{"buggy_code": ["//////////////////////////////////////////////////////////////////////////////////////\n//    akashi - a server for Attorney Online 2                                       //\n//    Copyright (C) 2020  scatterflower                                           //\n//                                                                                  //\n//    This program is free software: you can redistribute it and/or modify          //\n//    it under the terms of the GNU Affero General Public License as                //\n//    published by the Free Software Foundation, either version 3 of the            //\n//    License, or (at your option) any later version.                               //\n//                                                                                  //\n//    This program is distributed in the hope that it will be useful,               //\n//    but WITHOUT ANY WARRANTY{} without even the implied warranty of                //\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//    GNU Affero General Public License for more details.                           //\n//                                                                                  //\n//    You should have received a copy of the GNU Affero General Public License      //\n//    along with this program.  If not, see <https://www.gnu.org/licenses/>.        //\n//////////////////////////////////////////////////////////////////////////////////////\n#include \"include/aoclient.h\"\n\nvoid AOClient::pktDefault(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n#ifdef NET_DEBUG\n    qDebug() << \"Unimplemented packet:\" << packet.header << packet.contents;\n#endif\n}\n\nvoid AOClient::pktHardwareId(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    hwid = argv[0];\n    auto ban = server->db_manager->isHDIDBanned(hwid);\n    if (ban.first) {\n        sendPacket(\"BD\", {ban.second + \"\\nBan ID: \" + QString::number(server->db_manager->getBanID(hwid))});\n        socket->close();\n        return;\n    }\n    sendPacket(\"ID\", {QString::number(id), \"akashi\", QCoreApplication::applicationVersion()});\n}\n\nvoid AOClient::pktSoftwareId(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n\n\n    // Full feature list as of AO 2.8.5\n    // The only ones that are critical to ensuring the server works are\n    // \"noencryption\" and \"fastloading\"\n    QStringList feature_list = {\n        \"noencryption\", \"yellowtext\",         \"prezoom\",\n        \"flipping\",     \"customobjections\",   \"fastloading\",\n        \"deskmod\",      \"evidence\",           \"cccc_ic_support\",\n        \"arup\",         \"casing_alerts\",      \"modcall_reason\",\n        \"looping_sfx\",  \"additive\",           \"effects\",\n        \"y_offset\",     \"expanded_desk_mods\", \"auth_packet\"\n    };\n\n\n    version.string = argv[1];\n    QRegularExpression rx(\"\\\\b(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\b\"); // matches X.X.X (e.g. 2.9.0, 2.4.10, etc.)\n    QRegularExpressionMatch match = rx.match(version.string);\n    if (match.hasMatch()) {\n        version.release = match.captured(1).toInt();\n        version.major = match.captured(2).toInt();\n        version.minor = match.captured(3).toInt();\n    }\n\n    sendPacket(\"PN\", {QString::number(server->player_count), QString::number(ConfigManager::maxPlayers())});\n    sendPacket(\"FL\", feature_list);\n\n    if (ConfigManager::assetUrl().isValid()) {\n    QByteArray asset_url = ConfigManager::assetUrl().toEncoded(QUrl::EncodeSpaces);\n    sendPacket(\"ASS\", {asset_url});\n    }\n}\n\nvoid AOClient::pktBeginLoad(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Evidence isn't loaded during this part anymore\n    // As a result, we can always send \"0\" for evidence length\n    // Client only cares about what it gets from LE\n    sendPacket(\"SI\", {QString::number(server->characters.length()), \"0\", QString::number(server->area_names.length() + server->music_list.length())});\n}\n\nvoid AOClient::pktRequestChars(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    sendPacket(\"SC\", server->characters);\n}\n\nvoid AOClient::pktRequestMusic(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    sendPacket(\"SM\", server->area_names + server->music_list);\n}\n\nvoid AOClient::pktLoadingDone(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (hwid == \"\") {\n        // No early connecting!\n        socket->close();\n        return;\n    }\n\n    if (joined) {\n        return;\n    }\n\n    server->player_count++;\n    area->clientJoinedArea();\n    joined = true;\n    server->updateCharsTaken(area);\n\n    arup(ARUPType::PLAYER_COUNT, true); // Tell everyone there is a new player\n    sendEvidenceList(area);\n\n    sendPacket(\"HP\", {\"1\", QString::number(area->defHP())});\n    sendPacket(\"HP\", {\"2\", QString::number(area->proHP())});\n    sendPacket(\"FA\", server->area_names);\n    //Here lies OPPASS, the genius of FanatSors who send the modpass to everyone in plain text.\n    sendPacket(\"DONE\");\n    sendPacket(\"BN\", {area->background()});\n  \n    sendServerMessage(\"=== MOTD ===\\r\\n\" + ConfigManager::motd() + \"\\r\\n=============\");\n\n    fullArup(); // Give client all the area data\n    if (server->timer->isActive()) {\n        sendPacket(\"TI\", {\"0\", \"2\"});\n        sendPacket(\"TI\", {\"0\", \"0\", QString::number(QTime(0,0).msecsTo(QTime(0,0).addMSecs(server->timer->remainingTime())))});\n    }\n    else {\n        sendPacket(\"TI\", {\"0\", \"3\"});\n    }\n    for (QTimer* timer : area->timers()) {\n        int timer_id = area->timers().indexOf(timer) + 1;\n        if (timer->isActive()) {\n            sendPacket(\"TI\", {QString::number(timer_id), \"2\"});\n            sendPacket(\"TI\", {QString::number(timer_id), \"0\", QString::number(QTime(0,0).msecsTo(QTime(0,0).addMSecs(timer->remainingTime())))});\n        }\n        else {\n            sendPacket(\"TI\", {QString::number(timer_id), \"3\"});\n        }\n    }\n}\n\nvoid AOClient::pktCharPassword(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    password = argv[0];\n}\n\nvoid AOClient::pktSelectChar(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    bool argument_ok;\n    int selected_char_id = argv[1].toInt(&argument_ok);\n    if (!argument_ok) {\n        selected_char_id = -1;\n        return;\n    }\n\n    if (changeCharacter(selected_char_id))\n        char_id = selected_char_id;\n}\n\nvoid AOClient::pktIcChat(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_muted) {\n        sendServerMessage(\"You cannot speak while muted.\");\n        return;\n    }\n\n    if (!server->can_send_ic_messages) {\n        return;\n    }\n\n    AOPacket validated_packet = validateIcPacket(packet);\n    if (validated_packet.header == \"INVALID\")\n        return;\n\n    if (pos != \"\")\n        validated_packet.contents[5] = pos;\n\n    area->log(current_char, ipid, validated_packet);\n    server->broadcast(validated_packet, current_area);\n    area->updateLastICMessage(validated_packet.contents);\n\n    server->can_send_ic_messages = false;\n    server->next_message_timer.start(ConfigManager::messageFloodguard());\n}\n\nvoid AOClient::pktOocChat(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_ooc_muted) {\n        sendServerMessage(\"You are OOC muted, and cannot speak.\");\n        return;\n    }\n\n    ooc_name = dezalgo(argv[0]).replace(QRegExp(\"\\\\[|\\\\]|\\\\{|\\\\}|\\\\#|\\\\$|\\\\%|\\\\&\"), \"\"); // no fucky wucky shit here\n    if (ooc_name.isEmpty() || ooc_name == ConfigManager::serverName()) // impersonation & empty name protection\n        return;\n\n    if (ooc_name.length() > 30) {\n        sendServerMessage(\"Your name is too long! Please limit it to under 30 characters.\");\n        return;\n    }\n\n    if (is_logging_in) {\n        loginAttempt(argv[1]);\n        return;\n    }\n    \n    QString message = dezalgo(argv[1]);\n    if (message.length() == 0 || message.length() > ConfigManager::maxCharacters())\n        return;\n    AOPacket final_packet(\"CT\", {ooc_name, message, \"0\"});\n    if(message.at(0) == '/') {\n        QStringList cmd_argv = message.split(\" \", QString::SplitBehavior::SkipEmptyParts);\n        QString command = cmd_argv[0].trimmed().toLower();\n        command = command.right(command.length() - 1);\n        cmd_argv.removeFirst();\n        int cmd_argc = cmd_argv.length();\n\n        handleCommand(command, cmd_argc, cmd_argv);\n        area->logCmd(current_char, ipid, command, cmd_argv);\n        return;\n    }\n    else {\n        server->broadcast(final_packet, current_area);\n    }\n    area->log(current_char, ipid, final_packet);\n}\n\nvoid AOClient::pktPing(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Why does this packet exist\n    // At least Crystal made it useful\n    // It is now used for ping measurement\n    sendPacket(\"CHECK\");\n}\n\nvoid AOClient::pktChangeMusic(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Due to historical reasons, this\n    // packet has two functions:\n    // Change area, and set music.\n\n    // First, we check if the provided\n    // argument is a valid song\n    QString argument = argv[0];\n\n    for (QString song : server->music_list) {\n        if (song == argument || song == \"~stop.mp3\") { // ~stop.mp3 is a dummy track used by 2.9+\n            // We have a song here\n            if (is_dj_blocked) {\n                sendServerMessage(\"You are blocked from changing the music.\");\n                return;\n            }\n            if (!area->isMusicAllowed() && !checkAuth(ACLFlags.value(\"CM\"))) {\n                sendServerMessage(\"Music is disabled in this area.\");\n                return;\n            }\n            QString effects;\n            if (argc >= 4)\n                effects = argv[3];\n            else\n                effects = \"0\";\n            QString final_song;\n            if (!argument.contains(\".\"))\n                final_song = \"~stop.mp3\";\n            else\n                final_song = argument;\n            AOPacket music_change(\"MC\", {final_song, argv[1], showname, \"1\", \"0\", effects});\n            area->currentMusic() = final_song;\n            area->musicPlayerBy() = showname;\n            server->broadcast(music_change, current_area);\n            return;\n        }\n    }\n\n    for (int i = 0; i < server->area_names.length(); i++) {\n        QString area = server->area_names[i];\n        if(area == argument) {\n            changeArea(i);\n            break;\n        }\n    }\n}\n\nvoid AOClient::pktWtCe(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_wtce_blocked) {\n        sendServerMessage(\"You are blocked from using the judge controls.\");\n        return;\n    }\n    if (QDateTime::currentDateTime().toSecsSinceEpoch() - last_wtce_time <= 5)\n        return;\n    last_wtce_time = QDateTime::currentDateTime().toSecsSinceEpoch();\n    server->broadcast(packet, current_area);\n    updateJudgeLog(area, this, \"WT/CE\");\n}\n\nvoid AOClient::pktHpBar(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_wtce_blocked) {\n        sendServerMessage(\"You are blocked from using the judge controls.\");\n        return;\n    }\n    int l_newValue = argv.at(1).toInt();\n\n    if (argv[0] == \"1\") {\n        area->changeHP(AreaData::Side::DEFENCE, l_newValue);\n    }\n    else if (argv[0] == \"2\") {\n        area->changeHP(AreaData::Side::PROSECUTOR, l_newValue);\n    }\n\n    server->broadcast(AOPacket(\"HP\", {\"1\", QString::number(area->defHP())}), area->index());\n    server->broadcast(AOPacket(\"HP\", {\"2\", QString::number(area->proHP())}), area->index());\n\n    updateJudgeLog(area, this, \"updated the penalties\");\n}\n\nvoid AOClient::pktWebSocketIp(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Special packet to set remote IP from the webao proxy\n    // Only valid if from a local ip\n    if (remote_ip.isLoopback()) {\n#ifdef NET_DEBUG\n        qDebug() << \"ws ip set to\" << argv[0];\n#endif\n        remote_ip = QHostAddress(argv[0]);\n        calculateIpid();\n        auto ban = server->db_manager->isIPBanned(ipid);\n        if (ban.first) {\n            sendPacket(\"BD\", {ban.second});\n            socket->close();\n            return;\n        }\n\n        int multiclient_count = 0;\n        for (AOClient* joined_client : server->clients) {\n            if (remote_ip.isEqual(joined_client->remote_ip))\n                multiclient_count++;\n        }\n\n        if (multiclient_count > ConfigManager::multiClientLimit()) {\n            socket->close();\n            return;\n        }\n    }\n}\n\nvoid AOClient::pktModCall(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    for (AOClient* client : server->clients) {\n        if (client->authenticated)\n            client->sendPacket(packet);\n    }\n    area->log(current_char, ipid, packet);\n\n    if (ConfigManager::discordWebhookEnabled()) {\n        QString name = ooc_name;\n        if (ooc_name.isEmpty())\n            name = current_char;\n\n        emit server->modcallWebhookRequest(name, server->areas[current_area]->name(), packet.contents[0], area->buffer());\n    }\n    \n    area->flushLogs();\n}\n\nvoid AOClient::pktAddEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    AreaData::Evidence evi = {argv[0], argv[1], argv[2]};\n    area->appendEvidence(evi);\n    sendEvidenceList(area);\n}\n\nvoid AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}\n\nvoid AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}\n\nvoid AOClient::pktSetCase(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    QList<bool> prefs_list;\n    for (int i = 2; i <=6; i++) {\n        bool is_int = false;\n        bool pref = argv[i].toInt(&is_int);\n        if (!is_int)\n            return;\n        prefs_list.append(pref);\n    }\n    casing_preferences = prefs_list;\n}\n\nvoid AOClient::pktAnnounceCase(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    QString case_title = argv[0];\n    QStringList needed_roles;\n    QList<bool> needs_list;\n    for (int i = 1; i <=5; i++) {\n        bool is_int = false;\n        bool need = argv[i].toInt(&is_int);\n        if (!is_int)\n            return;\n        needs_list.append(need);\n    }\n    QStringList roles = {\"defense attorney\", \"prosecutor\", \"judge\", \"jurors\", \"stenographer\"};\n    for (int i = 0; i < 5; i++) {\n      if (needs_list[i])\n        needed_roles.append(roles[i]);\n    }\n    if (needed_roles.isEmpty())\n        return;\n\n    QString message = \"=== Case Announcement ===\\r\\n\" + (ooc_name == \"\" ? current_char : ooc_name) + \" needs \" + needed_roles.join(\", \") + \" for \" + (case_title == \"\" ? \"a case\" : case_title) + \"!\";\n\n    QList<AOClient*> clients_to_alert;\n    // here lies morton, RIP\n    QSet<bool> needs_set = needs_list.toSet();\n    for (AOClient* client : server->clients) {\n        QSet<bool> matches = client->casing_preferences.toSet().intersect(needs_set);\n        if (!matches.isEmpty() && !clients_to_alert.contains(client))\n            clients_to_alert.append(client);\n    }\n\n    for (AOClient* client : clients_to_alert) {\n        client->sendPacket(AOPacket(\"CASEA\", {message, argv[1], argv[2], argv[3], argv[4], argv[5], \"1\"}));\n        // you may be thinking, \"hey wait a minute the network protocol documentation doesn't mention that last argument!\"\n        // if you are in fact thinking that, you are correct! it is not in the documentation!\n        // however for some inscrutable reason Attorney Online 2 will outright reject a CASEA packet that does not have\n        // at least 7 arguments despite only using the first 6. Cera, i kneel. you have truly broken me.\n    }\n}\n\nvoid AOClient::sendEvidenceList(AreaData* area)\n{\n    for (AOClient* client : server->clients) {\n        if (client->current_area == current_area)\n            client->updateEvidenceList(area);\n    }\n}\n\nvoid AOClient::updateEvidenceList(AreaData* area)\n{\n    QStringList evidence_list;\n    QString evidence_format(\"%1&%2&%3\");\n\n    for (AreaData::Evidence evidence : area->evidence()) {\n        if (!checkAuth(ACLFlags.value(\"CM\")) && area->eviMod() == AreaData::EvidenceMod::HIDDEN_CM) {\n            QRegularExpression regex(\"<owner=(.*?)>\");\n            QRegularExpressionMatch match = regex.match(evidence.description);\n            if (match.hasMatch()) {\n                QStringList owners = match.captured(1).split(\",\");\n                if (!owners.contains(\"all\", Qt::CaseSensitivity::CaseInsensitive) && !owners.contains(pos, Qt::CaseSensitivity::CaseInsensitive)) {\n                    continue;\n                }\n            }\n            // no match = show it to all\n        }\n        evidence_list.append(evidence_format\n            .arg(evidence.name)\n            .arg(evidence.description)\n            .arg(evidence.image));\n    }\n\n    sendPacket(AOPacket(\"LE\", evidence_list));\n}\n\nAOPacket AOClient::validateIcPacket(AOPacket packet)\n{\n    // Welcome to the super cursed server-side IC chat validation hell\n\n    // I wanted to use enums or #defines here to make the\n    // indicies of the args arrays more readable. But,\n    // in typical AO fasion, the indicies for the incoming\n    // and outgoing packets are different. Just RTFM.\n\n    AOPacket invalid(\"INVALID\", {});\n    QStringList args;\n    if (current_char == \"\" || !joined)\n        // Spectators cannot use IC\n        return invalid;\n    AreaData* area = server->areas[current_area];\n    if (area->lockStatus() == AreaData::LockStatus::SPECTATABLE && !area->invited().contains(id) && !checkAuth(ACLFlags.value(\"BYPASS_LOCKS\")))\n        // Non-invited players cannot speak in spectatable areas\n        return invalid;\n\n    QList<QVariant> incoming_args;\n    for (QString arg : packet.contents) {\n        incoming_args.append(QVariant(arg));\n    }\n\n    // desk modifier\n    QStringList allowed_desk_mods;\n    allowed_desk_mods << \"chat\" << \"0\" << \"1\" << \"2\" << \"3\" << \"4\" << \"5\";\n    if (allowed_desk_mods.contains(incoming_args[0].toString())) {\n        args.append(incoming_args[0].toString());\n    }\n    else\n        return invalid;\n\n    // preanim\n    args.append(incoming_args[1].toString());\n\n    // char name\n    if (current_char.toLower() != incoming_args[2].toString().toLower()) {\n        // Selected char is different from supplied folder name\n        // This means the user is INI-swapped\n        if (!area->iniswapAllowed()) {\n            if (!server->characters.contains(incoming_args[2].toString(), Qt::CaseInsensitive))\n                return invalid;\n        }\n        qDebug() << \"INI swap detected from \" << getIpid();\n    }\n    current_iniswap = incoming_args[2].toString();\n    args.append(incoming_args[2].toString());\n\n    // emote\n    emote = incoming_args[3].toString();\n    if (first_person)\n        emote = \"\";\n    args.append(emote);\n\n    // message text\n    if (incoming_args[4].toString().size() > ConfigManager::maxCharacters())\n        return invalid;\n\n    QString incoming_msg = dezalgo(incoming_args[4].toString().trimmed());\n    if (!area->lastICMessage().isEmpty()\n            && incoming_msg == area->lastICMessage()[4]\n            && incoming_msg != \"\")\n        return invalid;\n\n    if (incoming_msg == \"\" && area->blankpostingAllowed() == false) {\n        sendServerMessage(\"Blankposting has been forbidden in this area.\");\n        return invalid;\n    }\n\n    if (is_gimped) {\n        QString gimp_message = ConfigManager::gimpList()[(genRand(1, ConfigManager::gimpList().size() - 1))];\n        incoming_msg = gimp_message;\n    }\n\n    if (is_shaken) {\n        QStringList parts = incoming_msg.split(\" \");\n        std::random_shuffle(parts.begin(), parts.end());\n        incoming_msg = parts.join(\" \");\n    }\n\n    if (is_disemvoweled) {\n        QString disemvoweled_message = incoming_msg.remove(QRegExp(\"[AEIOUaeiou]\"));\n        incoming_msg = disemvoweled_message;\n    }\n\n    last_message = incoming_msg;\n    args.append(incoming_msg);\n\n    // side\n    // this is validated clientside so w/e\n    args.append(incoming_args[5].toString());\n    if (pos != incoming_args[5].toString()) {\n        pos = incoming_args[5].toString();\n        updateEvidenceList(server->areas[current_area]);\n    }\n\n    // sfx name\n    args.append(incoming_args[6].toString());\n\n    // emote modifier\n    // Now, gather round, y'all. Here is a story that is truly a microcosm of the AO dev experience.\n    // If this value is a 4, it will crash the client. Why? Who knows, but it does.\n    // Now here is the kicker: in certain versions, the client would incorrectly send a 4 here\n    // For a long time, by configuring the client to do a zoom with a preanim, it would send 4\n    // This would crash everyone else's client, and the feature had to be disabled\n    // But, for some reason, nobody traced the cause of this issue for many many years.\n    // The serverside fix is needed to ensure invalid values are not sent, because the client sucks\n    int emote_mod = incoming_args[7].toInt();\n\n    if (emote_mod == 4)\n        emote_mod = 6;\n    if (emote_mod != 0 && emote_mod != 1 && emote_mod != 2 && emote_mod != 5 && emote_mod != 6)\n        return invalid;\n    args.append(QString::number(emote_mod));\n\n    // char id\n    if (incoming_args[8].toInt() != char_id)\n        return invalid;\n    args.append(incoming_args[8].toString());\n\n    // sfx delay\n    args.append(incoming_args[9].toString());\n\n    // objection modifier\n    if (incoming_args[10].toString().contains(\"4\")) {\n        // custom shout includes text metadata\n        args.append(incoming_args[10].toString());\n    }\n    else {\n        int obj_mod = incoming_args[10].toInt();\n        if (obj_mod != 0 && obj_mod != 1 && obj_mod != 2 && obj_mod != 3)\n            return invalid;\n        args.append(QString::number(obj_mod));\n    }\n\n    // evidence\n    int evi_idx = incoming_args[11].toInt();\n    if (evi_idx > area->evidence().length())\n        return invalid;\n    args.append(QString::number(evi_idx));\n\n    // flipping\n    int flip = incoming_args[12].toInt();\n    if (flip != 0 && flip != 1)\n        return invalid;\n    flipping = QString::number(flip);\n    args.append(flipping);\n\n    // realization\n    int realization = incoming_args[13].toInt();\n    if (realization != 0 && realization != 1)\n        return invalid;\n    args.append(QString::number(realization));\n\n    // text color\n    int text_color = incoming_args[14].toInt();\n    if (text_color < 0 || text_color > 11)\n        return invalid;\n    args.append(QString::number(text_color));\n\n    // 2.6 packet extensions\n    if (incoming_args.length() > 15) {\n        // showname\n        QString incoming_showname = dezalgo(incoming_args[15].toString().trimmed());\n        if (!(incoming_showname == current_char || incoming_showname.isEmpty()) && !area->shownameAllowed()) {\n            sendServerMessage(\"Shownames are not allowed in this area!\");\n            return invalid;\n        }\n        if (incoming_showname.length() > 30) {\n            sendServerMessage(\"Your showname is too long! Please limit it to under 30 characters\");\n            return invalid;\n        }\n\n        // if the raw input is not empty but the trimmed input is, use a single space\n        if (incoming_showname.isEmpty() && !incoming_args[15].toString().isEmpty())\n            incoming_showname = \" \";\n        args.append(incoming_showname);\n        showname = incoming_showname;\n\n        // other char id\n        // things get a bit hairy here\n        // don't ask me how this works, because i don't know either\n        QStringList pair_data = incoming_args[16].toString().split(\"^\");\n        pairing_with = pair_data[0].toInt();\n        QString front_back = \"\";\n        if (pair_data.length() > 1)\n            front_back = \"^\" + pair_data[1];\n        int other_charid = pairing_with;\n        bool pairing = false;\n        QString other_name = \"0\";\n        QString other_emote = \"0\";\n        QString other_offset = \"0\";\n        QString other_flip = \"0\";\n        for (AOClient* client : server->clients) {\n            if (client->pairing_with == char_id\n                    && other_charid != char_id\n                    && client->char_id == pairing_with\n                    && client->pos == pos) {\n                other_name = client->current_iniswap;\n                other_emote = client->emote;\n                other_offset = client->offset;\n                other_flip = client->flipping;\n                pairing = true;\n            }\n        }\n        if (!pairing) {\n            other_charid = -1;\n            front_back = \"\";\n        }\n        args.append(QString::number(other_charid) + front_back);\n        args.append(other_name);\n        args.append(other_emote);\n\n        // self offset\n        offset = incoming_args[17].toString();\n        // versions 2.6-2.8 cannot validate y-offset so we send them just the x-offset\n        if ((version.release == 2) && (version.major == 6 || version.major == 7 || version.major == 8)) {\n            QString x_offset = offset.split(\"&\")[0];\n            args.append(x_offset);\n            QString other_x_offset = other_offset.split(\"&\")[0];\n            args.append(other_x_offset);\n        }\n        else {\n            args.append(offset);\n            args.append(other_offset);\n        }\n        args.append(other_flip);\n\n        // immediate text processing\n        int immediate = incoming_args[18].toInt();\n        if (area->forceImmediate()) {\n            if (args[7] == \"1\" || args[7] == \"2\") {\n                args[7] = \"0\";\n                immediate = 1;\n            }\n            else if (args[7] == \"6\") {\n                args[7] = \"5\";\n                immediate = 1;\n            }\n        }\n        if (immediate != 1 && immediate != 0)\n            return invalid;\n        args.append(QString::number(immediate));\n    }\n\n    // 2.8 packet extensions\n    if (incoming_args.length() > 19) {\n        // sfx looping\n        int sfx_loop = incoming_args[19].toInt();\n        if (sfx_loop != 0 && sfx_loop != 1)\n            return invalid;\n        args.append(QString::number(sfx_loop));\n\n        // screenshake\n        int screenshake = incoming_args[20].toInt();\n        if (screenshake != 0 && screenshake != 1)\n            return invalid;\n        args.append(QString::number(screenshake));\n\n        // frames shake\n        args.append(incoming_args[21].toString());\n\n        // frames realization\n        args.append(incoming_args[22].toString());\n\n        // frames sfx\n        args.append(incoming_args[23].toString());\n\n        // additive\n        int additive = incoming_args[24].toInt();\n        if (additive != 0 && additive != 1)\n            return invalid;\n        else if (area->lastICMessage().isEmpty()){\n            additive = 0;\n        }\n        else if (!(char_id == area->lastICMessage()[8].toInt())) {\n            additive = 0;\n        }\n        else if (additive == 1) {\n            args[4].insert(0, \" \");\n        }\n        args.append(QString::number(additive));\n\n        // effect\n        args.append(incoming_args[25].toString());\n    }\n\n    //Testimony playback\n    if (area->testimonyRecording() == AreaData::TestimonyRecording::RECORDING || area->testimonyRecording() == AreaData::TestimonyRecording::ADD) {\n        if (args[5] != \"wit\")\n            return AOPacket(\"MS\", args);\n\n        if (area->statement() == -1) {\n            args[4] = \"~~\\\\n-- \" + args[4] + \" --\";\n            args[14] = \"3\";\n            server->broadcast(AOPacket(\"RT\",{\"testimony1\"}), current_area);\n        }\n        addStatement(args);\n    }\n    else if (area->testimonyRecording() == AreaData::TestimonyRecording::UPDATE) {\n        args = updateStatement(args);\n    }\n    else if (area->testimonyRecording() == AreaData::TestimonyRecording::PLAYBACK) {\n        AreaData::TestimonyProgress l_progress;\n\n        if (args[4] == \">\") {\n            pos = \"wit\";\n            auto l_statement = area->jumpToStatement(area->statement() +1);\n            args = l_statement.first;\n            l_progress = l_statement.second;\n\n            if (l_progress == AreaData::TestimonyProgress::LOOPED) {\n                sendServerMessageArea(\"Last statement reached. Looping to first statement.\");\n            }\n        }\n        if (args[4] == \"<\") {\n            pos = \"wit\";\n            auto l_statement = area->jumpToStatement(area->statement() - 1);\n            args = l_statement.first;\n            l_progress = l_statement.second;\n\n            if (l_progress == AreaData::TestimonyProgress::STAYED_AT_FIRST) {\n                sendServerMessage(\"First statement reached.\");\n            }\n        }\n\n        QString decoded_message = decodeMessage(args[4]); //Get rid of that pesky encoding first.\n        QRegularExpression jump(\"(?<arrow>>)(?<int>[0,1,2,3,4,5,6,7,8,9]+)\");\n        QRegularExpressionMatch match = jump.match(decoded_message);\n        if (match.hasMatch()) {\n            pos = \"wit\";\n            auto l_statement = area->jumpToStatement(match.captured(\"int\").toInt());\n            args = l_statement.first;\n            l_progress = l_statement.second;\n\n\n            switch (l_progress){\n            case AreaData::TestimonyProgress::LOOPED:\n            {\n                sendServerMessageArea(\"Last statement reached. Looping to first statement.\");\n            }\n            case AreaData::TestimonyProgress::STAYED_AT_FIRST:\n            {\n                sendServerMessage(\"First statement reached.\");\n            }\n            case AreaData::TestimonyProgress::OK:\n            default:\n                // No need to handle.\n                break;\n            }\n        }\n    }\n\n    return AOPacket(\"MS\", args);\n}\n\nQString AOClient::dezalgo(QString p_text)\n{\n    QRegularExpression rxp(\"([\u0300\u0301\u0302\u0303\u0304\u0305\u0306\u0307\u0308\u0309\u030a\u030b\u030c\u030d\u030e\u030f\u0310\u0311\u0312\u0313\u0314\u0315\u0316\u0317\u0318\u0319\u031a\u031b\u031c\u031d\u031e\u031f\u0320\u0321\u0322\u0323\u0324\u0325\u0326\u0327\u0328\u0329\u032a\u032b\u032c\u032d\u032e\u032f\u0330\u0331\u0332\u0333\u0334\u0335\u0336\u0337\u0338\u0339\u033a\u033b\u033c\u033d\u033e\u033f\u0300\u0301\u0342\u0313\u0308\u0301\u0345\u0346\u0347\u0348\u0349\u034a\u034b\u034c\u034d\u034e\u034f\u0350\u0351\u0352\u0353\u0354\u0355\u0356\u0357\u0358\u0359\u035a\u035b\u035c\u035d\u035e\u035f\u0360\u0361\u0362\u0363\u0364\u0365\u0366\u0367\u0368\u0369\u036a\u036b\u036c\u036d\u036e\u036f])\");\n    QString filtered = p_text.replace(rxp, \"\");\n    return filtered;\n}\n\nbool AOClient::checkEvidenceAccess(AreaData *area)\n{\n    switch(area->eviMod()) {\n    case AreaData::EvidenceMod::FFA:\n        return true;\n    case AreaData::EvidenceMod::CM:\n    case AreaData::EvidenceMod::HIDDEN_CM:\n        return checkAuth(ACLFlags.value(\"CM\"));\n    case AreaData::EvidenceMod::MOD:\n        return authenticated;\n    default:\n        return false;\n    }\n}\n\nvoid AOClient::updateJudgeLog(AreaData* area, AOClient* client, QString action)\n{\n    QString timestamp = QTime::currentTime().toString(\"hh:mm:ss\");\n    QString uid = QString::number(client->id);\n    QString char_name = client->current_char;\n    QString ipid = client->getIpid();\n    QString message = action;\n    QString logmessage = QString(\"[%1]: [%2] %3 (%4) %5\").arg(timestamp, uid, char_name, ipid, message);\n    area->appendJudgelog(logmessage);\n}\n\nQString AOClient::decodeMessage(QString incoming_message)\n{\n   QString decoded_message = incoming_message.replace(\"<num>\", \"#\")\n                                             .replace(\"<percent>\", \"%\")\n                                             .replace(\"<dollar>\", \"$\")\n                                             .replace(\"<and>\", \"&\");\n    return decoded_message;\n}\n\nvoid AOClient::loginAttempt(QString message)\n{\n    switch (ConfigManager::authType()) {\n    case DataTypes::AuthType::SIMPLE:\n        if (message == ConfigManager::modpass()) {\n            sendPacket(\"AUTH\", {\"1\"}); // Client: \"You were granted the Disable Modcalls button.\"\n            sendServerMessage(\"Logged in as a moderator.\"); // pre-2.9.1 clients are hardcoded to display the mod UI when this string is sent in OOC\n            authenticated = true;\n        }\n        else {\n            sendPacket(\"AUTH\", {\"0\"}); // Client: \"Login unsuccessful.\"\n            sendServerMessage(\"Incorrect password.\");\n        }\n        server->areas.value(current_area)->logLogin(current_char, ipid, authenticated, \"moderator\");\n        break;\n    case DataTypes::AuthType::ADVANCED:\n        QStringList login = message.split(\" \");\n        if (login.size() < 2) {\n            sendServerMessage(\"You must specify a username and a password\");\n            sendServerMessage(\"Exiting login prompt.\");\n            is_logging_in = false;\n            return;\n        }\n        QString username = login[0];\n        QString password = login[1];\n        if (server->db_manager->authenticate(username, password)) {\n            moderator_name = username;\n            authenticated = true;\n            sendPacket(\"AUTH\", {\"1\"}); // Client: \"You were granted the Disable Modcalls button.\"\n            if (version.release <= 2 && version.major <= 9 && version.minor <= 0)\n                sendServerMessage(\"Logged in as a moderator.\"); // pre-2.9.1 clients are hardcoded to display the mod UI when this string is sent in OOC\n            sendServerMessage(\"Welcome, \" + username);\n        }\n        else {\n            sendPacket(\"AUTH\", {\"0\"}); // Client: \"Login unsuccessful.\"\n            sendServerMessage(\"Incorrect password.\");\n        }\n        server->areas.value(current_area)->logLogin(current_char, ipid, authenticated, username);\n        break;\n    }\n    sendServerMessage(\"Exiting login prompt.\");\n    is_logging_in = false;\n    return;\n}\n\n"], "fixing_code": ["//////////////////////////////////////////////////////////////////////////////////////\n//    akashi - a server for Attorney Online 2                                       //\n//    Copyright (C) 2020  scatterflower                                           //\n//                                                                                  //\n//    This program is free software: you can redistribute it and/or modify          //\n//    it under the terms of the GNU Affero General Public License as                //\n//    published by the Free Software Foundation, either version 3 of the            //\n//    License, or (at your option) any later version.                               //\n//                                                                                  //\n//    This program is distributed in the hope that it will be useful,               //\n//    but WITHOUT ANY WARRANTY{} without even the implied warranty of                //\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//    GNU Affero General Public License for more details.                           //\n//                                                                                  //\n//    You should have received a copy of the GNU Affero General Public License      //\n//    along with this program.  If not, see <https://www.gnu.org/licenses/>.        //\n//////////////////////////////////////////////////////////////////////////////////////\n#include \"include/aoclient.h\"\n\nvoid AOClient::pktDefault(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n#ifdef NET_DEBUG\n    qDebug() << \"Unimplemented packet:\" << packet.header << packet.contents;\n#endif\n}\n\nvoid AOClient::pktHardwareId(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    hwid = argv[0];\n    auto ban = server->db_manager->isHDIDBanned(hwid);\n    if (ban.first) {\n        sendPacket(\"BD\", {ban.second + \"\\nBan ID: \" + QString::number(server->db_manager->getBanID(hwid))});\n        socket->close();\n        return;\n    }\n    sendPacket(\"ID\", {QString::number(id), \"akashi\", QCoreApplication::applicationVersion()});\n}\n\nvoid AOClient::pktSoftwareId(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n\n\n    // Full feature list as of AO 2.8.5\n    // The only ones that are critical to ensuring the server works are\n    // \"noencryption\" and \"fastloading\"\n    QStringList feature_list = {\n        \"noencryption\", \"yellowtext\",         \"prezoom\",\n        \"flipping\",     \"customobjections\",   \"fastloading\",\n        \"deskmod\",      \"evidence\",           \"cccc_ic_support\",\n        \"arup\",         \"casing_alerts\",      \"modcall_reason\",\n        \"looping_sfx\",  \"additive\",           \"effects\",\n        \"y_offset\",     \"expanded_desk_mods\", \"auth_packet\"\n    };\n\n\n    version.string = argv[1];\n    QRegularExpression rx(\"\\\\b(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\b\"); // matches X.X.X (e.g. 2.9.0, 2.4.10, etc.)\n    QRegularExpressionMatch match = rx.match(version.string);\n    if (match.hasMatch()) {\n        version.release = match.captured(1).toInt();\n        version.major = match.captured(2).toInt();\n        version.minor = match.captured(3).toInt();\n    }\n\n    sendPacket(\"PN\", {QString::number(server->player_count), QString::number(ConfigManager::maxPlayers())});\n    sendPacket(\"FL\", feature_list);\n\n    if (ConfigManager::assetUrl().isValid()) {\n    QByteArray asset_url = ConfigManager::assetUrl().toEncoded(QUrl::EncodeSpaces);\n    sendPacket(\"ASS\", {asset_url});\n    }\n}\n\nvoid AOClient::pktBeginLoad(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Evidence isn't loaded during this part anymore\n    // As a result, we can always send \"0\" for evidence length\n    // Client only cares about what it gets from LE\n    sendPacket(\"SI\", {QString::number(server->characters.length()), \"0\", QString::number(server->area_names.length() + server->music_list.length())});\n}\n\nvoid AOClient::pktRequestChars(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    sendPacket(\"SC\", server->characters);\n}\n\nvoid AOClient::pktRequestMusic(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    sendPacket(\"SM\", server->area_names + server->music_list);\n}\n\nvoid AOClient::pktLoadingDone(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (hwid == \"\") {\n        // No early connecting!\n        socket->close();\n        return;\n    }\n\n    if (joined) {\n        return;\n    }\n\n    server->player_count++;\n    area->clientJoinedArea();\n    joined = true;\n    server->updateCharsTaken(area);\n\n    arup(ARUPType::PLAYER_COUNT, true); // Tell everyone there is a new player\n    sendEvidenceList(area);\n\n    sendPacket(\"HP\", {\"1\", QString::number(area->defHP())});\n    sendPacket(\"HP\", {\"2\", QString::number(area->proHP())});\n    sendPacket(\"FA\", server->area_names);\n    //Here lies OPPASS, the genius of FanatSors who send the modpass to everyone in plain text.\n    sendPacket(\"DONE\");\n    sendPacket(\"BN\", {area->background()});\n  \n    sendServerMessage(\"=== MOTD ===\\r\\n\" + ConfigManager::motd() + \"\\r\\n=============\");\n\n    fullArup(); // Give client all the area data\n    if (server->timer->isActive()) {\n        sendPacket(\"TI\", {\"0\", \"2\"});\n        sendPacket(\"TI\", {\"0\", \"0\", QString::number(QTime(0,0).msecsTo(QTime(0,0).addMSecs(server->timer->remainingTime())))});\n    }\n    else {\n        sendPacket(\"TI\", {\"0\", \"3\"});\n    }\n    for (QTimer* timer : area->timers()) {\n        int timer_id = area->timers().indexOf(timer) + 1;\n        if (timer->isActive()) {\n            sendPacket(\"TI\", {QString::number(timer_id), \"2\"});\n            sendPacket(\"TI\", {QString::number(timer_id), \"0\", QString::number(QTime(0,0).msecsTo(QTime(0,0).addMSecs(timer->remainingTime())))});\n        }\n        else {\n            sendPacket(\"TI\", {QString::number(timer_id), \"3\"});\n        }\n    }\n}\n\nvoid AOClient::pktCharPassword(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    password = argv[0];\n}\n\nvoid AOClient::pktSelectChar(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    bool argument_ok;\n    int selected_char_id = argv[1].toInt(&argument_ok);\n    if (!argument_ok) {\n        selected_char_id = -1;\n        return;\n    }\n\n    if (changeCharacter(selected_char_id))\n        char_id = selected_char_id;\n}\n\nvoid AOClient::pktIcChat(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_muted) {\n        sendServerMessage(\"You cannot speak while muted.\");\n        return;\n    }\n\n    if (!server->can_send_ic_messages) {\n        return;\n    }\n\n    AOPacket validated_packet = validateIcPacket(packet);\n    if (validated_packet.header == \"INVALID\")\n        return;\n\n    if (pos != \"\")\n        validated_packet.contents[5] = pos;\n\n    area->log(current_char, ipid, validated_packet);\n    server->broadcast(validated_packet, current_area);\n    area->updateLastICMessage(validated_packet.contents);\n\n    server->can_send_ic_messages = false;\n    server->next_message_timer.start(ConfigManager::messageFloodguard());\n}\n\nvoid AOClient::pktOocChat(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_ooc_muted) {\n        sendServerMessage(\"You are OOC muted, and cannot speak.\");\n        return;\n    }\n\n    ooc_name = dezalgo(argv[0]).replace(QRegExp(\"\\\\[|\\\\]|\\\\{|\\\\}|\\\\#|\\\\$|\\\\%|\\\\&\"), \"\"); // no fucky wucky shit here\n    if (ooc_name.isEmpty() || ooc_name == ConfigManager::serverName()) // impersonation & empty name protection\n        return;\n\n    if (ooc_name.length() > 30) {\n        sendServerMessage(\"Your name is too long! Please limit it to under 30 characters.\");\n        return;\n    }\n\n    if (is_logging_in) {\n        loginAttempt(argv[1]);\n        return;\n    }\n    \n    QString message = dezalgo(argv[1]);\n    if (message.length() == 0 || message.length() > ConfigManager::maxCharacters())\n        return;\n    AOPacket final_packet(\"CT\", {ooc_name, message, \"0\"});\n    if(message.at(0) == '/') {\n        QStringList cmd_argv = message.split(\" \", QString::SplitBehavior::SkipEmptyParts);\n        QString command = cmd_argv[0].trimmed().toLower();\n        command = command.right(command.length() - 1);\n        cmd_argv.removeFirst();\n        int cmd_argc = cmd_argv.length();\n\n        handleCommand(command, cmd_argc, cmd_argv);\n        area->logCmd(current_char, ipid, command, cmd_argv);\n        return;\n    }\n    else {\n        server->broadcast(final_packet, current_area);\n    }\n    area->log(current_char, ipid, final_packet);\n}\n\nvoid AOClient::pktPing(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Why does this packet exist\n    // At least Crystal made it useful\n    // It is now used for ping measurement\n    sendPacket(\"CHECK\");\n}\n\nvoid AOClient::pktChangeMusic(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Due to historical reasons, this\n    // packet has two functions:\n    // Change area, and set music.\n\n    // First, we check if the provided\n    // argument is a valid song\n    QString argument = argv[0];\n\n    for (QString song : server->music_list) {\n        if (song == argument || song == \"~stop.mp3\") { // ~stop.mp3 is a dummy track used by 2.9+\n            // We have a song here\n            if (is_dj_blocked) {\n                sendServerMessage(\"You are blocked from changing the music.\");\n                return;\n            }\n            if (!area->isMusicAllowed() && !checkAuth(ACLFlags.value(\"CM\"))) {\n                sendServerMessage(\"Music is disabled in this area.\");\n                return;\n            }\n            QString effects;\n            if (argc >= 4)\n                effects = argv[3];\n            else\n                effects = \"0\";\n            QString final_song;\n            if (!argument.contains(\".\"))\n                final_song = \"~stop.mp3\";\n            else\n                final_song = argument;\n            AOPacket music_change(\"MC\", {final_song, argv[1], showname, \"1\", \"0\", effects});\n            area->currentMusic() = final_song;\n            area->musicPlayerBy() = showname;\n            server->broadcast(music_change, current_area);\n            return;\n        }\n    }\n\n    for (int i = 0; i < server->area_names.length(); i++) {\n        QString area = server->area_names[i];\n        if(area == argument) {\n            changeArea(i);\n            break;\n        }\n    }\n}\n\nvoid AOClient::pktWtCe(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_wtce_blocked) {\n        sendServerMessage(\"You are blocked from using the judge controls.\");\n        return;\n    }\n    if (QDateTime::currentDateTime().toSecsSinceEpoch() - last_wtce_time <= 5)\n        return;\n    last_wtce_time = QDateTime::currentDateTime().toSecsSinceEpoch();\n    server->broadcast(packet, current_area);\n    updateJudgeLog(area, this, \"WT/CE\");\n}\n\nvoid AOClient::pktHpBar(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (is_wtce_blocked) {\n        sendServerMessage(\"You are blocked from using the judge controls.\");\n        return;\n    }\n    int l_newValue = argv.at(1).toInt();\n\n    if (argv[0] == \"1\") {\n        area->changeHP(AreaData::Side::DEFENCE, l_newValue);\n    }\n    else if (argv[0] == \"2\") {\n        area->changeHP(AreaData::Side::PROSECUTOR, l_newValue);\n    }\n\n    server->broadcast(AOPacket(\"HP\", {\"1\", QString::number(area->defHP())}), area->index());\n    server->broadcast(AOPacket(\"HP\", {\"2\", QString::number(area->proHP())}), area->index());\n\n    updateJudgeLog(area, this, \"updated the penalties\");\n}\n\nvoid AOClient::pktWebSocketIp(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    // Special packet to set remote IP from the webao proxy\n    // Only valid if from a local ip\n    if (remote_ip.isLoopback()) {\n#ifdef NET_DEBUG\n        qDebug() << \"ws ip set to\" << argv[0];\n#endif\n        remote_ip = QHostAddress(argv[0]);\n        calculateIpid();\n        auto ban = server->db_manager->isIPBanned(ipid);\n        if (ban.first) {\n            sendPacket(\"BD\", {ban.second});\n            socket->close();\n            return;\n        }\n\n        int multiclient_count = 0;\n        for (AOClient* joined_client : server->clients) {\n            if (remote_ip.isEqual(joined_client->remote_ip))\n                multiclient_count++;\n        }\n\n        if (multiclient_count > ConfigManager::multiClientLimit()) {\n            socket->close();\n            return;\n        }\n    }\n}\n\nvoid AOClient::pktModCall(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    for (AOClient* client : server->clients) {\n        if (client->authenticated)\n            client->sendPacket(packet);\n    }\n    area->log(current_char, ipid, packet);\n\n    if (ConfigManager::discordWebhookEnabled()) {\n        QString name = ooc_name;\n        if (ooc_name.isEmpty())\n            name = current_char;\n\n        emit server->modcallWebhookRequest(name, server->areas[current_area]->name(), packet.contents[0], area->buffer());\n    }\n    \n    area->flushLogs();\n}\n\nvoid AOClient::pktAddEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    AreaData::Evidence evi = {argv[0], argv[1], argv[2]};\n    area->appendEvidence(evi);\n    sendEvidenceList(area);\n}\n\nvoid AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}\n\nvoid AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}\n\nvoid AOClient::pktSetCase(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    QList<bool> prefs_list;\n    for (int i = 2; i <=6; i++) {\n        bool is_int = false;\n        bool pref = argv[i].toInt(&is_int);\n        if (!is_int)\n            return;\n        prefs_list.append(pref);\n    }\n    casing_preferences = prefs_list;\n}\n\nvoid AOClient::pktAnnounceCase(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    QString case_title = argv[0];\n    QStringList needed_roles;\n    QList<bool> needs_list;\n    for (int i = 1; i <=5; i++) {\n        bool is_int = false;\n        bool need = argv[i].toInt(&is_int);\n        if (!is_int)\n            return;\n        needs_list.append(need);\n    }\n    QStringList roles = {\"defense attorney\", \"prosecutor\", \"judge\", \"jurors\", \"stenographer\"};\n    for (int i = 0; i < 5; i++) {\n      if (needs_list[i])\n        needed_roles.append(roles[i]);\n    }\n    if (needed_roles.isEmpty())\n        return;\n\n    QString message = \"=== Case Announcement ===\\r\\n\" + (ooc_name == \"\" ? current_char : ooc_name) + \" needs \" + needed_roles.join(\", \") + \" for \" + (case_title == \"\" ? \"a case\" : case_title) + \"!\";\n\n    QList<AOClient*> clients_to_alert;\n    // here lies morton, RIP\n    QSet<bool> needs_set = needs_list.toSet();\n    for (AOClient* client : server->clients) {\n        QSet<bool> matches = client->casing_preferences.toSet().intersect(needs_set);\n        if (!matches.isEmpty() && !clients_to_alert.contains(client))\n            clients_to_alert.append(client);\n    }\n\n    for (AOClient* client : clients_to_alert) {\n        client->sendPacket(AOPacket(\"CASEA\", {message, argv[1], argv[2], argv[3], argv[4], argv[5], \"1\"}));\n        // you may be thinking, \"hey wait a minute the network protocol documentation doesn't mention that last argument!\"\n        // if you are in fact thinking that, you are correct! it is not in the documentation!\n        // however for some inscrutable reason Attorney Online 2 will outright reject a CASEA packet that does not have\n        // at least 7 arguments despite only using the first 6. Cera, i kneel. you have truly broken me.\n    }\n}\n\nvoid AOClient::sendEvidenceList(AreaData* area)\n{\n    for (AOClient* client : server->clients) {\n        if (client->current_area == current_area)\n            client->updateEvidenceList(area);\n    }\n}\n\nvoid AOClient::updateEvidenceList(AreaData* area)\n{\n    QStringList evidence_list;\n    QString evidence_format(\"%1&%2&%3\");\n\n    for (AreaData::Evidence evidence : area->evidence()) {\n        if (!checkAuth(ACLFlags.value(\"CM\")) && area->eviMod() == AreaData::EvidenceMod::HIDDEN_CM) {\n            QRegularExpression regex(\"<owner=(.*?)>\");\n            QRegularExpressionMatch match = regex.match(evidence.description);\n            if (match.hasMatch()) {\n                QStringList owners = match.captured(1).split(\",\");\n                if (!owners.contains(\"all\", Qt::CaseSensitivity::CaseInsensitive) && !owners.contains(pos, Qt::CaseSensitivity::CaseInsensitive)) {\n                    continue;\n                }\n            }\n            // no match = show it to all\n        }\n        evidence_list.append(evidence_format\n            .arg(evidence.name)\n            .arg(evidence.description)\n            .arg(evidence.image));\n    }\n\n    sendPacket(AOPacket(\"LE\", evidence_list));\n}\n\nAOPacket AOClient::validateIcPacket(AOPacket packet)\n{\n    // Welcome to the super cursed server-side IC chat validation hell\n\n    // I wanted to use enums or #defines here to make the\n    // indicies of the args arrays more readable. But,\n    // in typical AO fasion, the indicies for the incoming\n    // and outgoing packets are different. Just RTFM.\n\n    AOPacket invalid(\"INVALID\", {});\n    QStringList args;\n    if (current_char == \"\" || !joined)\n        // Spectators cannot use IC\n        return invalid;\n    AreaData* area = server->areas[current_area];\n    if (area->lockStatus() == AreaData::LockStatus::SPECTATABLE && !area->invited().contains(id) && !checkAuth(ACLFlags.value(\"BYPASS_LOCKS\")))\n        // Non-invited players cannot speak in spectatable areas\n        return invalid;\n\n    QList<QVariant> incoming_args;\n    for (QString arg : packet.contents) {\n        incoming_args.append(QVariant(arg));\n    }\n\n    // desk modifier\n    QStringList allowed_desk_mods;\n    allowed_desk_mods << \"chat\" << \"0\" << \"1\" << \"2\" << \"3\" << \"4\" << \"5\";\n    if (allowed_desk_mods.contains(incoming_args[0].toString())) {\n        args.append(incoming_args[0].toString());\n    }\n    else\n        return invalid;\n\n    // preanim\n    args.append(incoming_args[1].toString());\n\n    // char name\n    if (current_char.toLower() != incoming_args[2].toString().toLower()) {\n        // Selected char is different from supplied folder name\n        // This means the user is INI-swapped\n        if (!area->iniswapAllowed()) {\n            if (!server->characters.contains(incoming_args[2].toString(), Qt::CaseInsensitive))\n                return invalid;\n        }\n        qDebug() << \"INI swap detected from \" << getIpid();\n    }\n    current_iniswap = incoming_args[2].toString();\n    args.append(incoming_args[2].toString());\n\n    // emote\n    emote = incoming_args[3].toString();\n    if (first_person)\n        emote = \"\";\n    args.append(emote);\n\n    // message text\n    if (incoming_args[4].toString().size() > ConfigManager::maxCharacters())\n        return invalid;\n\n    QString incoming_msg = dezalgo(incoming_args[4].toString().trimmed());\n    if (!area->lastICMessage().isEmpty()\n            && incoming_msg == area->lastICMessage()[4]\n            && incoming_msg != \"\")\n        return invalid;\n\n    if (incoming_msg == \"\" && area->blankpostingAllowed() == false) {\n        sendServerMessage(\"Blankposting has been forbidden in this area.\");\n        return invalid;\n    }\n\n    if (is_gimped) {\n        QString gimp_message = ConfigManager::gimpList()[(genRand(1, ConfigManager::gimpList().size() - 1))];\n        incoming_msg = gimp_message;\n    }\n\n    if (is_shaken) {\n        QStringList parts = incoming_msg.split(\" \");\n        std::random_shuffle(parts.begin(), parts.end());\n        incoming_msg = parts.join(\" \");\n    }\n\n    if (is_disemvoweled) {\n        QString disemvoweled_message = incoming_msg.remove(QRegExp(\"[AEIOUaeiou]\"));\n        incoming_msg = disemvoweled_message;\n    }\n\n    last_message = incoming_msg;\n    args.append(incoming_msg);\n\n    // side\n    // this is validated clientside so w/e\n    args.append(incoming_args[5].toString());\n    if (pos != incoming_args[5].toString()) {\n        pos = incoming_args[5].toString();\n        updateEvidenceList(server->areas[current_area]);\n    }\n\n    // sfx name\n    args.append(incoming_args[6].toString());\n\n    // emote modifier\n    // Now, gather round, y'all. Here is a story that is truly a microcosm of the AO dev experience.\n    // If this value is a 4, it will crash the client. Why? Who knows, but it does.\n    // Now here is the kicker: in certain versions, the client would incorrectly send a 4 here\n    // For a long time, by configuring the client to do a zoom with a preanim, it would send 4\n    // This would crash everyone else's client, and the feature had to be disabled\n    // But, for some reason, nobody traced the cause of this issue for many many years.\n    // The serverside fix is needed to ensure invalid values are not sent, because the client sucks\n    int emote_mod = incoming_args[7].toInt();\n\n    if (emote_mod == 4)\n        emote_mod = 6;\n    if (emote_mod != 0 && emote_mod != 1 && emote_mod != 2 && emote_mod != 5 && emote_mod != 6)\n        return invalid;\n    args.append(QString::number(emote_mod));\n\n    // char id\n    if (incoming_args[8].toInt() != char_id)\n        return invalid;\n    args.append(incoming_args[8].toString());\n\n    // sfx delay\n    args.append(incoming_args[9].toString());\n\n    // objection modifier\n    if (incoming_args[10].toString().contains(\"4\")) {\n        // custom shout includes text metadata\n        args.append(incoming_args[10].toString());\n    }\n    else {\n        int obj_mod = incoming_args[10].toInt();\n        if (obj_mod != 0 && obj_mod != 1 && obj_mod != 2 && obj_mod != 3)\n            return invalid;\n        args.append(QString::number(obj_mod));\n    }\n\n    // evidence\n    int evi_idx = incoming_args[11].toInt();\n    if (evi_idx > area->evidence().length())\n        return invalid;\n    args.append(QString::number(evi_idx));\n\n    // flipping\n    int flip = incoming_args[12].toInt();\n    if (flip != 0 && flip != 1)\n        return invalid;\n    flipping = QString::number(flip);\n    args.append(flipping);\n\n    // realization\n    int realization = incoming_args[13].toInt();\n    if (realization != 0 && realization != 1)\n        return invalid;\n    args.append(QString::number(realization));\n\n    // text color\n    int text_color = incoming_args[14].toInt();\n    if (text_color < 0 || text_color > 11)\n        return invalid;\n    args.append(QString::number(text_color));\n\n    // 2.6 packet extensions\n    if (incoming_args.length() > 15) {\n        // showname\n        QString incoming_showname = dezalgo(incoming_args[15].toString().trimmed());\n        if (!(incoming_showname == current_char || incoming_showname.isEmpty()) && !area->shownameAllowed()) {\n            sendServerMessage(\"Shownames are not allowed in this area!\");\n            return invalid;\n        }\n        if (incoming_showname.length() > 30) {\n            sendServerMessage(\"Your showname is too long! Please limit it to under 30 characters\");\n            return invalid;\n        }\n\n        // if the raw input is not empty but the trimmed input is, use a single space\n        if (incoming_showname.isEmpty() && !incoming_args[15].toString().isEmpty())\n            incoming_showname = \" \";\n        args.append(incoming_showname);\n        showname = incoming_showname;\n\n        // other char id\n        // things get a bit hairy here\n        // don't ask me how this works, because i don't know either\n        QStringList pair_data = incoming_args[16].toString().split(\"^\");\n        pairing_with = pair_data[0].toInt();\n        QString front_back = \"\";\n        if (pair_data.length() > 1)\n            front_back = \"^\" + pair_data[1];\n        int other_charid = pairing_with;\n        bool pairing = false;\n        QString other_name = \"0\";\n        QString other_emote = \"0\";\n        QString other_offset = \"0\";\n        QString other_flip = \"0\";\n        for (AOClient* client : server->clients) {\n            if (client->pairing_with == char_id\n                    && other_charid != char_id\n                    && client->char_id == pairing_with\n                    && client->pos == pos) {\n                other_name = client->current_iniswap;\n                other_emote = client->emote;\n                other_offset = client->offset;\n                other_flip = client->flipping;\n                pairing = true;\n            }\n        }\n        if (!pairing) {\n            other_charid = -1;\n            front_back = \"\";\n        }\n        args.append(QString::number(other_charid) + front_back);\n        args.append(other_name);\n        args.append(other_emote);\n\n        // self offset\n        offset = incoming_args[17].toString();\n        // versions 2.6-2.8 cannot validate y-offset so we send them just the x-offset\n        if ((version.release == 2) && (version.major == 6 || version.major == 7 || version.major == 8)) {\n            QString x_offset = offset.split(\"&\")[0];\n            args.append(x_offset);\n            QString other_x_offset = other_offset.split(\"&\")[0];\n            args.append(other_x_offset);\n        }\n        else {\n            args.append(offset);\n            args.append(other_offset);\n        }\n        args.append(other_flip);\n\n        // immediate text processing\n        int immediate = incoming_args[18].toInt();\n        if (area->forceImmediate()) {\n            if (args[7] == \"1\" || args[7] == \"2\") {\n                args[7] = \"0\";\n                immediate = 1;\n            }\n            else if (args[7] == \"6\") {\n                args[7] = \"5\";\n                immediate = 1;\n            }\n        }\n        if (immediate != 1 && immediate != 0)\n            return invalid;\n        args.append(QString::number(immediate));\n    }\n\n    // 2.8 packet extensions\n    if (incoming_args.length() > 19) {\n        // sfx looping\n        int sfx_loop = incoming_args[19].toInt();\n        if (sfx_loop != 0 && sfx_loop != 1)\n            return invalid;\n        args.append(QString::number(sfx_loop));\n\n        // screenshake\n        int screenshake = incoming_args[20].toInt();\n        if (screenshake != 0 && screenshake != 1)\n            return invalid;\n        args.append(QString::number(screenshake));\n\n        // frames shake\n        args.append(incoming_args[21].toString());\n\n        // frames realization\n        args.append(incoming_args[22].toString());\n\n        // frames sfx\n        args.append(incoming_args[23].toString());\n\n        // additive\n        int additive = incoming_args[24].toInt();\n        if (additive != 0 && additive != 1)\n            return invalid;\n        else if (area->lastICMessage().isEmpty()){\n            additive = 0;\n        }\n        else if (!(char_id == area->lastICMessage()[8].toInt())) {\n            additive = 0;\n        }\n        else if (additive == 1) {\n            args[4].insert(0, \" \");\n        }\n        args.append(QString::number(additive));\n\n        // effect\n        args.append(incoming_args[25].toString());\n    }\n\n    //Testimony playback\n    if (area->testimonyRecording() == AreaData::TestimonyRecording::RECORDING || area->testimonyRecording() == AreaData::TestimonyRecording::ADD) {\n        if (args[5] != \"wit\")\n            return AOPacket(\"MS\", args);\n\n        if (area->statement() == -1) {\n            args[4] = \"~~\\\\n-- \" + args[4] + \" --\";\n            args[14] = \"3\";\n            server->broadcast(AOPacket(\"RT\",{\"testimony1\"}), current_area);\n        }\n        addStatement(args);\n    }\n    else if (area->testimonyRecording() == AreaData::TestimonyRecording::UPDATE) {\n        args = updateStatement(args);\n    }\n    else if (area->testimonyRecording() == AreaData::TestimonyRecording::PLAYBACK) {\n        AreaData::TestimonyProgress l_progress;\n\n        if (args[4] == \">\") {\n            pos = \"wit\";\n            auto l_statement = area->jumpToStatement(area->statement() +1);\n            args = l_statement.first;\n            l_progress = l_statement.second;\n\n            if (l_progress == AreaData::TestimonyProgress::LOOPED) {\n                sendServerMessageArea(\"Last statement reached. Looping to first statement.\");\n            }\n        }\n        if (args[4] == \"<\") {\n            pos = \"wit\";\n            auto l_statement = area->jumpToStatement(area->statement() - 1);\n            args = l_statement.first;\n            l_progress = l_statement.second;\n\n            if (l_progress == AreaData::TestimonyProgress::STAYED_AT_FIRST) {\n                sendServerMessage(\"First statement reached.\");\n            }\n        }\n\n        QString decoded_message = decodeMessage(args[4]); //Get rid of that pesky encoding first.\n        QRegularExpression jump(\"(?<arrow>>)(?<int>[0,1,2,3,4,5,6,7,8,9]+)\");\n        QRegularExpressionMatch match = jump.match(decoded_message);\n        if (match.hasMatch()) {\n            pos = \"wit\";\n            auto l_statement = area->jumpToStatement(match.captured(\"int\").toInt());\n            args = l_statement.first;\n            l_progress = l_statement.second;\n\n\n            switch (l_progress){\n            case AreaData::TestimonyProgress::LOOPED:\n            {\n                sendServerMessageArea(\"Last statement reached. Looping to first statement.\");\n            }\n            case AreaData::TestimonyProgress::STAYED_AT_FIRST:\n            {\n                sendServerMessage(\"First statement reached.\");\n            }\n            case AreaData::TestimonyProgress::OK:\n            default:\n                // No need to handle.\n                break;\n            }\n        }\n    }\n\n    return AOPacket(\"MS\", args);\n}\n\nQString AOClient::dezalgo(QString p_text)\n{\n    QRegularExpression rxp(\"([\u0300\u0301\u0302\u0303\u0304\u0305\u0306\u0307\u0308\u0309\u030a\u030b\u030c\u030d\u030e\u030f\u0310\u0311\u0312\u0313\u0314\u0315\u0316\u0317\u0318\u0319\u031a\u031b\u031c\u031d\u031e\u031f\u0320\u0321\u0322\u0323\u0324\u0325\u0326\u0327\u0328\u0329\u032a\u032b\u032c\u032d\u032e\u032f\u0330\u0331\u0332\u0333\u0334\u0335\u0336\u0337\u0338\u0339\u033a\u033b\u033c\u033d\u033e\u033f\u0300\u0301\u0342\u0313\u0308\u0301\u0345\u0346\u0347\u0348\u0349\u034a\u034b\u034c\u034d\u034e\u034f\u0350\u0351\u0352\u0353\u0354\u0355\u0356\u0357\u0358\u0359\u035a\u035b\u035c\u035d\u035e\u035f\u0360\u0361\u0362\u0363\u0364\u0365\u0366\u0367\u0368\u0369\u036a\u036b\u036c\u036d\u036e\u036f])\");\n    QString filtered = p_text.replace(rxp, \"\");\n    return filtered;\n}\n\nbool AOClient::checkEvidenceAccess(AreaData *area)\n{\n    switch(area->eviMod()) {\n    case AreaData::EvidenceMod::FFA:\n        return true;\n    case AreaData::EvidenceMod::CM:\n    case AreaData::EvidenceMod::HIDDEN_CM:\n        return checkAuth(ACLFlags.value(\"CM\"));\n    case AreaData::EvidenceMod::MOD:\n        return authenticated;\n    default:\n        return false;\n    }\n}\n\nvoid AOClient::updateJudgeLog(AreaData* area, AOClient* client, QString action)\n{\n    QString timestamp = QTime::currentTime().toString(\"hh:mm:ss\");\n    QString uid = QString::number(client->id);\n    QString char_name = client->current_char;\n    QString ipid = client->getIpid();\n    QString message = action;\n    QString logmessage = QString(\"[%1]: [%2] %3 (%4) %5\").arg(timestamp, uid, char_name, ipid, message);\n    area->appendJudgelog(logmessage);\n}\n\nQString AOClient::decodeMessage(QString incoming_message)\n{\n   QString decoded_message = incoming_message.replace(\"<num>\", \"#\")\n                                             .replace(\"<percent>\", \"%\")\n                                             .replace(\"<dollar>\", \"$\")\n                                             .replace(\"<and>\", \"&\");\n    return decoded_message;\n}\n\nvoid AOClient::loginAttempt(QString message)\n{\n    switch (ConfigManager::authType()) {\n    case DataTypes::AuthType::SIMPLE:\n        if (message == ConfigManager::modpass()) {\n            sendPacket(\"AUTH\", {\"1\"}); // Client: \"You were granted the Disable Modcalls button.\"\n            sendServerMessage(\"Logged in as a moderator.\"); // pre-2.9.1 clients are hardcoded to display the mod UI when this string is sent in OOC\n            authenticated = true;\n        }\n        else {\n            sendPacket(\"AUTH\", {\"0\"}); // Client: \"Login unsuccessful.\"\n            sendServerMessage(\"Incorrect password.\");\n        }\n        server->areas.value(current_area)->logLogin(current_char, ipid, authenticated, \"moderator\");\n        break;\n    case DataTypes::AuthType::ADVANCED:\n        QStringList login = message.split(\" \");\n        if (login.size() < 2) {\n            sendServerMessage(\"You must specify a username and a password\");\n            sendServerMessage(\"Exiting login prompt.\");\n            is_logging_in = false;\n            return;\n        }\n        QString username = login[0];\n        QString password = login[1];\n        if (server->db_manager->authenticate(username, password)) {\n            moderator_name = username;\n            authenticated = true;\n            sendPacket(\"AUTH\", {\"1\"}); // Client: \"You were granted the Disable Modcalls button.\"\n            if (version.release <= 2 && version.major <= 9 && version.minor <= 0)\n                sendServerMessage(\"Logged in as a moderator.\"); // pre-2.9.1 clients are hardcoded to display the mod UI when this string is sent in OOC\n            sendServerMessage(\"Welcome, \" + username);\n        }\n        else {\n            sendPacket(\"AUTH\", {\"0\"}); // Client: \"Login unsuccessful.\"\n            sendServerMessage(\"Incorrect password.\");\n        }\n        server->areas.value(current_area)->logLogin(current_char, ipid, authenticated, username);\n        break;\n    }\n    sendServerMessage(\"Exiting login prompt.\");\n    is_logging_in = false;\n    return;\n}\n\n"], "filenames": ["core/src/packets.cpp"], "buggy_code_start_loc": [381], "buggy_code_end_loc": [395], "fixing_code_start_loc": [381], "fixing_code_end_loc": [395], "type": "CWE-129", "message": "Akashi is an open source server implementation of the Attorney Online video game based on the Ace Attorney universe. Affected versions of Akashi are subject to a denial of service attack. An attacker can use a specially crafted evidence packet to make an illegal modification, causing a server crash. This can be used to mount a denial-of-service exploit. Users are advised to upgrade. There is no known workaround for this issue.", "other": {"cve": {"id": "CVE-2022-31135", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-07T18:15:09.637", "lastModified": "2022-07-15T03:22:49.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Akashi is an open source server implementation of the Attorney Online video game based on the Ace Attorney universe. Affected versions of Akashi are subject to a denial of service attack. An attacker can use a specially crafted evidence packet to make an illegal modification, causing a server crash. This can be used to mount a denial-of-service exploit. Users are advised to upgrade. There is no known workaround for this issue."}, {"lang": "es", "value": "Akashi es una implementaci\u00f3n de servidor de c\u00f3digo abierto del videojuego Attorney Online basado en el universo de Ace Attorney. Las versiones afectadas de Akashi est\u00e1n sujetas a un ataque de denegaci\u00f3n de servicio. Un atacante puede usar un paquete de pruebas especialmente dise\u00f1ado para realizar una modificaci\u00f3n ilegal, causando un bloqueo del servidor. Esto puede ser usado para montar una explotaci\u00f3n de denegaci\u00f3n de servicio. Es recomendado a usuarios actualizar. No es conocida ninguna mitigaci\u00f3n para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aceattorneyonline:akashi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4", "matchCriteriaId": "C2173CC1-E03A-4A5B-BD12-B2001559BDEA"}]}]}], "references": [{"url": "https://github.com/AttorneyOnline/akashi/commit/5566cdfedddef1f219aee33477d9c9690bf2f78b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/AttorneyOnline/akashi/security/advisories/GHSA-vj86-vfmg-q68v", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AttorneyOnline/akashi/commit/5566cdfedddef1f219aee33477d9c9690bf2f78b"}}