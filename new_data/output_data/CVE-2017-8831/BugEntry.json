{"buggy_code": ["/*\n *  Driver for the NXP SAA7164 PCIe bridge\n *\n *  Copyright (c) 2010-2015 Steven Toth <stoth@kernellabs.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *\n *  GNU General Public License for more details.\n */\n\n#include \"saa7164.h\"\n\n/* The message bus to/from the firmware is a ring buffer in PCI address\n * space. Establish the defaults.\n */\nint saa7164_bus_setup(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b\t= &dev->bus;\n\n\tmutex_init(&b->lock);\n\n\tb->Type\t\t\t= TYPE_BUS_PCIe;\n\tb->m_wMaxReqSize\t= SAA_DEVICE_MAXREQUESTSIZE;\n\n\tb->m_pdwSetRing\t\t= (u8 __iomem *)(dev->bmmio +\n\t\t((u32)dev->busdesc.CommandRing));\n\n\tb->m_dwSizeSetRing\t= SAA_DEVICE_BUFFERBLOCKSIZE;\n\n\tb->m_pdwGetRing\t\t= (u8 __iomem *)(dev->bmmio +\n\t\t((u32)dev->busdesc.ResponseRing));\n\n\tb->m_dwSizeGetRing\t= SAA_DEVICE_BUFFERBLOCKSIZE;\n\n\tb->m_dwSetWritePos\t= ((u32)dev->intfdesc.BARLocation) +\n\t\t(2 * sizeof(u64));\n\tb->m_dwSetReadPos\t= b->m_dwSetWritePos + (1 * sizeof(u32));\n\n\tb->m_dwGetWritePos\t= b->m_dwSetWritePos + (2 * sizeof(u32));\n\tb->m_dwGetReadPos\t= b->m_dwSetWritePos + (3 * sizeof(u32));\n\n\treturn 0;\n}\n\nvoid saa7164_bus_dump(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b = &dev->bus;\n\n\tdprintk(DBGLVL_BUS, \"Dumping the bus structure:\\n\");\n\tdprintk(DBGLVL_BUS, \" .type             = %d\\n\", b->Type);\n\tdprintk(DBGLVL_BUS, \" .dev->bmmio       = 0x%p\\n\", dev->bmmio);\n\tdprintk(DBGLVL_BUS, \" .m_wMaxReqSize    = 0x%x\\n\", b->m_wMaxReqSize);\n\tdprintk(DBGLVL_BUS, \" .m_pdwSetRing     = 0x%p\\n\", b->m_pdwSetRing);\n\tdprintk(DBGLVL_BUS, \" .m_dwSizeSetRing  = 0x%x\\n\", b->m_dwSizeSetRing);\n\tdprintk(DBGLVL_BUS, \" .m_pdwGetRing     = 0x%p\\n\", b->m_pdwGetRing);\n\tdprintk(DBGLVL_BUS, \" .m_dwSizeGetRing  = 0x%x\\n\", b->m_dwSizeGetRing);\n\n\tdprintk(DBGLVL_BUS, \" .m_dwSetReadPos   = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwSetReadPos, saa7164_readl(b->m_dwSetReadPos));\n\n\tdprintk(DBGLVL_BUS, \" .m_dwSetWritePos  = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwSetWritePos, saa7164_readl(b->m_dwSetWritePos));\n\n\tdprintk(DBGLVL_BUS, \" .m_dwGetReadPos   = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwGetReadPos, saa7164_readl(b->m_dwGetReadPos));\n\n\tdprintk(DBGLVL_BUS, \" .m_dwGetWritePos  = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwGetWritePos, saa7164_readl(b->m_dwGetWritePos));\n\n}\n\n/* Intensionally throw a BUG() if the state of the message bus looks corrupt */\nstatic void saa7164_bus_verify(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b = &dev->bus;\n\tint bug = 0;\n\n\tif (saa7164_readl(b->m_dwSetReadPos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwSetWritePos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetReadPos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetWritePos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (bug) {\n\t\tsaa_debug = 0xffff; /* Ensure we get the bus dump */\n\t\tsaa7164_bus_dump(dev);\n\t\tsaa_debug = 1024; /* Ensure we get the bus dump */\n\t\tBUG();\n\t}\n}\n\nstatic void saa7164_bus_dumpmsg(struct saa7164_dev *dev, struct tmComResInfo *m,\n\t\t\t\tvoid *buf)\n{\n\tdprintk(DBGLVL_BUS, \"Dumping msg structure:\\n\");\n\tdprintk(DBGLVL_BUS, \" .id               = %d\\n\",   m->id);\n\tdprintk(DBGLVL_BUS, \" .flags            = 0x%x\\n\", m->flags);\n\tdprintk(DBGLVL_BUS, \" .size             = 0x%x\\n\", m->size);\n\tdprintk(DBGLVL_BUS, \" .command          = 0x%x\\n\", m->command);\n\tdprintk(DBGLVL_BUS, \" .controlselector  = 0x%x\\n\", m->controlselector);\n\tdprintk(DBGLVL_BUS, \" .seqno            = %d\\n\",   m->seqno);\n\tif (buf)\n\t\tdprintk(DBGLVL_BUS, \" .buffer (ignored)\\n\");\n}\n\n/*\n * Places a command or a response on the bus. The implementation does not\n * know if it is a command or a response it just places the data on the\n * bus depending on the bus information given in the struct tmComResBusInfo\n * structure. If the command or response does not fit into the bus ring\n * buffer it will be refused.\n *\n * Return Value:\n *  SAA_OK     The function executed successfully.\n *  < 0        One or more members are not initialized.\n */\nint saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_write, free_write_space, timeout, curr_srp, curr_swp;\n\tu32 new_swp, space_rem;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\tu16 size;\n\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s() !msg\\n\", __func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\tdprintk(DBGLVL_BUS, \"%s()\\n\", __func__);\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\tif ((msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR \"%s() Missing message buffer\\n\", __func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\t/* Lock the bus from any other access */\n\tmutex_lock(&bus->lock);\n\n\tbytes_to_write = sizeof(*msg) + msg->size;\n\tfree_write_space = 0;\n\ttimeout = SAA_BUS_TIMEOUT;\n\tcurr_srp = saa7164_readl(bus->m_dwSetReadPos);\n\tcurr_swp = saa7164_readl(bus->m_dwSetWritePos);\n\n\t/* Deal with ring wrapping issues */\n\tif (curr_srp > curr_swp)\n\t\t/* Deal with the wrapped ring */\n\t\tfree_write_space = curr_srp - curr_swp;\n\telse\n\t\t/* The ring has not wrapped yet */\n\t\tfree_write_space = (curr_srp + bus->m_dwSizeSetRing) - curr_swp;\n\n\tdprintk(DBGLVL_BUS, \"%s() bytes_to_write = %d\\n\", __func__,\n\t\tbytes_to_write);\n\n\tdprintk(DBGLVL_BUS, \"%s() free_write_space = %d\\n\", __func__,\n\t\tfree_write_space);\n\n\tdprintk(DBGLVL_BUS, \"%s() curr_srp = %x\\n\", __func__, curr_srp);\n\tdprintk(DBGLVL_BUS, \"%s() curr_swp = %x\\n\", __func__, curr_swp);\n\n\t/* Process the msg and write the content onto the bus */\n\twhile (bytes_to_write >= free_write_space) {\n\n\t\tif (timeout-- == 0) {\n\t\t\tprintk(KERN_ERR \"%s() bus timeout\\n\", __func__);\n\t\t\tret = SAA_ERR_NO_RESOURCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* TODO: Review this delay, efficient? */\n\t\t/* Wait, allowing the hardware fetch time */\n\t\tmdelay(1);\n\n\t\t/* Check the space usage again */\n\t\tcurr_srp = saa7164_readl(bus->m_dwSetReadPos);\n\n\t\t/* Deal with ring wrapping issues */\n\t\tif (curr_srp > curr_swp)\n\t\t\t/* Deal with the wrapped ring */\n\t\t\tfree_write_space = curr_srp - curr_swp;\n\t\telse\n\t\t\t/* Read didn't wrap around the buffer */\n\t\t\tfree_write_space = (curr_srp + bus->m_dwSizeSetRing) -\n\t\t\t\tcurr_swp;\n\n\t}\n\n\t/* Calculate the new write position */\n\tnew_swp = curr_swp + bytes_to_write;\n\n\tdprintk(DBGLVL_BUS, \"%s() new_swp = %x\\n\", __func__, new_swp);\n\tdprintk(DBGLVL_BUS, \"%s() bus->m_dwSizeSetRing = %x\\n\", __func__,\n\t\tbus->m_dwSizeSetRing);\n\n\t/*\n\t * Make a copy of msg->size before it is converted to le16 since it is\n\t * used in the code below.\n\t */\n\tsize = msg->size;\n\t/* Convert to le16/le32 */\n\tmsg->size = (__force u16)cpu_to_le16(msg->size);\n\tmsg->command = (__force u32)cpu_to_le32(msg->command);\n\tmsg->controlselector = (__force u16)cpu_to_le16(msg->controlselector);\n\n\t/* Mental Note: line 462 tmmhComResBusPCIe.cpp */\n\n\t/* Check if we're going to wrap again */\n\tif (new_swp > bus->m_dwSizeSetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_swp -= bus->m_dwSizeSetRing;\n\n\t\tspace_rem = bus->m_dwSizeSetRing - curr_swp;\n\n\t\tdprintk(DBGLVL_BUS, \"%s() space_rem = %x\\n\", __func__,\n\t\t\tspace_rem);\n\n\t\tdprintk(DBGLVL_BUS, \"%s() sizeof(*msg) = %d\\n\", __func__,\n\t\t\t(u32)sizeof(*msg));\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\tdprintk(DBGLVL_BUS, \"%s() tr4\\n\", __func__);\n\n\t\t\t/* Split the msg into pieces as the ring wraps */\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, space_rem);\n\t\t\tmemcpy_toio(bus->m_pdwSetRing, (u8 *)msg + space_rem,\n\t\t\t\tsizeof(*msg) - space_rem);\n\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + sizeof(*msg) - space_rem,\n\t\t\t\tbuf, size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tdprintk(DBGLVL_BUS, \"%s() tr5\\n\", __func__);\n\n\t\t\t/* Additional data at the beginning of the ring */\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));\n\t\t\tmemcpy_toio(bus->m_pdwSetRing, buf, size);\n\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));\n\t\t\tif (size > 0) {\n\t\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp +\n\t\t\t\t\tsizeof(*msg), buf, space_rem -\n\t\t\t\t\tsizeof(*msg));\n\t\t\t\tmemcpy_toio(bus->m_pdwSetRing, (u8 *)buf +\n\t\t\t\t\tspace_rem - sizeof(*msg),\n\t\t\t\t\tbytes_to_write - space_rem);\n\t\t\t}\n\n\t\t}\n\n\t} /* (new_swp > bus->m_dwSizeSetRing) */\n\telse {\n\t\tdprintk(DBGLVL_BUS, \"%s() tr6\\n\", __func__);\n\n\t\t/* The ring buffer doesn't wrap, two simple copies */\n\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));\n\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp + sizeof(*msg), buf,\n\t\t\tsize);\n\t}\n\n\tdprintk(DBGLVL_BUS, \"%s() new_swp = %x\\n\", __func__, new_swp);\n\n\t/* Update the bus write position */\n\tsaa7164_writel(bus->m_dwSetWritePos, new_swp);\n\n\t/* Convert back to cpu after writing the msg to the ringbuffer. */\n\tmsg->size = le16_to_cpu((__force __le16)msg->size);\n\tmsg->command = le32_to_cpu((__force __le32)msg->command);\n\tmsg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);\n\tret = SAA_OK;\n\nout:\n\tsaa7164_bus_dump(dev);\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}\n\n/*\n * Receive a command or a response from the bus. The implementation does not\n * know if it is a command or a response it simply dequeues the data,\n * depending on the bus information given in the struct tmComResBusInfo\n * structure.\n *\n * Return Value:\n *  0          The function executed successfully.\n *  < 0        One or more members are not initialized.\n */\nint saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf, int peekonly)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_read, write_distance, curr_grp, curr_gwp,\n\t\tnew_grp, buf_size, space_rem;\n\tstruct tmComResInfo msg_tmp;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg == NULL)\n\t\treturn ret;\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s() Missing msg buf, size should be %d bytes\\n\",\n\t\t\t__func__, msg->size);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&bus->lock);\n\n\t/* Peek the bus to see if a msg exists, if it's not what we're expecting\n\t * then return cleanly else read the message from the bus.\n\t */\n\tcurr_gwp = saa7164_readl(bus->m_dwGetWritePos);\n\tcurr_grp = saa7164_readl(bus->m_dwGetReadPos);\n\n\tif (curr_gwp == curr_grp) {\n\t\tret = SAA_ERR_EMPTY;\n\t\tgoto out;\n\t}\n\n\tbytes_to_read = sizeof(*msg);\n\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() No message/response found\\n\", __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\tmemcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,\n\t\t\tbytes_to_read - space_rem);\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);\n\tmsg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);\n\tmsg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);\n\n\t/* No need to update the read positions, because this was a peek */\n\t/* If the caller specifically want to peek, return */\n\tif (peekonly) {\n\t\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n\t\tgoto peekout;\n\t}\n\n\t/* Check if the command/response matches what is expected */\n\tif ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||\n\t\t(msg_tmp.controlselector != msg->controlselector) ||\n\t\t(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {\n\n\t\tprintk(KERN_ERR \"%s() Unexpected msg miss-match\\n\", __func__);\n\t\tsaa7164_bus_dumpmsg(dev, msg, buf);\n\t\tsaa7164_bus_dumpmsg(dev, &msg_tmp, NULL);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Get the actual command and response from the bus */\n\tbuf_size = msg->size;\n\n\tbytes_to_read = sizeof(*msg) + msg->size;\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\\n\",\n\t\t       __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\t/* msg wraps around the ring */\n\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\t\tmemcpy_fromio((u8 *)msg + space_rem, bus->m_pdwGetRing,\n\t\t\t\tsizeof(*msg) - space_rem);\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -\n\t\t\t\t\tspace_rem, buf_size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing, buf_size);\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n\t\t\tif (buf) {\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +\n\t\t\t\t\tsizeof(*msg), space_rem - sizeof(*msg));\n\t\t\t\tmemcpy_fromio(buf + space_rem - sizeof(*msg),\n\t\t\t\t\tbus->m_pdwGetRing, bytes_to_read -\n\t\t\t\t\tspace_rem);\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n\t\tif (buf)\n\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),\n\t\t\t\tbuf_size);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg->size = le16_to_cpu((__force __le16)msg->size);\n\tmsg->command = le32_to_cpu((__force __le32)msg->command);\n\tmsg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);\n\n\t/* Update the read positions, adjusting the ring */\n\tsaa7164_writel(bus->m_dwGetReadPos, new_grp);\n\npeekout:\n\tret = SAA_OK;\nout:\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}\n\n"], "fixing_code": ["/*\n *  Driver for the NXP SAA7164 PCIe bridge\n *\n *  Copyright (c) 2010-2015 Steven Toth <stoth@kernellabs.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *\n *  GNU General Public License for more details.\n */\n\n#include \"saa7164.h\"\n\n/* The message bus to/from the firmware is a ring buffer in PCI address\n * space. Establish the defaults.\n */\nint saa7164_bus_setup(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b\t= &dev->bus;\n\n\tmutex_init(&b->lock);\n\n\tb->Type\t\t\t= TYPE_BUS_PCIe;\n\tb->m_wMaxReqSize\t= SAA_DEVICE_MAXREQUESTSIZE;\n\n\tb->m_pdwSetRing\t\t= (u8 __iomem *)(dev->bmmio +\n\t\t((u32)dev->busdesc.CommandRing));\n\n\tb->m_dwSizeSetRing\t= SAA_DEVICE_BUFFERBLOCKSIZE;\n\n\tb->m_pdwGetRing\t\t= (u8 __iomem *)(dev->bmmio +\n\t\t((u32)dev->busdesc.ResponseRing));\n\n\tb->m_dwSizeGetRing\t= SAA_DEVICE_BUFFERBLOCKSIZE;\n\n\tb->m_dwSetWritePos\t= ((u32)dev->intfdesc.BARLocation) +\n\t\t(2 * sizeof(u64));\n\tb->m_dwSetReadPos\t= b->m_dwSetWritePos + (1 * sizeof(u32));\n\n\tb->m_dwGetWritePos\t= b->m_dwSetWritePos + (2 * sizeof(u32));\n\tb->m_dwGetReadPos\t= b->m_dwSetWritePos + (3 * sizeof(u32));\n\n\treturn 0;\n}\n\nvoid saa7164_bus_dump(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b = &dev->bus;\n\n\tdprintk(DBGLVL_BUS, \"Dumping the bus structure:\\n\");\n\tdprintk(DBGLVL_BUS, \" .type             = %d\\n\", b->Type);\n\tdprintk(DBGLVL_BUS, \" .dev->bmmio       = 0x%p\\n\", dev->bmmio);\n\tdprintk(DBGLVL_BUS, \" .m_wMaxReqSize    = 0x%x\\n\", b->m_wMaxReqSize);\n\tdprintk(DBGLVL_BUS, \" .m_pdwSetRing     = 0x%p\\n\", b->m_pdwSetRing);\n\tdprintk(DBGLVL_BUS, \" .m_dwSizeSetRing  = 0x%x\\n\", b->m_dwSizeSetRing);\n\tdprintk(DBGLVL_BUS, \" .m_pdwGetRing     = 0x%p\\n\", b->m_pdwGetRing);\n\tdprintk(DBGLVL_BUS, \" .m_dwSizeGetRing  = 0x%x\\n\", b->m_dwSizeGetRing);\n\n\tdprintk(DBGLVL_BUS, \" .m_dwSetReadPos   = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwSetReadPos, saa7164_readl(b->m_dwSetReadPos));\n\n\tdprintk(DBGLVL_BUS, \" .m_dwSetWritePos  = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwSetWritePos, saa7164_readl(b->m_dwSetWritePos));\n\n\tdprintk(DBGLVL_BUS, \" .m_dwGetReadPos   = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwGetReadPos, saa7164_readl(b->m_dwGetReadPos));\n\n\tdprintk(DBGLVL_BUS, \" .m_dwGetWritePos  = 0x%x (0x%08x)\\n\",\n\t\tb->m_dwGetWritePos, saa7164_readl(b->m_dwGetWritePos));\n\n}\n\n/* Intensionally throw a BUG() if the state of the message bus looks corrupt */\nstatic void saa7164_bus_verify(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b = &dev->bus;\n\tint bug = 0;\n\n\tif (saa7164_readl(b->m_dwSetReadPos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwSetWritePos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetReadPos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetWritePos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (bug) {\n\t\tsaa_debug = 0xffff; /* Ensure we get the bus dump */\n\t\tsaa7164_bus_dump(dev);\n\t\tsaa_debug = 1024; /* Ensure we get the bus dump */\n\t\tBUG();\n\t}\n}\n\nstatic void saa7164_bus_dumpmsg(struct saa7164_dev *dev, struct tmComResInfo *m,\n\t\t\t\tvoid *buf)\n{\n\tdprintk(DBGLVL_BUS, \"Dumping msg structure:\\n\");\n\tdprintk(DBGLVL_BUS, \" .id               = %d\\n\",   m->id);\n\tdprintk(DBGLVL_BUS, \" .flags            = 0x%x\\n\", m->flags);\n\tdprintk(DBGLVL_BUS, \" .size             = 0x%x\\n\", m->size);\n\tdprintk(DBGLVL_BUS, \" .command          = 0x%x\\n\", m->command);\n\tdprintk(DBGLVL_BUS, \" .controlselector  = 0x%x\\n\", m->controlselector);\n\tdprintk(DBGLVL_BUS, \" .seqno            = %d\\n\",   m->seqno);\n\tif (buf)\n\t\tdprintk(DBGLVL_BUS, \" .buffer (ignored)\\n\");\n}\n\n/*\n * Places a command or a response on the bus. The implementation does not\n * know if it is a command or a response it just places the data on the\n * bus depending on the bus information given in the struct tmComResBusInfo\n * structure. If the command or response does not fit into the bus ring\n * buffer it will be refused.\n *\n * Return Value:\n *  SAA_OK     The function executed successfully.\n *  < 0        One or more members are not initialized.\n */\nint saa7164_bus_set(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_write, free_write_space, timeout, curr_srp, curr_swp;\n\tu32 new_swp, space_rem;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\tu16 size;\n\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s() !msg\\n\", __func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\tdprintk(DBGLVL_BUS, \"%s()\\n\", __func__);\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\tif ((msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR \"%s() Missing message buffer\\n\", __func__);\n\t\treturn SAA_ERR_BAD_PARAMETER;\n\t}\n\n\t/* Lock the bus from any other access */\n\tmutex_lock(&bus->lock);\n\n\tbytes_to_write = sizeof(*msg) + msg->size;\n\tfree_write_space = 0;\n\ttimeout = SAA_BUS_TIMEOUT;\n\tcurr_srp = saa7164_readl(bus->m_dwSetReadPos);\n\tcurr_swp = saa7164_readl(bus->m_dwSetWritePos);\n\n\t/* Deal with ring wrapping issues */\n\tif (curr_srp > curr_swp)\n\t\t/* Deal with the wrapped ring */\n\t\tfree_write_space = curr_srp - curr_swp;\n\telse\n\t\t/* The ring has not wrapped yet */\n\t\tfree_write_space = (curr_srp + bus->m_dwSizeSetRing) - curr_swp;\n\n\tdprintk(DBGLVL_BUS, \"%s() bytes_to_write = %d\\n\", __func__,\n\t\tbytes_to_write);\n\n\tdprintk(DBGLVL_BUS, \"%s() free_write_space = %d\\n\", __func__,\n\t\tfree_write_space);\n\n\tdprintk(DBGLVL_BUS, \"%s() curr_srp = %x\\n\", __func__, curr_srp);\n\tdprintk(DBGLVL_BUS, \"%s() curr_swp = %x\\n\", __func__, curr_swp);\n\n\t/* Process the msg and write the content onto the bus */\n\twhile (bytes_to_write >= free_write_space) {\n\n\t\tif (timeout-- == 0) {\n\t\t\tprintk(KERN_ERR \"%s() bus timeout\\n\", __func__);\n\t\t\tret = SAA_ERR_NO_RESOURCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* TODO: Review this delay, efficient? */\n\t\t/* Wait, allowing the hardware fetch time */\n\t\tmdelay(1);\n\n\t\t/* Check the space usage again */\n\t\tcurr_srp = saa7164_readl(bus->m_dwSetReadPos);\n\n\t\t/* Deal with ring wrapping issues */\n\t\tif (curr_srp > curr_swp)\n\t\t\t/* Deal with the wrapped ring */\n\t\t\tfree_write_space = curr_srp - curr_swp;\n\t\telse\n\t\t\t/* Read didn't wrap around the buffer */\n\t\t\tfree_write_space = (curr_srp + bus->m_dwSizeSetRing) -\n\t\t\t\tcurr_swp;\n\n\t}\n\n\t/* Calculate the new write position */\n\tnew_swp = curr_swp + bytes_to_write;\n\n\tdprintk(DBGLVL_BUS, \"%s() new_swp = %x\\n\", __func__, new_swp);\n\tdprintk(DBGLVL_BUS, \"%s() bus->m_dwSizeSetRing = %x\\n\", __func__,\n\t\tbus->m_dwSizeSetRing);\n\n\t/*\n\t * Make a copy of msg->size before it is converted to le16 since it is\n\t * used in the code below.\n\t */\n\tsize = msg->size;\n\t/* Convert to le16/le32 */\n\tmsg->size = (__force u16)cpu_to_le16(msg->size);\n\tmsg->command = (__force u32)cpu_to_le32(msg->command);\n\tmsg->controlselector = (__force u16)cpu_to_le16(msg->controlselector);\n\n\t/* Mental Note: line 462 tmmhComResBusPCIe.cpp */\n\n\t/* Check if we're going to wrap again */\n\tif (new_swp > bus->m_dwSizeSetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_swp -= bus->m_dwSizeSetRing;\n\n\t\tspace_rem = bus->m_dwSizeSetRing - curr_swp;\n\n\t\tdprintk(DBGLVL_BUS, \"%s() space_rem = %x\\n\", __func__,\n\t\t\tspace_rem);\n\n\t\tdprintk(DBGLVL_BUS, \"%s() sizeof(*msg) = %d\\n\", __func__,\n\t\t\t(u32)sizeof(*msg));\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\tdprintk(DBGLVL_BUS, \"%s() tr4\\n\", __func__);\n\n\t\t\t/* Split the msg into pieces as the ring wraps */\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, space_rem);\n\t\t\tmemcpy_toio(bus->m_pdwSetRing, (u8 *)msg + space_rem,\n\t\t\t\tsizeof(*msg) - space_rem);\n\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + sizeof(*msg) - space_rem,\n\t\t\t\tbuf, size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tdprintk(DBGLVL_BUS, \"%s() tr5\\n\", __func__);\n\n\t\t\t/* Additional data at the beginning of the ring */\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));\n\t\t\tmemcpy_toio(bus->m_pdwSetRing, buf, size);\n\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));\n\t\t\tif (size > 0) {\n\t\t\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp +\n\t\t\t\t\tsizeof(*msg), buf, space_rem -\n\t\t\t\t\tsizeof(*msg));\n\t\t\t\tmemcpy_toio(bus->m_pdwSetRing, (u8 *)buf +\n\t\t\t\t\tspace_rem - sizeof(*msg),\n\t\t\t\t\tbytes_to_write - space_rem);\n\t\t\t}\n\n\t\t}\n\n\t} /* (new_swp > bus->m_dwSizeSetRing) */\n\telse {\n\t\tdprintk(DBGLVL_BUS, \"%s() tr6\\n\", __func__);\n\n\t\t/* The ring buffer doesn't wrap, two simple copies */\n\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));\n\t\tmemcpy_toio(bus->m_pdwSetRing + curr_swp + sizeof(*msg), buf,\n\t\t\tsize);\n\t}\n\n\tdprintk(DBGLVL_BUS, \"%s() new_swp = %x\\n\", __func__, new_swp);\n\n\t/* Update the bus write position */\n\tsaa7164_writel(bus->m_dwSetWritePos, new_swp);\n\n\t/* Convert back to cpu after writing the msg to the ringbuffer. */\n\tmsg->size = le16_to_cpu((__force __le16)msg->size);\n\tmsg->command = le32_to_cpu((__force __le32)msg->command);\n\tmsg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);\n\tret = SAA_OK;\n\nout:\n\tsaa7164_bus_dump(dev);\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}\n\n/*\n * Receive a command or a response from the bus. The implementation does not\n * know if it is a command or a response it simply dequeues the data,\n * depending on the bus information given in the struct tmComResBusInfo\n * structure.\n *\n * Return Value:\n *  0          The function executed successfully.\n *  < 0        One or more members are not initialized.\n */\nint saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf, int peekonly)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_read, write_distance, curr_grp, curr_gwp,\n\t\tnew_grp, buf_size, space_rem;\n\tstruct tmComResInfo msg_tmp;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg == NULL)\n\t\treturn ret;\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s() Missing msg buf, size should be %d bytes\\n\",\n\t\t\t__func__, msg->size);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&bus->lock);\n\n\t/* Peek the bus to see if a msg exists, if it's not what we're expecting\n\t * then return cleanly else read the message from the bus.\n\t */\n\tcurr_gwp = saa7164_readl(bus->m_dwGetWritePos);\n\tcurr_grp = saa7164_readl(bus->m_dwGetReadPos);\n\n\tif (curr_gwp == curr_grp) {\n\t\tret = SAA_ERR_EMPTY;\n\t\tgoto out;\n\t}\n\n\tbytes_to_read = sizeof(*msg);\n\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() No message/response found\\n\", __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\tmemcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,\n\t\t\tbytes_to_read - space_rem);\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);\n\tmsg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);\n\tmsg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);\n\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n\n\t/* No need to update the read positions, because this was a peek */\n\t/* If the caller specifically want to peek, return */\n\tif (peekonly) {\n\t\tgoto peekout;\n\t}\n\n\t/* Check if the command/response matches what is expected */\n\tif ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||\n\t\t(msg_tmp.controlselector != msg->controlselector) ||\n\t\t(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {\n\n\t\tprintk(KERN_ERR \"%s() Unexpected msg miss-match\\n\", __func__);\n\t\tsaa7164_bus_dumpmsg(dev, msg, buf);\n\t\tsaa7164_bus_dumpmsg(dev, &msg_tmp, NULL);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Get the actual command and response from the bus */\n\tbuf_size = msg->size;\n\n\tbytes_to_read = sizeof(*msg) + msg->size;\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\\n\",\n\t\t       __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -\n\t\t\t\t\tspace_rem, buf_size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing, buf_size);\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tif (buf) {\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +\n\t\t\t\t\tsizeof(*msg), space_rem - sizeof(*msg));\n\t\t\t\tmemcpy_fromio(buf + space_rem - sizeof(*msg),\n\t\t\t\t\tbus->m_pdwGetRing, bytes_to_read -\n\t\t\t\t\tspace_rem);\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\t\t/* No wrapping */\n\t\tif (buf)\n\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),\n\t\t\t\tbuf_size);\n\t}\n\n\t/* Update the read positions, adjusting the ring */\n\tsaa7164_writel(bus->m_dwGetReadPos, new_grp);\n\npeekout:\n\tret = SAA_OK;\nout:\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}\n\n"], "filenames": ["drivers/media/pci/saa7164/saa7164-bus.c"], "buggy_code_start_loc": [391], "buggy_code_end_loc": [477], "fixing_code_start_loc": [392], "fixing_code_end_loc": [465], "type": "CWE-125", "message": "The saa7164_bus_get function in drivers/media/pci/saa7164/saa7164-bus.c in the Linux kernel through 4.11.5 allows local users to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact by changing a certain sequence-number value, aka a \"double fetch\" vulnerability.", "other": {"cve": {"id": "CVE-2017-8831", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-08T06:29:00.270", "lastModified": "2021-06-01T19:14:18.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The saa7164_bus_get function in drivers/media/pci/saa7164/saa7164-bus.c in the Linux kernel through 4.11.5 allows local users to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact by changing a certain sequence-number value, aka a \"double fetch\" vulnerability."}, {"lang": "es", "value": "La funci\u00f3n saa7164_bus_get en el archivo drivers/media/pci/saa7164/saa7164-bus.c en el kernel de Linux hasta versi\u00f3n 4.11.5, permite a los usuarios locales causar una denegaci\u00f3n de servicio (acceso de matriz fuera de l\u00edmites) o posiblemente tener otro impacto no especificado por el cambio de un  valor predeterminado de n\u00famero de secuencia, tambi\u00e9n se conoce como una vulnerabilidad de \"double fetch\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.11.5", "matchCriteriaId": "16B5D5A3-9169-4BA1-8193-51B6C8E04851"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://www.securityfocus.com/archive/1/540770/30/0/threaded", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/99619", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=195559", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c"}}