{"buggy_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Main export hanling code\n * @package PhpMyAdmin\n */\n\n/**\n * Get the variables sent or posted to this script and a core script\n */\nrequire_once './libraries/common.inc.php';\nrequire_once './libraries/zip.lib.php';\nrequire_once './libraries/plugin_interface.lib.php';\n\nPMA_checkParameters(array('what', 'export_type'));\n\n// Scan plugins\n$export_list = PMA_getPlugins(\n    './libraries/export/',\n    array(\n        'export_type' => $export_type,\n        'single_table' => isset($single_table)));\n\n// Backward compatbility\n$type = $what;\n\n// Check export type\nif (! isset($export_list[$type])) {\n    die(__('Bad type!'));\n}\n\n/**\n * valid compression methods\n */\n$compression_methods = array(\n    'zip',\n    'gzip',\n    'bzip2',\n);\n\n/**\n * init and variable checking\n */\n$compression = false;\n$onserver = false;\n$save_on_server = false;\n$buffer_needed = false;\n\n// Is it a quick or custom export?\nif ($_REQUEST['quick_or_custom'] == 'quick') {\n    $quick_export = true;\n} else {\n    $quick_export = false;\n}\n\nif ($_REQUEST['output_format'] == 'astext') {\n    $asfile = false;\n} else {\n    $asfile = true;\n    if (in_array($_REQUEST['compression'], $compression_methods)) {\n        $compression = $_REQUEST['compression'];\n        $buffer_needed = true;\n    }\n    if (($quick_export && !empty($_REQUEST['quick_export_onserver'])) || (!$quick_export && !empty($_REQUEST['onserver']))) {\n        if ($quick_export) {\n            $onserver = $_REQUEST['quick_export_onserver'];\n        } else {\n            $onserver = $_REQUEST['onserver'];\n        }\n        // Will we save dump on server?\n        $save_on_server = ! empty($cfg['SaveDir']) && $onserver;\n    }\n}\n\n// Does export require to be into file?\nif (isset($export_list[$type]['force_file']) && ! $asfile) {\n    $message = PMA_Message::error(__('Selected export type has to be saved in file!'));\n    include_once './libraries/header.inc.php';\n    if ($export_type == 'server') {\n        $active_page = 'server_export.php';\n        include './server_export.php';\n    } elseif ($export_type == 'database') {\n        $active_page = 'db_export.php';\n        include './db_export.php';\n    } else {\n        $active_page = 'tbl_export.php';\n        include './tbl_export.php';\n    }\n    exit();\n}\n\n// Generate error url and check for needed variables\nif ($export_type == 'server') {\n    $err_url = 'server_export.php?' . PMA_generate_common_url();\n} elseif ($export_type == 'database' && strlen($db)) {\n    $err_url = 'db_export.php?' . PMA_generate_common_url($db);\n    // Check if we have something to export\n    if (isset($table_select)) {\n        $tables = $table_select;\n    } else {\n        $tables = array();\n    }\n} elseif ($export_type == 'table' && strlen($db) && strlen($table)) {\n    $err_url = 'tbl_export.php?' . PMA_generate_common_url($db, $table);\n} else {\n    die(__('Bad parameters!'));\n}\n\n// Get the functions specific to the export type\nrequire './libraries/export/' . PMA_securePath($type) . '.php';\n\n/**\n * Increase time limit for script execution and initializes some variables\n */\n@set_time_limit($cfg['ExecTimeLimit']);\nif (!empty($cfg['MemoryLimit'])) {\n    @ini_set('memory_limit', $cfg['MemoryLimit']);\n}\n\n// Start with empty buffer\n$dump_buffer = '';\n$dump_buffer_len = 0;\n\n// We send fake headers to avoid browser timeout when buffering\n$time_start = time();\n\n\n/**\n * Output handler for all exports, if needed buffering, it stores data into\n * $dump_buffer, otherwise it prints thems out.\n *\n * @param string  $line  the insert statement\n * @return  bool    Whether output succeeded\n */\nfunction PMA_exportOutputHandler($line)\n{\n    global $time_start, $dump_buffer, $dump_buffer_len, $save_filename;\n\n    // Kanji encoding convert feature\n    if ($GLOBALS['output_kanji_conversion']) {\n        $line = PMA_kanji_str_conv($line, $GLOBALS['knjenc'], isset($GLOBALS['xkana']) ? $GLOBALS['xkana'] : '');\n    }\n    // If we have to buffer data, we will perform everything at once at the end\n    if ($GLOBALS['buffer_needed']) {\n\n        $dump_buffer .= $line;\n        if ($GLOBALS['onfly_compression']) {\n\n            $dump_buffer_len += strlen($line);\n\n            if ($dump_buffer_len > $GLOBALS['memory_limit']) {\n                if ($GLOBALS['output_charset_conversion']) {\n                    $dump_buffer = PMA_convert_string('utf-8', $GLOBALS['charset_of_file'], $dump_buffer);\n                }\n                // as bzipped\n                if ($GLOBALS['compression'] == 'bzip2'  && @function_exists('bzcompress')) {\n                    $dump_buffer = bzcompress($dump_buffer);\n                } elseif ($GLOBALS['compression'] == 'gzip' && @function_exists('gzencode')) {\n                    // as a gzipped file\n                    // without the optional parameter level because it bug\n                    $dump_buffer = gzencode($dump_buffer);\n                }\n                if ($GLOBALS['save_on_server']) {\n                    $write_result = @fwrite($GLOBALS['file_handle'], $dump_buffer);\n                    if (!$write_result || ($write_result != strlen($dump_buffer))) {\n                        $GLOBALS['message'] = PMA_Message::error(__('Insufficient space to save the file %s.'));\n                        $GLOBALS['message']->addParam($save_filename);\n                        return false;\n                    }\n                } else {\n                    echo $dump_buffer;\n                }\n                $dump_buffer = '';\n                $dump_buffer_len = 0;\n            }\n        } else {\n            $time_now = time();\n            if ($time_start >= $time_now + 30) {\n                $time_start = $time_now;\n                header('X-pmaPing: Pong');\n            } // end if\n        }\n    } else {\n        if ($GLOBALS['asfile']) {\n            if ($GLOBALS['output_charset_conversion']) {\n                $line = PMA_convert_string('utf-8', $GLOBALS['charset_of_file'], $line);\n            }\n            if ($GLOBALS['save_on_server'] && strlen($line) > 0) {\n                $write_result = @fwrite($GLOBALS['file_handle'], $line);\n                if (!$write_result || ($write_result != strlen($line))) {\n                    $GLOBALS['message'] = PMA_Message::error(__('Insufficient space to save the file %s.'));\n                    $GLOBALS['message']->addParam($save_filename);\n                    return false;\n                }\n                $time_now = time();\n                if ($time_start >= $time_now + 30) {\n                    $time_start = $time_now;\n                    header('X-pmaPing: Pong');\n                } // end if\n            } else {\n                // We export as file - output normally\n                echo $line;\n            }\n        } else {\n            // We export as html - replace special chars\n            echo htmlspecialchars($line);\n        }\n    }\n    return true;\n} // end of the 'PMA_exportOutputHandler()' function\n\n// Defines the default <CR><LF> format. For SQL always use \\n as MySQL wants this on all platforms.\nif ($what == 'sql') {\n    $crlf = \"\\n\";\n} else {\n    $crlf = PMA_whichCrlf();\n}\n\n$output_kanji_conversion = function_exists('PMA_kanji_str_conv') && $type != 'xls';\n\n// Do we need to convert charset?\n$output_charset_conversion = $asfile && $GLOBALS['PMA_recoding_engine'] != PMA_CHARSET_NONE\n    && isset($charset_of_file) && $charset_of_file != 'utf-8'\n    && $type != 'xls';\n\n// Use on the fly compression?\n$onfly_compression = $GLOBALS['cfg']['CompressOnFly'] && ($compression == 'gzip' || $compression == 'bzip2');\nif ($onfly_compression) {\n    $memory_limit = trim(@ini_get('memory_limit'));\n    // 2 MB as default\n    if (empty($memory_limit)) {\n        $memory_limit = 2 * 1024 * 1024;\n    }\n\n    if (strtolower(substr($memory_limit, -1)) == 'm') {\n        $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024;\n    } elseif (strtolower(substr($memory_limit, -1)) == 'k') {\n        $memory_limit = (int)substr($memory_limit, 0, -1) * 1024;\n    } elseif (strtolower(substr($memory_limit, -1)) == 'g') {\n        $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024 * 1024;\n    } else {\n        $memory_limit = (int)$memory_limit;\n    }\n\n    // Some of memory is needed for other thins and as treshold.\n    // Nijel: During export I had allocated (see memory_get_usage function)\n    //        approx 1.2MB so this comes from that.\n    if ($memory_limit > 1500000) {\n        $memory_limit -= 1500000;\n    }\n\n    // Some memory is needed for compression, assume 1/3\n    $memory_limit /= 8;\n}\n\n// Generate filename and mime type if needed\nif ($asfile) {\n    $pma_uri_parts = parse_url($cfg['PmaAbsoluteUri']);\n    if ($export_type == 'server') {\n        if (isset($remember_template)) {\n            $GLOBALS['PMA_Config']->setUserValue('pma_server_filename_template',\n                'Export/file_template_server', $filename_template);\n        }\n    } elseif ($export_type == 'database') {\n        if (isset($remember_template)) {\n            $GLOBALS['PMA_Config']->setUserValue('pma_db_filename_template',\n                'Export/file_template_database', $filename_template);\n        }\n    } else {\n        if (isset($remember_template)) {\n            $GLOBALS['PMA_Config']->setUserValue('pma_table_filename_template',\n                'Export/file_template_table', $filename_template);\n        }\n    }\n    // remove dots in template to avoid a remote code execution vulnerability\n    $filename_template = str_replace('.', '', $filename_template);\n    $filename = PMA_expandUserString($filename_template);\n    $filename = PMA_sanitize_filename($filename);\n\n    // Grab basic dump extension and mime type\n    // Check if the user already added extension; get the substring where the extension would be if it was included\n    $extension_start_pos = strlen($filename) - strlen($export_list[$type]['extension']) - 1;\n    $user_extension = substr($filename, $extension_start_pos, strlen($filename));\n    $required_extension = \".\" . $export_list[$type]['extension'];\n    if (strtolower($user_extension) != $required_extension) {\n        $filename  .= $required_extension;\n    }\n    $mime_type  = $export_list[$type]['mime_type'];\n\n    // If dump is going to be compressed, set correct mime_type and add\n    // compression to extension\n    if ($compression == 'bzip2') {\n        $filename  .= '.bz2';\n        $mime_type = 'application/x-bzip2';\n    } elseif ($compression == 'gzip') {\n        $filename  .= '.gz';\n        $mime_type = 'application/x-gzip';\n    } elseif ($compression == 'zip') {\n        $filename  .= '.zip';\n        $mime_type = 'application/zip';\n    }\n}\n\n// Open file on server if needed\nif ($save_on_server) {\n    $save_filename = PMA_userDir($cfg['SaveDir']) . preg_replace('@[/\\\\\\\\]@', '_', $filename);\n    unset($message);\n    if (file_exists($save_filename) && ((!$quick_export && empty($onserverover)) || ($quick_export && $_REQUEST['quick_export_onserverover'] != 'saveitover'))) {\n        $message = PMA_Message::error(__('File %s already exists on server, change filename or check overwrite option.'));\n        $message->addParam($save_filename);\n    } else {\n        if (is_file($save_filename) && !is_writable($save_filename)) {\n            $message = PMA_Message::error(__('The web server does not have permission to save the file %s.'));\n            $message->addParam($save_filename);\n        } else {\n            if (!$file_handle = @fopen($save_filename, 'w')) {\n                $message = PMA_Message::error(__('The web server does not have permission to save the file %s.'));\n                $message->addParam($save_filename);\n            }\n        }\n    }\n    if (isset($message)) {\n        include_once './libraries/header.inc.php';\n        if ($export_type == 'server') {\n            $active_page = 'server_export.php';\n            include './server_export.php';\n        } elseif ($export_type == 'database') {\n            $active_page = 'db_export.php';\n            include './db_export.php';\n        } else {\n            $active_page = 'tbl_export.php';\n            include './tbl_export.php';\n        }\n        exit();\n    }\n}\n\n/**\n * Send headers depending on whether the user chose to download a dump file\n * or not\n */\nif (!$save_on_server) {\n    if ($asfile) {\n        // Download\n        // (avoid rewriting data containing HTML with anchors and forms;\n        // this was reported to happen under Plesk)\n        @ini_set('url_rewriter.tags', '');\n        $filename = PMA_sanitize_filename($filename);\n\n        PMA_download_header($filename, $mime_type);\n    } else {\n        // HTML\n        if ($export_type == 'database') {\n            $num_tables = count($tables);\n            if ($num_tables == 0) {\n                $message = PMA_Message::error(__('No tables found in database.'));\n                include_once './libraries/header.inc.php';\n                $active_page = 'db_export.php';\n                include './db_export.php';\n                exit();\n            }\n        }\n        $backup_cfgServer = $cfg['Server'];\n        include_once './libraries/header.inc.php';\n        $cfg['Server'] = $backup_cfgServer;\n        unset($backup_cfgServer);\n        echo \"\\n\" . '<div align=\"' . $cell_align_left . '\">' . \"\\n\";\n        //echo '    <pre>' . \"\\n\";\n\n        /**\n         * Displays a back button with all the $_REQUEST data in the URL (store in a variable to also display after the textarea)\n         */\n         $back_button = '<p>[ <a href=\"';\n        if ($export_type == 'server') {\n           $back_button .= 'server_export.php?' . PMA_generate_common_url();\n         } elseif ($export_type == 'database') {\n            $back_button .= 'db_export.php?' . PMA_generate_common_url($db);\n        } else {\n            $back_button .= 'tbl_export.php?' . PMA_generate_common_url($db, $table);\n        }\n\n        // Convert the multiple select elements from an array to a string\n        if ($export_type == 'server' && isset($_REQUEST['db_select'])) {\n            $_REQUEST['db_select'] = implode(\",\", $_REQUEST['db_select']);\n        } elseif ($export_type == 'database' && isset($_REQUEST['table_select'])) {\n            $_REQUEST['table_select'] = implode(\",\", $_REQUEST['table_select']);\n        }\n\n        foreach ($_REQUEST as $name => $value) {\n            $back_button .= '&' . urlencode($name) . '=' . urlencode($value);\n        }\n        $back_button .= '&repopulate=1\">Back</a> ]</p>';\n\n        echo $back_button;\n        echo '    <form name=\"nofunction\">' . \"\\n\"\n           // remove auto-select for now: there is no way to select\n           // only a part of the text; anyway, it should obey\n           // $cfg['TextareaAutoSelect']\n           //. '        <textarea name=\"sqldump\" cols=\"50\" rows=\"30\" onclick=\"this.select();\" id=\"textSQLDUMP\" wrap=\"OFF\">' . \"\\n\";\n           . '        <textarea name=\"sqldump\" cols=\"50\" rows=\"30\" id=\"textSQLDUMP\" wrap=\"OFF\">' . \"\\n\";\n    } // end download\n}\n\n// Fake loop just to allow skip of remain of this code by break, I'd really\n// need exceptions here :-)\ndo {\n\n    // Add possibly some comments to export\n    if (!PMA_exportHeader()) {\n        break;\n    }\n\n    // Will we need relation & co. setup?\n    $do_relation = isset($GLOBALS[$what . '_relation']);\n    $do_comments = isset($GLOBALS[$what . '_include_comments']);\n    $do_mime     = isset($GLOBALS[$what . '_mime']);\n    if ($do_relation || $do_comments || $do_mime) {\n        $cfgRelation = PMA_getRelationsParam();\n    }\n    if ($do_mime) {\n        include_once './libraries/transformations.lib.php';\n    }\n\n    // Include dates in export?\n    $do_dates   = isset($GLOBALS[$what . '_dates']);\n\n    /**\n     * Builds the dump\n     */\n    // Gets the number of tables if a dump of a database has been required\n    if ($export_type == 'server') {\n        if (isset($db_select)) {\n            $tmp_select = implode($db_select, '|');\n            $tmp_select = '|' . $tmp_select . '|';\n        }\n        // Walk over databases\n        foreach ($GLOBALS['pma']->databases as $current_db) {\n            if ((isset($tmp_select) && strpos(' ' . $tmp_select, '|' . $current_db . '|'))\n                || ! isset($tmp_select)) {\n                if (!PMA_exportDBHeader($current_db)) {\n                    break 2;\n                }\n                if (!PMA_exportDBCreate($current_db)) {\n                    break 2;\n                }\n                if (function_exists('PMA_exportRoutines') && strpos($GLOBALS['sql_structure_or_data'], 'structure') !== false && isset($GLOBALS['sql_procedure_function'])) {\n                    PMA_exportRoutines($current_db);\n                }\n\n                $tables = PMA_DBI_get_tables($current_db);\n                $views = array();\n                foreach ($tables as $table) {\n                    // if this is a view, collect it for later; views must be exported\n                    // after the tables\n                    $is_view = PMA_Table::isView($current_db, $table);\n                    if ($is_view) {\n                        $views[] = $table;\n                    }\n                    if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                        // for a view, export a stand-in definition of the table\n                        // to resolve view dependencies\n                        if (!PMA_exportStructure($current_db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, $is_view ? 'stand_in' : 'create_table', $export_type)) {\n                            break 3;\n                        }\n                    }\n                    // if this is a view or a merge table, don't export data\n                    if (($GLOBALS[$what . '_structure_or_data'] == 'data' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') && !($is_view || PMA_Table::isMerge($current_db, $table))) {\n                        $local_query  = 'SELECT * FROM ' . PMA_backquote($current_db) . '.' . PMA_backquote($table);\n                        if (!PMA_exportData($current_db, $table, $crlf, $err_url, $local_query)) {\n                            break 3;\n                        }\n                    }\n                    // now export the triggers (needs to be done after the data because\n                    // triggers can modify already imported tables)\n                    if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                        if (!PMA_exportStructure($current_db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'triggers', $export_type)) {\n                            break 2;\n                        }\n                    }\n                }\n                foreach ($views as $view) {\n                    // no data export for a view\n                    if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                        if (!PMA_exportStructure($current_db, $view, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'create_view', $export_type)) {\n                            break 3;\n                        }\n                    }\n                }\n                if (!PMA_exportDBFooter($current_db)) {\n                    break 2;\n                }\n            }\n        }\n    } elseif ($export_type == 'database') {\n        if (!PMA_exportDBHeader($db)) {\n            break;\n        }\n\n        if (function_exists('PMA_exportRoutines') && strpos($GLOBALS['sql_structure_or_data'], 'structure') !== false && isset($GLOBALS['sql_procedure_function'])) {\n            PMA_exportRoutines($db);\n        }\n\n        $i = 0;\n        $views = array();\n        // $tables contains the choices from the user (via $table_select)\n        foreach ($tables as $table) {\n            // if this is a view, collect it for later; views must be exported after\n            // the tables\n            $is_view = PMA_Table::isView($db, $table);\n            if ($is_view) {\n                $views[] = $table;\n            }\n            if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                // for a view, export a stand-in definition of the table\n                // to resolve view dependencies\n                if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, $is_view ? 'stand_in' : 'create_table', $export_type)) {\n                    break 2;\n                }\n            }\n            // if this is a view or a merge table, don't export data\n            if (($GLOBALS[$what . '_structure_or_data'] == 'data' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') && !($is_view || PMA_Table::isMerge($db, $table))) {\n                $local_query  = 'SELECT * FROM ' . PMA_backquote($db) . '.' . PMA_backquote($table);\n                if (!PMA_exportData($db, $table, $crlf, $err_url, $local_query)) {\n                    break 2;\n                }\n            }\n            // now export the triggers (needs to be done after the data because\n            // triggers can modify already imported tables)\n            if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'triggers', $export_type)) {\n                    break 2;\n                }\n            }\n        }\n        foreach ($views as $view) {\n            // no data export for a view\n            if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                if (!PMA_exportStructure($db, $view, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'create_view', $export_type)) {\n                    break 2;\n                }\n            }\n        }\n\n        if (!PMA_exportDBFooter($db)) {\n            break;\n        }\n    } else {\n        if (!PMA_exportDBHeader($db)) {\n            break;\n        }\n        // We export just one table\n        // $allrows comes from the form when \"Dump all rows\" has been selected\n        if ($allrows == '0' && $limit_to > 0 && $limit_from >= 0) {\n            $add_query  = ' LIMIT '\n                        . (($limit_from > 0) ? $limit_from . ', ' : '')\n                        . $limit_to;\n        } else {\n            $add_query  = '';\n        }\n\n        $is_view = PMA_Table::isView($db, $table);\n        if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n            if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, $is_view ? 'create_view' : 'create_table', $export_type)) {\n                break;\n            }\n        }\n        // If this is an export of a single view, we have to export data;\n        // for example, a PDF report\n        // if it is a merge table, no data is exported\n        if (($GLOBALS[$what . '_structure_or_data'] == 'data' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') && ! PMA_Table::isMerge($db, $table)) {\n            if (!empty($sql_query)) {\n                // only preg_replace if needed\n                if (!empty($add_query)) {\n                    // remove trailing semicolon before adding a LIMIT\n                    $sql_query = preg_replace('%;\\s*$%', '', $sql_query);\n                }\n                $local_query = $sql_query . $add_query;\n                PMA_DBI_select_db($db);\n            } else {\n                $local_query  = 'SELECT * FROM ' . PMA_backquote($db) . '.' . PMA_backquote($table) . $add_query;\n            }\n            if (!PMA_exportData($db, $table, $crlf, $err_url, $local_query)) {\n                break;\n            }\n        }\n        // now export the triggers (needs to be done after the data because\n        // triggers can modify already imported tables)\n        if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n            if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'triggers', $export_type)) {\n                break 2;\n            }\n        }\n        if (!PMA_exportDBFooter($db)) {\n            break;\n        }\n    }\n    if (!PMA_exportFooter()) {\n        break;\n    }\n\n} while (false);\n// End of fake loop\n\nif ($save_on_server && isset($message)) {\n    include_once './libraries/header.inc.php';\n    if ($export_type == 'server') {\n        $active_page = 'server_export.php';\n        include './server_export.php';\n    } elseif ($export_type == 'database') {\n        $active_page = 'db_export.php';\n        include './db_export.php';\n    } else {\n        $active_page = 'tbl_export.php';\n        include './tbl_export.php';\n    }\n    exit();\n}\n\n/**\n * Send the dump as a file...\n */\nif (!empty($asfile)) {\n    // Convert the charset if required.\n    if ($output_charset_conversion) {\n        $dump_buffer = PMA_convert_string('utf-8', $GLOBALS['charset_of_file'], $dump_buffer);\n    }\n\n    // Do the compression\n    // 1. as a zipped file\n    if ($compression == 'zip') {\n        if (@function_exists('gzcompress')) {\n            $zipfile = new zipfile();\n            $zipfile -> addFile($dump_buffer, substr($filename, 0, -4));\n            $dump_buffer = $zipfile -> file();\n        }\n    } elseif ($compression == 'bzip2') {\n        // 2. as a bzipped file\n        if (@function_exists('bzcompress')) {\n            $dump_buffer = bzcompress($dump_buffer);\n        }\n    } elseif ($compression == 'gzip') {\n        // 3. as a gzipped file\n        if (@function_exists('gzencode') \n            && ! @ini_get('zlib.output_compression')\n            // Here, we detect Apache's mod_deflate so we bet that\n            // this module is active for this instance of phpMyAdmin\n            // and therefore, will gzip encode the content\n            && ! (function_exists('apache_get_modules')\n                && in_array('mod_deflate', apache_get_modules()))\n            ) {\n            // without the optional parameter level because it bug\n            $dump_buffer = gzencode($dump_buffer);\n        }\n    }\n\n    /* If ve saved on server, we have to close file now */\n    if ($save_on_server) {\n        $write_result = @fwrite($file_handle, $dump_buffer);\n        fclose($file_handle);\n        if (strlen($dump_buffer) !=0 && (!$write_result || ($write_result != strlen($dump_buffer)))) {\n            $message = new PMA_Message(__('Insufficient space to save the file %s.'), PMA_Message::ERROR, $save_filename);\n        } else {\n            $message = new PMA_Message(__('Dump has been saved to file %s.'), PMA_Message::SUCCESS, $save_filename);\n        }\n\n        include_once './libraries/header.inc.php';\n        if ($export_type == 'server') {\n            $active_page = 'server_export.php';\n            include_once './server_export.php';\n        } elseif ($export_type == 'database') {\n            $active_page = 'db_export.php';\n            include_once './db_export.php';\n        } else {\n            $active_page = 'tbl_export.php';\n            include_once './tbl_export.php';\n        }\n        exit();\n    } else {\n        echo $dump_buffer;\n    }\n} else {\n    /**\n     * Displays the dump...\n     *\n     * Close the html tags and add the footers if dump is displayed on screen\n     */\n    echo '</textarea>' . \"\\n\"\n       . '    </form>' . \"\\n\";\n    echo $back_button;\n\n    echo \"\\n\";\n    echo '</div>' . \"\\n\";\n    echo \"\\n\";\n?>\n<script type=\"text/javascript\">\n//<![CDATA[\n    var bodyWidth=null; var bodyHeight=null;\n    if (document.getElementById('textSQLDUMP')) {\n        bodyWidth  = self.innerWidth;\n        bodyHeight = self.innerHeight;\n        if (!bodyWidth && !bodyHeight) {\n            if (document.compatMode && document.compatMode == \"BackCompat\") {\n                bodyWidth  = document.body.clientWidth;\n                bodyHeight = document.body.clientHeight;\n            } else if (document.compatMode && document.compatMode == \"CSS1Compat\") {\n                bodyWidth  = document.documentElement.clientWidth;\n                bodyHeight = document.documentElement.clientHeight;\n            }\n        }\n        document.getElementById('textSQLDUMP').style.width=(bodyWidth-50) + 'px';\n        document.getElementById('textSQLDUMP').style.height=(bodyHeight-100) + 'px';\n    }\n//]]>\n</script>\n<?php\n    include './libraries/footer.inc.php';\n} // end if\n?>\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * This is in a separate script because it's called from a number of scripts\n *\n * @package PhpMyAdmin\n */\n\n/**\n * Checks whether given link is valid\n *\n * @param string $url URL to check\n * @return boolean True if string can be used as link\n */\nfunction PMA_checkLink($url)\n{\n    $valid_starts = array(\n        'http://',\n        'https://',\n        './url.php?url=http%3A%2F%2F',\n        './url.php?url=https%3A%2F%2F',\n    );\n    if (defined('PMA_SETUP')) {\n        $valid_starts[] = '../Documentation.html';\n        $valid_starts[] = '?page=form&';\n    } else {\n        $valid_starts[] = './Documentation.html';\n    }\n    foreach ($valid_starts as $val) {\n        if (substr($url, 0, strlen($val)) == $val) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Callback function for replacing [a@link@target] links in bb code.\n *\n * @param array $found Array of preg matches\n * @return string Replaced string\n */\nfunction PMA_replaceBBLink($found)\n{\n    /* Check for valid link */\n    if (! PMA_checkLink($found[1])) {\n        return $found[0];\n    }\n    /* a-z and _ allowed in target */\n    if (! empty($found[3]) && preg_match('/[^a-z_]+/i', $found[3])) {\n        return $found[0];\n    }\n\n    /* Construct target */\n    $target = '';\n    if (! empty($found[3])) {\n        $target = ' target=\"' . $found[3] . '\"';\n    }\n\n    /* Construct url */\n    if (substr($found[1], 0, 4) == 'http') {\n        $url = PMA_linkURL($found[1]);\n    } else {\n        $url = $found[1];\n    }\n\n    return '<a href=\"' . $url . '\"' . $target . '>';\n}\n\n/**\n * Sanitizes $message, taking into account our special codes\n * for formatting.\n *\n * If you want to include result in element attribute, you should escape it.\n *\n * Examples:\n *\n * <p><?php echo PMA_sanitize($foo); ?></p>\n *\n * <a title=\"<?php echo PMA_sanitize($foo, true); ?>\">bar</a>\n *\n * @param string  $message the message\n * @param boolean $escape  whether to escape html in result\n * @param boolean $safe    whether string is safe (can keep < and > chars)\n * @return  string   the sanitized message\n */\nfunction PMA_sanitize($message, $escape = false, $safe = false)\n{\n    if (!$safe) {\n        $message = strtr($message, array('<' => '&lt;', '>' => '&gt;'));\n    }\n    /* Interpret bb code */\n    $replace_pairs = array(\n        '[i]'       => '<em>',      // deprecated by em\n        '[/i]'      => '</em>',     // deprecated by em\n        '[em]'      => '<em>',\n        '[/em]'     => '</em>',\n        '[b]'       => '<strong>',  // deprecated by strong\n        '[/b]'      => '</strong>', // deprecated by strong\n        '[strong]'  => '<strong>',\n        '[/strong]' => '</strong>',\n        '[tt]'      => '<code>',    // deprecated by CODE or KBD\n        '[/tt]'     => '</code>',   // deprecated by CODE or KBD\n        '[code]'    => '<code>',\n        '[/code]'   => '</code>',\n        '[kbd]'     => '<kbd>',\n        '[/kbd]'    => '</kbd>',\n        '[br]'      => '<br />',\n        '[/a]'      => '</a>',\n        '[sup]'      => '<sup>',\n        '[/sup]'      => '</sup>',\n    );\n    /* Adjust links for setup, which lives in subfolder */\n    if (defined('PMA_SETUP')) {\n        $replace_pairs['[a@Documentation.html'] = '[a@../Documentation.html';\n    } else {\n        $replace_pairs['[a@Documentation.html'] = '[a@./Documentation.html';\n    }\n    $message = strtr($message, $replace_pairs);\n\n    /* Match links in bb code ([a@url@target], where @target is options) */\n    $pattern = '/\\[a@([^]\"@]*)(@([^]\"]*))?\\]/';\n\n    /* Find and replace all links */\n    $message = preg_replace_callback($pattern, 'PMA_replaceBBLink', $message);\n\n    /* Possibly escape result */\n    if ($escape) {\n        $message = htmlspecialchars($message);\n    }\n\n    return $message;\n}\n\n\n/**\n * Sanitize a filename by removing anything besides A-Za-z0-9_.-\n *\n * Intended usecase:\n *    When using a filename in a Content-Disposition header the value should not contain ; or \"\n *\n * @param   string  The filename\n *\n * @return  string  the sanitized filename\n *\n */\nfunction PMA_sanitize_filename($filename) {\n    $filename = preg_replace('/[^A-Za-z0-9_.-]/', '_', $filename);\n    return $filename;\n}\n\n?>\n"], "fixing_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Main export hanling code\n * @package PhpMyAdmin\n */\n\n/**\n * Get the variables sent or posted to this script and a core script\n */\nrequire_once './libraries/common.inc.php';\nrequire_once './libraries/zip.lib.php';\nrequire_once './libraries/plugin_interface.lib.php';\n\nPMA_checkParameters(array('what', 'export_type'));\n\n// Scan plugins\n$export_list = PMA_getPlugins(\n    './libraries/export/',\n    array(\n        'export_type' => $export_type,\n        'single_table' => isset($single_table)));\n\n// Backward compatbility\n$type = $what;\n\n// Check export type\nif (! isset($export_list[$type])) {\n    die(__('Bad type!'));\n}\n\n/**\n * valid compression methods\n */\n$compression_methods = array(\n    'zip',\n    'gzip',\n    'bzip2',\n);\n\n/**\n * init and variable checking\n */\n$compression = false;\n$onserver = false;\n$save_on_server = false;\n$buffer_needed = false;\n\n// Is it a quick or custom export?\nif ($_REQUEST['quick_or_custom'] == 'quick') {\n    $quick_export = true;\n} else {\n    $quick_export = false;\n}\n\nif ($_REQUEST['output_format'] == 'astext') {\n    $asfile = false;\n} else {\n    $asfile = true;\n    if (in_array($_REQUEST['compression'], $compression_methods)) {\n        $compression = $_REQUEST['compression'];\n        $buffer_needed = true;\n    }\n    if (($quick_export && !empty($_REQUEST['quick_export_onserver'])) || (!$quick_export && !empty($_REQUEST['onserver']))) {\n        if ($quick_export) {\n            $onserver = $_REQUEST['quick_export_onserver'];\n        } else {\n            $onserver = $_REQUEST['onserver'];\n        }\n        // Will we save dump on server?\n        $save_on_server = ! empty($cfg['SaveDir']) && $onserver;\n    }\n}\n\n// Does export require to be into file?\nif (isset($export_list[$type]['force_file']) && ! $asfile) {\n    $message = PMA_Message::error(__('Selected export type has to be saved in file!'));\n    include_once './libraries/header.inc.php';\n    if ($export_type == 'server') {\n        $active_page = 'server_export.php';\n        include './server_export.php';\n    } elseif ($export_type == 'database') {\n        $active_page = 'db_export.php';\n        include './db_export.php';\n    } else {\n        $active_page = 'tbl_export.php';\n        include './tbl_export.php';\n    }\n    exit();\n}\n\n// Generate error url and check for needed variables\nif ($export_type == 'server') {\n    $err_url = 'server_export.php?' . PMA_generate_common_url();\n} elseif ($export_type == 'database' && strlen($db)) {\n    $err_url = 'db_export.php?' . PMA_generate_common_url($db);\n    // Check if we have something to export\n    if (isset($table_select)) {\n        $tables = $table_select;\n    } else {\n        $tables = array();\n    }\n} elseif ($export_type == 'table' && strlen($db) && strlen($table)) {\n    $err_url = 'tbl_export.php?' . PMA_generate_common_url($db, $table);\n} else {\n    die(__('Bad parameters!'));\n}\n\n// Get the functions specific to the export type\nrequire './libraries/export/' . PMA_securePath($type) . '.php';\n\n/**\n * Increase time limit for script execution and initializes some variables\n */\n@set_time_limit($cfg['ExecTimeLimit']);\nif (!empty($cfg['MemoryLimit'])) {\n    @ini_set('memory_limit', $cfg['MemoryLimit']);\n}\n\n// Start with empty buffer\n$dump_buffer = '';\n$dump_buffer_len = 0;\n\n// We send fake headers to avoid browser timeout when buffering\n$time_start = time();\n\n\n/**\n * Output handler for all exports, if needed buffering, it stores data into\n * $dump_buffer, otherwise it prints thems out.\n *\n * @param string  $line  the insert statement\n * @return  bool    Whether output succeeded\n */\nfunction PMA_exportOutputHandler($line)\n{\n    global $time_start, $dump_buffer, $dump_buffer_len, $save_filename;\n\n    // Kanji encoding convert feature\n    if ($GLOBALS['output_kanji_conversion']) {\n        $line = PMA_kanji_str_conv($line, $GLOBALS['knjenc'], isset($GLOBALS['xkana']) ? $GLOBALS['xkana'] : '');\n    }\n    // If we have to buffer data, we will perform everything at once at the end\n    if ($GLOBALS['buffer_needed']) {\n\n        $dump_buffer .= $line;\n        if ($GLOBALS['onfly_compression']) {\n\n            $dump_buffer_len += strlen($line);\n\n            if ($dump_buffer_len > $GLOBALS['memory_limit']) {\n                if ($GLOBALS['output_charset_conversion']) {\n                    $dump_buffer = PMA_convert_string('utf-8', $GLOBALS['charset_of_file'], $dump_buffer);\n                }\n                // as bzipped\n                if ($GLOBALS['compression'] == 'bzip2'  && @function_exists('bzcompress')) {\n                    $dump_buffer = bzcompress($dump_buffer);\n                } elseif ($GLOBALS['compression'] == 'gzip' && @function_exists('gzencode')) {\n                    // as a gzipped file\n                    // without the optional parameter level because it bug\n                    $dump_buffer = gzencode($dump_buffer);\n                }\n                if ($GLOBALS['save_on_server']) {\n                    $write_result = @fwrite($GLOBALS['file_handle'], $dump_buffer);\n                    if (!$write_result || ($write_result != strlen($dump_buffer))) {\n                        $GLOBALS['message'] = PMA_Message::error(__('Insufficient space to save the file %s.'));\n                        $GLOBALS['message']->addParam($save_filename);\n                        return false;\n                    }\n                } else {\n                    echo $dump_buffer;\n                }\n                $dump_buffer = '';\n                $dump_buffer_len = 0;\n            }\n        } else {\n            $time_now = time();\n            if ($time_start >= $time_now + 30) {\n                $time_start = $time_now;\n                header('X-pmaPing: Pong');\n            } // end if\n        }\n    } else {\n        if ($GLOBALS['asfile']) {\n            if ($GLOBALS['output_charset_conversion']) {\n                $line = PMA_convert_string('utf-8', $GLOBALS['charset_of_file'], $line);\n            }\n            if ($GLOBALS['save_on_server'] && strlen($line) > 0) {\n                $write_result = @fwrite($GLOBALS['file_handle'], $line);\n                if (!$write_result || ($write_result != strlen($line))) {\n                    $GLOBALS['message'] = PMA_Message::error(__('Insufficient space to save the file %s.'));\n                    $GLOBALS['message']->addParam($save_filename);\n                    return false;\n                }\n                $time_now = time();\n                if ($time_start >= $time_now + 30) {\n                    $time_start = $time_now;\n                    header('X-pmaPing: Pong');\n                } // end if\n            } else {\n                // We export as file - output normally\n                echo $line;\n            }\n        } else {\n            // We export as html - replace special chars\n            echo htmlspecialchars($line);\n        }\n    }\n    return true;\n} // end of the 'PMA_exportOutputHandler()' function\n\n// Defines the default <CR><LF> format. For SQL always use \\n as MySQL wants this on all platforms.\nif ($what == 'sql') {\n    $crlf = \"\\n\";\n} else {\n    $crlf = PMA_whichCrlf();\n}\n\n$output_kanji_conversion = function_exists('PMA_kanji_str_conv') && $type != 'xls';\n\n// Do we need to convert charset?\n$output_charset_conversion = $asfile && $GLOBALS['PMA_recoding_engine'] != PMA_CHARSET_NONE\n    && isset($charset_of_file) && $charset_of_file != 'utf-8'\n    && $type != 'xls';\n\n// Use on the fly compression?\n$onfly_compression = $GLOBALS['cfg']['CompressOnFly'] && ($compression == 'gzip' || $compression == 'bzip2');\nif ($onfly_compression) {\n    $memory_limit = trim(@ini_get('memory_limit'));\n    // 2 MB as default\n    if (empty($memory_limit)) {\n        $memory_limit = 2 * 1024 * 1024;\n    }\n\n    if (strtolower(substr($memory_limit, -1)) == 'm') {\n        $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024;\n    } elseif (strtolower(substr($memory_limit, -1)) == 'k') {\n        $memory_limit = (int)substr($memory_limit, 0, -1) * 1024;\n    } elseif (strtolower(substr($memory_limit, -1)) == 'g') {\n        $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024 * 1024;\n    } else {\n        $memory_limit = (int)$memory_limit;\n    }\n\n    // Some of memory is needed for other thins and as treshold.\n    // Nijel: During export I had allocated (see memory_get_usage function)\n    //        approx 1.2MB so this comes from that.\n    if ($memory_limit > 1500000) {\n        $memory_limit -= 1500000;\n    }\n\n    // Some memory is needed for compression, assume 1/3\n    $memory_limit /= 8;\n}\n\n// Generate filename and mime type if needed\nif ($asfile) {\n    $pma_uri_parts = parse_url($cfg['PmaAbsoluteUri']);\n    if ($export_type == 'server') {\n        if (isset($remember_template)) {\n            $GLOBALS['PMA_Config']->setUserValue('pma_server_filename_template',\n                'Export/file_template_server', $filename_template);\n        }\n    } elseif ($export_type == 'database') {\n        if (isset($remember_template)) {\n            $GLOBALS['PMA_Config']->setUserValue('pma_db_filename_template',\n                'Export/file_template_database', $filename_template);\n        }\n    } else {\n        if (isset($remember_template)) {\n            $GLOBALS['PMA_Config']->setUserValue('pma_table_filename_template',\n                'Export/file_template_table', $filename_template);\n        }\n    }\n    $filename = PMA_expandUserString($filename_template);\n    // remove dots in filename (coming from either the template or already\n    // part of the filename) to avoid a remote code execution vulnerability\n    $filename = PMA_sanitize_filename($filename, $replaceDots = true);\n\n    // Grab basic dump extension and mime type\n    // Check if the user already added extension; get the substring where the extension would be if it was included\n    $extension_start_pos = strlen($filename) - strlen($export_list[$type]['extension']) - 1;\n    $user_extension = substr($filename, $extension_start_pos, strlen($filename));\n    $required_extension = \".\" . $export_list[$type]['extension'];\n    if (strtolower($user_extension) != $required_extension) {\n        $filename  .= $required_extension;\n    }\n    $mime_type  = $export_list[$type]['mime_type'];\n\n    // If dump is going to be compressed, set correct mime_type and add\n    // compression to extension\n    if ($compression == 'bzip2') {\n        $filename  .= '.bz2';\n        $mime_type = 'application/x-bzip2';\n    } elseif ($compression == 'gzip') {\n        $filename  .= '.gz';\n        $mime_type = 'application/x-gzip';\n    } elseif ($compression == 'zip') {\n        $filename  .= '.zip';\n        $mime_type = 'application/zip';\n    }\n}\n\n// Open file on server if needed\nif ($save_on_server) {\n    $save_filename = PMA_userDir($cfg['SaveDir']) . preg_replace('@[/\\\\\\\\]@', '_', $filename);\n    unset($message);\n    if (file_exists($save_filename) && ((!$quick_export && empty($onserverover)) || ($quick_export && $_REQUEST['quick_export_onserverover'] != 'saveitover'))) {\n        $message = PMA_Message::error(__('File %s already exists on server, change filename or check overwrite option.'));\n        $message->addParam($save_filename);\n    } else {\n        if (is_file($save_filename) && !is_writable($save_filename)) {\n            $message = PMA_Message::error(__('The web server does not have permission to save the file %s.'));\n            $message->addParam($save_filename);\n        } else {\n            if (!$file_handle = @fopen($save_filename, 'w')) {\n                $message = PMA_Message::error(__('The web server does not have permission to save the file %s.'));\n                $message->addParam($save_filename);\n            }\n        }\n    }\n    if (isset($message)) {\n        include_once './libraries/header.inc.php';\n        if ($export_type == 'server') {\n            $active_page = 'server_export.php';\n            include './server_export.php';\n        } elseif ($export_type == 'database') {\n            $active_page = 'db_export.php';\n            include './db_export.php';\n        } else {\n            $active_page = 'tbl_export.php';\n            include './tbl_export.php';\n        }\n        exit();\n    }\n}\n\n/**\n * Send headers depending on whether the user chose to download a dump file\n * or not\n */\nif (!$save_on_server) {\n    if ($asfile) {\n        // Download\n        // (avoid rewriting data containing HTML with anchors and forms;\n        // this was reported to happen under Plesk)\n        @ini_set('url_rewriter.tags', '');\n        $filename = PMA_sanitize_filename($filename);\n\n        PMA_download_header($filename, $mime_type);\n    } else {\n        // HTML\n        if ($export_type == 'database') {\n            $num_tables = count($tables);\n            if ($num_tables == 0) {\n                $message = PMA_Message::error(__('No tables found in database.'));\n                include_once './libraries/header.inc.php';\n                $active_page = 'db_export.php';\n                include './db_export.php';\n                exit();\n            }\n        }\n        $backup_cfgServer = $cfg['Server'];\n        include_once './libraries/header.inc.php';\n        $cfg['Server'] = $backup_cfgServer;\n        unset($backup_cfgServer);\n        echo \"\\n\" . '<div align=\"' . $cell_align_left . '\">' . \"\\n\";\n        //echo '    <pre>' . \"\\n\";\n\n        /**\n         * Displays a back button with all the $_REQUEST data in the URL (store in a variable to also display after the textarea)\n         */\n         $back_button = '<p>[ <a href=\"';\n        if ($export_type == 'server') {\n           $back_button .= 'server_export.php?' . PMA_generate_common_url();\n         } elseif ($export_type == 'database') {\n            $back_button .= 'db_export.php?' . PMA_generate_common_url($db);\n        } else {\n            $back_button .= 'tbl_export.php?' . PMA_generate_common_url($db, $table);\n        }\n\n        // Convert the multiple select elements from an array to a string\n        if ($export_type == 'server' && isset($_REQUEST['db_select'])) {\n            $_REQUEST['db_select'] = implode(\",\", $_REQUEST['db_select']);\n        } elseif ($export_type == 'database' && isset($_REQUEST['table_select'])) {\n            $_REQUEST['table_select'] = implode(\",\", $_REQUEST['table_select']);\n        }\n\n        foreach ($_REQUEST as $name => $value) {\n            $back_button .= '&' . urlencode($name) . '=' . urlencode($value);\n        }\n        $back_button .= '&repopulate=1\">Back</a> ]</p>';\n\n        echo $back_button;\n        echo '    <form name=\"nofunction\">' . \"\\n\"\n           // remove auto-select for now: there is no way to select\n           // only a part of the text; anyway, it should obey\n           // $cfg['TextareaAutoSelect']\n           //. '        <textarea name=\"sqldump\" cols=\"50\" rows=\"30\" onclick=\"this.select();\" id=\"textSQLDUMP\" wrap=\"OFF\">' . \"\\n\";\n           . '        <textarea name=\"sqldump\" cols=\"50\" rows=\"30\" id=\"textSQLDUMP\" wrap=\"OFF\">' . \"\\n\";\n    } // end download\n}\n\n// Fake loop just to allow skip of remain of this code by break, I'd really\n// need exceptions here :-)\ndo {\n\n    // Add possibly some comments to export\n    if (!PMA_exportHeader()) {\n        break;\n    }\n\n    // Will we need relation & co. setup?\n    $do_relation = isset($GLOBALS[$what . '_relation']);\n    $do_comments = isset($GLOBALS[$what . '_include_comments']);\n    $do_mime     = isset($GLOBALS[$what . '_mime']);\n    if ($do_relation || $do_comments || $do_mime) {\n        $cfgRelation = PMA_getRelationsParam();\n    }\n    if ($do_mime) {\n        include_once './libraries/transformations.lib.php';\n    }\n\n    // Include dates in export?\n    $do_dates   = isset($GLOBALS[$what . '_dates']);\n\n    /**\n     * Builds the dump\n     */\n    // Gets the number of tables if a dump of a database has been required\n    if ($export_type == 'server') {\n        if (isset($db_select)) {\n            $tmp_select = implode($db_select, '|');\n            $tmp_select = '|' . $tmp_select . '|';\n        }\n        // Walk over databases\n        foreach ($GLOBALS['pma']->databases as $current_db) {\n            if ((isset($tmp_select) && strpos(' ' . $tmp_select, '|' . $current_db . '|'))\n                || ! isset($tmp_select)) {\n                if (!PMA_exportDBHeader($current_db)) {\n                    break 2;\n                }\n                if (!PMA_exportDBCreate($current_db)) {\n                    break 2;\n                }\n                if (function_exists('PMA_exportRoutines') && strpos($GLOBALS['sql_structure_or_data'], 'structure') !== false && isset($GLOBALS['sql_procedure_function'])) {\n                    PMA_exportRoutines($current_db);\n                }\n\n                $tables = PMA_DBI_get_tables($current_db);\n                $views = array();\n                foreach ($tables as $table) {\n                    // if this is a view, collect it for later; views must be exported\n                    // after the tables\n                    $is_view = PMA_Table::isView($current_db, $table);\n                    if ($is_view) {\n                        $views[] = $table;\n                    }\n                    if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                        // for a view, export a stand-in definition of the table\n                        // to resolve view dependencies\n                        if (!PMA_exportStructure($current_db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, $is_view ? 'stand_in' : 'create_table', $export_type)) {\n                            break 3;\n                        }\n                    }\n                    // if this is a view or a merge table, don't export data\n                    if (($GLOBALS[$what . '_structure_or_data'] == 'data' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') && !($is_view || PMA_Table::isMerge($current_db, $table))) {\n                        $local_query  = 'SELECT * FROM ' . PMA_backquote($current_db) . '.' . PMA_backquote($table);\n                        if (!PMA_exportData($current_db, $table, $crlf, $err_url, $local_query)) {\n                            break 3;\n                        }\n                    }\n                    // now export the triggers (needs to be done after the data because\n                    // triggers can modify already imported tables)\n                    if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                        if (!PMA_exportStructure($current_db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'triggers', $export_type)) {\n                            break 2;\n                        }\n                    }\n                }\n                foreach ($views as $view) {\n                    // no data export for a view\n                    if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                        if (!PMA_exportStructure($current_db, $view, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'create_view', $export_type)) {\n                            break 3;\n                        }\n                    }\n                }\n                if (!PMA_exportDBFooter($current_db)) {\n                    break 2;\n                }\n            }\n        }\n    } elseif ($export_type == 'database') {\n        if (!PMA_exportDBHeader($db)) {\n            break;\n        }\n\n        if (function_exists('PMA_exportRoutines') && strpos($GLOBALS['sql_structure_or_data'], 'structure') !== false && isset($GLOBALS['sql_procedure_function'])) {\n            PMA_exportRoutines($db);\n        }\n\n        $i = 0;\n        $views = array();\n        // $tables contains the choices from the user (via $table_select)\n        foreach ($tables as $table) {\n            // if this is a view, collect it for later; views must be exported after\n            // the tables\n            $is_view = PMA_Table::isView($db, $table);\n            if ($is_view) {\n                $views[] = $table;\n            }\n            if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                // for a view, export a stand-in definition of the table\n                // to resolve view dependencies\n                if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, $is_view ? 'stand_in' : 'create_table', $export_type)) {\n                    break 2;\n                }\n            }\n            // if this is a view or a merge table, don't export data\n            if (($GLOBALS[$what . '_structure_or_data'] == 'data' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') && !($is_view || PMA_Table::isMerge($db, $table))) {\n                $local_query  = 'SELECT * FROM ' . PMA_backquote($db) . '.' . PMA_backquote($table);\n                if (!PMA_exportData($db, $table, $crlf, $err_url, $local_query)) {\n                    break 2;\n                }\n            }\n            // now export the triggers (needs to be done after the data because\n            // triggers can modify already imported tables)\n            if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'triggers', $export_type)) {\n                    break 2;\n                }\n            }\n        }\n        foreach ($views as $view) {\n            // no data export for a view\n            if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n                if (!PMA_exportStructure($db, $view, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'create_view', $export_type)) {\n                    break 2;\n                }\n            }\n        }\n\n        if (!PMA_exportDBFooter($db)) {\n            break;\n        }\n    } else {\n        if (!PMA_exportDBHeader($db)) {\n            break;\n        }\n        // We export just one table\n        // $allrows comes from the form when \"Dump all rows\" has been selected\n        if ($allrows == '0' && $limit_to > 0 && $limit_from >= 0) {\n            $add_query  = ' LIMIT '\n                        . (($limit_from > 0) ? $limit_from . ', ' : '')\n                        . $limit_to;\n        } else {\n            $add_query  = '';\n        }\n\n        $is_view = PMA_Table::isView($db, $table);\n        if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n            if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, $is_view ? 'create_view' : 'create_table', $export_type)) {\n                break;\n            }\n        }\n        // If this is an export of a single view, we have to export data;\n        // for example, a PDF report\n        // if it is a merge table, no data is exported\n        if (($GLOBALS[$what . '_structure_or_data'] == 'data' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') && ! PMA_Table::isMerge($db, $table)) {\n            if (!empty($sql_query)) {\n                // only preg_replace if needed\n                if (!empty($add_query)) {\n                    // remove trailing semicolon before adding a LIMIT\n                    $sql_query = preg_replace('%;\\s*$%', '', $sql_query);\n                }\n                $local_query = $sql_query . $add_query;\n                PMA_DBI_select_db($db);\n            } else {\n                $local_query  = 'SELECT * FROM ' . PMA_backquote($db) . '.' . PMA_backquote($table) . $add_query;\n            }\n            if (!PMA_exportData($db, $table, $crlf, $err_url, $local_query)) {\n                break;\n            }\n        }\n        // now export the triggers (needs to be done after the data because\n        // triggers can modify already imported tables)\n        if ($GLOBALS[$what . '_structure_or_data'] == 'structure' || $GLOBALS[$what . '_structure_or_data'] == 'structure_and_data') {\n            if (!PMA_exportStructure($db, $table, $crlf, $err_url, $do_relation, $do_comments, $do_mime, $do_dates, 'triggers', $export_type)) {\n                break 2;\n            }\n        }\n        if (!PMA_exportDBFooter($db)) {\n            break;\n        }\n    }\n    if (!PMA_exportFooter()) {\n        break;\n    }\n\n} while (false);\n// End of fake loop\n\nif ($save_on_server && isset($message)) {\n    include_once './libraries/header.inc.php';\n    if ($export_type == 'server') {\n        $active_page = 'server_export.php';\n        include './server_export.php';\n    } elseif ($export_type == 'database') {\n        $active_page = 'db_export.php';\n        include './db_export.php';\n    } else {\n        $active_page = 'tbl_export.php';\n        include './tbl_export.php';\n    }\n    exit();\n}\n\n/**\n * Send the dump as a file...\n */\nif (!empty($asfile)) {\n    // Convert the charset if required.\n    if ($output_charset_conversion) {\n        $dump_buffer = PMA_convert_string('utf-8', $GLOBALS['charset_of_file'], $dump_buffer);\n    }\n\n    // Do the compression\n    // 1. as a zipped file\n    if ($compression == 'zip') {\n        if (@function_exists('gzcompress')) {\n            $zipfile = new zipfile();\n            $zipfile -> addFile($dump_buffer, substr($filename, 0, -4));\n            $dump_buffer = $zipfile -> file();\n        }\n    } elseif ($compression == 'bzip2') {\n        // 2. as a bzipped file\n        if (@function_exists('bzcompress')) {\n            $dump_buffer = bzcompress($dump_buffer);\n        }\n    } elseif ($compression == 'gzip') {\n        // 3. as a gzipped file\n        if (@function_exists('gzencode') \n            && ! @ini_get('zlib.output_compression')\n            // Here, we detect Apache's mod_deflate so we bet that\n            // this module is active for this instance of phpMyAdmin\n            // and therefore, will gzip encode the content\n            && ! (function_exists('apache_get_modules')\n                && in_array('mod_deflate', apache_get_modules()))\n            ) {\n            // without the optional parameter level because it bug\n            $dump_buffer = gzencode($dump_buffer);\n        }\n    }\n\n    /* If ve saved on server, we have to close file now */\n    if ($save_on_server) {\n        $write_result = @fwrite($file_handle, $dump_buffer);\n        fclose($file_handle);\n        if (strlen($dump_buffer) !=0 && (!$write_result || ($write_result != strlen($dump_buffer)))) {\n            $message = new PMA_Message(__('Insufficient space to save the file %s.'), PMA_Message::ERROR, $save_filename);\n        } else {\n            $message = new PMA_Message(__('Dump has been saved to file %s.'), PMA_Message::SUCCESS, $save_filename);\n        }\n\n        include_once './libraries/header.inc.php';\n        if ($export_type == 'server') {\n            $active_page = 'server_export.php';\n            include_once './server_export.php';\n        } elseif ($export_type == 'database') {\n            $active_page = 'db_export.php';\n            include_once './db_export.php';\n        } else {\n            $active_page = 'tbl_export.php';\n            include_once './tbl_export.php';\n        }\n        exit();\n    } else {\n        echo $dump_buffer;\n    }\n} else {\n    /**\n     * Displays the dump...\n     *\n     * Close the html tags and add the footers if dump is displayed on screen\n     */\n    echo '</textarea>' . \"\\n\"\n       . '    </form>' . \"\\n\";\n    echo $back_button;\n\n    echo \"\\n\";\n    echo '</div>' . \"\\n\";\n    echo \"\\n\";\n?>\n<script type=\"text/javascript\">\n//<![CDATA[\n    var bodyWidth=null; var bodyHeight=null;\n    if (document.getElementById('textSQLDUMP')) {\n        bodyWidth  = self.innerWidth;\n        bodyHeight = self.innerHeight;\n        if (!bodyWidth && !bodyHeight) {\n            if (document.compatMode && document.compatMode == \"BackCompat\") {\n                bodyWidth  = document.body.clientWidth;\n                bodyHeight = document.body.clientHeight;\n            } else if (document.compatMode && document.compatMode == \"CSS1Compat\") {\n                bodyWidth  = document.documentElement.clientWidth;\n                bodyHeight = document.documentElement.clientHeight;\n            }\n        }\n        document.getElementById('textSQLDUMP').style.width=(bodyWidth-50) + 'px';\n        document.getElementById('textSQLDUMP').style.height=(bodyHeight-100) + 'px';\n    }\n//]]>\n</script>\n<?php\n    include './libraries/footer.inc.php';\n} // end if\n?>\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * This is in a separate script because it's called from a number of scripts\n *\n * @package PhpMyAdmin\n */\n\n/**\n * Checks whether given link is valid\n *\n * @param string $url URL to check\n * @return boolean True if string can be used as link\n */\nfunction PMA_checkLink($url)\n{\n    $valid_starts = array(\n        'http://',\n        'https://',\n        './url.php?url=http%3A%2F%2F',\n        './url.php?url=https%3A%2F%2F',\n    );\n    if (defined('PMA_SETUP')) {\n        $valid_starts[] = '../Documentation.html';\n        $valid_starts[] = '?page=form&';\n    } else {\n        $valid_starts[] = './Documentation.html';\n    }\n    foreach ($valid_starts as $val) {\n        if (substr($url, 0, strlen($val)) == $val) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Callback function for replacing [a@link@target] links in bb code.\n *\n * @param array $found Array of preg matches\n * @return string Replaced string\n */\nfunction PMA_replaceBBLink($found)\n{\n    /* Check for valid link */\n    if (! PMA_checkLink($found[1])) {\n        return $found[0];\n    }\n    /* a-z and _ allowed in target */\n    if (! empty($found[3]) && preg_match('/[^a-z_]+/i', $found[3])) {\n        return $found[0];\n    }\n\n    /* Construct target */\n    $target = '';\n    if (! empty($found[3])) {\n        $target = ' target=\"' . $found[3] . '\"';\n    }\n\n    /* Construct url */\n    if (substr($found[1], 0, 4) == 'http') {\n        $url = PMA_linkURL($found[1]);\n    } else {\n        $url = $found[1];\n    }\n\n    return '<a href=\"' . $url . '\"' . $target . '>';\n}\n\n/**\n * Sanitizes $message, taking into account our special codes\n * for formatting.\n *\n * If you want to include result in element attribute, you should escape it.\n *\n * Examples:\n *\n * <p><?php echo PMA_sanitize($foo); ?></p>\n *\n * <a title=\"<?php echo PMA_sanitize($foo, true); ?>\">bar</a>\n *\n * @param string  $message the message\n * @param boolean $escape  whether to escape html in result\n * @param boolean $safe    whether string is safe (can keep < and > chars)\n * @return  string   the sanitized message\n */\nfunction PMA_sanitize($message, $escape = false, $safe = false)\n{\n    if (!$safe) {\n        $message = strtr($message, array('<' => '&lt;', '>' => '&gt;'));\n    }\n    /* Interpret bb code */\n    $replace_pairs = array(\n        '[i]'       => '<em>',      // deprecated by em\n        '[/i]'      => '</em>',     // deprecated by em\n        '[em]'      => '<em>',\n        '[/em]'     => '</em>',\n        '[b]'       => '<strong>',  // deprecated by strong\n        '[/b]'      => '</strong>', // deprecated by strong\n        '[strong]'  => '<strong>',\n        '[/strong]' => '</strong>',\n        '[tt]'      => '<code>',    // deprecated by CODE or KBD\n        '[/tt]'     => '</code>',   // deprecated by CODE or KBD\n        '[code]'    => '<code>',\n        '[/code]'   => '</code>',\n        '[kbd]'     => '<kbd>',\n        '[/kbd]'    => '</kbd>',\n        '[br]'      => '<br />',\n        '[/a]'      => '</a>',\n        '[sup]'      => '<sup>',\n        '[/sup]'      => '</sup>',\n    );\n    /* Adjust links for setup, which lives in subfolder */\n    if (defined('PMA_SETUP')) {\n        $replace_pairs['[a@Documentation.html'] = '[a@../Documentation.html';\n    } else {\n        $replace_pairs['[a@Documentation.html'] = '[a@./Documentation.html';\n    }\n    $message = strtr($message, $replace_pairs);\n\n    /* Match links in bb code ([a@url@target], where @target is options) */\n    $pattern = '/\\[a@([^]\"@]*)(@([^]\"]*))?\\]/';\n\n    /* Find and replace all links */\n    $message = preg_replace_callback($pattern, 'PMA_replaceBBLink', $message);\n\n    /* Possibly escape result */\n    if ($escape) {\n        $message = htmlspecialchars($message);\n    }\n\n    return $message;\n}\n\n\n/**\n * Sanitize a filename by removing anything besides legit characters \n *\n * Intended usecase:\n *    When using a filename in a Content-Disposition header the value\n *    should not contain ; or \"\n *\n *    When exporting, avoiding generation of an unexpected double-extension file\n *\n * @param   string  The filename\n * @param   boolean Whether to also replace dots \n *\n * @return  string  the sanitized filename\n *\n */\nfunction PMA_sanitize_filename($filename, $replaceDots = false) {\n    $pattern = '/[^A-Za-z0-9_';\n    // if we don't have to replace dots\n    if (! $replaceDots) {\n        // then add the dot to the list of legit characters\n        $pattern .= '.';\n    }\n    $pattern .= '-]/';\n    $filename = preg_replace($pattern, '_', $filename);\n    return $filename;\n}\n\n?>\n"], "filenames": ["export.php", "libraries/sanitizing.lib.php"], "buggy_code_start_loc": [275, 137], "buggy_code_end_loc": [279, 149], "fixing_code_start_loc": [274, 137], "fixing_code_end_loc": [279, 160], "type": "CWE-94", "message": "phpMyAdmin 3.5.x before 3.5.8 and 4.x before 4.0.0-rc3, when a SaveDir directory is configured, allows remote authenticated users to execute arbitrary code by using a double extension in the filename of an export file, leading to interpretation of this file as an executable file by the Apache HTTP Server, as demonstrated by a .php.sql filename.", "other": {"cve": {"id": "CVE-2013-3239", "sourceIdentifier": "cve@mitre.org", "published": "2013-04-26T03:34:23.463", "lastModified": "2013-11-19T04:48:21.203", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "phpMyAdmin 3.5.x before 3.5.8 and 4.x before 4.0.0-rc3, when a SaveDir directory is configured, allows remote authenticated users to execute arbitrary code by using a double extension in the filename of an export file, leading to interpretation of this file as an executable file by the Apache HTTP Server, as demonstrated by a .php.sql filename."}, {"lang": "es", "value": "phpMyAdmin v3.5.x antes de v3.5.8 y v4.x antes de v4.0.0-RC3, cuando se configura un directorio SaveDir, permite a los usuarios remotos autenticados ejecutar c\u00f3digo arbitrario mediante una doble extensi\u00f3n del nombre de archivo de un archivo de exportaci\u00f3n, lo que lleva a la interpretaci\u00f3n de este archivo como un archivo ejecutable por el Apache HTTP Server, como se demuestra por un nombre de archivo .php.sql"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "2577DB75-9893-4496-B9B8-22F4D7C70D8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "3BBC76AB-567B-4081-8520-D4BB2211CA91"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "EDFD7186-12C3-4FA6-951E-288063262EAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "C4E23EA5-8FD8-441A-8CB6-F1E77AA0D73B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "B5FE1328-F2E1-45C8-80ED-0560DAB666EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "EC675B47-0373-442E-9BCD-35D79355073C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "96E2C613-B1E9-4DB5-AA7D-165E5093452F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B0E7188-E3DE-4A9C-9B9B-31E7276F74AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "3E6D5B72-CA57-4054-B002-56C03856D740"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "71325EEA-441A-4D04-85E1-B7627C15ECE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "EE098CE1-0FA0-48C0-8F9F-CC9150E96C40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:3.5.8:rc1:*:*:*:*:*:*", "matchCriteriaId": "56245F7F-C483-42C1-9D30-AA39C3441591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B406A721-0075-46C8-A920-3C9602AD667B"}]}]}], "references": [{"url": "http://archives.neohapsis.com/archives/bugtraq/2013-04/0217.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/104725.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/104770.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/104936.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-06/msg00181.html", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:160", "source": "cve@mitre.org"}, {"url": "http://www.phpmyadmin.net/home_page/security/PMASA-2013-3.php", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/1f6bc0b707002e26cab216b9e57b4d5de764de48", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/d3fafdfba0807068196655e9b6d16c5d1d3ccf8a", "source": "cve@mitre.org"}, {"url": "https://wiki.mageia.org/en/Support/Advisories/MGASA-2013-0133", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/phpmyadmin/phpmyadmin/commit/1f6bc0b707002e26cab216b9e57b4d5de764de48"}}