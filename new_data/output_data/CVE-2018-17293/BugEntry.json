{"buggy_code": ["#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"Emscripten/Emscripten.h\"\n#include \"IR/Module.h\"\n#include \"IR/Operators.h\"\n#include \"IR/Types.h\"\n#include \"IR/Validate.h\"\n#include \"IR/Value.h\"\n#include \"Inline/BasicTypes.h\"\n#include \"Inline/CLI.h\"\n#include \"Inline/Errors.h\"\n#include \"Inline/Hash.h\"\n#include \"Inline/HashMap.h\"\n#include \"Inline/Serialization.h\"\n#include \"Inline/Timing.h\"\n#include \"Logging/Logging.h\"\n#include \"Runtime/Linker.h\"\n#include \"Runtime/Runtime.h\"\n#include \"ThreadTest/ThreadTest.h\"\n#include \"WASTParse/WASTParse.h\"\n\nusing namespace IR;\nusing namespace Runtime;\n\nstruct RootResolver : Resolver\n{\n\tCompartment* compartment;\n\tHashMap<std::string, ModuleInstance*> moduleNameToInstanceMap;\n\n\tRootResolver(Compartment* inCompartment) : compartment(inCompartment) {}\n\n\tbool resolve(const std::string& moduleName,\n\t\t\t\t const std::string& exportName,\n\t\t\t\t ObjectType type,\n\t\t\t\t Object*& outObject) override\n\t{\n\t\tauto namedInstance = moduleNameToInstanceMap.get(moduleName);\n\t\tif(namedInstance)\n\t\t{\n\t\t\toutObject = getInstanceExport(*namedInstance, exportName);\n\t\t\tif(outObject)\n\t\t\t{\n\t\t\t\tif(isA(outObject, type)) { return true; }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\t\t\"Resolved import %s.%s to a %s, but was expecting %s\\n\",\n\t\t\t\t\t\t\t\tmoduleName.c_str(),\n\t\t\t\t\t\t\t\texportName.c_str(),\n\t\t\t\t\t\t\t\tasString(getObjectType(outObject)).c_str(),\n\t\t\t\t\t\t\t\tasString(type).c_str());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLog::printf(Log::error,\n\t\t\t\t\t\"Generated stub for missing import %s.%s : %s\\n\",\n\t\t\t\t\tmoduleName.c_str(),\n\t\t\t\t\texportName.c_str(),\n\t\t\t\t\tasString(type).c_str());\n\t\toutObject = getStubObject(exportName, type);\n\t\treturn true;\n\t}\n\n\tObject* getStubObject(const std::string& exportName, ObjectType type) const\n\t{\n\t\t// If the import couldn't be resolved, stub it in.\n\t\tswitch(type.kind)\n\t\t{\n\t\tcase IR::ObjectKind::function:\n\t\t{\n\t\t\t// Generate a function body that just uses the unreachable op to fault if called.\n\t\t\tSerialization::ArrayOutputStream codeStream;\n\t\t\tOperatorEncoderStream encoder(codeStream);\n\t\t\tencoder.unreachable();\n\t\t\tencoder.end();\n\n\t\t\t// Generate a module for the stub function.\n\t\t\tIR::Module stubModule;\n\t\t\tDisassemblyNames stubModuleNames;\n\t\t\tstubModule.types.push_back(asFunctionType(type));\n\t\t\tstubModule.functions.defs.push_back({{0}, {}, std::move(codeStream.getBytes()), {}});\n\t\t\tstubModule.exports.push_back({\"importStub\", IR::ObjectKind::function, 0});\n\t\t\tstubModuleNames.functions.push_back({\"importStub: \" + exportName, {}, {}});\n\t\t\tIR::setDisassemblyNames(stubModule, stubModuleNames);\n\t\t\tIR::validateDefinitions(stubModule);\n\n\t\t\t// Instantiate the module and return the stub function instance.\n\t\t\tauto stubModuleInstance\n\t\t\t\t= instantiateModule(compartment, compileModule(stubModule), {}, \"importStub\");\n\t\t\treturn getInstanceExport(stubModuleInstance, \"importStub\");\n\t\t}\n\t\tcase IR::ObjectKind::memory:\n\t\t{\n\t\t\treturn asObject(Runtime::createMemory(compartment, asMemoryType(type)));\n\t\t}\n\t\tcase IR::ObjectKind::table:\n\t\t{\n\t\t\treturn asObject(Runtime::createTable(compartment, asTableType(type)));\n\t\t}\n\t\tcase IR::ObjectKind::global:\n\t\t{\n\t\t\treturn asObject(Runtime::createGlobal(\n\t\t\t\tcompartment,\n\t\t\t\tasGlobalType(type),\n\t\t\t\tIR::Value(asGlobalType(type).valueType, IR::UntaggedValue())));\n\t\t}\n\t\tcase IR::ObjectKind::exceptionType:\n\t\t{\n\t\t\treturn asObject(\n\t\t\t\tRuntime::createExceptionTypeInstance(asExceptionType(type), \"importStub\"));\n\t\t}\n\t\tdefault: Errors::unreachable();\n\t\t};\n\t}\n};\n\nstruct CommandLineOptions\n{\n\tconst char* filename = nullptr;\n\tconst char* functionName = nullptr;\n\tchar** args = nullptr;\n\tbool onlyCheck = false;\n\tbool enableEmscripten = true;\n\tbool enableThreadTest = false;\n\tbool precompiled = false;\n};\n\nstatic int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n\t\t\tif(!defaultMemory)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tstd::vector<const char*> argStrings;\n\t\t\targStrings.push_back(options.filename);\n\t\t\tchar** args = options.args;\n\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nstatic void showHelp()\n{\n\tLog::printf(Log::error,\n\t\t\t\t\"Usage: wavm [switches] [programfile] [--] [arguments]\\n\"\n\t\t\t\t\"  in.wast|in.wasm       Specify program file (.wast/.wasm)\\n\"\n\t\t\t\t\"  -c|--check            Exit after checking that the program is valid\\n\"\n\t\t\t\t\"  -d|--debug            Write additional debug information to stdout\\n\"\n\t\t\t\t\"  -f|--function name    Specify function name to run in module rather than main\\n\"\n\t\t\t\t\"  -h|--help             Display this message\\n\"\n\t\t\t\t\"  --disable-emscripten  Disable Emscripten intrinsics\\n\"\n\t\t\t\t\"  --enable-thread-test  Enable ThreadTest intrinsics\\n\"\n\t\t\t\t\"  --precompiled         Use precompiled object code in programfile\\n\"\n\t\t\t\t\"  --                    Stop parsing arguments\\n\");\n}\n\nint main(int argc, char** argv)\n{\n\tCommandLineOptions options;\n\toptions.args = argv;\n\twhile(*++options.args)\n\t{\n\t\tif(!strcmp(*options.args, \"--function\") || !strcmp(*options.args, \"-f\"))\n\t\t{\n\t\t\tif(!*++options.args)\n\t\t\t{\n\t\t\t\tshowHelp();\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\toptions.functionName = *options.args;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--check\") || !strcmp(*options.args, \"-c\"))\n\t\t{\n\t\t\toptions.onlyCheck = true;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--debug\") || !strcmp(*options.args, \"-d\"))\n\t\t{\n\t\t\tLog::setCategoryEnabled(Log::debug, true);\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--disable-emscripten\"))\n\t\t{\n\t\t\toptions.enableEmscripten = false;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--enable-thread-test\"))\n\t\t{\n\t\t\toptions.enableThreadTest = true;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--precompiled\"))\n\t\t{\n\t\t\toptions.precompiled = true;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--\"))\n\t\t{\n\t\t\t++options.args;\n\t\t\tbreak;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--help\") || !strcmp(*options.args, \"-h\"))\n\t\t{\n\t\t\tshowHelp();\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\telse if(!options.filename)\n\t\t{\n\t\t\toptions.filename = *options.args;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(!options.filename)\n\t{\n\t\tshowHelp();\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Treat any unhandled exception (e.g. in a thread) as a fatal error.\n\tRuntime::setUnhandledExceptionHandler([](Runtime::Exception&& exception) {\n\t\tErrors::fatalf(\"Runtime exception: %s\\n\", describeException(exception).c_str());\n\t});\n\n\treturn run(options);\n}\n"], "fixing_code": ["#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"Emscripten/Emscripten.h\"\n#include \"IR/Module.h\"\n#include \"IR/Operators.h\"\n#include \"IR/Types.h\"\n#include \"IR/Validate.h\"\n#include \"IR/Value.h\"\n#include \"Inline/BasicTypes.h\"\n#include \"Inline/CLI.h\"\n#include \"Inline/Errors.h\"\n#include \"Inline/Hash.h\"\n#include \"Inline/HashMap.h\"\n#include \"Inline/Serialization.h\"\n#include \"Inline/Timing.h\"\n#include \"Logging/Logging.h\"\n#include \"Runtime/Linker.h\"\n#include \"Runtime/Runtime.h\"\n#include \"ThreadTest/ThreadTest.h\"\n#include \"WASTParse/WASTParse.h\"\n\nusing namespace IR;\nusing namespace Runtime;\n\nstruct RootResolver : Resolver\n{\n\tCompartment* compartment;\n\tHashMap<std::string, ModuleInstance*> moduleNameToInstanceMap;\n\n\tRootResolver(Compartment* inCompartment) : compartment(inCompartment) {}\n\n\tbool resolve(const std::string& moduleName,\n\t\t\t\t const std::string& exportName,\n\t\t\t\t ObjectType type,\n\t\t\t\t Object*& outObject) override\n\t{\n\t\tauto namedInstance = moduleNameToInstanceMap.get(moduleName);\n\t\tif(namedInstance)\n\t\t{\n\t\t\toutObject = getInstanceExport(*namedInstance, exportName);\n\t\t\tif(outObject)\n\t\t\t{\n\t\t\t\tif(isA(outObject, type)) { return true; }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\t\t\"Resolved import %s.%s to a %s, but was expecting %s\\n\",\n\t\t\t\t\t\t\t\tmoduleName.c_str(),\n\t\t\t\t\t\t\t\texportName.c_str(),\n\t\t\t\t\t\t\t\tasString(getObjectType(outObject)).c_str(),\n\t\t\t\t\t\t\t\tasString(type).c_str());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLog::printf(Log::error,\n\t\t\t\t\t\"Generated stub for missing import %s.%s : %s\\n\",\n\t\t\t\t\tmoduleName.c_str(),\n\t\t\t\t\texportName.c_str(),\n\t\t\t\t\tasString(type).c_str());\n\t\toutObject = getStubObject(exportName, type);\n\t\treturn true;\n\t}\n\n\tObject* getStubObject(const std::string& exportName, ObjectType type) const\n\t{\n\t\t// If the import couldn't be resolved, stub it in.\n\t\tswitch(type.kind)\n\t\t{\n\t\tcase IR::ObjectKind::function:\n\t\t{\n\t\t\t// Generate a function body that just uses the unreachable op to fault if called.\n\t\t\tSerialization::ArrayOutputStream codeStream;\n\t\t\tOperatorEncoderStream encoder(codeStream);\n\t\t\tencoder.unreachable();\n\t\t\tencoder.end();\n\n\t\t\t// Generate a module for the stub function.\n\t\t\tIR::Module stubModule;\n\t\t\tDisassemblyNames stubModuleNames;\n\t\t\tstubModule.types.push_back(asFunctionType(type));\n\t\t\tstubModule.functions.defs.push_back({{0}, {}, std::move(codeStream.getBytes()), {}});\n\t\t\tstubModule.exports.push_back({\"importStub\", IR::ObjectKind::function, 0});\n\t\t\tstubModuleNames.functions.push_back({\"importStub: \" + exportName, {}, {}});\n\t\t\tIR::setDisassemblyNames(stubModule, stubModuleNames);\n\t\t\tIR::validateDefinitions(stubModule);\n\n\t\t\t// Instantiate the module and return the stub function instance.\n\t\t\tauto stubModuleInstance\n\t\t\t\t= instantiateModule(compartment, compileModule(stubModule), {}, \"importStub\");\n\t\t\treturn getInstanceExport(stubModuleInstance, \"importStub\");\n\t\t}\n\t\tcase IR::ObjectKind::memory:\n\t\t{\n\t\t\treturn asObject(Runtime::createMemory(compartment, asMemoryType(type)));\n\t\t}\n\t\tcase IR::ObjectKind::table:\n\t\t{\n\t\t\treturn asObject(Runtime::createTable(compartment, asTableType(type)));\n\t\t}\n\t\tcase IR::ObjectKind::global:\n\t\t{\n\t\t\treturn asObject(Runtime::createGlobal(\n\t\t\t\tcompartment,\n\t\t\t\tasGlobalType(type),\n\t\t\t\tIR::Value(asGlobalType(type).valueType, IR::UntaggedValue())));\n\t\t}\n\t\tcase IR::ObjectKind::exceptionType:\n\t\t{\n\t\t\treturn asObject(\n\t\t\t\tRuntime::createExceptionTypeInstance(asExceptionType(type), \"importStub\"));\n\t\t}\n\t\tdefault: Errors::unreachable();\n\t\t};\n\t}\n};\n\nstruct CommandLineOptions\n{\n\tconst char* filename = nullptr;\n\tconst char* functionName = nullptr;\n\tchar** args = nullptr;\n\tbool onlyCheck = false;\n\tbool enableEmscripten = true;\n\tbool enableThreadTest = false;\n\tbool precompiled = false;\n};\n\nstatic int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tif(!emscriptenInstance)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::vector<const char*> argStrings;\n\t\t\t\targStrings.push_back(options.filename);\n\t\t\t\tchar** args = options.args;\n\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\t\twavmAssert(emscriptenInstance);\n\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t\t}\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nstatic void showHelp()\n{\n\tLog::printf(Log::error,\n\t\t\t\t\"Usage: wavm [switches] [programfile] [--] [arguments]\\n\"\n\t\t\t\t\"  in.wast|in.wasm       Specify program file (.wast/.wasm)\\n\"\n\t\t\t\t\"  -c|--check            Exit after checking that the program is valid\\n\"\n\t\t\t\t\"  -d|--debug            Write additional debug information to stdout\\n\"\n\t\t\t\t\"  -f|--function name    Specify function name to run in module rather than main\\n\"\n\t\t\t\t\"  -h|--help             Display this message\\n\"\n\t\t\t\t\"  --disable-emscripten  Disable Emscripten intrinsics\\n\"\n\t\t\t\t\"  --enable-thread-test  Enable ThreadTest intrinsics\\n\"\n\t\t\t\t\"  --precompiled         Use precompiled object code in programfile\\n\"\n\t\t\t\t\"  --                    Stop parsing arguments\\n\");\n}\n\nint main(int argc, char** argv)\n{\n\tCommandLineOptions options;\n\toptions.args = argv;\n\twhile(*++options.args)\n\t{\n\t\tif(!strcmp(*options.args, \"--function\") || !strcmp(*options.args, \"-f\"))\n\t\t{\n\t\t\tif(!*++options.args)\n\t\t\t{\n\t\t\t\tshowHelp();\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\toptions.functionName = *options.args;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--check\") || !strcmp(*options.args, \"-c\"))\n\t\t{\n\t\t\toptions.onlyCheck = true;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--debug\") || !strcmp(*options.args, \"-d\"))\n\t\t{\n\t\t\tLog::setCategoryEnabled(Log::debug, true);\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--disable-emscripten\"))\n\t\t{\n\t\t\toptions.enableEmscripten = false;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--enable-thread-test\"))\n\t\t{\n\t\t\toptions.enableThreadTest = true;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--precompiled\"))\n\t\t{\n\t\t\toptions.precompiled = true;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--\"))\n\t\t{\n\t\t\t++options.args;\n\t\t\tbreak;\n\t\t}\n\t\telse if(!strcmp(*options.args, \"--help\") || !strcmp(*options.args, \"-h\"))\n\t\t{\n\t\t\tshowHelp();\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\telse if(!options.filename)\n\t\t{\n\t\t\toptions.filename = *options.args;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(!options.filename)\n\t{\n\t\tshowHelp();\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Treat any unhandled exception (e.g. in a thread) as a fatal error.\n\tRuntime::setUnhandledExceptionHandler([](Runtime::Exception&& exception) {\n\t\tErrors::fatalf(\"Runtime exception: %s\\n\", describeException(exception).c_str());\n\t});\n\n\treturn run(options);\n}\n"], "filenames": ["Programs/wavm/wavm.cpp"], "buggy_code_start_loc": [253], "buggy_code_end_loc": [268], "fixing_code_start_loc": [253], "fixing_code_end_loc": [270], "type": "CWE-476", "message": "An issue was discovered in WAVM before 2018-09-16. The run function in Programs/wavm/wavm.cpp does not check whether there is Emscripten memory to store the command-line arguments passed by the input WebAssembly file's main function, which allows attackers to cause a denial of service (application crash by NULL pointer dereference) or possibly have unspecified other impact by crafting certain WebAssembly files.", "other": {"cve": {"id": "CVE-2018-17293", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-21T07:29:00.457", "lastModified": "2018-11-21T18:09:08.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in WAVM before 2018-09-16. The run function in Programs/wavm/wavm.cpp does not check whether there is Emscripten memory to store the command-line arguments passed by the input WebAssembly file's main function, which allows attackers to cause a denial of service (application crash by NULL pointer dereference) or possibly have unspecified other impact by crafting certain WebAssembly files."}, {"lang": "es", "value": "Se ha descubierto un problema en WAVM en versiones anteriores al 16/09/2018. La funci\u00f3n run en Programs/wavm/wavm.cpp no comprueba si existe memoria Emscripten para almacenar los argumentos de la l\u00ednea de comandos pasados por la funci\u00f3n principal del archivo WebAssembly, lo que permite que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n por desreferencia de puntero NULL) o, posiblemente, provoquen otro impacto no especificado creando determinados archivos WebAssembly."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webassembly_virtual_machine_project:webassembly_virtual_machine:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-09-16", "matchCriteriaId": "F8DB01B9-1E08-4736-B665-9DD40423C024"}]}]}], "references": [{"url": "https://github.com/WAVM/WAVM/commit/31d670b6489e6d708c3b04b911cdf14ac43d846d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/WAVM/WAVM/issues/110#issuecomment-421764693", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WAVM/WAVM/commit/31d670b6489e6d708c3b04b911cdf14ac43d846d"}}