{"buggy_code": ["/*\r\n * Copyright 2008-2017 by Emeric Vernat\r\n *\r\n *     This file is part of Java Melody.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage net.bull.javamelody;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Scanner;\r\nimport java.util.regex.Pattern;\r\n\r\nimport javax.servlet.ReadListener;\r\nimport javax.servlet.ServletInputStream;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletRequestWrapper;\r\nimport javax.xml.stream.XMLInputFactory;\r\nimport javax.xml.stream.XMLStreamException;\r\nimport javax.xml.stream.XMLStreamReader;\r\n\r\nimport net.bull.javamelody.internal.common.LOG;\r\n\r\n//20091201 dhartford GWTRequestWrapper\r\n//20100519 dhartford adjustments for UTF-8, however did not have an impact so removed.\r\n//20100520 dhartford adjustments for reader/inputstream.\r\n//20110206 evernat   refactoring\r\n//20131111 roy.paterson   SOAP request wrapper\r\n//20131111 evernat   refactoring\r\n\r\n/**\r\n * Simple Wrapper class to inspect payload for name.\r\n * @author dhartford, roy.paterson, evernat\r\n */\r\npublic class PayloadNameRequestWrapper extends HttpServletRequestWrapper {\r\n\tprivate static final Pattern GWT_RPC_SEPARATOR_CHAR_PATTERN = Pattern\r\n\t\t\t.compile(Pattern.quote(\"|\"));\r\n\r\n\t/**\r\n\t * Name of request, or null if we don't know based on payload @null\r\n\t */\r\n\tprivate String name;\r\n\r\n\t/**\r\n\t * Type of request if name != null, or null if we don't know based on the payload @null\r\n\t */\r\n\tprivate String requestType;\r\n\r\n\tprivate BufferedInputStream bufferedInputStream;\r\n\tprivate ServletInputStream inputStream;\r\n\tprivate BufferedReader reader;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * @param request the original HttpServletRequest\r\n\t */\r\n\tpublic PayloadNameRequestWrapper(HttpServletRequest request) {\r\n\t\tsuper(request);\r\n\t}\r\n\r\n\tprotected void initialize() throws IOException {\r\n\t\t//name on a best-effort basis\r\n\t\tname = null;\r\n\t\trequestType = null;\r\n\r\n\t\tfinal HttpServletRequest request = (HttpServletRequest) getRequest();\r\n\t\tfinal String contentType = request.getContentType();\r\n\t\tif (contentType == null) {\r\n\t\t\t//don't know how to handle this content type\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!\"POST\".equalsIgnoreCase(request.getMethod())) {\r\n\t\t\t//no payload\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//Try look for name in payload on a best-effort basis...\r\n\t\ttry {\r\n\t\t\tif (contentType.startsWith(\"text/x-gwt-rpc\")) {\r\n\t\t\t\t//parse GWT-RPC method name\r\n\t\t\t\tname = parseGwtRpcMethodName(getBufferedInputStream(), getCharacterEncoding());\r\n\t\t\t\trequestType = \"GWT-RPC\";\r\n\t\t\t} else if (contentType.startsWith(\"application/soap+xml\") //SOAP 1.2\r\n\t\t\t\t\t|| contentType.startsWith(\"text/xml\") //SOAP 1.1\r\n\t\t\t\t\t\t\t&& request.getHeader(\"SOAPAction\") != null) {\r\n\t\t\t\t//parse SOAP method name\r\n\t\t\t\tname = parseSoapMethodName(getBufferedInputStream(), getCharacterEncoding());\r\n\t\t\t\trequestType = \"SOAP\";\r\n\t\t\t} else {\r\n\t\t\t\t//don't know how to name this request based on payload\r\n\t\t\t\t//(don't parse if text/xml for XML-RPC, because it is obsolete)\r\n\t\t\t\tname = null;\r\n\t\t\t\trequestType = null;\r\n\t\t\t}\r\n\t\t} catch (final Exception e) {\r\n\t\t\tLOG.debug(\"Error trying to parse payload content for request name\", e);\r\n\r\n\t\t\t//best-effort - couldn't figure it out\r\n\t\t\tname = null;\r\n\t\t\trequestType = null;\r\n\t\t} finally {\r\n\t\t\t//reset stream so application is unaffected\r\n\t\t\tresetBufferedInputStream();\r\n\t\t}\r\n\t}\r\n\r\n\tprotected BufferedInputStream getBufferedInputStream() throws IOException {\r\n\t\tif (bufferedInputStream == null) {\r\n\t\t\t//workaround Tomcat issue with form POSTs\r\n\t\t\t//see http://stackoverflow.com/questions/18489399/read-httpservletrequests-post-body-and-then-call-getparameter-in-tomcat\r\n\t\t\tfinal ServletRequest request = getRequest();\r\n\t\t\trequest.getParameterMap();\r\n\r\n\t\t\t//buffer the payload so we can inspect it\r\n\t\t\tbufferedInputStream = new BufferedInputStream(request.getInputStream());\r\n\t\t\t// and mark to allow the stream to be reset\r\n\t\t\tbufferedInputStream.mark(Integer.MAX_VALUE);\r\n\t\t}\r\n\t\treturn bufferedInputStream;\r\n\t}\r\n\r\n\tprotected void resetBufferedInputStream() throws IOException {\r\n\t\tif (bufferedInputStream != null) {\r\n\t\t\tbufferedInputStream.reset();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Try to parse GWT-RPC method name from request body stream.  Does not close the stream.\r\n\t *\r\n\t * @param stream GWT-RPC request body stream @nonnull\r\n\t * @param charEncoding character encoding of stream, or null for platform default @null\r\n\t * @return GWT-RPC method name, or null if unable to parse @null\r\n\t */\r\n\t@SuppressWarnings(\"resource\")\r\n\tprivate static String parseGwtRpcMethodName(InputStream stream, String charEncoding) {\r\n\t\t//commented out code uses GWT-user library for a more 'proper' approach.\r\n\t\t//GWT-user library approach is more future-proof, but requires more dependency management.\r\n\t\t//\t\t\t\tRPCRequest decodeRequest = RPC.decodeRequest(readLine);\r\n\t\t//\t\t\t\tgwtmethodname = decodeRequest.getMethod().getName();\r\n\r\n\t\ttry {\r\n\t\t\tfinal Scanner scanner;\r\n\t\t\tif (charEncoding == null) {\r\n\t\t\t\tscanner = new Scanner(stream);\r\n\t\t\t} else {\r\n\t\t\t\tscanner = new Scanner(stream, charEncoding);\r\n\t\t\t}\r\n\t\t\tscanner.useDelimiter(GWT_RPC_SEPARATOR_CHAR_PATTERN); //AbstractSerializationStream.RPC_SEPARATOR_CHAR\r\n\r\n\t\t\t//AbstractSerializationStreamReader.prepareToRead(...)\r\n\t\t\tscanner.next(); //stream version number\r\n\t\t\tscanner.next(); //flags\r\n\r\n\t\t\t//ServerSerializationStreamReader.deserializeStringTable()\r\n\t\t\tscanner.next(); //type name count\r\n\r\n\t\t\t//ServerSerializationStreamReader.preapreToRead(...)\r\n\t\t\tscanner.next(); //module base URL\r\n\t\t\tscanner.next(); //strong name\r\n\r\n\t\t\t//RPC.decodeRequest(...)\r\n\t\t\tscanner.next(); //service interface name\r\n\t\t\treturn \".\" + scanner.next(); //service method name\r\n\r\n\t\t\t//note we don't close the scanner because we don't want to close the underlying stream\r\n\t\t} catch (final NoSuchElementException e) {\r\n\t\t\tLOG.debug(\"Unable to parse GWT-RPC request\", e);\r\n\r\n\t\t\t//code above is best-effort - we were unable to parse GWT payload so\r\n\t\t\t//treat as a normal HTTP request\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Scan xml for tag child of the current element\r\n\t *\r\n\t * @param reader reader, must be at \"start element\" @nonnull\r\n\t * @param tagName name of child tag to find @nonnull\r\n\t * @return if found tag\r\n\t * @throws XMLStreamException on error\r\n\t */\r\n\tstatic boolean scanForChildTag(XMLStreamReader reader, String tagName)\r\n\t\t\tthrows XMLStreamException {\r\n\t\tassert reader.isStartElement();\r\n\r\n\t\tint level = -1;\r\n\t\twhile (reader.hasNext()) {\r\n\t\t\t//keep track of level so we only search children, not descendants\r\n\t\t\tif (reader.isStartElement()) {\r\n\t\t\t\tlevel++;\r\n\t\t\t} else if (reader.isEndElement()) {\r\n\t\t\t\tlevel--;\r\n\t\t\t}\r\n\t\t\tif (level < 0) {\r\n\t\t\t\t//end parent tag - no more children\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treader.next();\r\n\r\n\t\t\tif (level == 0 && reader.isStartElement() && reader.getLocalName().equals(tagName)) {\r\n\t\t\t\treturn true; //found\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false; //got to end of parent element and not found\r\n\t}\r\n\r\n\t/**\r\n\t * Try to parse SOAP method name from request body stream.  Does not close the stream.\r\n\t *\r\n\t * @param stream SOAP request body stream @nonnull\r\n\t * @param charEncoding character encoding of stream, or null for platform default @null\r\n\t * @return SOAP method name, or null if unable to parse @null\r\n\t */\r\n\tprivate static String parseSoapMethodName(InputStream stream, String charEncoding) {\r\n\t\ttry {\r\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\r\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\r\n\t\t\tfinal XMLStreamReader xmlReader;\r\n\t\t\tif (charEncoding != null) {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\r\n\t\t\t} else {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\r\n\t\t\t}\r\n\r\n\t\t\t//best-effort parsing\r\n\r\n\t\t\t//start document, go to first tag\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//expect first tag to be \"Envelope\"\r\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\r\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\r\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\t//scan for body tag\r\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\r\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//tag is method name\r\n\t\t\treturn \".\" + xmlReader.getLocalName();\r\n\t\t} catch (final XMLStreamException e) {\r\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\r\n\t\t\t//failed\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic BufferedReader getReader() throws IOException {\r\n\t\tif (bufferedInputStream == null) {\r\n\t\t\treturn super.getReader();\r\n\t\t}\r\n\t\tif (reader == null) {\r\n\t\t\t// use character encoding as said in the API\r\n\t\t\tfinal String characterEncoding = this.getCharacterEncoding();\r\n\t\t\tif (characterEncoding == null) {\r\n\t\t\t\treader = new BufferedReader(new InputStreamReader(this.getInputStream()));\r\n\t\t\t} else {\r\n\t\t\t\treader = new BufferedReader(\r\n\t\t\t\t\t\tnew InputStreamReader(this.getInputStream(), characterEncoding));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn reader;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic ServletInputStream getInputStream() throws IOException {\r\n\t\tfinal ServletInputStream requestInputStream = super.getInputStream();\r\n\t\tif (bufferedInputStream == null) {\r\n\t\t\treturn requestInputStream;\r\n\t\t}\r\n\t\tif (inputStream == null) {\r\n\t\t\tfinal BufferedInputStream myBufferedInputStream = bufferedInputStream;\r\n\t\t\t//CHECKSTYLE:OFF\r\n\t\t\tinputStream = new ServletInputStream() {\r\n\t\t\t\t//CHECKSTYLE:ON\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic int read() throws IOException {\r\n\t\t\t\t\treturn myBufferedInputStream.read();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic boolean isFinished() {\r\n\t\t\t\t\treturn requestInputStream.isFinished();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic boolean isReady() {\r\n\t\t\t\t\treturn requestInputStream.isReady();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void setReadListener(ReadListener readListener) {\r\n\t\t\t\t\trequestInputStream.setReadListener(readListener);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn inputStream;\r\n\t}\r\n\r\n\t/**\r\n\t * @return name of request, or null if we can't figure out a good name based on\r\n\t *   the request payload @null\r\n\t */\r\n\tpublic String getPayloadRequestName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\t/**\r\n\t * Get type of request.  If {@link #getPayloadRequestName()} returns non-null then\r\n\t * this method also returns non-null.\r\n\t *\r\n\t * @return type of request if or null if don't know @null\r\n\t */\r\n\tpublic String getPayloadRequestType() {\r\n\t\treturn requestType;\r\n\t}\r\n}\r\n"], "fixing_code": ["/*\r\n * Copyright 2008-2017 by Emeric Vernat\r\n *\r\n *     This file is part of Java Melody.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage net.bull.javamelody;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Scanner;\r\nimport java.util.regex.Pattern;\r\n\r\nimport javax.servlet.ReadListener;\r\nimport javax.servlet.ServletInputStream;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletRequestWrapper;\r\nimport javax.xml.stream.XMLInputFactory;\r\nimport javax.xml.stream.XMLStreamException;\r\nimport javax.xml.stream.XMLStreamReader;\r\n\r\nimport net.bull.javamelody.internal.common.LOG;\r\n\r\n//20091201 dhartford GWTRequestWrapper\r\n//20100519 dhartford adjustments for UTF-8, however did not have an impact so removed.\r\n//20100520 dhartford adjustments for reader/inputstream.\r\n//20110206 evernat   refactoring\r\n//20131111 roy.paterson   SOAP request wrapper\r\n//20131111 evernat   refactoring\r\n\r\n/**\r\n * Simple Wrapper class to inspect payload for name.\r\n * @author dhartford, roy.paterson, evernat\r\n */\r\npublic class PayloadNameRequestWrapper extends HttpServletRequestWrapper {\r\n\tprivate static final Pattern GWT_RPC_SEPARATOR_CHAR_PATTERN = Pattern\r\n\t\t\t.compile(Pattern.quote(\"|\"));\r\n\r\n\t/**\r\n\t * Name of request, or null if we don't know based on payload @null\r\n\t */\r\n\tprivate String name;\r\n\r\n\t/**\r\n\t * Type of request if name != null, or null if we don't know based on the payload @null\r\n\t */\r\n\tprivate String requestType;\r\n\r\n\tprivate BufferedInputStream bufferedInputStream;\r\n\tprivate ServletInputStream inputStream;\r\n\tprivate BufferedReader reader;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t * @param request the original HttpServletRequest\r\n\t */\r\n\tpublic PayloadNameRequestWrapper(HttpServletRequest request) {\r\n\t\tsuper(request);\r\n\t}\r\n\r\n\tprotected void initialize() throws IOException {\r\n\t\t//name on a best-effort basis\r\n\t\tname = null;\r\n\t\trequestType = null;\r\n\r\n\t\tfinal HttpServletRequest request = (HttpServletRequest) getRequest();\r\n\t\tfinal String contentType = request.getContentType();\r\n\t\tif (contentType == null) {\r\n\t\t\t//don't know how to handle this content type\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!\"POST\".equalsIgnoreCase(request.getMethod())) {\r\n\t\t\t//no payload\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//Try look for name in payload on a best-effort basis...\r\n\t\ttry {\r\n\t\t\tif (contentType.startsWith(\"text/x-gwt-rpc\")) {\r\n\t\t\t\t//parse GWT-RPC method name\r\n\t\t\t\tname = parseGwtRpcMethodName(getBufferedInputStream(), getCharacterEncoding());\r\n\t\t\t\trequestType = \"GWT-RPC\";\r\n\t\t\t} else if (contentType.startsWith(\"application/soap+xml\") //SOAP 1.2\r\n\t\t\t\t\t|| contentType.startsWith(\"text/xml\") //SOAP 1.1\r\n\t\t\t\t\t\t\t&& request.getHeader(\"SOAPAction\") != null) {\r\n\t\t\t\t//parse SOAP method name\r\n\t\t\t\tname = parseSoapMethodName(getBufferedInputStream(), getCharacterEncoding());\r\n\t\t\t\trequestType = \"SOAP\";\r\n\t\t\t} else {\r\n\t\t\t\t//don't know how to name this request based on payload\r\n\t\t\t\t//(don't parse if text/xml for XML-RPC, because it is obsolete)\r\n\t\t\t\tname = null;\r\n\t\t\t\trequestType = null;\r\n\t\t\t}\r\n\t\t} catch (final Exception e) {\r\n\t\t\tLOG.debug(\"Error trying to parse payload content for request name\", e);\r\n\r\n\t\t\t//best-effort - couldn't figure it out\r\n\t\t\tname = null;\r\n\t\t\trequestType = null;\r\n\t\t} finally {\r\n\t\t\t//reset stream so application is unaffected\r\n\t\t\tresetBufferedInputStream();\r\n\t\t}\r\n\t}\r\n\r\n\tprotected BufferedInputStream getBufferedInputStream() throws IOException {\r\n\t\tif (bufferedInputStream == null) {\r\n\t\t\t//workaround Tomcat issue with form POSTs\r\n\t\t\t//see http://stackoverflow.com/questions/18489399/read-httpservletrequests-post-body-and-then-call-getparameter-in-tomcat\r\n\t\t\tfinal ServletRequest request = getRequest();\r\n\t\t\trequest.getParameterMap();\r\n\r\n\t\t\t//buffer the payload so we can inspect it\r\n\t\t\tbufferedInputStream = new BufferedInputStream(request.getInputStream());\r\n\t\t\t// and mark to allow the stream to be reset\r\n\t\t\tbufferedInputStream.mark(Integer.MAX_VALUE);\r\n\t\t}\r\n\t\treturn bufferedInputStream;\r\n\t}\r\n\r\n\tprotected void resetBufferedInputStream() throws IOException {\r\n\t\tif (bufferedInputStream != null) {\r\n\t\t\tbufferedInputStream.reset();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Try to parse GWT-RPC method name from request body stream.  Does not close the stream.\r\n\t *\r\n\t * @param stream GWT-RPC request body stream @nonnull\r\n\t * @param charEncoding character encoding of stream, or null for platform default @null\r\n\t * @return GWT-RPC method name, or null if unable to parse @null\r\n\t */\r\n\t@SuppressWarnings(\"resource\")\r\n\tprivate static String parseGwtRpcMethodName(InputStream stream, String charEncoding) {\r\n\t\t//commented out code uses GWT-user library for a more 'proper' approach.\r\n\t\t//GWT-user library approach is more future-proof, but requires more dependency management.\r\n\t\t//\t\t\t\tRPCRequest decodeRequest = RPC.decodeRequest(readLine);\r\n\t\t//\t\t\t\tgwtmethodname = decodeRequest.getMethod().getName();\r\n\r\n\t\ttry {\r\n\t\t\tfinal Scanner scanner;\r\n\t\t\tif (charEncoding == null) {\r\n\t\t\t\tscanner = new Scanner(stream);\r\n\t\t\t} else {\r\n\t\t\t\tscanner = new Scanner(stream, charEncoding);\r\n\t\t\t}\r\n\t\t\tscanner.useDelimiter(GWT_RPC_SEPARATOR_CHAR_PATTERN); //AbstractSerializationStream.RPC_SEPARATOR_CHAR\r\n\r\n\t\t\t//AbstractSerializationStreamReader.prepareToRead(...)\r\n\t\t\tscanner.next(); //stream version number\r\n\t\t\tscanner.next(); //flags\r\n\r\n\t\t\t//ServerSerializationStreamReader.deserializeStringTable()\r\n\t\t\tscanner.next(); //type name count\r\n\r\n\t\t\t//ServerSerializationStreamReader.preapreToRead(...)\r\n\t\t\tscanner.next(); //module base URL\r\n\t\t\tscanner.next(); //strong name\r\n\r\n\t\t\t//RPC.decodeRequest(...)\r\n\t\t\tscanner.next(); //service interface name\r\n\t\t\treturn \".\" + scanner.next(); //service method name\r\n\r\n\t\t\t//note we don't close the scanner because we don't want to close the underlying stream\r\n\t\t} catch (final NoSuchElementException e) {\r\n\t\t\tLOG.debug(\"Unable to parse GWT-RPC request\", e);\r\n\r\n\t\t\t//code above is best-effort - we were unable to parse GWT payload so\r\n\t\t\t//treat as a normal HTTP request\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Scan xml for tag child of the current element\r\n\t *\r\n\t * @param reader reader, must be at \"start element\" @nonnull\r\n\t * @param tagName name of child tag to find @nonnull\r\n\t * @return if found tag\r\n\t * @throws XMLStreamException on error\r\n\t */\r\n\tstatic boolean scanForChildTag(XMLStreamReader reader, String tagName)\r\n\t\t\tthrows XMLStreamException {\r\n\t\tassert reader.isStartElement();\r\n\r\n\t\tint level = -1;\r\n\t\twhile (reader.hasNext()) {\r\n\t\t\t//keep track of level so we only search children, not descendants\r\n\t\t\tif (reader.isStartElement()) {\r\n\t\t\t\tlevel++;\r\n\t\t\t} else if (reader.isEndElement()) {\r\n\t\t\t\tlevel--;\r\n\t\t\t}\r\n\t\t\tif (level < 0) {\r\n\t\t\t\t//end parent tag - no more children\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treader.next();\r\n\r\n\t\t\tif (level == 0 && reader.isStartElement() && reader.getLocalName().equals(tagName)) {\r\n\t\t\t\treturn true; //found\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false; //got to end of parent element and not found\r\n\t}\r\n\r\n\t/**\r\n\t * Try to parse SOAP method name from request body stream.  Does not close the stream.\r\n\t *\r\n\t * @param stream SOAP request body stream @nonnull\r\n\t * @param charEncoding character encoding of stream, or null for platform default @null\r\n\t * @return SOAP method name, or null if unable to parse @null\r\n\t */\r\n\tprivate static String parseSoapMethodName(InputStream stream, String charEncoding) {\r\n\t\ttry {\r\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\r\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\r\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // disable DTDs entirely for that factory\r\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // disable external entities\r\n\t\t\tfinal XMLStreamReader xmlReader;\r\n\t\t\tif (charEncoding != null) {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\r\n\t\t\t} else {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\r\n\t\t\t}\r\n\r\n\t\t\t//best-effort parsing\r\n\r\n\t\t\t//start document, go to first tag\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//expect first tag to be \"Envelope\"\r\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\r\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\r\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\t//scan for body tag\r\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\r\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//tag is method name\r\n\t\t\treturn \".\" + xmlReader.getLocalName();\r\n\t\t} catch (final XMLStreamException e) {\r\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\r\n\t\t\t//failed\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic BufferedReader getReader() throws IOException {\r\n\t\tif (bufferedInputStream == null) {\r\n\t\t\treturn super.getReader();\r\n\t\t}\r\n\t\tif (reader == null) {\r\n\t\t\t// use character encoding as said in the API\r\n\t\t\tfinal String characterEncoding = this.getCharacterEncoding();\r\n\t\t\tif (characterEncoding == null) {\r\n\t\t\t\treader = new BufferedReader(new InputStreamReader(this.getInputStream()));\r\n\t\t\t} else {\r\n\t\t\t\treader = new BufferedReader(\r\n\t\t\t\t\t\tnew InputStreamReader(this.getInputStream(), characterEncoding));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn reader;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic ServletInputStream getInputStream() throws IOException {\r\n\t\tfinal ServletInputStream requestInputStream = super.getInputStream();\r\n\t\tif (bufferedInputStream == null) {\r\n\t\t\treturn requestInputStream;\r\n\t\t}\r\n\t\tif (inputStream == null) {\r\n\t\t\tfinal BufferedInputStream myBufferedInputStream = bufferedInputStream;\r\n\t\t\t//CHECKSTYLE:OFF\r\n\t\t\tinputStream = new ServletInputStream() {\r\n\t\t\t\t//CHECKSTYLE:ON\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic int read() throws IOException {\r\n\t\t\t\t\treturn myBufferedInputStream.read();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic boolean isFinished() {\r\n\t\t\t\t\treturn requestInputStream.isFinished();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic boolean isReady() {\r\n\t\t\t\t\treturn requestInputStream.isReady();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void setReadListener(ReadListener readListener) {\r\n\t\t\t\t\trequestInputStream.setReadListener(readListener);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn inputStream;\r\n\t}\r\n\r\n\t/**\r\n\t * @return name of request, or null if we can't figure out a good name based on\r\n\t *   the request payload @null\r\n\t */\r\n\tpublic String getPayloadRequestName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\t/**\r\n\t * Get type of request.  If {@link #getPayloadRequestName()} returns non-null then\r\n\t * this method also returns non-null.\r\n\t *\r\n\t * @return type of request if or null if don't know @null\r\n\t */\r\n\tpublic String getPayloadRequestType() {\r\n\t\treturn requestType;\r\n\t}\r\n}\r\n"], "filenames": ["javamelody-core/src/main/java/net/bull/javamelody/PayloadNameRequestWrapper.java"], "buggy_code_start_loc": [237], "buggy_code_end_loc": [237], "fixing_code_start_loc": [238], "fixing_code_end_loc": [240], "type": "CWE-611", "message": "JavaMelody before 1.74.0 has XXE via parseSoapMethodName in bull/javamelody/PayloadNameRequestWrapper.java.", "other": {"cve": {"id": "CVE-2018-15531", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-26T22:29:00.590", "lastModified": "2018-11-29T21:13:01.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JavaMelody before 1.74.0 has XXE via parseSoapMethodName in bull/javamelody/PayloadNameRequestWrapper.java."}, {"lang": "es", "value": "JavaMelody en versiones anteriores a la 1.74.0 tiene XEE (XML External Entity) mediante parseSoapMethodName en bull/javamelody/PayloadNameRequestWrapper.java."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:javamelody_project:javamelody:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.74.0", "matchCriteriaId": "4FFBA7BE-3258-4012-A81A-5A8FD701F33D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2018/09/25/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/javamelody/javamelody/commit/ef111822562d0b9365bd3e671a75b65bd0613353", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/javamelody/javamelody/wiki/ReleaseNotes", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://jenkins.io/security/advisory/2018-09-25/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/javamelody/javamelody/commit/ef111822562d0b9365bd3e671a75b65bd0613353"}}