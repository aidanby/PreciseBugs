{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Driver for the Conexant CX23885/7/8 PCIe bridge\n *\n *  CX23888 Integrated Consumer Infrared Controller\n *\n *  Copyright (C) 2009  Andy Walls <awalls@md.metrocast.net>\n */\n\n#include \"cx23885.h\"\n#include \"cx23888-ir.h\"\n\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-device.h>\n#include <media/rc-core.h>\n\nstatic unsigned int ir_888_debug;\nmodule_param(ir_888_debug, int, 0644);\nMODULE_PARM_DESC(ir_888_debug, \"enable debug messages [CX23888 IR controller]\");\n\n#define CX23888_IR_REG_BASE\t0x170000\n/*\n * These CX23888 register offsets have a straightforward one to one mapping\n * to the CX23885 register offsets of 0x200 through 0x218\n */\n#define CX23888_IR_CNTRL_REG\t0x170000\n#define CNTRL_WIN_3_3\t0x00000000\n#define CNTRL_WIN_4_3\t0x00000001\n#define CNTRL_WIN_3_4\t0x00000002\n#define CNTRL_WIN_4_4\t0x00000003\n#define CNTRL_WIN\t0x00000003\n#define CNTRL_EDG_NONE\t0x00000000\n#define CNTRL_EDG_FALL\t0x00000004\n#define CNTRL_EDG_RISE\t0x00000008\n#define CNTRL_EDG_BOTH\t0x0000000C\n#define CNTRL_EDG\t0x0000000C\n#define CNTRL_DMD\t0x00000010\n#define CNTRL_MOD\t0x00000020\n#define CNTRL_RFE\t0x00000040\n#define CNTRL_TFE\t0x00000080\n#define CNTRL_RXE\t0x00000100\n#define CNTRL_TXE\t0x00000200\n#define CNTRL_RIC\t0x00000400\n#define CNTRL_TIC\t0x00000800\n#define CNTRL_CPL\t0x00001000\n#define CNTRL_LBM\t0x00002000\n#define CNTRL_R\t\t0x00004000\n/* CX23888 specific control flag */\n#define CNTRL_IVO\t0x00008000\n\n#define CX23888_IR_TXCLK_REG\t0x170004\n#define TXCLK_TCD\t0x0000FFFF\n\n#define CX23888_IR_RXCLK_REG\t0x170008\n#define RXCLK_RCD\t0x0000FFFF\n\n#define CX23888_IR_CDUTY_REG\t0x17000C\n#define CDUTY_CDC\t0x0000000F\n\n#define CX23888_IR_STATS_REG\t0x170010\n#define STATS_RTO\t0x00000001\n#define STATS_ROR\t0x00000002\n#define STATS_RBY\t0x00000004\n#define STATS_TBY\t0x00000008\n#define STATS_RSR\t0x00000010\n#define STATS_TSR\t0x00000020\n\n#define CX23888_IR_IRQEN_REG\t0x170014\n#define IRQEN_RTE\t0x00000001\n#define IRQEN_ROE\t0x00000002\n#define IRQEN_RSE\t0x00000010\n#define IRQEN_TSE\t0x00000020\n\n#define CX23888_IR_FILTR_REG\t0x170018\n#define FILTR_LPF\t0x0000FFFF\n\n/* This register doesn't follow the pattern; it's 0x23C on a CX23885 */\n#define CX23888_IR_FIFO_REG\t0x170040\n#define FIFO_RXTX\t0x0000FFFF\n#define FIFO_RXTX_LVL\t0x00010000\n#define FIFO_RXTX_RTO\t0x0001FFFF\n#define FIFO_RX_NDV\t0x00020000\n#define FIFO_RX_DEPTH\t8\n#define FIFO_TX_DEPTH\t8\n\n/* CX23888 unique registers */\n#define CX23888_IR_SEEDP_REG\t0x17001C\n#define CX23888_IR_TIMOL_REG\t0x170020\n#define CX23888_IR_WAKE0_REG\t0x170024\n#define CX23888_IR_WAKE1_REG\t0x170028\n#define CX23888_IR_WAKE2_REG\t0x17002C\n#define CX23888_IR_MASK0_REG\t0x170030\n#define CX23888_IR_MASK1_REG\t0x170034\n#define CX23888_IR_MAKS2_REG\t0x170038\n#define CX23888_IR_DPIPG_REG\t0x17003C\n#define CX23888_IR_LEARN_REG\t0x170044\n\n#define CX23888_VIDCLK_FREQ\t108000000 /* 108 MHz, BT.656 */\n#define CX23888_IR_REFCLK_FREQ\t(CX23888_VIDCLK_FREQ / 2)\n\n/*\n * We use this union internally for convenience, but callers to tx_write\n * and rx_read will be expecting records of type struct ir_raw_event.\n * Always ensure the size of this union is dictated by struct ir_raw_event.\n */\nunion cx23888_ir_fifo_rec {\n\tu32 hw_fifo_data;\n\tstruct ir_raw_event ir_core_data;\n};\n\n#define CX23888_IR_RX_KFIFO_SIZE    (256 * sizeof(union cx23888_ir_fifo_rec))\n#define CX23888_IR_TX_KFIFO_SIZE    (256 * sizeof(union cx23888_ir_fifo_rec))\n\nstruct cx23888_ir_state {\n\tstruct v4l2_subdev sd;\n\tstruct cx23885_dev *dev;\n\n\tstruct v4l2_subdev_ir_parameters rx_params;\n\tstruct mutex rx_params_lock;\n\tatomic_t rxclk_divider;\n\tatomic_t rx_invert;\n\n\tstruct kfifo rx_kfifo;\n\tspinlock_t rx_kfifo_lock;\n\n\tstruct v4l2_subdev_ir_parameters tx_params;\n\tstruct mutex tx_params_lock;\n\tatomic_t txclk_divider;\n};\n\nstatic inline struct cx23888_ir_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn v4l2_get_subdevdata(sd);\n}\n\n/*\n * IR register block read and write functions\n */\nstatic\ninline int cx23888_ir_write4(struct cx23885_dev *dev, u32 addr, u32 value)\n{\n\tcx_write(addr, value);\n\treturn 0;\n}\n\nstatic inline u32 cx23888_ir_read4(struct cx23885_dev *dev, u32 addr)\n{\n\treturn cx_read(addr);\n}\n\nstatic inline int cx23888_ir_and_or4(struct cx23885_dev *dev, u32 addr,\n\t\t\t\t     u32 and_mask, u32 or_value)\n{\n\tcx_andor(addr, ~and_mask, or_value);\n\treturn 0;\n}\n\n/*\n * Rx and Tx Clock Divider register computations\n *\n * Note the largest clock divider value of 0xffff corresponds to:\n *\t(0xffff + 1) * 1000 / 108/2 MHz = 1,213,629.629... ns\n * which fits in 21 bits, so we'll use unsigned int for time arguments.\n */\nstatic inline u16 count_to_clock_divider(unsigned int d)\n{\n\tif (d > RXCLK_RCD + 1)\n\t\td = RXCLK_RCD;\n\telse if (d < 2)\n\t\td = 1;\n\telse\n\t\td--;\n\treturn (u16) d;\n}\n\nstatic inline u16 ns_to_clock_divider(unsigned int ns)\n{\n\treturn count_to_clock_divider(\n\t\tDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ / 1000000 * ns, 1000));\n}\n\nstatic inline unsigned int clock_divider_to_ns(unsigned int divider)\n{\n\t/* Period of the Rx or Tx clock in ns */\n\treturn DIV_ROUND_CLOSEST((divider + 1) * 1000,\n\t\t\t\t CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic inline u16 carrier_freq_to_clock_divider(unsigned int freq)\n{\n\treturn count_to_clock_divider(\n\t\t\t  DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, freq * 16));\n}\n\nstatic inline unsigned int clock_divider_to_carrier_freq(unsigned int divider)\n{\n\treturn DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, (divider + 1) * 16);\n}\n\nstatic inline u16 freq_to_clock_divider(unsigned int freq,\n\t\t\t\t\tunsigned int rollovers)\n{\n\treturn count_to_clock_divider(\n\t\t   DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, freq * rollovers));\n}\n\nstatic inline unsigned int clock_divider_to_freq(unsigned int divider,\n\t\t\t\t\t\t unsigned int rollovers)\n{\n\treturn DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ,\n\t\t\t\t (divider + 1) * rollovers);\n}\n\n/*\n * Low Pass Filter register calculations\n *\n * Note the largest count value of 0xffff corresponds to:\n *\t0xffff * 1000 / 108/2 MHz = 1,213,611.11... ns\n * which fits in 21 bits, so we'll use unsigned int for time arguments.\n */\nstatic inline u16 count_to_lpf_count(unsigned int d)\n{\n\tif (d > FILTR_LPF)\n\t\td = FILTR_LPF;\n\telse if (d < 4)\n\t\td = 0;\n\treturn (u16) d;\n}\n\nstatic inline u16 ns_to_lpf_count(unsigned int ns)\n{\n\treturn count_to_lpf_count(\n\t\tDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ / 1000000 * ns, 1000));\n}\n\nstatic inline unsigned int lpf_count_to_ns(unsigned int count)\n{\n\t/* Duration of the Low Pass Filter rejection window in ns */\n\treturn DIV_ROUND_CLOSEST(count * 1000,\n\t\t\t\t CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic inline unsigned int lpf_count_to_us(unsigned int count)\n{\n\t/* Duration of the Low Pass Filter rejection window in us */\n\treturn DIV_ROUND_CLOSEST(count, CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\n/*\n * FIFO register pulse width count computations\n */\nstatic u32 clock_divider_to_resolution(u16 divider)\n{\n\t/*\n\t * Resolution is the duration of 1 tick of the readable portion of\n\t * of the pulse width counter as read from the FIFO.  The two lsb's are\n\t * not readable, hence the << 2.  This function returns ns.\n\t */\n\treturn DIV_ROUND_CLOSEST((1 << 2)  * ((u32) divider + 1) * 1000,\n\t\t\t\t CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic u64 pulse_width_count_to_ns(u16 count, u16 divider)\n{\n\tu64 n;\n\tu32 rem;\n\n\t/*\n\t * The 2 lsb's of the pulse width timer count are not readable, hence\n\t * the (count << 2) | 0x3\n\t */\n\tn = (((u64) count << 2) | 0x3) * (divider + 1) * 1000; /* millicycles */\n\trem = do_div(n, CX23888_IR_REFCLK_FREQ / 1000000);     /* / MHz => ns */\n\tif (rem >= CX23888_IR_REFCLK_FREQ / 1000000 / 2)\n\t\tn++;\n\treturn n;\n}\n\nstatic unsigned int pulse_width_count_to_us(u16 count, u16 divider)\n{\n\tu64 n;\n\tu32 rem;\n\n\t/*\n\t * The 2 lsb's of the pulse width timer count are not readable, hence\n\t * the (count << 2) | 0x3\n\t */\n\tn = (((u64) count << 2) | 0x3) * (divider + 1);    /* cycles      */\n\trem = do_div(n, CX23888_IR_REFCLK_FREQ / 1000000); /* / MHz => us */\n\tif (rem >= CX23888_IR_REFCLK_FREQ / 1000000 / 2)\n\t\tn++;\n\treturn (unsigned int) n;\n}\n\n/*\n * Pulse Clocks computations: Combined Pulse Width Count & Rx Clock Counts\n *\n * The total pulse clock count is an 18 bit pulse width timer count as the most\n * significant part and (up to) 16 bit clock divider count as a modulus.\n * When the Rx clock divider ticks down to 0, it increments the 18 bit pulse\n * width timer count's least significant bit.\n */\nstatic u64 ns_to_pulse_clocks(u32 ns)\n{\n\tu64 clocks;\n\tu32 rem;\n\tclocks = CX23888_IR_REFCLK_FREQ / 1000000 * (u64) ns; /* millicycles  */\n\trem = do_div(clocks, 1000);                         /* /1000 = cycles */\n\tif (rem >= 1000 / 2)\n\t\tclocks++;\n\treturn clocks;\n}\n\nstatic u16 pulse_clocks_to_clock_divider(u64 count)\n{\n\tdo_div(count, (FIFO_RXTX << 2) | 0x3);\n\n\t/* net result needs to be rounded down and decremented by 1 */\n\tif (count > RXCLK_RCD + 1)\n\t\tcount = RXCLK_RCD;\n\telse if (count < 2)\n\t\tcount = 1;\n\telse\n\t\tcount--;\n\treturn (u16) count;\n}\n\n/*\n * IR Control Register helpers\n */\nenum tx_fifo_watermark {\n\tTX_FIFO_HALF_EMPTY = 0,\n\tTX_FIFO_EMPTY      = CNTRL_TIC,\n};\n\nenum rx_fifo_watermark {\n\tRX_FIFO_HALF_FULL = 0,\n\tRX_FIFO_NOT_EMPTY = CNTRL_RIC,\n};\n\nstatic inline void control_tx_irq_watermark(struct cx23885_dev *dev,\n\t\t\t\t\t    enum tx_fifo_watermark level)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_TIC, level);\n}\n\nstatic inline void control_rx_irq_watermark(struct cx23885_dev *dev,\n\t\t\t\t\t    enum rx_fifo_watermark level)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_RIC, level);\n}\n\nstatic inline void control_tx_enable(struct cx23885_dev *dev, bool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~(CNTRL_TXE | CNTRL_TFE),\n\t\t\t   enable ? (CNTRL_TXE | CNTRL_TFE) : 0);\n}\n\nstatic inline void control_rx_enable(struct cx23885_dev *dev, bool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~(CNTRL_RXE | CNTRL_RFE),\n\t\t\t   enable ? (CNTRL_RXE | CNTRL_RFE) : 0);\n}\n\nstatic inline void control_tx_modulation_enable(struct cx23885_dev *dev,\n\t\t\t\t\t\tbool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_MOD,\n\t\t\t   enable ? CNTRL_MOD : 0);\n}\n\nstatic inline void control_rx_demodulation_enable(struct cx23885_dev *dev,\n\t\t\t\t\t\t  bool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_DMD,\n\t\t\t   enable ? CNTRL_DMD : 0);\n}\n\nstatic inline void control_rx_s_edge_detection(struct cx23885_dev *dev,\n\t\t\t\t\t       u32 edge_types)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_EDG_BOTH,\n\t\t\t   edge_types & CNTRL_EDG_BOTH);\n}\n\nstatic void control_rx_s_carrier_window(struct cx23885_dev *dev,\n\t\t\t\t\tunsigned int carrier,\n\t\t\t\t\tunsigned int *carrier_range_low,\n\t\t\t\t\tunsigned int *carrier_range_high)\n{\n\tu32 v;\n\tunsigned int c16 = carrier * 16;\n\n\tif (*carrier_range_low < DIV_ROUND_CLOSEST(c16, 16 + 3)) {\n\t\tv = CNTRL_WIN_3_4;\n\t\t*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 4);\n\t} else {\n\t\tv = CNTRL_WIN_3_3;\n\t\t*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 3);\n\t}\n\n\tif (*carrier_range_high > DIV_ROUND_CLOSEST(c16, 16 - 3)) {\n\t\tv |= CNTRL_WIN_4_3;\n\t\t*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 4);\n\t} else {\n\t\tv |= CNTRL_WIN_3_3;\n\t\t*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 3);\n\t}\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_WIN, v);\n}\n\nstatic inline void control_tx_polarity_invert(struct cx23885_dev *dev,\n\t\t\t\t\t      bool invert)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_CPL,\n\t\t\t   invert ? CNTRL_CPL : 0);\n}\n\nstatic inline void control_tx_level_invert(struct cx23885_dev *dev,\n\t\t\t\t\t  bool invert)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_IVO,\n\t\t\t   invert ? CNTRL_IVO : 0);\n}\n\n/*\n * IR Rx & Tx Clock Register helpers\n */\nstatic unsigned int txclk_tx_s_carrier(struct cx23885_dev *dev,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       u16 *divider)\n{\n\t*divider = carrier_freq_to_clock_divider(freq);\n\tcx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);\n\treturn clock_divider_to_carrier_freq(*divider);\n}\n\nstatic unsigned int rxclk_rx_s_carrier(struct cx23885_dev *dev,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       u16 *divider)\n{\n\t*divider = carrier_freq_to_clock_divider(freq);\n\tcx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, *divider);\n\treturn clock_divider_to_carrier_freq(*divider);\n}\n\nstatic u32 txclk_tx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,\n\t\t\t\t      u16 *divider)\n{\n\tu64 pulse_clocks;\n\n\tif (ns > IR_MAX_DURATION)\n\t\tns = IR_MAX_DURATION;\n\tpulse_clocks = ns_to_pulse_clocks(ns);\n\t*divider = pulse_clocks_to_clock_divider(pulse_clocks);\n\tcx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);\n\treturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\n}\n\nstatic u32 rxclk_rx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,\n\t\t\t\t      u16 *divider)\n{\n\tu64 pulse_clocks;\n\n\tif (ns > IR_MAX_DURATION)\n\t\tns = IR_MAX_DURATION;\n\tpulse_clocks = ns_to_pulse_clocks(ns);\n\t*divider = pulse_clocks_to_clock_divider(pulse_clocks);\n\tcx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, *divider);\n\treturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\n}\n\n/*\n * IR Tx Carrier Duty Cycle register helpers\n */\nstatic unsigned int cduty_tx_s_duty_cycle(struct cx23885_dev *dev,\n\t\t\t\t\t  unsigned int duty_cycle)\n{\n\tu32 n;\n\tn = DIV_ROUND_CLOSEST(duty_cycle * 100, 625); /* 16ths of 100% */\n\tif (n != 0)\n\t\tn--;\n\tif (n > 15)\n\t\tn = 15;\n\tcx23888_ir_write4(dev, CX23888_IR_CDUTY_REG, n);\n\treturn DIV_ROUND_CLOSEST((n + 1) * 100, 16);\n}\n\n/*\n * IR Filter Register helpers\n */\nstatic u32 filter_rx_s_min_width(struct cx23885_dev *dev, u32 min_width_ns)\n{\n\tu32 count = ns_to_lpf_count(min_width_ns);\n\tcx23888_ir_write4(dev, CX23888_IR_FILTR_REG, count);\n\treturn lpf_count_to_ns(count);\n}\n\n/*\n * IR IRQ Enable Register helpers\n */\nstatic inline void irqenable_rx(struct cx23885_dev *dev, u32 mask)\n{\n\tmask &= (IRQEN_RTE | IRQEN_ROE | IRQEN_RSE);\n\tcx23888_ir_and_or4(dev, CX23888_IR_IRQEN_REG,\n\t\t\t   ~(IRQEN_RTE | IRQEN_ROE | IRQEN_RSE), mask);\n}\n\nstatic inline void irqenable_tx(struct cx23885_dev *dev, u32 mask)\n{\n\tmask &= IRQEN_TSE;\n\tcx23888_ir_and_or4(dev, CX23888_IR_IRQEN_REG, ~IRQEN_TSE, mask);\n}\n\n/*\n * V4L2 Subdevice IR Ops\n */\nstatic int cx23888_ir_irq_handler(struct v4l2_subdev *sd, u32 status,\n\t\t\t\t  bool *handled)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tunsigned long flags;\n\n\tu32 cntrl = cx23888_ir_read4(dev, CX23888_IR_CNTRL_REG);\n\tu32 irqen = cx23888_ir_read4(dev, CX23888_IR_IRQEN_REG);\n\tu32 stats = cx23888_ir_read4(dev, CX23888_IR_STATS_REG);\n\n\tunion cx23888_ir_fifo_rec rx_data[FIFO_RX_DEPTH];\n\tunsigned int i, j, k;\n\tu32 events, v;\n\tint tsr, rsr, rto, ror, tse, rse, rte, roe, kror;\n\n\ttsr = stats & STATS_TSR; /* Tx FIFO Service Request */\n\trsr = stats & STATS_RSR; /* Rx FIFO Service Request */\n\trto = stats & STATS_RTO; /* Rx Pulse Width Timer Time Out */\n\tror = stats & STATS_ROR; /* Rx FIFO Over Run */\n\n\ttse = irqen & IRQEN_TSE; /* Tx FIFO Service Request IRQ Enable */\n\trse = irqen & IRQEN_RSE; /* Rx FIFO Service Request IRQ Enable */\n\trte = irqen & IRQEN_RTE; /* Rx Pulse Width Timer Time Out IRQ Enable */\n\troe = irqen & IRQEN_ROE; /* Rx FIFO Over Run IRQ Enable */\n\n\t*handled = false;\n\tv4l2_dbg(2, ir_888_debug, sd, \"IRQ Status:  %s %s %s %s %s %s\\n\",\n\t\t tsr ? \"tsr\" : \"   \", rsr ? \"rsr\" : \"   \",\n\t\t rto ? \"rto\" : \"   \", ror ? \"ror\" : \"   \",\n\t\t stats & STATS_TBY ? \"tby\" : \"   \",\n\t\t stats & STATS_RBY ? \"rby\" : \"   \");\n\n\tv4l2_dbg(2, ir_888_debug, sd, \"IRQ Enables: %s %s %s %s\\n\",\n\t\t tse ? \"tse\" : \"   \", rse ? \"rse\" : \"   \",\n\t\t rte ? \"rte\" : \"   \", roe ? \"roe\" : \"   \");\n\n\t/*\n\t * Transmitter interrupt service\n\t */\n\tif (tse && tsr) {\n\t\t/*\n\t\t * TODO:\n\t\t * Check the watermark threshold setting\n\t\t * Pull FIFO_TX_DEPTH or FIFO_TX_DEPTH/2 entries from tx_kfifo\n\t\t * Push the data to the hardware FIFO.\n\t\t * If there was nothing more to send in the tx_kfifo, disable\n\t\t *\tthe TSR IRQ and notify the v4l2_device.\n\t\t * If there was something in the tx_kfifo, check the tx_kfifo\n\t\t *      level and notify the v4l2_device, if it is low.\n\t\t */\n\t\t/* For now, inhibit TSR interrupt until Tx is implemented */\n\t\tirqenable_tx(dev, 0);\n\t\tevents = V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ;\n\t\tv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_TX_NOTIFY, &events);\n\t\t*handled = true;\n\t}\n\n\t/*\n\t * Receiver interrupt service\n\t */\n\tkror = 0;\n\tif ((rse && rsr) || (rte && rto)) {\n\t\t/*\n\t\t * Receive data on RSR to clear the STATS_RSR.\n\t\t * Receive data on RTO, since we may not have yet hit the RSR\n\t\t * watermark when we receive the RTO.\n\t\t */\n\t\tfor (i = 0, v = FIFO_RX_NDV;\n\t\t     (v & FIFO_RX_NDV) && !kror; i = 0) {\n\t\t\tfor (j = 0;\n\t\t\t     (v & FIFO_RX_NDV) && j < FIFO_RX_DEPTH; j++) {\n\t\t\t\tv = cx23888_ir_read4(dev, CX23888_IR_FIFO_REG);\n\t\t\t\trx_data[i].hw_fifo_data = v & ~FIFO_RX_NDV;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tj = i * sizeof(union cx23888_ir_fifo_rec);\n\t\t\tk = kfifo_in_locked(&state->rx_kfifo,\n\t\t\t\t      (unsigned char *) rx_data, j,\n\t\t\t\t      &state->rx_kfifo_lock);\n\t\t\tif (k != j)\n\t\t\t\tkror++; /* rx_kfifo over run */\n\t\t}\n\t\t*handled = true;\n\t}\n\n\tevents = 0;\n\tv = 0;\n\tif (kror) {\n\t\tevents |= V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN;\n\t\tv4l2_err(sd, \"IR receiver software FIFO overrun\\n\");\n\t}\n\tif (roe && ror) {\n\t\t/*\n\t\t * The RX FIFO Enable (CNTRL_RFE) must be toggled to clear\n\t\t * the Rx FIFO Over Run status (STATS_ROR)\n\t\t */\n\t\tv |= CNTRL_RFE;\n\t\tevents |= V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN;\n\t\tv4l2_err(sd, \"IR receiver hardware FIFO overrun\\n\");\n\t}\n\tif (rte && rto) {\n\t\t/*\n\t\t * The IR Receiver Enable (CNTRL_RXE) must be toggled to clear\n\t\t * the Rx Pulse Width Timer Time Out (STATS_RTO)\n\t\t */\n\t\tv |= CNTRL_RXE;\n\t\tevents |= V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED;\n\t}\n\tif (v) {\n\t\t/* Clear STATS_ROR & STATS_RTO as needed by resetting hardware */\n\t\tcx23888_ir_write4(dev, CX23888_IR_CNTRL_REG, cntrl & ~v);\n\t\tcx23888_ir_write4(dev, CX23888_IR_CNTRL_REG, cntrl);\n\t\t*handled = true;\n\t}\n\n\tspin_lock_irqsave(&state->rx_kfifo_lock, flags);\n\tif (kfifo_len(&state->rx_kfifo) >= CX23888_IR_RX_KFIFO_SIZE / 2)\n\t\tevents |= V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ;\n\tspin_unlock_irqrestore(&state->rx_kfifo_lock, flags);\n\n\tif (events)\n\t\tv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_RX_NOTIFY, &events);\n\treturn 0;\n}\n\n/* Receiver */\nstatic int cx23888_ir_rx_read(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t      ssize_t *num)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tbool invert = (bool) atomic_read(&state->rx_invert);\n\tu16 divider = (u16) atomic_read(&state->rxclk_divider);\n\n\tunsigned int i, n;\n\tunion cx23888_ir_fifo_rec *p;\n\tunsigned u, v, w;\n\n\tn = count / sizeof(union cx23888_ir_fifo_rec)\n\t\t* sizeof(union cx23888_ir_fifo_rec);\n\tif (n == 0) {\n\t\t*num = 0;\n\t\treturn 0;\n\t}\n\n\tn = kfifo_out_locked(&state->rx_kfifo, buf, n, &state->rx_kfifo_lock);\n\n\tn /= sizeof(union cx23888_ir_fifo_rec);\n\t*num = n * sizeof(union cx23888_ir_fifo_rec);\n\n\tfor (p = (union cx23888_ir_fifo_rec *) buf, i = 0; i < n; p++, i++) {\n\n\t\tif ((p->hw_fifo_data & FIFO_RXTX_RTO) == FIFO_RXTX_RTO) {\n\t\t\t/* Assume RTO was because of no IR light input */\n\t\t\tu = 0;\n\t\t\tw = 1;\n\t\t} else {\n\t\t\tu = (p->hw_fifo_data & FIFO_RXTX_LVL) ? 1 : 0;\n\t\t\tif (invert)\n\t\t\t\tu = u ? 0 : 1;\n\t\t\tw = 0;\n\t\t}\n\n\t\tv = (unsigned) pulse_width_count_to_ns(\n\t\t\t\t  (u16) (p->hw_fifo_data & FIFO_RXTX), divider);\n\t\tif (v > IR_MAX_DURATION)\n\t\t\tv = IR_MAX_DURATION;\n\n\t\tp->ir_core_data = (struct ir_raw_event)\n\t\t\t{ .pulse = u, .duration = v, .timeout = w };\n\n\t\tv4l2_dbg(2, ir_888_debug, sd, \"rx read: %10u ns  %s  %s\\n\",\n\t\t\t v, u ? \"mark\" : \"space\", w ? \"(timed out)\" : \"\");\n\t\tif (w)\n\t\t\tv4l2_dbg(2, ir_888_debug, sd, \"rx read: end of rx\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int cx23888_ir_rx_g_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tmutex_lock(&state->rx_params_lock);\n\tmemcpy(p, &state->rx_params, sizeof(struct v4l2_subdev_ir_parameters));\n\tmutex_unlock(&state->rx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_rx_shutdown(struct v4l2_subdev *sd)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\n\tmutex_lock(&state->rx_params_lock);\n\n\t/* Disable or slow down all IR Rx circuits and counters */\n\tirqenable_rx(dev, 0);\n\tcontrol_rx_enable(dev, false);\n\tcontrol_rx_demodulation_enable(dev, false);\n\tcontrol_rx_s_edge_detection(dev, CNTRL_EDG_NONE);\n\tfilter_rx_s_min_width(dev, 0);\n\tcx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, RXCLK_RCD);\n\n\tstate->rx_params.shutdown = true;\n\n\tmutex_unlock(&state->rx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_rx_s_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tstruct v4l2_subdev_ir_parameters *o = &state->rx_params;\n\tu16 rxclk_divider;\n\n\tif (p->shutdown)\n\t\treturn cx23888_ir_rx_shutdown(sd);\n\n\tif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&state->rx_params_lock);\n\n\to->shutdown = p->shutdown;\n\n\to->mode = p->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\n\n\to->bytes_per_data_element = p->bytes_per_data_element\n\t\t\t\t  = sizeof(union cx23888_ir_fifo_rec);\n\n\t/* Before we tweak the hardware, we have to disable the receiver */\n\tirqenable_rx(dev, 0);\n\tcontrol_rx_enable(dev, false);\n\n\tcontrol_rx_demodulation_enable(dev, p->modulation);\n\to->modulation = p->modulation;\n\n\tif (p->modulation) {\n\t\tp->carrier_freq = rxclk_rx_s_carrier(dev, p->carrier_freq,\n\t\t\t\t\t\t     &rxclk_divider);\n\n\t\to->carrier_freq = p->carrier_freq;\n\n\t\to->duty_cycle = p->duty_cycle = 50;\n\n\t\tcontrol_rx_s_carrier_window(dev, p->carrier_freq,\n\t\t\t\t\t    &p->carrier_range_lower,\n\t\t\t\t\t    &p->carrier_range_upper);\n\t\to->carrier_range_lower = p->carrier_range_lower;\n\t\to->carrier_range_upper = p->carrier_range_upper;\n\n\t\tp->max_pulse_width =\n\t\t\t(u32) pulse_width_count_to_ns(FIFO_RXTX, rxclk_divider);\n\t} else {\n\t\tp->max_pulse_width =\n\t\t\t    rxclk_rx_s_max_pulse_width(dev, p->max_pulse_width,\n\t\t\t\t\t\t       &rxclk_divider);\n\t}\n\to->max_pulse_width = p->max_pulse_width;\n\tatomic_set(&state->rxclk_divider, rxclk_divider);\n\n\tp->noise_filter_min_width =\n\t\t\t  filter_rx_s_min_width(dev, p->noise_filter_min_width);\n\to->noise_filter_min_width = p->noise_filter_min_width;\n\n\tp->resolution = clock_divider_to_resolution(rxclk_divider);\n\to->resolution = p->resolution;\n\n\t/* FIXME - make this dependent on resolution for better performance */\n\tcontrol_rx_irq_watermark(dev, RX_FIFO_HALF_FULL);\n\n\tcontrol_rx_s_edge_detection(dev, CNTRL_EDG_BOTH);\n\n\to->invert_level = p->invert_level;\n\tatomic_set(&state->rx_invert, p->invert_level);\n\n\to->interrupt_enable = p->interrupt_enable;\n\to->enable = p->enable;\n\tif (p->enable) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&state->rx_kfifo_lock, flags);\n\t\tkfifo_reset(&state->rx_kfifo);\n\t\t/* reset tx_fifo too if there is one... */\n\t\tspin_unlock_irqrestore(&state->rx_kfifo_lock, flags);\n\t\tif (p->interrupt_enable)\n\t\t\tirqenable_rx(dev, IRQEN_RSE | IRQEN_RTE | IRQEN_ROE);\n\t\tcontrol_rx_enable(dev, p->enable);\n\t}\n\n\tmutex_unlock(&state->rx_params_lock);\n\treturn 0;\n}\n\n/* Transmitter */\nstatic int cx23888_ir_tx_write(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t       ssize_t *num)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\t/* For now enable the Tx FIFO Service interrupt & pretend we did work */\n\tirqenable_tx(dev, IRQEN_TSE);\n\t*num = count;\n\treturn 0;\n}\n\nstatic int cx23888_ir_tx_g_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tmutex_lock(&state->tx_params_lock);\n\tmemcpy(p, &state->tx_params, sizeof(struct v4l2_subdev_ir_parameters));\n\tmutex_unlock(&state->tx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_tx_shutdown(struct v4l2_subdev *sd)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\n\tmutex_lock(&state->tx_params_lock);\n\n\t/* Disable or slow down all IR Tx circuits and counters */\n\tirqenable_tx(dev, 0);\n\tcontrol_tx_enable(dev, false);\n\tcontrol_tx_modulation_enable(dev, false);\n\tcx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, TXCLK_TCD);\n\n\tstate->tx_params.shutdown = true;\n\n\tmutex_unlock(&state->tx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_tx_s_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tstruct v4l2_subdev_ir_parameters *o = &state->tx_params;\n\tu16 txclk_divider;\n\n\tif (p->shutdown)\n\t\treturn cx23888_ir_tx_shutdown(sd);\n\n\tif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&state->tx_params_lock);\n\n\to->shutdown = p->shutdown;\n\n\to->mode = p->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\n\n\to->bytes_per_data_element = p->bytes_per_data_element\n\t\t\t\t  = sizeof(union cx23888_ir_fifo_rec);\n\n\t/* Before we tweak the hardware, we have to disable the transmitter */\n\tirqenable_tx(dev, 0);\n\tcontrol_tx_enable(dev, false);\n\n\tcontrol_tx_modulation_enable(dev, p->modulation);\n\to->modulation = p->modulation;\n\n\tif (p->modulation) {\n\t\tp->carrier_freq = txclk_tx_s_carrier(dev, p->carrier_freq,\n\t\t\t\t\t\t     &txclk_divider);\n\t\to->carrier_freq = p->carrier_freq;\n\n\t\tp->duty_cycle = cduty_tx_s_duty_cycle(dev, p->duty_cycle);\n\t\to->duty_cycle = p->duty_cycle;\n\n\t\tp->max_pulse_width =\n\t\t\t(u32) pulse_width_count_to_ns(FIFO_RXTX, txclk_divider);\n\t} else {\n\t\tp->max_pulse_width =\n\t\t\t    txclk_tx_s_max_pulse_width(dev, p->max_pulse_width,\n\t\t\t\t\t\t       &txclk_divider);\n\t}\n\to->max_pulse_width = p->max_pulse_width;\n\tatomic_set(&state->txclk_divider, txclk_divider);\n\n\tp->resolution = clock_divider_to_resolution(txclk_divider);\n\to->resolution = p->resolution;\n\n\t/* FIXME - make this dependent on resolution for better performance */\n\tcontrol_tx_irq_watermark(dev, TX_FIFO_HALF_EMPTY);\n\n\tcontrol_tx_polarity_invert(dev, p->invert_carrier_sense);\n\to->invert_carrier_sense = p->invert_carrier_sense;\n\n\tcontrol_tx_level_invert(dev, p->invert_level);\n\to->invert_level = p->invert_level;\n\n\to->interrupt_enable = p->interrupt_enable;\n\to->enable = p->enable;\n\tif (p->enable) {\n\t\tif (p->interrupt_enable)\n\t\t\tirqenable_tx(dev, IRQEN_TSE);\n\t\tcontrol_tx_enable(dev, p->enable);\n\t}\n\n\tmutex_unlock(&state->tx_params_lock);\n\treturn 0;\n}\n\n\n/*\n * V4L2 Subdevice Core Ops\n */\nstatic int cx23888_ir_log_status(struct v4l2_subdev *sd)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tchar *s;\n\tint i, j;\n\n\tu32 cntrl = cx23888_ir_read4(dev, CX23888_IR_CNTRL_REG);\n\tu32 txclk = cx23888_ir_read4(dev, CX23888_IR_TXCLK_REG) & TXCLK_TCD;\n\tu32 rxclk = cx23888_ir_read4(dev, CX23888_IR_RXCLK_REG) & RXCLK_RCD;\n\tu32 cduty = cx23888_ir_read4(dev, CX23888_IR_CDUTY_REG) & CDUTY_CDC;\n\tu32 stats = cx23888_ir_read4(dev, CX23888_IR_STATS_REG);\n\tu32 irqen = cx23888_ir_read4(dev, CX23888_IR_IRQEN_REG);\n\tu32 filtr = cx23888_ir_read4(dev, CX23888_IR_FILTR_REG) & FILTR_LPF;\n\n\tv4l2_info(sd, \"IR Receiver:\\n\");\n\tv4l2_info(sd, \"\\tEnabled:                           %s\\n\",\n\t\t  cntrl & CNTRL_RXE ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tDemodulation from a carrier:       %s\\n\",\n\t\t  cntrl & CNTRL_DMD ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO:                              %s\\n\",\n\t\t  cntrl & CNTRL_RFE ? \"enabled\" : \"disabled\");\n\tswitch (cntrl & CNTRL_EDG) {\n\tcase CNTRL_EDG_NONE:\n\t\ts = \"disabled\";\n\t\tbreak;\n\tcase CNTRL_EDG_FALL:\n\t\ts = \"falling edge\";\n\t\tbreak;\n\tcase CNTRL_EDG_RISE:\n\t\ts = \"rising edge\";\n\t\tbreak;\n\tcase CNTRL_EDG_BOTH:\n\t\ts = \"rising & falling edges\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"??? edge\";\n\t\tbreak;\n\t}\n\tv4l2_info(sd, \"\\tPulse timers' start/stop trigger:  %s\\n\", s);\n\tv4l2_info(sd, \"\\tFIFO data on pulse timer overflow: %s\\n\",\n\t\t  cntrl & CNTRL_R ? \"not loaded\" : \"overflow marker\");\n\tv4l2_info(sd, \"\\tFIFO interrupt watermark:          %s\\n\",\n\t\t  cntrl & CNTRL_RIC ? \"not empty\" : \"half full or greater\");\n\tv4l2_info(sd, \"\\tLoopback mode:                     %s\\n\",\n\t\t  cntrl & CNTRL_LBM ? \"loopback active\" : \"normal receive\");\n\tif (cntrl & CNTRL_DMD) {\n\t\tv4l2_info(sd, \"\\tExpected carrier (16 clocks):      %u Hz\\n\",\n\t\t\t  clock_divider_to_carrier_freq(rxclk));\n\t\tswitch (cntrl & CNTRL_WIN) {\n\t\tcase CNTRL_WIN_3_3:\n\t\t\ti = 3;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_3:\n\t\t\ti = 4;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_3_4:\n\t\t\ti = 3;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_4:\n\t\t\ti = 4;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\t}\n\t\tv4l2_info(sd, \"\\tNext carrier edge window:\t    16 clocks -%1d/+%1d, %u to %u Hz\\n\",\n\t\t\t  i, j,\n\t\t\t  clock_divider_to_freq(rxclk, 16 + j),\n\t\t\t  clock_divider_to_freq(rxclk, 16 - i));\n\t}\n\tv4l2_info(sd, \"\\tMax measurable pulse width:        %u us, %llu ns\\n\",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, rxclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, rxclk));\n\tv4l2_info(sd, \"\\tLow pass filter:                   %s\\n\",\n\t\t  filtr ? \"enabled\" : \"disabled\");\n\tif (filtr)\n\t\tv4l2_info(sd, \"\\tMin acceptable pulse width (LPF):  %u us, %u ns\\n\",\n\t\t\t  lpf_count_to_us(filtr),\n\t\t\t  lpf_count_to_ns(filtr));\n\tv4l2_info(sd, \"\\tPulse width timer timed-out:       %s\\n\",\n\t\t  stats & STATS_RTO ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tPulse width timer time-out intr:   %s\\n\",\n\t\t  irqen & IRQEN_RTE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO overrun:                      %s\\n\",\n\t\t  stats & STATS_ROR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO overrun interrupt:            %s\\n\",\n\t\t  irqen & IRQEN_ROE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tBusy:                              %s\\n\",\n\t\t  stats & STATS_RBY ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service requested:            %s\\n\",\n\t\t  stats & STATS_RSR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service request interrupt:    %s\\n\",\n\t\t  irqen & IRQEN_RSE ? \"enabled\" : \"disabled\");\n\n\tv4l2_info(sd, \"IR Transmitter:\\n\");\n\tv4l2_info(sd, \"\\tEnabled:                           %s\\n\",\n\t\t  cntrl & CNTRL_TXE ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tModulation onto a carrier:         %s\\n\",\n\t\t  cntrl & CNTRL_MOD ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO:                              %s\\n\",\n\t\t  cntrl & CNTRL_TFE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO interrupt watermark:          %s\\n\",\n\t\t  cntrl & CNTRL_TIC ? \"not empty\" : \"half full or less\");\n\tv4l2_info(sd, \"\\tOutput pin level inversion         %s\\n\",\n\t\t  cntrl & CNTRL_IVO ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tCarrier polarity:                  %s\\n\",\n\t\t  cntrl & CNTRL_CPL ? \"space:burst mark:noburst\"\n\t\t\t\t    : \"space:noburst mark:burst\");\n\tif (cntrl & CNTRL_MOD) {\n\t\tv4l2_info(sd, \"\\tCarrier (16 clocks):               %u Hz\\n\",\n\t\t\t  clock_divider_to_carrier_freq(txclk));\n\t\tv4l2_info(sd, \"\\tCarrier duty cycle:                %2u/16\\n\",\n\t\t\t  cduty + 1);\n\t}\n\tv4l2_info(sd, \"\\tMax pulse width:                   %u us, %llu ns\\n\",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, txclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, txclk));\n\tv4l2_info(sd, \"\\tBusy:                              %s\\n\",\n\t\t  stats & STATS_TBY ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service requested:            %s\\n\",\n\t\t  stats & STATS_TSR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service request interrupt:    %s\\n\",\n\t\t  irqen & IRQEN_TSE ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int cx23888_ir_g_register(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_dbg_register *reg)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tu32 addr = CX23888_IR_REG_BASE + (u32) reg->reg;\n\n\tif ((addr & 0x3) != 0)\n\t\treturn -EINVAL;\n\tif (addr < CX23888_IR_CNTRL_REG || addr > CX23888_IR_LEARN_REG)\n\t\treturn -EINVAL;\n\treg->size = 4;\n\treg->val = cx23888_ir_read4(state->dev, addr);\n\treturn 0;\n}\n\nstatic int cx23888_ir_s_register(struct v4l2_subdev *sd,\n\t\t\t\t const struct v4l2_dbg_register *reg)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tu32 addr = CX23888_IR_REG_BASE + (u32) reg->reg;\n\n\tif ((addr & 0x3) != 0)\n\t\treturn -EINVAL;\n\tif (addr < CX23888_IR_CNTRL_REG || addr > CX23888_IR_LEARN_REG)\n\t\treturn -EINVAL;\n\tcx23888_ir_write4(state->dev, addr, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_subdev_core_ops cx23888_ir_core_ops = {\n\t.log_status = cx23888_ir_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = cx23888_ir_g_register,\n\t.s_register = cx23888_ir_s_register,\n#endif\n\t.interrupt_service_routine = cx23888_ir_irq_handler,\n};\n\nstatic const struct v4l2_subdev_ir_ops cx23888_ir_ir_ops = {\n\t.rx_read = cx23888_ir_rx_read,\n\t.rx_g_parameters = cx23888_ir_rx_g_parameters,\n\t.rx_s_parameters = cx23888_ir_rx_s_parameters,\n\n\t.tx_write = cx23888_ir_tx_write,\n\t.tx_g_parameters = cx23888_ir_tx_g_parameters,\n\t.tx_s_parameters = cx23888_ir_tx_s_parameters,\n};\n\nstatic const struct v4l2_subdev_ops cx23888_ir_controller_ops = {\n\t.core = &cx23888_ir_core_ops,\n\t.ir = &cx23888_ir_ir_ops,\n};\n\nstatic const struct v4l2_subdev_ir_parameters default_rx_params = {\n\t.bytes_per_data_element = sizeof(union cx23888_ir_fifo_rec),\n\t.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n\n\t.enable = false,\n\t.interrupt_enable = false,\n\t.shutdown = true,\n\n\t.modulation = true,\n\t.carrier_freq = 36000, /* 36 kHz - RC-5, RC-6, and RC-6A carrier */\n\n\t/* RC-5:    666,667 ns = 1/36 kHz * 32 cycles * 1 mark * 0.75 */\n\t/* RC-6A:   333,333 ns = 1/36 kHz * 16 cycles * 1 mark * 0.75 */\n\t.noise_filter_min_width = 333333, /* ns */\n\t.carrier_range_lower = 35000,\n\t.carrier_range_upper = 37000,\n\t.invert_level = false,\n};\n\nstatic const struct v4l2_subdev_ir_parameters default_tx_params = {\n\t.bytes_per_data_element = sizeof(union cx23888_ir_fifo_rec),\n\t.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n\n\t.enable = false,\n\t.interrupt_enable = false,\n\t.shutdown = true,\n\n\t.modulation = true,\n\t.carrier_freq = 36000, /* 36 kHz - RC-5 carrier */\n\t.duty_cycle = 25,      /* 25 %   - RC-5 carrier */\n\t.invert_level = false,\n\t.invert_carrier_sense = false,\n};\n\nint cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}\n\nint cx23888_ir_remove(struct cx23885_dev *dev)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct cx23888_ir_state *state;\n\n\tsd = cx23885_find_hw(dev, CX23885_HW_888_IR);\n\tif (sd == NULL)\n\t\treturn -ENODEV;\n\n\tcx23888_ir_rx_shutdown(sd);\n\tcx23888_ir_tx_shutdown(sd);\n\n\tstate = to_state(sd);\n\tv4l2_device_unregister_subdev(sd);\n\tkfifo_free(&state->rx_kfifo);\n\tkfree(state);\n\t/* Nothing more to free() as state held the actual v4l2_subdev object */\n\treturn 0;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Driver for the Conexant CX23885/7/8 PCIe bridge\n *\n *  CX23888 Integrated Consumer Infrared Controller\n *\n *  Copyright (C) 2009  Andy Walls <awalls@md.metrocast.net>\n */\n\n#include \"cx23885.h\"\n#include \"cx23888-ir.h\"\n\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-device.h>\n#include <media/rc-core.h>\n\nstatic unsigned int ir_888_debug;\nmodule_param(ir_888_debug, int, 0644);\nMODULE_PARM_DESC(ir_888_debug, \"enable debug messages [CX23888 IR controller]\");\n\n#define CX23888_IR_REG_BASE\t0x170000\n/*\n * These CX23888 register offsets have a straightforward one to one mapping\n * to the CX23885 register offsets of 0x200 through 0x218\n */\n#define CX23888_IR_CNTRL_REG\t0x170000\n#define CNTRL_WIN_3_3\t0x00000000\n#define CNTRL_WIN_4_3\t0x00000001\n#define CNTRL_WIN_3_4\t0x00000002\n#define CNTRL_WIN_4_4\t0x00000003\n#define CNTRL_WIN\t0x00000003\n#define CNTRL_EDG_NONE\t0x00000000\n#define CNTRL_EDG_FALL\t0x00000004\n#define CNTRL_EDG_RISE\t0x00000008\n#define CNTRL_EDG_BOTH\t0x0000000C\n#define CNTRL_EDG\t0x0000000C\n#define CNTRL_DMD\t0x00000010\n#define CNTRL_MOD\t0x00000020\n#define CNTRL_RFE\t0x00000040\n#define CNTRL_TFE\t0x00000080\n#define CNTRL_RXE\t0x00000100\n#define CNTRL_TXE\t0x00000200\n#define CNTRL_RIC\t0x00000400\n#define CNTRL_TIC\t0x00000800\n#define CNTRL_CPL\t0x00001000\n#define CNTRL_LBM\t0x00002000\n#define CNTRL_R\t\t0x00004000\n/* CX23888 specific control flag */\n#define CNTRL_IVO\t0x00008000\n\n#define CX23888_IR_TXCLK_REG\t0x170004\n#define TXCLK_TCD\t0x0000FFFF\n\n#define CX23888_IR_RXCLK_REG\t0x170008\n#define RXCLK_RCD\t0x0000FFFF\n\n#define CX23888_IR_CDUTY_REG\t0x17000C\n#define CDUTY_CDC\t0x0000000F\n\n#define CX23888_IR_STATS_REG\t0x170010\n#define STATS_RTO\t0x00000001\n#define STATS_ROR\t0x00000002\n#define STATS_RBY\t0x00000004\n#define STATS_TBY\t0x00000008\n#define STATS_RSR\t0x00000010\n#define STATS_TSR\t0x00000020\n\n#define CX23888_IR_IRQEN_REG\t0x170014\n#define IRQEN_RTE\t0x00000001\n#define IRQEN_ROE\t0x00000002\n#define IRQEN_RSE\t0x00000010\n#define IRQEN_TSE\t0x00000020\n\n#define CX23888_IR_FILTR_REG\t0x170018\n#define FILTR_LPF\t0x0000FFFF\n\n/* This register doesn't follow the pattern; it's 0x23C on a CX23885 */\n#define CX23888_IR_FIFO_REG\t0x170040\n#define FIFO_RXTX\t0x0000FFFF\n#define FIFO_RXTX_LVL\t0x00010000\n#define FIFO_RXTX_RTO\t0x0001FFFF\n#define FIFO_RX_NDV\t0x00020000\n#define FIFO_RX_DEPTH\t8\n#define FIFO_TX_DEPTH\t8\n\n/* CX23888 unique registers */\n#define CX23888_IR_SEEDP_REG\t0x17001C\n#define CX23888_IR_TIMOL_REG\t0x170020\n#define CX23888_IR_WAKE0_REG\t0x170024\n#define CX23888_IR_WAKE1_REG\t0x170028\n#define CX23888_IR_WAKE2_REG\t0x17002C\n#define CX23888_IR_MASK0_REG\t0x170030\n#define CX23888_IR_MASK1_REG\t0x170034\n#define CX23888_IR_MAKS2_REG\t0x170038\n#define CX23888_IR_DPIPG_REG\t0x17003C\n#define CX23888_IR_LEARN_REG\t0x170044\n\n#define CX23888_VIDCLK_FREQ\t108000000 /* 108 MHz, BT.656 */\n#define CX23888_IR_REFCLK_FREQ\t(CX23888_VIDCLK_FREQ / 2)\n\n/*\n * We use this union internally for convenience, but callers to tx_write\n * and rx_read will be expecting records of type struct ir_raw_event.\n * Always ensure the size of this union is dictated by struct ir_raw_event.\n */\nunion cx23888_ir_fifo_rec {\n\tu32 hw_fifo_data;\n\tstruct ir_raw_event ir_core_data;\n};\n\n#define CX23888_IR_RX_KFIFO_SIZE    (256 * sizeof(union cx23888_ir_fifo_rec))\n#define CX23888_IR_TX_KFIFO_SIZE    (256 * sizeof(union cx23888_ir_fifo_rec))\n\nstruct cx23888_ir_state {\n\tstruct v4l2_subdev sd;\n\tstruct cx23885_dev *dev;\n\n\tstruct v4l2_subdev_ir_parameters rx_params;\n\tstruct mutex rx_params_lock;\n\tatomic_t rxclk_divider;\n\tatomic_t rx_invert;\n\n\tstruct kfifo rx_kfifo;\n\tspinlock_t rx_kfifo_lock;\n\n\tstruct v4l2_subdev_ir_parameters tx_params;\n\tstruct mutex tx_params_lock;\n\tatomic_t txclk_divider;\n};\n\nstatic inline struct cx23888_ir_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn v4l2_get_subdevdata(sd);\n}\n\n/*\n * IR register block read and write functions\n */\nstatic\ninline int cx23888_ir_write4(struct cx23885_dev *dev, u32 addr, u32 value)\n{\n\tcx_write(addr, value);\n\treturn 0;\n}\n\nstatic inline u32 cx23888_ir_read4(struct cx23885_dev *dev, u32 addr)\n{\n\treturn cx_read(addr);\n}\n\nstatic inline int cx23888_ir_and_or4(struct cx23885_dev *dev, u32 addr,\n\t\t\t\t     u32 and_mask, u32 or_value)\n{\n\tcx_andor(addr, ~and_mask, or_value);\n\treturn 0;\n}\n\n/*\n * Rx and Tx Clock Divider register computations\n *\n * Note the largest clock divider value of 0xffff corresponds to:\n *\t(0xffff + 1) * 1000 / 108/2 MHz = 1,213,629.629... ns\n * which fits in 21 bits, so we'll use unsigned int for time arguments.\n */\nstatic inline u16 count_to_clock_divider(unsigned int d)\n{\n\tif (d > RXCLK_RCD + 1)\n\t\td = RXCLK_RCD;\n\telse if (d < 2)\n\t\td = 1;\n\telse\n\t\td--;\n\treturn (u16) d;\n}\n\nstatic inline u16 ns_to_clock_divider(unsigned int ns)\n{\n\treturn count_to_clock_divider(\n\t\tDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ / 1000000 * ns, 1000));\n}\n\nstatic inline unsigned int clock_divider_to_ns(unsigned int divider)\n{\n\t/* Period of the Rx or Tx clock in ns */\n\treturn DIV_ROUND_CLOSEST((divider + 1) * 1000,\n\t\t\t\t CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic inline u16 carrier_freq_to_clock_divider(unsigned int freq)\n{\n\treturn count_to_clock_divider(\n\t\t\t  DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, freq * 16));\n}\n\nstatic inline unsigned int clock_divider_to_carrier_freq(unsigned int divider)\n{\n\treturn DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, (divider + 1) * 16);\n}\n\nstatic inline u16 freq_to_clock_divider(unsigned int freq,\n\t\t\t\t\tunsigned int rollovers)\n{\n\treturn count_to_clock_divider(\n\t\t   DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, freq * rollovers));\n}\n\nstatic inline unsigned int clock_divider_to_freq(unsigned int divider,\n\t\t\t\t\t\t unsigned int rollovers)\n{\n\treturn DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ,\n\t\t\t\t (divider + 1) * rollovers);\n}\n\n/*\n * Low Pass Filter register calculations\n *\n * Note the largest count value of 0xffff corresponds to:\n *\t0xffff * 1000 / 108/2 MHz = 1,213,611.11... ns\n * which fits in 21 bits, so we'll use unsigned int for time arguments.\n */\nstatic inline u16 count_to_lpf_count(unsigned int d)\n{\n\tif (d > FILTR_LPF)\n\t\td = FILTR_LPF;\n\telse if (d < 4)\n\t\td = 0;\n\treturn (u16) d;\n}\n\nstatic inline u16 ns_to_lpf_count(unsigned int ns)\n{\n\treturn count_to_lpf_count(\n\t\tDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ / 1000000 * ns, 1000));\n}\n\nstatic inline unsigned int lpf_count_to_ns(unsigned int count)\n{\n\t/* Duration of the Low Pass Filter rejection window in ns */\n\treturn DIV_ROUND_CLOSEST(count * 1000,\n\t\t\t\t CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic inline unsigned int lpf_count_to_us(unsigned int count)\n{\n\t/* Duration of the Low Pass Filter rejection window in us */\n\treturn DIV_ROUND_CLOSEST(count, CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\n/*\n * FIFO register pulse width count computations\n */\nstatic u32 clock_divider_to_resolution(u16 divider)\n{\n\t/*\n\t * Resolution is the duration of 1 tick of the readable portion of\n\t * of the pulse width counter as read from the FIFO.  The two lsb's are\n\t * not readable, hence the << 2.  This function returns ns.\n\t */\n\treturn DIV_ROUND_CLOSEST((1 << 2)  * ((u32) divider + 1) * 1000,\n\t\t\t\t CX23888_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic u64 pulse_width_count_to_ns(u16 count, u16 divider)\n{\n\tu64 n;\n\tu32 rem;\n\n\t/*\n\t * The 2 lsb's of the pulse width timer count are not readable, hence\n\t * the (count << 2) | 0x3\n\t */\n\tn = (((u64) count << 2) | 0x3) * (divider + 1) * 1000; /* millicycles */\n\trem = do_div(n, CX23888_IR_REFCLK_FREQ / 1000000);     /* / MHz => ns */\n\tif (rem >= CX23888_IR_REFCLK_FREQ / 1000000 / 2)\n\t\tn++;\n\treturn n;\n}\n\nstatic unsigned int pulse_width_count_to_us(u16 count, u16 divider)\n{\n\tu64 n;\n\tu32 rem;\n\n\t/*\n\t * The 2 lsb's of the pulse width timer count are not readable, hence\n\t * the (count << 2) | 0x3\n\t */\n\tn = (((u64) count << 2) | 0x3) * (divider + 1);    /* cycles      */\n\trem = do_div(n, CX23888_IR_REFCLK_FREQ / 1000000); /* / MHz => us */\n\tif (rem >= CX23888_IR_REFCLK_FREQ / 1000000 / 2)\n\t\tn++;\n\treturn (unsigned int) n;\n}\n\n/*\n * Pulse Clocks computations: Combined Pulse Width Count & Rx Clock Counts\n *\n * The total pulse clock count is an 18 bit pulse width timer count as the most\n * significant part and (up to) 16 bit clock divider count as a modulus.\n * When the Rx clock divider ticks down to 0, it increments the 18 bit pulse\n * width timer count's least significant bit.\n */\nstatic u64 ns_to_pulse_clocks(u32 ns)\n{\n\tu64 clocks;\n\tu32 rem;\n\tclocks = CX23888_IR_REFCLK_FREQ / 1000000 * (u64) ns; /* millicycles  */\n\trem = do_div(clocks, 1000);                         /* /1000 = cycles */\n\tif (rem >= 1000 / 2)\n\t\tclocks++;\n\treturn clocks;\n}\n\nstatic u16 pulse_clocks_to_clock_divider(u64 count)\n{\n\tdo_div(count, (FIFO_RXTX << 2) | 0x3);\n\n\t/* net result needs to be rounded down and decremented by 1 */\n\tif (count > RXCLK_RCD + 1)\n\t\tcount = RXCLK_RCD;\n\telse if (count < 2)\n\t\tcount = 1;\n\telse\n\t\tcount--;\n\treturn (u16) count;\n}\n\n/*\n * IR Control Register helpers\n */\nenum tx_fifo_watermark {\n\tTX_FIFO_HALF_EMPTY = 0,\n\tTX_FIFO_EMPTY      = CNTRL_TIC,\n};\n\nenum rx_fifo_watermark {\n\tRX_FIFO_HALF_FULL = 0,\n\tRX_FIFO_NOT_EMPTY = CNTRL_RIC,\n};\n\nstatic inline void control_tx_irq_watermark(struct cx23885_dev *dev,\n\t\t\t\t\t    enum tx_fifo_watermark level)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_TIC, level);\n}\n\nstatic inline void control_rx_irq_watermark(struct cx23885_dev *dev,\n\t\t\t\t\t    enum rx_fifo_watermark level)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_RIC, level);\n}\n\nstatic inline void control_tx_enable(struct cx23885_dev *dev, bool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~(CNTRL_TXE | CNTRL_TFE),\n\t\t\t   enable ? (CNTRL_TXE | CNTRL_TFE) : 0);\n}\n\nstatic inline void control_rx_enable(struct cx23885_dev *dev, bool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~(CNTRL_RXE | CNTRL_RFE),\n\t\t\t   enable ? (CNTRL_RXE | CNTRL_RFE) : 0);\n}\n\nstatic inline void control_tx_modulation_enable(struct cx23885_dev *dev,\n\t\t\t\t\t\tbool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_MOD,\n\t\t\t   enable ? CNTRL_MOD : 0);\n}\n\nstatic inline void control_rx_demodulation_enable(struct cx23885_dev *dev,\n\t\t\t\t\t\t  bool enable)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_DMD,\n\t\t\t   enable ? CNTRL_DMD : 0);\n}\n\nstatic inline void control_rx_s_edge_detection(struct cx23885_dev *dev,\n\t\t\t\t\t       u32 edge_types)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_EDG_BOTH,\n\t\t\t   edge_types & CNTRL_EDG_BOTH);\n}\n\nstatic void control_rx_s_carrier_window(struct cx23885_dev *dev,\n\t\t\t\t\tunsigned int carrier,\n\t\t\t\t\tunsigned int *carrier_range_low,\n\t\t\t\t\tunsigned int *carrier_range_high)\n{\n\tu32 v;\n\tunsigned int c16 = carrier * 16;\n\n\tif (*carrier_range_low < DIV_ROUND_CLOSEST(c16, 16 + 3)) {\n\t\tv = CNTRL_WIN_3_4;\n\t\t*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 4);\n\t} else {\n\t\tv = CNTRL_WIN_3_3;\n\t\t*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 3);\n\t}\n\n\tif (*carrier_range_high > DIV_ROUND_CLOSEST(c16, 16 - 3)) {\n\t\tv |= CNTRL_WIN_4_3;\n\t\t*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 4);\n\t} else {\n\t\tv |= CNTRL_WIN_3_3;\n\t\t*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 3);\n\t}\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_WIN, v);\n}\n\nstatic inline void control_tx_polarity_invert(struct cx23885_dev *dev,\n\t\t\t\t\t      bool invert)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_CPL,\n\t\t\t   invert ? CNTRL_CPL : 0);\n}\n\nstatic inline void control_tx_level_invert(struct cx23885_dev *dev,\n\t\t\t\t\t  bool invert)\n{\n\tcx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_IVO,\n\t\t\t   invert ? CNTRL_IVO : 0);\n}\n\n/*\n * IR Rx & Tx Clock Register helpers\n */\nstatic unsigned int txclk_tx_s_carrier(struct cx23885_dev *dev,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       u16 *divider)\n{\n\t*divider = carrier_freq_to_clock_divider(freq);\n\tcx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);\n\treturn clock_divider_to_carrier_freq(*divider);\n}\n\nstatic unsigned int rxclk_rx_s_carrier(struct cx23885_dev *dev,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       u16 *divider)\n{\n\t*divider = carrier_freq_to_clock_divider(freq);\n\tcx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, *divider);\n\treturn clock_divider_to_carrier_freq(*divider);\n}\n\nstatic u32 txclk_tx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,\n\t\t\t\t      u16 *divider)\n{\n\tu64 pulse_clocks;\n\n\tif (ns > IR_MAX_DURATION)\n\t\tns = IR_MAX_DURATION;\n\tpulse_clocks = ns_to_pulse_clocks(ns);\n\t*divider = pulse_clocks_to_clock_divider(pulse_clocks);\n\tcx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);\n\treturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\n}\n\nstatic u32 rxclk_rx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,\n\t\t\t\t      u16 *divider)\n{\n\tu64 pulse_clocks;\n\n\tif (ns > IR_MAX_DURATION)\n\t\tns = IR_MAX_DURATION;\n\tpulse_clocks = ns_to_pulse_clocks(ns);\n\t*divider = pulse_clocks_to_clock_divider(pulse_clocks);\n\tcx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, *divider);\n\treturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\n}\n\n/*\n * IR Tx Carrier Duty Cycle register helpers\n */\nstatic unsigned int cduty_tx_s_duty_cycle(struct cx23885_dev *dev,\n\t\t\t\t\t  unsigned int duty_cycle)\n{\n\tu32 n;\n\tn = DIV_ROUND_CLOSEST(duty_cycle * 100, 625); /* 16ths of 100% */\n\tif (n != 0)\n\t\tn--;\n\tif (n > 15)\n\t\tn = 15;\n\tcx23888_ir_write4(dev, CX23888_IR_CDUTY_REG, n);\n\treturn DIV_ROUND_CLOSEST((n + 1) * 100, 16);\n}\n\n/*\n * IR Filter Register helpers\n */\nstatic u32 filter_rx_s_min_width(struct cx23885_dev *dev, u32 min_width_ns)\n{\n\tu32 count = ns_to_lpf_count(min_width_ns);\n\tcx23888_ir_write4(dev, CX23888_IR_FILTR_REG, count);\n\treturn lpf_count_to_ns(count);\n}\n\n/*\n * IR IRQ Enable Register helpers\n */\nstatic inline void irqenable_rx(struct cx23885_dev *dev, u32 mask)\n{\n\tmask &= (IRQEN_RTE | IRQEN_ROE | IRQEN_RSE);\n\tcx23888_ir_and_or4(dev, CX23888_IR_IRQEN_REG,\n\t\t\t   ~(IRQEN_RTE | IRQEN_ROE | IRQEN_RSE), mask);\n}\n\nstatic inline void irqenable_tx(struct cx23885_dev *dev, u32 mask)\n{\n\tmask &= IRQEN_TSE;\n\tcx23888_ir_and_or4(dev, CX23888_IR_IRQEN_REG, ~IRQEN_TSE, mask);\n}\n\n/*\n * V4L2 Subdevice IR Ops\n */\nstatic int cx23888_ir_irq_handler(struct v4l2_subdev *sd, u32 status,\n\t\t\t\t  bool *handled)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tunsigned long flags;\n\n\tu32 cntrl = cx23888_ir_read4(dev, CX23888_IR_CNTRL_REG);\n\tu32 irqen = cx23888_ir_read4(dev, CX23888_IR_IRQEN_REG);\n\tu32 stats = cx23888_ir_read4(dev, CX23888_IR_STATS_REG);\n\n\tunion cx23888_ir_fifo_rec rx_data[FIFO_RX_DEPTH];\n\tunsigned int i, j, k;\n\tu32 events, v;\n\tint tsr, rsr, rto, ror, tse, rse, rte, roe, kror;\n\n\ttsr = stats & STATS_TSR; /* Tx FIFO Service Request */\n\trsr = stats & STATS_RSR; /* Rx FIFO Service Request */\n\trto = stats & STATS_RTO; /* Rx Pulse Width Timer Time Out */\n\tror = stats & STATS_ROR; /* Rx FIFO Over Run */\n\n\ttse = irqen & IRQEN_TSE; /* Tx FIFO Service Request IRQ Enable */\n\trse = irqen & IRQEN_RSE; /* Rx FIFO Service Request IRQ Enable */\n\trte = irqen & IRQEN_RTE; /* Rx Pulse Width Timer Time Out IRQ Enable */\n\troe = irqen & IRQEN_ROE; /* Rx FIFO Over Run IRQ Enable */\n\n\t*handled = false;\n\tv4l2_dbg(2, ir_888_debug, sd, \"IRQ Status:  %s %s %s %s %s %s\\n\",\n\t\t tsr ? \"tsr\" : \"   \", rsr ? \"rsr\" : \"   \",\n\t\t rto ? \"rto\" : \"   \", ror ? \"ror\" : \"   \",\n\t\t stats & STATS_TBY ? \"tby\" : \"   \",\n\t\t stats & STATS_RBY ? \"rby\" : \"   \");\n\n\tv4l2_dbg(2, ir_888_debug, sd, \"IRQ Enables: %s %s %s %s\\n\",\n\t\t tse ? \"tse\" : \"   \", rse ? \"rse\" : \"   \",\n\t\t rte ? \"rte\" : \"   \", roe ? \"roe\" : \"   \");\n\n\t/*\n\t * Transmitter interrupt service\n\t */\n\tif (tse && tsr) {\n\t\t/*\n\t\t * TODO:\n\t\t * Check the watermark threshold setting\n\t\t * Pull FIFO_TX_DEPTH or FIFO_TX_DEPTH/2 entries from tx_kfifo\n\t\t * Push the data to the hardware FIFO.\n\t\t * If there was nothing more to send in the tx_kfifo, disable\n\t\t *\tthe TSR IRQ and notify the v4l2_device.\n\t\t * If there was something in the tx_kfifo, check the tx_kfifo\n\t\t *      level and notify the v4l2_device, if it is low.\n\t\t */\n\t\t/* For now, inhibit TSR interrupt until Tx is implemented */\n\t\tirqenable_tx(dev, 0);\n\t\tevents = V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ;\n\t\tv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_TX_NOTIFY, &events);\n\t\t*handled = true;\n\t}\n\n\t/*\n\t * Receiver interrupt service\n\t */\n\tkror = 0;\n\tif ((rse && rsr) || (rte && rto)) {\n\t\t/*\n\t\t * Receive data on RSR to clear the STATS_RSR.\n\t\t * Receive data on RTO, since we may not have yet hit the RSR\n\t\t * watermark when we receive the RTO.\n\t\t */\n\t\tfor (i = 0, v = FIFO_RX_NDV;\n\t\t     (v & FIFO_RX_NDV) && !kror; i = 0) {\n\t\t\tfor (j = 0;\n\t\t\t     (v & FIFO_RX_NDV) && j < FIFO_RX_DEPTH; j++) {\n\t\t\t\tv = cx23888_ir_read4(dev, CX23888_IR_FIFO_REG);\n\t\t\t\trx_data[i].hw_fifo_data = v & ~FIFO_RX_NDV;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tj = i * sizeof(union cx23888_ir_fifo_rec);\n\t\t\tk = kfifo_in_locked(&state->rx_kfifo,\n\t\t\t\t      (unsigned char *) rx_data, j,\n\t\t\t\t      &state->rx_kfifo_lock);\n\t\t\tif (k != j)\n\t\t\t\tkror++; /* rx_kfifo over run */\n\t\t}\n\t\t*handled = true;\n\t}\n\n\tevents = 0;\n\tv = 0;\n\tif (kror) {\n\t\tevents |= V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN;\n\t\tv4l2_err(sd, \"IR receiver software FIFO overrun\\n\");\n\t}\n\tif (roe && ror) {\n\t\t/*\n\t\t * The RX FIFO Enable (CNTRL_RFE) must be toggled to clear\n\t\t * the Rx FIFO Over Run status (STATS_ROR)\n\t\t */\n\t\tv |= CNTRL_RFE;\n\t\tevents |= V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN;\n\t\tv4l2_err(sd, \"IR receiver hardware FIFO overrun\\n\");\n\t}\n\tif (rte && rto) {\n\t\t/*\n\t\t * The IR Receiver Enable (CNTRL_RXE) must be toggled to clear\n\t\t * the Rx Pulse Width Timer Time Out (STATS_RTO)\n\t\t */\n\t\tv |= CNTRL_RXE;\n\t\tevents |= V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED;\n\t}\n\tif (v) {\n\t\t/* Clear STATS_ROR & STATS_RTO as needed by resetting hardware */\n\t\tcx23888_ir_write4(dev, CX23888_IR_CNTRL_REG, cntrl & ~v);\n\t\tcx23888_ir_write4(dev, CX23888_IR_CNTRL_REG, cntrl);\n\t\t*handled = true;\n\t}\n\n\tspin_lock_irqsave(&state->rx_kfifo_lock, flags);\n\tif (kfifo_len(&state->rx_kfifo) >= CX23888_IR_RX_KFIFO_SIZE / 2)\n\t\tevents |= V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ;\n\tspin_unlock_irqrestore(&state->rx_kfifo_lock, flags);\n\n\tif (events)\n\t\tv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_RX_NOTIFY, &events);\n\treturn 0;\n}\n\n/* Receiver */\nstatic int cx23888_ir_rx_read(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t      ssize_t *num)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tbool invert = (bool) atomic_read(&state->rx_invert);\n\tu16 divider = (u16) atomic_read(&state->rxclk_divider);\n\n\tunsigned int i, n;\n\tunion cx23888_ir_fifo_rec *p;\n\tunsigned u, v, w;\n\n\tn = count / sizeof(union cx23888_ir_fifo_rec)\n\t\t* sizeof(union cx23888_ir_fifo_rec);\n\tif (n == 0) {\n\t\t*num = 0;\n\t\treturn 0;\n\t}\n\n\tn = kfifo_out_locked(&state->rx_kfifo, buf, n, &state->rx_kfifo_lock);\n\n\tn /= sizeof(union cx23888_ir_fifo_rec);\n\t*num = n * sizeof(union cx23888_ir_fifo_rec);\n\n\tfor (p = (union cx23888_ir_fifo_rec *) buf, i = 0; i < n; p++, i++) {\n\n\t\tif ((p->hw_fifo_data & FIFO_RXTX_RTO) == FIFO_RXTX_RTO) {\n\t\t\t/* Assume RTO was because of no IR light input */\n\t\t\tu = 0;\n\t\t\tw = 1;\n\t\t} else {\n\t\t\tu = (p->hw_fifo_data & FIFO_RXTX_LVL) ? 1 : 0;\n\t\t\tif (invert)\n\t\t\t\tu = u ? 0 : 1;\n\t\t\tw = 0;\n\t\t}\n\n\t\tv = (unsigned) pulse_width_count_to_ns(\n\t\t\t\t  (u16) (p->hw_fifo_data & FIFO_RXTX), divider);\n\t\tif (v > IR_MAX_DURATION)\n\t\t\tv = IR_MAX_DURATION;\n\n\t\tp->ir_core_data = (struct ir_raw_event)\n\t\t\t{ .pulse = u, .duration = v, .timeout = w };\n\n\t\tv4l2_dbg(2, ir_888_debug, sd, \"rx read: %10u ns  %s  %s\\n\",\n\t\t\t v, u ? \"mark\" : \"space\", w ? \"(timed out)\" : \"\");\n\t\tif (w)\n\t\t\tv4l2_dbg(2, ir_888_debug, sd, \"rx read: end of rx\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int cx23888_ir_rx_g_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tmutex_lock(&state->rx_params_lock);\n\tmemcpy(p, &state->rx_params, sizeof(struct v4l2_subdev_ir_parameters));\n\tmutex_unlock(&state->rx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_rx_shutdown(struct v4l2_subdev *sd)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\n\tmutex_lock(&state->rx_params_lock);\n\n\t/* Disable or slow down all IR Rx circuits and counters */\n\tirqenable_rx(dev, 0);\n\tcontrol_rx_enable(dev, false);\n\tcontrol_rx_demodulation_enable(dev, false);\n\tcontrol_rx_s_edge_detection(dev, CNTRL_EDG_NONE);\n\tfilter_rx_s_min_width(dev, 0);\n\tcx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, RXCLK_RCD);\n\n\tstate->rx_params.shutdown = true;\n\n\tmutex_unlock(&state->rx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_rx_s_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tstruct v4l2_subdev_ir_parameters *o = &state->rx_params;\n\tu16 rxclk_divider;\n\n\tif (p->shutdown)\n\t\treturn cx23888_ir_rx_shutdown(sd);\n\n\tif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&state->rx_params_lock);\n\n\to->shutdown = p->shutdown;\n\n\to->mode = p->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\n\n\to->bytes_per_data_element = p->bytes_per_data_element\n\t\t\t\t  = sizeof(union cx23888_ir_fifo_rec);\n\n\t/* Before we tweak the hardware, we have to disable the receiver */\n\tirqenable_rx(dev, 0);\n\tcontrol_rx_enable(dev, false);\n\n\tcontrol_rx_demodulation_enable(dev, p->modulation);\n\to->modulation = p->modulation;\n\n\tif (p->modulation) {\n\t\tp->carrier_freq = rxclk_rx_s_carrier(dev, p->carrier_freq,\n\t\t\t\t\t\t     &rxclk_divider);\n\n\t\to->carrier_freq = p->carrier_freq;\n\n\t\to->duty_cycle = p->duty_cycle = 50;\n\n\t\tcontrol_rx_s_carrier_window(dev, p->carrier_freq,\n\t\t\t\t\t    &p->carrier_range_lower,\n\t\t\t\t\t    &p->carrier_range_upper);\n\t\to->carrier_range_lower = p->carrier_range_lower;\n\t\to->carrier_range_upper = p->carrier_range_upper;\n\n\t\tp->max_pulse_width =\n\t\t\t(u32) pulse_width_count_to_ns(FIFO_RXTX, rxclk_divider);\n\t} else {\n\t\tp->max_pulse_width =\n\t\t\t    rxclk_rx_s_max_pulse_width(dev, p->max_pulse_width,\n\t\t\t\t\t\t       &rxclk_divider);\n\t}\n\to->max_pulse_width = p->max_pulse_width;\n\tatomic_set(&state->rxclk_divider, rxclk_divider);\n\n\tp->noise_filter_min_width =\n\t\t\t  filter_rx_s_min_width(dev, p->noise_filter_min_width);\n\to->noise_filter_min_width = p->noise_filter_min_width;\n\n\tp->resolution = clock_divider_to_resolution(rxclk_divider);\n\to->resolution = p->resolution;\n\n\t/* FIXME - make this dependent on resolution for better performance */\n\tcontrol_rx_irq_watermark(dev, RX_FIFO_HALF_FULL);\n\n\tcontrol_rx_s_edge_detection(dev, CNTRL_EDG_BOTH);\n\n\to->invert_level = p->invert_level;\n\tatomic_set(&state->rx_invert, p->invert_level);\n\n\to->interrupt_enable = p->interrupt_enable;\n\to->enable = p->enable;\n\tif (p->enable) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&state->rx_kfifo_lock, flags);\n\t\tkfifo_reset(&state->rx_kfifo);\n\t\t/* reset tx_fifo too if there is one... */\n\t\tspin_unlock_irqrestore(&state->rx_kfifo_lock, flags);\n\t\tif (p->interrupt_enable)\n\t\t\tirqenable_rx(dev, IRQEN_RSE | IRQEN_RTE | IRQEN_ROE);\n\t\tcontrol_rx_enable(dev, p->enable);\n\t}\n\n\tmutex_unlock(&state->rx_params_lock);\n\treturn 0;\n}\n\n/* Transmitter */\nstatic int cx23888_ir_tx_write(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t       ssize_t *num)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\t/* For now enable the Tx FIFO Service interrupt & pretend we did work */\n\tirqenable_tx(dev, IRQEN_TSE);\n\t*num = count;\n\treturn 0;\n}\n\nstatic int cx23888_ir_tx_g_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tmutex_lock(&state->tx_params_lock);\n\tmemcpy(p, &state->tx_params, sizeof(struct v4l2_subdev_ir_parameters));\n\tmutex_unlock(&state->tx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_tx_shutdown(struct v4l2_subdev *sd)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\n\tmutex_lock(&state->tx_params_lock);\n\n\t/* Disable or slow down all IR Tx circuits and counters */\n\tirqenable_tx(dev, 0);\n\tcontrol_tx_enable(dev, false);\n\tcontrol_tx_modulation_enable(dev, false);\n\tcx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, TXCLK_TCD);\n\n\tstate->tx_params.shutdown = true;\n\n\tmutex_unlock(&state->tx_params_lock);\n\treturn 0;\n}\n\nstatic int cx23888_ir_tx_s_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tstruct v4l2_subdev_ir_parameters *o = &state->tx_params;\n\tu16 txclk_divider;\n\n\tif (p->shutdown)\n\t\treturn cx23888_ir_tx_shutdown(sd);\n\n\tif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&state->tx_params_lock);\n\n\to->shutdown = p->shutdown;\n\n\to->mode = p->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\n\n\to->bytes_per_data_element = p->bytes_per_data_element\n\t\t\t\t  = sizeof(union cx23888_ir_fifo_rec);\n\n\t/* Before we tweak the hardware, we have to disable the transmitter */\n\tirqenable_tx(dev, 0);\n\tcontrol_tx_enable(dev, false);\n\n\tcontrol_tx_modulation_enable(dev, p->modulation);\n\to->modulation = p->modulation;\n\n\tif (p->modulation) {\n\t\tp->carrier_freq = txclk_tx_s_carrier(dev, p->carrier_freq,\n\t\t\t\t\t\t     &txclk_divider);\n\t\to->carrier_freq = p->carrier_freq;\n\n\t\tp->duty_cycle = cduty_tx_s_duty_cycle(dev, p->duty_cycle);\n\t\to->duty_cycle = p->duty_cycle;\n\n\t\tp->max_pulse_width =\n\t\t\t(u32) pulse_width_count_to_ns(FIFO_RXTX, txclk_divider);\n\t} else {\n\t\tp->max_pulse_width =\n\t\t\t    txclk_tx_s_max_pulse_width(dev, p->max_pulse_width,\n\t\t\t\t\t\t       &txclk_divider);\n\t}\n\to->max_pulse_width = p->max_pulse_width;\n\tatomic_set(&state->txclk_divider, txclk_divider);\n\n\tp->resolution = clock_divider_to_resolution(txclk_divider);\n\to->resolution = p->resolution;\n\n\t/* FIXME - make this dependent on resolution for better performance */\n\tcontrol_tx_irq_watermark(dev, TX_FIFO_HALF_EMPTY);\n\n\tcontrol_tx_polarity_invert(dev, p->invert_carrier_sense);\n\to->invert_carrier_sense = p->invert_carrier_sense;\n\n\tcontrol_tx_level_invert(dev, p->invert_level);\n\to->invert_level = p->invert_level;\n\n\to->interrupt_enable = p->interrupt_enable;\n\to->enable = p->enable;\n\tif (p->enable) {\n\t\tif (p->interrupt_enable)\n\t\t\tirqenable_tx(dev, IRQEN_TSE);\n\t\tcontrol_tx_enable(dev, p->enable);\n\t}\n\n\tmutex_unlock(&state->tx_params_lock);\n\treturn 0;\n}\n\n\n/*\n * V4L2 Subdevice Core Ops\n */\nstatic int cx23888_ir_log_status(struct v4l2_subdev *sd)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tstruct cx23885_dev *dev = state->dev;\n\tchar *s;\n\tint i, j;\n\n\tu32 cntrl = cx23888_ir_read4(dev, CX23888_IR_CNTRL_REG);\n\tu32 txclk = cx23888_ir_read4(dev, CX23888_IR_TXCLK_REG) & TXCLK_TCD;\n\tu32 rxclk = cx23888_ir_read4(dev, CX23888_IR_RXCLK_REG) & RXCLK_RCD;\n\tu32 cduty = cx23888_ir_read4(dev, CX23888_IR_CDUTY_REG) & CDUTY_CDC;\n\tu32 stats = cx23888_ir_read4(dev, CX23888_IR_STATS_REG);\n\tu32 irqen = cx23888_ir_read4(dev, CX23888_IR_IRQEN_REG);\n\tu32 filtr = cx23888_ir_read4(dev, CX23888_IR_FILTR_REG) & FILTR_LPF;\n\n\tv4l2_info(sd, \"IR Receiver:\\n\");\n\tv4l2_info(sd, \"\\tEnabled:                           %s\\n\",\n\t\t  cntrl & CNTRL_RXE ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tDemodulation from a carrier:       %s\\n\",\n\t\t  cntrl & CNTRL_DMD ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO:                              %s\\n\",\n\t\t  cntrl & CNTRL_RFE ? \"enabled\" : \"disabled\");\n\tswitch (cntrl & CNTRL_EDG) {\n\tcase CNTRL_EDG_NONE:\n\t\ts = \"disabled\";\n\t\tbreak;\n\tcase CNTRL_EDG_FALL:\n\t\ts = \"falling edge\";\n\t\tbreak;\n\tcase CNTRL_EDG_RISE:\n\t\ts = \"rising edge\";\n\t\tbreak;\n\tcase CNTRL_EDG_BOTH:\n\t\ts = \"rising & falling edges\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"??? edge\";\n\t\tbreak;\n\t}\n\tv4l2_info(sd, \"\\tPulse timers' start/stop trigger:  %s\\n\", s);\n\tv4l2_info(sd, \"\\tFIFO data on pulse timer overflow: %s\\n\",\n\t\t  cntrl & CNTRL_R ? \"not loaded\" : \"overflow marker\");\n\tv4l2_info(sd, \"\\tFIFO interrupt watermark:          %s\\n\",\n\t\t  cntrl & CNTRL_RIC ? \"not empty\" : \"half full or greater\");\n\tv4l2_info(sd, \"\\tLoopback mode:                     %s\\n\",\n\t\t  cntrl & CNTRL_LBM ? \"loopback active\" : \"normal receive\");\n\tif (cntrl & CNTRL_DMD) {\n\t\tv4l2_info(sd, \"\\tExpected carrier (16 clocks):      %u Hz\\n\",\n\t\t\t  clock_divider_to_carrier_freq(rxclk));\n\t\tswitch (cntrl & CNTRL_WIN) {\n\t\tcase CNTRL_WIN_3_3:\n\t\t\ti = 3;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_3:\n\t\t\ti = 4;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_3_4:\n\t\t\ti = 3;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_4:\n\t\t\ti = 4;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\t}\n\t\tv4l2_info(sd, \"\\tNext carrier edge window:\t    16 clocks -%1d/+%1d, %u to %u Hz\\n\",\n\t\t\t  i, j,\n\t\t\t  clock_divider_to_freq(rxclk, 16 + j),\n\t\t\t  clock_divider_to_freq(rxclk, 16 - i));\n\t}\n\tv4l2_info(sd, \"\\tMax measurable pulse width:        %u us, %llu ns\\n\",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, rxclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, rxclk));\n\tv4l2_info(sd, \"\\tLow pass filter:                   %s\\n\",\n\t\t  filtr ? \"enabled\" : \"disabled\");\n\tif (filtr)\n\t\tv4l2_info(sd, \"\\tMin acceptable pulse width (LPF):  %u us, %u ns\\n\",\n\t\t\t  lpf_count_to_us(filtr),\n\t\t\t  lpf_count_to_ns(filtr));\n\tv4l2_info(sd, \"\\tPulse width timer timed-out:       %s\\n\",\n\t\t  stats & STATS_RTO ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tPulse width timer time-out intr:   %s\\n\",\n\t\t  irqen & IRQEN_RTE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO overrun:                      %s\\n\",\n\t\t  stats & STATS_ROR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO overrun interrupt:            %s\\n\",\n\t\t  irqen & IRQEN_ROE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tBusy:                              %s\\n\",\n\t\t  stats & STATS_RBY ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service requested:            %s\\n\",\n\t\t  stats & STATS_RSR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service request interrupt:    %s\\n\",\n\t\t  irqen & IRQEN_RSE ? \"enabled\" : \"disabled\");\n\n\tv4l2_info(sd, \"IR Transmitter:\\n\");\n\tv4l2_info(sd, \"\\tEnabled:                           %s\\n\",\n\t\t  cntrl & CNTRL_TXE ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tModulation onto a carrier:         %s\\n\",\n\t\t  cntrl & CNTRL_MOD ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO:                              %s\\n\",\n\t\t  cntrl & CNTRL_TFE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO interrupt watermark:          %s\\n\",\n\t\t  cntrl & CNTRL_TIC ? \"not empty\" : \"half full or less\");\n\tv4l2_info(sd, \"\\tOutput pin level inversion         %s\\n\",\n\t\t  cntrl & CNTRL_IVO ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tCarrier polarity:                  %s\\n\",\n\t\t  cntrl & CNTRL_CPL ? \"space:burst mark:noburst\"\n\t\t\t\t    : \"space:noburst mark:burst\");\n\tif (cntrl & CNTRL_MOD) {\n\t\tv4l2_info(sd, \"\\tCarrier (16 clocks):               %u Hz\\n\",\n\t\t\t  clock_divider_to_carrier_freq(txclk));\n\t\tv4l2_info(sd, \"\\tCarrier duty cycle:                %2u/16\\n\",\n\t\t\t  cduty + 1);\n\t}\n\tv4l2_info(sd, \"\\tMax pulse width:                   %u us, %llu ns\\n\",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, txclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, txclk));\n\tv4l2_info(sd, \"\\tBusy:                              %s\\n\",\n\t\t  stats & STATS_TBY ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service requested:            %s\\n\",\n\t\t  stats & STATS_TSR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service request interrupt:    %s\\n\",\n\t\t  irqen & IRQEN_TSE ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int cx23888_ir_g_register(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_dbg_register *reg)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tu32 addr = CX23888_IR_REG_BASE + (u32) reg->reg;\n\n\tif ((addr & 0x3) != 0)\n\t\treturn -EINVAL;\n\tif (addr < CX23888_IR_CNTRL_REG || addr > CX23888_IR_LEARN_REG)\n\t\treturn -EINVAL;\n\treg->size = 4;\n\treg->val = cx23888_ir_read4(state->dev, addr);\n\treturn 0;\n}\n\nstatic int cx23888_ir_s_register(struct v4l2_subdev *sd,\n\t\t\t\t const struct v4l2_dbg_register *reg)\n{\n\tstruct cx23888_ir_state *state = to_state(sd);\n\tu32 addr = CX23888_IR_REG_BASE + (u32) reg->reg;\n\n\tif ((addr & 0x3) != 0)\n\t\treturn -EINVAL;\n\tif (addr < CX23888_IR_CNTRL_REG || addr > CX23888_IR_LEARN_REG)\n\t\treturn -EINVAL;\n\tcx23888_ir_write4(state->dev, addr, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_subdev_core_ops cx23888_ir_core_ops = {\n\t.log_status = cx23888_ir_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = cx23888_ir_g_register,\n\t.s_register = cx23888_ir_s_register,\n#endif\n\t.interrupt_service_routine = cx23888_ir_irq_handler,\n};\n\nstatic const struct v4l2_subdev_ir_ops cx23888_ir_ir_ops = {\n\t.rx_read = cx23888_ir_rx_read,\n\t.rx_g_parameters = cx23888_ir_rx_g_parameters,\n\t.rx_s_parameters = cx23888_ir_rx_s_parameters,\n\n\t.tx_write = cx23888_ir_tx_write,\n\t.tx_g_parameters = cx23888_ir_tx_g_parameters,\n\t.tx_s_parameters = cx23888_ir_tx_s_parameters,\n};\n\nstatic const struct v4l2_subdev_ops cx23888_ir_controller_ops = {\n\t.core = &cx23888_ir_core_ops,\n\t.ir = &cx23888_ir_ir_ops,\n};\n\nstatic const struct v4l2_subdev_ir_parameters default_rx_params = {\n\t.bytes_per_data_element = sizeof(union cx23888_ir_fifo_rec),\n\t.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n\n\t.enable = false,\n\t.interrupt_enable = false,\n\t.shutdown = true,\n\n\t.modulation = true,\n\t.carrier_freq = 36000, /* 36 kHz - RC-5, RC-6, and RC-6A carrier */\n\n\t/* RC-5:    666,667 ns = 1/36 kHz * 32 cycles * 1 mark * 0.75 */\n\t/* RC-6A:   333,333 ns = 1/36 kHz * 16 cycles * 1 mark * 0.75 */\n\t.noise_filter_min_width = 333333, /* ns */\n\t.carrier_range_lower = 35000,\n\t.carrier_range_upper = 37000,\n\t.invert_level = false,\n};\n\nstatic const struct v4l2_subdev_ir_parameters default_tx_params = {\n\t.bytes_per_data_element = sizeof(union cx23888_ir_fifo_rec),\n\t.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n\n\t.enable = false,\n\t.interrupt_enable = false,\n\t.shutdown = true,\n\n\t.modulation = true,\n\t.carrier_freq = 36000, /* 36 kHz - RC-5 carrier */\n\t.duty_cycle = 25,      /* 25 %   - RC-5 carrier */\n\t.invert_level = false,\n\t.invert_carrier_sense = false,\n};\n\nint cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE,\n\t\t\tGFP_KERNEL)) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}\n\nint cx23888_ir_remove(struct cx23885_dev *dev)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct cx23888_ir_state *state;\n\n\tsd = cx23885_find_hw(dev, CX23885_HW_888_IR);\n\tif (sd == NULL)\n\t\treturn -ENODEV;\n\n\tcx23888_ir_rx_shutdown(sd);\n\tcx23888_ir_tx_shutdown(sd);\n\n\tstate = to_state(sd);\n\tv4l2_device_unregister_subdev(sd);\n\tkfifo_free(&state->rx_kfifo);\n\tkfree(state);\n\t/* Nothing more to free() as state held the actual v4l2_subdev object */\n\treturn 0;\n}\n"], "filenames": ["drivers/media/pci/cx23885/cx23888-ir.c"], "buggy_code_start_loc": [1170], "buggy_code_end_loc": [1171], "fixing_code_start_loc": [1170], "fixing_code_end_loc": [1175], "type": "CWE-401", "message": "A memory leak in the cx23888_ir_probe() function in drivers/media/pci/cx23885/cx23888-ir.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering kfifo_alloc() failures, aka CID-a7b2df76b42b.", "other": {"cve": {"id": "CVE-2019-19054", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.967", "lastModified": "2022-11-08T03:18:07.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the cx23888_ir_probe() function in drivers/media/pci/cx23885/cx23888-ir.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering kfifo_alloc() failures, aka CID-a7b2df76b42b."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n cx23888_ir_probe() en el archivo drivers/media/pci/cx23885/cx23888-ir.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n de kfifo_alloc(), tambi\u00e9n se conoce como CID-a7b2df76b42b."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C0ADE5D-F91D-4E0D-B6C5-3511B19665F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "8AFF1109-26F3-43A5-A4CB-0F169FDBC0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AF71C49-ADEF-4EE2-802C-6159ADD51355"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.20:*:*:*:*:*:*:*", "matchCriteriaId": "B3BC6E59-2134-4A28-AAD2-77C8AE236BCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.25:*:*:*:*:*:*:*", "matchCriteriaId": "24377899-5389-4BDC-AC82-0E4186F4DE53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30:*:*:*:*:*:*:*", "matchCriteriaId": "23FE83DE-AE7C-4313-88E3-886110C31302"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30.5r3:*:*:*:*:*:*:*", "matchCriteriaId": "490B327B-AC20-419B-BB76-8AB6971304BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40:*:*:*:*:*:*:*", "matchCriteriaId": "8DCE2754-7A9E-4B3B-91D1-DCF90C1BABE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.3r2:*:*:*:*:*:*:*", "matchCriteriaId": "6CA74E8B-51E2-4A7C-8A98-0583D31134A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B64AB37-A1D9-4163-A51B-4C780361F1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.1:*:*:*:*:*:*:*", "matchCriteriaId": "7BE9C9D7-9CED-4184-A190-1024A6FB8C82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:-:*:*:*:*:*:*", "matchCriteriaId": "B73D4C3C-A511-4E14-B19F-91F561ACB1B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:p1:*:*:*:*:*:*", "matchCriteriaId": "0C47D72C-9B6B-4E52-AF0E-56AD58E4A930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60:*:*:*:*:*:*:*", "matchCriteriaId": "039C3790-5AA2-4895-AEAE-CC84A71DB907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4592238-D1F2-43D6-9BAB-2F63ECF9C965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BA78068-80E9-4E49-9056-88EAB7E3682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.3:*:*:*:*:*:*:*", "matchCriteriaId": "092F366C-E8B0-4BE5-B106-0B7A73B08D34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.1:*:*:*:*:*:*:*", "matchCriteriaId": "E7992E92-B159-4810-B895-01A9B944058A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.2:*:*:*:*:*:*:*", "matchCriteriaId": "5BDD7AAB-2BF3-4E8C-BEE2-5217E2926C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas\\/aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "66EEA3CA-8CC7-4F0B-8204-6132D4114873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h610s:*:*:*:*:*:*:*", "matchCriteriaId": "DE7C6010-F736-4BDA-9E3B-C4370BBFA149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:broadcom:brocade_fabric_operating_system_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B2748912-FC54-47F6-8C0C-B96784765B8E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a7b2df76b42bdd026e3106cf2ba97db41345a177", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4525-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4526-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4527-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a7b2df76b42bdd026e3106cf2ba97db41345a177"}}