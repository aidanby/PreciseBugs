{"buggy_code": ["from decimal import Decimal\n\nimport pytest\n\nfrom vyper.compiler import compile_code\nfrom vyper.exceptions import ArgumentException, CallViolation\n\npytestmark = pytest.mark.usefixtures(\"memory_mocker\")\n\n\ndef test_selfcall_code(get_contract_with_gas_estimation):\n    selfcall_code = \"\"\"\n@internal\ndef _foo() -> int128:\n    return 3\n\n@external\ndef bar() -> int128:\n    return self._foo()\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code)\n    assert c.bar() == 3\n\n    print(\"Passed no-argument self-call test\")\n\n\ndef test_selfcall_code_2(get_contract_with_gas_estimation, keccak):\n    selfcall_code_2 = \"\"\"\n@internal\ndef _double(x: int128) -> int128:\n    return x * 2\n\n@external\ndef returnten() -> int128:\n    return self._double(5)\n\n@internal\ndef _hashy(x: bytes32) -> bytes32:\n    return keccak256(x)\n\n@external\ndef return_hash_of_rzpadded_cow() -> bytes32:\n    return self._hashy(0x636f770000000000000000000000000000000000000000000000000000000000)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_2)\n    assert c.returnten() == 10\n    assert c.return_hash_of_rzpadded_cow() == keccak(b\"cow\" + b\"\\x00\" * 29)\n\n    print(\"Passed single fixed-size argument self-call test\")\n\n\n# test that side-effecting self calls do not get optimized out\ndef test_selfcall_optimizer(get_contract):\n    code = \"\"\"\ncounter: uint256\n\n@internal\ndef increment_counter() -> uint256:\n    self.counter += 1\n    return self.counter\n@external\ndef foo() -> (uint256, uint256):\n    x: uint256 = unsafe_mul(self.increment_counter(), 0)\n    return x, self.counter\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == [0, 1]\n\n\ndef test_selfcall_code_3(get_contract_with_gas_estimation, keccak):\n    selfcall_code_3 = \"\"\"\n@internal\ndef _hashy2(x: Bytes[100]) -> bytes32:\n    return keccak256(x)\n\n@external\ndef return_hash_of_cow_x_30() -> bytes32:\n    return self._hashy2(b\"cowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcow\")  # noqa: E501\n\n@internal\ndef _len(x: Bytes[100]) -> uint256:\n    return len(x)\n\n@external\ndef returnten() -> uint256:\n    return self._len(b\"badminton!\")\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_3)\n    assert c.return_hash_of_cow_x_30() == keccak(b\"cow\" * 30)\n    assert c.returnten() == 10\n\n    print(\"Passed single variable-size argument self-call test\")\n\n\ndef test_selfcall_code_4(get_contract_with_gas_estimation):\n    selfcall_code_4 = \"\"\"\n@internal\ndef _summy(x: int128, y: int128) -> int128:\n    return x + y\n\n@internal\ndef _catty(x: Bytes[5], y: Bytes[5]) -> Bytes[10]:\n    return concat(x, y)\n\n@internal\ndef _slicey1(x: Bytes[10], y: uint256) -> Bytes[10]:\n    return slice(x, 0, y)\n\n@internal\ndef _slicey2(y: uint256, x: Bytes[10]) -> Bytes[10]:\n    return slice(x, 0, y)\n\n@external\ndef returnten() -> int128:\n    return self._summy(3, 7)\n\n@external\ndef return_mongoose() -> Bytes[10]:\n    return self._catty(b\"mon\", b\"goose\")\n\n@external\ndef return_goose() -> Bytes[10]:\n    return self._slicey1(b\"goosedog\", 5)\n\n@external\ndef return_goose2() -> Bytes[10]:\n    return self._slicey2(5, b\"goosedog\")\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_4)\n    assert c.returnten() == 10\n    assert c.return_mongoose() == b\"mongoose\"\n    assert c.return_goose() == b\"goose\"\n    assert c.return_goose2() == b\"goose\"\n\n    print(\"Passed multi-argument self-call test\")\n\n\ndef test_selfcall_code_5(get_contract_with_gas_estimation):\n    selfcall_code_5 = \"\"\"\ncounter: int128\n\n@internal\ndef _increment():\n    self.counter += 1\n\n@external\ndef returnten() -> int128:\n    for i in range(10):\n        self._increment()\n    return self.counter\n    \"\"\"\n    c = get_contract_with_gas_estimation(selfcall_code_5)\n    assert c.returnten() == 10\n\n    print(\"Passed self-call statement test\")\n\n\ndef test_selfcall_code_6(get_contract_with_gas_estimation):\n    selfcall_code_6 = \"\"\"\nexcls: Bytes[32]\n\n@internal\ndef _set_excls(arg: Bytes[32]):\n    self.excls = arg\n\n@internal\ndef _underscore() -> Bytes[1]:\n    return b\"_\"\n\n@internal\ndef _hardtest(x: Bytes[100], y: uint256, z: uint256, a: Bytes[100], b: uint256, c: uint256) -> Bytes[201]:  # noqa: E501\n    return concat(slice(x, y, z), self._underscore(), slice(a, b, c))\n\n@external\ndef return_mongoose_revolution_32_excls() -> Bytes[201]:\n    self._set_excls(b\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n    return self._hardtest(b\"megamongoose123\", 4, 8, concat(b\"russian revolution\", self.excls), 8, 42)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_6)\n    assert c.return_mongoose_revolution_32_excls() == b\"mongoose_revolution\" + b\"!\" * 32\n\n    print(\"Passed composite self-call test\")\n\n\ndef test_list_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _foo0(x: int128[2]) -> int128:\n    return x[0]\n\n@internal\ndef _foo1(x: int128[2]) -> int128:\n    return x[1]\n\n\n@external\ndef foo1(x: int128[2]) -> int128:\n    return self._foo1(x)\n\n@external\ndef bar() -> int128:\n    x: int128[2] = [0, 0]\n    return self._foo0(x)\n\n@external\ndef bar2() -> int128:\n    x: int128[2] = [55, 66]\n    return self._foo0(x)\n\n@external\ndef bar3() -> int128:\n    x: int128[2] = [55, 66]\n    return self._foo1(x)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 0\n    assert c.foo1([0, 0]) == 0\n    assert c.bar2() == 55\n    assert c.bar3() == 66\n\n\ndef test_list_storage_call(get_contract_with_gas_estimation):\n    code = \"\"\"\ny: int128[2]\n\n@internal\ndef _foo0(x: int128[2]) -> int128:\n    return x[0]\n\n@internal\ndef _foo1(x: int128[2]) -> int128:\n    return x[1]\n\n@external\ndef set():\n    self.y  = [88, 99]\n\n@external\ndef bar0() -> int128:\n    return self._foo0(self.y)\n\n@external\ndef bar1() -> int128:\n    return self._foo1(self.y)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    c.set(transact={})\n    assert c.bar0() == 88\n    assert c.bar1() == 99\n\n\ndef test_multi_arg_list_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _foo0(y: decimal, x: int128[2]) -> int128:\n    return x[0]\n\n@internal\ndef _foo1(x: int128[2], y: decimal) -> int128:\n    return x[1]\n\n@internal\ndef _foo2(y: decimal, x: int128[2]) -> decimal:\n    return y\n\n@internal\ndef _foo3(x: int128[2], y: decimal) -> int128:\n    return x[0]\n\n@internal\ndef _foo4(x: int128[2], y: int128[2]) -> int128:\n    return y[0]\n\n\n@external\ndef foo1(x: int128[2], y: decimal) -> int128:\n    return self._foo1(x, y)\n\n@external\ndef bar() -> int128:\n    x: int128[2] = [0, 0]\n    return self._foo0(0.3434, x)\n\n# list as second parameter\n@external\ndef bar2() -> int128:\n    x: int128[2] = [55, 66]\n    return self._foo0(0.01, x)\n\n@external\ndef bar3() -> decimal:\n    x: int128[2] = [88, 77]\n    return self._foo2(1.33, x)\n\n# list as first parameter\n@external\ndef bar4() -> int128:\n    x: int128[2] = [88, 77]\n    return self._foo1(x, 1.33)\n\n@external\ndef bar5() -> int128:\n    x: int128[2] = [88, 77]\n    return self._foo3(x, 1.33)\n\n# two lists\n@external\ndef bar6() -> int128:\n    x: int128[2] = [88, 77]\n    y: int128[2] = [99, 66]\n    return self._foo4(x, y)\n\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 0\n    assert c.foo1([0, 0], Decimal(\"0\")) == 0\n    assert c.bar2() == 55\n    assert c.bar3() == Decimal(\"1.33\")\n    assert c.bar4() == 77\n    assert c.bar5() == 88\n\n\ndef test_multi_mixed_arg_list_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _fooz(x: int128[2], y: decimal, z: int128[2], a: decimal) -> int128:\n    return z[1]\n\n@internal\ndef _fooa(x: int128[2], y: decimal, z: int128[2], a: decimal) -> decimal:\n    return a\n\n@external\ndef bar() -> (int128, decimal):\n    x: int128[2] = [33, 44]\n    y: decimal = 55.44\n    z: int128[2] = [55, 66]\n    a: decimal = 66.77\n\n    return self._fooz(x, y, z, a), self._fooa(x, y, z, a)\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == [66, Decimal(\"66.77\")]\n\n\ndef test_internal_function_multiple_lists_as_args(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _foo(y: int128[2], x: Bytes[5]) -> int128:\n    return y[0]\n\n@internal\ndef _foo2(x: Bytes[5], y: int128[2]) -> int128:\n    return y[0]\n\n@external\ndef bar() -> int128:\n    return self._foo([1, 2], b\"hello\")\n\n@external\ndef bar2() -> int128:\n    return self._foo2(b\"hello\", [1, 2])\n\"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 1\n    assert c.bar2() == 1\n\n\ndef test_multi_mixed_arg_list_bytes_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _fooz(x: int128[2], y: decimal, z: Bytes[11], a: decimal) -> Bytes[11]:\n    return z\n\n@internal\ndef _fooa(x: int128[2], y: decimal, z: Bytes[11], a: decimal) -> decimal:\n    return a\n\n@internal\ndef _foox(x: int128[2], y: decimal, z: Bytes[11], a: decimal) -> int128:\n    return x[1]\n\n\n@external\ndef bar() -> (Bytes[11], decimal, int128):\n    x: int128[2] = [33, 44]\n    y: decimal = 55.44\n    z: Bytes[11] = b\"hello world\"\n    a: decimal = 66.77\n\n    return self._fooz(x, y, z, a), self._fooa(x, y, z, a), self._foox(x, y, z, a)\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == [b\"hello world\", Decimal(\"66.77\"), 44]\n\n\nFAILING_CONTRACTS_CALL_VIOLATION = [\n    \"\"\"\n# should not compile - public to public\n@external\ndef bar() -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar()\n    \"\"\",\n    \"\"\"\n# should not compile - internal to external\n@external\ndef bar() -> int128:\n    return 1\n\n@internal\ndef _baz() -> int128:\n    return self.bar()\n\n@external\ndef foo() -> int128:\n    return self._baz()\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"failing_contract_code\", FAILING_CONTRACTS_CALL_VIOLATION)\ndef test_selfcall_call_violation(failing_contract_code, assert_compile_failed):\n    assert_compile_failed(lambda: compile_code(failing_contract_code), CallViolation)\n\n\nFAILING_CONTRACTS_ARGUMENT_EXCEPTION = [\n    \"\"\"\n# expected no args, args given\n@internal\ndef bar() -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar(1)\n    \"\"\",\n    \"\"\"\n# expected args, none given\n@internal\ndef bar(a: int128) -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar()\n    \"\"\",\n    \"\"\"\n# wrong arg count\n@internal\ndef bar(a: int128) -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar(1, 2)\n    \"\"\",\n    \"\"\"\n@internal\ndef _foo(x: uint256, y: uint256 = 1):\n    pass\n\n@external\ndef foo(x: uint256, y: uint256):\n    self._foo(x, y=y)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"failing_contract_code\", FAILING_CONTRACTS_ARGUMENT_EXCEPTION)\ndef test_selfcall_wrong_arg_count(failing_contract_code, assert_compile_failed):\n    assert_compile_failed(lambda: compile_code(failing_contract_code), ArgumentException)\n\n\nFAILING_CONTRACTS_TYPE_MISMATCH = [\n    \"\"\"\n# should not compile - value kwarg when calling {0} function\n@{0}\ndef foo():\n    pass\n\n@external\ndef bar():\n    self.foo(value=100)\n    \"\"\",\n    \"\"\"\n# should not compile - gas kwarg when calling {0} function\n@{0}\ndef foo():\n    pass\n\n@external\ndef bar():\n    self.foo(gas=100)\n    \"\"\",\n    \"\"\"\n# should not compile - arbitrary kwargs when calling {0} function\n@{0}\ndef foo():\n    pass\n\n@external\ndef bar():\n    self.foo(baz=100)\n    \"\"\",\n    \"\"\"\n# should not compile - args-as-kwargs to a {0} function\n@{0}\ndef foo(baz: int128):\n    pass\n\n@external\ndef bar():\n    self.foo(baz=100)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"failing_contract_code\", FAILING_CONTRACTS_TYPE_MISMATCH)\n@pytest.mark.parametrize(\"decorator\", [\"external\", \"internal\"])\ndef test_selfcall_kwarg_raises(failing_contract_code, decorator, assert_compile_failed):\n    assert_compile_failed(\n        lambda: compile_code(failing_contract_code.format(decorator)),\n        ArgumentException if decorator == \"internal\" else CallViolation,\n    )\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_struct_return_1(get_contract_with_gas_estimation, i, ln, s):\n    contract = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\n@internal\ndef get_struct_x() -> X:\n    return X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n\n@external\ndef test() -> (int128, String[{ln}], Bytes[{ln}]):\n    ret: X = self.get_struct_x()\n    return ret.x, ret.y, ret.z\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.test() == [i, s, bytes(s, \"utf-8\")]\n\n\ndef test_dynamically_sized_struct_as_arg(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\n@internal\ndef _foo(x: X) -> Bytes[6]:\n    return x.y\n\n@external\ndef bar() -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return self._foo(_X)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == b\"hello\"\n\n\ndef test_dynamically_sized_struct_as_arg_2(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\n@internal\ndef _foo(x: X) -> String[6]:\n    return x.y\n\n@external\ndef bar() -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return self._foo(_X)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == \"hello\"\n\n\ndef test_dynamically_sized_struct_member_as_arg(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\n@internal\ndef _foo(s: Bytes[6]) -> Bytes[6]:\n    return s\n\n@external\ndef bar() -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return self._foo(_X.y)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == b\"hello\"\n\n\ndef test_dynamically_sized_struct_member_as_arg_2(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\n@internal\ndef _foo(s: String[6]) -> String[6]:\n    return s\n\n@external\ndef bar() -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return self._foo(_X.y)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == \"hello\"\n", "import contextlib\nimport enum\nfrom dataclasses import dataclass\nfrom typing import Any, Optional\n\nfrom vyper.codegen.ir_node import Encoding\nfrom vyper.evm.address_space import MEMORY, AddrSpace\nfrom vyper.exceptions import CompilerPanic, StateAccessViolation\nfrom vyper.semantics.types import VyperType\n\n\nclass Constancy(enum.Enum):\n    Mutable = 0\n    Constant = 1\n\n\n# Function variable\n@dataclass\nclass VariableRecord:\n    name: str\n    pos: int\n    typ: VyperType\n    mutable: bool\n    encoding: Encoding = Encoding.VYPER\n    location: AddrSpace = MEMORY\n    size: Optional[int] = None  # allocated size\n    blockscopes: Optional[list] = None\n    defined_at: Any = None\n    is_internal: bool = False\n    is_immutable: bool = False\n    data_offset: Optional[int] = None\n\n    def __post_init__(self):\n        if self.blockscopes is None:\n            self.blockscopes = []\n\n    def __repr__(self):\n        ret = vars(self)\n        ret[\"allocated\"] = self.typ.memory_bytes_required\n        return f\"VariableRecord({ret})\"\n\n\n# Contains arguments, variables, etc\nclass Context:\n    def __init__(\n        self,\n        global_ctx,\n        memory_allocator,\n        vars_=None,\n        sigs=None,\n        forvars=None,\n        constancy=Constancy.Mutable,\n        sig=None,\n    ):\n        # In-memory variables, in the form (name, memory location, type)\n        self.vars = vars_ or {}\n\n        # Global variables, in the form (name, storage location, type)\n        self.globals = global_ctx.variables\n\n        # ABI objects, in the form {classname: ABI JSON}\n        self.sigs = sigs or {\"self\": {}}\n\n        # Variables defined in for loops, e.g. for i in range(6): ...\n        self.forvars = forvars or {}\n\n        # Is the function constant?\n        self.constancy = constancy\n\n        # Whether body is currently in an assert statement\n        self.in_assertion = False\n\n        # Whether we are currently parsing a range expression\n        self.in_range_expr = False\n\n        # store global context\n        self.global_ctx = global_ctx\n\n        # full function signature\n        self.sig = sig\n        # Active scopes\n        self._scopes = set()\n\n        # Memory alloctor, keeps track of currently allocated memory.\n        # Not intended to be accessed directly\n        self.memory_allocator = memory_allocator\n\n        # Incremented values, used for internal IDs\n        self._internal_var_iter = 0\n        self._scope_id_iter = 0\n\n    def is_constant(self):\n        return self.constancy is Constancy.Constant or self.in_assertion or self.in_range_expr\n\n    def check_is_not_constant(self, err, expr):\n        if self.is_constant():\n            raise StateAccessViolation(f\"Cannot {err} from {self.pp_constancy()}\", expr)\n\n    # convenience propreties\n    @property\n    def is_payable(self):\n        return self.sig.mutability == \"payable\"\n\n    @property\n    def is_internal(self):\n        return self.sig.internal\n\n    @property\n    def return_type(self):\n        return self.sig.return_type\n\n    #\n    # Context Managers\n    # - Context managers are used to ensure proper wrapping of scopes and context states.\n\n    @contextlib.contextmanager\n    def range_scope(self):\n        prev_value = self.in_range_expr\n        self.in_range_expr = True\n        yield\n        self.in_range_expr = prev_value\n\n    @contextlib.contextmanager\n    def internal_memory_scope(self):\n        \"\"\"\n        Internal memory scope context manager.\n\n        Internal variables that are declared within this context are de-allocated\n        upon exiting the context.\n        \"\"\"\n        scope_id = self._scope_id_iter\n        self._scope_id_iter += 1\n        self._scopes.add(scope_id)\n        yield\n\n        # Remove all variables that have specific scope_id attached\n        released = [\n            (k, v) for k, v in self.vars.items() if v.is_internal and scope_id in v.blockscopes\n        ]\n        for name, var in released:\n            n = var.typ.memory_bytes_required\n            assert n == var.size\n            self.memory_allocator.deallocate_memory(var.pos, n)\n            del self.vars[name]\n\n        # Remove block scopes\n        self._scopes.remove(scope_id)\n\n    @contextlib.contextmanager\n    def block_scope(self):\n        \"\"\"\n        Block scope context manager.\n\n        All variables (public and internal) that are declared within this context\n        are de-allocated upon exiting the context.\n        \"\"\"\n        scope_id = self._scope_id_iter\n        self._scope_id_iter += 1\n        self._scopes.add(scope_id)\n        yield\n\n        # Remove all variables that have specific scope_id attached\n        released = [(k, v) for k, v in self.vars.items() if scope_id in v.blockscopes]\n        for name, var in released:\n            n = var.typ.memory_bytes_required\n            # sanity check the type's size hasn't changed since allocation.\n            assert n == var.size\n            self.memory_allocator.deallocate_memory(var.pos, n)\n            del self.vars[name]\n\n        # Remove block scopes\n        self._scopes.remove(scope_id)\n\n    def _new_variable(\n        self, name: str, typ: VyperType, var_size: int, is_internal: bool, is_mutable: bool = True\n    ) -> int:\n        var_pos = self.memory_allocator.allocate_memory(var_size)\n\n        assert var_pos + var_size <= self.memory_allocator.size_of_mem, \"function frame overrun\"\n\n        self.vars[name] = VariableRecord(\n            name=name,\n            pos=var_pos,\n            typ=typ,\n            size=var_size,\n            mutable=is_mutable,\n            blockscopes=self._scopes.copy(),\n            is_internal=is_internal,\n        )\n        return var_pos\n\n    def new_variable(self, name: str, typ: VyperType, is_mutable: bool = True) -> int:\n        \"\"\"\n        Allocate memory for a user-defined variable.\n\n        Arguments\n        ---------\n        name : str\n            Name of the variable\n        typ : VyperType\n            Variable type, used to determine the size of memory allocation\n\n        Returns\n        -------\n        int\n            Memory offset for the variable\n        \"\"\"\n\n        var_size = typ.memory_bytes_required\n        return self._new_variable(name, typ, var_size, False, is_mutable=is_mutable)\n\n    def fresh_varname(self, name: Optional[str] = None) -> str:\n        \"\"\"\n        return a unique\n        \"\"\"\n        if name is None:\n            name = \"var\"\n        t = self._internal_var_iter\n        self._internal_var_iter += 1\n        return f\"{name}{t}\"\n\n    # do we ever allocate immutable internal variables?\n    def new_internal_variable(self, typ: VyperType) -> int:\n        \"\"\"\n        Allocate memory for an internal variable.\n\n        Arguments\n        ---------\n        typ : VyperType\n            Variable type, used to determine the size of memory allocation\n\n        Returns\n        -------\n        int\n            Memory offset for the variable\n        \"\"\"\n        # internal variable names begin with a number sign so there is no chance for collision\n        name = self.fresh_varname(\"#internal\")\n\n        var_size = typ.memory_bytes_required\n        return self._new_variable(name, typ, var_size, True)\n\n    def parse_type(self, ast_node):\n        return self.global_ctx.parse_type(ast_node)\n\n    def lookup_var(self, varname):\n        return self.vars[varname]\n\n    def lookup_internal_function(self, method_name, args_ir, ast_source):\n        # TODO is this the right module for me?\n        \"\"\"\n        Using a list of args, find the internal method to use, and\n        the kwargs which need to be filled in by the compiler\n        \"\"\"\n\n        sig = self.sigs[\"self\"].get(method_name, None)\n\n        def _check(cond, s=\"Unreachable\"):\n            if not cond:\n                raise CompilerPanic(s)\n\n        # these should have been caught during type checking; sanity check\n        _check(sig is not None)\n        _check(sig.internal)\n        _check(len(sig.base_args) <= len(args_ir) <= len(sig.args))\n        # more sanity check, that the types match\n        # _check(all(l.typ == r.typ for (l, r) in zip(args_ir, sig.args))\n\n        num_provided_kwargs = len(args_ir) - len(sig.base_args)\n        num_kwargs = len(sig.default_args)\n        kwargs_needed = num_kwargs - num_provided_kwargs\n\n        kw_vals = list(sig.default_values.values())[:kwargs_needed]\n\n        return sig, kw_vals\n\n    # Pretty print constancy for error messages\n    def pp_constancy(self):\n        if self.in_assertion:\n            return \"an assertion\"\n        elif self.in_range_expr:\n            return \"a range expression\"\n        elif self.constancy == Constancy.Constant:\n            return \"a constant function\"\n        raise CompilerPanic(f\"unknown constancy in pp_constancy: {self.constancy}\")\n"], "fixing_code": ["import string\nfrom decimal import Decimal\n\nimport hypothesis.strategies as st\nimport pytest\nfrom hypothesis import given, settings\n\nfrom vyper.compiler import compile_code\nfrom vyper.exceptions import ArgumentException, CallViolation\n\npytestmark = pytest.mark.usefixtures(\"memory_mocker\")\n\n\ndef test_selfcall_code(get_contract_with_gas_estimation):\n    selfcall_code = \"\"\"\n@internal\ndef _foo() -> int128:\n    return 3\n\n@external\ndef bar() -> int128:\n    return self._foo()\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code)\n    assert c.bar() == 3\n\n    print(\"Passed no-argument self-call test\")\n\n\ndef test_selfcall_code_2(get_contract_with_gas_estimation, keccak):\n    selfcall_code_2 = \"\"\"\n@internal\ndef _double(x: int128) -> int128:\n    return x * 2\n\n@external\ndef returnten() -> int128:\n    return self._double(5)\n\n@internal\ndef _hashy(x: bytes32) -> bytes32:\n    return keccak256(x)\n\n@external\ndef return_hash_of_rzpadded_cow() -> bytes32:\n    return self._hashy(0x636f770000000000000000000000000000000000000000000000000000000000)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_2)\n    assert c.returnten() == 10\n    assert c.return_hash_of_rzpadded_cow() == keccak(b\"cow\" + b\"\\x00\" * 29)\n\n    print(\"Passed single fixed-size argument self-call test\")\n\n\n# test that side-effecting self calls do not get optimized out\ndef test_selfcall_optimizer(get_contract):\n    code = \"\"\"\ncounter: uint256\n\n@internal\ndef increment_counter() -> uint256:\n    self.counter += 1\n    return self.counter\n@external\ndef foo() -> (uint256, uint256):\n    x: uint256 = unsafe_mul(self.increment_counter(), 0)\n    return x, self.counter\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == [0, 1]\n\n\ndef test_selfcall_code_3(get_contract_with_gas_estimation, keccak):\n    selfcall_code_3 = \"\"\"\n@internal\ndef _hashy2(x: Bytes[100]) -> bytes32:\n    return keccak256(x)\n\n@external\ndef return_hash_of_cow_x_30() -> bytes32:\n    return self._hashy2(b\"cowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcowcow\")  # noqa: E501\n\n@internal\ndef _len(x: Bytes[100]) -> uint256:\n    return len(x)\n\n@external\ndef returnten() -> uint256:\n    return self._len(b\"badminton!\")\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_3)\n    assert c.return_hash_of_cow_x_30() == keccak(b\"cow\" * 30)\n    assert c.returnten() == 10\n\n    print(\"Passed single variable-size argument self-call test\")\n\n\ndef test_selfcall_code_4(get_contract_with_gas_estimation):\n    selfcall_code_4 = \"\"\"\n@internal\ndef _summy(x: int128, y: int128) -> int128:\n    return x + y\n\n@internal\ndef _catty(x: Bytes[5], y: Bytes[5]) -> Bytes[10]:\n    return concat(x, y)\n\n@internal\ndef _slicey1(x: Bytes[10], y: uint256) -> Bytes[10]:\n    return slice(x, 0, y)\n\n@internal\ndef _slicey2(y: uint256, x: Bytes[10]) -> Bytes[10]:\n    return slice(x, 0, y)\n\n@external\ndef returnten() -> int128:\n    return self._summy(3, 7)\n\n@external\ndef return_mongoose() -> Bytes[10]:\n    return self._catty(b\"mon\", b\"goose\")\n\n@external\ndef return_goose() -> Bytes[10]:\n    return self._slicey1(b\"goosedog\", 5)\n\n@external\ndef return_goose2() -> Bytes[10]:\n    return self._slicey2(5, b\"goosedog\")\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_4)\n    assert c.returnten() == 10\n    assert c.return_mongoose() == b\"mongoose\"\n    assert c.return_goose() == b\"goose\"\n    assert c.return_goose2() == b\"goose\"\n\n    print(\"Passed multi-argument self-call test\")\n\n\ndef test_selfcall_code_5(get_contract_with_gas_estimation):\n    selfcall_code_5 = \"\"\"\ncounter: int128\n\n@internal\ndef _increment():\n    self.counter += 1\n\n@external\ndef returnten() -> int128:\n    for i in range(10):\n        self._increment()\n    return self.counter\n    \"\"\"\n    c = get_contract_with_gas_estimation(selfcall_code_5)\n    assert c.returnten() == 10\n\n    print(\"Passed self-call statement test\")\n\n\ndef test_selfcall_code_6(get_contract_with_gas_estimation):\n    selfcall_code_6 = \"\"\"\nexcls: Bytes[32]\n\n@internal\ndef _set_excls(arg: Bytes[32]):\n    self.excls = arg\n\n@internal\ndef _underscore() -> Bytes[1]:\n    return b\"_\"\n\n@internal\ndef _hardtest(x: Bytes[100], y: uint256, z: uint256, a: Bytes[100], b: uint256, c: uint256) -> Bytes[201]:  # noqa: E501\n    return concat(slice(x, y, z), self._underscore(), slice(a, b, c))\n\n@external\ndef return_mongoose_revolution_32_excls() -> Bytes[201]:\n    self._set_excls(b\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n    return self._hardtest(b\"megamongoose123\", 4, 8, concat(b\"russian revolution\", self.excls), 8, 42)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(selfcall_code_6)\n    assert c.return_mongoose_revolution_32_excls() == b\"mongoose_revolution\" + b\"!\" * 32\n\n    print(\"Passed composite self-call test\")\n\n\ndef test_list_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _foo0(x: int128[2]) -> int128:\n    return x[0]\n\n@internal\ndef _foo1(x: int128[2]) -> int128:\n    return x[1]\n\n\n@external\ndef foo1(x: int128[2]) -> int128:\n    return self._foo1(x)\n\n@external\ndef bar() -> int128:\n    x: int128[2] = [0, 0]\n    return self._foo0(x)\n\n@external\ndef bar2() -> int128:\n    x: int128[2] = [55, 66]\n    return self._foo0(x)\n\n@external\ndef bar3() -> int128:\n    x: int128[2] = [55, 66]\n    return self._foo1(x)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 0\n    assert c.foo1([0, 0]) == 0\n    assert c.bar2() == 55\n    assert c.bar3() == 66\n\n\ndef test_list_storage_call(get_contract_with_gas_estimation):\n    code = \"\"\"\ny: int128[2]\n\n@internal\ndef _foo0(x: int128[2]) -> int128:\n    return x[0]\n\n@internal\ndef _foo1(x: int128[2]) -> int128:\n    return x[1]\n\n@external\ndef set():\n    self.y  = [88, 99]\n\n@external\ndef bar0() -> int128:\n    return self._foo0(self.y)\n\n@external\ndef bar1() -> int128:\n    return self._foo1(self.y)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    c.set(transact={})\n    assert c.bar0() == 88\n    assert c.bar1() == 99\n\n\ndef test_multi_arg_list_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _foo0(y: decimal, x: int128[2]) -> int128:\n    return x[0]\n\n@internal\ndef _foo1(x: int128[2], y: decimal) -> int128:\n    return x[1]\n\n@internal\ndef _foo2(y: decimal, x: int128[2]) -> decimal:\n    return y\n\n@internal\ndef _foo3(x: int128[2], y: decimal) -> int128:\n    return x[0]\n\n@internal\ndef _foo4(x: int128[2], y: int128[2]) -> int128:\n    return y[0]\n\n\n@external\ndef foo1(x: int128[2], y: decimal) -> int128:\n    return self._foo1(x, y)\n\n@external\ndef bar() -> int128:\n    x: int128[2] = [0, 0]\n    return self._foo0(0.3434, x)\n\n# list as second parameter\n@external\ndef bar2() -> int128:\n    x: int128[2] = [55, 66]\n    return self._foo0(0.01, x)\n\n@external\ndef bar3() -> decimal:\n    x: int128[2] = [88, 77]\n    return self._foo2(1.33, x)\n\n# list as first parameter\n@external\ndef bar4() -> int128:\n    x: int128[2] = [88, 77]\n    return self._foo1(x, 1.33)\n\n@external\ndef bar5() -> int128:\n    x: int128[2] = [88, 77]\n    return self._foo3(x, 1.33)\n\n# two lists\n@external\ndef bar6() -> int128:\n    x: int128[2] = [88, 77]\n    y: int128[2] = [99, 66]\n    return self._foo4(x, y)\n\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 0\n    assert c.foo1([0, 0], Decimal(\"0\")) == 0\n    assert c.bar2() == 55\n    assert c.bar3() == Decimal(\"1.33\")\n    assert c.bar4() == 77\n    assert c.bar5() == 88\n\n\ndef test_multi_mixed_arg_list_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _fooz(x: int128[2], y: decimal, z: int128[2], a: decimal) -> int128:\n    return z[1]\n\n@internal\ndef _fooa(x: int128[2], y: decimal, z: int128[2], a: decimal) -> decimal:\n    return a\n\n@external\ndef bar() -> (int128, decimal):\n    x: int128[2] = [33, 44]\n    y: decimal = 55.44\n    z: int128[2] = [55, 66]\n    a: decimal = 66.77\n\n    return self._fooz(x, y, z, a), self._fooa(x, y, z, a)\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == [66, Decimal(\"66.77\")]\n\n\ndef test_internal_function_multiple_lists_as_args(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _foo(y: int128[2], x: Bytes[5]) -> int128:\n    return y[0]\n\n@internal\ndef _foo2(x: Bytes[5], y: int128[2]) -> int128:\n    return y[0]\n\n@external\ndef bar() -> int128:\n    return self._foo([1, 2], b\"hello\")\n\n@external\ndef bar2() -> int128:\n    return self._foo2(b\"hello\", [1, 2])\n\"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 1\n    assert c.bar2() == 1\n\n\ndef test_multi_mixed_arg_list_bytes_call(get_contract_with_gas_estimation):\n    code = \"\"\"\n@internal\ndef _fooz(x: int128[2], y: decimal, z: Bytes[11], a: decimal) -> Bytes[11]:\n    return z\n\n@internal\ndef _fooa(x: int128[2], y: decimal, z: Bytes[11], a: decimal) -> decimal:\n    return a\n\n@internal\ndef _foox(x: int128[2], y: decimal, z: Bytes[11], a: decimal) -> int128:\n    return x[1]\n\n\n@external\ndef bar() -> (Bytes[11], decimal, int128):\n    x: int128[2] = [33, 44]\n    y: decimal = 55.44\n    z: Bytes[11] = b\"hello world\"\n    a: decimal = 66.77\n\n    return self._fooz(x, y, z, a), self._fooa(x, y, z, a), self._foox(x, y, z, a)\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == [b\"hello world\", Decimal(\"66.77\"), 44]\n\n\nFAILING_CONTRACTS_CALL_VIOLATION = [\n    \"\"\"\n# should not compile - public to public\n@external\ndef bar() -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar()\n    \"\"\",\n    \"\"\"\n# should not compile - internal to external\n@external\ndef bar() -> int128:\n    return 1\n\n@internal\ndef _baz() -> int128:\n    return self.bar()\n\n@external\ndef foo() -> int128:\n    return self._baz()\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"failing_contract_code\", FAILING_CONTRACTS_CALL_VIOLATION)\ndef test_selfcall_call_violation(failing_contract_code, assert_compile_failed):\n    assert_compile_failed(lambda: compile_code(failing_contract_code), CallViolation)\n\n\nFAILING_CONTRACTS_ARGUMENT_EXCEPTION = [\n    \"\"\"\n# expected no args, args given\n@internal\ndef bar() -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar(1)\n    \"\"\",\n    \"\"\"\n# expected args, none given\n@internal\ndef bar(a: int128) -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar()\n    \"\"\",\n    \"\"\"\n# wrong arg count\n@internal\ndef bar(a: int128) -> int128:\n    return 1\n\n@external\ndef foo() -> int128:\n    return self.bar(1, 2)\n    \"\"\",\n    \"\"\"\n@internal\ndef _foo(x: uint256, y: uint256 = 1):\n    pass\n\n@external\ndef foo(x: uint256, y: uint256):\n    self._foo(x, y=y)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"failing_contract_code\", FAILING_CONTRACTS_ARGUMENT_EXCEPTION)\ndef test_selfcall_wrong_arg_count(failing_contract_code, assert_compile_failed):\n    assert_compile_failed(lambda: compile_code(failing_contract_code), ArgumentException)\n\n\nFAILING_CONTRACTS_TYPE_MISMATCH = [\n    \"\"\"\n# should not compile - value kwarg when calling {0} function\n@{0}\ndef foo():\n    pass\n\n@external\ndef bar():\n    self.foo(value=100)\n    \"\"\",\n    \"\"\"\n# should not compile - gas kwarg when calling {0} function\n@{0}\ndef foo():\n    pass\n\n@external\ndef bar():\n    self.foo(gas=100)\n    \"\"\",\n    \"\"\"\n# should not compile - arbitrary kwargs when calling {0} function\n@{0}\ndef foo():\n    pass\n\n@external\ndef bar():\n    self.foo(baz=100)\n    \"\"\",\n    \"\"\"\n# should not compile - args-as-kwargs to a {0} function\n@{0}\ndef foo(baz: int128):\n    pass\n\n@external\ndef bar():\n    self.foo(baz=100)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"failing_contract_code\", FAILING_CONTRACTS_TYPE_MISMATCH)\n@pytest.mark.parametrize(\"decorator\", [\"external\", \"internal\"])\ndef test_selfcall_kwarg_raises(failing_contract_code, decorator, assert_compile_failed):\n    assert_compile_failed(\n        lambda: compile_code(failing_contract_code.format(decorator)),\n        ArgumentException if decorator == \"internal\" else CallViolation,\n    )\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_struct_return_1(get_contract_with_gas_estimation, i, ln, s):\n    contract = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\n@internal\ndef get_struct_x() -> X:\n    return X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n\n@external\ndef test() -> (int128, String[{ln}], Bytes[{ln}]):\n    ret: X = self.get_struct_x()\n    return ret.x, ret.y, ret.z\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.test() == [i, s, bytes(s, \"utf-8\")]\n\n\ndef test_dynamically_sized_struct_as_arg(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\n@internal\ndef _foo(x: X) -> Bytes[6]:\n    return x.y\n\n@external\ndef bar() -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return self._foo(_X)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == b\"hello\"\n\n\ndef test_dynamically_sized_struct_as_arg_2(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\n@internal\ndef _foo(x: X) -> String[6]:\n    return x.y\n\n@external\ndef bar() -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return self._foo(_X)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == \"hello\"\n\n\ndef test_dynamically_sized_struct_member_as_arg(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\n@internal\ndef _foo(s: Bytes[6]) -> Bytes[6]:\n    return s\n\n@external\ndef bar() -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return self._foo(_X.y)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == b\"hello\"\n\n\ndef test_dynamically_sized_struct_member_as_arg_2(get_contract_with_gas_estimation):\n    contract = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\n@internal\ndef _foo(s: String[6]) -> String[6]:\n    return s\n\n@external\ndef bar() -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return self._foo(_X.y)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract)\n\n    assert c.bar() == \"hello\"\n\n\n# TODO probably want to refactor these into general test utils\nst_uint256 = st.integers(min_value=0, max_value=2**256 - 1)\nst_string65 = st.text(max_size=65, alphabet=string.printable)\nst_bytes65 = st.binary(max_size=65)\nst_sarray3 = st.lists(st_uint256, min_size=3, max_size=3)\nst_darray3 = st.lists(st_uint256, max_size=3)\n\ninternal_call_kwargs_cases = [\n    (\"uint256\", st_uint256),\n    (\"String[65]\", st_string65),\n    (\"Bytes[65]\", st_bytes65),\n    (\"uint256[3]\", st_sarray3),\n    (\"DynArray[uint256, 3]\", st_darray3),\n]\n\n\n@pytest.mark.parametrize(\"typ1,strategy1\", internal_call_kwargs_cases)\n@pytest.mark.parametrize(\"typ2,strategy2\", internal_call_kwargs_cases)\ndef test_internal_call_kwargs(get_contract, typ1, strategy1, typ2, strategy2):\n    # GHSA-ph9x-4vc9-m39g\n\n    @given(kwarg1=strategy1, default1=strategy1, kwarg2=strategy2, default2=strategy2)\n    @settings(deadline=None, max_examples=5)  # len(cases) * len(cases) * 5 * 5\n    def fuzz(kwarg1, kwarg2, default1, default2):\n        code = f\"\"\"\n@internal\ndef foo(a: {typ1} = {repr(default1)}, b: {typ2} = {repr(default2)}) -> ({typ1}, {typ2}):\n    return a, b\n\n@external\ndef test0() -> ({typ1}, {typ2}):\n    return self.foo()\n\n@external\ndef test1() -> ({typ1}, {typ2}):\n    return self.foo({repr(kwarg1)})\n\n@external\ndef test2() -> ({typ1}, {typ2}):\n    return self.foo({repr(kwarg1)}, {repr(kwarg2)})\n\n@external\ndef test3(x1: {typ1}) -> ({typ1}, {typ2}):\n    return self.foo(x1)\n\n@external\ndef test4(x1: {typ1}, x2: {typ2}) -> ({typ1}, {typ2}):\n    return self.foo(x1, x2)\n        \"\"\"\n        c = get_contract(code)\n        assert c.test0() == [default1, default2]\n        assert c.test1() == [kwarg1, default2]\n        assert c.test2() == [kwarg1, kwarg2]\n        assert c.test3(kwarg1) == [kwarg1, default2]\n        assert c.test4(kwarg1, kwarg2) == [kwarg1, kwarg2]\n\n    fuzz()\n", "import contextlib\nimport enum\nfrom dataclasses import dataclass\nfrom typing import Any, Optional\n\nfrom vyper.codegen.ir_node import Encoding\nfrom vyper.evm.address_space import MEMORY, AddrSpace\nfrom vyper.exceptions import CompilerPanic, StateAccessViolation\nfrom vyper.semantics.types import VyperType\n\n\nclass Constancy(enum.Enum):\n    Mutable = 0\n    Constant = 1\n\n\n# Function variable\n@dataclass\nclass VariableRecord:\n    name: str\n    pos: int\n    typ: VyperType\n    mutable: bool\n    encoding: Encoding = Encoding.VYPER\n    location: AddrSpace = MEMORY\n    size: Optional[int] = None  # allocated size\n    blockscopes: Optional[list] = None\n    defined_at: Any = None\n    is_internal: bool = False\n    is_immutable: bool = False\n    data_offset: Optional[int] = None\n\n    def __post_init__(self):\n        if self.blockscopes is None:\n            self.blockscopes = []\n\n    def __repr__(self):\n        ret = vars(self)\n        ret[\"allocated\"] = self.typ.memory_bytes_required\n        return f\"VariableRecord({ret})\"\n\n\n# Contains arguments, variables, etc\nclass Context:\n    def __init__(\n        self,\n        global_ctx,\n        memory_allocator,\n        vars_=None,\n        sigs=None,\n        forvars=None,\n        constancy=Constancy.Mutable,\n        sig=None,\n    ):\n        # In-memory variables, in the form (name, memory location, type)\n        self.vars = vars_ or {}\n\n        # Global variables, in the form (name, storage location, type)\n        self.globals = global_ctx.variables\n\n        # ABI objects, in the form {classname: ABI JSON}\n        self.sigs = sigs or {\"self\": {}}\n\n        # Variables defined in for loops, e.g. for i in range(6): ...\n        self.forvars = forvars or {}\n\n        # Is the function constant?\n        self.constancy = constancy\n\n        # Whether body is currently in an assert statement\n        self.in_assertion = False\n\n        # Whether we are currently parsing a range expression\n        self.in_range_expr = False\n\n        # store global context\n        self.global_ctx = global_ctx\n\n        # full function signature\n        self.sig = sig\n        # Active scopes\n        self._scopes = set()\n\n        # Memory alloctor, keeps track of currently allocated memory.\n        # Not intended to be accessed directly\n        self.memory_allocator = memory_allocator\n\n        # Incremented values, used for internal IDs\n        self._internal_var_iter = 0\n        self._scope_id_iter = 0\n\n    def is_constant(self):\n        return self.constancy is Constancy.Constant or self.in_assertion or self.in_range_expr\n\n    def check_is_not_constant(self, err, expr):\n        if self.is_constant():\n            raise StateAccessViolation(f\"Cannot {err} from {self.pp_constancy()}\", expr)\n\n    # convenience propreties\n    @property\n    def is_payable(self):\n        return self.sig.mutability == \"payable\"\n\n    @property\n    def is_internal(self):\n        return self.sig.internal\n\n    @property\n    def return_type(self):\n        return self.sig.return_type\n\n    #\n    # Context Managers\n    # - Context managers are used to ensure proper wrapping of scopes and context states.\n\n    @contextlib.contextmanager\n    def range_scope(self):\n        prev_value = self.in_range_expr\n        self.in_range_expr = True\n        yield\n        self.in_range_expr = prev_value\n\n    @contextlib.contextmanager\n    def internal_memory_scope(self):\n        \"\"\"\n        Internal memory scope context manager.\n\n        Internal variables that are declared within this context are de-allocated\n        upon exiting the context.\n        \"\"\"\n        scope_id = self._scope_id_iter\n        self._scope_id_iter += 1\n        self._scopes.add(scope_id)\n        yield\n\n        # Remove all variables that have specific scope_id attached\n        released = [\n            (k, v) for k, v in self.vars.items() if v.is_internal and scope_id in v.blockscopes\n        ]\n        for name, var in released:\n            n = var.typ.memory_bytes_required\n            assert n == var.size\n            self.memory_allocator.deallocate_memory(var.pos, n)\n            del self.vars[name]\n\n        # Remove block scopes\n        self._scopes.remove(scope_id)\n\n    @contextlib.contextmanager\n    def block_scope(self):\n        \"\"\"\n        Block scope context manager.\n\n        All variables (public and internal) that are declared within this context\n        are de-allocated upon exiting the context.\n        \"\"\"\n        scope_id = self._scope_id_iter\n        self._scope_id_iter += 1\n        self._scopes.add(scope_id)\n        yield\n\n        # Remove all variables that have specific scope_id attached\n        released = [(k, v) for k, v in self.vars.items() if scope_id in v.blockscopes]\n        for name, var in released:\n            n = var.typ.memory_bytes_required\n            # sanity check the type's size hasn't changed since allocation.\n            assert n == var.size\n            self.memory_allocator.deallocate_memory(var.pos, n)\n            del self.vars[name]\n\n        # Remove block scopes\n        self._scopes.remove(scope_id)\n\n    def _new_variable(\n        self, name: str, typ: VyperType, var_size: int, is_internal: bool, is_mutable: bool = True\n    ) -> int:\n        var_pos = self.memory_allocator.allocate_memory(var_size)\n\n        assert var_pos + var_size <= self.memory_allocator.size_of_mem, \"function frame overrun\"\n\n        self.vars[name] = VariableRecord(\n            name=name,\n            pos=var_pos,\n            typ=typ,\n            size=var_size,\n            mutable=is_mutable,\n            blockscopes=self._scopes.copy(),\n            is_internal=is_internal,\n        )\n        return var_pos\n\n    def new_variable(self, name: str, typ: VyperType, is_mutable: bool = True) -> int:\n        \"\"\"\n        Allocate memory for a user-defined variable.\n\n        Arguments\n        ---------\n        name : str\n            Name of the variable\n        typ : VyperType\n            Variable type, used to determine the size of memory allocation\n\n        Returns\n        -------\n        int\n            Memory offset for the variable\n        \"\"\"\n\n        var_size = typ.memory_bytes_required\n        return self._new_variable(name, typ, var_size, False, is_mutable=is_mutable)\n\n    def fresh_varname(self, name: Optional[str] = None) -> str:\n        \"\"\"\n        return a unique\n        \"\"\"\n        if name is None:\n            name = \"var\"\n        t = self._internal_var_iter\n        self._internal_var_iter += 1\n        return f\"{name}{t}\"\n\n    # do we ever allocate immutable internal variables?\n    def new_internal_variable(self, typ: VyperType) -> int:\n        \"\"\"\n        Allocate memory for an internal variable.\n\n        Arguments\n        ---------\n        typ : VyperType\n            Variable type, used to determine the size of memory allocation\n\n        Returns\n        -------\n        int\n            Memory offset for the variable\n        \"\"\"\n        # internal variable names begin with a number sign so there is no chance for collision\n        name = self.fresh_varname(\"#internal\")\n\n        var_size = typ.memory_bytes_required\n        return self._new_variable(name, typ, var_size, True)\n\n    def parse_type(self, ast_node):\n        return self.global_ctx.parse_type(ast_node)\n\n    def lookup_var(self, varname):\n        return self.vars[varname]\n\n    def lookup_internal_function(self, method_name, args_ir, ast_source):\n        # TODO is this the right module for me?\n        \"\"\"\n        Using a list of args, find the internal method to use, and\n        the kwargs which need to be filled in by the compiler\n        \"\"\"\n\n        sig = self.sigs[\"self\"].get(method_name, None)\n\n        def _check(cond, s=\"Unreachable\"):\n            if not cond:\n                raise CompilerPanic(s)\n\n        # these should have been caught during type checking; sanity check\n        _check(sig is not None)\n        _check(sig.internal)\n        _check(len(sig.base_args) <= len(args_ir) <= len(sig.args))\n        # more sanity check, that the types match\n        # _check(all(l.typ == r.typ for (l, r) in zip(args_ir, sig.args))\n\n        num_provided_kwargs = len(args_ir) - len(sig.base_args)\n\n        kw_vals = list(sig.default_values.values())[num_provided_kwargs:]\n\n        return sig, kw_vals\n\n    # Pretty print constancy for error messages\n    def pp_constancy(self):\n        if self.in_assertion:\n            return \"an assertion\"\n        elif self.in_range_expr:\n            return \"a range expression\"\n        elif self.constancy == Constancy.Constant:\n            return \"a constant function\"\n        raise CompilerPanic(f\"unknown constancy in pp_constancy: {self.constancy}\")\n"], "filenames": ["tests/parser/features/test_internal_call.py", "vyper/codegen/context.py"], "buggy_code_start_loc": [0, 270], "buggy_code_end_loc": [644, 274], "fixing_code_start_loc": [1, 270], "fixing_code_end_loc": [707, 272], "type": "NVD-CWE-noinfo", "message": "Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.", "other": {"cve": {"id": "CVE-2023-32059", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-11T22:15:11.803", "lastModified": "2023-05-23T19:07:14.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-683"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vyper_project:vyper:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.8", "matchCriteriaId": "BD6E3906-C87B-4245-9871-27CD85C32EEF"}]}]}], "references": [{"url": "https://github.com/vyperlang/vyper/commit/c3e68c302aa6e1429946473769dd1232145822ac", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-ph9x-4vc9-m39g", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vyperlang/vyper/commit/c3e68c302aa6e1429946473769dd1232145822ac"}}