{"buggy_code": ["/* radare2 - LGPL - Copyright 2017 - pancake, cgvwzq */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n\n#include \"wasm.h\"\n\n// Consume functions\nstatic size_t consume_u32 (ut8 *buf, ut8 *max, ut32 *out, ut32 *offset) {\n\tsize_t n;\n\tif (!buf || !max || !out) {\n\t\treturn 0;\n\t}\n\tif (!(n = read_u32_leb128 (buf, max, out)) || n > 5) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += n;\n\t}\n\treturn n;\n}\n\nstatic size_t consume_s32 (ut8 *buf, ut8 *max, st32 *out, ut32 *offset) {\n\tsize_t n;\n\tif (!buf || !max || !out) {\n\t\treturn 0;\n\t}\n\tif (!(n = read_i32_leb128 (buf, max, out)) || n > 5) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += n;\n\t}\n\treturn n;\n}\n\nstatic size_t consume_u8 (ut8 *buf, ut8 *max, ut8 *out, ut32 *offset) {\n\tsize_t n;\n\tut32 tmp;\n\tif (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {\n\t\treturn 0;\n\t}\n\t*out = tmp & 0x7f;\n\treturn 1;\t\n}\n\nstatic size_t consume_s8 (ut8 *buf, ut8 *max, st8 *out, ut32 *offset) {\n\tsize_t n;\n\tut32 tmp;\n\tif (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {\n\t\treturn 0;\n\t}\n\t*out = (st8)(tmp & 0x7f);\n\treturn 1;\t\n}\n\nstatic size_t consume_str (ut8 *buf, ut8 *max, size_t sz, char *out, ut32 *offset) {\n\tif (!buf || !max || !out || !sz) {\n\t\treturn 0;\n\t}\n\tif (!(buf + sz < max)) {\n\t\treturn 0;\n\t}\n\tstrncpy ((char*)out, (char*)buf, R_MIN (R_BIN_WASM_STRING_LENGTH-1, sz));\n\tif (offset) *offset += sz;\n\treturn sz;\n}\nstatic size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\t// TODO: calc the expresion with the bytcode (ESIL?)\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}\n\nstatic size_t consume_locals (ut8 *buf, ut8 *max, ut32 count, RBinWasmCodeEntry *out, ut32 *offset) {\n\tut32 i = 0, j = 0;\n\tif (count < 1) return 0;\n\t// memory leak\n\tif (!(out->locals = (struct r_bin_wasm_local_entry_t*) malloc (sizeof(struct r_bin_wasm_local_entry_t) * count))) {\n\t\treturn 0;\n\t}\n\twhile (buf + i < max && j < count) {\n\t\tif (!(consume_u32 (buf + i, max, &out->locals[j].count, &i))) {\n\t\t\tfree (out->locals);\n\t\t\treturn 0;\t\n\t\t}\n\n\t\tif (!(consume_s8 (buf + i, max, (st8*)&out->locals[j].type, &i))) {\n\t\t\tfree (out->locals);\n\t\t\treturn 0;\n\t\t}\n\t\tj += 1;\n\t}\n\tif (offset) *offset += i;\n\treturn j;\n}\n\nstatic size_t consume_limits (ut8 *buf, ut8 *max, struct r_bin_wasm_resizable_limits_t *out, ut32 *offset) {\n\tut32 i = 0;\n\tif (!(consume_u8 (buf + i, max, &out->flags, &i))) return 0;\n\tif (!(consume_u32 (buf + i, max, &out->initial, &i))) return 0;\n\tif (out->flags && (!(consume_u32 (buf + i, max, &out->maximum, &i)))) return 0;\n\tif (offset) *offset += i;\n\treturn i;\n}\n\n// Utils\nstatic RList *r_bin_wasm_get_sections_by_id (RList *sections, ut8 id) {\n\tRBinWasmSection *sec = NULL;\n\tRList *ret = NULL;\t\n\tRListIter *iter = NULL;\n\n\t// memory leak\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (sections, iter, sec) {\n\t\tif (sec->id == id) {\n\t\t\tr_list_append(ret, sec);\n\t\t}\n\t}\n\treturn ret;\n}\n\n#define R_BIN_WASM_VALUETYPETOSTRING(p, type, i) {\\\n\tswitch(type) {\\\n\tcase R_BIN_WASM_VALUETYPE_i32:\\\n\t\tstrcpy(p, \"i32\");\\\n\t\tbreak;\\\n\tcase R_BIN_WASM_VALUETYPE_i64:\\\n\t\tstrcpy(p, \"i64\");\\\n\t\tbreak;\\\n\tcase R_BIN_WASM_VALUETYPE_f32:\\\n\t\tstrcpy(p, \"f32\");\\\n\t\tbreak;\\\n\tcase R_BIN_WASM_VALUETYPE_f64:\\\n\t\tstrcpy(p, \"f64\");\\\n\t\tbreak;\\\n\t}\\\n\ti+= 3;\\\n}\n\nstatic char *r_bin_wasm_type_entry_to_string (RBinWasmTypeEntry *ptr) {\n\tif (!ptr || ptr->to_str) {\n\t\treturn NULL;\n\t}\n\n\tchar *ret;\n\n\tint p, i = 0, sz;\n\n\tsz = (ptr->param_count + ptr->return_count) * 5 + 9;\n\n\t// memory leak\n\tif (!(ret = (char*) malloc (sz * sizeof(char)))) {\n\t\treturn NULL;\n\t}\n\n\tstrcpy (ret + i, \"(\");\n\ti++;\n\n\tfor (p = 0; p < ptr->param_count; p++ ) {\n\t\tR_BIN_WASM_VALUETYPETOSTRING (ret+i, ptr->param_types[p], i); // i+=3\n\t\tif (p < ptr->param_count - 1) {\n\t\t\tstrcpy (ret+i, \", \");\n\t\t\ti += 2;\n\t\t}\n\t}\t\t\n\n\tstrcpy (ret + i, \") -> (\");\n\ti += 6;\n\n\tif (ptr->return_count == 1) {\n\t\tR_BIN_WASM_VALUETYPETOSTRING (ret + i, ptr->return_type, i);\n\t}\n\n\tstrcpy (ret + i, \")\");\n\n\treturn ret;\n}\n\n// Parsing\nstatic RList *r_bin_wasm_get_type_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmTypeEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmTypeEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->form, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->param_count, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(i + ptr->param_count < len)) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tint j;\n\t\tfor (j = 0; j < ptr->param_count; j++) {\n\t\t\tif (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->param_types[j], &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!(consume_s8 (buf + i, buf + len, &ptr->return_count, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ptr->return_count > 1) {\n\t\t\tfree(ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ptr->return_count == 1) {\n\t\t\tif (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->return_type, &i))) {\n\t\t\t\tfree(ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tptr->to_str = r_bin_wasm_type_entry_to_string (ptr);\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n\n}\n\nstatic RList *r_bin_wasm_get_import_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmImportEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmImportEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->module_len, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tif (!(consume_str (buf + i, buf + len, ptr->module_len, ptr->module_str, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tif (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {\n\t\t\tgoto culvert;\n\t\t} \n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tswitch (ptr->kind) {\n\t\tcase 0: // Function\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->type_f, &i))) {\n\t\t\t\tgoto sewer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: // Table\n\t\t\tif (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_t.elem_type, &i))) {\n\t\t\t\tgoto sewer; // varint7\n\t\t\t}\n\t\t\tif (!(consume_limits (buf + i, buf + len, &ptr->type_t.limits, &i))) {\n\t\t\t\tgoto sewer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // Memory\n\t\t\tif (!(consume_limits (buf + i, buf + len, &ptr->type_m.limits, &i))) {\n\t\t\t\tgoto sewer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: // Global\n\t\t\tif (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.content_type, &i))) {\n\t\t\t\tgoto sewer; // varint7\n\t\t\t}\n\t\t\tif (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.mutability, &i))) {\n\t\t\t\tgoto sewer; // varuint1\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto sewer;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nsewer:\n\tret = NULL;\nculvert:\n\tfree (ptr);\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_export_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmExportEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmExportEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_code_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmCodeEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, j = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmCodeEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_u32 (buf + i, buf + len, &ptr->body_size, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(i + ptr->body_size - 1 < len)) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tj = i;\n\n\t\tif (!(n = consume_u32 (buf + i, buf + len, &ptr->local_count, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ((n = consume_locals (buf + i, buf + len, ptr->local_count,ptr, &i)) < ptr->local_count) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->code = sec->payload_data + i;\n\t\tptr->len = ptr->body_size - (i - j);\n\n\t\ti += ptr->len - 1; // consume bytecode\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->byte, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ptr->byte != R_BIN_WASM_END_OF_CODE) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\t// search 'r' in function_space, if present get signature from types\n\t\t// if export get name\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->offset.len = n;\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RBinWasmStartEntry *r_bin_wasm_get_start (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRBinWasmStartEntry *ptr;\t\n\n\tif (!(ptr = R_NEW0 (RBinWasmStartEntry))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 i = 0;\n\n\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\n\treturn ptr;\n\n}\n\nstatic RList *r_bin_wasm_get_memory_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmMemoryEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmMemoryEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_table_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmTableEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmTableEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->element_type, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem\t) {\n\t\t\t// TODO: allocate space and fill entry\n\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\n// Public functions\nRBinWasmObj *r_bin_wasm_init (RBinFile *arch) {\n\tRBinWasmObj *bin = R_NEW0 (RBinWasmObj);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (!(bin->buf = r_buf_new ())) {\n\t\tfree (bin);\n\t\treturn NULL;\n\t}\n\tbin->size = (ut32)arch->buf->length;\n\tif (!r_buf_set_bytes (bin->buf, arch->buf->buf, bin->size)) {\n\t\tr_bin_wasm_destroy (arch);\n\t\tfree (bin);\n\t\treturn NULL;\n\t}\n\n\tbin->g_sections = r_bin_wasm_get_sections (bin);\n\t// TODO: recursive invocation more natural with streamed parsing\n\t// but dependency problems when sections are disordered (against spec)\n\n\tbin->g_types = r_bin_wasm_get_types (bin);\n\tbin->g_imports = r_bin_wasm_get_imports (bin);\t\n\tbin->g_exports = r_bin_wasm_get_exports (bin);\n\tbin->g_tables = r_bin_wasm_get_tables (bin);\n\tbin->g_memories = r_bin_wasm_get_memories (bin);\n\tbin->g_globals = r_bin_wasm_get_globals (bin);\n\tbin->g_codes = r_bin_wasm_get_codes (bin);\n\tbin->g_datas = r_bin_wasm_get_datas (bin);\n\n\t// entrypoint from Start section\n\tbin->entrypoint = r_bin_wasm_get_entrypoint (bin);\n\n\treturn bin;\n}\n\nvoid r_bin_wasm_destroy (RBinFile *arch) {\n\tRBinWasmObj *bin;\n\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn;\n\t}\n\n\tbin = arch->o->bin_obj;\n\tr_buf_free (bin->buf);\n\n\tr_list_free (bin->g_sections);\n\tr_list_free (bin->g_types);\n\n\tr_list_free (bin->g_imports);\n\tr_list_free (bin->g_exports);\n\tr_list_free (bin->g_tables);\n\tr_list_free (bin->g_memories);\n\tr_list_free (bin->g_globals);\n\tr_list_free (bin->g_codes);\n\tr_list_free (bin->g_datas);\n\n\tfree (bin->g_start);\n\tfree (bin);\n\tarch->o->bin_obj = NULL;\n}\n\nRList *r_bin_wasm_get_sections (RBinWasmObj *bin) {\n\tRList *ret = NULL;\n\tRBinWasmSection *ptr = NULL;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->g_sections) {\n\t\treturn bin->g_sections;\n\t}\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf;\n\tut32 len = bin->size, i = 8; // skip magic bytes + version\n\n\twhile (i < len) {\n\n\t\t//r_buf_read_* api but it makes sense going through the array directly\n\t\tif (!(ptr = R_NEW0 (RBinWasmSection))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->id, &i))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\n\t\t\tfree(ptr);\n\t\t\treturn NULL;\n\t\t}\t\n\n\t\tptr->count = 0;\n\t\tptr->offset = i;\n\n\t\tswitch (ptr->id) {\n\n\t\tcase R_BIN_WASM_SECTION_CUSTOM:\n\t\t\t//eprintf(\"custom section: 0x%x, \", i);\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->name_len, &i))) {\n\t\t\t\tfree(ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (!(consume_str (buf + i, buf + len, ptr->name_len,\n\t\t\t\t\tptr->name, &i))) {\n\t\t\t\tfree(ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t//eprintf(\"%s\\n\", ptr->name);\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_TYPE:\n\t\t\t//eprintf(\"section type: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"type\");\n\t\t\tptr->name_len = 4;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_IMPORT:\n\t\t\t//eprintf(\"section import: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"import\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_FUNCTION:\n\t\t\t//eprintf(\"section function: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"function\");\n\t\t\tptr->name_len = 8;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_TABLE:\n\t\t\t//eprintf(\"section table: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"table\");\n\t\t\tptr->name_len = 5;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_MEMORY:\n\t\t\t//eprintf(\"section memory: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"memory\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_GLOBAL:\n\t\t\t//eprintf(\"section global: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"global\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_EXPORT:\n\t\t\t//eprintf(\"section export: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"export\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_START:\n\t\t\t//eprintf(\"section start: 0x%x\\n\", i);\n\t\t\tstrcpy (ptr->name, \"start\");\n\t\t\tptr->name_len = 5;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_ELEMENT:\n\t\t\t//eprintf(\"section element: 0x%x, \", i);\n\t\t\tstrncpy (ptr->name, \"element\", R_BIN_WASM_STRING_LENGTH);\n\t\t\tptr->name_len = 7;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_CODE:\n\t\t\t//eprintf(\"section code: 0x%x, \", i);\n\t\t\tstrncpy (ptr->name, \"code\", R_BIN_WASM_STRING_LENGTH);\n\t\t\tptr->name_len = 4;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_DATA:\n\t\t\t//eprintf(\"section data: 0x%x, \", i);\n\t\t\tstrncpy (ptr->name, \"data\", R_BIN_WASM_STRING_LENGTH);\n\t\t\tptr->name_len = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\teprintf(\"unkown section id: %d\\n\", ptr->id);\n\t\t\ti += ptr->size - 1; // next\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tif (ptr->id != R_BIN_WASM_SECTION_START\n\t\t\t\t&& ptr->id != R_BIN_WASM_SECTION_CUSTOM) {\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->count, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t//eprintf(\"count %d\\n\", ptr->count);\n\t\t}\n\n\t\tptr->payload_data = i;\n\t\tptr->payload_len = ptr->size - (i - ptr->offset);\n\n\t\tr_list_append (ret, ptr);\n\n\t\ti += ptr->payload_len; // next\n\n\t}\n\n\tbin->g_sections = ret;\n\n\treturn ret;\n\n}\n\nut32 r_bin_wasm_get_entrypoint (RBinWasmObj *bin) {\n\tRList *secs = NULL;\n\tRBinWasmStartEntry *start = NULL;\n\tRBinWasmSection *sec = NULL;\n\tRBinWasmCodeEntry *func = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn 0;\n\t}\n\tif (bin->entrypoint) {\n\t\treturn bin->entrypoint;\n\t}\n\tif (bin->g_start) {\n\t\tstart = bin->g_start;\n\t} else if (!(secs = r_bin_wasm_get_sections_by_id (bin->g_sections, R_BIN_WASM_SECTION_START))) {\n\t\treturn 0;\n\t} else if (!(sec = (RBinWasmSection*) r_list_first (secs))) {\n\t\treturn 0;\n\t} else {\n\t\tstart = r_bin_wasm_get_start (bin, sec);\n\t\tbin->g_start = start;\n\t}\n\n\tif (!start) {\n\t\treturn 0;\n\t}\n\n\t// FIX: entrypoint can be also an import\n\tfunc = r_list_get_n (r_bin_wasm_get_codes (bin), start->index);\n\treturn (ut32)func? func->code: 0;\n\n}\n\nRList *r_bin_wasm_get_imports (RBinWasmObj *bin) {\n\tRBinWasmSection *import = NULL;\n\tRList *imports = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\tif (bin->g_imports) {\n\t\treturn bin->g_imports;\n\t}\n\tif (!(imports = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_IMPORT))) {\n\t\treturn r_list_new();\n\t}\n\t// support for multiple import sections against spec\n\tif (!(import = (RBinWasmSection*) r_list_first (imports))) {\n\t\treturn r_list_new();\n\t}\n\treturn bin->g_imports = r_bin_wasm_get_import_entries (bin, import);\n}\n\nRList *r_bin_wasm_get_exports (RBinWasmObj *bin) {\n\n\tRBinWasmSection *export = NULL;\n\tRList *exports = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_exports) {\n\t\treturn bin->g_exports;\n\t}\n\n\tif (!(exports= r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_EXPORT))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(export = (RBinWasmSection*) r_list_first (exports))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_exports = r_bin_wasm_get_export_entries (bin, export);\n\n\treturn bin->g_exports;\n}\n\nRList *r_bin_wasm_get_types (RBinWasmObj *bin) {\n\tRBinWasmSection *type = NULL;\n\tRList *types = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_types) {\n\t\treturn bin->g_types;\n\t}\n\n\tif (!(types = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_TYPE))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(type = (RBinWasmSection*) r_list_first (types))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_types = r_bin_wasm_get_type_entries (bin, type);\n\n\treturn bin->g_types;\n}\n\nRList *r_bin_wasm_get_tables (RBinWasmObj *bin) {\n\tRBinWasmSection *table = NULL;\n\tRList *tables = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_tables) {\n\t\treturn bin->g_tables;\n\t}\n\n\tif (!(tables = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_TABLE))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(table = (RBinWasmSection*) r_list_first (tables))) {\n\t\tr_list_free (tables);\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_tables = r_bin_wasm_get_table_entries (bin, table);\n\n\tr_list_free (tables);\n\treturn bin->g_tables;\n}\n\nRList *r_bin_wasm_get_memories (RBinWasmObj *bin) {\n\tRBinWasmSection *memory;\n\tRList *memories;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_memories) {\n\t\treturn bin->g_memories;\n\t}\n\n\tif (!(memories = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_MEMORY))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(memory = (RBinWasmSection*) r_list_first (memories))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_memories = r_bin_wasm_get_memory_entries (bin, memory);\n\n\treturn bin->g_memories;\n}\n\nRList *r_bin_wasm_get_globals (RBinWasmObj *bin) {\n\tRBinWasmSection *global = NULL;\n\tRList *globals = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_globals) {\n\t\treturn bin->g_globals;\n\t}\n\n\tif (!(globals = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_GLOBAL))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(global = (RBinWasmSection*) r_list_first (globals))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_globals = r_bin_wasm_get_global_entries (bin, global);\n\n\treturn bin->g_globals;\n}\n\nRList *r_bin_wasm_get_elements (RBinWasmObj *bin) {\n\tRBinWasmSection *element = NULL;\n\tRList *elements = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_elements) {\n\t\treturn bin->g_elements;\n\t}\n\n\tif (!(elements = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_ELEMENT))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(element = (RBinWasmSection*) r_list_first (elements))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_elements = r_bin_wasm_get_element_entries (bin, element);\n\n\treturn bin->g_elements;\n}\n\nRList *r_bin_wasm_get_codes (RBinWasmObj *bin) {\n\tRBinWasmSection *code = NULL;;\n\tRList *codes = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_codes) {\n\t\treturn bin->g_codes;\n\t}\n\n\tif (!(codes = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_CODE))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(code = (RBinWasmSection*) r_list_first (codes))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_codes = r_bin_wasm_get_code_entries (bin, code);\n\n\treturn bin->g_codes;\n}\n\nRList *r_bin_wasm_get_datas (RBinWasmObj *bin) {\n\tRBinWasmSection *data = NULL;\n\tRList *datas = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_datas) {\n\t\treturn bin->g_datas;\n\t}\n\n\tif (!(datas = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_DATA))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(data = (RBinWasmSection*) r_list_first (datas))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_datas = r_bin_wasm_get_data_entries (bin, data);\n\n\treturn bin->g_datas;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2017 - pancake, cgvwzq */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n\n#include \"wasm.h\"\n\n// Consume functions\nstatic size_t consume_u32 (ut8 *buf, ut8 *max, ut32 *out, ut32 *offset) {\n\tsize_t n;\n\tif (!buf || !max || !out) {\n\t\treturn 0;\n\t}\n\tif (!(n = read_u32_leb128 (buf, max, out)) || n > 5) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += n;\n\t}\n\treturn n;\n}\n\nstatic size_t consume_s32 (ut8 *buf, ut8 *max, st32 *out, ut32 *offset) {\n\tsize_t n;\n\tif (!buf || !max || !out) {\n\t\treturn 0;\n\t}\n\tif (!(n = read_i32_leb128 (buf, max, out)) || n > 5) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += n;\n\t}\n\treturn n;\n}\n\nstatic size_t consume_u8 (ut8 *buf, ut8 *max, ut8 *out, ut32 *offset) {\n\tsize_t n;\n\tut32 tmp;\n\tif (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {\n\t\treturn 0;\n\t}\n\t*out = tmp & 0x7f;\n\treturn 1;\t\n}\n\nstatic size_t consume_s8 (ut8 *buf, ut8 *max, st8 *out, ut32 *offset) {\n\tsize_t n;\n\tut32 tmp;\n\tif (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {\n\t\treturn 0;\n\t}\n\t*out = (st8)(tmp & 0x7f);\n\treturn 1;\t\n}\n\nstatic size_t consume_str (ut8 *buf, ut8 *max, size_t sz, char *out, ut32 *offset) {\n\tif (!buf || !max || !out || !sz) {\n\t\treturn 0;\n\t}\n\tif (!(buf + sz < max)) {\n\t\treturn 0;\n\t}\n\tstrncpy ((char*)out, (char*)buf, R_MIN (R_BIN_WASM_STRING_LENGTH-1, sz));\n\tif (offset) *offset += sz;\n\treturn sz;\n}\n\nstatic size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\t// TODO: calc the expresion with the bytcode (ESIL?)\n\t\ti++;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}\n\nstatic size_t consume_locals (ut8 *buf, ut8 *max, ut32 count, RBinWasmCodeEntry *out, ut32 *offset) {\n\tut32 i = 0, j = 0;\n\tif (count < 1) return 0;\n\t// memory leak\n\tif (!(out->locals = (struct r_bin_wasm_local_entry_t*) malloc (sizeof(struct r_bin_wasm_local_entry_t) * count))) {\n\t\treturn 0;\n\t}\n\twhile (buf + i < max && j < count) {\n\t\tif (!(consume_u32 (buf + i, max, &out->locals[j].count, &i))) {\n\t\t\tfree (out->locals);\n\t\t\treturn 0;\t\n\t\t}\n\n\t\tif (!(consume_s8 (buf + i, max, (st8*)&out->locals[j].type, &i))) {\n\t\t\tfree (out->locals);\n\t\t\treturn 0;\n\t\t}\n\t\tj += 1;\n\t}\n\tif (offset) *offset += i;\n\treturn j;\n}\n\nstatic size_t consume_limits (ut8 *buf, ut8 *max, struct r_bin_wasm_resizable_limits_t *out, ut32 *offset) {\n\tut32 i = 0;\n\tif (!(consume_u8 (buf + i, max, &out->flags, &i))) return 0;\n\tif (!(consume_u32 (buf + i, max, &out->initial, &i))) return 0;\n\tif (out->flags && (!(consume_u32 (buf + i, max, &out->maximum, &i)))) return 0;\n\tif (offset) *offset += i;\n\treturn i;\n}\n\n// Utils\nstatic RList *r_bin_wasm_get_sections_by_id (RList *sections, ut8 id) {\n\tRBinWasmSection *sec = NULL;\n\tRList *ret = NULL;\t\n\tRListIter *iter = NULL;\n\n\t// memory leak\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (sections, iter, sec) {\n\t\tif (sec->id == id) {\n\t\t\tr_list_append(ret, sec);\n\t\t}\n\t}\n\treturn ret;\n}\n\n#define R_BIN_WASM_VALUETYPETOSTRING(p, type, i) {\\\n\tswitch(type) {\\\n\tcase R_BIN_WASM_VALUETYPE_i32:\\\n\t\tstrcpy(p, \"i32\");\\\n\t\tbreak;\\\n\tcase R_BIN_WASM_VALUETYPE_i64:\\\n\t\tstrcpy(p, \"i64\");\\\n\t\tbreak;\\\n\tcase R_BIN_WASM_VALUETYPE_f32:\\\n\t\tstrcpy(p, \"f32\");\\\n\t\tbreak;\\\n\tcase R_BIN_WASM_VALUETYPE_f64:\\\n\t\tstrcpy(p, \"f64\");\\\n\t\tbreak;\\\n\t}\\\n\ti+= 3;\\\n}\n\nstatic char *r_bin_wasm_type_entry_to_string (RBinWasmTypeEntry *ptr) {\n\tif (!ptr || ptr->to_str) {\n\t\treturn NULL;\n\t}\n\n\tchar *ret;\n\n\tint p, i = 0, sz;\n\n\tsz = (ptr->param_count + ptr->return_count) * 5 + 9;\n\n\t// memory leak\n\tif (!(ret = (char*) malloc (sz * sizeof(char)))) {\n\t\treturn NULL;\n\t}\n\n\tstrcpy (ret + i, \"(\");\n\ti++;\n\n\tfor (p = 0; p < ptr->param_count; p++ ) {\n\t\tR_BIN_WASM_VALUETYPETOSTRING (ret+i, ptr->param_types[p], i); // i+=3\n\t\tif (p < ptr->param_count - 1) {\n\t\t\tstrcpy (ret+i, \", \");\n\t\t\ti += 2;\n\t\t}\n\t}\t\t\n\n\tstrcpy (ret + i, \") -> (\");\n\ti += 6;\n\n\tif (ptr->return_count == 1) {\n\t\tR_BIN_WASM_VALUETYPETOSTRING (ret + i, ptr->return_type, i);\n\t}\n\n\tstrcpy (ret + i, \")\");\n\n\treturn ret;\n}\n\n// Parsing\nstatic RList *r_bin_wasm_get_type_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmTypeEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmTypeEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->form, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->param_count, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(i + ptr->param_count < len)) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tint j;\n\t\tfor (j = 0; j < ptr->param_count; j++) {\n\t\t\tif (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->param_types[j], &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!(consume_s8 (buf + i, buf + len, &ptr->return_count, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ptr->return_count > 1) {\n\t\t\tfree(ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ptr->return_count == 1) {\n\t\t\tif (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->return_type, &i))) {\n\t\t\t\tfree(ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tptr->to_str = r_bin_wasm_type_entry_to_string (ptr);\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n\n}\n\nstatic RList *r_bin_wasm_get_import_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmImportEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmImportEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->module_len, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tif (!(consume_str (buf + i, buf + len, ptr->module_len, ptr->module_str, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tif (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {\n\t\t\tgoto culvert;\n\t\t} \n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {\n\t\t\tgoto culvert;\n\t\t}\n\t\tswitch (ptr->kind) {\n\t\tcase 0: // Function\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->type_f, &i))) {\n\t\t\t\tgoto sewer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: // Table\n\t\t\tif (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_t.elem_type, &i))) {\n\t\t\t\tgoto sewer; // varint7\n\t\t\t}\n\t\t\tif (!(consume_limits (buf + i, buf + len, &ptr->type_t.limits, &i))) {\n\t\t\t\tgoto sewer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // Memory\n\t\t\tif (!(consume_limits (buf + i, buf + len, &ptr->type_m.limits, &i))) {\n\t\t\t\tgoto sewer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: // Global\n\t\t\tif (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.content_type, &i))) {\n\t\t\t\tgoto sewer; // varint7\n\t\t\t}\n\t\t\tif (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.mutability, &i))) {\n\t\t\t\tgoto sewer; // varuint1\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto sewer;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nsewer:\n\tret = NULL;\nculvert:\n\tfree (ptr);\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_export_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmExportEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmExportEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_code_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmCodeEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, j = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmCodeEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_u32 (buf + i, buf + len, &ptr->body_size, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(i + ptr->body_size - 1 < len)) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tj = i;\n\n\t\tif (!(n = consume_u32 (buf + i, buf + len, &ptr->local_count, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ((n = consume_locals (buf + i, buf + len, ptr->local_count,ptr, &i)) < ptr->local_count) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->code = sec->payload_data + i;\n\t\tptr->len = ptr->body_size - (i - j);\n\n\t\ti += ptr->len - 1; // consume bytecode\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->byte, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ptr->byte != R_BIN_WASM_END_OF_CODE) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\t// search 'r' in function_space, if present get signature from types\n\t\t// if export get name\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tut32 len =  sec->payload_len;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tint buflen = bin->buf->length - (ut32)sec->payload_data;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (i + 4 >= buflen) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tgoto beach;\n\t\t}\n\t\tif (i + 4 >= buflen) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}\n\nstatic RBinWasmStartEntry *r_bin_wasm_get_start (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRBinWasmStartEntry *ptr;\t\n\n\tif (!(ptr = R_NEW0 (RBinWasmStartEntry))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 i = 0;\n\n\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\n\treturn ptr;\n\n}\n\nstatic RList *r_bin_wasm_get_memory_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmMemoryEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmMemoryEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_table_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmTableEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmTableEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->element_type, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tint buflen = bin->buf->length - (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}\n\nstatic RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tint buflen = bin->buf->length - (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem) {\n\t\t\t// TODO: allocate space and fill entry\n\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}\n\n// Public functions\nRBinWasmObj *r_bin_wasm_init (RBinFile *arch) {\n\tRBinWasmObj *bin = R_NEW0 (RBinWasmObj);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (!(bin->buf = r_buf_new ())) {\n\t\tfree (bin);\n\t\treturn NULL;\n\t}\n\tbin->size = (ut32)arch->buf->length;\n\tif (!r_buf_set_bytes (bin->buf, arch->buf->buf, bin->size)) {\n\t\tr_bin_wasm_destroy (arch);\n\t\tfree (bin);\n\t\treturn NULL;\n\t}\n\n\tbin->g_sections = r_bin_wasm_get_sections (bin);\n\t// TODO: recursive invocation more natural with streamed parsing\n\t// but dependency problems when sections are disordered (against spec)\n\n\tbin->g_types = r_bin_wasm_get_types (bin);\n\tbin->g_imports = r_bin_wasm_get_imports (bin);\t\n\tbin->g_exports = r_bin_wasm_get_exports (bin);\n\tbin->g_tables = r_bin_wasm_get_tables (bin);\n\tbin->g_memories = r_bin_wasm_get_memories (bin);\n\tbin->g_globals = r_bin_wasm_get_globals (bin);\n\tbin->g_codes = r_bin_wasm_get_codes (bin);\n\tbin->g_datas = r_bin_wasm_get_datas (bin);\n\n\t// entrypoint from Start section\n\tbin->entrypoint = r_bin_wasm_get_entrypoint (bin);\n\n\treturn bin;\n}\n\nvoid r_bin_wasm_destroy (RBinFile *arch) {\n\tRBinWasmObj *bin;\n\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn;\n\t}\n\n\tbin = arch->o->bin_obj;\n\tr_buf_free (bin->buf);\n\n\tr_list_free (bin->g_sections);\n\tr_list_free (bin->g_types);\n\n\tr_list_free (bin->g_imports);\n\tr_list_free (bin->g_exports);\n\tr_list_free (bin->g_tables);\n\tr_list_free (bin->g_memories);\n\tr_list_free (bin->g_globals);\n\tr_list_free (bin->g_codes);\n\tr_list_free (bin->g_datas);\n\n\tfree (bin->g_start);\n\tfree (bin);\n\tarch->o->bin_obj = NULL;\n}\n\nRList *r_bin_wasm_get_sections (RBinWasmObj *bin) {\n\tRList *ret = NULL;\n\tRBinWasmSection *ptr = NULL;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->g_sections) {\n\t\treturn bin->g_sections;\n\t}\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf;\n\tut32 len = bin->size, i = 8; // skip magic bytes + version\n\n\twhile (i < len) {\n\n\t\t//r_buf_read_* api but it makes sense going through the array directly\n\t\tif (!(ptr = R_NEW0 (RBinWasmSection))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u8 (buf + i, buf + len, &ptr->id, &i))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\n\t\t\tfree(ptr);\n\t\t\treturn NULL;\n\t\t}\t\n\n\t\tptr->count = 0;\n\t\tptr->offset = i;\n\n\t\tswitch (ptr->id) {\n\n\t\tcase R_BIN_WASM_SECTION_CUSTOM:\n\t\t\t//eprintf(\"custom section: 0x%x, \", i);\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->name_len, &i))) {\n\t\t\t\tfree(ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (!(consume_str (buf + i, buf + len, ptr->name_len,\n\t\t\t\t\tptr->name, &i))) {\n\t\t\t\tfree(ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t//eprintf(\"%s\\n\", ptr->name);\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_TYPE:\n\t\t\t//eprintf(\"section type: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"type\");\n\t\t\tptr->name_len = 4;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_IMPORT:\n\t\t\t//eprintf(\"section import: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"import\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_FUNCTION:\n\t\t\t//eprintf(\"section function: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"function\");\n\t\t\tptr->name_len = 8;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_TABLE:\n\t\t\t//eprintf(\"section table: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"table\");\n\t\t\tptr->name_len = 5;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_MEMORY:\n\t\t\t//eprintf(\"section memory: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"memory\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_GLOBAL:\n\t\t\t//eprintf(\"section global: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"global\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_EXPORT:\n\t\t\t//eprintf(\"section export: 0x%x, \", i);\n\t\t\tstrcpy (ptr->name, \"export\");\n\t\t\tptr->name_len = 6;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_START:\n\t\t\t//eprintf(\"section start: 0x%x\\n\", i);\n\t\t\tstrcpy (ptr->name, \"start\");\n\t\t\tptr->name_len = 5;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_ELEMENT:\n\t\t\t//eprintf(\"section element: 0x%x, \", i);\n\t\t\tstrncpy (ptr->name, \"element\", R_BIN_WASM_STRING_LENGTH);\n\t\t\tptr->name_len = 7;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_CODE:\n\t\t\t//eprintf(\"section code: 0x%x, \", i);\n\t\t\tstrncpy (ptr->name, \"code\", R_BIN_WASM_STRING_LENGTH);\n\t\t\tptr->name_len = 4;\n\t\t\tbreak;\n\n\t\tcase R_BIN_WASM_SECTION_DATA:\n\t\t\t//eprintf(\"section data: 0x%x, \", i);\n\t\t\tstrncpy (ptr->name, \"data\", R_BIN_WASM_STRING_LENGTH);\n\t\t\tptr->name_len = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\teprintf(\"unkown section id: %d\\n\", ptr->id);\n\t\t\ti += ptr->size - 1; // next\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tif (ptr->id != R_BIN_WASM_SECTION_START\n\t\t\t\t&& ptr->id != R_BIN_WASM_SECTION_CUSTOM) {\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->count, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t//eprintf(\"count %d\\n\", ptr->count);\n\t\t}\n\n\t\tptr->payload_data = i;\n\t\tptr->payload_len = ptr->size - (i - ptr->offset);\n\n\t\tr_list_append (ret, ptr);\n\n\t\ti += ptr->payload_len; // next\n\n\t}\n\n\tbin->g_sections = ret;\n\n\treturn ret;\n\n}\n\nut32 r_bin_wasm_get_entrypoint (RBinWasmObj *bin) {\n\tRList *secs = NULL;\n\tRBinWasmStartEntry *start = NULL;\n\tRBinWasmSection *sec = NULL;\n\tRBinWasmCodeEntry *func = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn 0;\n\t}\n\tif (bin->entrypoint) {\n\t\treturn bin->entrypoint;\n\t}\n\tif (bin->g_start) {\n\t\tstart = bin->g_start;\n\t} else if (!(secs = r_bin_wasm_get_sections_by_id (bin->g_sections, R_BIN_WASM_SECTION_START))) {\n\t\treturn 0;\n\t} else if (!(sec = (RBinWasmSection*) r_list_first (secs))) {\n\t\treturn 0;\n\t} else {\n\t\tstart = r_bin_wasm_get_start (bin, sec);\n\t\tbin->g_start = start;\n\t}\n\n\tif (!start) {\n\t\treturn 0;\n\t}\n\n\t// FIX: entrypoint can be also an import\n\tfunc = r_list_get_n (r_bin_wasm_get_codes (bin), start->index);\n\treturn (ut32)func? func->code: 0;\n\n}\n\nRList *r_bin_wasm_get_imports (RBinWasmObj *bin) {\n\tRBinWasmSection *import = NULL;\n\tRList *imports = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\tif (bin->g_imports) {\n\t\treturn bin->g_imports;\n\t}\n\tif (!(imports = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_IMPORT))) {\n\t\treturn r_list_new();\n\t}\n\t// support for multiple import sections against spec\n\tif (!(import = (RBinWasmSection*) r_list_first (imports))) {\n\t\treturn r_list_new();\n\t}\n\treturn bin->g_imports = r_bin_wasm_get_import_entries (bin, import);\n}\n\nRList *r_bin_wasm_get_exports (RBinWasmObj *bin) {\n\n\tRBinWasmSection *export = NULL;\n\tRList *exports = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_exports) {\n\t\treturn bin->g_exports;\n\t}\n\n\tif (!(exports= r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_EXPORT))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(export = (RBinWasmSection*) r_list_first (exports))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_exports = r_bin_wasm_get_export_entries (bin, export);\n\n\treturn bin->g_exports;\n}\n\nRList *r_bin_wasm_get_types (RBinWasmObj *bin) {\n\tRBinWasmSection *type = NULL;\n\tRList *types = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_types) {\n\t\treturn bin->g_types;\n\t}\n\n\tif (!(types = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_TYPE))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(type = (RBinWasmSection*) r_list_first (types))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_types = r_bin_wasm_get_type_entries (bin, type);\n\n\treturn bin->g_types;\n}\n\nRList *r_bin_wasm_get_tables (RBinWasmObj *bin) {\n\tRBinWasmSection *table = NULL;\n\tRList *tables = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_tables) {\n\t\treturn bin->g_tables;\n\t}\n\n\tif (!(tables = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_TABLE))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(table = (RBinWasmSection*) r_list_first (tables))) {\n\t\tr_list_free (tables);\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_tables = r_bin_wasm_get_table_entries (bin, table);\n\n\tr_list_free (tables);\n\treturn bin->g_tables;\n}\n\nRList *r_bin_wasm_get_memories (RBinWasmObj *bin) {\n\tRBinWasmSection *memory;\n\tRList *memories;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_memories) {\n\t\treturn bin->g_memories;\n\t}\n\n\tif (!(memories = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_MEMORY))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(memory = (RBinWasmSection*) r_list_first (memories))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_memories = r_bin_wasm_get_memory_entries (bin, memory);\n\n\treturn bin->g_memories;\n}\n\nRList *r_bin_wasm_get_globals (RBinWasmObj *bin) {\n\tRBinWasmSection *global = NULL;\n\tRList *globals = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_globals) {\n\t\treturn bin->g_globals;\n\t}\n\n\tif (!(globals = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_GLOBAL))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(global = (RBinWasmSection*) r_list_first (globals))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_globals = r_bin_wasm_get_global_entries (bin, global);\n\n\treturn bin->g_globals;\n}\n\nRList *r_bin_wasm_get_elements (RBinWasmObj *bin) {\n\tRBinWasmSection *element = NULL;\n\tRList *elements = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_elements) {\n\t\treturn bin->g_elements;\n\t}\n\n\tif (!(elements = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_ELEMENT))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(element = (RBinWasmSection*) r_list_first (elements))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_elements = r_bin_wasm_get_element_entries (bin, element);\n\n\treturn bin->g_elements;\n}\n\nRList *r_bin_wasm_get_codes (RBinWasmObj *bin) {\n\tRBinWasmSection *code = NULL;;\n\tRList *codes = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_codes) {\n\t\treturn bin->g_codes;\n\t}\n\n\tif (!(codes = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_CODE))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(code = (RBinWasmSection*) r_list_first (codes))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_codes = r_bin_wasm_get_code_entries (bin, code);\n\n\treturn bin->g_codes;\n}\n\nRList *r_bin_wasm_get_datas (RBinWasmObj *bin) {\n\tRBinWasmSection *data = NULL;\n\tRList *datas = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->g_datas) {\n\t\treturn bin->g_datas;\n\t}\n\n\tif (!(datas = r_bin_wasm_get_sections_by_id (bin->g_sections,\n\t\t\t\t\t\tR_BIN_WASM_SECTION_DATA))) {\n\t\treturn r_list_new();\n\t}\n\n\t// support for multiple export sections against spec\n\tif (!(data = (RBinWasmSection*) r_list_first (datas))) {\n\t\treturn r_list_new();\n\t}\n\n\tbin->g_datas = r_bin_wasm_get_data_entries (bin, data);\n\n\treturn bin->g_datas;\n}\n"], "filenames": ["libr/bin/format/wasm/wasm.c"], "buggy_code_start_loc": [69], "buggy_code_end_loc": [684], "fixing_code_start_loc": [70], "fixing_code_end_loc": [673], "type": "CWE-125", "message": "The consume_init_expr function in wasm.c in radare2 1.3.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Web Assembly file.", "other": {"cve": {"id": "CVE-2017-7854", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-13T16:59:01.317", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The consume_init_expr function in wasm.c in radare2 1.3.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Web Assembly file."}, {"lang": "es", "value": "La funci\u00f3n consume_init_expr de wasm.c en radare2 1.3.0 permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (sobre-lectura de b\u00fafer basada en memoria din\u00e1mica y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo Web manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "6FEDA3B8-616C-42E1-A70A-D8ABE8DEF929"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97648", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/7265", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4"}}