{"buggy_code": ["/*\n * Copyright (c) 2017 Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n#include <net/addrconf.h>\n#include <linux/etherdevice.h>\n#include <linux/mlx5/vport.h>\n\n#include \"mlx5_core.h\"\n#include \"lib/mlx5.h\"\n#include \"fpga/conn.h\"\n\n#define MLX5_FPGA_PKEY 0xFFFF\n#define MLX5_FPGA_PKEY_INDEX 0 /* RoCE PKEY 0xFFFF is always at index 0 */\n#define MLX5_FPGA_RECV_SIZE 2048\n#define MLX5_FPGA_PORT_NUM 1\n#define MLX5_FPGA_CQ_BUDGET 64\n\nstatic int mlx5_fpga_conn_map_buf(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct device *dma_device;\n\tint err = 0;\n\n\tif (unlikely(!buf->sg[0].data))\n\t\tgoto out;\n\n\tdma_device = &conn->fdev->mdev->pdev->dev;\n\tbuf->sg[0].dma_addr = dma_map_single(dma_device, buf->sg[0].data,\n\t\t\t\t\t     buf->sg[0].size, buf->dma_dir);\n\terr = dma_mapping_error(dma_device, buf->sg[0].dma_addr);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev, \"DMA error on sg 0: %d\\n\", err);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!buf->sg[1].data)\n\t\tgoto out;\n\n\tbuf->sg[1].dma_addr = dma_map_single(dma_device, buf->sg[1].data,\n\t\t\t\t\t     buf->sg[1].size, buf->dma_dir);\n\terr = dma_mapping_error(dma_device, buf->sg[1].dma_addr);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev, \"DMA error on sg 1: %d\\n\", err);\n\t\tdma_unmap_single(dma_device, buf->sg[0].dma_addr,\n\t\t\t\t buf->sg[0].size, buf->dma_dir);\n\t\terr = -ENOMEM;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_unmap_buf(struct mlx5_fpga_conn *conn,\n\t\t\t\t     struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct device *dma_device;\n\n\tdma_device = &conn->fdev->mdev->pdev->dev;\n\tif (buf->sg[1].data)\n\t\tdma_unmap_single(dma_device, buf->sg[1].dma_addr,\n\t\t\t\t buf->sg[1].size, buf->dma_dir);\n\n\tif (likely(buf->sg[0].data))\n\t\tdma_unmap_single(dma_device, buf->sg[0].dma_addr,\n\t\t\t\t buf->sg[0].size, buf->dma_dir);\n}\n\nstatic int mlx5_fpga_conn_post_recv(struct mlx5_fpga_conn *conn,\n\t\t\t\t    struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct mlx5_wqe_data_seg *data;\n\tunsigned int ix;\n\tint err = 0;\n\n\terr = mlx5_fpga_conn_map_buf(conn, buf);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (unlikely(conn->qp.rq.pc - conn->qp.rq.cc >= conn->qp.rq.size)) {\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\treturn -EBUSY;\n\t}\n\n\tix = conn->qp.rq.pc & (conn->qp.rq.size - 1);\n\tdata = mlx5_wq_cyc_get_wqe(&conn->qp.wq.rq, ix);\n\tdata->byte_count = cpu_to_be32(buf->sg[0].size);\n\tdata->lkey = cpu_to_be32(conn->fdev->conn_res.mkey.key);\n\tdata->addr = cpu_to_be64(buf->sg[0].dma_addr);\n\n\tconn->qp.rq.pc++;\n\tconn->qp.rq.bufs[ix] = buf;\n\n\t/* Make sure that descriptors are written before doorbell record. */\n\tdma_wmb();\n\t*conn->qp.wq.rq.db = cpu_to_be32(conn->qp.rq.pc & 0xffff);\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_notify_hw(struct mlx5_fpga_conn *conn, void *wqe)\n{\n\t/* ensure wqe is visible to device before updating doorbell record */\n\tdma_wmb();\n\t*conn->qp.wq.sq.db = cpu_to_be32(conn->qp.sq.pc);\n\t/* Make sure that doorbell record is visible before ringing */\n\twmb();\n\tmlx5_write64(wqe, conn->fdev->conn_res.uar->map + MLX5_BF_OFFSET);\n}\n\nstatic void mlx5_fpga_conn_post_send(struct mlx5_fpga_conn *conn,\n\t\t\t\t     struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl;\n\tstruct mlx5_wqe_data_seg *data;\n\tunsigned int ix, sgi;\n\tint size = 1;\n\n\tix = conn->qp.sq.pc & (conn->qp.sq.size - 1);\n\n\tctrl = mlx5_wq_cyc_get_wqe(&conn->qp.wq.sq, ix);\n\tdata = (void *)(ctrl + 1);\n\n\tfor (sgi = 0; sgi < ARRAY_SIZE(buf->sg); sgi++) {\n\t\tif (!buf->sg[sgi].data)\n\t\t\tbreak;\n\t\tdata->byte_count = cpu_to_be32(buf->sg[sgi].size);\n\t\tdata->lkey = cpu_to_be32(conn->fdev->conn_res.mkey.key);\n\t\tdata->addr = cpu_to_be64(buf->sg[sgi].dma_addr);\n\t\tdata++;\n\t\tsize++;\n\t}\n\n\tctrl->imm = 0;\n\tctrl->fm_ce_se = MLX5_WQE_CTRL_CQ_UPDATE;\n\tctrl->opmod_idx_opcode = cpu_to_be32(((conn->qp.sq.pc & 0xffff) << 8) |\n\t\t\t\t\t     MLX5_OPCODE_SEND);\n\tctrl->qpn_ds = cpu_to_be32(size | (conn->qp.mqp.qpn << 8));\n\n\tconn->qp.sq.pc++;\n\tconn->qp.sq.bufs[ix] = buf;\n\tmlx5_fpga_conn_notify_hw(conn, ctrl);\n}\n\nint mlx5_fpga_conn_send(struct mlx5_fpga_conn *conn,\n\t\t\tstruct mlx5_fpga_dma_buf *buf)\n{\n\tunsigned long flags;\n\tint err;\n\n\tif (!conn->qp.active)\n\t\treturn -ENOTCONN;\n\n\tbuf->dma_dir = DMA_TO_DEVICE;\n\terr = mlx5_fpga_conn_map_buf(conn, buf);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irqsave(&conn->qp.sq.lock, flags);\n\n\tif (conn->qp.sq.pc - conn->qp.sq.cc >= conn->qp.sq.size) {\n\t\tlist_add_tail(&buf->list, &conn->qp.sq.backlog);\n\t\tgoto out_unlock;\n\t}\n\n\tmlx5_fpga_conn_post_send(conn, buf);\n\nout_unlock:\n\tspin_unlock_irqrestore(&conn->qp.sq.lock, flags);\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_post_recv_buf(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_dma_buf *buf;\n\tint err;\n\n\tbuf = kzalloc(sizeof(*buf) + MLX5_FPGA_RECV_SIZE, 0);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->sg[0].data = (void *)(buf + 1);\n\tbuf->sg[0].size = MLX5_FPGA_RECV_SIZE;\n\tbuf->dma_dir = DMA_FROM_DEVICE;\n\n\terr = mlx5_fpga_conn_post_recv(conn, buf);\n\tif (err)\n\t\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_create_mkey(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t      struct mlx5_core_mkey *mkey)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tvoid *mkc;\n\tu32 *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\n\tMLX5_SET(mkc, mkc, pd, pdn);\n\tMLX5_SET(mkc, mkc, length64, 1);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\n\terr = mlx5_core_create_mkey(mdev, mkey, in, inlen);\n\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_rq_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_cqe64 *cqe, u8 status)\n{\n\tstruct mlx5_fpga_dma_buf *buf;\n\tint ix, err;\n\n\tix = be16_to_cpu(cqe->wqe_counter) & (conn->qp.rq.size - 1);\n\tbuf = conn->qp.rq.bufs[ix];\n\tconn->qp.rq.bufs[ix] = NULL;\n\tconn->qp.rq.cc++;\n\n\tif (unlikely(status && (status != MLX5_CQE_SYNDROME_WR_FLUSH_ERR)))\n\t\tmlx5_fpga_warn(conn->fdev, \"RQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t       buf, conn->fpga_qpn, status);\n\telse\n\t\tmlx5_fpga_dbg(conn->fdev, \"RQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t      buf, conn->fpga_qpn, status);\n\n\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\n\tif (unlikely(status || !conn->qp.active)) {\n\t\tconn->qp.active = false;\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tbuf->sg[0].size = be32_to_cpu(cqe->byte_cnt);\n\tmlx5_fpga_dbg(conn->fdev, \"Message with %u bytes received successfully\\n\",\n\t\t      buf->sg[0].size);\n\tconn->recv_cb(conn->cb_arg, buf);\n\n\tbuf->sg[0].size = MLX5_FPGA_RECV_SIZE;\n\terr = mlx5_fpga_conn_post_recv(conn, buf);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev,\n\t\t\t       \"Failed to re-post recv buf: %d\\n\", err);\n\t\tkfree(buf);\n\t}\n}\n\nstatic void mlx5_fpga_conn_sq_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_cqe64 *cqe, u8 status)\n{\n\tstruct mlx5_fpga_dma_buf *buf, *nextbuf;\n\tunsigned long flags;\n\tint ix;\n\n\tspin_lock_irqsave(&conn->qp.sq.lock, flags);\n\n\tix = be16_to_cpu(cqe->wqe_counter) & (conn->qp.sq.size - 1);\n\tbuf = conn->qp.sq.bufs[ix];\n\tconn->qp.sq.bufs[ix] = NULL;\n\tconn->qp.sq.cc++;\n\n\t/* Handle backlog still under the spinlock to ensure message post order */\n\tif (unlikely(!list_empty(&conn->qp.sq.backlog))) {\n\t\tif (likely(conn->qp.active)) {\n\t\t\tnextbuf = list_first_entry(&conn->qp.sq.backlog,\n\t\t\t\t\t\t   struct mlx5_fpga_dma_buf, list);\n\t\t\tlist_del(&nextbuf->list);\n\t\t\tmlx5_fpga_conn_post_send(conn, nextbuf);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&conn->qp.sq.lock, flags);\n\n\tif (unlikely(status && (status != MLX5_CQE_SYNDROME_WR_FLUSH_ERR)))\n\t\tmlx5_fpga_warn(conn->fdev, \"SQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t       buf, conn->fpga_qpn, status);\n\telse\n\t\tmlx5_fpga_dbg(conn->fdev, \"SQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t      buf, conn->fpga_qpn, status);\n\n\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\n\tif (likely(buf->complete))\n\t\tbuf->complete(conn, conn->fdev, buf, status);\n\n\tif (unlikely(status))\n\t\tconn->qp.active = false;\n}\n\nstatic void mlx5_fpga_conn_handle_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t      struct mlx5_cqe64 *cqe)\n{\n\tu8 opcode, status = 0;\n\n\topcode = get_cqe_opcode(cqe);\n\n\tswitch (opcode) {\n\tcase MLX5_CQE_REQ_ERR:\n\t\tstatus = ((struct mlx5_err_cqe *)cqe)->syndrome;\n\t\t/* Fall through */\n\tcase MLX5_CQE_REQ:\n\t\tmlx5_fpga_conn_sq_cqe(conn, cqe, status);\n\t\tbreak;\n\n\tcase MLX5_CQE_RESP_ERR:\n\t\tstatus = ((struct mlx5_err_cqe *)cqe)->syndrome;\n\t\t/* Fall through */\n\tcase MLX5_CQE_RESP_SEND:\n\t\tmlx5_fpga_conn_rq_cqe(conn, cqe, status);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_fpga_warn(conn->fdev, \"Unexpected cqe opcode %u\\n\",\n\t\t\t       opcode);\n\t}\n}\n\nstatic void mlx5_fpga_conn_arm_cq(struct mlx5_fpga_conn *conn)\n{\n\tmlx5_cq_arm(&conn->cq.mcq, MLX5_CQ_DB_REQ_NOT,\n\t\t    conn->fdev->conn_res.uar->map, conn->cq.wq.cc);\n}\n\nstatic void mlx5_fpga_conn_cq_event(struct mlx5_core_cq *mcq,\n\t\t\t\t    enum mlx5_event event)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mcq, struct mlx5_fpga_conn, cq.mcq);\n\tmlx5_fpga_warn(conn->fdev, \"CQ event %u on CQ #%u\\n\", event, mcq->cqn);\n}\n\nstatic void mlx5_fpga_conn_event(struct mlx5_core_qp *mqp, int event)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mqp, struct mlx5_fpga_conn, qp.mqp);\n\tmlx5_fpga_warn(conn->fdev, \"QP event %u on QP #%u\\n\", event, mqp->qpn);\n}\n\nstatic inline void mlx5_fpga_conn_cqes(struct mlx5_fpga_conn *conn,\n\t\t\t\t       unsigned int budget)\n{\n\tstruct mlx5_cqe64 *cqe;\n\n\twhile (budget) {\n\t\tcqe = mlx5_cqwq_get_cqe(&conn->cq.wq);\n\t\tif (!cqe)\n\t\t\tbreak;\n\n\t\tbudget--;\n\t\tmlx5_cqwq_pop(&conn->cq.wq);\n\t\tmlx5_fpga_conn_handle_cqe(conn, cqe);\n\t\tmlx5_cqwq_update_db_record(&conn->cq.wq);\n\t}\n\tif (!budget) {\n\t\ttasklet_schedule(&conn->cq.tasklet);\n\t\treturn;\n\t}\n\n\tmlx5_fpga_dbg(conn->fdev, \"Re-arming CQ with cc# %u\\n\", conn->cq.wq.cc);\n\t/* ensure cq space is freed before enabling more cqes */\n\twmb();\n\tmlx5_fpga_conn_arm_cq(conn);\n}\n\nstatic void mlx5_fpga_conn_cq_tasklet(unsigned long data)\n{\n\tstruct mlx5_fpga_conn *conn = (void *)data;\n\n\tif (unlikely(!conn->qp.active))\n\t\treturn;\n\tmlx5_fpga_conn_cqes(conn, MLX5_FPGA_CQ_BUDGET);\n}\n\nstatic void mlx5_fpga_conn_cq_complete(struct mlx5_core_cq *mcq,\n\t\t\t\t       struct mlx5_eqe *eqe)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mcq, struct mlx5_fpga_conn, cq.mcq);\n\tif (unlikely(!conn->qp.active))\n\t\treturn;\n\tmlx5_fpga_conn_cqes(conn, MLX5_FPGA_CQ_BUDGET);\n}\n\nstatic int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_destroy_cq(struct mlx5_fpga_conn *conn)\n{\n\ttasklet_disable(&conn->cq.tasklet);\n\ttasklet_kill(&conn->cq.tasklet);\n\tmlx5_core_destroy_cq(conn->fdev->mdev, &conn->cq.mcq);\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_create_wq(struct mlx5_fpga_conn *conn, void *qpc)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tstruct mlx5_wq_param wqp;\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\treturn mlx5_wq_qp_create(mdev, &wqp, qpc, &conn->qp.wq,\n\t\t\t\t &conn->qp.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_create_qp(struct mlx5_fpga_conn *conn,\n\t\t\t\t    unsigned int tx_size, unsigned int rx_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_qpc[MLX5_ST_SZ_DW(qpc)] = {0};\n\tvoid *in = NULL, *qpc;\n\tint err, inlen;\n\n\tconn->qp.rq.pc = 0;\n\tconn->qp.rq.cc = 0;\n\tconn->qp.rq.size = roundup_pow_of_two(rx_size);\n\tconn->qp.sq.pc = 0;\n\tconn->qp.sq.cc = 0;\n\tconn->qp.sq.size = roundup_pow_of_two(tx_size);\n\n\tMLX5_SET(qpc, temp_qpc, log_rq_stride, ilog2(MLX5_SEND_WQE_DS) - 4);\n\tMLX5_SET(qpc, temp_qpc, log_rq_size, ilog2(conn->qp.rq.size));\n\tMLX5_SET(qpc, temp_qpc, log_sq_size, ilog2(conn->qp.sq.size));\n\terr = mlx5_fpga_conn_create_wq(conn, temp_qpc);\n\tif (err)\n\t\tgoto out;\n\n\tconn->qp.rq.bufs = kvcalloc(conn->qp.rq.size,\n\t\t\t\t    sizeof(conn->qp.rq.bufs[0]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!conn->qp.rq.bufs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wq;\n\t}\n\n\tconn->qp.sq.bufs = kvcalloc(conn->qp.sq.size,\n\t\t\t\t    sizeof(conn->qp.sq.bufs[0]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!conn->qp.sq.bufs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rq_bufs;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\tMLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) *\n\t\tconn->qp.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_sq_bufs;\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\tMLX5_SET(qpc, qpc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(qpc, qpc, log_page_size,\n\t\t conn->qp.wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(qpc, qpc, fre, 1);\n\tMLX5_SET(qpc, qpc, rlky, 1);\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_RC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, pd, fdev->conn_res.pdn);\n\tMLX5_SET(qpc, qpc, log_rq_stride, ilog2(MLX5_SEND_WQE_DS) - 4);\n\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(conn->qp.rq.size));\n\tMLX5_SET(qpc, qpc, rq_type, MLX5_NON_ZERO_RQ);\n\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(conn->qp.sq.size));\n\tMLX5_SET(qpc, qpc, cqn_snd, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_rcv, conn->cq.mcq.cqn);\n\tMLX5_SET64(qpc, qpc, dbr_addr, conn->qp.wq_ctrl.db.dma);\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == 1)\n\t\tMLX5_SET(qpc, qpc, user_index, 0xFFFFFF);\n\n\tmlx5_fill_page_frag_array(&conn->qp.wq_ctrl.buf,\n\t\t\t\t  (__be64 *)MLX5_ADDR_OF(create_qp_in, in, pas));\n\n\terr = mlx5_core_create_qp(mdev, &conn->qp.mqp, in, inlen);\n\tif (err)\n\t\tgoto err_sq_bufs;\n\n\tconn->qp.mqp.event = mlx5_fpga_conn_event;\n\tmlx5_fpga_dbg(fdev, \"Created QP #0x%x\\n\", conn->qp.mqp.qpn);\n\n\tgoto out;\n\nerr_sq_bufs:\n\tkvfree(conn->qp.sq.bufs);\nerr_rq_bufs:\n\tkvfree(conn->qp.rq.bufs);\nerr_wq:\n\tmlx5_wq_destroy(&conn->qp.wq_ctrl);\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_free_recv_bufs(struct mlx5_fpga_conn *conn)\n{\n\tint ix;\n\n\tfor (ix = 0; ix < conn->qp.rq.size; ix++) {\n\t\tif (!conn->qp.rq.bufs[ix])\n\t\t\tcontinue;\n\t\tmlx5_fpga_conn_unmap_buf(conn, conn->qp.rq.bufs[ix]);\n\t\tkfree(conn->qp.rq.bufs[ix]);\n\t\tconn->qp.rq.bufs[ix] = NULL;\n\t}\n}\n\nstatic void mlx5_fpga_conn_flush_send_bufs(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_dma_buf *buf, *temp;\n\tint ix;\n\n\tfor (ix = 0; ix < conn->qp.sq.size; ix++) {\n\t\tbuf = conn->qp.sq.bufs[ix];\n\t\tif (!buf)\n\t\t\tcontinue;\n\t\tconn->qp.sq.bufs[ix] = NULL;\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\tif (!buf->complete)\n\t\t\tcontinue;\n\t\tbuf->complete(conn, conn->fdev, buf, MLX5_CQE_SYNDROME_WR_FLUSH_ERR);\n\t}\n\tlist_for_each_entry_safe(buf, temp, &conn->qp.sq.backlog, list) {\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\tif (!buf->complete)\n\t\t\tcontinue;\n\t\tbuf->complete(conn, conn->fdev, buf, MLX5_CQE_SYNDROME_WR_FLUSH_ERR);\n\t}\n}\n\nstatic void mlx5_fpga_conn_destroy_qp(struct mlx5_fpga_conn *conn)\n{\n\tmlx5_core_destroy_qp(conn->fdev->mdev, &conn->qp.mqp);\n\tmlx5_fpga_conn_free_recv_bufs(conn);\n\tmlx5_fpga_conn_flush_send_bufs(conn);\n\tkvfree(conn->qp.sq.bufs);\n\tkvfree(conn->qp.rq.bufs);\n\tmlx5_wq_destroy(&conn->qp.wq_ctrl);\n}\n\nstatic inline int mlx5_fpga_conn_reset_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_core_dev *mdev = conn->fdev->mdev;\n\n\tmlx5_fpga_dbg(conn->fdev, \"Modifying QP %u to RST\\n\", conn->qp.mqp.qpn);\n\n\treturn mlx5_core_qp_modify(mdev, MLX5_CMD_OP_2RST_QP, 0, NULL,\n\t\t\t\t   &conn->qp.mqp);\n}\n\nstatic inline int mlx5_fpga_conn_init_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc = NULL;\n\tint err;\n\n\tmlx5_fpga_dbg(conn->fdev, \"Modifying QP %u to INIT\\n\", conn->qp.mqp.qpn);\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_RC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index, MLX5_FPGA_PKEY_INDEX);\n\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, MLX5_FPGA_PORT_NUM);\n\tMLX5_SET(qpc, qpc, pd, conn->fdev->conn_res.pdn);\n\tMLX5_SET(qpc, qpc, cqn_snd, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_rcv, conn->cq.mcq.cqn);\n\tMLX5_SET64(qpc, qpc, dbr_addr, conn->qp.wq_ctrl.db.dma);\n\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_RST2INIT_QP, 0, qpc,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err) {\n\t\tmlx5_fpga_warn(fdev, \"qp_modify RST2INIT failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic inline int mlx5_fpga_conn_rtr_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc = NULL;\n\tint err;\n\n\tmlx5_fpga_dbg(conn->fdev, \"QP RTR\\n\");\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpc, qpc, mtu, MLX5_QPC_MTU_1K_BYTES);\n\tMLX5_SET(qpc, qpc, log_msg_max, (u8)MLX5_CAP_GEN(mdev, log_max_msg));\n\tMLX5_SET(qpc, qpc, remote_qpn, conn->fpga_qpn);\n\tMLX5_SET(qpc, qpc, next_rcv_psn,\n\t\t MLX5_GET(fpga_qpc, conn->fpga_qpc, next_send_psn));\n\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index, MLX5_FPGA_PKEY_INDEX);\n\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, MLX5_FPGA_PORT_NUM);\n\tether_addr_copy(MLX5_ADDR_OF(qpc, qpc, primary_address_path.rmac_47_32),\n\t\t\tMLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, fpga_mac_47_32));\n\tMLX5_SET(qpc, qpc, primary_address_path.udp_sport,\n\t\t MLX5_CAP_ROCE(mdev, r_roce_min_src_udp_port));\n\tMLX5_SET(qpc, qpc, primary_address_path.src_addr_index,\n\t\t conn->qp.sgid_index);\n\tMLX5_SET(qpc, qpc, primary_address_path.hop_limit, 0);\n\tmemcpy(MLX5_ADDR_OF(qpc, qpc, primary_address_path.rgid_rip),\n\t       MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, fpga_ip),\n\t       MLX5_FLD_SZ_BYTES(qpc, primary_address_path.rgid_rip));\n\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_INIT2RTR_QP, 0, qpc,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err) {\n\t\tmlx5_fpga_warn(fdev, \"qp_modify RST2INIT failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic inline int mlx5_fpga_conn_rts_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc = NULL;\n\tu32 opt_mask;\n\tint err;\n\n\tmlx5_fpga_dbg(conn->fdev, \"QP RTS\\n\");\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpc, qpc, log_ack_req_freq, 8);\n\tMLX5_SET(qpc, qpc, min_rnr_nak, 0x12);\n\tMLX5_SET(qpc, qpc, primary_address_path.ack_timeout, 0x12); /* ~1.07s */\n\tMLX5_SET(qpc, qpc, next_send_psn,\n\t\t MLX5_GET(fpga_qpc, conn->fpga_qpc, next_rcv_psn));\n\tMLX5_SET(qpc, qpc, retry_count, 7);\n\tMLX5_SET(qpc, qpc, rnr_retry, 7); /* Infinite retry if RNR NACK */\n\n\topt_mask = MLX5_QP_OPTPAR_RNR_TIMEOUT;\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_RTR2RTS_QP, opt_mask, qpc,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err) {\n\t\tmlx5_fpga_warn(fdev, \"qp_modify RST2INIT failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_connect(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tint err;\n\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_ACTIVE);\n\terr = mlx5_fpga_modify_qp(conn->fdev->mdev, conn->fpga_qpn,\n\t\t\t\t  MLX5_FPGA_QPC_STATE, &conn->fpga_qpc);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to activate FPGA RC QP: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = mlx5_fpga_conn_reset_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state to reset\\n\");\n\t\tgoto err_fpga_qp;\n\t}\n\n\terr = mlx5_fpga_conn_init_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to modify QP from RESET to INIT\\n\");\n\t\tgoto err_fpga_qp;\n\t}\n\tconn->qp.active = true;\n\n\twhile (!mlx5_fpga_conn_post_recv_buf(conn))\n\t\t;\n\n\terr = mlx5_fpga_conn_rtr_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state from INIT to RTR\\n\");\n\t\tgoto err_recv_bufs;\n\t}\n\n\terr = mlx5_fpga_conn_rts_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state from RTR to RTS\\n\");\n\t\tgoto err_recv_bufs;\n\t}\n\tgoto out;\n\nerr_recv_bufs:\n\tmlx5_fpga_conn_free_recv_bufs(conn);\nerr_fpga_qp:\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_INIT);\n\tif (mlx5_fpga_modify_qp(conn->fdev->mdev, conn->fpga_qpn,\n\t\t\t\tMLX5_FPGA_QPC_STATE, &conn->fpga_qpc))\n\t\tmlx5_fpga_err(fdev, \"Failed to revert FPGA QP to INIT\\n\");\nout:\n\treturn err;\n}\n\nstruct mlx5_fpga_conn *mlx5_fpga_conn_create(struct mlx5_fpga_device *fdev,\n\t\t\t\t\t     struct mlx5_fpga_conn_attr *attr,\n\t\t\t\t\t     enum mlx5_ifc_fpga_qp_type qp_type)\n{\n\tstruct mlx5_fpga_conn *ret, *conn;\n\tu8 *remote_mac, *remote_ip;\n\tint err;\n\n\tif (!attr->recv_cb)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconn->fdev = fdev;\n\tINIT_LIST_HEAD(&conn->qp.sq.backlog);\n\n\tspin_lock_init(&conn->qp.sq.lock);\n\n\tconn->recv_cb = attr->recv_cb;\n\tconn->cb_arg = attr->cb_arg;\n\n\tremote_mac = MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, remote_mac_47_32);\n\terr = mlx5_query_mac_address(fdev->mdev, remote_mac);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to query local MAC: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err;\n\t}\n\n\t/* Build Modified EUI-64 IPv6 address from the MAC address */\n\tremote_ip = MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, remote_ip);\n\tremote_ip[0] = 0xfe;\n\tremote_ip[1] = 0x80;\n\taddrconf_addr_eui48(&remote_ip[8], remote_mac);\n\n\terr = mlx5_core_reserved_gid_alloc(fdev->mdev, &conn->qp.sgid_index);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to allocate SGID: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err;\n\t}\n\n\terr = mlx5_core_roce_gid_set(fdev->mdev, conn->qp.sgid_index,\n\t\t\t\t     MLX5_ROCE_VERSION_2,\n\t\t\t\t     MLX5_ROCE_L3_TYPE_IPV6,\n\t\t\t\t     remote_ip, remote_mac, true, 0,\n\t\t\t\t     MLX5_FPGA_PORT_NUM);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to set SGID: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_rsvd_gid;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Reserved SGID index %u\\n\", conn->qp.sgid_index);\n\n\t/* Allow for one cqe per rx/tx wqe, plus one cqe for the next wqe,\n\t * created during processing of the cqe\n\t */\n\terr = mlx5_fpga_conn_create_cq(conn,\n\t\t\t\t       (attr->tx_size + attr->rx_size) * 2);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create CQ: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_gid;\n\t}\n\n\tmlx5_fpga_conn_arm_cq(conn);\n\n\terr = mlx5_fpga_conn_create_qp(conn, attr->tx_size, attr->rx_size);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create QP: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_cq;\n\t}\n\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_INIT);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, qp_type, qp_type);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, st, MLX5_FPGA_QPC_ST_RC);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, ether_type, ETH_P_8021Q);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, vid, 0);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, next_rcv_psn, 1);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, next_send_psn, 0);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, pkey, MLX5_FPGA_PKEY);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, remote_qpn, conn->qp.mqp.qpn);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, rnr_retry, 7);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, retry_count, 7);\n\n\terr = mlx5_fpga_create_qp(fdev->mdev, &conn->fpga_qpc,\n\t\t\t\t  &conn->fpga_qpn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create FPGA RC QP: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_qp;\n\t}\n\n\terr = mlx5_fpga_conn_connect(conn);\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto err_conn;\n\t}\n\n\tmlx5_fpga_dbg(fdev, \"FPGA QPN is %u\\n\", conn->fpga_qpn);\n\tret = conn;\n\tgoto out;\n\nerr_conn:\n\tmlx5_fpga_destroy_qp(conn->fdev->mdev, conn->fpga_qpn);\nerr_qp:\n\tmlx5_fpga_conn_destroy_qp(conn);\nerr_cq:\n\tmlx5_fpga_conn_destroy_cq(conn);\nerr_gid:\n\tmlx5_core_roce_gid_set(fdev->mdev, conn->qp.sgid_index, 0, 0, NULL,\n\t\t\t       NULL, false, 0, MLX5_FPGA_PORT_NUM);\nerr_rsvd_gid:\n\tmlx5_core_reserved_gid_free(fdev->mdev, conn->qp.sgid_index);\nerr:\n\tkfree(conn);\nout:\n\treturn ret;\n}\n\nvoid mlx5_fpga_conn_destroy(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tint err = 0;\n\n\tconn->qp.active = false;\n\ttasklet_disable(&conn->cq.tasklet);\n\tsynchronize_irq(conn->cq.mcq.irqn);\n\n\tmlx5_fpga_destroy_qp(conn->fdev->mdev, conn->fpga_qpn);\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_2ERR_QP, 0, NULL,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err)\n\t\tmlx5_fpga_warn(fdev, \"qp_modify 2ERR failed: %d\\n\", err);\n\tmlx5_fpga_conn_destroy_qp(conn);\n\tmlx5_fpga_conn_destroy_cq(conn);\n\n\tmlx5_core_roce_gid_set(conn->fdev->mdev, conn->qp.sgid_index, 0, 0,\n\t\t\t       NULL, NULL, false, 0, MLX5_FPGA_PORT_NUM);\n\tmlx5_core_reserved_gid_free(conn->fdev->mdev, conn->qp.sgid_index);\n\tkfree(conn);\n}\n\nint mlx5_fpga_conn_device_init(struct mlx5_fpga_device *fdev)\n{\n\tint err;\n\n\terr = mlx5_nic_vport_enable_roce(fdev->mdev);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to enable RoCE: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfdev->conn_res.uar = mlx5_get_uars_page(fdev->mdev);\n\tif (IS_ERR(fdev->conn_res.uar)) {\n\t\terr = PTR_ERR(fdev->conn_res.uar);\n\t\tmlx5_fpga_err(fdev, \"get_uars_page failed, %d\\n\", err);\n\t\tgoto err_roce;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Allocated UAR index %u\\n\",\n\t\t      fdev->conn_res.uar->index);\n\n\terr = mlx5_core_alloc_pd(fdev->mdev, &fdev->conn_res.pdn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"alloc pd failed, %d\\n\", err);\n\t\tgoto err_uar;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Allocated PD %u\\n\", fdev->conn_res.pdn);\n\n\terr = mlx5_fpga_conn_create_mkey(fdev->mdev, fdev->conn_res.pdn,\n\t\t\t\t\t &fdev->conn_res.mkey);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"create mkey failed, %d\\n\", err);\n\t\tgoto err_dealloc_pd;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Created mkey 0x%x\\n\", fdev->conn_res.mkey.key);\n\n\treturn 0;\n\nerr_dealloc_pd:\n\tmlx5_core_dealloc_pd(fdev->mdev, fdev->conn_res.pdn);\nerr_uar:\n\tmlx5_put_uars_page(fdev->mdev, fdev->conn_res.uar);\nerr_roce:\n\tmlx5_nic_vport_disable_roce(fdev->mdev);\nout:\n\treturn err;\n}\n\nvoid mlx5_fpga_conn_device_cleanup(struct mlx5_fpga_device *fdev)\n{\n\tmlx5_core_destroy_mkey(fdev->mdev, &fdev->conn_res.mkey);\n\tmlx5_core_dealloc_pd(fdev->mdev, fdev->conn_res.pdn);\n\tmlx5_put_uars_page(fdev->mdev, fdev->conn_res.uar);\n\tmlx5_nic_vport_disable_roce(fdev->mdev);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2017 Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n#include <net/addrconf.h>\n#include <linux/etherdevice.h>\n#include <linux/mlx5/vport.h>\n\n#include \"mlx5_core.h\"\n#include \"lib/mlx5.h\"\n#include \"fpga/conn.h\"\n\n#define MLX5_FPGA_PKEY 0xFFFF\n#define MLX5_FPGA_PKEY_INDEX 0 /* RoCE PKEY 0xFFFF is always at index 0 */\n#define MLX5_FPGA_RECV_SIZE 2048\n#define MLX5_FPGA_PORT_NUM 1\n#define MLX5_FPGA_CQ_BUDGET 64\n\nstatic int mlx5_fpga_conn_map_buf(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct device *dma_device;\n\tint err = 0;\n\n\tif (unlikely(!buf->sg[0].data))\n\t\tgoto out;\n\n\tdma_device = &conn->fdev->mdev->pdev->dev;\n\tbuf->sg[0].dma_addr = dma_map_single(dma_device, buf->sg[0].data,\n\t\t\t\t\t     buf->sg[0].size, buf->dma_dir);\n\terr = dma_mapping_error(dma_device, buf->sg[0].dma_addr);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev, \"DMA error on sg 0: %d\\n\", err);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!buf->sg[1].data)\n\t\tgoto out;\n\n\tbuf->sg[1].dma_addr = dma_map_single(dma_device, buf->sg[1].data,\n\t\t\t\t\t     buf->sg[1].size, buf->dma_dir);\n\terr = dma_mapping_error(dma_device, buf->sg[1].dma_addr);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev, \"DMA error on sg 1: %d\\n\", err);\n\t\tdma_unmap_single(dma_device, buf->sg[0].dma_addr,\n\t\t\t\t buf->sg[0].size, buf->dma_dir);\n\t\terr = -ENOMEM;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_unmap_buf(struct mlx5_fpga_conn *conn,\n\t\t\t\t     struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct device *dma_device;\n\n\tdma_device = &conn->fdev->mdev->pdev->dev;\n\tif (buf->sg[1].data)\n\t\tdma_unmap_single(dma_device, buf->sg[1].dma_addr,\n\t\t\t\t buf->sg[1].size, buf->dma_dir);\n\n\tif (likely(buf->sg[0].data))\n\t\tdma_unmap_single(dma_device, buf->sg[0].dma_addr,\n\t\t\t\t buf->sg[0].size, buf->dma_dir);\n}\n\nstatic int mlx5_fpga_conn_post_recv(struct mlx5_fpga_conn *conn,\n\t\t\t\t    struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct mlx5_wqe_data_seg *data;\n\tunsigned int ix;\n\tint err = 0;\n\n\terr = mlx5_fpga_conn_map_buf(conn, buf);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (unlikely(conn->qp.rq.pc - conn->qp.rq.cc >= conn->qp.rq.size)) {\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\treturn -EBUSY;\n\t}\n\n\tix = conn->qp.rq.pc & (conn->qp.rq.size - 1);\n\tdata = mlx5_wq_cyc_get_wqe(&conn->qp.wq.rq, ix);\n\tdata->byte_count = cpu_to_be32(buf->sg[0].size);\n\tdata->lkey = cpu_to_be32(conn->fdev->conn_res.mkey.key);\n\tdata->addr = cpu_to_be64(buf->sg[0].dma_addr);\n\n\tconn->qp.rq.pc++;\n\tconn->qp.rq.bufs[ix] = buf;\n\n\t/* Make sure that descriptors are written before doorbell record. */\n\tdma_wmb();\n\t*conn->qp.wq.rq.db = cpu_to_be32(conn->qp.rq.pc & 0xffff);\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_notify_hw(struct mlx5_fpga_conn *conn, void *wqe)\n{\n\t/* ensure wqe is visible to device before updating doorbell record */\n\tdma_wmb();\n\t*conn->qp.wq.sq.db = cpu_to_be32(conn->qp.sq.pc);\n\t/* Make sure that doorbell record is visible before ringing */\n\twmb();\n\tmlx5_write64(wqe, conn->fdev->conn_res.uar->map + MLX5_BF_OFFSET);\n}\n\nstatic void mlx5_fpga_conn_post_send(struct mlx5_fpga_conn *conn,\n\t\t\t\t     struct mlx5_fpga_dma_buf *buf)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl;\n\tstruct mlx5_wqe_data_seg *data;\n\tunsigned int ix, sgi;\n\tint size = 1;\n\n\tix = conn->qp.sq.pc & (conn->qp.sq.size - 1);\n\n\tctrl = mlx5_wq_cyc_get_wqe(&conn->qp.wq.sq, ix);\n\tdata = (void *)(ctrl + 1);\n\n\tfor (sgi = 0; sgi < ARRAY_SIZE(buf->sg); sgi++) {\n\t\tif (!buf->sg[sgi].data)\n\t\t\tbreak;\n\t\tdata->byte_count = cpu_to_be32(buf->sg[sgi].size);\n\t\tdata->lkey = cpu_to_be32(conn->fdev->conn_res.mkey.key);\n\t\tdata->addr = cpu_to_be64(buf->sg[sgi].dma_addr);\n\t\tdata++;\n\t\tsize++;\n\t}\n\n\tctrl->imm = 0;\n\tctrl->fm_ce_se = MLX5_WQE_CTRL_CQ_UPDATE;\n\tctrl->opmod_idx_opcode = cpu_to_be32(((conn->qp.sq.pc & 0xffff) << 8) |\n\t\t\t\t\t     MLX5_OPCODE_SEND);\n\tctrl->qpn_ds = cpu_to_be32(size | (conn->qp.mqp.qpn << 8));\n\n\tconn->qp.sq.pc++;\n\tconn->qp.sq.bufs[ix] = buf;\n\tmlx5_fpga_conn_notify_hw(conn, ctrl);\n}\n\nint mlx5_fpga_conn_send(struct mlx5_fpga_conn *conn,\n\t\t\tstruct mlx5_fpga_dma_buf *buf)\n{\n\tunsigned long flags;\n\tint err;\n\n\tif (!conn->qp.active)\n\t\treturn -ENOTCONN;\n\n\tbuf->dma_dir = DMA_TO_DEVICE;\n\terr = mlx5_fpga_conn_map_buf(conn, buf);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irqsave(&conn->qp.sq.lock, flags);\n\n\tif (conn->qp.sq.pc - conn->qp.sq.cc >= conn->qp.sq.size) {\n\t\tlist_add_tail(&buf->list, &conn->qp.sq.backlog);\n\t\tgoto out_unlock;\n\t}\n\n\tmlx5_fpga_conn_post_send(conn, buf);\n\nout_unlock:\n\tspin_unlock_irqrestore(&conn->qp.sq.lock, flags);\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_post_recv_buf(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_dma_buf *buf;\n\tint err;\n\n\tbuf = kzalloc(sizeof(*buf) + MLX5_FPGA_RECV_SIZE, 0);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->sg[0].data = (void *)(buf + 1);\n\tbuf->sg[0].size = MLX5_FPGA_RECV_SIZE;\n\tbuf->dma_dir = DMA_FROM_DEVICE;\n\n\terr = mlx5_fpga_conn_post_recv(conn, buf);\n\tif (err)\n\t\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_create_mkey(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t      struct mlx5_core_mkey *mkey)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_mkey_in);\n\tvoid *mkc;\n\tu32 *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\n\tMLX5_SET(mkc, mkc, pd, pdn);\n\tMLX5_SET(mkc, mkc, length64, 1);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\n\terr = mlx5_core_create_mkey(mdev, mkey, in, inlen);\n\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_rq_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_cqe64 *cqe, u8 status)\n{\n\tstruct mlx5_fpga_dma_buf *buf;\n\tint ix, err;\n\n\tix = be16_to_cpu(cqe->wqe_counter) & (conn->qp.rq.size - 1);\n\tbuf = conn->qp.rq.bufs[ix];\n\tconn->qp.rq.bufs[ix] = NULL;\n\tconn->qp.rq.cc++;\n\n\tif (unlikely(status && (status != MLX5_CQE_SYNDROME_WR_FLUSH_ERR)))\n\t\tmlx5_fpga_warn(conn->fdev, \"RQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t       buf, conn->fpga_qpn, status);\n\telse\n\t\tmlx5_fpga_dbg(conn->fdev, \"RQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t      buf, conn->fpga_qpn, status);\n\n\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\n\tif (unlikely(status || !conn->qp.active)) {\n\t\tconn->qp.active = false;\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tbuf->sg[0].size = be32_to_cpu(cqe->byte_cnt);\n\tmlx5_fpga_dbg(conn->fdev, \"Message with %u bytes received successfully\\n\",\n\t\t      buf->sg[0].size);\n\tconn->recv_cb(conn->cb_arg, buf);\n\n\tbuf->sg[0].size = MLX5_FPGA_RECV_SIZE;\n\terr = mlx5_fpga_conn_post_recv(conn, buf);\n\tif (unlikely(err)) {\n\t\tmlx5_fpga_warn(conn->fdev,\n\t\t\t       \"Failed to re-post recv buf: %d\\n\", err);\n\t\tkfree(buf);\n\t}\n}\n\nstatic void mlx5_fpga_conn_sq_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t  struct mlx5_cqe64 *cqe, u8 status)\n{\n\tstruct mlx5_fpga_dma_buf *buf, *nextbuf;\n\tunsigned long flags;\n\tint ix;\n\n\tspin_lock_irqsave(&conn->qp.sq.lock, flags);\n\n\tix = be16_to_cpu(cqe->wqe_counter) & (conn->qp.sq.size - 1);\n\tbuf = conn->qp.sq.bufs[ix];\n\tconn->qp.sq.bufs[ix] = NULL;\n\tconn->qp.sq.cc++;\n\n\t/* Handle backlog still under the spinlock to ensure message post order */\n\tif (unlikely(!list_empty(&conn->qp.sq.backlog))) {\n\t\tif (likely(conn->qp.active)) {\n\t\t\tnextbuf = list_first_entry(&conn->qp.sq.backlog,\n\t\t\t\t\t\t   struct mlx5_fpga_dma_buf, list);\n\t\t\tlist_del(&nextbuf->list);\n\t\t\tmlx5_fpga_conn_post_send(conn, nextbuf);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&conn->qp.sq.lock, flags);\n\n\tif (unlikely(status && (status != MLX5_CQE_SYNDROME_WR_FLUSH_ERR)))\n\t\tmlx5_fpga_warn(conn->fdev, \"SQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t       buf, conn->fpga_qpn, status);\n\telse\n\t\tmlx5_fpga_dbg(conn->fdev, \"SQ buf %p on FPGA QP %u completion status %d\\n\",\n\t\t\t      buf, conn->fpga_qpn, status);\n\n\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\n\tif (likely(buf->complete))\n\t\tbuf->complete(conn, conn->fdev, buf, status);\n\n\tif (unlikely(status))\n\t\tconn->qp.active = false;\n}\n\nstatic void mlx5_fpga_conn_handle_cqe(struct mlx5_fpga_conn *conn,\n\t\t\t\t      struct mlx5_cqe64 *cqe)\n{\n\tu8 opcode, status = 0;\n\n\topcode = get_cqe_opcode(cqe);\n\n\tswitch (opcode) {\n\tcase MLX5_CQE_REQ_ERR:\n\t\tstatus = ((struct mlx5_err_cqe *)cqe)->syndrome;\n\t\t/* Fall through */\n\tcase MLX5_CQE_REQ:\n\t\tmlx5_fpga_conn_sq_cqe(conn, cqe, status);\n\t\tbreak;\n\n\tcase MLX5_CQE_RESP_ERR:\n\t\tstatus = ((struct mlx5_err_cqe *)cqe)->syndrome;\n\t\t/* Fall through */\n\tcase MLX5_CQE_RESP_SEND:\n\t\tmlx5_fpga_conn_rq_cqe(conn, cqe, status);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_fpga_warn(conn->fdev, \"Unexpected cqe opcode %u\\n\",\n\t\t\t       opcode);\n\t}\n}\n\nstatic void mlx5_fpga_conn_arm_cq(struct mlx5_fpga_conn *conn)\n{\n\tmlx5_cq_arm(&conn->cq.mcq, MLX5_CQ_DB_REQ_NOT,\n\t\t    conn->fdev->conn_res.uar->map, conn->cq.wq.cc);\n}\n\nstatic void mlx5_fpga_conn_cq_event(struct mlx5_core_cq *mcq,\n\t\t\t\t    enum mlx5_event event)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mcq, struct mlx5_fpga_conn, cq.mcq);\n\tmlx5_fpga_warn(conn->fdev, \"CQ event %u on CQ #%u\\n\", event, mcq->cqn);\n}\n\nstatic void mlx5_fpga_conn_event(struct mlx5_core_qp *mqp, int event)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mqp, struct mlx5_fpga_conn, qp.mqp);\n\tmlx5_fpga_warn(conn->fdev, \"QP event %u on QP #%u\\n\", event, mqp->qpn);\n}\n\nstatic inline void mlx5_fpga_conn_cqes(struct mlx5_fpga_conn *conn,\n\t\t\t\t       unsigned int budget)\n{\n\tstruct mlx5_cqe64 *cqe;\n\n\twhile (budget) {\n\t\tcqe = mlx5_cqwq_get_cqe(&conn->cq.wq);\n\t\tif (!cqe)\n\t\t\tbreak;\n\n\t\tbudget--;\n\t\tmlx5_cqwq_pop(&conn->cq.wq);\n\t\tmlx5_fpga_conn_handle_cqe(conn, cqe);\n\t\tmlx5_cqwq_update_db_record(&conn->cq.wq);\n\t}\n\tif (!budget) {\n\t\ttasklet_schedule(&conn->cq.tasklet);\n\t\treturn;\n\t}\n\n\tmlx5_fpga_dbg(conn->fdev, \"Re-arming CQ with cc# %u\\n\", conn->cq.wq.cc);\n\t/* ensure cq space is freed before enabling more cqes */\n\twmb();\n\tmlx5_fpga_conn_arm_cq(conn);\n}\n\nstatic void mlx5_fpga_conn_cq_tasklet(unsigned long data)\n{\n\tstruct mlx5_fpga_conn *conn = (void *)data;\n\n\tif (unlikely(!conn->qp.active))\n\t\treturn;\n\tmlx5_fpga_conn_cqes(conn, MLX5_FPGA_CQ_BUDGET);\n}\n\nstatic void mlx5_fpga_conn_cq_complete(struct mlx5_core_cq *mcq,\n\t\t\t\t       struct mlx5_eqe *eqe)\n{\n\tstruct mlx5_fpga_conn *conn;\n\n\tconn = container_of(mcq, struct mlx5_fpga_conn, cq.mcq);\n\tif (unlikely(!conn->qp.active))\n\t\treturn;\n\tmlx5_fpga_conn_cqes(conn, MLX5_FPGA_CQ_BUDGET);\n}\n\nstatic int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err) {\n\t\tkvfree(in);\n\t\tgoto err_cqwq;\n\t}\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_destroy_cq(struct mlx5_fpga_conn *conn)\n{\n\ttasklet_disable(&conn->cq.tasklet);\n\ttasklet_kill(&conn->cq.tasklet);\n\tmlx5_core_destroy_cq(conn->fdev->mdev, &conn->cq.mcq);\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_create_wq(struct mlx5_fpga_conn *conn, void *qpc)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tstruct mlx5_wq_param wqp;\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\treturn mlx5_wq_qp_create(mdev, &wqp, qpc, &conn->qp.wq,\n\t\t\t\t &conn->qp.wq_ctrl);\n}\n\nstatic int mlx5_fpga_conn_create_qp(struct mlx5_fpga_conn *conn,\n\t\t\t\t    unsigned int tx_size, unsigned int rx_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_qpc[MLX5_ST_SZ_DW(qpc)] = {0};\n\tvoid *in = NULL, *qpc;\n\tint err, inlen;\n\n\tconn->qp.rq.pc = 0;\n\tconn->qp.rq.cc = 0;\n\tconn->qp.rq.size = roundup_pow_of_two(rx_size);\n\tconn->qp.sq.pc = 0;\n\tconn->qp.sq.cc = 0;\n\tconn->qp.sq.size = roundup_pow_of_two(tx_size);\n\n\tMLX5_SET(qpc, temp_qpc, log_rq_stride, ilog2(MLX5_SEND_WQE_DS) - 4);\n\tMLX5_SET(qpc, temp_qpc, log_rq_size, ilog2(conn->qp.rq.size));\n\tMLX5_SET(qpc, temp_qpc, log_sq_size, ilog2(conn->qp.sq.size));\n\terr = mlx5_fpga_conn_create_wq(conn, temp_qpc);\n\tif (err)\n\t\tgoto out;\n\n\tconn->qp.rq.bufs = kvcalloc(conn->qp.rq.size,\n\t\t\t\t    sizeof(conn->qp.rq.bufs[0]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!conn->qp.rq.bufs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wq;\n\t}\n\n\tconn->qp.sq.bufs = kvcalloc(conn->qp.sq.size,\n\t\t\t\t    sizeof(conn->qp.sq.bufs[0]),\n\t\t\t\t    GFP_KERNEL);\n\tif (!conn->qp.sq.bufs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rq_bufs;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\tMLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) *\n\t\tconn->qp.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_sq_bufs;\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\tMLX5_SET(qpc, qpc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(qpc, qpc, log_page_size,\n\t\t conn->qp.wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(qpc, qpc, fre, 1);\n\tMLX5_SET(qpc, qpc, rlky, 1);\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_RC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, pd, fdev->conn_res.pdn);\n\tMLX5_SET(qpc, qpc, log_rq_stride, ilog2(MLX5_SEND_WQE_DS) - 4);\n\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(conn->qp.rq.size));\n\tMLX5_SET(qpc, qpc, rq_type, MLX5_NON_ZERO_RQ);\n\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(conn->qp.sq.size));\n\tMLX5_SET(qpc, qpc, cqn_snd, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_rcv, conn->cq.mcq.cqn);\n\tMLX5_SET64(qpc, qpc, dbr_addr, conn->qp.wq_ctrl.db.dma);\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == 1)\n\t\tMLX5_SET(qpc, qpc, user_index, 0xFFFFFF);\n\n\tmlx5_fill_page_frag_array(&conn->qp.wq_ctrl.buf,\n\t\t\t\t  (__be64 *)MLX5_ADDR_OF(create_qp_in, in, pas));\n\n\terr = mlx5_core_create_qp(mdev, &conn->qp.mqp, in, inlen);\n\tif (err)\n\t\tgoto err_sq_bufs;\n\n\tconn->qp.mqp.event = mlx5_fpga_conn_event;\n\tmlx5_fpga_dbg(fdev, \"Created QP #0x%x\\n\", conn->qp.mqp.qpn);\n\n\tgoto out;\n\nerr_sq_bufs:\n\tkvfree(conn->qp.sq.bufs);\nerr_rq_bufs:\n\tkvfree(conn->qp.rq.bufs);\nerr_wq:\n\tmlx5_wq_destroy(&conn->qp.wq_ctrl);\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_fpga_conn_free_recv_bufs(struct mlx5_fpga_conn *conn)\n{\n\tint ix;\n\n\tfor (ix = 0; ix < conn->qp.rq.size; ix++) {\n\t\tif (!conn->qp.rq.bufs[ix])\n\t\t\tcontinue;\n\t\tmlx5_fpga_conn_unmap_buf(conn, conn->qp.rq.bufs[ix]);\n\t\tkfree(conn->qp.rq.bufs[ix]);\n\t\tconn->qp.rq.bufs[ix] = NULL;\n\t}\n}\n\nstatic void mlx5_fpga_conn_flush_send_bufs(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_dma_buf *buf, *temp;\n\tint ix;\n\n\tfor (ix = 0; ix < conn->qp.sq.size; ix++) {\n\t\tbuf = conn->qp.sq.bufs[ix];\n\t\tif (!buf)\n\t\t\tcontinue;\n\t\tconn->qp.sq.bufs[ix] = NULL;\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\tif (!buf->complete)\n\t\t\tcontinue;\n\t\tbuf->complete(conn, conn->fdev, buf, MLX5_CQE_SYNDROME_WR_FLUSH_ERR);\n\t}\n\tlist_for_each_entry_safe(buf, temp, &conn->qp.sq.backlog, list) {\n\t\tmlx5_fpga_conn_unmap_buf(conn, buf);\n\t\tif (!buf->complete)\n\t\t\tcontinue;\n\t\tbuf->complete(conn, conn->fdev, buf, MLX5_CQE_SYNDROME_WR_FLUSH_ERR);\n\t}\n}\n\nstatic void mlx5_fpga_conn_destroy_qp(struct mlx5_fpga_conn *conn)\n{\n\tmlx5_core_destroy_qp(conn->fdev->mdev, &conn->qp.mqp);\n\tmlx5_fpga_conn_free_recv_bufs(conn);\n\tmlx5_fpga_conn_flush_send_bufs(conn);\n\tkvfree(conn->qp.sq.bufs);\n\tkvfree(conn->qp.rq.bufs);\n\tmlx5_wq_destroy(&conn->qp.wq_ctrl);\n}\n\nstatic inline int mlx5_fpga_conn_reset_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_core_dev *mdev = conn->fdev->mdev;\n\n\tmlx5_fpga_dbg(conn->fdev, \"Modifying QP %u to RST\\n\", conn->qp.mqp.qpn);\n\n\treturn mlx5_core_qp_modify(mdev, MLX5_CMD_OP_2RST_QP, 0, NULL,\n\t\t\t\t   &conn->qp.mqp);\n}\n\nstatic inline int mlx5_fpga_conn_init_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc = NULL;\n\tint err;\n\n\tmlx5_fpga_dbg(conn->fdev, \"Modifying QP %u to INIT\\n\", conn->qp.mqp.qpn);\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_RC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index, MLX5_FPGA_PKEY_INDEX);\n\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, MLX5_FPGA_PORT_NUM);\n\tMLX5_SET(qpc, qpc, pd, conn->fdev->conn_res.pdn);\n\tMLX5_SET(qpc, qpc, cqn_snd, conn->cq.mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_rcv, conn->cq.mcq.cqn);\n\tMLX5_SET64(qpc, qpc, dbr_addr, conn->qp.wq_ctrl.db.dma);\n\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_RST2INIT_QP, 0, qpc,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err) {\n\t\tmlx5_fpga_warn(fdev, \"qp_modify RST2INIT failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic inline int mlx5_fpga_conn_rtr_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc = NULL;\n\tint err;\n\n\tmlx5_fpga_dbg(conn->fdev, \"QP RTR\\n\");\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpc, qpc, mtu, MLX5_QPC_MTU_1K_BYTES);\n\tMLX5_SET(qpc, qpc, log_msg_max, (u8)MLX5_CAP_GEN(mdev, log_max_msg));\n\tMLX5_SET(qpc, qpc, remote_qpn, conn->fpga_qpn);\n\tMLX5_SET(qpc, qpc, next_rcv_psn,\n\t\t MLX5_GET(fpga_qpc, conn->fpga_qpc, next_send_psn));\n\tMLX5_SET(qpc, qpc, primary_address_path.pkey_index, MLX5_FPGA_PKEY_INDEX);\n\tMLX5_SET(qpc, qpc, primary_address_path.vhca_port_num, MLX5_FPGA_PORT_NUM);\n\tether_addr_copy(MLX5_ADDR_OF(qpc, qpc, primary_address_path.rmac_47_32),\n\t\t\tMLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, fpga_mac_47_32));\n\tMLX5_SET(qpc, qpc, primary_address_path.udp_sport,\n\t\t MLX5_CAP_ROCE(mdev, r_roce_min_src_udp_port));\n\tMLX5_SET(qpc, qpc, primary_address_path.src_addr_index,\n\t\t conn->qp.sgid_index);\n\tMLX5_SET(qpc, qpc, primary_address_path.hop_limit, 0);\n\tmemcpy(MLX5_ADDR_OF(qpc, qpc, primary_address_path.rgid_rip),\n\t       MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, fpga_ip),\n\t       MLX5_FLD_SZ_BYTES(qpc, primary_address_path.rgid_rip));\n\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_INIT2RTR_QP, 0, qpc,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err) {\n\t\tmlx5_fpga_warn(fdev, \"qp_modify RST2INIT failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic inline int mlx5_fpga_conn_rts_qp(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 *qpc = NULL;\n\tu32 opt_mask;\n\tint err;\n\n\tmlx5_fpga_dbg(conn->fdev, \"QP RTS\\n\");\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET(qpc, qpc, log_ack_req_freq, 8);\n\tMLX5_SET(qpc, qpc, min_rnr_nak, 0x12);\n\tMLX5_SET(qpc, qpc, primary_address_path.ack_timeout, 0x12); /* ~1.07s */\n\tMLX5_SET(qpc, qpc, next_send_psn,\n\t\t MLX5_GET(fpga_qpc, conn->fpga_qpc, next_rcv_psn));\n\tMLX5_SET(qpc, qpc, retry_count, 7);\n\tMLX5_SET(qpc, qpc, rnr_retry, 7); /* Infinite retry if RNR NACK */\n\n\topt_mask = MLX5_QP_OPTPAR_RNR_TIMEOUT;\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_RTR2RTS_QP, opt_mask, qpc,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err) {\n\t\tmlx5_fpga_warn(fdev, \"qp_modify RST2INIT failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic int mlx5_fpga_conn_connect(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tint err;\n\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_ACTIVE);\n\terr = mlx5_fpga_modify_qp(conn->fdev->mdev, conn->fpga_qpn,\n\t\t\t\t  MLX5_FPGA_QPC_STATE, &conn->fpga_qpc);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to activate FPGA RC QP: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = mlx5_fpga_conn_reset_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state to reset\\n\");\n\t\tgoto err_fpga_qp;\n\t}\n\n\terr = mlx5_fpga_conn_init_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to modify QP from RESET to INIT\\n\");\n\t\tgoto err_fpga_qp;\n\t}\n\tconn->qp.active = true;\n\n\twhile (!mlx5_fpga_conn_post_recv_buf(conn))\n\t\t;\n\n\terr = mlx5_fpga_conn_rtr_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state from INIT to RTR\\n\");\n\t\tgoto err_recv_bufs;\n\t}\n\n\terr = mlx5_fpga_conn_rts_qp(conn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to change QP state from RTR to RTS\\n\");\n\t\tgoto err_recv_bufs;\n\t}\n\tgoto out;\n\nerr_recv_bufs:\n\tmlx5_fpga_conn_free_recv_bufs(conn);\nerr_fpga_qp:\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_INIT);\n\tif (mlx5_fpga_modify_qp(conn->fdev->mdev, conn->fpga_qpn,\n\t\t\t\tMLX5_FPGA_QPC_STATE, &conn->fpga_qpc))\n\t\tmlx5_fpga_err(fdev, \"Failed to revert FPGA QP to INIT\\n\");\nout:\n\treturn err;\n}\n\nstruct mlx5_fpga_conn *mlx5_fpga_conn_create(struct mlx5_fpga_device *fdev,\n\t\t\t\t\t     struct mlx5_fpga_conn_attr *attr,\n\t\t\t\t\t     enum mlx5_ifc_fpga_qp_type qp_type)\n{\n\tstruct mlx5_fpga_conn *ret, *conn;\n\tu8 *remote_mac, *remote_ip;\n\tint err;\n\n\tif (!attr->recv_cb)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconn->fdev = fdev;\n\tINIT_LIST_HEAD(&conn->qp.sq.backlog);\n\n\tspin_lock_init(&conn->qp.sq.lock);\n\n\tconn->recv_cb = attr->recv_cb;\n\tconn->cb_arg = attr->cb_arg;\n\n\tremote_mac = MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, remote_mac_47_32);\n\terr = mlx5_query_mac_address(fdev->mdev, remote_mac);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to query local MAC: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err;\n\t}\n\n\t/* Build Modified EUI-64 IPv6 address from the MAC address */\n\tremote_ip = MLX5_ADDR_OF(fpga_qpc, conn->fpga_qpc, remote_ip);\n\tremote_ip[0] = 0xfe;\n\tremote_ip[1] = 0x80;\n\taddrconf_addr_eui48(&remote_ip[8], remote_mac);\n\n\terr = mlx5_core_reserved_gid_alloc(fdev->mdev, &conn->qp.sgid_index);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to allocate SGID: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err;\n\t}\n\n\terr = mlx5_core_roce_gid_set(fdev->mdev, conn->qp.sgid_index,\n\t\t\t\t     MLX5_ROCE_VERSION_2,\n\t\t\t\t     MLX5_ROCE_L3_TYPE_IPV6,\n\t\t\t\t     remote_ip, remote_mac, true, 0,\n\t\t\t\t     MLX5_FPGA_PORT_NUM);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to set SGID: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_rsvd_gid;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Reserved SGID index %u\\n\", conn->qp.sgid_index);\n\n\t/* Allow for one cqe per rx/tx wqe, plus one cqe for the next wqe,\n\t * created during processing of the cqe\n\t */\n\terr = mlx5_fpga_conn_create_cq(conn,\n\t\t\t\t       (attr->tx_size + attr->rx_size) * 2);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create CQ: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_gid;\n\t}\n\n\tmlx5_fpga_conn_arm_cq(conn);\n\n\terr = mlx5_fpga_conn_create_qp(conn, attr->tx_size, attr->rx_size);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create QP: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_cq;\n\t}\n\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, state, MLX5_FPGA_QPC_STATE_INIT);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, qp_type, qp_type);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, st, MLX5_FPGA_QPC_ST_RC);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, ether_type, ETH_P_8021Q);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, vid, 0);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, next_rcv_psn, 1);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, next_send_psn, 0);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, pkey, MLX5_FPGA_PKEY);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, remote_qpn, conn->qp.mqp.qpn);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, rnr_retry, 7);\n\tMLX5_SET(fpga_qpc, conn->fpga_qpc, retry_count, 7);\n\n\terr = mlx5_fpga_create_qp(fdev->mdev, &conn->fpga_qpc,\n\t\t\t\t  &conn->fpga_qpn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to create FPGA RC QP: %d\\n\", err);\n\t\tret = ERR_PTR(err);\n\t\tgoto err_qp;\n\t}\n\n\terr = mlx5_fpga_conn_connect(conn);\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto err_conn;\n\t}\n\n\tmlx5_fpga_dbg(fdev, \"FPGA QPN is %u\\n\", conn->fpga_qpn);\n\tret = conn;\n\tgoto out;\n\nerr_conn:\n\tmlx5_fpga_destroy_qp(conn->fdev->mdev, conn->fpga_qpn);\nerr_qp:\n\tmlx5_fpga_conn_destroy_qp(conn);\nerr_cq:\n\tmlx5_fpga_conn_destroy_cq(conn);\nerr_gid:\n\tmlx5_core_roce_gid_set(fdev->mdev, conn->qp.sgid_index, 0, 0, NULL,\n\t\t\t       NULL, false, 0, MLX5_FPGA_PORT_NUM);\nerr_rsvd_gid:\n\tmlx5_core_reserved_gid_free(fdev->mdev, conn->qp.sgid_index);\nerr:\n\tkfree(conn);\nout:\n\treturn ret;\n}\n\nvoid mlx5_fpga_conn_destroy(struct mlx5_fpga_conn *conn)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tint err = 0;\n\n\tconn->qp.active = false;\n\ttasklet_disable(&conn->cq.tasklet);\n\tsynchronize_irq(conn->cq.mcq.irqn);\n\n\tmlx5_fpga_destroy_qp(conn->fdev->mdev, conn->fpga_qpn);\n\terr = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_2ERR_QP, 0, NULL,\n\t\t\t\t  &conn->qp.mqp);\n\tif (err)\n\t\tmlx5_fpga_warn(fdev, \"qp_modify 2ERR failed: %d\\n\", err);\n\tmlx5_fpga_conn_destroy_qp(conn);\n\tmlx5_fpga_conn_destroy_cq(conn);\n\n\tmlx5_core_roce_gid_set(conn->fdev->mdev, conn->qp.sgid_index, 0, 0,\n\t\t\t       NULL, NULL, false, 0, MLX5_FPGA_PORT_NUM);\n\tmlx5_core_reserved_gid_free(conn->fdev->mdev, conn->qp.sgid_index);\n\tkfree(conn);\n}\n\nint mlx5_fpga_conn_device_init(struct mlx5_fpga_device *fdev)\n{\n\tint err;\n\n\terr = mlx5_nic_vport_enable_roce(fdev->mdev);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to enable RoCE: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfdev->conn_res.uar = mlx5_get_uars_page(fdev->mdev);\n\tif (IS_ERR(fdev->conn_res.uar)) {\n\t\terr = PTR_ERR(fdev->conn_res.uar);\n\t\tmlx5_fpga_err(fdev, \"get_uars_page failed, %d\\n\", err);\n\t\tgoto err_roce;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Allocated UAR index %u\\n\",\n\t\t      fdev->conn_res.uar->index);\n\n\terr = mlx5_core_alloc_pd(fdev->mdev, &fdev->conn_res.pdn);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"alloc pd failed, %d\\n\", err);\n\t\tgoto err_uar;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Allocated PD %u\\n\", fdev->conn_res.pdn);\n\n\terr = mlx5_fpga_conn_create_mkey(fdev->mdev, fdev->conn_res.pdn,\n\t\t\t\t\t &fdev->conn_res.mkey);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"create mkey failed, %d\\n\", err);\n\t\tgoto err_dealloc_pd;\n\t}\n\tmlx5_fpga_dbg(fdev, \"Created mkey 0x%x\\n\", fdev->conn_res.mkey.key);\n\n\treturn 0;\n\nerr_dealloc_pd:\n\tmlx5_core_dealloc_pd(fdev->mdev, fdev->conn_res.pdn);\nerr_uar:\n\tmlx5_put_uars_page(fdev->mdev, fdev->conn_res.uar);\nerr_roce:\n\tmlx5_nic_vport_disable_roce(fdev->mdev);\nout:\n\treturn err;\n}\n\nvoid mlx5_fpga_conn_device_cleanup(struct mlx5_fpga_device *fdev)\n{\n\tmlx5_core_destroy_mkey(fdev->mdev, &fdev->conn_res.mkey);\n\tmlx5_core_dealloc_pd(fdev->mdev, fdev->conn_res.pdn);\n\tmlx5_put_uars_page(fdev->mdev, fdev->conn_res.uar);\n\tmlx5_nic_vport_disable_roce(fdev->mdev);\n}\n"], "filenames": ["drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c"], "buggy_code_start_loc": [467], "buggy_code_end_loc": [468], "fixing_code_start_loc": [467], "fixing_code_end_loc": [471], "type": "CWE-401", "message": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7.", "other": {"cve": {"id": "CVE-2019-19045", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.357", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n mlx5_fpga_conn_create_cq() en el archivo drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n mlx5_vector2eqn(), tambi\u00e9n se conoce como CID-c8c2a057fdc7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.11", "matchCriteriaId": "AFBC7FC6-5284-45A6-AEF0-98EE91D9A0A5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39"}}