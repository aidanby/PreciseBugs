{"buggy_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 cervinko, idalin, SiphonSquirrel, ouzklcn, akushsky,\n#                            OzzieIsaacs, bodybybuddha, jkrehm, matthazinski, janeczku\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport io\nimport mimetypes\nimport re\nimport shutil\nimport socket\nimport unicodedata\nfrom datetime import datetime, timedelta\nfrom tempfile import gettempdir\nfrom urllib.parse import urlparse\nimport requests\n\nfrom babel.dates import format_datetime\nfrom babel.units import format_unit\nfrom flask import send_from_directory, make_response, redirect, abort, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user\nfrom sqlalchemy.sql.expression import true, false, and_, text, func\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash\nfrom markupsafe import escape\nfrom urllib.parse import quote\n\ntry:\n    import unidecode\n    use_unidecode = True\nexcept ImportError:\n    use_unidecode = False\n\nfrom . import calibre_db, cli\nfrom .tasks.convert import TaskConvert\nfrom . import logger, config, get_locale, db, ub, kobo_sync_status\nfrom . import gdriveutils as gd\nfrom .constants import STATIC_DIR as _STATIC_DIR\nfrom .subproc_wrapper import process_wait\nfrom .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS\nfrom .tasks.mail import TaskEmail\n\nlog = logger.create()\n\ntry:\n    from wand.image import Image\n    from wand.exceptions import MissingDelegateError, BlobError\n    use_IM = True\nexcept (ImportError, RuntimeError) as e:\n    log.debug('Cannot import Image, generating covers from non jpg files will not work: %s', e)\n    use_IM = False\n    MissingDelegateError = BaseException\n\n\n# Convert existing book entry to new format\ndef convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book.id, old_book_format)\n    file_path = os.path.join(calibrepath, book.path, data.name)\n    if not data:\n        error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)\n        log.error(\"convert_book_format: %s\", error_message)\n        return error_message\n    if config.config_use_google_drive:\n        if not gd.getFileFromEbooksFolder(book.path, data.name + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    else:\n        if not os.path.exists(file_path + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    # read settings and append converter task to queue\n    if kindle_mail:\n        settings = config.get_mail_settings()\n        settings['subject'] = _('Send to Kindle')  # pretranslate Subject for e-mail\n        settings['body'] = _(u'This e-mail has been sent via Calibre-Web.')\n    else:\n        settings = dict()\n    link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))  # prevent xss\n    txt = u\"{} -> {}: {}\".format(\n           old_book_format.upper(),\n           new_book_format.upper(),\n           link)\n    settings['old_book_format'] = old_book_format\n    settings['new_book_format'] = new_book_format\n    WorkerThread.add(user_id, TaskConvert(file_path, book.id, txt, settings, kindle_mail, user_id))\n    return None\n\n\ndef send_test_mail(kindle_mail, user_name):\n    WorkerThread.add(user_name, TaskEmail(_(u'Calibre-Web test e-mail'), None, None,\n                     config.get_mail_settings(), kindle_mail, _(u\"Test e-mail\"),\n                                          _(u'This e-mail has been sent via Calibre-Web.')))\n    return\n\n\n# Send registration email or password reset email, depending on parameter resend (False means welcome email)\ndef send_registration_mail(e_mail, user_name, default_password, resend=False):\n    txt = \"Hello %s!\\r\\n\" % user_name\n    if not resend:\n        txt += \"Your new account at Calibre-Web has been created. Thanks for joining us!\\r\\n\"\n    txt += \"Please log in to your account using the following informations:\\r\\n\"\n    txt += \"User name: %s\\r\\n\" % user_name\n    txt += \"Password: %s\\r\\n\" % default_password\n    txt += \"Don't forget to change your password after first login.\\r\\n\"\n    txt += \"Sincerely\\r\\n\\r\\n\"\n    txt += \"Your Calibre-Web team\"\n    WorkerThread.add(None, TaskEmail(\n        subject=_(u'Get Started with Calibre-Web'),\n        filepath=None,\n        attachment=None,\n        settings=config.get_mail_settings(),\n        recipient=e_mail,\n        taskMessage=_(u\"Registration e-mail for user: %(name)s\", name=user_name),\n        text=txt\n    ))\n    return\n\n\ndef check_send_to_kindle_with_converter(formats):\n    bookformats = list()\n    if 'EPUB' in formats and 'MOBI' not in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 1,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Epub',\n                                      format='Mobi')})\n    if 'AZW3' in formats and not 'MOBI' in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 2,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Azw3',\n                                      format='Mobi')})\n    return bookformats\n\n\ndef check_send_to_kindle(entry):\n    \"\"\"\n        returns all available book formats for sending to Kindle\n    \"\"\"\n    formats = list()\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.uncompressed_size < config.mail_size:\n                formats.append(ele.format)\n        if 'MOBI' in formats:\n            bookformats.append({'format': 'Mobi',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Mobi')})\n        if 'PDF' in formats:\n            bookformats.append({'format': 'Pdf',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Pdf')})\n        if 'AZW' in formats:\n            bookformats.append({'format': 'Azw',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Azw')})\n        if config.config_converterpath:\n            bookformats.extend(check_send_to_kindle_with_converter(formats))\n        return bookformats\n    else:\n        log.error(u'Cannot find book entry %d', entry.id)\n        return None\n\n\n# Check if a reader is existing for any of the book formats, if not, return empty list, otherwise return\n# list with supported formats\ndef check_read_formats(entry):\n    EXTENSIONS_READER = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.format.upper() in EXTENSIONS_READER:\n                bookformats.append(ele.format.lower())\n    return bookformats\n\n\n# Files are processed in the following order/priority:\n# 1: If Mobi file is existing, it's directly send to kindle email,\n# 2: If Epub file is existing, it's converted and send to kindle email,\n# 3: If Pdf file is existing, it's directly send to kindle email\ndef send_mail(book_id, book_format, convert, kindle_mail, calibrepath, user_id):\n    \"\"\"Send email with attachments\"\"\"\n    book = calibre_db.get_book(book_id)\n\n    if convert == 1:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'epub', book_format.lower(), user_id, kindle_mail)\n    if convert == 2:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'azw3', book_format.lower(), user_id, kindle_mail)\n\n    for entry in iter(book.data):\n        if entry.format.upper() == book_format.upper():\n            converted_file_name = entry.name + '.' + book_format.lower()\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(book.title))\n            EmailText = _(u\"%(book)s send to Kindle\", book=link)\n            WorkerThread.add(user_id, TaskEmail(_(u\"Send to Kindle\"), book.path, converted_file_name,\n                             config.get_mail_settings(), kindle_mail,\n                             EmailText, _(u'This e-mail has been sent via Calibre-Web.')))\n            return\n    return _(u\"The requested file could not be read. Maybe wrong permissions?\")\n\n\ndef get_valid_filename(value, replace_whitespace=True, chars=128):\n    \"\"\"\n    Returns the given string converted to a string that can be used for a clean\n    filename. Limits num characters to 128 max.\n    \"\"\"\n    if value[-1:] == u'.':\n        value = value[:-1]+u'_'\n    value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')\n    if use_unidecode:\n        if config.config_unicode_filename:\n            value = (unidecode.unidecode(value))\n    else:\n        value = value.replace(u'\u00a7', u'SS')\n        value = value.replace(u'\u00df', u'ss')\n        value = unicodedata.normalize('NFKD', value)\n        re_slugify = re.compile(r'[\\W\\s-]', re.UNICODE)\n        value = re_slugify.sub('', value)\n    if replace_whitespace:\n        #  *+:\\\"/<>? are replaced by _\n        value = re.sub(r'[*+:\\\\\\\"/<>?]+', u'_', value, flags=re.U)\n        # pipe has to be replaced with comma\n        value = re.sub(r'[|]+', u',', value, flags=re.U)\n    value = value[:chars].strip()\n    if not value:\n        raise ValueError(\"Filename cannot be empty\")\n    return value\n\n\ndef split_authors(values):\n    authors_list = []\n    for value in values:\n        authors = re.split('[&;]', value)\n        for author in authors:\n            commas = author.count(',')\n            if commas == 1:\n                author_split = author.split(',')\n                authors_list.append(author_split[1].strip() + ' ' + author_split[0].strip())\n            elif commas > 1:\n                authors_list.extend([x.strip() for x in author.split(',')])\n            else:\n                authors_list.append(author.strip())\n    return authors_list\n\n\ndef get_sorted_author(value):\n    try:\n        if ',' not in value:\n            regexes = [r\"^(JR|SR)\\.?$\", r\"^I{1,3}\\.?$\", r\"^IV\\.?$\"]\n            combined = \"(\" + \")|(\".join(regexes) + \")\"\n            value = value.split(\" \")\n            if re.match(combined, value[-1].upper()):\n                if len(value) > 1:\n                    value2 = value[-2] + \", \" + \" \".join(value[:-2]) + \" \" + value[-1]\n                else:\n                    value2 = value[0]\n            elif len(value) == 1:\n                value2 = value[0]\n            else:\n                value2 = value[-1] + \", \" + \" \".join(value[:-1])\n        else:\n            value2 = value\n    except Exception as ex:\n        log.error(\"Sorting author %s failed: %s\", value, ex)\n        if isinstance(list, value2):\n            value2 = value[0]\n        else:\n            value2 = value\n    return value2\n\ndef edit_book_read_status(book_id, read_status=None):\n    if not config.config_read_column:\n        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),\n                                                         ub.ReadBook.book_id == book_id)).first()\n        if book:\n            if read_status is None:\n                if book.read_status == ub.ReadBook.STATUS_FINISHED:\n                    book.read_status = ub.ReadBook.STATUS_UNREAD\n                else:\n                    book.read_status = ub.ReadBook.STATUS_FINISHED\n            else:\n                book.read_status = ub.ReadBook.STATUS_FINISHED if read_status else ub.ReadBook.STATUS_UNREAD\n        else:\n            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)\n            readBook.read_status = ub.ReadBook.STATUS_FINISHED\n            book = readBook\n        if not book.kobo_reading_state:\n            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)\n            kobo_reading_state.current_bookmark = ub.KoboBookmark()\n            kobo_reading_state.statistics = ub.KoboStatistics()\n            book.kobo_reading_state = kobo_reading_state\n        ub.session.merge(book)\n        ub.session_commit(\"Book {} readbit toggled\".format(book_id))\n    else:\n        try:\n            calibre_db.update_title_sort(config)\n            book = calibre_db.get_filtered_book(book_id)\n            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))\n            if len(read_status):\n                if read_status is None:\n                    read_status[0].value = not read_status[0].value\n                else:\n                    read_status[0].value = read_status is True\n                calibre_db.session.commit()\n            else:\n                cc_class = db.cc_classes[config.config_read_column]\n                new_cc = cc_class(value=read_status or 1, book=book_id)\n                calibre_db.session.add(new_cc)\n                calibre_db.session.commit()\n        except (KeyError, AttributeError):\n            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column)\n        except (OperationalError, InvalidRequestError) as e:\n            calibre_db.session.rollback()\n            log.error(u\"Read status could not set: {}\".format(e))\n            return \"Read status could not set: {}\".format(e), 400\n    return \"\"\n\n# Deletes a book fro the local filestorage, returns True if deleting is successfull, otherwise false\ndef delete_book_file(book, calibrepath, book_format=None):\n    # check that path is 2 elements deep, check that target path has no subfolders\n    if book.path.count('/') == 1:\n        path = os.path.join(calibrepath, book.path)\n        if book_format:\n            for file in os.listdir(path):\n                if file.upper().endswith(\".\"+book_format):\n                    os.remove(os.path.join(path, file))\n            return True, None\n        else:\n            if os.path.isdir(path):\n                try:\n                    for root, folders, files in os.walk(path):\n                        for f in files:\n                            os.unlink(os.path.join(root, f))\n                        if len(folders):\n                            log.warning(\"Deleting book {} failed, path {} has subfolders: {}\".format(book.id,\n                                        book.path, folders))\n                            return True, _(\"Deleting bookfolder for book %(id)s failed, path has subfolders: %(path)s\",\n                                           id=book.id,\n                                           path=book.path)\n                    shutil.rmtree(path)\n                except (IOError, OSError) as e:\n                    log.error(\"Deleting book %s failed: %s\", book.id, e)\n                    return False, _(\"Deleting book %(id)s failed: %(message)s\", id=book.id, message=e)\n                authorpath = os.path.join(calibrepath, os.path.split(book.path)[0])\n                if not os.listdir(authorpath):\n                    try:\n                        shutil.rmtree(authorpath)\n                    except (IOError, OSError) as e:\n                        log.error(\"Deleting authorpath for book %s failed: %s\", book.id, e)\n                return True, None\n\n    log.error(\"Deleting book %s from database only, book path in database not valid: %s\",\n              book.id, book.path)\n    return True, _(\"Deleting book %(id)s from database only, book path in database not valid: %(path)s\",\n                   id=book.id,\n                   path=book.path)\n\n\ndef clean_author_database(renamed_author, calibre_path=\"\", local_book=None, gdrive=None):\n    valid_filename_authors = [get_valid_filename(r, chars=96) for r in renamed_author]\n    for r in renamed_author:\n        if local_book:\n            all_books = [local_book]\n        else:\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == r)).all()\n        for book in all_books:\n            book_author_path = book.path.split('/')[0]\n            if book_author_path in valid_filename_authors or local_book:\n                new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n                all_new_authordir = get_valid_filename(new_author.name, chars=96)\n                all_titledir = book.path.split('/')[1]\n                all_new_path = os.path.join(calibre_path, all_new_authordir, all_titledir)\n                all_new_name = get_valid_filename(book.title, chars=42) + ' - ' \\\n                               + get_valid_filename(new_author.name, chars=42)\n                # change location in database to new author/title path\n                book.path = os.path.join(all_new_authordir, all_titledir).replace('\\\\', '/')\n                for file_format in book.data:\n                    if not gdrive:\n                        shutil.move(os.path.normcase(os.path.join(all_new_path,\n                                                                  file_format.name + '.' + file_format.format.lower())),\n                            os.path.normcase(os.path.join(all_new_path,\n                                                          all_new_name + '.' + file_format.format.lower())))\n                    else:\n                        gFile = gd.getFileFromEbooksFolder(all_new_path,\n                                                           file_format.name + '.' + file_format.format.lower())\n                        if gFile:\n                            gd.moveGdriveFileRemote(gFile, all_new_name + u'.' + file_format.format.lower())\n                            gd.updateDatabaseOnEdit(gFile['id'], all_new_name + u'.' + file_format.format.lower())\n                        else:\n                            log.error(\"File {} not found on gdrive\"\n                                      .format(all_new_path, file_format.name + '.' + file_format.format.lower()))\n                    file_format.name = all_new_name\n\n\ndef rename_all_authors(first_author, renamed_author, calibre_path=\"\", localbook=None, gdrive=False):\n    # Create new_author_dir from parameter or from database\n    # Create new title_dir from database and add id\n    if first_author:\n        new_authordir = get_valid_filename(first_author, chars=96)\n        for r in renamed_author:\n            new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n            old_author_dir = get_valid_filename(r, chars=96)\n            new_author_rename_dir = get_valid_filename(new_author.name, chars=96)\n            if gdrive:\n                gFile = gd.getFileFromEbooksFolder(None, old_author_dir)\n                if gFile:\n                    gd.moveGdriveFolderRemote(gFile, new_author_rename_dir)\n            else:\n                if os.path.isdir(os.path.join(calibre_path, old_author_dir)):\n                    try:\n                        old_author_path = os.path.join(calibre_path, old_author_dir)\n                        new_author_path = os.path.join(calibre_path, new_author_rename_dir)\n                        shutil.move(os.path.normcase(old_author_path), os.path.normcase(new_author_path))\n                    except (OSError) as ex:\n                        log.error(\"Rename author from: %s to %s: %s\", old_author_path, new_author_path, ex)\n                        log.debug(ex, exc_info=True)\n                        return _(\"Rename author from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                                 src=old_author_path, dest=new_author_path, error=str(ex))\n    else:\n        new_authordir = get_valid_filename(localbook.authors[0].name, chars=96)\n    return new_authordir\n\n# Moves files in file storage during author/title rename, or from temp dir to file storage\ndef update_dir_structure_file(book_id, calibre_path, first_author, original_filepath, db_filename, renamed_author):\n    # get book database entry from id, if original path overwrite source with original_filepath\n    localbook = calibre_db.get_book(book_id)\n    if original_filepath:\n        path = original_filepath\n    else:\n        path = os.path.join(calibre_path, localbook.path)\n\n    # Create (current) authordir and titledir from database\n    authordir = localbook.path.split('/')[0]\n    titledir = localbook.path.split('/')[1]\n\n    # Create new_authordir from parameter or from database\n    # Create new titledir from database and add id\n    new_authordir = rename_all_authors(first_author, renamed_author, calibre_path, localbook)\n    if first_author:\n        if first_author.lower() in [r.lower() for r in renamed_author]:\n            if os.path.isdir(os.path.join(calibre_path, new_authordir)):\n                path = os.path.join(calibre_path, new_authordir, titledir)\n\n    new_titledir = get_valid_filename(localbook.title, chars=96) + \" (\" + str(book_id) + \")\"\n\n    if titledir != new_titledir or authordir != new_authordir or original_filepath:\n        error = move_files_on_change(calibre_path,\n                                     new_authordir,\n                                     new_titledir,\n                                     localbook,\n                                     db_filename,\n                                     original_filepath,\n                                     path)\n        if error:\n            return error\n\n    # Rename all files from old names to new names\n    return rename_files_on_change(first_author, renamed_author, localbook, original_filepath, path, calibre_path)\n\n\ndef upload_new_file_gdrive(book_id, first_author, renamed_author, title, title_dir, original_filepath, filename_ext):\n    error = False\n    book = calibre_db.get_book(book_id)\n    file_name = get_valid_filename(title, chars=42) + ' - ' + \\\n                get_valid_filename(first_author, chars=42) + \\\n                filename_ext\n    rename_all_authors(first_author, renamed_author, gdrive=True)\n    gdrive_path = os.path.join(get_valid_filename(first_author, chars=96),\n                               title_dir + \" (\" + str(book_id) + \")\")\n    book.path = gdrive_path.replace(\"\\\\\", \"/\")\n    gd.uploadFileToEbooksFolder(os.path.join(gdrive_path, file_name).replace(\"\\\\\", \"/\"), original_filepath)\n    error |= rename_files_on_change(first_author, renamed_author, localbook=book, gdrive=True)\n    return error\n\n\ndef update_dir_structure_gdrive(book_id, first_author, renamed_author):\n    error = False\n    book = calibre_db.get_book(book_id)\n\n    authordir = book.path.split('/')[0]\n    titledir = book.path.split('/')[1]\n    new_authordir = rename_all_authors(first_author, renamed_author, gdrive=True)\n    new_titledir = get_valid_filename(book.title, chars=96) + u\" (\" + str(book_id) + u\")\"\n\n    if titledir != new_titledir:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), titledir)\n        if gFile:\n            gd.moveGdriveFileRemote(gFile, new_titledir)\n            book.path = book.path.split('/')[0] + u'/' + new_titledir\n            gd.updateDatabaseOnEdit(gFile['id'], book.path)     # only child folder affected\n        else:\n            error = _(u'File %(file)s not found on Google Drive', file=book.path)  # file not found\n\n    if authordir != new_authordir and authordir not in renamed_author:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), new_titledir)\n        if gFile:\n            gd.moveGdriveFolderRemote(gFile, new_authordir)\n            book.path = new_authordir + u'/' + book.path.split('/')[1]\n            gd.updateDatabaseOnEdit(gFile['id'], book.path)\n        else:\n            error = _(u'File %(file)s not found on Google Drive', file=authordir)  # file not found\n\n    # change location in database to new author/title path\n    book.path = os.path.join(new_authordir, new_titledir).replace('\\\\', '/')\n    error |= rename_files_on_change(first_author, renamed_author, book, gdrive=True)\n    return error\n\n\ndef move_files_on_change(calibre_path, new_authordir, new_titledir, localbook, db_filename, original_filepath, path):\n    new_path = os.path.join(calibre_path, new_authordir, new_titledir)\n    new_name = get_valid_filename(localbook.title, chars=96) + ' - ' + new_authordir\n    try:\n        if original_filepath:\n            if not os.path.isdir(new_path):\n                os.makedirs(new_path)\n            shutil.move(os.path.normcase(original_filepath), os.path.normcase(os.path.join(new_path, db_filename)))\n            log.debug(\"Moving title: %s to %s/%s\", original_filepath, new_path, new_name)\n        else:\n            # Check new path is not valid path\n            if not os.path.exists(new_path):\n                # move original path to new path\n                log.debug(\"Moving title: %s to %s\", path, new_path)\n                shutil.move(os.path.normcase(path), os.path.normcase(new_path))\n            else: # path is valid copy only files to new location (merge)\n                log.info(\"Moving title: %s into existing: %s\", path, new_path)\n                # Take all files and subfolder from old path (strange command)\n                for dir_name, __, file_list in os.walk(path):\n                    for file in file_list:\n                        shutil.move(os.path.normcase(os.path.join(dir_name, file)),\n                                        os.path.normcase(os.path.join(new_path + dir_name[len(path):], file)))\n        # change location in database to new author/title path\n        localbook.path = os.path.join(new_authordir, new_titledir).replace('\\\\','/')\n    except OSError as ex:\n        log.error(\"Rename title from: %s to %s: %s\", path, new_path, ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Rename title from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                 src=path, dest=new_path, error=str(ex))\n    return False\n\n\ndef rename_files_on_change(first_author,\n                           renamed_author,\n                           localbook,\n                           orignal_filepath=\"\",\n                           path=\"\",\n                           calibre_path=\"\",\n                           gdrive=False):\n    # Rename all files from old names to new names\n    try:\n        clean_author_database(renamed_author, calibre_path, gdrive=gdrive)\n        if first_author and first_author not in renamed_author:\n            clean_author_database([first_author], calibre_path, localbook, gdrive)\n        if not gdrive and not renamed_author and not orignal_filepath and len(os.listdir(os.path.dirname(path))) == 0:\n            shutil.rmtree(os.path.dirname(path))\n    except (OSError, FileNotFoundError) as ex:\n        log.error(\"Error in rename file in path %s\", ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Error in rename file in path: %(error)s\", error=str(ex))\n    return False\n\n\ndef delete_book_gdrive(book, book_format):\n    error = None\n    if book_format:\n        name = ''\n        for entry in book.data:\n            if entry.format.upper() == book_format:\n                name = entry.name + '.' + book_format\n        gFile = gd.getFileFromEbooksFolder(book.path, name)\n    else:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), book.path.split('/')[1])\n    if gFile:\n        gd.deleteDatabaseEntry(gFile['id'])\n        gFile.Trash()\n    else:\n        error = _(u'Book path %(path)s not found on Google Drive', path=book.path)  # file not found\n\n    return error is None, error\n\n\ndef reset_password(user_id):\n    existing_user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n    if not existing_user:\n        return 0, None\n    if not config.get_mail_server_configured():\n        return 2, None\n    try:\n        password = generate_random_password()\n        existing_user.password = generate_password_hash(password)\n        ub.session.commit()\n        send_registration_mail(existing_user.email, existing_user.name, password, True)\n        return 1, existing_user.name\n    except Exception:\n        ub.session.rollback()\n        return 0, None\n\n\ndef generate_random_password():\n    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%&*()?\"\n    passlen = 8\n    return \"\".join(s[c % len(s)] for c in os.urandom(passlen))\n\n\ndef uniq(inpt):\n    output = []\n    inpt = [ \" \".join(inp.split()) for inp in inpt]\n    for x in inpt:\n        if x not in output:\n            output.append(x)\n    return output\n\ndef check_email(email):\n    email = valid_email(email)\n    if ub.session.query(ub.User).filter(func.lower(ub.User.email) == email.lower()).first():\n        log.error(u\"Found an existing account for this e-mail address\")\n        raise Exception(_(u\"Found an existing account for this e-mail address\"))\n    return email\n\n\ndef check_username(username):\n    username = username.strip()\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).scalar():\n        log.error(u\"This username is already taken\")\n        raise Exception (_(u\"This username is already taken\"))\n    return username\n\n\ndef valid_email(email):\n    email = email.strip()\n    # Regex according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#validation\n    if not re.search(r\"^[\\w.!#$%&'*+\\\\/=?^_`{|}~-]+@[\\w](?:[\\w-]{0,61}[\\w])?(?:\\.[\\w](?:[\\w-]{0,61}[\\w])?)*$\",\n                     email):\n        log.error(u\"Invalid e-mail address format\")\n        raise Exception(_(u\"Invalid e-mail address format\"))\n    return email\n\n# ################################# External interface #################################\n\n\ndef update_dir_structure(book_id,\n                         calibre_path,\n                         first_author=None,     # change author of book to this author\n                         original_filepath=None,\n                         db_filename=None,\n                         renamed_author=None):\n    renamed_author = renamed_author or []\n    if config.config_use_google_drive:\n        return update_dir_structure_gdrive(book_id, first_author, renamed_author)\n    else:\n        return update_dir_structure_file(book_id,\n                                         calibre_path,\n                                         first_author,\n                                         original_filepath,\n                                         db_filename, renamed_author)\n\n\ndef delete_book(book, calibrepath, book_format):\n    if config.config_use_google_drive:\n        return delete_book_gdrive(book, book_format)\n    else:\n        return delete_book_file(book, calibrepath, book_format)\n\n\ndef get_cover_on_failure(use_generic_cover):\n    if use_generic_cover:\n        return send_from_directory(_STATIC_DIR, \"generic_cover.jpg\")\n    else:\n        return None\n\n\ndef get_book_cover(book_id):\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    return get_book_cover_internal(book, use_generic_cover_on_failure=True)\n\n\ndef get_book_cover_with_uuid(book_uuid,\n                             use_generic_cover_on_failure=True):\n    book = calibre_db.get_book_by_uuid(book_uuid)\n    return get_book_cover_internal(book, use_generic_cover_on_failure)\n\n\ndef get_book_cover_internal(book, use_generic_cover_on_failure):\n    if book and book.has_cover:\n        if config.config_use_google_drive:\n            try:\n                if not gd.is_gdrive_ready():\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n                path = gd.get_cover_via_gdrive(book.path)\n                if path:\n                    return redirect(path)\n                else:\n                    log.error('%s/cover.jpg not found on Google Drive', book.path)\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n            except Exception as ex:\n                log.debug_or_exception(ex)\n                return get_cover_on_failure(use_generic_cover_on_failure)\n        else:\n            cover_file_path = os.path.join(config.config_calibre_dir, book.path)\n            if os.path.isfile(os.path.join(cover_file_path, \"cover.jpg\")):\n                return send_from_directory(cover_file_path, \"cover.jpg\")\n            else:\n                return get_cover_on_failure(use_generic_cover_on_failure)\n    else:\n        return get_cover_on_failure(use_generic_cover_on_failure)\n\n\n# saves book cover from url\ndef save_cover_from_url(url, book_path):\n    try:\n        if not cli.allow_localhost:\n            # 127.0.x.x, localhost, [::1], [::ffff:7f00:1]\n            ip = socket.getaddrinfo(urlparse(url).hostname, 0)[0][4][0]\n            if ip.startswith(\"127.\") or ip.startswith('::ffff:7f') or ip == \"::1\":\n                log.error(\"Localhost was accessed for cover upload\")\n                return False, _(\"You are not allowed to access localhost for cover uploads\")\n        img = requests.get(url, timeout=(10, 200))      # ToDo: Error Handling\n        img.raise_for_status()\n        return save_cover(img, book_path)\n    except (socket.gaierror,\n            requests.exceptions.HTTPError,\n            requests.exceptions.ConnectionError,\n            requests.exceptions.Timeout) as ex:\n        log.info(u'Cover Download Error %s', ex)\n        return False, _(\"Error Downloading Cover\")\n    except MissingDelegateError as ex:\n        log.info(u'File Format Error %s', ex)\n        return False, _(\"Cover Format Error\")\n\n\ndef save_cover_from_filestorage(filepath, saved_filename, img):\n    # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n    if not os.path.exists(filepath):\n        try:\n            os.makedirs(filepath)\n        except OSError:\n            log.error(u\"Failed to create path for cover\")\n            return False, _(u\"Failed to create path for cover\")\n    try:\n        # upload of jgp file without wand\n        if isinstance(img, requests.Response):\n            with open(os.path.join(filepath, saved_filename), 'wb') as f:\n                f.write(img.content)\n        else:\n            if hasattr(img, \"metadata\"):\n                # upload of jpg/png... via url\n                img.save(filename=os.path.join(filepath, saved_filename))\n                img.close()\n            else:\n                # upload of jpg/png... from hdd\n                img.save(os.path.join(filepath, saved_filename))\n    except (IOError, OSError):\n        log.error(u\"Cover-file is not a valid image file, or could not be stored\")\n        return False, _(u\"Cover-file is not a valid image file, or could not be stored\")\n    return True, None\n\n\n# saves book cover to gdrive or locally\ndef save_cover(img, book_path):\n    content_type = img.headers.get('content-type')\n\n    if use_IM:\n        if content_type not in ('image/jpeg', 'image/png', 'image/webp', 'image/bmp'):\n            log.error(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n        # convert to jpg because calibre only supports jpg\n        if content_type != 'image/jpg':\n            try:\n                if hasattr(img, 'stream'):\n                    imgc = Image(blob=img.stream)\n                else:\n                    imgc = Image(blob=io.BytesIO(img.content))\n                imgc.format = 'jpeg'\n                imgc.transform_colorspace(\"rgb\")\n                img = imgc\n            except (BlobError, MissingDelegateError):\n                log.error(\"Invalid cover file content\")\n                return False, _(\"Invalid cover file content\")\n    else:\n        if content_type not in 'image/jpeg':\n            log.error(\"Only jpg/jpeg files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg files are supported as coverfile\")\n\n    if config.config_use_google_drive:\n        tmp_dir = os.path.join(gettempdir(), 'calibre_web')\n\n        if not os.path.isdir(tmp_dir):\n            os.mkdir(tmp_dir)\n        ret, message = save_cover_from_filestorage(tmp_dir, \"uploaded_cover.jpg\", img)\n        if ret is True:\n            gd.uploadFileToEbooksFolder(os.path.join(book_path, 'cover.jpg').replace(\"\\\\\",\"/\"),\n                                        os.path.join(tmp_dir, \"uploaded_cover.jpg\"))\n            log.info(\"Cover is saved on Google Drive\")\n            return True, None\n        else:\n            return False, message\n    else:\n        return save_cover_from_filestorage(os.path.join(config.config_calibre_dir, book_path), \"cover.jpg\", img)\n\n\ndef do_download_file(book, book_format, client, data, headers):\n    if config.config_use_google_drive:\n        #startTime = time.time()\n        df = gd.getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n        #log.debug('%s', time.time() - startTime)\n        if df:\n            return gd.do_gdrive_download(df, headers)\n        else:\n            abort(404)\n    else:\n        filename = os.path.join(config.config_calibre_dir, book.path)\n        if not os.path.isfile(os.path.join(filename, data.name + \".\" + book_format)):\n            # ToDo: improve error handling\n            log.error('File not found: %s', os.path.join(filename, data.name + \".\" + book_format))\n\n        if client == \"kobo\" and book_format == \"kepub\":\n            headers[\"Content-Disposition\"] = headers[\"Content-Disposition\"].replace(\".kepub\", \".kepub.epub\")\n\n        response = make_response(send_from_directory(filename, data.name + \".\" + book_format))\n        # ToDo Check headers parameter\n        for element in headers:\n            response.headers[element[0]] = element[1]\n        log.info('Downloading file: {}'.format(os.path.join(filename, data.name + \".\" + book_format)))\n        return response\n\n##################################\n\n\ndef check_unrar(unrarLocation):\n    if not unrarLocation:\n        return\n\n    if not os.path.exists(unrarLocation):\n        return _('Unrar binary file not found')\n\n    try:\n        unrarLocation = [unrarLocation]\n        value = process_wait(unrarLocation, pattern='UNRAR (.*) freeware')\n        if value:\n            version = value.group(1)\n            log.debug(\"unrar version %s\", version)\n\n    except (OSError, UnicodeDecodeError) as err:\n        log.debug_or_exception(err)\n        return _('Error excecuting UnRar')\n\n\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    if isinstance(obj, timedelta):\n        return {\n            '__type__': 'timedelta',\n            'days': obj.days,\n            'seconds': obj.seconds,\n            'microseconds': obj.microseconds,\n        }\n    raise TypeError(\"Type %s not serializable\" % type(obj))\n\n\n# helper function for displaying the runtime of tasks\ndef format_runtime(runtime):\n    retVal = \"\"\n    if runtime.days:\n        retVal = format_unit(runtime.days, 'duration-day', length=\"long\", locale=get_locale()) + ', '\n    mins, seconds = divmod(runtime.seconds, 60)\n    hours, minutes = divmod(mins, 60)\n    # ToDo: locale.number_symbols._data['timeSeparator'] -> localize time separator ?\n    if hours:\n        retVal += '{:d}:{:02d}:{:02d}s'.format(hours, minutes, seconds)\n    elif minutes:\n        retVal += '{:2d}:{:02d}s'.format(minutes, seconds)\n    else:\n        retVal += '{:2d}s'.format(seconds)\n    return retVal\n\n\n# helper function to apply localize status information in tasklist entries\ndef render_task_status(tasklist):\n    renderedtasklist = list()\n    for __, user, __, task in tasklist:\n        if user == current_user.name or current_user.role_admin():\n            ret = {}\n            if task.start_time:\n                ret['starttime'] = format_datetime(task.start_time, format='short', locale=get_locale())\n                ret['runtime'] = format_runtime(task.runtime)\n\n            # localize the task status\n            if isinstance(task.stat, int):\n                if task.stat == STAT_WAITING:\n                    ret['status'] = _(u'Waiting')\n                elif task.stat == STAT_FAIL:\n                    ret['status'] = _(u'Failed')\n                elif task.stat == STAT_STARTED:\n                    ret['status'] = _(u'Started')\n                elif task.stat == STAT_FINISH_SUCCESS:\n                    ret['status'] = _(u'Finished')\n                else:\n                    ret['status'] = _(u'Unknown Status')\n\n            ret['taskMessage'] = \"{}: {}\".format(_(task.name), task.message)\n            ret['progress'] = \"{} %\".format(int(task.progress * 100))\n            ret['user'] = escape(user)  # prevent xss\n            renderedtasklist.append(ret)\n\n    return renderedtasklist\n\n\ndef tags_filters():\n    negtags_list = current_user.list_denied_tags()\n    postags_list = current_user.list_allowed_tags()\n    neg_content_tags_filter = false() if negtags_list == [''] else db.Tags.name.in_(negtags_list)\n    pos_content_tags_filter = true() if postags_list == [''] else db.Tags.name.in_(postags_list)\n    return and_(pos_content_tags_filter, ~neg_content_tags_filter)\n\n\n# checks if domain is in database (including wildcards)\n# example SELECT * FROM @TABLE WHERE  'abcdefg' LIKE Name;\n# from https://code.luasoftware.com/tutorials/flask/execute-raw-sql-in-flask-sqlalchemy/\n# in all calls the email address is checked for validity\ndef check_valid_domain(domain_text):\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 1);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    if not len(result):\n        return False\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 0);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    return not len(result)\n\n\ndef get_cc_columns(filter_config_custom_read=False):\n    tmpcc = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    cc = []\n    r = None\n    if config.config_columns_to_ignore:\n        r = re.compile(config.config_columns_to_ignore)\n\n    for col in tmpcc:\n        if filter_config_custom_read and config.config_read_column and config.config_read_column == col.id:\n            continue\n        if r and r.match(col.name):\n            continue\n        cc.append(col)\n\n    return cc\n\n\ndef get_download_link(book_id, book_format, client):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if book:\n        data1 = calibre_db.get_book_format(book.id, book_format.upper())\n    else:\n        log.error(\"Book id {} not found for downloading\".format(book_id))\n        abort(404)\n    if data1:\n        # collect downloaded books only for registered user and not for anonymous user\n        if current_user.is_authenticated:\n            ub.update_download(book_id, int(current_user.id))\n        file_name = book.title\n        if len(book.authors) > 0:\n            file_name = file_name + ' - ' + book.authors[0].name\n        file_name = get_valid_filename(file_name, replace_whitespace=False)\n        headers = Headers()\n        headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n        headers[\"Content-Disposition\"] = \"attachment; filename=%s.%s; filename*=UTF-8''%s.%s\" % (\n            quote(file_name.encode('utf-8')), book_format, quote(file_name.encode('utf-8')), book_format)\n        return do_download_file(book, book_format, client, data1, headers)\n    else:\n        abort(404)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 cervinko, idalin, SiphonSquirrel, ouzklcn, akushsky,\n#                            OzzieIsaacs, bodybybuddha, jkrehm, matthazinski, janeczku\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport io\nimport mimetypes\nimport re\nimport shutil\nimport socket\nimport unicodedata\nfrom datetime import datetime, timedelta\nfrom tempfile import gettempdir\nfrom urllib.parse import urlparse\nimport requests\n\nfrom babel.dates import format_datetime\nfrom babel.units import format_unit\nfrom flask import send_from_directory, make_response, redirect, abort, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user\nfrom sqlalchemy.sql.expression import true, false, and_, text, func\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash\nfrom markupsafe import escape\nfrom urllib.parse import quote\n\ntry:\n    import unidecode\n    use_unidecode = True\nexcept ImportError:\n    use_unidecode = False\n\nfrom . import calibre_db, cli\nfrom .tasks.convert import TaskConvert\nfrom . import logger, config, get_locale, db, ub, kobo_sync_status\nfrom . import gdriveutils as gd\nfrom .constants import STATIC_DIR as _STATIC_DIR\nfrom .subproc_wrapper import process_wait\nfrom .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS\nfrom .tasks.mail import TaskEmail\n\nlog = logger.create()\n\ntry:\n    from wand.image import Image\n    from wand.exceptions import MissingDelegateError, BlobError\n    use_IM = True\nexcept (ImportError, RuntimeError) as e:\n    log.debug('Cannot import Image, generating covers from non jpg files will not work: %s', e)\n    use_IM = False\n    MissingDelegateError = BaseException\n\n\n# Convert existing book entry to new format\ndef convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book.id, old_book_format)\n    file_path = os.path.join(calibrepath, book.path, data.name)\n    if not data:\n        error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)\n        log.error(\"convert_book_format: %s\", error_message)\n        return error_message\n    if config.config_use_google_drive:\n        if not gd.getFileFromEbooksFolder(book.path, data.name + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    else:\n        if not os.path.exists(file_path + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    # read settings and append converter task to queue\n    if kindle_mail:\n        settings = config.get_mail_settings()\n        settings['subject'] = _('Send to Kindle')  # pretranslate Subject for e-mail\n        settings['body'] = _(u'This e-mail has been sent via Calibre-Web.')\n    else:\n        settings = dict()\n    link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))  # prevent xss\n    txt = u\"{} -> {}: {}\".format(\n           old_book_format.upper(),\n           new_book_format.upper(),\n           link)\n    settings['old_book_format'] = old_book_format\n    settings['new_book_format'] = new_book_format\n    WorkerThread.add(user_id, TaskConvert(file_path, book.id, txt, settings, kindle_mail, user_id))\n    return None\n\n\ndef send_test_mail(kindle_mail, user_name):\n    WorkerThread.add(user_name, TaskEmail(_(u'Calibre-Web test e-mail'), None, None,\n                     config.get_mail_settings(), kindle_mail, _(u\"Test e-mail\"),\n                                          _(u'This e-mail has been sent via Calibre-Web.')))\n    return\n\n\n# Send registration email or password reset email, depending on parameter resend (False means welcome email)\ndef send_registration_mail(e_mail, user_name, default_password, resend=False):\n    txt = \"Hello %s!\\r\\n\" % user_name\n    if not resend:\n        txt += \"Your new account at Calibre-Web has been created. Thanks for joining us!\\r\\n\"\n    txt += \"Please log in to your account using the following informations:\\r\\n\"\n    txt += \"User name: %s\\r\\n\" % user_name\n    txt += \"Password: %s\\r\\n\" % default_password\n    txt += \"Don't forget to change your password after first login.\\r\\n\"\n    txt += \"Sincerely\\r\\n\\r\\n\"\n    txt += \"Your Calibre-Web team\"\n    WorkerThread.add(None, TaskEmail(\n        subject=_(u'Get Started with Calibre-Web'),\n        filepath=None,\n        attachment=None,\n        settings=config.get_mail_settings(),\n        recipient=e_mail,\n        taskMessage=_(u\"Registration e-mail for user: %(name)s\", name=user_name),\n        text=txt\n    ))\n    return\n\n\ndef check_send_to_kindle_with_converter(formats):\n    bookformats = list()\n    if 'EPUB' in formats and 'MOBI' not in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 1,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Epub',\n                                      format='Mobi')})\n    if 'AZW3' in formats and not 'MOBI' in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 2,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Azw3',\n                                      format='Mobi')})\n    return bookformats\n\n\ndef check_send_to_kindle(entry):\n    \"\"\"\n        returns all available book formats for sending to Kindle\n    \"\"\"\n    formats = list()\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.uncompressed_size < config.mail_size:\n                formats.append(ele.format)\n        if 'MOBI' in formats:\n            bookformats.append({'format': 'Mobi',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Mobi')})\n        if 'PDF' in formats:\n            bookformats.append({'format': 'Pdf',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Pdf')})\n        if 'AZW' in formats:\n            bookformats.append({'format': 'Azw',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Azw')})\n        if config.config_converterpath:\n            bookformats.extend(check_send_to_kindle_with_converter(formats))\n        return bookformats\n    else:\n        log.error(u'Cannot find book entry %d', entry.id)\n        return None\n\n\n# Check if a reader is existing for any of the book formats, if not, return empty list, otherwise return\n# list with supported formats\ndef check_read_formats(entry):\n    EXTENSIONS_READER = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.format.upper() in EXTENSIONS_READER:\n                bookformats.append(ele.format.lower())\n    return bookformats\n\n\n# Files are processed in the following order/priority:\n# 1: If Mobi file is existing, it's directly send to kindle email,\n# 2: If Epub file is existing, it's converted and send to kindle email,\n# 3: If Pdf file is existing, it's directly send to kindle email\ndef send_mail(book_id, book_format, convert, kindle_mail, calibrepath, user_id):\n    \"\"\"Send email with attachments\"\"\"\n    book = calibre_db.get_book(book_id)\n\n    if convert == 1:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'epub', book_format.lower(), user_id, kindle_mail)\n    if convert == 2:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'azw3', book_format.lower(), user_id, kindle_mail)\n\n    for entry in iter(book.data):\n        if entry.format.upper() == book_format.upper():\n            converted_file_name = entry.name + '.' + book_format.lower()\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(book.title))\n            EmailText = _(u\"%(book)s send to Kindle\", book=link)\n            WorkerThread.add(user_id, TaskEmail(_(u\"Send to Kindle\"), book.path, converted_file_name,\n                             config.get_mail_settings(), kindle_mail,\n                             EmailText, _(u'This e-mail has been sent via Calibre-Web.')))\n            return\n    return _(u\"The requested file could not be read. Maybe wrong permissions?\")\n\n\ndef get_valid_filename(value, replace_whitespace=True, chars=128):\n    \"\"\"\n    Returns the given string converted to a string that can be used for a clean\n    filename. Limits num characters to 128 max.\n    \"\"\"\n    if value[-1:] == u'.':\n        value = value[:-1]+u'_'\n    value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')\n    if use_unidecode:\n        if config.config_unicode_filename:\n            value = (unidecode.unidecode(value))\n    else:\n        value = value.replace(u'\u00a7', u'SS')\n        value = value.replace(u'\u00df', u'ss')\n        value = unicodedata.normalize('NFKD', value)\n        re_slugify = re.compile(r'[\\W\\s-]', re.UNICODE)\n        value = re_slugify.sub('', value)\n    if replace_whitespace:\n        #  *+:\\\"/<>? are replaced by _\n        value = re.sub(r'[*+:\\\\\\\"/<>?]+', u'_', value, flags=re.U)\n        # pipe has to be replaced with comma\n        value = re.sub(r'[|]+', u',', value, flags=re.U)\n    value = value[:chars].strip()\n    if not value:\n        raise ValueError(\"Filename cannot be empty\")\n    return value\n\n\ndef split_authors(values):\n    authors_list = []\n    for value in values:\n        authors = re.split('[&;]', value)\n        for author in authors:\n            commas = author.count(',')\n            if commas == 1:\n                author_split = author.split(',')\n                authors_list.append(author_split[1].strip() + ' ' + author_split[0].strip())\n            elif commas > 1:\n                authors_list.extend([x.strip() for x in author.split(',')])\n            else:\n                authors_list.append(author.strip())\n    return authors_list\n\n\ndef get_sorted_author(value):\n    try:\n        if ',' not in value:\n            regexes = [r\"^(JR|SR)\\.?$\", r\"^I{1,3}\\.?$\", r\"^IV\\.?$\"]\n            combined = \"(\" + \")|(\".join(regexes) + \")\"\n            value = value.split(\" \")\n            if re.match(combined, value[-1].upper()):\n                if len(value) > 1:\n                    value2 = value[-2] + \", \" + \" \".join(value[:-2]) + \" \" + value[-1]\n                else:\n                    value2 = value[0]\n            elif len(value) == 1:\n                value2 = value[0]\n            else:\n                value2 = value[-1] + \", \" + \" \".join(value[:-1])\n        else:\n            value2 = value\n    except Exception as ex:\n        log.error(\"Sorting author %s failed: %s\", value, ex)\n        if isinstance(list, value2):\n            value2 = value[0]\n        else:\n            value2 = value\n    return value2\n\ndef edit_book_read_status(book_id, read_status=None):\n    if not config.config_read_column:\n        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),\n                                                         ub.ReadBook.book_id == book_id)).first()\n        if book:\n            if read_status is None:\n                if book.read_status == ub.ReadBook.STATUS_FINISHED:\n                    book.read_status = ub.ReadBook.STATUS_UNREAD\n                else:\n                    book.read_status = ub.ReadBook.STATUS_FINISHED\n            else:\n                book.read_status = ub.ReadBook.STATUS_FINISHED if read_status else ub.ReadBook.STATUS_UNREAD\n        else:\n            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)\n            readBook.read_status = ub.ReadBook.STATUS_FINISHED\n            book = readBook\n        if not book.kobo_reading_state:\n            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)\n            kobo_reading_state.current_bookmark = ub.KoboBookmark()\n            kobo_reading_state.statistics = ub.KoboStatistics()\n            book.kobo_reading_state = kobo_reading_state\n        ub.session.merge(book)\n        ub.session_commit(\"Book {} readbit toggled\".format(book_id))\n    else:\n        try:\n            calibre_db.update_title_sort(config)\n            book = calibre_db.get_filtered_book(book_id)\n            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))\n            if len(read_status):\n                if read_status is None:\n                    read_status[0].value = not read_status[0].value\n                else:\n                    read_status[0].value = read_status is True\n                calibre_db.session.commit()\n            else:\n                cc_class = db.cc_classes[config.config_read_column]\n                new_cc = cc_class(value=read_status or 1, book=book_id)\n                calibre_db.session.add(new_cc)\n                calibre_db.session.commit()\n        except (KeyError, AttributeError):\n            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column)\n        except (OperationalError, InvalidRequestError) as e:\n            calibre_db.session.rollback()\n            log.error(u\"Read status could not set: {}\".format(e))\n            return \"Read status could not set: {}\".format(e), 400\n    return \"\"\n\n# Deletes a book fro the local filestorage, returns True if deleting is successfull, otherwise false\ndef delete_book_file(book, calibrepath, book_format=None):\n    # check that path is 2 elements deep, check that target path has no subfolders\n    if book.path.count('/') == 1:\n        path = os.path.join(calibrepath, book.path)\n        if book_format:\n            for file in os.listdir(path):\n                if file.upper().endswith(\".\"+book_format):\n                    os.remove(os.path.join(path, file))\n            return True, None\n        else:\n            if os.path.isdir(path):\n                try:\n                    for root, folders, files in os.walk(path):\n                        for f in files:\n                            os.unlink(os.path.join(root, f))\n                        if len(folders):\n                            log.warning(\"Deleting book {} failed, path {} has subfolders: {}\".format(book.id,\n                                        book.path, folders))\n                            return True, _(\"Deleting bookfolder for book %(id)s failed, path has subfolders: %(path)s\",\n                                           id=book.id,\n                                           path=book.path)\n                    shutil.rmtree(path)\n                except (IOError, OSError) as e:\n                    log.error(\"Deleting book %s failed: %s\", book.id, e)\n                    return False, _(\"Deleting book %(id)s failed: %(message)s\", id=book.id, message=e)\n                authorpath = os.path.join(calibrepath, os.path.split(book.path)[0])\n                if not os.listdir(authorpath):\n                    try:\n                        shutil.rmtree(authorpath)\n                    except (IOError, OSError) as e:\n                        log.error(\"Deleting authorpath for book %s failed: %s\", book.id, e)\n                return True, None\n\n    log.error(\"Deleting book %s from database only, book path in database not valid: %s\",\n              book.id, book.path)\n    return True, _(\"Deleting book %(id)s from database only, book path in database not valid: %(path)s\",\n                   id=book.id,\n                   path=book.path)\n\n\ndef clean_author_database(renamed_author, calibre_path=\"\", local_book=None, gdrive=None):\n    valid_filename_authors = [get_valid_filename(r, chars=96) for r in renamed_author]\n    for r in renamed_author:\n        if local_book:\n            all_books = [local_book]\n        else:\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == r)).all()\n        for book in all_books:\n            book_author_path = book.path.split('/')[0]\n            if book_author_path in valid_filename_authors or local_book:\n                new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n                all_new_authordir = get_valid_filename(new_author.name, chars=96)\n                all_titledir = book.path.split('/')[1]\n                all_new_path = os.path.join(calibre_path, all_new_authordir, all_titledir)\n                all_new_name = get_valid_filename(book.title, chars=42) + ' - ' \\\n                               + get_valid_filename(new_author.name, chars=42)\n                # change location in database to new author/title path\n                book.path = os.path.join(all_new_authordir, all_titledir).replace('\\\\', '/')\n                for file_format in book.data:\n                    if not gdrive:\n                        shutil.move(os.path.normcase(os.path.join(all_new_path,\n                                                                  file_format.name + '.' + file_format.format.lower())),\n                            os.path.normcase(os.path.join(all_new_path,\n                                                          all_new_name + '.' + file_format.format.lower())))\n                    else:\n                        gFile = gd.getFileFromEbooksFolder(all_new_path,\n                                                           file_format.name + '.' + file_format.format.lower())\n                        if gFile:\n                            gd.moveGdriveFileRemote(gFile, all_new_name + u'.' + file_format.format.lower())\n                            gd.updateDatabaseOnEdit(gFile['id'], all_new_name + u'.' + file_format.format.lower())\n                        else:\n                            log.error(\"File {} not found on gdrive\"\n                                      .format(all_new_path, file_format.name + '.' + file_format.format.lower()))\n                    file_format.name = all_new_name\n\n\ndef rename_all_authors(first_author, renamed_author, calibre_path=\"\", localbook=None, gdrive=False):\n    # Create new_author_dir from parameter or from database\n    # Create new title_dir from database and add id\n    if first_author:\n        new_authordir = get_valid_filename(first_author, chars=96)\n        for r in renamed_author:\n            new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n            old_author_dir = get_valid_filename(r, chars=96)\n            new_author_rename_dir = get_valid_filename(new_author.name, chars=96)\n            if gdrive:\n                gFile = gd.getFileFromEbooksFolder(None, old_author_dir)\n                if gFile:\n                    gd.moveGdriveFolderRemote(gFile, new_author_rename_dir)\n            else:\n                if os.path.isdir(os.path.join(calibre_path, old_author_dir)):\n                    try:\n                        old_author_path = os.path.join(calibre_path, old_author_dir)\n                        new_author_path = os.path.join(calibre_path, new_author_rename_dir)\n                        shutil.move(os.path.normcase(old_author_path), os.path.normcase(new_author_path))\n                    except (OSError) as ex:\n                        log.error(\"Rename author from: %s to %s: %s\", old_author_path, new_author_path, ex)\n                        log.debug(ex, exc_info=True)\n                        return _(\"Rename author from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                                 src=old_author_path, dest=new_author_path, error=str(ex))\n    else:\n        new_authordir = get_valid_filename(localbook.authors[0].name, chars=96)\n    return new_authordir\n\n# Moves files in file storage during author/title rename, or from temp dir to file storage\ndef update_dir_structure_file(book_id, calibre_path, first_author, original_filepath, db_filename, renamed_author):\n    # get book database entry from id, if original path overwrite source with original_filepath\n    localbook = calibre_db.get_book(book_id)\n    if original_filepath:\n        path = original_filepath\n    else:\n        path = os.path.join(calibre_path, localbook.path)\n\n    # Create (current) authordir and titledir from database\n    authordir = localbook.path.split('/')[0]\n    titledir = localbook.path.split('/')[1]\n\n    # Create new_authordir from parameter or from database\n    # Create new titledir from database and add id\n    new_authordir = rename_all_authors(first_author, renamed_author, calibre_path, localbook)\n    if first_author:\n        if first_author.lower() in [r.lower() for r in renamed_author]:\n            if os.path.isdir(os.path.join(calibre_path, new_authordir)):\n                path = os.path.join(calibre_path, new_authordir, titledir)\n\n    new_titledir = get_valid_filename(localbook.title, chars=96) + \" (\" + str(book_id) + \")\"\n\n    if titledir != new_titledir or authordir != new_authordir or original_filepath:\n        error = move_files_on_change(calibre_path,\n                                     new_authordir,\n                                     new_titledir,\n                                     localbook,\n                                     db_filename,\n                                     original_filepath,\n                                     path)\n        if error:\n            return error\n\n    # Rename all files from old names to new names\n    return rename_files_on_change(first_author, renamed_author, localbook, original_filepath, path, calibre_path)\n\n\ndef upload_new_file_gdrive(book_id, first_author, renamed_author, title, title_dir, original_filepath, filename_ext):\n    error = False\n    book = calibre_db.get_book(book_id)\n    file_name = get_valid_filename(title, chars=42) + ' - ' + \\\n                get_valid_filename(first_author, chars=42) + \\\n                filename_ext\n    rename_all_authors(first_author, renamed_author, gdrive=True)\n    gdrive_path = os.path.join(get_valid_filename(first_author, chars=96),\n                               title_dir + \" (\" + str(book_id) + \")\")\n    book.path = gdrive_path.replace(\"\\\\\", \"/\")\n    gd.uploadFileToEbooksFolder(os.path.join(gdrive_path, file_name).replace(\"\\\\\", \"/\"), original_filepath)\n    error |= rename_files_on_change(first_author, renamed_author, localbook=book, gdrive=True)\n    return error\n\n\ndef update_dir_structure_gdrive(book_id, first_author, renamed_author):\n    error = False\n    book = calibre_db.get_book(book_id)\n\n    authordir = book.path.split('/')[0]\n    titledir = book.path.split('/')[1]\n    new_authordir = rename_all_authors(first_author, renamed_author, gdrive=True)\n    new_titledir = get_valid_filename(book.title, chars=96) + u\" (\" + str(book_id) + u\")\"\n\n    if titledir != new_titledir:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), titledir)\n        if gFile:\n            gd.moveGdriveFileRemote(gFile, new_titledir)\n            book.path = book.path.split('/')[0] + u'/' + new_titledir\n            gd.updateDatabaseOnEdit(gFile['id'], book.path)     # only child folder affected\n        else:\n            error = _(u'File %(file)s not found on Google Drive', file=book.path)  # file not found\n\n    if authordir != new_authordir and authordir not in renamed_author:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), new_titledir)\n        if gFile:\n            gd.moveGdriveFolderRemote(gFile, new_authordir)\n            book.path = new_authordir + u'/' + book.path.split('/')[1]\n            gd.updateDatabaseOnEdit(gFile['id'], book.path)\n        else:\n            error = _(u'File %(file)s not found on Google Drive', file=authordir)  # file not found\n\n    # change location in database to new author/title path\n    book.path = os.path.join(new_authordir, new_titledir).replace('\\\\', '/')\n    error |= rename_files_on_change(first_author, renamed_author, book, gdrive=True)\n    return error\n\n\ndef move_files_on_change(calibre_path, new_authordir, new_titledir, localbook, db_filename, original_filepath, path):\n    new_path = os.path.join(calibre_path, new_authordir, new_titledir)\n    new_name = get_valid_filename(localbook.title, chars=96) + ' - ' + new_authordir\n    try:\n        if original_filepath:\n            if not os.path.isdir(new_path):\n                os.makedirs(new_path)\n            shutil.move(os.path.normcase(original_filepath), os.path.normcase(os.path.join(new_path, db_filename)))\n            log.debug(\"Moving title: %s to %s/%s\", original_filepath, new_path, new_name)\n        else:\n            # Check new path is not valid path\n            if not os.path.exists(new_path):\n                # move original path to new path\n                log.debug(\"Moving title: %s to %s\", path, new_path)\n                shutil.move(os.path.normcase(path), os.path.normcase(new_path))\n            else: # path is valid copy only files to new location (merge)\n                log.info(\"Moving title: %s into existing: %s\", path, new_path)\n                # Take all files and subfolder from old path (strange command)\n                for dir_name, __, file_list in os.walk(path):\n                    for file in file_list:\n                        shutil.move(os.path.normcase(os.path.join(dir_name, file)),\n                                        os.path.normcase(os.path.join(new_path + dir_name[len(path):], file)))\n        # change location in database to new author/title path\n        localbook.path = os.path.join(new_authordir, new_titledir).replace('\\\\','/')\n    except OSError as ex:\n        log.error(\"Rename title from: %s to %s: %s\", path, new_path, ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Rename title from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                 src=path, dest=new_path, error=str(ex))\n    return False\n\n\ndef rename_files_on_change(first_author,\n                           renamed_author,\n                           localbook,\n                           orignal_filepath=\"\",\n                           path=\"\",\n                           calibre_path=\"\",\n                           gdrive=False):\n    # Rename all files from old names to new names\n    try:\n        clean_author_database(renamed_author, calibre_path, gdrive=gdrive)\n        if first_author and first_author not in renamed_author:\n            clean_author_database([first_author], calibre_path, localbook, gdrive)\n        if not gdrive and not renamed_author and not orignal_filepath and len(os.listdir(os.path.dirname(path))) == 0:\n            shutil.rmtree(os.path.dirname(path))\n    except (OSError, FileNotFoundError) as ex:\n        log.error(\"Error in rename file in path %s\", ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Error in rename file in path: %(error)s\", error=str(ex))\n    return False\n\n\ndef delete_book_gdrive(book, book_format):\n    error = None\n    if book_format:\n        name = ''\n        for entry in book.data:\n            if entry.format.upper() == book_format:\n                name = entry.name + '.' + book_format\n        gFile = gd.getFileFromEbooksFolder(book.path, name)\n    else:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), book.path.split('/')[1])\n    if gFile:\n        gd.deleteDatabaseEntry(gFile['id'])\n        gFile.Trash()\n    else:\n        error = _(u'Book path %(path)s not found on Google Drive', path=book.path)  # file not found\n\n    return error is None, error\n\n\ndef reset_password(user_id):\n    existing_user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n    if not existing_user:\n        return 0, None\n    if not config.get_mail_server_configured():\n        return 2, None\n    try:\n        password = generate_random_password()\n        existing_user.password = generate_password_hash(password)\n        ub.session.commit()\n        send_registration_mail(existing_user.email, existing_user.name, password, True)\n        return 1, existing_user.name\n    except Exception:\n        ub.session.rollback()\n        return 0, None\n\n\ndef generate_random_password():\n    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%&*()?\"\n    passlen = 8\n    return \"\".join(s[c % len(s)] for c in os.urandom(passlen))\n\n\ndef uniq(inpt):\n    output = []\n    inpt = [ \" \".join(inp.split()) for inp in inpt]\n    for x in inpt:\n        if x not in output:\n            output.append(x)\n    return output\n\ndef check_email(email):\n    email = valid_email(email)\n    if ub.session.query(ub.User).filter(func.lower(ub.User.email) == email.lower()).first():\n        log.error(u\"Found an existing account for this e-mail address\")\n        raise Exception(_(u\"Found an existing account for this e-mail address\"))\n    return email\n\n\ndef check_username(username):\n    username = username.strip()\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).scalar():\n        log.error(u\"This username is already taken\")\n        raise Exception (_(u\"This username is already taken\"))\n    return username\n\n\ndef valid_email(email):\n    email = email.strip()\n    # Regex according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#validation\n    if not re.search(r\"^[\\w.!#$%&'*+\\\\/=?^_`{|}~-]+@[\\w](?:[\\w-]{0,61}[\\w])?(?:\\.[\\w](?:[\\w-]{0,61}[\\w])?)*$\",\n                     email):\n        log.error(u\"Invalid e-mail address format\")\n        raise Exception(_(u\"Invalid e-mail address format\"))\n    return email\n\n# ################################# External interface #################################\n\n\ndef update_dir_structure(book_id,\n                         calibre_path,\n                         first_author=None,     # change author of book to this author\n                         original_filepath=None,\n                         db_filename=None,\n                         renamed_author=None):\n    renamed_author = renamed_author or []\n    if config.config_use_google_drive:\n        return update_dir_structure_gdrive(book_id, first_author, renamed_author)\n    else:\n        return update_dir_structure_file(book_id,\n                                         calibre_path,\n                                         first_author,\n                                         original_filepath,\n                                         db_filename, renamed_author)\n\n\ndef delete_book(book, calibrepath, book_format):\n    if config.config_use_google_drive:\n        return delete_book_gdrive(book, book_format)\n    else:\n        return delete_book_file(book, calibrepath, book_format)\n\n\ndef get_cover_on_failure(use_generic_cover):\n    if use_generic_cover:\n        return send_from_directory(_STATIC_DIR, \"generic_cover.jpg\")\n    else:\n        return None\n\n\ndef get_book_cover(book_id):\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    return get_book_cover_internal(book, use_generic_cover_on_failure=True)\n\n\ndef get_book_cover_with_uuid(book_uuid,\n                             use_generic_cover_on_failure=True):\n    book = calibre_db.get_book_by_uuid(book_uuid)\n    return get_book_cover_internal(book, use_generic_cover_on_failure)\n\n\ndef get_book_cover_internal(book, use_generic_cover_on_failure):\n    if book and book.has_cover:\n        if config.config_use_google_drive:\n            try:\n                if not gd.is_gdrive_ready():\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n                path = gd.get_cover_via_gdrive(book.path)\n                if path:\n                    return redirect(path)\n                else:\n                    log.error('%s/cover.jpg not found on Google Drive', book.path)\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n            except Exception as ex:\n                log.debug_or_exception(ex)\n                return get_cover_on_failure(use_generic_cover_on_failure)\n        else:\n            cover_file_path = os.path.join(config.config_calibre_dir, book.path)\n            if os.path.isfile(os.path.join(cover_file_path, \"cover.jpg\")):\n                return send_from_directory(cover_file_path, \"cover.jpg\")\n            else:\n                return get_cover_on_failure(use_generic_cover_on_failure)\n    else:\n        return get_cover_on_failure(use_generic_cover_on_failure)\n\n\n# saves book cover from url\ndef save_cover_from_url(url, book_path):\n    try:\n        if not cli.allow_localhost:\n            # 127.0.x.x, localhost, [::1], [::ffff:7f00:1]\n            ip = socket.getaddrinfo(urlparse(url).hostname, 0)[0][4][0]\n            if ip.startswith(\"127.\") or ip.startswith('::ffff:7f') or ip == \"::1\" or ip == \"0.0.0.0\" or ip == \"::\":\n                log.error(\"Localhost was accessed for cover upload\")\n                return False, _(\"You are not allowed to access localhost for cover uploads\")\n        img = requests.get(url, timeout=(10, 200), allow_redirects=False)      # ToDo: Error Handling\n        img.raise_for_status()\n        return save_cover(img, book_path)\n    except (socket.gaierror,\n            requests.exceptions.HTTPError,\n            requests.exceptions.ConnectionError,\n            requests.exceptions.Timeout) as ex:\n        log.info(u'Cover Download Error %s', ex)\n        return False, _(\"Error Downloading Cover\")\n    except MissingDelegateError as ex:\n        log.info(u'File Format Error %s', ex)\n        return False, _(\"Cover Format Error\")\n\n\ndef save_cover_from_filestorage(filepath, saved_filename, img):\n    # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n    if not os.path.exists(filepath):\n        try:\n            os.makedirs(filepath)\n        except OSError:\n            log.error(u\"Failed to create path for cover\")\n            return False, _(u\"Failed to create path for cover\")\n    try:\n        # upload of jgp file without wand\n        if isinstance(img, requests.Response):\n            with open(os.path.join(filepath, saved_filename), 'wb') as f:\n                f.write(img.content)\n        else:\n            if hasattr(img, \"metadata\"):\n                # upload of jpg/png... via url\n                img.save(filename=os.path.join(filepath, saved_filename))\n                img.close()\n            else:\n                # upload of jpg/png... from hdd\n                img.save(os.path.join(filepath, saved_filename))\n    except (IOError, OSError):\n        log.error(u\"Cover-file is not a valid image file, or could not be stored\")\n        return False, _(u\"Cover-file is not a valid image file, or could not be stored\")\n    return True, None\n\n\n# saves book cover to gdrive or locally\ndef save_cover(img, book_path):\n    content_type = img.headers.get('content-type')\n\n    if use_IM:\n        if content_type not in ('image/jpeg', 'image/png', 'image/webp', 'image/bmp'):\n            log.error(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n        # convert to jpg because calibre only supports jpg\n        if content_type != 'image/jpg':\n            try:\n                if hasattr(img, 'stream'):\n                    imgc = Image(blob=img.stream)\n                else:\n                    imgc = Image(blob=io.BytesIO(img.content))\n                imgc.format = 'jpeg'\n                imgc.transform_colorspace(\"rgb\")\n                img = imgc\n            except (BlobError, MissingDelegateError):\n                log.error(\"Invalid cover file content\")\n                return False, _(\"Invalid cover file content\")\n    else:\n        if content_type not in 'image/jpeg':\n            log.error(\"Only jpg/jpeg files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg files are supported as coverfile\")\n\n    if config.config_use_google_drive:\n        tmp_dir = os.path.join(gettempdir(), 'calibre_web')\n\n        if not os.path.isdir(tmp_dir):\n            os.mkdir(tmp_dir)\n        ret, message = save_cover_from_filestorage(tmp_dir, \"uploaded_cover.jpg\", img)\n        if ret is True:\n            gd.uploadFileToEbooksFolder(os.path.join(book_path, 'cover.jpg').replace(\"\\\\\",\"/\"),\n                                        os.path.join(tmp_dir, \"uploaded_cover.jpg\"))\n            log.info(\"Cover is saved on Google Drive\")\n            return True, None\n        else:\n            return False, message\n    else:\n        return save_cover_from_filestorage(os.path.join(config.config_calibre_dir, book_path), \"cover.jpg\", img)\n\n\ndef do_download_file(book, book_format, client, data, headers):\n    if config.config_use_google_drive:\n        #startTime = time.time()\n        df = gd.getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n        #log.debug('%s', time.time() - startTime)\n        if df:\n            return gd.do_gdrive_download(df, headers)\n        else:\n            abort(404)\n    else:\n        filename = os.path.join(config.config_calibre_dir, book.path)\n        if not os.path.isfile(os.path.join(filename, data.name + \".\" + book_format)):\n            # ToDo: improve error handling\n            log.error('File not found: %s', os.path.join(filename, data.name + \".\" + book_format))\n\n        if client == \"kobo\" and book_format == \"kepub\":\n            headers[\"Content-Disposition\"] = headers[\"Content-Disposition\"].replace(\".kepub\", \".kepub.epub\")\n\n        response = make_response(send_from_directory(filename, data.name + \".\" + book_format))\n        # ToDo Check headers parameter\n        for element in headers:\n            response.headers[element[0]] = element[1]\n        log.info('Downloading file: {}'.format(os.path.join(filename, data.name + \".\" + book_format)))\n        return response\n\n##################################\n\n\ndef check_unrar(unrarLocation):\n    if not unrarLocation:\n        return\n\n    if not os.path.exists(unrarLocation):\n        return _('Unrar binary file not found')\n\n    try:\n        unrarLocation = [unrarLocation]\n        value = process_wait(unrarLocation, pattern='UNRAR (.*) freeware')\n        if value:\n            version = value.group(1)\n            log.debug(\"unrar version %s\", version)\n\n    except (OSError, UnicodeDecodeError) as err:\n        log.debug_or_exception(err)\n        return _('Error excecuting UnRar')\n\n\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    if isinstance(obj, timedelta):\n        return {\n            '__type__': 'timedelta',\n            'days': obj.days,\n            'seconds': obj.seconds,\n            'microseconds': obj.microseconds,\n        }\n    raise TypeError(\"Type %s not serializable\" % type(obj))\n\n\n# helper function for displaying the runtime of tasks\ndef format_runtime(runtime):\n    retVal = \"\"\n    if runtime.days:\n        retVal = format_unit(runtime.days, 'duration-day', length=\"long\", locale=get_locale()) + ', '\n    mins, seconds = divmod(runtime.seconds, 60)\n    hours, minutes = divmod(mins, 60)\n    # ToDo: locale.number_symbols._data['timeSeparator'] -> localize time separator ?\n    if hours:\n        retVal += '{:d}:{:02d}:{:02d}s'.format(hours, minutes, seconds)\n    elif minutes:\n        retVal += '{:2d}:{:02d}s'.format(minutes, seconds)\n    else:\n        retVal += '{:2d}s'.format(seconds)\n    return retVal\n\n\n# helper function to apply localize status information in tasklist entries\ndef render_task_status(tasklist):\n    renderedtasklist = list()\n    for __, user, __, task in tasklist:\n        if user == current_user.name or current_user.role_admin():\n            ret = {}\n            if task.start_time:\n                ret['starttime'] = format_datetime(task.start_time, format='short', locale=get_locale())\n                ret['runtime'] = format_runtime(task.runtime)\n\n            # localize the task status\n            if isinstance(task.stat, int):\n                if task.stat == STAT_WAITING:\n                    ret['status'] = _(u'Waiting')\n                elif task.stat == STAT_FAIL:\n                    ret['status'] = _(u'Failed')\n                elif task.stat == STAT_STARTED:\n                    ret['status'] = _(u'Started')\n                elif task.stat == STAT_FINISH_SUCCESS:\n                    ret['status'] = _(u'Finished')\n                else:\n                    ret['status'] = _(u'Unknown Status')\n\n            ret['taskMessage'] = \"{}: {}\".format(_(task.name), task.message)\n            ret['progress'] = \"{} %\".format(int(task.progress * 100))\n            ret['user'] = escape(user)  # prevent xss\n            renderedtasklist.append(ret)\n\n    return renderedtasklist\n\n\ndef tags_filters():\n    negtags_list = current_user.list_denied_tags()\n    postags_list = current_user.list_allowed_tags()\n    neg_content_tags_filter = false() if negtags_list == [''] else db.Tags.name.in_(negtags_list)\n    pos_content_tags_filter = true() if postags_list == [''] else db.Tags.name.in_(postags_list)\n    return and_(pos_content_tags_filter, ~neg_content_tags_filter)\n\n\n# checks if domain is in database (including wildcards)\n# example SELECT * FROM @TABLE WHERE  'abcdefg' LIKE Name;\n# from https://code.luasoftware.com/tutorials/flask/execute-raw-sql-in-flask-sqlalchemy/\n# in all calls the email address is checked for validity\ndef check_valid_domain(domain_text):\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 1);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    if not len(result):\n        return False\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 0);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    return not len(result)\n\n\ndef get_cc_columns(filter_config_custom_read=False):\n    tmpcc = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    cc = []\n    r = None\n    if config.config_columns_to_ignore:\n        r = re.compile(config.config_columns_to_ignore)\n\n    for col in tmpcc:\n        if filter_config_custom_read and config.config_read_column and config.config_read_column == col.id:\n            continue\n        if r and r.match(col.name):\n            continue\n        cc.append(col)\n\n    return cc\n\n\ndef get_download_link(book_id, book_format, client):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if book:\n        data1 = calibre_db.get_book_format(book.id, book_format.upper())\n    else:\n        log.error(\"Book id {} not found for downloading\".format(book_id))\n        abort(404)\n    if data1:\n        # collect downloaded books only for registered user and not for anonymous user\n        if current_user.is_authenticated:\n            ub.update_download(book_id, int(current_user.id))\n        file_name = book.title\n        if len(book.authors) > 0:\n            file_name = file_name + ' - ' + book.authors[0].name\n        file_name = get_valid_filename(file_name, replace_whitespace=False)\n        headers = Headers()\n        headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n        headers[\"Content-Disposition\"] = \"attachment; filename=%s.%s; filename*=UTF-8''%s.%s\" % (\n            quote(file_name.encode('utf-8')), book_format, quote(file_name.encode('utf-8')), book_format)\n        return do_download_file(book, book_format, client, data1, headers)\n    else:\n        abort(404)\n"], "filenames": ["cps/helper.py"], "buggy_code_start_loc": [737], "buggy_code_end_loc": [741], "fixing_code_start_loc": [737], "fixing_code_end_loc": [741], "type": "CWE-918", "message": "Server-Side Request Forgery (SSRF) in GitHub repository janeczku/calibre-web prior to 0.6.17.", "other": {"cve": {"id": "CVE-2022-0766", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-07T07:15:07.257", "lastModified": "2022-03-11T17:08:58.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Server-Side Request Forgery (SSRF) in GitHub repository janeczku/calibre-web prior to 0.6.17."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Server-Side Request Forgery (SSRF) en el repositorio de GitHub janeczku/calibre-web versiones anteriores a 0.6.17"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-web_project:calibre-web:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.17", "matchCriteriaId": "FFC250B3-EA6A-45C9-8CE4-1456B205320E"}]}]}], "references": [{"url": "https://github.com/janeczku/calibre-web/commit/965352c8d96c9eae7a6867ff76b0db137d04b0b8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7f2a5bb4-e6c7-4b6a-b8eb-face9e3add7b", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janeczku/calibre-web/commit/965352c8d96c9eae7a6867ff76b0db137d04b0b8"}}