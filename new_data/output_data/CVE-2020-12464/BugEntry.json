{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * message.c - synchronous message handling\n *\n * Released under the GPLv2 only.\n */\n\n#include <linux/acpi.h>\n#include <linux/pci.h>\t/* for scatterlist macros */\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <linux/device.h>\n#include <linux/scatterlist.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/quirks.h>\n#include <linux/usb/hcd.h>\t/* for usbcore internals */\n#include <linux/usb/of.h>\n#include <asm/byteorder.h>\n\n#include \"usb.h\"\n\nstatic void cancel_async_set_config(struct usb_device *udev);\n\nstruct api_context {\n\tstruct completion\tdone;\n\tint\t\t\tstatus;\n};\n\nstatic void usb_api_blocking_completion(struct urb *urb)\n{\n\tstruct api_context *ctx = urb->context;\n\n\tctx->status = urb->status;\n\tcomplete(&ctx->done);\n}\n\n\n/*\n * Starts urb and waits for completion or timeout. Note that this call\n * is NOT interruptible. Many device driver i/o requests should be\n * interruptible and therefore these drivers should implement their\n * own interruptible routines.\n */\nstatic int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)\n{\n\tstruct api_context ctx;\n\tunsigned long expire;\n\tint retval;\n\n\tinit_completion(&ctx.done);\n\turb->context = &ctx;\n\turb->actual_length = 0;\n\tretval = usb_submit_urb(urb, GFP_NOIO);\n\tif (unlikely(retval))\n\t\tgoto out;\n\n\texpire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;\n\tif (!wait_for_completion_timeout(&ctx.done, expire)) {\n\t\tusb_kill_urb(urb);\n\t\tretval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);\n\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"%s timed out on ep%d%s len=%u/%u\\n\",\n\t\t\tcurrent->comm,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\turb->actual_length,\n\t\t\turb->transfer_buffer_length);\n\t} else\n\t\tretval = ctx.status;\nout:\n\tif (actual_length)\n\t\t*actual_length = urb->actual_length;\n\n\tusb_free_urb(urb);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------*/\n/* returns status (negative) or length (positive) */\nstatic int usb_internal_control_msg(struct usb_device *usb_dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    struct usb_ctrlrequest *cmd,\n\t\t\t\t    void *data, int len, int timeout)\n{\n\tstruct urb *urb;\n\tint retv;\n\tint length;\n\n\turb = usb_alloc_urb(0, GFP_NOIO);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,\n\t\t\t     len, usb_api_blocking_completion, NULL);\n\n\tretv = usb_start_wait_urb(urb, timeout, &length);\n\tif (retv < 0)\n\t\treturn retv;\n\telse\n\t\treturn length;\n}\n\n/**\n * usb_control_msg - Builds a control urb, sends it off and waits for completion\n * @dev: pointer to the usb device to send the message to\n * @pipe: endpoint \"pipe\" to send the message to\n * @request: USB message request value\n * @requesttype: USB message request type value\n * @value: USB message value\n * @index: USB message index value\n * @data: pointer to the data to send\n * @size: length in bytes of the data to send\n * @timeout: time in msecs to wait for the message to complete before timing\n *\tout (if 0 the wait is forever)\n *\n * Context: !in_interrupt ()\n *\n * This function sends a simple control message to a specified endpoint and\n * waits for the message to complete, or timeout.\n *\n * Don't use this function from within an interrupt context. If you need\n * an asynchronous message, or need to send a message from within interrupt\n * context, use usb_submit_urb(). If a thread in your driver uses this call,\n * make sure your disconnect() method can wait for it to complete. Since you\n * don't have a handle on the URB used, you can't cancel the request.\n *\n * Return: If successful, the number of bytes transferred. Otherwise, a negative\n * error number.\n */\nint usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\n\t\t    __u8 requesttype, __u16 value, __u16 index, void *data,\n\t\t    __u16 size, int timeout)\n{\n\tstruct usb_ctrlrequest *dr;\n\tint ret;\n\n\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->bRequestType = requesttype;\n\tdr->bRequest = request;\n\tdr->wValue = cpu_to_le16(value);\n\tdr->wIndex = cpu_to_le16(index);\n\tdr->wLength = cpu_to_le16(size);\n\n\tret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);\n\n\t/* Linger a bit, prior to the next control message. */\n\tif (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)\n\t\tmsleep(200);\n\n\tkfree(dr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_control_msg);\n\n/**\n * usb_interrupt_msg - Builds an interrupt urb, sends it off and waits for completion\n * @usb_dev: pointer to the usb device to send the message to\n * @pipe: endpoint \"pipe\" to send the message to\n * @data: pointer to the data to send\n * @len: length in bytes of the data to send\n * @actual_length: pointer to a location to put the actual length transferred\n *\tin bytes\n * @timeout: time in msecs to wait for the message to complete before\n *\ttiming out (if 0 the wait is forever)\n *\n * Context: !in_interrupt ()\n *\n * This function sends a simple interrupt message to a specified endpoint and\n * waits for the message to complete, or timeout.\n *\n * Don't use this function from within an interrupt context. If you need\n * an asynchronous message, or need to send a message from within interrupt\n * context, use usb_submit_urb() If a thread in your driver uses this call,\n * make sure your disconnect() method can wait for it to complete. Since you\n * don't have a handle on the URB used, you can't cancel the request.\n *\n * Return:\n * If successful, 0. Otherwise a negative error number. The number of actual\n * bytes transferred will be stored in the @actual_length parameter.\n */\nint usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\t\t      void *data, int len, int *actual_length, int timeout)\n{\n\treturn usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout);\n}\nEXPORT_SYMBOL_GPL(usb_interrupt_msg);\n\n/**\n * usb_bulk_msg - Builds a bulk urb, sends it off and waits for completion\n * @usb_dev: pointer to the usb device to send the message to\n * @pipe: endpoint \"pipe\" to send the message to\n * @data: pointer to the data to send\n * @len: length in bytes of the data to send\n * @actual_length: pointer to a location to put the actual length transferred\n *\tin bytes\n * @timeout: time in msecs to wait for the message to complete before\n *\ttiming out (if 0 the wait is forever)\n *\n * Context: !in_interrupt ()\n *\n * This function sends a simple bulk message to a specified endpoint\n * and waits for the message to complete, or timeout.\n *\n * Don't use this function from within an interrupt context. If you need\n * an asynchronous message, or need to send a message from within interrupt\n * context, use usb_submit_urb() If a thread in your driver uses this call,\n * make sure your disconnect() method can wait for it to complete. Since you\n * don't have a handle on the URB used, you can't cancel the request.\n *\n * Because there is no usb_interrupt_msg() and no USBDEVFS_INTERRUPT ioctl,\n * users are forced to abuse this routine by using it to submit URBs for\n * interrupt endpoints.  We will take the liberty of creating an interrupt URB\n * (with the default interval) if the target is an interrupt endpoint.\n *\n * Return:\n * If successful, 0. Otherwise a negative error number. The number of actual\n * bytes transferred will be stored in the @actual_length parameter.\n *\n */\nint usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\t\t void *data, int len, int *actual_length, int timeout)\n{\n\tstruct urb *urb;\n\tstruct usb_host_endpoint *ep;\n\n\tep = usb_pipe_endpoint(usb_dev, pipe);\n\tif (!ep || len < 0)\n\t\treturn -EINVAL;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tif ((ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_INT) {\n\t\tpipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);\n\t\tusb_fill_int_urb(urb, usb_dev, pipe, data, len,\n\t\t\t\tusb_api_blocking_completion, NULL,\n\t\t\t\tep->desc.bInterval);\n\t} else\n\t\tusb_fill_bulk_urb(urb, usb_dev, pipe, data, len,\n\t\t\t\tusb_api_blocking_completion, NULL);\n\n\treturn usb_start_wait_urb(urb, timeout, actual_length);\n}\nEXPORT_SYMBOL_GPL(usb_bulk_msg);\n\n/*-------------------------------------------------------------------*/\n\nstatic void sg_clean(struct usb_sg_request *io)\n{\n\tif (io->urbs) {\n\t\twhile (io->entries--)\n\t\t\tusb_free_urb(io->urbs[io->entries]);\n\t\tkfree(io->urbs);\n\t\tio->urbs = NULL;\n\t}\n\tio->dev = NULL;\n}\n\nstatic void sg_complete(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_sg_request *io = urb->context;\n\tint status = urb->status;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\n\t/* In 2.5 we require hcds' endpoint queues not to progress after fault\n\t * reports, until the completion callback (this!) returns.  That lets\n\t * device driver code (like this routine) unlink queued urbs first,\n\t * if it needs to, since the HC won't work on them at all.  So it's\n\t * not possible for page N+1 to overwrite page N, and so on.\n\t *\n\t * That's only for \"hard\" faults; \"soft\" faults (unlinks) sometimes\n\t * complete before the HCD can get requests away from hardware,\n\t * though never during cleanup after a hard fault.\n\t */\n\tif (io->status\n\t\t\t&& (io->status != -ECONNRESET\n\t\t\t\t|| status != -ECONNRESET)\n\t\t\t&& urb->actual_length) {\n\t\tdev_err(io->dev->bus->controller,\n\t\t\t\"dev %s ep%d%s scatterlist error %d/%d\\n\",\n\t\t\tio->dev->devpath,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\tstatus, io->status);\n\t\t/* BUG (); */\n\t}\n\n\tif (io->status == 0 && status && status != -ECONNRESET) {\n\t\tint i, found, retval;\n\n\t\tio->status = status;\n\n\t\t/* the previous urbs, and this one, completed already.\n\t\t * unlink pending urbs so they won't rx/tx bad data.\n\t\t * careful: unlink can sometimes be synchronous...\n\t\t */\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\tfor (i = 0, found = 0; i < io->entries; i++) {\n\t\t\tif (!io->urbs[i])\n\t\t\t\tcontinue;\n\t\t\tif (found) {\n\t\t\t\tusb_block_urb(io->urbs[i]);\n\t\t\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\t\t\tif (retval != -EINPROGRESS &&\n\t\t\t\t    retval != -ENODEV &&\n\t\t\t\t    retval != -EBUSY &&\n\t\t\t\t    retval != -EIDRM)\n\t\t\t\t\tdev_err(&io->dev->dev,\n\t\t\t\t\t\t\"%s, unlink --> %d\\n\",\n\t\t\t\t\t\t__func__, retval);\n\t\t\t} else if (urb == io->urbs[i])\n\t\t\t\tfound = 1;\n\t\t}\n\t\tspin_lock_irqsave(&io->lock, flags);\n\t}\n\n\t/* on the last completion, signal usb_sg_wait() */\n\tio->bytes += urb->actual_length;\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\n\tspin_unlock_irqrestore(&io->lock, flags);\n}\n\n\n/**\n * usb_sg_init - initializes scatterlist-based bulk/interrupt I/O request\n * @io: request block being initialized.  until usb_sg_wait() returns,\n *\ttreat this as a pointer to an opaque block of memory,\n * @dev: the usb device that will send or receive the data\n * @pipe: endpoint \"pipe\" used to transfer the data\n * @period: polling rate for interrupt endpoints, in frames or\n * \t(for high speed endpoints) microframes; ignored for bulk\n * @sg: scatterlist entries\n * @nents: how many entries in the scatterlist\n * @length: how many bytes to send from the scatterlist, or zero to\n * \tsend every byte identified in the list.\n * @mem_flags: SLAB_* flags affecting memory allocations in this call\n *\n * This initializes a scatter/gather request, allocating resources such as\n * I/O mappings and urb memory (except maybe memory used by USB controller\n * drivers).\n *\n * The request must be issued using usb_sg_wait(), which waits for the I/O to\n * complete (or to be canceled) and then cleans up all resources allocated by\n * usb_sg_init().\n *\n * The request may be canceled with usb_sg_cancel(), either before or after\n * usb_sg_wait() is called.\n *\n * Return: Zero for success, else a negative errno value.\n */\nint usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,\n\t\tunsigned pipe, unsigned\tperiod, struct scatterlist *sg,\n\t\tint nents, size_t length, gfp_t mem_flags)\n{\n\tint i;\n\tint urb_flags;\n\tint use_sg;\n\n\tif (!io || !dev || !sg\n\t\t\t|| usb_pipecontrol(pipe)\n\t\t\t|| usb_pipeisoc(pipe)\n\t\t\t|| nents <= 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&io->lock);\n\tio->dev = dev;\n\tio->pipe = pipe;\n\n\tif (dev->bus->sg_tablesize > 0) {\n\t\tuse_sg = true;\n\t\tio->entries = 1;\n\t} else {\n\t\tuse_sg = false;\n\t\tio->entries = nents;\n\t}\n\n\t/* initialize all the urbs we'll use */\n\tio->urbs = kmalloc_array(io->entries, sizeof(*io->urbs), mem_flags);\n\tif (!io->urbs)\n\t\tgoto nomem;\n\n\turb_flags = URB_NO_INTERRUPT;\n\tif (usb_pipein(pipe))\n\t\turb_flags |= URB_SHORT_NOT_OK;\n\n\tfor_each_sg(sg, sg, io->entries, i) {\n\t\tstruct urb *urb;\n\t\tunsigned len;\n\n\t\turb = usb_alloc_urb(0, mem_flags);\n\t\tif (!urb) {\n\t\t\tio->entries = i;\n\t\t\tgoto nomem;\n\t\t}\n\t\tio->urbs[i] = urb;\n\n\t\turb->dev = NULL;\n\t\turb->pipe = pipe;\n\t\turb->interval = period;\n\t\turb->transfer_flags = urb_flags;\n\t\turb->complete = sg_complete;\n\t\turb->context = io;\n\t\turb->sg = sg;\n\n\t\tif (use_sg) {\n\t\t\t/* There is no single transfer buffer */\n\t\t\turb->transfer_buffer = NULL;\n\t\t\turb->num_sgs = nents;\n\n\t\t\t/* A length of zero means transfer the whole sg list */\n\t\t\tlen = length;\n\t\t\tif (len == 0) {\n\t\t\t\tstruct scatterlist\t*sg2;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\tfor_each_sg(sg, sg2, nents, j)\n\t\t\t\t\tlen += sg2->length;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Some systems can't use DMA; they use PIO instead.\n\t\t\t * For their sakes, transfer_buffer is set whenever\n\t\t\t * possible.\n\t\t\t */\n\t\t\tif (!PageHighMem(sg_page(sg)))\n\t\t\t\turb->transfer_buffer = sg_virt(sg);\n\t\t\telse\n\t\t\t\turb->transfer_buffer = NULL;\n\n\t\t\tlen = sg->length;\n\t\t\tif (length) {\n\t\t\t\tlen = min_t(size_t, len, length);\n\t\t\t\tlength -= len;\n\t\t\t\tif (length == 0)\n\t\t\t\t\tio->entries = i + 1;\n\t\t\t}\n\t\t}\n\t\turb->transfer_buffer_length = len;\n\t}\n\tio->urbs[--i]->transfer_flags &= ~URB_NO_INTERRUPT;\n\n\t/* transaction state */\n\tio->count = io->entries;\n\tio->status = 0;\n\tio->bytes = 0;\n\tinit_completion(&io->complete);\n\treturn 0;\n\nnomem:\n\tsg_clean(io);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_sg_init);\n\n/**\n * usb_sg_wait - synchronously execute scatter/gather request\n * @io: request block handle, as initialized with usb_sg_init().\n * \tsome fields become accessible when this call returns.\n * Context: !in_interrupt ()\n *\n * This function blocks until the specified I/O operation completes.  It\n * leverages the grouping of the related I/O requests to get good transfer\n * rates, by queueing the requests.  At higher speeds, such queuing can\n * significantly improve USB throughput.\n *\n * There are three kinds of completion for this function.\n *\n * (1) success, where io->status is zero.  The number of io->bytes\n *     transferred is as requested.\n * (2) error, where io->status is a negative errno value.  The number\n *     of io->bytes transferred before the error is usually less\n *     than requested, and can be nonzero.\n * (3) cancellation, a type of error with status -ECONNRESET that\n *     is initiated by usb_sg_cancel().\n *\n * When this function returns, all memory allocated through usb_sg_init() or\n * this call will have been freed.  The request block parameter may still be\n * passed to usb_sg_cancel(), or it may be freed.  It could also be\n * reinitialized and then reused.\n *\n * Data Transfer Rates:\n *\n * Bulk transfers are valid for full or high speed endpoints.\n * The best full speed data rate is 19 packets of 64 bytes each\n * per frame, or 1216 bytes per millisecond.\n * The best high speed data rate is 13 packets of 512 bytes each\n * per microframe, or 52 KBytes per millisecond.\n *\n * The reason to use interrupt transfers through this API would most likely\n * be to reserve high speed bandwidth, where up to 24 KBytes per millisecond\n * could be transferred.  That capability is less useful for low or full\n * speed interrupt endpoints, which allow at most one packet per millisecond,\n * of at most 8 or 64 bytes (respectively).\n *\n * It is not necessary to call this function to reserve bandwidth for devices\n * under an xHCI host controller, as the bandwidth is reserved when the\n * configuration or interface alt setting is selected.\n */\nvoid usb_sg_wait(struct usb_sg_request *io)\n{\n\tint i;\n\tint entries = io->entries;\n\n\t/* queue the urbs.  */\n\tspin_lock_irq(&io->lock);\n\ti = 0;\n\twhile (i < entries && !io->status) {\n\t\tint retval;\n\n\t\tio->urbs[i]->dev = io->dev;\n\t\tspin_unlock_irq(&io->lock);\n\n\t\tretval = usb_submit_urb(io->urbs[i], GFP_NOIO);\n\n\t\tswitch (retval) {\n\t\t\t/* maybe we retrying will recover */\n\t\tcase -ENXIO:\t/* hc didn't queue this one */\n\t\tcase -EAGAIN:\n\t\tcase -ENOMEM:\n\t\t\tretval = 0;\n\t\t\tyield();\n\t\t\tbreak;\n\n\t\t\t/* no error? continue immediately.\n\t\t\t *\n\t\t\t * NOTE: to work better with UHCI (4K I/O buffer may\n\t\t\t * need 3K of TDs) it may be good to limit how many\n\t\t\t * URBs are queued at once; N milliseconds?\n\t\t\t */\n\t\tcase 0:\n\t\t\t++i;\n\t\t\tcpu_relax();\n\t\t\tbreak;\n\n\t\t\t/* fail any uncompleted urbs */\n\t\tdefault:\n\t\t\tio->urbs[i]->status = retval;\n\t\t\tdev_dbg(&io->dev->dev, \"%s, submit --> %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tusb_sg_cancel(io);\n\t\t}\n\t\tspin_lock_irq(&io->lock);\n\t\tif (retval && (io->status == 0 || io->status == -ECONNRESET))\n\t\t\tio->status = retval;\n\t}\n\tio->count -= entries - i;\n\tif (io->count == 0)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irq(&io->lock);\n\n\t/* OK, yes, this could be packaged as non-blocking.\n\t * So could the submit loop above ... but it's easier to\n\t * solve neither problem than to solve both!\n\t */\n\twait_for_completion(&io->complete);\n\n\tsg_clean(io);\n}\nEXPORT_SYMBOL_GPL(usb_sg_wait);\n\n/**\n * usb_sg_cancel - stop scatter/gather i/o issued by usb_sg_wait()\n * @io: request block, initialized with usb_sg_init()\n *\n * This stops a request after it has been started by usb_sg_wait().\n * It can also prevents one initialized by usb_sg_init() from starting,\n * so that call just frees resources allocated to the request.\n */\nvoid usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_sg_cancel);\n\n/*-------------------------------------------------------------------*/\n\n/**\n * usb_get_descriptor - issues a generic GET_DESCRIPTOR request\n * @dev: the device whose descriptor is being retrieved\n * @type: the descriptor type (USB_DT_*)\n * @index: the number of the descriptor\n * @buf: where to put the descriptor\n * @size: how big is \"buf\"?\n * Context: !in_interrupt ()\n *\n * Gets a USB descriptor.  Convenience functions exist to simplify\n * getting some types of descriptors.  Use\n * usb_get_string() or usb_string() for USB_DT_STRING.\n * Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)\n * are part of the device structure.\n * In addition to a number of USB-standard descriptors, some\n * devices also use class-specific or vendor-specific descriptors.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: The number of bytes received on success, or else the status code\n * returned by the underlying usb_control_msg() call.\n */\nint usb_get_descriptor(struct usb_device *dev, unsigned char type,\n\t\t       unsigned char index, void *buf, int size)\n{\n\tint i;\n\tint result;\n\n\tmemset(buf, 0, size);\t/* Make sure we parse really received data */\n\n\tfor (i = 0; i < 3; ++i) {\n\t\t/* retry on length 0 or error; some devices are flakey */\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t(type << 8) + index, 0, buf, size,\n\t\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (result <= 0 && result != -ETIMEDOUT)\n\t\t\tcontinue;\n\t\tif (result > 1 && ((u8 *)buf)[1] != type) {\n\t\t\tresult = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_get_descriptor);\n\n/**\n * usb_get_string - gets a string descriptor\n * @dev: the device whose string descriptor is being retrieved\n * @langid: code for language chosen (from string descriptor zero)\n * @index: the number of the descriptor\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n * Context: !in_interrupt ()\n *\n * Retrieves a string, encoded using UTF-16LE (Unicode, 16 bits per character,\n * in little-endian byte order).\n * The usb_string() function will often be a convenient way to turn\n * these strings into kernel-printable form.\n *\n * Strings may be referenced in device, configuration, interface, or other\n * descriptors, and could also be used in vendor-specific ways.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: The number of bytes received on success, or else the status code\n * returned by the underlying usb_control_msg() call.\n */\nstatic int usb_get_string(struct usb_device *dev, unsigned short langid,\n\t\t\t  unsigned char index, void *buf, int size)\n{\n\tint i;\n\tint result;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\t/* retry on length 0 or stall; some devices are flakey */\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t(USB_DT_STRING << 8) + index, langid, buf, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (result == 0 || result == -EPIPE)\n\t\t\tcontinue;\n\t\tif (result > 1 && ((u8 *) buf)[1] != USB_DT_STRING) {\n\t\t\tresult = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic void usb_try_string_workarounds(unsigned char *buf, int *length)\n{\n\tint newlength, oldlength = *length;\n\n\tfor (newlength = 2; newlength + 1 < oldlength; newlength += 2)\n\t\tif (!isprint(buf[newlength]) || buf[newlength + 1])\n\t\t\tbreak;\n\n\tif (newlength > 2) {\n\t\tbuf[0] = newlength;\n\t\t*length = newlength;\n\t}\n}\n\nstatic int usb_string_sub(struct usb_device *dev, unsigned int langid,\n\t\t\t  unsigned int index, unsigned char *buf)\n{\n\tint rc;\n\n\t/* Try to read the string descriptor by asking for the maximum\n\t * possible number of bytes */\n\tif (dev->quirks & USB_QUIRK_STRING_FETCH_255)\n\t\trc = -EIO;\n\telse\n\t\trc = usb_get_string(dev, langid, index, buf, 255);\n\n\t/* If that failed try to read the descriptor length, then\n\t * ask for just that many bytes */\n\tif (rc < 2) {\n\t\trc = usb_get_string(dev, langid, index, buf, 2);\n\t\tif (rc == 2)\n\t\t\trc = usb_get_string(dev, langid, index, buf, buf[0]);\n\t}\n\n\tif (rc >= 2) {\n\t\tif (!buf[0] && !buf[1])\n\t\t\tusb_try_string_workarounds(buf, &rc);\n\n\t\t/* There might be extra junk at the end of the descriptor */\n\t\tif (buf[0] < rc)\n\t\t\trc = buf[0];\n\n\t\trc = rc - (rc & 1); /* force a multiple of two */\n\t}\n\n\tif (rc < 2)\n\t\trc = (rc < 0 ? rc : -EINVAL);\n\n\treturn rc;\n}\n\nstatic int usb_get_langid(struct usb_device *dev, unsigned char *tbuf)\n{\n\tint err;\n\n\tif (dev->have_langid)\n\t\treturn 0;\n\n\tif (dev->string_langid < 0)\n\t\treturn -EPIPE;\n\n\terr = usb_string_sub(dev, 0, 0, tbuf);\n\n\t/* If the string was reported but is malformed, default to english\n\t * (0x0409) */\n\tif (err == -ENODATA || (err > 0 && err < 4)) {\n\t\tdev->string_langid = 0x0409;\n\t\tdev->have_langid = 1;\n\t\tdev_err(&dev->dev,\n\t\t\t\"language id specifier not provided by device, defaulting to English\\n\");\n\t\treturn 0;\n\t}\n\n\t/* In case of all other errors, we assume the device is not able to\n\t * deal with strings at all. Set string_langid to -1 in order to\n\t * prevent any string to be retrieved from the device */\n\tif (err < 0) {\n\t\tdev_info(&dev->dev, \"string descriptor 0 read error: %d\\n\",\n\t\t\t\t\terr);\n\t\tdev->string_langid = -1;\n\t\treturn -EPIPE;\n\t}\n\n\t/* always use the first langid listed */\n\tdev->string_langid = tbuf[2] | (tbuf[3] << 8);\n\tdev->have_langid = 1;\n\tdev_dbg(&dev->dev, \"default language 0x%04x\\n\",\n\t\t\t\tdev->string_langid);\n\treturn 0;\n}\n\n/**\n * usb_string - returns UTF-8 version of a string descriptor\n * @dev: the device whose string descriptor is being retrieved\n * @index: the number of the descriptor\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n * Context: !in_interrupt ()\n *\n * This converts the UTF-16LE encoded strings returned by devices, from\n * usb_get_string_descriptor(), to null-terminated UTF-8 encoded ones\n * that are more usable in most kernel contexts.  Note that this function\n * chooses strings in the first language supported by the device.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: length of the string (>= 0) or usb_control_msg status (< 0).\n */\nint usb_string(struct usb_device *dev, int index, char *buf, size_t size)\n{\n\tunsigned char *tbuf;\n\tint err;\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tif (size <= 0 || !buf)\n\t\treturn -EINVAL;\n\tbuf[0] = 0;\n\tif (index <= 0 || index >= 256)\n\t\treturn -EINVAL;\n\ttbuf = kmalloc(256, GFP_NOIO);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\terr = usb_get_langid(dev, tbuf);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = usb_string_sub(dev, dev->string_langid, index, tbuf);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tsize--;\t\t/* leave room for trailing NULL char in output buffer */\n\terr = utf16s_to_utf8s((wchar_t *) &tbuf[2], (err - 2) / 2,\n\t\t\tUTF16_LITTLE_ENDIAN, buf, size);\n\tbuf[err] = 0;\n\n\tif (tbuf[1] != USB_DT_STRING)\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"wrong descriptor type %02x for string %d (\\\"%s\\\")\\n\",\n\t\t\ttbuf[1], index, buf);\n\n errout:\n\tkfree(tbuf);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(usb_string);\n\n/* one UTF-8-encoded 16-bit character has at most three bytes */\n#define MAX_USB_STRING_SIZE (127 * 3 + 1)\n\n/**\n * usb_cache_string - read a string descriptor and cache it for later use\n * @udev: the device whose string descriptor is being read\n * @index: the descriptor index\n *\n * Return: A pointer to a kmalloc'ed buffer containing the descriptor string,\n * or %NULL if the index is 0 or the string could not be read.\n */\nchar *usb_cache_string(struct usb_device *udev, int index)\n{\n\tchar *buf;\n\tchar *smallbuf = NULL;\n\tint len;\n\n\tif (index <= 0)\n\t\treturn NULL;\n\n\tbuf = kmalloc(MAX_USB_STRING_SIZE, GFP_NOIO);\n\tif (buf) {\n\t\tlen = usb_string(udev, index, buf, MAX_USB_STRING_SIZE);\n\t\tif (len > 0) {\n\t\t\tsmallbuf = kmalloc(++len, GFP_NOIO);\n\t\t\tif (!smallbuf)\n\t\t\t\treturn buf;\n\t\t\tmemcpy(smallbuf, buf, len);\n\t\t}\n\t\tkfree(buf);\n\t}\n\treturn smallbuf;\n}\n\n/*\n * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)\n * @dev: the device whose device descriptor is being updated\n * @size: how much of the descriptor to read\n * Context: !in_interrupt ()\n *\n * Updates the copy of the device descriptor stored in the device structure,\n * which dedicates space for this purpose.\n *\n * Not exported, only for use by the core.  If drivers really want to read\n * the device descriptor directly, they can call usb_get_descriptor() with\n * type = USB_DT_DEVICE and index = 0.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: The number of bytes received on success, or else the status code\n * returned by the underlying usb_control_msg() call.\n */\nint usb_get_device_descriptor(struct usb_device *dev, unsigned int size)\n{\n\tstruct usb_device_descriptor *desc;\n\tint ret;\n\n\tif (size > sizeof(*desc))\n\t\treturn -EINVAL;\n\tdesc = kmalloc(sizeof(*desc), GFP_NOIO);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);\n\tif (ret >= 0)\n\t\tmemcpy(&dev->descriptor, desc, size);\n\tkfree(desc);\n\treturn ret;\n}\n\n/*\n * usb_set_isoch_delay - informs the device of the packet transmit delay\n * @dev: the device whose delay is to be informed\n * Context: !in_interrupt()\n *\n * Since this is an optional request, we don't bother if it fails.\n */\nint usb_set_isoch_delay(struct usb_device *dev)\n{\n\t/* skip hub devices */\n\tif (dev->descriptor.bDeviceClass == USB_CLASS_HUB)\n\t\treturn 0;\n\n\t/* skip non-SS/non-SSP devices */\n\tif (dev->speed < USB_SPEED_SUPER)\n\t\treturn 0;\n\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tUSB_REQ_SET_ISOCH_DELAY,\n\t\t\tUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\t\tdev->hub_delay, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n/**\n * usb_get_status - issues a GET_STATUS call\n * @dev: the device whose status is being checked\n * @recip: USB_RECIP_*; for device, interface, or endpoint\n * @type: USB_STATUS_TYPE_*; for standard or PTM status types\n * @target: zero (for device), else interface or endpoint number\n * @data: pointer to two bytes of bitmap data\n * Context: !in_interrupt ()\n *\n * Returns device, interface, or endpoint status.  Normally only of\n * interest to see if the device is self powered, or has enabled the\n * remote wakeup facility; or whether a bulk or interrupt endpoint\n * is halted (\"stalled\").\n *\n * Bits in these status bitmaps are set using the SET_FEATURE request,\n * and cleared using the CLEAR_FEATURE request.  The usb_clear_halt()\n * function should be used to clear halt (\"stall\") status.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Returns 0 and the status value in *@data (in host byte order) on success,\n * or else the status code from the underlying usb_control_msg() call.\n */\nint usb_get_status(struct usb_device *dev, int recip, int type, int target,\n\t\tvoid *data)\n{\n\tint ret;\n\tvoid *status;\n\tint length;\n\n\tswitch (type) {\n\tcase USB_STATUS_TYPE_STANDARD:\n\t\tlength = 2;\n\t\tbreak;\n\tcase USB_STATUS_TYPE_PTM:\n\t\tif (recip != USB_RECIP_DEVICE)\n\t\t\treturn -EINVAL;\n\n\t\tlength = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstatus =  kmalloc(length, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | recip, USB_STATUS_TYPE_STANDARD,\n\t\ttarget, status, length, USB_CTRL_GET_TIMEOUT);\n\n\tswitch (ret) {\n\tcase 4:\n\t\tif (type != USB_STATUS_TYPE_PTM) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t*(u32 *) data = le32_to_cpu(*(__le32 *) status);\n\t\tret = 0;\n\t\tbreak;\n\tcase 2:\n\t\tif (type != USB_STATUS_TYPE_STANDARD) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t*(u16 *) data = le16_to_cpu(*(__le16 *) status);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t}\n\n\tkfree(status);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_get_status);\n\n/**\n * usb_clear_halt - tells device to clear endpoint halt/stall condition\n * @dev: device whose endpoint is halted\n * @pipe: endpoint \"pipe\" being cleared\n * Context: !in_interrupt ()\n *\n * This is used to clear halt conditions for bulk and interrupt endpoints,\n * as reported by URB completion status.  Endpoints that are halted are\n * sometimes referred to as being \"stalled\".  Such endpoints are unable\n * to transmit or receive data until the halt status is cleared.  Any URBs\n * queued for such an endpoint should normally be unlinked by the driver\n * before clearing the halt condition, as described in sections 5.7.5\n * and 5.8.5 of the USB 2.0 spec.\n *\n * Note that control and isochronous endpoints don't halt, although control\n * endpoints report \"protocol stall\" (for unsupported requests) using the\n * same status code used to report a true stall.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: Zero on success, or else the status code returned by the\n * underlying usb_control_msg() call.\n */\nint usb_clear_halt(struct usb_device *dev, int pipe)\n{\n\tint result;\n\tint endp = usb_pipeendpoint(pipe);\n\n\tif (usb_pipein(pipe))\n\t\tendp |= USB_DIR_IN;\n\n\t/* we don't care if it wasn't halted first. in fact some devices\n\t * (like some ibmcam model 1 units) seem to expect hosts to make\n\t * this request for iso endpoints, which can't halt!\n\t */\n\tresult = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\n\t\tUSB_ENDPOINT_HALT, endp, NULL, 0,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t/* don't un-halt or force to DATA0 except on success */\n\tif (result < 0)\n\t\treturn result;\n\n\t/* NOTE:  seems like Microsoft and Apple don't bother verifying\n\t * the clear \"took\", so some devices could lock up if you check...\n\t * such as the Hagiwara FlashGate DUAL.  So we won't bother.\n\t *\n\t * NOTE:  make sure the logic here doesn't diverge much from\n\t * the copy in usb-storage, for as long as we need two copies.\n\t */\n\n\tusb_reset_endpoint(dev, endp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_clear_halt);\n\nstatic int create_intf_ep_devs(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tif (intf->ep_devs_created || intf->unregistering)\n\t\treturn 0;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\t(void) usb_create_ep_devs(&intf->dev, &alt->endpoint[i], udev);\n\tintf->ep_devs_created = 1;\n\treturn 0;\n}\n\nstatic void remove_intf_ep_devs(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tif (!intf->ep_devs_created)\n\t\treturn;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\tusb_remove_ep_devs(&alt->endpoint[i]);\n\tintf->ep_devs_created = 0;\n}\n\n/**\n * usb_disable_endpoint -- Disable an endpoint by address\n * @dev: the device whose endpoint is being disabled\n * @epaddr: the endpoint's address.  Endpoint number for output,\n *\tendpoint number + USB_DIR_IN for input\n * @reset_hardware: flag to erase any endpoint state stored in the\n *\tcontroller hardware\n *\n * Disables the endpoint for URB submission and nukes all pending URBs.\n * If @reset_hardware is set then also deallocates hcd/hardware state\n * for the endpoint.\n */\nvoid usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,\n\t\tbool reset_hardware)\n{\n\tunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\n\tstruct usb_host_endpoint *ep;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (usb_endpoint_out(epaddr)) {\n\t\tep = dev->ep_out[epnum];\n\t\tif (reset_hardware)\n\t\t\tdev->ep_out[epnum] = NULL;\n\t} else {\n\t\tep = dev->ep_in[epnum];\n\t\tif (reset_hardware)\n\t\t\tdev->ep_in[epnum] = NULL;\n\t}\n\tif (ep) {\n\t\tep->enabled = 0;\n\t\tusb_hcd_flush_endpoint(dev, ep);\n\t\tif (reset_hardware)\n\t\t\tusb_hcd_disable_endpoint(dev, ep);\n\t}\n}\n\n/**\n * usb_reset_endpoint - Reset an endpoint's state.\n * @dev: the device whose endpoint is to be reset\n * @epaddr: the endpoint's address.  Endpoint number for output,\n *\tendpoint number + USB_DIR_IN for input\n *\n * Resets any host-side endpoint state such as the toggle bit,\n * sequence number or current window.\n */\nvoid usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr)\n{\n\tunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\n\tstruct usb_host_endpoint *ep;\n\n\tif (usb_endpoint_out(epaddr))\n\t\tep = dev->ep_out[epnum];\n\telse\n\t\tep = dev->ep_in[epnum];\n\tif (ep)\n\t\tusb_hcd_reset_endpoint(dev, ep);\n}\nEXPORT_SYMBOL_GPL(usb_reset_endpoint);\n\n\n/**\n * usb_disable_interface -- Disable all endpoints for an interface\n * @dev: the device whose interface is being disabled\n * @intf: pointer to the interface descriptor\n * @reset_hardware: flag to erase any endpoint state stored in the\n *\tcontroller hardware\n *\n * Disables all the endpoints for the interface's current altsetting.\n */\nvoid usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,\n\t\tbool reset_hardware)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\tusb_disable_endpoint(dev,\n\t\t\t\talt->endpoint[i].desc.bEndpointAddress,\n\t\t\t\treset_hardware);\n\t}\n}\n\n/**\n * usb_disable_device - Disable all the endpoints for a USB device\n * @dev: the device whose endpoints are being disabled\n * @skip_ep0: 0 to disable endpoint 0, 1 to skip it.\n *\n * Disables all the device's endpoints, potentially including endpoint 0.\n * Deallocates hcd/hardware state for the endpoints (nuking all or most\n * pending urbs) and usbcore state for the interfaces, so that usbcore\n * must usb_set_configuration() before any interfaces could be used.\n */\nvoid usb_disable_device(struct usb_device *dev, int skip_ep0)\n{\n\tint i;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\t/* getting rid of interfaces will disconnect\n\t * any drivers bound to them (a key side effect)\n\t */\n\tif (dev->actconfig) {\n\t\t/*\n\t\t * FIXME: In order to avoid self-deadlock involving the\n\t\t * bandwidth_mutex, we have to mark all the interfaces\n\t\t * before unregistering any of them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\n\t\t\tdev->actconfig->interface[i]->unregistering = 1;\n\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tstruct usb_interface\t*interface;\n\n\t\t\t/* remove this interface if it has been registered */\n\t\t\tinterface = dev->actconfig->interface[i];\n\t\t\tif (!device_is_registered(&interface->dev))\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->dev, \"unregistering interface %s\\n\",\n\t\t\t\tdev_name(&interface->dev));\n\t\t\tremove_intf_ep_devs(interface);\n\t\t\tdevice_del(&interface->dev);\n\t\t}\n\n\t\t/* Now that the interfaces are unbound, nobody should\n\t\t * try to access them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tput_device(&dev->actconfig->interface[i]->dev);\n\t\t\tdev->actconfig->interface[i] = NULL;\n\t\t}\n\n\t\tusb_disable_usb2_hardware_lpm(dev);\n\t\tusb_unlocked_disable_lpm(dev);\n\t\tusb_disable_ltm(dev);\n\n\t\tdev->actconfig = NULL;\n\t\tif (dev->state == USB_STATE_CONFIGURED)\n\t\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t}\n\n\tdev_dbg(&dev->dev, \"%s nuking %s URBs\\n\", __func__,\n\t\tskip_ep0 ? \"non-ep0\" : \"all\");\n\tif (hcd->driver->check_bandwidth) {\n\t\t/* First pass: Cancel URBs, leave endpoint pointers intact. */\n\t\tfor (i = skip_ep0; i < 16; ++i) {\n\t\t\tusb_disable_endpoint(dev, i, false);\n\t\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, false);\n\t\t}\n\t\t/* Remove endpoints from the host controller internal state */\n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\t/* Second pass: remove endpoint pointers */\n\t}\n\tfor (i = skip_ep0; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n}\n\n/**\n * usb_enable_endpoint - Enable an endpoint for USB communications\n * @dev: the device whose interface is being enabled\n * @ep: the endpoint\n * @reset_ep: flag to reset the endpoint state\n *\n * Resets the endpoint state if asked, and sets dev->ep_{in,out} pointers.\n * For control endpoints, both the input and output sides are handled.\n */\nvoid usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,\n\t\tbool reset_ep)\n{\n\tint epnum = usb_endpoint_num(&ep->desc);\n\tint is_out = usb_endpoint_dir_out(&ep->desc);\n\tint is_control = usb_endpoint_xfer_control(&ep->desc);\n\n\tif (reset_ep)\n\t\tusb_hcd_reset_endpoint(dev, ep);\n\tif (is_out || is_control)\n\t\tdev->ep_out[epnum] = ep;\n\tif (!is_out || is_control)\n\t\tdev->ep_in[epnum] = ep;\n\tep->enabled = 1;\n}\n\n/**\n * usb_enable_interface - Enable all the endpoints for an interface\n * @dev: the device whose interface is being enabled\n * @intf: pointer to the interface descriptor\n * @reset_eps: flag to reset the endpoints' state\n *\n * Enables all the endpoints for the interface's current altsetting.\n */\nvoid usb_enable_interface(struct usb_device *dev,\n\t\tstruct usb_interface *intf, bool reset_eps)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\tusb_enable_endpoint(dev, &alt->endpoint[i], reset_eps);\n}\n\n/**\n * usb_set_interface - Makes a particular alternate setting be current\n * @dev: the device whose interface is being updated\n * @interface: the interface being updated\n * @alternate: the setting being chosen.\n * Context: !in_interrupt ()\n *\n * This is used to enable data transfers on interfaces that may not\n * be enabled by default.  Not all devices support such configurability.\n * Only the driver bound to an interface may change its setting.\n *\n * Within any given configuration, each interface may have several\n * alternative settings.  These are often used to control levels of\n * bandwidth consumption.  For example, the default setting for a high\n * speed interrupt endpoint may not send more than 64 bytes per microframe,\n * while interrupt transfers of up to 3KBytes per microframe are legal.\n * Also, isochronous endpoints may never be part of an\n * interface's default setting.  To access such bandwidth, alternate\n * interface settings must be made current.\n *\n * Note that in the Linux USB subsystem, bandwidth associated with\n * an endpoint in a given alternate setting is not reserved until an URB\n * is submitted that needs that bandwidth.  Some other operating systems\n * allocate bandwidth early, when a configuration is chosen.\n *\n * xHCI reserves bandwidth and configures the alternate setting in\n * usb_hcd_alloc_bandwidth(). If it fails the original interface altsetting\n * may be disabled. Drivers cannot rely on any particular alternate\n * setting being in effect after a failure.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n * Also, drivers must not change altsettings while urbs are scheduled for\n * endpoints in that interface; all such urbs must first be completed\n * (perhaps forced by unlinking).\n *\n * Return: Zero on success, or else the status code returned by the\n * underlying usb_control_msg() call.\n */\nint usb_set_interface(struct usb_device *dev, int interface, int alternate)\n{\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alt;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint i, ret, manual = 0;\n\tunsigned int epaddr;\n\tunsigned int pipe;\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\tiface = usb_ifnum_to_if(dev, interface);\n\tif (!iface) {\n\t\tdev_dbg(&dev->dev, \"selecting invalid interface %d\\n\",\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\tif (iface->unregistering)\n\t\treturn -ENODEV;\n\n\talt = usb_altnum_to_altsetting(iface, alternate);\n\tif (!alt) {\n\t\tdev_warn(&dev->dev, \"selecting invalid altsetting %d\\n\",\n\t\t\t alternate);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * usb3 hosts configure the interface in usb_hcd_alloc_bandwidth,\n\t * including freeing dropped endpoint ring buffers.\n\t * Make sure the interface endpoints are flushed before that\n\t */\n\tusb_disable_interface(dev, iface, false);\n\n\t/* Make sure we have enough bandwidth for this alternate interface.\n\t * Remove the current alt setting and add the new alt setting.\n\t */\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the new alt setting is installed,\n\t * so that the xHCI driver can recalculate the U1/U2 timeouts.\n\t */\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&iface->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t/* Changing alt-setting also frees any allocated streams */\n\tfor (i = 0; i < iface->cur_altsetting->desc.bNumEndpoints; i++)\n\t\tiface->cur_altsetting->endpoint[i].streams = 0;\n\n\tret = usb_hcd_alloc_bandwidth(dev, NULL, iface->cur_altsetting, alt);\n\tif (ret < 0) {\n\t\tdev_info(&dev->dev, \"Not enough bandwidth for altsetting %d\\n\",\n\t\t\t\talternate);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\n\tif (dev->quirks & USB_QUIRK_NO_SET_INTF)\n\t\tret = -EPIPE;\n\telse\n\t\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t   USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,\n\t\t\t\t   alternate, interface, NULL, 0, 5000);\n\n\t/* 9.4.10 says devices don't need this and are free to STALL the\n\t * request if the interface only has one alternate setting.\n\t */\n\tif (ret == -EPIPE && iface->num_altsetting == 1) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"manual set_interface for iface %d, alt %d\\n\",\n\t\t\tinterface, alternate);\n\t\tmanual = 1;\n\t} else if (ret < 0) {\n\t\t/* Re-instate the old alt setting */\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, alt, iface->cur_altsetting);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\t/* FIXME drivers shouldn't need to replicate/bugfix the logic here\n\t * when they implement async or easily-killable versions of this or\n\t * other \"should-be-internal\" functions (like clear_halt).\n\t * should hcd+usbcore postprocess control requests?\n\t */\n\n\t/* prevent submissions using previous endpoint settings */\n\tif (iface->cur_altsetting != alt) {\n\t\tremove_intf_ep_devs(iface);\n\t\tusb_remove_sysfs_intf_files(iface);\n\t}\n\tusb_disable_interface(dev, iface, true);\n\n\tiface->cur_altsetting = alt;\n\n\t/* Now that the interface is installed, re-enable LPM. */\n\tusb_unlocked_enable_lpm(dev);\n\n\t/* If the interface only has one altsetting and the device didn't\n\t * accept the request, we attempt to carry out the equivalent action\n\t * by manually clearing the HALT feature for each endpoint in the\n\t * new altsetting.\n\t */\n\tif (manual) {\n\t\tfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\n\t\t\tepaddr = alt->endpoint[i].desc.bEndpointAddress;\n\t\t\tpipe = __create_pipe(dev,\n\t\t\t\t\tUSB_ENDPOINT_NUMBER_MASK & epaddr) |\n\t\t\t\t\t(usb_endpoint_out(epaddr) ?\n\t\t\t\t\tUSB_DIR_OUT : USB_DIR_IN);\n\n\t\t\tusb_clear_halt(dev, pipe);\n\t\t}\n\t}\n\n\t/* 9.1.1.5: reset toggles for all endpoints in the new altsetting\n\t *\n\t * Note:\n\t * Despite EP0 is always present in all interfaces/AS, the list of\n\t * endpoints from the descriptor does not contain EP0. Due to its\n\t * omnipresence one might expect EP0 being considered \"affected\" by\n\t * any SetInterface request and hence assume toggles need to be reset.\n\t * However, EP0 toggles are re-synced for every individual transfer\n\t * during the SETUP stage - hence EP0 toggles are \"don't care\" here.\n\t * (Likewise, EP0 never \"halts\" on well designed devices.)\n\t */\n\tusb_enable_interface(dev, iface, true);\n\tif (device_is_registered(&iface->dev)) {\n\t\tusb_create_sysfs_intf_files(iface);\n\t\tcreate_intf_ep_devs(iface);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_interface);\n\n/**\n * usb_reset_configuration - lightweight device reset\n * @dev: the device whose configuration is being reset\n *\n * This issues a standard SET_CONFIGURATION request to the device using\n * the current configuration.  The effect is to reset most USB-related\n * state in the device, including interface altsettings (reset to zero),\n * endpoint halts (cleared), and endpoint state (only for bulk and interrupt\n * endpoints).  Other usbcore state is unchanged, including bindings of\n * usb device drivers to interfaces.\n *\n * Because this affects multiple interfaces, avoid using this with composite\n * (multi-interface) devices.  Instead, the driver for each interface may\n * use usb_set_interface() on the interfaces it claims.  Be careful though;\n * some devices don't support the SET_INTERFACE request, and others won't\n * reset all the interface state (notably endpoint state).  Resetting the whole\n * configuration would affect other drivers' interfaces.\n *\n * The caller must own the device lock.\n *\n * Return: Zero on success, else a negative error code.\n */\nint usb_reset_configuration(struct usb_device *dev)\n{\n\tint\t\t\ti, retval;\n\tstruct usb_host_config\t*config;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\t/* caller must have locked the device and must own\n\t * the usb bus readlock (so driver bindings are stable);\n\t * calls during probe() are fine\n\t */\n\n\tfor (i = 1; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n\n\tconfig = dev->actconfig;\n\tretval = 0;\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the configuration is reset, so\n\t * that the xHCI driver can recalculate the U1/U2 timeouts.\n\t */\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t/* Make sure we have enough bandwidth for each alternate setting 0 */\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tif (alt != intf->cur_altsetting)\n\t\t\tretval = usb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\tintf->cur_altsetting, alt);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\t/* If not, reinstate the old alternate settings */\n\tif (retval < 0) {\nreset_old_alts:\n\t\tfor (i--; i >= 0; i--) {\n\t\t\tstruct usb_interface *intf = config->interface[i];\n\t\t\tstruct usb_host_interface *alt;\n\n\t\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\t\tif (!alt)\n\t\t\t\talt = &intf->altsetting[0];\n\t\t\tif (alt != intf->cur_altsetting)\n\t\t\t\tusb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\t\talt, intf->cur_altsetting);\n\t\t}\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn retval;\n\t}\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0)\n\t\tgoto reset_old_alts;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\t/* re-init hc/hcd interface/endpoint state */\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\n\t\t/* No altsetting 0?  We'll assume the first altsetting.\n\t\t * We could use a GetInterface call, but if a device is\n\t\t * so non-compliant that it doesn't have altsetting 0\n\t\t * then I wouldn't trust its reply anyway.\n\t\t */\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\n\t\tif (alt != intf->cur_altsetting) {\n\t\t\tremove_intf_ep_devs(intf);\n\t\t\tusb_remove_sysfs_intf_files(intf);\n\t\t}\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tif (device_is_registered(&intf->dev)) {\n\t\t\tusb_create_sysfs_intf_files(intf);\n\t\t\tcreate_intf_ep_devs(intf);\n\t\t}\n\t}\n\t/* Now that the interfaces are installed, re-enable LPM. */\n\tusb_unlocked_enable_lpm(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_reset_configuration);\n\nstatic void usb_release_interface(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_interface_cache *intfc =\n\t\t\taltsetting_to_usb_interface_cache(intf->altsetting);\n\n\tkref_put(&intfc->ref, usb_release_interface_cache);\n\tusb_put_dev(interface_to_usbdev(intf));\n\tof_node_put(dev->of_node);\n\tkfree(intf);\n}\n\n/*\n * usb_deauthorize_interface - deauthorize an USB interface\n *\n * @intf: USB interface structure\n */\nvoid usb_deauthorize_interface(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\n\tdevice_lock(dev->parent);\n\n\tif (intf->authorized) {\n\t\tdevice_lock(dev);\n\t\tintf->authorized = 0;\n\t\tdevice_unlock(dev);\n\n\t\tusb_forced_unbind_intf(intf);\n\t}\n\n\tdevice_unlock(dev->parent);\n}\n\n/*\n * usb_authorize_interface - authorize an USB interface\n *\n * @intf: USB interface structure\n */\nvoid usb_authorize_interface(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\n\tif (!intf->authorized) {\n\t\tdevice_lock(dev);\n\t\tintf->authorized = 1; /* authorize interface */\n\t\tdevice_unlock(dev);\n\t}\n}\n\nstatic int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alt;\n\n\tintf = to_usb_interface(dev);\n\tusb_dev = interface_to_usbdev(intf);\n\talt = intf->cur_altsetting;\n\n\tif (add_uevent_var(env, \"INTERFACE=%d/%d/%d\",\n\t\t   alt->desc.bInterfaceClass,\n\t\t   alt->desc.bInterfaceSubClass,\n\t\t   alt->desc.bInterfaceProtocol))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env,\n\t\t   \"MODALIAS=usb:\"\n\t\t   \"v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\",\n\t\t   le16_to_cpu(usb_dev->descriptor.idVendor),\n\t\t   le16_to_cpu(usb_dev->descriptor.idProduct),\n\t\t   le16_to_cpu(usb_dev->descriptor.bcdDevice),\n\t\t   usb_dev->descriptor.bDeviceClass,\n\t\t   usb_dev->descriptor.bDeviceSubClass,\n\t\t   usb_dev->descriptor.bDeviceProtocol,\n\t\t   alt->desc.bInterfaceClass,\n\t\t   alt->desc.bInterfaceSubClass,\n\t\t   alt->desc.bInterfaceProtocol,\n\t\t   alt->desc.bInterfaceNumber))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct device_type usb_if_device_type = {\n\t.name =\t\t\"usb_interface\",\n\t.release =\tusb_release_interface,\n\t.uevent =\tusb_if_uevent,\n};\n\nstatic struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,\n\t\t\t\t\t\tstruct usb_host_config *config,\n\t\t\t\t\t\tu8 inum)\n{\n\tstruct usb_interface_assoc_descriptor *retval = NULL;\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\tint first_intf;\n\tint last_intf;\n\tint i;\n\n\tfor (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {\n\t\tintf_assoc = config->intf_assoc[i];\n\t\tif (intf_assoc->bInterfaceCount == 0)\n\t\t\tcontinue;\n\n\t\tfirst_intf = intf_assoc->bFirstInterface;\n\t\tlast_intf = first_intf + (intf_assoc->bInterfaceCount - 1);\n\t\tif (inum >= first_intf && inum <= last_intf) {\n\t\t\tif (!retval)\n\t\t\t\tretval = intf_assoc;\n\t\t\telse\n\t\t\t\tdev_err(&dev->dev, \"Interface #%d referenced\"\n\t\t\t\t\t\" by multiple IADs\\n\", inum);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n\n/*\n * Internal function to queue a device reset\n * See usb_queue_reset_device() for more details\n */\nstatic void __usb_queue_reset_device(struct work_struct *ws)\n{\n\tint rc;\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, reset_ws);\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\n\trc = usb_lock_device_for_reset(udev, iface);\n\tif (rc >= 0) {\n\t\tusb_reset_device(udev);\n\t\tusb_unlock_device(udev);\n\t}\n\tusb_put_intf(iface);\t/* Undo _get_ in usb_queue_reset_device() */\n}\n\n\n/*\n * usb_set_configuration - Makes a particular device setting be current\n * @dev: the device whose configuration is being updated\n * @configuration: the configuration being chosen.\n * Context: !in_interrupt(), caller owns the device lock\n *\n * This is used to enable non-default device modes.  Not all devices\n * use this kind of configurability; many devices only have one\n * configuration.\n *\n * @configuration is the value of the configuration to be installed.\n * According to the USB spec (e.g. section 9.1.1.5), configuration values\n * must be non-zero; a value of zero indicates that the device in\n * unconfigured.  However some devices erroneously use 0 as one of their\n * configuration values.  To help manage such devices, this routine will\n * accept @configuration = -1 as indicating the device should be put in\n * an unconfigured state.\n *\n * USB device configurations may affect Linux interoperability,\n * power consumption and the functionality available.  For example,\n * the default configuration is limited to using 100mA of bus power,\n * so that when certain device functionality requires more power,\n * and the device is bus powered, that functionality should be in some\n * non-default device configuration.  Other device modes may also be\n * reflected as configuration options, such as whether two ISDN\n * channels are available independently; and choosing between open\n * standard device protocols (like CDC) or proprietary ones.\n *\n * Note that a non-authorized device (dev->authorized == 0) will only\n * be put in unconfigured mode.\n *\n * Note that USB has an additional level of device configurability,\n * associated with interfaces.  That configurability is accessed using\n * usb_set_interface().\n *\n * This call is synchronous. The calling context must be able to sleep,\n * must own the device lock, and must not hold the driver model's USB\n * bus mutex; usb interface driver probe() methods cannot use this routine.\n *\n * Returns zero on success, or else the status code returned by the\n * underlying call that failed.  On successful completion, each interface\n * in the original device configuration has been destroyed, and each one\n * in the new configuration has been probed by all relevant usb device\n * drivers currently known to the kernel.\n */\nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n\tint i, ret;\n\tstruct usb_host_config *cp = NULL;\n\tstruct usb_interface **new_interfaces = NULL;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint n, nintf;\n\n\tif (dev->authorized == 0 || configuration == -1)\n\t\tconfiguration = 0;\n\telse {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\n\t\t\tif (dev->config[i].desc.bConfigurationValue ==\n\t\t\t\t\tconfiguration) {\n\t\t\t\tcp = &dev->config[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((!cp && configuration != 0))\n\t\treturn -EINVAL;\n\n\t/* The USB spec says configuration 0 means unconfigured.\n\t * But if a device includes a configuration numbered 0,\n\t * we will accept it as a correctly configured state.\n\t * Use -1 if you really want to unconfigure the device.\n\t */\n\tif (cp && configuration == 0)\n\t\tdev_warn(&dev->dev, \"config 0 descriptor??\\n\");\n\n\t/* Allocate memory for new interfaces before doing anything else,\n\t * so that if we run out then nothing will have changed. */\n\tn = nintf = 0;\n\tif (cp) {\n\t\tnintf = cp->desc.bNumInterfaces;\n\t\tnew_interfaces = kmalloc_array(nintf, sizeof(*new_interfaces),\n\t\t\t\t\t       GFP_NOIO);\n\t\tif (!new_interfaces)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (; n < nintf; ++n) {\n\t\t\tnew_interfaces[n] = kzalloc(\n\t\t\t\t\tsizeof(struct usb_interface),\n\t\t\t\t\tGFP_NOIO);\n\t\t\tif (!new_interfaces[n]) {\n\t\t\t\tret = -ENOMEM;\nfree_interfaces:\n\t\t\t\twhile (--n >= 0)\n\t\t\t\t\tkfree(new_interfaces[n]);\n\t\t\t\tkfree(new_interfaces);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\ti = dev->bus_mA - usb_get_max_power(dev, cp);\n\t\tif (i < 0)\n\t\t\tdev_warn(&dev->dev, \"new config #%d exceeds power \"\n\t\t\t\t\t\"limit by %dmA\\n\",\n\t\t\t\t\tconfiguration, -i);\n\t}\n\n\t/* Wake up the device so we can send it the Set-Config request */\n\tret = usb_autoresume_device(dev);\n\tif (ret)\n\t\tgoto free_interfaces;\n\n\t/* if it's already configured, clear out old state first.\n\t * getting rid of old interfaces means unbinding their drivers.\n\t */\n\tif (dev->state != USB_STATE_ADDRESS)\n\t\tusb_disable_device(dev, 1);\t/* Skip ep0 */\n\n\t/* Get rid of pending async Set-Config requests for this device */\n\tcancel_async_set_config(dev);\n\n\t/* Make sure we have bandwidth (and available HCD resources) for this\n\t * configuration.  Remove endpoints from the schedule if we're dropping\n\t * this configuration to set configuration 0.  After this point, the\n\t * host controller will not allow submissions to dropped endpoints.  If\n\t * this call fails, the device state is unchanged.\n\t */\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the new configuration is\n\t * installed, so that the xHCI driver can recalculate the U1/U2\n\t * timeouts.\n\t */\n\tif (dev->actconfig && usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto free_interfaces;\n\t}\n\tret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (dev->actconfig)\n\t\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tusb_autosuspend_device(dev);\n\t\tgoto free_interfaces;\n\t}\n\n\t/*\n\t * Initialize the new interface structures and the\n\t * hc/hcd/usbcore interface/endpoint state.\n\t */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface_cache *intfc;\n\t\tstruct usb_interface *intf;\n\t\tstruct usb_host_interface *alt;\n\t\tu8 ifnum;\n\n\t\tcp->interface[i] = intf = new_interfaces[i];\n\t\tintfc = cp->intf_cache[i];\n\t\tintf->altsetting = intfc->altsetting;\n\t\tintf->num_altsetting = intfc->num_altsetting;\n\t\tintf->authorized = !!HCD_INTF_AUTHORIZED(hcd);\n\t\tkref_get(&intfc->ref);\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\n\t\t/* No altsetting 0?  We'll assume the first altsetting.\n\t\t * We could use a GetInterface call, but if a device is\n\t\t * so non-compliant that it doesn't have altsetting 0\n\t\t * then I wouldn't trust its reply anyway.\n\t\t */\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\n\t\tifnum = alt->desc.bInterfaceNumber;\n\t\tintf->intf_assoc = find_iad(dev, cp, ifnum);\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tintf->dev.parent = &dev->dev;\n\t\tif (usb_of_has_combined_node(dev)) {\n\t\t\tdevice_set_of_node_from_dev(&intf->dev, &dev->dev);\n\t\t} else {\n\t\t\tintf->dev.of_node = usb_of_get_interface_node(dev,\n\t\t\t\t\tconfiguration, ifnum);\n\t\t}\n\t\tACPI_COMPANION_SET(&intf->dev, ACPI_COMPANION(&dev->dev));\n\t\tintf->dev.driver = NULL;\n\t\tintf->dev.bus = &usb_bus_type;\n\t\tintf->dev.type = &usb_if_device_type;\n\t\tintf->dev.groups = usb_interface_groups;\n\t\t/*\n\t\t * Please refer to usb_alloc_dev() to see why we set\n\t\t * dma_mask and dma_pfn_offset.\n\t\t */\n\t\tintf->dev.dma_mask = dev->dev.dma_mask;\n\t\tintf->dev.dma_pfn_offset = dev->dev.dma_pfn_offset;\n\t\tINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);\n\t\tintf->minor = -1;\n\t\tdevice_initialize(&intf->dev);\n\t\tpm_runtime_no_callbacks(&intf->dev);\n\t\tdev_set_name(&intf->dev, \"%d-%s:%d.%d\", dev->bus->busnum,\n\t\t\t\tdev->devpath, configuration, ifnum);\n\t\tusb_get_dev(dev);\n\t}\n\tkfree(new_interfaces);\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0 && cp) {\n\t\t/*\n\t\t * All the old state is gone, so what else can we do?\n\t\t * The device is probably useless now anyway.\n\t\t */\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tfor (i = 0; i < nintf; ++i) {\n\t\t\tusb_disable_interface(dev, cp->interface[i], true);\n\t\t\tput_device(&cp->interface[i]->dev);\n\t\t\tcp->interface[i] = NULL;\n\t\t}\n\t\tcp = NULL;\n\t}\n\n\tdev->actconfig = cp;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\tif (!cp) {\n\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\n\t\t/* Leave LPM disabled while the device is unconfigured. */\n\t\tusb_autosuspend_device(dev);\n\t\treturn ret;\n\t}\n\tusb_set_device_state(dev, USB_STATE_CONFIGURED);\n\n\tif (cp->string == NULL &&\n\t\t\t!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\n\t\tcp->string = usb_cache_string(dev, cp->desc.iConfiguration);\n\n\t/* Now that the interfaces are installed, re-enable LPM. */\n\tusb_unlocked_enable_lpm(dev);\n\t/* Enable LTM if it was turned off by usb_disable_device. */\n\tusb_enable_ltm(dev);\n\n\t/* Now that all the interfaces are set up, register them\n\t * to trigger binding of drivers to interfaces.  probe()\n\t * routines may install different altsettings and may\n\t * claim() any interfaces not yet bound.  Many class drivers\n\t * need that: CDC, audio, video, etc.\n\t */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface *intf = cp->interface[i];\n\n\t\tif (intf->dev.of_node &&\n\t\t    !of_device_is_available(intf->dev.of_node)) {\n\t\t\tdev_info(&dev->dev, \"skipping disabled interface %d\\n\",\n\t\t\t\t intf->cur_altsetting->desc.bInterfaceNumber);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"adding %s (config #%d, interface %d)\\n\",\n\t\t\tdev_name(&intf->dev), configuration,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\tdevice_enable_async_suspend(&intf->dev);\n\t\tret = device_add(&intf->dev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&dev->dev, \"device_add(%s) --> %d\\n\",\n\t\t\t\tdev_name(&intf->dev), ret);\n\t\t\tcontinue;\n\t\t}\n\t\tcreate_intf_ep_devs(intf);\n\t}\n\n\tusb_autosuspend_device(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_configuration);\n\nstatic LIST_HEAD(set_config_list);\nstatic DEFINE_SPINLOCK(set_config_lock);\n\nstruct set_config_request {\n\tstruct usb_device\t*udev;\n\tint\t\t\tconfig;\n\tstruct work_struct\twork;\n\tstruct list_head\tnode;\n};\n\n/* Worker routine for usb_driver_set_configuration() */\nstatic void driver_set_config_work(struct work_struct *work)\n{\n\tstruct set_config_request *req =\n\t\tcontainer_of(work, struct set_config_request, work);\n\tstruct usb_device *udev = req->udev;\n\n\tusb_lock_device(udev);\n\tspin_lock(&set_config_lock);\n\tlist_del(&req->node);\n\tspin_unlock(&set_config_lock);\n\n\tif (req->config >= -1)\t\t/* Is req still valid? */\n\t\tusb_set_configuration(udev, req->config);\n\tusb_unlock_device(udev);\n\tusb_put_dev(udev);\n\tkfree(req);\n}\n\n/* Cancel pending Set-Config requests for a device whose configuration\n * was just changed\n */\nstatic void cancel_async_set_config(struct usb_device *udev)\n{\n\tstruct set_config_request *req;\n\n\tspin_lock(&set_config_lock);\n\tlist_for_each_entry(req, &set_config_list, node) {\n\t\tif (req->udev == udev)\n\t\t\treq->config = -999;\t/* Mark as cancelled */\n\t}\n\tspin_unlock(&set_config_lock);\n}\n\n/**\n * usb_driver_set_configuration - Provide a way for drivers to change device configurations\n * @udev: the device whose configuration is being updated\n * @config: the configuration being chosen.\n * Context: In process context, must be able to sleep\n *\n * Device interface drivers are not allowed to change device configurations.\n * This is because changing configurations will destroy the interface the\n * driver is bound to and create new ones; it would be like a floppy-disk\n * driver telling the computer to replace the floppy-disk drive with a\n * tape drive!\n *\n * Still, in certain specialized circumstances the need may arise.  This\n * routine gets around the normal restrictions by using a work thread to\n * submit the change-config request.\n *\n * Return: 0 if the request was successfully queued, error code otherwise.\n * The caller has no way to know whether the queued request will eventually\n * succeed.\n */\nint usb_driver_set_configuration(struct usb_device *udev, int config)\n{\n\tstruct set_config_request *req;\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->udev = udev;\n\treq->config = config;\n\tINIT_WORK(&req->work, driver_set_config_work);\n\n\tspin_lock(&set_config_lock);\n\tlist_add(&req->node, &set_config_list);\n\tspin_unlock(&set_config_lock);\n\n\tusb_get_dev(udev);\n\tschedule_work(&req->work);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_driver_set_configuration);\n\n/**\n * cdc_parse_cdc_header - parse the extra headers present in CDC devices\n * @hdr: the place to put the results of the parsing\n * @intf: the interface for which parsing is requested\n * @buffer: pointer to the extra headers to be parsed\n * @buflen: length of the extra headers\n *\n * This evaluates the extra headers present in CDC devices which\n * bind the interfaces for data and control and provide details\n * about the capabilities of the device.\n *\n * Return: number of descriptors parsed or -EINVAL\n * if the header is contradictory beyond salvage\n */\n\nint cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\t/* duplicates are ignored */\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\n\t/* duplicates are not tolerated */\n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\n\tunsigned int elength;\n\tint cnt = 0;\n\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif ((buflen < elength) || (elength < 3)) {\n\t\t\tdev_err(&intf->dev, \"invalid descriptor buffer length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE: /* we've found it */\n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * there are LOTS more CDC descriptors that\n\t\t\t * could legitimately be found here.\n\t\t\t */\n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}\n\nEXPORT_SYMBOL(cdc_parse_cdc_header);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * message.c - synchronous message handling\n *\n * Released under the GPLv2 only.\n */\n\n#include <linux/acpi.h>\n#include <linux/pci.h>\t/* for scatterlist macros */\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <linux/device.h>\n#include <linux/scatterlist.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/quirks.h>\n#include <linux/usb/hcd.h>\t/* for usbcore internals */\n#include <linux/usb/of.h>\n#include <asm/byteorder.h>\n\n#include \"usb.h\"\n\nstatic void cancel_async_set_config(struct usb_device *udev);\n\nstruct api_context {\n\tstruct completion\tdone;\n\tint\t\t\tstatus;\n};\n\nstatic void usb_api_blocking_completion(struct urb *urb)\n{\n\tstruct api_context *ctx = urb->context;\n\n\tctx->status = urb->status;\n\tcomplete(&ctx->done);\n}\n\n\n/*\n * Starts urb and waits for completion or timeout. Note that this call\n * is NOT interruptible. Many device driver i/o requests should be\n * interruptible and therefore these drivers should implement their\n * own interruptible routines.\n */\nstatic int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)\n{\n\tstruct api_context ctx;\n\tunsigned long expire;\n\tint retval;\n\n\tinit_completion(&ctx.done);\n\turb->context = &ctx;\n\turb->actual_length = 0;\n\tretval = usb_submit_urb(urb, GFP_NOIO);\n\tif (unlikely(retval))\n\t\tgoto out;\n\n\texpire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;\n\tif (!wait_for_completion_timeout(&ctx.done, expire)) {\n\t\tusb_kill_urb(urb);\n\t\tretval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);\n\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"%s timed out on ep%d%s len=%u/%u\\n\",\n\t\t\tcurrent->comm,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\turb->actual_length,\n\t\t\turb->transfer_buffer_length);\n\t} else\n\t\tretval = ctx.status;\nout:\n\tif (actual_length)\n\t\t*actual_length = urb->actual_length;\n\n\tusb_free_urb(urb);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------*/\n/* returns status (negative) or length (positive) */\nstatic int usb_internal_control_msg(struct usb_device *usb_dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    struct usb_ctrlrequest *cmd,\n\t\t\t\t    void *data, int len, int timeout)\n{\n\tstruct urb *urb;\n\tint retv;\n\tint length;\n\n\turb = usb_alloc_urb(0, GFP_NOIO);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,\n\t\t\t     len, usb_api_blocking_completion, NULL);\n\n\tretv = usb_start_wait_urb(urb, timeout, &length);\n\tif (retv < 0)\n\t\treturn retv;\n\telse\n\t\treturn length;\n}\n\n/**\n * usb_control_msg - Builds a control urb, sends it off and waits for completion\n * @dev: pointer to the usb device to send the message to\n * @pipe: endpoint \"pipe\" to send the message to\n * @request: USB message request value\n * @requesttype: USB message request type value\n * @value: USB message value\n * @index: USB message index value\n * @data: pointer to the data to send\n * @size: length in bytes of the data to send\n * @timeout: time in msecs to wait for the message to complete before timing\n *\tout (if 0 the wait is forever)\n *\n * Context: !in_interrupt ()\n *\n * This function sends a simple control message to a specified endpoint and\n * waits for the message to complete, or timeout.\n *\n * Don't use this function from within an interrupt context. If you need\n * an asynchronous message, or need to send a message from within interrupt\n * context, use usb_submit_urb(). If a thread in your driver uses this call,\n * make sure your disconnect() method can wait for it to complete. Since you\n * don't have a handle on the URB used, you can't cancel the request.\n *\n * Return: If successful, the number of bytes transferred. Otherwise, a negative\n * error number.\n */\nint usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\n\t\t    __u8 requesttype, __u16 value, __u16 index, void *data,\n\t\t    __u16 size, int timeout)\n{\n\tstruct usb_ctrlrequest *dr;\n\tint ret;\n\n\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->bRequestType = requesttype;\n\tdr->bRequest = request;\n\tdr->wValue = cpu_to_le16(value);\n\tdr->wIndex = cpu_to_le16(index);\n\tdr->wLength = cpu_to_le16(size);\n\n\tret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);\n\n\t/* Linger a bit, prior to the next control message. */\n\tif (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)\n\t\tmsleep(200);\n\n\tkfree(dr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_control_msg);\n\n/**\n * usb_interrupt_msg - Builds an interrupt urb, sends it off and waits for completion\n * @usb_dev: pointer to the usb device to send the message to\n * @pipe: endpoint \"pipe\" to send the message to\n * @data: pointer to the data to send\n * @len: length in bytes of the data to send\n * @actual_length: pointer to a location to put the actual length transferred\n *\tin bytes\n * @timeout: time in msecs to wait for the message to complete before\n *\ttiming out (if 0 the wait is forever)\n *\n * Context: !in_interrupt ()\n *\n * This function sends a simple interrupt message to a specified endpoint and\n * waits for the message to complete, or timeout.\n *\n * Don't use this function from within an interrupt context. If you need\n * an asynchronous message, or need to send a message from within interrupt\n * context, use usb_submit_urb() If a thread in your driver uses this call,\n * make sure your disconnect() method can wait for it to complete. Since you\n * don't have a handle on the URB used, you can't cancel the request.\n *\n * Return:\n * If successful, 0. Otherwise a negative error number. The number of actual\n * bytes transferred will be stored in the @actual_length parameter.\n */\nint usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\t\t      void *data, int len, int *actual_length, int timeout)\n{\n\treturn usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout);\n}\nEXPORT_SYMBOL_GPL(usb_interrupt_msg);\n\n/**\n * usb_bulk_msg - Builds a bulk urb, sends it off and waits for completion\n * @usb_dev: pointer to the usb device to send the message to\n * @pipe: endpoint \"pipe\" to send the message to\n * @data: pointer to the data to send\n * @len: length in bytes of the data to send\n * @actual_length: pointer to a location to put the actual length transferred\n *\tin bytes\n * @timeout: time in msecs to wait for the message to complete before\n *\ttiming out (if 0 the wait is forever)\n *\n * Context: !in_interrupt ()\n *\n * This function sends a simple bulk message to a specified endpoint\n * and waits for the message to complete, or timeout.\n *\n * Don't use this function from within an interrupt context. If you need\n * an asynchronous message, or need to send a message from within interrupt\n * context, use usb_submit_urb() If a thread in your driver uses this call,\n * make sure your disconnect() method can wait for it to complete. Since you\n * don't have a handle on the URB used, you can't cancel the request.\n *\n * Because there is no usb_interrupt_msg() and no USBDEVFS_INTERRUPT ioctl,\n * users are forced to abuse this routine by using it to submit URBs for\n * interrupt endpoints.  We will take the liberty of creating an interrupt URB\n * (with the default interval) if the target is an interrupt endpoint.\n *\n * Return:\n * If successful, 0. Otherwise a negative error number. The number of actual\n * bytes transferred will be stored in the @actual_length parameter.\n *\n */\nint usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\t\t void *data, int len, int *actual_length, int timeout)\n{\n\tstruct urb *urb;\n\tstruct usb_host_endpoint *ep;\n\n\tep = usb_pipe_endpoint(usb_dev, pipe);\n\tif (!ep || len < 0)\n\t\treturn -EINVAL;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tif ((ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_INT) {\n\t\tpipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);\n\t\tusb_fill_int_urb(urb, usb_dev, pipe, data, len,\n\t\t\t\tusb_api_blocking_completion, NULL,\n\t\t\t\tep->desc.bInterval);\n\t} else\n\t\tusb_fill_bulk_urb(urb, usb_dev, pipe, data, len,\n\t\t\t\tusb_api_blocking_completion, NULL);\n\n\treturn usb_start_wait_urb(urb, timeout, actual_length);\n}\nEXPORT_SYMBOL_GPL(usb_bulk_msg);\n\n/*-------------------------------------------------------------------*/\n\nstatic void sg_clean(struct usb_sg_request *io)\n{\n\tif (io->urbs) {\n\t\twhile (io->entries--)\n\t\t\tusb_free_urb(io->urbs[io->entries]);\n\t\tkfree(io->urbs);\n\t\tio->urbs = NULL;\n\t}\n\tio->dev = NULL;\n}\n\nstatic void sg_complete(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_sg_request *io = urb->context;\n\tint status = urb->status;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\n\t/* In 2.5 we require hcds' endpoint queues not to progress after fault\n\t * reports, until the completion callback (this!) returns.  That lets\n\t * device driver code (like this routine) unlink queued urbs first,\n\t * if it needs to, since the HC won't work on them at all.  So it's\n\t * not possible for page N+1 to overwrite page N, and so on.\n\t *\n\t * That's only for \"hard\" faults; \"soft\" faults (unlinks) sometimes\n\t * complete before the HCD can get requests away from hardware,\n\t * though never during cleanup after a hard fault.\n\t */\n\tif (io->status\n\t\t\t&& (io->status != -ECONNRESET\n\t\t\t\t|| status != -ECONNRESET)\n\t\t\t&& urb->actual_length) {\n\t\tdev_err(io->dev->bus->controller,\n\t\t\t\"dev %s ep%d%s scatterlist error %d/%d\\n\",\n\t\t\tio->dev->devpath,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\tstatus, io->status);\n\t\t/* BUG (); */\n\t}\n\n\tif (io->status == 0 && status && status != -ECONNRESET) {\n\t\tint i, found, retval;\n\n\t\tio->status = status;\n\n\t\t/* the previous urbs, and this one, completed already.\n\t\t * unlink pending urbs so they won't rx/tx bad data.\n\t\t * careful: unlink can sometimes be synchronous...\n\t\t */\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\tfor (i = 0, found = 0; i < io->entries; i++) {\n\t\t\tif (!io->urbs[i])\n\t\t\t\tcontinue;\n\t\t\tif (found) {\n\t\t\t\tusb_block_urb(io->urbs[i]);\n\t\t\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\t\t\tif (retval != -EINPROGRESS &&\n\t\t\t\t    retval != -ENODEV &&\n\t\t\t\t    retval != -EBUSY &&\n\t\t\t\t    retval != -EIDRM)\n\t\t\t\t\tdev_err(&io->dev->dev,\n\t\t\t\t\t\t\"%s, unlink --> %d\\n\",\n\t\t\t\t\t\t__func__, retval);\n\t\t\t} else if (urb == io->urbs[i])\n\t\t\t\tfound = 1;\n\t\t}\n\t\tspin_lock_irqsave(&io->lock, flags);\n\t}\n\n\t/* on the last completion, signal usb_sg_wait() */\n\tio->bytes += urb->actual_length;\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\n\tspin_unlock_irqrestore(&io->lock, flags);\n}\n\n\n/**\n * usb_sg_init - initializes scatterlist-based bulk/interrupt I/O request\n * @io: request block being initialized.  until usb_sg_wait() returns,\n *\ttreat this as a pointer to an opaque block of memory,\n * @dev: the usb device that will send or receive the data\n * @pipe: endpoint \"pipe\" used to transfer the data\n * @period: polling rate for interrupt endpoints, in frames or\n * \t(for high speed endpoints) microframes; ignored for bulk\n * @sg: scatterlist entries\n * @nents: how many entries in the scatterlist\n * @length: how many bytes to send from the scatterlist, or zero to\n * \tsend every byte identified in the list.\n * @mem_flags: SLAB_* flags affecting memory allocations in this call\n *\n * This initializes a scatter/gather request, allocating resources such as\n * I/O mappings and urb memory (except maybe memory used by USB controller\n * drivers).\n *\n * The request must be issued using usb_sg_wait(), which waits for the I/O to\n * complete (or to be canceled) and then cleans up all resources allocated by\n * usb_sg_init().\n *\n * The request may be canceled with usb_sg_cancel(), either before or after\n * usb_sg_wait() is called.\n *\n * Return: Zero for success, else a negative errno value.\n */\nint usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,\n\t\tunsigned pipe, unsigned\tperiod, struct scatterlist *sg,\n\t\tint nents, size_t length, gfp_t mem_flags)\n{\n\tint i;\n\tint urb_flags;\n\tint use_sg;\n\n\tif (!io || !dev || !sg\n\t\t\t|| usb_pipecontrol(pipe)\n\t\t\t|| usb_pipeisoc(pipe)\n\t\t\t|| nents <= 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&io->lock);\n\tio->dev = dev;\n\tio->pipe = pipe;\n\n\tif (dev->bus->sg_tablesize > 0) {\n\t\tuse_sg = true;\n\t\tio->entries = 1;\n\t} else {\n\t\tuse_sg = false;\n\t\tio->entries = nents;\n\t}\n\n\t/* initialize all the urbs we'll use */\n\tio->urbs = kmalloc_array(io->entries, sizeof(*io->urbs), mem_flags);\n\tif (!io->urbs)\n\t\tgoto nomem;\n\n\turb_flags = URB_NO_INTERRUPT;\n\tif (usb_pipein(pipe))\n\t\turb_flags |= URB_SHORT_NOT_OK;\n\n\tfor_each_sg(sg, sg, io->entries, i) {\n\t\tstruct urb *urb;\n\t\tunsigned len;\n\n\t\turb = usb_alloc_urb(0, mem_flags);\n\t\tif (!urb) {\n\t\t\tio->entries = i;\n\t\t\tgoto nomem;\n\t\t}\n\t\tio->urbs[i] = urb;\n\n\t\turb->dev = NULL;\n\t\turb->pipe = pipe;\n\t\turb->interval = period;\n\t\turb->transfer_flags = urb_flags;\n\t\turb->complete = sg_complete;\n\t\turb->context = io;\n\t\turb->sg = sg;\n\n\t\tif (use_sg) {\n\t\t\t/* There is no single transfer buffer */\n\t\t\turb->transfer_buffer = NULL;\n\t\t\turb->num_sgs = nents;\n\n\t\t\t/* A length of zero means transfer the whole sg list */\n\t\t\tlen = length;\n\t\t\tif (len == 0) {\n\t\t\t\tstruct scatterlist\t*sg2;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\tfor_each_sg(sg, sg2, nents, j)\n\t\t\t\t\tlen += sg2->length;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Some systems can't use DMA; they use PIO instead.\n\t\t\t * For their sakes, transfer_buffer is set whenever\n\t\t\t * possible.\n\t\t\t */\n\t\t\tif (!PageHighMem(sg_page(sg)))\n\t\t\t\turb->transfer_buffer = sg_virt(sg);\n\t\t\telse\n\t\t\t\turb->transfer_buffer = NULL;\n\n\t\t\tlen = sg->length;\n\t\t\tif (length) {\n\t\t\t\tlen = min_t(size_t, len, length);\n\t\t\t\tlength -= len;\n\t\t\t\tif (length == 0)\n\t\t\t\t\tio->entries = i + 1;\n\t\t\t}\n\t\t}\n\t\turb->transfer_buffer_length = len;\n\t}\n\tio->urbs[--i]->transfer_flags &= ~URB_NO_INTERRUPT;\n\n\t/* transaction state */\n\tio->count = io->entries;\n\tio->status = 0;\n\tio->bytes = 0;\n\tinit_completion(&io->complete);\n\treturn 0;\n\nnomem:\n\tsg_clean(io);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_sg_init);\n\n/**\n * usb_sg_wait - synchronously execute scatter/gather request\n * @io: request block handle, as initialized with usb_sg_init().\n * \tsome fields become accessible when this call returns.\n * Context: !in_interrupt ()\n *\n * This function blocks until the specified I/O operation completes.  It\n * leverages the grouping of the related I/O requests to get good transfer\n * rates, by queueing the requests.  At higher speeds, such queuing can\n * significantly improve USB throughput.\n *\n * There are three kinds of completion for this function.\n *\n * (1) success, where io->status is zero.  The number of io->bytes\n *     transferred is as requested.\n * (2) error, where io->status is a negative errno value.  The number\n *     of io->bytes transferred before the error is usually less\n *     than requested, and can be nonzero.\n * (3) cancellation, a type of error with status -ECONNRESET that\n *     is initiated by usb_sg_cancel().\n *\n * When this function returns, all memory allocated through usb_sg_init() or\n * this call will have been freed.  The request block parameter may still be\n * passed to usb_sg_cancel(), or it may be freed.  It could also be\n * reinitialized and then reused.\n *\n * Data Transfer Rates:\n *\n * Bulk transfers are valid for full or high speed endpoints.\n * The best full speed data rate is 19 packets of 64 bytes each\n * per frame, or 1216 bytes per millisecond.\n * The best high speed data rate is 13 packets of 512 bytes each\n * per microframe, or 52 KBytes per millisecond.\n *\n * The reason to use interrupt transfers through this API would most likely\n * be to reserve high speed bandwidth, where up to 24 KBytes per millisecond\n * could be transferred.  That capability is less useful for low or full\n * speed interrupt endpoints, which allow at most one packet per millisecond,\n * of at most 8 or 64 bytes (respectively).\n *\n * It is not necessary to call this function to reserve bandwidth for devices\n * under an xHCI host controller, as the bandwidth is reserved when the\n * configuration or interface alt setting is selected.\n */\nvoid usb_sg_wait(struct usb_sg_request *io)\n{\n\tint i;\n\tint entries = io->entries;\n\n\t/* queue the urbs.  */\n\tspin_lock_irq(&io->lock);\n\ti = 0;\n\twhile (i < entries && !io->status) {\n\t\tint retval;\n\n\t\tio->urbs[i]->dev = io->dev;\n\t\tspin_unlock_irq(&io->lock);\n\n\t\tretval = usb_submit_urb(io->urbs[i], GFP_NOIO);\n\n\t\tswitch (retval) {\n\t\t\t/* maybe we retrying will recover */\n\t\tcase -ENXIO:\t/* hc didn't queue this one */\n\t\tcase -EAGAIN:\n\t\tcase -ENOMEM:\n\t\t\tretval = 0;\n\t\t\tyield();\n\t\t\tbreak;\n\n\t\t\t/* no error? continue immediately.\n\t\t\t *\n\t\t\t * NOTE: to work better with UHCI (4K I/O buffer may\n\t\t\t * need 3K of TDs) it may be good to limit how many\n\t\t\t * URBs are queued at once; N milliseconds?\n\t\t\t */\n\t\tcase 0:\n\t\t\t++i;\n\t\t\tcpu_relax();\n\t\t\tbreak;\n\n\t\t\t/* fail any uncompleted urbs */\n\t\tdefault:\n\t\t\tio->urbs[i]->status = retval;\n\t\t\tdev_dbg(&io->dev->dev, \"%s, submit --> %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tusb_sg_cancel(io);\n\t\t}\n\t\tspin_lock_irq(&io->lock);\n\t\tif (retval && (io->status == 0 || io->status == -ECONNRESET))\n\t\t\tio->status = retval;\n\t}\n\tio->count -= entries - i;\n\tif (io->count == 0)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irq(&io->lock);\n\n\t/* OK, yes, this could be packaged as non-blocking.\n\t * So could the submit loop above ... but it's easier to\n\t * solve neither problem than to solve both!\n\t */\n\twait_for_completion(&io->complete);\n\n\tsg_clean(io);\n}\nEXPORT_SYMBOL_GPL(usb_sg_wait);\n\n/**\n * usb_sg_cancel - stop scatter/gather i/o issued by usb_sg_wait()\n * @io: request block, initialized with usb_sg_init()\n *\n * This stops a request after it has been started by usb_sg_wait().\n * It can also prevents one initialized by usb_sg_init() from starting,\n * so that call just frees resources allocated to the request.\n */\nvoid usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tio->count++;\t\t/* Keep the request alive until we're done */\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_sg_cancel);\n\n/*-------------------------------------------------------------------*/\n\n/**\n * usb_get_descriptor - issues a generic GET_DESCRIPTOR request\n * @dev: the device whose descriptor is being retrieved\n * @type: the descriptor type (USB_DT_*)\n * @index: the number of the descriptor\n * @buf: where to put the descriptor\n * @size: how big is \"buf\"?\n * Context: !in_interrupt ()\n *\n * Gets a USB descriptor.  Convenience functions exist to simplify\n * getting some types of descriptors.  Use\n * usb_get_string() or usb_string() for USB_DT_STRING.\n * Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)\n * are part of the device structure.\n * In addition to a number of USB-standard descriptors, some\n * devices also use class-specific or vendor-specific descriptors.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: The number of bytes received on success, or else the status code\n * returned by the underlying usb_control_msg() call.\n */\nint usb_get_descriptor(struct usb_device *dev, unsigned char type,\n\t\t       unsigned char index, void *buf, int size)\n{\n\tint i;\n\tint result;\n\n\tmemset(buf, 0, size);\t/* Make sure we parse really received data */\n\n\tfor (i = 0; i < 3; ++i) {\n\t\t/* retry on length 0 or error; some devices are flakey */\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t(type << 8) + index, 0, buf, size,\n\t\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (result <= 0 && result != -ETIMEDOUT)\n\t\t\tcontinue;\n\t\tif (result > 1 && ((u8 *)buf)[1] != type) {\n\t\t\tresult = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_get_descriptor);\n\n/**\n * usb_get_string - gets a string descriptor\n * @dev: the device whose string descriptor is being retrieved\n * @langid: code for language chosen (from string descriptor zero)\n * @index: the number of the descriptor\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n * Context: !in_interrupt ()\n *\n * Retrieves a string, encoded using UTF-16LE (Unicode, 16 bits per character,\n * in little-endian byte order).\n * The usb_string() function will often be a convenient way to turn\n * these strings into kernel-printable form.\n *\n * Strings may be referenced in device, configuration, interface, or other\n * descriptors, and could also be used in vendor-specific ways.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: The number of bytes received on success, or else the status code\n * returned by the underlying usb_control_msg() call.\n */\nstatic int usb_get_string(struct usb_device *dev, unsigned short langid,\n\t\t\t  unsigned char index, void *buf, int size)\n{\n\tint i;\n\tint result;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\t/* retry on length 0 or stall; some devices are flakey */\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t(USB_DT_STRING << 8) + index, langid, buf, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (result == 0 || result == -EPIPE)\n\t\t\tcontinue;\n\t\tif (result > 1 && ((u8 *) buf)[1] != USB_DT_STRING) {\n\t\t\tresult = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic void usb_try_string_workarounds(unsigned char *buf, int *length)\n{\n\tint newlength, oldlength = *length;\n\n\tfor (newlength = 2; newlength + 1 < oldlength; newlength += 2)\n\t\tif (!isprint(buf[newlength]) || buf[newlength + 1])\n\t\t\tbreak;\n\n\tif (newlength > 2) {\n\t\tbuf[0] = newlength;\n\t\t*length = newlength;\n\t}\n}\n\nstatic int usb_string_sub(struct usb_device *dev, unsigned int langid,\n\t\t\t  unsigned int index, unsigned char *buf)\n{\n\tint rc;\n\n\t/* Try to read the string descriptor by asking for the maximum\n\t * possible number of bytes */\n\tif (dev->quirks & USB_QUIRK_STRING_FETCH_255)\n\t\trc = -EIO;\n\telse\n\t\trc = usb_get_string(dev, langid, index, buf, 255);\n\n\t/* If that failed try to read the descriptor length, then\n\t * ask for just that many bytes */\n\tif (rc < 2) {\n\t\trc = usb_get_string(dev, langid, index, buf, 2);\n\t\tif (rc == 2)\n\t\t\trc = usb_get_string(dev, langid, index, buf, buf[0]);\n\t}\n\n\tif (rc >= 2) {\n\t\tif (!buf[0] && !buf[1])\n\t\t\tusb_try_string_workarounds(buf, &rc);\n\n\t\t/* There might be extra junk at the end of the descriptor */\n\t\tif (buf[0] < rc)\n\t\t\trc = buf[0];\n\n\t\trc = rc - (rc & 1); /* force a multiple of two */\n\t}\n\n\tif (rc < 2)\n\t\trc = (rc < 0 ? rc : -EINVAL);\n\n\treturn rc;\n}\n\nstatic int usb_get_langid(struct usb_device *dev, unsigned char *tbuf)\n{\n\tint err;\n\n\tif (dev->have_langid)\n\t\treturn 0;\n\n\tif (dev->string_langid < 0)\n\t\treturn -EPIPE;\n\n\terr = usb_string_sub(dev, 0, 0, tbuf);\n\n\t/* If the string was reported but is malformed, default to english\n\t * (0x0409) */\n\tif (err == -ENODATA || (err > 0 && err < 4)) {\n\t\tdev->string_langid = 0x0409;\n\t\tdev->have_langid = 1;\n\t\tdev_err(&dev->dev,\n\t\t\t\"language id specifier not provided by device, defaulting to English\\n\");\n\t\treturn 0;\n\t}\n\n\t/* In case of all other errors, we assume the device is not able to\n\t * deal with strings at all. Set string_langid to -1 in order to\n\t * prevent any string to be retrieved from the device */\n\tif (err < 0) {\n\t\tdev_info(&dev->dev, \"string descriptor 0 read error: %d\\n\",\n\t\t\t\t\terr);\n\t\tdev->string_langid = -1;\n\t\treturn -EPIPE;\n\t}\n\n\t/* always use the first langid listed */\n\tdev->string_langid = tbuf[2] | (tbuf[3] << 8);\n\tdev->have_langid = 1;\n\tdev_dbg(&dev->dev, \"default language 0x%04x\\n\",\n\t\t\t\tdev->string_langid);\n\treturn 0;\n}\n\n/**\n * usb_string - returns UTF-8 version of a string descriptor\n * @dev: the device whose string descriptor is being retrieved\n * @index: the number of the descriptor\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n * Context: !in_interrupt ()\n *\n * This converts the UTF-16LE encoded strings returned by devices, from\n * usb_get_string_descriptor(), to null-terminated UTF-8 encoded ones\n * that are more usable in most kernel contexts.  Note that this function\n * chooses strings in the first language supported by the device.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: length of the string (>= 0) or usb_control_msg status (< 0).\n */\nint usb_string(struct usb_device *dev, int index, char *buf, size_t size)\n{\n\tunsigned char *tbuf;\n\tint err;\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tif (size <= 0 || !buf)\n\t\treturn -EINVAL;\n\tbuf[0] = 0;\n\tif (index <= 0 || index >= 256)\n\t\treturn -EINVAL;\n\ttbuf = kmalloc(256, GFP_NOIO);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\terr = usb_get_langid(dev, tbuf);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = usb_string_sub(dev, dev->string_langid, index, tbuf);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tsize--;\t\t/* leave room for trailing NULL char in output buffer */\n\terr = utf16s_to_utf8s((wchar_t *) &tbuf[2], (err - 2) / 2,\n\t\t\tUTF16_LITTLE_ENDIAN, buf, size);\n\tbuf[err] = 0;\n\n\tif (tbuf[1] != USB_DT_STRING)\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"wrong descriptor type %02x for string %d (\\\"%s\\\")\\n\",\n\t\t\ttbuf[1], index, buf);\n\n errout:\n\tkfree(tbuf);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(usb_string);\n\n/* one UTF-8-encoded 16-bit character has at most three bytes */\n#define MAX_USB_STRING_SIZE (127 * 3 + 1)\n\n/**\n * usb_cache_string - read a string descriptor and cache it for later use\n * @udev: the device whose string descriptor is being read\n * @index: the descriptor index\n *\n * Return: A pointer to a kmalloc'ed buffer containing the descriptor string,\n * or %NULL if the index is 0 or the string could not be read.\n */\nchar *usb_cache_string(struct usb_device *udev, int index)\n{\n\tchar *buf;\n\tchar *smallbuf = NULL;\n\tint len;\n\n\tif (index <= 0)\n\t\treturn NULL;\n\n\tbuf = kmalloc(MAX_USB_STRING_SIZE, GFP_NOIO);\n\tif (buf) {\n\t\tlen = usb_string(udev, index, buf, MAX_USB_STRING_SIZE);\n\t\tif (len > 0) {\n\t\t\tsmallbuf = kmalloc(++len, GFP_NOIO);\n\t\t\tif (!smallbuf)\n\t\t\t\treturn buf;\n\t\t\tmemcpy(smallbuf, buf, len);\n\t\t}\n\t\tkfree(buf);\n\t}\n\treturn smallbuf;\n}\n\n/*\n * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)\n * @dev: the device whose device descriptor is being updated\n * @size: how much of the descriptor to read\n * Context: !in_interrupt ()\n *\n * Updates the copy of the device descriptor stored in the device structure,\n * which dedicates space for this purpose.\n *\n * Not exported, only for use by the core.  If drivers really want to read\n * the device descriptor directly, they can call usb_get_descriptor() with\n * type = USB_DT_DEVICE and index = 0.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: The number of bytes received on success, or else the status code\n * returned by the underlying usb_control_msg() call.\n */\nint usb_get_device_descriptor(struct usb_device *dev, unsigned int size)\n{\n\tstruct usb_device_descriptor *desc;\n\tint ret;\n\n\tif (size > sizeof(*desc))\n\t\treturn -EINVAL;\n\tdesc = kmalloc(sizeof(*desc), GFP_NOIO);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);\n\tif (ret >= 0)\n\t\tmemcpy(&dev->descriptor, desc, size);\n\tkfree(desc);\n\treturn ret;\n}\n\n/*\n * usb_set_isoch_delay - informs the device of the packet transmit delay\n * @dev: the device whose delay is to be informed\n * Context: !in_interrupt()\n *\n * Since this is an optional request, we don't bother if it fails.\n */\nint usb_set_isoch_delay(struct usb_device *dev)\n{\n\t/* skip hub devices */\n\tif (dev->descriptor.bDeviceClass == USB_CLASS_HUB)\n\t\treturn 0;\n\n\t/* skip non-SS/non-SSP devices */\n\tif (dev->speed < USB_SPEED_SUPER)\n\t\treturn 0;\n\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tUSB_REQ_SET_ISOCH_DELAY,\n\t\t\tUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\t\tdev->hub_delay, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n/**\n * usb_get_status - issues a GET_STATUS call\n * @dev: the device whose status is being checked\n * @recip: USB_RECIP_*; for device, interface, or endpoint\n * @type: USB_STATUS_TYPE_*; for standard or PTM status types\n * @target: zero (for device), else interface or endpoint number\n * @data: pointer to two bytes of bitmap data\n * Context: !in_interrupt ()\n *\n * Returns device, interface, or endpoint status.  Normally only of\n * interest to see if the device is self powered, or has enabled the\n * remote wakeup facility; or whether a bulk or interrupt endpoint\n * is halted (\"stalled\").\n *\n * Bits in these status bitmaps are set using the SET_FEATURE request,\n * and cleared using the CLEAR_FEATURE request.  The usb_clear_halt()\n * function should be used to clear halt (\"stall\") status.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Returns 0 and the status value in *@data (in host byte order) on success,\n * or else the status code from the underlying usb_control_msg() call.\n */\nint usb_get_status(struct usb_device *dev, int recip, int type, int target,\n\t\tvoid *data)\n{\n\tint ret;\n\tvoid *status;\n\tint length;\n\n\tswitch (type) {\n\tcase USB_STATUS_TYPE_STANDARD:\n\t\tlength = 2;\n\t\tbreak;\n\tcase USB_STATUS_TYPE_PTM:\n\t\tif (recip != USB_RECIP_DEVICE)\n\t\t\treturn -EINVAL;\n\n\t\tlength = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstatus =  kmalloc(length, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | recip, USB_STATUS_TYPE_STANDARD,\n\t\ttarget, status, length, USB_CTRL_GET_TIMEOUT);\n\n\tswitch (ret) {\n\tcase 4:\n\t\tif (type != USB_STATUS_TYPE_PTM) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t*(u32 *) data = le32_to_cpu(*(__le32 *) status);\n\t\tret = 0;\n\t\tbreak;\n\tcase 2:\n\t\tif (type != USB_STATUS_TYPE_STANDARD) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t*(u16 *) data = le16_to_cpu(*(__le16 *) status);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t}\n\n\tkfree(status);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_get_status);\n\n/**\n * usb_clear_halt - tells device to clear endpoint halt/stall condition\n * @dev: device whose endpoint is halted\n * @pipe: endpoint \"pipe\" being cleared\n * Context: !in_interrupt ()\n *\n * This is used to clear halt conditions for bulk and interrupt endpoints,\n * as reported by URB completion status.  Endpoints that are halted are\n * sometimes referred to as being \"stalled\".  Such endpoints are unable\n * to transmit or receive data until the halt status is cleared.  Any URBs\n * queued for such an endpoint should normally be unlinked by the driver\n * before clearing the halt condition, as described in sections 5.7.5\n * and 5.8.5 of the USB 2.0 spec.\n *\n * Note that control and isochronous endpoints don't halt, although control\n * endpoints report \"protocol stall\" (for unsupported requests) using the\n * same status code used to report a true stall.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Return: Zero on success, or else the status code returned by the\n * underlying usb_control_msg() call.\n */\nint usb_clear_halt(struct usb_device *dev, int pipe)\n{\n\tint result;\n\tint endp = usb_pipeendpoint(pipe);\n\n\tif (usb_pipein(pipe))\n\t\tendp |= USB_DIR_IN;\n\n\t/* we don't care if it wasn't halted first. in fact some devices\n\t * (like some ibmcam model 1 units) seem to expect hosts to make\n\t * this request for iso endpoints, which can't halt!\n\t */\n\tresult = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\n\t\tUSB_ENDPOINT_HALT, endp, NULL, 0,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t/* don't un-halt or force to DATA0 except on success */\n\tif (result < 0)\n\t\treturn result;\n\n\t/* NOTE:  seems like Microsoft and Apple don't bother verifying\n\t * the clear \"took\", so some devices could lock up if you check...\n\t * such as the Hagiwara FlashGate DUAL.  So we won't bother.\n\t *\n\t * NOTE:  make sure the logic here doesn't diverge much from\n\t * the copy in usb-storage, for as long as we need two copies.\n\t */\n\n\tusb_reset_endpoint(dev, endp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_clear_halt);\n\nstatic int create_intf_ep_devs(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tif (intf->ep_devs_created || intf->unregistering)\n\t\treturn 0;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\t(void) usb_create_ep_devs(&intf->dev, &alt->endpoint[i], udev);\n\tintf->ep_devs_created = 1;\n\treturn 0;\n}\n\nstatic void remove_intf_ep_devs(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tif (!intf->ep_devs_created)\n\t\treturn;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\tusb_remove_ep_devs(&alt->endpoint[i]);\n\tintf->ep_devs_created = 0;\n}\n\n/**\n * usb_disable_endpoint -- Disable an endpoint by address\n * @dev: the device whose endpoint is being disabled\n * @epaddr: the endpoint's address.  Endpoint number for output,\n *\tendpoint number + USB_DIR_IN for input\n * @reset_hardware: flag to erase any endpoint state stored in the\n *\tcontroller hardware\n *\n * Disables the endpoint for URB submission and nukes all pending URBs.\n * If @reset_hardware is set then also deallocates hcd/hardware state\n * for the endpoint.\n */\nvoid usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,\n\t\tbool reset_hardware)\n{\n\tunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\n\tstruct usb_host_endpoint *ep;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (usb_endpoint_out(epaddr)) {\n\t\tep = dev->ep_out[epnum];\n\t\tif (reset_hardware)\n\t\t\tdev->ep_out[epnum] = NULL;\n\t} else {\n\t\tep = dev->ep_in[epnum];\n\t\tif (reset_hardware)\n\t\t\tdev->ep_in[epnum] = NULL;\n\t}\n\tif (ep) {\n\t\tep->enabled = 0;\n\t\tusb_hcd_flush_endpoint(dev, ep);\n\t\tif (reset_hardware)\n\t\t\tusb_hcd_disable_endpoint(dev, ep);\n\t}\n}\n\n/**\n * usb_reset_endpoint - Reset an endpoint's state.\n * @dev: the device whose endpoint is to be reset\n * @epaddr: the endpoint's address.  Endpoint number for output,\n *\tendpoint number + USB_DIR_IN for input\n *\n * Resets any host-side endpoint state such as the toggle bit,\n * sequence number or current window.\n */\nvoid usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr)\n{\n\tunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\n\tstruct usb_host_endpoint *ep;\n\n\tif (usb_endpoint_out(epaddr))\n\t\tep = dev->ep_out[epnum];\n\telse\n\t\tep = dev->ep_in[epnum];\n\tif (ep)\n\t\tusb_hcd_reset_endpoint(dev, ep);\n}\nEXPORT_SYMBOL_GPL(usb_reset_endpoint);\n\n\n/**\n * usb_disable_interface -- Disable all endpoints for an interface\n * @dev: the device whose interface is being disabled\n * @intf: pointer to the interface descriptor\n * @reset_hardware: flag to erase any endpoint state stored in the\n *\tcontroller hardware\n *\n * Disables all the endpoints for the interface's current altsetting.\n */\nvoid usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,\n\t\tbool reset_hardware)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\tusb_disable_endpoint(dev,\n\t\t\t\talt->endpoint[i].desc.bEndpointAddress,\n\t\t\t\treset_hardware);\n\t}\n}\n\n/**\n * usb_disable_device - Disable all the endpoints for a USB device\n * @dev: the device whose endpoints are being disabled\n * @skip_ep0: 0 to disable endpoint 0, 1 to skip it.\n *\n * Disables all the device's endpoints, potentially including endpoint 0.\n * Deallocates hcd/hardware state for the endpoints (nuking all or most\n * pending urbs) and usbcore state for the interfaces, so that usbcore\n * must usb_set_configuration() before any interfaces could be used.\n */\nvoid usb_disable_device(struct usb_device *dev, int skip_ep0)\n{\n\tint i;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\t/* getting rid of interfaces will disconnect\n\t * any drivers bound to them (a key side effect)\n\t */\n\tif (dev->actconfig) {\n\t\t/*\n\t\t * FIXME: In order to avoid self-deadlock involving the\n\t\t * bandwidth_mutex, we have to mark all the interfaces\n\t\t * before unregistering any of them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\n\t\t\tdev->actconfig->interface[i]->unregistering = 1;\n\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tstruct usb_interface\t*interface;\n\n\t\t\t/* remove this interface if it has been registered */\n\t\t\tinterface = dev->actconfig->interface[i];\n\t\t\tif (!device_is_registered(&interface->dev))\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->dev, \"unregistering interface %s\\n\",\n\t\t\t\tdev_name(&interface->dev));\n\t\t\tremove_intf_ep_devs(interface);\n\t\t\tdevice_del(&interface->dev);\n\t\t}\n\n\t\t/* Now that the interfaces are unbound, nobody should\n\t\t * try to access them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tput_device(&dev->actconfig->interface[i]->dev);\n\t\t\tdev->actconfig->interface[i] = NULL;\n\t\t}\n\n\t\tusb_disable_usb2_hardware_lpm(dev);\n\t\tusb_unlocked_disable_lpm(dev);\n\t\tusb_disable_ltm(dev);\n\n\t\tdev->actconfig = NULL;\n\t\tif (dev->state == USB_STATE_CONFIGURED)\n\t\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t}\n\n\tdev_dbg(&dev->dev, \"%s nuking %s URBs\\n\", __func__,\n\t\tskip_ep0 ? \"non-ep0\" : \"all\");\n\tif (hcd->driver->check_bandwidth) {\n\t\t/* First pass: Cancel URBs, leave endpoint pointers intact. */\n\t\tfor (i = skip_ep0; i < 16; ++i) {\n\t\t\tusb_disable_endpoint(dev, i, false);\n\t\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, false);\n\t\t}\n\t\t/* Remove endpoints from the host controller internal state */\n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\t/* Second pass: remove endpoint pointers */\n\t}\n\tfor (i = skip_ep0; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n}\n\n/**\n * usb_enable_endpoint - Enable an endpoint for USB communications\n * @dev: the device whose interface is being enabled\n * @ep: the endpoint\n * @reset_ep: flag to reset the endpoint state\n *\n * Resets the endpoint state if asked, and sets dev->ep_{in,out} pointers.\n * For control endpoints, both the input and output sides are handled.\n */\nvoid usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,\n\t\tbool reset_ep)\n{\n\tint epnum = usb_endpoint_num(&ep->desc);\n\tint is_out = usb_endpoint_dir_out(&ep->desc);\n\tint is_control = usb_endpoint_xfer_control(&ep->desc);\n\n\tif (reset_ep)\n\t\tusb_hcd_reset_endpoint(dev, ep);\n\tif (is_out || is_control)\n\t\tdev->ep_out[epnum] = ep;\n\tif (!is_out || is_control)\n\t\tdev->ep_in[epnum] = ep;\n\tep->enabled = 1;\n}\n\n/**\n * usb_enable_interface - Enable all the endpoints for an interface\n * @dev: the device whose interface is being enabled\n * @intf: pointer to the interface descriptor\n * @reset_eps: flag to reset the endpoints' state\n *\n * Enables all the endpoints for the interface's current altsetting.\n */\nvoid usb_enable_interface(struct usb_device *dev,\n\t\tstruct usb_interface *intf, bool reset_eps)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\tusb_enable_endpoint(dev, &alt->endpoint[i], reset_eps);\n}\n\n/**\n * usb_set_interface - Makes a particular alternate setting be current\n * @dev: the device whose interface is being updated\n * @interface: the interface being updated\n * @alternate: the setting being chosen.\n * Context: !in_interrupt ()\n *\n * This is used to enable data transfers on interfaces that may not\n * be enabled by default.  Not all devices support such configurability.\n * Only the driver bound to an interface may change its setting.\n *\n * Within any given configuration, each interface may have several\n * alternative settings.  These are often used to control levels of\n * bandwidth consumption.  For example, the default setting for a high\n * speed interrupt endpoint may not send more than 64 bytes per microframe,\n * while interrupt transfers of up to 3KBytes per microframe are legal.\n * Also, isochronous endpoints may never be part of an\n * interface's default setting.  To access such bandwidth, alternate\n * interface settings must be made current.\n *\n * Note that in the Linux USB subsystem, bandwidth associated with\n * an endpoint in a given alternate setting is not reserved until an URB\n * is submitted that needs that bandwidth.  Some other operating systems\n * allocate bandwidth early, when a configuration is chosen.\n *\n * xHCI reserves bandwidth and configures the alternate setting in\n * usb_hcd_alloc_bandwidth(). If it fails the original interface altsetting\n * may be disabled. Drivers cannot rely on any particular alternate\n * setting being in effect after a failure.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n * Also, drivers must not change altsettings while urbs are scheduled for\n * endpoints in that interface; all such urbs must first be completed\n * (perhaps forced by unlinking).\n *\n * Return: Zero on success, or else the status code returned by the\n * underlying usb_control_msg() call.\n */\nint usb_set_interface(struct usb_device *dev, int interface, int alternate)\n{\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alt;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint i, ret, manual = 0;\n\tunsigned int epaddr;\n\tunsigned int pipe;\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\tiface = usb_ifnum_to_if(dev, interface);\n\tif (!iface) {\n\t\tdev_dbg(&dev->dev, \"selecting invalid interface %d\\n\",\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\tif (iface->unregistering)\n\t\treturn -ENODEV;\n\n\talt = usb_altnum_to_altsetting(iface, alternate);\n\tif (!alt) {\n\t\tdev_warn(&dev->dev, \"selecting invalid altsetting %d\\n\",\n\t\t\t alternate);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * usb3 hosts configure the interface in usb_hcd_alloc_bandwidth,\n\t * including freeing dropped endpoint ring buffers.\n\t * Make sure the interface endpoints are flushed before that\n\t */\n\tusb_disable_interface(dev, iface, false);\n\n\t/* Make sure we have enough bandwidth for this alternate interface.\n\t * Remove the current alt setting and add the new alt setting.\n\t */\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the new alt setting is installed,\n\t * so that the xHCI driver can recalculate the U1/U2 timeouts.\n\t */\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&iface->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t/* Changing alt-setting also frees any allocated streams */\n\tfor (i = 0; i < iface->cur_altsetting->desc.bNumEndpoints; i++)\n\t\tiface->cur_altsetting->endpoint[i].streams = 0;\n\n\tret = usb_hcd_alloc_bandwidth(dev, NULL, iface->cur_altsetting, alt);\n\tif (ret < 0) {\n\t\tdev_info(&dev->dev, \"Not enough bandwidth for altsetting %d\\n\",\n\t\t\t\talternate);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\n\tif (dev->quirks & USB_QUIRK_NO_SET_INTF)\n\t\tret = -EPIPE;\n\telse\n\t\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t   USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,\n\t\t\t\t   alternate, interface, NULL, 0, 5000);\n\n\t/* 9.4.10 says devices don't need this and are free to STALL the\n\t * request if the interface only has one alternate setting.\n\t */\n\tif (ret == -EPIPE && iface->num_altsetting == 1) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"manual set_interface for iface %d, alt %d\\n\",\n\t\t\tinterface, alternate);\n\t\tmanual = 1;\n\t} else if (ret < 0) {\n\t\t/* Re-instate the old alt setting */\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, alt, iface->cur_altsetting);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\t/* FIXME drivers shouldn't need to replicate/bugfix the logic here\n\t * when they implement async or easily-killable versions of this or\n\t * other \"should-be-internal\" functions (like clear_halt).\n\t * should hcd+usbcore postprocess control requests?\n\t */\n\n\t/* prevent submissions using previous endpoint settings */\n\tif (iface->cur_altsetting != alt) {\n\t\tremove_intf_ep_devs(iface);\n\t\tusb_remove_sysfs_intf_files(iface);\n\t}\n\tusb_disable_interface(dev, iface, true);\n\n\tiface->cur_altsetting = alt;\n\n\t/* Now that the interface is installed, re-enable LPM. */\n\tusb_unlocked_enable_lpm(dev);\n\n\t/* If the interface only has one altsetting and the device didn't\n\t * accept the request, we attempt to carry out the equivalent action\n\t * by manually clearing the HALT feature for each endpoint in the\n\t * new altsetting.\n\t */\n\tif (manual) {\n\t\tfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\n\t\t\tepaddr = alt->endpoint[i].desc.bEndpointAddress;\n\t\t\tpipe = __create_pipe(dev,\n\t\t\t\t\tUSB_ENDPOINT_NUMBER_MASK & epaddr) |\n\t\t\t\t\t(usb_endpoint_out(epaddr) ?\n\t\t\t\t\tUSB_DIR_OUT : USB_DIR_IN);\n\n\t\t\tusb_clear_halt(dev, pipe);\n\t\t}\n\t}\n\n\t/* 9.1.1.5: reset toggles for all endpoints in the new altsetting\n\t *\n\t * Note:\n\t * Despite EP0 is always present in all interfaces/AS, the list of\n\t * endpoints from the descriptor does not contain EP0. Due to its\n\t * omnipresence one might expect EP0 being considered \"affected\" by\n\t * any SetInterface request and hence assume toggles need to be reset.\n\t * However, EP0 toggles are re-synced for every individual transfer\n\t * during the SETUP stage - hence EP0 toggles are \"don't care\" here.\n\t * (Likewise, EP0 never \"halts\" on well designed devices.)\n\t */\n\tusb_enable_interface(dev, iface, true);\n\tif (device_is_registered(&iface->dev)) {\n\t\tusb_create_sysfs_intf_files(iface);\n\t\tcreate_intf_ep_devs(iface);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_interface);\n\n/**\n * usb_reset_configuration - lightweight device reset\n * @dev: the device whose configuration is being reset\n *\n * This issues a standard SET_CONFIGURATION request to the device using\n * the current configuration.  The effect is to reset most USB-related\n * state in the device, including interface altsettings (reset to zero),\n * endpoint halts (cleared), and endpoint state (only for bulk and interrupt\n * endpoints).  Other usbcore state is unchanged, including bindings of\n * usb device drivers to interfaces.\n *\n * Because this affects multiple interfaces, avoid using this with composite\n * (multi-interface) devices.  Instead, the driver for each interface may\n * use usb_set_interface() on the interfaces it claims.  Be careful though;\n * some devices don't support the SET_INTERFACE request, and others won't\n * reset all the interface state (notably endpoint state).  Resetting the whole\n * configuration would affect other drivers' interfaces.\n *\n * The caller must own the device lock.\n *\n * Return: Zero on success, else a negative error code.\n */\nint usb_reset_configuration(struct usb_device *dev)\n{\n\tint\t\t\ti, retval;\n\tstruct usb_host_config\t*config;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\t/* caller must have locked the device and must own\n\t * the usb bus readlock (so driver bindings are stable);\n\t * calls during probe() are fine\n\t */\n\n\tfor (i = 1; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n\n\tconfig = dev->actconfig;\n\tretval = 0;\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the configuration is reset, so\n\t * that the xHCI driver can recalculate the U1/U2 timeouts.\n\t */\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t/* Make sure we have enough bandwidth for each alternate setting 0 */\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tif (alt != intf->cur_altsetting)\n\t\t\tretval = usb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\tintf->cur_altsetting, alt);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\t/* If not, reinstate the old alternate settings */\n\tif (retval < 0) {\nreset_old_alts:\n\t\tfor (i--; i >= 0; i--) {\n\t\t\tstruct usb_interface *intf = config->interface[i];\n\t\t\tstruct usb_host_interface *alt;\n\n\t\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\t\tif (!alt)\n\t\t\t\talt = &intf->altsetting[0];\n\t\t\tif (alt != intf->cur_altsetting)\n\t\t\t\tusb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\t\talt, intf->cur_altsetting);\n\t\t}\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn retval;\n\t}\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0)\n\t\tgoto reset_old_alts;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\t/* re-init hc/hcd interface/endpoint state */\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\n\t\t/* No altsetting 0?  We'll assume the first altsetting.\n\t\t * We could use a GetInterface call, but if a device is\n\t\t * so non-compliant that it doesn't have altsetting 0\n\t\t * then I wouldn't trust its reply anyway.\n\t\t */\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\n\t\tif (alt != intf->cur_altsetting) {\n\t\t\tremove_intf_ep_devs(intf);\n\t\t\tusb_remove_sysfs_intf_files(intf);\n\t\t}\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tif (device_is_registered(&intf->dev)) {\n\t\t\tusb_create_sysfs_intf_files(intf);\n\t\t\tcreate_intf_ep_devs(intf);\n\t\t}\n\t}\n\t/* Now that the interfaces are installed, re-enable LPM. */\n\tusb_unlocked_enable_lpm(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_reset_configuration);\n\nstatic void usb_release_interface(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_interface_cache *intfc =\n\t\t\taltsetting_to_usb_interface_cache(intf->altsetting);\n\n\tkref_put(&intfc->ref, usb_release_interface_cache);\n\tusb_put_dev(interface_to_usbdev(intf));\n\tof_node_put(dev->of_node);\n\tkfree(intf);\n}\n\n/*\n * usb_deauthorize_interface - deauthorize an USB interface\n *\n * @intf: USB interface structure\n */\nvoid usb_deauthorize_interface(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\n\tdevice_lock(dev->parent);\n\n\tif (intf->authorized) {\n\t\tdevice_lock(dev);\n\t\tintf->authorized = 0;\n\t\tdevice_unlock(dev);\n\n\t\tusb_forced_unbind_intf(intf);\n\t}\n\n\tdevice_unlock(dev->parent);\n}\n\n/*\n * usb_authorize_interface - authorize an USB interface\n *\n * @intf: USB interface structure\n */\nvoid usb_authorize_interface(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\n\tif (!intf->authorized) {\n\t\tdevice_lock(dev);\n\t\tintf->authorized = 1; /* authorize interface */\n\t\tdevice_unlock(dev);\n\t}\n}\n\nstatic int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alt;\n\n\tintf = to_usb_interface(dev);\n\tusb_dev = interface_to_usbdev(intf);\n\talt = intf->cur_altsetting;\n\n\tif (add_uevent_var(env, \"INTERFACE=%d/%d/%d\",\n\t\t   alt->desc.bInterfaceClass,\n\t\t   alt->desc.bInterfaceSubClass,\n\t\t   alt->desc.bInterfaceProtocol))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env,\n\t\t   \"MODALIAS=usb:\"\n\t\t   \"v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\",\n\t\t   le16_to_cpu(usb_dev->descriptor.idVendor),\n\t\t   le16_to_cpu(usb_dev->descriptor.idProduct),\n\t\t   le16_to_cpu(usb_dev->descriptor.bcdDevice),\n\t\t   usb_dev->descriptor.bDeviceClass,\n\t\t   usb_dev->descriptor.bDeviceSubClass,\n\t\t   usb_dev->descriptor.bDeviceProtocol,\n\t\t   alt->desc.bInterfaceClass,\n\t\t   alt->desc.bInterfaceSubClass,\n\t\t   alt->desc.bInterfaceProtocol,\n\t\t   alt->desc.bInterfaceNumber))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct device_type usb_if_device_type = {\n\t.name =\t\t\"usb_interface\",\n\t.release =\tusb_release_interface,\n\t.uevent =\tusb_if_uevent,\n};\n\nstatic struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,\n\t\t\t\t\t\tstruct usb_host_config *config,\n\t\t\t\t\t\tu8 inum)\n{\n\tstruct usb_interface_assoc_descriptor *retval = NULL;\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\tint first_intf;\n\tint last_intf;\n\tint i;\n\n\tfor (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {\n\t\tintf_assoc = config->intf_assoc[i];\n\t\tif (intf_assoc->bInterfaceCount == 0)\n\t\t\tcontinue;\n\n\t\tfirst_intf = intf_assoc->bFirstInterface;\n\t\tlast_intf = first_intf + (intf_assoc->bInterfaceCount - 1);\n\t\tif (inum >= first_intf && inum <= last_intf) {\n\t\t\tif (!retval)\n\t\t\t\tretval = intf_assoc;\n\t\t\telse\n\t\t\t\tdev_err(&dev->dev, \"Interface #%d referenced\"\n\t\t\t\t\t\" by multiple IADs\\n\", inum);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n\n/*\n * Internal function to queue a device reset\n * See usb_queue_reset_device() for more details\n */\nstatic void __usb_queue_reset_device(struct work_struct *ws)\n{\n\tint rc;\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, reset_ws);\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\n\trc = usb_lock_device_for_reset(udev, iface);\n\tif (rc >= 0) {\n\t\tusb_reset_device(udev);\n\t\tusb_unlock_device(udev);\n\t}\n\tusb_put_intf(iface);\t/* Undo _get_ in usb_queue_reset_device() */\n}\n\n\n/*\n * usb_set_configuration - Makes a particular device setting be current\n * @dev: the device whose configuration is being updated\n * @configuration: the configuration being chosen.\n * Context: !in_interrupt(), caller owns the device lock\n *\n * This is used to enable non-default device modes.  Not all devices\n * use this kind of configurability; many devices only have one\n * configuration.\n *\n * @configuration is the value of the configuration to be installed.\n * According to the USB spec (e.g. section 9.1.1.5), configuration values\n * must be non-zero; a value of zero indicates that the device in\n * unconfigured.  However some devices erroneously use 0 as one of their\n * configuration values.  To help manage such devices, this routine will\n * accept @configuration = -1 as indicating the device should be put in\n * an unconfigured state.\n *\n * USB device configurations may affect Linux interoperability,\n * power consumption and the functionality available.  For example,\n * the default configuration is limited to using 100mA of bus power,\n * so that when certain device functionality requires more power,\n * and the device is bus powered, that functionality should be in some\n * non-default device configuration.  Other device modes may also be\n * reflected as configuration options, such as whether two ISDN\n * channels are available independently; and choosing between open\n * standard device protocols (like CDC) or proprietary ones.\n *\n * Note that a non-authorized device (dev->authorized == 0) will only\n * be put in unconfigured mode.\n *\n * Note that USB has an additional level of device configurability,\n * associated with interfaces.  That configurability is accessed using\n * usb_set_interface().\n *\n * This call is synchronous. The calling context must be able to sleep,\n * must own the device lock, and must not hold the driver model's USB\n * bus mutex; usb interface driver probe() methods cannot use this routine.\n *\n * Returns zero on success, or else the status code returned by the\n * underlying call that failed.  On successful completion, each interface\n * in the original device configuration has been destroyed, and each one\n * in the new configuration has been probed by all relevant usb device\n * drivers currently known to the kernel.\n */\nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n\tint i, ret;\n\tstruct usb_host_config *cp = NULL;\n\tstruct usb_interface **new_interfaces = NULL;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint n, nintf;\n\n\tif (dev->authorized == 0 || configuration == -1)\n\t\tconfiguration = 0;\n\telse {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\n\t\t\tif (dev->config[i].desc.bConfigurationValue ==\n\t\t\t\t\tconfiguration) {\n\t\t\t\tcp = &dev->config[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((!cp && configuration != 0))\n\t\treturn -EINVAL;\n\n\t/* The USB spec says configuration 0 means unconfigured.\n\t * But if a device includes a configuration numbered 0,\n\t * we will accept it as a correctly configured state.\n\t * Use -1 if you really want to unconfigure the device.\n\t */\n\tif (cp && configuration == 0)\n\t\tdev_warn(&dev->dev, \"config 0 descriptor??\\n\");\n\n\t/* Allocate memory for new interfaces before doing anything else,\n\t * so that if we run out then nothing will have changed. */\n\tn = nintf = 0;\n\tif (cp) {\n\t\tnintf = cp->desc.bNumInterfaces;\n\t\tnew_interfaces = kmalloc_array(nintf, sizeof(*new_interfaces),\n\t\t\t\t\t       GFP_NOIO);\n\t\tif (!new_interfaces)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (; n < nintf; ++n) {\n\t\t\tnew_interfaces[n] = kzalloc(\n\t\t\t\t\tsizeof(struct usb_interface),\n\t\t\t\t\tGFP_NOIO);\n\t\t\tif (!new_interfaces[n]) {\n\t\t\t\tret = -ENOMEM;\nfree_interfaces:\n\t\t\t\twhile (--n >= 0)\n\t\t\t\t\tkfree(new_interfaces[n]);\n\t\t\t\tkfree(new_interfaces);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\ti = dev->bus_mA - usb_get_max_power(dev, cp);\n\t\tif (i < 0)\n\t\t\tdev_warn(&dev->dev, \"new config #%d exceeds power \"\n\t\t\t\t\t\"limit by %dmA\\n\",\n\t\t\t\t\tconfiguration, -i);\n\t}\n\n\t/* Wake up the device so we can send it the Set-Config request */\n\tret = usb_autoresume_device(dev);\n\tif (ret)\n\t\tgoto free_interfaces;\n\n\t/* if it's already configured, clear out old state first.\n\t * getting rid of old interfaces means unbinding their drivers.\n\t */\n\tif (dev->state != USB_STATE_ADDRESS)\n\t\tusb_disable_device(dev, 1);\t/* Skip ep0 */\n\n\t/* Get rid of pending async Set-Config requests for this device */\n\tcancel_async_set_config(dev);\n\n\t/* Make sure we have bandwidth (and available HCD resources) for this\n\t * configuration.  Remove endpoints from the schedule if we're dropping\n\t * this configuration to set configuration 0.  After this point, the\n\t * host controller will not allow submissions to dropped endpoints.  If\n\t * this call fails, the device state is unchanged.\n\t */\n\tmutex_lock(hcd->bandwidth_mutex);\n\t/* Disable LPM, and re-enable it once the new configuration is\n\t * installed, so that the xHCI driver can recalculate the U1/U2\n\t * timeouts.\n\t */\n\tif (dev->actconfig && usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto free_interfaces;\n\t}\n\tret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (dev->actconfig)\n\t\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tusb_autosuspend_device(dev);\n\t\tgoto free_interfaces;\n\t}\n\n\t/*\n\t * Initialize the new interface structures and the\n\t * hc/hcd/usbcore interface/endpoint state.\n\t */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface_cache *intfc;\n\t\tstruct usb_interface *intf;\n\t\tstruct usb_host_interface *alt;\n\t\tu8 ifnum;\n\n\t\tcp->interface[i] = intf = new_interfaces[i];\n\t\tintfc = cp->intf_cache[i];\n\t\tintf->altsetting = intfc->altsetting;\n\t\tintf->num_altsetting = intfc->num_altsetting;\n\t\tintf->authorized = !!HCD_INTF_AUTHORIZED(hcd);\n\t\tkref_get(&intfc->ref);\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\n\t\t/* No altsetting 0?  We'll assume the first altsetting.\n\t\t * We could use a GetInterface call, but if a device is\n\t\t * so non-compliant that it doesn't have altsetting 0\n\t\t * then I wouldn't trust its reply anyway.\n\t\t */\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\n\t\tifnum = alt->desc.bInterfaceNumber;\n\t\tintf->intf_assoc = find_iad(dev, cp, ifnum);\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tintf->dev.parent = &dev->dev;\n\t\tif (usb_of_has_combined_node(dev)) {\n\t\t\tdevice_set_of_node_from_dev(&intf->dev, &dev->dev);\n\t\t} else {\n\t\t\tintf->dev.of_node = usb_of_get_interface_node(dev,\n\t\t\t\t\tconfiguration, ifnum);\n\t\t}\n\t\tACPI_COMPANION_SET(&intf->dev, ACPI_COMPANION(&dev->dev));\n\t\tintf->dev.driver = NULL;\n\t\tintf->dev.bus = &usb_bus_type;\n\t\tintf->dev.type = &usb_if_device_type;\n\t\tintf->dev.groups = usb_interface_groups;\n\t\t/*\n\t\t * Please refer to usb_alloc_dev() to see why we set\n\t\t * dma_mask and dma_pfn_offset.\n\t\t */\n\t\tintf->dev.dma_mask = dev->dev.dma_mask;\n\t\tintf->dev.dma_pfn_offset = dev->dev.dma_pfn_offset;\n\t\tINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);\n\t\tintf->minor = -1;\n\t\tdevice_initialize(&intf->dev);\n\t\tpm_runtime_no_callbacks(&intf->dev);\n\t\tdev_set_name(&intf->dev, \"%d-%s:%d.%d\", dev->bus->busnum,\n\t\t\t\tdev->devpath, configuration, ifnum);\n\t\tusb_get_dev(dev);\n\t}\n\tkfree(new_interfaces);\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0 && cp) {\n\t\t/*\n\t\t * All the old state is gone, so what else can we do?\n\t\t * The device is probably useless now anyway.\n\t\t */\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tfor (i = 0; i < nintf; ++i) {\n\t\t\tusb_disable_interface(dev, cp->interface[i], true);\n\t\t\tput_device(&cp->interface[i]->dev);\n\t\t\tcp->interface[i] = NULL;\n\t\t}\n\t\tcp = NULL;\n\t}\n\n\tdev->actconfig = cp;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\tif (!cp) {\n\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\n\t\t/* Leave LPM disabled while the device is unconfigured. */\n\t\tusb_autosuspend_device(dev);\n\t\treturn ret;\n\t}\n\tusb_set_device_state(dev, USB_STATE_CONFIGURED);\n\n\tif (cp->string == NULL &&\n\t\t\t!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\n\t\tcp->string = usb_cache_string(dev, cp->desc.iConfiguration);\n\n\t/* Now that the interfaces are installed, re-enable LPM. */\n\tusb_unlocked_enable_lpm(dev);\n\t/* Enable LTM if it was turned off by usb_disable_device. */\n\tusb_enable_ltm(dev);\n\n\t/* Now that all the interfaces are set up, register them\n\t * to trigger binding of drivers to interfaces.  probe()\n\t * routines may install different altsettings and may\n\t * claim() any interfaces not yet bound.  Many class drivers\n\t * need that: CDC, audio, video, etc.\n\t */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface *intf = cp->interface[i];\n\n\t\tif (intf->dev.of_node &&\n\t\t    !of_device_is_available(intf->dev.of_node)) {\n\t\t\tdev_info(&dev->dev, \"skipping disabled interface %d\\n\",\n\t\t\t\t intf->cur_altsetting->desc.bInterfaceNumber);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"adding %s (config #%d, interface %d)\\n\",\n\t\t\tdev_name(&intf->dev), configuration,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\tdevice_enable_async_suspend(&intf->dev);\n\t\tret = device_add(&intf->dev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&dev->dev, \"device_add(%s) --> %d\\n\",\n\t\t\t\tdev_name(&intf->dev), ret);\n\t\t\tcontinue;\n\t\t}\n\t\tcreate_intf_ep_devs(intf);\n\t}\n\n\tusb_autosuspend_device(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_configuration);\n\nstatic LIST_HEAD(set_config_list);\nstatic DEFINE_SPINLOCK(set_config_lock);\n\nstruct set_config_request {\n\tstruct usb_device\t*udev;\n\tint\t\t\tconfig;\n\tstruct work_struct\twork;\n\tstruct list_head\tnode;\n};\n\n/* Worker routine for usb_driver_set_configuration() */\nstatic void driver_set_config_work(struct work_struct *work)\n{\n\tstruct set_config_request *req =\n\t\tcontainer_of(work, struct set_config_request, work);\n\tstruct usb_device *udev = req->udev;\n\n\tusb_lock_device(udev);\n\tspin_lock(&set_config_lock);\n\tlist_del(&req->node);\n\tspin_unlock(&set_config_lock);\n\n\tif (req->config >= -1)\t\t/* Is req still valid? */\n\t\tusb_set_configuration(udev, req->config);\n\tusb_unlock_device(udev);\n\tusb_put_dev(udev);\n\tkfree(req);\n}\n\n/* Cancel pending Set-Config requests for a device whose configuration\n * was just changed\n */\nstatic void cancel_async_set_config(struct usb_device *udev)\n{\n\tstruct set_config_request *req;\n\n\tspin_lock(&set_config_lock);\n\tlist_for_each_entry(req, &set_config_list, node) {\n\t\tif (req->udev == udev)\n\t\t\treq->config = -999;\t/* Mark as cancelled */\n\t}\n\tspin_unlock(&set_config_lock);\n}\n\n/**\n * usb_driver_set_configuration - Provide a way for drivers to change device configurations\n * @udev: the device whose configuration is being updated\n * @config: the configuration being chosen.\n * Context: In process context, must be able to sleep\n *\n * Device interface drivers are not allowed to change device configurations.\n * This is because changing configurations will destroy the interface the\n * driver is bound to and create new ones; it would be like a floppy-disk\n * driver telling the computer to replace the floppy-disk drive with a\n * tape drive!\n *\n * Still, in certain specialized circumstances the need may arise.  This\n * routine gets around the normal restrictions by using a work thread to\n * submit the change-config request.\n *\n * Return: 0 if the request was successfully queued, error code otherwise.\n * The caller has no way to know whether the queued request will eventually\n * succeed.\n */\nint usb_driver_set_configuration(struct usb_device *udev, int config)\n{\n\tstruct set_config_request *req;\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->udev = udev;\n\treq->config = config;\n\tINIT_WORK(&req->work, driver_set_config_work);\n\n\tspin_lock(&set_config_lock);\n\tlist_add(&req->node, &set_config_list);\n\tspin_unlock(&set_config_lock);\n\n\tusb_get_dev(udev);\n\tschedule_work(&req->work);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_driver_set_configuration);\n\n/**\n * cdc_parse_cdc_header - parse the extra headers present in CDC devices\n * @hdr: the place to put the results of the parsing\n * @intf: the interface for which parsing is requested\n * @buffer: pointer to the extra headers to be parsed\n * @buflen: length of the extra headers\n *\n * This evaluates the extra headers present in CDC devices which\n * bind the interfaces for data and control and provide details\n * about the capabilities of the device.\n *\n * Return: number of descriptors parsed or -EINVAL\n * if the header is contradictory beyond salvage\n */\n\nint cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\t/* duplicates are ignored */\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\n\t/* duplicates are not tolerated */\n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\n\tunsigned int elength;\n\tint cnt = 0;\n\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif ((buflen < elength) || (elength < 3)) {\n\t\t\tdev_err(&intf->dev, \"invalid descriptor buffer length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE: /* we've found it */\n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * there are LOTS more CDC descriptors that\n\t\t\t * could legitimately be found here.\n\t\t\t */\n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}\n\nEXPORT_SYMBOL(cdc_parse_cdc_header);\n"], "filenames": ["drivers/usb/core/message.c"], "buggy_code_start_loc": [592], "buggy_code_end_loc": [610], "fixing_code_start_loc": [592], "fixing_code_end_loc": [618], "type": "CWE-416", "message": "usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925.", "other": {"cve": {"id": "CVE-2020-12464", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-29T18:15:13.597", "lastModified": "2020-06-22T22:15:12.430", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925."}, {"lang": "es", "value": "a funci\u00f3n usb_sg_cancel en el archivo drivers/usb/core/message.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.6.8, tiene un uso de la memoria previamente liberada porque se produce una transferencia sin una referencia, tambi\u00e9n se conoce como CID-056ad39ee925."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.8", "matchCriteriaId": "BD585B38-A4DA-436C-8F92-3334BD7A443B"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.6.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=056ad39ee9253873522f6469c3364964a322912b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://lkml.org/lkml/2020/3/23/52", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://patchwork.kernel.org/patch/11463781/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200608-0001/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4387-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4388-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4389-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4390-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4391-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4699", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b"}}