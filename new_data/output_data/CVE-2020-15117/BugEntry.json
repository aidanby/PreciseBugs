{"buggy_code": ["/*\n * synergy -- mouse and keyboard sharing utility\n * Copyright (C) 2012-2016 Symless Ltd.\n * Copyright (C) 2002 Chris Schoeneman\n * \n * This package is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * found in the file LICENSE that should have accompanied this file.\n * \n * This package is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"synergy/ProtocolUtil.h\"\n#include \"io/IStream.h\"\n#include \"base/Log.h\"\n#include \"common/stdvector.h\"\n\n#include <cctype>\n#include <cstring>\n\n//\n// ProtocolUtil\n//\n\nvoid\nProtocolUtil::writef(synergy::IStream* stream, const char* fmt, ...)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n    LOG((CLOG_DEBUG2 \"writef(%s)\", fmt));\n\n    va_list args;\n    va_start(args, fmt);\n    UInt32 size = getLength(fmt, args);\n    va_end(args);\n    va_start(args, fmt);\n    vwritef(stream, fmt, size, args);\n    va_end(args);\n}\n\nbool\nProtocolUtil::readf(synergy::IStream* stream, const char* fmt, ...)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n    LOG((CLOG_DEBUG2 \"readf(%s)\", fmt));\n\n    bool result;\n    va_list args;\n    va_start(args, fmt);\n    try {\n        vreadf(stream, fmt, args);\n        result = true;\n    }\n    catch (XIO&) {\n        result = false;\n    }\n    va_end(args);\n    return result;\n}\n\nvoid\nProtocolUtil::vwritef(synergy::IStream* stream,\n                const char* fmt, UInt32 size, va_list args)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n\n    // done if nothing to write\n    if (size == 0) {\n        return;\n    }\n\n    // fill buffer\n    UInt8* buffer = new UInt8[size];\n    writef(buffer, fmt, args);\n\n    try {\n        // write buffer\n        stream->write(buffer, size);\n        LOG((CLOG_DEBUG2 \"wrote %d bytes\", size));\n\n        delete[] buffer;\n    }\n    catch (XBase&) {\n        delete[] buffer;\n        throw;\n    }\n}\n\nvoid\nProtocolUtil::vreadf(synergy::IStream* stream, const char* fmt, va_list args)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n\n    // begin scanning\n    while (*fmt) {\n        if (*fmt == '%') {\n            // format specifier.  determine argument size.\n            ++fmt;\n            UInt32 len = eatLength(&fmt);\n            switch (*fmt) {\n            case 'i': {\n                // check for valid length\n                assert(len == 1 || len == 2 || len == 4);\n\n                // read the data\n                UInt8 buffer[4];\n                read(stream, buffer, len);\n\n                // convert it\n                void* v = va_arg(args, void*);\n                switch (len) {\n                case 1:\n                    // 1 byte integer\n                    *static_cast<UInt8*>(v) = buffer[0];\n                    LOG((CLOG_DEBUG2 \"readf: read %d byte integer: %d (0x%x)\", len, *static_cast<UInt8*>(v), *static_cast<UInt8*>(v)));\n                    break;\n\n                case 2:\n                    // 2 byte integer\n                    *static_cast<UInt16*>(v) =\n                        static_cast<UInt16>(\n                        (static_cast<UInt16>(buffer[0]) << 8) |\n                         static_cast<UInt16>(buffer[1]));\n                    LOG((CLOG_DEBUG2 \"readf: read %d byte integer: %d (0x%x)\", len, *static_cast<UInt16*>(v), *static_cast<UInt16*>(v)));\n                    break;\n\n                case 4:\n                    // 4 byte integer\n                    *static_cast<UInt32*>(v) =\n                        (static_cast<UInt32>(buffer[0]) << 24) |\n                        (static_cast<UInt32>(buffer[1]) << 16) |\n                        (static_cast<UInt32>(buffer[2]) <<  8) |\n                         static_cast<UInt32>(buffer[3]);\n                    LOG((CLOG_DEBUG2 \"readf: read %d byte integer: %d (0x%x)\", len, *static_cast<UInt32*>(v), *static_cast<UInt32*>(v)));\n                    break;\n                }\n                break;\n            }\n\n            case 'I': {\n                // check for valid length\n                assert(len == 1 || len == 2 || len == 4);\n\n                // read the vector length\n                UInt8 buffer[4];\n                read(stream, buffer, 4);\n                UInt32 n = (static_cast<UInt32>(buffer[0]) << 24) |\n                           (static_cast<UInt32>(buffer[1]) << 16) |\n                           (static_cast<UInt32>(buffer[2]) <<  8) |\n                            static_cast<UInt32>(buffer[3]);\n\n                // convert it\n                void* v = va_arg(args, void*);\n                switch (len) {\n                case 1:\n                    // 1 byte integer\n                    for (UInt32 i = 0; i < n; ++i) {\n                        read(stream, buffer, 1);\n                        static_cast<std::vector<UInt8>*>(v)->push_back(\n                            buffer[0]);\n                        LOG((CLOG_DEBUG2 \"readf: read %d byte integer[%d]: %d (0x%x)\", len, i, static_cast<std::vector<UInt8>*>(v)->back(), static_cast<std::vector<UInt8>*>(v)->back()));\n                    }\n                    break;\n\n                case 2:\n                    // 2 byte integer\n                    for (UInt32 i = 0; i < n; ++i) {\n                        read(stream, buffer, 2);\n                        static_cast<std::vector<UInt16>*>(v)->push_back(\n                            static_cast<UInt16>(\n                            (static_cast<UInt16>(buffer[0]) << 8) |\n                             static_cast<UInt16>(buffer[1])));\n                        LOG((CLOG_DEBUG2 \"readf: read %d byte integer[%d]: %d (0x%x)\", len, i, static_cast<std::vector<UInt16>*>(v)->back(), static_cast<std::vector<UInt16>*>(v)->back()));\n                    }\n                    break;\n\n                case 4:\n                    // 4 byte integer\n                    for (UInt32 i = 0; i < n; ++i) {\n                        read(stream, buffer, 4);\n                        static_cast<std::vector<UInt32>*>(v)->push_back(\n                            (static_cast<UInt32>(buffer[0]) << 24) |\n                            (static_cast<UInt32>(buffer[1]) << 16) |\n                            (static_cast<UInt32>(buffer[2]) <<  8) |\n                             static_cast<UInt32>(buffer[3]));\n                        LOG((CLOG_DEBUG2 \"readf: read %d byte integer[%d]: %d (0x%x)\", len, i, static_cast<std::vector<UInt32>*>(v)->back(), static_cast<std::vector<UInt32>*>(v)->back()));\n                    }\n                    break;\n                }\n                break;\n            }\n\n            case 's': {\n                assert(len == 0);\n\n                // read the string length\n                UInt8 buffer[128];\n                read(stream, buffer, 4);\n                UInt32 len = (static_cast<UInt32>(buffer[0]) << 24) |\n                             (static_cast<UInt32>(buffer[1]) << 16) |\n                             (static_cast<UInt32>(buffer[2]) <<  8) |\n                              static_cast<UInt32>(buffer[3]);\n\n                // use a fixed size buffer if its big enough\n                const bool useFixed = (len <= sizeof(buffer));\n\n                // allocate a buffer to read the data\n                UInt8* sBuffer = buffer;\n                if (!useFixed) {\n                    sBuffer = new UInt8[len];\n                }\n\n                // read the data\n                try {\n                    read(stream, sBuffer, len);\n                }\n                catch (...) {\n                    if (!useFixed) {\n                        delete[] sBuffer;\n                    }\n                    throw;\n                }\n\n                LOG((CLOG_DEBUG2 \"readf: read %d byte string\", len));\n\n                // save the data\n                String* dst = va_arg(args, String*);\n                dst->assign((const char*)sBuffer, len);\n\n                // release the buffer\n                if (!useFixed) {\n                    delete[] sBuffer;\n                }\n                break;\n            }\n\n            case '%':\n                assert(len == 0);\n                break;\n\n            default:\n                assert(0 && \"invalid format specifier\");\n            }\n\n            // next format character\n            ++fmt;\n        }\n        else {\n            // read next character\n            char buffer[1];\n            read(stream, buffer, 1);\n\n            // verify match\n            if (buffer[0] != *fmt) {\n                LOG((CLOG_DEBUG2 \"readf: format mismatch: %c vs %c\", *fmt, buffer[0]));\n                throw XIOReadMismatch();\n            }\n\n            // next format character\n            ++fmt;\n        }\n    }\n}\n\nUInt32\nProtocolUtil::getLength(const char* fmt, va_list args)\n{\n    UInt32 n = 0;\n    while (*fmt) {\n        if (*fmt == '%') {\n            // format specifier.  determine argument size.\n            ++fmt;\n            UInt32 len = eatLength(&fmt);\n            switch (*fmt) {\n            case 'i':\n                assert(len == 1 || len == 2 || len == 4);\n                (void)va_arg(args, UInt32);\n                break;\n\n            case 'I':\n                assert(len == 1 || len == 2 || len == 4);\n                switch (len) {\n                case 1:\n                    len = (UInt32)(va_arg(args, std::vector<UInt8>*))->size() + 4;\n                    break;\n\n                case 2:\n                    len = 2 * (UInt32)(va_arg(args, std::vector<UInt16>*))->size() + 4;\n                    break;\n\n                case 4:\n                    len = 4 * (UInt32)(va_arg(args, std::vector<UInt32>*))->size() + 4;\n                    break;\n                }\n                break;\n\n            case 's':\n                assert(len == 0);\n                len = (UInt32)(va_arg(args, String*))->size() + 4;\n                (void)va_arg(args, UInt8*);\n                break;\n\n            case 'S':\n                assert(len == 0);\n                len = va_arg(args, UInt32) + 4;\n                (void)va_arg(args, UInt8*);\n                break;\n\n            case '%':\n                assert(len == 0);\n                len = 1;\n                break;\n\n            default:\n                assert(0 && \"invalid format specifier\");\n            }\n\n            // accumulate size\n            n += len;\n            ++fmt;\n        }\n        else {\n            // regular character\n            ++n;\n            ++fmt;\n        }\n    }\n    return n;\n}\n\nvoid\nProtocolUtil::writef(void* buffer, const char* fmt, va_list args)\n{\n    UInt8* dst = static_cast<UInt8*>(buffer);\n\n    while (*fmt) {\n        if (*fmt == '%') {\n            // format specifier.  determine argument size.\n            ++fmt;\n            UInt32 len = eatLength(&fmt);\n            switch (*fmt) {\n            case 'i': {\n                const UInt32 v = va_arg(args, UInt32);\n                switch (len) {\n                case 1:\n                    // 1 byte integer\n                    *dst++ = static_cast<UInt8>(v & 0xff);\n                    break;\n\n                case 2:\n                    // 2 byte integer\n                    *dst++ = static_cast<UInt8>((v >> 8) & 0xff);\n                    *dst++ = static_cast<UInt8>( v       & 0xff);\n                    break;\n\n                case 4:\n                    // 4 byte integer\n                    *dst++ = static_cast<UInt8>((v >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((v >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((v >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( v        & 0xff);\n                    break;\n\n                default:\n                    assert(0 && \"invalid integer format length\");\n                    return;\n                }\n                break;\n            }\n\n            case 'I': {\n                switch (len) {\n                case 1: {\n                    // 1 byte integers\n                    const std::vector<UInt8>* list =\n                        va_arg(args, const std::vector<UInt8>*);\n                    const UInt32 n = (UInt32)list->size();\n                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( n        & 0xff);\n                    for (UInt32 i = 0; i < n; ++i) {\n                        *dst++ = (*list)[i];\n                    }\n                    break;\n                }\n\n                case 2: {\n                    // 2 byte integers\n                    const std::vector<UInt16>* list =\n                        va_arg(args, const std::vector<UInt16>*);\n                    const UInt32 n = (UInt32)list->size();\n                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( n        & 0xff);\n                    for (UInt32 i = 0; i < n; ++i) {\n                        const UInt16 v = (*list)[i];\n                        *dst++ = static_cast<UInt8>((v >> 8) & 0xff);\n                        *dst++ = static_cast<UInt8>( v       & 0xff);\n                    }\n                    break;\n                }\n\n                case 4: {\n                    // 4 byte integers\n                    const std::vector<UInt32>* list =\n                        va_arg(args, const std::vector<UInt32>*);\n                    const UInt32 n = (UInt32)list->size();\n                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( n        & 0xff);\n                    for (UInt32 i = 0; i < n; ++i) {\n                        const UInt32 v = (*list)[i];\n                        *dst++ = static_cast<UInt8>((v >> 24) & 0xff);\n                        *dst++ = static_cast<UInt8>((v >> 16) & 0xff);\n                        *dst++ = static_cast<UInt8>((v >>  8) & 0xff);\n                        *dst++ = static_cast<UInt8>( v        & 0xff);\n                    }\n                    break;\n                }\n\n                default:\n                    assert(0 && \"invalid integer vector format length\");\n                    return;\n                }\n                break;\n            }\n\n            case 's': {\n                assert(len == 0);\n                const String* src = va_arg(args, String*);\n                const UInt32 len = (src != NULL) ? (UInt32)src->size() : 0;\n                *dst++ = static_cast<UInt8>((len >> 24) & 0xff);\n                *dst++ = static_cast<UInt8>((len >> 16) & 0xff);\n                *dst++ = static_cast<UInt8>((len >>  8) & 0xff);\n                *dst++ = static_cast<UInt8>( len        & 0xff);\n                if (len != 0) {\n                    memcpy(dst, src->data(), len);\n                    dst += len;\n                }\n                break;\n            }\n\n            case 'S': {\n                assert(len == 0);\n                const UInt32 len = va_arg(args, UInt32);\n                const UInt8* src = va_arg(args, UInt8*);\n                *dst++ = static_cast<UInt8>((len >> 24) & 0xff);\n                *dst++ = static_cast<UInt8>((len >> 16) & 0xff);\n                *dst++ = static_cast<UInt8>((len >>  8) & 0xff);\n                *dst++ = static_cast<UInt8>( len        & 0xff);\n                memcpy(dst, src, len);\n                dst += len;\n                break;\n            }\n\n            case '%':\n                assert(len == 0);\n                *dst++ = '%';\n                break;\n\n            default:\n                assert(0 && \"invalid format specifier\");\n            }\n\n            // next format character\n            ++fmt;\n        }\n        else {\n            // copy regular character\n            *dst++ = *fmt++;\n        }\n    }\n}\n\nUInt32\nProtocolUtil::eatLength(const char** pfmt)\n{\n    const char* fmt = *pfmt;\n    UInt32 n = 0;\n    for (;;) {\n        UInt32 d;\n        switch (*fmt) {\n        case '0': d = 0; break;\n        case '1': d = 1; break;\n        case '2': d = 2; break;\n        case '3': d = 3; break;\n        case '4': d = 4; break;\n        case '5': d = 5; break;\n        case '6': d = 6; break;\n        case '7': d = 7; break;\n        case '8': d = 8; break;\n        case '9': d = 9; break;\n        default: *pfmt = fmt; return n;\n        }\n        n = 10 * n + d;\n        ++fmt;\n    }\n}\n\nvoid\nProtocolUtil::read(synergy::IStream* stream, void* vbuffer, UInt32 count)\n{\n    assert(stream != NULL);\n    assert(vbuffer != NULL);\n\n    UInt8* buffer = static_cast<UInt8*>(vbuffer);\n    while (count > 0) {\n        // read more\n        UInt32 n = stream->read(buffer, count);\n\n        // bail if stream has hungup\n        if (n == 0) {\n            LOG((CLOG_DEBUG2 \"unexpected disconnect in readf(), %d bytes left\", count));\n            throw XIOEndOfStream();\n        }\n\n        // prepare for next read\n        buffer += n;\n        count  -= n;\n    }\n}\n\n\n//\n// XIOReadMismatch\n//\n\nString\nXIOReadMismatch::getWhat() const throw()\n{\n    return format(\"XIOReadMismatch\", \"ProtocolUtil::readf() mismatch\");\n}\n"], "fixing_code": ["/*\n * synergy -- mouse and keyboard sharing utility\n * Copyright (C) 2012-2016 Symless Ltd.\n * Copyright (C) 2002 Chris Schoeneman\n * \n * This package is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * found in the file LICENSE that should have accompanied this file.\n * \n * This package is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"synergy/ProtocolUtil.h\"\n#include \"io/IStream.h\"\n#include \"base/Log.h\"\n#include \"common/stdvector.h\"\n\n#include <cctype>\n#include <cstring>\n\n//\n// ProtocolUtil\n//\n\nvoid\nProtocolUtil::writef(synergy::IStream* stream, const char* fmt, ...)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n    LOG((CLOG_DEBUG2 \"writef(%s)\", fmt));\n\n    va_list args;\n    va_start(args, fmt);\n    UInt32 size = getLength(fmt, args);\n    va_end(args);\n    va_start(args, fmt);\n    vwritef(stream, fmt, size, args);\n    va_end(args);\n}\n\nbool\nProtocolUtil::readf(synergy::IStream* stream, const char* fmt, ...)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n    LOG((CLOG_DEBUG2 \"readf(%s)\", fmt));\n\n    bool result;\n    va_list args;\n    va_start(args, fmt);\n    try {\n        vreadf(stream, fmt, args);\n        result = true;\n    }\n    catch (XIO&) {\n        result = false;\n    }\n    catch (std::bad_alloc & exception) {\n        result = false;\n    }\n    va_end(args);\n    return result;\n}\n\nvoid\nProtocolUtil::vwritef(synergy::IStream* stream,\n                const char* fmt, UInt32 size, va_list args)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n\n    // done if nothing to write\n    if (size == 0) {\n        return;\n    }\n\n    // fill buffer\n    UInt8* buffer = new UInt8[size];\n    writef(buffer, fmt, args);\n\n    try {\n        // write buffer\n        stream->write(buffer, size);\n        LOG((CLOG_DEBUG2 \"wrote %d bytes\", size));\n\n        delete[] buffer;\n    }\n    catch (XBase&) {\n        delete[] buffer;\n        throw;\n    }\n}\n\nvoid\nProtocolUtil::vreadf(synergy::IStream* stream, const char* fmt, va_list args)\n{\n    assert(stream != NULL);\n    assert(fmt != NULL);\n\n    // begin scanning\n    while (*fmt) {\n        if (*fmt == '%') {\n            // format specifier.  determine argument size.\n            ++fmt;\n            UInt32 len = eatLength(&fmt);\n            switch (*fmt) {\n            case 'i': {\n                // check for valid length\n                assert(len == 1 || len == 2 || len == 4);\n\n                // read the data\n                UInt8 buffer[4];\n                read(stream, buffer, len);\n\n                // convert it\n                void* v = va_arg(args, void*);\n                switch (len) {\n                case 1:\n                    // 1 byte integer\n                    *static_cast<UInt8*>(v) = buffer[0];\n                    LOG((CLOG_DEBUG2 \"readf: read %d byte integer: %d (0x%x)\", len, *static_cast<UInt8*>(v), *static_cast<UInt8*>(v)));\n                    break;\n\n                case 2:\n                    // 2 byte integer\n                    *static_cast<UInt16*>(v) =\n                        static_cast<UInt16>(\n                        (static_cast<UInt16>(buffer[0]) << 8) |\n                         static_cast<UInt16>(buffer[1]));\n                    LOG((CLOG_DEBUG2 \"readf: read %d byte integer: %d (0x%x)\", len, *static_cast<UInt16*>(v), *static_cast<UInt16*>(v)));\n                    break;\n\n                case 4:\n                    // 4 byte integer\n                    *static_cast<UInt32*>(v) =\n                        (static_cast<UInt32>(buffer[0]) << 24) |\n                        (static_cast<UInt32>(buffer[1]) << 16) |\n                        (static_cast<UInt32>(buffer[2]) <<  8) |\n                         static_cast<UInt32>(buffer[3]);\n                    LOG((CLOG_DEBUG2 \"readf: read %d byte integer: %d (0x%x)\", len, *static_cast<UInt32*>(v), *static_cast<UInt32*>(v)));\n                    break;\n                }\n                break;\n            }\n\n            case 'I': {\n                // check for valid length\n                assert(len == 1 || len == 2 || len == 4);\n\n                // read the vector length\n                UInt8 buffer[4];\n                read(stream, buffer, 4);\n                UInt32 n = (static_cast<UInt32>(buffer[0]) << 24) |\n                           (static_cast<UInt32>(buffer[1]) << 16) |\n                           (static_cast<UInt32>(buffer[2]) <<  8) |\n                            static_cast<UInt32>(buffer[3]);\n\n                // convert it\n                void* v = va_arg(args, void*);\n                switch (len) {\n                case 1:\n                    // 1 byte integer\n                    for (UInt32 i = 0; i < n; ++i) {\n                        read(stream, buffer, 1);\n                        static_cast<std::vector<UInt8>*>(v)->push_back(\n                            buffer[0]);\n                        LOG((CLOG_DEBUG2 \"readf: read %d byte integer[%d]: %d (0x%x)\", len, i, static_cast<std::vector<UInt8>*>(v)->back(), static_cast<std::vector<UInt8>*>(v)->back()));\n                    }\n                    break;\n\n                case 2:\n                    // 2 byte integer\n                    for (UInt32 i = 0; i < n; ++i) {\n                        read(stream, buffer, 2);\n                        static_cast<std::vector<UInt16>*>(v)->push_back(\n                            static_cast<UInt16>(\n                            (static_cast<UInt16>(buffer[0]) << 8) |\n                             static_cast<UInt16>(buffer[1])));\n                        LOG((CLOG_DEBUG2 \"readf: read %d byte integer[%d]: %d (0x%x)\", len, i, static_cast<std::vector<UInt16>*>(v)->back(), static_cast<std::vector<UInt16>*>(v)->back()));\n                    }\n                    break;\n\n                case 4:\n                    // 4 byte integer\n                    for (UInt32 i = 0; i < n; ++i) {\n                        read(stream, buffer, 4);\n                        static_cast<std::vector<UInt32>*>(v)->push_back(\n                            (static_cast<UInt32>(buffer[0]) << 24) |\n                            (static_cast<UInt32>(buffer[1]) << 16) |\n                            (static_cast<UInt32>(buffer[2]) <<  8) |\n                             static_cast<UInt32>(buffer[3]));\n                        LOG((CLOG_DEBUG2 \"readf: read %d byte integer[%d]: %d (0x%x)\", len, i, static_cast<std::vector<UInt32>*>(v)->back(), static_cast<std::vector<UInt32>*>(v)->back()));\n                    }\n                    break;\n                }\n                break;\n            }\n\n            case 's': {\n                assert(len == 0);\n\n                // read the string length\n                UInt8 buffer[128];\n                read(stream, buffer, 4);\n                UInt32 len = (static_cast<UInt32>(buffer[0]) << 24) |\n                             (static_cast<UInt32>(buffer[1]) << 16) |\n                             (static_cast<UInt32>(buffer[2]) <<  8) |\n                              static_cast<UInt32>(buffer[3]);\n\n                // use a fixed size buffer if its big enough\n                const bool useFixed = (len <= sizeof(buffer));\n\n                // allocate a buffer to read the data\n                UInt8* sBuffer = buffer;\n                if (!useFixed) {\n                    try{\n                        sBuffer = new UInt8[len];\n                    }\n                    catch (std::bad_alloc & exception) {\n                        // Added try catch due to GHSA-chfm-333q-gfpp\n                        LOG((CLOG_ERR \"ALLOC: Unable to allocate memory %d bytes\", len));\n                        LOG((CLOG_DEBUG \"bad_alloc detected: Do you have enough free memory?\"));\n                        throw exception;\n                    }\n                }\n\n                // read the data\n                try {\n                    read(stream, sBuffer, len);\n                }\n                catch (...) {\n                    if (!useFixed) {\n                        delete[] sBuffer;\n                    }\n                    throw;\n                }\n\n                LOG((CLOG_DEBUG2 \"readf: read %d byte string\", len));\n\n                // save the data\n                String* dst = va_arg(args, String*);\n                dst->assign((const char*)sBuffer, len);\n\n                // release the buffer\n                if (!useFixed) {\n                    delete[] sBuffer;\n                }\n                break;\n            }\n\n            case '%':\n                assert(len == 0);\n                break;\n\n            default:\n                assert(0 && \"invalid format specifier\");\n            }\n\n            // next format character\n            ++fmt;\n        }\n        else {\n            // read next character\n            char buffer[1];\n            read(stream, buffer, 1);\n\n            // verify match\n            if (buffer[0] != *fmt) {\n                LOG((CLOG_DEBUG2 \"readf: format mismatch: %c vs %c\", *fmt, buffer[0]));\n                throw XIOReadMismatch();\n            }\n\n            // next format character\n            ++fmt;\n        }\n    }\n}\n\nUInt32\nProtocolUtil::getLength(const char* fmt, va_list args)\n{\n    UInt32 n = 0;\n    while (*fmt) {\n        if (*fmt == '%') {\n            // format specifier.  determine argument size.\n            ++fmt;\n            UInt32 len = eatLength(&fmt);\n            switch (*fmt) {\n            case 'i':\n                assert(len == 1 || len == 2 || len == 4);\n                (void)va_arg(args, UInt32);\n                break;\n\n            case 'I':\n                assert(len == 1 || len == 2 || len == 4);\n                switch (len) {\n                case 1:\n                    len = (UInt32)(va_arg(args, std::vector<UInt8>*))->size() + 4;\n                    break;\n\n                case 2:\n                    len = 2 * (UInt32)(va_arg(args, std::vector<UInt16>*))->size() + 4;\n                    break;\n\n                case 4:\n                    len = 4 * (UInt32)(va_arg(args, std::vector<UInt32>*))->size() + 4;\n                    break;\n                }\n                break;\n\n            case 's':\n                assert(len == 0);\n                len = (UInt32)(va_arg(args, String*))->size() + 4;\n                (void)va_arg(args, UInt8*);\n                break;\n\n            case 'S':\n                assert(len == 0);\n                len = va_arg(args, UInt32) + 4;\n                (void)va_arg(args, UInt8*);\n                break;\n\n            case '%':\n                assert(len == 0);\n                len = 1;\n                break;\n\n            default:\n                assert(0 && \"invalid format specifier\");\n            }\n\n            // accumulate size\n            n += len;\n            ++fmt;\n        }\n        else {\n            // regular character\n            ++n;\n            ++fmt;\n        }\n    }\n    return n;\n}\n\nvoid\nProtocolUtil::writef(void* buffer, const char* fmt, va_list args)\n{\n    UInt8* dst = static_cast<UInt8*>(buffer);\n\n    while (*fmt) {\n        if (*fmt == '%') {\n            // format specifier.  determine argument size.\n            ++fmt;\n            UInt32 len = eatLength(&fmt);\n            switch (*fmt) {\n            case 'i': {\n                const UInt32 v = va_arg(args, UInt32);\n                switch (len) {\n                case 1:\n                    // 1 byte integer\n                    *dst++ = static_cast<UInt8>(v & 0xff);\n                    break;\n\n                case 2:\n                    // 2 byte integer\n                    *dst++ = static_cast<UInt8>((v >> 8) & 0xff);\n                    *dst++ = static_cast<UInt8>( v       & 0xff);\n                    break;\n\n                case 4:\n                    // 4 byte integer\n                    *dst++ = static_cast<UInt8>((v >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((v >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((v >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( v        & 0xff);\n                    break;\n\n                default:\n                    assert(0 && \"invalid integer format length\");\n                    return;\n                }\n                break;\n            }\n\n            case 'I': {\n                switch (len) {\n                case 1: {\n                    // 1 byte integers\n                    const std::vector<UInt8>* list =\n                        va_arg(args, const std::vector<UInt8>*);\n                    const UInt32 n = (UInt32)list->size();\n                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( n        & 0xff);\n                    for (UInt32 i = 0; i < n; ++i) {\n                        *dst++ = (*list)[i];\n                    }\n                    break;\n                }\n\n                case 2: {\n                    // 2 byte integers\n                    const std::vector<UInt16>* list =\n                        va_arg(args, const std::vector<UInt16>*);\n                    const UInt32 n = (UInt32)list->size();\n                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( n        & 0xff);\n                    for (UInt32 i = 0; i < n; ++i) {\n                        const UInt16 v = (*list)[i];\n                        *dst++ = static_cast<UInt8>((v >> 8) & 0xff);\n                        *dst++ = static_cast<UInt8>( v       & 0xff);\n                    }\n                    break;\n                }\n\n                case 4: {\n                    // 4 byte integers\n                    const std::vector<UInt32>* list =\n                        va_arg(args, const std::vector<UInt32>*);\n                    const UInt32 n = (UInt32)list->size();\n                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);\n                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);\n                    *dst++ = static_cast<UInt8>( n        & 0xff);\n                    for (UInt32 i = 0; i < n; ++i) {\n                        const UInt32 v = (*list)[i];\n                        *dst++ = static_cast<UInt8>((v >> 24) & 0xff);\n                        *dst++ = static_cast<UInt8>((v >> 16) & 0xff);\n                        *dst++ = static_cast<UInt8>((v >>  8) & 0xff);\n                        *dst++ = static_cast<UInt8>( v        & 0xff);\n                    }\n                    break;\n                }\n\n                default:\n                    assert(0 && \"invalid integer vector format length\");\n                    return;\n                }\n                break;\n            }\n\n            case 's': {\n                assert(len == 0);\n                const String* src = va_arg(args, String*);\n                const UInt32 len = (src != NULL) ? (UInt32)src->size() : 0;\n                *dst++ = static_cast<UInt8>((len >> 24) & 0xff);\n                *dst++ = static_cast<UInt8>((len >> 16) & 0xff);\n                *dst++ = static_cast<UInt8>((len >>  8) & 0xff);\n                *dst++ = static_cast<UInt8>( len        & 0xff);\n                if (len != 0) {\n                    memcpy(dst, src->data(), len);\n                    dst += len;\n                }\n                break;\n            }\n\n            case 'S': {\n                assert(len == 0);\n                const UInt32 len = va_arg(args, UInt32);\n                const UInt8* src = va_arg(args, UInt8*);\n                *dst++ = static_cast<UInt8>((len >> 24) & 0xff);\n                *dst++ = static_cast<UInt8>((len >> 16) & 0xff);\n                *dst++ = static_cast<UInt8>((len >>  8) & 0xff);\n                *dst++ = static_cast<UInt8>( len        & 0xff);\n                memcpy(dst, src, len);\n                dst += len;\n                break;\n            }\n\n            case '%':\n                assert(len == 0);\n                *dst++ = '%';\n                break;\n\n            default:\n                assert(0 && \"invalid format specifier\");\n            }\n\n            // next format character\n            ++fmt;\n        }\n        else {\n            // copy regular character\n            *dst++ = *fmt++;\n        }\n    }\n}\n\nUInt32\nProtocolUtil::eatLength(const char** pfmt)\n{\n    const char* fmt = *pfmt;\n    UInt32 n = 0;\n    for (;;) {\n        UInt32 d;\n        switch (*fmt) {\n        case '0': d = 0; break;\n        case '1': d = 1; break;\n        case '2': d = 2; break;\n        case '3': d = 3; break;\n        case '4': d = 4; break;\n        case '5': d = 5; break;\n        case '6': d = 6; break;\n        case '7': d = 7; break;\n        case '8': d = 8; break;\n        case '9': d = 9; break;\n        default: *pfmt = fmt; return n;\n        }\n        n = 10 * n + d;\n        ++fmt;\n    }\n}\n\nvoid\nProtocolUtil::read(synergy::IStream* stream, void* vbuffer, UInt32 count)\n{\n    assert(stream != NULL);\n    assert(vbuffer != NULL);\n\n    UInt8* buffer = static_cast<UInt8*>(vbuffer);\n    while (count > 0) {\n        // read more\n        UInt32 n = stream->read(buffer, count);\n\n        // bail if stream has hungup\n        if (n == 0) {\n            LOG((CLOG_DEBUG2 \"unexpected disconnect in readf(), %d bytes left\", count));\n            throw XIOEndOfStream();\n        }\n\n        // prepare for next read\n        buffer += n;\n        count  -= n;\n    }\n}\n\n\n//\n// XIOReadMismatch\n//\n\nString\nXIOReadMismatch::getWhat() const throw()\n{\n    return format(\"XIOReadMismatch\", \"ProtocolUtil::readf() mismatch\");\n}\n"], "filenames": ["src/lib/synergy/ProtocolUtil.cpp"], "buggy_code_start_loc": [63], "buggy_code_end_loc": [220], "fixing_code_start_loc": [64], "fixing_code_end_loc": [231], "type": "CWE-754", "message": "In Synergy before version 1.12.0, a Synergy server can be crashed by receiving a kMsgHelloBack packet with a client name length set to 0xffffffff (4294967295) if the servers memory is less than 4 GB. It was verified that this issue does not cause a crash through the exception handler if the available memory of the Server is more than 4GB.", "other": {"cve": {"id": "CVE-2020-15117", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-15T18:15:36.333", "lastModified": "2022-10-21T18:02:47.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Synergy before version 1.12.0, a Synergy server can be crashed by receiving a kMsgHelloBack packet with a client name length set to 0xffffffff (4294967295) if the servers memory is less than 4 GB. It was verified that this issue does not cause a crash through the exception handler if the available memory of the Server is more than 4GB."}, {"lang": "es", "value": "En Synergy anterior a la versi\u00f3n 1.12.0, un servidor de Synergy puede ser bloqueado al recibir un paquete kMsgHelloBack con una longitud de nombre de cliente establecida en 0xffffffff (4294967295) si la memoria del servidor es inferior a 4 GB. Se verific\u00f3 que este problema no causa un bloqueo por medio del manejador de excepciones si la memoria disponible del servidor es superior a 4 GB"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:symless:synergy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.0", "matchCriteriaId": "B0AF35B4-C68F-47FE-8CC1-4F2BF150E55B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/symless/synergy-core/commit/0a97c2be0da2d0df25cb86dfd642429e7a8bea39", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symless/synergy-core/security/advisories/GHSA-chfm-333q-gfpp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VFDEQED64YLWQK2TF73EMXZDYX7YT2DD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WAQYCMBWNVCIEM27NPIKK3DGJCNBYLAK/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symless/synergy-core/commit/0a97c2be0da2d0df25cb86dfd642429e7a8bea39"}}