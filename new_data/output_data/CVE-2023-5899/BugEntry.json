{"buggy_code": ["<?php\n\n/**\n * @file classes/controllers/grid/users/reviewer/PKPReviewerGridHandler.inc.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class PKPReviewerGridHandler\n * @ingroup classes_controllers_grid_users_reviewer\n *\n * @brief Handle reviewer grid requests.\n */\n\n// import grid base classes\nimport('lib.pkp.classes.controllers.grid.GridHandler');\n\n// import reviewer grid specific classes\nimport('lib.pkp.controllers.grid.users.reviewer.ReviewerGridCellProvider');\nimport('lib.pkp.controllers.grid.users.reviewer.ReviewerGridRow');\n\n// Reviewer selection types\ndefine('REVIEWER_SELECT_ADVANCED_SEARCH',\t\t0x00000001);\ndefine('REVIEWER_SELECT_CREATE',\t\t\t0x00000002);\ndefine('REVIEWER_SELECT_ENROLL_EXISTING',\t\t0x00000003);\n\nclass PKPReviewerGridHandler extends GridHandler {\n\n\t/** @var Submission */\n\tvar $_submission;\n\n\t/** @var integer */\n\tvar $_stageId;\n\n\t/** @var boolean Is the current user assigned as an author to this submission */\n\tvar $_isCurrentUserAssignedAuthor;\n\n\tvar $isAuthorGrid;\n\n\t/**\n\t * Constructor\n\t */\n\tfunction __construct() {\n\t\tparent::__construct();\n\n\t\t$allOperations = array_merge($this->_getReviewAssignmentOps(), $this->_getReviewRoundOps());\n\n\t\t$this->addRoleAssignment(\n\t\t\tarray(ROLE_ID_MANAGER, ROLE_ID_SUB_EDITOR),\n\t\t\t$allOperations\n\t\t);\n\n\t\t// Remove operations related to creation and enrollment of users.\n\t\t$assistantOperations = array_flip($allOperations);\n\t\tunset($assistantOperations['createReviewer']);\n\t\tunset($assistantOperations['enrollReviewer']);\n\t\tunset($assistantOperations['gossip']);\n\t\t$assistantOperations = array_flip($assistantOperations);\n\n\t\t$this->addRoleAssignment(\n\t\t\tarray(ROLE_ID_ASSISTANT),\n\t\t\t$assistantOperations\n\t\t);\n\n\t\t$this->isAuthorGrid = false;\n\t}\n\n\t/**\n\t * @copydoc PKPHandler::authorize()\n\t */\n\tfunction authorize($request, &$args, $roleAssignments) {\n\n\t\tif (!$this->isAuthorGrid) {\n\n\t\t\t$stageId = $request->getUserVar('stageId'); // This is being validated in WorkflowStageAccessPolicy\n\n\t\t\t// Not all actions need a stageId. Some work off the reviewAssignment which has the type and round.\n\t\t\t$this->_stageId = (int)$stageId;\n\n\t\t\t// Get the stage access policy\n\t\t\timport('lib.pkp.classes.security.authorization.WorkflowStageAccessPolicy');\n\t\t\t$workflowStageAccessPolicy = new WorkflowStageAccessPolicy($request, $args, $roleAssignments, 'submissionId', $stageId, WORKFLOW_TYPE_EDITORIAL);\n\n\t\t\t// Add policy to ensure there is a review round id.\n\t\t\timport('lib.pkp.classes.security.authorization.internal.ReviewRoundRequiredPolicy');\n\t\t\t$workflowStageAccessPolicy->addPolicy(new ReviewRoundRequiredPolicy($request, $args, 'reviewRoundId', $this->_getReviewRoundOps()));\n\n\t\t\t// Add policy to ensure there is a review assignment for certain operations.\n\t\t\timport('lib.pkp.classes.security.authorization.internal.ReviewAssignmentRequiredPolicy');\n\t\t\t$workflowStageAccessPolicy->addPolicy(new ReviewAssignmentRequiredPolicy($request, $args, 'reviewAssignmentId', $this->_getReviewAssignmentOps()));\n\t\t\t$this->addPolicy($workflowStageAccessPolicy);\n\n\t\t\t$success = parent::authorize($request, $args, $roleAssignments);\n\n\t\t\t// Prevent authors from accessing review details, even if they are also\n\t\t\t// assigned as an editor, sub-editor or assistant.\n\t\t\t$userAssignedRoles = $this->getAuthorizedContextObject(ASSOC_TYPE_ACCESSIBLE_WORKFLOW_STAGES);\n\t\t\t$this->_isCurrentUserAssignedAuthor = false;\n\t\t\tforeach ($userAssignedRoles as $stageId => $roles) {\n\t\t\t\tif (in_array(ROLE_ID_AUTHOR, $roles)) {\n\t\t\t\t\t$this->_isCurrentUserAssignedAuthor = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($this->_isCurrentUserAssignedAuthor) {\n\t\t\t\t$operation = $request->getRouter()->getRequestedOp($request);\n\n\t\t\t\tif (in_array($operation, $this->_getAuthorDeniedOps())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (in_array($operation, $this->_getAuthorDeniedAnonymousOps())) {\n\t\t\t\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t\t\t\tif ($reviewAssignment && in_array($reviewAssignment->getReviewMethod(), array(SUBMISSION_REVIEW_METHOD_ANONYMOUS, SUBMISSION_REVIEW_METHOD_DOUBLEANONYMOUS))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $success;\n\n\t\t} else {\n\t\t\treturn parent::authorize($request, $args, $roleAssignments);\n\t\t}\n\n\t}\n\n\n\t//\n\t// Getters and Setters\n\t//\n\t/**\n\t * Get the authorized submission.\n\t * @return Submission\n\t */\n\tfunction getSubmission() {\n\t\treturn $this->getAuthorizedContextObject(ASSOC_TYPE_SUBMISSION);\n\t}\n\n\t/**\n\t * Get the review stage id.\n\t * @return integer\n\t */\n\tfunction getStageId() {\n\t\treturn $this->_stageId;\n\t}\n\n\t/**\n\t * Get review round object.\n\t * @return ReviewRound\n\t */\n\tfunction getReviewRound() {\n\t\t$reviewRound = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ROUND);\n\t\tif (is_a($reviewRound, 'ReviewRound')) {\n\t\t\treturn $reviewRound;\n\t\t} else {\n\t\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t\t$reviewRoundId = $reviewAssignment->getReviewRoundId();\n\t\t\t$reviewRoundDao = DAORegistry::getDAO('ReviewRoundDAO'); /* @var $reviewRoundDao ReviewRoundDAO */\n\t\t\t$reviewRound = $reviewRoundDao->getById($reviewRoundId);\n\t\t\treturn $reviewRound;\n\t\t}\n\t}\n\n\n\t//\n\t// Overridden methods from PKPHandler\n\t//\n\t/**\n\t * @copydoc GridHandler::initialize()\n\t */\n\tfunction initialize($request, $args = null) {\n\t\tparent::initialize($request, $args);\n\n\t\t// Load submission-specific translations\n\t\tAppLocale::requireComponents(\n\t\t\tLOCALE_COMPONENT_PKP_SUBMISSION,\n\t\t\tLOCALE_COMPONENT_PKP_MANAGER,\n\t\t\tLOCALE_COMPONENT_PKP_USER,\n\t\t\tLOCALE_COMPONENT_PKP_EDITOR,\n\t\t\tLOCALE_COMPONENT_PKP_REVIEWER,\n\t\t\tLOCALE_COMPONENT_APP_EDITOR\n\t\t);\n\n\t\t$this->setTitle('user.role.reviewers');\n\n\t\t// Grid actions\n\t\tif (!$this->_isCurrentUserAssignedAuthor) {\n\t\t\timport('lib.pkp.classes.linkAction.request.AjaxModal');\n\t\t\t$router = $request->getRouter();\n\t\t\t$actionArgs = array_merge($this->getRequestArgs(), array('selectionType' => REVIEWER_SELECT_ADVANCED_SEARCH));\n\t\t\t$this->addAction(\n\t\t\t\tnew LinkAction(\n\t\t\t\t\t'addReviewer',\n\t\t\t\t\tnew AjaxModal(\n\t\t\t\t\t\t$router->url($request, null, null, 'showReviewerForm', null, $actionArgs),\n\t\t\t\t\t\t__('editor.submission.addReviewer'),\n\t\t\t\t\t\t'modal_add_user'\n\t\t\t\t\t),\n\t\t\t\t\t__('editor.submission.addReviewer'),\n\t\t\t\t\t'add_user'\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\t// Columns\n\t\t$cellProvider = new ReviewerGridCellProvider($this->_isCurrentUserAssignedAuthor);\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'name',\n\t\t\t\t'user.name',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider\n\t\t\t)\n\t\t);\n\n\t\t// Add a column for the status of the review.\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'considered',\n\t\t\t\t'common.status',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider,\n\t\t\t\tarray('anyhtml' => true)\n\t\t\t)\n\t\t);\n\n\t\t// Add a column for the review method\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'method',\n\t\t\t\t'common.type',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider\n\t\t\t)\n\t\t);\n\n\t\t// Add a column for the status of the review.\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'actions',\n\t\t\t\t'grid.columns.actions',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider\n\t\t\t)\n\t\t);\n\t}\n\n\n\t//\n\t// Overridden methods from GridHandler\n\t//\n\t/**\n\t * @see GridHandler::getRowInstance()\n\t * @return ReviewerGridRow\n\t */\n\tprotected function getRowInstance() {\n\t\treturn new ReviewerGridRow($this->_isCurrentUserAssignedAuthor);\n\t}\n\n\t/**\n\t * @see GridHandler::getRequestArgs()\n\t */\n\tfunction getRequestArgs() {\n\t\t$submission = $this->getSubmission();\n\t\t$reviewRound = $this->getReviewRound();\n\t\treturn array(\n\t\t\t'submissionId' => $submission->getId(),\n\t\t\t'stageId' => $this->getStageId(),\n\t\t\t'reviewRoundId' => $reviewRound->getId()\n\t\t);\n\t}\n\n\t/**\n\t * @see GridHandler::loadData()\n\t */\n\tprotected function loadData($request, $filter) {\n\t\t// Get the existing review assignments for this submission\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$reviewAssignmentDao = DAORegistry::getDAO('ReviewAssignmentDAO'); /* @var $reviewAssignmentDao ReviewAssignmentDAO */\n\t\treturn $reviewAssignmentDao->getByReviewRoundId($reviewRound->getId());\n\t}\n\n\n\t//\n\t// Public actions\n\t//\n\t/**\n\t * Add a reviewer.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction showReviewerForm($args, $request) {\n\t\treturn new JSONMessage(true, $this->_fetchReviewerForm($args, $request));\n\t}\n\n\t/**\n\t * Load the contents of the reviewer form\n\t * @param $args array\n\t * @param $request Request\n\t * @return JSONMessage JSON object\n\t */\n\tfunction reloadReviewerForm($args, $request) {\n\t\t$json = new JSONMessage(true);\n\t\t$json->setEvent('refreshForm', $this->_fetchReviewerForm($args, $request));\n\t\treturn $json;\n\t}\n\n\t/**\n\t * Create a new user as reviewer.\n\t * @param $args Array\n\t * @param $request Request\n\t * @return string Serialized JSON object\n\t */\n\tfunction createReviewer($args, $request) {\n\t\treturn $this->updateReviewer($args, $request);\n\t}\n\n\t/**\n\t * Enroll an existing user as reviewer.\n\t * @param $args Array\n\t * @param $request Request\n\t * @return string Serialized JSON object\n\t */\n\tfunction enrollReviewer($args, $request) {\n\t\treturn $this->updateReviewer($args, $request);\n\t}\n\n\t/**\n\t * Edit a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction updateReviewer($args, $request) {\n\t\t$selectionType = $request->getUserVar('selectionType');\n\t\t$formClassName = $this->_getReviewerFormClassName($selectionType);\n\n\t\t// Form handling\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.' . $formClassName );\n\t\t$reviewerForm = new $formClassName($this->getSubmission(), $this->getReviewRound());\n\t\t$reviewerForm->readInputData();\n\t\tif ($reviewerForm->validate()) {\n\t\t\t$reviewAssignment = $reviewerForm->execute();\n\t\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t\t} else {\n\t\t\t// There was an error, redisplay the form\n\t\t\treturn new JSONMessage(true, $reviewerForm->fetch($request));\n\t\t}\n\t}\n\n\t/**\n\t * Manage reviewer access to files\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction editReview($args, $request) {\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.EditReviewForm');\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$editReviewForm = new EditReviewForm($reviewAssignment);\n\t\t$editReviewForm->initData();\n\t\treturn new JSONMessage(true, $editReviewForm->fetch($request));\n\t}\n\n\t/**\n\t * Save a change to reviewer access to files\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction updateReview($args, $request) {\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.EditReviewForm');\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$editReviewForm = new EditReviewForm($reviewAssignment);\n\t\t$editReviewForm->readInputData();\n\t\tif ($editReviewForm->validate()) {\n\t\t\t$editReviewForm->execute();\n\t\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t\t} else {\n\t\t\treturn new JSONMessage(false);\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of all non-reviewer users in the system to populate the reviewer role assignment autocomplete.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction getUsersNotAssignedAsReviewers($args, $request) {\n\t\t$context = $request->getContext();\n\t\t$term = $request->getUserVar('term');\n\n\t\t$userGroupDao = DAORegistry::getDAO('UserGroupDAO'); /* @var $userGroupDao UserGroupDAO */\n\t\t$users = $userGroupDao->getUsersNotInRole(ROLE_ID_REVIEWER, $context->getId(), $term);\n\n\t\t$userList = array();\n\t\twhile ($user = $users->next()) {\n\t\t\t$label = $user->getFullName() . \" (\" . $user->getEmail() . \")\";\n\t\t\t$userList[] = array('label' => $label, 'value' => $user->getId());\n\t\t}\n\n\t\tif (count($userList) == 0) {\n\t\t\treturn $this->noAutocompleteResults();\n\t\t}\n\n\t\treturn new JSONMessage(true, $userList);\n\t}\n\n\t/**\n\t * Unassign a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction unassignReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.UnassignReviewerForm');\n\t\t$unassignReviewerForm = new UnassignReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$unassignReviewerForm->initData();\n\n\t\treturn new JSONMessage(true, $unassignReviewerForm->fetch($request));\n\t}\n\n\t/**\n\t * Reinstate a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tpublic function reinstateReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReinstateReviewerForm');\n\t\t$reinstateReviewerForm = new ReinstateReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$reinstateReviewerForm->initData();\n\n\t\treturn new JSONMessage(true, $reinstateReviewerForm->fetch($request));\n\t}\n\n\t/**\n\t * Save the reviewer reinstatement\n\t * @param mixed $args\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tpublic function updateReinstateReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReinstateReviewerForm');\n\t\t$reinstateReviewerForm = new ReinstateReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$reinstateReviewerForm->readInputData();\n\n\t\t// Reinstate the reviewer and return status message\n\t\tif (!$reinstateReviewerForm->validate()) {\n\t\t\treturn new JSONMessage(false, __('editor.review.errorReinstatingReviewer'));\n\t\t}\n\n\t\t$reinstateReviewerForm->execute();\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * Save the reviewer unassignment\n\t *\n\t * @param mixed $args\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction updateUnassignReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.UnassignReviewerForm');\n\t\t$unassignReviewerForm = new UnassignReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$unassignReviewerForm->readInputData();\n\n\t\t// Unassign the reviewer and return status message\n\t\tif (!$unassignReviewerForm->validate()) {\n\t\t\treturn new JSONMessage(false, __('editor.review.errorDeletingReviewer'));\n\t\t}\n\n\t\t$unassignReviewerForm->execute();\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * An action triggered by a confirmation modal to allow an editor to unconsider a review.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction unconsiderReview($args, $request) {\n\t\tif (!$request->checkCSRF()) return new JSONMessage(false);\n\n\t\t// This resets the state of the review to 'unread', but does not delete note history.\n\t\t$submission = $this->getSubmission();\n\t\t$user = $request->getUser();\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewAssignmentDao = DAORegistry::getDAO('ReviewAssignmentDAO'); /* @var $reviewAssignmentDao ReviewAssignmentDAO */\n\n\t\t$reviewAssignment->setUnconsidered(REVIEW_ASSIGNMENT_UNCONSIDERED);\n\t\t$reviewAssignmentDao->updateObject($reviewAssignment);\n\n\t\t// log the unconsider.\n\t\timport('lib.pkp.classes.log.SubmissionLog');\n\t\timport('classes.log.SubmissionEventLogEntry');\n\n\t\t$entry = new SubmissionEventLogEntry();\n\t\t$entry->setSubmissionId($reviewAssignment->getSubmissionId());\n\t\t$entry->setUserId($user->getId());\n\t\t$entry->setDateLogged(Core::getCurrentDate());\n\t\t$entry->setEventType(SUBMISSION_LOG_REVIEW_UNCONSIDERED);\n\n\t\tSubmissionLog::logEvent(\n\t\t\t$request,\n\t\t\t$submission,\n\t\t\tSUBMISSION_LOG_REVIEW_UNCONSIDERED,\n\t\t\t'log.review.reviewUnconsidered',\n\t\t\tarray(\n\t\t\t\t'editorName' => $user->getFullName(),\n\t\t\t\t'submissionId' => $submission->getId(),\n\t\t\t\t'round' => $reviewAssignment->getRound(),\n\t\t\t)\n\t\t);\n\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * Mark the review as read and trigger a rewrite of the row.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction reviewRead($args, $request) {\n\t\t// Retrieve review assignment.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT); /* @var $reviewAssignment ReviewAssignment */\n\n\t\t// Rate the reviewer's performance on this assignment\n\t\t$quality = $request->getUserVar('quality');\n\t\tif ($quality) {\n\t\t\t$reviewAssignment->setQuality((int) $quality);\n\t\t\t$reviewAssignment->setDateRated(Core::getCurrentDate());\n\t\t} else {\n\t\t\t$reviewAssignment->setQuality(null);\n\t\t\t$reviewAssignment->setDateRated(null);\n\t\t}\n\n\t\t// Mark the latest read date of the review by the editor.\n\t\t$user = $request->getUser();\n\t\t$viewsDao = DAORegistry::getDAO('ViewsDAO'); /* @var $viewsDao ViewsDAO */\n\t\t$viewsDao->recordView(ASSOC_TYPE_REVIEW_RESPONSE, $reviewAssignment->getId(), $user->getId());\n\n\t\t// if the review assignment had been unconsidered, update the flag.\n\t\tif ($reviewAssignment->getUnconsidered() == REVIEW_ASSIGNMENT_UNCONSIDERED) {\n\t\t\t$reviewAssignment->setUnconsidered(REVIEW_ASSIGNMENT_UNCONSIDERED_READ);\n\t\t}\n\n\t\tif (!$reviewAssignment->getDateCompleted()) {\n\t\t\t// Editor completes the review.\n\t\t\t$reviewAssignment->setDateConfirmed(Core::getCurrentDate());\n\t\t\t$reviewAssignment->setDateCompleted(Core::getCurrentDate());\n\t\t}\n\n\t\t// Trigger an update of the review round status\n\t\t$reviewAssignmentDao = DAORegistry::getDAO('ReviewAssignmentDAO'); /* @var $reviewAssignmentDao ReviewAssignmentDAO */\n\t\t$reviewAssignmentDao->updateObject($reviewAssignment);\n\n\t\t//if the review was read by an editor, log event\n\t\tif ($reviewAssignment->isRead()) {\n\t\t\timport('lib.pkp.classes.log.SubmissionLog');\n\t\t\timport('classes.log.SubmissionEventLogEntry');\n\n\t\t\t$submissionId = $reviewAssignment->getSubmissionId();\n\t\t\t$submissionDao = DAORegistry::getDAO('SubmissionDAO'); /* @var $submissionDao SubmissionDAO */\n\t\t\t$submission = $submissionDao->getById($submissionId);\n\n\t\t\tSubmissionLog::logEvent(\n\t\t\t\t$request,\n\t\t\t\t$submission,\n\t\t\t\tSUBMISSION_LOG_REVIEW_CONFIRMED,\n\t\t\t\t'log.review.reviewConfirmed',\n\t\t\t\tarray(\n\t\t\t\t\t'userName' => $user->getFullName(),\n\t\t\t\t\t'submissionId' => $reviewAssignment->getSubmissionId(),\n\t\t\t\t\t'round' => $reviewAssignment->getRound()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\t// Remove the reviewer task.\n\t\t$notificationDao = DAORegistry::getDAO('NotificationDAO'); /* @var $notificationDao NotificationDAO */\n\t\t$notificationDao->deleteByAssoc(\n\t\t\tASSOC_TYPE_REVIEW_ASSIGNMENT,\n\t\t\t$reviewAssignment->getId(),\n\t\t\t$reviewAssignment->getReviewerId(),\n\t\t\tNOTIFICATION_TYPE_REVIEW_ASSIGNMENT\n\t\t);\n\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * Displays a modal to allow the editor to enter a message to send to the reviewer as a thank you.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction editThankReviewer($args, $request) {\n\t\t// Identify the review assignment being updated.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Initialize form.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ThankReviewerForm');\n\t\t$thankReviewerForm = new ThankReviewerForm($reviewAssignment);\n\t\t$thankReviewerForm->initData();\n\n\t\t// Render form.\n\t\treturn new JSONMessage(true, $thankReviewerForm->fetch($request));\n\t}\n\n\t/**\n\t * Open a modal to read the reviewer's review and\n\t * download any files they may have uploaded\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction readReview($args, $request) {\n\t\t$templateMgr = TemplateManager::getManager($request);\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$starHtml = '<span class=\"fa fa-star\"></span>';\n\t\t$templateMgr->assign(array(\n\t\t\t'submission' => $this->getSubmission(),\n\t\t\t'reviewAssignment' => $reviewAssignment,\n\t\t\t'reviewerRatingOptions' => array(\n\t\t\t\t0 => __('editor.review.reviewerRating.none'),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_VERY_GOOD => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_VERY_GOOD),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_GOOD => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_GOOD),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_AVERAGE => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_AVERAGE),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_POOR => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_POOR),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_VERY_POOR => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_VERY_POOR),\n\t\t\t),\n\t\t\t'reviewerRecommendationOptions' => ReviewAssignment::getReviewerRecommendationOptions(),\n\t\t));\n\n\t\tif ($reviewAssignment->getReviewFormId()) {\n\t\t\t// Retrieve review form\n\t\t\t$context = $request->getContext();\n\t\t\t$reviewFormElementDao = DAORegistry::getDAO('ReviewFormElementDAO'); /* @var $reviewFormElementDao ReviewFormElementDAO */\n\t\t\t$reviewFormElements = $reviewFormElementDao->getByReviewFormId($reviewAssignment->getReviewFormId());\n\t\t\t$reviewFormResponseDao = DAORegistry::getDAO('ReviewFormResponseDAO'); /* @var $reviewFormResponseDao ReviewFormResponseDAO */\n\t\t\t$reviewFormResponses = $reviewFormResponseDao->getReviewReviewFormResponseValues($reviewAssignment->getId());\n\t\t\t$reviewFormDao = DAORegistry::getDAO('ReviewFormDAO'); /* @var $reviewFormDao ReviewFormDAO */\n\t\t\t$reviewformid = $reviewAssignment->getReviewFormId();\n\t\t\t$reviewForm = $reviewFormDao->getById($reviewAssignment->getReviewFormId(), Application::getContextAssocType(), $context->getId());\n\t\t\t$templateMgr->assign(array(\n\t\t\t\t'reviewForm' => $reviewForm,\n\t\t\t\t'reviewFormElements' => $reviewFormElements,\n\t\t\t\t'reviewFormResponses' => $reviewFormResponses,\n\t\t\t\t'disabled' => true,\n\t\t\t));\n\t\t} else {\n\t\t\t// Retrieve reviewer comments.\n\t\t\t$submissionCommentDao = DAORegistry::getDAO('SubmissionCommentDAO'); /* @var $submissionCommentDao SubmissionCommentDAO */\n\t\t\t$templateMgr->assign(array(\n\t\t\t\t'comments' => $submissionCommentDao->getReviewerCommentsByReviewerId($reviewAssignment->getSubmissionId(), null, $reviewAssignment->getId(), true),\n\t\t\t\t'commentsPrivate' => $submissionCommentDao->getReviewerCommentsByReviewerId($reviewAssignment->getSubmissionId(), null, $reviewAssignment->getId(), false),\n\t\t\t));\n\t\t}\n\n\n\t\t// Render the response.\n\t\treturn $templateMgr->fetchJson('controllers/grid/users/reviewer/readReview.tpl');\n\t}\n\n\t/**\n\t * Send the acknowledgement email, if desired, and trigger a row refresh action.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction thankReviewer($args, $request) {\n\t\t// Identify the review assignment being updated.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Form handling\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ThankReviewerForm');\n\t\t$thankReviewerForm = new ThankReviewerForm($reviewAssignment);\n\t\t$thankReviewerForm->readInputData();\n\t\tif ($thankReviewerForm->validate()) {\n\t\t\t$thankReviewerForm->execute();\n\t\t\t$json = DAO::getDataChangedEvent($reviewAssignment->getId());\n\t\t\t// Insert a trivial notification to indicate the reviewer was reminded successfully.\n\t\t\t$currentUser = $request->getUser();\n\t\t\t$notificationMgr = new NotificationManager();\n\t\t\t$messageKey = $thankReviewerForm->getData('skipEmail') ? __('notification.reviewAcknowledged') : __('notification.reviewerThankedEmail');\n\t\t\t$notificationMgr->createTrivialNotification($currentUser->getId(), NOTIFICATION_TYPE_SUCCESS, array('contents' => $messageKey));\n\t\t} else {\n\t\t\t$json = new JSONMessage(false, __('editor.review.thankReviewerError'));\n\t\t}\n\n\t\treturn $json;\n\t}\n\n\t/**\n\t * Displays a modal to allow the editor to enter a message to send to the reviewer as a reminder\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return string Serialized JSON object\n\t */\n\tfunction editReminder($args, $request) {\n\t\t// Identify the review assignment being updated.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Initialize form.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReviewReminderForm');\n\t\t$reviewReminderForm = new ReviewReminderForm($reviewAssignment);\n\t\t$reviewReminderForm->initData();\n\n\t\t// Render form.\n\t\treturn new JSONMessage(true, $reviewReminderForm->fetch($request));\n\t}\n\n\t/**\n\t * Send the reviewer reminder and close the modal\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction sendReminder($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Form handling\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReviewReminderForm');\n\t\t$reviewReminderForm = new ReviewReminderForm($reviewAssignment);\n\t\t$reviewReminderForm->readInputData();\n\t\tif ($reviewReminderForm->validate()) {\n\t\t\t$reviewReminderForm->execute();\n\t\t\t// Insert a trivial notification to indicate the reviewer was reminded successfully.\n\t\t\t$currentUser = $request->getUser();\n\t\t\t$notificationMgr = new NotificationManager();\n\t\t\t$notificationMgr->createTrivialNotification($currentUser->getId(), NOTIFICATION_TYPE_SUCCESS, array('contents' => __('notification.sentNotification')));\n\t\t\treturn new JSONMessage(true);\n\t\t} else {\n\t\t\treturn new JSONMessage(false, __('editor.review.reminderError'));\n\t\t}\n\t}\n\n\t/**\n\t * Displays a modal to send an email message to the user.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction sendEmail($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$submission = $this->getAuthorizedContextObject(ASSOC_TYPE_SUBMISSION);\n\n\t\t// Form handling.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.EmailReviewerForm');\n\t\t$emailReviewerForm = new EmailReviewerForm($reviewAssignment, $submission);\n\t\tif (!$request->isPost()) {\n\t\t\t$emailReviewerForm->initData();\n\t\t\treturn new JSONMessage(\n\t\t\t\ttrue,\n\t\t\t\t$emailReviewerForm->fetch(\n\t\t\t\t\t$request,\n\t\t\t\t\tnull,\n\t\t\t\t\tfalse,\n\t\t\t\t\t$this->getRequestArgs()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\t$emailReviewerForm->readInputData();\n\t\t$emailReviewerForm->execute();\n\t\treturn new JSONMessage(true);\n\t}\n\n\n\t/**\n\t * Displays a modal containing history for the review assignment.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction reviewHistory($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t$templateMgr = TemplateManager::getManager($request);\n\t\t$dates = array(\n\t\t\t'common.assigned' => $reviewAssignment->getDateAssigned(),\n\t\t\t'common.notified' => $reviewAssignment->getDateNotified(),\n\t\t\t'common.reminder' => $reviewAssignment->getDateReminded(),\n\t\t\t'common.confirm' => $reviewAssignment->getDateConfirmed(),\n\t\t\t'common.completed' => $reviewAssignment->getDateCompleted(),\n\t\t\t'common.acknowledged' => $reviewAssignment->getDateAcknowledged(),\n\t\t);\n\t\tasort($dates);\n\t\t$templateMgr->assign('dates', $dates);\n\n\t\treturn $templateMgr->fetchJson('workflow/reviewHistory.tpl');\n\t}\n\n\n\t/**\n\t * Displays a modal containing the gossip values for a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction gossip($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$userDao = DAORegistry::getDAO('UserDAO'); /* @var $userDao UserDAO */\n\t\t$user = $userDao->getById($reviewAssignment->getReviewerId());\n\n\t\t// Check that the current user is specifically allowed to access gossip for\n\t\t// this user\n\t\timport('classes.core.Services');\n\t\t$canCurrentUserGossip = Services::get('user')->canCurrentUserGossip($user->getId());\n\t\tif (!$canCurrentUserGossip) {\n\t\t\treturn new JSONMessage(false, __('user.authorization.roleBasedAccessDenied'));\n\t\t}\n\n\t\t$requestArgs = array_merge($this->getRequestArgs(), array('reviewAssignmentId' => $reviewAssignment->getId()));\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReviewerGossipForm');\n\t\t$reviewerGossipForm = new ReviewerGossipForm($user, $requestArgs);\n\n\t\t// View form\n\t\tif (!$request->isPost()) {\n\t\t\treturn new JSONMessage(true, $reviewerGossipForm->fetch($request));\n\t\t}\n\n\t\t// Execute form\n\t\t$reviewerGossipForm->readInputData();\n\t\tif ($reviewerGossipForm->validate()) {\n\t\t\t$reviewerGossipForm->execute();\n\t\t\treturn new JSONMessage(true);\n\t\t}\n\n\t\treturn new JSONMessage(false, __('user.authorization.roleBasedAccessDenied'));\n\t}\n\n\n\t/**\n\t * Fetches an email template's message body and returns it via AJAX.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction fetchTemplateBody($args, $request) {\n\t\timport('lib.pkp.classes.mail.SubmissionMailTemplate');\n\t\t$template = new SubmissionMailTemplate($this->getSubmission(), $request->getUserVar('template'));\n\t\tif (!$template) return;\n\n\t\t$user = $request->getUser();\n\t\t$dispatcher = $request->getDispatcher();\n\t\t$context = $request->getContext();\n\n\t\t$template->assignParams([\n\t\t\t'contextUrl' => $dispatcher->url($request, ROUTE_PAGE, $context->getPath()),\n\t\t\t'editorialContactSignature' => $user->getContactSignature(),\n\t\t\t'signatureFullName' => htmlspecialchars($user->getFullname()),\n\t\t\t'passwordResetUrl' => $dispatcher->url($request, ROUTE_PAGE, $context->getPath(), 'login', 'lostPassword'),\n\t\t\t'messageToReviewer' => __('reviewer.step1.requestBoilerplate'),\n\t\t\t'abstractTermIfEnabled' => $this->getSubmission()->getLocalizedAbstract() == '' ? '' : __('common.abstract'), // Deprecated; for OJS 2.x templates\n\t\t]);\n\t\t$template->replaceParams();\n\n\t\treturn new JSONMessage(true, $template->getBody());\n\t}\n\n\n\t//\n\t// Private helper methods\n\t//\n\t/**\n\t * Return a fetched reviewer form data in string.\n\t * @param $args Array\n\t * @param $request Request\n\t * @return String\n\t */\n\tfunction _fetchReviewerForm($args, $request) {\n\t\t$selectionType = $request->getUserVar('selectionType');\n\t\tassert(!empty($selectionType));\n\t\t$formClassName = $this->_getReviewerFormClassName($selectionType);\n\t\t$userRoles = $this->getAuthorizedContextObject(ASSOC_TYPE_USER_ROLES);\n\n\t\t// Form handling.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.' . $formClassName );\n\t\t$reviewerForm = new $formClassName($this->getSubmission(), $this->getReviewRound());\n\t\t$reviewerForm->initData();\n\t\t$reviewerForm->setUserRoles($userRoles);\n\n\t\treturn $reviewerForm->fetch($request);\n\t}\n\n\t/**\n\t * Get the name of ReviewerForm class for the current selection type.\n\t * @param $selectionType String (const)\n\t * @return FormClassName String\n\t */\n\tfunction _getReviewerFormClassName($selectionType) {\n\t\tswitch ($selectionType) {\n\t\t\tcase REVIEWER_SELECT_ADVANCED_SEARCH:\n\t\t\t\treturn 'AdvancedSearchReviewerForm';\n\t\t\tcase REVIEWER_SELECT_CREATE:\n\t\t\t\treturn 'CreateReviewerForm';\n\t\t\tcase REVIEWER_SELECT_ENROLL_EXISTING:\n\t\t\t\treturn 'EnrollExistingReviewerForm';\n\t\t}\n\t\tassert(false);\n\t}\n\n\t/**\n\t * Get operations that need a review assignment policy.\n\t * @return array\n\t */\n\tfunction _getReviewAssignmentOps() {\n\t\t// Define operations that need a review assignment policy.\n\t\treturn array('readReview', 'reviewHistory', 'reviewRead', 'editThankReviewer', 'thankReviewer', 'editReminder', 'sendReminder', 'unassignReviewer', 'updateUnassignReviewer', 'reinstateReviewer', 'updateReinstateReviewer', 'sendEmail', 'unconsiderReview', 'editReview', 'updateReview', 'gossip');\n\n\t}\n\n\t/**\n\t * Get operations that need a review round policy.\n\t * @return array\n\t */\n\tfunction _getReviewRoundOps() {\n\t\t// Define operations that need a review round policy.\n\t\treturn array(\n\t\t\t'fetchGrid', 'fetchRow', 'showReviewerForm', 'reloadReviewerForm',\n\t\t\t'createReviewer', 'enrollReviewer', 'updateReviewer',\n\t\t\t'getUsersNotAssignedAsReviewers',\n\t\t\t'fetchTemplateBody'\n\t\t);\n\t}\n\n\t/**\n\t * Get operations that an author is not allowed to access regardless of review\n\t * type.\n\t * @return array\n\t */\n\tprotected function _getAuthorDeniedOps() {\n\t\treturn array(\n\t\t\t'showReviewerForm',\n\t\t\t'reloadReviewerForm',\n\t\t\t'createReviewer',\n\t\t\t'enrollReviewer',\n\t\t\t'updateReviewer',\n\t\t\t'getUsersNotAssignedAsReviewers',\n\t\t\t'fetchTemplateBody',\n\t\t\t'editThankReviewer',\n\t\t\t'thankReviewer',\n\t\t\t'editReminder',\n\t\t\t'sendReminder',\n\t\t\t'unassignReviewer', 'updateUnassignReviewer',\n\t\t\t'reinstateReviewer', 'updateReinstateReviewer',\n\t\t\t'unconsiderReview',\n\t\t\t'editReview', 'updateReview',\n\t\t);\n\t}\n\n\t/**\n\t * Get additional operations that an author is not allowed to access when the\n\t * review type is anonymous or double-anonymous.\n\t * @return array\n\t */\n\tprotected function _getAuthorDeniedAnonymousOps() {\n\t\treturn array(\n\t\t\t'readReview',\n\t\t\t'reviewHistory',\n\t\t\t'reviewRead',\n\t\t\t'sendEmail',\n\t\t\t'gossip',\n\t\t);\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * @file classes/controllers/grid/users/reviewer/PKPReviewerGridHandler.inc.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class PKPReviewerGridHandler\n * @ingroup classes_controllers_grid_users_reviewer\n *\n * @brief Handle reviewer grid requests.\n */\n\n// import grid base classes\nimport('lib.pkp.classes.controllers.grid.GridHandler');\n\n// import reviewer grid specific classes\nimport('lib.pkp.controllers.grid.users.reviewer.ReviewerGridCellProvider');\nimport('lib.pkp.controllers.grid.users.reviewer.ReviewerGridRow');\n\n// Reviewer selection types\ndefine('REVIEWER_SELECT_ADVANCED_SEARCH',\t\t0x00000001);\ndefine('REVIEWER_SELECT_CREATE',\t\t\t0x00000002);\ndefine('REVIEWER_SELECT_ENROLL_EXISTING',\t\t0x00000003);\n\nclass PKPReviewerGridHandler extends GridHandler {\n\n\t/** @var Submission */\n\tvar $_submission;\n\n\t/** @var integer */\n\tvar $_stageId;\n\n\t/** @var boolean Is the current user assigned as an author to this submission */\n\tvar $_isCurrentUserAssignedAuthor;\n\n\tvar $isAuthorGrid;\n\n\t/**\n\t * Constructor\n\t */\n\tfunction __construct() {\n\t\tparent::__construct();\n\n\t\t$allOperations = array_merge($this->_getReviewAssignmentOps(), $this->_getReviewRoundOps());\n\n\t\t$this->addRoleAssignment(\n\t\t\tarray(ROLE_ID_MANAGER, ROLE_ID_SUB_EDITOR),\n\t\t\t$allOperations\n\t\t);\n\n\t\t// Remove operations related to creation and enrollment of users.\n\t\t$assistantOperations = array_flip($allOperations);\n\t\tunset($assistantOperations['createReviewer']);\n\t\tunset($assistantOperations['enrollReviewer']);\n\t\tunset($assistantOperations['gossip']);\n\t\t$assistantOperations = array_flip($assistantOperations);\n\n\t\t$this->addRoleAssignment(\n\t\t\tarray(ROLE_ID_ASSISTANT),\n\t\t\t$assistantOperations\n\t\t);\n\n\t\t$this->isAuthorGrid = false;\n\t}\n\n\t/**\n\t * @copydoc PKPHandler::authorize()\n\t */\n\tfunction authorize($request, &$args, $roleAssignments) {\n\n\t\tif (!$this->isAuthorGrid) {\n\n\t\t\t$stageId = $request->getUserVar('stageId'); // This is being validated in WorkflowStageAccessPolicy\n\n\t\t\t// Not all actions need a stageId. Some work off the reviewAssignment which has the type and round.\n\t\t\t$this->_stageId = (int)$stageId;\n\n\t\t\t// Get the stage access policy\n\t\t\timport('lib.pkp.classes.security.authorization.WorkflowStageAccessPolicy');\n\t\t\t$workflowStageAccessPolicy = new WorkflowStageAccessPolicy($request, $args, $roleAssignments, 'submissionId', $stageId, WORKFLOW_TYPE_EDITORIAL);\n\n\t\t\t// Add policy to ensure there is a review round id.\n\t\t\timport('lib.pkp.classes.security.authorization.internal.ReviewRoundRequiredPolicy');\n\t\t\t$workflowStageAccessPolicy->addPolicy(new ReviewRoundRequiredPolicy($request, $args, 'reviewRoundId', $this->_getReviewRoundOps()));\n\n\t\t\t// Add policy to ensure there is a review assignment for certain operations.\n\t\t\timport('lib.pkp.classes.security.authorization.internal.ReviewAssignmentRequiredPolicy');\n\t\t\t$workflowStageAccessPolicy->addPolicy(new ReviewAssignmentRequiredPolicy($request, $args, 'reviewAssignmentId', $this->_getReviewAssignmentOps()));\n\t\t\t$this->addPolicy($workflowStageAccessPolicy);\n\n\t\t\t$success = parent::authorize($request, $args, $roleAssignments);\n\n\t\t\t// Prevent authors from accessing review details, even if they are also\n\t\t\t// assigned as an editor, sub-editor or assistant.\n\t\t\t$userAssignedRoles = $this->getAuthorizedContextObject(ASSOC_TYPE_ACCESSIBLE_WORKFLOW_STAGES);\n\t\t\t$this->_isCurrentUserAssignedAuthor = false;\n\t\t\tforeach ($userAssignedRoles as $stageId => $roles) {\n\t\t\t\tif (in_array(ROLE_ID_AUTHOR, $roles)) {\n\t\t\t\t\t$this->_isCurrentUserAssignedAuthor = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($this->_isCurrentUserAssignedAuthor) {\n\t\t\t\t$operation = $request->getRouter()->getRequestedOp($request);\n\n\t\t\t\tif (in_array($operation, $this->_getAuthorDeniedOps())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (in_array($operation, $this->_getAuthorDeniedAnonymousOps())) {\n\t\t\t\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t\t\t\tif ($reviewAssignment && in_array($reviewAssignment->getReviewMethod(), array(SUBMISSION_REVIEW_METHOD_ANONYMOUS, SUBMISSION_REVIEW_METHOD_DOUBLEANONYMOUS))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $success;\n\n\t\t} else {\n\t\t\treturn parent::authorize($request, $args, $roleAssignments);\n\t\t}\n\n\t}\n\n\n\t//\n\t// Getters and Setters\n\t//\n\t/**\n\t * Get the authorized submission.\n\t * @return Submission\n\t */\n\tfunction getSubmission() {\n\t\treturn $this->getAuthorizedContextObject(ASSOC_TYPE_SUBMISSION);\n\t}\n\n\t/**\n\t * Get the review stage id.\n\t * @return integer\n\t */\n\tfunction getStageId() {\n\t\treturn $this->_stageId;\n\t}\n\n\t/**\n\t * Get review round object.\n\t * @return ReviewRound\n\t */\n\tfunction getReviewRound() {\n\t\t$reviewRound = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ROUND);\n\t\tif (is_a($reviewRound, 'ReviewRound')) {\n\t\t\treturn $reviewRound;\n\t\t} else {\n\t\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t\t$reviewRoundId = $reviewAssignment->getReviewRoundId();\n\t\t\t$reviewRoundDao = DAORegistry::getDAO('ReviewRoundDAO'); /* @var $reviewRoundDao ReviewRoundDAO */\n\t\t\t$reviewRound = $reviewRoundDao->getById($reviewRoundId);\n\t\t\treturn $reviewRound;\n\t\t}\n\t}\n\n\n\t//\n\t// Overridden methods from PKPHandler\n\t//\n\t/**\n\t * @copydoc GridHandler::initialize()\n\t */\n\tfunction initialize($request, $args = null) {\n\t\tparent::initialize($request, $args);\n\n\t\t// Load submission-specific translations\n\t\tAppLocale::requireComponents(\n\t\t\tLOCALE_COMPONENT_PKP_SUBMISSION,\n\t\t\tLOCALE_COMPONENT_PKP_MANAGER,\n\t\t\tLOCALE_COMPONENT_PKP_USER,\n\t\t\tLOCALE_COMPONENT_PKP_EDITOR,\n\t\t\tLOCALE_COMPONENT_PKP_REVIEWER,\n\t\t\tLOCALE_COMPONENT_APP_EDITOR\n\t\t);\n\n\t\t$this->setTitle('user.role.reviewers');\n\n\t\t// Grid actions\n\t\tif (!$this->_isCurrentUserAssignedAuthor) {\n\t\t\timport('lib.pkp.classes.linkAction.request.AjaxModal');\n\t\t\t$router = $request->getRouter();\n\t\t\t$actionArgs = array_merge($this->getRequestArgs(), array('selectionType' => REVIEWER_SELECT_ADVANCED_SEARCH));\n\t\t\t$this->addAction(\n\t\t\t\tnew LinkAction(\n\t\t\t\t\t'addReviewer',\n\t\t\t\t\tnew AjaxModal(\n\t\t\t\t\t\t$router->url($request, null, null, 'showReviewerForm', null, $actionArgs),\n\t\t\t\t\t\t__('editor.submission.addReviewer'),\n\t\t\t\t\t\t'modal_add_user'\n\t\t\t\t\t),\n\t\t\t\t\t__('editor.submission.addReviewer'),\n\t\t\t\t\t'add_user'\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\t// Columns\n\t\t$cellProvider = new ReviewerGridCellProvider($this->_isCurrentUserAssignedAuthor);\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'name',\n\t\t\t\t'user.name',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider\n\t\t\t)\n\t\t);\n\n\t\t// Add a column for the status of the review.\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'considered',\n\t\t\t\t'common.status',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider,\n\t\t\t\tarray('anyhtml' => true)\n\t\t\t)\n\t\t);\n\n\t\t// Add a column for the review method\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'method',\n\t\t\t\t'common.type',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider\n\t\t\t)\n\t\t);\n\n\t\t// Add a column for the status of the review.\n\t\t$this->addColumn(\n\t\t\tnew GridColumn(\n\t\t\t\t'actions',\n\t\t\t\t'grid.columns.actions',\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t$cellProvider\n\t\t\t)\n\t\t);\n\t}\n\n\n\t//\n\t// Overridden methods from GridHandler\n\t//\n\t/**\n\t * @see GridHandler::getRowInstance()\n\t * @return ReviewerGridRow\n\t */\n\tprotected function getRowInstance() {\n\t\treturn new ReviewerGridRow($this->_isCurrentUserAssignedAuthor);\n\t}\n\n\t/**\n\t * @see GridHandler::getRequestArgs()\n\t */\n\tfunction getRequestArgs() {\n\t\t$submission = $this->getSubmission();\n\t\t$reviewRound = $this->getReviewRound();\n\t\treturn array(\n\t\t\t'submissionId' => $submission->getId(),\n\t\t\t'stageId' => $this->getStageId(),\n\t\t\t'reviewRoundId' => $reviewRound->getId()\n\t\t);\n\t}\n\n\t/**\n\t * @see GridHandler::loadData()\n\t */\n\tprotected function loadData($request, $filter) {\n\t\t// Get the existing review assignments for this submission\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$reviewAssignmentDao = DAORegistry::getDAO('ReviewAssignmentDAO'); /* @var $reviewAssignmentDao ReviewAssignmentDAO */\n\t\treturn $reviewAssignmentDao->getByReviewRoundId($reviewRound->getId());\n\t}\n\n\n\t//\n\t// Public actions\n\t//\n\t/**\n\t * Add a reviewer.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction showReviewerForm($args, $request) {\n\t\treturn new JSONMessage(true, $this->_fetchReviewerForm($args, $request));\n\t}\n\n\t/**\n\t * Load the contents of the reviewer form\n\t * @param $args array\n\t * @param $request Request\n\t * @return JSONMessage JSON object\n\t */\n\tfunction reloadReviewerForm($args, $request) {\n\t\t$json = new JSONMessage(true);\n\t\t$json->setEvent('refreshForm', $this->_fetchReviewerForm($args, $request));\n\t\treturn $json;\n\t}\n\n\t/**\n\t * Create a new user as reviewer.\n\t * @param $args Array\n\t * @param $request Request\n\t * @return string Serialized JSON object\n\t */\n\tfunction createReviewer($args, $request) {\n\t\treturn $this->updateReviewer($args, $request);\n\t}\n\n\t/**\n\t * Enroll an existing user as reviewer.\n\t * @param $args Array\n\t * @param $request Request\n\t * @return string Serialized JSON object\n\t */\n\tfunction enrollReviewer($args, $request) {\n\t\treturn $this->updateReviewer($args, $request);\n\t}\n\n\t/**\n\t * Edit a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction updateReviewer($args, $request) {\n\t\t$selectionType = $request->getUserVar('selectionType');\n\t\t$formClassName = $this->_getReviewerFormClassName($selectionType);\n\n\t\t// Form handling\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.' . $formClassName );\n\t\t$reviewerForm = new $formClassName($this->getSubmission(), $this->getReviewRound());\n\t\t$reviewerForm->readInputData();\n\t\tif ($reviewerForm->validate()) {\n\t\t\t$reviewAssignment = $reviewerForm->execute();\n\t\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t\t} else {\n\t\t\t// There was an error, redisplay the form\n\t\t\treturn new JSONMessage(true, $reviewerForm->fetch($request));\n\t\t}\n\t}\n\n\t/**\n\t * Manage reviewer access to files\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction editReview($args, $request) {\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.EditReviewForm');\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$editReviewForm = new EditReviewForm($reviewAssignment);\n\t\t$editReviewForm->initData();\n\t\treturn new JSONMessage(true, $editReviewForm->fetch($request));\n\t}\n\n\t/**\n\t * Save a change to reviewer access to files\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction updateReview($args, $request) {\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.EditReviewForm');\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$editReviewForm = new EditReviewForm($reviewAssignment);\n\t\t$editReviewForm->readInputData();\n\t\tif ($editReviewForm->validate()) {\n\t\t\t$editReviewForm->execute();\n\t\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t\t} else {\n\t\t\treturn new JSONMessage(false);\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of all non-reviewer users in the system to populate the reviewer role assignment autocomplete.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction getUsersNotAssignedAsReviewers($args, $request) {\n\t\t$context = $request->getContext();\n\t\t$term = $request->getUserVar('term');\n\n\t\t$userGroupDao = DAORegistry::getDAO('UserGroupDAO'); /* @var $userGroupDao UserGroupDAO */\n\t\t$users = $userGroupDao->getUsersNotInRole(ROLE_ID_REVIEWER, $context->getId(), $term);\n\n\t\t$userList = array();\n\t\twhile ($user = $users->next()) {\n\t\t\t$label = $user->getFullName() . \" (\" . $user->getEmail() . \")\";\n\t\t\t$userList[] = array('label' => $label, 'value' => $user->getId());\n\t\t}\n\n\t\tif (count($userList) == 0) {\n\t\t\treturn $this->noAutocompleteResults();\n\t\t}\n\n\t\treturn new JSONMessage(true, $userList);\n\t}\n\n\t/**\n\t * Unassign a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction unassignReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.UnassignReviewerForm');\n\t\t$unassignReviewerForm = new UnassignReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$unassignReviewerForm->initData();\n\n\t\treturn new JSONMessage(true, $unassignReviewerForm->fetch($request));\n\t}\n\n\t/**\n\t * Reinstate a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tpublic function reinstateReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReinstateReviewerForm');\n\t\t$reinstateReviewerForm = new ReinstateReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$reinstateReviewerForm->initData();\n\n\t\treturn new JSONMessage(true, $reinstateReviewerForm->fetch($request));\n\t}\n\n\t/**\n\t * Save the reviewer reinstatement\n\t * @param mixed $args\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tpublic function updateReinstateReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReinstateReviewerForm');\n\t\t$reinstateReviewerForm = new ReinstateReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$reinstateReviewerForm->readInputData();\n\n\t\t// Reinstate the reviewer and return status message\n\t\tif (!$reinstateReviewerForm->validate()) {\n\t\t\treturn new JSONMessage(false, __('editor.review.errorReinstatingReviewer'));\n\t\t}\n\n\t\t$reinstateReviewerForm->execute();\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * Save the reviewer unassignment\n\t *\n\t * @param mixed $args\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction updateUnassignReviewer($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewRound = $this->getReviewRound();\n\t\t$submission = $this->getSubmission();\n\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.UnassignReviewerForm');\n\t\t$unassignReviewerForm = new UnassignReviewerForm($reviewAssignment, $reviewRound, $submission);\n\t\t$unassignReviewerForm->readInputData();\n\n\t\t// Unassign the reviewer and return status message\n\t\tif (!$unassignReviewerForm->validate()) {\n\t\t\treturn new JSONMessage(false, __('editor.review.errorDeletingReviewer'));\n\t\t}\n\n\t\t$unassignReviewerForm->execute();\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * An action triggered by a confirmation modal to allow an editor to unconsider a review.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction unconsiderReview($args, $request) {\n\t\tif (!$request->checkCSRF()) return new JSONMessage(false);\n\n\t\t// This resets the state of the review to 'unread', but does not delete note history.\n\t\t$submission = $this->getSubmission();\n\t\t$user = $request->getUser();\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$reviewAssignmentDao = DAORegistry::getDAO('ReviewAssignmentDAO'); /* @var $reviewAssignmentDao ReviewAssignmentDAO */\n\n\t\t$reviewAssignment->setUnconsidered(REVIEW_ASSIGNMENT_UNCONSIDERED);\n\t\t$reviewAssignmentDao->updateObject($reviewAssignment);\n\n\t\t// log the unconsider.\n\t\timport('lib.pkp.classes.log.SubmissionLog');\n\t\timport('classes.log.SubmissionEventLogEntry');\n\n\t\t$entry = new SubmissionEventLogEntry();\n\t\t$entry->setSubmissionId($reviewAssignment->getSubmissionId());\n\t\t$entry->setUserId($user->getId());\n\t\t$entry->setDateLogged(Core::getCurrentDate());\n\t\t$entry->setEventType(SUBMISSION_LOG_REVIEW_UNCONSIDERED);\n\n\t\tSubmissionLog::logEvent(\n\t\t\t$request,\n\t\t\t$submission,\n\t\t\tSUBMISSION_LOG_REVIEW_UNCONSIDERED,\n\t\t\t'log.review.reviewUnconsidered',\n\t\t\tarray(\n\t\t\t\t'editorName' => $user->getFullName(),\n\t\t\t\t'submissionId' => $submission->getId(),\n\t\t\t\t'round' => $reviewAssignment->getRound(),\n\t\t\t)\n\t\t);\n\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * Mark the review as read and trigger a rewrite of the row.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction reviewRead($args, $request) {\n\t\tif (!$request->checkCSRF()) return new JSONMessage(false);\n\n\t\t// Retrieve review assignment.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT); /* @var $reviewAssignment ReviewAssignment */\n\n\t\t// Rate the reviewer's performance on this assignment\n\t\t$quality = $request->getUserVar('quality');\n\t\tif ($quality) {\n\t\t\t$reviewAssignment->setQuality((int) $quality);\n\t\t\t$reviewAssignment->setDateRated(Core::getCurrentDate());\n\t\t} else {\n\t\t\t$reviewAssignment->setQuality(null);\n\t\t\t$reviewAssignment->setDateRated(null);\n\t\t}\n\n\t\t// Mark the latest read date of the review by the editor.\n\t\t$user = $request->getUser();\n\t\t$viewsDao = DAORegistry::getDAO('ViewsDAO'); /* @var $viewsDao ViewsDAO */\n\t\t$viewsDao->recordView(ASSOC_TYPE_REVIEW_RESPONSE, $reviewAssignment->getId(), $user->getId());\n\n\t\t// if the review assignment had been unconsidered, update the flag.\n\t\tif ($reviewAssignment->getUnconsidered() == REVIEW_ASSIGNMENT_UNCONSIDERED) {\n\t\t\t$reviewAssignment->setUnconsidered(REVIEW_ASSIGNMENT_UNCONSIDERED_READ);\n\t\t}\n\n\t\tif (!$reviewAssignment->getDateCompleted()) {\n\t\t\t// Editor completes the review.\n\t\t\t$reviewAssignment->setDateConfirmed(Core::getCurrentDate());\n\t\t\t$reviewAssignment->setDateCompleted(Core::getCurrentDate());\n\t\t}\n\n\t\t// Trigger an update of the review round status\n\t\t$reviewAssignmentDao = DAORegistry::getDAO('ReviewAssignmentDAO'); /* @var $reviewAssignmentDao ReviewAssignmentDAO */\n\t\t$reviewAssignmentDao->updateObject($reviewAssignment);\n\n\t\t//if the review was read by an editor, log event\n\t\tif ($reviewAssignment->isRead()) {\n\t\t\timport('lib.pkp.classes.log.SubmissionLog');\n\t\t\timport('classes.log.SubmissionEventLogEntry');\n\n\t\t\t$submissionId = $reviewAssignment->getSubmissionId();\n\t\t\t$submissionDao = DAORegistry::getDAO('SubmissionDAO'); /* @var $submissionDao SubmissionDAO */\n\t\t\t$submission = $submissionDao->getById($submissionId);\n\n\t\t\tSubmissionLog::logEvent(\n\t\t\t\t$request,\n\t\t\t\t$submission,\n\t\t\t\tSUBMISSION_LOG_REVIEW_CONFIRMED,\n\t\t\t\t'log.review.reviewConfirmed',\n\t\t\t\tarray(\n\t\t\t\t\t'userName' => $user->getFullName(),\n\t\t\t\t\t'submissionId' => $reviewAssignment->getSubmissionId(),\n\t\t\t\t\t'round' => $reviewAssignment->getRound()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\t// Remove the reviewer task.\n\t\t$notificationDao = DAORegistry::getDAO('NotificationDAO'); /* @var $notificationDao NotificationDAO */\n\t\t$notificationDao->deleteByAssoc(\n\t\t\tASSOC_TYPE_REVIEW_ASSIGNMENT,\n\t\t\t$reviewAssignment->getId(),\n\t\t\t$reviewAssignment->getReviewerId(),\n\t\t\tNOTIFICATION_TYPE_REVIEW_ASSIGNMENT\n\t\t);\n\n\t\treturn DAO::getDataChangedEvent($reviewAssignment->getId());\n\t}\n\n\t/**\n\t * Displays a modal to allow the editor to enter a message to send to the reviewer as a thank you.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction editThankReviewer($args, $request) {\n\t\t// Identify the review assignment being updated.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Initialize form.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ThankReviewerForm');\n\t\t$thankReviewerForm = new ThankReviewerForm($reviewAssignment);\n\t\t$thankReviewerForm->initData();\n\n\t\t// Render form.\n\t\treturn new JSONMessage(true, $thankReviewerForm->fetch($request));\n\t}\n\n\t/**\n\t * Open a modal to read the reviewer's review and\n\t * download any files they may have uploaded\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction readReview($args, $request) {\n\t\t$templateMgr = TemplateManager::getManager($request);\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$starHtml = '<span class=\"fa fa-star\"></span>';\n\t\t$templateMgr->assign(array(\n\t\t\t'submission' => $this->getSubmission(),\n\t\t\t'reviewAssignment' => $reviewAssignment,\n\t\t\t'reviewerRatingOptions' => array(\n\t\t\t\t0 => __('editor.review.reviewerRating.none'),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_VERY_GOOD => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_VERY_GOOD),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_GOOD => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_GOOD),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_AVERAGE => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_AVERAGE),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_POOR => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_POOR),\n\t\t\t\tSUBMISSION_REVIEWER_RATING_VERY_POOR => str_repeat($starHtml, SUBMISSION_REVIEWER_RATING_VERY_POOR),\n\t\t\t),\n\t\t\t'reviewerRecommendationOptions' => ReviewAssignment::getReviewerRecommendationOptions(),\n\t\t));\n\n\t\tif ($reviewAssignment->getReviewFormId()) {\n\t\t\t// Retrieve review form\n\t\t\t$context = $request->getContext();\n\t\t\t$reviewFormElementDao = DAORegistry::getDAO('ReviewFormElementDAO'); /* @var $reviewFormElementDao ReviewFormElementDAO */\n\t\t\t$reviewFormElements = $reviewFormElementDao->getByReviewFormId($reviewAssignment->getReviewFormId());\n\t\t\t$reviewFormResponseDao = DAORegistry::getDAO('ReviewFormResponseDAO'); /* @var $reviewFormResponseDao ReviewFormResponseDAO */\n\t\t\t$reviewFormResponses = $reviewFormResponseDao->getReviewReviewFormResponseValues($reviewAssignment->getId());\n\t\t\t$reviewFormDao = DAORegistry::getDAO('ReviewFormDAO'); /* @var $reviewFormDao ReviewFormDAO */\n\t\t\t$reviewformid = $reviewAssignment->getReviewFormId();\n\t\t\t$reviewForm = $reviewFormDao->getById($reviewAssignment->getReviewFormId(), Application::getContextAssocType(), $context->getId());\n\t\t\t$templateMgr->assign(array(\n\t\t\t\t'reviewForm' => $reviewForm,\n\t\t\t\t'reviewFormElements' => $reviewFormElements,\n\t\t\t\t'reviewFormResponses' => $reviewFormResponses,\n\t\t\t\t'disabled' => true,\n\t\t\t));\n\t\t} else {\n\t\t\t// Retrieve reviewer comments.\n\t\t\t$submissionCommentDao = DAORegistry::getDAO('SubmissionCommentDAO'); /* @var $submissionCommentDao SubmissionCommentDAO */\n\t\t\t$templateMgr->assign(array(\n\t\t\t\t'comments' => $submissionCommentDao->getReviewerCommentsByReviewerId($reviewAssignment->getSubmissionId(), null, $reviewAssignment->getId(), true),\n\t\t\t\t'commentsPrivate' => $submissionCommentDao->getReviewerCommentsByReviewerId($reviewAssignment->getSubmissionId(), null, $reviewAssignment->getId(), false),\n\t\t\t));\n\t\t}\n\n\n\t\t// Render the response.\n\t\treturn $templateMgr->fetchJson('controllers/grid/users/reviewer/readReview.tpl');\n\t}\n\n\t/**\n\t * Send the acknowledgement email, if desired, and trigger a row refresh action.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction thankReviewer($args, $request) {\n\t\t// Identify the review assignment being updated.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Form handling\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ThankReviewerForm');\n\t\t$thankReviewerForm = new ThankReviewerForm($reviewAssignment);\n\t\t$thankReviewerForm->readInputData();\n\t\tif ($thankReviewerForm->validate()) {\n\t\t\t$thankReviewerForm->execute();\n\t\t\t$json = DAO::getDataChangedEvent($reviewAssignment->getId());\n\t\t\t// Insert a trivial notification to indicate the reviewer was reminded successfully.\n\t\t\t$currentUser = $request->getUser();\n\t\t\t$notificationMgr = new NotificationManager();\n\t\t\t$messageKey = $thankReviewerForm->getData('skipEmail') ? __('notification.reviewAcknowledged') : __('notification.reviewerThankedEmail');\n\t\t\t$notificationMgr->createTrivialNotification($currentUser->getId(), NOTIFICATION_TYPE_SUCCESS, array('contents' => $messageKey));\n\t\t} else {\n\t\t\t$json = new JSONMessage(false, __('editor.review.thankReviewerError'));\n\t\t}\n\n\t\treturn $json;\n\t}\n\n\t/**\n\t * Displays a modal to allow the editor to enter a message to send to the reviewer as a reminder\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return string Serialized JSON object\n\t */\n\tfunction editReminder($args, $request) {\n\t\t// Identify the review assignment being updated.\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Initialize form.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReviewReminderForm');\n\t\t$reviewReminderForm = new ReviewReminderForm($reviewAssignment);\n\t\t$reviewReminderForm->initData();\n\n\t\t// Render form.\n\t\treturn new JSONMessage(true, $reviewReminderForm->fetch($request));\n\t}\n\n\t/**\n\t * Send the reviewer reminder and close the modal\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction sendReminder($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t// Form handling\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReviewReminderForm');\n\t\t$reviewReminderForm = new ReviewReminderForm($reviewAssignment);\n\t\t$reviewReminderForm->readInputData();\n\t\tif ($reviewReminderForm->validate()) {\n\t\t\t$reviewReminderForm->execute();\n\t\t\t// Insert a trivial notification to indicate the reviewer was reminded successfully.\n\t\t\t$currentUser = $request->getUser();\n\t\t\t$notificationMgr = new NotificationManager();\n\t\t\t$notificationMgr->createTrivialNotification($currentUser->getId(), NOTIFICATION_TYPE_SUCCESS, array('contents' => __('notification.sentNotification')));\n\t\t\treturn new JSONMessage(true);\n\t\t} else {\n\t\t\treturn new JSONMessage(false, __('editor.review.reminderError'));\n\t\t}\n\t}\n\n\t/**\n\t * Displays a modal to send an email message to the user.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction sendEmail($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$submission = $this->getAuthorizedContextObject(ASSOC_TYPE_SUBMISSION);\n\n\t\t// Form handling.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.EmailReviewerForm');\n\t\t$emailReviewerForm = new EmailReviewerForm($reviewAssignment, $submission);\n\t\tif (!$request->isPost()) {\n\t\t\t$emailReviewerForm->initData();\n\t\t\treturn new JSONMessage(\n\t\t\t\ttrue,\n\t\t\t\t$emailReviewerForm->fetch(\n\t\t\t\t\t$request,\n\t\t\t\t\tnull,\n\t\t\t\t\tfalse,\n\t\t\t\t\t$this->getRequestArgs()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\t$emailReviewerForm->readInputData();\n\t\t$emailReviewerForm->execute();\n\t\treturn new JSONMessage(true);\n\t}\n\n\n\t/**\n\t * Displays a modal containing history for the review assignment.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction reviewHistory($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\n\t\t$templateMgr = TemplateManager::getManager($request);\n\t\t$dates = array(\n\t\t\t'common.assigned' => $reviewAssignment->getDateAssigned(),\n\t\t\t'common.notified' => $reviewAssignment->getDateNotified(),\n\t\t\t'common.reminder' => $reviewAssignment->getDateReminded(),\n\t\t\t'common.confirm' => $reviewAssignment->getDateConfirmed(),\n\t\t\t'common.completed' => $reviewAssignment->getDateCompleted(),\n\t\t\t'common.acknowledged' => $reviewAssignment->getDateAcknowledged(),\n\t\t);\n\t\tasort($dates);\n\t\t$templateMgr->assign('dates', $dates);\n\n\t\treturn $templateMgr->fetchJson('workflow/reviewHistory.tpl');\n\t}\n\n\n\t/**\n\t * Displays a modal containing the gossip values for a reviewer\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction gossip($args, $request) {\n\t\t$reviewAssignment = $this->getAuthorizedContextObject(ASSOC_TYPE_REVIEW_ASSIGNMENT);\n\t\t$userDao = DAORegistry::getDAO('UserDAO'); /* @var $userDao UserDAO */\n\t\t$user = $userDao->getById($reviewAssignment->getReviewerId());\n\n\t\t// Check that the current user is specifically allowed to access gossip for\n\t\t// this user\n\t\timport('classes.core.Services');\n\t\t$canCurrentUserGossip = Services::get('user')->canCurrentUserGossip($user->getId());\n\t\tif (!$canCurrentUserGossip) {\n\t\t\treturn new JSONMessage(false, __('user.authorization.roleBasedAccessDenied'));\n\t\t}\n\n\t\t$requestArgs = array_merge($this->getRequestArgs(), array('reviewAssignmentId' => $reviewAssignment->getId()));\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.ReviewerGossipForm');\n\t\t$reviewerGossipForm = new ReviewerGossipForm($user, $requestArgs);\n\n\t\t// View form\n\t\tif (!$request->isPost()) {\n\t\t\treturn new JSONMessage(true, $reviewerGossipForm->fetch($request));\n\t\t}\n\n\t\t// Execute form\n\t\t$reviewerGossipForm->readInputData();\n\t\tif ($reviewerGossipForm->validate()) {\n\t\t\t$reviewerGossipForm->execute();\n\t\t\treturn new JSONMessage(true);\n\t\t}\n\n\t\treturn new JSONMessage(false, __('user.authorization.roleBasedAccessDenied'));\n\t}\n\n\n\t/**\n\t * Fetches an email template's message body and returns it via AJAX.\n\t * @param $args array\n\t * @param $request PKPRequest\n\t * @return JSONMessage JSON object\n\t */\n\tfunction fetchTemplateBody($args, $request) {\n\t\timport('lib.pkp.classes.mail.SubmissionMailTemplate');\n\t\t$template = new SubmissionMailTemplate($this->getSubmission(), $request->getUserVar('template'));\n\t\tif (!$template) return;\n\n\t\t$user = $request->getUser();\n\t\t$dispatcher = $request->getDispatcher();\n\t\t$context = $request->getContext();\n\n\t\t$template->assignParams([\n\t\t\t'contextUrl' => $dispatcher->url($request, ROUTE_PAGE, $context->getPath()),\n\t\t\t'editorialContactSignature' => $user->getContactSignature(),\n\t\t\t'signatureFullName' => htmlspecialchars($user->getFullname()),\n\t\t\t'passwordResetUrl' => $dispatcher->url($request, ROUTE_PAGE, $context->getPath(), 'login', 'lostPassword'),\n\t\t\t'messageToReviewer' => __('reviewer.step1.requestBoilerplate'),\n\t\t\t'abstractTermIfEnabled' => $this->getSubmission()->getLocalizedAbstract() == '' ? '' : __('common.abstract'), // Deprecated; for OJS 2.x templates\n\t\t]);\n\t\t$template->replaceParams();\n\n\t\treturn new JSONMessage(true, $template->getBody());\n\t}\n\n\n\t//\n\t// Private helper methods\n\t//\n\t/**\n\t * Return a fetched reviewer form data in string.\n\t * @param $args Array\n\t * @param $request Request\n\t * @return String\n\t */\n\tfunction _fetchReviewerForm($args, $request) {\n\t\t$selectionType = $request->getUserVar('selectionType');\n\t\tassert(!empty($selectionType));\n\t\t$formClassName = $this->_getReviewerFormClassName($selectionType);\n\t\t$userRoles = $this->getAuthorizedContextObject(ASSOC_TYPE_USER_ROLES);\n\n\t\t// Form handling.\n\t\timport('lib.pkp.controllers.grid.users.reviewer.form.' . $formClassName );\n\t\t$reviewerForm = new $formClassName($this->getSubmission(), $this->getReviewRound());\n\t\t$reviewerForm->initData();\n\t\t$reviewerForm->setUserRoles($userRoles);\n\n\t\treturn $reviewerForm->fetch($request);\n\t}\n\n\t/**\n\t * Get the name of ReviewerForm class for the current selection type.\n\t * @param $selectionType String (const)\n\t * @return FormClassName String\n\t */\n\tfunction _getReviewerFormClassName($selectionType) {\n\t\tswitch ($selectionType) {\n\t\t\tcase REVIEWER_SELECT_ADVANCED_SEARCH:\n\t\t\t\treturn 'AdvancedSearchReviewerForm';\n\t\t\tcase REVIEWER_SELECT_CREATE:\n\t\t\t\treturn 'CreateReviewerForm';\n\t\t\tcase REVIEWER_SELECT_ENROLL_EXISTING:\n\t\t\t\treturn 'EnrollExistingReviewerForm';\n\t\t}\n\t\tassert(false);\n\t}\n\n\t/**\n\t * Get operations that need a review assignment policy.\n\t * @return array\n\t */\n\tfunction _getReviewAssignmentOps() {\n\t\t// Define operations that need a review assignment policy.\n\t\treturn array('readReview', 'reviewHistory', 'reviewRead', 'editThankReviewer', 'thankReviewer', 'editReminder', 'sendReminder', 'unassignReviewer', 'updateUnassignReviewer', 'reinstateReviewer', 'updateReinstateReviewer', 'sendEmail', 'unconsiderReview', 'editReview', 'updateReview', 'gossip');\n\n\t}\n\n\t/**\n\t * Get operations that need a review round policy.\n\t * @return array\n\t */\n\tfunction _getReviewRoundOps() {\n\t\t// Define operations that need a review round policy.\n\t\treturn array(\n\t\t\t'fetchGrid', 'fetchRow', 'showReviewerForm', 'reloadReviewerForm',\n\t\t\t'createReviewer', 'enrollReviewer', 'updateReviewer',\n\t\t\t'getUsersNotAssignedAsReviewers',\n\t\t\t'fetchTemplateBody'\n\t\t);\n\t}\n\n\t/**\n\t * Get operations that an author is not allowed to access regardless of review\n\t * type.\n\t * @return array\n\t */\n\tprotected function _getAuthorDeniedOps() {\n\t\treturn array(\n\t\t\t'showReviewerForm',\n\t\t\t'reloadReviewerForm',\n\t\t\t'createReviewer',\n\t\t\t'enrollReviewer',\n\t\t\t'updateReviewer',\n\t\t\t'getUsersNotAssignedAsReviewers',\n\t\t\t'fetchTemplateBody',\n\t\t\t'editThankReviewer',\n\t\t\t'thankReviewer',\n\t\t\t'editReminder',\n\t\t\t'sendReminder',\n\t\t\t'unassignReviewer', 'updateUnassignReviewer',\n\t\t\t'reinstateReviewer', 'updateReinstateReviewer',\n\t\t\t'unconsiderReview',\n\t\t\t'editReview', 'updateReview',\n\t\t);\n\t}\n\n\t/**\n\t * Get additional operations that an author is not allowed to access when the\n\t * review type is anonymous or double-anonymous.\n\t * @return array\n\t */\n\tprotected function _getAuthorDeniedAnonymousOps() {\n\t\treturn array(\n\t\t\t'readReview',\n\t\t\t'reviewHistory',\n\t\t\t'reviewRead',\n\t\t\t'sendEmail',\n\t\t\t'gossip',\n\t\t);\n\t}\n}\n"], "filenames": ["classes/controllers/grid/users/reviewer/PKPReviewerGridHandler.inc.php"], "buggy_code_start_loc": [552], "buggy_code_end_loc": [552], "fixing_code_start_loc": [553], "fixing_code_end_loc": [555], "type": "CWE-352", "message": "Cross-Site Request Forgery (CSRF) in GitHub repository pkp/pkp-lib prior to 3.3.0-16.", "other": {"cve": {"id": "CVE-2023-5899", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-01T01:15:08.067", "lastModified": "2023-11-08T00:26:14.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery (CSRF) in GitHub repository pkp/pkp-lib prior to 3.3.0-16."}, {"lang": "es", "value": "Cross-Site Request Forgery (CSRF) en el repositorio de GitHub pkp/pkp-lib anterior a 3.3.0-16."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pkp:pkp_web_application_library:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.0-16", "matchCriteriaId": "620A9B67-F772-49B8-87D8-001DCD83FA6E"}]}]}], "references": [{"url": "https://github.com/pkp/pkp-lib/commit/04e0e0eaeacd5d754b2f39c42148b31f646113c5", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/0c7f1981-3bba-4508-a07e-4cb9a2553216", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pkp/pkp-lib/commit/04e0e0eaeacd5d754b2f39c42148b31f646113c5"}}