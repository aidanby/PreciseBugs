{"buggy_code": ["# Copyright 2020 Planet Labs, Inc.\n# Copyright 2022 Planet Labs PBC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n'''Manage authentication with Planet APIs'''\nfrom __future__ import annotations  # https://stackoverflow.com/a/33533514\nimport abc\nimport json\nimport logging\nimport os\nimport pathlib\nimport typing\n\nimport httpx\nimport jwt\n\nfrom . import http\nfrom .constants import ENV_API_KEY, PLANET_BASE_URL, SECRET_FILE_PATH\nfrom .exceptions import AuthException\nfrom typing import Optional\n\nLOGGER = logging.getLogger(__name__)\n\nBASE_URL = f'{PLANET_BASE_URL}/v0/auth'\n\nAuthType = httpx.Auth\n\n\nclass Auth(metaclass=abc.ABCMeta):\n    '''Handle authentication information for use with Planet APIs.'''\n\n    @staticmethod\n    def from_key(key: str) -> AuthType:\n        '''Obtain authentication from api key.\n\n        Parameters:\n            key: Planet API key\n        '''\n        auth = APIKeyAuth(key=key)\n        LOGGER.debug('Auth obtained from api key.')\n        return auth\n\n    @staticmethod\n    def from_file(\n        filename: Optional[typing.Union[str,\n                                        pathlib.Path]] = None) -> AuthType:\n        '''Create authentication from secret file.\n\n        The secret file is named `.planet.json` and is stored in the user\n        directory. The file has a special format and should have been created\n        with `Auth.write()`.\n\n        Parameters:\n            filename: Alternate path for the planet secret file.\n\n        '''\n        filename = filename or SECRET_FILE_PATH\n\n        try:\n            secrets = _SecretFile(filename).read()\n            auth = APIKeyAuth.from_dict(secrets)\n        except FileNotFoundError:\n            raise AuthException(f'File {filename} does not exist.')\n        except (KeyError, json.decoder.JSONDecodeError):\n            raise AuthException(f'File {filename} is not the correct format.')\n\n        LOGGER.debug(f'Auth read from secret file {filename}.')\n        return auth\n\n    @staticmethod\n    def from_env(variable_name: Optional[str] = None) -> AuthType:\n        '''Create authentication from environment variable.\n\n        Reads the `PL_API_KEY` environment variable\n\n        Parameters:\n            variable_name: Alternate environment variable.\n        '''\n        variable_name = variable_name or ENV_API_KEY\n        api_key = os.getenv(variable_name, '')\n        try:\n            auth = APIKeyAuth(api_key)\n            LOGGER.debug(f'Auth set from environment variable {variable_name}')\n        except APIKeyAuthException:\n            raise AuthException(\n                f'Environment variable {variable_name} either does not exist '\n                'or is empty.')\n        return auth\n\n    @staticmethod\n    def from_login(email: str,\n                   password: str,\n                   base_url: Optional[str] = None) -> AuthType:\n        '''Create authentication from login email and password.\n\n        Note: To keep your password secure, the use of `getpass` is\n        recommended.\n\n        Parameters:\n            email: Planet account email address.\n            password: Planet account password.\n            base_url: The base URL to use. Defaults to production\n                authentication API base url.\n        '''\n        cl = AuthClient(base_url=base_url)\n        auth_data = cl.login(email, password)\n\n        api_key = auth_data['api_key']\n        auth = APIKeyAuth(api_key)\n        LOGGER.debug('Auth set from login email and password')\n        return auth\n\n    @classmethod\n    @abc.abstractmethod\n    def from_dict(cls, data: dict) -> AuthType:\n        pass\n\n    @property\n    @abc.abstractmethod\n    def value(self):\n        pass\n\n    @abc.abstractmethod\n    def to_dict(self) -> dict:\n        pass\n\n    def store(self,\n              filename: Optional[typing.Union[str, pathlib.Path]] = None):\n        '''Store authentication information in secret file.\n\n        Parameters:\n            filename: Alternate path for the planet secret file.\n        '''\n        filename = filename or SECRET_FILE_PATH\n        secret_file = _SecretFile(filename)\n        secret_file.write(self.to_dict())\n\n\nclass AuthClient:\n\n    def __init__(self, base_url: Optional[str] = None):\n        \"\"\"\n        Parameters:\n            base_url: The base URL to use. Defaults to production\n                authentication API base url.\n        \"\"\"\n        self._base_url = base_url or BASE_URL\n        if self._base_url.endswith('/'):\n            self._base_url = self._base_url[:-1]\n\n    def login(self, email: str, password: str) -> dict:\n        '''Login using email identity and credentials.\n\n        Note: To keep your password secure, the use of `getpass` is\n        recommended.\n\n        Parameters:\n            email: Planet account email address.\n            password:  Planet account password.\n\n        Returns:\n             A JSON object containing an `api_key` property with the user's\n        API_KEY.\n        '''\n        url = f'{self._base_url}/login'\n        data = {'email': email, 'password': password}\n\n        sess = http.AuthSession()\n        resp = sess.request(url=url, method='POST', json=data)\n        return self.decode_response(resp)\n\n    @staticmethod\n    def decode_response(response):\n        '''Decode the token JWT'''\n        token = response.json()['token']\n        return jwt.decode(token, options={'verify_signature': False})\n\n\nclass APIKeyAuthException(Exception):\n    '''exceptions thrown by APIKeyAuth'''\n    pass\n\n\nclass APIKeyAuth(httpx.BasicAuth, Auth):\n    '''Planet API Key authentication.'''\n    DICT_KEY = 'key'\n\n    def __init__(self, key: str):\n        '''Initialize APIKeyAuth.\n\n        Parameters:\n            key: API key.\n\n        Raises:\n            APIKeyException: If API key is None or empty string.\n        '''\n        if not key:\n            raise APIKeyAuthException('API key cannot be empty.')\n        self._key = key\n        super().__init__(self._key, '')\n\n    @classmethod\n    def from_dict(cls, data: dict) -> APIKeyAuth:\n        '''Instantiate APIKeyAuth from a dict.'''\n        api_key = data[cls.DICT_KEY]\n        return cls(api_key)\n\n    def to_dict(self):\n        '''Represent APIKeyAuth as a dict.'''\n        return {self.DICT_KEY: self._key}\n\n    @property\n    def value(self):\n        return self._key\n\n\nclass _SecretFile:\n\n    def __init__(self, path):\n        self.path = path\n\n    def write(self, contents: dict):\n        try:\n            secrets_to_write = self.read()\n            secrets_to_write.update(contents)\n        except (FileNotFoundError, KeyError, json.decoder.JSONDecodeError):\n            secrets_to_write = contents\n\n        self._write(secrets_to_write)\n\n    def _write(self, contents: dict):\n        LOGGER.debug(f'Writing to {self.path}')\n        with open(self.path, 'w') as fp:\n            fp.write(json.dumps(contents))\n\n    def read(self) -> dict:\n        LOGGER.debug(f'Reading from {self.path}')\n        with open(self.path, 'r') as fp:\n            contents = json.loads(fp.read())\n        return contents\n", "# Copyright 2020 Planet Labs, Inc.\n# Copyright 2022 Planet Labs PBC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport json\nimport logging\n\nimport pytest\n\nfrom planet import auth\n\nLOGGER = logging.getLogger(__name__)\n\n\n# skip the global mock of _SecretFile.read\n# for this module\n@pytest.fixture(autouse=True, scope='module')\ndef test_secretfile_read():\n    return\n\n\n@pytest.fixture\ndef secret_path(monkeypatch, tmp_path):\n    secret_path = str(tmp_path / '.test')\n    monkeypatch.setattr(auth, 'SECRET_FILE_PATH', secret_path)\n    yield secret_path\n\n\ndef test_Auth_from_key():\n    test_auth_env1 = auth.Auth.from_key('testkey')\n    assert test_auth_env1.value == 'testkey'\n\n\ndef test_Auth_from_key_empty():\n    with pytest.raises(auth.APIKeyAuthException):\n        _ = auth.Auth.from_key('')\n\n\ndef test_Auth_from_file(secret_path):\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"key\": \"testvar\"}')\n\n    test_auth = auth.Auth.from_file()\n    assert test_auth.value == 'testvar'\n\n\ndef test_Auth_from_file_doesnotexist(secret_path):\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_file(secret_path)\n\n\ndef test_Auth_from_file_wrongformat(secret_path):\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"notkey\": \"testvar\"}')\n\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_file(secret_path)\n\n\ndef test_Auth_from_file_alternate(tmp_path):\n    secret_path = str(tmp_path / '.test')\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"key\": \"testvar\"}')\n\n    test_auth = auth.Auth.from_file(secret_path)\n    assert test_auth.value == 'testvar'\n\n\ndef test_Auth_from_env(monkeypatch):\n    monkeypatch.setenv('PL_API_KEY', 'testkey')\n    test_auth_env = auth.Auth.from_env()\n    assert test_auth_env.value == 'testkey'\n\n\ndef test_Auth_from_env_failure(monkeypatch):\n    monkeypatch.delenv('PL_API_KEY', raising=False)\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_env()\n\n\ndef test_Auth_from_env_alternate_success(monkeypatch):\n    alternate = 'OTHER_VAR'\n    monkeypatch.setenv(alternate, 'testkey')\n    monkeypatch.delenv('PL_API_KEY', raising=False)\n\n    test_auth_env = auth.Auth.from_env(alternate)\n    assert test_auth_env.value == 'testkey'\n\n\ndef test_Auth_from_env_alternate_doesnotexist(monkeypatch):\n    alternate = 'OTHER_VAR'\n    monkeypatch.delenv(alternate, raising=False)\n    monkeypatch.delenv('PL_API_KEY', raising=False)\n\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_env(alternate)\n\n\ndef test_Auth_from_login(monkeypatch):\n    auth_data = 'authdata'\n\n    def login(*args, **kwargs):\n        return {'api_key': auth_data}\n\n    monkeypatch.setattr(auth.AuthClient, 'login', login)\n\n    test_auth = auth.Auth.from_login('email', 'pw')\n    assert test_auth.value == auth_data\n\n\ndef test_Auth_store_doesnotexist(tmp_path):\n    test_auth = auth.Auth.from_key('test')\n    secret_path = str(tmp_path / '.test')\n    test_auth.store(secret_path)\n\n    with open(secret_path, 'r') as fp:\n        assert json.loads(fp.read()) == {\"key\": \"test\"}\n\n\ndef test_Auth_store_exists(tmp_path):\n    secret_path = str(tmp_path / '.test')\n\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"existing\": \"exists\"}')\n\n    test_auth = auth.Auth.from_key('test')\n    test_auth.store(secret_path)\n\n    with open(secret_path, 'r') as fp:\n        assert json.loads(fp.read()) == {\"key\": \"test\", \"existing\": \"exists\"}\n"], "fixing_code": ["# Copyright 2020 Planet Labs, Inc.\n# Copyright 2022 Planet Labs PBC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n'''Manage authentication with Planet APIs'''\nfrom __future__ import annotations  # https://stackoverflow.com/a/33533514\nimport abc\nimport json\nimport logging\nimport os\nimport pathlib\nimport stat\nimport typing\nfrom typing import Optional\n\nimport httpx\nimport jwt\n\nfrom . import http\nfrom .constants import ENV_API_KEY, PLANET_BASE_URL, SECRET_FILE_PATH\nfrom .exceptions import AuthException\n\nLOGGER = logging.getLogger(__name__)\n\nBASE_URL = f'{PLANET_BASE_URL}/v0/auth'\n\nAuthType = httpx.Auth\n\n\nclass Auth(metaclass=abc.ABCMeta):\n    '''Handle authentication information for use with Planet APIs.'''\n\n    @staticmethod\n    def from_key(key: str) -> AuthType:\n        '''Obtain authentication from api key.\n\n        Parameters:\n            key: Planet API key\n        '''\n        auth = APIKeyAuth(key=key)\n        LOGGER.debug('Auth obtained from api key.')\n        return auth\n\n    @staticmethod\n    def from_file(\n        filename: Optional[typing.Union[str,\n                                        pathlib.Path]] = None) -> AuthType:\n        '''Create authentication from secret file.\n\n        The secret file is named `.planet.json` and is stored in the user\n        directory. The file has a special format and should have been created\n        with `Auth.write()`.\n\n        Parameters:\n            filename: Alternate path for the planet secret file.\n\n        '''\n        filename = filename or SECRET_FILE_PATH\n\n        try:\n            secrets = _SecretFile(filename).read()\n            auth = APIKeyAuth.from_dict(secrets)\n        except FileNotFoundError:\n            raise AuthException(f'File {filename} does not exist.')\n        except (KeyError, json.decoder.JSONDecodeError):\n            raise AuthException(f'File {filename} is not the correct format.')\n\n        LOGGER.debug(f'Auth read from secret file {filename}.')\n        return auth\n\n    @staticmethod\n    def from_env(variable_name: Optional[str] = None) -> AuthType:\n        '''Create authentication from environment variable.\n\n        Reads the `PL_API_KEY` environment variable\n\n        Parameters:\n            variable_name: Alternate environment variable.\n        '''\n        variable_name = variable_name or ENV_API_KEY\n        api_key = os.getenv(variable_name, '')\n        try:\n            auth = APIKeyAuth(api_key)\n            LOGGER.debug(f'Auth set from environment variable {variable_name}')\n        except APIKeyAuthException:\n            raise AuthException(\n                f'Environment variable {variable_name} either does not exist '\n                'or is empty.')\n        return auth\n\n    @staticmethod\n    def from_login(email: str,\n                   password: str,\n                   base_url: Optional[str] = None) -> AuthType:\n        '''Create authentication from login email and password.\n\n        Note: To keep your password secure, the use of `getpass` is\n        recommended.\n\n        Parameters:\n            email: Planet account email address.\n            password: Planet account password.\n            base_url: The base URL to use. Defaults to production\n                authentication API base url.\n        '''\n        cl = AuthClient(base_url=base_url)\n        auth_data = cl.login(email, password)\n\n        api_key = auth_data['api_key']\n        auth = APIKeyAuth(api_key)\n        LOGGER.debug('Auth set from login email and password')\n        return auth\n\n    @classmethod\n    @abc.abstractmethod\n    def from_dict(cls, data: dict) -> AuthType:\n        pass\n\n    @property\n    @abc.abstractmethod\n    def value(self):\n        pass\n\n    @abc.abstractmethod\n    def to_dict(self) -> dict:\n        pass\n\n    def store(self,\n              filename: Optional[typing.Union[str, pathlib.Path]] = None):\n        '''Store authentication information in secret file.\n\n        Parameters:\n            filename: Alternate path for the planet secret file.\n        '''\n        filename = filename or SECRET_FILE_PATH\n        secret_file = _SecretFile(filename)\n        secret_file.write(self.to_dict())\n\n\nclass AuthClient:\n\n    def __init__(self, base_url: Optional[str] = None):\n        \"\"\"\n        Parameters:\n            base_url: The base URL to use. Defaults to production\n                authentication API base url.\n        \"\"\"\n        self._base_url = base_url or BASE_URL\n        if self._base_url.endswith('/'):\n            self._base_url = self._base_url[:-1]\n\n    def login(self, email: str, password: str) -> dict:\n        '''Login using email identity and credentials.\n\n        Note: To keep your password secure, the use of `getpass` is\n        recommended.\n\n        Parameters:\n            email: Planet account email address.\n            password:  Planet account password.\n\n        Returns:\n             A JSON object containing an `api_key` property with the user's\n        API_KEY.\n        '''\n        url = f'{self._base_url}/login'\n        data = {'email': email, 'password': password}\n\n        sess = http.AuthSession()\n        resp = sess.request(url=url, method='POST', json=data)\n        return self.decode_response(resp)\n\n    @staticmethod\n    def decode_response(response):\n        '''Decode the token JWT'''\n        token = response.json()['token']\n        return jwt.decode(token, options={'verify_signature': False})\n\n\nclass APIKeyAuthException(Exception):\n    '''exceptions thrown by APIKeyAuth'''\n    pass\n\n\nclass APIKeyAuth(httpx.BasicAuth, Auth):\n    '''Planet API Key authentication.'''\n    DICT_KEY = 'key'\n\n    def __init__(self, key: str):\n        '''Initialize APIKeyAuth.\n\n        Parameters:\n            key: API key.\n\n        Raises:\n            APIKeyException: If API key is None or empty string.\n        '''\n        if not key:\n            raise APIKeyAuthException('API key cannot be empty.')\n        self._key = key\n        super().__init__(self._key, '')\n\n    @classmethod\n    def from_dict(cls, data: dict) -> APIKeyAuth:\n        '''Instantiate APIKeyAuth from a dict.'''\n        api_key = data[cls.DICT_KEY]\n        return cls(api_key)\n\n    def to_dict(self):\n        '''Represent APIKeyAuth as a dict.'''\n        return {self.DICT_KEY: self._key}\n\n    @property\n    def value(self):\n        return self._key\n\n\nclass _SecretFile:\n\n    def __init__(self, path: typing.Union[str, pathlib.Path]):\n        self.path = pathlib.Path(path)\n\n        self.permissions = stat.S_IRUSR | stat.S_IWUSR  # user rw\n\n        # in sdk versions <=2.0.0, secret file was created with the wrong\n        # permissions, fix this automatically as well as catching the unlikely\n        # cases where the permissions get changed externally\n        self._enforce_permissions()\n\n    def write(self, contents: dict):\n        try:\n            secrets_to_write = self.read()\n            secrets_to_write.update(contents)\n        except (FileNotFoundError, KeyError, json.decoder.JSONDecodeError):\n            secrets_to_write = contents\n\n        self._write(secrets_to_write)\n\n    def _write(self, contents: dict):\n        LOGGER.debug(f'Writing to {self.path}')\n\n        def opener(path, flags):\n            return os.open(path, flags, self.permissions)\n\n        with open(self.path, 'w', opener=opener) as fp:\n            fp.write(json.dumps(contents))\n\n    def read(self) -> dict:\n        LOGGER.debug(f'Reading from {self.path}')\n        with open(self.path, 'r') as fp:\n            contents = json.loads(fp.read())\n        return contents\n\n    def _enforce_permissions(self):\n        '''if the file's permissions are not what they should be, fix them'''\n        try:\n            # in octal, permissions is the last three bits of the mode\n            file_permissions = self.path.stat().st_mode & 0o777\n            if file_permissions != self.permissions:\n                LOGGER.debug(\n                    f'{self.path} permissions are {oct(file_permissions)}, '\n                    f'should be {oct(self.permissions)}. Fixing.')\n                self.path.chmod(self.permissions)\n        except FileNotFoundError:\n            # just skip it if the secret file doesn't exist\n            pass\n", "# Copyright 2020 Planet Labs, Inc.\n# Copyright 2022 Planet Labs PBC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport json\nimport logging\n\nimport pytest\n\nfrom planet import auth\n\nLOGGER = logging.getLogger(__name__)\n\n\n# skip the global mock of _SecretFile.read\n# for this module\n@pytest.fixture(autouse=True, scope='module')\ndef test_secretfile_read():\n    return\n\n\n@pytest.fixture\ndef secret_path(monkeypatch, tmp_path):\n    secret_path = tmp_path / '.test'\n    monkeypatch.setattr(auth, 'SECRET_FILE_PATH', secret_path)\n    yield secret_path\n\n\ndef test_Auth_from_key():\n    test_auth_env1 = auth.Auth.from_key('testkey')\n    assert test_auth_env1.value == 'testkey'\n\n\ndef test_Auth_from_key_empty():\n    with pytest.raises(auth.APIKeyAuthException):\n        _ = auth.Auth.from_key('')\n\n\ndef test_Auth_from_file(secret_path):\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"key\": \"testvar\"}')\n\n    test_auth = auth.Auth.from_file()\n    assert test_auth.value == 'testvar'\n\n\ndef test_Auth_from_file_doesnotexist(secret_path):\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_file(secret_path)\n\n\ndef test_Auth_from_file_wrongformat(secret_path):\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"notkey\": \"testvar\"}')\n\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_file(secret_path)\n\n\ndef test_Auth_from_file_alternate(tmp_path):\n    secret_path = str(tmp_path / '.test')\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"key\": \"testvar\"}')\n\n    test_auth = auth.Auth.from_file(secret_path)\n    assert test_auth.value == 'testvar'\n\n\ndef test_Auth_from_env(monkeypatch):\n    monkeypatch.setenv('PL_API_KEY', 'testkey')\n    test_auth_env = auth.Auth.from_env()\n    assert test_auth_env.value == 'testkey'\n\n\ndef test_Auth_from_env_failure(monkeypatch):\n    monkeypatch.delenv('PL_API_KEY', raising=False)\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_env()\n\n\ndef test_Auth_from_env_alternate_success(monkeypatch):\n    alternate = 'OTHER_VAR'\n    monkeypatch.setenv(alternate, 'testkey')\n    monkeypatch.delenv('PL_API_KEY', raising=False)\n\n    test_auth_env = auth.Auth.from_env(alternate)\n    assert test_auth_env.value == 'testkey'\n\n\ndef test_Auth_from_env_alternate_doesnotexist(monkeypatch):\n    alternate = 'OTHER_VAR'\n    monkeypatch.delenv(alternate, raising=False)\n    monkeypatch.delenv('PL_API_KEY', raising=False)\n\n    with pytest.raises(auth.AuthException):\n        _ = auth.Auth.from_env(alternate)\n\n\ndef test_Auth_from_login(monkeypatch):\n    auth_data = 'authdata'\n\n    def login(*args, **kwargs):\n        return {'api_key': auth_data}\n\n    monkeypatch.setattr(auth.AuthClient, 'login', login)\n\n    test_auth = auth.Auth.from_login('email', 'pw')\n    assert test_auth.value == auth_data\n\n\ndef test_Auth_store_doesnotexist(tmp_path):\n    test_auth = auth.Auth.from_key('test')\n    secret_path = str(tmp_path / '.test')\n    test_auth.store(secret_path)\n\n    with open(secret_path, 'r') as fp:\n        assert json.loads(fp.read()) == {\"key\": \"test\"}\n\n\ndef test_Auth_store_exists(tmp_path):\n    secret_path = str(tmp_path / '.test')\n\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"existing\": \"exists\"}')\n\n    test_auth = auth.Auth.from_key('test')\n    test_auth.store(secret_path)\n\n    with open(secret_path, 'r') as fp:\n        assert json.loads(fp.read()) == {\"key\": \"test\", \"existing\": \"exists\"}\n\n\ndef test__SecretFile_permissions_doesnotexist(secret_path):\n    '''No exception is raised if the file doesn't exist'''\n    auth._SecretFile(secret_path)\n\n\ndef test__SecretFile_permissions_incorrect(secret_path):\n    '''Incorrect permissions are fixed'''\n    with open(secret_path, 'w') as fp:\n        fp.write('{\"existing\": \"exists\"}')\n\n    secret_path.chmod(0o666)\n\n    auth._SecretFile(secret_path)\n    assert secret_path.stat().st_mode & 0o777 == 0o600\n"], "filenames": ["planet/auth.py", "tests/unit/test_auth.py"], "buggy_code_start_loc": [21, 34], "buggy_code_end_loc": [250, 140], "fixing_code_start_loc": [22, 34], "fixing_code_end_loc": [277, 157], "type": "CWE-732", "message": "Planet is software that provides satellite data. The secret file stores the user's Planet API authentication information. It should only be accessible by the user, but before version 2.0.1, its permissions allowed the user's group and non-group to read the file as well. This issue was patched in version 2.0.1. As a workaround, set the secret file permissions to only user read/write by hand.\n", "other": {"cve": {"id": "CVE-2023-32303", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-12T21:15:09.560", "lastModified": "2023-05-26T17:36:37.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Planet is software that provides satellite data. The secret file stores the user's Planet API authentication information. It should only be accessible by the user, but before version 2.0.1, its permissions allowed the user's group and non-group to read the file as well. This issue was patched in version 2.0.1. As a workaround, set the secret file permissions to only user read/write by hand.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:planet:planet:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.1", "matchCriteriaId": "EED867FB-E5D4-44AA-B656-E9A6EE43C7AC"}]}]}], "references": [{"url": "https://github.com/planetlabs/planet-client-python/commit/d71415a83119c5e89d7b80d5f940d162376ee3b7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/planetlabs/planet-client-python/releases/tag/2.0.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/planetlabs/planet-client-python/security/advisories/GHSA-j5fj-rfh6-qj85", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/planetlabs/planet-client-python/commit/d71415a83119c5e89d7b80d5f940d162376ee3b7"}}