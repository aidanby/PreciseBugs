{"buggy_code": ["/****************************************\n*  Computer Algebra System SINGULAR     *\n****************************************/\n/*\n* ABSTRACT: Singular debugger\n*/\n\n#include \"kernel/mod2.h\"\n#include \"omalloc/omalloc.h\"\n#include \"misc/options.h\"\n#include \"reporter/si_signals.h\"\n#include \"Singular/tok.h\"\n#include \"Singular/ipshell.h\"\n#include \"Singular/ipid.h\"\n#include \"Singular/fevoices.h\"\n#include \"kernel/oswrapper/feread.h\"\n#include \"Singular/sdb.h\"\n\n#include <unistd.h>   // for unlink,fork,execlp,getpid\n#include <sys/wait.h> // for wait\n\n\n#ifdef HAVE_SDB\n// We use 8 breakpoints - corresponding to a bit in a char variable in procinfo\n// bit 1..7 force a breakpoint, if lineno==sdb_lines[i-1],\n//                         (for displaying only: file sdb_files[i-1])\n// bit 0 force a breakpoint in every line (used for 'n')\n\nVAR int sdb_lines[]={-1,-1,-1,-1,-1,-1,-1,-1};\nVAR char * sdb_files[6];\nVAR int sdb_flags=0;\n\nint sdb_checkline(char f)\n{\n  int i;\n  char ff=f>>1;\n  for(i=0;i<7;i++)\n  {\n    if((ff & 1) && (yylineno==sdb_lines[i]))\n      return i+1;\n    ff>>=1;\n    if (ff==0) return 0;\n  }\n  return 0;\n}\n\nstatic char *sdb_find_arg(char *p)\n{\n  p++;\n  while (*p==' ') p++;\n  char *pp=p;\n  while (*pp>' ') pp++;\n  *pp='\\0';\n  return p;\n}\n\nvoid sdb_show_bp()\n{\n  for(int i=0; i<7;i++)\n    if (sdb_lines[i]!= -1)\n      Print(\"Breakpoint %d: %s::%d\\n\",i+1,sdb_files[i],sdb_lines[i]);\n}\n\nBOOLEAN sdb_set_breakpoint(const char *pp, int given_lineno)\n{\n  idhdl h=ggetid(pp);\n  if ((h==NULL)||(IDTYP(h)!=PROC_CMD))\n  {\n    PrintS(\" not found\\n\");\n    return TRUE;\n  }\n  else\n  {\n    procinfov p=(procinfov)IDDATA(h);\n    #ifdef HAVE_DYNAMIC_LOADING\n    if (p->language!=LANG_SINGULAR)\n    {\n      PrintS(\"is not a Singular procedure\\n\");\n      return TRUE;\n    }\n    #endif\n    int lineno;\n    if (given_lineno >0) lineno=given_lineno;\n    else                 lineno=p->data.s.body_lineno;\n    int i;\n    if (given_lineno== -1)\n    {\n      i=p->trace_flag;\n      p->trace_flag &=1;\n      Print(\"breakpoints in %s deleted(%#x)\\n\",p->procname,i &255);\n      return FALSE;\n    }\n    i=0;\n    while((i<7) && (sdb_lines[i]!=-1)) i++;\n    if (sdb_lines[i]!= -1)\n    {\n      PrintS(\"too many breakpoints set, max is 7\\n\");\n      return TRUE;\n    }\n    sdb_lines[i]=lineno;\n    sdb_files[i]=p->libname;\n    i++;\n    p->trace_flag|=(1<<i);\n    Print(\"breakpoint %d, at line %d in %s\\n\",i,lineno,p->procname);\n    return FALSE;\n  }\n}\n\nvoid sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}\n\nSTATIC_VAR char sdb_lastcmd='c';\n\nvoid sdb(Voice * currentVoice, const char * currLine, int len)\n{\n  int bp=0;\n  if ((len>1)\n  && ((currentVoice->pi->trace_flag & 1)\n    || (bp=sdb_checkline(currentVoice->pi->trace_flag)))\n  )\n  {\n    loop\n    {\n      char gdb[80];\n      char *p=(char *)currLine+len-1;\n      while ((*p<=' ') && (p!=currLine))\n      {\n        p--; len--;\n      }\n      if (p==currLine) return;\n\n      currentVoice->pi->trace_flag&= ~1; // delete flag for \"all lines\"\n      Print(\"(%s,%d) >>\",currentVoice->filename,yylineno);\n      fwrite(currLine,1,len,stdout);\n      Print(\"<<\\nbreakpoint %d (press ? for list of commands)\\n\",bp);\n      p=fe_fgets_stdin(\">>\",gdb,80);\n      while (*p==' ') p++;\n      if (*p >' ')\n      {\n        sdb_lastcmd=*p;\n      }\n      Print(\"command:%c\\n\",sdb_lastcmd);\n      switch(sdb_lastcmd)\n      {\n        case '?':\n        case 'h':\n        {\n          PrintS(\n          \"b - print backtrace of calling stack\\n\"\n          \"B <proc> [<line>] - define breakpoint\\n\"\n          \"c - continue\\n\"\n          \"d - delete current breakpoint\\n\"\n          \"D - show all breakpoints\\n\"\n          \"e - edit the current procedure (current call will be aborted)\\n\"\n          \"h,? - display this help screen\\n\"\n          \"n - execute current line, break at next line\\n\"\n          \"p <var> - display type and value of the variable <var>\\n\"\n          \"q <flags> - quit debugger, set debugger flags(0,1,2)\\n\"\n\t  \"   0: stop debug, 1:continue, 2: throw an error, return to toplevel\\n\"\n          \"Q - quit Singular\\n\");\n          int i;\n          for(i=0;i<7;i++)\n          {\n            if (sdb_lines[i] != -1)\n              Print(\"breakpoint %d at line %d in %s\\n\",\n                i,sdb_lines[i],sdb_files[i]);\n          }\n          break;\n        }\n        case 'd':\n        {\n          Print(\"delete break point %d\\n\",bp);\n          currentVoice->pi->trace_flag &= (~Sy_bit(bp));\n          if (bp!=0)\n          {\n            sdb_lines[bp-1]=-1;\n          }\n          break;\n        }\n        case 'D':\n          sdb_show_bp();\n          break;\n\t#if 0\n\tcase 'l':\n\t{\n\t  extern void listall(int showproc);\n\t  listall(FALSE);\n\t  break;\n\t}\n\t#endif\n        case 'n':\n          currentVoice->pi->trace_flag|= 1;\n          return;\n        case 'e':\n        {\n          sdb_edit(currentVoice->pi);\n          sdb_flags=2;\n          return;\n        }\n        case 'p':\n        {\n          p=sdb_find_arg(p);\n\t  EXTERN_VAR int myynest;\n          Print(\"variable `%s`at level %d\",p,myynest);\n          idhdl h=ggetid(p);\n          if (h==NULL)\n            PrintS(\" not found\\n\");\n          else\n          {\n            sleftv tmp;\n            memset(&tmp,0,sizeof(tmp));\n            tmp.rtyp=IDHDL;\n            tmp.data=h;\n            Print(\"(type %s):\\n\",Tok2Cmdname(tmp.Typ()));\n            tmp.Print();\n          }\n          break;\n        }\n        case 'b':\n          VoiceBackTrack();\n          break;\n        case 'B':\n        {\n          p=sdb_find_arg(p);\n          Print(\"procedure `%s` \",p);\n          sdb_set_breakpoint(p);\n          break;\n        }\n        case 'q':\n        {\n          p=sdb_find_arg(p);\n          if (*p!='\\0')\n          {\n            sdb_flags=atoi(p);\n            Print(\"new sdb_flags:%d\\n\",sdb_flags);\n          }\n          return;\n        }\n        case 'Q':\n          m2_end(999);\n        case 'c':\n        default:\n          return;\n      }\n    }\n  }\n}\n#endif\n"], "fixing_code": ["/****************************************\n*  Computer Algebra System SINGULAR     *\n****************************************/\n/*\n* ABSTRACT: Singular debugger\n*/\n\n#include \"kernel/mod2.h\"\n#include \"omalloc/omalloc.h\"\n#include \"misc/options.h\"\n#include \"reporter/si_signals.h\"\n#include \"Singular/tok.h\"\n#include \"Singular/ipshell.h\"\n#include \"Singular/ipid.h\"\n#include \"Singular/fevoices.h\"\n#include \"kernel/oswrapper/feread.h\"\n#include \"Singular/sdb.h\"\n\n#include <unistd.h>   // for unlink,fork,execlp,getpid\n#include <sys/wait.h> // for wait\n\n\n#ifdef HAVE_SDB\n// We use 8 breakpoints - corresponding to a bit in a char variable in procinfo\n// bit 1..7 force a breakpoint, if lineno==sdb_lines[i-1],\n//                         (for displaying only: file sdb_files[i-1])\n// bit 0 force a breakpoint in every line (used for 'n')\n\nVAR int sdb_lines[]={-1,-1,-1,-1,-1,-1,-1,-1};\nVAR char * sdb_files[6];\nVAR int sdb_flags=0;\n\nint sdb_checkline(char f)\n{\n  int i;\n  char ff=f>>1;\n  for(i=0;i<7;i++)\n  {\n    if((ff & 1) && (yylineno==sdb_lines[i]))\n      return i+1;\n    ff>>=1;\n    if (ff==0) return 0;\n  }\n  return 0;\n}\n\nstatic char *sdb_find_arg(char *p)\n{\n  p++;\n  while (*p==' ') p++;\n  char *pp=p;\n  while (*pp>' ') pp++;\n  *pp='\\0';\n  return p;\n}\n\nvoid sdb_show_bp()\n{\n  for(int i=0; i<7;i++)\n    if (sdb_lines[i]!= -1)\n      Print(\"Breakpoint %d: %s::%d\\n\",i+1,sdb_files[i],sdb_lines[i]);\n}\n\nBOOLEAN sdb_set_breakpoint(const char *pp, int given_lineno)\n{\n  idhdl h=ggetid(pp);\n  if ((h==NULL)||(IDTYP(h)!=PROC_CMD))\n  {\n    PrintS(\" not found\\n\");\n    return TRUE;\n  }\n  else\n  {\n    procinfov p=(procinfov)IDDATA(h);\n    #ifdef HAVE_DYNAMIC_LOADING\n    if (p->language!=LANG_SINGULAR)\n    {\n      PrintS(\"is not a Singular procedure\\n\");\n      return TRUE;\n    }\n    #endif\n    int lineno;\n    if (given_lineno >0) lineno=given_lineno;\n    else                 lineno=p->data.s.body_lineno;\n    int i;\n    if (given_lineno== -1)\n    {\n      i=p->trace_flag;\n      p->trace_flag &=1;\n      Print(\"breakpoints in %s deleted(%#x)\\n\",p->procname,i &255);\n      return FALSE;\n    }\n    i=0;\n    while((i<7) && (sdb_lines[i]!=-1)) i++;\n    if (sdb_lines[i]!= -1)\n    {\n      PrintS(\"too many breakpoints set, max is 7\\n\");\n      return TRUE;\n    }\n    sdb_lines[i]=lineno;\n    sdb_files[i]=p->libname;\n    i++;\n    p->trace_flag|=(1<<i);\n    Print(\"breakpoint %d, at line %d in %s\\n\",i,lineno,p->procname);\n    return FALSE;\n  }\n}\n\nvoid sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}\n\nSTATIC_VAR char sdb_lastcmd='c';\n\nvoid sdb(Voice * currentVoice, const char * currLine, int len)\n{\n  int bp=0;\n  if ((len>1)\n  && ((currentVoice->pi->trace_flag & 1)\n    || (bp=sdb_checkline(currentVoice->pi->trace_flag)))\n  )\n  {\n    loop\n    {\n      char gdb[80];\n      char *p=(char *)currLine+len-1;\n      while ((*p<=' ') && (p!=currLine))\n      {\n        p--; len--;\n      }\n      if (p==currLine) return;\n\n      currentVoice->pi->trace_flag&= ~1; // delete flag for \"all lines\"\n      Print(\"(%s,%d) >>\",currentVoice->filename,yylineno);\n      fwrite(currLine,1,len,stdout);\n      Print(\"<<\\nbreakpoint %d (press ? for list of commands)\\n\",bp);\n      p=fe_fgets_stdin(\">>\",gdb,80);\n      while (*p==' ') p++;\n      if (*p >' ')\n      {\n        sdb_lastcmd=*p;\n      }\n      Print(\"command:%c\\n\",sdb_lastcmd);\n      switch(sdb_lastcmd)\n      {\n        case '?':\n        case 'h':\n        {\n          PrintS(\n          \"b - print backtrace of calling stack\\n\"\n          \"B <proc> [<line>] - define breakpoint\\n\"\n          \"c - continue\\n\"\n          \"d - delete current breakpoint\\n\"\n          \"D - show all breakpoints\\n\"\n          \"e - edit the current procedure (current call will be aborted)\\n\"\n          \"h,? - display this help screen\\n\"\n          \"n - execute current line, break at next line\\n\"\n          \"p <var> - display type and value of the variable <var>\\n\"\n          \"q <flags> - quit debugger, set debugger flags(0,1,2)\\n\"\n\t  \"   0: stop debug, 1:continue, 2: throw an error, return to toplevel\\n\"\n          \"Q - quit Singular\\n\");\n          int i;\n          for(i=0;i<7;i++)\n          {\n            if (sdb_lines[i] != -1)\n              Print(\"breakpoint %d at line %d in %s\\n\",\n                i,sdb_lines[i],sdb_files[i]);\n          }\n          break;\n        }\n        case 'd':\n        {\n          Print(\"delete break point %d\\n\",bp);\n          currentVoice->pi->trace_flag &= (~Sy_bit(bp));\n          if (bp!=0)\n          {\n            sdb_lines[bp-1]=-1;\n          }\n          break;\n        }\n        case 'D':\n          sdb_show_bp();\n          break;\n\t#if 0\n\tcase 'l':\n\t{\n\t  extern void listall(int showproc);\n\t  listall(FALSE);\n\t  break;\n\t}\n\t#endif\n        case 'n':\n          currentVoice->pi->trace_flag|= 1;\n          return;\n        case 'e':\n        {\n          sdb_edit(currentVoice->pi);\n          sdb_flags=2;\n          return;\n        }\n        case 'p':\n        {\n          p=sdb_find_arg(p);\n\t  EXTERN_VAR int myynest;\n          Print(\"variable `%s`at level %d\",p,myynest);\n          idhdl h=ggetid(p);\n          if (h==NULL)\n            PrintS(\" not found\\n\");\n          else\n          {\n            sleftv tmp;\n            memset(&tmp,0,sizeof(tmp));\n            tmp.rtyp=IDHDL;\n            tmp.data=h;\n            Print(\"(type %s):\\n\",Tok2Cmdname(tmp.Typ()));\n            tmp.Print();\n          }\n          break;\n        }\n        case 'b':\n          VoiceBackTrack();\n          break;\n        case 'B':\n        {\n          p=sdb_find_arg(p);\n          Print(\"procedure `%s` \",p);\n          sdb_set_breakpoint(p);\n          break;\n        }\n        case 'q':\n        {\n          p=sdb_find_arg(p);\n          if (*p!='\\0')\n          {\n            sdb_flags=atoi(p);\n            Print(\"new sdb_flags:%d\\n\",sdb_flags);\n          }\n          return;\n        }\n        case 'Q':\n          m2_end(999);\n        case 'c':\n        default:\n          return;\n      }\n    }\n  }\n}\n#endif\n"], "filenames": ["Singular/sdb.cc"], "buggy_code_start_loc": [111], "buggy_code_end_loc": [177], "fixing_code_start_loc": [111], "fixing_code_end_loc": [176], "type": "CWE-269", "message": "In Singular before 4.3.1, a predictable /tmp pathname is used (e.g., by sdb.cc), which allows local users to gain the privileges of other users via a procedure in a file under /tmp. NOTE: this CVE Record is about sdb.cc and similar files in the Singular interface that have predictable /tmp pathnames; this CVE Record is not about the lack of a safe temporary-file creation capability in the Singular language.", "other": {"cve": {"id": "CVE-2022-40299", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-09T01:15:07.853", "lastModified": "2022-09-10T03:54:15.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Singular before 4.3.1, a predictable /tmp pathname is used (e.g., by sdb.cc), which allows local users to gain the privileges of other users via a procedure in a file under /tmp. NOTE: this CVE Record is about sdb.cc and similar files in the Singular interface that have predictable /tmp pathnames; this CVE Record is not about the lack of a safe temporary-file creation capability in the Singular language."}, {"lang": "es", "value": "En Singular versiones anteriores a 4.3.1, es usado un nombre de ruta /tmp predecible (por ejemplo, por sdb.cc), lo que permite a usuarios locales conseguir los privilegios de otros usuarios por medio de un procedimiento en un archivo bajo /tmp. NOTA: este registro CVE esta referido a sdb.cc y a archivos similares en la interfaz de Singular que presentan nombres de ruta /tmp predecibles; este registro CVE no esta referido a una falta de capacidad de creaci\u00f3n de archivos temporales seguros en el lenguaje Singular"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:singular:singular:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.1", "matchCriteriaId": "3FE9F514-BE4C-43B5-AAF5-30D4AE629E20"}]}]}], "references": [{"url": "http://michael.orlitzky.com/cves/cve-2022-40299.xhtml", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/Singular/Singular/commit/5f28fbf066626fa9c4a8f0e6408c0bb362fb386c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Singular/Singular/issues/1137", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Singular/Singular/commit/5f28fbf066626fa9c4a8f0e6408c0bb362fb386c"}}