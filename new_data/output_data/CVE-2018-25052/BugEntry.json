{"buggy_code": ["#!/usr/bin/perl\n\npackage Catalyst::Plugin::Session;\n\nuse Moose;\nwith 'MooseX::Emulate::Class::Accessor::Fast';\nuse MRO::Compat;\nuse Catalyst::Exception ();\nuse Digest              ();\nuse overload            ();\nuse Object::Signature   ();\nuse Carp;\nuse List::Util qw/ max /;\n\nuse namespace::clean -except => 'meta';\n\nour $VERSION = '0.40';\n$VERSION = eval $VERSION;\n\nmy @session_data_accessors; # used in delete_session\n\n__PACKAGE__->mk_accessors(\n        \"_session_delete_reason\",\n        @session_data_accessors = qw/\n          _sessionid\n          _session\n          _session_expires\n          _extended_session_expires\n          _session_data_sig\n          _flash\n          _flash_keep_keys\n          _flash_key_hashes\n          _tried_loading_session_id\n          _tried_loading_session_data\n          _tried_loading_session_expires\n          _tried_loading_flash_data\n          _needs_early_session_finalization\n          /\n);\n\nsub _session_plugin_config {\n    my $c = shift;\n    # FIXME - Start warning once all the state/store modules have also been updated.\n    #$c->log->warn(\"Deprecated 'session' config key used, please use the key 'Plugin::Session' instead\")\n    #    if exists $c->config->{session}\n    #$c->config->{'Plugin::Session'} ||= delete($c->config->{session}) || {};\n    $c->config->{'Plugin::Session'} ||= $c->config->{session} || {};\n}\n\nsub setup {\n    my $c = shift;\n\n    $c->maybe::next::method(@_);\n\n    $c->check_session_plugin_requirements;\n    $c->setup_session;\n\n    return $c;\n}\n\nsub check_session_plugin_requirements {\n    my $c = shift;\n\n    unless ( $c->isa(\"Catalyst::Plugin::Session::State\")\n        && $c->isa(\"Catalyst::Plugin::Session::Store\") )\n    {\n        my $err =\n          (     \"The Session plugin requires both Session::State \"\n              . \"and Session::Store plugins to be used as well.\" );\n\n        $c->log->fatal($err);\n        Catalyst::Exception->throw($err);\n    }\n}\n\nsub setup_session {\n    my $c = shift;\n\n    my $cfg = $c->_session_plugin_config;\n\n    %$cfg = (\n        expires        => 7200,\n        verify_address => 0,\n        verify_user_agent => 0,\n        expiry_threshold => 0,\n        %$cfg,\n    );\n\n    $c->maybe::next::method();\n}\n\nsub prepare_action {\n    my $c = shift;\n\n    $c->maybe::next::method(@_);\n\n    if (    $c->_session_plugin_config->{flash_to_stash}\n        and $c->sessionid\n        and my $flash_data = $c->flash )\n    {\n        @{ $c->stash }{ keys %$flash_data } = values %$flash_data;\n    }\n}\n\nsub finalize_headers {\n    my $c = shift;\n\n    # fix cookie before we send headers\n    $c->_save_session_expires;\n\n    # Force extension of session_expires before finalizing headers, so a pos\n    # up to date. First call to session_expires will extend the expiry, subs\n    # just return the previously extended value.\n    $c->session_expires;\n    $c->finalize_session if $c->_needs_early_session_finalization;\n\n    return $c->maybe::next::method(@_);\n}\n\nsub finalize_body {\n    my $c = shift;\n\n    # We have to finalize our session *before* $c->engine->finalize_xxx is called,\n    # because we do not want to send the HTTP response before the session is stored/committed to\n    # the session database (or whatever Session::Store you use).\n    $c->finalize_session unless $c->_needs_early_session_finalization;\n    $c->_clear_session_instance_data;\n\n    return $c->maybe::next::method(@_);\n}\n\nsub finalize_session {\n    my $c = shift;\n\n    $c->maybe::next::method(@_);\n\n    $c->_save_session_id;\n    $c->_save_session;\n    $c->_save_flash;\n\n}\n\nsub _session_updated {\n    my $c = shift;\n\n    if ( my $session_data = $c->_session ) {\n\n        no warnings 'uninitialized';\n        if ( Object::Signature::signature($session_data) ne\n            $c->_session_data_sig )\n        {\n            return $session_data;\n        } else {\n            return;\n        }\n\n    } else {\n\n        return;\n\n    }\n}\n\nsub _save_session_id {\n    my $c = shift;\n\n    # we already called set when allocating\n    # no need to tell the state plugins anything new\n}\n\nsub _save_session_expires {\n    my $c = shift;\n\n    if ( defined($c->_session_expires) ) {\n\n        if (my $sid = $c->sessionid) {\n\n            my $current  = $c->_get_stored_session_expires;\n            my $extended = $c->session_expires;\n            if ($extended > $current) {\n                $c->store_session_data( \"expires:$sid\" => $extended );\n            }\n\n        }\n    }\n}\n\nsub _save_session {\n    my $c = shift;\n\n    if ( my $session_data = $c->_session_updated ) {\n\n        $session_data->{__updated} = time();\n        my $sid = $c->sessionid;\n        $c->store_session_data( \"session:$sid\" => $session_data );\n    }\n}\n\nsub _save_flash {\n    my $c = shift;\n\n    if ( my $flash_data = $c->_flash ) {\n\n        my $hashes = $c->_flash_key_hashes || {};\n        my $keep = $c->_flash_keep_keys || {};\n        foreach my $key ( keys %$hashes ) {\n            if ( !exists $keep->{$key} and Object::Signature::signature( \\$flash_data->{$key} ) eq $hashes->{$key} ) {\n                delete $flash_data->{$key};\n            }\n        }\n\n        my $sid = $c->sessionid;\n\n        my $session_data = $c->_session;\n        if (%$flash_data) {\n            $session_data->{__flash} = $flash_data;\n        }\n        else {\n            delete $session_data->{__flash};\n        }\n        $c->_session($session_data);\n        $c->_save_session;\n    }\n}\n\nsub _load_session_expires {\n    my $c = shift;\n    return $c->_session_expires if $c->_tried_loading_session_expires;\n    $c->_tried_loading_session_expires(1);\n\n    if ( my $sid = $c->sessionid ) {\n        my $expires =  $c->_get_stored_session_expires;\n\n        if ( $expires >= time() ) {\n            $c->_session_expires( $expires );\n            return $expires;\n        } else {\n            $c->delete_session( \"session expired\" );\n            return 0;\n        }\n    }\n\n    return;\n}\n\nsub _load_session {\n    my $c = shift;\n    return $c->_session if $c->_tried_loading_session_data;\n    $c->_tried_loading_session_data(1);\n\n    if ( my $sid = $c->sessionid ) {\n        if ( $c->_load_session_expires ) {    # > 0\n\n            my $session_data = $c->get_session_data(\"session:$sid\") || return;\n            $c->_session($session_data);\n\n            no warnings 'uninitialized';    # ne __address\n            if (   $c->_session_plugin_config->{verify_address}\n                && exists $session_data->{__address}\n                && $session_data->{__address} ne $c->request->address )\n            {\n                $c->log->warn(\n                        \"Deleting session $sid due to address mismatch (\"\n                      . $session_data->{__address} . \" != \"\n                      . $c->request->address . \")\"\n                );\n                $c->delete_session(\"address mismatch\");\n                return;\n            }\n            if (   $c->_session_plugin_config->{verify_user_agent}\n                && $session_data->{__user_agent} ne $c->request->user_agent )\n            {\n                $c->log->warn(\n                        \"Deleting session $sid due to user agent mismatch (\"\n                      . $session_data->{__user_agent} . \" != \"\n                      . $c->request->user_agent . \")\"\n                );\n                $c->delete_session(\"user agent mismatch\");\n                return;\n            }\n\n            $c->log->debug(qq/Restored session \"$sid\"/) if $c->debug;\n            $c->_session_data_sig( Object::Signature::signature($session_data) ) if $session_data;\n            $c->_expire_session_keys;\n\n            return $session_data;\n        }\n    }\n\n    return;\n}\n\nsub _load_flash {\n    my $c = shift;\n    return $c->_flash if $c->_tried_loading_flash_data;\n    $c->_tried_loading_flash_data(1);\n\n    if ( my $sid = $c->sessionid ) {\n\n        my $session_data = $c->session;\n        $c->_flash($session_data->{__flash});\n\n        if ( my $flash_data = $c->_flash )\n        {\n            $c->_flash_key_hashes({ map { $_ => Object::Signature::signature( \\$flash_data->{$_} ) } keys %$flash_data });\n\n            return $flash_data;\n        }\n    }\n\n    return;\n}\n\nsub _expire_session_keys {\n    my ( $c, $data ) = @_;\n\n    my $now = time;\n\n    my $expire_times = ( $data || $c->_session || {} )->{__expire_keys} || {};\n    foreach my $key ( grep { $expire_times->{$_} < $now } keys %$expire_times ) {\n        delete $c->_session->{$key};\n        delete $expire_times->{$key};\n    }\n}\n\nsub _clear_session_instance_data {\n    my $c = shift;\n    $c->$_(undef) for @session_data_accessors;\n    $c->maybe::next::method(@_); # allow other plugins to hook in on this\n}\n\nsub change_session_id {\n    my $c = shift;\n\n    my $sessiondata = $c->session;\n    my $oldsid = $c->sessionid;\n    my $newsid = $c->create_session_id;\n\n    if ($oldsid) {\n        $c->log->debug(qq/change_sessid: deleting session data from \"$oldsid\"/) if $c->debug;\n        $c->delete_session_data(\"${_}:${oldsid}\") for qw/session expires flash/;\n    }\n\n    $c->log->debug(qq/change_sessid: storing session data to \"$newsid\"/) if $c->debug;\n    $c->store_session_data( \"session:$newsid\" => $sessiondata );\n\n    return $newsid;\n}\n\nsub delete_session {\n    my ( $c, $msg ) = @_;\n\n    $c->log->debug(\"Deleting session\" . ( defined($msg) ? \"($msg)\" : '(no reason given)') ) if $c->debug;\n\n    # delete the session data\n    if ( my $sid = $c->sessionid ) {\n        $c->delete_session_data(\"${_}:${sid}\") for qw/session expires flash/;\n        $c->delete_session_id($sid);\n    }\n\n    # reset the values in the context object\n    # see the BEGIN block\n    $c->_clear_session_instance_data;\n\n    $c->_session_delete_reason($msg);\n}\n\nsub session_delete_reason {\n    my $c = shift;\n\n    $c->session_is_valid; # check that it was loaded\n\n    $c->_session_delete_reason(@_);\n}\n\nsub session_expires {\n    my $c = shift;\n\n    if ( defined( my $expires = $c->_extended_session_expires ) ) {\n        return $expires;\n    } elsif ( defined( $expires = $c->_load_session_expires ) ) {\n        return $c->extend_session_expires( $expires );\n    } else {\n        return 0;\n    }\n}\n\nsub extend_session_expires {\n    my ( $c, $expires ) = @_;\n\n    my $threshold = $c->_session_plugin_config->{expiry_threshold} || 0;\n\n    if ( my $sid = $c->sessionid ) {\n        my $expires = $c->_get_stored_session_expires;\n        my $cutoff  = $expires - $threshold;\n\n        if (!$threshold || $cutoff <= time || $c->_session_updated) {\n\n            $c->_extended_session_expires( my $updated = $c->calculate_initial_session_expires() );\n            $c->extend_session_id( $sid, $updated );\n\n            return $updated;\n\n        } else {\n\n            return $expires;\n\n        }\n\n    } else {\n\n        return;\n\n    }\n\n}\n\nsub change_session_expires {\n    my ( $c, $expires ) = @_;\n\n    $expires ||= 0;\n    my $sid = $c->sessionid;\n    my $time_exp = time() + $expires;\n    $c->store_session_data( \"expires:$sid\" => $time_exp );\n}\n\nsub _get_stored_session_expires {\n    my ($c) = @_;\n\n    if ( my $sid = $c->sessionid ) {\n        return $c->get_session_data(\"expires:$sid\") || 0;\n    } else {\n        return 0;\n    }\n}\n\nsub initial_session_expires {\n    my $c = shift;\n    return ( time() + $c->_session_plugin_config->{expires} );\n}\n\nsub calculate_initial_session_expires {\n    my ($c) = @_;\n    return max( $c->initial_session_expires, $c->_get_stored_session_expires );\n}\n\nsub calculate_extended_session_expires {\n    my ( $c, $prev ) = @_;\n    return ( time() + $prev );\n}\n\nsub reset_session_expires {\n    my ( $c, $sid ) = @_;\n\n    my $exp = $c->calculate_initial_session_expires;\n    $c->_session_expires( $exp );\n    #\n    # since we're setting _session_expires directly, make load_session_expires\n    # actually use that value.\n    #\n    $c->_tried_loading_session_expires(1);\n    $c->_extended_session_expires( $exp );\n    $exp;\n}\n\nsub sessionid {\n    my $c = shift;\n\n    return $c->_sessionid || $c->_load_sessionid;\n}\n\nsub _load_sessionid {\n    my $c = shift;\n    return if $c->_tried_loading_session_id;\n    $c->_tried_loading_session_id(1);\n\n    if ( defined( my $sid = $c->get_session_id ) ) {\n        if ( $c->validate_session_id($sid) ) {\n            # temporarily set the inner key, so that validation will work\n            $c->_sessionid($sid);\n            return $sid;\n        } else {\n            my $err = \"Tried to set invalid session ID '$sid'\";\n            $c->log->error($err);\n            Catalyst::Exception->throw($err);\n        }\n    }\n\n    return;\n}\n\nsub session_is_valid {\n    my $c = shift;\n\n    # force a check for expiry, but also __address, etc\n    if ( $c->_load_session ) {\n        return 1;\n    } else {\n        return;\n    }\n}\n\nsub validate_session_id {\n    my ( $c, $sid ) = @_;\n\n    $sid and $sid =~ /^[a-f\\d]+$/i;\n}\n\nsub session {\n    my $c = shift;\n\n    my $session = $c->_session || $c->_load_session || do {\n        $c->create_session_id_if_needed;\n        $c->initialize_session_data;\n    };\n\n    if (@_) {\n      my $new_values = @_ > 1 ? { @_ } : $_[0];\n      croak('session takes a hash or hashref') unless ref $new_values;\n\n      for my $key (keys %$new_values) {\n        $session->{$key} = $new_values->{$key};\n      }\n    }\n\n    $session;\n}\n\nsub keep_flash {\n    my ( $c, @keys ) = @_;\n    my $href = $c->_flash_keep_keys || $c->_flash_keep_keys({});\n    (@{$href}{@keys}) = ((undef) x @keys);\n}\n\nsub _flash_data {\n    my $c = shift;\n    $c->_flash || $c->_load_flash || do {\n        $c->create_session_id_if_needed;\n        $c->_flash( {} );\n    };\n}\n\nsub _set_flash {\n    my $c = shift;\n    if (@_) {\n        my $items = @_ > 1 ? {@_} : $_[0];\n        croak('flash takes a hash or hashref') unless ref $items;\n        @{ $c->_flash }{ keys %$items } = values %$items;\n    }\n}\n\nsub flash {\n    my $c = shift;\n    $c->_flash_data;\n    $c->_set_flash(@_);\n    return $c->_flash;\n}\n\nsub clear_flash {\n    my $c = shift;\n\n    #$c->delete_session_data(\"flash:\" . $c->sessionid); # should this be in here? or delayed till finalization?\n    $c->_flash_key_hashes({});\n    $c->_flash_keep_keys({});\n    $c->_flash({});\n}\n\nsub session_expire_key {\n    my ( $c, %keys ) = @_;\n\n    my $now = time;\n    @{ $c->session->{__expire_keys} }{ keys %keys } =\n      map { $now + $_ } values %keys;\n}\n\nsub initialize_session_data {\n    my $c = shift;\n\n    my $now = time;\n\n    return $c->_session(\n        {\n            __created => $now,\n            __updated => $now,\n\n            (\n                $c->_session_plugin_config->{verify_address}\n                ? ( __address => $c->request->address||'' )\n                : ()\n            ),\n            (\n                $c->_session_plugin_config->{verify_user_agent}\n                ? ( __user_agent => $c->request->user_agent||'' )\n                : ()\n            ),\n        }\n    );\n}\n\nsub generate_session_id {\n    my $c = shift;\n\n    my $digest = $c->_find_digest();\n    $digest->add( $c->session_hash_seed() );\n    return $digest->hexdigest;\n}\n\nsub create_session_id_if_needed {\n    my $c = shift;\n    $c->create_session_id unless $c->sessionid;\n}\n\nsub create_session_id {\n    my $c = shift;\n\n    my $sid = $c->generate_session_id;\n\n    $c->log->debug(qq/Created session \"$sid\"/) if $c->debug;\n\n    $c->_sessionid($sid);\n    $c->reset_session_expires;\n    $c->set_session_id($sid);\n\n    return $sid;\n}\n\nmy $counter;\n\nsub session_hash_seed {\n    my $c = shift;\n\n    return join( \"\", ++$counter, time, rand, $$, {}, overload::StrVal($c), );\n}\n\nmy $usable;\n\nsub _find_digest () {\n    unless ($usable) {\n        foreach my $alg (qw/SHA-1 SHA-256 MD5/) {\n            if ( eval { Digest->new($alg) } ) {\n                $usable = $alg;\n                last;\n            }\n        }\n        Catalyst::Exception->throw(\n                \"Could not find a suitable Digest module. Please install \"\n              . \"Digest::SHA1, Digest::SHA, or Digest::MD5\" )\n          unless $usable;\n    }\n\n    return Digest->new($usable);\n}\n\nsub dump_these {\n    my $c = shift;\n\n    (\n        $c->maybe::next::method(),\n\n        $c->_sessionid\n        ? ( [ \"Session ID\" => $c->sessionid ], [ Session => $c->session ], )\n        : ()\n    );\n}\n\n\nsub get_session_id { shift->maybe::next::method(@_) }\nsub set_session_id { shift->maybe::next::method(@_) }\nsub delete_session_id { shift->maybe::next::method(@_) }\nsub extend_session_id { shift->maybe::next::method(@_) }\n\n__PACKAGE__;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nCatalyst::Plugin::Session - Generic Session plugin - ties together server side storage and client side state required to maintain session data.\n\n=head1 SYNOPSIS\n\n    # To get sessions to \"just work\", all you need to do is use these plugins:\n\n    use Catalyst qw/\n      Session\n      Session::Store::FastMmap\n      Session::State::Cookie\n      /;\n\n    # you can replace Store::FastMmap with Store::File - both have sensible\n    # default configurations (see their docs for details)\n\n    # more complicated backends are available for other scenarios (DBI storage,\n    # etc)\n\n\n    # after you've loaded the plugins you can save session data\n    # For example, if you are writing a shopping cart, it could be implemented\n    # like this:\n\n    sub add_item : Local {\n        my ( $self, $c ) = @_;\n\n        my $item_id = $c->req->param(\"item\");\n\n        # $c->session is a hash ref, a bit like $c->stash\n        # the difference is that it' preserved across requests\n\n        push @{ $c->session->{items} }, $item_id;\n\n        $c->forward(\"MyView\");\n    }\n\n    sub display_items : Local {\n        my ( $self, $c ) = @_;\n\n        # values in $c->session are restored\n        $c->stash->{items_to_display} =\n          [ map { MyModel->retrieve($_) } @{ $c->session->{items} } ];\n\n        $c->forward(\"MyView\");\n    }\n\n=head1 DESCRIPTION\n\nThe Session plugin is the base of two related parts of functionality required\nfor session management in web applications.\n\nThe first part, the State, is getting the browser to repeat back a session key,\nso that the web application can identify the client and logically string\nseveral requests together into a session.\n\nThe second part, the Store, deals with the actual storage of information about\nthe client. This data is stored so that the it may be revived for every request\nmade by the same client.\n\nThis plugin links the two pieces together.\n\n=head1 RECOMENDED BACKENDS\n\n=over 4\n\n=item Session::State::Cookie\n\nThe only really sane way to do state is using cookies.\n\n=item Session::Store::File\n\nA portable backend, based on Cache::File.\n\n=item Session::Store::FastMmap\n\nA fast and flexible backend, based on Cache::FastMmap.\n\n=back\n\n=head1 METHODS\n\n=over 4\n\n=item sessionid\n\nAn accessor for the session ID value.\n\n=item session\n\nReturns a hash reference that might contain unserialized values from previous\nrequests in the same session, and whose modified value will be saved for future\nrequests.\n\nThis method will automatically create a new session and session ID if none\nexists.\n\nYou can also set session keys by passing a list of key/value pairs or a\nhashref.\n\n    $c->session->{foo} = \"bar\";      # This works.\n    $c->session(one => 1, two => 2); # And this.\n    $c->session({ answer => 42 });   # And this.\n\n=item session_expires\n\nThis method returns the time when the current session will expire, or 0 if\nthere is no current session. If there is a session and it already expired, it\nwill delete the session and return 0 as well.\n\n=item flash\n\nThis is like Ruby on Rails' flash data structure. Think of it as a stash that\nlasts for longer than one request, letting you redirect instead of forward.\n\nThe flash data will be cleaned up only on requests on which actually use\n$c->flash (thus allowing multiple redirections), and the policy is to delete\nall the keys which haven't changed since the flash data was loaded at the end\nof every request.\n\nNote that use of the flash is an easy way to get data across requests, but\nit's also strongly disrecommended, due it it being inherently plagued with\nrace conditions. This means that it's unlikely to work well if your\nusers have multiple tabs open at once, or if your site does a lot of AJAX\nrequests.\n\nL<Catalyst::Plugin::StatusMessage> is the recommended alternative solution,\nas this doesn't suffer from these issues.\n\n    sub moose : Local {\n        my ( $self, $c ) = @_;\n\n        $c->flash->{beans} = 10;\n        $c->response->redirect( $c->uri_for(\"foo\") );\n    }\n\n    sub foo : Local {\n        my ( $self, $c ) = @_;\n\n        my $value = $c->flash->{beans};\n\n        # ...\n\n        $c->response->redirect( $c->uri_for(\"bar\") );\n    }\n\n    sub bar : Local {\n        my ( $self, $c ) = @_;\n\n        if ( exists $c->flash->{beans} ) { # false\n\n        }\n    }\n\n=item clear_flash\n\nZap all the keys in the flash regardless of their current state.\n\n=item keep_flash @keys\n\nIf you want to keep a flash key for the next request too, even if it hasn't\nchanged, call C<keep_flash> and pass in the keys as arguments.\n\n=item delete_session REASON\n\nThis method is used to invalidate a session. It takes an optional parameter\nwhich will be saved in C<session_delete_reason> if provided.\n\nNOTE: This method will B<also> delete your flash data.\n\n=item session_delete_reason\n\nThis accessor contains a string with the reason a session was deleted. Possible\nvalues include:\n\n=over 4\n\n=item *\n\nC<address mismatch>\n\n=item *\n\nC<session expired>\n\n=back\n\n=item session_expire_key $key, $ttl\n\nMark a key to expire at a certain time (only useful when shorter than the\nexpiry time for the whole session).\n\nFor example:\n\n    __PACKAGE__->config('Plugin::Session' => { expires => 10000000000 }); # \"forever\"\n    (NB If this number is too large, Y2K38 breakage could result.)\n\n    # later\n\n    $c->session_expire_key( __user => 3600 );\n\nWill make the session data survive, but the user will still be logged out after\nan hour.\n\nNote that these values are not auto extended.\n\n=item change_session_id\n\nBy calling this method you can force a session id change while keeping all\nsession data. This method might come handy when you are paranoid about some\nadvanced variations of session fixation attack.\n\nIf you want to prevent this session fixation scenario:\n\n    0) let us have WebApp with anonymous and authenticated parts\n    1) a hacker goes to vulnerable WebApp and gets a real sessionid,\n       just by browsing anonymous part of WebApp\n    2) the hacker inserts (somehow) this values into a cookie in victim's browser\n    3) after the victim logs into WebApp the hacker can enter his/her session\n\nyou should call change_session_id in your login controller like this:\n\n      if ($c->authenticate( { username => $user, password => $pass } )) {\n        # login OK\n        $c->change_session_id;\n        ...\n      } else {\n        # login FAILED\n        ...\n      }\n\n=item change_session_expires $expires\n\nYou can change the session expiration time for this session;\n\n    $c->change_session_expires( 4000 );\n\nNote that this only works to set the session longer than the config setting.\n\n=back\n\n=head1 INTERNAL METHODS\n\n=over 4\n\n=item setup\n\nThis method is extended to also make calls to\nC<check_session_plugin_requirements> and C<setup_session>.\n\n=item check_session_plugin_requirements\n\nThis method ensures that a State and a Store plugin are also in use by the\napplication.\n\n=item setup_session\n\nThis method populates C<< $c->config('Plugin::Session') >> with the default values\nlisted in L</CONFIGURATION>.\n\n=item prepare_action\n\nThis method is extended.\n\nIts only effect is if the (off by default) C<flash_to_stash> configuration\nparameter is on - then it will copy the contents of the flash to the stash at\nprepare time.\n\n=item finalize_headers\n\nThis method is extended and will extend the expiry time before sending\nthe response.\n\n=item finalize_body\n\nThis method is extended and will call finalize_session before the other\nfinalize_body methods run.  Here we persist the session data if a session exists.\n\n=item initialize_session_data\n\nThis method will initialize the internal structure of the session, and is\ncalled by the C<session> method if appropriate.\n\n=item create_session_id\n\nCreates a new session ID using C<generate_session_id> if there is no session ID\nyet.\n\n=item validate_session_id SID\n\nMake sure a session ID is of the right format.\n\nThis currently ensures that the session ID string is any amount of case\ninsensitive hexadecimal characters.\n\n=item generate_session_id\n\nThis method will return a string that can be used as a session ID. It is\nsupposed to be a reasonably random string with enough bits to prevent\ncollision. It basically takes C<session_hash_seed> and hashes it using SHA-1,\nMD5 or SHA-256, depending on the availability of these modules.\n\n=item session_hash_seed\n\nThis method is actually rather internal to generate_session_id, but should be\noverridable in case you want to provide more random data.\n\nCurrently it returns a concatenated string which contains:\n\n=over 4\n\n=item * A counter\n\n=item * The current time\n\n=item * One value from C<rand>.\n\n=item * The stringified value of a newly allocated hash reference\n\n=item * The stringified value of the Catalyst context object\n\n=back\n\nin the hopes that those combined values are entropic enough for most uses. If\nthis is not the case you can replace C<session_hash_seed> with e.g.\n\n    sub session_hash_seed {\n        open my $fh, \"<\", \"/dev/random\";\n        read $fh, my $bytes, 20;\n        close $fh;\n        return $bytes;\n    }\n\nOr even more directly, replace C<generate_session_id>:\n\n    sub generate_session_id {\n        open my $fh, \"<\", \"/dev/random\";\n        read $fh, my $bytes, 20;\n        close $fh;\n        return unpack(\"H*\", $bytes);\n    }\n\nAlso have a look at L<Crypt::Random> and the various openssl bindings - these\nmodules provide APIs for cryptographically secure random data.\n\n=item finalize_session\n\nClean up the session during C<finalize>.\n\nThis clears the various accessors after saving to the store.\n\n=item dump_these\n\nSee L<Catalyst/dump_these> - ammends the session data structure to the list of\ndumped objects if session ID is defined.\n\n\n=item calculate_extended_session_expires\n\n=item calculate_initial_session_expires\n\n=item create_session_id_if_needed\n\n=item delete_session_id\n\n=item extend_session_expires\n\nNote: this is *not* used to give an individual user a longer session. See\n'change_session_expires'.\n\n=item extend_session_id\n\n=item get_session_id\n\n=item reset_session_expires\n\n=item session_is_valid\n\n=item set_session_id\n\n=item initial_session_expires\n\n=back\n\n=head1 USING SESSIONS DURING PREPARE\n\nThe earliest point in time at which you may use the session data is after\nL<Catalyst::Plugin::Session>'s C<prepare_action> has finished.\n\nState plugins must set $c->session ID before C<prepare_action>, and during\nC<prepare_action> L<Catalyst::Plugin::Session> will actually load the data from\nthe store.\n\n    sub prepare_action {\n        my $c = shift;\n\n        # don't touch $c->session yet!\n\n        $c->NEXT::prepare_action( @_ );\n\n        $c->session;  # this is OK\n        $c->sessionid; # this is also OK\n    }\n\n=head1 CONFIGURATION\n\n    $c->config('Plugin::Session' => {\n        expires => 1234,\n    });\n\nAll configuation parameters are provided in a hash reference under the\nC<Plugin::Session> key in the configuration hash.\n\n=over 4\n\n=item expires\n\nThe time-to-live of each session, expressed in seconds. Defaults to 7200 (two\nhours).\n\n=item expiry_threshold\n\nOnly update the session expiry time if it would otherwise expire\nwithin this many seconds from now.\n\nThe purpose of this is to keep the session store from being updated\nwhen nothing else in the session is updated.\n\nDefaults to 0 (in which case, the expiration will always be updated).\n\n=item verify_address\n\nWhen true, C<< $c->request->address >> will be checked at prepare time. If it is\nnot the same as the address that initiated the session, the session is deleted.\n\nDefaults to false.\n\n=item verify_user_agent\n\nWhen true, C<< $c->request->user_agent >> will be checked at prepare time. If it\nis not the same as the user agent that initiated the session, the session is\ndeleted.\n\nDefaults to false.\n\n=item flash_to_stash\n\nThis option makes it easier to have actions behave the same whether they were\nforwarded to or redirected to. On prepare time it copies the contents of\nC<flash> (if any) to the stash.\n\n=back\n\n=head1 SPECIAL KEYS\n\nThe hash reference returned by C<< $c->session >> contains several keys which\nare automatically set:\n\n=over 4\n\n=item __expires\n\nThis key no longer exists. Use C<session_expires> instead.\n\n=item __updated\n\nThe last time a session was saved to the store.\n\n=item __created\n\nThe time when the session was first created.\n\n=item __address\n\nThe value of C<< $c->request->address >> at the time the session was created.\nThis value is only populated if C<verify_address> is true in the configuration.\n\n=item __user_agent\n\nThe value of C<< $c->request->user_agent >> at the time the session was created.\nThis value is only populated if C<verify_user_agent> is true in the configuration.\n\n=back\n\n=head1 CAVEATS\n\n=head2 Round the Robin Proxies\n\nC<verify_address> could make your site inaccessible to users who are behind\nload balanced proxies. Some ISPs may give a different IP to each request by the\nsame client due to this type of proxying. If addresses are verified these\nusers' sessions cannot persist.\n\nTo let these users access your site you can either disable address verification\nas a whole, or provide a checkbox in the login dialog that tells the server\nthat it's OK for the address of the client to change. When the server sees that\nthis box is checked it should delete the C<__address> special key from the\nsession hash when the hash is first created.\n\n=head2 Race Conditions\n\nIn this day and age where cleaning detergents and Dutch football (not the\nAmerican kind) teams roam the plains in great numbers, requests may happen\nsimultaneously. This means that there is some risk of session data being\noverwritten, like this:\n\n=over 4\n\n=item 1.\n\nrequest a starts, request b starts, with the same session ID\n\n=item 2.\n\nsession data is loaded in request a\n\n=item 3.\n\nsession data is loaded in request b\n\n=item 4.\n\nsession data is changed in request a\n\n=item 5.\n\nrequest a finishes, session data is updated and written to store\n\n=item 6.\n\nrequest b finishes, session data is updated and written to store, overwriting\nchanges by request a\n\n=back\n\nFor applications where any given user's session is only making one request\nat a time this plugin should be safe enough.\n\n=head1 AUTHORS\n\nAndy Grundman\n\nChristian Hansen\n\nYuval Kogman, C<nothingmuch@woobling.org>\n\nSebastian Riedel\n\nTomas Doran (t0m) C<bobtfish@bobtfish.net> (current maintainer)\n\nSergio Salvi\n\nkmx C<kmx@volny.cz>\n\nFlorian Ragwitz (rafl) C<rafl@debian.org>\n\nKent Fredric (kentnl)\n\nAnd countless other contributers from #catalyst. Thanks guys!\n\n=head1 Contributors\n\nDevin Austin (dhoss) <dhoss@cpan.org>\n\nRobert Rothenberg <rrwo@cpan.org> (on behalf of Foxtons Ltd.)\n\n=head1 COPYRIGHT & LICENSE\n\n    Copyright (c) 2005 the aforementioned authors. All rights\n    reserved. This program is free software; you can redistribute\n    it and/or modify it under the same terms as Perl itself.\n\n=cut\n\n\n"], "fixing_code": ["#!/usr/bin/perl\n\npackage Catalyst::Plugin::Session;\n\nuse Moose;\nwith 'MooseX::Emulate::Class::Accessor::Fast';\nuse MRO::Compat;\nuse Catalyst::Exception ();\nuse Digest              ();\nuse overload            ();\nuse Object::Signature   ();\nuse HTML::Entities      ();\nuse Carp;\nuse List::Util qw/ max /;\n\nuse namespace::clean -except => 'meta';\n\nour $VERSION = '0.40';\n$VERSION = eval $VERSION;\n\nmy @session_data_accessors; # used in delete_session\n\n__PACKAGE__->mk_accessors(\n        \"_session_delete_reason\",\n        @session_data_accessors = qw/\n          _sessionid\n          _session\n          _session_expires\n          _extended_session_expires\n          _session_data_sig\n          _flash\n          _flash_keep_keys\n          _flash_key_hashes\n          _tried_loading_session_id\n          _tried_loading_session_data\n          _tried_loading_session_expires\n          _tried_loading_flash_data\n          _needs_early_session_finalization\n          /\n);\n\nsub _session_plugin_config {\n    my $c = shift;\n    # FIXME - Start warning once all the state/store modules have also been updated.\n    #$c->log->warn(\"Deprecated 'session' config key used, please use the key 'Plugin::Session' instead\")\n    #    if exists $c->config->{session}\n    #$c->config->{'Plugin::Session'} ||= delete($c->config->{session}) || {};\n    $c->config->{'Plugin::Session'} ||= $c->config->{session} || {};\n}\n\nsub setup {\n    my $c = shift;\n\n    $c->maybe::next::method(@_);\n\n    $c->check_session_plugin_requirements;\n    $c->setup_session;\n\n    return $c;\n}\n\nsub check_session_plugin_requirements {\n    my $c = shift;\n\n    unless ( $c->isa(\"Catalyst::Plugin::Session::State\")\n        && $c->isa(\"Catalyst::Plugin::Session::Store\") )\n    {\n        my $err =\n          (     \"The Session plugin requires both Session::State \"\n              . \"and Session::Store plugins to be used as well.\" );\n\n        $c->log->fatal($err);\n        Catalyst::Exception->throw($err);\n    }\n}\n\nsub setup_session {\n    my $c = shift;\n\n    my $cfg = $c->_session_plugin_config;\n\n    %$cfg = (\n        expires        => 7200,\n        verify_address => 0,\n        verify_user_agent => 0,\n        expiry_threshold => 0,\n        %$cfg,\n    );\n\n    $c->maybe::next::method();\n}\n\nsub prepare_action {\n    my $c = shift;\n\n    $c->maybe::next::method(@_);\n\n    if (    $c->_session_plugin_config->{flash_to_stash}\n        and $c->sessionid\n        and my $flash_data = $c->flash )\n    {\n        @{ $c->stash }{ keys %$flash_data } = values %$flash_data;\n    }\n}\n\nsub finalize_headers {\n    my $c = shift;\n\n    # fix cookie before we send headers\n    $c->_save_session_expires;\n\n    # Force extension of session_expires before finalizing headers, so a pos\n    # up to date. First call to session_expires will extend the expiry, subs\n    # just return the previously extended value.\n    $c->session_expires;\n    $c->finalize_session if $c->_needs_early_session_finalization;\n\n    return $c->maybe::next::method(@_);\n}\n\nsub finalize_body {\n    my $c = shift;\n\n    # We have to finalize our session *before* $c->engine->finalize_xxx is called,\n    # because we do not want to send the HTTP response before the session is stored/committed to\n    # the session database (or whatever Session::Store you use).\n    $c->finalize_session unless $c->_needs_early_session_finalization;\n    $c->_clear_session_instance_data;\n\n    return $c->maybe::next::method(@_);\n}\n\nsub finalize_session {\n    my $c = shift;\n\n    $c->maybe::next::method(@_);\n\n    $c->_save_session_id;\n    $c->_save_session;\n    $c->_save_flash;\n\n}\n\nsub _session_updated {\n    my $c = shift;\n\n    if ( my $session_data = $c->_session ) {\n\n        no warnings 'uninitialized';\n        if ( Object::Signature::signature($session_data) ne\n            $c->_session_data_sig )\n        {\n            return $session_data;\n        } else {\n            return;\n        }\n\n    } else {\n\n        return;\n\n    }\n}\n\nsub _save_session_id {\n    my $c = shift;\n\n    # we already called set when allocating\n    # no need to tell the state plugins anything new\n}\n\nsub _save_session_expires {\n    my $c = shift;\n\n    if ( defined($c->_session_expires) ) {\n\n        if (my $sid = $c->sessionid) {\n\n            my $current  = $c->_get_stored_session_expires;\n            my $extended = $c->session_expires;\n            if ($extended > $current) {\n                $c->store_session_data( \"expires:$sid\" => $extended );\n            }\n\n        }\n    }\n}\n\nsub _save_session {\n    my $c = shift;\n\n    if ( my $session_data = $c->_session_updated ) {\n\n        $session_data->{__updated} = time();\n        my $sid = $c->sessionid;\n        $c->store_session_data( \"session:$sid\" => $session_data );\n    }\n}\n\nsub _save_flash {\n    my $c = shift;\n\n    if ( my $flash_data = $c->_flash ) {\n\n        my $hashes = $c->_flash_key_hashes || {};\n        my $keep = $c->_flash_keep_keys || {};\n        foreach my $key ( keys %$hashes ) {\n            if ( !exists $keep->{$key} and Object::Signature::signature( \\$flash_data->{$key} ) eq $hashes->{$key} ) {\n                delete $flash_data->{$key};\n            }\n        }\n\n        my $sid = $c->sessionid;\n\n        my $session_data = $c->_session;\n        if (%$flash_data) {\n            $session_data->{__flash} = $flash_data;\n        }\n        else {\n            delete $session_data->{__flash};\n        }\n        $c->_session($session_data);\n        $c->_save_session;\n    }\n}\n\nsub _load_session_expires {\n    my $c = shift;\n    return $c->_session_expires if $c->_tried_loading_session_expires;\n    $c->_tried_loading_session_expires(1);\n\n    if ( my $sid = $c->sessionid ) {\n        my $expires =  $c->_get_stored_session_expires;\n\n        if ( $expires >= time() ) {\n            $c->_session_expires( $expires );\n            return $expires;\n        } else {\n            $c->delete_session( \"session expired\" );\n            return 0;\n        }\n    }\n\n    return;\n}\n\nsub _load_session {\n    my $c = shift;\n    return $c->_session if $c->_tried_loading_session_data;\n    $c->_tried_loading_session_data(1);\n\n    if ( my $sid = $c->sessionid ) {\n        if ( $c->_load_session_expires ) {    # > 0\n\n            my $session_data = $c->get_session_data(\"session:$sid\") || return;\n            $c->_session($session_data);\n\n            no warnings 'uninitialized';    # ne __address\n            if (   $c->_session_plugin_config->{verify_address}\n                && exists $session_data->{__address}\n                && $session_data->{__address} ne $c->request->address )\n            {\n                $c->log->warn(\n                        \"Deleting session $sid due to address mismatch (\"\n                      . $session_data->{__address} . \" != \"\n                      . $c->request->address . \")\"\n                );\n                $c->delete_session(\"address mismatch\");\n                return;\n            }\n            if (   $c->_session_plugin_config->{verify_user_agent}\n                && $session_data->{__user_agent} ne $c->request->user_agent )\n            {\n                $c->log->warn(\n                        \"Deleting session $sid due to user agent mismatch (\"\n                      . $session_data->{__user_agent} . \" != \"\n                      . $c->request->user_agent . \")\"\n                );\n                $c->delete_session(\"user agent mismatch\");\n                return;\n            }\n\n            $c->log->debug(qq/Restored session \"$sid\"/) if $c->debug;\n            $c->_session_data_sig( Object::Signature::signature($session_data) ) if $session_data;\n            $c->_expire_session_keys;\n\n            return $session_data;\n        }\n    }\n\n    return;\n}\n\nsub _load_flash {\n    my $c = shift;\n    return $c->_flash if $c->_tried_loading_flash_data;\n    $c->_tried_loading_flash_data(1);\n\n    if ( my $sid = $c->sessionid ) {\n\n        my $session_data = $c->session;\n        $c->_flash($session_data->{__flash});\n\n        if ( my $flash_data = $c->_flash )\n        {\n            $c->_flash_key_hashes({ map { $_ => Object::Signature::signature( \\$flash_data->{$_} ) } keys %$flash_data });\n\n            return $flash_data;\n        }\n    }\n\n    return;\n}\n\nsub _expire_session_keys {\n    my ( $c, $data ) = @_;\n\n    my $now = time;\n\n    my $expire_times = ( $data || $c->_session || {} )->{__expire_keys} || {};\n    foreach my $key ( grep { $expire_times->{$_} < $now } keys %$expire_times ) {\n        delete $c->_session->{$key};\n        delete $expire_times->{$key};\n    }\n}\n\nsub _clear_session_instance_data {\n    my $c = shift;\n    $c->$_(undef) for @session_data_accessors;\n    $c->maybe::next::method(@_); # allow other plugins to hook in on this\n}\n\nsub change_session_id {\n    my $c = shift;\n\n    my $sessiondata = $c->session;\n    my $oldsid = $c->sessionid;\n    my $newsid = $c->create_session_id;\n\n    if ($oldsid) {\n        $c->log->debug(qq/change_sessid: deleting session data from \"$oldsid\"/) if $c->debug;\n        $c->delete_session_data(\"${_}:${oldsid}\") for qw/session expires flash/;\n    }\n\n    $c->log->debug(qq/change_sessid: storing session data to \"$newsid\"/) if $c->debug;\n    $c->store_session_data( \"session:$newsid\" => $sessiondata );\n\n    return $newsid;\n}\n\nsub delete_session {\n    my ( $c, $msg ) = @_;\n\n    $c->log->debug(\"Deleting session\" . ( defined($msg) ? \"($msg)\" : '(no reason given)') ) if $c->debug;\n\n    # delete the session data\n    if ( my $sid = $c->sessionid ) {\n        $c->delete_session_data(\"${_}:${sid}\") for qw/session expires flash/;\n        $c->delete_session_id($sid);\n    }\n\n    # reset the values in the context object\n    # see the BEGIN block\n    $c->_clear_session_instance_data;\n\n    $c->_session_delete_reason($msg);\n}\n\nsub session_delete_reason {\n    my $c = shift;\n\n    $c->session_is_valid; # check that it was loaded\n\n    $c->_session_delete_reason(@_);\n}\n\nsub session_expires {\n    my $c = shift;\n\n    if ( defined( my $expires = $c->_extended_session_expires ) ) {\n        return $expires;\n    } elsif ( defined( $expires = $c->_load_session_expires ) ) {\n        return $c->extend_session_expires( $expires );\n    } else {\n        return 0;\n    }\n}\n\nsub extend_session_expires {\n    my ( $c, $expires ) = @_;\n\n    my $threshold = $c->_session_plugin_config->{expiry_threshold} || 0;\n\n    if ( my $sid = $c->sessionid ) {\n        my $expires = $c->_get_stored_session_expires;\n        my $cutoff  = $expires - $threshold;\n\n        if (!$threshold || $cutoff <= time || $c->_session_updated) {\n\n            $c->_extended_session_expires( my $updated = $c->calculate_initial_session_expires() );\n            $c->extend_session_id( $sid, $updated );\n\n            return $updated;\n\n        } else {\n\n            return $expires;\n\n        }\n\n    } else {\n\n        return;\n\n    }\n\n}\n\nsub change_session_expires {\n    my ( $c, $expires ) = @_;\n\n    $expires ||= 0;\n    my $sid = $c->sessionid;\n    my $time_exp = time() + $expires;\n    $c->store_session_data( \"expires:$sid\" => $time_exp );\n}\n\nsub _get_stored_session_expires {\n    my ($c) = @_;\n\n    if ( my $sid = $c->sessionid ) {\n        return $c->get_session_data(\"expires:$sid\") || 0;\n    } else {\n        return 0;\n    }\n}\n\nsub initial_session_expires {\n    my $c = shift;\n    return ( time() + $c->_session_plugin_config->{expires} );\n}\n\nsub calculate_initial_session_expires {\n    my ($c) = @_;\n    return max( $c->initial_session_expires, $c->_get_stored_session_expires );\n}\n\nsub calculate_extended_session_expires {\n    my ( $c, $prev ) = @_;\n    return ( time() + $prev );\n}\n\nsub reset_session_expires {\n    my ( $c, $sid ) = @_;\n\n    my $exp = $c->calculate_initial_session_expires;\n    $c->_session_expires( $exp );\n    #\n    # since we're setting _session_expires directly, make load_session_expires\n    # actually use that value.\n    #\n    $c->_tried_loading_session_expires(1);\n    $c->_extended_session_expires( $exp );\n    $exp;\n}\n\nsub sessionid {\n    my $c = shift;\n\n    return $c->_sessionid || $c->_load_sessionid;\n}\n\nsub _load_sessionid {\n    my $c = shift;\n    return if $c->_tried_loading_session_id;\n    $c->_tried_loading_session_id(1);\n\n    if ( defined( my $sid = $c->get_session_id ) ) {\n        if ( $c->validate_session_id($sid) ) {\n            # temporarily set the inner key, so that validation will work\n            $c->_sessionid($sid);\n            return $sid;\n        } else {\n            $sid = HTML::Entities::encode_entities($sid);\n            my $err = \"Tried to set invalid session ID '$sid'\";\n            $c->log->error($err);\n            Catalyst::Exception->throw($err);\n        }\n    }\n\n    return;\n}\n\nsub session_is_valid {\n    my $c = shift;\n\n    # force a check for expiry, but also __address, etc\n    if ( $c->_load_session ) {\n        return 1;\n    } else {\n        return;\n    }\n}\n\nsub validate_session_id {\n    my ( $c, $sid ) = @_;\n\n    $sid and $sid =~ /^[a-f\\d]+$/i;\n}\n\nsub session {\n    my $c = shift;\n\n    my $session = $c->_session || $c->_load_session || do {\n        $c->create_session_id_if_needed;\n        $c->initialize_session_data;\n    };\n\n    if (@_) {\n      my $new_values = @_ > 1 ? { @_ } : $_[0];\n      croak('session takes a hash or hashref') unless ref $new_values;\n\n      for my $key (keys %$new_values) {\n        $session->{$key} = $new_values->{$key};\n      }\n    }\n\n    $session;\n}\n\nsub keep_flash {\n    my ( $c, @keys ) = @_;\n    my $href = $c->_flash_keep_keys || $c->_flash_keep_keys({});\n    (@{$href}{@keys}) = ((undef) x @keys);\n}\n\nsub _flash_data {\n    my $c = shift;\n    $c->_flash || $c->_load_flash || do {\n        $c->create_session_id_if_needed;\n        $c->_flash( {} );\n    };\n}\n\nsub _set_flash {\n    my $c = shift;\n    if (@_) {\n        my $items = @_ > 1 ? {@_} : $_[0];\n        croak('flash takes a hash or hashref') unless ref $items;\n        @{ $c->_flash }{ keys %$items } = values %$items;\n    }\n}\n\nsub flash {\n    my $c = shift;\n    $c->_flash_data;\n    $c->_set_flash(@_);\n    return $c->_flash;\n}\n\nsub clear_flash {\n    my $c = shift;\n\n    #$c->delete_session_data(\"flash:\" . $c->sessionid); # should this be in here? or delayed till finalization?\n    $c->_flash_key_hashes({});\n    $c->_flash_keep_keys({});\n    $c->_flash({});\n}\n\nsub session_expire_key {\n    my ( $c, %keys ) = @_;\n\n    my $now = time;\n    @{ $c->session->{__expire_keys} }{ keys %keys } =\n      map { $now + $_ } values %keys;\n}\n\nsub initialize_session_data {\n    my $c = shift;\n\n    my $now = time;\n\n    return $c->_session(\n        {\n            __created => $now,\n            __updated => $now,\n\n            (\n                $c->_session_plugin_config->{verify_address}\n                ? ( __address => $c->request->address||'' )\n                : ()\n            ),\n            (\n                $c->_session_plugin_config->{verify_user_agent}\n                ? ( __user_agent => $c->request->user_agent||'' )\n                : ()\n            ),\n        }\n    );\n}\n\nsub generate_session_id {\n    my $c = shift;\n\n    my $digest = $c->_find_digest();\n    $digest->add( $c->session_hash_seed() );\n    return $digest->hexdigest;\n}\n\nsub create_session_id_if_needed {\n    my $c = shift;\n    $c->create_session_id unless $c->sessionid;\n}\n\nsub create_session_id {\n    my $c = shift;\n\n    my $sid = $c->generate_session_id;\n\n    $c->log->debug(qq/Created session \"$sid\"/) if $c->debug;\n\n    $c->_sessionid($sid);\n    $c->reset_session_expires;\n    $c->set_session_id($sid);\n\n    return $sid;\n}\n\nmy $counter;\n\nsub session_hash_seed {\n    my $c = shift;\n\n    return join( \"\", ++$counter, time, rand, $$, {}, overload::StrVal($c), );\n}\n\nmy $usable;\n\nsub _find_digest () {\n    unless ($usable) {\n        foreach my $alg (qw/SHA-1 SHA-256 MD5/) {\n            if ( eval { Digest->new($alg) } ) {\n                $usable = $alg;\n                last;\n            }\n        }\n        Catalyst::Exception->throw(\n                \"Could not find a suitable Digest module. Please install \"\n              . \"Digest::SHA1, Digest::SHA, or Digest::MD5\" )\n          unless $usable;\n    }\n\n    return Digest->new($usable);\n}\n\nsub dump_these {\n    my $c = shift;\n\n    (\n        $c->maybe::next::method(),\n\n        $c->_sessionid\n        ? ( [ \"Session ID\" => $c->sessionid ], [ Session => $c->session ], )\n        : ()\n    );\n}\n\n\nsub get_session_id { shift->maybe::next::method(@_) }\nsub set_session_id { shift->maybe::next::method(@_) }\nsub delete_session_id { shift->maybe::next::method(@_) }\nsub extend_session_id { shift->maybe::next::method(@_) }\n\n__PACKAGE__;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nCatalyst::Plugin::Session - Generic Session plugin - ties together server side storage and client side state required to maintain session data.\n\n=head1 SYNOPSIS\n\n    # To get sessions to \"just work\", all you need to do is use these plugins:\n\n    use Catalyst qw/\n      Session\n      Session::Store::FastMmap\n      Session::State::Cookie\n      /;\n\n    # you can replace Store::FastMmap with Store::File - both have sensible\n    # default configurations (see their docs for details)\n\n    # more complicated backends are available for other scenarios (DBI storage,\n    # etc)\n\n\n    # after you've loaded the plugins you can save session data\n    # For example, if you are writing a shopping cart, it could be implemented\n    # like this:\n\n    sub add_item : Local {\n        my ( $self, $c ) = @_;\n\n        my $item_id = $c->req->param(\"item\");\n\n        # $c->session is a hash ref, a bit like $c->stash\n        # the difference is that it' preserved across requests\n\n        push @{ $c->session->{items} }, $item_id;\n\n        $c->forward(\"MyView\");\n    }\n\n    sub display_items : Local {\n        my ( $self, $c ) = @_;\n\n        # values in $c->session are restored\n        $c->stash->{items_to_display} =\n          [ map { MyModel->retrieve($_) } @{ $c->session->{items} } ];\n\n        $c->forward(\"MyView\");\n    }\n\n=head1 DESCRIPTION\n\nThe Session plugin is the base of two related parts of functionality required\nfor session management in web applications.\n\nThe first part, the State, is getting the browser to repeat back a session key,\nso that the web application can identify the client and logically string\nseveral requests together into a session.\n\nThe second part, the Store, deals with the actual storage of information about\nthe client. This data is stored so that the it may be revived for every request\nmade by the same client.\n\nThis plugin links the two pieces together.\n\n=head1 RECOMENDED BACKENDS\n\n=over 4\n\n=item Session::State::Cookie\n\nThe only really sane way to do state is using cookies.\n\n=item Session::Store::File\n\nA portable backend, based on Cache::File.\n\n=item Session::Store::FastMmap\n\nA fast and flexible backend, based on Cache::FastMmap.\n\n=back\n\n=head1 METHODS\n\n=over 4\n\n=item sessionid\n\nAn accessor for the session ID value.\n\n=item session\n\nReturns a hash reference that might contain unserialized values from previous\nrequests in the same session, and whose modified value will be saved for future\nrequests.\n\nThis method will automatically create a new session and session ID if none\nexists.\n\nYou can also set session keys by passing a list of key/value pairs or a\nhashref.\n\n    $c->session->{foo} = \"bar\";      # This works.\n    $c->session(one => 1, two => 2); # And this.\n    $c->session({ answer => 42 });   # And this.\n\n=item session_expires\n\nThis method returns the time when the current session will expire, or 0 if\nthere is no current session. If there is a session and it already expired, it\nwill delete the session and return 0 as well.\n\n=item flash\n\nThis is like Ruby on Rails' flash data structure. Think of it as a stash that\nlasts for longer than one request, letting you redirect instead of forward.\n\nThe flash data will be cleaned up only on requests on which actually use\n$c->flash (thus allowing multiple redirections), and the policy is to delete\nall the keys which haven't changed since the flash data was loaded at the end\nof every request.\n\nNote that use of the flash is an easy way to get data across requests, but\nit's also strongly disrecommended, due it it being inherently plagued with\nrace conditions. This means that it's unlikely to work well if your\nusers have multiple tabs open at once, or if your site does a lot of AJAX\nrequests.\n\nL<Catalyst::Plugin::StatusMessage> is the recommended alternative solution,\nas this doesn't suffer from these issues.\n\n    sub moose : Local {\n        my ( $self, $c ) = @_;\n\n        $c->flash->{beans} = 10;\n        $c->response->redirect( $c->uri_for(\"foo\") );\n    }\n\n    sub foo : Local {\n        my ( $self, $c ) = @_;\n\n        my $value = $c->flash->{beans};\n\n        # ...\n\n        $c->response->redirect( $c->uri_for(\"bar\") );\n    }\n\n    sub bar : Local {\n        my ( $self, $c ) = @_;\n\n        if ( exists $c->flash->{beans} ) { # false\n\n        }\n    }\n\n=item clear_flash\n\nZap all the keys in the flash regardless of their current state.\n\n=item keep_flash @keys\n\nIf you want to keep a flash key for the next request too, even if it hasn't\nchanged, call C<keep_flash> and pass in the keys as arguments.\n\n=item delete_session REASON\n\nThis method is used to invalidate a session. It takes an optional parameter\nwhich will be saved in C<session_delete_reason> if provided.\n\nNOTE: This method will B<also> delete your flash data.\n\n=item session_delete_reason\n\nThis accessor contains a string with the reason a session was deleted. Possible\nvalues include:\n\n=over 4\n\n=item *\n\nC<address mismatch>\n\n=item *\n\nC<session expired>\n\n=back\n\n=item session_expire_key $key, $ttl\n\nMark a key to expire at a certain time (only useful when shorter than the\nexpiry time for the whole session).\n\nFor example:\n\n    __PACKAGE__->config('Plugin::Session' => { expires => 10000000000 }); # \"forever\"\n    (NB If this number is too large, Y2K38 breakage could result.)\n\n    # later\n\n    $c->session_expire_key( __user => 3600 );\n\nWill make the session data survive, but the user will still be logged out after\nan hour.\n\nNote that these values are not auto extended.\n\n=item change_session_id\n\nBy calling this method you can force a session id change while keeping all\nsession data. This method might come handy when you are paranoid about some\nadvanced variations of session fixation attack.\n\nIf you want to prevent this session fixation scenario:\n\n    0) let us have WebApp with anonymous and authenticated parts\n    1) a hacker goes to vulnerable WebApp and gets a real sessionid,\n       just by browsing anonymous part of WebApp\n    2) the hacker inserts (somehow) this values into a cookie in victim's browser\n    3) after the victim logs into WebApp the hacker can enter his/her session\n\nyou should call change_session_id in your login controller like this:\n\n      if ($c->authenticate( { username => $user, password => $pass } )) {\n        # login OK\n        $c->change_session_id;\n        ...\n      } else {\n        # login FAILED\n        ...\n      }\n\n=item change_session_expires $expires\n\nYou can change the session expiration time for this session;\n\n    $c->change_session_expires( 4000 );\n\nNote that this only works to set the session longer than the config setting.\n\n=back\n\n=head1 INTERNAL METHODS\n\n=over 4\n\n=item setup\n\nThis method is extended to also make calls to\nC<check_session_plugin_requirements> and C<setup_session>.\n\n=item check_session_plugin_requirements\n\nThis method ensures that a State and a Store plugin are also in use by the\napplication.\n\n=item setup_session\n\nThis method populates C<< $c->config('Plugin::Session') >> with the default values\nlisted in L</CONFIGURATION>.\n\n=item prepare_action\n\nThis method is extended.\n\nIts only effect is if the (off by default) C<flash_to_stash> configuration\nparameter is on - then it will copy the contents of the flash to the stash at\nprepare time.\n\n=item finalize_headers\n\nThis method is extended and will extend the expiry time before sending\nthe response.\n\n=item finalize_body\n\nThis method is extended and will call finalize_session before the other\nfinalize_body methods run.  Here we persist the session data if a session exists.\n\n=item initialize_session_data\n\nThis method will initialize the internal structure of the session, and is\ncalled by the C<session> method if appropriate.\n\n=item create_session_id\n\nCreates a new session ID using C<generate_session_id> if there is no session ID\nyet.\n\n=item validate_session_id SID\n\nMake sure a session ID is of the right format.\n\nThis currently ensures that the session ID string is any amount of case\ninsensitive hexadecimal characters.\n\n=item generate_session_id\n\nThis method will return a string that can be used as a session ID. It is\nsupposed to be a reasonably random string with enough bits to prevent\ncollision. It basically takes C<session_hash_seed> and hashes it using SHA-1,\nMD5 or SHA-256, depending on the availability of these modules.\n\n=item session_hash_seed\n\nThis method is actually rather internal to generate_session_id, but should be\noverridable in case you want to provide more random data.\n\nCurrently it returns a concatenated string which contains:\n\n=over 4\n\n=item * A counter\n\n=item * The current time\n\n=item * One value from C<rand>.\n\n=item * The stringified value of a newly allocated hash reference\n\n=item * The stringified value of the Catalyst context object\n\n=back\n\nin the hopes that those combined values are entropic enough for most uses. If\nthis is not the case you can replace C<session_hash_seed> with e.g.\n\n    sub session_hash_seed {\n        open my $fh, \"<\", \"/dev/random\";\n        read $fh, my $bytes, 20;\n        close $fh;\n        return $bytes;\n    }\n\nOr even more directly, replace C<generate_session_id>:\n\n    sub generate_session_id {\n        open my $fh, \"<\", \"/dev/random\";\n        read $fh, my $bytes, 20;\n        close $fh;\n        return unpack(\"H*\", $bytes);\n    }\n\nAlso have a look at L<Crypt::Random> and the various openssl bindings - these\nmodules provide APIs for cryptographically secure random data.\n\n=item finalize_session\n\nClean up the session during C<finalize>.\n\nThis clears the various accessors after saving to the store.\n\n=item dump_these\n\nSee L<Catalyst/dump_these> - ammends the session data structure to the list of\ndumped objects if session ID is defined.\n\n\n=item calculate_extended_session_expires\n\n=item calculate_initial_session_expires\n\n=item create_session_id_if_needed\n\n=item delete_session_id\n\n=item extend_session_expires\n\nNote: this is *not* used to give an individual user a longer session. See\n'change_session_expires'.\n\n=item extend_session_id\n\n=item get_session_id\n\n=item reset_session_expires\n\n=item session_is_valid\n\n=item set_session_id\n\n=item initial_session_expires\n\n=back\n\n=head1 USING SESSIONS DURING PREPARE\n\nThe earliest point in time at which you may use the session data is after\nL<Catalyst::Plugin::Session>'s C<prepare_action> has finished.\n\nState plugins must set $c->session ID before C<prepare_action>, and during\nC<prepare_action> L<Catalyst::Plugin::Session> will actually load the data from\nthe store.\n\n    sub prepare_action {\n        my $c = shift;\n\n        # don't touch $c->session yet!\n\n        $c->NEXT::prepare_action( @_ );\n\n        $c->session;  # this is OK\n        $c->sessionid; # this is also OK\n    }\n\n=head1 CONFIGURATION\n\n    $c->config('Plugin::Session' => {\n        expires => 1234,\n    });\n\nAll configuation parameters are provided in a hash reference under the\nC<Plugin::Session> key in the configuration hash.\n\n=over 4\n\n=item expires\n\nThe time-to-live of each session, expressed in seconds. Defaults to 7200 (two\nhours).\n\n=item expiry_threshold\n\nOnly update the session expiry time if it would otherwise expire\nwithin this many seconds from now.\n\nThe purpose of this is to keep the session store from being updated\nwhen nothing else in the session is updated.\n\nDefaults to 0 (in which case, the expiration will always be updated).\n\n=item verify_address\n\nWhen true, C<< $c->request->address >> will be checked at prepare time. If it is\nnot the same as the address that initiated the session, the session is deleted.\n\nDefaults to false.\n\n=item verify_user_agent\n\nWhen true, C<< $c->request->user_agent >> will be checked at prepare time. If it\nis not the same as the user agent that initiated the session, the session is\ndeleted.\n\nDefaults to false.\n\n=item flash_to_stash\n\nThis option makes it easier to have actions behave the same whether they were\nforwarded to or redirected to. On prepare time it copies the contents of\nC<flash> (if any) to the stash.\n\n=back\n\n=head1 SPECIAL KEYS\n\nThe hash reference returned by C<< $c->session >> contains several keys which\nare automatically set:\n\n=over 4\n\n=item __expires\n\nThis key no longer exists. Use C<session_expires> instead.\n\n=item __updated\n\nThe last time a session was saved to the store.\n\n=item __created\n\nThe time when the session was first created.\n\n=item __address\n\nThe value of C<< $c->request->address >> at the time the session was created.\nThis value is only populated if C<verify_address> is true in the configuration.\n\n=item __user_agent\n\nThe value of C<< $c->request->user_agent >> at the time the session was created.\nThis value is only populated if C<verify_user_agent> is true in the configuration.\n\n=back\n\n=head1 CAVEATS\n\n=head2 Round the Robin Proxies\n\nC<verify_address> could make your site inaccessible to users who are behind\nload balanced proxies. Some ISPs may give a different IP to each request by the\nsame client due to this type of proxying. If addresses are verified these\nusers' sessions cannot persist.\n\nTo let these users access your site you can either disable address verification\nas a whole, or provide a checkbox in the login dialog that tells the server\nthat it's OK for the address of the client to change. When the server sees that\nthis box is checked it should delete the C<__address> special key from the\nsession hash when the hash is first created.\n\n=head2 Race Conditions\n\nIn this day and age where cleaning detergents and Dutch football (not the\nAmerican kind) teams roam the plains in great numbers, requests may happen\nsimultaneously. This means that there is some risk of session data being\noverwritten, like this:\n\n=over 4\n\n=item 1.\n\nrequest a starts, request b starts, with the same session ID\n\n=item 2.\n\nsession data is loaded in request a\n\n=item 3.\n\nsession data is loaded in request b\n\n=item 4.\n\nsession data is changed in request a\n\n=item 5.\n\nrequest a finishes, session data is updated and written to store\n\n=item 6.\n\nrequest b finishes, session data is updated and written to store, overwriting\nchanges by request a\n\n=back\n\nFor applications where any given user's session is only making one request\nat a time this plugin should be safe enough.\n\n=head1 AUTHORS\n\nAndy Grundman\n\nChristian Hansen\n\nYuval Kogman, C<nothingmuch@woobling.org>\n\nSebastian Riedel\n\nTomas Doran (t0m) C<bobtfish@bobtfish.net> (current maintainer)\n\nSergio Salvi\n\nkmx C<kmx@volny.cz>\n\nFlorian Ragwitz (rafl) C<rafl@debian.org>\n\nKent Fredric (kentnl)\n\nAnd countless other contributers from #catalyst. Thanks guys!\n\n=head1 Contributors\n\nDevin Austin (dhoss) <dhoss@cpan.org>\n\nRobert Rothenberg <rrwo@cpan.org> (on behalf of Foxtons Ltd.)\n\n=head1 COPYRIGHT & LICENSE\n\n    Copyright (c) 2005 the aforementioned authors. All rights\n    reserved. This program is free software; you can redistribute\n    it and/or modify it under the same terms as Perl itself.\n\n=cut\n\n\n"], "filenames": ["lib/Catalyst/Plugin/Session.pm"], "buggy_code_start_loc": [11], "buggy_code_end_loc": [482], "fixing_code_start_loc": [12], "fixing_code_end_loc": [485], "type": "CWE-79", "message": "A vulnerability has been found in Catalyst-Plugin-Session up to 0.40 and classified as problematic. This vulnerability affects the function _load_sessionid of the file lib/Catalyst/Plugin/Session.pm of the component Session ID Handler. The manipulation of the argument sid leads to cross site scripting. The attack can be initiated remotely. Upgrading to version 0.41 is able to address this issue. The name of the patch is 88d1b599e1163761c9bd53bec53ba078f13e09d4. It is recommended to upgrade the affected component. VDB-216958 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2018-25052", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-28T12:15:08.607", "lastModified": "2023-01-06T19:11:19.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in Catalyst-Plugin-Session up to 0.40 and classified as problematic. This vulnerability affects the function _load_sessionid of the file lib/Catalyst/Plugin/Session.pm of the component Session ID Handler. The manipulation of the argument sid leads to cross site scripting. The attack can be initiated remotely. Upgrading to version 0.41 is able to address this issue. The name of the patch is 88d1b599e1163761c9bd53bec53ba078f13e09d4. It is recommended to upgrade the affected component. VDB-216958 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:catalyst-plugin-session_project:catalyst-plugin-session:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.41", "matchCriteriaId": "B2E8D730-08F5-4D5C-8BD8-6E5520647EF1"}]}]}], "references": [{"url": "https://github.com/perl-catalyst/Catalyst-Plugin-Session/commit/88d1b599e1163761c9bd53bec53ba078f13e09d4", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/perl-catalyst/Catalyst-Plugin-Session/releases/tag/0.41", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216958", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216958", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/perl-catalyst/Catalyst-Plugin-Session/commit/88d1b599e1163761c9bd53bec53ba078f13e09d4"}}