{"buggy_code": ["menu \"Boot options\"\n\nmenu \"Boot images\"\n\nconfig ANDROID_BOOT_IMAGE\n\tbool \"Enable support for Android Boot Images\"\n\tdefault y if FASTBOOT\n\thelp\n\t  This enables support for booting images which use the Android\n\t  image format header.\n\nconfig FIT\n\tbool \"Support Flattened Image Tree\"\n\tselect MD5\n\tselect SHA1\n\thelp\n\t  This option allows you to boot the new uImage structure,\n\t  Flattened Image Tree.  FIT is formally a FDT, which can include\n\t  images of various types (kernel, FDT blob, ramdisk, etc.)\n\t  in a single blob.  To boot this new uImage structure,\n\t  pass the address of the blob to the \"bootm\" command.\n\t  FIT is very flexible, supporting compression, multiple images,\n\t  multiple configurations, verification through hashing and also\n\t  verified boot (secure boot using RSA).\n\nif FIT\n\nconfig FIT_EXTERNAL_OFFSET\n\thex \"FIT external data offset\"\n\tdefault 0x0\n\thelp\n\t  This specifies a data offset in fit image.\n\t  The offset is from data payload offset to the beginning of\n\t  fit image header. When specifies a offset, specific data\n\t  could be put in the hole between data payload and fit image\n\t  header, such as CSF data on i.MX platform.\n\nconfig FIT_ENABLE_SHA256_SUPPORT\n\tbool \"Support SHA256 checksum of FIT image contents\"\n\tdefault y\n\tselect SHA256\n\thelp\n\t  Enable this to support SHA256 checksum of FIT image contents. A\n\t  SHA256 checksum is a 256-bit (32-byte) hash value used to check that\n\t  the image contents have not been corrupted.\n\nconfig FIT_ENABLE_SHA384_SUPPORT\n\tbool \"Support SHA384 checksum of FIT image contents\"\n\tdefault n\n\tselect SHA384\n\thelp\n\t  Enable this to support SHA384 checksum of FIT image contents. A\n\t  SHA384 checksum is a 384-bit (48-byte) hash value used to check that\n\t  the image contents have not been corrupted. Use this for the highest\n\t  security.\n\nconfig FIT_ENABLE_SHA512_SUPPORT\n\tbool \"Support SHA512 checksum of FIT image contents\"\n\tdefault n\n\tselect SHA512\n\thelp\n\t  Enable this to support SHA512 checksum of FIT image contents. A\n\t  SHA512 checksum is a 512-bit (64-byte) hash value used to check that\n\t  the image contents have not been corrupted.\n\nconfig FIT_SIGNATURE\n\tbool \"Enable signature verification of FIT uImages\"\n\tdepends on DM\n\tselect HASH\n\tselect RSA\n\tselect RSA_VERIFY\n\tselect IMAGE_SIGN_INFO\n\thelp\n\t  This option enables signature verification of FIT uImages,\n\t  using a hash signed and verified using RSA. If\n\t  CONFIG_SHA_PROG_HW_ACCEL is defined, i.e support for progressive\n\t  hashing is available using hardware, then the RSA library will use\n\t  it. See doc/uImage.FIT/signature.txt for more details.\n\n\t  WARNING: When relying on signed FIT images with a required signature\n\t  check the legacy image format is disabled by default, so that\n\t  unsigned images cannot be loaded. If a board needs the legacy image\n\t  format support in this case, enable it using\n\t  CONFIG_LEGACY_IMAGE_FORMAT.\n\nconfig FIT_SIGNATURE_MAX_SIZE\n\thex \"Max size of signed FIT structures\"\n\tdepends on FIT_SIGNATURE\n\tdefault 0x10000000\n\thelp\n\t  This option sets a max size in bytes for verified FIT uImages.\n\t  A sane value of 256MB protects corrupted DTB structures from overlapping\n\t  device memory. Assure this size does not extend past expected storage\n\t  space.\n\nconfig FIT_ENABLE_RSASSA_PSS_SUPPORT\n\tbool \"Support rsassa-pss signature scheme of FIT image contents\"\n\tdepends on FIT_SIGNATURE\n\tdefault n\n\thelp\n\t  Enable this to support the pss padding algorithm as described\n\t  in the rfc8017 (https://tools.ietf.org/html/rfc8017).\n\nconfig FIT_CIPHER\n\tbool \"Enable ciphering data in a FIT uImages\"\n\tdepends on DM\n\tselect AES\n\thelp\n\t  Enable the feature of data ciphering/unciphering in the tool mkimage\n\t  and in the u-boot support of the FIT image.\n\nconfig FIT_VERBOSE\n\tbool \"Show verbose messages when FIT images fail\"\n\thelp\n\t  Generally a system will have valid FIT images so debug messages\n\t  are a waste of code space. If you are debugging your images then\n\t  you can enable this option to get more verbose information about\n\t  failures.\n\nconfig FIT_BEST_MATCH\n\tbool \"Select the best match for the kernel device tree\"\n\thelp\n\t  When no configuration is explicitly selected, default to the\n\t  one whose fdt's compatibility field best matches that of\n\t  U-Boot itself. A match is considered \"best\" if it matches the\n\t  most specific compatibility entry of U-Boot's fdt's root node.\n\t  The order of entries in the configuration's fdt is ignored.\n\nconfig FIT_IMAGE_POST_PROCESS\n\tbool \"Enable post-processing of FIT artifacts after loading by U-Boot\"\n\tdepends on TI_SECURE_DEVICE\n\thelp\n\t  Allows doing any sort of manipulation to blobs after they got extracted\n\t  from FIT images like stripping off headers or modifying the size of the\n\t  blob, verification, authentication, decryption etc. in a platform or\n\t  board specific way. In order to use this feature a platform or board-\n\t  specific implementation of board_fit_image_post_process() must be\n\t  provided. Also, anything done during this post-processing step would\n\t  need to be comprehended in how the images were prepared before being\n\t  injected into the FIT creation (i.e. the blobs would have been pre-\n\t  processed before being added to the FIT image).\n\nconfig FIT_PRINT\n        bool \"Support FIT printing\"\n        default y\n        help\n          Support printing the content of the fitImage in a verbose manner.\n\nif SPL\n\nconfig SPL_FIT\n\tbool \"Support Flattened Image Tree within SPL\"\n\tdepends on SPL\n\tselect SPL_OF_LIBFDT\n\nconfig SPL_FIT_PRINT\n\tbool \"Support FIT printing within SPL\"\n\tdepends on SPL_FIT\n\thelp\n\t  Support printing the content of the fitImage in a verbose manner in SPL.\n\nconfig SPL_FIT_SIGNATURE\n\tbool \"Enable signature verification of FIT firmware within SPL\"\n\tdepends on SPL_DM\n\tselect SPL_FIT\n\tselect SPL_CRYPTO_SUPPORT\n\tselect SPL_HASH_SUPPORT\n\tselect SPL_RSA\n\tselect SPL_RSA_VERIFY\n\tselect SPL_IMAGE_SIGN_INFO\n\nconfig SPL_LOAD_FIT\n\tbool \"Enable SPL loading U-Boot as a FIT (basic fitImage features)\"\n\tselect SPL_FIT\n\thelp\n\t  Normally with the SPL framework a legacy image is generated as part\n\t  of the build. This contains U-Boot along with information as to\n\t  where it should be loaded. This option instead enables generation\n\t  of a FIT (Flat Image Tree) which provides more flexibility. In\n\t  particular it can handle selecting from multiple device tree\n\t  and passing the correct one to U-Boot.\n\nconfig SPL_LOAD_FIT_ADDRESS\n\thex \"load address of fit image\"\n\tdepends on SPL_LOAD_FIT\n\tdefault 0x0\n\thelp\n\t  Specify the load address of the fit image that will be loaded\n\t  by SPL.\n\nconfig SPL_LOAD_FIT_APPLY_OVERLAY\n\tbool \"Enable SPL applying DT overlays from FIT\"\n\tdepends on SPL_LOAD_FIT\n\tselect OF_LIBFDT_OVERLAY\n\thelp\n\t  The device tree is loaded from the FIT image. Allow the SPL is to\n\t  also load device-tree overlays from the FIT image an apply them\n\t  over the device tree.\n\nconfig SPL_LOAD_FIT_APPLY_OVERLAY_BUF_SZ\n\tdepends on SPL_LOAD_FIT_APPLY_OVERLAY\n\tdefault 0x10000\n\thex \"size of temporary buffer used to load the overlays\"\n\thelp\n\t  The size of the area where the overlays will be loaded and\n\t  uncompress. Must be at least as large as biggest overlay\n\t  (uncompressed)\n\nconfig SPL_LOAD_FIT_FULL\n\tbool \"Enable SPL loading U-Boot as a FIT (full fitImage features)\"\n\tselect SPL_FIT\n\thelp\n\t  Normally with the SPL framework a legacy image is generated as part\n\t  of the build. This contains U-Boot along with information as to\n\t  where it should be loaded. This option instead enables generation\n\t  of a FIT (Flat Image Tree) which provides more flexibility. In\n\t  particular it can handle selecting from multiple device tree\n\t  and passing the correct one to U-Boot.\n\nconfig SPL_FIT_IMAGE_POST_PROCESS\n\tbool \"Enable post-processing of FIT artifacts after loading by the SPL\"\n\tdepends on SPL_LOAD_FIT\n\thelp\n\t  Allows doing any sort of manipulation to blobs after they got extracted\n\t  from the U-Boot FIT image like stripping off headers or modifying the\n\t  size of the blob, verification, authentication, decryption etc. in a\n\t  platform or board specific way. In order to use this feature a platform\n\t  or board-specific implementation of board_fit_image_post_process() must\n\t  be provided. Also, anything done during this post-processing step would\n\t  need to be comprehended in how the images were prepared before being\n\t  injected into the FIT creation (i.e. the blobs would have been pre-\n\t  processed before being added to the FIT image).\n\nconfig SPL_FIT_SOURCE\n\tstring \".its source file for U-Boot FIT image\"\n\tdepends on SPL_FIT\n\thelp\n\t  Specifies a (platform specific) FIT source file to generate the\n\t  U-Boot FIT image. This could specify further image to load and/or\n\t  execute.\n\nconfig USE_SPL_FIT_GENERATOR\n\tbool \"Use a script to generate the .its script\"\n\tdefault y if SPL_FIT && !ARCH_SUNXI\n\nconfig SPL_FIT_GENERATOR\n\tstring \".its file generator script for U-Boot FIT image\"\n\tdepends on USE_SPL_FIT_GENERATOR\n\tdefault \"arch/arm/mach-rockchip/make_fit_atf.py\" if SPL_LOAD_FIT && ARCH_ROCKCHIP\n\tdefault \"arch/arm/mach-zynqmp/mkimage_fit_atf.sh\" if SPL_LOAD_FIT && ARCH_ZYNQMP\n\tdefault \"arch/riscv/lib/mkimage_fit_opensbi.sh\" if SPL_LOAD_FIT && RISCV\n\thelp\n\t  Specifies a (platform specific) script file to generate the FIT\n\t  source file used to build the U-Boot FIT image file. This gets\n\t  passed a list of supported device tree file stub names to\n\t  include in the generated image.\n\nendif # SPL\n\nendif # FIT\n\nconfig LEGACY_IMAGE_FORMAT\n\tbool \"Enable support for the legacy image format\"\n\tdefault y if !FIT_SIGNATURE\n\thelp\n\t  This option enables the legacy image format. It is enabled by\n\t  default for backward compatibility, unless FIT_SIGNATURE is\n\t  set where it is disabled so that unsigned images cannot be\n\t  loaded. If a board needs the legacy image format support in this\n\t  case, enable it here.\n\nconfig SUPPORT_RAW_INITRD\n\tbool \"Enable raw initrd images\"\n\thelp\n\t  Note, defining the SUPPORT_RAW_INITRD allows user to supply\n\t  kernel with raw initrd images. The syntax is slightly different, the\n\t  address of the initrd must be augmented by it's size, in the following\n\t  format: \"<initrd address>:<initrd size>\".\n\nconfig OF_BOARD_SETUP\n\tbool \"Set up board-specific details in device tree before boot\"\n\tdepends on OF_LIBFDT\n\thelp\n\t  This causes U-Boot to call ft_board_setup() before booting into\n\t  the Operating System. This function can set up various\n\t  board-specific information in the device tree for use by the OS.\n\t  The device tree is then passed to the OS.\n\nconfig OF_SYSTEM_SETUP\n\tbool \"Set up system-specific details in device tree before boot\"\n\tdepends on OF_LIBFDT\n\thelp\n\t  This causes U-Boot to call ft_system_setup() before booting into\n\t  the Operating System. This function can set up various\n\t  system-specific information in the device tree for use by the OS.\n\t  The device tree is then passed to the OS.\n\nconfig OF_STDOUT_VIA_ALIAS\n\tbool \"Update the device-tree stdout alias from U-Boot\"\n\tdepends on OF_LIBFDT\n\thelp\n\t  This uses U-Boot's serial alias from the aliases node to update\n\t  the device tree passed to the OS. The \"linux,stdout-path\" property\n\t  in the chosen node is set to point to the correct serial node.\n\t  This option currently references CONFIG_CONS_INDEX, which is\n\t  incorrect when used with device tree as this option does not\n\t  exist / should not be used.\n\nconfig SYS_EXTRA_OPTIONS\n\tstring \"Extra Options (DEPRECATED)\"\n\thelp\n\t  The old configuration infrastructure (= mkconfig + boards.cfg)\n\t  provided the extra options field. If you have something like\n\t  \"HAS_BAR,BAZ=64\", the optional options\n\t    #define CONFIG_HAS\n\t    #define CONFIG_BAZ\t64\n\t  will be defined in include/config.h.\n\t  This option was prepared for the smooth migration from the old\n\t  configuration to Kconfig. Since this option will be removed sometime,\n\t  new boards should not use this option.\n\nconfig HAVE_SYS_TEXT_BASE\n\tbool\n\tdepends on !NIOS2 && !XTENSA\n\tdepends on !EFI_APP\n\tdefault y\n\nconfig SYS_TEXT_BASE\n\tdepends on HAVE_SYS_TEXT_BASE\n\tdefault 0x80800000 if ARCH_OMAP2PLUS || ARCH_K3\n\tdefault 0x4a000000 if ARCH_SUNXI && !MACH_SUN9I && !MACH_SUN8I_V3S\n\tdefault 0x2a000000 if ARCH_SUNXI && MACH_SUN9I\n\tdefault 0x42e00000 if ARCH_SUNXI && MACH_SUN8I_V3S\n\thex \"Text Base\"\n\thelp\n\t  The address in memory that U-Boot will be running from, initially.\n\nconfig SYS_CLK_FREQ\n\tdepends on ARC || ARCH_SUNXI || MPC83xx\n\tint \"CPU clock frequency\"\n\thelp\n\t  TODO: Move CONFIG_SYS_CLK_FREQ for all the architecture\n\nconfig ARCH_FIXUP_FDT_MEMORY\n\tbool \"Enable arch_fixup_memory_banks() call\"\n\tdefault y\n\thelp\n\t  Enable FDT memory map syncup before OS boot. This feature can be\n\t  used for booting OS with different memory setup where the part of\n\t  the memory location should be used for different purpose.\n\nconfig CHROMEOS\n\tbool \"Support booting Chrome OS\"\n\thelp\n\t  Chrome OS requires U-Boot to set up a table indicating the boot mode\n\t  (e.g. Developer mode) and a few other things. Enable this if you are\n\t  booting on a Chromebook to avoid getting an error about an invalid\n\t  firmware ID.\n\nconfig CHROMEOS_VBOOT\n\tbool \"Support Chrome OS verified boot\"\n\thelp\n\t  This is intended to enable the full Chrome OS verified boot support\n\t  in U-Boot. It is not actually implemented in the U-Boot source code\n\t  at present, so this option is always set to 'n'. It allows\n\t  distinguishing between booting Chrome OS in a basic way (developer\n\t  mode) and a full boot.\n\nendmenu\t\t# Boot images\n\nmenu \"Boot timing\"\n\nconfig BOOTSTAGE\n\tbool \"Boot timing and reporting\"\n\thelp\n\t  Enable recording of boot time while booting. To use it, insert\n\t  calls to bootstage_mark() with a suitable BOOTSTAGE_ID from\n\t  bootstage.h. Only a single entry is recorded for each ID. You can\n\t  give the entry a name with bootstage_mark_name(). You can also\n\t  record elapsed time in a particular stage using bootstage_start()\n\t  before starting and bootstage_accum() when finished. Bootstage will\n\t  add up all the accumulated time and report it.\n\n\t  Normally, IDs are defined in bootstage.h but a small number of\n\t  additional 'user' IDs can be used by passing BOOTSTAGE_ID_ALLOC\n\t  as the ID.\n\n\t  Calls to show_boot_progress() will also result in log entries but\n\t  these will not have names.\n\nconfig SPL_BOOTSTAGE\n\tbool \"Boot timing and reported in SPL\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Enable recording of boot time in SPL. To make this visible to U-Boot\n\t  proper, enable BOOTSTAGE_STASH as well. This will stash the timing\n\t  information when SPL finishes and load it when U-Boot proper starts\n\t  up.\n\nconfig TPL_BOOTSTAGE\n\tbool \"Boot timing and reported in TPL\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Enable recording of boot time in SPL. To make this visible to U-Boot\n\t  proper, enable BOOTSTAGE_STASH as well. This will stash the timing\n\t  information when TPL finishes and load it when U-Boot proper starts\n\t  up.\n\nconfig BOOTSTAGE_REPORT\n\tbool \"Display a detailed boot timing report before booting the OS\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Enable output of a boot time report just before the OS is booted.\n\t  This shows how long it took U-Boot to go through each stage of the\n\t  boot process. The report looks something like this:\n\n\t\tTimer summary in microseconds:\n\t\t       Mark    Elapsed  Stage\n\t\t\t  0          0  reset\n\t\t  3,575,678  3,575,678  board_init_f start\n\t\t  3,575,695         17  arch_cpu_init A9\n\t\t  3,575,777         82  arch_cpu_init done\n\t\t  3,659,598     83,821  board_init_r start\n\t\t  3,910,375    250,777  main_loop\n\t\t 29,916,167 26,005,792  bootm_start\n\t\t 30,361,327    445,160  start_kernel\n\nconfig BOOTSTAGE_RECORD_COUNT\n\tint \"Number of boot stage records to store\"\n\tdefault 30\n\thelp\n\t  This is the size of the bootstage record list and is the maximum\n\t  number of bootstage records that can be recorded.\n\nconfig SPL_BOOTSTAGE_RECORD_COUNT\n\tint \"Number of boot stage records to store for SPL\"\n\tdefault 5\n\thelp\n\t  This is the size of the bootstage record list and is the maximum\n\t  number of bootstage records that can be recorded.\n\nconfig TPL_BOOTSTAGE_RECORD_COUNT\n\tint \"Number of boot stage records to store for TPL\"\n\tdefault 5\n\thelp\n\t  This is the size of the bootstage record list and is the maximum\n\t  number of bootstage records that can be recorded.\n\nconfig BOOTSTAGE_FDT\n\tbool \"Store boot timing information in the OS device tree\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Stash the bootstage information in the FDT. A root 'bootstage'\n\t  node is created with each bootstage id as a child. Each child\n\t  has a 'name' property and either 'mark' containing the\n\t  mark time in microseconds, or 'accum' containing the\n\t  accumulated time for that bootstage id in microseconds.\n\t  For example:\n\n\t\tbootstage {\n\t\t\t154 {\n\t\t\t\tname = \"board_init_f\";\n\t\t\t\tmark = <3575678>;\n\t\t\t};\n\t\t\t170 {\n\t\t\t\tname = \"lcd\";\n\t\t\t\taccum = <33482>;\n\t\t\t};\n\t\t};\n\n\t  Code in the Linux kernel can find this in /proc/devicetree.\n\nconfig BOOTSTAGE_STASH\n\tbool \"Stash the boot timing information in memory before booting OS\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Some OSes do not support device tree. Bootstage can instead write\n\t  the boot timing information in a binary format at a given address.\n\t  This happens through a call to bootstage_stash(), typically in\n\t  the CPU's cleanup_before_linux() function. You can use the\n\t  'bootstage stash' and 'bootstage unstash' commands to do this on\n\t  the command line.\n\nconfig BOOTSTAGE_STASH_ADDR\n\thex \"Address to stash boot timing information\"\n\tdefault 0\n\thelp\n\t  Provide an address which will not be overwritten by the OS when it\n\t  starts, so that it can read this information when ready.\n\nconfig BOOTSTAGE_STASH_SIZE\n\thex \"Size of boot timing stash region\"\n\tdefault 0x1000\n\thelp\n\t  This should be large enough to hold the bootstage stash. A value of\n\t  4096 (4KiB) is normally plenty.\n\nconfig SHOW_BOOT_PROGRESS\n\tbool \"Show boot progress in a board-specific manner\"\n\thelp\n\t  Defining this option allows to add some board-specific code (calling\n\t  a user-provided function show_boot_progress(int) that enables you to\n\t  show the system's boot progress on some display (for example, some\n\t  LEDs) on your board. At the moment, the following checkpoints are\n\t  implemented:\n\n\t  Legacy uImage format:\n\n\t  Arg\tWhere\t\t\tWhen\n\t    1\tcommon/cmd_bootm.c\tbefore attempting to boot an image\n\t   -1\tcommon/cmd_bootm.c\tImage header has bad\t magic number\n\t    2\tcommon/cmd_bootm.c\tImage header has correct magic number\n\t   -2\tcommon/cmd_bootm.c\tImage header has bad\t checksum\n\t    3\tcommon/cmd_bootm.c\tImage header has correct checksum\n\t   -3\tcommon/cmd_bootm.c\tImage data   has bad\t checksum\n\t    4\tcommon/cmd_bootm.c\tImage data   has correct checksum\n\t   -4\tcommon/cmd_bootm.c\tImage is for unsupported architecture\n\t    5\tcommon/cmd_bootm.c\tArchitecture check OK\n\t   -5\tcommon/cmd_bootm.c\tWrong Image Type (not kernel, multi)\n\t    6\tcommon/cmd_bootm.c\tImage Type check OK\n\t   -6\tcommon/cmd_bootm.c\tgunzip uncompression error\n\t   -7\tcommon/cmd_bootm.c\tUnimplemented compression type\n\t    7\tcommon/cmd_bootm.c\tUncompression OK\n\t    8\tcommon/cmd_bootm.c\tNo uncompress/copy overwrite error\n\t   -9\tcommon/cmd_bootm.c\tUnsupported OS (not Linux, BSD, VxWorks, QNX)\n\n\t    9\tcommon/image.c\t\tStart initial ramdisk verification\n\t  -10\tcommon/image.c\t\tRamdisk header has bad\t   magic number\n\t  -11\tcommon/image.c\t\tRamdisk header has bad\t   checksum\n\t   10\tcommon/image.c\t\tRamdisk header is OK\n\t  -12\tcommon/image.c\t\tRamdisk data   has bad\t   checksum\n\t   11\tcommon/image.c\t\tRamdisk data   has correct checksum\n\t   12\tcommon/image.c\t\tRamdisk verification complete, start loading\n\t  -13\tcommon/image.c\t\tWrong Image Type (not PPC Linux ramdisk)\n\t   13\tcommon/image.c\t\tStart multifile image verification\n\t   14\tcommon/image.c\t\tNo initial ramdisk, no multifile, continue.\n\n\t   15\tarch/<arch>/lib/bootm.c All preparation done, transferring control to OS\n\n\t  -30\tarch/powerpc/lib/board.c\tFatal error, hang the system\n\t  -31\tpost/post.c\t\tPOST test failed, detected by post_output_backlog()\n\t  -32\tpost/post.c\t\tPOST test failed, detected by post_run_single()\n\n\t   34\tcommon/cmd_doc.c\tbefore loading a Image from a DOC device\n\t  -35\tcommon/cmd_doc.c\tBad usage of \"doc\" command\n\t   35\tcommon/cmd_doc.c\tcorrect usage of \"doc\" command\n\t  -36\tcommon/cmd_doc.c\tNo boot device\n\t   36\tcommon/cmd_doc.c\tcorrect boot device\n\t  -37\tcommon/cmd_doc.c\tUnknown Chip ID on boot device\n\t   37\tcommon/cmd_doc.c\tcorrect chip ID found, device available\n\t  -38\tcommon/cmd_doc.c\tRead Error on boot device\n\t   38\tcommon/cmd_doc.c\treading Image header from DOC device OK\n\t  -39\tcommon/cmd_doc.c\tImage header has bad magic number\n\t   39\tcommon/cmd_doc.c\tImage header has correct magic number\n\t  -40\tcommon/cmd_doc.c\tError reading Image from DOC device\n\t   40\tcommon/cmd_doc.c\tImage header has correct magic number\n\t   41\tcommon/cmd_ide.c\tbefore loading a Image from a IDE device\n\t  -42\tcommon/cmd_ide.c\tBad usage of \"ide\" command\n\t   42\tcommon/cmd_ide.c\tcorrect usage of \"ide\" command\n\t  -43\tcommon/cmd_ide.c\tNo boot device\n\t   43\tcommon/cmd_ide.c\tboot device found\n\t  -44\tcommon/cmd_ide.c\tDevice not available\n\t   44\tcommon/cmd_ide.c\tDevice available\n\t  -45\tcommon/cmd_ide.c\twrong partition selected\n\t   45\tcommon/cmd_ide.c\tpartition selected\n\t  -46\tcommon/cmd_ide.c\tUnknown partition table\n\t   46\tcommon/cmd_ide.c\tvalid partition table found\n\t  -47\tcommon/cmd_ide.c\tInvalid partition type\n\t   47\tcommon/cmd_ide.c\tcorrect partition type\n\t  -48\tcommon/cmd_ide.c\tError reading Image Header on boot device\n\t   48\tcommon/cmd_ide.c\treading Image Header from IDE device OK\n\t  -49\tcommon/cmd_ide.c\tImage header has bad magic number\n\t   49\tcommon/cmd_ide.c\tImage header has correct magic number\n\t  -50\tcommon/cmd_ide.c\tImage header has bad\t checksum\n\t   50\tcommon/cmd_ide.c\tImage header has correct checksum\n\t  -51\tcommon/cmd_ide.c\tError reading Image from IDE device\n\t   51\tcommon/cmd_ide.c\treading Image from IDE device OK\n\t   52\tcommon/cmd_nand.c\tbefore loading a Image from a NAND device\n\t  -53\tcommon/cmd_nand.c\tBad usage of \"nand\" command\n\t   53\tcommon/cmd_nand.c\tcorrect usage of \"nand\" command\n\t  -54\tcommon/cmd_nand.c\tNo boot device\n\t   54\tcommon/cmd_nand.c\tboot device found\n\t  -55\tcommon/cmd_nand.c\tUnknown Chip ID on boot device\n\t   55\tcommon/cmd_nand.c\tcorrect chip ID found, device available\n\t  -56\tcommon/cmd_nand.c\tError reading Image Header on boot device\n\t   56\tcommon/cmd_nand.c\treading Image Header from NAND device OK\n\t  -57\tcommon/cmd_nand.c\tImage header has bad magic number\n\t   57\tcommon/cmd_nand.c\tImage header has correct magic number\n\t  -58\tcommon/cmd_nand.c\tError reading Image from NAND device\n\t   58\tcommon/cmd_nand.c\treading Image from NAND device OK\n\n\t  -60\tcommon/env_common.c\tEnvironment has a bad CRC, using default\n\n\t   64\tnet/eth.c\t\tstarting with Ethernet configuration.\n\t  -64\tnet/eth.c\t\tno Ethernet found.\n\t   65\tnet/eth.c\t\tEthernet found.\n\n\t  -80\tcommon/cmd_net.c\tusage wrong\n\t   80\tcommon/cmd_net.c\tbefore calling net_loop()\n\t  -81\tcommon/cmd_net.c\tsome error in net_loop() occurred\n\t   81\tcommon/cmd_net.c\tnet_loop() back without error\n\t  -82\tcommon/cmd_net.c\tsize == 0 (File with size 0 loaded)\n\t   82\tcommon/cmd_net.c\ttrying automatic boot\n\t   83\tcommon/cmd_net.c\trunning \"source\" command\n\t  -83\tcommon/cmd_net.c\tsome error in automatic boot or \"source\" command\n\t   84\tcommon/cmd_net.c\tend without errors\n\n\t  FIT uImage format:\n\n\t  Arg\tWhere\t\t\tWhen\n\t  100\tcommon/cmd_bootm.c\tKernel FIT Image has correct format\n\t  -100\tcommon/cmd_bootm.c\tKernel FIT Image has incorrect format\n\t  101\tcommon/cmd_bootm.c\tNo Kernel subimage unit name, using configuration\n\t  -101\tcommon/cmd_bootm.c\tCan't get configuration for kernel subimage\n\t  102\tcommon/cmd_bootm.c\tKernel unit name specified\n\t  -103\tcommon/cmd_bootm.c\tCan't get kernel subimage node offset\n\t  103\tcommon/cmd_bootm.c\tFound configuration node\n\t  104\tcommon/cmd_bootm.c\tGot kernel subimage node offset\n\t  -104\tcommon/cmd_bootm.c\tKernel subimage hash verification failed\n\t  105\tcommon/cmd_bootm.c\tKernel subimage hash verification OK\n\t  -105\tcommon/cmd_bootm.c\tKernel subimage is for unsupported architecture\n\t  106\tcommon/cmd_bootm.c\tArchitecture check OK\n\t  -106\tcommon/cmd_bootm.c\tKernel subimage has wrong type\n\t  107\tcommon/cmd_bootm.c\tKernel subimage type OK\n\t  -107\tcommon/cmd_bootm.c\tCan't get kernel subimage data/size\n\t  108\tcommon/cmd_bootm.c\tGot kernel subimage data/size\n\t  -108\tcommon/cmd_bootm.c\tWrong image type (not legacy, FIT)\n\t  -109\tcommon/cmd_bootm.c\tCan't get kernel subimage type\n\t  -110\tcommon/cmd_bootm.c\tCan't get kernel subimage comp\n\t  -111\tcommon/cmd_bootm.c\tCan't get kernel subimage os\n\t  -112\tcommon/cmd_bootm.c\tCan't get kernel subimage load address\n\t  -113\tcommon/cmd_bootm.c\tImage uncompress/copy overwrite error\n\n\t  120\tcommon/image.c\t\tStart initial ramdisk verification\n\t  -120\tcommon/image.c\t\tRamdisk FIT image has incorrect format\n\t  121\tcommon/image.c\t\tRamdisk FIT image has correct format\n\t  122\tcommon/image.c\t\tNo ramdisk subimage unit name, using configuration\n\t  -122\tcommon/image.c\t\tCan't get configuration for ramdisk subimage\n\t  123\tcommon/image.c\t\tRamdisk unit name specified\n\t  -124\tcommon/image.c\t\tCan't get ramdisk subimage node offset\n\t  125\tcommon/image.c\t\tGot ramdisk subimage node offset\n\t  -125\tcommon/image.c\t\tRamdisk subimage hash verification failed\n\t  126\tcommon/image.c\t\tRamdisk subimage hash verification OK\n\t  -126\tcommon/image.c\t\tRamdisk subimage for unsupported architecture\n\t  127\tcommon/image.c\t\tArchitecture check OK\n\t  -127\tcommon/image.c\t\tCan't get ramdisk subimage data/size\n\t  128\tcommon/image.c\t\tGot ramdisk subimage data/size\n\t  129\tcommon/image.c\t\tCan't get ramdisk load address\n\t  -129\tcommon/image.c\t\tGot ramdisk load address\n\n\t  -130\tcommon/cmd_doc.c\tIncorrect FIT image format\n\t  131\tcommon/cmd_doc.c\tFIT image format OK\n\n\t  -140\tcommon/cmd_ide.c\tIncorrect FIT image format\n\t  141\tcommon/cmd_ide.c\tFIT image format OK\n\n\t  -150\tcommon/cmd_nand.c\tIncorrect FIT image format\n\t  151\tcommon/cmd_nand.c\tFIT image format OK\n\nendmenu\n\nmenu \"Boot media\"\n\nconfig NOR_BOOT\n\tbool \"Support for booting from NOR flash\"\n\tdepends on NOR\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via NOR.  In this case we will enable certain pinmux early\n\t  as the ROM only partially sets up pinmux.  We also default to using\n\t  NOR for environment.\n\nconfig NAND_BOOT\n\tbool \"Support for booting from NAND flash\"\n\tdefault n\n\timply MTD_RAW_NAND\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via NAND flash. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig ONENAND_BOOT\n\tbool \"Support for booting from ONENAND\"\n\tdefault n\n\timply MTD_RAW_NAND\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via ONENAND. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig QSPI_BOOT\n\tbool \"Support for booting from QSPI flash\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via QSPI flash. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig SATA_BOOT\n\tbool \"Support for booting from SATA\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via SATA. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig SD_BOOT\n\tbool \"Support for booting from SD/EMMC\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via SD/EMMC. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig SPI_BOOT\n\tbool \"Support for booting from SPI flash\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via SPI flash. This is not a must, some SoCs need this,\n\t  some not.\n\nendmenu\n\nmenu \"Autoboot options\"\n\nconfig AUTOBOOT\n\tbool \"Autoboot\"\n\tdefault y\n\thelp\n\t  This enables the autoboot.  See doc/README.autoboot for detail.\n\nconfig BOOTDELAY\n\tint \"delay in seconds before automatically booting\"\n\tdefault 2\n\tdepends on AUTOBOOT\n\thelp\n\t  Delay before automatically running bootcmd;\n\t  set to 0 to autoboot with no delay, but you can stop it by key input.\n\t  set to -1 to disable autoboot.\n\t  set to -2 to autoboot with no delay and not check for abort\n\n\t  If this value is >= 0 then it is also used for the default delay\n\t  before starting the default entry in bootmenu. If it is < 0 then\n\t  a default value of 10s is used.\n\n\t  See doc/README.autoboot for details.\n\nconfig AUTOBOOT_KEYED\n\tbool \"Stop autobooting via specific input key / string\"\n\tdefault n\n\thelp\n\t  This option enables stopping (aborting) of the automatic\n\t  boot feature only by issuing a specific input key or\n\t  string. If not enabled, any input key will abort the\n\t  U-Boot automatic booting process and bring the device\n\t  to the U-Boot prompt for user input.\n\nconfig AUTOBOOT_PROMPT\n\tstring \"Autoboot stop prompt\"\n\tdepends on AUTOBOOT_KEYED\n\tdefault \"Autoboot in %d seconds\\\\n\"\n\thelp\n\t  This string is displayed before the boot delay selected by\n\t  CONFIG_BOOTDELAY starts. If it is not defined\tthere is no\n\t  output indicating that autoboot is in progress.\n\n\t  Note that this define is used as the (only) argument to a\n\t  printf() call, so it may contain '%' format specifications,\n\t  provided that it also includes, sepearated by commas exactly\n\t  like in a printf statement, the required arguments. It is\n\t  the responsibility of the user to select only such arguments\n\t  that are valid in the given context.\n\nconfig AUTOBOOT_ENCRYPTION\n\tbool \"Enable encryption in autoboot stopping\"\n\tdepends on AUTOBOOT_KEYED\n\thelp\n\t  This option allows a string to be entered into U-Boot to stop the\n\t  autoboot. The string itself is hashed and compared against the hash\n\t  in the environment variable 'bootstopkeysha256'. If it matches then\n\t  boot stops and a command-line prompt is presented.\n\n\t  This provides a way to ship a secure production device which can also\n\t  be accessed at the U-Boot command line.\n\nconfig AUTOBOOT_DELAY_STR\n\tstring \"Delay autobooting via specific input key / string\"\n\tdepends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION\n\thelp\n\t  This option delays the automatic boot feature by issuing\n\t  a specific input key or string. If CONFIG_AUTOBOOT_DELAY_STR\n\t  or the environment variable \"bootdelaykey\" is specified\n\t  and this string is received from console input before\n\t  autoboot starts booting, U-Boot gives a command prompt. The\n\t  U-Boot prompt will time out if CONFIG_BOOT_RETRY_TIME is\n\t  used, otherwise it never times out.\n\nconfig AUTOBOOT_STOP_STR\n\tstring \"Stop autobooting via specific input key / string\"\n\tdepends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION\n\thelp\n\t  This option enables stopping (aborting) of the automatic\n\t  boot feature only by issuing a specific input key or\n\t  string. If CONFIG_AUTOBOOT_STOP_STR or the environment\n\t  variable \"bootstopkey\" is specified and this string is\n\t  received from console input before autoboot starts booting,\n\t  U-Boot gives a command prompt. The U-Boot prompt never\n\t  times out, even if CONFIG_BOOT_RETRY_TIME is used.\n\nconfig AUTOBOOT_KEYED_CTRLC\n\tbool \"Enable Ctrl-C autoboot interruption\"\n\tdepends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION\n\tdefault n\n\thelp\n\t  This option allows for the boot sequence to be interrupted\n\t  by ctrl-c, in addition to the \"bootdelaykey\" and \"bootstopkey\".\n\t  Setting this variable\tprovides an escape sequence from the\n\t  limited \"password\" strings.\n\nconfig AUTOBOOT_STOP_STR_SHA256\n\tstring \"Stop autobooting via SHA256 encrypted password\"\n\tdepends on AUTOBOOT_KEYED && AUTOBOOT_ENCRYPTION\n\thelp\n\t  This option adds the feature to only stop the autobooting,\n\t  and therefore boot into the U-Boot prompt, when the input\n\t  string / password matches a values that is encypted via\n\t  a SHA256 hash and saved in the environment variable\n\t  \"bootstopkeysha256\". If the value in that variable\n\t  includes a \":\", the portion prior to the \":\" will be treated\n\t  as a salt value.\n\nconfig AUTOBOOT_USE_MENUKEY\n\tbool \"Allow a specify key to run a menu from the environment\"\n\tdepends on !AUTOBOOT_KEYED\n\thelp\n\t  If a specific key is pressed to stop autoboot, then the commands in\n\t  the environment variable 'menucmd' are executed before boot starts.\n\nconfig AUTOBOOT_MENUKEY\n\tint \"ASCII value of boot key to show a menu\"\n\tdefault 0\n\tdepends on AUTOBOOT_USE_MENUKEY\n\thelp\n\t  If this key is pressed to stop autoboot, then the commands in the\n\t  environment variable 'menucmd' will be executed before boot starts.\n\t  For example, 33 means \"!\" in ASCII, so pressing ! at boot would take\n\t  this action.\n\nconfig AUTOBOOT_MENU_SHOW\n\tbool \"Show a menu on boot\"\n\tdepends on CMD_BOOTMENU\n\thelp\n\t  This enables the boot menu, controlled by environment variables\n\t  defined by the board. The menu starts after running the 'preboot'\n\t  environmnent variable (if enabled) and before handling the boot delay.\n\t  See README.bootmenu for more details.\n\nendmenu\n\nconfig USE_BOOTARGS\n\tbool \"Enable boot arguments\"\n\thelp\n\t  Provide boot arguments to bootm command. Boot arguments are specified\n\t  in CONFIG_BOOTARGS option. Enable this option to be able to specify\n\t  CONFIG_BOOTARGS string. If this option is disabled, CONFIG_BOOTARGS\n\t  will be undefined and won't take any space in U-Boot image.\n\nconfig BOOTARGS\n\tstring \"Boot arguments\"\n\tdepends on USE_BOOTARGS && !USE_DEFAULT_ENV_FILE\n\thelp\n\t  This can be used to pass arguments to the bootm command. The value of\n\t  CONFIG_BOOTARGS goes into the environment value \"bootargs\". Note that\n\t  this value will also override the \"chosen\" node in FDT blob.\n\nconfig BOOTARGS_SUBST\n\tbool \"Support substituting strings in boot arguments\"\n\thelp\n\t  This allows substituting string values in the boot arguments. These\n\t  are applied after the commandline has been built.\n\n\t  One use for this is to insert the root-disk UUID into the command\n\t  line where bootargs contains \"root=${uuid}\"\n\n\t\tsetenv bootargs \"console= root=${uuid}\"\n\t\t# Set the 'uuid' environment variable\n\t\tpart uuid mmc 2:2 uuid\n\n\t\t# Command-line substitution will put the real uuid into the\n\t\t# kernel command line\n\t\tbootm\n\nconfig USE_BOOTCOMMAND\n\tbool \"Enable a default value for bootcmd\"\n\thelp\n\t  Provide a default value for the bootcmd entry in the environment.  If\n\t  autoboot is enabled this is what will be run automatically.  Enable\n\t  this option to be able to specify CONFIG_BOOTCOMMAND as a string.  If\n\t  this option is disabled, CONFIG_BOOTCOMMAND will be undefined and\n\t  won't take any space in U-Boot image.\n\nconfig BOOTCOMMAND\n\tstring \"bootcmd value\"\n\tdepends on USE_BOOTCOMMAND && !USE_DEFAULT_ENV_FILE\n\tdefault \"run distro_bootcmd\" if DISTRO_DEFAULTS\n\thelp\n\t  This is the string of commands that will be used as bootcmd and if\n\t  AUTOBOOT is set, automatically run.\n\nconfig USE_PREBOOT\n\tbool \"Enable preboot\"\n\thelp\n\t  When this option is enabled, the existence of the environment\n\t  variable \"preboot\" will be checked immediately before starting the\n\t  CONFIG_BOOTDELAY countdown and/or running the auto-boot command resp.\n\t  entering interactive mode.\n\n\t  This feature is especially useful when \"preboot\" is automatically\n\t  generated or modified. For example, the boot code can modify the\n\t  \"preboot\" when a user holds down a certain combination of keys.\n\nconfig PREBOOT\n\tstring \"preboot default value\"\n\tdepends on USE_PREBOOT && !USE_DEFAULT_ENV_FILE\n\tdefault \"usb start\" if USB_KEYBOARD\n\tdefault \"\"\n\thelp\n\t  This is the default of \"preboot\" environment variable.\n\nconfig DEFAULT_FDT_FILE\n\tstring \"Default fdt file\"\n\thelp\n\t  This option is used to set the default fdt file to boot OS.\n\nendmenu\t\t# Booting\n", "// SPDX-License-Identifier: GPL-2.0+\n/*\n * Copyright (c) 2013, Google Inc.\n *\n * (C) Copyright 2008 Semihalf\n *\n * (C) Copyright 2000-2006\n * Wolfgang Denk, DENX Software Engineering, wd@denx.de.\n */\n\n#define LOG_CATEGORY LOGC_BOOT\n\n#ifdef USE_HOSTCC\n#include \"mkimage.h\"\n#include <time.h>\n#include <linux/libfdt.h>\n#include <u-boot/crc.h>\n#else\n#include <linux/compiler.h>\n#include <common.h>\n#include <errno.h>\n#include <log.h>\n#include <mapmem.h>\n#include <asm/io.h>\n#include <malloc.h>\n#include <asm/global_data.h>\nDECLARE_GLOBAL_DATA_PTR;\n#endif /* !USE_HOSTCC*/\n\n#include <bootm.h>\n#include <image.h>\n#include <bootstage.h>\n#include <linux/kconfig.h>\n#include <u-boot/crc.h>\n#include <u-boot/md5.h>\n#include <u-boot/sha1.h>\n#include <u-boot/sha256.h>\n#include <u-boot/sha512.h>\n\n/*****************************************************************************/\n/* New uImage format routines */\n/*****************************************************************************/\n#ifndef USE_HOSTCC\nstatic int fit_parse_spec(const char *spec, char sepc, ulong addr_curr,\n\t\tulong *addr, const char **name)\n{\n\tconst char *sep;\n\n\t*addr = addr_curr;\n\t*name = NULL;\n\n\tsep = strchr(spec, sepc);\n\tif (sep) {\n\t\tif (sep - spec > 0)\n\t\t\t*addr = simple_strtoul(spec, NULL, 16);\n\n\t\t*name = sep + 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_parse_conf - parse FIT configuration spec\n * @spec: input string, containing configuration spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * configuration\n * @conf_name double pointer to a char, will hold pointer to a configuration\n * unit name\n *\n * fit_parse_conf() expects configuration spec in the form of [<addr>]#<conf>,\n * where <addr> is a FIT image address that contains configuration\n * with a <conf> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid configuration string,\n *     addr and conf_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_conf(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **conf_name)\n{\n\treturn fit_parse_spec(spec, '#', addr_curr, addr, conf_name);\n}\n\n/**\n * fit_parse_subimage - parse FIT subimage spec\n * @spec: input string, containing subimage spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * subimage\n * @image_name: double pointer to a char, will hold pointer to a subimage name\n *\n * fit_parse_subimage() expects subimage spec in the form of\n * [<addr>]:<subimage>, where <addr> is a FIT image address that contains\n * subimage with a <subimg> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid subimage string,\n *     addr and image_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_subimage(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **image_name)\n{\n\treturn fit_parse_spec(spec, ':', addr_curr, addr, image_name);\n}\n#endif /* !USE_HOSTCC */\n\n#ifdef USE_HOSTCC\n/* Host tools use these implementations for Cipher and Signature support */\nstatic void *host_blob;\n\nvoid image_set_host_blob(void *blob)\n{\n\thost_blob = blob;\n}\n\nvoid *image_get_host_blob(void)\n{\n\treturn host_blob;\n}\n#endif /* USE_HOSTCC */\n\nstatic void fit_get_debug(const void *fit, int noffset,\n\t\tchar *prop_name, int err)\n{\n\tdebug(\"Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)\\n\",\n\t      prop_name, (ulong)fit, noffset, fit_get_name(fit, noffset, NULL),\n\t      fdt_strerror(err));\n}\n\n/**\n * fit_get_subimage_count - get component (sub-image) count\n * @fit: pointer to the FIT format image header\n * @images_noffset: offset of images node\n *\n * returns:\n *     number of image components\n */\nint fit_get_subimage_count(const void *fit, int images_noffset)\n{\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n#if CONFIG_IS_ENABLED(FIT_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT)\n/**\n * fit_image_print_data() - prints out the hash node details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash node\n * @p: pointer to prefix string\n * @type: Type of information to print (\"hash\" or \"sign\")\n *\n * fit_image_print_data() lists properties for the processed hash node\n *\n * This function avoid using puts() since it prints a newline on the host\n * but does not in U-Boot.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_data(const void *fit, int noffset, const char *p,\n\t\t\t\t const char *type)\n{\n\tconst char *keyname;\n\tuint8_t *value;\n\tint value_len;\n\tchar *algo;\n\tconst char *padding;\n\tbool required;\n\tint ret, i;\n\n\tdebug(\"%s  %s node:    '%s'\\n\", p, type,\n\t      fit_get_name(fit, noffset, NULL));\n\tprintf(\"%s  %s algo:    \", p, type);\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\tprintf(\"invalid/unsupported\\n\");\n\t\treturn;\n\t}\n\tprintf(\"%s\", algo);\n\tkeyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);\n\trequired = fdt_getprop(fit, noffset, FIT_KEY_REQUIRED, NULL) != NULL;\n\tif (keyname)\n\t\tprintf(\":%s\", keyname);\n\tif (required)\n\t\tprintf(\" (required)\");\n\tprintf(\"\\n\");\n\n\tpadding = fdt_getprop(fit, noffset, \"padding\", NULL);\n\tif (padding)\n\t\tprintf(\"%s  %s padding: %s\\n\", p, type, padding);\n\n\tret = fit_image_hash_get_value(fit, noffset, &value,\n\t\t\t\t       &value_len);\n\tprintf(\"%s  %s value:   \", p, type);\n\tif (ret) {\n\t\tprintf(\"unavailable\\n\");\n\t} else {\n\t\tfor (i = 0; i < value_len; i++)\n\t\t\tprintf(\"%02x\", value[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tdebug(\"%s  %s len:     %d\\n\", p, type, value_len);\n\n\t/* Signatures have a time stamp */\n\tif (IMAGE_ENABLE_TIMESTAMP && keyname) {\n\t\ttime_t timestamp;\n\n\t\tprintf(\"%s  Timestamp:    \", p);\n\t\tif (fit_get_timestamp(fit, noffset, &timestamp))\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n}\n\n/**\n * fit_image_print_verification_data() - prints out the hash/signature details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash or signature node\n * @p: pointer to prefix string\n *\n * This lists properties for the processed hash node\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_verification_data(const void *fit, int noffset,\n\t\t\t\t\t      const char *p)\n{\n\tconst char *name;\n\n\t/*\n\t * Check subnode name, must be equal to \"hash\" or \"signature\".\n\t * Multiple hash/signature nodes require unique unit node\n\t * names, e.g. hash-1, hash-2, signature-1, signature-2, etc.\n\t */\n\tname = fit_get_name(fit, noffset, NULL);\n\tif (!strncmp(name, FIT_HASH_NODENAME, strlen(FIT_HASH_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Hash\");\n\t} else if (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Sign\");\n\t}\n}\n\n/**\n * fit_conf_print - prints out the FIT configuration details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the configuration node\n * @p: pointer to prefix string\n *\n * fit_conf_print() lists all mandatory properties for the processed\n * configuration node.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_conf_print(const void *fit, int noffset, const char *p)\n{\n\tchar *desc;\n\tconst char *uname;\n\tint ret;\n\tint fdt_index, loadables_index;\n\tint ndepth;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tuname = fdt_getprop(fit, noffset, FIT_KERNEL_PROP, NULL);\n\tprintf(\"%s  Kernel:       \", p);\n\tif (!uname)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", uname);\n\n\t/* Optional properties */\n\tuname = fdt_getprop(fit, noffset, FIT_RAMDISK_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Init Ramdisk: %s\\n\", p, uname);\n\n\tuname = fdt_getprop(fit, noffset, FIT_FIRMWARE_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Firmware:     %s\\n\", p, uname);\n\n\tfor (fdt_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_FDT_PROP,\n\t\t\t\t\tfdt_index, NULL), uname;\n\t     fdt_index++) {\n\t\tif (fdt_index == 0)\n\t\t\tprintf(\"%s  FDT:          \", p);\n\t\telse\n\t\t\tprintf(\"%s                \", p);\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\tuname = fdt_getprop(fit, noffset, FIT_FPGA_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  FPGA:         %s\\n\", p, uname);\n\n\t/* Print out all of the specified loadables */\n\tfor (loadables_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_LOADABLE_PROP,\n\t\t\t\t\tloadables_index, NULL), uname;\n\t     loadables_index++) {\n\t\tif (loadables_index == 0) {\n\t\t\tprintf(\"%s  Loadables:    \", p);\n\t\t} else {\n\t\t\tprintf(\"%s                \", p);\n\t\t}\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\t/* Process all hash subnodes of the component configuration node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component configuration node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_print_contents - prints out the contents of the FIT format image\n * @fit: pointer to the FIT format image header\n * @p: pointer to prefix string\n *\n * fit_print_contents() formats a multi line FIT image contents description.\n * The routine prints out FIT image properties (root node level) followed by\n * the details of each component image.\n *\n * returns:\n *     no returned results\n */\nvoid fit_print_contents(const void *fit)\n{\n\tchar *desc;\n\tchar *uname;\n\tint images_noffset;\n\tint confs_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\tint ret;\n\tconst char *p;\n\ttime_t timestamp;\n\n\t/* Indent string is defined in header image.h */\n\tp = IMAGE_INDENT_STRING;\n\n\t/* Root node properties */\n\tret = fit_get_desc(fit, 0, &desc);\n\tprintf(\"%sFIT description: \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%sCreated:         \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn;\n\t}\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"%s Image %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_image_print(fit, noffset, p);\n\t\t}\n\t}\n\n\t/* Find configurations parent node offset */\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't get configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn;\n\t}\n\n\t/* get default configuration unit name from default property */\n\tuname = (char *)fdt_getprop(fit, noffset, FIT_DEFAULT_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s Default Configuration: '%s'\\n\", p, uname);\n\n\t/* Process its subnodes, print out configurations details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the configurations parent node,\n\t\t\t * i.e. configuration node.\n\t\t\t */\n\t\t\tprintf(\"%s Configuration %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_conf_print(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_image_print - prints out the FIT component image details\n * @fit: pointer to the FIT format image header\n * @image_noffset: offset of the component image node\n * @p: pointer to prefix string\n *\n * fit_image_print() lists all mandatory properties for the processed component\n * image. If present, hash nodes are printed out as well. Load\n * address for images of type firmware is also printed out. Since the load\n * address is not mandatory for firmware images, it will be output as\n * \"unavailable\" when not present.\n *\n * returns:\n *     no returned results\n */\nvoid fit_image_print(const void *fit, int image_noffset, const char *p)\n{\n\tchar *desc;\n\tuint8_t type, arch, os, comp;\n\tsize_t size;\n\tulong load, entry;\n\tconst void *data;\n\tint noffset;\n\tint ndepth;\n\tint ret;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, image_noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\ttime_t timestamp;\n\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%s  Created:      \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\tfit_image_get_type(fit, image_noffset, &type);\n\tprintf(\"%s  Type:         %s\\n\", p, genimg_get_type_name(type));\n\n\tfit_image_get_comp(fit, image_noffset, &comp);\n\tprintf(\"%s  Compression:  %s\\n\", p, genimg_get_comp_name(comp));\n\n\tret = fit_image_get_data_and_size(fit, image_noffset, &data, &size);\n\n\tif (!host_build()) {\n\t\tprintf(\"%s  Data Start:   \", p);\n\t\tif (ret) {\n\t\t\tprintf(\"unavailable\\n\");\n\t\t} else {\n\t\t\tvoid *vdata = (void *)data;\n\n\t\t\tprintf(\"0x%08lx\\n\", (ulong)map_to_sysmem(vdata));\n\t\t}\n\t}\n\n\tprintf(\"%s  Data Size:    \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tgenimg_print_size(size);\n\n\t/* Remaining, type dependent properties */\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK) || (type == IH_TYPE_FIRMWARE) ||\n\t    (type == IH_TYPE_FLATDT)) {\n\t\tfit_image_get_arch(fit, image_noffset, &arch);\n\t\tprintf(\"%s  Architecture: %s\\n\", p, genimg_get_arch_name(arch));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FIRMWARE)) {\n\t\tfit_image_get_os(fit, image_noffset, &os);\n\t\tprintf(\"%s  OS:           %s\\n\", p, genimg_get_os_name(os));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_FIRMWARE) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FPGA)) {\n\t\tret = fit_image_get_load(fit, image_noffset, &load);\n\t\tprintf(\"%s  Load Address: \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", load);\n\t}\n\n\t/* optional load address for FDT */\n\tif (type == IH_TYPE_FLATDT && !fit_image_get_load(fit, image_noffset, &load))\n\t\tprintf(\"%s  Load Address: 0x%08lx\\n\", p, load);\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK)) {\n\t\tret = fit_image_get_entry(fit, image_noffset, &entry);\n\t\tprintf(\"%s  Entry Point:  \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", entry);\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, image_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component image node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n#else\nvoid fit_print_contents(const void *fit) { }\nvoid fit_image_print(const void *fit, int image_noffset, const char *p) { }\n#endif /* CONFIG_IS_ENABLED(FIR_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT) */\n\n/**\n * fit_get_desc - get node description property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @desc: double pointer to the char, will hold pointer to the description\n *\n * fit_get_desc() reads description property from a given node, if\n * description is found pointer to it is returned in third call argument.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_get_desc(const void *fit, int noffset, char **desc)\n{\n\tint len;\n\n\t*desc = (char *)fdt_getprop(fit, noffset, FIT_DESC_PROP, &len);\n\tif (*desc == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DESC_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_get_timestamp - get node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: pointer to the time_t, will hold read timestamp\n *\n * fit_get_timestamp() reads timestamp property from given node, if timestamp\n * is found and has a correct size its value is returned in third call\n * argument.\n *\n * returns:\n *     0, on success\n *     -1, on property read failure\n *     -2, on wrong timestamp size\n */\nint fit_get_timestamp(const void *fit, int noffset, time_t *timestamp)\n{\n\tint len;\n\tconst void *data;\n\n\tdata = fdt_getprop(fit, noffset, FIT_TIMESTAMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TIMESTAMP_PROP, len);\n\t\treturn -1;\n\t}\n\tif (len != sizeof(uint32_t)) {\n\t\tdebug(\"FIT timestamp with incorrect size of (%u)\\n\", len);\n\t\treturn -2;\n\t}\n\n\t*timestamp = uimage_to_cpu(*((uint32_t *)data));\n\treturn 0;\n}\n\n/**\n * fit_image_get_node - get node offset for component image of a given unit name\n * @fit: pointer to the FIT format image header\n * @image_uname: component image node unit name\n *\n * fit_image_get_node() finds a component image (within the '/images'\n * node) of a provided unit name. If image is found its node offset is\n * returned to the caller.\n *\n * returns:\n *     image node offset when found (>=0)\n *     negative number on failure (FDT_ERR_* code)\n */\nint fit_image_get_node(const void *fit, const char *image_uname)\n{\n\tint noffset, images_noffset;\n\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tdebug(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t      FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn images_noffset;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, images_noffset, image_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for image unit name: '%s' (%s)\\n\",\n\t\t      image_uname, fdt_strerror(noffset));\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_image_get_os - get os id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: pointer to the uint8_t, will hold os numeric id\n *\n * fit_image_get_os() finds os property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_os(const void *fit, int noffset, uint8_t *os)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get OS name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_OS_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_OS_PROP, len);\n\t\t*os = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate OS name to id */\n\t*os = genimg_get_os_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_arch - get arch id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: pointer to the uint8_t, will hold arch numeric id\n *\n * fit_image_get_arch() finds arch property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_arch(const void *fit, int noffset, uint8_t *arch)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get architecture name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_ARCH_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ARCH_PROP, len);\n\t\t*arch = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate architecture name to id */\n\t*arch = genimg_get_arch_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_type - get type id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: pointer to the uint8_t, will hold type numeric id\n *\n * fit_image_get_type() finds type property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_type(const void *fit, int noffset, uint8_t *type)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get image type name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_TYPE_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TYPE_PROP, len);\n\t\t*type = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate image type name to id */\n\t*type = genimg_get_type_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_comp - get comp id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: pointer to the uint8_t, will hold comp numeric id\n *\n * fit_image_get_comp() finds comp property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_comp(const void *fit, int noffset, uint8_t *comp)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get compression name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_COMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_COMP_PROP, len);\n\t\t*comp = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate compression name to id */\n\t*comp = genimg_get_comp_id(data);\n\treturn 0;\n}\n\nstatic int fit_image_get_address(const void *fit, int noffset, char *name,\n\t\t\t  ulong *load)\n{\n\tint len, cell_len;\n\tconst fdt32_t *cell;\n\tuint64_t load64 = 0;\n\n\tcell = fdt_getprop(fit, noffset, name, &len);\n\tif (cell == NULL) {\n\t\tfit_get_debug(fit, noffset, name, len);\n\t\treturn -1;\n\t}\n\n\tcell_len = len >> 2;\n\t/* Use load64 to avoid compiling warning for 32-bit target */\n\twhile (cell_len--) {\n\t\tload64 = (load64 << 32) | uimage_to_cpu(*cell);\n\t\tcell++;\n\t}\n\n\tif (len > sizeof(ulong) && (uint32_t)(load64 >> 32)) {\n\t\tprintf(\"Unsupported %s address size\\n\", name);\n\t\treturn -1;\n\t}\n\n\t*load = (ulong)load64;\n\n\treturn 0;\n}\n/**\n * fit_image_get_load() - get load addr property for given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @load: pointer to the uint32_t, will hold load address\n *\n * fit_image_get_load() finds load address property in a given component\n * image node. If the property is found, its value is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_load(const void *fit, int noffset, ulong *load)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_LOAD_PROP, load);\n}\n\n/**\n * fit_image_get_entry() - get entry point address property\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @entry: pointer to the uint32_t, will hold entry point address\n *\n * This gets the entry point address property for a given component image\n * node.\n *\n * fit_image_get_entry() finds entry point address property in a given\n * component image node.  If the property is found, its value is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_entry(const void *fit, int noffset, ulong *entry)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_ENTRY_PROP, entry);\n}\n\n/**\n * fit_image_get_data - get data property and its size for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data() finds data property in a given component image node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_data(const void *fit, int noffset,\n\t\tconst void **data, size_t *size)\n{\n\tint len;\n\n\t*data = fdt_getprop(fit, noffset, FIT_DATA_PROP, &len);\n\tif (*data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DATA_PROP, len);\n\t\t*size = 0;\n\t\treturn -1;\n\t}\n\n\t*size = len;\n\treturn 0;\n}\n\n/**\n * Get 'data-offset' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_offset: holds the data-offset property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_offset(const void *fit, int noffset, int *data_offset)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_OFFSET_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_offset = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-position' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_position: holds the data-position property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_position(const void *fit, int noffset,\n\t\t\t\tint *data_position)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_POSITION_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_position = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size(const void *fit, int noffset, int *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_SIZE_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size-unciphered' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size_unciphered(const void *fit, int noffset,\n\t\t\t\t       size_t *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, \"data-size-unciphered\", NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = (size_t)fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * fit_image_get_data_and_size - get data and its size including\n *\t\t\t\t both embedded and external data\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data_and_size() finds data and its size including\n * both embedded and external data. If the property is found\n * its data start address and size are returned to the caller.\n *\n * returns:\n *     0, on success\n *     otherwise, on failure\n */\nint fit_image_get_data_and_size(const void *fit, int noffset,\n\t\t\t\tconst void **data, size_t *size)\n{\n\tbool external_data = false;\n\tint offset;\n\tint len;\n\tint ret;\n\n\tif (!fit_image_get_data_position(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t} else if (!fit_image_get_data_offset(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t\t/*\n\t\t * For FIT with external data, figure out where\n\t\t * the external images start. This is the base\n\t\t * for the data-offset properties in each image.\n\t\t */\n\t\toffset += ((fdt_totalsize(fit) + 3) & ~3);\n\t}\n\n\tif (external_data) {\n\t\tdebug(\"External Data\\n\");\n\t\tret = fit_image_get_data_size(fit, noffset, &len);\n\t\tif (!ret) {\n\t\t\t*data = fit + offset;\n\t\t\t*size = len;\n\t\t}\n\t} else {\n\t\tret = fit_image_get_data(fit, noffset, data, size);\n\t}\n\n\treturn ret;\n}\n\n/**\n * fit_image_hash_get_algo - get hash algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.\n * If the property is found its data start address is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (*algo == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_value - get hash value and length\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @value: double pointer to uint8_t, will hold address of a hash value data\n * @value_len: pointer to an int, will hold hash data length\n *\n * fit_image_hash_get_value() finds hash value property in a given hash node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_value(const void *fit, int noffset, uint8_t **value,\n\t\t\t\tint *value_len)\n{\n\tint len;\n\n\t*value = (uint8_t *)fdt_getprop(fit, noffset, FIT_VALUE_PROP, &len);\n\tif (*value == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_VALUE_PROP, len);\n\t\t*value_len = 0;\n\t\treturn -1;\n\t}\n\n\t*value_len = len;\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_ignore - get hash ignore flag\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @ignore: pointer to an int, will hold hash ignore flag\n *\n * fit_image_hash_get_ignore() finds hash ignore property in a given hash node.\n * If the property is found and non-zero, the hash algorithm is not verified by\n * u-boot automatically.\n *\n * returns:\n *     0, on ignore not found\n *     value, on ignore found\n */\nstatic int fit_image_hash_get_ignore(const void *fit, int noffset, int *ignore)\n{\n\tint len;\n\tint *value;\n\n\tvalue = (int *)fdt_getprop(fit, noffset, FIT_IGNORE_PROP, &len);\n\tif (value == NULL || len != sizeof(int))\n\t\t*ignore = 0;\n\telse\n\t\t*ignore = *value;\n\n\treturn 0;\n}\n\n/**\n * fit_image_cipher_get_algo - get cipher algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: cipher node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_cipher_get_algo() finds cipher algorithm property in a given\n * cipher node. If the property is found its data start address is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_cipher_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (!*algo) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nulong fit_get_end(const void *fit)\n{\n\treturn map_to_sysmem((void *)(fit + fdt_totalsize(fit)));\n}\n\n/**\n * fit_set_timestamp - set node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: timestamp value to be set\n *\n * fit_set_timestamp() attempts to set timestamp property in the requested\n * node and returns operation status to the caller.\n *\n * returns:\n *     0, on success\n *     -ENOSPC if no space in device tree, -1 for other error\n */\nint fit_set_timestamp(void *fit, int noffset, time_t timestamp)\n{\n\tuint32_t t;\n\tint ret;\n\n\tt = cpu_to_uimage(timestamp);\n\tret = fdt_setprop(fit, noffset, FIT_TIMESTAMP_PROP, &t,\n\t\t\t\tsizeof(uint32_t));\n\tif (ret) {\n\t\tdebug(\"Can't set '%s' property for '%s' node (%s)\\n\",\n\t\t      FIT_TIMESTAMP_PROP, fit_get_name(fit, noffset, NULL),\n\t\t      fdt_strerror(ret));\n\t\treturn ret == -FDT_ERR_NOSPACE ? -ENOSPC : -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * calculate_hash - calculate and return hash for provided input data\n * @data: pointer to the input data\n * @data_len: data length\n * @algo: requested hash algorithm\n * @value: pointer to the char, will hold hash value data (caller must\n * allocate enough free space)\n * value_len: length of the calculated hash\n *\n * calculate_hash() computes input data hash according to the requested\n * algorithm.\n * Resulting hash value is placed in caller provided 'value' buffer, length\n * of the calculated hash is returned via value_len pointer argument.\n *\n * returns:\n *     0, on success\n *    -1, when algo is unsupported\n */\nint calculate_hash(const void *data, int data_len, const char *algo,\n\t\t\tuint8_t *value, int *value_len)\n{\n\tif (IMAGE_ENABLE_CRC32 && strcmp(algo, \"crc32\") == 0) {\n\t\t*((uint32_t *)value) = crc32_wd(0, data, data_len,\n\t\t\t\t\t\t\tCHUNKSZ_CRC32);\n\t\t*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));\n\t\t*value_len = 4;\n\t} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, \"sha1\") == 0) {\n\t\tsha1_csum_wd((unsigned char *)data, data_len,\n\t\t\t     (unsigned char *)value, CHUNKSZ_SHA1);\n\t\t*value_len = 20;\n\t} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, \"sha256\") == 0) {\n\t\tsha256_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA256);\n\t\t*value_len = SHA256_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA384 && strcmp(algo, \"sha384\") == 0) {\n\t\tsha384_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA384);\n\t\t*value_len = SHA384_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA512 && strcmp(algo, \"sha512\") == 0) {\n\t\tsha512_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA512);\n\t\t*value_len = SHA512_SUM_LEN;\n\t} else if (IMAGE_ENABLE_MD5 && strcmp(algo, \"md5\") == 0) {\n\t\tmd5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);\n\t\t*value_len = 16;\n\t} else {\n\t\tdebug(\"Unsupported hash alogrithm\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int fit_image_check_hash(const void *fit, int noffset, const void *data,\n\t\t\t\tsize_t size, char **err_msgp)\n{\n\tuint8_t value[FIT_MAX_HASH_LEN];\n\tint value_len;\n\tchar *algo;\n\tuint8_t *fit_value;\n\tint fit_value_len;\n\tint ignore;\n\n\t*err_msgp = NULL;\n\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\t*err_msgp = \"Can't get hash algo property\";\n\t\treturn -1;\n\t}\n\tprintf(\"%s\", algo);\n\n\tif (IMAGE_ENABLE_IGNORE) {\n\t\tfit_image_hash_get_ignore(fit, noffset, &ignore);\n\t\tif (ignore) {\n\t\t\tprintf(\"-skipped \");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fit_image_hash_get_value(fit, noffset, &fit_value,\n\t\t\t\t     &fit_value_len)) {\n\t\t*err_msgp = \"Can't get hash value property\";\n\t\treturn -1;\n\t}\n\n\tif (calculate_hash(data, size, algo, value, &value_len)) {\n\t\t*err_msgp = \"Unsupported hash algorithm\";\n\t\treturn -1;\n\t}\n\n\tif (value_len != fit_value_len) {\n\t\t*err_msgp = \"Bad hash value len\";\n\t\treturn -1;\n\t} else if (memcmp(value, fit_value, value_len) != 0) {\n\t\t*err_msgp = \"Bad hash value\";\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint fit_image_verify_with_data(const void *fit, int image_noffset,\n\t\t\t       const void *data, size_t size)\n{\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tint verify_all = 1;\n\tint ret;\n\n\t/* Verify all required signatures */\n\tif (FIT_IMAGE_ENABLE_VERIFY &&\n\t    fit_image_verify_required_sigs(fit, image_noffset, data, size,\n\t\t\t\t\t   gd_fdt_blob(), &verify_all)) {\n\t\terr_msg = \"Unable to verify required signature\";\n\t\tgoto error;\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\n\t\t/*\n\t\t * Check subnode name, must be equal to \"hash\".\n\t\t * Multiple hash nodes require unique unit node\n\t\t * names, e.g. hash-1, hash-2, etc.\n\t\t */\n\t\tif (!strncmp(name, FIT_HASH_NODENAME,\n\t\t\t     strlen(FIT_HASH_NODENAME))) {\n\t\t\tif (fit_image_check_hash(fit, noffset, data, size,\n\t\t\t\t\t\t &err_msg))\n\t\t\t\tgoto error;\n\t\t\tputs(\"+ \");\n\t\t} else if (FIT_IMAGE_ENABLE_VERIFY && verify_all &&\n\t\t\t\t!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t\tsize, -1, &err_msg);\n\n\t\t\t/*\n\t\t\t * Show an indication on failure, but do not return\n\t\t\t * an error. Only keys marked 'required' can cause\n\t\t\t * an image validation failure. See the call to\n\t\t\t * fit_image_verify_required_sigs() above.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tputs(\"- \");\n\t\t\telse\n\t\t\t\tputs(\"+ \");\n\t\t}\n\t}\n\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\n\treturn 1;\n\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_image_verify - verify data integrity\n * @fit: pointer to the FIT format image header\n * @image_noffset: component image node offset\n *\n * fit_image_verify() goes over component image hash nodes,\n * re-calculates each data hash and compares with the value stored in hash\n * node.\n *\n * returns:\n *     1, if all hashes are valid\n *     0, otherwise (or on error)\n */\nint fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst char *name = fit_get_name(fit, image_noffset, NULL);\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tchar\t\t*err_msg = \"\";\n\n\tif (strchr(name, '@')) {\n\t\t/*\n\t\t * We don't support this since libfdt considers names with the\n\t\t * name root but different @ suffix to be equal\n\t\t */\n\t\terr_msg = \"Node name contains @\";\n\t\tgoto err;\n\t}\n\t/* Get image data and data length */\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tgoto err;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n\nerr:\n\tprintf(\"error!\\n%s in '%s' image node\\n\", err_msg,\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_all_image_verify - verify data integrity for all images\n * @fit: pointer to the FIT format image header\n *\n * fit_all_image_verify() goes over all images in the FIT and\n * for every images checks if all it's hashes are valid.\n *\n * returns:\n *     1, if all hashes of all images are valid\n *     0, otherwise (or on error)\n */\nint fit_all_image_verify(const void *fit)\n{\n\tint images_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count;\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn 0;\n\t}\n\n\t/* Process all image subnodes, check hashes for each */\n\tprintf(\"## Checking hash(es) for FIT Image at %08lx ...\\n\",\n\t       (ulong)fit);\n\tfor (ndepth = 0, count = 0,\n\t     noffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"   Hash(es) for Image %u (%s): \", count,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\t\t\tcount++;\n\n\t\t\tif (!fit_image_verify(fit, noffset))\n\t\t\t\treturn 0;\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int fit_image_uncipher(const void *fit, int image_noffset,\n\t\t\t      void **data, size_t *size)\n{\n\tint cipher_noffset, ret;\n\tvoid *dst;\n\tsize_t size_dst;\n\n\tcipher_noffset = fdt_subnode_offset(fit, image_noffset,\n\t\t\t\t\t    FIT_CIPHER_NODENAME);\n\tif (cipher_noffset < 0)\n\t\treturn 0;\n\n\tret = fit_image_decrypt_data(fit, image_noffset, cipher_noffset,\n\t\t\t\t     *data, *size, &dst, &size_dst);\n\tif (ret)\n\t\tgoto out;\n\n\t*data = dst;\n\t*size = size_dst;\n\n out:\n\treturn ret;\n}\n\n/**\n * fit_image_check_os - check whether image node is of a given os type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: requested image os\n *\n * fit_image_check_os() reads image os property and compares its numeric\n * id with the requested os. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given os type\n *     0 otherwise (or on error)\n */\nint fit_image_check_os(const void *fit, int noffset, uint8_t os)\n{\n\tuint8_t image_os;\n\n\tif (fit_image_get_os(fit, noffset, &image_os))\n\t\treturn 0;\n\treturn (os == image_os);\n}\n\n/**\n * fit_image_check_arch - check whether image node is of a given arch\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: requested imagearch\n *\n * fit_image_check_arch() reads image arch property and compares its numeric\n * id with the requested arch. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given arch\n *     0 otherwise (or on error)\n */\nint fit_image_check_arch(const void *fit, int noffset, uint8_t arch)\n{\n\tuint8_t image_arch;\n\tint aarch32_support = 0;\n\n\tif (IS_ENABLED(CONFIG_ARM64_SUPPORT_AARCH32))\n\t\taarch32_support = 1;\n\n\tif (fit_image_get_arch(fit, noffset, &image_arch))\n\t\treturn 0;\n\treturn (arch == image_arch) ||\n\t\t(arch == IH_ARCH_I386 && image_arch == IH_ARCH_X86_64) ||\n\t\t(arch == IH_ARCH_ARM64 && image_arch == IH_ARCH_ARM &&\n\t\t aarch32_support);\n}\n\n/**\n * fit_image_check_type - check whether image node is of a given type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: requested image type\n *\n * fit_image_check_type() reads image type property and compares its numeric\n * id with the requested type. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given type\n *     0 otherwise (or on error)\n */\nint fit_image_check_type(const void *fit, int noffset, uint8_t type)\n{\n\tuint8_t image_type;\n\n\tif (fit_image_get_type(fit, noffset, &image_type))\n\t\treturn 0;\n\treturn (type == image_type);\n}\n\n/**\n * fit_image_check_comp - check whether image node uses given compression\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: requested image compression type\n *\n * fit_image_check_comp() reads image compression property and compares its\n * numeric id with the requested compression type. Comparison result is\n * returned to the caller.\n *\n * returns:\n *     1 if image uses requested compression\n *     0 otherwise (or on error)\n */\nint fit_image_check_comp(const void *fit, int noffset, uint8_t comp)\n{\n\tuint8_t image_comp;\n\n\tif (fit_image_get_comp(fit, noffset, &image_comp))\n\t\treturn 0;\n\treturn (comp == image_comp);\n}\n\nint fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\n\t/* A FIT image must be a valid FDT */\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* mandatory / node 'description' property */\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\t/* mandatory / node 'timestamp' property */\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\t/* mandatory subimages parent '/images' node */\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_conf_find_compat\n * @fit: pointer to the FIT format image header\n * @fdt: pointer to the device tree to compare against\n *\n * fit_conf_find_compat() attempts to find the configuration whose fdt is the\n * most compatible with the passed in device tree.\n *\n * Example:\n *\n * / o image-tree\n *   |-o images\n *   | |-o fdt-1\n *   | |-o fdt-2\n *   |\n *   |-o configurations\n *     |-o config-1\n *     | |-fdt = fdt-1\n *     |\n *     |-o config-2\n *       |-fdt = fdt-2\n *\n * / o U-Boot fdt\n *   |-compatible = \"foo,bar\", \"bim,bam\"\n *\n * / o kernel fdt1\n *   |-compatible = \"foo,bar\",\n *\n * / o kernel fdt2\n *   |-compatible = \"bim,bam\", \"baz,biz\"\n *\n * Configuration 1 would be picked because the first string in U-Boot's\n * compatible list, \"foo,bar\", matches a compatible string in the root of fdt1.\n * \"bim,bam\" in fdt2 matches the second string which isn't as good as fdt1.\n *\n * As an optimization, the compatible property from the FDT's root node can be\n * copied into the configuration node in the FIT image. This is required to\n * match configurations with compressed FDTs.\n *\n * returns:\n *     offset to the configuration to use if one was found\n *     -1 otherwise\n */\nint fit_conf_find_compat(const void *fit, const void *fdt)\n{\n\tint ndepth = 0;\n\tint noffset, confs_noffset, images_noffset;\n\tconst void *fdt_compat;\n\tint fdt_compat_len;\n\tint best_match_offset = 0;\n\tint best_match_pos = 0;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (confs_noffset < 0 || images_noffset < 0) {\n\t\tdebug(\"Can't find configurations or images nodes.\\n\");\n\t\treturn -1;\n\t}\n\n\tfdt_compat = fdt_getprop(fdt, 0, \"compatible\", &fdt_compat_len);\n\tif (!fdt_compat) {\n\t\tdebug(\"Fdt for comparison has no \\\"compatible\\\" property.\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Loop over the configurations in the FIT image.\n\t */\n\tfor (noffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tconst void *fdt;\n\t\tconst char *kfdt_name;\n\t\tint kfdt_noffset, compat_noffset;\n\t\tconst char *cur_fdt_compat;\n\t\tint len;\n\t\tsize_t sz;\n\t\tint i;\n\n\t\tif (ndepth > 1)\n\t\t\tcontinue;\n\n\t\t/* If there's a compat property in the config node, use that. */\n\t\tif (fdt_getprop(fit, noffset, \"compatible\", NULL)) {\n\t\t\tfdt = fit;\t\t  /* search in FIT image */\n\t\t\tcompat_noffset = noffset; /* search under config node */\n\t\t} else {\t/* Otherwise extract it from the kernel FDT. */\n\t\t\tkfdt_name = fdt_getprop(fit, noffset, \"fdt\", &len);\n\t\t\tif (!kfdt_name) {\n\t\t\t\tdebug(\"No fdt property found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkfdt_noffset = fdt_subnode_offset(fit, images_noffset,\n\t\t\t\t\t\t\t  kfdt_name);\n\t\t\tif (kfdt_noffset < 0) {\n\t\t\t\tdebug(\"No image node named \\\"%s\\\" found.\\n\",\n\t\t\t\t      kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fit_image_check_comp(fit, kfdt_noffset,\n\t\t\t\t\t\t  IH_COMP_NONE)) {\n\t\t\t\tdebug(\"Can't extract compat from \\\"%s\\\" \"\n\t\t\t\t      \"(compressed)\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* search in this config's kernel FDT */\n\t\t\tif (fit_image_get_data(fit, kfdt_noffset, &fdt, &sz)) {\n\t\t\t\tdebug(\"Failed to get fdt \\\"%s\\\".\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcompat_noffset = 0;  /* search kFDT under root node */\n\t\t}\n\n\t\tlen = fdt_compat_len;\n\t\tcur_fdt_compat = fdt_compat;\n\t\t/*\n\t\t * Look for a match for each U-Boot compatibility string in\n\t\t * turn in the compat string property.\n\t\t */\n\t\tfor (i = 0; len > 0 &&\n\t\t     (!best_match_offset || best_match_pos > i); i++) {\n\t\t\tint cur_len = strlen(cur_fdt_compat) + 1;\n\n\t\t\tif (!fdt_node_check_compatible(fdt, compat_noffset,\n\t\t\t\t\t\t       cur_fdt_compat)) {\n\t\t\t\tbest_match_offset = noffset;\n\t\t\t\tbest_match_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= cur_len;\n\t\t\tcur_fdt_compat += cur_len;\n\t\t}\n\t}\n\tif (!best_match_offset) {\n\t\tdebug(\"No match found.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn best_match_offset;\n}\n\nint fit_conf_get_node(const void *fit, const char *conf_uname)\n{\n\tint noffset, confs_noffset;\n\tint len;\n\tconst char *s;\n\tchar *conf_uname_copy = NULL;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't find configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn confs_noffset;\n\t}\n\n\tif (conf_uname == NULL) {\n\t\t/* get configuration unit name from the default property */\n\t\tdebug(\"No configuration specified, trying default...\\n\");\n\t\tif (!host_build() && IS_ENABLED(CONFIG_MULTI_DTB_FIT)) {\n\t\t\tnoffset = fit_find_config_node(fit);\n\t\t\tif (noffset < 0)\n\t\t\t\treturn noffset;\n\t\t\tconf_uname = fdt_get_name(fit, noffset, NULL);\n\t\t} else {\n\t\t\tconf_uname = (char *)fdt_getprop(fit, confs_noffset,\n\t\t\t\t\t\t\t FIT_DEFAULT_PROP, &len);\n\t\t\tif (conf_uname == NULL) {\n\t\t\t\tfit_get_debug(fit, confs_noffset, FIT_DEFAULT_PROP,\n\t\t\t\t\t      len);\n\t\t\t\treturn len;\n\t\t\t}\n\t\t}\n\t\tdebug(\"Found default configuration: '%s'\\n\", conf_uname);\n\t}\n\n\ts = strchr(conf_uname, '#');\n\tif (s) {\n\t\tlen = s - conf_uname;\n\t\tconf_uname_copy = malloc(len + 1);\n\t\tif (!conf_uname_copy) {\n\t\t\tdebug(\"Can't allocate uname copy: '%s'\\n\",\n\t\t\t\t\tconf_uname);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(conf_uname_copy, conf_uname, len);\n\t\tconf_uname_copy[len] = '\\0';\n\t\tconf_uname = conf_uname_copy;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, confs_noffset, conf_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for configuration unit name: '%s' (%s)\\n\",\n\t\t      conf_uname, fdt_strerror(noffset));\n\t}\n\n\tif (conf_uname_copy)\n\t\tfree(conf_uname_copy);\n\n\treturn noffset;\n}\n\nint fit_conf_get_prop_node_count(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fdt_stringlist_count(fit, noffset, prop_name);\n}\n\nint fit_conf_get_prop_node_index(const void *fit, int noffset,\n\t\tconst char *prop_name, int index)\n{\n\tconst char *uname;\n\tint len;\n\n\t/* get kernel image unit name from configuration kernel property */\n\tuname = fdt_stringlist_get(fit, noffset, prop_name, index, &len);\n\tif (uname == NULL)\n\t\treturn len;\n\n\treturn fit_image_get_node(fit, uname);\n}\n\nint fit_conf_get_prop_node(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fit_conf_get_prop_node_index(fit, noffset, prop_name, 0);\n}\n\nstatic int fit_image_select(const void *fit, int rd_noffset, int verify)\n{\n\tfit_image_print(fit, rd_noffset, \"   \");\n\n\tif (verify) {\n\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\tif (!fit_image_verify(fit, rd_noffset)) {\n\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\treturn 0;\n}\n\nint fit_get_node_from_config(bootm_headers_t *images, const char *prop_name,\n\t\t\tulong addr)\n{\n\tint cfg_noffset;\n\tvoid *fit_hdr;\n\tint noffset;\n\n\tdebug(\"*  %s: using config '%s' from image at 0x%08lx\\n\",\n\t      prop_name, images->fit_uname_cfg, addr);\n\n\t/* Check whether configuration has this property defined */\n\tfit_hdr = map_sysmem(addr, 0);\n\tcfg_noffset = fit_conf_get_node(fit_hdr, images->fit_uname_cfg);\n\tif (cfg_noffset < 0) {\n\t\tdebug(\"*  %s: no such config\\n\", prop_name);\n\t\treturn -EINVAL;\n\t}\n\n\tnoffset = fit_conf_get_prop_node(fit_hdr, cfg_noffset, prop_name);\n\tif (noffset < 0) {\n\t\tdebug(\"*  %s: no '%s' in config\\n\", prop_name, prop_name);\n\t\treturn -ENOENT;\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_get_image_type_property() - get property name for IH_TYPE_...\n *\n * @return the properly name where we expect to find the image in the\n * config node\n */\nstatic const char *fit_get_image_type_property(int type)\n{\n\t/*\n\t * This is sort-of available in the uimage_type[] table in image.c\n\t * but we don't have access to the short name, and \"fdt\" is different\n\t * anyway. So let's just keep it here.\n\t */\n\tswitch (type) {\n\tcase IH_TYPE_FLATDT:\n\t\treturn FIT_FDT_PROP;\n\tcase IH_TYPE_KERNEL:\n\t\treturn FIT_KERNEL_PROP;\n\tcase IH_TYPE_RAMDISK:\n\t\treturn FIT_RAMDISK_PROP;\n\tcase IH_TYPE_X86_SETUP:\n\t\treturn FIT_SETUP_PROP;\n\tcase IH_TYPE_LOADABLE:\n\t\treturn FIT_LOADABLE_PROP;\n\tcase IH_TYPE_FPGA:\n\t\treturn FIT_FPGA_PROP;\n\tcase IH_TYPE_STANDALONE:\n\t\treturn FIT_STANDALONE_PROP;\n\t}\n\n\treturn \"unknown\";\n}\n\nint fit_image_load(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, int image_type, int bootstage_id,\n\t\t   enum fit_load_op load_op, ulong *datap, ulong *lenp)\n{\n\tint cfg_noffset, noffset;\n\tconst char *fit_uname;\n\tconst char *fit_uname_config;\n\tconst char *fit_base_uname_config;\n\tconst void *fit;\n\tvoid *buf;\n\tvoid *loadbuf;\n\tsize_t size;\n\tint type_ok, os_ok;\n\tulong load, load_end, data, len;\n\tuint8_t os, comp;\n#ifndef USE_HOSTCC\n\tuint8_t os_arch;\n#endif\n\tconst char *prop_name;\n\tint ret;\n\n\tfit = map_sysmem(addr, 0);\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\tfit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;\n\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tif (fit_check_format(fit, IMAGE_SIZE_INVAL)) {\n\t\tprintf(\"Bad FIT %s image format!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn -ENOEXEC;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t/* get FIT component image node offset */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);\n\t\tnoffset = fit_image_get_node(fit, fit_uname);\n\t} else {\n\t\t/*\n\t\t * no image node unit name, try to get config\n\t\t * node first. If config unit node name is NULL\n\t\t * fit_conf_get_node() will try to find default config node\n\t\t */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\tif (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) {\n\t\t\tcfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob());\n\t\t} else {\n\t\t\tcfg_noffset = fit_conf_get_node(fit,\n\t\t\t\t\t\t\tfit_uname_config);\n\t\t}\n\t\tif (cfg_noffset < 0) {\n\t\t\tputs(\"Could not find configuration node\\n\");\n\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tfit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL);\n\t\tprintf(\"   Using '%s' configuration\\n\", fit_base_uname_config);\n\t\t/* Remember this config */\n\t\tif (image_type == IH_TYPE_KERNEL)\n\t\t\timages->fit_uname_cfg = fit_base_uname_config;\n\n\t\tif (FIT_IMAGE_ENABLE_VERIFY && images->verify) {\n\t\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\t\tif (fit_config_verify(fit, cfg_noffset)) {\n\t\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_HASH);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tputs(\"OK\\n\");\n\t\t}\n\n\t\tbootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);\n\n\t\tnoffset = fit_conf_get_prop_node(fit, cfg_noffset,\n\t\t\t\t\t\t prop_name);\n\t\tfit_uname = fit_get_name(fit, noffset, NULL);\n\t}\n\tif (noffset < 0) {\n\t\tprintf(\"Could not find subimage node type '%s'\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE);\n\t\treturn -ENOENT;\n\t}\n\n\tprintf(\"   Trying '%s' %s subimage\\n\", fit_uname, prop_name);\n\n\tret = fit_image_select(fit, noffset, images->verify);\n\tif (ret) {\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH);\n\t\treturn ret;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\tif (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) {\n\t\tif (!fit_image_check_target_arch(fit, noffset)) {\n\t\t\tputs(\"Unsupported Architecture\\n\");\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n#ifndef USE_HOSTCC\n\tfit_image_get_arch(fit, noffset, &os_arch);\n\timages->os.arch = os_arch;\n#endif\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\ttype_ok = fit_image_check_type(fit, noffset, image_type) ||\n\t\t  fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) ||\n\t\t  (image_type == IH_TYPE_KERNEL &&\n\t\t   fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD));\n\n\tos_ok = image_type == IH_TYPE_FLATDT ||\n\t\timage_type == IH_TYPE_FPGA ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_LINUX) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_U_BOOT) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_OPENRTOS) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_EFI) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_VXWORKS);\n\n\t/*\n\t * If either of the checks fail, we should report an error, but\n\t * if the image type is coming from the \"loadables\" field, we\n\t * don't care what it is\n\t */\n\tif ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) {\n\t\tfit_image_get_os(fit, noffset, &os);\n\t\tprintf(\"No %s %s %s Image\\n\",\n\t\t       genimg_get_os_name(os),\n\t\t       genimg_get_arch_name(arch),\n\t\t       genimg_get_type_name(image_type));\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\t\treturn -EIO;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK);\n\n\t/* get image data address and length */\n\tif (fit_image_get_data_and_size(fit, noffset,\n\t\t\t\t\t(const void **)&buf, &size)) {\n\t\tprintf(\"Could not find %s subimage data!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA);\n\t\treturn -ENOENT;\n\t}\n\n\t/* Decrypt data before uncompress/move */\n\tif (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) {\n\t\tputs(\"   Decrypting Data ... \");\n\t\tif (fit_image_uncipher(fit, noffset, &buf, &size)) {\n\t\t\tputs(\"Error\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\t/* perform any post-processing on the image data */\n\tif (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS))\n\t\tboard_fit_image_post_process(&buf, &size);\n\n\tlen = (ulong)size;\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK);\n\n\tdata = map_to_sysmem(buf);\n\tload = data;\n\tif (load_op == FIT_LOAD_IGNORED) {\n\t\t/* Don't load */\n\t} else if (fit_image_get_load(fit, noffset, &load)) {\n\t\tif (load_op == FIT_LOAD_REQUIRED) {\n\t\t\tprintf(\"Can't get %s subimage load address!\\n\",\n\t\t\t       prop_name);\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\t\t\treturn -EBADF;\n\t\t}\n\t} else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) {\n\t\tulong image_start, image_end;\n\n\t\t/*\n\t\t * move image data to the load address,\n\t\t * make sure we don't overwrite initial image\n\t\t */\n\t\timage_start = addr;\n\t\timage_end = addr + fit_get_size(fit);\n\n\t\tload_end = load + len;\n\t\tif (image_type != IH_TYPE_KERNEL &&\n\t\t    load < image_end && load_end > image_start) {\n\t\t\tprintf(\"Error: %s overwritten\\n\", prop_name);\n\t\t\treturn -EXDEV;\n\t\t}\n\n\t\tprintf(\"   Loading %s from 0x%08lx to 0x%08lx\\n\",\n\t\t       prop_name, data, load);\n\t} else {\n\t\tload = data;\t/* No load address specified */\n\t}\n\n\tcomp = IH_COMP_NONE;\n\tloadbuf = buf;\n\t/* Kernel images get decompressed later in bootm_load_os(). */\n\tif (!fit_image_get_comp(fit, noffset, &comp) &&\n\t    comp != IH_COMP_NONE &&\n\t    !(image_type == IH_TYPE_KERNEL ||\n\t      image_type == IH_TYPE_KERNEL_NOLOAD ||\n\t      image_type == IH_TYPE_RAMDISK)) {\n\t\tulong max_decomp_len = len * 20;\n\t\tif (load == data) {\n\t\t\tloadbuf = malloc(max_decomp_len);\n\t\t\tload = map_to_sysmem(loadbuf);\n\t\t} else {\n\t\t\tloadbuf = map_sysmem(load, max_decomp_len);\n\t\t}\n\t\tif (image_decomp(comp, load, data, image_type,\n\t\t\t\tloadbuf, buf, len, max_decomp_len, &load_end)) {\n\t\t\tprintf(\"Error decompressing %s\\n\", prop_name);\n\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t\tlen = load_end - load;\n\t} else if (load != data) {\n\t\tloadbuf = map_sysmem(load, len);\n\t\tmemcpy(loadbuf, buf, len);\n\t}\n\n\tif (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE)\n\t\tputs(\"WARNING: 'compression' nodes for ramdisks are deprecated,\"\n\t\t     \" please fix your .its file!\\n\");\n\n\t/* verify that image data is a proper FDT blob */\n\tif (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) {\n\t\tputs(\"Subimage data is not a FDT\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\n\t*datap = load;\n\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = (char *)fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = (char *)(fit_uname_config ? :\n\t\t\t\t\t      fit_base_uname_config);\n\n\treturn noffset;\n}\n\nint boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,\n\t\t\tulong *setup_start, ulong *setup_len)\n{\n\tint noffset;\n\tulong addr;\n\tulong len;\n\tint ret;\n\n\taddr = map_to_sysmem(images->fit_hdr_os);\n\tnoffset = fit_get_node_from_config(images, FIT_SETUP_PROP, addr);\n\tif (noffset < 0)\n\t\treturn noffset;\n\n\tret = fit_image_load(images, addr, NULL, NULL, arch,\n\t\t\t     IH_TYPE_X86_SETUP, BOOTSTAGE_ID_FIT_SETUP_START,\n\t\t\t     FIT_LOAD_REQUIRED, setup_start, &len);\n\n\treturn ret;\n}\n\n#ifndef USE_HOSTCC\nint boot_get_fdt_fit(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, ulong *datap, ulong *lenp)\n{\n\tint fdt_noffset, cfg_noffset, count;\n\tconst void *fit;\n\tconst char *fit_uname = NULL;\n\tconst char *fit_uname_config = NULL;\n\tchar *fit_uname_config_copy = NULL;\n\tchar *next_config = NULL;\n\tulong load, len;\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\tulong image_start, image_end;\n\tulong ovload, ovlen;\n\tconst char *uconfig;\n\tconst char *uname;\n\tvoid *base, *ov;\n\tint i, err, noffset, ov_noffset;\n#endif\n\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\n\tif (fit_uname_configp && *fit_uname_configp) {\n\t\tfit_uname_config_copy = strdup(*fit_uname_configp);\n\t\tif (!fit_uname_config_copy)\n\t\t\treturn -ENOMEM;\n\n\t\tnext_config = strchr(fit_uname_config_copy, '#');\n\t\tif (next_config)\n\t\t\t*next_config++ = '\\0';\n\t\tif (next_config - 1 > fit_uname_config_copy)\n\t\t\tfit_uname_config = fit_uname_config_copy;\n\t}\n\n\tfdt_noffset = fit_image_load(images,\n\t\taddr, &fit_uname, &fit_uname_config,\n\t\tarch, IH_TYPE_FLATDT,\n\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\tFIT_LOAD_OPTIONAL, &load, &len);\n\n\tif (fdt_noffset < 0)\n\t\tgoto out;\n\n\tdebug(\"fit_uname=%s, fit_uname_config=%s\\n\",\n\t\t\tfit_uname ? fit_uname : \"<NULL>\",\n\t\t\tfit_uname_config ? fit_uname_config : \"<NULL>\");\n\n\tfit = map_sysmem(addr, 0);\n\n\tcfg_noffset = fit_conf_get_node(fit, fit_uname_config);\n\n\t/* single blob, or error just return as well */\n\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset, FIT_FDT_PROP);\n\tif (count <= 1 && !next_config)\n\t\tgoto out;\n\n\t/* we need to apply overlays */\n\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\timage_start = addr;\n\timage_end = addr + fit_get_size(fit);\n\t/* verify that relocation took place by load address not being in fit */\n\tif (load >= image_start && load < image_end) {\n\t\t/* check is simplified; fit load checks for overlaps */\n\t\tprintf(\"Overlayed FDT requires relocation\\n\");\n\t\tfdt_noffset = -EBADF;\n\t\tgoto out;\n\t}\n\n\tbase = map_sysmem(load, len);\n\n\t/* apply extra configs in FIT first, followed by args */\n\tfor (i = 1; ; i++) {\n\t\tif (i < count) {\n\t\t\tnoffset = fit_conf_get_prop_node_index(fit, cfg_noffset,\n\t\t\t\t\t\t\t       FIT_FDT_PROP, i);\n\t\t\tuname = fit_get_name(fit, noffset, NULL);\n\t\t\tuconfig = NULL;\n\t\t} else {\n\t\t\tif (!next_config)\n\t\t\t\tbreak;\n\t\t\tuconfig = next_config;\n\t\t\tnext_config = strchr(next_config, '#');\n\t\t\tif (next_config)\n\t\t\t\t*next_config++ = '\\0';\n\t\t\tuname = NULL;\n\n\t\t\t/*\n\t\t\t * fit_image_load() would load the first FDT from the\n\t\t\t * extra config only when uconfig is specified.\n\t\t\t * Check if the extra config contains multiple FDTs and\n\t\t\t * if so, load them.\n\t\t\t */\n\t\t\tcfg_noffset = fit_conf_get_node(fit, uconfig);\n\n\t\t\ti = 0;\n\t\t\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset,\n\t\t\t\t\t\t\t     FIT_FDT_PROP);\n\t\t}\n\n\t\tdebug(\"%d: using uname=%s uconfig=%s\\n\", i, uname, uconfig);\n\n\t\tov_noffset = fit_image_load(images,\n\t\t\taddr, &uname, &uconfig,\n\t\t\tarch, IH_TYPE_FLATDT,\n\t\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\t\tFIT_LOAD_REQUIRED, &ovload, &ovlen);\n\t\tif (ov_noffset < 0) {\n\t\t\tprintf(\"load of %s failed\\n\", uname);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%s loaded at 0x%08lx len=0x%08lx\\n\",\n\t\t\t\tuname, ovload, ovlen);\n\t\tov = map_sysmem(ovload, ovlen);\n\n\t\tbase = map_sysmem(load, len + ovlen);\n\t\terr = fdt_open_into(base, base, len + ovlen);\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed on fdt_open_into\\n\");\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\t/* the verbose method prints out messages on error */\n\t\terr = fdt_overlay_apply_verbose(base, ov);\n\t\tif (err < 0) {\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\tfdt_pack(base);\n\t\tlen = fdt_totalsize(base);\n\t}\n#else\n\tprintf(\"config with overlays but CONFIG_OF_LIBFDT_OVERLAY not set\\n\");\n\tfdt_noffset = -EBADF;\n#endif\n\nout:\n\tif (datap)\n\t\t*datap = load;\n\tif (lenp)\n\t\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = fit_uname_config;\n\n\tif (fit_uname_config_copy)\n\t\tfree(fit_uname_config_copy);\n\treturn fdt_noffset;\n}\n#endif\n"], "fixing_code": ["menu \"Boot options\"\n\nmenu \"Boot images\"\n\nconfig ANDROID_BOOT_IMAGE\n\tbool \"Enable support for Android Boot Images\"\n\tdefault y if FASTBOOT\n\thelp\n\t  This enables support for booting images which use the Android\n\t  image format header.\n\nconfig FIT\n\tbool \"Support Flattened Image Tree\"\n\tselect MD5\n\tselect SHA1\n\thelp\n\t  This option allows you to boot the new uImage structure,\n\t  Flattened Image Tree.  FIT is formally a FDT, which can include\n\t  images of various types (kernel, FDT blob, ramdisk, etc.)\n\t  in a single blob.  To boot this new uImage structure,\n\t  pass the address of the blob to the \"bootm\" command.\n\t  FIT is very flexible, supporting compression, multiple images,\n\t  multiple configurations, verification through hashing and also\n\t  verified boot (secure boot using RSA).\n\nif FIT\n\nconfig FIT_EXTERNAL_OFFSET\n\thex \"FIT external data offset\"\n\tdefault 0x0\n\thelp\n\t  This specifies a data offset in fit image.\n\t  The offset is from data payload offset to the beginning of\n\t  fit image header. When specifies a offset, specific data\n\t  could be put in the hole between data payload and fit image\n\t  header, such as CSF data on i.MX platform.\n\nconfig FIT_ENABLE_SHA256_SUPPORT\n\tbool \"Support SHA256 checksum of FIT image contents\"\n\tdefault y\n\tselect SHA256\n\thelp\n\t  Enable this to support SHA256 checksum of FIT image contents. A\n\t  SHA256 checksum is a 256-bit (32-byte) hash value used to check that\n\t  the image contents have not been corrupted.\n\nconfig FIT_ENABLE_SHA384_SUPPORT\n\tbool \"Support SHA384 checksum of FIT image contents\"\n\tdefault n\n\tselect SHA384\n\thelp\n\t  Enable this to support SHA384 checksum of FIT image contents. A\n\t  SHA384 checksum is a 384-bit (48-byte) hash value used to check that\n\t  the image contents have not been corrupted. Use this for the highest\n\t  security.\n\nconfig FIT_ENABLE_SHA512_SUPPORT\n\tbool \"Support SHA512 checksum of FIT image contents\"\n\tdefault n\n\tselect SHA512\n\thelp\n\t  Enable this to support SHA512 checksum of FIT image contents. A\n\t  SHA512 checksum is a 512-bit (64-byte) hash value used to check that\n\t  the image contents have not been corrupted.\n\nconfig FIT_FULL_CHECK\n\tbool \"Do a full check of the FIT before using it\"\n\tdefault y\n\thelp\n\t  Enable this do a full check of the FIT to make sure it is valid. This\n\t  helps to protect against carefully crafted FITs which take advantage\n\t  of bugs or omissions in the code. This includes a bad structure,\n\t  multiple root nodes and the like.\n\nconfig FIT_SIGNATURE\n\tbool \"Enable signature verification of FIT uImages\"\n\tdepends on DM\n\tselect HASH\n\tselect RSA\n\tselect RSA_VERIFY\n\tselect IMAGE_SIGN_INFO\n\tselect FIT_FULL_CHECK\n\thelp\n\t  This option enables signature verification of FIT uImages,\n\t  using a hash signed and verified using RSA. If\n\t  CONFIG_SHA_PROG_HW_ACCEL is defined, i.e support for progressive\n\t  hashing is available using hardware, then the RSA library will use\n\t  it. See doc/uImage.FIT/signature.txt for more details.\n\n\t  WARNING: When relying on signed FIT images with a required signature\n\t  check the legacy image format is disabled by default, so that\n\t  unsigned images cannot be loaded. If a board needs the legacy image\n\t  format support in this case, enable it using\n\t  CONFIG_LEGACY_IMAGE_FORMAT.\n\nconfig FIT_SIGNATURE_MAX_SIZE\n\thex \"Max size of signed FIT structures\"\n\tdepends on FIT_SIGNATURE\n\tdefault 0x10000000\n\thelp\n\t  This option sets a max size in bytes for verified FIT uImages.\n\t  A sane value of 256MB protects corrupted DTB structures from overlapping\n\t  device memory. Assure this size does not extend past expected storage\n\t  space.\n\nconfig FIT_ENABLE_RSASSA_PSS_SUPPORT\n\tbool \"Support rsassa-pss signature scheme of FIT image contents\"\n\tdepends on FIT_SIGNATURE\n\tdefault n\n\thelp\n\t  Enable this to support the pss padding algorithm as described\n\t  in the rfc8017 (https://tools.ietf.org/html/rfc8017).\n\nconfig FIT_CIPHER\n\tbool \"Enable ciphering data in a FIT uImages\"\n\tdepends on DM\n\tselect AES\n\thelp\n\t  Enable the feature of data ciphering/unciphering in the tool mkimage\n\t  and in the u-boot support of the FIT image.\n\nconfig FIT_VERBOSE\n\tbool \"Show verbose messages when FIT images fail\"\n\thelp\n\t  Generally a system will have valid FIT images so debug messages\n\t  are a waste of code space. If you are debugging your images then\n\t  you can enable this option to get more verbose information about\n\t  failures.\n\nconfig FIT_BEST_MATCH\n\tbool \"Select the best match for the kernel device tree\"\n\thelp\n\t  When no configuration is explicitly selected, default to the\n\t  one whose fdt's compatibility field best matches that of\n\t  U-Boot itself. A match is considered \"best\" if it matches the\n\t  most specific compatibility entry of U-Boot's fdt's root node.\n\t  The order of entries in the configuration's fdt is ignored.\n\nconfig FIT_IMAGE_POST_PROCESS\n\tbool \"Enable post-processing of FIT artifacts after loading by U-Boot\"\n\tdepends on TI_SECURE_DEVICE\n\thelp\n\t  Allows doing any sort of manipulation to blobs after they got extracted\n\t  from FIT images like stripping off headers or modifying the size of the\n\t  blob, verification, authentication, decryption etc. in a platform or\n\t  board specific way. In order to use this feature a platform or board-\n\t  specific implementation of board_fit_image_post_process() must be\n\t  provided. Also, anything done during this post-processing step would\n\t  need to be comprehended in how the images were prepared before being\n\t  injected into the FIT creation (i.e. the blobs would have been pre-\n\t  processed before being added to the FIT image).\n\nconfig FIT_PRINT\n        bool \"Support FIT printing\"\n        default y\n        help\n          Support printing the content of the fitImage in a verbose manner.\n\nif SPL\n\nconfig SPL_FIT\n\tbool \"Support Flattened Image Tree within SPL\"\n\tdepends on SPL\n\tselect SPL_OF_LIBFDT\n\nconfig SPL_FIT_PRINT\n\tbool \"Support FIT printing within SPL\"\n\tdepends on SPL_FIT\n\thelp\n\t  Support printing the content of the fitImage in a verbose manner in SPL.\n\nconfig SPL_FIT_FULL_CHECK\n\tbool \"Do a full check of the FIT before using it\"\n\thelp\n\t  Enable this do a full check of the FIT to make sure it is valid. This\n\t  helps to protect against carefully crafted FITs which take advantage\n\t  of bugs or omissions in the code. This includes a bad structure,\n\t  multiple root nodes and the like.\n\n\nconfig SPL_FIT_SIGNATURE\n\tbool \"Enable signature verification of FIT firmware within SPL\"\n\tdepends on SPL_DM\n\tselect SPL_FIT\n\tselect SPL_CRYPTO_SUPPORT\n\tselect SPL_HASH_SUPPORT\n\tselect SPL_RSA\n\tselect SPL_RSA_VERIFY\n\tselect SPL_IMAGE_SIGN_INFO\n\tselect SPL_FIT_FULL_CHECK\n\nconfig SPL_LOAD_FIT\n\tbool \"Enable SPL loading U-Boot as a FIT (basic fitImage features)\"\n\tselect SPL_FIT\n\thelp\n\t  Normally with the SPL framework a legacy image is generated as part\n\t  of the build. This contains U-Boot along with information as to\n\t  where it should be loaded. This option instead enables generation\n\t  of a FIT (Flat Image Tree) which provides more flexibility. In\n\t  particular it can handle selecting from multiple device tree\n\t  and passing the correct one to U-Boot.\n\nconfig SPL_LOAD_FIT_ADDRESS\n\thex \"load address of fit image\"\n\tdepends on SPL_LOAD_FIT\n\tdefault 0x0\n\thelp\n\t  Specify the load address of the fit image that will be loaded\n\t  by SPL.\n\nconfig SPL_LOAD_FIT_APPLY_OVERLAY\n\tbool \"Enable SPL applying DT overlays from FIT\"\n\tdepends on SPL_LOAD_FIT\n\tselect OF_LIBFDT_OVERLAY\n\thelp\n\t  The device tree is loaded from the FIT image. Allow the SPL is to\n\t  also load device-tree overlays from the FIT image an apply them\n\t  over the device tree.\n\nconfig SPL_LOAD_FIT_APPLY_OVERLAY_BUF_SZ\n\tdepends on SPL_LOAD_FIT_APPLY_OVERLAY\n\tdefault 0x10000\n\thex \"size of temporary buffer used to load the overlays\"\n\thelp\n\t  The size of the area where the overlays will be loaded and\n\t  uncompress. Must be at least as large as biggest overlay\n\t  (uncompressed)\n\nconfig SPL_LOAD_FIT_FULL\n\tbool \"Enable SPL loading U-Boot as a FIT (full fitImage features)\"\n\tselect SPL_FIT\n\thelp\n\t  Normally with the SPL framework a legacy image is generated as part\n\t  of the build. This contains U-Boot along with information as to\n\t  where it should be loaded. This option instead enables generation\n\t  of a FIT (Flat Image Tree) which provides more flexibility. In\n\t  particular it can handle selecting from multiple device tree\n\t  and passing the correct one to U-Boot.\n\nconfig SPL_FIT_IMAGE_POST_PROCESS\n\tbool \"Enable post-processing of FIT artifacts after loading by the SPL\"\n\tdepends on SPL_LOAD_FIT\n\thelp\n\t  Allows doing any sort of manipulation to blobs after they got extracted\n\t  from the U-Boot FIT image like stripping off headers or modifying the\n\t  size of the blob, verification, authentication, decryption etc. in a\n\t  platform or board specific way. In order to use this feature a platform\n\t  or board-specific implementation of board_fit_image_post_process() must\n\t  be provided. Also, anything done during this post-processing step would\n\t  need to be comprehended in how the images were prepared before being\n\t  injected into the FIT creation (i.e. the blobs would have been pre-\n\t  processed before being added to the FIT image).\n\nconfig SPL_FIT_SOURCE\n\tstring \".its source file for U-Boot FIT image\"\n\tdepends on SPL_FIT\n\thelp\n\t  Specifies a (platform specific) FIT source file to generate the\n\t  U-Boot FIT image. This could specify further image to load and/or\n\t  execute.\n\nconfig USE_SPL_FIT_GENERATOR\n\tbool \"Use a script to generate the .its script\"\n\tdefault y if SPL_FIT && !ARCH_SUNXI\n\nconfig SPL_FIT_GENERATOR\n\tstring \".its file generator script for U-Boot FIT image\"\n\tdepends on USE_SPL_FIT_GENERATOR\n\tdefault \"arch/arm/mach-rockchip/make_fit_atf.py\" if SPL_LOAD_FIT && ARCH_ROCKCHIP\n\tdefault \"arch/arm/mach-zynqmp/mkimage_fit_atf.sh\" if SPL_LOAD_FIT && ARCH_ZYNQMP\n\tdefault \"arch/riscv/lib/mkimage_fit_opensbi.sh\" if SPL_LOAD_FIT && RISCV\n\thelp\n\t  Specifies a (platform specific) script file to generate the FIT\n\t  source file used to build the U-Boot FIT image file. This gets\n\t  passed a list of supported device tree file stub names to\n\t  include in the generated image.\n\nendif # SPL\n\nendif # FIT\n\nconfig LEGACY_IMAGE_FORMAT\n\tbool \"Enable support for the legacy image format\"\n\tdefault y if !FIT_SIGNATURE\n\thelp\n\t  This option enables the legacy image format. It is enabled by\n\t  default for backward compatibility, unless FIT_SIGNATURE is\n\t  set where it is disabled so that unsigned images cannot be\n\t  loaded. If a board needs the legacy image format support in this\n\t  case, enable it here.\n\nconfig SUPPORT_RAW_INITRD\n\tbool \"Enable raw initrd images\"\n\thelp\n\t  Note, defining the SUPPORT_RAW_INITRD allows user to supply\n\t  kernel with raw initrd images. The syntax is slightly different, the\n\t  address of the initrd must be augmented by it's size, in the following\n\t  format: \"<initrd address>:<initrd size>\".\n\nconfig OF_BOARD_SETUP\n\tbool \"Set up board-specific details in device tree before boot\"\n\tdepends on OF_LIBFDT\n\thelp\n\t  This causes U-Boot to call ft_board_setup() before booting into\n\t  the Operating System. This function can set up various\n\t  board-specific information in the device tree for use by the OS.\n\t  The device tree is then passed to the OS.\n\nconfig OF_SYSTEM_SETUP\n\tbool \"Set up system-specific details in device tree before boot\"\n\tdepends on OF_LIBFDT\n\thelp\n\t  This causes U-Boot to call ft_system_setup() before booting into\n\t  the Operating System. This function can set up various\n\t  system-specific information in the device tree for use by the OS.\n\t  The device tree is then passed to the OS.\n\nconfig OF_STDOUT_VIA_ALIAS\n\tbool \"Update the device-tree stdout alias from U-Boot\"\n\tdepends on OF_LIBFDT\n\thelp\n\t  This uses U-Boot's serial alias from the aliases node to update\n\t  the device tree passed to the OS. The \"linux,stdout-path\" property\n\t  in the chosen node is set to point to the correct serial node.\n\t  This option currently references CONFIG_CONS_INDEX, which is\n\t  incorrect when used with device tree as this option does not\n\t  exist / should not be used.\n\nconfig SYS_EXTRA_OPTIONS\n\tstring \"Extra Options (DEPRECATED)\"\n\thelp\n\t  The old configuration infrastructure (= mkconfig + boards.cfg)\n\t  provided the extra options field. If you have something like\n\t  \"HAS_BAR,BAZ=64\", the optional options\n\t    #define CONFIG_HAS\n\t    #define CONFIG_BAZ\t64\n\t  will be defined in include/config.h.\n\t  This option was prepared for the smooth migration from the old\n\t  configuration to Kconfig. Since this option will be removed sometime,\n\t  new boards should not use this option.\n\nconfig HAVE_SYS_TEXT_BASE\n\tbool\n\tdepends on !NIOS2 && !XTENSA\n\tdepends on !EFI_APP\n\tdefault y\n\nconfig SYS_TEXT_BASE\n\tdepends on HAVE_SYS_TEXT_BASE\n\tdefault 0x80800000 if ARCH_OMAP2PLUS || ARCH_K3\n\tdefault 0x4a000000 if ARCH_SUNXI && !MACH_SUN9I && !MACH_SUN8I_V3S\n\tdefault 0x2a000000 if ARCH_SUNXI && MACH_SUN9I\n\tdefault 0x42e00000 if ARCH_SUNXI && MACH_SUN8I_V3S\n\thex \"Text Base\"\n\thelp\n\t  The address in memory that U-Boot will be running from, initially.\n\nconfig SYS_CLK_FREQ\n\tdepends on ARC || ARCH_SUNXI || MPC83xx\n\tint \"CPU clock frequency\"\n\thelp\n\t  TODO: Move CONFIG_SYS_CLK_FREQ for all the architecture\n\nconfig ARCH_FIXUP_FDT_MEMORY\n\tbool \"Enable arch_fixup_memory_banks() call\"\n\tdefault y\n\thelp\n\t  Enable FDT memory map syncup before OS boot. This feature can be\n\t  used for booting OS with different memory setup where the part of\n\t  the memory location should be used for different purpose.\n\nconfig CHROMEOS\n\tbool \"Support booting Chrome OS\"\n\thelp\n\t  Chrome OS requires U-Boot to set up a table indicating the boot mode\n\t  (e.g. Developer mode) and a few other things. Enable this if you are\n\t  booting on a Chromebook to avoid getting an error about an invalid\n\t  firmware ID.\n\nconfig CHROMEOS_VBOOT\n\tbool \"Support Chrome OS verified boot\"\n\thelp\n\t  This is intended to enable the full Chrome OS verified boot support\n\t  in U-Boot. It is not actually implemented in the U-Boot source code\n\t  at present, so this option is always set to 'n'. It allows\n\t  distinguishing between booting Chrome OS in a basic way (developer\n\t  mode) and a full boot.\n\nendmenu\t\t# Boot images\n\nmenu \"Boot timing\"\n\nconfig BOOTSTAGE\n\tbool \"Boot timing and reporting\"\n\thelp\n\t  Enable recording of boot time while booting. To use it, insert\n\t  calls to bootstage_mark() with a suitable BOOTSTAGE_ID from\n\t  bootstage.h. Only a single entry is recorded for each ID. You can\n\t  give the entry a name with bootstage_mark_name(). You can also\n\t  record elapsed time in a particular stage using bootstage_start()\n\t  before starting and bootstage_accum() when finished. Bootstage will\n\t  add up all the accumulated time and report it.\n\n\t  Normally, IDs are defined in bootstage.h but a small number of\n\t  additional 'user' IDs can be used by passing BOOTSTAGE_ID_ALLOC\n\t  as the ID.\n\n\t  Calls to show_boot_progress() will also result in log entries but\n\t  these will not have names.\n\nconfig SPL_BOOTSTAGE\n\tbool \"Boot timing and reported in SPL\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Enable recording of boot time in SPL. To make this visible to U-Boot\n\t  proper, enable BOOTSTAGE_STASH as well. This will stash the timing\n\t  information when SPL finishes and load it when U-Boot proper starts\n\t  up.\n\nconfig TPL_BOOTSTAGE\n\tbool \"Boot timing and reported in TPL\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Enable recording of boot time in SPL. To make this visible to U-Boot\n\t  proper, enable BOOTSTAGE_STASH as well. This will stash the timing\n\t  information when TPL finishes and load it when U-Boot proper starts\n\t  up.\n\nconfig BOOTSTAGE_REPORT\n\tbool \"Display a detailed boot timing report before booting the OS\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Enable output of a boot time report just before the OS is booted.\n\t  This shows how long it took U-Boot to go through each stage of the\n\t  boot process. The report looks something like this:\n\n\t\tTimer summary in microseconds:\n\t\t       Mark    Elapsed  Stage\n\t\t\t  0          0  reset\n\t\t  3,575,678  3,575,678  board_init_f start\n\t\t  3,575,695         17  arch_cpu_init A9\n\t\t  3,575,777         82  arch_cpu_init done\n\t\t  3,659,598     83,821  board_init_r start\n\t\t  3,910,375    250,777  main_loop\n\t\t 29,916,167 26,005,792  bootm_start\n\t\t 30,361,327    445,160  start_kernel\n\nconfig BOOTSTAGE_RECORD_COUNT\n\tint \"Number of boot stage records to store\"\n\tdefault 30\n\thelp\n\t  This is the size of the bootstage record list and is the maximum\n\t  number of bootstage records that can be recorded.\n\nconfig SPL_BOOTSTAGE_RECORD_COUNT\n\tint \"Number of boot stage records to store for SPL\"\n\tdefault 5\n\thelp\n\t  This is the size of the bootstage record list and is the maximum\n\t  number of bootstage records that can be recorded.\n\nconfig TPL_BOOTSTAGE_RECORD_COUNT\n\tint \"Number of boot stage records to store for TPL\"\n\tdefault 5\n\thelp\n\t  This is the size of the bootstage record list and is the maximum\n\t  number of bootstage records that can be recorded.\n\nconfig BOOTSTAGE_FDT\n\tbool \"Store boot timing information in the OS device tree\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Stash the bootstage information in the FDT. A root 'bootstage'\n\t  node is created with each bootstage id as a child. Each child\n\t  has a 'name' property and either 'mark' containing the\n\t  mark time in microseconds, or 'accum' containing the\n\t  accumulated time for that bootstage id in microseconds.\n\t  For example:\n\n\t\tbootstage {\n\t\t\t154 {\n\t\t\t\tname = \"board_init_f\";\n\t\t\t\tmark = <3575678>;\n\t\t\t};\n\t\t\t170 {\n\t\t\t\tname = \"lcd\";\n\t\t\t\taccum = <33482>;\n\t\t\t};\n\t\t};\n\n\t  Code in the Linux kernel can find this in /proc/devicetree.\n\nconfig BOOTSTAGE_STASH\n\tbool \"Stash the boot timing information in memory before booting OS\"\n\tdepends on BOOTSTAGE\n\thelp\n\t  Some OSes do not support device tree. Bootstage can instead write\n\t  the boot timing information in a binary format at a given address.\n\t  This happens through a call to bootstage_stash(), typically in\n\t  the CPU's cleanup_before_linux() function. You can use the\n\t  'bootstage stash' and 'bootstage unstash' commands to do this on\n\t  the command line.\n\nconfig BOOTSTAGE_STASH_ADDR\n\thex \"Address to stash boot timing information\"\n\tdefault 0\n\thelp\n\t  Provide an address which will not be overwritten by the OS when it\n\t  starts, so that it can read this information when ready.\n\nconfig BOOTSTAGE_STASH_SIZE\n\thex \"Size of boot timing stash region\"\n\tdefault 0x1000\n\thelp\n\t  This should be large enough to hold the bootstage stash. A value of\n\t  4096 (4KiB) is normally plenty.\n\nconfig SHOW_BOOT_PROGRESS\n\tbool \"Show boot progress in a board-specific manner\"\n\thelp\n\t  Defining this option allows to add some board-specific code (calling\n\t  a user-provided function show_boot_progress(int) that enables you to\n\t  show the system's boot progress on some display (for example, some\n\t  LEDs) on your board. At the moment, the following checkpoints are\n\t  implemented:\n\n\t  Legacy uImage format:\n\n\t  Arg\tWhere\t\t\tWhen\n\t    1\tcommon/cmd_bootm.c\tbefore attempting to boot an image\n\t   -1\tcommon/cmd_bootm.c\tImage header has bad\t magic number\n\t    2\tcommon/cmd_bootm.c\tImage header has correct magic number\n\t   -2\tcommon/cmd_bootm.c\tImage header has bad\t checksum\n\t    3\tcommon/cmd_bootm.c\tImage header has correct checksum\n\t   -3\tcommon/cmd_bootm.c\tImage data   has bad\t checksum\n\t    4\tcommon/cmd_bootm.c\tImage data   has correct checksum\n\t   -4\tcommon/cmd_bootm.c\tImage is for unsupported architecture\n\t    5\tcommon/cmd_bootm.c\tArchitecture check OK\n\t   -5\tcommon/cmd_bootm.c\tWrong Image Type (not kernel, multi)\n\t    6\tcommon/cmd_bootm.c\tImage Type check OK\n\t   -6\tcommon/cmd_bootm.c\tgunzip uncompression error\n\t   -7\tcommon/cmd_bootm.c\tUnimplemented compression type\n\t    7\tcommon/cmd_bootm.c\tUncompression OK\n\t    8\tcommon/cmd_bootm.c\tNo uncompress/copy overwrite error\n\t   -9\tcommon/cmd_bootm.c\tUnsupported OS (not Linux, BSD, VxWorks, QNX)\n\n\t    9\tcommon/image.c\t\tStart initial ramdisk verification\n\t  -10\tcommon/image.c\t\tRamdisk header has bad\t   magic number\n\t  -11\tcommon/image.c\t\tRamdisk header has bad\t   checksum\n\t   10\tcommon/image.c\t\tRamdisk header is OK\n\t  -12\tcommon/image.c\t\tRamdisk data   has bad\t   checksum\n\t   11\tcommon/image.c\t\tRamdisk data   has correct checksum\n\t   12\tcommon/image.c\t\tRamdisk verification complete, start loading\n\t  -13\tcommon/image.c\t\tWrong Image Type (not PPC Linux ramdisk)\n\t   13\tcommon/image.c\t\tStart multifile image verification\n\t   14\tcommon/image.c\t\tNo initial ramdisk, no multifile, continue.\n\n\t   15\tarch/<arch>/lib/bootm.c All preparation done, transferring control to OS\n\n\t  -30\tarch/powerpc/lib/board.c\tFatal error, hang the system\n\t  -31\tpost/post.c\t\tPOST test failed, detected by post_output_backlog()\n\t  -32\tpost/post.c\t\tPOST test failed, detected by post_run_single()\n\n\t   34\tcommon/cmd_doc.c\tbefore loading a Image from a DOC device\n\t  -35\tcommon/cmd_doc.c\tBad usage of \"doc\" command\n\t   35\tcommon/cmd_doc.c\tcorrect usage of \"doc\" command\n\t  -36\tcommon/cmd_doc.c\tNo boot device\n\t   36\tcommon/cmd_doc.c\tcorrect boot device\n\t  -37\tcommon/cmd_doc.c\tUnknown Chip ID on boot device\n\t   37\tcommon/cmd_doc.c\tcorrect chip ID found, device available\n\t  -38\tcommon/cmd_doc.c\tRead Error on boot device\n\t   38\tcommon/cmd_doc.c\treading Image header from DOC device OK\n\t  -39\tcommon/cmd_doc.c\tImage header has bad magic number\n\t   39\tcommon/cmd_doc.c\tImage header has correct magic number\n\t  -40\tcommon/cmd_doc.c\tError reading Image from DOC device\n\t   40\tcommon/cmd_doc.c\tImage header has correct magic number\n\t   41\tcommon/cmd_ide.c\tbefore loading a Image from a IDE device\n\t  -42\tcommon/cmd_ide.c\tBad usage of \"ide\" command\n\t   42\tcommon/cmd_ide.c\tcorrect usage of \"ide\" command\n\t  -43\tcommon/cmd_ide.c\tNo boot device\n\t   43\tcommon/cmd_ide.c\tboot device found\n\t  -44\tcommon/cmd_ide.c\tDevice not available\n\t   44\tcommon/cmd_ide.c\tDevice available\n\t  -45\tcommon/cmd_ide.c\twrong partition selected\n\t   45\tcommon/cmd_ide.c\tpartition selected\n\t  -46\tcommon/cmd_ide.c\tUnknown partition table\n\t   46\tcommon/cmd_ide.c\tvalid partition table found\n\t  -47\tcommon/cmd_ide.c\tInvalid partition type\n\t   47\tcommon/cmd_ide.c\tcorrect partition type\n\t  -48\tcommon/cmd_ide.c\tError reading Image Header on boot device\n\t   48\tcommon/cmd_ide.c\treading Image Header from IDE device OK\n\t  -49\tcommon/cmd_ide.c\tImage header has bad magic number\n\t   49\tcommon/cmd_ide.c\tImage header has correct magic number\n\t  -50\tcommon/cmd_ide.c\tImage header has bad\t checksum\n\t   50\tcommon/cmd_ide.c\tImage header has correct checksum\n\t  -51\tcommon/cmd_ide.c\tError reading Image from IDE device\n\t   51\tcommon/cmd_ide.c\treading Image from IDE device OK\n\t   52\tcommon/cmd_nand.c\tbefore loading a Image from a NAND device\n\t  -53\tcommon/cmd_nand.c\tBad usage of \"nand\" command\n\t   53\tcommon/cmd_nand.c\tcorrect usage of \"nand\" command\n\t  -54\tcommon/cmd_nand.c\tNo boot device\n\t   54\tcommon/cmd_nand.c\tboot device found\n\t  -55\tcommon/cmd_nand.c\tUnknown Chip ID on boot device\n\t   55\tcommon/cmd_nand.c\tcorrect chip ID found, device available\n\t  -56\tcommon/cmd_nand.c\tError reading Image Header on boot device\n\t   56\tcommon/cmd_nand.c\treading Image Header from NAND device OK\n\t  -57\tcommon/cmd_nand.c\tImage header has bad magic number\n\t   57\tcommon/cmd_nand.c\tImage header has correct magic number\n\t  -58\tcommon/cmd_nand.c\tError reading Image from NAND device\n\t   58\tcommon/cmd_nand.c\treading Image from NAND device OK\n\n\t  -60\tcommon/env_common.c\tEnvironment has a bad CRC, using default\n\n\t   64\tnet/eth.c\t\tstarting with Ethernet configuration.\n\t  -64\tnet/eth.c\t\tno Ethernet found.\n\t   65\tnet/eth.c\t\tEthernet found.\n\n\t  -80\tcommon/cmd_net.c\tusage wrong\n\t   80\tcommon/cmd_net.c\tbefore calling net_loop()\n\t  -81\tcommon/cmd_net.c\tsome error in net_loop() occurred\n\t   81\tcommon/cmd_net.c\tnet_loop() back without error\n\t  -82\tcommon/cmd_net.c\tsize == 0 (File with size 0 loaded)\n\t   82\tcommon/cmd_net.c\ttrying automatic boot\n\t   83\tcommon/cmd_net.c\trunning \"source\" command\n\t  -83\tcommon/cmd_net.c\tsome error in automatic boot or \"source\" command\n\t   84\tcommon/cmd_net.c\tend without errors\n\n\t  FIT uImage format:\n\n\t  Arg\tWhere\t\t\tWhen\n\t  100\tcommon/cmd_bootm.c\tKernel FIT Image has correct format\n\t  -100\tcommon/cmd_bootm.c\tKernel FIT Image has incorrect format\n\t  101\tcommon/cmd_bootm.c\tNo Kernel subimage unit name, using configuration\n\t  -101\tcommon/cmd_bootm.c\tCan't get configuration for kernel subimage\n\t  102\tcommon/cmd_bootm.c\tKernel unit name specified\n\t  -103\tcommon/cmd_bootm.c\tCan't get kernel subimage node offset\n\t  103\tcommon/cmd_bootm.c\tFound configuration node\n\t  104\tcommon/cmd_bootm.c\tGot kernel subimage node offset\n\t  -104\tcommon/cmd_bootm.c\tKernel subimage hash verification failed\n\t  105\tcommon/cmd_bootm.c\tKernel subimage hash verification OK\n\t  -105\tcommon/cmd_bootm.c\tKernel subimage is for unsupported architecture\n\t  106\tcommon/cmd_bootm.c\tArchitecture check OK\n\t  -106\tcommon/cmd_bootm.c\tKernel subimage has wrong type\n\t  107\tcommon/cmd_bootm.c\tKernel subimage type OK\n\t  -107\tcommon/cmd_bootm.c\tCan't get kernel subimage data/size\n\t  108\tcommon/cmd_bootm.c\tGot kernel subimage data/size\n\t  -108\tcommon/cmd_bootm.c\tWrong image type (not legacy, FIT)\n\t  -109\tcommon/cmd_bootm.c\tCan't get kernel subimage type\n\t  -110\tcommon/cmd_bootm.c\tCan't get kernel subimage comp\n\t  -111\tcommon/cmd_bootm.c\tCan't get kernel subimage os\n\t  -112\tcommon/cmd_bootm.c\tCan't get kernel subimage load address\n\t  -113\tcommon/cmd_bootm.c\tImage uncompress/copy overwrite error\n\n\t  120\tcommon/image.c\t\tStart initial ramdisk verification\n\t  -120\tcommon/image.c\t\tRamdisk FIT image has incorrect format\n\t  121\tcommon/image.c\t\tRamdisk FIT image has correct format\n\t  122\tcommon/image.c\t\tNo ramdisk subimage unit name, using configuration\n\t  -122\tcommon/image.c\t\tCan't get configuration for ramdisk subimage\n\t  123\tcommon/image.c\t\tRamdisk unit name specified\n\t  -124\tcommon/image.c\t\tCan't get ramdisk subimage node offset\n\t  125\tcommon/image.c\t\tGot ramdisk subimage node offset\n\t  -125\tcommon/image.c\t\tRamdisk subimage hash verification failed\n\t  126\tcommon/image.c\t\tRamdisk subimage hash verification OK\n\t  -126\tcommon/image.c\t\tRamdisk subimage for unsupported architecture\n\t  127\tcommon/image.c\t\tArchitecture check OK\n\t  -127\tcommon/image.c\t\tCan't get ramdisk subimage data/size\n\t  128\tcommon/image.c\t\tGot ramdisk subimage data/size\n\t  129\tcommon/image.c\t\tCan't get ramdisk load address\n\t  -129\tcommon/image.c\t\tGot ramdisk load address\n\n\t  -130\tcommon/cmd_doc.c\tIncorrect FIT image format\n\t  131\tcommon/cmd_doc.c\tFIT image format OK\n\n\t  -140\tcommon/cmd_ide.c\tIncorrect FIT image format\n\t  141\tcommon/cmd_ide.c\tFIT image format OK\n\n\t  -150\tcommon/cmd_nand.c\tIncorrect FIT image format\n\t  151\tcommon/cmd_nand.c\tFIT image format OK\n\nendmenu\n\nmenu \"Boot media\"\n\nconfig NOR_BOOT\n\tbool \"Support for booting from NOR flash\"\n\tdepends on NOR\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via NOR.  In this case we will enable certain pinmux early\n\t  as the ROM only partially sets up pinmux.  We also default to using\n\t  NOR for environment.\n\nconfig NAND_BOOT\n\tbool \"Support for booting from NAND flash\"\n\tdefault n\n\timply MTD_RAW_NAND\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via NAND flash. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig ONENAND_BOOT\n\tbool \"Support for booting from ONENAND\"\n\tdefault n\n\timply MTD_RAW_NAND\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via ONENAND. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig QSPI_BOOT\n\tbool \"Support for booting from QSPI flash\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via QSPI flash. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig SATA_BOOT\n\tbool \"Support for booting from SATA\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via SATA. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig SD_BOOT\n\tbool \"Support for booting from SD/EMMC\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via SD/EMMC. This is not a must, some SoCs need this,\n\t  some not.\n\nconfig SPI_BOOT\n\tbool \"Support for booting from SPI flash\"\n\tdefault n\n\thelp\n\t  Enabling this will make a U-Boot binary that is capable of being\n\t  booted via SPI flash. This is not a must, some SoCs need this,\n\t  some not.\n\nendmenu\n\nmenu \"Autoboot options\"\n\nconfig AUTOBOOT\n\tbool \"Autoboot\"\n\tdefault y\n\thelp\n\t  This enables the autoboot.  See doc/README.autoboot for detail.\n\nconfig BOOTDELAY\n\tint \"delay in seconds before automatically booting\"\n\tdefault 2\n\tdepends on AUTOBOOT\n\thelp\n\t  Delay before automatically running bootcmd;\n\t  set to 0 to autoboot with no delay, but you can stop it by key input.\n\t  set to -1 to disable autoboot.\n\t  set to -2 to autoboot with no delay and not check for abort\n\n\t  If this value is >= 0 then it is also used for the default delay\n\t  before starting the default entry in bootmenu. If it is < 0 then\n\t  a default value of 10s is used.\n\n\t  See doc/README.autoboot for details.\n\nconfig AUTOBOOT_KEYED\n\tbool \"Stop autobooting via specific input key / string\"\n\tdefault n\n\thelp\n\t  This option enables stopping (aborting) of the automatic\n\t  boot feature only by issuing a specific input key or\n\t  string. If not enabled, any input key will abort the\n\t  U-Boot automatic booting process and bring the device\n\t  to the U-Boot prompt for user input.\n\nconfig AUTOBOOT_PROMPT\n\tstring \"Autoboot stop prompt\"\n\tdepends on AUTOBOOT_KEYED\n\tdefault \"Autoboot in %d seconds\\\\n\"\n\thelp\n\t  This string is displayed before the boot delay selected by\n\t  CONFIG_BOOTDELAY starts. If it is not defined\tthere is no\n\t  output indicating that autoboot is in progress.\n\n\t  Note that this define is used as the (only) argument to a\n\t  printf() call, so it may contain '%' format specifications,\n\t  provided that it also includes, sepearated by commas exactly\n\t  like in a printf statement, the required arguments. It is\n\t  the responsibility of the user to select only such arguments\n\t  that are valid in the given context.\n\nconfig AUTOBOOT_ENCRYPTION\n\tbool \"Enable encryption in autoboot stopping\"\n\tdepends on AUTOBOOT_KEYED\n\thelp\n\t  This option allows a string to be entered into U-Boot to stop the\n\t  autoboot. The string itself is hashed and compared against the hash\n\t  in the environment variable 'bootstopkeysha256'. If it matches then\n\t  boot stops and a command-line prompt is presented.\n\n\t  This provides a way to ship a secure production device which can also\n\t  be accessed at the U-Boot command line.\n\nconfig AUTOBOOT_DELAY_STR\n\tstring \"Delay autobooting via specific input key / string\"\n\tdepends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION\n\thelp\n\t  This option delays the automatic boot feature by issuing\n\t  a specific input key or string. If CONFIG_AUTOBOOT_DELAY_STR\n\t  or the environment variable \"bootdelaykey\" is specified\n\t  and this string is received from console input before\n\t  autoboot starts booting, U-Boot gives a command prompt. The\n\t  U-Boot prompt will time out if CONFIG_BOOT_RETRY_TIME is\n\t  used, otherwise it never times out.\n\nconfig AUTOBOOT_STOP_STR\n\tstring \"Stop autobooting via specific input key / string\"\n\tdepends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION\n\thelp\n\t  This option enables stopping (aborting) of the automatic\n\t  boot feature only by issuing a specific input key or\n\t  string. If CONFIG_AUTOBOOT_STOP_STR or the environment\n\t  variable \"bootstopkey\" is specified and this string is\n\t  received from console input before autoboot starts booting,\n\t  U-Boot gives a command prompt. The U-Boot prompt never\n\t  times out, even if CONFIG_BOOT_RETRY_TIME is used.\n\nconfig AUTOBOOT_KEYED_CTRLC\n\tbool \"Enable Ctrl-C autoboot interruption\"\n\tdepends on AUTOBOOT_KEYED && !AUTOBOOT_ENCRYPTION\n\tdefault n\n\thelp\n\t  This option allows for the boot sequence to be interrupted\n\t  by ctrl-c, in addition to the \"bootdelaykey\" and \"bootstopkey\".\n\t  Setting this variable\tprovides an escape sequence from the\n\t  limited \"password\" strings.\n\nconfig AUTOBOOT_STOP_STR_SHA256\n\tstring \"Stop autobooting via SHA256 encrypted password\"\n\tdepends on AUTOBOOT_KEYED && AUTOBOOT_ENCRYPTION\n\thelp\n\t  This option adds the feature to only stop the autobooting,\n\t  and therefore boot into the U-Boot prompt, when the input\n\t  string / password matches a values that is encypted via\n\t  a SHA256 hash and saved in the environment variable\n\t  \"bootstopkeysha256\". If the value in that variable\n\t  includes a \":\", the portion prior to the \":\" will be treated\n\t  as a salt value.\n\nconfig AUTOBOOT_USE_MENUKEY\n\tbool \"Allow a specify key to run a menu from the environment\"\n\tdepends on !AUTOBOOT_KEYED\n\thelp\n\t  If a specific key is pressed to stop autoboot, then the commands in\n\t  the environment variable 'menucmd' are executed before boot starts.\n\nconfig AUTOBOOT_MENUKEY\n\tint \"ASCII value of boot key to show a menu\"\n\tdefault 0\n\tdepends on AUTOBOOT_USE_MENUKEY\n\thelp\n\t  If this key is pressed to stop autoboot, then the commands in the\n\t  environment variable 'menucmd' will be executed before boot starts.\n\t  For example, 33 means \"!\" in ASCII, so pressing ! at boot would take\n\t  this action.\n\nconfig AUTOBOOT_MENU_SHOW\n\tbool \"Show a menu on boot\"\n\tdepends on CMD_BOOTMENU\n\thelp\n\t  This enables the boot menu, controlled by environment variables\n\t  defined by the board. The menu starts after running the 'preboot'\n\t  environmnent variable (if enabled) and before handling the boot delay.\n\t  See README.bootmenu for more details.\n\nendmenu\n\nconfig USE_BOOTARGS\n\tbool \"Enable boot arguments\"\n\thelp\n\t  Provide boot arguments to bootm command. Boot arguments are specified\n\t  in CONFIG_BOOTARGS option. Enable this option to be able to specify\n\t  CONFIG_BOOTARGS string. If this option is disabled, CONFIG_BOOTARGS\n\t  will be undefined and won't take any space in U-Boot image.\n\nconfig BOOTARGS\n\tstring \"Boot arguments\"\n\tdepends on USE_BOOTARGS && !USE_DEFAULT_ENV_FILE\n\thelp\n\t  This can be used to pass arguments to the bootm command. The value of\n\t  CONFIG_BOOTARGS goes into the environment value \"bootargs\". Note that\n\t  this value will also override the \"chosen\" node in FDT blob.\n\nconfig BOOTARGS_SUBST\n\tbool \"Support substituting strings in boot arguments\"\n\thelp\n\t  This allows substituting string values in the boot arguments. These\n\t  are applied after the commandline has been built.\n\n\t  One use for this is to insert the root-disk UUID into the command\n\t  line where bootargs contains \"root=${uuid}\"\n\n\t\tsetenv bootargs \"console= root=${uuid}\"\n\t\t# Set the 'uuid' environment variable\n\t\tpart uuid mmc 2:2 uuid\n\n\t\t# Command-line substitution will put the real uuid into the\n\t\t# kernel command line\n\t\tbootm\n\nconfig USE_BOOTCOMMAND\n\tbool \"Enable a default value for bootcmd\"\n\thelp\n\t  Provide a default value for the bootcmd entry in the environment.  If\n\t  autoboot is enabled this is what will be run automatically.  Enable\n\t  this option to be able to specify CONFIG_BOOTCOMMAND as a string.  If\n\t  this option is disabled, CONFIG_BOOTCOMMAND will be undefined and\n\t  won't take any space in U-Boot image.\n\nconfig BOOTCOMMAND\n\tstring \"bootcmd value\"\n\tdepends on USE_BOOTCOMMAND && !USE_DEFAULT_ENV_FILE\n\tdefault \"run distro_bootcmd\" if DISTRO_DEFAULTS\n\thelp\n\t  This is the string of commands that will be used as bootcmd and if\n\t  AUTOBOOT is set, automatically run.\n\nconfig USE_PREBOOT\n\tbool \"Enable preboot\"\n\thelp\n\t  When this option is enabled, the existence of the environment\n\t  variable \"preboot\" will be checked immediately before starting the\n\t  CONFIG_BOOTDELAY countdown and/or running the auto-boot command resp.\n\t  entering interactive mode.\n\n\t  This feature is especially useful when \"preboot\" is automatically\n\t  generated or modified. For example, the boot code can modify the\n\t  \"preboot\" when a user holds down a certain combination of keys.\n\nconfig PREBOOT\n\tstring \"preboot default value\"\n\tdepends on USE_PREBOOT && !USE_DEFAULT_ENV_FILE\n\tdefault \"usb start\" if USB_KEYBOARD\n\tdefault \"\"\n\thelp\n\t  This is the default of \"preboot\" environment variable.\n\nconfig DEFAULT_FDT_FILE\n\tstring \"Default fdt file\"\n\thelp\n\t  This option is used to set the default fdt file to boot OS.\n\nendmenu\t\t# Booting\n", "// SPDX-License-Identifier: GPL-2.0+\n/*\n * Copyright (c) 2013, Google Inc.\n *\n * (C) Copyright 2008 Semihalf\n *\n * (C) Copyright 2000-2006\n * Wolfgang Denk, DENX Software Engineering, wd@denx.de.\n */\n\n#define LOG_CATEGORY LOGC_BOOT\n\n#ifdef USE_HOSTCC\n#include \"mkimage.h\"\n#include <time.h>\n#include <linux/libfdt.h>\n#include <u-boot/crc.h>\n#else\n#include <linux/compiler.h>\n#include <common.h>\n#include <errno.h>\n#include <log.h>\n#include <mapmem.h>\n#include <asm/io.h>\n#include <malloc.h>\n#include <asm/global_data.h>\nDECLARE_GLOBAL_DATA_PTR;\n#endif /* !USE_HOSTCC*/\n\n#include <bootm.h>\n#include <image.h>\n#include <bootstage.h>\n#include <linux/kconfig.h>\n#include <u-boot/crc.h>\n#include <u-boot/md5.h>\n#include <u-boot/sha1.h>\n#include <u-boot/sha256.h>\n#include <u-boot/sha512.h>\n\n/*****************************************************************************/\n/* New uImage format routines */\n/*****************************************************************************/\n#ifndef USE_HOSTCC\nstatic int fit_parse_spec(const char *spec, char sepc, ulong addr_curr,\n\t\tulong *addr, const char **name)\n{\n\tconst char *sep;\n\n\t*addr = addr_curr;\n\t*name = NULL;\n\n\tsep = strchr(spec, sepc);\n\tif (sep) {\n\t\tif (sep - spec > 0)\n\t\t\t*addr = simple_strtoul(spec, NULL, 16);\n\n\t\t*name = sep + 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_parse_conf - parse FIT configuration spec\n * @spec: input string, containing configuration spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * configuration\n * @conf_name double pointer to a char, will hold pointer to a configuration\n * unit name\n *\n * fit_parse_conf() expects configuration spec in the form of [<addr>]#<conf>,\n * where <addr> is a FIT image address that contains configuration\n * with a <conf> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid configuration string,\n *     addr and conf_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_conf(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **conf_name)\n{\n\treturn fit_parse_spec(spec, '#', addr_curr, addr, conf_name);\n}\n\n/**\n * fit_parse_subimage - parse FIT subimage spec\n * @spec: input string, containing subimage spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * subimage\n * @image_name: double pointer to a char, will hold pointer to a subimage name\n *\n * fit_parse_subimage() expects subimage spec in the form of\n * [<addr>]:<subimage>, where <addr> is a FIT image address that contains\n * subimage with a <subimg> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid subimage string,\n *     addr and image_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_subimage(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **image_name)\n{\n\treturn fit_parse_spec(spec, ':', addr_curr, addr, image_name);\n}\n#endif /* !USE_HOSTCC */\n\n#ifdef USE_HOSTCC\n/* Host tools use these implementations for Cipher and Signature support */\nstatic void *host_blob;\n\nvoid image_set_host_blob(void *blob)\n{\n\thost_blob = blob;\n}\n\nvoid *image_get_host_blob(void)\n{\n\treturn host_blob;\n}\n#endif /* USE_HOSTCC */\n\nstatic void fit_get_debug(const void *fit, int noffset,\n\t\tchar *prop_name, int err)\n{\n\tdebug(\"Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)\\n\",\n\t      prop_name, (ulong)fit, noffset, fit_get_name(fit, noffset, NULL),\n\t      fdt_strerror(err));\n}\n\n/**\n * fit_get_subimage_count - get component (sub-image) count\n * @fit: pointer to the FIT format image header\n * @images_noffset: offset of images node\n *\n * returns:\n *     number of image components\n */\nint fit_get_subimage_count(const void *fit, int images_noffset)\n{\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n#if CONFIG_IS_ENABLED(FIT_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT)\n/**\n * fit_image_print_data() - prints out the hash node details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash node\n * @p: pointer to prefix string\n * @type: Type of information to print (\"hash\" or \"sign\")\n *\n * fit_image_print_data() lists properties for the processed hash node\n *\n * This function avoid using puts() since it prints a newline on the host\n * but does not in U-Boot.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_data(const void *fit, int noffset, const char *p,\n\t\t\t\t const char *type)\n{\n\tconst char *keyname;\n\tuint8_t *value;\n\tint value_len;\n\tchar *algo;\n\tconst char *padding;\n\tbool required;\n\tint ret, i;\n\n\tdebug(\"%s  %s node:    '%s'\\n\", p, type,\n\t      fit_get_name(fit, noffset, NULL));\n\tprintf(\"%s  %s algo:    \", p, type);\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\tprintf(\"invalid/unsupported\\n\");\n\t\treturn;\n\t}\n\tprintf(\"%s\", algo);\n\tkeyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);\n\trequired = fdt_getprop(fit, noffset, FIT_KEY_REQUIRED, NULL) != NULL;\n\tif (keyname)\n\t\tprintf(\":%s\", keyname);\n\tif (required)\n\t\tprintf(\" (required)\");\n\tprintf(\"\\n\");\n\n\tpadding = fdt_getprop(fit, noffset, \"padding\", NULL);\n\tif (padding)\n\t\tprintf(\"%s  %s padding: %s\\n\", p, type, padding);\n\n\tret = fit_image_hash_get_value(fit, noffset, &value,\n\t\t\t\t       &value_len);\n\tprintf(\"%s  %s value:   \", p, type);\n\tif (ret) {\n\t\tprintf(\"unavailable\\n\");\n\t} else {\n\t\tfor (i = 0; i < value_len; i++)\n\t\t\tprintf(\"%02x\", value[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tdebug(\"%s  %s len:     %d\\n\", p, type, value_len);\n\n\t/* Signatures have a time stamp */\n\tif (IMAGE_ENABLE_TIMESTAMP && keyname) {\n\t\ttime_t timestamp;\n\n\t\tprintf(\"%s  Timestamp:    \", p);\n\t\tif (fit_get_timestamp(fit, noffset, &timestamp))\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n}\n\n/**\n * fit_image_print_verification_data() - prints out the hash/signature details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash or signature node\n * @p: pointer to prefix string\n *\n * This lists properties for the processed hash node\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_verification_data(const void *fit, int noffset,\n\t\t\t\t\t      const char *p)\n{\n\tconst char *name;\n\n\t/*\n\t * Check subnode name, must be equal to \"hash\" or \"signature\".\n\t * Multiple hash/signature nodes require unique unit node\n\t * names, e.g. hash-1, hash-2, signature-1, signature-2, etc.\n\t */\n\tname = fit_get_name(fit, noffset, NULL);\n\tif (!strncmp(name, FIT_HASH_NODENAME, strlen(FIT_HASH_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Hash\");\n\t} else if (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Sign\");\n\t}\n}\n\n/**\n * fit_conf_print - prints out the FIT configuration details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the configuration node\n * @p: pointer to prefix string\n *\n * fit_conf_print() lists all mandatory properties for the processed\n * configuration node.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_conf_print(const void *fit, int noffset, const char *p)\n{\n\tchar *desc;\n\tconst char *uname;\n\tint ret;\n\tint fdt_index, loadables_index;\n\tint ndepth;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tuname = fdt_getprop(fit, noffset, FIT_KERNEL_PROP, NULL);\n\tprintf(\"%s  Kernel:       \", p);\n\tif (!uname)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", uname);\n\n\t/* Optional properties */\n\tuname = fdt_getprop(fit, noffset, FIT_RAMDISK_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Init Ramdisk: %s\\n\", p, uname);\n\n\tuname = fdt_getprop(fit, noffset, FIT_FIRMWARE_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Firmware:     %s\\n\", p, uname);\n\n\tfor (fdt_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_FDT_PROP,\n\t\t\t\t\tfdt_index, NULL), uname;\n\t     fdt_index++) {\n\t\tif (fdt_index == 0)\n\t\t\tprintf(\"%s  FDT:          \", p);\n\t\telse\n\t\t\tprintf(\"%s                \", p);\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\tuname = fdt_getprop(fit, noffset, FIT_FPGA_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  FPGA:         %s\\n\", p, uname);\n\n\t/* Print out all of the specified loadables */\n\tfor (loadables_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_LOADABLE_PROP,\n\t\t\t\t\tloadables_index, NULL), uname;\n\t     loadables_index++) {\n\t\tif (loadables_index == 0) {\n\t\t\tprintf(\"%s  Loadables:    \", p);\n\t\t} else {\n\t\t\tprintf(\"%s                \", p);\n\t\t}\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\t/* Process all hash subnodes of the component configuration node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component configuration node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_print_contents - prints out the contents of the FIT format image\n * @fit: pointer to the FIT format image header\n * @p: pointer to prefix string\n *\n * fit_print_contents() formats a multi line FIT image contents description.\n * The routine prints out FIT image properties (root node level) followed by\n * the details of each component image.\n *\n * returns:\n *     no returned results\n */\nvoid fit_print_contents(const void *fit)\n{\n\tchar *desc;\n\tchar *uname;\n\tint images_noffset;\n\tint confs_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\tint ret;\n\tconst char *p;\n\ttime_t timestamp;\n\n\t/* Indent string is defined in header image.h */\n\tp = IMAGE_INDENT_STRING;\n\n\t/* Root node properties */\n\tret = fit_get_desc(fit, 0, &desc);\n\tprintf(\"%sFIT description: \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%sCreated:         \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn;\n\t}\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"%s Image %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_image_print(fit, noffset, p);\n\t\t}\n\t}\n\n\t/* Find configurations parent node offset */\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't get configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn;\n\t}\n\n\t/* get default configuration unit name from default property */\n\tuname = (char *)fdt_getprop(fit, noffset, FIT_DEFAULT_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s Default Configuration: '%s'\\n\", p, uname);\n\n\t/* Process its subnodes, print out configurations details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the configurations parent node,\n\t\t\t * i.e. configuration node.\n\t\t\t */\n\t\t\tprintf(\"%s Configuration %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_conf_print(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_image_print - prints out the FIT component image details\n * @fit: pointer to the FIT format image header\n * @image_noffset: offset of the component image node\n * @p: pointer to prefix string\n *\n * fit_image_print() lists all mandatory properties for the processed component\n * image. If present, hash nodes are printed out as well. Load\n * address for images of type firmware is also printed out. Since the load\n * address is not mandatory for firmware images, it will be output as\n * \"unavailable\" when not present.\n *\n * returns:\n *     no returned results\n */\nvoid fit_image_print(const void *fit, int image_noffset, const char *p)\n{\n\tchar *desc;\n\tuint8_t type, arch, os, comp;\n\tsize_t size;\n\tulong load, entry;\n\tconst void *data;\n\tint noffset;\n\tint ndepth;\n\tint ret;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, image_noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\ttime_t timestamp;\n\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%s  Created:      \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\tfit_image_get_type(fit, image_noffset, &type);\n\tprintf(\"%s  Type:         %s\\n\", p, genimg_get_type_name(type));\n\n\tfit_image_get_comp(fit, image_noffset, &comp);\n\tprintf(\"%s  Compression:  %s\\n\", p, genimg_get_comp_name(comp));\n\n\tret = fit_image_get_data_and_size(fit, image_noffset, &data, &size);\n\n\tif (!host_build()) {\n\t\tprintf(\"%s  Data Start:   \", p);\n\t\tif (ret) {\n\t\t\tprintf(\"unavailable\\n\");\n\t\t} else {\n\t\t\tvoid *vdata = (void *)data;\n\n\t\t\tprintf(\"0x%08lx\\n\", (ulong)map_to_sysmem(vdata));\n\t\t}\n\t}\n\n\tprintf(\"%s  Data Size:    \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tgenimg_print_size(size);\n\n\t/* Remaining, type dependent properties */\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK) || (type == IH_TYPE_FIRMWARE) ||\n\t    (type == IH_TYPE_FLATDT)) {\n\t\tfit_image_get_arch(fit, image_noffset, &arch);\n\t\tprintf(\"%s  Architecture: %s\\n\", p, genimg_get_arch_name(arch));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FIRMWARE)) {\n\t\tfit_image_get_os(fit, image_noffset, &os);\n\t\tprintf(\"%s  OS:           %s\\n\", p, genimg_get_os_name(os));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_FIRMWARE) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FPGA)) {\n\t\tret = fit_image_get_load(fit, image_noffset, &load);\n\t\tprintf(\"%s  Load Address: \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", load);\n\t}\n\n\t/* optional load address for FDT */\n\tif (type == IH_TYPE_FLATDT && !fit_image_get_load(fit, image_noffset, &load))\n\t\tprintf(\"%s  Load Address: 0x%08lx\\n\", p, load);\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK)) {\n\t\tret = fit_image_get_entry(fit, image_noffset, &entry);\n\t\tprintf(\"%s  Entry Point:  \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", entry);\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, image_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component image node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n#else\nvoid fit_print_contents(const void *fit) { }\nvoid fit_image_print(const void *fit, int image_noffset, const char *p) { }\n#endif /* CONFIG_IS_ENABLED(FIR_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT) */\n\n/**\n * fit_get_desc - get node description property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @desc: double pointer to the char, will hold pointer to the description\n *\n * fit_get_desc() reads description property from a given node, if\n * description is found pointer to it is returned in third call argument.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_get_desc(const void *fit, int noffset, char **desc)\n{\n\tint len;\n\n\t*desc = (char *)fdt_getprop(fit, noffset, FIT_DESC_PROP, &len);\n\tif (*desc == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DESC_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_get_timestamp - get node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: pointer to the time_t, will hold read timestamp\n *\n * fit_get_timestamp() reads timestamp property from given node, if timestamp\n * is found and has a correct size its value is returned in third call\n * argument.\n *\n * returns:\n *     0, on success\n *     -1, on property read failure\n *     -2, on wrong timestamp size\n */\nint fit_get_timestamp(const void *fit, int noffset, time_t *timestamp)\n{\n\tint len;\n\tconst void *data;\n\n\tdata = fdt_getprop(fit, noffset, FIT_TIMESTAMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TIMESTAMP_PROP, len);\n\t\treturn -1;\n\t}\n\tif (len != sizeof(uint32_t)) {\n\t\tdebug(\"FIT timestamp with incorrect size of (%u)\\n\", len);\n\t\treturn -2;\n\t}\n\n\t*timestamp = uimage_to_cpu(*((uint32_t *)data));\n\treturn 0;\n}\n\n/**\n * fit_image_get_node - get node offset for component image of a given unit name\n * @fit: pointer to the FIT format image header\n * @image_uname: component image node unit name\n *\n * fit_image_get_node() finds a component image (within the '/images'\n * node) of a provided unit name. If image is found its node offset is\n * returned to the caller.\n *\n * returns:\n *     image node offset when found (>=0)\n *     negative number on failure (FDT_ERR_* code)\n */\nint fit_image_get_node(const void *fit, const char *image_uname)\n{\n\tint noffset, images_noffset;\n\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tdebug(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t      FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn images_noffset;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, images_noffset, image_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for image unit name: '%s' (%s)\\n\",\n\t\t      image_uname, fdt_strerror(noffset));\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_image_get_os - get os id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: pointer to the uint8_t, will hold os numeric id\n *\n * fit_image_get_os() finds os property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_os(const void *fit, int noffset, uint8_t *os)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get OS name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_OS_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_OS_PROP, len);\n\t\t*os = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate OS name to id */\n\t*os = genimg_get_os_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_arch - get arch id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: pointer to the uint8_t, will hold arch numeric id\n *\n * fit_image_get_arch() finds arch property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_arch(const void *fit, int noffset, uint8_t *arch)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get architecture name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_ARCH_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ARCH_PROP, len);\n\t\t*arch = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate architecture name to id */\n\t*arch = genimg_get_arch_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_type - get type id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: pointer to the uint8_t, will hold type numeric id\n *\n * fit_image_get_type() finds type property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_type(const void *fit, int noffset, uint8_t *type)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get image type name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_TYPE_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TYPE_PROP, len);\n\t\t*type = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate image type name to id */\n\t*type = genimg_get_type_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_comp - get comp id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: pointer to the uint8_t, will hold comp numeric id\n *\n * fit_image_get_comp() finds comp property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_comp(const void *fit, int noffset, uint8_t *comp)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get compression name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_COMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_COMP_PROP, len);\n\t\t*comp = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate compression name to id */\n\t*comp = genimg_get_comp_id(data);\n\treturn 0;\n}\n\nstatic int fit_image_get_address(const void *fit, int noffset, char *name,\n\t\t\t  ulong *load)\n{\n\tint len, cell_len;\n\tconst fdt32_t *cell;\n\tuint64_t load64 = 0;\n\n\tcell = fdt_getprop(fit, noffset, name, &len);\n\tif (cell == NULL) {\n\t\tfit_get_debug(fit, noffset, name, len);\n\t\treturn -1;\n\t}\n\n\tcell_len = len >> 2;\n\t/* Use load64 to avoid compiling warning for 32-bit target */\n\twhile (cell_len--) {\n\t\tload64 = (load64 << 32) | uimage_to_cpu(*cell);\n\t\tcell++;\n\t}\n\n\tif (len > sizeof(ulong) && (uint32_t)(load64 >> 32)) {\n\t\tprintf(\"Unsupported %s address size\\n\", name);\n\t\treturn -1;\n\t}\n\n\t*load = (ulong)load64;\n\n\treturn 0;\n}\n/**\n * fit_image_get_load() - get load addr property for given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @load: pointer to the uint32_t, will hold load address\n *\n * fit_image_get_load() finds load address property in a given component\n * image node. If the property is found, its value is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_load(const void *fit, int noffset, ulong *load)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_LOAD_PROP, load);\n}\n\n/**\n * fit_image_get_entry() - get entry point address property\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @entry: pointer to the uint32_t, will hold entry point address\n *\n * This gets the entry point address property for a given component image\n * node.\n *\n * fit_image_get_entry() finds entry point address property in a given\n * component image node.  If the property is found, its value is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_entry(const void *fit, int noffset, ulong *entry)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_ENTRY_PROP, entry);\n}\n\n/**\n * fit_image_get_data - get data property and its size for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data() finds data property in a given component image node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_data(const void *fit, int noffset,\n\t\tconst void **data, size_t *size)\n{\n\tint len;\n\n\t*data = fdt_getprop(fit, noffset, FIT_DATA_PROP, &len);\n\tif (*data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DATA_PROP, len);\n\t\t*size = 0;\n\t\treturn -1;\n\t}\n\n\t*size = len;\n\treturn 0;\n}\n\n/**\n * Get 'data-offset' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_offset: holds the data-offset property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_offset(const void *fit, int noffset, int *data_offset)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_OFFSET_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_offset = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-position' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_position: holds the data-position property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_position(const void *fit, int noffset,\n\t\t\t\tint *data_position)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_POSITION_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_position = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size(const void *fit, int noffset, int *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_SIZE_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size-unciphered' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size_unciphered(const void *fit, int noffset,\n\t\t\t\t       size_t *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, \"data-size-unciphered\", NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = (size_t)fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * fit_image_get_data_and_size - get data and its size including\n *\t\t\t\t both embedded and external data\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data_and_size() finds data and its size including\n * both embedded and external data. If the property is found\n * its data start address and size are returned to the caller.\n *\n * returns:\n *     0, on success\n *     otherwise, on failure\n */\nint fit_image_get_data_and_size(const void *fit, int noffset,\n\t\t\t\tconst void **data, size_t *size)\n{\n\tbool external_data = false;\n\tint offset;\n\tint len;\n\tint ret;\n\n\tif (!fit_image_get_data_position(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t} else if (!fit_image_get_data_offset(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t\t/*\n\t\t * For FIT with external data, figure out where\n\t\t * the external images start. This is the base\n\t\t * for the data-offset properties in each image.\n\t\t */\n\t\toffset += ((fdt_totalsize(fit) + 3) & ~3);\n\t}\n\n\tif (external_data) {\n\t\tdebug(\"External Data\\n\");\n\t\tret = fit_image_get_data_size(fit, noffset, &len);\n\t\tif (!ret) {\n\t\t\t*data = fit + offset;\n\t\t\t*size = len;\n\t\t}\n\t} else {\n\t\tret = fit_image_get_data(fit, noffset, data, size);\n\t}\n\n\treturn ret;\n}\n\n/**\n * fit_image_hash_get_algo - get hash algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.\n * If the property is found its data start address is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (*algo == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_value - get hash value and length\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @value: double pointer to uint8_t, will hold address of a hash value data\n * @value_len: pointer to an int, will hold hash data length\n *\n * fit_image_hash_get_value() finds hash value property in a given hash node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_value(const void *fit, int noffset, uint8_t **value,\n\t\t\t\tint *value_len)\n{\n\tint len;\n\n\t*value = (uint8_t *)fdt_getprop(fit, noffset, FIT_VALUE_PROP, &len);\n\tif (*value == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_VALUE_PROP, len);\n\t\t*value_len = 0;\n\t\treturn -1;\n\t}\n\n\t*value_len = len;\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_ignore - get hash ignore flag\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @ignore: pointer to an int, will hold hash ignore flag\n *\n * fit_image_hash_get_ignore() finds hash ignore property in a given hash node.\n * If the property is found and non-zero, the hash algorithm is not verified by\n * u-boot automatically.\n *\n * returns:\n *     0, on ignore not found\n *     value, on ignore found\n */\nstatic int fit_image_hash_get_ignore(const void *fit, int noffset, int *ignore)\n{\n\tint len;\n\tint *value;\n\n\tvalue = (int *)fdt_getprop(fit, noffset, FIT_IGNORE_PROP, &len);\n\tif (value == NULL || len != sizeof(int))\n\t\t*ignore = 0;\n\telse\n\t\t*ignore = *value;\n\n\treturn 0;\n}\n\n/**\n * fit_image_cipher_get_algo - get cipher algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: cipher node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_cipher_get_algo() finds cipher algorithm property in a given\n * cipher node. If the property is found its data start address is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_cipher_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (!*algo) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nulong fit_get_end(const void *fit)\n{\n\treturn map_to_sysmem((void *)(fit + fdt_totalsize(fit)));\n}\n\n/**\n * fit_set_timestamp - set node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: timestamp value to be set\n *\n * fit_set_timestamp() attempts to set timestamp property in the requested\n * node and returns operation status to the caller.\n *\n * returns:\n *     0, on success\n *     -ENOSPC if no space in device tree, -1 for other error\n */\nint fit_set_timestamp(void *fit, int noffset, time_t timestamp)\n{\n\tuint32_t t;\n\tint ret;\n\n\tt = cpu_to_uimage(timestamp);\n\tret = fdt_setprop(fit, noffset, FIT_TIMESTAMP_PROP, &t,\n\t\t\t\tsizeof(uint32_t));\n\tif (ret) {\n\t\tdebug(\"Can't set '%s' property for '%s' node (%s)\\n\",\n\t\t      FIT_TIMESTAMP_PROP, fit_get_name(fit, noffset, NULL),\n\t\t      fdt_strerror(ret));\n\t\treturn ret == -FDT_ERR_NOSPACE ? -ENOSPC : -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * calculate_hash - calculate and return hash for provided input data\n * @data: pointer to the input data\n * @data_len: data length\n * @algo: requested hash algorithm\n * @value: pointer to the char, will hold hash value data (caller must\n * allocate enough free space)\n * value_len: length of the calculated hash\n *\n * calculate_hash() computes input data hash according to the requested\n * algorithm.\n * Resulting hash value is placed in caller provided 'value' buffer, length\n * of the calculated hash is returned via value_len pointer argument.\n *\n * returns:\n *     0, on success\n *    -1, when algo is unsupported\n */\nint calculate_hash(const void *data, int data_len, const char *algo,\n\t\t\tuint8_t *value, int *value_len)\n{\n\tif (IMAGE_ENABLE_CRC32 && strcmp(algo, \"crc32\") == 0) {\n\t\t*((uint32_t *)value) = crc32_wd(0, data, data_len,\n\t\t\t\t\t\t\tCHUNKSZ_CRC32);\n\t\t*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));\n\t\t*value_len = 4;\n\t} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, \"sha1\") == 0) {\n\t\tsha1_csum_wd((unsigned char *)data, data_len,\n\t\t\t     (unsigned char *)value, CHUNKSZ_SHA1);\n\t\t*value_len = 20;\n\t} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, \"sha256\") == 0) {\n\t\tsha256_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA256);\n\t\t*value_len = SHA256_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA384 && strcmp(algo, \"sha384\") == 0) {\n\t\tsha384_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA384);\n\t\t*value_len = SHA384_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA512 && strcmp(algo, \"sha512\") == 0) {\n\t\tsha512_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA512);\n\t\t*value_len = SHA512_SUM_LEN;\n\t} else if (IMAGE_ENABLE_MD5 && strcmp(algo, \"md5\") == 0) {\n\t\tmd5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);\n\t\t*value_len = 16;\n\t} else {\n\t\tdebug(\"Unsupported hash alogrithm\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int fit_image_check_hash(const void *fit, int noffset, const void *data,\n\t\t\t\tsize_t size, char **err_msgp)\n{\n\tuint8_t value[FIT_MAX_HASH_LEN];\n\tint value_len;\n\tchar *algo;\n\tuint8_t *fit_value;\n\tint fit_value_len;\n\tint ignore;\n\n\t*err_msgp = NULL;\n\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\t*err_msgp = \"Can't get hash algo property\";\n\t\treturn -1;\n\t}\n\tprintf(\"%s\", algo);\n\n\tif (IMAGE_ENABLE_IGNORE) {\n\t\tfit_image_hash_get_ignore(fit, noffset, &ignore);\n\t\tif (ignore) {\n\t\t\tprintf(\"-skipped \");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fit_image_hash_get_value(fit, noffset, &fit_value,\n\t\t\t\t     &fit_value_len)) {\n\t\t*err_msgp = \"Can't get hash value property\";\n\t\treturn -1;\n\t}\n\n\tif (calculate_hash(data, size, algo, value, &value_len)) {\n\t\t*err_msgp = \"Unsupported hash algorithm\";\n\t\treturn -1;\n\t}\n\n\tif (value_len != fit_value_len) {\n\t\t*err_msgp = \"Bad hash value len\";\n\t\treturn -1;\n\t} else if (memcmp(value, fit_value, value_len) != 0) {\n\t\t*err_msgp = \"Bad hash value\";\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint fit_image_verify_with_data(const void *fit, int image_noffset,\n\t\t\t       const void *data, size_t size)\n{\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tint verify_all = 1;\n\tint ret;\n\n\t/* Verify all required signatures */\n\tif (FIT_IMAGE_ENABLE_VERIFY &&\n\t    fit_image_verify_required_sigs(fit, image_noffset, data, size,\n\t\t\t\t\t   gd_fdt_blob(), &verify_all)) {\n\t\terr_msg = \"Unable to verify required signature\";\n\t\tgoto error;\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\n\t\t/*\n\t\t * Check subnode name, must be equal to \"hash\".\n\t\t * Multiple hash nodes require unique unit node\n\t\t * names, e.g. hash-1, hash-2, etc.\n\t\t */\n\t\tif (!strncmp(name, FIT_HASH_NODENAME,\n\t\t\t     strlen(FIT_HASH_NODENAME))) {\n\t\t\tif (fit_image_check_hash(fit, noffset, data, size,\n\t\t\t\t\t\t &err_msg))\n\t\t\t\tgoto error;\n\t\t\tputs(\"+ \");\n\t\t} else if (FIT_IMAGE_ENABLE_VERIFY && verify_all &&\n\t\t\t\t!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t\tsize, -1, &err_msg);\n\n\t\t\t/*\n\t\t\t * Show an indication on failure, but do not return\n\t\t\t * an error. Only keys marked 'required' can cause\n\t\t\t * an image validation failure. See the call to\n\t\t\t * fit_image_verify_required_sigs() above.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tputs(\"- \");\n\t\t\telse\n\t\t\t\tputs(\"+ \");\n\t\t}\n\t}\n\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\n\treturn 1;\n\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_image_verify - verify data integrity\n * @fit: pointer to the FIT format image header\n * @image_noffset: component image node offset\n *\n * fit_image_verify() goes over component image hash nodes,\n * re-calculates each data hash and compares with the value stored in hash\n * node.\n *\n * returns:\n *     1, if all hashes are valid\n *     0, otherwise (or on error)\n */\nint fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst char *name = fit_get_name(fit, image_noffset, NULL);\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tchar\t\t*err_msg = \"\";\n\n\tif (strchr(name, '@')) {\n\t\t/*\n\t\t * We don't support this since libfdt considers names with the\n\t\t * name root but different @ suffix to be equal\n\t\t */\n\t\terr_msg = \"Node name contains @\";\n\t\tgoto err;\n\t}\n\t/* Get image data and data length */\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tgoto err;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n\nerr:\n\tprintf(\"error!\\n%s in '%s' image node\\n\", err_msg,\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_all_image_verify - verify data integrity for all images\n * @fit: pointer to the FIT format image header\n *\n * fit_all_image_verify() goes over all images in the FIT and\n * for every images checks if all it's hashes are valid.\n *\n * returns:\n *     1, if all hashes of all images are valid\n *     0, otherwise (or on error)\n */\nint fit_all_image_verify(const void *fit)\n{\n\tint images_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count;\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn 0;\n\t}\n\n\t/* Process all image subnodes, check hashes for each */\n\tprintf(\"## Checking hash(es) for FIT Image at %08lx ...\\n\",\n\t       (ulong)fit);\n\tfor (ndepth = 0, count = 0,\n\t     noffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"   Hash(es) for Image %u (%s): \", count,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\t\t\tcount++;\n\n\t\t\tif (!fit_image_verify(fit, noffset))\n\t\t\t\treturn 0;\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int fit_image_uncipher(const void *fit, int image_noffset,\n\t\t\t      void **data, size_t *size)\n{\n\tint cipher_noffset, ret;\n\tvoid *dst;\n\tsize_t size_dst;\n\n\tcipher_noffset = fdt_subnode_offset(fit, image_noffset,\n\t\t\t\t\t    FIT_CIPHER_NODENAME);\n\tif (cipher_noffset < 0)\n\t\treturn 0;\n\n\tret = fit_image_decrypt_data(fit, image_noffset, cipher_noffset,\n\t\t\t\t     *data, *size, &dst, &size_dst);\n\tif (ret)\n\t\tgoto out;\n\n\t*data = dst;\n\t*size = size_dst;\n\n out:\n\treturn ret;\n}\n\n/**\n * fit_image_check_os - check whether image node is of a given os type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: requested image os\n *\n * fit_image_check_os() reads image os property and compares its numeric\n * id with the requested os. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given os type\n *     0 otherwise (or on error)\n */\nint fit_image_check_os(const void *fit, int noffset, uint8_t os)\n{\n\tuint8_t image_os;\n\n\tif (fit_image_get_os(fit, noffset, &image_os))\n\t\treturn 0;\n\treturn (os == image_os);\n}\n\n/**\n * fit_image_check_arch - check whether image node is of a given arch\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: requested imagearch\n *\n * fit_image_check_arch() reads image arch property and compares its numeric\n * id with the requested arch. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given arch\n *     0 otherwise (or on error)\n */\nint fit_image_check_arch(const void *fit, int noffset, uint8_t arch)\n{\n\tuint8_t image_arch;\n\tint aarch32_support = 0;\n\n\tif (IS_ENABLED(CONFIG_ARM64_SUPPORT_AARCH32))\n\t\taarch32_support = 1;\n\n\tif (fit_image_get_arch(fit, noffset, &image_arch))\n\t\treturn 0;\n\treturn (arch == image_arch) ||\n\t\t(arch == IH_ARCH_I386 && image_arch == IH_ARCH_X86_64) ||\n\t\t(arch == IH_ARCH_ARM64 && image_arch == IH_ARCH_ARM &&\n\t\t aarch32_support);\n}\n\n/**\n * fit_image_check_type - check whether image node is of a given type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: requested image type\n *\n * fit_image_check_type() reads image type property and compares its numeric\n * id with the requested type. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given type\n *     0 otherwise (or on error)\n */\nint fit_image_check_type(const void *fit, int noffset, uint8_t type)\n{\n\tuint8_t image_type;\n\n\tif (fit_image_get_type(fit, noffset, &image_type))\n\t\treturn 0;\n\treturn (type == image_type);\n}\n\n/**\n * fit_image_check_comp - check whether image node uses given compression\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: requested image compression type\n *\n * fit_image_check_comp() reads image compression property and compares its\n * numeric id with the requested compression type. Comparison result is\n * returned to the caller.\n *\n * returns:\n *     1 if image uses requested compression\n *     0 otherwise (or on error)\n */\nint fit_image_check_comp(const void *fit, int noffset, uint8_t comp)\n{\n\tuint8_t image_comp;\n\n\tif (fit_image_get_comp(fit, noffset, &image_comp))\n\t\treturn 0;\n\treturn (comp == image_comp);\n}\n\nint fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\n\t/* A FIT image must be a valid FDT */\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\t/*\n\t\t * If we are not given the size, make do wtih calculating it.\n\t\t * This is not as secure, so we should consider a flag to\n\t\t * control this.\n\t\t */\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* mandatory / node 'description' property */\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\t/* mandatory / node 'timestamp' property */\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\t/* mandatory subimages parent '/images' node */\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_conf_find_compat\n * @fit: pointer to the FIT format image header\n * @fdt: pointer to the device tree to compare against\n *\n * fit_conf_find_compat() attempts to find the configuration whose fdt is the\n * most compatible with the passed in device tree.\n *\n * Example:\n *\n * / o image-tree\n *   |-o images\n *   | |-o fdt-1\n *   | |-o fdt-2\n *   |\n *   |-o configurations\n *     |-o config-1\n *     | |-fdt = fdt-1\n *     |\n *     |-o config-2\n *       |-fdt = fdt-2\n *\n * / o U-Boot fdt\n *   |-compatible = \"foo,bar\", \"bim,bam\"\n *\n * / o kernel fdt1\n *   |-compatible = \"foo,bar\",\n *\n * / o kernel fdt2\n *   |-compatible = \"bim,bam\", \"baz,biz\"\n *\n * Configuration 1 would be picked because the first string in U-Boot's\n * compatible list, \"foo,bar\", matches a compatible string in the root of fdt1.\n * \"bim,bam\" in fdt2 matches the second string which isn't as good as fdt1.\n *\n * As an optimization, the compatible property from the FDT's root node can be\n * copied into the configuration node in the FIT image. This is required to\n * match configurations with compressed FDTs.\n *\n * returns:\n *     offset to the configuration to use if one was found\n *     -1 otherwise\n */\nint fit_conf_find_compat(const void *fit, const void *fdt)\n{\n\tint ndepth = 0;\n\tint noffset, confs_noffset, images_noffset;\n\tconst void *fdt_compat;\n\tint fdt_compat_len;\n\tint best_match_offset = 0;\n\tint best_match_pos = 0;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (confs_noffset < 0 || images_noffset < 0) {\n\t\tdebug(\"Can't find configurations or images nodes.\\n\");\n\t\treturn -1;\n\t}\n\n\tfdt_compat = fdt_getprop(fdt, 0, \"compatible\", &fdt_compat_len);\n\tif (!fdt_compat) {\n\t\tdebug(\"Fdt for comparison has no \\\"compatible\\\" property.\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Loop over the configurations in the FIT image.\n\t */\n\tfor (noffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tconst void *fdt;\n\t\tconst char *kfdt_name;\n\t\tint kfdt_noffset, compat_noffset;\n\t\tconst char *cur_fdt_compat;\n\t\tint len;\n\t\tsize_t sz;\n\t\tint i;\n\n\t\tif (ndepth > 1)\n\t\t\tcontinue;\n\n\t\t/* If there's a compat property in the config node, use that. */\n\t\tif (fdt_getprop(fit, noffset, \"compatible\", NULL)) {\n\t\t\tfdt = fit;\t\t  /* search in FIT image */\n\t\t\tcompat_noffset = noffset; /* search under config node */\n\t\t} else {\t/* Otherwise extract it from the kernel FDT. */\n\t\t\tkfdt_name = fdt_getprop(fit, noffset, \"fdt\", &len);\n\t\t\tif (!kfdt_name) {\n\t\t\t\tdebug(\"No fdt property found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkfdt_noffset = fdt_subnode_offset(fit, images_noffset,\n\t\t\t\t\t\t\t  kfdt_name);\n\t\t\tif (kfdt_noffset < 0) {\n\t\t\t\tdebug(\"No image node named \\\"%s\\\" found.\\n\",\n\t\t\t\t      kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fit_image_check_comp(fit, kfdt_noffset,\n\t\t\t\t\t\t  IH_COMP_NONE)) {\n\t\t\t\tdebug(\"Can't extract compat from \\\"%s\\\" \"\n\t\t\t\t      \"(compressed)\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* search in this config's kernel FDT */\n\t\t\tif (fit_image_get_data(fit, kfdt_noffset, &fdt, &sz)) {\n\t\t\t\tdebug(\"Failed to get fdt \\\"%s\\\".\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcompat_noffset = 0;  /* search kFDT under root node */\n\t\t}\n\n\t\tlen = fdt_compat_len;\n\t\tcur_fdt_compat = fdt_compat;\n\t\t/*\n\t\t * Look for a match for each U-Boot compatibility string in\n\t\t * turn in the compat string property.\n\t\t */\n\t\tfor (i = 0; len > 0 &&\n\t\t     (!best_match_offset || best_match_pos > i); i++) {\n\t\t\tint cur_len = strlen(cur_fdt_compat) + 1;\n\n\t\t\tif (!fdt_node_check_compatible(fdt, compat_noffset,\n\t\t\t\t\t\t       cur_fdt_compat)) {\n\t\t\t\tbest_match_offset = noffset;\n\t\t\t\tbest_match_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= cur_len;\n\t\t\tcur_fdt_compat += cur_len;\n\t\t}\n\t}\n\tif (!best_match_offset) {\n\t\tdebug(\"No match found.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn best_match_offset;\n}\n\nint fit_conf_get_node(const void *fit, const char *conf_uname)\n{\n\tint noffset, confs_noffset;\n\tint len;\n\tconst char *s;\n\tchar *conf_uname_copy = NULL;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't find configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn confs_noffset;\n\t}\n\n\tif (conf_uname == NULL) {\n\t\t/* get configuration unit name from the default property */\n\t\tdebug(\"No configuration specified, trying default...\\n\");\n\t\tif (!host_build() && IS_ENABLED(CONFIG_MULTI_DTB_FIT)) {\n\t\t\tnoffset = fit_find_config_node(fit);\n\t\t\tif (noffset < 0)\n\t\t\t\treturn noffset;\n\t\t\tconf_uname = fdt_get_name(fit, noffset, NULL);\n\t\t} else {\n\t\t\tconf_uname = (char *)fdt_getprop(fit, confs_noffset,\n\t\t\t\t\t\t\t FIT_DEFAULT_PROP, &len);\n\t\t\tif (conf_uname == NULL) {\n\t\t\t\tfit_get_debug(fit, confs_noffset, FIT_DEFAULT_PROP,\n\t\t\t\t\t      len);\n\t\t\t\treturn len;\n\t\t\t}\n\t\t}\n\t\tdebug(\"Found default configuration: '%s'\\n\", conf_uname);\n\t}\n\n\ts = strchr(conf_uname, '#');\n\tif (s) {\n\t\tlen = s - conf_uname;\n\t\tconf_uname_copy = malloc(len + 1);\n\t\tif (!conf_uname_copy) {\n\t\t\tdebug(\"Can't allocate uname copy: '%s'\\n\",\n\t\t\t\t\tconf_uname);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(conf_uname_copy, conf_uname, len);\n\t\tconf_uname_copy[len] = '\\0';\n\t\tconf_uname = conf_uname_copy;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, confs_noffset, conf_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for configuration unit name: '%s' (%s)\\n\",\n\t\t      conf_uname, fdt_strerror(noffset));\n\t}\n\n\tif (conf_uname_copy)\n\t\tfree(conf_uname_copy);\n\n\treturn noffset;\n}\n\nint fit_conf_get_prop_node_count(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fdt_stringlist_count(fit, noffset, prop_name);\n}\n\nint fit_conf_get_prop_node_index(const void *fit, int noffset,\n\t\tconst char *prop_name, int index)\n{\n\tconst char *uname;\n\tint len;\n\n\t/* get kernel image unit name from configuration kernel property */\n\tuname = fdt_stringlist_get(fit, noffset, prop_name, index, &len);\n\tif (uname == NULL)\n\t\treturn len;\n\n\treturn fit_image_get_node(fit, uname);\n}\n\nint fit_conf_get_prop_node(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fit_conf_get_prop_node_index(fit, noffset, prop_name, 0);\n}\n\nstatic int fit_image_select(const void *fit, int rd_noffset, int verify)\n{\n\tfit_image_print(fit, rd_noffset, \"   \");\n\n\tif (verify) {\n\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\tif (!fit_image_verify(fit, rd_noffset)) {\n\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\treturn 0;\n}\n\nint fit_get_node_from_config(bootm_headers_t *images, const char *prop_name,\n\t\t\tulong addr)\n{\n\tint cfg_noffset;\n\tvoid *fit_hdr;\n\tint noffset;\n\n\tdebug(\"*  %s: using config '%s' from image at 0x%08lx\\n\",\n\t      prop_name, images->fit_uname_cfg, addr);\n\n\t/* Check whether configuration has this property defined */\n\tfit_hdr = map_sysmem(addr, 0);\n\tcfg_noffset = fit_conf_get_node(fit_hdr, images->fit_uname_cfg);\n\tif (cfg_noffset < 0) {\n\t\tdebug(\"*  %s: no such config\\n\", prop_name);\n\t\treturn -EINVAL;\n\t}\n\n\tnoffset = fit_conf_get_prop_node(fit_hdr, cfg_noffset, prop_name);\n\tif (noffset < 0) {\n\t\tdebug(\"*  %s: no '%s' in config\\n\", prop_name, prop_name);\n\t\treturn -ENOENT;\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_get_image_type_property() - get property name for IH_TYPE_...\n *\n * @return the properly name where we expect to find the image in the\n * config node\n */\nstatic const char *fit_get_image_type_property(int type)\n{\n\t/*\n\t * This is sort-of available in the uimage_type[] table in image.c\n\t * but we don't have access to the short name, and \"fdt\" is different\n\t * anyway. So let's just keep it here.\n\t */\n\tswitch (type) {\n\tcase IH_TYPE_FLATDT:\n\t\treturn FIT_FDT_PROP;\n\tcase IH_TYPE_KERNEL:\n\t\treturn FIT_KERNEL_PROP;\n\tcase IH_TYPE_RAMDISK:\n\t\treturn FIT_RAMDISK_PROP;\n\tcase IH_TYPE_X86_SETUP:\n\t\treturn FIT_SETUP_PROP;\n\tcase IH_TYPE_LOADABLE:\n\t\treturn FIT_LOADABLE_PROP;\n\tcase IH_TYPE_FPGA:\n\t\treturn FIT_FPGA_PROP;\n\tcase IH_TYPE_STANDALONE:\n\t\treturn FIT_STANDALONE_PROP;\n\t}\n\n\treturn \"unknown\";\n}\n\nint fit_image_load(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, int image_type, int bootstage_id,\n\t\t   enum fit_load_op load_op, ulong *datap, ulong *lenp)\n{\n\tint cfg_noffset, noffset;\n\tconst char *fit_uname;\n\tconst char *fit_uname_config;\n\tconst char *fit_base_uname_config;\n\tconst void *fit;\n\tvoid *buf;\n\tvoid *loadbuf;\n\tsize_t size;\n\tint type_ok, os_ok;\n\tulong load, load_end, data, len;\n\tuint8_t os, comp;\n#ifndef USE_HOSTCC\n\tuint8_t os_arch;\n#endif\n\tconst char *prop_name;\n\tint ret;\n\n\tfit = map_sysmem(addr, 0);\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\tfit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;\n\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tif (fit_check_format(fit, IMAGE_SIZE_INVAL)) {\n\t\tprintf(\"Bad FIT %s image format!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn -ENOEXEC;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t/* get FIT component image node offset */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);\n\t\tnoffset = fit_image_get_node(fit, fit_uname);\n\t} else {\n\t\t/*\n\t\t * no image node unit name, try to get config\n\t\t * node first. If config unit node name is NULL\n\t\t * fit_conf_get_node() will try to find default config node\n\t\t */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\tif (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) {\n\t\t\tcfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob());\n\t\t} else {\n\t\t\tcfg_noffset = fit_conf_get_node(fit,\n\t\t\t\t\t\t\tfit_uname_config);\n\t\t}\n\t\tif (cfg_noffset < 0) {\n\t\t\tputs(\"Could not find configuration node\\n\");\n\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tfit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL);\n\t\tprintf(\"   Using '%s' configuration\\n\", fit_base_uname_config);\n\t\t/* Remember this config */\n\t\tif (image_type == IH_TYPE_KERNEL)\n\t\t\timages->fit_uname_cfg = fit_base_uname_config;\n\n\t\tif (FIT_IMAGE_ENABLE_VERIFY && images->verify) {\n\t\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\t\tif (fit_config_verify(fit, cfg_noffset)) {\n\t\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_HASH);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tputs(\"OK\\n\");\n\t\t}\n\n\t\tbootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);\n\n\t\tnoffset = fit_conf_get_prop_node(fit, cfg_noffset,\n\t\t\t\t\t\t prop_name);\n\t\tfit_uname = fit_get_name(fit, noffset, NULL);\n\t}\n\tif (noffset < 0) {\n\t\tprintf(\"Could not find subimage node type '%s'\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE);\n\t\treturn -ENOENT;\n\t}\n\n\tprintf(\"   Trying '%s' %s subimage\\n\", fit_uname, prop_name);\n\n\tret = fit_image_select(fit, noffset, images->verify);\n\tif (ret) {\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH);\n\t\treturn ret;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\tif (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) {\n\t\tif (!fit_image_check_target_arch(fit, noffset)) {\n\t\t\tputs(\"Unsupported Architecture\\n\");\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n#ifndef USE_HOSTCC\n\tfit_image_get_arch(fit, noffset, &os_arch);\n\timages->os.arch = os_arch;\n#endif\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\ttype_ok = fit_image_check_type(fit, noffset, image_type) ||\n\t\t  fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) ||\n\t\t  (image_type == IH_TYPE_KERNEL &&\n\t\t   fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD));\n\n\tos_ok = image_type == IH_TYPE_FLATDT ||\n\t\timage_type == IH_TYPE_FPGA ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_LINUX) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_U_BOOT) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_OPENRTOS) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_EFI) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_VXWORKS);\n\n\t/*\n\t * If either of the checks fail, we should report an error, but\n\t * if the image type is coming from the \"loadables\" field, we\n\t * don't care what it is\n\t */\n\tif ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) {\n\t\tfit_image_get_os(fit, noffset, &os);\n\t\tprintf(\"No %s %s %s Image\\n\",\n\t\t       genimg_get_os_name(os),\n\t\t       genimg_get_arch_name(arch),\n\t\t       genimg_get_type_name(image_type));\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\t\treturn -EIO;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK);\n\n\t/* get image data address and length */\n\tif (fit_image_get_data_and_size(fit, noffset,\n\t\t\t\t\t(const void **)&buf, &size)) {\n\t\tprintf(\"Could not find %s subimage data!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA);\n\t\treturn -ENOENT;\n\t}\n\n\t/* Decrypt data before uncompress/move */\n\tif (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) {\n\t\tputs(\"   Decrypting Data ... \");\n\t\tif (fit_image_uncipher(fit, noffset, &buf, &size)) {\n\t\t\tputs(\"Error\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\t/* perform any post-processing on the image data */\n\tif (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS))\n\t\tboard_fit_image_post_process(&buf, &size);\n\n\tlen = (ulong)size;\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK);\n\n\tdata = map_to_sysmem(buf);\n\tload = data;\n\tif (load_op == FIT_LOAD_IGNORED) {\n\t\t/* Don't load */\n\t} else if (fit_image_get_load(fit, noffset, &load)) {\n\t\tif (load_op == FIT_LOAD_REQUIRED) {\n\t\t\tprintf(\"Can't get %s subimage load address!\\n\",\n\t\t\t       prop_name);\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\t\t\treturn -EBADF;\n\t\t}\n\t} else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) {\n\t\tulong image_start, image_end;\n\n\t\t/*\n\t\t * move image data to the load address,\n\t\t * make sure we don't overwrite initial image\n\t\t */\n\t\timage_start = addr;\n\t\timage_end = addr + fit_get_size(fit);\n\n\t\tload_end = load + len;\n\t\tif (image_type != IH_TYPE_KERNEL &&\n\t\t    load < image_end && load_end > image_start) {\n\t\t\tprintf(\"Error: %s overwritten\\n\", prop_name);\n\t\t\treturn -EXDEV;\n\t\t}\n\n\t\tprintf(\"   Loading %s from 0x%08lx to 0x%08lx\\n\",\n\t\t       prop_name, data, load);\n\t} else {\n\t\tload = data;\t/* No load address specified */\n\t}\n\n\tcomp = IH_COMP_NONE;\n\tloadbuf = buf;\n\t/* Kernel images get decompressed later in bootm_load_os(). */\n\tif (!fit_image_get_comp(fit, noffset, &comp) &&\n\t    comp != IH_COMP_NONE &&\n\t    !(image_type == IH_TYPE_KERNEL ||\n\t      image_type == IH_TYPE_KERNEL_NOLOAD ||\n\t      image_type == IH_TYPE_RAMDISK)) {\n\t\tulong max_decomp_len = len * 20;\n\t\tif (load == data) {\n\t\t\tloadbuf = malloc(max_decomp_len);\n\t\t\tload = map_to_sysmem(loadbuf);\n\t\t} else {\n\t\t\tloadbuf = map_sysmem(load, max_decomp_len);\n\t\t}\n\t\tif (image_decomp(comp, load, data, image_type,\n\t\t\t\tloadbuf, buf, len, max_decomp_len, &load_end)) {\n\t\t\tprintf(\"Error decompressing %s\\n\", prop_name);\n\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t\tlen = load_end - load;\n\t} else if (load != data) {\n\t\tloadbuf = map_sysmem(load, len);\n\t\tmemcpy(loadbuf, buf, len);\n\t}\n\n\tif (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE)\n\t\tputs(\"WARNING: 'compression' nodes for ramdisks are deprecated,\"\n\t\t     \" please fix your .its file!\\n\");\n\n\t/* verify that image data is a proper FDT blob */\n\tif (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) {\n\t\tputs(\"Subimage data is not a FDT\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\n\t*datap = load;\n\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = (char *)fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = (char *)(fit_uname_config ? :\n\t\t\t\t\t      fit_base_uname_config);\n\n\treturn noffset;\n}\n\nint boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,\n\t\t\tulong *setup_start, ulong *setup_len)\n{\n\tint noffset;\n\tulong addr;\n\tulong len;\n\tint ret;\n\n\taddr = map_to_sysmem(images->fit_hdr_os);\n\tnoffset = fit_get_node_from_config(images, FIT_SETUP_PROP, addr);\n\tif (noffset < 0)\n\t\treturn noffset;\n\n\tret = fit_image_load(images, addr, NULL, NULL, arch,\n\t\t\t     IH_TYPE_X86_SETUP, BOOTSTAGE_ID_FIT_SETUP_START,\n\t\t\t     FIT_LOAD_REQUIRED, setup_start, &len);\n\n\treturn ret;\n}\n\n#ifndef USE_HOSTCC\nint boot_get_fdt_fit(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, ulong *datap, ulong *lenp)\n{\n\tint fdt_noffset, cfg_noffset, count;\n\tconst void *fit;\n\tconst char *fit_uname = NULL;\n\tconst char *fit_uname_config = NULL;\n\tchar *fit_uname_config_copy = NULL;\n\tchar *next_config = NULL;\n\tulong load, len;\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\tulong image_start, image_end;\n\tulong ovload, ovlen;\n\tconst char *uconfig;\n\tconst char *uname;\n\tvoid *base, *ov;\n\tint i, err, noffset, ov_noffset;\n#endif\n\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\n\tif (fit_uname_configp && *fit_uname_configp) {\n\t\tfit_uname_config_copy = strdup(*fit_uname_configp);\n\t\tif (!fit_uname_config_copy)\n\t\t\treturn -ENOMEM;\n\n\t\tnext_config = strchr(fit_uname_config_copy, '#');\n\t\tif (next_config)\n\t\t\t*next_config++ = '\\0';\n\t\tif (next_config - 1 > fit_uname_config_copy)\n\t\t\tfit_uname_config = fit_uname_config_copy;\n\t}\n\n\tfdt_noffset = fit_image_load(images,\n\t\taddr, &fit_uname, &fit_uname_config,\n\t\tarch, IH_TYPE_FLATDT,\n\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\tFIT_LOAD_OPTIONAL, &load, &len);\n\n\tif (fdt_noffset < 0)\n\t\tgoto out;\n\n\tdebug(\"fit_uname=%s, fit_uname_config=%s\\n\",\n\t\t\tfit_uname ? fit_uname : \"<NULL>\",\n\t\t\tfit_uname_config ? fit_uname_config : \"<NULL>\");\n\n\tfit = map_sysmem(addr, 0);\n\n\tcfg_noffset = fit_conf_get_node(fit, fit_uname_config);\n\n\t/* single blob, or error just return as well */\n\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset, FIT_FDT_PROP);\n\tif (count <= 1 && !next_config)\n\t\tgoto out;\n\n\t/* we need to apply overlays */\n\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\timage_start = addr;\n\timage_end = addr + fit_get_size(fit);\n\t/* verify that relocation took place by load address not being in fit */\n\tif (load >= image_start && load < image_end) {\n\t\t/* check is simplified; fit load checks for overlaps */\n\t\tprintf(\"Overlayed FDT requires relocation\\n\");\n\t\tfdt_noffset = -EBADF;\n\t\tgoto out;\n\t}\n\n\tbase = map_sysmem(load, len);\n\n\t/* apply extra configs in FIT first, followed by args */\n\tfor (i = 1; ; i++) {\n\t\tif (i < count) {\n\t\t\tnoffset = fit_conf_get_prop_node_index(fit, cfg_noffset,\n\t\t\t\t\t\t\t       FIT_FDT_PROP, i);\n\t\t\tuname = fit_get_name(fit, noffset, NULL);\n\t\t\tuconfig = NULL;\n\t\t} else {\n\t\t\tif (!next_config)\n\t\t\t\tbreak;\n\t\t\tuconfig = next_config;\n\t\t\tnext_config = strchr(next_config, '#');\n\t\t\tif (next_config)\n\t\t\t\t*next_config++ = '\\0';\n\t\t\tuname = NULL;\n\n\t\t\t/*\n\t\t\t * fit_image_load() would load the first FDT from the\n\t\t\t * extra config only when uconfig is specified.\n\t\t\t * Check if the extra config contains multiple FDTs and\n\t\t\t * if so, load them.\n\t\t\t */\n\t\t\tcfg_noffset = fit_conf_get_node(fit, uconfig);\n\n\t\t\ti = 0;\n\t\t\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset,\n\t\t\t\t\t\t\t     FIT_FDT_PROP);\n\t\t}\n\n\t\tdebug(\"%d: using uname=%s uconfig=%s\\n\", i, uname, uconfig);\n\n\t\tov_noffset = fit_image_load(images,\n\t\t\taddr, &uname, &uconfig,\n\t\t\tarch, IH_TYPE_FLATDT,\n\t\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\t\tFIT_LOAD_REQUIRED, &ovload, &ovlen);\n\t\tif (ov_noffset < 0) {\n\t\t\tprintf(\"load of %s failed\\n\", uname);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%s loaded at 0x%08lx len=0x%08lx\\n\",\n\t\t\t\tuname, ovload, ovlen);\n\t\tov = map_sysmem(ovload, ovlen);\n\n\t\tbase = map_sysmem(load, len + ovlen);\n\t\terr = fdt_open_into(base, base, len + ovlen);\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed on fdt_open_into\\n\");\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\t/* the verbose method prints out messages on error */\n\t\terr = fdt_overlay_apply_verbose(base, ov);\n\t\tif (err < 0) {\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\tfdt_pack(base);\n\t\tlen = fdt_totalsize(base);\n\t}\n#else\n\tprintf(\"config with overlays but CONFIG_OF_LIBFDT_OVERLAY not set\\n\");\n\tfdt_noffset = -EBADF;\n#endif\n\nout:\n\tif (datap)\n\t\t*datap = load;\n\tif (lenp)\n\t\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = fit_uname_config;\n\n\tif (fit_uname_config_copy)\n\t\tfree(fit_uname_config_copy);\n\treturn fdt_noffset;\n}\n#endif\n"], "filenames": ["common/Kconfig.boot", "common/image-fit.c"], "buggy_code_start_loc": [65, 1582], "buggy_code_end_loc": [170, 1582], "fixing_code_start_loc": [66, 1583], "fixing_code_end_loc": [191, 1599], "type": "NVD-CWE-noinfo", "message": "The boot loader in Das U-Boot before 2021.04-rc2 mishandles a modified FIT.", "other": {"cve": {"id": "CVE-2021-27097", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-17T23:15:13.653", "lastModified": "2021-02-23T23:43:48.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The boot loader in Das U-Boot before 2021.04-rc2 mishandles a modified FIT."}, {"lang": "es", "value": "El cargador de arranque en Das U-Boot versiones anteriores a 2021.04-rc2, maneja inapropiadamente un FIT modificado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve@mitre.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2021.01", "matchCriteriaId": "A5899D85-92F8-4CB2-879B-E75488D8471C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2021.04:rc1:*:*:*:*:*:*", "matchCriteriaId": "E7B5BAFE-DC47-41E2-94D9-15A7DC1E3E28"}]}]}], "references": [{"url": "https://github.com/u-boot/u-boot/commit/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/u-boot/u-boot/commit/8a7d4cf9820ea16fabd25a6379351b4dc291204b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/u-boot/u-boot/commit/b6f4c757959f8850e1299a77c8e5713da78e8ec0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/u-boot/u-boot/commit/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01"}}