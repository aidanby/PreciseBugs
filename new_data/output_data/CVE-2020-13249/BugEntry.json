{"buggy_code": ["/************************************************************************************\n    Copyright (C) 2000, 2012 MySQL AB & MySQL Finland AB & TCX DataKonsult AB,\n                 Monty Program AB\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc.,\n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA\n\n   Part of this code includes code from the PHP project which\n   is freely available from http://www.php.net\n*************************************************************************************/\n\n#include <ma_global.h>\n\n#include <ma_sys.h>\n#include <ma_string.h>\n#include <mariadb_ctype.h>\n#include <ma_common.h>\n#include \"ma_priv.h\"\n#include \"ma_context.h\"\n#include \"mysql.h\"\n#include \"mariadb_version.h\"\n#include \"ma_server_error.h\"\n#include <mariadb/ma_io.h>\n#include \"errmsg.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <time.h>\n#include <mariadb_dyncol.h>\n\n#ifndef __has_feature\n# define __has_feature(x) 0\n#endif\n\n#ifdef HAVE_PWD_H\n#include <pwd.h>\n#endif\n#if !defined(MSDOS) && !defined(_WIN32)\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#ifdef HAVE_SELECT_H\n#  include <select.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#endif\n#ifdef HAVE_SYS_UN_H\n#  include <sys/un.h>\n#endif\n#ifndef INADDR_NONE\n#define INADDR_NONE -1\n#endif\n#include <ma_sha1.h>\n#ifndef _WIN32\n#include <poll.h>\n#endif\n#include <ma_pvio.h>\n#ifdef HAVE_TLS\n#include <ma_tls.h>\n#endif\n#include <mysql/client_plugin.h>\n#ifdef _WIN32\n#include \"Shlwapi.h\"\n#define strncasecmp _strnicmp\n#endif\n\n#define ASYNC_CONTEXT_DEFAULT_STACK_SIZE (4096*15)\n#define MA_RPL_VERSION_HACK \"5.5.5-\"\n\n#undef max_allowed_packet\n#undef net_buffer_length\nextern ulong max_allowed_packet; /* net.c */\nextern ulong net_buffer_length;  /* net.c */\n\nstatic MYSQL_PARAMETERS mariadb_internal_parameters= {&max_allowed_packet, &net_buffer_length, 0};\nstatic my_bool mysql_client_init=0;\nstatic void mysql_close_options(MYSQL *mysql);\nstatic void ma_clear_session_state(MYSQL *mysql);\nextern void release_configuration_dirs();\nextern char **get_default_configuration_dirs();\nextern my_bool  ma_init_done;\nextern my_bool  mysql_ps_subsystem_initialized;\nextern my_bool mysql_handle_local_infile(MYSQL *mysql, const char *filename, my_bool can_local_infile);\nextern const MARIADB_CHARSET_INFO * mysql_find_charset_nr(uint charsetnr);\nextern const MARIADB_CHARSET_INFO * mysql_find_charset_name(const char * const name);\nextern my_bool set_default_charset_by_name(const char *cs_name, myf flags __attribute__((unused)));\nextern int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,\n                           const char *data_plugin, const char *db);\nextern int net_add_multi_command(NET *net, uchar command, const uchar *packet,\n                                 size_t length);\n\nextern LIST *pvio_callback;\n\n/* prepare statement methods from my_stmt.c */\nextern my_bool mthd_supported_buffer_type(enum enum_field_types type);\nextern my_bool mthd_stmt_read_prepare_response(MYSQL_STMT *stmt);\nextern my_bool mthd_stmt_get_param_metadata(MYSQL_STMT *stmt);\nextern my_bool mthd_stmt_get_result_metadata(MYSQL_STMT *stmt);\nextern int mthd_stmt_fetch_row(MYSQL_STMT *stmt, unsigned char **row);\nextern int mthd_stmt_fetch_to_bind(MYSQL_STMT *stmt, unsigned char *row);\nextern int mthd_stmt_read_all_rows(MYSQL_STMT *stmt);\nextern void mthd_stmt_flush_unbuffered(MYSQL_STMT *stmt);\nextern my_bool _mariadb_read_options(MYSQL *mysql, const char *dir, const char *config_file, char *group, unsigned int recursion);\nextern unsigned char *mysql_net_store_length(unsigned char *packet, size_t length);\n\nextern void\nmy_context_install_suspend_resume_hook(struct mysql_async_context *b,\n                                       void (*hook)(my_bool, void *),\n                                       void *user_data);\n\nuint mysql_port=0;\nmy_string mysql_unix_port=0;\n\n#define CONNECT_TIMEOUT 0\n\nstruct st_mariadb_methods MARIADB_DEFAULT_METHODS;\n\n#if defined(MSDOS) || defined(_WIN32)\n// socket_errno is defined in ma_global.h for all platforms\n#define perror(A)\n#else\n#include <errno.h>\n#define SOCKET_ERROR -1\n#endif /* _WIN32 */\n\n#include <mysql/client_plugin.h>\n\n#define IS_CONNHDLR_ACTIVE(mysql)\\\n  ((mysql)->extension && (mysql)->extension->conn_hdlr)\n\nstatic void end_server(MYSQL *mysql);\nstatic void mysql_close_memory(MYSQL *mysql);\nvoid read_user_name(char *name);\nmy_bool STDCALL mariadb_reconnect(MYSQL *mysql);\nstatic int cli_report_progress(MYSQL *mysql, uchar *packet, uint length);\n\nextern int mysql_client_plugin_init();\nextern void mysql_client_plugin_deinit();\n\n/* net_get_error */\nvoid net_get_error(char *buf, size_t buf_len,\n       char *error, size_t error_len,\n       unsigned int *error_no,\n       char *sqlstate)\n{\n  char *p= buf;\n  size_t error_msg_len= 0;\n\n  if (buf_len > 2)\n  {\n    *error_no= uint2korr(p);\n    p+= 2;\n\n    /* since 4.1 sqlstate is following */\n    if (*p == '#')\n    {\n      memcpy(sqlstate, ++p, SQLSTATE_LENGTH);\n      p+= SQLSTATE_LENGTH;\n    }\n    error_msg_len= buf_len - (p - buf);\n    error_msg_len= MIN(error_msg_len, error_len - 1);\n    memcpy(error, p, error_msg_len);\n  }\n  else\n  {\n    *error_no= CR_UNKNOWN_ERROR;\n    memcpy(sqlstate, SQLSTATE_UNKNOWN, SQLSTATE_LENGTH);\n  }\n}\n\n/*****************************************************************************\n** read a packet from server. Give error message if socket was down\n** or packet is an error message\n*****************************************************************************/\n\nulong\nma_net_safe_read(MYSQL *mysql)\n{\n  NET *net= &mysql->net;\n  ulong len=0;\n\nrestart:\n  if (net->pvio != 0)\n    len=ma_net_read(net);\n\n  if (len == packet_error || len == 0)\n  {\n    end_server(mysql);\n    my_set_error(mysql, net->last_errno == ER_NET_PACKET_TOO_LARGE ?\n\t\t     CR_NET_PACKET_TOO_LARGE:\n\t\t     CR_SERVER_LOST,\n         SQLSTATE_UNKNOWN, 0, errno);\n    return(packet_error);\n  }\n  if (net->read_pos[0] == 255)\n  {\n    if (len > 3)\n    {\n      char *pos=(char*) net->read_pos+1;\n      uint last_errno=uint2korr(pos);\n      pos+=2;\n      len-=2;\n\n      if (last_errno== 65535 &&\n          ((mariadb_connection(mysql) && (mysql->server_capabilities & CLIENT_PROGRESS)) ||\n           (!(mysql->extension->mariadb_server_capabilities & MARIADB_CLIENT_PROGRESS << 32))))\n      {\n        if (cli_report_progress(mysql, (uchar *)pos, (uint) (len-1)))\n        {\n          /* Wrong packet */\n          my_set_error(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n          return (packet_error);\n        }\n        goto restart;\n      }\n      net->last_errno= last_errno;\n      if (pos[0]== '#')\n      {\n        ma_strmake(net->sqlstate, pos+1, SQLSTATE_LENGTH);\n        pos+= SQLSTATE_LENGTH + 1;\n      }\n      else\n      {\n        strncpy(net->sqlstate, SQLSTATE_UNKNOWN, SQLSTATE_LENGTH);\n      }\n      ma_strmake(net->last_error,(char*) pos,\n              min(len,sizeof(net->last_error)-1));\n    }\n    else\n    {\n      my_set_error(mysql, CR_UNKNOWN_ERROR, SQLSTATE_UNKNOWN, 0);\n    }\n\n    mysql->server_status&= ~SERVER_MORE_RESULTS_EXIST;\n\n    return(packet_error);\n  }\n  return len;\n}\n\n/*\n  Report progress to the client\n\n  RETURN VALUES\n    0  ok\n    1  error\n*/\nstatic int cli_report_progress(MYSQL *mysql, uchar *packet, uint length)\n{\n  uint stage, max_stage, proc_length;\n  double progress;\n  uchar *start= packet;\n\n  if (length < 5)\n    return 1;                         /* Wrong packet */\n\n  if (!(mysql->options.extension && mysql->options.extension->report_progress))\n    return 0;                         /* No callback, ignore packet */\n\n  packet++;                           /* Ignore number of strings */\n  stage= (uint) *packet++;\n  max_stage= (uint) *packet++;\n  progress= uint3korr(packet)/1000.0;\n  packet+= 3;\n  proc_length= net_field_length(&packet);\n  if (packet + proc_length > start + length)\n    return 1;                         /* Wrong packet */\n  (*mysql->options.extension->report_progress)(mysql, stage, max_stage,\n                                               progress, (char*) packet,\n                                               proc_length);\n  return 0;\n}\n\n/* Get the length of next field. Change parameter to point at fieldstart */\nulong\nnet_field_length(uchar **packet)\n{\n  reg1 uchar *pos= *packet;\n  if (*pos < 251)\n  {\n    (*packet)++;\n    return (ulong) *pos;\n  }\n  if (*pos == 251)\n  {\n    (*packet)++;\n    return NULL_LENGTH;\n  }\n  if (*pos == 252)\n  {\n    (*packet)+=3;\n    return (ulong) uint2korr(pos+1);\n  }\n  if (*pos == 253)\n  {\n    (*packet)+=4;\n    return (ulong) uint3korr(pos+1);\n  }\n  (*packet)+=9;\t\t\t\t\t/* Must be 254 when here */\n  return (ulong) uint4korr(pos+1);\n}\n\n/* Same as above, but returns ulonglong values */\n\nstatic unsigned long long\nnet_field_length_ll(uchar **packet)\n{\n  reg1 uchar *pos= *packet;\n  if (*pos < 251)\n  {\n    (*packet)++;\n    return (unsigned long long) *pos;\n  }\n  if (*pos == 251)\n  {\n    (*packet)++;\n    return (unsigned long long) NULL_LENGTH;\n  }\n  if (*pos == 252)\n  {\n    (*packet)+=3;\n    return (unsigned long long) uint2korr(pos+1);\n  }\n  if (*pos == 253)\n  {\n    (*packet)+=4;\n    return (unsigned long long) uint3korr(pos+1);\n  }\n  (*packet)+=9;\t\t\t\t\t/* Must be 254 when here */\n#ifdef NO_CLIENT_LONGLONG\n  return (unsigned long long) uint4korr(pos+1);\n#else\n  return (unsigned long long) uint8korr(pos+1);\n#endif\n}\n\n\nvoid free_rows(MYSQL_DATA *cur)\n{\n  if (cur)\n  {\n    ma_free_root(&cur->alloc,MYF(0));\n    free(cur);\n  }\n}\n\nint\nmthd_my_send_cmd(MYSQL *mysql,enum enum_server_command command, const char *arg,\n\t       size_t length, my_bool skipp_check, void *opt_arg)\n{\n  NET *net= &mysql->net;\n  int result= -1;\n  if (mysql->net.pvio == 0)\n  {\n    /* Do reconnect if possible */\n    if (mariadb_reconnect(mysql))\n      return(1);\n  }\n  if (mysql->status != MYSQL_STATUS_READY ||\n      mysql->server_status & SERVER_MORE_RESULTS_EXIST)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    goto end;\n  }\n\n  if (IS_CONNHDLR_ACTIVE(mysql))\n  {\n    result= mysql->extension->conn_hdlr->plugin->set_connection(mysql, command, arg, length, skipp_check, opt_arg);\n    if (result== -1)\n      return(result);\n  }\n\n  CLEAR_CLIENT_ERROR(mysql);\n\n  mysql->info=0;\n  mysql->affected_rows= ~(unsigned long long) 0;\n  ma_net_clear(net);\t\t\t/* Clear receive buffer */\n  if (!arg)\n    arg=\"\";\n\n  if (net->extension->multi_status== COM_MULTI_ENABLED)\n  {\n    return net_add_multi_command(net, command, (const uchar *)arg, length);\n  }\n\n  if (ma_net_write_command(net,(uchar) command,arg,\n\t\t\tlength ? length : (ulong) strlen(arg), 0))\n  {\n    if (net->last_errno == ER_NET_PACKET_TOO_LARGE)\n    {\n      my_set_error(mysql, CR_NET_PACKET_TOO_LARGE, SQLSTATE_UNKNOWN, 0);\n      goto end;\n    }\n    end_server(mysql);\n    if (mariadb_reconnect(mysql))\n      goto end;\n    if (ma_net_write_command(net,(uchar) command,arg,\n\t\t\t  length ? length : (ulong) strlen(arg), 0))\n    {\n      my_set_error(mysql, CR_SERVER_GONE_ERROR, SQLSTATE_UNKNOWN, 0);\n      goto end;\n    }\n  }\n  result=0;\n\n  if (net->extension->multi_status > COM_MULTI_OFF)\n    skipp_check= 1;\n\n  if (!skipp_check)\n  {\n    result= ((mysql->packet_length=ma_net_safe_read(mysql)) == packet_error ?\n\t     1 : 0);\n  }\n end:\n  return(result);\n}\n\nint\nma_simple_command(MYSQL *mysql,enum enum_server_command command, const char *arg,\n\t       size_t length, my_bool skipp_check, void *opt_arg)\n{\n  if ((mysql->options.client_flag & CLIENT_LOCAL_FILES) &&\n       mysql->options.extension && mysql->extension->auto_local_infile == WAIT_FOR_QUERY &&\n       arg && (*arg == 'l' || *arg == 'L') &&\n       command == COM_QUERY)\n  {\n    if (strncasecmp(arg, \"load\", 4) == 0)\n      mysql->extension->auto_local_infile= ACCEPT_FILE_REQUEST;\n  }\n  return mysql->methods->db_command(mysql, command, arg, length, skipp_check, opt_arg);\n}\n\nint ma_multi_command(MYSQL *mysql, enum enum_multi_status status)\n{\n  NET *net= &mysql->net;\n\n  switch (status) {\n  case COM_MULTI_OFF:\n    ma_net_clear(net);\n    net->extension->multi_status= status;\n    return 0;\n  case COM_MULTI_ENABLED:\n    if (net->extension->multi_status > COM_MULTI_DISABLED)\n      return 1;\n    ma_net_clear(net);\n    net->extension->multi_status= status;\n    return 0;\n  case COM_MULTI_DISABLED:\n    /* Opposite to COM_MULTI_OFF we don't clear net buffer,\n       next command or com_nulti_end will flush entire buffer */\n    net->extension->multi_status= status;\n    return 0;\n  case COM_MULTI_END:\n  {\n    size_t len= net->write_pos - net->buff - NET_HEADER_SIZE;\n\n    if (len < NET_HEADER_SIZE) /* don't send empty COM_MULTI */\n    {\n      ma_net_clear(net);\n      return 1;\n    }\n    net->extension->multi_status= COM_MULTI_OFF;\n    return ma_net_flush(net);\n  }\n  case COM_MULTI_CANCEL:\n    ma_net_clear(net);\n    net->extension->multi_status= COM_MULTI_OFF;\n    return 0;\n  default:\n    return 1;\n  }\n}\n\nstatic void free_old_query(MYSQL *mysql)\n{\n  if (mysql->fields)\n    ma_free_root(&mysql->field_alloc,MYF(0));\n  ma_init_alloc_root(&mysql->field_alloc,8192,0);\t/* Assume rowlength < 8192 */\n  mysql->fields=0;\n  mysql->field_count=0;\t\t\t\t/* For API */\n  mysql->info= 0;\n  return;\n}\n\n#if defined(HAVE_GETPWUID) && defined(NO_GETPWUID_DECL)\nstruct passwd *getpwuid(uid_t);\nchar* getlogin(void);\n#endif\n\n#if !defined(_WIN32)\nvoid read_user_name(char *name)\n{\n  if (geteuid() == 0)\n    strcpy(name,\"root\");\t\t/* allow use of surun */\n  else\n  {\n#ifdef HAVE_GETPWUID\n    struct passwd *skr;\n    const char *str;\n    if ((skr=getpwuid(geteuid())) != NULL)\n    {\n      str=skr->pw_name;\n    } else if ((str=getlogin()) == NULL)\n    {\n      if (!(str=getenv(\"USER\")) && !(str=getenv(\"LOGNAME\")) &&\n               !(str=getenv(\"LOGIN\")))\n        str=\"UNKNOWN_USER\";\n    }\n    ma_strmake(name,str,USERNAME_LENGTH);\n#elif defined(HAVE_CUSERID)\n    (void) cuserid(name);\n#else\n    ma_strmake(name,\"UNKNOWN_USER\", USERNAME_LENGTH);\n#endif\n  }\n  return;\n}\n\n#else /* If MSDOS || VMS */\n\nvoid read_user_name(char *name)\n{\n  char *str=getenv(\"USERNAME\");\t\t/* ODBC will send user variable */\n  ma_strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}\n\n#endif\n\n\n/**************************************************************************\n** Shut down connection\n**************************************************************************/\n\nstatic void\nend_server(MYSQL *mysql)\n{\n  /* if net->error 2 and reconnect is activated, we need to inforn\n     connection handler */\n  if (mysql->net.pvio != 0)\n  {\n    ma_pvio_close(mysql->net.pvio);\n    mysql->net.pvio= 0;    /* Marker */\n  }\n  ma_net_end(&mysql->net);\n  free_old_query(mysql);\n  return;\n}\n\nvoid mthd_my_skip_result(MYSQL *mysql)\n{\n  ulong pkt_len;\n\n  do {\n    pkt_len= ma_net_safe_read(mysql);\n    if (pkt_len == packet_error)\n      break;\n  } while (pkt_len > 8 || mysql->net.read_pos[0] != 254);\n  return;\n}\n\nvoid STDCALL\nmysql_free_result(MYSQL_RES *result)\n{\n  if (result)\n  {\n    if (result->handle && result->handle->status == MYSQL_STATUS_USE_RESULT)\n    {\n      result->handle->methods->db_skip_result(result->handle);\n      result->handle->status=MYSQL_STATUS_READY;\n    }\n    free_rows(result->data);\n    if (result->fields)\n      ma_free_root(&result->field_alloc,MYF(0));\n    if (result->row)\n      free(result->row);\n    free(result);\n  }\n  return;\n}\n\n\n/****************************************************************************\n** Get options from my.cnf\n****************************************************************************/\nenum enum_option_type {\n  MARIADB_OPTION_NONE,\n  MARIADB_OPTION_BOOL,\n  MARIADB_OPTION_INT,\n  MARIADB_OPTION_SIZET,\n  MARIADB_OPTION_STR,\n};\n\nstruct st_default_options {\n  enum mysql_option option;\n  enum enum_option_type type;\n  const char *conf_key;\n};\n\nstruct st_default_options mariadb_defaults[] =\n{\n  {MARIADB_OPT_PORT, MARIADB_OPTION_INT,\"port\"},\n  {MARIADB_OPT_UNIXSOCKET, MARIADB_OPTION_STR, \"socket\"},\n  {MYSQL_OPT_COMPRESS, MARIADB_OPTION_BOOL, \"compress\"},\n  {MARIADB_OPT_PASSWORD, MARIADB_OPTION_STR, \"password\"},\n  {MYSQL_OPT_NAMED_PIPE, MARIADB_OPTION_BOOL, \"pipe\"},\n  {MYSQL_OPT_CONNECT_TIMEOUT, MARIADB_OPTION_INT, \"timeout\"},\n  {MARIADB_OPT_USER, MARIADB_OPTION_STR, \"user\"},\n  {MYSQL_INIT_COMMAND, MARIADB_OPTION_STR, \"init-command\"},\n  {MARIADB_OPT_HOST, MARIADB_OPTION_STR, \"host\"},\n  {MARIADB_OPT_SCHEMA, MARIADB_OPTION_STR, \"database\"},\n  {MARIADB_OPT_DEBUG, MARIADB_OPTION_STR, \"debug\"},\n  {MARIADB_OPT_FOUND_ROWS, MARIADB_OPTION_NONE, \"return-found-rows\"},\n  {MYSQL_OPT_SSL_KEY, MARIADB_OPTION_STR, \"ssl-key\"},\n  {MYSQL_OPT_SSL_CERT, MARIADB_OPTION_STR,\"ssl-cert\"},\n  {MYSQL_OPT_SSL_CA, MARIADB_OPTION_STR,\"ssl-ca\"},\n  {MYSQL_OPT_SSL_CAPATH, MARIADB_OPTION_STR,\"ssl-capath\"},\n  {MYSQL_OPT_SSL_CRL, MARIADB_OPTION_STR,\"ssl-crl\"},\n  {MYSQL_OPT_SSL_CRLPATH, MARIADB_OPTION_STR,\"ssl-crlpath\"},\n  {MYSQL_OPT_SSL_VERIFY_SERVER_CERT, MARIADB_OPTION_BOOL,\"ssl-verify-server-cert\"},\n  {MYSQL_SET_CHARSET_DIR, MARIADB_OPTION_STR, \"character-sets-dir\"},\n  {MYSQL_SET_CHARSET_NAME, MARIADB_OPTION_STR, \"default-character-set\"},\n  {MARIADB_OPT_INTERACTIVE, MARIADB_OPTION_NONE, \"interactive-timeout\"},\n  {MYSQL_OPT_CONNECT_TIMEOUT, MARIADB_OPTION_INT, \"connect-timeout\"},\n  {MYSQL_OPT_LOCAL_INFILE, MARIADB_OPTION_BOOL, \"local-infile\"},\n  {0, 0 ,\"disable-local-infile\",},\n  {MYSQL_OPT_SSL_CIPHER, MARIADB_OPTION_STR, \"ssl-cipher\"},\n  {MYSQL_OPT_MAX_ALLOWED_PACKET, MARIADB_OPTION_SIZET, \"max-allowed-packet\"},\n  {MYSQL_OPT_NET_BUFFER_LENGTH, MARIADB_OPTION_SIZET, \"net-buffer-length\"},\n  {MYSQL_OPT_PROTOCOL, MARIADB_OPTION_INT, \"protocol\"},\n  {MYSQL_SHARED_MEMORY_BASE_NAME, MARIADB_OPTION_STR,\"shared-memory-base-name\"},\n  {MARIADB_OPT_MULTI_RESULTS, MARIADB_OPTION_NONE, \"multi-results\"},\n  {MARIADB_OPT_MULTI_STATEMENTS, MARIADB_OPTION_STR, \"multi-statements\"},\n  {MARIADB_OPT_MULTI_STATEMENTS, MARIADB_OPTION_STR, \"multi-queries\"},\n  {MYSQL_SECURE_AUTH, MARIADB_OPTION_BOOL, \"secure-auth\"},\n  {MYSQL_REPORT_DATA_TRUNCATION, MARIADB_OPTION_BOOL, \"report-data-truncation\"},\n  {MYSQL_OPT_RECONNECT, MARIADB_OPTION_BOOL, \"reconnect\"},\n  {MYSQL_PLUGIN_DIR, MARIADB_OPTION_STR, \"plugin-dir\"},\n  {MYSQL_DEFAULT_AUTH, MARIADB_OPTION_STR, \"default-auth\"},\n  {MARIADB_OPT_SSL_FP, MARIADB_OPTION_STR, \"ssl-fp\"},\n  {MARIADB_OPT_SSL_FP_LIST, MARIADB_OPTION_STR, \"ssl-fp-list\"},\n  {MARIADB_OPT_SSL_FP_LIST, MARIADB_OPTION_STR, \"ssl-fplist\"},\n  {MARIADB_OPT_TLS_PASSPHRASE, MARIADB_OPTION_STR, \"ssl-passphrase\"},\n  {MARIADB_OPT_TLS_VERSION, MARIADB_OPTION_STR, \"tls-version\"},\n  {MYSQL_SERVER_PUBLIC_KEY, MARIADB_OPTION_STR, \"server-public-key\"},\n  {MYSQL_OPT_BIND, MARIADB_OPTION_STR, \"bind-address\"},\n  {MYSQL_OPT_SSL_ENFORCE, MARIADB_OPTION_BOOL, \"ssl-enforce\"},\n  {0, 0, NULL}\n};\n\n#define CHECK_OPT_EXTENSION_SET(OPTS)\\\n    if (!(OPTS)->extension)                                     \\\n      (OPTS)->extension= (struct st_mysql_options_extension *)  \\\n        calloc(1, sizeof(struct st_mysql_options_extension));\n\n#define OPT_SET_EXTENDED_VALUE_STR(OPTS, KEY, VAL)               \\\n    CHECK_OPT_EXTENSION_SET(OPTS)                                \\\n    free((gptr)(OPTS)->extension->KEY);                          \\\n    if((VAL))                                                   \\\n      (OPTS)->extension->KEY= strdup((char *)(VAL));             \\\n    else                                                         \\\n      (OPTS)->extension->KEY= NULL\n\n#define OPT_SET_EXTENDED_VALUE(OPTS, KEY, VAL)                \\\n    CHECK_OPT_EXTENSION_SET(OPTS)                                 \\\n    (OPTS)->extension->KEY= (VAL)\n\n#define OPT_SET_EXTENDED_VALUE_INT(A,B,C) OPT_SET_EXTENDED_VALUE(A,B,C)\n\n#define OPT_SET_VALUE_STR(OPTS, KEY, VAL)                        \\\n    free((OPTS)->KEY);                                           \\\n    if((VAL))                                                   \\\n      (OPTS)->KEY= strdup((char *)(VAL));                        \\\n    else                                                         \\\n      (OPTS)->KEY= NULL\n\n#define OPT_SET_VALUE_INT(OPTS, KEY, VAL)                         \\\n    (OPTS)->KEY= (VAL)\n\nstatic void options_add_initcommand(struct st_mysql_options *options,\n                                     const char *init_cmd)\n{\n  char *insert= strdup(init_cmd);\n  if (!options->init_command)\n  {\n    options->init_command= (DYNAMIC_ARRAY*)malloc(sizeof(DYNAMIC_ARRAY));\n    ma_init_dynamic_array(options->init_command, sizeof(char*), 5, 5);\n  }\n\n  if (ma_insert_dynamic(options->init_command, (gptr)&insert))\n    free(insert);\n}\nmy_bool _mariadb_set_conf_option(MYSQL *mysql, const char *config_option, const char *config_value)\n{\n  if (config_option)\n  {\n    int i;\n    char *c;\n    \n    /* CONC-395: replace underscore \"_\" by dash \"-\" */\n    while ((c= strchr(config_option, '_')))\n      *c= '-';\n\n    for (i=0; mariadb_defaults[i].conf_key; i++)\n    {\n      if (!strcmp(mariadb_defaults[i].conf_key, config_option))\n      {\n        my_bool val_bool;\n        int     val_int;\n        size_t  val_sizet;\n        int rc;\n        void *option_val= NULL;\n        switch (mariadb_defaults[i].type) {\n        case MARIADB_OPTION_BOOL:\n          val_bool= 0;\n          if (config_value)\n            val_bool= atoi(config_value);\n          option_val= &val_bool;\n          break;\n        case MARIADB_OPTION_INT:\n          val_int= 0;\n          if (config_value)\n            val_int= atoi(config_value);\n          option_val= &val_int;\n          break;\n        case MARIADB_OPTION_SIZET:\n          val_sizet= 0;\n          if (config_value)\n            val_sizet= strtol(config_value, NULL, 10);\n          option_val= &val_sizet;\n          break;\n        case MARIADB_OPTION_STR:\n          option_val= (void*)config_value;\n          break;\n        case MARIADB_OPTION_NONE:\n          break;\n        }\n        rc= mysql_optionsv(mysql, mariadb_defaults[i].option, option_val);\n        return(test(rc));\n      }\n    }\n  }\n  /* unknown key */\n  return 1;\n}\n\n\nstatic MARIADB_CONST_STRING null_const_string= {0,0};\n\n/***************************************************************************\n** Allocate a string copy on memroot\n***************************************************************************/\nstatic MARIADB_CONST_STRING ma_const_string_copy_root(MA_MEM_ROOT *memroot,\n                                                      const char *str,\n                                                      size_t length)\n{\n  MARIADB_CONST_STRING res;\n  if (!str || !(res.str= ma_memdup_root(memroot, str, length)))\n    return null_const_string;\n  res.length= length;\n  return res;\n}\n\n\n/***************************************************************************\n** Allocate and initialize MA_FIELD_EXTENSION\n***************************************************************************/\nMA_FIELD_EXTENSION *new_ma_field_extension(MA_MEM_ROOT *memroot)\n{\n  MA_FIELD_EXTENSION *ext= ma_alloc_root(memroot, sizeof(MA_FIELD_EXTENSION));\n  if (ext)\n    memset((void *) ext, 0, sizeof(*ext));\n  return ext;\n}\n\n\n/***************************************************************************\n** Populate field extension from a type info packet\n***************************************************************************/\n\nstatic void ma_field_extension_init_type_info(MA_MEM_ROOT *memroot,\n                                              MA_FIELD_EXTENSION *ext,\n                                              const char *ptr, size_t length)\n{\n  const char *end= ptr + length;\n  for ( ;  ptr < end; )\n  {\n    uint itype= (uchar) *ptr++;\n    uint len= (uchar) *ptr++;\n    if (ptr + len > end  || len > 127)\n      break; /*Badly encoded data*/\n    if (itype <= 127 && itype <= MARIADB_FIELD_ATTR_LAST)\n      ext->metadata[itype]= ma_const_string_copy_root(memroot, ptr, len);\n    ptr+= len;\n  }\n}\n\n\n/***************************************************************************\n** Allocate a field extension deep copy\n***************************************************************************/\n\nMA_FIELD_EXTENSION *ma_field_extension_deep_dup(MA_MEM_ROOT *memroot,\n                                                const MA_FIELD_EXTENSION *from)\n{\n  MA_FIELD_EXTENSION *ext= new_ma_field_extension(memroot);\n  uint i;\n  if (!ext)\n    return NULL;\n  for (i= 0; i < MARIADB_FIELD_ATTR_LAST; i++)\n  {\n    if (from->metadata[i].str)\n      ext->metadata[i]= ma_const_string_copy_root(memroot,\n                                                  from->metadata[i].str,\n                                                  from->metadata[i].length);\n  }\n  return ext;\n}\n\n/***************************************************************************\n** Change field rows to field structs\n***************************************************************************/\n\nstatic size_t rset_field_offsets[]= {\n  OFFSET(MYSQL_FIELD, catalog),\n  OFFSET(MYSQL_FIELD, catalog_length),\n  OFFSET(MYSQL_FIELD, db),\n  OFFSET(MYSQL_FIELD, db_length),\n  OFFSET(MYSQL_FIELD, table),\n  OFFSET(MYSQL_FIELD, table_length),\n  OFFSET(MYSQL_FIELD, org_table),\n  OFFSET(MYSQL_FIELD, org_table_length),\n  OFFSET(MYSQL_FIELD, name),\n  OFFSET(MYSQL_FIELD, name_length),\n  OFFSET(MYSQL_FIELD, org_name),\n  OFFSET(MYSQL_FIELD, org_name_length)\n};\n\nMYSQL_FIELD *\nunpack_fields(const MYSQL *mysql,\n              MYSQL_DATA *data, MA_MEM_ROOT *alloc, uint fields,\n\t      my_bool default_value)\n{\n  MYSQL_ROWS\t*row;\n  MYSQL_FIELD\t*field,*result;\n  char    *p;\n  unsigned int i, field_count= sizeof(rset_field_offsets)/sizeof(size_t)/2;\n\n  field=result=(MYSQL_FIELD*) ma_alloc_root(alloc,sizeof(MYSQL_FIELD)*fields);\n  if (!result)\n    return(0);\n\n  for (row=data->data; row ; row = row->next,field++)\n  {\n    if (field >= result + fields)\n      goto error;\n\n    for (i=0; i < field_count; i++)\n    {\n      uint length= (uint)(row->data[i+1] - row->data[i] - 1);\n      if (!row->data[i] && row->data[i][length])\n        goto error;\n\n      *(char **)(((char *)field) + rset_field_offsets[i*2])=\n        ma_strdup_root(alloc, (char *)row->data[i]);\n      *(unsigned int *)(((char *)field) + rset_field_offsets[i*2+1])= length;\n    }\n\n    field->extension= NULL;\n    if (ma_has_extended_type_info(mysql))\n    {\n      if (row->data[i+1] - row->data[i] > 1)\n      {\n        size_t len= row->data[i+1] - row->data[i] - 1;\n        MA_FIELD_EXTENSION *ext= new_ma_field_extension(alloc);\n        if ((field->extension= ext))\n          ma_field_extension_init_type_info(alloc, ext, row->data[i], len);\n      }\n      i++;\n    }\n\n    p= (char *)row->data[i];\n    /* filler */\n    field->charsetnr= uint2korr(p);\n    p+= 2;\n    field->length= (uint) uint4korr(p);\n    p+= 4;\n    field->type=   (enum enum_field_types)uint1korr(p);\n    p++;\n    field->flags= uint2korr(p);\n    p+= 2;\n    field->decimals= (uint) p[0];\n    p++;\n\n    /* filler */\n    p+= 2;\n\n    if (INTERNAL_NUM_FIELD(field))\n      field->flags|= NUM_FLAG;\n\n    i++;\n    /* This is used by deprecated function mysql_list_fields only,\n       however the reported length is not correct, so we always zero it */\n    if (default_value && row->data[i])\n      field->def=ma_strdup_root(alloc,(char*) row->data[i]);\n    else\n      field->def=0;\n    field->def_length= 0;\n\n    field->max_length= 0;\n  }\n  if (field < result + fields)\n    goto error;\n  free_rows(data);\t\t\t\t/* Free old data */\n  return(result);\nerror:\n  free_rows(data);\n  ma_free_root(alloc, MYF(0));\n  return(0);\n}\n\n\n/* Read all rows (fields or data) from server */\n\nMYSQL_DATA *mthd_my_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,\n\t\t\t     uint fields)\n{\n  uint\tfield;\n  ulong pkt_len;\n  ulong len;\n  uchar *cp;\n  char\t*to, *end_to;\n  MYSQL_DATA *result;\n  MYSQL_ROWS **prev_ptr,*cur;\n  NET *net = &mysql->net;\n\n  if ((pkt_len= ma_net_safe_read(mysql)) == packet_error)\n    return(0);\n  if (!(result=(MYSQL_DATA*) calloc(1, sizeof(MYSQL_DATA))))\n  {\n    SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  ma_init_alloc_root(&result->alloc,8192,0);\t/* Assume rowlength < 8192 */\n  result->alloc.min_malloc=sizeof(MYSQL_ROWS);\n  prev_ptr= &result->data;\n  result->rows=0;\n  result->fields=fields;\n\n  while (*(cp=net->read_pos) != 254 || pkt_len >= 8)\n  {\n    result->rows++;\n    if (!(cur= (MYSQL_ROWS*) ma_alloc_root(&result->alloc,\n\t\t\t\t\t    sizeof(MYSQL_ROWS))) ||\n\t      !(cur->data= ((MYSQL_ROW)\n\t\t      ma_alloc_root(&result->alloc,\n\t\t\t\t     (fields+1)*sizeof(char *)+fields+pkt_len))))\n    {\n      free_rows(result);\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      return(0);\n    }\n    *prev_ptr=cur;\n    prev_ptr= &cur->next;\n    to= (char*) (cur->data+fields+1);\n    end_to=to+fields+pkt_len-1;\n    for (field=0 ; field < fields ; field++)\n    {\n      if ((len=(ulong) net_field_length(&cp)) == NULL_LENGTH)\n      {\t\t\t\t\t\t/* null field */\n        cur->data[field] = 0;\n      }\n      else\n      {\n        cur->data[field] = to;\n        if (len > (ulong)(end_to - to) || to > end_to)\n        {\n          free_rows(result);\n          SET_CLIENT_ERROR(mysql, CR_UNKNOWN_ERROR, SQLSTATE_UNKNOWN, 0);\n          return(0);\n        }\n        memcpy(to,(char*) cp,len); to[len]=0;\n        to+=len+1;\n        cp+=len;\n        if (mysql_fields)\n        {\n          if (mysql_fields[field].max_length < len)\n            mysql_fields[field].max_length=len;\n         }\n      }\n    }\n    cur->data[field]=to;\t\t\t/* End of last field */\n    if ((pkt_len=ma_net_safe_read(mysql)) == packet_error)\n    {\n      free_rows(result);\n      return(0);\n    }\n  }\n  *prev_ptr=0;\t\t\t\t\t/* last pointer is null */\n  /* save status */\n  if (pkt_len > 1)\n  {\n    cp++;\n    mysql->warning_count= uint2korr(cp);\n    cp+= 2;\n    mysql->server_status= uint2korr(cp);\n  }\n  return(result);\n}\n\n\n/*\n** Read one row. Uses packet buffer as storage for fields.\n** When next packet is read, the previous field values are destroyed\n*/\n\n\nint mthd_my_read_one_row(MYSQL *mysql,uint fields,MYSQL_ROW row, ulong *lengths)\n{\n  uint field;\n  ulong pkt_len,len;\n  uchar *pos,*prev_pos, *end_pos;\n\n  if ((pkt_len=(uint) ma_net_safe_read(mysql)) == packet_error)\n    return -1;\n\n  if (pkt_len <= 8 && mysql->net.read_pos[0] == 254)\n  {\n    mysql->warning_count= uint2korr(mysql->net.read_pos + 1);\n    mysql->server_status= uint2korr(mysql->net.read_pos + 3);\n    return 1;\t\t\t\t/* End of data */\n  }\n  prev_pos= 0;\t\t\t\t/* allowed to write at packet[-1] */\n  pos=mysql->net.read_pos;\n  end_pos=pos+pkt_len;\n  for (field=0 ; field < fields ; field++)\n  {\n    if ((len=(ulong) net_field_length(&pos)) == NULL_LENGTH)\n    {\t\t\t\t\t\t/* null field */\n      row[field] = 0;\n      *lengths++=0;\n    }\n    else\n    {\n      if (len > (ulong) (end_pos - pos) || pos > end_pos)\n      {\n        mysql->net.last_errno=CR_UNKNOWN_ERROR;\n        strncpy(mysql->net.last_error,ER(mysql->net.last_errno),\n                MYSQL_ERRMSG_SIZE - 1);\n        return -1;\n      }\n      row[field] = (char*) pos;\n      pos+=len;\n      *lengths++=len;\n    }\n    if (prev_pos)\n      *prev_pos=0;\t\t\t\t/* Terminate prev field */\n    prev_pos=pos;\n  }\n  row[field]=(char*) prev_pos+1;\t\t/* End of last field */\n  *prev_pos=0;\t\t\t\t\t/* Terminate last field */\n  return 0;\n}\n\n/****************************************************************************\n** Init MySQL structure or allocate one\n****************************************************************************/\n\nMYSQL * STDCALL\nmysql_init(MYSQL *mysql)\n{\n  if (mysql_server_init(0, NULL, NULL))\n    return NULL;\n  if (!mysql)\n  {\n    if (!(mysql=(MYSQL*) calloc(1, sizeof(MYSQL))))\n      return 0;\n    mysql->free_me=1;\n    mysql->net.pvio= 0;\n    mysql->net.extension= 0;\n  }\n  else\n  {\n    memset((char*) (mysql), 0, sizeof(*(mysql)));\n    mysql->net.pvio= 0;\n    mysql->free_me= 0;\n    mysql->net.extension= 0;\n  }\n\n  if (!(mysql->net.extension= (struct st_mariadb_net_extension *)\n                               calloc(1, sizeof(struct st_mariadb_net_extension))) ||\n      !(mysql->extension= (struct st_mariadb_extension *)\n                          calloc(1, sizeof(struct st_mariadb_extension))))\n    goto error;\n  mysql->options.report_data_truncation= 1;\n  mysql->options.connect_timeout=CONNECT_TIMEOUT;\n  mysql->charset= mysql_find_charset_name(MARIADB_DEFAULT_CHARSET);\n  mysql->methods= &MARIADB_DEFAULT_METHODS;\n  strcpy(mysql->net.sqlstate, \"00000\");\n  mysql->net.last_error[0]= mysql->net.last_errno= mysql->net.extension->extended_errno= 0;\n\n  if (ENABLED_LOCAL_INFILE != LOCAL_INFILE_MODE_OFF)\n    mysql->options.client_flag|= CLIENT_LOCAL_FILES;\n  mysql->extension->auto_local_infile= ENABLED_LOCAL_INFILE == LOCAL_INFILE_MODE_AUTO\n                                       ? WAIT_FOR_QUERY : ALWAYS_ACCEPT;\n  mysql->options.reconnect= 0;\n  return mysql;\nerror:\n  if (mysql->free_me)\n    free(mysql);\n  return 0;\n}\n\nint STDCALL\nmysql_ssl_set(MYSQL *mysql __attribute__((unused)),\n              const char *key __attribute__((unused)),\n              const char *cert __attribute__((unused)),\n              const char *ca __attribute__((unused)),\n              const char *capath __attribute__((unused)),\n              const char *cipher __attribute__((unused)))\n{\n#ifdef HAVE_TLS\n  char enable= 1;\n  return (mysql_optionsv(mysql, MYSQL_OPT_SSL_ENFORCE, &enable) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_KEY, key) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CERT, cert) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CA, ca) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CAPATH, capath) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CIPHER, cipher)) ? 1 : 0;\n#else\n  return 0;\n#endif\n}\n\n/**************************************************************************\n**************************************************************************/\n\nconst char * STDCALL\nmysql_get_ssl_cipher(MYSQL *mysql __attribute__((unused)))\n{\n#ifdef HAVE_TLS\n  if (mysql->net.pvio && mysql->net.pvio->ctls)\n  {\n    return ma_pvio_tls_cipher(mysql->net.pvio->ctls);\n  }\n#endif\n  return(NULL);\n}\n\n/**************************************************************************\n** Free strings in the SSL structure and clear 'use_ssl' flag.\n** NB! Errors are not reported until you do mysql_real_connect.\n**************************************************************************/\n\nchar *ma_send_connect_attr(MYSQL *mysql, unsigned char *buffer)\n{\n  if (mysql->server_capabilities & CLIENT_CONNECT_ATTRS)\n  {\n    buffer= (unsigned char *)mysql_net_store_length((unsigned char *)buffer, (mysql->options.extension) ?\n                             mysql->options.extension->connect_attrs_len : 0);\n    if (mysql->options.extension &&\n        hash_inited(&mysql->options.extension->connect_attrs))\n    {\n      uint i;\n      for (i=0; i < mysql->options.extension->connect_attrs.records; i++)\n      {\n        size_t len;\n        uchar *p= hash_element(&mysql->options.extension->connect_attrs, i);\n\n        len= strlen((char *)p);\n        buffer= mysql_net_store_length(buffer, len);\n        memcpy(buffer, p, len);\n        buffer+= (len);\n        p+= (len + 1);\n        len= strlen((char *)p);\n        buffer= mysql_net_store_length(buffer, len);\n        memcpy(buffer, p, len);\n        buffer+= len;\n      }\n    }\n  }\n  return (char *)buffer;\n}\n\n/** set some default attributes */\nstatic my_bool\nma_set_connect_attrs(MYSQL *mysql, const char *host)\n{\n  char buffer[255];\n  int rc= 0;\n\n  rc= mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_client_name\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_client_version\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_os\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_server_host\") +\n#ifdef _WIN32\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_thread\") +\n#endif\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_pid\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_platform\");\n\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_client_name\", \"libmariadb\")\n       + mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_client_version\", MARIADB_PACKAGE_VERSION)\n       + mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_os\", MARIADB_SYSTEM_TYPE);\n\n  if (host && *host)\n    rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_server_host\", host);\n\n#ifdef _WIN32\n  snprintf(buffer, 255, \"%lu\", (ulong) GetCurrentThreadId());\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_thread\", buffer);\n  snprintf(buffer, 255, \"%lu\", (ulong) GetCurrentProcessId());\n#else\n  snprintf(buffer, 255, \"%lu\", (ulong) getpid());\n#endif\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_pid\", buffer);\n\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_platform\", MARIADB_MACHINE_TYPE);\n  return(test(rc>0));\n}\n\n/*\n** Note that the mysql argument must be initialized with mysql_init()\n** before calling mysql_real_connect !\n*/\n\nMYSQL * STDCALL\nmysql_real_connect(MYSQL *mysql, const char *host, const char *user,\n\t\t   const char *passwd, const char *db,\n\t\t   uint port, const char *unix_socket,unsigned long client_flag)\n{\n  char *end= NULL;\n  char *connection_handler= (mysql->options.extension) ?\n                            mysql->options.extension->connection_handler : 0;\n\n  if (!mysql->methods)\n    mysql->methods= &MARIADB_DEFAULT_METHODS;\n\n  if (connection_handler ||\n      (host && (end= strstr(host, \"://\"))))\n  {\n    MARIADB_CONNECTION_PLUGIN *plugin;\n    char plugin_name[64];\n\n    if (!connection_handler || !connection_handler[0])\n    {\n      memset(plugin_name, 0, 64);\n      ma_strmake(plugin_name, host, MIN(end - host, 63));\n      end+= 3;\n    }\n    else\n      ma_strmake(plugin_name, connection_handler, MIN(63, strlen(connection_handler)));\n\n    if (!(plugin= (MARIADB_CONNECTION_PLUGIN *)mysql_client_find_plugin(mysql, plugin_name, MARIADB_CLIENT_CONNECTION_PLUGIN)))\n      return NULL;\n\n    if (!(mysql->extension->conn_hdlr= (MA_CONNECTION_HANDLER *)calloc(1, sizeof(MA_CONNECTION_HANDLER))))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      return NULL;\n    }\n\n    /* save URL for reconnect */\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, url, host);\n\n    mysql->extension->conn_hdlr->plugin= plugin;\n\n    if (plugin && plugin->connect)\n    {\n      MYSQL *my= plugin->connect(mysql, end, user, passwd, db, port, unix_socket, client_flag);\n      if (!my)\n      {\n        free(mysql->extension->conn_hdlr);\n        mysql->extension->conn_hdlr= NULL;\n      }\n      return my;\n    }\n  }\n#ifndef HAVE_SCHANNEL\n  return mysql->methods->db_connect(mysql, host, user, passwd,\n                                    db, port, unix_socket, client_flag);\n#else\n/* \n   With older windows versions (prior Win 10) TLS connections periodically\n   fail with SEC_E_INVALID_TOKEN, SEC_E_BUFFER_TOO_SMALL or SEC_E_MESSAGE_ALTERED\n   error (see MDEV-13492). If the connect attempt returns on of these error codes\n   in mysql->net.extended_errno we will try to connect again (max. 3 times)\n*/\n#define MAX_SCHANNEL_CONNECT_ATTEMPTS 3\n  {\n    int ssl_retry= (mysql->options.use_ssl) ? MAX_SCHANNEL_CONNECT_ATTEMPTS : 1;\n\tMYSQL *my= NULL;\n    while (ssl_retry)\n    {\n      if ((my= mysql->methods->db_connect(mysql, host, user, passwd,\n                                    db, port, unix_socket, client_flag | CLIENT_REMEMBER_OPTIONS)))\n        return my;\n\n      switch (mysql->net.extension->extended_errno) {\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_BUFFER_TOO_SMALL:\n        case SEC_E_MESSAGE_ALTERED:\n          ssl_retry--;\n          break;\n        default:\n          ssl_retry= 0;\n          break;\n      }\n    }\n    if (!my && !(client_flag & CLIENT_REMEMBER_OPTIONS))\n      mysql_close_options(mysql);\n    return my;\n  }\n#endif\n}\n\nMYSQL *mthd_my_real_connect(MYSQL *mysql, const char *host, const char *user,\n\t\t   const char *passwd, const char *db,\n\t\t   uint port, const char *unix_socket, unsigned long client_flag)\n{\n  char\t\tbuff[NAME_LEN+USERNAME_LENGTH+100];\n  char\t\t*end, *end_pkt, *host_info;\n  MA_PVIO_CINFO  cinfo= {NULL, NULL, 0, -1, NULL};\n  MARIADB_PVIO   *pvio= NULL;\n  char    *scramble_data;\n  my_bool is_maria= 0;\n  const char *scramble_plugin;\n  uint pkt_length, scramble_len, pkt_scramble_len= 0;\n  NET\t*net= &mysql->net;\n\n  if (!mysql->methods)\n    mysql->methods= &MARIADB_DEFAULT_METHODS;\n\n  if (net->pvio)  /* check if we are already connected */\n  {\n    SET_CLIENT_ERROR(mysql, CR_ALREADY_CONNECTED, SQLSTATE_UNKNOWN, 0);\n    return(NULL);\n  }\n\n  /* use default options */\n  if (mysql->options.my_cnf_file || mysql->options.my_cnf_group)\n  {\n    _mariadb_read_options(mysql, NULL,\n\t\t\t  (mysql->options.my_cnf_file ?\n\t\t\t   mysql->options.my_cnf_file : NULL),\n\t\t\t   mysql->options.my_cnf_group, 0);\n    free(mysql->options.my_cnf_file);\n    free(mysql->options.my_cnf_group);\n    mysql->options.my_cnf_file=mysql->options.my_cnf_group=0;\n  }\n\n  if (!host || !host[0])\n    host = mysql->options.host;\n\n  ma_set_connect_attrs(mysql, host);\n\n#ifndef WIN32\n  if (mysql->options.protocol > MYSQL_PROTOCOL_SOCKET)\n  {\n    SET_CLIENT_ERROR(mysql, CR_CONN_UNKNOWN_PROTOCOL, SQLSTATE_UNKNOWN, 0);\n    return(NULL);\n  }\n#endif\n\n  /* Some empty-string-tests are done because of ODBC */\n  if (!user || !user[0])\n    user=mysql->options.user;\n  if (!passwd)\n  {\n    passwd=mysql->options.password;\n#ifndef DONT_USE_MYSQL_PWD\n    if (!passwd)\n      passwd=getenv(\"MYSQL_PWD\");  /* get it from environment (haneke) */\n    if (!passwd)\n      passwd= \"\";\n#endif\n  }\n  if (!db || !db[0])\n    db=mysql->options.db;\n  if (!port)\n    port=mysql->options.port;\n  if (!unix_socket)\n    unix_socket=mysql->options.unix_socket;\n\n  mysql->server_status=SERVER_STATUS_AUTOCOMMIT;\n\n  /* try to connect via pvio_init */\n  cinfo.host= host;\n  cinfo.unix_socket= unix_socket;\n  cinfo.port= port;\n  cinfo.mysql= mysql;\n\n  /*\n  ** Grab a socket and connect it to the server\n  */\n#ifndef _WIN32\n#if defined(HAVE_SYS_UN_H)\n  if ((!host ||  strcmp(host,LOCAL_HOST) == 0) &&\n      mysql->options.protocol != MYSQL_PROTOCOL_TCP &&\n      (unix_socket || mysql_unix_port))\n  {\n    cinfo.host= LOCAL_HOST;\n    cinfo.unix_socket= (unix_socket) ? unix_socket : mysql_unix_port;\n    cinfo.type= PVIO_TYPE_UNIXSOCKET;\n    sprintf(host_info=buff,ER(CR_LOCALHOST_CONNECTION),cinfo.host);\n  }\n  else\n#endif\n#else\n  if (mysql->options.protocol == MYSQL_PROTOCOL_MEMORY)\n  {\n    cinfo.host= mysql->options.shared_memory_base_name;\n    cinfo.type= PVIO_TYPE_SHAREDMEM;\n    sprintf(host_info=buff,ER(CR_SHARED_MEMORY_CONNECTION), cinfo.host ? cinfo.host : SHM_DEFAULT_NAME);\n  }\n   /* named pipe */\n  else if (mysql->options.protocol == MYSQL_PROTOCOL_PIPE ||\n\t  (host && strcmp(host,LOCAL_HOST_NAMEDPIPE) == 0))\n  {\n    cinfo.type= PVIO_TYPE_NAMEDPIPE;\n    sprintf(host_info=buff,ER(CR_NAMEDPIPE_CONNECTION),cinfo.host);\n  }\n  else\n#endif\n  {\n    cinfo.unix_socket=0;\t\t\t\t/* This is not used */\n    if (!port)\n      port=mysql_port;\n    if (!host)\n      host=LOCAL_HOST;\n    cinfo.host= host;\n    cinfo.port= port;\n    cinfo.type= PVIO_TYPE_SOCKET;\n    sprintf(host_info=buff,ER(CR_TCP_CONNECTION), cinfo.host);\n  }\n  /* Initialize and load pvio plugin */\n  if (!(pvio= ma_pvio_init(&cinfo)))\n    goto error;\n\n  /* try to connect */\n  if (ma_pvio_connect(pvio, &cinfo) != 0)\n  {\n    ma_pvio_close(pvio);\n    goto error;\n  }\n\n  if (mysql->options.extension && mysql->options.extension->proxy_header)\n  {\n    char *hdr = mysql->options.extension->proxy_header;\n    size_t len = mysql->options.extension->proxy_header_len;\n    if (ma_pvio_write(pvio, (unsigned char *)hdr, len) <= 0)\n    {\n      ma_pvio_close(pvio);\n      goto error;\n    }\n  }\n\n  if (ma_net_init(net, pvio))\n    goto error;\n\n  if (mysql->options.max_allowed_packet)\n    net->max_packet_size= mysql->options.max_allowed_packet;\n\n  ma_pvio_keepalive(net->pvio);\n  strcpy(mysql->net.sqlstate, \"00000\");\n\n  /* Get version info */\n  mysql->protocol_version= PROTOCOL_VERSION;\t/* Assume this */\n/*\n  if (ma_pvio_wait_io_or_timeout(net->pvio, FALSE, 0) < 1)\n  {\n    my_set_error(mysql, CR_SERVER_LOST, SQLSTATE_UNKNOWN,\n                 ER(CR_SERVER_LOST_EXTENDED),\n                 \"handshake: waiting for initial communication packet\",\n                 errno);\n    goto error;\n  }\n */\n  if ((pkt_length=ma_net_safe_read(mysql)) == packet_error)\n  {\n    if (mysql->net.last_errno == CR_SERVER_LOST)\n      my_set_error(mysql, CR_SERVER_LOST, SQLSTATE_UNKNOWN,\n                 ER(CR_SERVER_LOST_EXTENDED),\n                 \"handshake: reading initial communication packet\",\n                 errno);\n\n    goto error;\n  }\n  end= (char *)net->read_pos;\n  end_pkt= (char *)net->read_pos + pkt_length;\n\n  /* Check if version of protocol matches current one */\n\n  mysql->protocol_version= end[0];\n  end++;\n\n  /* Check if server sends an error */\n  if (mysql->protocol_version == 0XFF)\n  {\n    net_get_error(end, pkt_length - 1, net->last_error, sizeof(net->last_error),\n      &net->last_errno, net->sqlstate);\n    /* fix for bug #26426 */\n    if (net->last_errno == 1040)\n      memcpy(net->sqlstate, \"08004\", SQLSTATE_LENGTH);\n    goto error;\n  }\n\n  if (mysql->protocol_version <  PROTOCOL_VERSION)\n  {\n    net->last_errno= CR_VERSION_ERROR;\n    sprintf(net->last_error, ER(CR_VERSION_ERROR), mysql->protocol_version,\n\t    PROTOCOL_VERSION);\n    goto error;\n  }\n  /* Save connection information */\n  if (!user) user=\"\";\n\n  if (!(mysql->host_info= strdup(host_info)) ||\n      !(mysql->host= strdup(cinfo.host ? cinfo.host : \"\")) ||\n      !(mysql->user=strdup(user)) ||\n      !(mysql->passwd=strdup(passwd)))\n  {\n    SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n    goto error;\n  }\n  if (cinfo.unix_socket)\n    mysql->unix_socket= strdup(cinfo.unix_socket);\n  else\n    mysql->unix_socket=0;\n  mysql->port=port;\n  client_flag|=mysql->options.client_flag;\n\n  if (strncmp(end, MA_RPL_VERSION_HACK, sizeof(MA_RPL_VERSION_HACK) - 1) == 0)\n  {\n    mysql->server_version= strdup(end + sizeof(MA_RPL_VERSION_HACK) - 1);\n    is_maria= 1;\n  }\n  else\n  {\n    if (!(mysql->server_version= strdup(end)))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      goto error;\n    }\n  }\n  end+= strlen(end) + 1;\n\n  mysql->thread_id=uint4korr(end);\n  end+=4;\n\n  /* This is the first part of scramble packet. In 4.1 and later\n     a second package will follow later */\n  scramble_data= end;\n  scramble_len= SCRAMBLE_LENGTH_323 + 1;\n  scramble_plugin= old_password_plugin_name;\n  end+= SCRAMBLE_LENGTH_323;\n\n  /* 1st pad */\n  end++;\n\n  if (end + 1<= end_pkt)\n  {\n    mysql->server_capabilities=uint2korr(end);\n  }\n\n  /* mysql 5.5 protocol */\n  if (end + 18 <= end_pkt)\n  {\n    mysql->server_language= uint1korr(end + 2);\n    mysql->server_status= uint2korr(end + 3);\n    mysql->server_capabilities|= (unsigned int)(uint2korr(end + 5)) << 16;\n    pkt_scramble_len= uint1korr(end + 7);\n\n    /* check if MariaD2B specific capabilities are available */\n    if (is_maria && !(mysql->server_capabilities & CLIENT_MYSQL))\n    {\n      mysql->extension->mariadb_server_capabilities= (ulonglong) uint4korr(end + 14);\n    }\n  }\n\n  /* pad 2 */\n  end+= 18;\n\n  /* second scramble package */\n  if (end + SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323 + 1 <= end_pkt)\n  {\n    memcpy(end - SCRAMBLE_LENGTH_323, scramble_data, SCRAMBLE_LENGTH_323);\n    scramble_data= end - SCRAMBLE_LENGTH_323;\n    if (mysql->server_capabilities & CLIENT_PLUGIN_AUTH)\n    {\n      scramble_len= pkt_scramble_len;\n      scramble_plugin= scramble_data + scramble_len;\n      if (scramble_data + scramble_len > end_pkt)\n      {\n        SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n        goto error;\n      }\n    } else\n    {\n      scramble_len= (uint)(end_pkt - scramble_data);\n      scramble_plugin= native_password_plugin_name;\n    }\n  } else\n  {\n    mysql->server_capabilities&= ~CLIENT_SECURE_CONNECTION;\n    if (mysql->options.secure_auth)\n    {\n      SET_CLIENT_ERROR(mysql, CR_SECURE_AUTH, SQLSTATE_UNKNOWN, 0);\n      goto error;\n    }\n  }\n\n  /* Set character set */\n  if (mysql->options.charset_name)\n    mysql->charset= mysql_find_charset_name(mysql->options.charset_name);\n  else\n    mysql->charset=mysql_find_charset_name(MARIADB_DEFAULT_CHARSET);\n\n  if (!mysql->charset)\n  {\n    net->last_errno=CR_CANT_READ_CHARSET;\n    sprintf(net->last_error,ER(net->last_errno),\n      mysql->options.charset_name ? mysql->options.charset_name : \n                                    MARIADB_DEFAULT_CHARSET,\n      \"compiled_in\");\n    goto error;\n  }\n\n  mysql->client_flag= client_flag;\n\n  if (run_plugin_auth(mysql, scramble_data, scramble_len,\n                             scramble_plugin, db))\n    goto error;\n\n  if (mysql->client_flag & CLIENT_COMPRESS)\n    net->compress= 1;\n\n  /* last part: select default db */\n  if (!(mysql->server_capabilities & CLIENT_CONNECT_WITH_DB) &&\n      (db && !mysql->db))\n  {\n    if (mysql_select_db(mysql, db))\n    {\n      my_set_error(mysql, CR_SERVER_LOST, SQLSTATE_UNKNOWN,\n                          ER(CR_SERVER_LOST_EXTENDED),\n                          \"Setting intital database\",\n                          errno);\n      goto error;\n    }\n  }\n\n  if (mysql->options.init_command)\n  {\n    char **begin= (char **)mysql->options.init_command->buffer;\n    char **end= begin + mysql->options.init_command->elements;\n\n    /* Avoid reconnect in mysql_real_connect */\n    my_bool save_reconnect= mysql->options.reconnect;\n    mysql->options.reconnect= 0;\n\n    for (;begin < end; begin++)\n    {\n      if (mysql_real_query(mysql, *begin, (unsigned long)strlen(*begin)))\n        goto error;\n\n    /* check if query produced a result set */\n      do {\n        MYSQL_RES *res;\n        if ((res= mysql_use_result(mysql)))\n          mysql_free_result(res);\n      } while (!mysql_next_result(mysql));\n    }\n    mysql->options.reconnect= save_reconnect;\n  }\n\n  strcpy(mysql->net.sqlstate, \"00000\");\n\n  /* connection established, apply timeouts */\n  ma_pvio_set_timeout(mysql->net.pvio, PVIO_READ_TIMEOUT, mysql->options.read_timeout);\n  ma_pvio_set_timeout(mysql->net.pvio, PVIO_WRITE_TIMEOUT, mysql->options.write_timeout);\n  return(mysql);\n\nerror:\n  /* Free alloced memory */\n  end_server(mysql);\n  /* only free the allocated memory, user needs to call mysql_close */\n  mysql_close_memory(mysql);\n  if (!(client_flag & CLIENT_REMEMBER_OPTIONS) &&\n      !mysql->options.extension->async_context)\n    mysql_close_options(mysql);\n  return(0);\n}\n\nstruct my_hook_data {\n  MYSQL *orig_mysql;\n  MYSQL *new_mysql;\n  /* This is always NULL currently, but restoring does not hurt just in case. */\n  MARIADB_PVIO *orig_pvio;\n};\n/*\n  Callback hook to make the new VIO accessible via the old MYSQL to calling\n  application when suspending a non-blocking call during automatic reconnect.\n*/\nstatic void\nmy_suspend_hook(my_bool suspend, void *data)\n{\n  struct my_hook_data *hook_data= (struct my_hook_data *)data;\n  if (suspend)\n  {\n    hook_data->orig_pvio= hook_data->orig_mysql->net.pvio;\n    hook_data->orig_mysql->net.pvio= hook_data->new_mysql->net.pvio;\n  }\n  else\n    hook_data->orig_mysql->net.pvio= hook_data->orig_pvio;\n}\n\nmy_bool STDCALL mariadb_reconnect(MYSQL *mysql)\n{\n  MYSQL tmp_mysql;\n  struct my_hook_data hook_data;\n  struct mysql_async_context *ctxt= NULL;\n  LIST *li_stmt= mysql->stmts;\n\n  /* check if connection handler is active */\n  if (IS_CONNHDLR_ACTIVE(mysql))\n  {\n    if (mysql->extension->conn_hdlr->plugin && mysql->extension->conn_hdlr->plugin->reconnect)\n      return(mysql->extension->conn_hdlr->plugin->reconnect(mysql));\n  }\n\n  if (!mysql->options.reconnect ||\n      (mysql->server_status & SERVER_STATUS_IN_TRANS) || !mysql->host_info)\n  {\n   /* Allow reconnect next time */\n    mysql->server_status&= ~SERVER_STATUS_IN_TRANS;\n    my_set_error(mysql, CR_SERVER_GONE_ERROR, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n\n  mysql_init(&tmp_mysql);\n  tmp_mysql.free_me= 0;\n  tmp_mysql.options=mysql->options;\n  if (mysql->extension->conn_hdlr)\n  {\n    tmp_mysql.extension->conn_hdlr= mysql->extension->conn_hdlr;\n    mysql->extension->conn_hdlr= 0;\n  }\n\n  /* don't reread options from configuration files */\n  tmp_mysql.options.my_cnf_group= tmp_mysql.options.my_cnf_file= NULL;\n  if (IS_MYSQL_ASYNC_ACTIVE(mysql))\n  {\n    ctxt= mysql->options.extension->async_context;\n    hook_data.orig_mysql= mysql;\n    hook_data.new_mysql= &tmp_mysql;\n    hook_data.orig_pvio= mysql->net.pvio;\n    my_context_install_suspend_resume_hook(ctxt, my_suspend_hook, &hook_data);\n  }\n\n  if (!mysql_real_connect(&tmp_mysql,mysql->host,mysql->user,mysql->passwd,\n\t\t\t  mysql->db, mysql->port, mysql->unix_socket,\n\t\t\t  mysql->client_flag | CLIENT_REMEMBER_OPTIONS) ||\n      mysql_set_character_set(&tmp_mysql, mysql->charset->csname))\n  {\n    if (ctxt)\n      my_context_install_suspend_resume_hook(ctxt, NULL, NULL);\n    /* don't free options (CONC-118) */\n    memset(&tmp_mysql.options, 0, sizeof(struct st_mysql_options));\n    my_set_error(mysql, tmp_mysql.net.last_errno,\n                        tmp_mysql.net.sqlstate,\n                        tmp_mysql.net.last_error);\n    mysql_close(&tmp_mysql);\n    return(1);\n  }\n\n  for (;li_stmt;li_stmt= li_stmt->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *)li_stmt->data;\n\n    if (stmt->state != MYSQL_STMT_INITTED)\n    {\n      stmt->state= MYSQL_STMT_INITTED;\n      SET_CLIENT_STMT_ERROR(stmt, CR_SERVER_LOST, SQLSTATE_UNKNOWN, 0);\n    }\n  }\n\n  tmp_mysql.free_me= mysql->free_me;\n  tmp_mysql.stmts= mysql->stmts;\n  mysql->stmts= NULL;\n\n  if (ctxt)\n    my_context_install_suspend_resume_hook(ctxt, NULL, NULL);\n  /* Don't free options, we moved them to tmp_mysql */\n  memset(&mysql->options, 0, sizeof(mysql->options));\n  mysql->free_me=0;\n  mysql_close(mysql);\n  *mysql=tmp_mysql;\n  mysql->net.pvio->mysql= mysql;\n  ma_net_clear(&mysql->net);\n  mysql->affected_rows= ~(unsigned long long) 0;\n  mysql->info= 0;\n  return(0);\n}\n\nvoid ma_invalidate_stmts(MYSQL *mysql, const char *function_name)\n{\n  if (mysql->stmts)\n  {\n    LIST *li_stmt= mysql->stmts;\n\n    for (; li_stmt; li_stmt= li_stmt->next)\n    {\n      MYSQL_STMT *stmt= (MYSQL_STMT *)li_stmt->data;\n      stmt->mysql= NULL;\n      SET_CLIENT_STMT_ERROR(stmt, CR_STMT_CLOSED, SQLSTATE_UNKNOWN, function_name);\n    }\n    mysql->stmts= NULL;\n  }\n}\n\n/*\n  Legacy support of the MariaDB 5.5 version, where timeouts where only in\n  seconds resolution. Applications that use this will be asked to set a timeout\n  at the nearest higher whole-seconds value.\n*/\nunsigned int STDCALL\nmysql_get_timeout_value(const MYSQL *mysql)\n{\n  unsigned int timeout= 0;\n\n  if (mysql->options.extension && mysql->options.extension->async_context)\n    timeout= mysql->options.extension->async_context->timeout_value;\n  /* Avoid overflow. */\n  if (timeout > UINT_MAX - 999)\n    return (timeout - 1)/1000 + 1;\n  else\n    return (timeout+999)/1000;\n}\n\n\nunsigned int STDCALL\nmysql_get_timeout_value_ms(const MYSQL *mysql)\n{\n  if (mysql->options.extension && mysql->options.extension->async_context)\n    return mysql->options.extension->async_context->timeout_value;\n  return 0;\n}\n\n/**************************************************************************\n** Change user and database\n**************************************************************************/\n\nmy_bool\tSTDCALL mysql_change_user(MYSQL *mysql, const char *user,\n\t\t\t\t  const char *passwd, const char *db)\n{\n  const MARIADB_CHARSET_INFO *s_cs= mysql->charset;\n  char *s_user= mysql->user,\n       *s_passwd= mysql->passwd,\n       *s_db= mysql->db;\n  int rc;\n\n  if (mysql->options.charset_name)\n    mysql->charset= mysql_find_charset_name(mysql->options.charset_name);\n  else\n    mysql->charset=mysql_find_charset_name(MARIADB_DEFAULT_CHARSET);\n\n  mysql->user= strdup(user ? user : \"\");\n  mysql->passwd= strdup(passwd ? passwd : \"\");\n\n  /* db will be set in run_plugin_auth */\n  mysql->db= 0;\n  rc= run_plugin_auth(mysql, 0, 0, 0, db);\n\n  /* COM_CHANGE_USER always releases prepared statements, so we need to invalidate them */\n  ma_invalidate_stmts(mysql, \"mysql_change_user()\");\n\n  if (rc==0)\n  {\n    free(s_user);\n    free(s_passwd);\n    free(s_db);\n\n    if (!mysql->db && db && !(mysql->db= strdup(db)))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      rc= 1;\n    }\n  } else\n  {\n    free(mysql->user);\n    free(mysql->passwd);\n    free(mysql->db);\n\n    mysql->user= s_user;\n    mysql->passwd= s_passwd;\n    mysql->db= s_db;\n    mysql->charset= s_cs;\n  }\n  return(rc);\n}\n\n\n/**************************************************************************\n** Set current database\n**************************************************************************/\n\nint STDCALL\nmysql_select_db(MYSQL *mysql, const char *db)\n{\n  int error;\n\n  if (!db)\n    return 1;\n\n  if ((error=ma_simple_command(mysql, COM_INIT_DB, db,\n                               (uint) strlen(db),0,0)))\n    return(error);\n  free(mysql->db);\n  mysql->db=strdup(db);\n  return(0);\n}\n\n\n/*************************************************************************\n** Send a QUIT to the server and close the connection\n** If handle is alloced by mysql connect free it.\n*************************************************************************/\n\nstatic void mysql_close_options(MYSQL *mysql)\n{\n  if (mysql->options.init_command)\n  {\n    char **begin= (char **)mysql->options.init_command->buffer;\n    char **end= begin + mysql->options.init_command->elements;\n\n    for (;begin < end; begin++)\n      free(*begin);\n    ma_delete_dynamic(mysql->options.init_command);\n    free(mysql->options.init_command);\n  }\n  free(mysql->options.user);\n  free(mysql->options.host);\n  free(mysql->options.password);\n  free(mysql->options.unix_socket);\n  free(mysql->options.db);\n  free(mysql->options.my_cnf_file);\n  free(mysql->options.my_cnf_group);\n  free(mysql->options.charset_dir);\n  free(mysql->options.charset_name);\n  free(mysql->options.bind_address);\n  free(mysql->options.ssl_key);\n  free(mysql->options.ssl_cert);\n  free(mysql->options.ssl_ca);\n  free(mysql->options.ssl_capath);\n  free(mysql->options.ssl_cipher);\n\n  if (mysql->options.extension)\n  {\n    struct mysql_async_context *ctxt;\n    if ((ctxt = mysql->options.extension->async_context))\n    {\n      my_context_destroy(&ctxt->async_context);\n      free(ctxt);\n      mysql->options.extension->async_context= 0;\n    }\n    free(mysql->options.extension->plugin_dir);\n    free(mysql->options.extension->default_auth);\n    free(mysql->options.extension->db_driver);\n    free(mysql->options.extension->ssl_crl);\n    free(mysql->options.extension->ssl_crlpath);\n    free(mysql->options.extension->tls_fp);\n    free(mysql->options.extension->tls_fp_list);\n    free(mysql->options.extension->tls_pw);\n    free(mysql->options.extension->tls_version);\n    free(mysql->options.extension->url);\n    free(mysql->options.extension->connection_handler);\n    if(hash_inited(&mysql->options.extension->connect_attrs))\n      hash_free(&mysql->options.extension->connect_attrs);\n    if (hash_inited(&mysql->options.extension->userdata))\n      hash_free(&mysql->options.extension->userdata);\n\n  }\n  free(mysql->options.extension);\n  /* clear all pointer */\n  memset(&mysql->options, 0, sizeof(mysql->options));\n}\n\nstatic void mysql_close_memory(MYSQL *mysql)\n{\n  ma_clear_session_state(mysql);\n  free(mysql->host_info);\n  free(mysql->host);\n  free(mysql->user);\n  free(mysql->passwd);\n  free(mysql->db);\n  free(mysql->unix_socket);\n  free(mysql->server_version);\n  mysql->host_info= mysql->host= mysql->unix_socket=\n                    mysql->server_version=mysql->user=mysql->passwd=mysql->db=0;\n}\n\nvoid my_set_error(MYSQL *mysql,\n                  unsigned int error_nr,\n                  const char *sqlstate,\n                  const char *format,\n                  ...)\n{\n  va_list ap;\n\n  const char *errmsg;\n\n  if (!format)\n  {\n    if (error_nr >= CR_MIN_ERROR && error_nr <= CR_MYSQL_LAST_ERROR)\n      errmsg= ER(error_nr);\n    else if (error_nr >= CER_MIN_ERROR && error_nr <= CR_MARIADB_LAST_ERROR)\n      errmsg= CER(error_nr);\n    else\n      errmsg= ER(CR_UNKNOWN_ERROR);\n  }\n\n  mysql->net.last_errno= error_nr;\n  ma_strmake(mysql->net.sqlstate, sqlstate, SQLSTATE_LENGTH);\n  va_start(ap, format);\n  vsnprintf(mysql->net.last_error, MYSQL_ERRMSG_SIZE - 1,\n            format ? format : errmsg, ap);\n  va_end(ap);\n  return;\n}\n\nvoid mysql_close_slow_part(MYSQL *mysql)\n{\n  if (mysql->net.pvio)\n  {\n    free_old_query(mysql);\n    mysql->status=MYSQL_STATUS_READY; /* Force command */\n    mysql->options.reconnect=0;\n    if (mysql->net.pvio && mysql->net.buff)\n      ma_simple_command(mysql, COM_QUIT,NullS,0,1,0);\n    end_server(mysql);\n  }\n}\n\nstatic void ma_clear_session_state(MYSQL *mysql)\n{\n  uint i;\n\n  if (!mysql || !mysql->extension)\n    return;\n\n  for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n  {\n    list_free(mysql->extension->session_state[i].list, 0);\n  }\n  memset(mysql->extension->session_state, 0, sizeof(struct st_mariadb_session_state) * SESSION_TRACK_TYPES);\n}\n\nvoid STDCALL\nmysql_close(MYSQL *mysql)\n{\n  if (mysql)\t\t\t\t\t/* Some simple safety */\n  {\n    if (mysql->extension && mysql->extension->conn_hdlr)\n    {\n      MA_CONNECTION_HANDLER *p= mysql->extension->conn_hdlr;\n      if (p->plugin->close)\n        p->plugin->close(mysql);\n      free(p);\n      /* Fix for CONC-294: Since we already called plugin->close function\n         we need to prevent that mysql_close_slow_part (which sends COM_QUIT\n         to the server) will be handled by plugin again. */\n      mysql->extension->conn_hdlr= NULL;\n    }\n\n    if (mysql->methods)\n      mysql->methods->db_close(mysql);\n\n    /* reset the connection in all active statements */\n    ma_invalidate_stmts(mysql, \"mysql_close()\");\n\n    mysql_close_memory(mysql);\n    mysql_close_options(mysql);\n    ma_clear_session_state(mysql);\n\n    if (mysql->net.extension)\n      free(mysql->net.extension);\n\n    mysql->host_info=mysql->user=mysql->passwd=mysql->db=0;\n\n    /* Clear pointers for better safety */\n    memset((char*) &mysql->options, 0, sizeof(mysql->options));\n\n    if (mysql->extension)\n      free(mysql->extension);\n\n    mysql->net.pvio= 0;\n    if (mysql->free_me)\n      free(mysql);\n  }\n  return;\n}\n\n\n/**************************************************************************\n** Do a query. If query returned rows, free old rows.\n** Read data by mysql_store_result or by repeating calls to mysql_fetch_row\n**************************************************************************/\n\nint STDCALL\nmysql_query(MYSQL *mysql, const char *query)\n{\n  return mysql_real_query(mysql,query, (unsigned long) strlen(query));\n}\n\n/*\n  Send the query and return so we can do something else.\n  Needs to be followed by mysql_read_query_result() when we want to\n  finish processing it.\n*/\n\nint STDCALL\nmysql_send_query(MYSQL* mysql, const char* query, unsigned long length)\n{\n  return ma_simple_command(mysql, COM_QUERY, query, length, 1,0);\n}\n\nint ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)\n{\n  size_t item_len;\n  mysql->affected_rows= net_field_length_ll(&pos);\n  mysql->insert_id=\t  net_field_length_ll(&pos);\n  mysql->server_status=uint2korr(pos);\n  pos+=2;\n  mysql->warning_count=uint2korr(pos);\n  pos+=2;\n  if (pos < mysql->net.read_pos+length)\n  {\n    if ((item_len= net_field_length(&pos)))\n      mysql->info=(char*) pos;\n\n    /* check if server supports session tracking */\n    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    {\n      ma_clear_session_state(mysql);\n      pos+= item_len;\n\n      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n      {\n        int i;\n        if (pos < mysql->net.read_pos + length)\n        {\n          LIST *session_item;\n          MYSQL_LEX_STRING *str= NULL;\n          enum enum_session_state_type si_type;\n          uchar *old_pos= pos;\n          size_t item_len= net_field_length(&pos);  /* length for all items */\n\n          /* length was already set, so make sure that info will be zero terminated */\n          if (mysql->info)\n            *old_pos= 0;\n\n          while (item_len > 0)\n          {\n            size_t plen;\n            char *data;\n            old_pos= pos;\n            si_type= (enum enum_session_state_type)net_field_length(&pos);\n            switch(si_type) {\n            case SESSION_TRACK_SCHEMA:\n            case SESSION_TRACK_STATE_CHANGE:\n            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n            case SESSION_TRACK_SYSTEM_VARIABLES:\n              if (si_type != SESSION_TRACK_STATE_CHANGE)\n                net_field_length(&pos); /* ignore total length, item length will follow next */\n              plen= net_field_length(&pos);\n              if (!(session_item= ma_multi_malloc(0,\n                                  &session_item, sizeof(LIST),\n                                  &str, sizeof(MYSQL_LEX_STRING),\n                                  &data, plen,\n                                  NULL)))\n              {\n                ma_clear_session_state(mysql);\n                SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                return -1;\n              }\n              str->length= plen;\n              str->str= data;\n              memcpy(str->str, (char *)pos, plen);\n              pos+= plen;\n              session_item->data= str;\n              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n\n              /* in case schema has changed, we have to update mysql->db */\n              if (si_type == SESSION_TRACK_SCHEMA)\n              {\n                free(mysql->db);\n                mysql->db= malloc(plen + 1);\n                memcpy(mysql->db, str->str, plen);\n                mysql->db[plen]= 0;\n              }\n              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n              {\n                my_bool set_charset= 0;\n                /* make sure that we update charset in case it has changed */\n                if (!strncmp(str->str, \"character_set_client\", str->length))\n                  set_charset= 1;\n                plen= net_field_length(&pos);\n                if (!(session_item= ma_multi_malloc(0,\n                                    &session_item, sizeof(LIST),\n                                    &str, sizeof(MYSQL_LEX_STRING),\n                                    &data, plen,\n                                    NULL)))\n                {\n                  ma_clear_session_state(mysql);\n                  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                  return -1;\n                }\n                str->length= plen;\n                str->str= data;\n                memcpy(str->str, (char *)pos, plen);\n                pos+= plen;\n                session_item->data= str;\n                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n                if (set_charset &&\n                    strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                {\n                  char cs_name[64];\n                  MARIADB_CHARSET_INFO *cs_info;\n                  memcpy(cs_name, str->str, str->length);\n                  cs_name[str->length]= 0;\n                  if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))\n                    mysql->charset= cs_info;\n                }\n              }\n              break;\n            default:\n              /* not supported yet */\n              plen= net_field_length(&pos);\n              pos+= plen;\n              break;\n            }\n            item_len-= (pos - old_pos);\n          }\n        }\n        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n        {\n          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n        }\n      }\n    }\n  }\n  /* CONC-351: clear session state information */\n  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    ma_clear_session_state(mysql);\n  return(0);\n}\n\nint mthd_my_read_query_result(MYSQL *mysql)\n{\n  uchar *pos;\n  ulong field_count;\n  MYSQL_DATA *fields;\n  ulong length;\n  my_bool can_local_infile= (mysql->options.extension) && (mysql->extension->auto_local_infile != WAIT_FOR_QUERY);\n\n  if (mysql->options.extension && mysql->extension->auto_local_infile == ACCEPT_FILE_REQUEST)\n    mysql->extension->auto_local_infile= WAIT_FOR_QUERY;\n\n  if ((length = ma_net_safe_read(mysql)) == packet_error)\n  {\n    return(1);\n  }\n  free_old_query(mysql);\t\t\t/* Free old result */\nget_info:\n  pos=(uchar*) mysql->net.read_pos;\n  if ((field_count= net_field_length(&pos)) == 0)\n    return ma_read_ok_packet(mysql, pos, length);\n  if (field_count == NULL_LENGTH)\t\t/* LOAD DATA LOCAL INFILE */\n  {\n    int error=mysql_handle_local_infile(mysql, (char *)pos, can_local_infile);\n\n    if ((length=ma_net_safe_read(mysql)) == packet_error || error)\n      return(-1);\n    goto get_info;\t\t\t\t/* Get info packet */\n  }\n  if (!(mysql->server_status & SERVER_STATUS_AUTOCOMMIT))\n    mysql->server_status|= SERVER_STATUS_IN_TRANS;\n\n  mysql->extra_info= net_field_length_ll(&pos); /* Maybe number of rec */\n  if (!(fields=mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,\n                                            ma_result_set_rows(mysql))))\n    return(-1);\n  if (!(mysql->fields=unpack_fields(mysql, fields, &mysql->field_alloc,\n\t\t\t\t    (uint) field_count, 1)))\n    return(-1);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  return(0);\n}\n\nint STDCALL mysql_session_track_get_next(MYSQL *mysql, enum enum_session_state_type type,\n                                         const char **data, size_t *length)\n{\n  MYSQL_LEX_STRING *str;\n  if (!mysql->extension->session_state[type].current)\n    return 1;\n\n  str= (MYSQL_LEX_STRING *)mysql->extension->session_state[type].current->data;\n  mysql->extension->session_state[type].current= mysql->extension->session_state[type].current->next;\n\n  *data= str->str ? str->str : NULL;\n  *length= str->str ? str->length : 0;\n  return 0;\n}\n\nint STDCALL mysql_session_track_get_first(MYSQL *mysql, enum enum_session_state_type type,\n                                          const char **data, size_t *length)\n{\n  mysql->extension->session_state[type].current= mysql->extension->session_state[type].list;\n  return mysql_session_track_get_next(mysql, type, data, length);\n}\n\nmy_bool STDCALL\nmysql_read_query_result(MYSQL *mysql)\n{\n  return test(mysql->methods->db_read_query_result(mysql)) ? 1 : 0;\n}\n\nint STDCALL\nmysql_real_query(MYSQL *mysql, const char *query, unsigned long length)\n{\n  my_bool skip_result= OPT_EXT_VAL(mysql, multi_command);\n\n  if (length == (unsigned long)-1)\n    length= (unsigned long)strlen(query);\n\n  free_old_query(mysql);\n\n  if (ma_simple_command(mysql, COM_QUERY,query,length,1,0))\n    return(-1);\n  if (!skip_result)\n    return(mysql->methods->db_read_query_result(mysql));\n  return(0);\n}\n\n/**************************************************************************\n** Alloc result struct for buffered results. All rows are read to buffer.\n** mysql_data_seek may be used.\n**************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_store_result(MYSQL *mysql)\n{\n  MYSQL_RES *result;\n\n  if (!mysql->fields)\n    return(0);\n  if (mysql->status != MYSQL_STATUS_GET_RESULT)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  mysql->status=MYSQL_STATUS_READY;\t\t/* server is ready */\n  if (!(result=(MYSQL_RES*) calloc(1, sizeof(MYSQL_RES)+\n\t\t\t\t       sizeof(ulong)*mysql->field_count)))\n  {\n    SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  result->eof=1;\t\t\t\t/* Marker for buffered */\n  result->lengths=(ulong*) (result+1);\n  if (!(result->data=mysql->methods->db_read_rows(mysql,mysql->fields,mysql->field_count)))\n  {\n    free(result);\n    return(0);\n  }\n  mysql->affected_rows= result->row_count= result->data->rows;\n  result->data_cursor=\tresult->data->data;\n  result->fields=\tmysql->fields;\n  result->field_alloc=\tmysql->field_alloc;\n  result->field_count=\tmysql->field_count;\n  result->current_field=0;\n  result->current_row=0;\t\t\t/* Must do a fetch first */\n  mysql->fields=0;\t\t\t\t/* fields is now in result */\n  return(result);\t\t\t\t/* Data fetched */\n}\n\n\n/**************************************************************************\n** Alloc struct for use with unbuffered reads. Data is fetched by domand\n** when calling to mysql_fetch_row.\n** mysql_data_seek is a noop.\n**\n** No other queries may be specified with the same MYSQL handle.\n** There shouldn't be much processing per row because mysql server shouldn't\n** have to wait for the client (and will not wait more than 30 sec/packet).\n**************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_use_result(MYSQL *mysql)\n{\n  MYSQL_RES *result;\n\n  if (!mysql->fields)\n    return(0);\n  if (mysql->status != MYSQL_STATUS_GET_RESULT)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  if (!(result=(MYSQL_RES*) calloc(1, sizeof(*result)+\n\t\t\t\t      sizeof(ulong)*mysql->field_count)))\n    return(0);\n  result->lengths=(ulong*) (result+1);\n  if (!(result->row=(MYSQL_ROW)\n\tmalloc(sizeof(result->row[0])*(mysql->field_count+1))))\n  {\t\t\t\t\t/* Ptrs: to one row */\n    free(result);\n    return(0);\n  }\n  result->fields=\tmysql->fields;\n  result->field_alloc=\tmysql->field_alloc;\n  result->field_count=\tmysql->field_count;\n  result->current_field=0;\n  result->handle=\tmysql;\n  result->current_row=\t0;\n  mysql->fields=0;\t\t\t/* fields is now in result */\n  mysql->status=MYSQL_STATUS_USE_RESULT;\n  return(result);\t\t\t/* Data is read to be fetched */\n}\n\n/**************************************************************************\n** Return next field of the query results\n**************************************************************************/\nMYSQL_FIELD * STDCALL\nmysql_fetch_field(MYSQL_RES *result)\n{\n  if (result->current_field >= result->field_count)\n    return(NULL);\n  return &result->fields[result->current_field++];\n}\n\n\n/**************************************************************************\n** Return mysql field metadata\n**************************************************************************/\nint STDCALL\nmariadb_field_attr(MARIADB_CONST_STRING *attr,\n                   const MYSQL_FIELD *field,\n                   enum mariadb_field_attr_t type)\n{\n  MA_FIELD_EXTENSION *ext= (MA_FIELD_EXTENSION*) field->extension;\n  if (!ext || type > MARIADB_FIELD_ATTR_LAST)\n  {\n    *attr= null_const_string;\n    return 1;\n  }\n  *attr= ext->metadata[type];\n  return 0;\n}\n\n\n/**************************************************************************\n**  Return next row of the query results\n**************************************************************************/\nMYSQL_ROW STDCALL\nmysql_fetch_row(MYSQL_RES *res)\n{\n  if (!res)\n    return 0;\n  if (res->handle)\n  {\n    if (res->handle->status != MYSQL_STATUS_USE_RESULT &&\n        res->handle->status != MYSQL_STATUS_GET_RESULT)\n      return 0;\n  }\n  if (!res->data)\n  {\t\t\t\t\t\t/* Unbufferred fetch */\n    if (!res->eof && res->handle)\n    {\n      if (!(res->handle->methods->db_read_one_row(res->handle,res->field_count,res->row, res->lengths)))\n      {\n        res->row_count++;\n        return(res->current_row=res->row);\n      }\n      res->eof=1;\n      res->handle->status=MYSQL_STATUS_READY;\n       /* Don't clear handle in mysql_free_results */\n      res->handle=0;\n    }\n    return((MYSQL_ROW) NULL);\n  }\n  {\n    MYSQL_ROW tmp;\n    if (!res->data_cursor)\n    {\n      return(res->current_row=(MYSQL_ROW) NULL);\n    }\n    tmp = res->data_cursor->data;\n    res->data_cursor = res->data_cursor->next;\n    return(res->current_row=tmp);\n  }\n}\n\n/**************************************************************************\n** Get column lengths of the current row\n** If one uses mysql_use_result, res->lengths contains the length information,\n** else the lengths are calculated from the offset between pointers.\n**************************************************************************/\n\nulong * STDCALL\nmysql_fetch_lengths(MYSQL_RES *res)\n{\n  ulong *lengths,*prev_length;\n  char *start;\n  MYSQL_ROW column,end;\n\n  if (!(column=res->current_row))\n    return 0;\t\t\t\t\t/* Something is wrong */\n  if (res->data)\n  {\n    start=0;\n    prev_length=0;\t\t\t\t/* Keep gcc happy */\n    lengths=res->lengths;\n    for (end=column+res->field_count+1 ; column != end ; column++,lengths++)\n    {\n      if (!*column)\n      {\n\t*lengths=0;\t\t\t\t/* Null */\n\tcontinue;\n      }\n      if (start)\t\t\t\t/* Found end of prev string */\n\t*prev_length= (uint) (*column-start-1);\n      start= *column;\n      prev_length=lengths;\n    }\n  }\n  return res->lengths;\n}\n\n/**************************************************************************\n** Move to a specific row and column\n**************************************************************************/\n\nvoid STDCALL\nmysql_data_seek(MYSQL_RES *result, unsigned long long row)\n{\n  MYSQL_ROWS\t*tmp=0;\n  if (result->data)\n    for (tmp=result->data->data; row-- && tmp ; tmp = tmp->next) ;\n  result->current_row=0;\n  result->data_cursor = tmp;\n}\n\n/*************************************************************************\n** put the row or field cursor one a position one got from mysql_row_tell()\n** This doesn't restore any data. The next mysql_fetch_row or\n** mysql_fetch_field will return the next row or field after the last used\n*************************************************************************/\n\nMYSQL_ROW_OFFSET STDCALL\nmysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET row)\n{\n  MYSQL_ROW_OFFSET return_value=result->data_cursor;\n  result->current_row= 0;\n  result->data_cursor= row;\n  return return_value;\n}\n\n\nMYSQL_FIELD_OFFSET STDCALL\nmysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)\n{\n  MYSQL_FIELD_OFFSET return_value=result->current_field;\n  result->current_field=field_offset;\n  return return_value;\n}\n\n/********************************************************\n Warning: mysql_list_dbs is deprecated and will be\n          removed. Use SQL statement \"SHOW DATABASES\"\n          instead\n ********************************************************/\n\n/*****************************************************************************\n** List all databases\n*****************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_list_dbs(MYSQL *mysql, const char *wild)\n{\n  char buff[255];\n  snprintf(buff, 255, \"SHOW DATABASES LIKE '%s'\", wild ? wild : \"%\");\n  if (mysql_query(mysql,buff))\n    return(0);\n  return (mysql_store_result(mysql));\n}\n\n\n/********************************************************\n Warning: mysql_list_tables is deprecated and will be\n          removed. Use SQL statement \"SHOW TABLES\"\n          instead\n ********************************************************/\n/*****************************************************************************\n** List all tables in a database\n** If wild is given then only the tables matching wild are returned\n*****************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_list_tables(MYSQL *mysql, const char *wild)\n{\n  char buff[255];\n\n  snprintf(buff, 255, \"SHOW TABLES LIKE '%s'\", wild ? wild : \"%\");\n  if (mysql_query(mysql,buff))\n    return(0);\n  return (mysql_store_result(mysql));\n}\n\n\n/**************************************************************************\n** List all fields in a table\n** If wild is given then only the fields matching wild are returned\n** Instead of this use query:\n** show fields in 'table' like \"wild\"\n**************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_list_fields(MYSQL *mysql, const char *table, const char *wild)\n{\n  MYSQL_RES *result;\n  MYSQL_DATA *query;\n  char buff[255];\n  int length= 0;\n\n  LINT_INIT(query);\n\n  length= snprintf(buff, 128, \"%s%c%s\", table, '\\0', wild ? wild : \"\");\n\n  if (ma_simple_command(mysql, COM_FIELD_LIST,buff,length,1,0) ||\n      !(query = mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,\n                                             ma_result_set_rows(mysql))))\n    return(NULL);\n\n  free_old_query(mysql);\n  if (!(result = (MYSQL_RES *) calloc(1, sizeof(MYSQL_RES))))\n  {\n    free_rows(query);\n    return(NULL);\n  }\n  result->field_alloc=mysql->field_alloc;\n  mysql->fields=0;\n  result->eof=1;\n  result->field_count = (uint) query->rows;\n  result->fields= unpack_fields(mysql, query, &result->field_alloc,\n\t\t\t\tresult->field_count, 1);\n  if (result->fields)\n    return(result);\n\n  free(result);\n  return(NULL);\n}\n\n/********************************************************\n Warning: mysql_list_processes is deprecated and will be\n          removed. Use SQL statement \"SHOW PROCESSLIST\"\n          instead\n ********************************************************/\n\n/* List all running processes (threads) in server */\n\nMYSQL_RES * STDCALL\nmysql_list_processes(MYSQL *mysql)\n{\n  MYSQL_DATA *fields;\n  uint field_count;\n  uchar *pos;\n\n  LINT_INIT(fields);\n  if (ma_simple_command(mysql, COM_PROCESS_INFO,0,0,0,0))\n    return(NULL);\n  free_old_query(mysql);\n  pos=(uchar*) mysql->net.read_pos;\n  field_count=(uint) net_field_length(&pos);\n  if (!(fields = mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,7)))\n    return(NULL);\n  if (!(mysql->fields= unpack_fields(mysql, fields, &mysql->field_alloc,\n                                     field_count, 0)))\n    return(NULL);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  return(mysql_store_result(mysql));\n}\n\n/* In 5.0 this version became an additional parameter shutdown_level */\nint STDCALL\nmysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)\n{\n  uchar s_level[2];\n  s_level[0]= (uchar)shutdown_level;\n  return(ma_simple_command(mysql, COM_SHUTDOWN, (char *)s_level, 1, 0, 0));\n}\n\nint STDCALL\nmysql_refresh(MYSQL *mysql,uint options)\n{\n  uchar bits[1];\n  bits[0]= (uchar) options;\n  return(ma_simple_command(mysql, COM_REFRESH,(char*) bits,1,0,0));\n}\n\nint STDCALL\nmysql_kill(MYSQL *mysql,ulong pid)\n{\n  char buff[12];\n  int4store(buff,pid);\n  /* if we kill our own thread, reading the response packet will fail */\n  return(ma_simple_command(mysql, COM_PROCESS_KILL,buff,4,0,0));\n}\n\n\nint STDCALL\nmysql_dump_debug_info(MYSQL *mysql)\n{\n  return(ma_simple_command(mysql, COM_DEBUG,0,0,0,0));\n}\n\nchar * STDCALL\nmysql_stat(MYSQL *mysql)\n{\n  if (ma_simple_command(mysql, COM_STATISTICS,0,0,0,0))\n    return mysql->net.last_error;\n  mysql->net.read_pos[mysql->packet_length]=0;\t/* End of stat string */\n  if (!mysql->net.read_pos[0])\n  {\n    SET_CLIENT_ERROR(mysql, CR_WRONG_HOST_INFO , SQLSTATE_UNKNOWN, 0);\n    return mysql->net.last_error;\n  }\n  return((char*) mysql->net.read_pos);\n}\n\nint STDCALL\nmysql_ping(MYSQL *mysql)\n{\n  int rc;\n  rc= ma_simple_command(mysql, COM_PING, 0, 0, 0, 0);\n  if (rc && mysql->options.reconnect)\n    rc= ma_simple_command(mysql, COM_PING, 0, 0, 0, 0);\n  return rc;\n}\n\nchar * STDCALL\nmysql_get_server_info(MYSQL *mysql)\n{\n  return((char*) mysql->server_version);\n}\n\nstatic size_t mariadb_server_version_id(MYSQL *mysql)\n{\n  size_t major, minor, patch;\n  char *p;\n\n  if (!(p = mysql->server_version)) {\n    return 0;\n  }\n\n  major = strtol(p, &p, 10);\n  p += 1; /* consume the dot */\n  minor = strtol(p, &p, 10);\n  p += 1; /* consume the dot */\n  patch = strtol(p, &p, 10);\n\n  return (major * 10000L + (unsigned long)(minor * 100L + patch));\n}\n\nunsigned long STDCALL mysql_get_server_version(MYSQL *mysql)\n{\n  return (unsigned long)mariadb_server_version_id(mysql);\n}\n\nchar * STDCALL\nmysql_get_host_info(MYSQL *mysql)\n{\n  return(mysql->host_info);\n}\n\nuint STDCALL\nmysql_get_proto_info(MYSQL *mysql)\n{\n  return (mysql->protocol_version);\n}\n\nconst char * STDCALL\nmysql_get_client_info(void)\n{\n  return (char*) MARIADB_CLIENT_VERSION_STR;\n}\n\nstatic size_t get_store_length(size_t length)\n{\n  #define MAX_STORE_SIZE 9\n  unsigned char buffer[MAX_STORE_SIZE], *p;\n\n  /* We just store the length and substract offset of our buffer\n     to determine the length */\n  p= mysql_net_store_length(buffer, length);\n  return p - buffer;\n}\n\nuchar *ma_get_hash_keyval(const uchar *hash_entry,\n                       unsigned int *length,\n                       my_bool not_used __attribute__((unused)))\n{\n  /* Hash entry has the following format:\n     Offset: 0               key (\\0 terminated)\n             key_length + 1  value (\\0 terminated)\n  */\n  uchar *p= (uchar *)hash_entry;\n  size_t len= strlen((char *)p);\n  *length= (unsigned int)len;\n  return p;\n}\n\nvoid ma_int_hash_free(void *p)\n{\n  free(p);\n}\n\nint\nmysql_optionsv(MYSQL *mysql,enum mysql_option option, ...)\n{\n  va_list ap;\n  void *arg1;\n  size_t stacksize;\n  struct mysql_async_context *ctxt;\n\n  va_start(ap, option);\n\n  arg1= va_arg(ap, void *);\n\n  switch (option) {\n  case MYSQL_OPT_CONNECT_TIMEOUT:\n    mysql->options.connect_timeout= *(uint*) arg1;\n    break;\n  case MYSQL_OPT_COMPRESS:\n    mysql->options.compress= 1;\t\t\t/* Remember for connect */\n    mysql->options.client_flag|= CLIENT_COMPRESS;\n    break;\n  case MYSQL_OPT_NAMED_PIPE:\n    mysql->options.named_pipe=1;\t\t/* Force named pipe */\n    break;\n  case MYSQL_OPT_LOCAL_INFILE:\t\t\t/* Allow LOAD DATA LOCAL ?*/\n    if (!arg1 || test(*(unsigned int*) arg1))\n      mysql->options.client_flag|= CLIENT_LOCAL_FILES;\n    else\n      mysql->options.client_flag&= ~CLIENT_LOCAL_FILES;\n    if (arg1) {\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      mysql->extension->auto_local_infile= *(uint*)arg1 == LOCAL_INFILE_MODE_AUTO\n                                           ? WAIT_FOR_QUERY : ALWAYS_ACCEPT;\n    }\n    break;\n  case MYSQL_INIT_COMMAND:\n    options_add_initcommand(&mysql->options, (char *)arg1);\n    break;\n  case MYSQL_READ_DEFAULT_FILE:\n    OPT_SET_VALUE_STR(&mysql->options, my_cnf_file, (char *)arg1);\n    break;\n  case MYSQL_READ_DEFAULT_GROUP:\n    OPT_SET_VALUE_STR(&mysql->options, my_cnf_group, arg1 ? (char *)arg1 : \"\");\n    break;\n  case MYSQL_SET_CHARSET_DIR:\n    OPT_SET_VALUE_STR(&mysql->options, charset_dir, arg1);\n    break;\n  case MYSQL_SET_CHARSET_NAME:\n    OPT_SET_VALUE_STR(&mysql->options, charset_name, arg1);\n    break;\n  case MYSQL_OPT_RECONNECT:\n    mysql->options.reconnect= *(my_bool *)arg1;\n    break;\n  case MYSQL_OPT_PROTOCOL:\n    mysql->options.protocol= *((uint *)arg1);\n    break;\n#ifdef _WIN32\n  case MYSQL_SHARED_MEMORY_BASE_NAME:\n    OPT_SET_VALUE_STR(&mysql->options, shared_memory_base_name, arg1);\n    break;\n#endif\n  case MYSQL_OPT_READ_TIMEOUT:\n    mysql->options.read_timeout= *(uint *)arg1;\n    break;\n  case MYSQL_OPT_WRITE_TIMEOUT:\n    mysql->options.write_timeout= *(uint *)arg1;\n    break;\n  case MYSQL_REPORT_DATA_TRUNCATION:\n    mysql->options.report_data_truncation= *(my_bool *)arg1;\n    break;\n  case MYSQL_PROGRESS_CALLBACK:\n    CHECK_OPT_EXTENSION_SET(&mysql->options);\n    if (mysql->options.extension)\n      mysql->options.extension->report_progress=\n        (void (*)(const MYSQL *, uint, uint, double, const char *, uint)) arg1;\n    break;\n  case MYSQL_SERVER_PUBLIC_KEY:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, server_public_key, (char *)arg1);\n    break;\n  case MYSQL_PLUGIN_DIR:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, plugin_dir, (char *)arg1);\n    break;\n  case MYSQL_DEFAULT_AUTH:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, default_auth, (char *)arg1);\n    break;\n  case MYSQL_OPT_NONBLOCK:\n    if (mysql->options.extension &&\n        (ctxt = mysql->options.extension->async_context) != 0)\n    {\n      /*\n        We must not allow changing the stack size while a non-blocking call is\n        suspended (as the stack is then in use).\n      */\n      if (ctxt->suspended)\n        goto end;\n      my_context_destroy(&ctxt->async_context);\n      free(ctxt);\n    }\n    if (!(ctxt= (struct mysql_async_context *)\n          calloc(1, sizeof(*ctxt))))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      goto end;\n    }\n    stacksize= 0;\n    if (arg1)\n      stacksize= *(const size_t *)arg1;\n    if (!stacksize)\n      stacksize= ASYNC_CONTEXT_DEFAULT_STACK_SIZE;\n    if (my_context_init(&ctxt->async_context, stacksize))\n    {\n      free(ctxt);\n      goto end;\n    }\n    if (!mysql->options.extension)\n      if(!(mysql->options.extension= (struct st_mysql_options_extension *)\n        calloc(1, sizeof(struct st_mysql_options_extension))))\n      {\n        free(ctxt);\n        SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n    mysql->options.extension->async_context= ctxt;\n    break;\n  case MYSQL_OPT_MAX_ALLOWED_PACKET:\n    if (mysql)\n      mysql->options.max_allowed_packet= (unsigned long)(*(size_t *)arg1);\n    else\n      max_allowed_packet= (unsigned long)(*(size_t *)arg1);\n    break;\n  case MYSQL_OPT_NET_BUFFER_LENGTH:\n    net_buffer_length= (unsigned long)(*(size_t *)arg1);\n    break;\n  case MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS:\n    if (*(my_bool *)arg1)\n      mysql->options.client_flag |= CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS;\n    else\n      mysql->options.client_flag &= ~CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS;\n    break;\n  case MYSQL_OPT_SSL_ENFORCE:\n    mysql->options.use_ssl= (*(my_bool *)arg1);\n    break;\n  case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:\n    if (*(my_bool *)arg1)\n      mysql->options.client_flag |= CLIENT_SSL_VERIFY_SERVER_CERT;\n    else\n      mysql->options.client_flag &= ~CLIENT_SSL_VERIFY_SERVER_CERT;\n    break;\n  case MYSQL_OPT_SSL_KEY:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_key, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CERT:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_cert, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CA:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_ca, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CAPATH:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_capath, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CIPHER:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_cipher, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CRL:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, ssl_crl, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CRLPATH:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, ssl_crlpath, (char *)arg1);\n    break;\n  case MYSQL_OPT_CONNECT_ATTR_DELETE:\n    {\n      uchar *h;\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      if (hash_inited(&mysql->options.extension->connect_attrs) &&\n          (h= (uchar *)hash_search(&mysql->options.extension->connect_attrs, (uchar *)arg1,\n                      arg1 ? (uint)strlen((char *)arg1) : 0)))\n      {\n        uchar *p= h;\n        size_t key_len= strlen((char *)p);\n        mysql->options.extension->connect_attrs_len-= key_len + get_store_length(key_len);\n        p+= key_len + 1;\n        key_len= strlen((char *)p);\n        mysql->options.extension->connect_attrs_len-= key_len + get_store_length(key_len);\n        hash_delete(&mysql->options.extension->connect_attrs, h);\n      }\n\n    }\n    break;\n  case MYSQL_OPT_CONNECT_ATTR_RESET:\n    CHECK_OPT_EXTENSION_SET(&mysql->options);\n    if (hash_inited(&mysql->options.extension->connect_attrs))\n    {\n      hash_free(&mysql->options.extension->connect_attrs);\n      mysql->options.extension->connect_attrs_len= 0;\n    }\n    break;\n  case MARIADB_OPT_CONNECTION_HANDLER:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, connection_handler, (char *)arg1);\n    break;\n  case MARIADB_OPT_PORT:\n    OPT_SET_VALUE_INT(&mysql->options, port, *((uint *)arg1));\n    break;\n  case MARIADB_OPT_UNIXSOCKET:\n    OPT_SET_VALUE_STR(&mysql->options, unix_socket, arg1);\n    break;\n  case MARIADB_OPT_USER:\n    OPT_SET_VALUE_STR(&mysql->options, user, arg1);\n    break;\n  case MARIADB_OPT_HOST:\n    OPT_SET_VALUE_STR(&mysql->options, host, arg1);\n    break;\n  case MARIADB_OPT_SCHEMA:\n    OPT_SET_VALUE_STR(&mysql->options, db, arg1);\n    break;\n  case MARIADB_OPT_DEBUG:\n    break;\n  case MARIADB_OPT_FOUND_ROWS:\n    mysql->options.client_flag|= CLIENT_FOUND_ROWS;\n    break;\n  case MARIADB_OPT_INTERACTIVE:\n    mysql->options.client_flag|= CLIENT_INTERACTIVE;\n    break;\n  case MARIADB_OPT_MULTI_RESULTS:\n    mysql->options.client_flag|= CLIENT_MULTI_RESULTS;\n    break;\n  case MARIADB_OPT_MULTI_STATEMENTS:\n    mysql->options.client_flag|= CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS;\n    break;\n  case MARIADB_OPT_PASSWORD:\n    OPT_SET_VALUE_STR(&mysql->options, password, arg1);\n    break;\n  case MARIADB_OPT_USERDATA:\n    {\n      void *data= va_arg(ap, void *);\n      uchar *buffer, *p;\n      char *key= (char *)arg1;\n\n      if (!key || !data)\n      {\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      if (!hash_inited(&mysql->options.extension->userdata))\n      {\n        if (_hash_init(&mysql->options.extension->userdata,\n                       0, 0, 0, ma_get_hash_keyval, ma_int_hash_free, 0))\n        {\n          SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n          goto end;\n        }\n      }\n      /* check if key is already in buffer */\n      p= (uchar *)hash_search(&mysql->options.extension->userdata, \n                              (uchar *)key,\n                              (uint)strlen(key));\n      if (p)\n      {\n        p+= strlen(key) + 1;\n        memcpy(p, &data, sizeof(void *));\n        break;\n      }\n\n      if (!(buffer= (uchar *)malloc(strlen(key) + 1 + sizeof(void *))))\n      {\n        SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n\n      p= buffer;\n      strcpy((char *)p, key);\n      p+= strlen(key) + 1;\n      memcpy(p, &data, sizeof(void *));\n\n      if (hash_insert(&mysql->options.extension->userdata, buffer))\n      {\n        free(buffer);\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n    }\n    break;\n  case MYSQL_OPT_CONNECT_ATTR_ADD:\n    {\n      uchar *buffer;\n      void *arg2= va_arg(ap, void *);\n      size_t storage_len, key_len= arg1 ? strlen((char *)arg1) : 0,\n             value_len= arg2 ? strlen((char *)arg2) : 0;\n      if (!key_len || !value_len)\n      {\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n      storage_len= key_len + value_len +\n                   get_store_length(key_len) +\n                   get_store_length(value_len);\n\n      /* since we store terminating zero character in hash, we need\n       * to increase lengths */\n      key_len++;\n      value_len++;\n\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      if (!key_len ||\n          storage_len + mysql->options.extension->connect_attrs_len > 0xFFFF)\n      {\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n\n      if (!hash_inited(&mysql->options.extension->connect_attrs))\n      {\n        if (_hash_init(&mysql->options.extension->connect_attrs,\n                       0, 0, 0, ma_get_hash_keyval, ma_int_hash_free, 0))\n        {\n          SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n          goto end;\n        }\n      }\n      if ((buffer= (uchar *)malloc(key_len + value_len)))\n      {\n        uchar *p= buffer;\n        strcpy((char *)p, arg1);\n        p+= (strlen(arg1) + 1);\n        if (arg2)\n          strcpy((char *)p, arg2);\n\n        if (hash_insert(&mysql->options.extension->connect_attrs, buffer))\n        {\n          free(buffer);\n          SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n          goto end;\n        }\n        mysql->options.extension->connect_attrs_len+= storage_len;\n      }\n      else\n      {\n        SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n    }\n    break;\n  case MYSQL_ENABLE_CLEARTEXT_PLUGIN:\n    break;\n  case MYSQL_SECURE_AUTH:\n    mysql->options.secure_auth= *(my_bool *)arg1;\n    break;\n  case MYSQL_OPT_BIND:\n    OPT_SET_VALUE_STR(&mysql->options, bind_address, arg1);\n    break;\n  case MARIADB_OPT_TLS_CIPHER_STRENGTH:\n    OPT_SET_EXTENDED_VALUE_INT(&mysql->options, tls_cipher_strength, *((unsigned int *)arg1));\n    break;\n  case MARIADB_OPT_SSL_FP:\n  case MARIADB_OPT_TLS_PEER_FP:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_fp, (char *)arg1);\n    mysql->options.use_ssl= 1;\n    break;\n  case MARIADB_OPT_SSL_FP_LIST:\n  case MARIADB_OPT_TLS_PEER_FP_LIST:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_fp_list, (char *)arg1);\n    mysql->options.use_ssl= 1;\n    break;\n  case MARIADB_OPT_TLS_PASSPHRASE:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_pw, (char *)arg1);\n    break;\n  case MARIADB_OPT_CONNECTION_READ_ONLY:\n    OPT_SET_EXTENDED_VALUE_INT(&mysql->options, read_only, *(my_bool *)arg1);\n    break;\n  case MARIADB_OPT_PROXY_HEADER:\n    {\n    size_t arg2 = va_arg(ap, size_t);\n    OPT_SET_EXTENDED_VALUE(&mysql->options, proxy_header, (char *)arg1);\n    OPT_SET_EXTENDED_VALUE(&mysql->options, proxy_header_len, arg2);\n    }\n    break;\n  case MARIADB_OPT_TLS_VERSION:\n  case MYSQL_OPT_TLS_VERSION:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_version, (char *)arg1);\n    break;\n  case MARIADB_OPT_IO_WAIT:\n    CHECK_OPT_EXTENSION_SET(&mysql->options);\n    mysql->options.extension->io_wait = (int(*)(my_socket, my_bool, int))arg1;\n    break;\n  default:\n    va_end(ap);\n    SET_CLIENT_ERROR(mysql, CR_NOT_IMPLEMENTED, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n  va_end(ap);\n  return(0);\nend:\n  va_end(ap);\n  return(1);\n}\n\nint\nmysql_get_optionv(MYSQL *mysql, enum mysql_option option, void *arg, ...)\n{\n  va_list ap;\n\n  va_start(ap, arg);\n\n  switch(option) {\n  case MYSQL_OPT_CONNECT_TIMEOUT:\n    *((uint *)arg)= mysql->options.connect_timeout;\n    break;\n  case MYSQL_OPT_COMPRESS:\n    *((my_bool *)arg)= mysql->options.compress;\n    break;\n  case MYSQL_OPT_NAMED_PIPE:\n    *((my_bool *)arg)= mysql->options.named_pipe;\n    break;\n  case MYSQL_OPT_LOCAL_INFILE:\t\t\t/* Allow LOAD DATA LOCAL ?*/\n    *((uint *)arg)= test(mysql->options.client_flag & CLIENT_LOCAL_FILES);\n    break;\n  case MYSQL_INIT_COMMAND:\n    /* mysql_get_optionsv(mysql, MYSQL_INIT_COMMAND, commands, elements) */\n    {\n      unsigned int *elements;\n      if (arg)\n        *((char **)arg)= mysql->options.init_command ? mysql->options.init_command->buffer : NULL;\n      if ((elements= va_arg(ap, unsigned int *)))\n        *elements= mysql->options.init_command ? mysql->options.init_command->elements : 0;\n    }\n    break;\n  case MYSQL_READ_DEFAULT_FILE:\n    *((char **)arg)= mysql->options.my_cnf_file;\n    break;\n  case MYSQL_READ_DEFAULT_GROUP:\n    *((char **)arg)= mysql->options.my_cnf_group;\n    break;\n  case MYSQL_SET_CHARSET_DIR:\n    /* not supported in this version. Since all character sets\n       are internally available, we don't throw an error */\n    *((char **)arg)= NULL;\n    break;\n  case MYSQL_SET_CHARSET_NAME:\n    if (mysql->charset)\n      *((const char **)arg)= mysql->charset->csname;\n    else\n      *((char **)arg)= mysql->options.charset_name;\n    break;\n  case MYSQL_OPT_RECONNECT:\n    *((my_bool *)arg)= mysql->options.reconnect;\n    break;\n  case MYSQL_OPT_PROTOCOL:\n    *((uint *)arg)= mysql->options.protocol;\n    break;\n  case MYSQL_OPT_READ_TIMEOUT:\n    *((uint *)arg)= mysql->options.read_timeout;\n    break;\n  case MYSQL_OPT_WRITE_TIMEOUT:\n    *((uint *)arg)= mysql->options.write_timeout;\n    break;\n  case MYSQL_REPORT_DATA_TRUNCATION:\n    *((my_bool *)arg)= mysql->options.report_data_truncation;\n    break;\n  case MYSQL_PROGRESS_CALLBACK:\n    *((void (**)(const MYSQL *, uint, uint, double, const char *, uint))arg)=\n       mysql->options.extension ?  mysql->options.extension->report_progress : NULL;\n    break;\n  case MYSQL_SERVER_PUBLIC_KEY:\n    *((char **)arg)= mysql->options.extension ?\n      mysql->options.extension->server_public_key : NULL;\n    break;\n  case MYSQL_PLUGIN_DIR:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->plugin_dir : NULL;\n    break;\n  case MYSQL_DEFAULT_AUTH:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->default_auth : NULL;\n    break;\n  case MYSQL_OPT_NONBLOCK:\n    *((my_bool *)arg)= test(mysql->options.extension && mysql->options.extension->async_context);\n    break;\n  case MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS:\n    *((my_bool *)arg)= test(mysql->options.client_flag & CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS);\n    break;\n  case MYSQL_OPT_SSL_ENFORCE:\n    *((my_bool *)arg)= mysql->options.use_ssl;\n    break;\n  case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:\n    *((my_bool *)arg)= test(mysql->options.client_flag & CLIENT_SSL_VERIFY_SERVER_CERT);\n    break;\n  case MYSQL_OPT_SSL_KEY:\n    *((char **)arg)= mysql->options.ssl_key;\n    break;\n  case MYSQL_OPT_SSL_CERT:\n    *((char **)arg)= mysql->options.ssl_cert;\n    break;\n  case MYSQL_OPT_SSL_CA:\n    *((char **)arg)= mysql->options.ssl_ca;\n    break;\n  case MYSQL_OPT_SSL_CAPATH:\n    *((char **)arg)= mysql->options.ssl_capath;\n    break;\n  case MYSQL_OPT_SSL_CIPHER:\n    *((char **)arg)= mysql->options.ssl_cipher;\n    break;\n  case MYSQL_OPT_SSL_CRL:\n    *((char **)arg)= mysql->options.extension ? mysql->options.ssl_cipher : NULL;\n    break;\n  case MYSQL_OPT_SSL_CRLPATH:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->ssl_crlpath : NULL;\n    break;\n  case MYSQL_OPT_CONNECT_ATTRS:\n    /* mysql_get_optionsv(mysql, MYSQL_OPT_CONNECT_ATTRS, keys, vals, elements) */\n    {\n      unsigned int i, *elements;\n      char **key= NULL;\n      void *arg1;\n      char **val= NULL;\n\n      if (arg)\n        key= *(char ***)arg;\n\n      arg1= va_arg(ap, char **);\n      if (arg1)\n        val= *(char ***)arg1;\n\n      if (!(elements= va_arg(ap, unsigned int *)))\n        goto error;\n\n      *elements= 0;\n\n      if (!mysql->options.extension ||\n          !hash_inited(&mysql->options.extension->connect_attrs))\n        break;\n\n      *elements= mysql->options.extension->connect_attrs.records;\n\n      if (val || key)\n      {\n        for (i=0; i < *elements; i++)\n        {\n          uchar *p= hash_element(&mysql->options.extension->connect_attrs, i);\n          if (key)\n            key[i]= (char *)p;\n          p+= strlen((char *)p) + 1;\n          if (val)\n            val[i]= (char *)p;\n        }\n      }\n    }\n    break;\n  case MYSQL_OPT_MAX_ALLOWED_PACKET:\n    *((unsigned long *)arg)= (mysql) ? mysql->options.max_allowed_packet :\n                                       max_allowed_packet;\n    break;\n  case MYSQL_OPT_NET_BUFFER_LENGTH:\n    *((unsigned long *)arg)= net_buffer_length;\n    break;\n  case MYSQL_SECURE_AUTH:\n    *((my_bool *)arg)= mysql->options.secure_auth;\n    break;\n  case MYSQL_OPT_BIND:\n    *((char **)arg)= mysql->options.bind_address;\n    break;\n  case MARIADB_OPT_TLS_CIPHER_STRENGTH:\n    *((unsigned int *)arg) = mysql->options.extension ? mysql->options.extension->tls_cipher_strength : 0;\n    break;\n  case MARIADB_OPT_SSL_FP:\n  case MARIADB_OPT_TLS_PEER_FP:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->tls_fp : NULL;\n    break;\n  case MARIADB_OPT_SSL_FP_LIST:\n  case MARIADB_OPT_TLS_PEER_FP_LIST:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->tls_fp_list : NULL;\n    break;\n  case MARIADB_OPT_TLS_PASSPHRASE:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->tls_pw : NULL;\n    break;\n  case MARIADB_OPT_CONNECTION_READ_ONLY:\n    *((my_bool *)arg)= mysql->options.extension ? mysql->options.extension->read_only : 0;\n    break;\n  case MARIADB_OPT_USERDATA:\n    /* nysql_get_optionv(mysql, MARIADB_OPT_USERDATA, key, value) */\n    {\n      uchar *p;\n      void *data= va_arg(ap, void *);\n      char *key= (char *)arg;\n      if (key && data && mysql->options.extension && hash_inited(&mysql->options.extension->userdata) &&\n          (p= (uchar *)hash_search(&mysql->options.extension->userdata, (uchar *)key,\n                      (uint)strlen((char *)key))))\n      {\n        p+= strlen(key) + 1;\n        *((void **)data)= *((void **)p);\n        break;\n      }\n      if (data)\n        *((void **)data)= NULL;\n    }\n    break;\n  case MARIADB_OPT_CONNECTION_HANDLER:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->connection_handler : NULL;\n    break;\n  case MARIADB_OPT_IO_WAIT:\n    *((int(**)(my_socket, my_bool, int))arg) = mysql->options.extension ? mysql->options.extension->io_wait : NULL;\n    break;\n  default:\n    va_end(ap);\n    SET_CLIENT_ERROR(mysql, CR_NOT_IMPLEMENTED, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n  va_end(ap);\n  return(0);\nerror:\n  va_end(ap);\n  return(1);\n}\n\nint STDCALL mysql_get_option(MYSQL *mysql, enum mysql_option option, void *arg)\n{\n  return mysql_get_optionv(mysql, option, arg);\n}\n\nint STDCALL\nmysql_options(MYSQL *mysql,enum mysql_option option, const void *arg)\n{\n  return mysql_optionsv(mysql, option, arg);\n}\n\nint STDCALL\nmysql_options4(MYSQL *mysql,enum mysql_option option, const void *arg1, const void *arg2)\n{\n  return mysql_optionsv(mysql, option, arg1, arg2);\n}\n/****************************************************************************\n** Functions to get information from the MySQL structure\n** These are functions to make shared libraries more usable.\n****************************************************************************/\n\n/* MYSQL_RES */\nmy_ulonglong STDCALL mysql_num_rows(MYSQL_RES *res)\n{\n  return res->row_count;\n}\n\nunsigned int STDCALL mysql_num_fields(MYSQL_RES *res)\n{\n  return res->field_count;\n}\n\n/* deprecated */\nmy_bool STDCALL mysql_eof(MYSQL_RES *res)\n{\n  return res->eof;\n}\n\nMYSQL_FIELD * STDCALL mysql_fetch_field_direct(MYSQL_RES *res,uint fieldnr)\n{\n  return &(res)->fields[fieldnr];\n}\n\nMYSQL_FIELD * STDCALL mysql_fetch_fields(MYSQL_RES *res)\n{\n  return (res)->fields;\n}\n\nMYSQL_ROWS * STDCALL mysql_row_tell(MYSQL_RES *res)\n{\n  return res->data_cursor;\n}\n\nuint STDCALL mysql_field_tell(MYSQL_RES *res)\n{\n  return (res)->current_field;\n}\n\n/* MYSQL */\n\nunsigned int STDCALL mysql_field_count(MYSQL *mysql)\n{\n  return mysql->field_count;\n}\n\nmy_ulonglong STDCALL mysql_affected_rows(MYSQL *mysql)\n{\n  return (mysql)->affected_rows;\n}\n\nmy_bool STDCALL mysql_autocommit(MYSQL *mysql, my_bool mode)\n{\n  return((my_bool) mysql_real_query(mysql, (mode) ? \"SET autocommit=1\" :\n                                         \"SET autocommit=0\", 16));\n}\n\nmy_bool STDCALL mysql_commit(MYSQL *mysql)\n{\n  return((my_bool)mysql_real_query(mysql, \"COMMIT\", (unsigned long)strlen(\"COMMIT\")));\n}\n\nmy_bool STDCALL mysql_rollback(MYSQL *mysql)\n{\n  return((my_bool)mysql_real_query(mysql, \"ROLLBACK\", (unsigned long)strlen(\"ROLLBACK\")));\n}\n\nmy_ulonglong STDCALL mysql_insert_id(MYSQL *mysql)\n{\n  return (mysql)->insert_id;\n}\n\nuint STDCALL mysql_errno(MYSQL *mysql)\n{\n  return mysql ? mysql->net.last_errno : 0;\n}\n\nconst char * STDCALL mysql_error(MYSQL *mysql)\n{\n  return mysql ? (mysql)->net.last_error : (char *)\"\";\n}\n\nconst char *STDCALL mysql_info(MYSQL *mysql)\n{\n  return (mysql)->info;\n}\n\nmy_bool STDCALL mysql_more_results(MYSQL *mysql)\n{\n  return(test(mysql->server_status & SERVER_MORE_RESULTS_EXIST));\n}\n\nint STDCALL mysql_next_result(MYSQL *mysql)\n{\n\n  /* make sure communication is not blocking */\n  if (mysql->status != MYSQL_STATUS_READY)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n\n  /* clear error, and mysql status variables */\n  CLEAR_CLIENT_ERROR(mysql);\n  mysql->affected_rows = (ulonglong) ~0;\n\n  if (mysql->server_status & SERVER_MORE_RESULTS_EXIST)\n  {\n     return(mysql->methods->db_read_query_result(mysql));\n  }\n\n  return(-1);\n}\n\nulong STDCALL mysql_thread_id(MYSQL *mysql)\n{\n  return (mysql)->thread_id;\n}\n\nconst char * STDCALL mysql_character_set_name(MYSQL *mysql)\n{\n  return mysql->charset->csname;\n}\n\n\nuint STDCALL mysql_thread_safe(void)\n{\n#ifdef THREAD\n  return 1;\n#else\n  return 0;\n#endif\n}\n\n/****************************************************************************\n** Some support functions\n****************************************************************************/\n\n/*\n** Add escape characters to a string (blob?) to make it suitable for a insert\n** to should at least have place for length*2+1 chars\n** Returns the length of the to string\n*/\n\nulong STDCALL\nmysql_escape_string(char *to,const char *from, ulong length)\n{\n    return (ulong)mysql_cset_escape_slashes(ma_default_charset_info, to, from, length);\n}\n\nulong STDCALL\nmysql_real_escape_string(MYSQL *mysql, char *to,const char *from,\n\t\t\t ulong length)\n{\n  if (mysql->server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES)\n    return (ulong)mysql_cset_escape_quotes(mysql->charset, to, from, length);\n  else\n    return (ulong)mysql_cset_escape_slashes(mysql->charset, to, from, length);\n}\n\nstatic void mariadb_get_charset_info(MYSQL *mysql, MY_CHARSET_INFO *cs)\n{\n  if (!cs)\n    return;\n\n  cs->number= mysql->charset->nr;\n  cs->csname=  mysql->charset->csname;\n  cs->name= mysql->charset->name;\n  cs->state= 0;\n  cs->comment= NULL;\n  cs->dir= NULL;\n  cs->mbminlen= mysql->charset->char_minlen;\n  cs->mbmaxlen= mysql->charset->char_maxlen;\n\n  return;\n}\n\nvoid STDCALL mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *cs)\n{\n  mariadb_get_charset_info(mysql, cs);\n}\n\nint STDCALL mysql_set_character_set(MYSQL *mysql, const char *csname)\n{\n  const MARIADB_CHARSET_INFO *cs;\n\n  if (!csname)\n    goto error;\n\n  if ((cs= mysql_find_charset_name(csname)))\n  {\n    char buff[64];\n\n    snprintf(buff, 63, \"SET NAMES %s\", cs->csname);\n    if (!mysql_real_query(mysql, buff, (unsigned long)strlen(buff)))\n    {\n      mysql->charset= cs;\n      return(0);\n    }\n    return(mysql->net.last_errno);\n  }\n\nerror:\n  my_set_error(mysql, CR_CANT_READ_CHARSET, SQLSTATE_UNKNOWN,\n               0, csname, \"compiled_in\");\n  return(mysql->net.last_errno);\n}\n\nunsigned int STDCALL mysql_warning_count(MYSQL *mysql)\n{\n  return mysql->warning_count;\n}\n\nconst char * STDCALL mysql_sqlstate(MYSQL *mysql)\n{\n  return mysql->net.sqlstate;\n}\n\n#ifndef _WIN32\n#include <signal.h>\nstatic void ignore_sigpipe()\n{\n  signal(SIGPIPE, SIG_IGN);\n}\n#else\n#define ignore_sigpipe()\n#endif\n\n#ifdef _WIN32\nstatic int mysql_once_init()\n#else\nstatic void mysql_once_init()\n#endif\n{\n  ma_init();\t\t\t\t\t/* Will init threads */\n  init_client_errs();\n  get_default_configuration_dirs();\n  set_default_charset_by_name(MARIADB_DEFAULT_CHARSET, 0);\n  if (mysql_client_plugin_init())\n  {\n#ifdef _WIN32\n    return 1;\n#else\n    return;\n#endif\n  }\n  if (!mysql_port)\n  {\n#if !__has_feature(memory_sanitizer) /* work around MSAN deficiency */\n    struct servent *serv_ptr;\n#endif\n    char *env;\n\n    mysql_port = MARIADB_PORT;\n#if !__has_feature(memory_sanitizer) /* work around MSAN deficiency */\n    if ((serv_ptr = getservbyname(\"mysql\", \"tcp\")))\n      mysql_port = (uint)ntohs((ushort)serv_ptr->s_port);\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysql_port =(uint)atoi(env);\n  }\n  if (!mysql_unix_port)\n  {\n    char *env;\n#ifdef _WIN32\n    mysql_unix_port = (char*)MARIADB_NAMEDPIPE;\n#else\n    mysql_unix_port = (char*)MARIADB_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")) ||\n      (env = getenv(\"MARIADB_UNIX_PORT\")))\n      mysql_unix_port = env;\n  }\n  if (!mysql_ps_subsystem_initialized)\n    mysql_init_ps_subsystem();\n#ifdef HAVE_TLS\n  ma_tls_start(0, 0);\n#endif\n  ignore_sigpipe();\n  mysql_client_init = 1;\n#ifdef _WIN32\n  return 0;\n#endif\n}\n\n#ifdef _WIN32\nstatic INIT_ONCE init_once= INIT_ONCE_STATIC_INIT;\nBOOL CALLBACK win_init_once(\n  PINIT_ONCE InitOnce,\n  PVOID Parameter,\n  PVOID *lpContext)\n{\n  return !mysql_once_init();\n  return TRUE;\n}\n#else\nstatic pthread_once_t init_once = PTHREAD_ONCE_INIT;\n#endif\n\nint STDCALL mysql_server_init(int argc __attribute__((unused)),\n  char **argv __attribute__((unused)),\n  char **groups __attribute__((unused)))\n{\n#ifdef _WIN32\n  BOOL ret = InitOnceExecuteOnce(&init_once, win_init_once, NULL, NULL);\n  return ret? 0: 1;\n#else\n  return pthread_once(&init_once, mysql_once_init);\n#endif\n}\n\nvoid STDCALL mysql_server_end(void)\n{\n  if (!mysql_client_init)\n    return;\n\n  release_configuration_dirs();\n  mysql_client_plugin_deinit();\n\n  list_free(pvio_callback, 0);\n  if (ma_init_done)\n    ma_end(0);\n#ifdef HAVE_TLS\n  ma_pvio_tls_end();\n#endif\n  mysql_client_init= 0;\n  ma_init_done= 0;\n#ifdef WIN32\n  init_once = (INIT_ONCE)INIT_ONCE_STATIC_INIT;\n#else\n  init_once = (pthread_once_t)PTHREAD_ONCE_INIT;\n#endif\n}\n\nmy_bool STDCALL mysql_thread_init(void)\n{\n  return 0;\n}\n\nvoid STDCALL mysql_thread_end(void)\n{\n}\n\nint STDCALL mysql_set_server_option(MYSQL *mysql,\n                                    enum enum_mysql_set_option option)\n{\n  char buffer[2];\n  int2store(buffer, (uint)option);\n  return(ma_simple_command(mysql, COM_SET_OPTION, buffer, sizeof(buffer), 0, 0));\n}\n\nulong STDCALL mysql_get_client_version(void)\n{\n  return MARIADB_VERSION_ID;\n}\n\nulong STDCALL mysql_hex_string(char *to, const char *from, unsigned long len)\n{\n  char *start= to;\n  char hexdigits[]= \"0123456789ABCDEF\";\n\n  while (len--)\n  {\n    *to++= hexdigits[((unsigned char)*from) >> 4];\n    *to++= hexdigits[((unsigned char)*from) & 0x0F];\n    from++;\n  }\n  *to= 0;\n  return (ulong)(to - start);\n}\n\nmy_bool STDCALL mariadb_connection(MYSQL *mysql)\n{\n  return (strstr(mysql->server_version, \"MariaDB\") ||\n          strstr(mysql->server_version, \"-maria-\"));\n}\n\nconst char * STDCALL\nmysql_get_server_name(MYSQL *mysql)\n{\n  if (mysql->options.extension &&\n      mysql->options.extension->db_driver != NULL)\n    return mysql->options.extension->db_driver->name;\n  return mariadb_connection(mysql) ? \"MariaDB\" : \"MySQL\";\n}\n\nstatic my_socket mariadb_get_socket(MYSQL *mysql)\n{\n  my_socket sock= INVALID_SOCKET;\n  if (mysql->net.pvio)\n  {\n    ma_pvio_get_handle(mysql->net.pvio, &sock);\n\n  }\n  /* if an asynchronous connect is in progress, we need to obtain\n     pvio handle from async_context until the connection was\n     successfully established.\n  */\n  else if (mysql->options.extension && mysql->options.extension->async_context &&\n           mysql->options.extension->async_context->pvio)\n  {\n    ma_pvio_get_handle(mysql->options.extension->async_context->pvio, &sock);\n  }\n  return sock;\n}\n\nmy_socket STDCALL\nmysql_get_socket(MYSQL *mysql)\n{\n  return mariadb_get_socket(mysql);\n}\n\nMARIADB_CHARSET_INFO * STDCALL mariadb_get_charset_by_name(const char *csname)\n{\n  return (MARIADB_CHARSET_INFO *)mysql_find_charset_name(csname);\n}\n\nMARIADB_CHARSET_INFO * STDCALL mariadb_get_charset_by_nr(unsigned int csnr)\n{\n  return (MARIADB_CHARSET_INFO *)mysql_find_charset_nr(csnr);\n}\n\nmy_bool mariadb_get_infov(MYSQL *mysql, enum mariadb_value value, void *arg, ...)\n{\n  va_list ap;\n\n  va_start(ap, arg);\n\n  switch(value) {\n  case MARIADB_MAX_ALLOWED_PACKET:\n    *((size_t *)arg)= (size_t)max_allowed_packet;\n    break;\n  case MARIADB_NET_BUFFER_LENGTH:\n    *((size_t *)arg)= (size_t)net_buffer_length;\n    break;\n  case MARIADB_CONNECTION_ERROR_ID:\n    if (!mysql)\n      goto error;\n    *((unsigned int *)arg)= mysql->net.last_errno;\n    break;\n  case MARIADB_CONNECTION_ERROR:\n    if (!mysql)\n      goto error;\n    *((char **)arg)= mysql->net.last_error;\n    break;\n  case MARIADB_CONNECTION_SQLSTATE:\n    if (!mysql)\n      goto error;\n    *((char **)arg)= mysql->net.sqlstate;\n    break;\n  case MARIADB_CONNECTION_TLS_VERSION:\n    #ifdef HAVE_TLS\n    if (mysql && mysql->net.pvio && mysql->net.pvio->ctls)\n      *((char **)arg)= (char *)ma_pvio_tls_get_protocol_version(mysql->net.pvio->ctls);\n    else\n    #endif\n      goto error;\n    break;\n  case MARIADB_CONNECTION_TLS_VERSION_ID:\n    #ifdef HAVE_TLS\n    if (mysql && mysql->net.pvio && mysql->net.pvio->ctls)\n      *((unsigned int *)arg)= ma_pvio_tls_get_protocol_version_id(mysql->net.pvio->ctls);\n    else\n    #endif\n      goto error;\n    break;\n  case MARIADB_TLS_LIBRARY:\n#ifdef HAVE_TLS\n    *((const char **)arg)= tls_library_version;\n#else\n    *((const char **)arg)= \"Off\";\n#endif\n    break;\n  case MARIADB_CLIENT_VERSION:\n    *((const char **)arg)= MARIADB_CLIENT_VERSION_STR;\n    break;\n  case MARIADB_CLIENT_VERSION_ID:\n    *((size_t *)arg)= MARIADB_VERSION_ID;\n    break;\n  case MARIADB_CONNECTION_SERVER_VERSION:\n    if (mysql)\n      *((char **)arg)= mysql->server_version;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_TYPE:\n    if (mysql)\n      *((const char **)arg)= mariadb_connection(mysql) ? \"MariaDB\" : \"MySQL\";\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_VERSION_ID:\n    if (mysql)\n      *((size_t *)arg)= mariadb_server_version_id(mysql);\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_PROTOCOL_VERSION_ID:\n    if (mysql)\n      *((unsigned int *)arg)= mysql->protocol_version;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_MARIADB_CHARSET_INFO:\n    if (mysql)\n      mariadb_get_charset_info(mysql, (MY_CHARSET_INFO *)arg);\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SOCKET:\n    if (mysql)\n      *((my_socket *)arg)= mariadb_get_socket(mysql);\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_TYPE:\n    if (mysql  && mysql->net.pvio)\n      *((int *)arg)= (int)mysql->net.pvio->type;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_ASYNC_TIMEOUT_MS:\n    if (mysql && mysql->options.extension && mysql->options.extension->async_context)\n      *((unsigned int *)arg)= mysql->options.extension->async_context->timeout_value;\n    break;\n  case MARIADB_CONNECTION_ASYNC_TIMEOUT:\n    if (mysql && mysql->options.extension && mysql->options.extension->async_context)\n    {\n      unsigned int timeout= mysql->options.extension->async_context->timeout_value;\n      if (timeout > UINT_MAX - 999)\n        *((unsigned int *)arg)= (timeout - 1)/1000 + 1;\n      else\n        *((unsigned int *)arg)= (timeout+999)/1000;\n    }\n    break;\n  case MARIADB_CHARSET_NAME:\n    {\n      char *name;\n      name= va_arg(ap, char *);\n      if (name)\n        *((MARIADB_CHARSET_INFO **)arg)= (MARIADB_CHARSET_INFO *)mysql_find_charset_name(name);\n      else\n        goto error;\n    }\n    break;\n  case MARIADB_CHARSET_ID:\n    {\n      unsigned int nr;\n      nr= va_arg(ap, unsigned int);\n      *((MARIADB_CHARSET_INFO **)arg)= (MARIADB_CHARSET_INFO *)mysql_find_charset_nr(nr);\n    }\n    break;\n  case MARIADB_CONNECTION_SSL_CIPHER:\n    #ifdef HAVE_TLS\n    if (mysql && mysql->net.pvio && mysql->net.pvio->ctls)\n      *((char **)arg)= (char *)ma_pvio_tls_cipher(mysql->net.pvio->ctls);\n    else\n    #endif\n      goto error;\n    break;\n  case MARIADB_CLIENT_ERRORS:\n    *((char ***)arg)= (char **)client_errors;\n    break;\n  case MARIADB_CONNECTION_INFO:\n    if (mysql)\n      *((char **)arg)= (char *)mysql->info;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_PVIO_TYPE:\n    if (mysql && mysql->net.pvio)\n      *((unsigned int *)arg)= (unsigned int)mysql->net.pvio->type;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SCHEMA:\n    if (mysql)\n      *((char **)arg)= mysql->db;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_USER:\n    if (mysql)\n      *((char **)arg)= mysql->user;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_PORT:\n    if (mysql)\n      *((unsigned int *)arg)= mysql->port;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_UNIX_SOCKET:\n    if (mysql)\n      *((char **)arg)= mysql->unix_socket;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_HOST:\n    if (mysql)\n      *((char **)arg)= mysql->host;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_STATUS:\n    if (mysql)\n      *((unsigned int *)arg)= mysql->server_status;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_CAPABILITIES:\n    if (mysql)\n      *((unsigned long *)arg)= mysql->server_capabilities;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_EXTENDED_SERVER_CAPABILITIES:\n    if (mysql)\n      *((unsigned long *)arg)= mysql->extension->mariadb_server_capabilities;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_CLIENT_CAPABILITIES:\n    if (mysql)\n      *((unsigned long *)arg)= mysql->client_flag;\n    else\n      goto error;\n    break;\n  default:\n    va_end(ap);\n    return(-1);\n  }\n  va_end(ap);\n  return(0);\nerror:\n  va_end(ap);\n  return(-1);\n}\n\nmy_bool STDCALL mariadb_get_info(MYSQL *mysql, enum mariadb_value value, void *arg)\n{\n  return mariadb_get_infov(mysql, value, arg);\n}\n\n/*\n  Immediately aborts connection, making all subsequent read/write operations fail.\n  Does not invalidate memory used for mysql structure, nor closes any communication\n  channels - mysql_close is still needed.\n  Useful to break long query, in situation  sending KILL is not possible.\n*/\nint STDCALL mariadb_cancel(MYSQL *mysql)\n{\n  if (!mysql || !mysql->net.pvio || !mysql->net.pvio->methods || !mysql->net.pvio->methods->shutdown)\n  {\n    return 1;\n  }\n  else\n  {\n    MARIADB_PVIO *pvio = mysql->net.pvio;\n    return pvio->methods->shutdown(pvio);\n  }\n}\n\n/* compatibility functions for MariaDB */\nvoid STDCALL\nmysql_debug(const char *debug __attribute__((unused)))\n{\n  return;\n}\n\n/********************************************************************\n  mysql_net_ functions - low-level API to MySQL protocol\n*********************************************************************/\nulong STDCALL mysql_net_read_packet(MYSQL *mysql)\n{\n  return ma_net_safe_read(mysql);\n}\n\nulong STDCALL mysql_net_field_length(uchar **packet)\n{\n  return net_field_length(packet);\n}\n\nmy_bool STDCALL mysql_embedded(void)\n{\n#ifdef EMBEDDED_LIBRARY\n  return 1;\n#else\n  return 0;\n#endif\n}\n\nMYSQL_PARAMETERS *STDCALL\nmysql_get_parameters(void)\n{\n  return &mariadb_internal_parameters;\n}\n\nint STDCALL mysql_reset_connection(MYSQL *mysql)\n{\n  int rc;\n\n  /* check if connection handler is active */\n  if (IS_CONNHDLR_ACTIVE(mysql))\n  {\n    if (mysql->extension->conn_hdlr->plugin && mysql->extension->conn_hdlr->plugin->reset)\n      return(mysql->extension->conn_hdlr->plugin->reset(mysql));\n  }\n\n  /* skip result sets */\n  if (mysql->status == MYSQL_STATUS_USE_RESULT ||\n      mysql->status == MYSQL_STATUS_GET_RESULT ||\n      mysql->status & SERVER_MORE_RESULTS_EXIST)\n  {\n    mthd_my_skip_result(mysql);\n    mysql->status= MYSQL_STATUS_READY;\n  }\n\n  rc= ma_simple_command(mysql, COM_RESET_CONNECTION, 0, 0, 0, 0);\n  if (rc && mysql->options.reconnect)\n  {\n    /* There is no big sense in resetting but we need reconnect */\n    rc= ma_simple_command(mysql, COM_RESET_CONNECTION,0,0,0,0);\n  }\n  if (rc)\n    return 1;\n\n  /* reset the connection in all active statements */\n  ma_invalidate_stmts(mysql, \"mysql_reset_connection()\");\n  free_old_query(mysql);\n  mysql->status= MYSQL_STATUS_READY;\n  mysql->affected_rows= ~(my_ulonglong)0;\n  mysql->insert_id= 0;\n  return 0;\n}\n\n#undef STDCALL\n/* API functions for usage in dynamic plugins */\nstruct st_mariadb_api MARIADB_API=\n{\n  mysql_num_rows,\n  mysql_num_fields,\n  mysql_eof,\n  mysql_fetch_field_direct,\n  mysql_fetch_fields,\n  mysql_row_tell,\n  mysql_field_tell,\n  mysql_field_count,\n  mysql_more_results,\n  mysql_next_result,\n  mysql_affected_rows,\n  mysql_autocommit,\n  mysql_commit,\n  mysql_rollback,\n  mysql_insert_id,\n  mysql_errno,\n  mysql_error,\n  mysql_info,\n  mysql_thread_id,\n  mysql_character_set_name,\n  mysql_get_character_set_info,\n  mysql_set_character_set,\n  mariadb_get_infov,\n  mariadb_get_info,\n  mysql_init,\n  mysql_ssl_set,\n  mysql_get_ssl_cipher,\n  mysql_change_user,\n  mysql_real_connect,\n  mysql_close,\n  mysql_select_db,\n  mysql_query,\n  mysql_send_query,\n  mysql_read_query_result,\n  mysql_real_query,\n  mysql_shutdown,\n  mysql_dump_debug_info,\n  mysql_refresh,\n  mysql_kill,\n  mysql_ping,\n  mysql_stat,\n  mysql_get_server_info,\n  mysql_get_server_version,\n  mysql_get_host_info,\n  mysql_get_proto_info,\n  mysql_list_dbs,\n  mysql_list_tables,\n  mysql_list_fields,\n  mysql_list_processes,\n  mysql_store_result,\n  mysql_use_result,\n  mysql_options,\n  mysql_free_result,\n  mysql_data_seek,\n  mysql_row_seek,\n  mysql_field_seek,\n  mysql_fetch_row,\n  mysql_fetch_lengths,\n  mysql_fetch_field,\n  mysql_escape_string,\n  mysql_real_escape_string,\n  mysql_thread_safe,\n  mysql_warning_count,\n  mysql_sqlstate,\n  mysql_server_init,\n  mysql_server_end,\n  mysql_thread_end,\n  mysql_thread_init,\n  mysql_set_server_option,\n  mysql_get_client_info,\n  mysql_get_client_version,\n  mariadb_connection,\n  mysql_get_server_name,\n  mariadb_get_charset_by_name,\n  mariadb_get_charset_by_nr,\n  mariadb_convert_string,\n  mysql_optionsv,\n  mysql_get_optionv,\n  mysql_get_option,\n  mysql_hex_string,\n  mysql_get_socket,\n  mysql_get_timeout_value,\n  mysql_get_timeout_value_ms,\n  mariadb_reconnect,\n  mysql_stmt_init,\n  mysql_stmt_prepare,\n  mysql_stmt_execute,\n  mysql_stmt_fetch,\n  mysql_stmt_fetch_column,\n  mysql_stmt_store_result,\n  mysql_stmt_param_count,\n  mysql_stmt_attr_set,\n  mysql_stmt_attr_get,\n  mysql_stmt_bind_param,\n  mysql_stmt_bind_result,\n  mysql_stmt_close,\n  mysql_stmt_reset,\n  mysql_stmt_free_result,\n  mysql_stmt_send_long_data,\n  mysql_stmt_result_metadata,\n  mysql_stmt_param_metadata,\n  mysql_stmt_errno,\n  mysql_stmt_error,\n  mysql_stmt_sqlstate,\n  mysql_stmt_row_seek,\n  mysql_stmt_row_tell,\n  mysql_stmt_data_seek,\n  mysql_stmt_num_rows,\n  mysql_stmt_affected_rows,\n  mysql_stmt_insert_id,\n  mysql_stmt_field_count,\n  mysql_stmt_next_result,\n  mysql_stmt_more_results,\n  mariadb_stmt_execute_direct,\n  mysql_reset_connection\n};\n\n/*\n * Default methods for a connection. These methods are\n * stored in mysql->methods and can be overwritten by\n * a plugin, e.g. for using another database\n */\nstruct st_mariadb_methods MARIADB_DEFAULT_METHODS = {\n  /* open a connection */\n  mthd_my_real_connect,\n  /* close connection */\n  mysql_close_slow_part,\n  /* send command to server */\n  mthd_my_send_cmd,\n  /* skip result set */\n  mthd_my_skip_result,\n  /* read response packet */\n  mthd_my_read_query_result,\n  /* read all rows from a result set */\n  mthd_my_read_rows,\n  /* read one/next row */\n  mthd_my_read_one_row,\n  /* check if datatype is supported */\n  mthd_supported_buffer_type,\n  /* read response packet from prepare */\n  mthd_stmt_read_prepare_response,\n  /* read response from stmt execute */\n  mthd_my_read_query_result,\n  /* get result set metadata for a prepared statement */\n  mthd_stmt_get_result_metadata,\n  /* get param metadata for a prepared statement */\n  mthd_stmt_get_param_metadata,\n  /* read all rows (buffered) */\n  mthd_stmt_read_all_rows,\n  /* fetch one row (unbuffered) */\n  mthd_stmt_fetch_row,\n  /* store values in bind buffer */\n  mthd_stmt_fetch_to_bind,\n  /* skip unbuffered stmt result */\n  mthd_stmt_flush_unbuffered,\n  /* set error */\n  my_set_error,\n  /* invalidate statements */\n  ma_invalidate_stmts,\n  /* API functions */\n  &MARIADB_API\n};\n"], "fixing_code": ["/************************************************************************************\n    Copyright (C) 2000, 2012 MySQL AB & MySQL Finland AB & TCX DataKonsult AB,\n                 Monty Program AB\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc.,\n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA\n\n   Part of this code includes code from the PHP project which\n   is freely available from http://www.php.net\n*************************************************************************************/\n\n#include <ma_global.h>\n\n#include <ma_sys.h>\n#include <ma_string.h>\n#include <mariadb_ctype.h>\n#include <ma_common.h>\n#include \"ma_priv.h\"\n#include \"ma_context.h\"\n#include \"mysql.h\"\n#include \"mariadb_version.h\"\n#include \"ma_server_error.h\"\n#include <mariadb/ma_io.h>\n#include \"errmsg.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <time.h>\n#include <mariadb_dyncol.h>\n\n#ifndef __has_feature\n# define __has_feature(x) 0\n#endif\n\n#ifdef HAVE_PWD_H\n#include <pwd.h>\n#endif\n#if !defined(MSDOS) && !defined(_WIN32)\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#ifdef HAVE_SELECT_H\n#  include <select.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#endif\n#ifdef HAVE_SYS_UN_H\n#  include <sys/un.h>\n#endif\n#ifndef INADDR_NONE\n#define INADDR_NONE -1\n#endif\n#include <ma_sha1.h>\n#ifndef _WIN32\n#include <poll.h>\n#endif\n#include <ma_pvio.h>\n#ifdef HAVE_TLS\n#include <ma_tls.h>\n#endif\n#include <mysql/client_plugin.h>\n#ifdef _WIN32\n#include \"Shlwapi.h\"\n#define strncasecmp _strnicmp\n#endif\n\n#define ASYNC_CONTEXT_DEFAULT_STACK_SIZE (4096*15)\n#define MA_RPL_VERSION_HACK \"5.5.5-\"\n\n#define CHARSET_NAME_LEN 64\n\n#undef max_allowed_packet\n#undef net_buffer_length\nextern ulong max_allowed_packet; /* net.c */\nextern ulong net_buffer_length;  /* net.c */\n\nstatic MYSQL_PARAMETERS mariadb_internal_parameters= {&max_allowed_packet, &net_buffer_length, 0};\nstatic my_bool mysql_client_init=0;\nstatic void mysql_close_options(MYSQL *mysql);\nstatic void ma_clear_session_state(MYSQL *mysql);\nextern void release_configuration_dirs();\nextern char **get_default_configuration_dirs();\nextern my_bool  ma_init_done;\nextern my_bool  mysql_ps_subsystem_initialized;\nextern my_bool mysql_handle_local_infile(MYSQL *mysql, const char *filename, my_bool can_local_infile);\nextern const MARIADB_CHARSET_INFO * mysql_find_charset_nr(uint charsetnr);\nextern const MARIADB_CHARSET_INFO * mysql_find_charset_name(const char * const name);\nextern my_bool set_default_charset_by_name(const char *cs_name, myf flags __attribute__((unused)));\nextern int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,\n                           const char *data_plugin, const char *db);\nextern int net_add_multi_command(NET *net, uchar command, const uchar *packet,\n                                 size_t length);\n\nextern LIST *pvio_callback;\n\n/* prepare statement methods from my_stmt.c */\nextern my_bool mthd_supported_buffer_type(enum enum_field_types type);\nextern my_bool mthd_stmt_read_prepare_response(MYSQL_STMT *stmt);\nextern my_bool mthd_stmt_get_param_metadata(MYSQL_STMT *stmt);\nextern my_bool mthd_stmt_get_result_metadata(MYSQL_STMT *stmt);\nextern int mthd_stmt_fetch_row(MYSQL_STMT *stmt, unsigned char **row);\nextern int mthd_stmt_fetch_to_bind(MYSQL_STMT *stmt, unsigned char *row);\nextern int mthd_stmt_read_all_rows(MYSQL_STMT *stmt);\nextern void mthd_stmt_flush_unbuffered(MYSQL_STMT *stmt);\nextern my_bool _mariadb_read_options(MYSQL *mysql, const char *dir, const char *config_file, char *group, unsigned int recursion);\nextern unsigned char *mysql_net_store_length(unsigned char *packet, size_t length);\n\nextern void\nmy_context_install_suspend_resume_hook(struct mysql_async_context *b,\n                                       void (*hook)(my_bool, void *),\n                                       void *user_data);\n\nuint mysql_port=0;\nmy_string mysql_unix_port=0;\n\n#define CONNECT_TIMEOUT 0\n\nstruct st_mariadb_methods MARIADB_DEFAULT_METHODS;\n\n#if defined(MSDOS) || defined(_WIN32)\n// socket_errno is defined in ma_global.h for all platforms\n#define perror(A)\n#else\n#include <errno.h>\n#define SOCKET_ERROR -1\n#endif /* _WIN32 */\n\n#include <mysql/client_plugin.h>\n\n#define IS_CONNHDLR_ACTIVE(mysql)\\\n  ((mysql)->extension && (mysql)->extension->conn_hdlr)\n\nstatic void end_server(MYSQL *mysql);\nstatic void mysql_close_memory(MYSQL *mysql);\nvoid read_user_name(char *name);\nmy_bool STDCALL mariadb_reconnect(MYSQL *mysql);\nstatic int cli_report_progress(MYSQL *mysql, uchar *packet, uint length);\n\nextern int mysql_client_plugin_init();\nextern void mysql_client_plugin_deinit();\n\n/* net_get_error */\nvoid net_get_error(char *buf, size_t buf_len,\n       char *error, size_t error_len,\n       unsigned int *error_no,\n       char *sqlstate)\n{\n  char *p= buf;\n  size_t error_msg_len= 0;\n\n  if (buf_len > 2)\n  {\n    *error_no= uint2korr(p);\n    p+= 2;\n\n    /* since 4.1 sqlstate is following */\n    if (*p == '#')\n    {\n      memcpy(sqlstate, ++p, SQLSTATE_LENGTH);\n      p+= SQLSTATE_LENGTH;\n    }\n    error_msg_len= buf_len - (p - buf);\n    error_msg_len= MIN(error_msg_len, error_len - 1);\n    memcpy(error, p, error_msg_len);\n  }\n  else\n  {\n    *error_no= CR_UNKNOWN_ERROR;\n    memcpy(sqlstate, SQLSTATE_UNKNOWN, SQLSTATE_LENGTH);\n  }\n}\n\n/*****************************************************************************\n** read a packet from server. Give error message if socket was down\n** or packet is an error message\n*****************************************************************************/\n\nulong\nma_net_safe_read(MYSQL *mysql)\n{\n  NET *net= &mysql->net;\n  ulong len=0;\n\nrestart:\n  if (net->pvio != 0)\n    len=ma_net_read(net);\n\n  if (len == packet_error || len == 0)\n  {\n    end_server(mysql);\n    my_set_error(mysql, net->last_errno == ER_NET_PACKET_TOO_LARGE ?\n\t\t     CR_NET_PACKET_TOO_LARGE:\n\t\t     CR_SERVER_LOST,\n         SQLSTATE_UNKNOWN, 0, errno);\n    return(packet_error);\n  }\n  if (net->read_pos[0] == 255)\n  {\n    if (len > 3)\n    {\n      char *pos=(char*) net->read_pos+1;\n      uint last_errno=uint2korr(pos);\n      pos+=2;\n      len-=2;\n\n      if (last_errno== 65535 &&\n          ((mariadb_connection(mysql) && (mysql->server_capabilities & CLIENT_PROGRESS)) ||\n           (!(mysql->extension->mariadb_server_capabilities & MARIADB_CLIENT_PROGRESS << 32))))\n      {\n        if (cli_report_progress(mysql, (uchar *)pos, (uint) (len-1)))\n        {\n          /* Wrong packet */\n          my_set_error(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n          return (packet_error);\n        }\n        goto restart;\n      }\n      net->last_errno= last_errno;\n      if (pos[0]== '#')\n      {\n        ma_strmake(net->sqlstate, pos+1, SQLSTATE_LENGTH);\n        pos+= SQLSTATE_LENGTH + 1;\n      }\n      else\n      {\n        strncpy(net->sqlstate, SQLSTATE_UNKNOWN, SQLSTATE_LENGTH);\n      }\n      ma_strmake(net->last_error,(char*) pos,\n              min(len,sizeof(net->last_error)-1));\n    }\n    else\n    {\n      my_set_error(mysql, CR_UNKNOWN_ERROR, SQLSTATE_UNKNOWN, 0);\n    }\n\n    mysql->server_status&= ~SERVER_MORE_RESULTS_EXIST;\n\n    return(packet_error);\n  }\n  return len;\n}\n\n/*\n  Report progress to the client\n\n  RETURN VALUES\n    0  ok\n    1  error\n*/\nstatic int cli_report_progress(MYSQL *mysql, uchar *packet, uint length)\n{\n  uint stage, max_stage, proc_length;\n  double progress;\n  uchar *start= packet;\n\n  if (length < 5)\n    return 1;                         /* Wrong packet */\n\n  if (!(mysql->options.extension && mysql->options.extension->report_progress))\n    return 0;                         /* No callback, ignore packet */\n\n  packet++;                           /* Ignore number of strings */\n  stage= (uint) *packet++;\n  max_stage= (uint) *packet++;\n  progress= uint3korr(packet)/1000.0;\n  packet+= 3;\n  proc_length= net_field_length(&packet);\n  if (packet + proc_length > start + length)\n    return 1;                         /* Wrong packet */\n  (*mysql->options.extension->report_progress)(mysql, stage, max_stage,\n                                               progress, (char*) packet,\n                                               proc_length);\n  return 0;\n}\n\n/* Get the length of next field. Change parameter to point at fieldstart */\nulong\nnet_field_length(uchar **packet)\n{\n  reg1 uchar *pos= *packet;\n  if (*pos < 251)\n  {\n    (*packet)++;\n    return (ulong) *pos;\n  }\n  if (*pos == 251)\n  {\n    (*packet)++;\n    return NULL_LENGTH;\n  }\n  if (*pos == 252)\n  {\n    (*packet)+=3;\n    return (ulong) uint2korr(pos+1);\n  }\n  if (*pos == 253)\n  {\n    (*packet)+=4;\n    return (ulong) uint3korr(pos+1);\n  }\n  (*packet)+=9;\t\t\t\t\t/* Must be 254 when here */\n  return (ulong) uint4korr(pos+1);\n}\n\n/* Same as above, but returns ulonglong values */\n\nstatic unsigned long long\nnet_field_length_ll(uchar **packet)\n{\n  reg1 uchar *pos= *packet;\n  if (*pos < 251)\n  {\n    (*packet)++;\n    return (unsigned long long) *pos;\n  }\n  if (*pos == 251)\n  {\n    (*packet)++;\n    return (unsigned long long) NULL_LENGTH;\n  }\n  if (*pos == 252)\n  {\n    (*packet)+=3;\n    return (unsigned long long) uint2korr(pos+1);\n  }\n  if (*pos == 253)\n  {\n    (*packet)+=4;\n    return (unsigned long long) uint3korr(pos+1);\n  }\n  (*packet)+=9;\t\t\t\t\t/* Must be 254 when here */\n#ifdef NO_CLIENT_LONGLONG\n  return (unsigned long long) uint4korr(pos+1);\n#else\n  return (unsigned long long) uint8korr(pos+1);\n#endif\n}\n\n\nvoid free_rows(MYSQL_DATA *cur)\n{\n  if (cur)\n  {\n    ma_free_root(&cur->alloc,MYF(0));\n    free(cur);\n  }\n}\n\nint\nmthd_my_send_cmd(MYSQL *mysql,enum enum_server_command command, const char *arg,\n\t       size_t length, my_bool skipp_check, void *opt_arg)\n{\n  NET *net= &mysql->net;\n  int result= -1;\n  if (mysql->net.pvio == 0)\n  {\n    /* Do reconnect if possible */\n    if (mariadb_reconnect(mysql))\n      return(1);\n  }\n  if (mysql->status != MYSQL_STATUS_READY ||\n      mysql->server_status & SERVER_MORE_RESULTS_EXIST)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    goto end;\n  }\n\n  if (IS_CONNHDLR_ACTIVE(mysql))\n  {\n    result= mysql->extension->conn_hdlr->plugin->set_connection(mysql, command, arg, length, skipp_check, opt_arg);\n    if (result== -1)\n      return(result);\n  }\n\n  CLEAR_CLIENT_ERROR(mysql);\n\n  mysql->info=0;\n  mysql->affected_rows= ~(unsigned long long) 0;\n  ma_net_clear(net);\t\t\t/* Clear receive buffer */\n  if (!arg)\n    arg=\"\";\n\n  if (net->extension->multi_status== COM_MULTI_ENABLED)\n  {\n    return net_add_multi_command(net, command, (const uchar *)arg, length);\n  }\n\n  if (ma_net_write_command(net,(uchar) command,arg,\n\t\t\tlength ? length : (ulong) strlen(arg), 0))\n  {\n    if (net->last_errno == ER_NET_PACKET_TOO_LARGE)\n    {\n      my_set_error(mysql, CR_NET_PACKET_TOO_LARGE, SQLSTATE_UNKNOWN, 0);\n      goto end;\n    }\n    end_server(mysql);\n    if (mariadb_reconnect(mysql))\n      goto end;\n    if (ma_net_write_command(net,(uchar) command,arg,\n\t\t\t  length ? length : (ulong) strlen(arg), 0))\n    {\n      my_set_error(mysql, CR_SERVER_GONE_ERROR, SQLSTATE_UNKNOWN, 0);\n      goto end;\n    }\n  }\n  result=0;\n\n  if (net->extension->multi_status > COM_MULTI_OFF)\n    skipp_check= 1;\n\n  if (!skipp_check)\n  {\n    result= ((mysql->packet_length=ma_net_safe_read(mysql)) == packet_error ?\n\t     1 : 0);\n  }\n end:\n  return(result);\n}\n\nint\nma_simple_command(MYSQL *mysql,enum enum_server_command command, const char *arg,\n\t       size_t length, my_bool skipp_check, void *opt_arg)\n{\n  if ((mysql->options.client_flag & CLIENT_LOCAL_FILES) &&\n       mysql->options.extension && mysql->extension->auto_local_infile == WAIT_FOR_QUERY &&\n       arg && (*arg == 'l' || *arg == 'L') &&\n       command == COM_QUERY)\n  {\n    if (strncasecmp(arg, \"load\", 4) == 0)\n      mysql->extension->auto_local_infile= ACCEPT_FILE_REQUEST;\n  }\n  return mysql->methods->db_command(mysql, command, arg, length, skipp_check, opt_arg);\n}\n\nint ma_multi_command(MYSQL *mysql, enum enum_multi_status status)\n{\n  NET *net= &mysql->net;\n\n  switch (status) {\n  case COM_MULTI_OFF:\n    ma_net_clear(net);\n    net->extension->multi_status= status;\n    return 0;\n  case COM_MULTI_ENABLED:\n    if (net->extension->multi_status > COM_MULTI_DISABLED)\n      return 1;\n    ma_net_clear(net);\n    net->extension->multi_status= status;\n    return 0;\n  case COM_MULTI_DISABLED:\n    /* Opposite to COM_MULTI_OFF we don't clear net buffer,\n       next command or com_nulti_end will flush entire buffer */\n    net->extension->multi_status= status;\n    return 0;\n  case COM_MULTI_END:\n  {\n    size_t len= net->write_pos - net->buff - NET_HEADER_SIZE;\n\n    if (len < NET_HEADER_SIZE) /* don't send empty COM_MULTI */\n    {\n      ma_net_clear(net);\n      return 1;\n    }\n    net->extension->multi_status= COM_MULTI_OFF;\n    return ma_net_flush(net);\n  }\n  case COM_MULTI_CANCEL:\n    ma_net_clear(net);\n    net->extension->multi_status= COM_MULTI_OFF;\n    return 0;\n  default:\n    return 1;\n  }\n}\n\nstatic void free_old_query(MYSQL *mysql)\n{\n  if (mysql->fields)\n    ma_free_root(&mysql->field_alloc,MYF(0));\n  ma_init_alloc_root(&mysql->field_alloc,8192,0);\t/* Assume rowlength < 8192 */\n  mysql->fields=0;\n  mysql->field_count=0;\t\t\t\t/* For API */\n  mysql->info= 0;\n  return;\n}\n\n#if defined(HAVE_GETPWUID) && defined(NO_GETPWUID_DECL)\nstruct passwd *getpwuid(uid_t);\nchar* getlogin(void);\n#endif\n\n#if !defined(_WIN32)\nvoid read_user_name(char *name)\n{\n  if (geteuid() == 0)\n    strcpy(name,\"root\");\t\t/* allow use of surun */\n  else\n  {\n#ifdef HAVE_GETPWUID\n    struct passwd *skr;\n    const char *str;\n    if ((skr=getpwuid(geteuid())) != NULL)\n    {\n      str=skr->pw_name;\n    } else if ((str=getlogin()) == NULL)\n    {\n      if (!(str=getenv(\"USER\")) && !(str=getenv(\"LOGNAME\")) &&\n               !(str=getenv(\"LOGIN\")))\n        str=\"UNKNOWN_USER\";\n    }\n    ma_strmake(name,str,USERNAME_LENGTH);\n#elif defined(HAVE_CUSERID)\n    (void) cuserid(name);\n#else\n    ma_strmake(name,\"UNKNOWN_USER\", USERNAME_LENGTH);\n#endif\n  }\n  return;\n}\n\n#else /* If MSDOS || VMS */\n\nvoid read_user_name(char *name)\n{\n  char *str=getenv(\"USERNAME\");\t\t/* ODBC will send user variable */\n  ma_strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}\n\n#endif\n\n\n/**************************************************************************\n** Shut down connection\n**************************************************************************/\n\nstatic void\nend_server(MYSQL *mysql)\n{\n  /* if net->error 2 and reconnect is activated, we need to inforn\n     connection handler */\n  if (mysql->net.pvio != 0)\n  {\n    ma_pvio_close(mysql->net.pvio);\n    mysql->net.pvio= 0;    /* Marker */\n  }\n  ma_net_end(&mysql->net);\n  free_old_query(mysql);\n  return;\n}\n\nvoid mthd_my_skip_result(MYSQL *mysql)\n{\n  ulong pkt_len;\n\n  do {\n    pkt_len= ma_net_safe_read(mysql);\n    if (pkt_len == packet_error)\n      break;\n  } while (pkt_len > 8 || mysql->net.read_pos[0] != 254);\n  return;\n}\n\nvoid STDCALL\nmysql_free_result(MYSQL_RES *result)\n{\n  if (result)\n  {\n    if (result->handle && result->handle->status == MYSQL_STATUS_USE_RESULT)\n    {\n      result->handle->methods->db_skip_result(result->handle);\n      result->handle->status=MYSQL_STATUS_READY;\n    }\n    free_rows(result->data);\n    if (result->fields)\n      ma_free_root(&result->field_alloc,MYF(0));\n    if (result->row)\n      free(result->row);\n    free(result);\n  }\n  return;\n}\n\n\n/****************************************************************************\n** Get options from my.cnf\n****************************************************************************/\nenum enum_option_type {\n  MARIADB_OPTION_NONE,\n  MARIADB_OPTION_BOOL,\n  MARIADB_OPTION_INT,\n  MARIADB_OPTION_SIZET,\n  MARIADB_OPTION_STR,\n};\n\nstruct st_default_options {\n  enum mysql_option option;\n  enum enum_option_type type;\n  const char *conf_key;\n};\n\nstruct st_default_options mariadb_defaults[] =\n{\n  {MARIADB_OPT_PORT, MARIADB_OPTION_INT,\"port\"},\n  {MARIADB_OPT_UNIXSOCKET, MARIADB_OPTION_STR, \"socket\"},\n  {MYSQL_OPT_COMPRESS, MARIADB_OPTION_BOOL, \"compress\"},\n  {MARIADB_OPT_PASSWORD, MARIADB_OPTION_STR, \"password\"},\n  {MYSQL_OPT_NAMED_PIPE, MARIADB_OPTION_BOOL, \"pipe\"},\n  {MYSQL_OPT_CONNECT_TIMEOUT, MARIADB_OPTION_INT, \"timeout\"},\n  {MARIADB_OPT_USER, MARIADB_OPTION_STR, \"user\"},\n  {MYSQL_INIT_COMMAND, MARIADB_OPTION_STR, \"init-command\"},\n  {MARIADB_OPT_HOST, MARIADB_OPTION_STR, \"host\"},\n  {MARIADB_OPT_SCHEMA, MARIADB_OPTION_STR, \"database\"},\n  {MARIADB_OPT_DEBUG, MARIADB_OPTION_STR, \"debug\"},\n  {MARIADB_OPT_FOUND_ROWS, MARIADB_OPTION_NONE, \"return-found-rows\"},\n  {MYSQL_OPT_SSL_KEY, MARIADB_OPTION_STR, \"ssl-key\"},\n  {MYSQL_OPT_SSL_CERT, MARIADB_OPTION_STR,\"ssl-cert\"},\n  {MYSQL_OPT_SSL_CA, MARIADB_OPTION_STR,\"ssl-ca\"},\n  {MYSQL_OPT_SSL_CAPATH, MARIADB_OPTION_STR,\"ssl-capath\"},\n  {MYSQL_OPT_SSL_CRL, MARIADB_OPTION_STR,\"ssl-crl\"},\n  {MYSQL_OPT_SSL_CRLPATH, MARIADB_OPTION_STR,\"ssl-crlpath\"},\n  {MYSQL_OPT_SSL_VERIFY_SERVER_CERT, MARIADB_OPTION_BOOL,\"ssl-verify-server-cert\"},\n  {MYSQL_SET_CHARSET_DIR, MARIADB_OPTION_STR, \"character-sets-dir\"},\n  {MYSQL_SET_CHARSET_NAME, MARIADB_OPTION_STR, \"default-character-set\"},\n  {MARIADB_OPT_INTERACTIVE, MARIADB_OPTION_NONE, \"interactive-timeout\"},\n  {MYSQL_OPT_CONNECT_TIMEOUT, MARIADB_OPTION_INT, \"connect-timeout\"},\n  {MYSQL_OPT_LOCAL_INFILE, MARIADB_OPTION_BOOL, \"local-infile\"},\n  {0, 0 ,\"disable-local-infile\",},\n  {MYSQL_OPT_SSL_CIPHER, MARIADB_OPTION_STR, \"ssl-cipher\"},\n  {MYSQL_OPT_MAX_ALLOWED_PACKET, MARIADB_OPTION_SIZET, \"max-allowed-packet\"},\n  {MYSQL_OPT_NET_BUFFER_LENGTH, MARIADB_OPTION_SIZET, \"net-buffer-length\"},\n  {MYSQL_OPT_PROTOCOL, MARIADB_OPTION_INT, \"protocol\"},\n  {MYSQL_SHARED_MEMORY_BASE_NAME, MARIADB_OPTION_STR,\"shared-memory-base-name\"},\n  {MARIADB_OPT_MULTI_RESULTS, MARIADB_OPTION_NONE, \"multi-results\"},\n  {MARIADB_OPT_MULTI_STATEMENTS, MARIADB_OPTION_STR, \"multi-statements\"},\n  {MARIADB_OPT_MULTI_STATEMENTS, MARIADB_OPTION_STR, \"multi-queries\"},\n  {MYSQL_SECURE_AUTH, MARIADB_OPTION_BOOL, \"secure-auth\"},\n  {MYSQL_REPORT_DATA_TRUNCATION, MARIADB_OPTION_BOOL, \"report-data-truncation\"},\n  {MYSQL_OPT_RECONNECT, MARIADB_OPTION_BOOL, \"reconnect\"},\n  {MYSQL_PLUGIN_DIR, MARIADB_OPTION_STR, \"plugin-dir\"},\n  {MYSQL_DEFAULT_AUTH, MARIADB_OPTION_STR, \"default-auth\"},\n  {MARIADB_OPT_SSL_FP, MARIADB_OPTION_STR, \"ssl-fp\"},\n  {MARIADB_OPT_SSL_FP_LIST, MARIADB_OPTION_STR, \"ssl-fp-list\"},\n  {MARIADB_OPT_SSL_FP_LIST, MARIADB_OPTION_STR, \"ssl-fplist\"},\n  {MARIADB_OPT_TLS_PASSPHRASE, MARIADB_OPTION_STR, \"ssl-passphrase\"},\n  {MARIADB_OPT_TLS_VERSION, MARIADB_OPTION_STR, \"tls-version\"},\n  {MYSQL_SERVER_PUBLIC_KEY, MARIADB_OPTION_STR, \"server-public-key\"},\n  {MYSQL_OPT_BIND, MARIADB_OPTION_STR, \"bind-address\"},\n  {MYSQL_OPT_SSL_ENFORCE, MARIADB_OPTION_BOOL, \"ssl-enforce\"},\n  {0, 0, NULL}\n};\n\n#define CHECK_OPT_EXTENSION_SET(OPTS)\\\n    if (!(OPTS)->extension)                                     \\\n      (OPTS)->extension= (struct st_mysql_options_extension *)  \\\n        calloc(1, sizeof(struct st_mysql_options_extension));\n\n#define OPT_SET_EXTENDED_VALUE_STR(OPTS, KEY, VAL)               \\\n    CHECK_OPT_EXTENSION_SET(OPTS)                                \\\n    free((gptr)(OPTS)->extension->KEY);                          \\\n    if((VAL))                                                   \\\n      (OPTS)->extension->KEY= strdup((char *)(VAL));             \\\n    else                                                         \\\n      (OPTS)->extension->KEY= NULL\n\n#define OPT_SET_EXTENDED_VALUE(OPTS, KEY, VAL)                \\\n    CHECK_OPT_EXTENSION_SET(OPTS)                                 \\\n    (OPTS)->extension->KEY= (VAL)\n\n#define OPT_SET_EXTENDED_VALUE_INT(A,B,C) OPT_SET_EXTENDED_VALUE(A,B,C)\n\n#define OPT_SET_VALUE_STR(OPTS, KEY, VAL)                        \\\n    free((OPTS)->KEY);                                           \\\n    if((VAL))                                                   \\\n      (OPTS)->KEY= strdup((char *)(VAL));                        \\\n    else                                                         \\\n      (OPTS)->KEY= NULL\n\n#define OPT_SET_VALUE_INT(OPTS, KEY, VAL)                         \\\n    (OPTS)->KEY= (VAL)\n\nstatic void options_add_initcommand(struct st_mysql_options *options,\n                                     const char *init_cmd)\n{\n  char *insert= strdup(init_cmd);\n  if (!options->init_command)\n  {\n    options->init_command= (DYNAMIC_ARRAY*)malloc(sizeof(DYNAMIC_ARRAY));\n    ma_init_dynamic_array(options->init_command, sizeof(char*), 5, 5);\n  }\n\n  if (ma_insert_dynamic(options->init_command, (gptr)&insert))\n    free(insert);\n}\nmy_bool _mariadb_set_conf_option(MYSQL *mysql, const char *config_option, const char *config_value)\n{\n  if (config_option)\n  {\n    int i;\n    char *c;\n    \n    /* CONC-395: replace underscore \"_\" by dash \"-\" */\n    while ((c= strchr(config_option, '_')))\n      *c= '-';\n\n    for (i=0; mariadb_defaults[i].conf_key; i++)\n    {\n      if (!strcmp(mariadb_defaults[i].conf_key, config_option))\n      {\n        my_bool val_bool;\n        int     val_int;\n        size_t  val_sizet;\n        int rc;\n        void *option_val= NULL;\n        switch (mariadb_defaults[i].type) {\n        case MARIADB_OPTION_BOOL:\n          val_bool= 0;\n          if (config_value)\n            val_bool= atoi(config_value);\n          option_val= &val_bool;\n          break;\n        case MARIADB_OPTION_INT:\n          val_int= 0;\n          if (config_value)\n            val_int= atoi(config_value);\n          option_val= &val_int;\n          break;\n        case MARIADB_OPTION_SIZET:\n          val_sizet= 0;\n          if (config_value)\n            val_sizet= strtol(config_value, NULL, 10);\n          option_val= &val_sizet;\n          break;\n        case MARIADB_OPTION_STR:\n          option_val= (void*)config_value;\n          break;\n        case MARIADB_OPTION_NONE:\n          break;\n        }\n        rc= mysql_optionsv(mysql, mariadb_defaults[i].option, option_val);\n        return(test(rc));\n      }\n    }\n  }\n  /* unknown key */\n  return 1;\n}\n\n\nstatic MARIADB_CONST_STRING null_const_string= {0,0};\n\n/***************************************************************************\n** Allocate a string copy on memroot\n***************************************************************************/\nstatic MARIADB_CONST_STRING ma_const_string_copy_root(MA_MEM_ROOT *memroot,\n                                                      const char *str,\n                                                      size_t length)\n{\n  MARIADB_CONST_STRING res;\n  if (!str || !(res.str= ma_memdup_root(memroot, str, length)))\n    return null_const_string;\n  res.length= length;\n  return res;\n}\n\n\n/***************************************************************************\n** Allocate and initialize MA_FIELD_EXTENSION\n***************************************************************************/\nMA_FIELD_EXTENSION *new_ma_field_extension(MA_MEM_ROOT *memroot)\n{\n  MA_FIELD_EXTENSION *ext= ma_alloc_root(memroot, sizeof(MA_FIELD_EXTENSION));\n  if (ext)\n    memset((void *) ext, 0, sizeof(*ext));\n  return ext;\n}\n\n\n/***************************************************************************\n** Populate field extension from a type info packet\n***************************************************************************/\n\nstatic void ma_field_extension_init_type_info(MA_MEM_ROOT *memroot,\n                                              MA_FIELD_EXTENSION *ext,\n                                              const char *ptr, size_t length)\n{\n  const char *end= ptr + length;\n  for ( ;  ptr < end; )\n  {\n    uint itype= (uchar) *ptr++;\n    uint len= (uchar) *ptr++;\n    if (ptr + len > end  || len > 127)\n      break; /*Badly encoded data*/\n    if (itype <= 127 && itype <= MARIADB_FIELD_ATTR_LAST)\n      ext->metadata[itype]= ma_const_string_copy_root(memroot, ptr, len);\n    ptr+= len;\n  }\n}\n\n\n/***************************************************************************\n** Allocate a field extension deep copy\n***************************************************************************/\n\nMA_FIELD_EXTENSION *ma_field_extension_deep_dup(MA_MEM_ROOT *memroot,\n                                                const MA_FIELD_EXTENSION *from)\n{\n  MA_FIELD_EXTENSION *ext= new_ma_field_extension(memroot);\n  uint i;\n  if (!ext)\n    return NULL;\n  for (i= 0; i < MARIADB_FIELD_ATTR_LAST; i++)\n  {\n    if (from->metadata[i].str)\n      ext->metadata[i]= ma_const_string_copy_root(memroot,\n                                                  from->metadata[i].str,\n                                                  from->metadata[i].length);\n  }\n  return ext;\n}\n\n/***************************************************************************\n** Change field rows to field structs\n***************************************************************************/\n\nstatic size_t rset_field_offsets[]= {\n  OFFSET(MYSQL_FIELD, catalog),\n  OFFSET(MYSQL_FIELD, catalog_length),\n  OFFSET(MYSQL_FIELD, db),\n  OFFSET(MYSQL_FIELD, db_length),\n  OFFSET(MYSQL_FIELD, table),\n  OFFSET(MYSQL_FIELD, table_length),\n  OFFSET(MYSQL_FIELD, org_table),\n  OFFSET(MYSQL_FIELD, org_table_length),\n  OFFSET(MYSQL_FIELD, name),\n  OFFSET(MYSQL_FIELD, name_length),\n  OFFSET(MYSQL_FIELD, org_name),\n  OFFSET(MYSQL_FIELD, org_name_length)\n};\n\nMYSQL_FIELD *\nunpack_fields(const MYSQL *mysql,\n              MYSQL_DATA *data, MA_MEM_ROOT *alloc, uint fields,\n\t      my_bool default_value)\n{\n  MYSQL_ROWS\t*row;\n  MYSQL_FIELD\t*field,*result;\n  char    *p;\n  unsigned int i, field_count= sizeof(rset_field_offsets)/sizeof(size_t)/2;\n\n  field=result=(MYSQL_FIELD*) ma_alloc_root(alloc,sizeof(MYSQL_FIELD)*fields);\n  if (!result)\n    return(0);\n\n  for (row=data->data; row ; row = row->next,field++)\n  {\n    if (field >= result + fields)\n      goto error;\n\n    for (i=0; i < field_count; i++)\n    {\n      uint length= (uint)(row->data[i+1] - row->data[i] - 1);\n      if (!row->data[i] && row->data[i][length])\n        goto error;\n\n      *(char **)(((char *)field) + rset_field_offsets[i*2])=\n        ma_strdup_root(alloc, (char *)row->data[i]);\n      *(unsigned int *)(((char *)field) + rset_field_offsets[i*2+1])= length;\n    }\n\n    field->extension= NULL;\n    if (ma_has_extended_type_info(mysql))\n    {\n      if (row->data[i+1] - row->data[i] > 1)\n      {\n        size_t len= row->data[i+1] - row->data[i] - 1;\n        MA_FIELD_EXTENSION *ext= new_ma_field_extension(alloc);\n        if ((field->extension= ext))\n          ma_field_extension_init_type_info(alloc, ext, row->data[i], len);\n      }\n      i++;\n    }\n\n    p= (char *)row->data[i];\n    /* filler */\n    field->charsetnr= uint2korr(p);\n    p+= 2;\n    field->length= (uint) uint4korr(p);\n    p+= 4;\n    field->type=   (enum enum_field_types)uint1korr(p);\n    p++;\n    field->flags= uint2korr(p);\n    p+= 2;\n    field->decimals= (uint) p[0];\n    p++;\n\n    /* filler */\n    p+= 2;\n\n    if (INTERNAL_NUM_FIELD(field))\n      field->flags|= NUM_FLAG;\n\n    i++;\n    /* This is used by deprecated function mysql_list_fields only,\n       however the reported length is not correct, so we always zero it */\n    if (default_value && row->data[i])\n      field->def=ma_strdup_root(alloc,(char*) row->data[i]);\n    else\n      field->def=0;\n    field->def_length= 0;\n\n    field->max_length= 0;\n  }\n  if (field < result + fields)\n    goto error;\n  free_rows(data);\t\t\t\t/* Free old data */\n  return(result);\nerror:\n  free_rows(data);\n  ma_free_root(alloc, MYF(0));\n  return(0);\n}\n\n\n/* Read all rows (fields or data) from server */\n\nMYSQL_DATA *mthd_my_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,\n\t\t\t     uint fields)\n{\n  uint\tfield;\n  ulong pkt_len;\n  ulong len;\n  uchar *cp;\n  char\t*to, *end_to;\n  MYSQL_DATA *result;\n  MYSQL_ROWS **prev_ptr,*cur;\n  NET *net = &mysql->net;\n\n  if ((pkt_len= ma_net_safe_read(mysql)) == packet_error)\n    return(0);\n  if (!(result=(MYSQL_DATA*) calloc(1, sizeof(MYSQL_DATA))))\n  {\n    SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  ma_init_alloc_root(&result->alloc,8192,0);\t/* Assume rowlength < 8192 */\n  result->alloc.min_malloc=sizeof(MYSQL_ROWS);\n  prev_ptr= &result->data;\n  result->rows=0;\n  result->fields=fields;\n\n  while (*(cp=net->read_pos) != 254 || pkt_len >= 8)\n  {\n    result->rows++;\n    if (!(cur= (MYSQL_ROWS*) ma_alloc_root(&result->alloc,\n\t\t\t\t\t    sizeof(MYSQL_ROWS))) ||\n\t      !(cur->data= ((MYSQL_ROW)\n\t\t      ma_alloc_root(&result->alloc,\n\t\t\t\t     (fields+1)*sizeof(char *)+fields+pkt_len))))\n    {\n      free_rows(result);\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      return(0);\n    }\n    *prev_ptr=cur;\n    prev_ptr= &cur->next;\n    to= (char*) (cur->data+fields+1);\n    end_to=to+fields+pkt_len-1;\n    for (field=0 ; field < fields ; field++)\n    {\n      if ((len=(ulong) net_field_length(&cp)) == NULL_LENGTH)\n      {\t\t\t\t\t\t/* null field */\n        cur->data[field] = 0;\n      }\n      else\n      {\n        cur->data[field] = to;\n        if (len > (ulong)(end_to - to) || to > end_to)\n        {\n          free_rows(result);\n          SET_CLIENT_ERROR(mysql, CR_UNKNOWN_ERROR, SQLSTATE_UNKNOWN, 0);\n          return(0);\n        }\n        memcpy(to,(char*) cp,len); to[len]=0;\n        to+=len+1;\n        cp+=len;\n        if (mysql_fields)\n        {\n          if (mysql_fields[field].max_length < len)\n            mysql_fields[field].max_length=len;\n         }\n      }\n    }\n    cur->data[field]=to;\t\t\t/* End of last field */\n    if ((pkt_len=ma_net_safe_read(mysql)) == packet_error)\n    {\n      free_rows(result);\n      return(0);\n    }\n  }\n  *prev_ptr=0;\t\t\t\t\t/* last pointer is null */\n  /* save status */\n  if (pkt_len > 1)\n  {\n    cp++;\n    mysql->warning_count= uint2korr(cp);\n    cp+= 2;\n    mysql->server_status= uint2korr(cp);\n  }\n  return(result);\n}\n\n\n/*\n** Read one row. Uses packet buffer as storage for fields.\n** When next packet is read, the previous field values are destroyed\n*/\n\n\nint mthd_my_read_one_row(MYSQL *mysql,uint fields,MYSQL_ROW row, ulong *lengths)\n{\n  uint field;\n  ulong pkt_len,len;\n  uchar *pos,*prev_pos, *end_pos;\n\n  if ((pkt_len=(uint) ma_net_safe_read(mysql)) == packet_error)\n    return -1;\n\n  if (pkt_len <= 8 && mysql->net.read_pos[0] == 254)\n  {\n    mysql->warning_count= uint2korr(mysql->net.read_pos + 1);\n    mysql->server_status= uint2korr(mysql->net.read_pos + 3);\n    return 1;\t\t\t\t/* End of data */\n  }\n  prev_pos= 0;\t\t\t\t/* allowed to write at packet[-1] */\n  pos=mysql->net.read_pos;\n  end_pos=pos+pkt_len;\n  for (field=0 ; field < fields ; field++)\n  {\n    if ((len=(ulong) net_field_length(&pos)) == NULL_LENGTH)\n    {\t\t\t\t\t\t/* null field */\n      row[field] = 0;\n      *lengths++=0;\n    }\n    else\n    {\n      if (len > (ulong) (end_pos - pos) || pos > end_pos)\n      {\n        mysql->net.last_errno=CR_UNKNOWN_ERROR;\n        strncpy(mysql->net.last_error,ER(mysql->net.last_errno),\n                MYSQL_ERRMSG_SIZE - 1);\n        return -1;\n      }\n      row[field] = (char*) pos;\n      pos+=len;\n      *lengths++=len;\n    }\n    if (prev_pos)\n      *prev_pos=0;\t\t\t\t/* Terminate prev field */\n    prev_pos=pos;\n  }\n  row[field]=(char*) prev_pos+1;\t\t/* End of last field */\n  *prev_pos=0;\t\t\t\t\t/* Terminate last field */\n  return 0;\n}\n\n/****************************************************************************\n** Init MySQL structure or allocate one\n****************************************************************************/\n\nMYSQL * STDCALL\nmysql_init(MYSQL *mysql)\n{\n  if (mysql_server_init(0, NULL, NULL))\n    return NULL;\n  if (!mysql)\n  {\n    if (!(mysql=(MYSQL*) calloc(1, sizeof(MYSQL))))\n      return 0;\n    mysql->free_me=1;\n    mysql->net.pvio= 0;\n    mysql->net.extension= 0;\n  }\n  else\n  {\n    memset((char*) (mysql), 0, sizeof(*(mysql)));\n    mysql->net.pvio= 0;\n    mysql->free_me= 0;\n    mysql->net.extension= 0;\n  }\n\n  if (!(mysql->net.extension= (struct st_mariadb_net_extension *)\n                               calloc(1, sizeof(struct st_mariadb_net_extension))) ||\n      !(mysql->extension= (struct st_mariadb_extension *)\n                          calloc(1, sizeof(struct st_mariadb_extension))))\n    goto error;\n  mysql->options.report_data_truncation= 1;\n  mysql->options.connect_timeout=CONNECT_TIMEOUT;\n  mysql->charset= mysql_find_charset_name(MARIADB_DEFAULT_CHARSET);\n  mysql->methods= &MARIADB_DEFAULT_METHODS;\n  strcpy(mysql->net.sqlstate, \"00000\");\n  mysql->net.last_error[0]= mysql->net.last_errno= mysql->net.extension->extended_errno= 0;\n\n  if (ENABLED_LOCAL_INFILE != LOCAL_INFILE_MODE_OFF)\n    mysql->options.client_flag|= CLIENT_LOCAL_FILES;\n  mysql->extension->auto_local_infile= ENABLED_LOCAL_INFILE == LOCAL_INFILE_MODE_AUTO\n                                       ? WAIT_FOR_QUERY : ALWAYS_ACCEPT;\n  mysql->options.reconnect= 0;\n  return mysql;\nerror:\n  if (mysql->free_me)\n    free(mysql);\n  return 0;\n}\n\nint STDCALL\nmysql_ssl_set(MYSQL *mysql __attribute__((unused)),\n              const char *key __attribute__((unused)),\n              const char *cert __attribute__((unused)),\n              const char *ca __attribute__((unused)),\n              const char *capath __attribute__((unused)),\n              const char *cipher __attribute__((unused)))\n{\n#ifdef HAVE_TLS\n  char enable= 1;\n  return (mysql_optionsv(mysql, MYSQL_OPT_SSL_ENFORCE, &enable) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_KEY, key) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CERT, cert) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CA, ca) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CAPATH, capath) |\n          mysql_optionsv(mysql, MYSQL_OPT_SSL_CIPHER, cipher)) ? 1 : 0;\n#else\n  return 0;\n#endif\n}\n\n/**************************************************************************\n**************************************************************************/\n\nconst char * STDCALL\nmysql_get_ssl_cipher(MYSQL *mysql __attribute__((unused)))\n{\n#ifdef HAVE_TLS\n  if (mysql->net.pvio && mysql->net.pvio->ctls)\n  {\n    return ma_pvio_tls_cipher(mysql->net.pvio->ctls);\n  }\n#endif\n  return(NULL);\n}\n\n/**************************************************************************\n** Free strings in the SSL structure and clear 'use_ssl' flag.\n** NB! Errors are not reported until you do mysql_real_connect.\n**************************************************************************/\n\nchar *ma_send_connect_attr(MYSQL *mysql, unsigned char *buffer)\n{\n  if (mysql->server_capabilities & CLIENT_CONNECT_ATTRS)\n  {\n    buffer= (unsigned char *)mysql_net_store_length((unsigned char *)buffer, (mysql->options.extension) ?\n                             mysql->options.extension->connect_attrs_len : 0);\n    if (mysql->options.extension &&\n        hash_inited(&mysql->options.extension->connect_attrs))\n    {\n      uint i;\n      for (i=0; i < mysql->options.extension->connect_attrs.records; i++)\n      {\n        size_t len;\n        uchar *p= hash_element(&mysql->options.extension->connect_attrs, i);\n\n        len= strlen((char *)p);\n        buffer= mysql_net_store_length(buffer, len);\n        memcpy(buffer, p, len);\n        buffer+= (len);\n        p+= (len + 1);\n        len= strlen((char *)p);\n        buffer= mysql_net_store_length(buffer, len);\n        memcpy(buffer, p, len);\n        buffer+= len;\n      }\n    }\n  }\n  return (char *)buffer;\n}\n\n/** set some default attributes */\nstatic my_bool\nma_set_connect_attrs(MYSQL *mysql, const char *host)\n{\n  char buffer[255];\n  int rc= 0;\n\n  rc= mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_client_name\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_client_version\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_os\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_server_host\") +\n#ifdef _WIN32\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_thread\") +\n#endif\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_pid\") +\n      mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_DELETE, \"_platform\");\n\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_client_name\", \"libmariadb\")\n       + mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_client_version\", MARIADB_PACKAGE_VERSION)\n       + mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_os\", MARIADB_SYSTEM_TYPE);\n\n  if (host && *host)\n    rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_server_host\", host);\n\n#ifdef _WIN32\n  snprintf(buffer, 255, \"%lu\", (ulong) GetCurrentThreadId());\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_thread\", buffer);\n  snprintf(buffer, 255, \"%lu\", (ulong) GetCurrentProcessId());\n#else\n  snprintf(buffer, 255, \"%lu\", (ulong) getpid());\n#endif\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_pid\", buffer);\n\n  rc+= mysql_optionsv(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"_platform\", MARIADB_MACHINE_TYPE);\n  return(test(rc>0));\n}\n\n/*\n** Note that the mysql argument must be initialized with mysql_init()\n** before calling mysql_real_connect !\n*/\n\nMYSQL * STDCALL\nmysql_real_connect(MYSQL *mysql, const char *host, const char *user,\n\t\t   const char *passwd, const char *db,\n\t\t   uint port, const char *unix_socket,unsigned long client_flag)\n{\n  char *end= NULL;\n  char *connection_handler= (mysql->options.extension) ?\n                            mysql->options.extension->connection_handler : 0;\n\n  if (!mysql->methods)\n    mysql->methods= &MARIADB_DEFAULT_METHODS;\n\n  if (connection_handler ||\n      (host && (end= strstr(host, \"://\"))))\n  {\n    MARIADB_CONNECTION_PLUGIN *plugin;\n    char plugin_name[64];\n\n    if (!connection_handler || !connection_handler[0])\n    {\n      memset(plugin_name, 0, 64);\n      ma_strmake(plugin_name, host, MIN(end - host, 63));\n      end+= 3;\n    }\n    else\n      ma_strmake(plugin_name, connection_handler, MIN(63, strlen(connection_handler)));\n\n    if (!(plugin= (MARIADB_CONNECTION_PLUGIN *)mysql_client_find_plugin(mysql, plugin_name, MARIADB_CLIENT_CONNECTION_PLUGIN)))\n      return NULL;\n\n    if (!(mysql->extension->conn_hdlr= (MA_CONNECTION_HANDLER *)calloc(1, sizeof(MA_CONNECTION_HANDLER))))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      return NULL;\n    }\n\n    /* save URL for reconnect */\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, url, host);\n\n    mysql->extension->conn_hdlr->plugin= plugin;\n\n    if (plugin && plugin->connect)\n    {\n      MYSQL *my= plugin->connect(mysql, end, user, passwd, db, port, unix_socket, client_flag);\n      if (!my)\n      {\n        free(mysql->extension->conn_hdlr);\n        mysql->extension->conn_hdlr= NULL;\n      }\n      return my;\n    }\n  }\n#ifndef HAVE_SCHANNEL\n  return mysql->methods->db_connect(mysql, host, user, passwd,\n                                    db, port, unix_socket, client_flag);\n#else\n/* \n   With older windows versions (prior Win 10) TLS connections periodically\n   fail with SEC_E_INVALID_TOKEN, SEC_E_BUFFER_TOO_SMALL or SEC_E_MESSAGE_ALTERED\n   error (see MDEV-13492). If the connect attempt returns on of these error codes\n   in mysql->net.extended_errno we will try to connect again (max. 3 times)\n*/\n#define MAX_SCHANNEL_CONNECT_ATTEMPTS 3\n  {\n    int ssl_retry= (mysql->options.use_ssl) ? MAX_SCHANNEL_CONNECT_ATTEMPTS : 1;\n\tMYSQL *my= NULL;\n    while (ssl_retry)\n    {\n      if ((my= mysql->methods->db_connect(mysql, host, user, passwd,\n                                    db, port, unix_socket, client_flag | CLIENT_REMEMBER_OPTIONS)))\n        return my;\n\n      switch (mysql->net.extension->extended_errno) {\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_BUFFER_TOO_SMALL:\n        case SEC_E_MESSAGE_ALTERED:\n          ssl_retry--;\n          break;\n        default:\n          ssl_retry= 0;\n          break;\n      }\n    }\n    if (!my && !(client_flag & CLIENT_REMEMBER_OPTIONS))\n      mysql_close_options(mysql);\n    return my;\n  }\n#endif\n}\n\nMYSQL *mthd_my_real_connect(MYSQL *mysql, const char *host, const char *user,\n\t\t   const char *passwd, const char *db,\n\t\t   uint port, const char *unix_socket, unsigned long client_flag)\n{\n  char\t\tbuff[NAME_LEN+USERNAME_LENGTH+100];\n  char\t\t*end, *end_pkt, *host_info;\n  MA_PVIO_CINFO  cinfo= {NULL, NULL, 0, -1, NULL};\n  MARIADB_PVIO   *pvio= NULL;\n  char    *scramble_data;\n  my_bool is_maria= 0;\n  const char *scramble_plugin;\n  uint pkt_length, scramble_len, pkt_scramble_len= 0;\n  NET\t*net= &mysql->net;\n\n  if (!mysql->methods)\n    mysql->methods= &MARIADB_DEFAULT_METHODS;\n\n  if (net->pvio)  /* check if we are already connected */\n  {\n    SET_CLIENT_ERROR(mysql, CR_ALREADY_CONNECTED, SQLSTATE_UNKNOWN, 0);\n    return(NULL);\n  }\n\n  /* use default options */\n  if (mysql->options.my_cnf_file || mysql->options.my_cnf_group)\n  {\n    _mariadb_read_options(mysql, NULL,\n\t\t\t  (mysql->options.my_cnf_file ?\n\t\t\t   mysql->options.my_cnf_file : NULL),\n\t\t\t   mysql->options.my_cnf_group, 0);\n    free(mysql->options.my_cnf_file);\n    free(mysql->options.my_cnf_group);\n    mysql->options.my_cnf_file=mysql->options.my_cnf_group=0;\n  }\n\n  if (!host || !host[0])\n    host = mysql->options.host;\n\n  ma_set_connect_attrs(mysql, host);\n\n#ifndef WIN32\n  if (mysql->options.protocol > MYSQL_PROTOCOL_SOCKET)\n  {\n    SET_CLIENT_ERROR(mysql, CR_CONN_UNKNOWN_PROTOCOL, SQLSTATE_UNKNOWN, 0);\n    return(NULL);\n  }\n#endif\n\n  /* Some empty-string-tests are done because of ODBC */\n  if (!user || !user[0])\n    user=mysql->options.user;\n  if (!passwd)\n  {\n    passwd=mysql->options.password;\n#ifndef DONT_USE_MYSQL_PWD\n    if (!passwd)\n      passwd=getenv(\"MYSQL_PWD\");  /* get it from environment (haneke) */\n    if (!passwd)\n      passwd= \"\";\n#endif\n  }\n  if (!db || !db[0])\n    db=mysql->options.db;\n  if (!port)\n    port=mysql->options.port;\n  if (!unix_socket)\n    unix_socket=mysql->options.unix_socket;\n\n  mysql->server_status=SERVER_STATUS_AUTOCOMMIT;\n\n  /* try to connect via pvio_init */\n  cinfo.host= host;\n  cinfo.unix_socket= unix_socket;\n  cinfo.port= port;\n  cinfo.mysql= mysql;\n\n  /*\n  ** Grab a socket and connect it to the server\n  */\n#ifndef _WIN32\n#if defined(HAVE_SYS_UN_H)\n  if ((!host ||  strcmp(host,LOCAL_HOST) == 0) &&\n      mysql->options.protocol != MYSQL_PROTOCOL_TCP &&\n      (unix_socket || mysql_unix_port))\n  {\n    cinfo.host= LOCAL_HOST;\n    cinfo.unix_socket= (unix_socket) ? unix_socket : mysql_unix_port;\n    cinfo.type= PVIO_TYPE_UNIXSOCKET;\n    sprintf(host_info=buff,ER(CR_LOCALHOST_CONNECTION),cinfo.host);\n  }\n  else\n#endif\n#else\n  if (mysql->options.protocol == MYSQL_PROTOCOL_MEMORY)\n  {\n    cinfo.host= mysql->options.shared_memory_base_name;\n    cinfo.type= PVIO_TYPE_SHAREDMEM;\n    sprintf(host_info=buff,ER(CR_SHARED_MEMORY_CONNECTION), cinfo.host ? cinfo.host : SHM_DEFAULT_NAME);\n  }\n   /* named pipe */\n  else if (mysql->options.protocol == MYSQL_PROTOCOL_PIPE ||\n\t  (host && strcmp(host,LOCAL_HOST_NAMEDPIPE) == 0))\n  {\n    cinfo.type= PVIO_TYPE_NAMEDPIPE;\n    sprintf(host_info=buff,ER(CR_NAMEDPIPE_CONNECTION),cinfo.host);\n  }\n  else\n#endif\n  {\n    cinfo.unix_socket=0;\t\t\t\t/* This is not used */\n    if (!port)\n      port=mysql_port;\n    if (!host)\n      host=LOCAL_HOST;\n    cinfo.host= host;\n    cinfo.port= port;\n    cinfo.type= PVIO_TYPE_SOCKET;\n    sprintf(host_info=buff,ER(CR_TCP_CONNECTION), cinfo.host);\n  }\n  /* Initialize and load pvio plugin */\n  if (!(pvio= ma_pvio_init(&cinfo)))\n    goto error;\n\n  /* try to connect */\n  if (ma_pvio_connect(pvio, &cinfo) != 0)\n  {\n    ma_pvio_close(pvio);\n    goto error;\n  }\n\n  if (mysql->options.extension && mysql->options.extension->proxy_header)\n  {\n    char *hdr = mysql->options.extension->proxy_header;\n    size_t len = mysql->options.extension->proxy_header_len;\n    if (ma_pvio_write(pvio, (unsigned char *)hdr, len) <= 0)\n    {\n      ma_pvio_close(pvio);\n      goto error;\n    }\n  }\n\n  if (ma_net_init(net, pvio))\n    goto error;\n\n  if (mysql->options.max_allowed_packet)\n    net->max_packet_size= mysql->options.max_allowed_packet;\n\n  ma_pvio_keepalive(net->pvio);\n  strcpy(mysql->net.sqlstate, \"00000\");\n\n  /* Get version info */\n  mysql->protocol_version= PROTOCOL_VERSION;\t/* Assume this */\n/*\n  if (ma_pvio_wait_io_or_timeout(net->pvio, FALSE, 0) < 1)\n  {\n    my_set_error(mysql, CR_SERVER_LOST, SQLSTATE_UNKNOWN,\n                 ER(CR_SERVER_LOST_EXTENDED),\n                 \"handshake: waiting for initial communication packet\",\n                 errno);\n    goto error;\n  }\n */\n  if ((pkt_length=ma_net_safe_read(mysql)) == packet_error)\n  {\n    if (mysql->net.last_errno == CR_SERVER_LOST)\n      my_set_error(mysql, CR_SERVER_LOST, SQLSTATE_UNKNOWN,\n                 ER(CR_SERVER_LOST_EXTENDED),\n                 \"handshake: reading initial communication packet\",\n                 errno);\n\n    goto error;\n  }\n  end= (char *)net->read_pos;\n  end_pkt= (char *)net->read_pos + pkt_length;\n\n  /* Check if version of protocol matches current one */\n\n  mysql->protocol_version= end[0];\n  end++;\n\n  /* Check if server sends an error */\n  if (mysql->protocol_version == 0XFF)\n  {\n    net_get_error(end, pkt_length - 1, net->last_error, sizeof(net->last_error),\n      &net->last_errno, net->sqlstate);\n    /* fix for bug #26426 */\n    if (net->last_errno == 1040)\n      memcpy(net->sqlstate, \"08004\", SQLSTATE_LENGTH);\n    goto error;\n  }\n\n  if (mysql->protocol_version <  PROTOCOL_VERSION)\n  {\n    net->last_errno= CR_VERSION_ERROR;\n    sprintf(net->last_error, ER(CR_VERSION_ERROR), mysql->protocol_version,\n\t    PROTOCOL_VERSION);\n    goto error;\n  }\n  /* Save connection information */\n  if (!user) user=\"\";\n\n  if (!(mysql->host_info= strdup(host_info)) ||\n      !(mysql->host= strdup(cinfo.host ? cinfo.host : \"\")) ||\n      !(mysql->user=strdup(user)) ||\n      !(mysql->passwd=strdup(passwd)))\n  {\n    SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n    goto error;\n  }\n  if (cinfo.unix_socket)\n    mysql->unix_socket= strdup(cinfo.unix_socket);\n  else\n    mysql->unix_socket=0;\n  mysql->port=port;\n  client_flag|=mysql->options.client_flag;\n\n  if (strncmp(end, MA_RPL_VERSION_HACK, sizeof(MA_RPL_VERSION_HACK) - 1) == 0)\n  {\n    mysql->server_version= strdup(end + sizeof(MA_RPL_VERSION_HACK) - 1);\n    is_maria= 1;\n  }\n  else\n  {\n    if (!(mysql->server_version= strdup(end)))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      goto error;\n    }\n  }\n  end+= strlen(end) + 1;\n\n  mysql->thread_id=uint4korr(end);\n  end+=4;\n\n  /* This is the first part of scramble packet. In 4.1 and later\n     a second package will follow later */\n  scramble_data= end;\n  scramble_len= SCRAMBLE_LENGTH_323 + 1;\n  scramble_plugin= old_password_plugin_name;\n  end+= SCRAMBLE_LENGTH_323;\n\n  /* 1st pad */\n  end++;\n\n  if (end + 1<= end_pkt)\n  {\n    mysql->server_capabilities=uint2korr(end);\n  }\n\n  /* mysql 5.5 protocol */\n  if (end + 18 <= end_pkt)\n  {\n    mysql->server_language= uint1korr(end + 2);\n    mysql->server_status= uint2korr(end + 3);\n    mysql->server_capabilities|= (unsigned int)(uint2korr(end + 5)) << 16;\n    pkt_scramble_len= uint1korr(end + 7);\n\n    /* check if MariaD2B specific capabilities are available */\n    if (is_maria && !(mysql->server_capabilities & CLIENT_MYSQL))\n    {\n      mysql->extension->mariadb_server_capabilities= (ulonglong) uint4korr(end + 14);\n    }\n  }\n\n  /* pad 2 */\n  end+= 18;\n\n  /* second scramble package */\n  if (end + SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323 + 1 <= end_pkt)\n  {\n    memcpy(end - SCRAMBLE_LENGTH_323, scramble_data, SCRAMBLE_LENGTH_323);\n    scramble_data= end - SCRAMBLE_LENGTH_323;\n    if (mysql->server_capabilities & CLIENT_PLUGIN_AUTH)\n    {\n      scramble_len= pkt_scramble_len;\n      scramble_plugin= scramble_data + scramble_len;\n      if (scramble_data + scramble_len > end_pkt)\n      {\n        SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n        goto error;\n      }\n    } else\n    {\n      scramble_len= (uint)(end_pkt - scramble_data);\n      scramble_plugin= native_password_plugin_name;\n    }\n  } else\n  {\n    mysql->server_capabilities&= ~CLIENT_SECURE_CONNECTION;\n    if (mysql->options.secure_auth)\n    {\n      SET_CLIENT_ERROR(mysql, CR_SECURE_AUTH, SQLSTATE_UNKNOWN, 0);\n      goto error;\n    }\n  }\n\n  /* Set character set */\n  if (mysql->options.charset_name)\n    mysql->charset= mysql_find_charset_name(mysql->options.charset_name);\n  else\n    mysql->charset=mysql_find_charset_name(MARIADB_DEFAULT_CHARSET);\n\n  if (!mysql->charset)\n  {\n    net->last_errno=CR_CANT_READ_CHARSET;\n    sprintf(net->last_error,ER(net->last_errno),\n      mysql->options.charset_name ? mysql->options.charset_name : \n                                    MARIADB_DEFAULT_CHARSET,\n      \"compiled_in\");\n    goto error;\n  }\n\n  mysql->client_flag= client_flag;\n\n  if (run_plugin_auth(mysql, scramble_data, scramble_len,\n                             scramble_plugin, db))\n    goto error;\n\n  if (mysql->client_flag & CLIENT_COMPRESS)\n    net->compress= 1;\n\n  /* last part: select default db */\n  if (!(mysql->server_capabilities & CLIENT_CONNECT_WITH_DB) &&\n      (db && !mysql->db))\n  {\n    if (mysql_select_db(mysql, db))\n    {\n      my_set_error(mysql, CR_SERVER_LOST, SQLSTATE_UNKNOWN,\n                          ER(CR_SERVER_LOST_EXTENDED),\n                          \"Setting intital database\",\n                          errno);\n      goto error;\n    }\n  }\n\n  if (mysql->options.init_command)\n  {\n    char **begin= (char **)mysql->options.init_command->buffer;\n    char **end= begin + mysql->options.init_command->elements;\n\n    /* Avoid reconnect in mysql_real_connect */\n    my_bool save_reconnect= mysql->options.reconnect;\n    mysql->options.reconnect= 0;\n\n    for (;begin < end; begin++)\n    {\n      if (mysql_real_query(mysql, *begin, (unsigned long)strlen(*begin)))\n        goto error;\n\n    /* check if query produced a result set */\n      do {\n        MYSQL_RES *res;\n        if ((res= mysql_use_result(mysql)))\n          mysql_free_result(res);\n      } while (!mysql_next_result(mysql));\n    }\n    mysql->options.reconnect= save_reconnect;\n  }\n\n  strcpy(mysql->net.sqlstate, \"00000\");\n\n  /* connection established, apply timeouts */\n  ma_pvio_set_timeout(mysql->net.pvio, PVIO_READ_TIMEOUT, mysql->options.read_timeout);\n  ma_pvio_set_timeout(mysql->net.pvio, PVIO_WRITE_TIMEOUT, mysql->options.write_timeout);\n  return(mysql);\n\nerror:\n  /* Free alloced memory */\n  end_server(mysql);\n  /* only free the allocated memory, user needs to call mysql_close */\n  mysql_close_memory(mysql);\n  if (!(client_flag & CLIENT_REMEMBER_OPTIONS) &&\n      !mysql->options.extension->async_context)\n    mysql_close_options(mysql);\n  return(0);\n}\n\nstruct my_hook_data {\n  MYSQL *orig_mysql;\n  MYSQL *new_mysql;\n  /* This is always NULL currently, but restoring does not hurt just in case. */\n  MARIADB_PVIO *orig_pvio;\n};\n/*\n  Callback hook to make the new VIO accessible via the old MYSQL to calling\n  application when suspending a non-blocking call during automatic reconnect.\n*/\nstatic void\nmy_suspend_hook(my_bool suspend, void *data)\n{\n  struct my_hook_data *hook_data= (struct my_hook_data *)data;\n  if (suspend)\n  {\n    hook_data->orig_pvio= hook_data->orig_mysql->net.pvio;\n    hook_data->orig_mysql->net.pvio= hook_data->new_mysql->net.pvio;\n  }\n  else\n    hook_data->orig_mysql->net.pvio= hook_data->orig_pvio;\n}\n\nmy_bool STDCALL mariadb_reconnect(MYSQL *mysql)\n{\n  MYSQL tmp_mysql;\n  struct my_hook_data hook_data;\n  struct mysql_async_context *ctxt= NULL;\n  LIST *li_stmt= mysql->stmts;\n\n  /* check if connection handler is active */\n  if (IS_CONNHDLR_ACTIVE(mysql))\n  {\n    if (mysql->extension->conn_hdlr->plugin && mysql->extension->conn_hdlr->plugin->reconnect)\n      return(mysql->extension->conn_hdlr->plugin->reconnect(mysql));\n  }\n\n  if (!mysql->options.reconnect ||\n      (mysql->server_status & SERVER_STATUS_IN_TRANS) || !mysql->host_info)\n  {\n   /* Allow reconnect next time */\n    mysql->server_status&= ~SERVER_STATUS_IN_TRANS;\n    my_set_error(mysql, CR_SERVER_GONE_ERROR, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n\n  mysql_init(&tmp_mysql);\n  tmp_mysql.free_me= 0;\n  tmp_mysql.options=mysql->options;\n  if (mysql->extension->conn_hdlr)\n  {\n    tmp_mysql.extension->conn_hdlr= mysql->extension->conn_hdlr;\n    mysql->extension->conn_hdlr= 0;\n  }\n\n  /* don't reread options from configuration files */\n  tmp_mysql.options.my_cnf_group= tmp_mysql.options.my_cnf_file= NULL;\n  if (IS_MYSQL_ASYNC_ACTIVE(mysql))\n  {\n    ctxt= mysql->options.extension->async_context;\n    hook_data.orig_mysql= mysql;\n    hook_data.new_mysql= &tmp_mysql;\n    hook_data.orig_pvio= mysql->net.pvio;\n    my_context_install_suspend_resume_hook(ctxt, my_suspend_hook, &hook_data);\n  }\n\n  if (!mysql_real_connect(&tmp_mysql,mysql->host,mysql->user,mysql->passwd,\n\t\t\t  mysql->db, mysql->port, mysql->unix_socket,\n\t\t\t  mysql->client_flag | CLIENT_REMEMBER_OPTIONS) ||\n      mysql_set_character_set(&tmp_mysql, mysql->charset->csname))\n  {\n    if (ctxt)\n      my_context_install_suspend_resume_hook(ctxt, NULL, NULL);\n    /* don't free options (CONC-118) */\n    memset(&tmp_mysql.options, 0, sizeof(struct st_mysql_options));\n    my_set_error(mysql, tmp_mysql.net.last_errno,\n                        tmp_mysql.net.sqlstate,\n                        tmp_mysql.net.last_error);\n    mysql_close(&tmp_mysql);\n    return(1);\n  }\n\n  for (;li_stmt;li_stmt= li_stmt->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *)li_stmt->data;\n\n    if (stmt->state != MYSQL_STMT_INITTED)\n    {\n      stmt->state= MYSQL_STMT_INITTED;\n      SET_CLIENT_STMT_ERROR(stmt, CR_SERVER_LOST, SQLSTATE_UNKNOWN, 0);\n    }\n  }\n\n  tmp_mysql.free_me= mysql->free_me;\n  tmp_mysql.stmts= mysql->stmts;\n  mysql->stmts= NULL;\n\n  if (ctxt)\n    my_context_install_suspend_resume_hook(ctxt, NULL, NULL);\n  /* Don't free options, we moved them to tmp_mysql */\n  memset(&mysql->options, 0, sizeof(mysql->options));\n  mysql->free_me=0;\n  mysql_close(mysql);\n  *mysql=tmp_mysql;\n  mysql->net.pvio->mysql= mysql;\n  ma_net_clear(&mysql->net);\n  mysql->affected_rows= ~(unsigned long long) 0;\n  mysql->info= 0;\n  return(0);\n}\n\nvoid ma_invalidate_stmts(MYSQL *mysql, const char *function_name)\n{\n  if (mysql->stmts)\n  {\n    LIST *li_stmt= mysql->stmts;\n\n    for (; li_stmt; li_stmt= li_stmt->next)\n    {\n      MYSQL_STMT *stmt= (MYSQL_STMT *)li_stmt->data;\n      stmt->mysql= NULL;\n      SET_CLIENT_STMT_ERROR(stmt, CR_STMT_CLOSED, SQLSTATE_UNKNOWN, function_name);\n    }\n    mysql->stmts= NULL;\n  }\n}\n\n/*\n  Legacy support of the MariaDB 5.5 version, where timeouts where only in\n  seconds resolution. Applications that use this will be asked to set a timeout\n  at the nearest higher whole-seconds value.\n*/\nunsigned int STDCALL\nmysql_get_timeout_value(const MYSQL *mysql)\n{\n  unsigned int timeout= 0;\n\n  if (mysql->options.extension && mysql->options.extension->async_context)\n    timeout= mysql->options.extension->async_context->timeout_value;\n  /* Avoid overflow. */\n  if (timeout > UINT_MAX - 999)\n    return (timeout - 1)/1000 + 1;\n  else\n    return (timeout+999)/1000;\n}\n\n\nunsigned int STDCALL\nmysql_get_timeout_value_ms(const MYSQL *mysql)\n{\n  if (mysql->options.extension && mysql->options.extension->async_context)\n    return mysql->options.extension->async_context->timeout_value;\n  return 0;\n}\n\n/**************************************************************************\n** Change user and database\n**************************************************************************/\n\nmy_bool\tSTDCALL mysql_change_user(MYSQL *mysql, const char *user,\n\t\t\t\t  const char *passwd, const char *db)\n{\n  const MARIADB_CHARSET_INFO *s_cs= mysql->charset;\n  char *s_user= mysql->user,\n       *s_passwd= mysql->passwd,\n       *s_db= mysql->db;\n  int rc;\n\n  if (mysql->options.charset_name)\n    mysql->charset= mysql_find_charset_name(mysql->options.charset_name);\n  else\n    mysql->charset=mysql_find_charset_name(MARIADB_DEFAULT_CHARSET);\n\n  mysql->user= strdup(user ? user : \"\");\n  mysql->passwd= strdup(passwd ? passwd : \"\");\n\n  /* db will be set in run_plugin_auth */\n  mysql->db= 0;\n  rc= run_plugin_auth(mysql, 0, 0, 0, db);\n\n  /* COM_CHANGE_USER always releases prepared statements, so we need to invalidate them */\n  ma_invalidate_stmts(mysql, \"mysql_change_user()\");\n\n  if (rc==0)\n  {\n    free(s_user);\n    free(s_passwd);\n    free(s_db);\n\n    if (!mysql->db && db && !(mysql->db= strdup(db)))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      rc= 1;\n    }\n  } else\n  {\n    free(mysql->user);\n    free(mysql->passwd);\n    free(mysql->db);\n\n    mysql->user= s_user;\n    mysql->passwd= s_passwd;\n    mysql->db= s_db;\n    mysql->charset= s_cs;\n  }\n  return(rc);\n}\n\n\n/**************************************************************************\n** Set current database\n**************************************************************************/\n\nint STDCALL\nmysql_select_db(MYSQL *mysql, const char *db)\n{\n  int error;\n\n  if (!db)\n    return 1;\n\n  if ((error=ma_simple_command(mysql, COM_INIT_DB, db,\n                               (uint) strlen(db),0,0)))\n    return(error);\n  free(mysql->db);\n  mysql->db=strdup(db);\n  return(0);\n}\n\n\n/*************************************************************************\n** Send a QUIT to the server and close the connection\n** If handle is alloced by mysql connect free it.\n*************************************************************************/\n\nstatic void mysql_close_options(MYSQL *mysql)\n{\n  if (mysql->options.init_command)\n  {\n    char **begin= (char **)mysql->options.init_command->buffer;\n    char **end= begin + mysql->options.init_command->elements;\n\n    for (;begin < end; begin++)\n      free(*begin);\n    ma_delete_dynamic(mysql->options.init_command);\n    free(mysql->options.init_command);\n  }\n  free(mysql->options.user);\n  free(mysql->options.host);\n  free(mysql->options.password);\n  free(mysql->options.unix_socket);\n  free(mysql->options.db);\n  free(mysql->options.my_cnf_file);\n  free(mysql->options.my_cnf_group);\n  free(mysql->options.charset_dir);\n  free(mysql->options.charset_name);\n  free(mysql->options.bind_address);\n  free(mysql->options.ssl_key);\n  free(mysql->options.ssl_cert);\n  free(mysql->options.ssl_ca);\n  free(mysql->options.ssl_capath);\n  free(mysql->options.ssl_cipher);\n\n  if (mysql->options.extension)\n  {\n    struct mysql_async_context *ctxt;\n    if ((ctxt = mysql->options.extension->async_context))\n    {\n      my_context_destroy(&ctxt->async_context);\n      free(ctxt);\n      mysql->options.extension->async_context= 0;\n    }\n    free(mysql->options.extension->plugin_dir);\n    free(mysql->options.extension->default_auth);\n    free(mysql->options.extension->db_driver);\n    free(mysql->options.extension->ssl_crl);\n    free(mysql->options.extension->ssl_crlpath);\n    free(mysql->options.extension->tls_fp);\n    free(mysql->options.extension->tls_fp_list);\n    free(mysql->options.extension->tls_pw);\n    free(mysql->options.extension->tls_version);\n    free(mysql->options.extension->url);\n    free(mysql->options.extension->connection_handler);\n    if(hash_inited(&mysql->options.extension->connect_attrs))\n      hash_free(&mysql->options.extension->connect_attrs);\n    if (hash_inited(&mysql->options.extension->userdata))\n      hash_free(&mysql->options.extension->userdata);\n\n  }\n  free(mysql->options.extension);\n  /* clear all pointer */\n  memset(&mysql->options, 0, sizeof(mysql->options));\n}\n\nstatic void mysql_close_memory(MYSQL *mysql)\n{\n  ma_clear_session_state(mysql);\n  free(mysql->host_info);\n  free(mysql->host);\n  free(mysql->user);\n  free(mysql->passwd);\n  free(mysql->db);\n  free(mysql->unix_socket);\n  free(mysql->server_version);\n  mysql->host_info= mysql->host= mysql->unix_socket=\n                    mysql->server_version=mysql->user=mysql->passwd=mysql->db=0;\n}\n\nvoid my_set_error(MYSQL *mysql,\n                  unsigned int error_nr,\n                  const char *sqlstate,\n                  const char *format,\n                  ...)\n{\n  va_list ap;\n\n  const char *errmsg;\n\n  if (!format)\n  {\n    if (error_nr >= CR_MIN_ERROR && error_nr <= CR_MYSQL_LAST_ERROR)\n      errmsg= ER(error_nr);\n    else if (error_nr >= CER_MIN_ERROR && error_nr <= CR_MARIADB_LAST_ERROR)\n      errmsg= CER(error_nr);\n    else\n      errmsg= ER(CR_UNKNOWN_ERROR);\n  }\n\n  mysql->net.last_errno= error_nr;\n  ma_strmake(mysql->net.sqlstate, sqlstate, SQLSTATE_LENGTH);\n  va_start(ap, format);\n  vsnprintf(mysql->net.last_error, MYSQL_ERRMSG_SIZE - 1,\n            format ? format : errmsg, ap);\n  va_end(ap);\n  return;\n}\n\nvoid mysql_close_slow_part(MYSQL *mysql)\n{\n  if (mysql->net.pvio)\n  {\n    free_old_query(mysql);\n    mysql->status=MYSQL_STATUS_READY; /* Force command */\n    mysql->options.reconnect=0;\n    if (mysql->net.pvio && mysql->net.buff)\n      ma_simple_command(mysql, COM_QUIT,NullS,0,1,0);\n    end_server(mysql);\n  }\n}\n\nstatic void ma_clear_session_state(MYSQL *mysql)\n{\n  uint i;\n\n  if (!mysql || !mysql->extension)\n    return;\n\n  for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n  {\n    list_free(mysql->extension->session_state[i].list, 0);\n  }\n  memset(mysql->extension->session_state, 0, sizeof(struct st_mariadb_session_state) * SESSION_TRACK_TYPES);\n}\n\nvoid STDCALL\nmysql_close(MYSQL *mysql)\n{\n  if (mysql)\t\t\t\t\t/* Some simple safety */\n  {\n    if (mysql->extension && mysql->extension->conn_hdlr)\n    {\n      MA_CONNECTION_HANDLER *p= mysql->extension->conn_hdlr;\n      if (p->plugin->close)\n        p->plugin->close(mysql);\n      free(p);\n      /* Fix for CONC-294: Since we already called plugin->close function\n         we need to prevent that mysql_close_slow_part (which sends COM_QUIT\n         to the server) will be handled by plugin again. */\n      mysql->extension->conn_hdlr= NULL;\n    }\n\n    if (mysql->methods)\n      mysql->methods->db_close(mysql);\n\n    /* reset the connection in all active statements */\n    ma_invalidate_stmts(mysql, \"mysql_close()\");\n\n    mysql_close_memory(mysql);\n    mysql_close_options(mysql);\n    ma_clear_session_state(mysql);\n\n    if (mysql->net.extension)\n      free(mysql->net.extension);\n\n    mysql->host_info=mysql->user=mysql->passwd=mysql->db=0;\n\n    /* Clear pointers for better safety */\n    memset((char*) &mysql->options, 0, sizeof(mysql->options));\n\n    if (mysql->extension)\n      free(mysql->extension);\n\n    mysql->net.pvio= 0;\n    if (mysql->free_me)\n      free(mysql);\n  }\n  return;\n}\n\n\n/**************************************************************************\n** Do a query. If query returned rows, free old rows.\n** Read data by mysql_store_result or by repeating calls to mysql_fetch_row\n**************************************************************************/\n\nint STDCALL\nmysql_query(MYSQL *mysql, const char *query)\n{\n  return mysql_real_query(mysql,query, (unsigned long) strlen(query));\n}\n\n/*\n  Send the query and return so we can do something else.\n  Needs to be followed by mysql_read_query_result() when we want to\n  finish processing it.\n*/\n\nint STDCALL\nmysql_send_query(MYSQL* mysql, const char* query, unsigned long length)\n{\n  return ma_simple_command(mysql, COM_QUERY, query, length, 1,0);\n}\n\nint ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)\n{\n  uchar *end= mysql->net.read_pos+length;\n  size_t item_len;\n  mysql->affected_rows= net_field_length_ll(&pos);\n  mysql->insert_id=\t  net_field_length_ll(&pos);\n  mysql->server_status=uint2korr(pos);\n  pos+=2;\n  mysql->warning_count=uint2korr(pos);\n  pos+=2;\n  if (pos > end)\n    goto corrupted;\n  if (pos < end)\n  {\n    if ((item_len= net_field_length(&pos)))\n      mysql->info=(char*) pos;\n    if (pos + item_len > end)\n      goto corrupted;\n\n    /* check if server supports session tracking */\n    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    {\n      ma_clear_session_state(mysql);\n      pos+= item_len;\n\n      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n      {\n        int i;\n        if (pos < end)\n        {\n          LIST *session_item;\n          MYSQL_LEX_STRING *str= NULL;\n          enum enum_session_state_type si_type;\n          uchar *old_pos= pos;\n\n          item_len= net_field_length(&pos);  /* length for all items */\n          if (pos + item_len > end)\n            goto corrupted;\n          end= pos + item_len;\n\n          /* length was already set, so make sure that info will be zero terminated */\n          if (mysql->info)\n            *old_pos= 0;\n\n          while (pos < end)\n          {\n            size_t plen;\n            char *data;\n            si_type= (enum enum_session_state_type)net_field_length(&pos);\n            switch(si_type) {\n            case SESSION_TRACK_SCHEMA:\n            case SESSION_TRACK_STATE_CHANGE:\n            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n            case SESSION_TRACK_SYSTEM_VARIABLES:\n              if (si_type != SESSION_TRACK_STATE_CHANGE)\n                net_field_length(&pos); /* ignore total length, item length will follow next */\n              plen= net_field_length(&pos);\n              if (pos + plen > end)\n                goto corrupted;\n              if (!(session_item= ma_multi_malloc(0,\n                                  &session_item, sizeof(LIST),\n                                  &str, sizeof(MYSQL_LEX_STRING),\n                                  &data, plen,\n                                  NULL)))\n                  goto oom;\n              str->length= plen;\n              str->str= data;\n              memcpy(str->str, (char *)pos, plen);\n              pos+= plen;\n              session_item->data= str;\n              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n\n              /* in case schema has changed, we have to update mysql->db */\n              if (si_type == SESSION_TRACK_SCHEMA)\n              {\n                free(mysql->db);\n                mysql->db= malloc(plen + 1);\n                memcpy(mysql->db, str->str, plen);\n                mysql->db[plen]= 0;\n              }\n              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n              {\n                my_bool set_charset= 0;\n                /* make sure that we update charset in case it has changed */\n                if (!strncmp(str->str, \"character_set_client\", str->length))\n                  set_charset= 1;\n                plen= net_field_length(&pos);\n                if (pos + plen > end)\n                  goto corrupted;\n                if (!(session_item= ma_multi_malloc(0,\n                                    &session_item, sizeof(LIST),\n                                    &str, sizeof(MYSQL_LEX_STRING),\n                                    &data, plen,\n                                    NULL)))\n                  goto oom;\n                str->length= plen;\n                str->str= data;\n                memcpy(str->str, (char *)pos, plen);\n                pos+= plen;\n                session_item->data= str;\n                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n                if (set_charset && str->length < CHARSET_NAME_LEN &&\n                    strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                {\n                  char cs_name[CHARSET_NAME_LEN];\n                  const MARIADB_CHARSET_INFO *cs_info;\n                  memcpy(cs_name, str->str, str->length);\n                  cs_name[str->length]= 0;\n                  if ((cs_info = mysql_find_charset_name(cs_name)))\n                    mysql->charset= cs_info;\n                }\n              }\n              break;\n            default:\n              /* not supported yet */\n              plen= net_field_length(&pos);\n              if (pos + plen > end)\n                goto corrupted;\n              pos+= plen;\n              break;\n            }\n          }\n        }\n        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n        {\n          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n        }\n      }\n    }\n  }\n  /* CONC-351: clear session state information */\n  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    ma_clear_session_state(mysql);\n  return(0);\n\noom:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n  return -1;\n\ncorrupted:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n  return -1;\n}\n\nint mthd_my_read_query_result(MYSQL *mysql)\n{\n  uchar *pos;\n  ulong field_count;\n  MYSQL_DATA *fields;\n  ulong length;\n  my_bool can_local_infile= (mysql->options.extension) && (mysql->extension->auto_local_infile != WAIT_FOR_QUERY);\n\n  if (mysql->options.extension && mysql->extension->auto_local_infile == ACCEPT_FILE_REQUEST)\n    mysql->extension->auto_local_infile= WAIT_FOR_QUERY;\n\n  if ((length = ma_net_safe_read(mysql)) == packet_error)\n  {\n    return(1);\n  }\n  free_old_query(mysql);\t\t\t/* Free old result */\nget_info:\n  pos=(uchar*) mysql->net.read_pos;\n  if ((field_count= net_field_length(&pos)) == 0)\n    return ma_read_ok_packet(mysql, pos, length);\n  if (field_count == NULL_LENGTH)\t\t/* LOAD DATA LOCAL INFILE */\n  {\n    int error=mysql_handle_local_infile(mysql, (char *)pos, can_local_infile);\n\n    if ((length=ma_net_safe_read(mysql)) == packet_error || error)\n      return(-1);\n    goto get_info;\t\t\t\t/* Get info packet */\n  }\n  if (!(mysql->server_status & SERVER_STATUS_AUTOCOMMIT))\n    mysql->server_status|= SERVER_STATUS_IN_TRANS;\n\n  mysql->extra_info= net_field_length_ll(&pos); /* Maybe number of rec */\n  if (!(fields=mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,\n                                            ma_result_set_rows(mysql))))\n    return(-1);\n  if (!(mysql->fields=unpack_fields(mysql, fields, &mysql->field_alloc,\n\t\t\t\t    (uint) field_count, 1)))\n    return(-1);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  return(0);\n}\n\nint STDCALL mysql_session_track_get_next(MYSQL *mysql, enum enum_session_state_type type,\n                                         const char **data, size_t *length)\n{\n  MYSQL_LEX_STRING *str;\n  if (!mysql->extension->session_state[type].current)\n    return 1;\n\n  str= (MYSQL_LEX_STRING *)mysql->extension->session_state[type].current->data;\n  mysql->extension->session_state[type].current= mysql->extension->session_state[type].current->next;\n\n  *data= str->str ? str->str : NULL;\n  *length= str->str ? str->length : 0;\n  return 0;\n}\n\nint STDCALL mysql_session_track_get_first(MYSQL *mysql, enum enum_session_state_type type,\n                                          const char **data, size_t *length)\n{\n  mysql->extension->session_state[type].current= mysql->extension->session_state[type].list;\n  return mysql_session_track_get_next(mysql, type, data, length);\n}\n\nmy_bool STDCALL\nmysql_read_query_result(MYSQL *mysql)\n{\n  return test(mysql->methods->db_read_query_result(mysql)) ? 1 : 0;\n}\n\nint STDCALL\nmysql_real_query(MYSQL *mysql, const char *query, unsigned long length)\n{\n  my_bool skip_result= OPT_EXT_VAL(mysql, multi_command);\n\n  if (length == (unsigned long)-1)\n    length= (unsigned long)strlen(query);\n\n  free_old_query(mysql);\n\n  if (ma_simple_command(mysql, COM_QUERY,query,length,1,0))\n    return(-1);\n  if (!skip_result)\n    return(mysql->methods->db_read_query_result(mysql));\n  return(0);\n}\n\n/**************************************************************************\n** Alloc result struct for buffered results. All rows are read to buffer.\n** mysql_data_seek may be used.\n**************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_store_result(MYSQL *mysql)\n{\n  MYSQL_RES *result;\n\n  if (!mysql->fields)\n    return(0);\n  if (mysql->status != MYSQL_STATUS_GET_RESULT)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  mysql->status=MYSQL_STATUS_READY;\t\t/* server is ready */\n  if (!(result=(MYSQL_RES*) calloc(1, sizeof(MYSQL_RES)+\n\t\t\t\t       sizeof(ulong)*mysql->field_count)))\n  {\n    SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  result->eof=1;\t\t\t\t/* Marker for buffered */\n  result->lengths=(ulong*) (result+1);\n  if (!(result->data=mysql->methods->db_read_rows(mysql,mysql->fields,mysql->field_count)))\n  {\n    free(result);\n    return(0);\n  }\n  mysql->affected_rows= result->row_count= result->data->rows;\n  result->data_cursor=\tresult->data->data;\n  result->fields=\tmysql->fields;\n  result->field_alloc=\tmysql->field_alloc;\n  result->field_count=\tmysql->field_count;\n  result->current_field=0;\n  result->current_row=0;\t\t\t/* Must do a fetch first */\n  mysql->fields=0;\t\t\t\t/* fields is now in result */\n  return(result);\t\t\t\t/* Data fetched */\n}\n\n\n/**************************************************************************\n** Alloc struct for use with unbuffered reads. Data is fetched by domand\n** when calling to mysql_fetch_row.\n** mysql_data_seek is a noop.\n**\n** No other queries may be specified with the same MYSQL handle.\n** There shouldn't be much processing per row because mysql server shouldn't\n** have to wait for the client (and will not wait more than 30 sec/packet).\n**************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_use_result(MYSQL *mysql)\n{\n  MYSQL_RES *result;\n\n  if (!mysql->fields)\n    return(0);\n  if (mysql->status != MYSQL_STATUS_GET_RESULT)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    return(0);\n  }\n  if (!(result=(MYSQL_RES*) calloc(1, sizeof(*result)+\n\t\t\t\t      sizeof(ulong)*mysql->field_count)))\n    return(0);\n  result->lengths=(ulong*) (result+1);\n  if (!(result->row=(MYSQL_ROW)\n\tmalloc(sizeof(result->row[0])*(mysql->field_count+1))))\n  {\t\t\t\t\t/* Ptrs: to one row */\n    free(result);\n    return(0);\n  }\n  result->fields=\tmysql->fields;\n  result->field_alloc=\tmysql->field_alloc;\n  result->field_count=\tmysql->field_count;\n  result->current_field=0;\n  result->handle=\tmysql;\n  result->current_row=\t0;\n  mysql->fields=0;\t\t\t/* fields is now in result */\n  mysql->status=MYSQL_STATUS_USE_RESULT;\n  return(result);\t\t\t/* Data is read to be fetched */\n}\n\n/**************************************************************************\n** Return next field of the query results\n**************************************************************************/\nMYSQL_FIELD * STDCALL\nmysql_fetch_field(MYSQL_RES *result)\n{\n  if (result->current_field >= result->field_count)\n    return(NULL);\n  return &result->fields[result->current_field++];\n}\n\n\n/**************************************************************************\n** Return mysql field metadata\n**************************************************************************/\nint STDCALL\nmariadb_field_attr(MARIADB_CONST_STRING *attr,\n                   const MYSQL_FIELD *field,\n                   enum mariadb_field_attr_t type)\n{\n  MA_FIELD_EXTENSION *ext= (MA_FIELD_EXTENSION*) field->extension;\n  if (!ext || type > MARIADB_FIELD_ATTR_LAST)\n  {\n    *attr= null_const_string;\n    return 1;\n  }\n  *attr= ext->metadata[type];\n  return 0;\n}\n\n\n/**************************************************************************\n**  Return next row of the query results\n**************************************************************************/\nMYSQL_ROW STDCALL\nmysql_fetch_row(MYSQL_RES *res)\n{\n  if (!res)\n    return 0;\n  if (res->handle)\n  {\n    if (res->handle->status != MYSQL_STATUS_USE_RESULT &&\n        res->handle->status != MYSQL_STATUS_GET_RESULT)\n      return 0;\n  }\n  if (!res->data)\n  {\t\t\t\t\t\t/* Unbufferred fetch */\n    if (!res->eof && res->handle)\n    {\n      if (!(res->handle->methods->db_read_one_row(res->handle,res->field_count,res->row, res->lengths)))\n      {\n        res->row_count++;\n        return(res->current_row=res->row);\n      }\n      res->eof=1;\n      res->handle->status=MYSQL_STATUS_READY;\n       /* Don't clear handle in mysql_free_results */\n      res->handle=0;\n    }\n    return((MYSQL_ROW) NULL);\n  }\n  {\n    MYSQL_ROW tmp;\n    if (!res->data_cursor)\n    {\n      return(res->current_row=(MYSQL_ROW) NULL);\n    }\n    tmp = res->data_cursor->data;\n    res->data_cursor = res->data_cursor->next;\n    return(res->current_row=tmp);\n  }\n}\n\n/**************************************************************************\n** Get column lengths of the current row\n** If one uses mysql_use_result, res->lengths contains the length information,\n** else the lengths are calculated from the offset between pointers.\n**************************************************************************/\n\nulong * STDCALL\nmysql_fetch_lengths(MYSQL_RES *res)\n{\n  ulong *lengths,*prev_length;\n  char *start;\n  MYSQL_ROW column,end;\n\n  if (!(column=res->current_row))\n    return 0;\t\t\t\t\t/* Something is wrong */\n  if (res->data)\n  {\n    start=0;\n    prev_length=0;\t\t\t\t/* Keep gcc happy */\n    lengths=res->lengths;\n    for (end=column+res->field_count+1 ; column != end ; column++,lengths++)\n    {\n      if (!*column)\n      {\n\t*lengths=0;\t\t\t\t/* Null */\n\tcontinue;\n      }\n      if (start)\t\t\t\t/* Found end of prev string */\n\t*prev_length= (uint) (*column-start-1);\n      start= *column;\n      prev_length=lengths;\n    }\n  }\n  return res->lengths;\n}\n\n/**************************************************************************\n** Move to a specific row and column\n**************************************************************************/\n\nvoid STDCALL\nmysql_data_seek(MYSQL_RES *result, unsigned long long row)\n{\n  MYSQL_ROWS\t*tmp=0;\n  if (result->data)\n    for (tmp=result->data->data; row-- && tmp ; tmp = tmp->next) ;\n  result->current_row=0;\n  result->data_cursor = tmp;\n}\n\n/*************************************************************************\n** put the row or field cursor one a position one got from mysql_row_tell()\n** This doesn't restore any data. The next mysql_fetch_row or\n** mysql_fetch_field will return the next row or field after the last used\n*************************************************************************/\n\nMYSQL_ROW_OFFSET STDCALL\nmysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET row)\n{\n  MYSQL_ROW_OFFSET return_value=result->data_cursor;\n  result->current_row= 0;\n  result->data_cursor= row;\n  return return_value;\n}\n\n\nMYSQL_FIELD_OFFSET STDCALL\nmysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)\n{\n  MYSQL_FIELD_OFFSET return_value=result->current_field;\n  result->current_field=field_offset;\n  return return_value;\n}\n\n/********************************************************\n Warning: mysql_list_dbs is deprecated and will be\n          removed. Use SQL statement \"SHOW DATABASES\"\n          instead\n ********************************************************/\n\n/*****************************************************************************\n** List all databases\n*****************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_list_dbs(MYSQL *mysql, const char *wild)\n{\n  char buff[255];\n  snprintf(buff, 255, \"SHOW DATABASES LIKE '%s'\", wild ? wild : \"%\");\n  if (mysql_query(mysql,buff))\n    return(0);\n  return (mysql_store_result(mysql));\n}\n\n\n/********************************************************\n Warning: mysql_list_tables is deprecated and will be\n          removed. Use SQL statement \"SHOW TABLES\"\n          instead\n ********************************************************/\n/*****************************************************************************\n** List all tables in a database\n** If wild is given then only the tables matching wild are returned\n*****************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_list_tables(MYSQL *mysql, const char *wild)\n{\n  char buff[255];\n\n  snprintf(buff, 255, \"SHOW TABLES LIKE '%s'\", wild ? wild : \"%\");\n  if (mysql_query(mysql,buff))\n    return(0);\n  return (mysql_store_result(mysql));\n}\n\n\n/**************************************************************************\n** List all fields in a table\n** If wild is given then only the fields matching wild are returned\n** Instead of this use query:\n** show fields in 'table' like \"wild\"\n**************************************************************************/\n\nMYSQL_RES * STDCALL\nmysql_list_fields(MYSQL *mysql, const char *table, const char *wild)\n{\n  MYSQL_RES *result;\n  MYSQL_DATA *query;\n  char buff[255];\n  int length= 0;\n\n  LINT_INIT(query);\n\n  length= snprintf(buff, 128, \"%s%c%s\", table, '\\0', wild ? wild : \"\");\n\n  if (ma_simple_command(mysql, COM_FIELD_LIST,buff,length,1,0) ||\n      !(query = mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,\n                                             ma_result_set_rows(mysql))))\n    return(NULL);\n\n  free_old_query(mysql);\n  if (!(result = (MYSQL_RES *) calloc(1, sizeof(MYSQL_RES))))\n  {\n    free_rows(query);\n    return(NULL);\n  }\n  result->field_alloc=mysql->field_alloc;\n  mysql->fields=0;\n  result->eof=1;\n  result->field_count = (uint) query->rows;\n  result->fields= unpack_fields(mysql, query, &result->field_alloc,\n\t\t\t\tresult->field_count, 1);\n  if (result->fields)\n    return(result);\n\n  free(result);\n  return(NULL);\n}\n\n/********************************************************\n Warning: mysql_list_processes is deprecated and will be\n          removed. Use SQL statement \"SHOW PROCESSLIST\"\n          instead\n ********************************************************/\n\n/* List all running processes (threads) in server */\n\nMYSQL_RES * STDCALL\nmysql_list_processes(MYSQL *mysql)\n{\n  MYSQL_DATA *fields;\n  uint field_count;\n  uchar *pos;\n\n  LINT_INIT(fields);\n  if (ma_simple_command(mysql, COM_PROCESS_INFO,0,0,0,0))\n    return(NULL);\n  free_old_query(mysql);\n  pos=(uchar*) mysql->net.read_pos;\n  field_count=(uint) net_field_length(&pos);\n  if (!(fields = mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,7)))\n    return(NULL);\n  if (!(mysql->fields= unpack_fields(mysql, fields, &mysql->field_alloc,\n                                     field_count, 0)))\n    return(NULL);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  return(mysql_store_result(mysql));\n}\n\n/* In 5.0 this version became an additional parameter shutdown_level */\nint STDCALL\nmysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)\n{\n  uchar s_level[2];\n  s_level[0]= (uchar)shutdown_level;\n  return(ma_simple_command(mysql, COM_SHUTDOWN, (char *)s_level, 1, 0, 0));\n}\n\nint STDCALL\nmysql_refresh(MYSQL *mysql,uint options)\n{\n  uchar bits[1];\n  bits[0]= (uchar) options;\n  return(ma_simple_command(mysql, COM_REFRESH,(char*) bits,1,0,0));\n}\n\nint STDCALL\nmysql_kill(MYSQL *mysql,ulong pid)\n{\n  char buff[12];\n  int4store(buff,pid);\n  /* if we kill our own thread, reading the response packet will fail */\n  return(ma_simple_command(mysql, COM_PROCESS_KILL,buff,4,0,0));\n}\n\n\nint STDCALL\nmysql_dump_debug_info(MYSQL *mysql)\n{\n  return(ma_simple_command(mysql, COM_DEBUG,0,0,0,0));\n}\n\nchar * STDCALL\nmysql_stat(MYSQL *mysql)\n{\n  if (ma_simple_command(mysql, COM_STATISTICS,0,0,0,0))\n    return mysql->net.last_error;\n  mysql->net.read_pos[mysql->packet_length]=0;\t/* End of stat string */\n  if (!mysql->net.read_pos[0])\n  {\n    SET_CLIENT_ERROR(mysql, CR_WRONG_HOST_INFO , SQLSTATE_UNKNOWN, 0);\n    return mysql->net.last_error;\n  }\n  return((char*) mysql->net.read_pos);\n}\n\nint STDCALL\nmysql_ping(MYSQL *mysql)\n{\n  int rc;\n  rc= ma_simple_command(mysql, COM_PING, 0, 0, 0, 0);\n  if (rc && mysql->options.reconnect)\n    rc= ma_simple_command(mysql, COM_PING, 0, 0, 0, 0);\n  return rc;\n}\n\nchar * STDCALL\nmysql_get_server_info(MYSQL *mysql)\n{\n  return((char*) mysql->server_version);\n}\n\nstatic size_t mariadb_server_version_id(MYSQL *mysql)\n{\n  size_t major, minor, patch;\n  char *p;\n\n  if (!(p = mysql->server_version)) {\n    return 0;\n  }\n\n  major = strtol(p, &p, 10);\n  p += 1; /* consume the dot */\n  minor = strtol(p, &p, 10);\n  p += 1; /* consume the dot */\n  patch = strtol(p, &p, 10);\n\n  return (major * 10000L + (unsigned long)(minor * 100L + patch));\n}\n\nunsigned long STDCALL mysql_get_server_version(MYSQL *mysql)\n{\n  return (unsigned long)mariadb_server_version_id(mysql);\n}\n\nchar * STDCALL\nmysql_get_host_info(MYSQL *mysql)\n{\n  return(mysql->host_info);\n}\n\nuint STDCALL\nmysql_get_proto_info(MYSQL *mysql)\n{\n  return (mysql->protocol_version);\n}\n\nconst char * STDCALL\nmysql_get_client_info(void)\n{\n  return (char*) MARIADB_CLIENT_VERSION_STR;\n}\n\nstatic size_t get_store_length(size_t length)\n{\n  #define MAX_STORE_SIZE 9\n  unsigned char buffer[MAX_STORE_SIZE], *p;\n\n  /* We just store the length and substract offset of our buffer\n     to determine the length */\n  p= mysql_net_store_length(buffer, length);\n  return p - buffer;\n}\n\nuchar *ma_get_hash_keyval(const uchar *hash_entry,\n                       unsigned int *length,\n                       my_bool not_used __attribute__((unused)))\n{\n  /* Hash entry has the following format:\n     Offset: 0               key (\\0 terminated)\n             key_length + 1  value (\\0 terminated)\n  */\n  uchar *p= (uchar *)hash_entry;\n  size_t len= strlen((char *)p);\n  *length= (unsigned int)len;\n  return p;\n}\n\nvoid ma_int_hash_free(void *p)\n{\n  free(p);\n}\n\nint\nmysql_optionsv(MYSQL *mysql,enum mysql_option option, ...)\n{\n  va_list ap;\n  void *arg1;\n  size_t stacksize;\n  struct mysql_async_context *ctxt;\n\n  va_start(ap, option);\n\n  arg1= va_arg(ap, void *);\n\n  switch (option) {\n  case MYSQL_OPT_CONNECT_TIMEOUT:\n    mysql->options.connect_timeout= *(uint*) arg1;\n    break;\n  case MYSQL_OPT_COMPRESS:\n    mysql->options.compress= 1;\t\t\t/* Remember for connect */\n    mysql->options.client_flag|= CLIENT_COMPRESS;\n    break;\n  case MYSQL_OPT_NAMED_PIPE:\n    mysql->options.named_pipe=1;\t\t/* Force named pipe */\n    break;\n  case MYSQL_OPT_LOCAL_INFILE:\t\t\t/* Allow LOAD DATA LOCAL ?*/\n    if (!arg1 || test(*(unsigned int*) arg1))\n      mysql->options.client_flag|= CLIENT_LOCAL_FILES;\n    else\n      mysql->options.client_flag&= ~CLIENT_LOCAL_FILES;\n    if (arg1) {\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      mysql->extension->auto_local_infile= *(uint*)arg1 == LOCAL_INFILE_MODE_AUTO\n                                           ? WAIT_FOR_QUERY : ALWAYS_ACCEPT;\n    }\n    break;\n  case MYSQL_INIT_COMMAND:\n    options_add_initcommand(&mysql->options, (char *)arg1);\n    break;\n  case MYSQL_READ_DEFAULT_FILE:\n    OPT_SET_VALUE_STR(&mysql->options, my_cnf_file, (char *)arg1);\n    break;\n  case MYSQL_READ_DEFAULT_GROUP:\n    OPT_SET_VALUE_STR(&mysql->options, my_cnf_group, arg1 ? (char *)arg1 : \"\");\n    break;\n  case MYSQL_SET_CHARSET_DIR:\n    OPT_SET_VALUE_STR(&mysql->options, charset_dir, arg1);\n    break;\n  case MYSQL_SET_CHARSET_NAME:\n    OPT_SET_VALUE_STR(&mysql->options, charset_name, arg1);\n    break;\n  case MYSQL_OPT_RECONNECT:\n    mysql->options.reconnect= *(my_bool *)arg1;\n    break;\n  case MYSQL_OPT_PROTOCOL:\n    mysql->options.protocol= *((uint *)arg1);\n    break;\n#ifdef _WIN32\n  case MYSQL_SHARED_MEMORY_BASE_NAME:\n    OPT_SET_VALUE_STR(&mysql->options, shared_memory_base_name, arg1);\n    break;\n#endif\n  case MYSQL_OPT_READ_TIMEOUT:\n    mysql->options.read_timeout= *(uint *)arg1;\n    break;\n  case MYSQL_OPT_WRITE_TIMEOUT:\n    mysql->options.write_timeout= *(uint *)arg1;\n    break;\n  case MYSQL_REPORT_DATA_TRUNCATION:\n    mysql->options.report_data_truncation= *(my_bool *)arg1;\n    break;\n  case MYSQL_PROGRESS_CALLBACK:\n    CHECK_OPT_EXTENSION_SET(&mysql->options);\n    if (mysql->options.extension)\n      mysql->options.extension->report_progress=\n        (void (*)(const MYSQL *, uint, uint, double, const char *, uint)) arg1;\n    break;\n  case MYSQL_SERVER_PUBLIC_KEY:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, server_public_key, (char *)arg1);\n    break;\n  case MYSQL_PLUGIN_DIR:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, plugin_dir, (char *)arg1);\n    break;\n  case MYSQL_DEFAULT_AUTH:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, default_auth, (char *)arg1);\n    break;\n  case MYSQL_OPT_NONBLOCK:\n    if (mysql->options.extension &&\n        (ctxt = mysql->options.extension->async_context) != 0)\n    {\n      /*\n        We must not allow changing the stack size while a non-blocking call is\n        suspended (as the stack is then in use).\n      */\n      if (ctxt->suspended)\n        goto end;\n      my_context_destroy(&ctxt->async_context);\n      free(ctxt);\n    }\n    if (!(ctxt= (struct mysql_async_context *)\n          calloc(1, sizeof(*ctxt))))\n    {\n      SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n      goto end;\n    }\n    stacksize= 0;\n    if (arg1)\n      stacksize= *(const size_t *)arg1;\n    if (!stacksize)\n      stacksize= ASYNC_CONTEXT_DEFAULT_STACK_SIZE;\n    if (my_context_init(&ctxt->async_context, stacksize))\n    {\n      free(ctxt);\n      goto end;\n    }\n    if (!mysql->options.extension)\n      if(!(mysql->options.extension= (struct st_mysql_options_extension *)\n        calloc(1, sizeof(struct st_mysql_options_extension))))\n      {\n        free(ctxt);\n        SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n    mysql->options.extension->async_context= ctxt;\n    break;\n  case MYSQL_OPT_MAX_ALLOWED_PACKET:\n    if (mysql)\n      mysql->options.max_allowed_packet= (unsigned long)(*(size_t *)arg1);\n    else\n      max_allowed_packet= (unsigned long)(*(size_t *)arg1);\n    break;\n  case MYSQL_OPT_NET_BUFFER_LENGTH:\n    net_buffer_length= (unsigned long)(*(size_t *)arg1);\n    break;\n  case MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS:\n    if (*(my_bool *)arg1)\n      mysql->options.client_flag |= CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS;\n    else\n      mysql->options.client_flag &= ~CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS;\n    break;\n  case MYSQL_OPT_SSL_ENFORCE:\n    mysql->options.use_ssl= (*(my_bool *)arg1);\n    break;\n  case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:\n    if (*(my_bool *)arg1)\n      mysql->options.client_flag |= CLIENT_SSL_VERIFY_SERVER_CERT;\n    else\n      mysql->options.client_flag &= ~CLIENT_SSL_VERIFY_SERVER_CERT;\n    break;\n  case MYSQL_OPT_SSL_KEY:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_key, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CERT:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_cert, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CA:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_ca, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CAPATH:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_capath, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CIPHER:\n    OPT_SET_VALUE_STR(&mysql->options, ssl_cipher, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CRL:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, ssl_crl, (char *)arg1);\n    break;\n  case MYSQL_OPT_SSL_CRLPATH:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, ssl_crlpath, (char *)arg1);\n    break;\n  case MYSQL_OPT_CONNECT_ATTR_DELETE:\n    {\n      uchar *h;\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      if (hash_inited(&mysql->options.extension->connect_attrs) &&\n          (h= (uchar *)hash_search(&mysql->options.extension->connect_attrs, (uchar *)arg1,\n                      arg1 ? (uint)strlen((char *)arg1) : 0)))\n      {\n        uchar *p= h;\n        size_t key_len= strlen((char *)p);\n        mysql->options.extension->connect_attrs_len-= key_len + get_store_length(key_len);\n        p+= key_len + 1;\n        key_len= strlen((char *)p);\n        mysql->options.extension->connect_attrs_len-= key_len + get_store_length(key_len);\n        hash_delete(&mysql->options.extension->connect_attrs, h);\n      }\n\n    }\n    break;\n  case MYSQL_OPT_CONNECT_ATTR_RESET:\n    CHECK_OPT_EXTENSION_SET(&mysql->options);\n    if (hash_inited(&mysql->options.extension->connect_attrs))\n    {\n      hash_free(&mysql->options.extension->connect_attrs);\n      mysql->options.extension->connect_attrs_len= 0;\n    }\n    break;\n  case MARIADB_OPT_CONNECTION_HANDLER:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, connection_handler, (char *)arg1);\n    break;\n  case MARIADB_OPT_PORT:\n    OPT_SET_VALUE_INT(&mysql->options, port, *((uint *)arg1));\n    break;\n  case MARIADB_OPT_UNIXSOCKET:\n    OPT_SET_VALUE_STR(&mysql->options, unix_socket, arg1);\n    break;\n  case MARIADB_OPT_USER:\n    OPT_SET_VALUE_STR(&mysql->options, user, arg1);\n    break;\n  case MARIADB_OPT_HOST:\n    OPT_SET_VALUE_STR(&mysql->options, host, arg1);\n    break;\n  case MARIADB_OPT_SCHEMA:\n    OPT_SET_VALUE_STR(&mysql->options, db, arg1);\n    break;\n  case MARIADB_OPT_DEBUG:\n    break;\n  case MARIADB_OPT_FOUND_ROWS:\n    mysql->options.client_flag|= CLIENT_FOUND_ROWS;\n    break;\n  case MARIADB_OPT_INTERACTIVE:\n    mysql->options.client_flag|= CLIENT_INTERACTIVE;\n    break;\n  case MARIADB_OPT_MULTI_RESULTS:\n    mysql->options.client_flag|= CLIENT_MULTI_RESULTS;\n    break;\n  case MARIADB_OPT_MULTI_STATEMENTS:\n    mysql->options.client_flag|= CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS;\n    break;\n  case MARIADB_OPT_PASSWORD:\n    OPT_SET_VALUE_STR(&mysql->options, password, arg1);\n    break;\n  case MARIADB_OPT_USERDATA:\n    {\n      void *data= va_arg(ap, void *);\n      uchar *buffer, *p;\n      char *key= (char *)arg1;\n\n      if (!key || !data)\n      {\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      if (!hash_inited(&mysql->options.extension->userdata))\n      {\n        if (_hash_init(&mysql->options.extension->userdata,\n                       0, 0, 0, ma_get_hash_keyval, ma_int_hash_free, 0))\n        {\n          SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n          goto end;\n        }\n      }\n      /* check if key is already in buffer */\n      p= (uchar *)hash_search(&mysql->options.extension->userdata, \n                              (uchar *)key,\n                              (uint)strlen(key));\n      if (p)\n      {\n        p+= strlen(key) + 1;\n        memcpy(p, &data, sizeof(void *));\n        break;\n      }\n\n      if (!(buffer= (uchar *)malloc(strlen(key) + 1 + sizeof(void *))))\n      {\n        SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n\n      p= buffer;\n      strcpy((char *)p, key);\n      p+= strlen(key) + 1;\n      memcpy(p, &data, sizeof(void *));\n\n      if (hash_insert(&mysql->options.extension->userdata, buffer))\n      {\n        free(buffer);\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n    }\n    break;\n  case MYSQL_OPT_CONNECT_ATTR_ADD:\n    {\n      uchar *buffer;\n      void *arg2= va_arg(ap, void *);\n      size_t storage_len, key_len= arg1 ? strlen((char *)arg1) : 0,\n             value_len= arg2 ? strlen((char *)arg2) : 0;\n      if (!key_len || !value_len)\n      {\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n      storage_len= key_len + value_len +\n                   get_store_length(key_len) +\n                   get_store_length(value_len);\n\n      /* since we store terminating zero character in hash, we need\n       * to increase lengths */\n      key_len++;\n      value_len++;\n\n      CHECK_OPT_EXTENSION_SET(&mysql->options);\n      if (!key_len ||\n          storage_len + mysql->options.extension->connect_attrs_len > 0xFFFF)\n      {\n        SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n\n      if (!hash_inited(&mysql->options.extension->connect_attrs))\n      {\n        if (_hash_init(&mysql->options.extension->connect_attrs,\n                       0, 0, 0, ma_get_hash_keyval, ma_int_hash_free, 0))\n        {\n          SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n          goto end;\n        }\n      }\n      if ((buffer= (uchar *)malloc(key_len + value_len)))\n      {\n        uchar *p= buffer;\n        strcpy((char *)p, arg1);\n        p+= (strlen(arg1) + 1);\n        if (arg2)\n          strcpy((char *)p, arg2);\n\n        if (hash_insert(&mysql->options.extension->connect_attrs, buffer))\n        {\n          free(buffer);\n          SET_CLIENT_ERROR(mysql, CR_INVALID_PARAMETER_NO, SQLSTATE_UNKNOWN, 0);\n          goto end;\n        }\n        mysql->options.extension->connect_attrs_len+= storage_len;\n      }\n      else\n      {\n        SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n        goto end;\n      }\n    }\n    break;\n  case MYSQL_ENABLE_CLEARTEXT_PLUGIN:\n    break;\n  case MYSQL_SECURE_AUTH:\n    mysql->options.secure_auth= *(my_bool *)arg1;\n    break;\n  case MYSQL_OPT_BIND:\n    OPT_SET_VALUE_STR(&mysql->options, bind_address, arg1);\n    break;\n  case MARIADB_OPT_TLS_CIPHER_STRENGTH:\n    OPT_SET_EXTENDED_VALUE_INT(&mysql->options, tls_cipher_strength, *((unsigned int *)arg1));\n    break;\n  case MARIADB_OPT_SSL_FP:\n  case MARIADB_OPT_TLS_PEER_FP:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_fp, (char *)arg1);\n    mysql->options.use_ssl= 1;\n    break;\n  case MARIADB_OPT_SSL_FP_LIST:\n  case MARIADB_OPT_TLS_PEER_FP_LIST:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_fp_list, (char *)arg1);\n    mysql->options.use_ssl= 1;\n    break;\n  case MARIADB_OPT_TLS_PASSPHRASE:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_pw, (char *)arg1);\n    break;\n  case MARIADB_OPT_CONNECTION_READ_ONLY:\n    OPT_SET_EXTENDED_VALUE_INT(&mysql->options, read_only, *(my_bool *)arg1);\n    break;\n  case MARIADB_OPT_PROXY_HEADER:\n    {\n    size_t arg2 = va_arg(ap, size_t);\n    OPT_SET_EXTENDED_VALUE(&mysql->options, proxy_header, (char *)arg1);\n    OPT_SET_EXTENDED_VALUE(&mysql->options, proxy_header_len, arg2);\n    }\n    break;\n  case MARIADB_OPT_TLS_VERSION:\n  case MYSQL_OPT_TLS_VERSION:\n    OPT_SET_EXTENDED_VALUE_STR(&mysql->options, tls_version, (char *)arg1);\n    break;\n  case MARIADB_OPT_IO_WAIT:\n    CHECK_OPT_EXTENSION_SET(&mysql->options);\n    mysql->options.extension->io_wait = (int(*)(my_socket, my_bool, int))arg1;\n    break;\n  default:\n    va_end(ap);\n    SET_CLIENT_ERROR(mysql, CR_NOT_IMPLEMENTED, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n  va_end(ap);\n  return(0);\nend:\n  va_end(ap);\n  return(1);\n}\n\nint\nmysql_get_optionv(MYSQL *mysql, enum mysql_option option, void *arg, ...)\n{\n  va_list ap;\n\n  va_start(ap, arg);\n\n  switch(option) {\n  case MYSQL_OPT_CONNECT_TIMEOUT:\n    *((uint *)arg)= mysql->options.connect_timeout;\n    break;\n  case MYSQL_OPT_COMPRESS:\n    *((my_bool *)arg)= mysql->options.compress;\n    break;\n  case MYSQL_OPT_NAMED_PIPE:\n    *((my_bool *)arg)= mysql->options.named_pipe;\n    break;\n  case MYSQL_OPT_LOCAL_INFILE:\t\t\t/* Allow LOAD DATA LOCAL ?*/\n    *((uint *)arg)= test(mysql->options.client_flag & CLIENT_LOCAL_FILES);\n    break;\n  case MYSQL_INIT_COMMAND:\n    /* mysql_get_optionsv(mysql, MYSQL_INIT_COMMAND, commands, elements) */\n    {\n      unsigned int *elements;\n      if (arg)\n        *((char **)arg)= mysql->options.init_command ? mysql->options.init_command->buffer : NULL;\n      if ((elements= va_arg(ap, unsigned int *)))\n        *elements= mysql->options.init_command ? mysql->options.init_command->elements : 0;\n    }\n    break;\n  case MYSQL_READ_DEFAULT_FILE:\n    *((char **)arg)= mysql->options.my_cnf_file;\n    break;\n  case MYSQL_READ_DEFAULT_GROUP:\n    *((char **)arg)= mysql->options.my_cnf_group;\n    break;\n  case MYSQL_SET_CHARSET_DIR:\n    /* not supported in this version. Since all character sets\n       are internally available, we don't throw an error */\n    *((char **)arg)= NULL;\n    break;\n  case MYSQL_SET_CHARSET_NAME:\n    if (mysql->charset)\n      *((const char **)arg)= mysql->charset->csname;\n    else\n      *((char **)arg)= mysql->options.charset_name;\n    break;\n  case MYSQL_OPT_RECONNECT:\n    *((my_bool *)arg)= mysql->options.reconnect;\n    break;\n  case MYSQL_OPT_PROTOCOL:\n    *((uint *)arg)= mysql->options.protocol;\n    break;\n  case MYSQL_OPT_READ_TIMEOUT:\n    *((uint *)arg)= mysql->options.read_timeout;\n    break;\n  case MYSQL_OPT_WRITE_TIMEOUT:\n    *((uint *)arg)= mysql->options.write_timeout;\n    break;\n  case MYSQL_REPORT_DATA_TRUNCATION:\n    *((my_bool *)arg)= mysql->options.report_data_truncation;\n    break;\n  case MYSQL_PROGRESS_CALLBACK:\n    *((void (**)(const MYSQL *, uint, uint, double, const char *, uint))arg)=\n       mysql->options.extension ?  mysql->options.extension->report_progress : NULL;\n    break;\n  case MYSQL_SERVER_PUBLIC_KEY:\n    *((char **)arg)= mysql->options.extension ?\n      mysql->options.extension->server_public_key : NULL;\n    break;\n  case MYSQL_PLUGIN_DIR:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->plugin_dir : NULL;\n    break;\n  case MYSQL_DEFAULT_AUTH:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->default_auth : NULL;\n    break;\n  case MYSQL_OPT_NONBLOCK:\n    *((my_bool *)arg)= test(mysql->options.extension && mysql->options.extension->async_context);\n    break;\n  case MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS:\n    *((my_bool *)arg)= test(mysql->options.client_flag & CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS);\n    break;\n  case MYSQL_OPT_SSL_ENFORCE:\n    *((my_bool *)arg)= mysql->options.use_ssl;\n    break;\n  case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:\n    *((my_bool *)arg)= test(mysql->options.client_flag & CLIENT_SSL_VERIFY_SERVER_CERT);\n    break;\n  case MYSQL_OPT_SSL_KEY:\n    *((char **)arg)= mysql->options.ssl_key;\n    break;\n  case MYSQL_OPT_SSL_CERT:\n    *((char **)arg)= mysql->options.ssl_cert;\n    break;\n  case MYSQL_OPT_SSL_CA:\n    *((char **)arg)= mysql->options.ssl_ca;\n    break;\n  case MYSQL_OPT_SSL_CAPATH:\n    *((char **)arg)= mysql->options.ssl_capath;\n    break;\n  case MYSQL_OPT_SSL_CIPHER:\n    *((char **)arg)= mysql->options.ssl_cipher;\n    break;\n  case MYSQL_OPT_SSL_CRL:\n    *((char **)arg)= mysql->options.extension ? mysql->options.ssl_cipher : NULL;\n    break;\n  case MYSQL_OPT_SSL_CRLPATH:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->ssl_crlpath : NULL;\n    break;\n  case MYSQL_OPT_CONNECT_ATTRS:\n    /* mysql_get_optionsv(mysql, MYSQL_OPT_CONNECT_ATTRS, keys, vals, elements) */\n    {\n      unsigned int i, *elements;\n      char **key= NULL;\n      void *arg1;\n      char **val= NULL;\n\n      if (arg)\n        key= *(char ***)arg;\n\n      arg1= va_arg(ap, char **);\n      if (arg1)\n        val= *(char ***)arg1;\n\n      if (!(elements= va_arg(ap, unsigned int *)))\n        goto error;\n\n      *elements= 0;\n\n      if (!mysql->options.extension ||\n          !hash_inited(&mysql->options.extension->connect_attrs))\n        break;\n\n      *elements= mysql->options.extension->connect_attrs.records;\n\n      if (val || key)\n      {\n        for (i=0; i < *elements; i++)\n        {\n          uchar *p= hash_element(&mysql->options.extension->connect_attrs, i);\n          if (key)\n            key[i]= (char *)p;\n          p+= strlen((char *)p) + 1;\n          if (val)\n            val[i]= (char *)p;\n        }\n      }\n    }\n    break;\n  case MYSQL_OPT_MAX_ALLOWED_PACKET:\n    *((unsigned long *)arg)= (mysql) ? mysql->options.max_allowed_packet :\n                                       max_allowed_packet;\n    break;\n  case MYSQL_OPT_NET_BUFFER_LENGTH:\n    *((unsigned long *)arg)= net_buffer_length;\n    break;\n  case MYSQL_SECURE_AUTH:\n    *((my_bool *)arg)= mysql->options.secure_auth;\n    break;\n  case MYSQL_OPT_BIND:\n    *((char **)arg)= mysql->options.bind_address;\n    break;\n  case MARIADB_OPT_TLS_CIPHER_STRENGTH:\n    *((unsigned int *)arg) = mysql->options.extension ? mysql->options.extension->tls_cipher_strength : 0;\n    break;\n  case MARIADB_OPT_SSL_FP:\n  case MARIADB_OPT_TLS_PEER_FP:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->tls_fp : NULL;\n    break;\n  case MARIADB_OPT_SSL_FP_LIST:\n  case MARIADB_OPT_TLS_PEER_FP_LIST:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->tls_fp_list : NULL;\n    break;\n  case MARIADB_OPT_TLS_PASSPHRASE:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->tls_pw : NULL;\n    break;\n  case MARIADB_OPT_CONNECTION_READ_ONLY:\n    *((my_bool *)arg)= mysql->options.extension ? mysql->options.extension->read_only : 0;\n    break;\n  case MARIADB_OPT_USERDATA:\n    /* nysql_get_optionv(mysql, MARIADB_OPT_USERDATA, key, value) */\n    {\n      uchar *p;\n      void *data= va_arg(ap, void *);\n      char *key= (char *)arg;\n      if (key && data && mysql->options.extension && hash_inited(&mysql->options.extension->userdata) &&\n          (p= (uchar *)hash_search(&mysql->options.extension->userdata, (uchar *)key,\n                      (uint)strlen((char *)key))))\n      {\n        p+= strlen(key) + 1;\n        *((void **)data)= *((void **)p);\n        break;\n      }\n      if (data)\n        *((void **)data)= NULL;\n    }\n    break;\n  case MARIADB_OPT_CONNECTION_HANDLER:\n    *((char **)arg)= mysql->options.extension ? mysql->options.extension->connection_handler : NULL;\n    break;\n  case MARIADB_OPT_IO_WAIT:\n    *((int(**)(my_socket, my_bool, int))arg) = mysql->options.extension ? mysql->options.extension->io_wait : NULL;\n    break;\n  default:\n    va_end(ap);\n    SET_CLIENT_ERROR(mysql, CR_NOT_IMPLEMENTED, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n  va_end(ap);\n  return(0);\nerror:\n  va_end(ap);\n  return(1);\n}\n\nint STDCALL mysql_get_option(MYSQL *mysql, enum mysql_option option, void *arg)\n{\n  return mysql_get_optionv(mysql, option, arg);\n}\n\nint STDCALL\nmysql_options(MYSQL *mysql,enum mysql_option option, const void *arg)\n{\n  return mysql_optionsv(mysql, option, arg);\n}\n\nint STDCALL\nmysql_options4(MYSQL *mysql,enum mysql_option option, const void *arg1, const void *arg2)\n{\n  return mysql_optionsv(mysql, option, arg1, arg2);\n}\n/****************************************************************************\n** Functions to get information from the MySQL structure\n** These are functions to make shared libraries more usable.\n****************************************************************************/\n\n/* MYSQL_RES */\nmy_ulonglong STDCALL mysql_num_rows(MYSQL_RES *res)\n{\n  return res->row_count;\n}\n\nunsigned int STDCALL mysql_num_fields(MYSQL_RES *res)\n{\n  return res->field_count;\n}\n\n/* deprecated */\nmy_bool STDCALL mysql_eof(MYSQL_RES *res)\n{\n  return res->eof;\n}\n\nMYSQL_FIELD * STDCALL mysql_fetch_field_direct(MYSQL_RES *res,uint fieldnr)\n{\n  return &(res)->fields[fieldnr];\n}\n\nMYSQL_FIELD * STDCALL mysql_fetch_fields(MYSQL_RES *res)\n{\n  return (res)->fields;\n}\n\nMYSQL_ROWS * STDCALL mysql_row_tell(MYSQL_RES *res)\n{\n  return res->data_cursor;\n}\n\nuint STDCALL mysql_field_tell(MYSQL_RES *res)\n{\n  return (res)->current_field;\n}\n\n/* MYSQL */\n\nunsigned int STDCALL mysql_field_count(MYSQL *mysql)\n{\n  return mysql->field_count;\n}\n\nmy_ulonglong STDCALL mysql_affected_rows(MYSQL *mysql)\n{\n  return (mysql)->affected_rows;\n}\n\nmy_bool STDCALL mysql_autocommit(MYSQL *mysql, my_bool mode)\n{\n  return((my_bool) mysql_real_query(mysql, (mode) ? \"SET autocommit=1\" :\n                                         \"SET autocommit=0\", 16));\n}\n\nmy_bool STDCALL mysql_commit(MYSQL *mysql)\n{\n  return((my_bool)mysql_real_query(mysql, \"COMMIT\", (unsigned long)strlen(\"COMMIT\")));\n}\n\nmy_bool STDCALL mysql_rollback(MYSQL *mysql)\n{\n  return((my_bool)mysql_real_query(mysql, \"ROLLBACK\", (unsigned long)strlen(\"ROLLBACK\")));\n}\n\nmy_ulonglong STDCALL mysql_insert_id(MYSQL *mysql)\n{\n  return (mysql)->insert_id;\n}\n\nuint STDCALL mysql_errno(MYSQL *mysql)\n{\n  return mysql ? mysql->net.last_errno : 0;\n}\n\nconst char * STDCALL mysql_error(MYSQL *mysql)\n{\n  return mysql ? (mysql)->net.last_error : (char *)\"\";\n}\n\nconst char *STDCALL mysql_info(MYSQL *mysql)\n{\n  return (mysql)->info;\n}\n\nmy_bool STDCALL mysql_more_results(MYSQL *mysql)\n{\n  return(test(mysql->server_status & SERVER_MORE_RESULTS_EXIST));\n}\n\nint STDCALL mysql_next_result(MYSQL *mysql)\n{\n\n  /* make sure communication is not blocking */\n  if (mysql->status != MYSQL_STATUS_READY)\n  {\n    SET_CLIENT_ERROR(mysql, CR_COMMANDS_OUT_OF_SYNC, SQLSTATE_UNKNOWN, 0);\n    return(1);\n  }\n\n  /* clear error, and mysql status variables */\n  CLEAR_CLIENT_ERROR(mysql);\n  mysql->affected_rows = (ulonglong) ~0;\n\n  if (mysql->server_status & SERVER_MORE_RESULTS_EXIST)\n  {\n     return(mysql->methods->db_read_query_result(mysql));\n  }\n\n  return(-1);\n}\n\nulong STDCALL mysql_thread_id(MYSQL *mysql)\n{\n  return (mysql)->thread_id;\n}\n\nconst char * STDCALL mysql_character_set_name(MYSQL *mysql)\n{\n  return mysql->charset->csname;\n}\n\n\nuint STDCALL mysql_thread_safe(void)\n{\n#ifdef THREAD\n  return 1;\n#else\n  return 0;\n#endif\n}\n\n/****************************************************************************\n** Some support functions\n****************************************************************************/\n\n/*\n** Add escape characters to a string (blob?) to make it suitable for a insert\n** to should at least have place for length*2+1 chars\n** Returns the length of the to string\n*/\n\nulong STDCALL\nmysql_escape_string(char *to,const char *from, ulong length)\n{\n    return (ulong)mysql_cset_escape_slashes(ma_default_charset_info, to, from, length);\n}\n\nulong STDCALL\nmysql_real_escape_string(MYSQL *mysql, char *to,const char *from,\n\t\t\t ulong length)\n{\n  if (mysql->server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES)\n    return (ulong)mysql_cset_escape_quotes(mysql->charset, to, from, length);\n  else\n    return (ulong)mysql_cset_escape_slashes(mysql->charset, to, from, length);\n}\n\nstatic void mariadb_get_charset_info(MYSQL *mysql, MY_CHARSET_INFO *cs)\n{\n  if (!cs)\n    return;\n\n  cs->number= mysql->charset->nr;\n  cs->csname=  mysql->charset->csname;\n  cs->name= mysql->charset->name;\n  cs->state= 0;\n  cs->comment= NULL;\n  cs->dir= NULL;\n  cs->mbminlen= mysql->charset->char_minlen;\n  cs->mbmaxlen= mysql->charset->char_maxlen;\n\n  return;\n}\n\nvoid STDCALL mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *cs)\n{\n  mariadb_get_charset_info(mysql, cs);\n}\n\nint STDCALL mysql_set_character_set(MYSQL *mysql, const char *csname)\n{\n  const MARIADB_CHARSET_INFO *cs;\n\n  if (!csname)\n    goto error;\n\n  if ((cs= mysql_find_charset_name(csname)))\n  {\n    char buff[64];\n\n    snprintf(buff, 63, \"SET NAMES %s\", cs->csname);\n    if (!mysql_real_query(mysql, buff, (unsigned long)strlen(buff)))\n    {\n      mysql->charset= cs;\n      return(0);\n    }\n    return(mysql->net.last_errno);\n  }\n\nerror:\n  my_set_error(mysql, CR_CANT_READ_CHARSET, SQLSTATE_UNKNOWN,\n               0, csname, \"compiled_in\");\n  return(mysql->net.last_errno);\n}\n\nunsigned int STDCALL mysql_warning_count(MYSQL *mysql)\n{\n  return mysql->warning_count;\n}\n\nconst char * STDCALL mysql_sqlstate(MYSQL *mysql)\n{\n  return mysql->net.sqlstate;\n}\n\n#ifndef _WIN32\n#include <signal.h>\nstatic void ignore_sigpipe()\n{\n  signal(SIGPIPE, SIG_IGN);\n}\n#else\n#define ignore_sigpipe()\n#endif\n\n#ifdef _WIN32\nstatic int mysql_once_init()\n#else\nstatic void mysql_once_init()\n#endif\n{\n  ma_init();\t\t\t\t\t/* Will init threads */\n  init_client_errs();\n  get_default_configuration_dirs();\n  set_default_charset_by_name(MARIADB_DEFAULT_CHARSET, 0);\n  if (mysql_client_plugin_init())\n  {\n#ifdef _WIN32\n    return 1;\n#else\n    return;\n#endif\n  }\n  if (!mysql_port)\n  {\n#if !__has_feature(memory_sanitizer) /* work around MSAN deficiency */\n    struct servent *serv_ptr;\n#endif\n    char *env;\n\n    mysql_port = MARIADB_PORT;\n#if !__has_feature(memory_sanitizer) /* work around MSAN deficiency */\n    if ((serv_ptr = getservbyname(\"mysql\", \"tcp\")))\n      mysql_port = (uint)ntohs((ushort)serv_ptr->s_port);\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysql_port =(uint)atoi(env);\n  }\n  if (!mysql_unix_port)\n  {\n    char *env;\n#ifdef _WIN32\n    mysql_unix_port = (char*)MARIADB_NAMEDPIPE;\n#else\n    mysql_unix_port = (char*)MARIADB_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")) ||\n      (env = getenv(\"MARIADB_UNIX_PORT\")))\n      mysql_unix_port = env;\n  }\n  if (!mysql_ps_subsystem_initialized)\n    mysql_init_ps_subsystem();\n#ifdef HAVE_TLS\n  ma_tls_start(0, 0);\n#endif\n  ignore_sigpipe();\n  mysql_client_init = 1;\n#ifdef _WIN32\n  return 0;\n#endif\n}\n\n#ifdef _WIN32\nstatic INIT_ONCE init_once= INIT_ONCE_STATIC_INIT;\nBOOL CALLBACK win_init_once(\n  PINIT_ONCE InitOnce,\n  PVOID Parameter,\n  PVOID *lpContext)\n{\n  return !mysql_once_init();\n  return TRUE;\n}\n#else\nstatic pthread_once_t init_once = PTHREAD_ONCE_INIT;\n#endif\n\nint STDCALL mysql_server_init(int argc __attribute__((unused)),\n  char **argv __attribute__((unused)),\n  char **groups __attribute__((unused)))\n{\n#ifdef _WIN32\n  BOOL ret = InitOnceExecuteOnce(&init_once, win_init_once, NULL, NULL);\n  return ret? 0: 1;\n#else\n  return pthread_once(&init_once, mysql_once_init);\n#endif\n}\n\nvoid STDCALL mysql_server_end(void)\n{\n  if (!mysql_client_init)\n    return;\n\n  release_configuration_dirs();\n  mysql_client_plugin_deinit();\n\n  list_free(pvio_callback, 0);\n  if (ma_init_done)\n    ma_end(0);\n#ifdef HAVE_TLS\n  ma_pvio_tls_end();\n#endif\n  mysql_client_init= 0;\n  ma_init_done= 0;\n#ifdef WIN32\n  init_once = (INIT_ONCE)INIT_ONCE_STATIC_INIT;\n#else\n  init_once = (pthread_once_t)PTHREAD_ONCE_INIT;\n#endif\n}\n\nmy_bool STDCALL mysql_thread_init(void)\n{\n  return 0;\n}\n\nvoid STDCALL mysql_thread_end(void)\n{\n}\n\nint STDCALL mysql_set_server_option(MYSQL *mysql,\n                                    enum enum_mysql_set_option option)\n{\n  char buffer[2];\n  int2store(buffer, (uint)option);\n  return(ma_simple_command(mysql, COM_SET_OPTION, buffer, sizeof(buffer), 0, 0));\n}\n\nulong STDCALL mysql_get_client_version(void)\n{\n  return MARIADB_VERSION_ID;\n}\n\nulong STDCALL mysql_hex_string(char *to, const char *from, unsigned long len)\n{\n  char *start= to;\n  char hexdigits[]= \"0123456789ABCDEF\";\n\n  while (len--)\n  {\n    *to++= hexdigits[((unsigned char)*from) >> 4];\n    *to++= hexdigits[((unsigned char)*from) & 0x0F];\n    from++;\n  }\n  *to= 0;\n  return (ulong)(to - start);\n}\n\nmy_bool STDCALL mariadb_connection(MYSQL *mysql)\n{\n  return (strstr(mysql->server_version, \"MariaDB\") ||\n          strstr(mysql->server_version, \"-maria-\"));\n}\n\nconst char * STDCALL\nmysql_get_server_name(MYSQL *mysql)\n{\n  if (mysql->options.extension &&\n      mysql->options.extension->db_driver != NULL)\n    return mysql->options.extension->db_driver->name;\n  return mariadb_connection(mysql) ? \"MariaDB\" : \"MySQL\";\n}\n\nstatic my_socket mariadb_get_socket(MYSQL *mysql)\n{\n  my_socket sock= INVALID_SOCKET;\n  if (mysql->net.pvio)\n  {\n    ma_pvio_get_handle(mysql->net.pvio, &sock);\n\n  }\n  /* if an asynchronous connect is in progress, we need to obtain\n     pvio handle from async_context until the connection was\n     successfully established.\n  */\n  else if (mysql->options.extension && mysql->options.extension->async_context &&\n           mysql->options.extension->async_context->pvio)\n  {\n    ma_pvio_get_handle(mysql->options.extension->async_context->pvio, &sock);\n  }\n  return sock;\n}\n\nmy_socket STDCALL\nmysql_get_socket(MYSQL *mysql)\n{\n  return mariadb_get_socket(mysql);\n}\n\nMARIADB_CHARSET_INFO * STDCALL mariadb_get_charset_by_name(const char *csname)\n{\n  return (MARIADB_CHARSET_INFO *)mysql_find_charset_name(csname);\n}\n\nMARIADB_CHARSET_INFO * STDCALL mariadb_get_charset_by_nr(unsigned int csnr)\n{\n  return (MARIADB_CHARSET_INFO *)mysql_find_charset_nr(csnr);\n}\n\nmy_bool mariadb_get_infov(MYSQL *mysql, enum mariadb_value value, void *arg, ...)\n{\n  va_list ap;\n\n  va_start(ap, arg);\n\n  switch(value) {\n  case MARIADB_MAX_ALLOWED_PACKET:\n    *((size_t *)arg)= (size_t)max_allowed_packet;\n    break;\n  case MARIADB_NET_BUFFER_LENGTH:\n    *((size_t *)arg)= (size_t)net_buffer_length;\n    break;\n  case MARIADB_CONNECTION_ERROR_ID:\n    if (!mysql)\n      goto error;\n    *((unsigned int *)arg)= mysql->net.last_errno;\n    break;\n  case MARIADB_CONNECTION_ERROR:\n    if (!mysql)\n      goto error;\n    *((char **)arg)= mysql->net.last_error;\n    break;\n  case MARIADB_CONNECTION_SQLSTATE:\n    if (!mysql)\n      goto error;\n    *((char **)arg)= mysql->net.sqlstate;\n    break;\n  case MARIADB_CONNECTION_TLS_VERSION:\n    #ifdef HAVE_TLS\n    if (mysql && mysql->net.pvio && mysql->net.pvio->ctls)\n      *((char **)arg)= (char *)ma_pvio_tls_get_protocol_version(mysql->net.pvio->ctls);\n    else\n    #endif\n      goto error;\n    break;\n  case MARIADB_CONNECTION_TLS_VERSION_ID:\n    #ifdef HAVE_TLS\n    if (mysql && mysql->net.pvio && mysql->net.pvio->ctls)\n      *((unsigned int *)arg)= ma_pvio_tls_get_protocol_version_id(mysql->net.pvio->ctls);\n    else\n    #endif\n      goto error;\n    break;\n  case MARIADB_TLS_LIBRARY:\n#ifdef HAVE_TLS\n    *((const char **)arg)= tls_library_version;\n#else\n    *((const char **)arg)= \"Off\";\n#endif\n    break;\n  case MARIADB_CLIENT_VERSION:\n    *((const char **)arg)= MARIADB_CLIENT_VERSION_STR;\n    break;\n  case MARIADB_CLIENT_VERSION_ID:\n    *((size_t *)arg)= MARIADB_VERSION_ID;\n    break;\n  case MARIADB_CONNECTION_SERVER_VERSION:\n    if (mysql)\n      *((char **)arg)= mysql->server_version;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_TYPE:\n    if (mysql)\n      *((const char **)arg)= mariadb_connection(mysql) ? \"MariaDB\" : \"MySQL\";\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_VERSION_ID:\n    if (mysql)\n      *((size_t *)arg)= mariadb_server_version_id(mysql);\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_PROTOCOL_VERSION_ID:\n    if (mysql)\n      *((unsigned int *)arg)= mysql->protocol_version;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_MARIADB_CHARSET_INFO:\n    if (mysql)\n      mariadb_get_charset_info(mysql, (MY_CHARSET_INFO *)arg);\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SOCKET:\n    if (mysql)\n      *((my_socket *)arg)= mariadb_get_socket(mysql);\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_TYPE:\n    if (mysql  && mysql->net.pvio)\n      *((int *)arg)= (int)mysql->net.pvio->type;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_ASYNC_TIMEOUT_MS:\n    if (mysql && mysql->options.extension && mysql->options.extension->async_context)\n      *((unsigned int *)arg)= mysql->options.extension->async_context->timeout_value;\n    break;\n  case MARIADB_CONNECTION_ASYNC_TIMEOUT:\n    if (mysql && mysql->options.extension && mysql->options.extension->async_context)\n    {\n      unsigned int timeout= mysql->options.extension->async_context->timeout_value;\n      if (timeout > UINT_MAX - 999)\n        *((unsigned int *)arg)= (timeout - 1)/1000 + 1;\n      else\n        *((unsigned int *)arg)= (timeout+999)/1000;\n    }\n    break;\n  case MARIADB_CHARSET_NAME:\n    {\n      char *name;\n      name= va_arg(ap, char *);\n      if (name)\n        *((MARIADB_CHARSET_INFO **)arg)= (MARIADB_CHARSET_INFO *)mysql_find_charset_name(name);\n      else\n        goto error;\n    }\n    break;\n  case MARIADB_CHARSET_ID:\n    {\n      unsigned int nr;\n      nr= va_arg(ap, unsigned int);\n      *((MARIADB_CHARSET_INFO **)arg)= (MARIADB_CHARSET_INFO *)mysql_find_charset_nr(nr);\n    }\n    break;\n  case MARIADB_CONNECTION_SSL_CIPHER:\n    #ifdef HAVE_TLS\n    if (mysql && mysql->net.pvio && mysql->net.pvio->ctls)\n      *((char **)arg)= (char *)ma_pvio_tls_cipher(mysql->net.pvio->ctls);\n    else\n    #endif\n      goto error;\n    break;\n  case MARIADB_CLIENT_ERRORS:\n    *((char ***)arg)= (char **)client_errors;\n    break;\n  case MARIADB_CONNECTION_INFO:\n    if (mysql)\n      *((char **)arg)= (char *)mysql->info;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_PVIO_TYPE:\n    if (mysql && mysql->net.pvio)\n      *((unsigned int *)arg)= (unsigned int)mysql->net.pvio->type;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SCHEMA:\n    if (mysql)\n      *((char **)arg)= mysql->db;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_USER:\n    if (mysql)\n      *((char **)arg)= mysql->user;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_PORT:\n    if (mysql)\n      *((unsigned int *)arg)= mysql->port;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_UNIX_SOCKET:\n    if (mysql)\n      *((char **)arg)= mysql->unix_socket;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_HOST:\n    if (mysql)\n      *((char **)arg)= mysql->host;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_STATUS:\n    if (mysql)\n      *((unsigned int *)arg)= mysql->server_status;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_SERVER_CAPABILITIES:\n    if (mysql)\n      *((unsigned long *)arg)= mysql->server_capabilities;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_EXTENDED_SERVER_CAPABILITIES:\n    if (mysql)\n      *((unsigned long *)arg)= mysql->extension->mariadb_server_capabilities;\n    else\n      goto error;\n    break;\n  case MARIADB_CONNECTION_CLIENT_CAPABILITIES:\n    if (mysql)\n      *((unsigned long *)arg)= mysql->client_flag;\n    else\n      goto error;\n    break;\n  default:\n    va_end(ap);\n    return(-1);\n  }\n  va_end(ap);\n  return(0);\nerror:\n  va_end(ap);\n  return(-1);\n}\n\nmy_bool STDCALL mariadb_get_info(MYSQL *mysql, enum mariadb_value value, void *arg)\n{\n  return mariadb_get_infov(mysql, value, arg);\n}\n\n/*\n  Immediately aborts connection, making all subsequent read/write operations fail.\n  Does not invalidate memory used for mysql structure, nor closes any communication\n  channels - mysql_close is still needed.\n  Useful to break long query, in situation  sending KILL is not possible.\n*/\nint STDCALL mariadb_cancel(MYSQL *mysql)\n{\n  if (!mysql || !mysql->net.pvio || !mysql->net.pvio->methods || !mysql->net.pvio->methods->shutdown)\n  {\n    return 1;\n  }\n  else\n  {\n    MARIADB_PVIO *pvio = mysql->net.pvio;\n    return pvio->methods->shutdown(pvio);\n  }\n}\n\n/* compatibility functions for MariaDB */\nvoid STDCALL\nmysql_debug(const char *debug __attribute__((unused)))\n{\n  return;\n}\n\n/********************************************************************\n  mysql_net_ functions - low-level API to MySQL protocol\n*********************************************************************/\nulong STDCALL mysql_net_read_packet(MYSQL *mysql)\n{\n  return ma_net_safe_read(mysql);\n}\n\nulong STDCALL mysql_net_field_length(uchar **packet)\n{\n  return net_field_length(packet);\n}\n\nmy_bool STDCALL mysql_embedded(void)\n{\n#ifdef EMBEDDED_LIBRARY\n  return 1;\n#else\n  return 0;\n#endif\n}\n\nMYSQL_PARAMETERS *STDCALL\nmysql_get_parameters(void)\n{\n  return &mariadb_internal_parameters;\n}\n\nint STDCALL mysql_reset_connection(MYSQL *mysql)\n{\n  int rc;\n\n  /* check if connection handler is active */\n  if (IS_CONNHDLR_ACTIVE(mysql))\n  {\n    if (mysql->extension->conn_hdlr->plugin && mysql->extension->conn_hdlr->plugin->reset)\n      return(mysql->extension->conn_hdlr->plugin->reset(mysql));\n  }\n\n  /* skip result sets */\n  if (mysql->status == MYSQL_STATUS_USE_RESULT ||\n      mysql->status == MYSQL_STATUS_GET_RESULT ||\n      mysql->status & SERVER_MORE_RESULTS_EXIST)\n  {\n    mthd_my_skip_result(mysql);\n    mysql->status= MYSQL_STATUS_READY;\n  }\n\n  rc= ma_simple_command(mysql, COM_RESET_CONNECTION, 0, 0, 0, 0);\n  if (rc && mysql->options.reconnect)\n  {\n    /* There is no big sense in resetting but we need reconnect */\n    rc= ma_simple_command(mysql, COM_RESET_CONNECTION,0,0,0,0);\n  }\n  if (rc)\n    return 1;\n\n  /* reset the connection in all active statements */\n  ma_invalidate_stmts(mysql, \"mysql_reset_connection()\");\n  free_old_query(mysql);\n  mysql->status= MYSQL_STATUS_READY;\n  mysql->affected_rows= ~(my_ulonglong)0;\n  mysql->insert_id= 0;\n  return 0;\n}\n\n#undef STDCALL\n/* API functions for usage in dynamic plugins */\nstruct st_mariadb_api MARIADB_API=\n{\n  mysql_num_rows,\n  mysql_num_fields,\n  mysql_eof,\n  mysql_fetch_field_direct,\n  mysql_fetch_fields,\n  mysql_row_tell,\n  mysql_field_tell,\n  mysql_field_count,\n  mysql_more_results,\n  mysql_next_result,\n  mysql_affected_rows,\n  mysql_autocommit,\n  mysql_commit,\n  mysql_rollback,\n  mysql_insert_id,\n  mysql_errno,\n  mysql_error,\n  mysql_info,\n  mysql_thread_id,\n  mysql_character_set_name,\n  mysql_get_character_set_info,\n  mysql_set_character_set,\n  mariadb_get_infov,\n  mariadb_get_info,\n  mysql_init,\n  mysql_ssl_set,\n  mysql_get_ssl_cipher,\n  mysql_change_user,\n  mysql_real_connect,\n  mysql_close,\n  mysql_select_db,\n  mysql_query,\n  mysql_send_query,\n  mysql_read_query_result,\n  mysql_real_query,\n  mysql_shutdown,\n  mysql_dump_debug_info,\n  mysql_refresh,\n  mysql_kill,\n  mysql_ping,\n  mysql_stat,\n  mysql_get_server_info,\n  mysql_get_server_version,\n  mysql_get_host_info,\n  mysql_get_proto_info,\n  mysql_list_dbs,\n  mysql_list_tables,\n  mysql_list_fields,\n  mysql_list_processes,\n  mysql_store_result,\n  mysql_use_result,\n  mysql_options,\n  mysql_free_result,\n  mysql_data_seek,\n  mysql_row_seek,\n  mysql_field_seek,\n  mysql_fetch_row,\n  mysql_fetch_lengths,\n  mysql_fetch_field,\n  mysql_escape_string,\n  mysql_real_escape_string,\n  mysql_thread_safe,\n  mysql_warning_count,\n  mysql_sqlstate,\n  mysql_server_init,\n  mysql_server_end,\n  mysql_thread_end,\n  mysql_thread_init,\n  mysql_set_server_option,\n  mysql_get_client_info,\n  mysql_get_client_version,\n  mariadb_connection,\n  mysql_get_server_name,\n  mariadb_get_charset_by_name,\n  mariadb_get_charset_by_nr,\n  mariadb_convert_string,\n  mysql_optionsv,\n  mysql_get_optionv,\n  mysql_get_option,\n  mysql_hex_string,\n  mysql_get_socket,\n  mysql_get_timeout_value,\n  mysql_get_timeout_value_ms,\n  mariadb_reconnect,\n  mysql_stmt_init,\n  mysql_stmt_prepare,\n  mysql_stmt_execute,\n  mysql_stmt_fetch,\n  mysql_stmt_fetch_column,\n  mysql_stmt_store_result,\n  mysql_stmt_param_count,\n  mysql_stmt_attr_set,\n  mysql_stmt_attr_get,\n  mysql_stmt_bind_param,\n  mysql_stmt_bind_result,\n  mysql_stmt_close,\n  mysql_stmt_reset,\n  mysql_stmt_free_result,\n  mysql_stmt_send_long_data,\n  mysql_stmt_result_metadata,\n  mysql_stmt_param_metadata,\n  mysql_stmt_errno,\n  mysql_stmt_error,\n  mysql_stmt_sqlstate,\n  mysql_stmt_row_seek,\n  mysql_stmt_row_tell,\n  mysql_stmt_data_seek,\n  mysql_stmt_num_rows,\n  mysql_stmt_affected_rows,\n  mysql_stmt_insert_id,\n  mysql_stmt_field_count,\n  mysql_stmt_next_result,\n  mysql_stmt_more_results,\n  mariadb_stmt_execute_direct,\n  mysql_reset_connection\n};\n\n/*\n * Default methods for a connection. These methods are\n * stored in mysql->methods and can be overwritten by\n * a plugin, e.g. for using another database\n */\nstruct st_mariadb_methods MARIADB_DEFAULT_METHODS = {\n  /* open a connection */\n  mthd_my_real_connect,\n  /* close connection */\n  mysql_close_slow_part,\n  /* send command to server */\n  mthd_my_send_cmd,\n  /* skip result set */\n  mthd_my_skip_result,\n  /* read response packet */\n  mthd_my_read_query_result,\n  /* read all rows from a result set */\n  mthd_my_read_rows,\n  /* read one/next row */\n  mthd_my_read_one_row,\n  /* check if datatype is supported */\n  mthd_supported_buffer_type,\n  /* read response packet from prepare */\n  mthd_stmt_read_prepare_response,\n  /* read response from stmt execute */\n  mthd_my_read_query_result,\n  /* get result set metadata for a prepared statement */\n  mthd_stmt_get_result_metadata,\n  /* get param metadata for a prepared statement */\n  mthd_stmt_get_param_metadata,\n  /* read all rows (buffered) */\n  mthd_stmt_read_all_rows,\n  /* fetch one row (unbuffered) */\n  mthd_stmt_fetch_row,\n  /* store values in bind buffer */\n  mthd_stmt_fetch_to_bind,\n  /* skip unbuffered stmt result */\n  mthd_stmt_flush_unbuffered,\n  /* set error */\n  my_set_error,\n  /* invalidate statements */\n  ma_invalidate_stmts,\n  /* API functions */\n  &MARIADB_API\n};\n"], "filenames": ["libmariadb/mariadb_lib.c"], "buggy_code_start_loc": [82], "buggy_code_end_loc": [2269], "fixing_code_start_loc": [83], "fixing_code_end_loc": [2287], "type": "NVD-CWE-noinfo", "message": "libmariadb/mariadb_lib.c in MariaDB Connector/C before 3.1.8 does not properly validate the content of an OK packet received from a server. NOTE: although mariadb_lib.c was originally based on code shipped for MySQL, this issue does not affect any MySQL components supported by Oracle.", "other": {"cve": {"id": "CVE-2020-13249", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-20T19:15:09.163", "lastModified": "2022-11-16T03:42:36.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libmariadb/mariadb_lib.c in MariaDB Connector/C before 3.1.8 does not properly validate the content of an OK packet received from a server. NOTE: although mariadb_lib.c was originally based on code shipped for MySQL, this issue does not affect any MySQL components supported by Oracle."}, {"lang": "es", "value": "La biblioteca libmariadb/mariadb_lib.c en MariaDB Connector/C versiones anteriores a 3.1.8 no comprueba apropiadamente el contenido de un paquete OK recibido desde un servidor. NOTA: aunque mariadb_lib.c se bas\u00f3 originalmente en el c\u00f3digo enviado para MySQL, este problema no afecta a ning\u00fan componente de MySQL soportado por Oracle."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:connector\\/c:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.8", "matchCriteriaId": "CE42BA11-5EE2-4277-8C91-2C04ED961357"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00064.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00054.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/mariadb-corporation/mariadb-connector-c/commit/2759b87d72926b7c9b5426437a7c8dd15ff57945", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mariadb-corporation/mariadb-connector-c/compare/v3.1.7...v3.1.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UW2ED32VEUHXFN2J3YQE27JIBV4SC2PI/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X4X2BMF3EILMTXGOZDTPYS3KT5VWLA2P/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mariadb-corporation/mariadb-connector-c/commit/2759b87d72926b7c9b5426437a7c8dd15ff57945"}}