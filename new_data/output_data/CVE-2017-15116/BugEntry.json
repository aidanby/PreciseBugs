{"buggy_code": ["/*\n * Cryptographic API.\n *\n * RNG operations.\n *\n * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/atomic.h>\n#include <crypto/internal/rng.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/cryptouser.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\nstatic DEFINE_MUTEX(crypto_default_rng_lock);\nstruct crypto_rng *crypto_default_rng;\nEXPORT_SYMBOL_GPL(crypto_default_rng);\nstatic int crypto_default_rng_refcnt;\n\nstatic inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n{\n\treturn container_of(tfm, struct crypto_rng, base);\n}\n\nstatic inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}\n\nstatic int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}\n\nstatic int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\n\tkzfree(buf);\n\treturn err;\n}\n\nint crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\n\terr = tfm->seed(tfm, seed, slen);\n\n\tkfree(buf);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_rng_reset);\n\nstatic int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\n\treturn 0;\n}\n\nstatic unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}\n\n#ifdef CONFIG_NET\nstatic int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.seedsize = seedsize(alg);\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n#else\nstatic int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}\n#endif\n\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n\t__attribute__ ((unused));\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tseq_printf(m, \"type         : rng\\n\");\n\tseq_printf(m, \"seedsize     : %u\\n\", seedsize(alg));\n}\n\nconst struct crypto_type crypto_rng_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_rng_init_tfm,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_rng_show,\n#endif\n\t.report = crypto_rng_report,\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_MASK,\n\t.type = CRYPTO_ALG_TYPE_RNG,\n\t.tfmsize = offsetof(struct crypto_rng, base),\n};\nEXPORT_SYMBOL_GPL(crypto_rng_type);\n\nstruct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_rng);\n\nint crypto_get_default_rng(void)\n{\n\tstruct crypto_rng *rng;\n\tint err;\n\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!crypto_default_rng) {\n\t\trng = crypto_alloc_rng(\"stdrng\", 0, 0);\n\t\terr = PTR_ERR(rng);\n\t\tif (IS_ERR(rng))\n\t\t\tgoto unlock;\n\n\t\terr = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\t\tif (err) {\n\t\t\tcrypto_free_rng(rng);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcrypto_default_rng = rng;\n\t}\n\n\tcrypto_default_rng_refcnt++;\n\terr = 0;\n\nunlock:\n\tmutex_unlock(&crypto_default_rng_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_get_default_rng);\n\nvoid crypto_put_default_rng(void)\n{\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!--crypto_default_rng_refcnt) {\n\t\tcrypto_free_rng(crypto_default_rng);\n\t\tcrypto_default_rng = NULL;\n\t}\n\tmutex_unlock(&crypto_default_rng_lock);\n}\nEXPORT_SYMBOL_GPL(crypto_put_default_rng);\n\nint crypto_register_rng(struct rng_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (alg->seedsize > PAGE_SIZE / 8)\n\t\treturn -EINVAL;\n\n\tbase->cra_type = &crypto_rng_type;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_RNG;\n\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_rng);\n\nvoid crypto_unregister_rng(struct rng_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_rng);\n\nint crypto_register_rngs(struct rng_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_rng(algs + i);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_register_rngs);\n\nvoid crypto_unregister_rngs(struct rng_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_rngs);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Random Number Generator\");\n", "/*\n * RNG: Random Number Generator  algorithms under the crypto API\n *\n * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#ifndef _CRYPTO_INTERNAL_RNG_H\n#define _CRYPTO_INTERNAL_RNG_H\n\n#include <crypto/algapi.h>\n#include <crypto/rng.h>\n\nextern const struct crypto_type crypto_rng_type;\n\nint crypto_register_rng(struct rng_alg *alg);\nvoid crypto_unregister_rng(struct rng_alg *alg);\nint crypto_register_rngs(struct rng_alg *algs, int count);\nvoid crypto_unregister_rngs(struct rng_alg *algs, int count);\n\nstatic inline void *crypto_rng_ctx(struct crypto_rng *tfm)\n{\n\treturn crypto_tfm_ctx(&tfm->base);\n}\n\nstatic inline void crypto_rng_set_entropy(struct crypto_rng *tfm,\n\t\t\t\t\t  const u8 *data, unsigned int len)\n{\n\tcrypto_rng_alg(tfm)->set_ent(tfm, data, len);\n}\n\n#endif\n", "/*\n * RNG: Random Number Generator  algorithms under the crypto API\n *\n * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#ifndef _CRYPTO_RNG_H\n#define _CRYPTO_RNG_H\n\n#include <linux/crypto.h>\n\nstruct crypto_rng;\n\n/**\n * struct rng_alg - random number generator definition\n *\n * @generate:\tThe function defined by this variable obtains a\n *\t\trandom number. The random number generator transform\n *\t\tmust generate the random number out of the context\n *\t\tprovided with this call, plus any additional data\n *\t\tif provided to the call.\n * @seed:\tSeed or reseed the random number generator.  With the\n *\t\tinvocation of this function call, the random number\n *\t\tgenerator shall become ready fo generation.  If the\n *\t\trandom number generator requires a seed for setting\n *\t\tup a new state, the seed must be provided by the\n *\t\tconsumer while invoking this function. The required\n *\t\tsize of the seed is defined with @seedsize .\n * @set_ent:\tSet entropy that would otherwise be obtained from\n *\t\tentropy source.  Internal use only.\n * @seedsize:\tThe seed size required for a random number generator\n *\t\tinitialization defined with this variable. Some\n *\t\trandom number generators does not require a seed\n *\t\tas the seeding is implemented internally without\n *\t\tthe need of support by the consumer. In this case,\n *\t\tthe seed size is set to zero.\n * @base:\tCommon crypto API algorithm data structure.\n */\nstruct rng_alg {\n\tint (*generate)(struct crypto_rng *tfm,\n\t\t\tconst u8 *src, unsigned int slen,\n\t\t\tu8 *dst, unsigned int dlen);\n\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n\tvoid (*set_ent)(struct crypto_rng *tfm, const u8 *data,\n\t\t\tunsigned int len);\n\n\tunsigned int seedsize;\n\n\tstruct crypto_alg base;\n};\n\nstruct crypto_rng {\n\tint (*generate)(struct crypto_rng *tfm,\n\t\t\tconst u8 *src, unsigned int slen,\n\t\t\tu8 *dst, unsigned int dlen);\n\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n\tunsigned int seedsize;\n\tstruct crypto_tfm base;\n};\n\nextern struct crypto_rng *crypto_default_rng;\n\nint crypto_get_default_rng(void);\nvoid crypto_put_default_rng(void);\n\n/**\n * DOC: Random number generator API\n *\n * The random number generator API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_RNG (listed as type \"rng\" in /proc/crypto)\n */\n\n/**\n * crypto_alloc_rng() -- allocate RNG handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      message digest cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a random number generator. The returned struct\n * crypto_rng is the cipher handle that is required for any subsequent\n * API invocation for that random number generator.\n *\n * For all random number generators, this call creates a new private copy of\n * the random number generator that does not share a state with other\n * instances. The only exception is the \"krng\" random number generator which\n * is a kernel crypto API use case for the get_random_bytes() function of the\n * /dev/random driver.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstruct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_rng_tfm(struct crypto_rng *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_rng_alg - obtain name of RNG\n * @tfm: cipher handle\n *\n * Return the generic name (cra_name) of the initialized random number generator\n *\n * Return: generic name string\n */\nstatic inline struct rng_alg *crypto_rng_alg(struct crypto_rng *tfm)\n{\n\treturn container_of(crypto_rng_tfm(tfm)->__crt_alg,\n\t\t\t    struct rng_alg, base);\n}\n\n/**\n * crypto_free_rng() - zeroize and free RNG handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_rng(struct crypto_rng *tfm)\n{\n\tcrypto_destroy_tfm(tfm, crypto_rng_tfm(tfm));\n}\n\n/**\n * crypto_rng_generate() - get random number\n * @tfm: cipher handle\n * @src: Input buffer holding additional data, may be NULL\n * @slen: Length of additional data\n * @dst: output buffer holding the random numbers\n * @dlen: length of the output buffer\n *\n * This function fills the caller-allocated buffer with random\n * numbers using the random number generator referenced by the\n * cipher handle.\n *\n * Return: 0 function was successful; < 0 if an error occurred\n */\nstatic inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}\n\n/**\n * crypto_rng_get_bytes() - get random number\n * @tfm: cipher handle\n * @rdata: output buffer holding the random numbers\n * @dlen: length of the output buffer\n *\n * This function fills the caller-allocated buffer with random numbers using the\n * random number generator referenced by the cipher handle.\n *\n * Return: 0 function was successful; < 0 if an error occurred\n */\nstatic inline int crypto_rng_get_bytes(struct crypto_rng *tfm,\n\t\t\t\t       u8 *rdata, unsigned int dlen)\n{\n\treturn crypto_rng_generate(tfm, NULL, 0, rdata, dlen);\n}\n\n/**\n * crypto_rng_reset() - re-initialize the RNG\n * @tfm: cipher handle\n * @seed: seed input data\n * @slen: length of the seed input data\n *\n * The reset function completely re-initializes the random number generator\n * referenced by the cipher handle by clearing the current state. The new state\n * is initialized with the caller provided seed or automatically, depending\n * on the random number generator type (the ANSI X9.31 RNG requires\n * caller-provided seed, the SP800-90A DRBGs perform an automatic seeding).\n * The seed is provided as a parameter to this function call. The provided seed\n * should have the length of the seed size defined for the random number\n * generator as defined by crypto_rng_seedsize.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nint crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t     unsigned int slen);\n\n/**\n * crypto_rng_seedsize() - obtain seed size of RNG\n * @tfm: cipher handle\n *\n * The function returns the seed size for the random number generator\n * referenced by the cipher handle. This value may be zero if the random\n * number generator does not implement or require a reseeding. For example,\n * the SP800-90A DRBGs implement an automated reseeding after reaching a\n * pre-defined threshold.\n *\n * Return: seed size for the random number generator\n */\nstatic inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}\n\n#endif\n", "/*\n * Scatterlist Cryptographic API.\n *\n * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>\n * Copyright (c) 2002 David S. Miller (davem@redhat.com)\n * Copyright (c) 2005 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * Portions derived from Cryptoapi, by Alexander Kjeldaas <astor@fast.no>\n * and Nettle, by Niels M\u00f6ller.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) \n * any later version.\n *\n */\n#ifndef _LINUX_CRYPTO_H\n#define _LINUX_CRYPTO_H\n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n/*\n * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n * arbitrary modules to be loaded. Loading from userspace may still need the\n * unprefixed names, so retains those aliases as well.\n * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n * expands twice on the same line. Instead, use a separate base name for the\n * alias.\n */\n#define MODULE_ALIAS_CRYPTO(name)\t\\\n\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n\t\t__MODULE_INFO(alias, alias_crypto, \"crypto-\" name)\n\n/*\n * Algorithm masks and types.\n */\n#define CRYPTO_ALG_TYPE_MASK\t\t0x0000000f\n#define CRYPTO_ALG_TYPE_CIPHER\t\t0x00000001\n#define CRYPTO_ALG_TYPE_COMPRESS\t0x00000002\n#define CRYPTO_ALG_TYPE_AEAD\t\t0x00000003\n#define CRYPTO_ALG_TYPE_BLKCIPHER\t0x00000004\n#define CRYPTO_ALG_TYPE_ABLKCIPHER\t0x00000005\n#define CRYPTO_ALG_TYPE_GIVCIPHER\t0x00000006\n#define CRYPTO_ALG_TYPE_DIGEST\t\t0x00000008\n#define CRYPTO_ALG_TYPE_HASH\t\t0x00000008\n#define CRYPTO_ALG_TYPE_SHASH\t\t0x00000009\n#define CRYPTO_ALG_TYPE_AHASH\t\t0x0000000a\n#define CRYPTO_ALG_TYPE_RNG\t\t0x0000000c\n#define CRYPTO_ALG_TYPE_PCOMPRESS\t0x0000000f\n\n#define CRYPTO_ALG_TYPE_HASH_MASK\t0x0000000e\n#define CRYPTO_ALG_TYPE_AHASH_MASK\t0x0000000c\n#define CRYPTO_ALG_TYPE_BLKCIPHER_MASK\t0x0000000c\n\n#define CRYPTO_ALG_LARVAL\t\t0x00000010\n#define CRYPTO_ALG_DEAD\t\t\t0x00000020\n#define CRYPTO_ALG_DYING\t\t0x00000040\n#define CRYPTO_ALG_ASYNC\t\t0x00000080\n\n/*\n * Set this bit if and only if the algorithm requires another algorithm of\n * the same type to handle corner cases.\n */\n#define CRYPTO_ALG_NEED_FALLBACK\t0x00000100\n\n/*\n * This bit is set for symmetric key ciphers that have already been wrapped\n * with a generic IV generator to prevent them from being wrapped again.\n */\n#define CRYPTO_ALG_GENIV\t\t0x00000200\n\n/*\n * Set if the algorithm has passed automated run-time testing.  Note that\n * if there is no run-time testing for a given algorithm it is considered\n * to have passed.\n */\n\n#define CRYPTO_ALG_TESTED\t\t0x00000400\n\n/*\n * Set if the algorithm is an instance that is build from templates.\n */\n#define CRYPTO_ALG_INSTANCE\t\t0x00000800\n\n/* Set this bit if the algorithm provided is hardware accelerated but\n * not available to userspace via instruction set or so.\n */\n#define CRYPTO_ALG_KERN_DRIVER_ONLY\t0x00001000\n\n/*\n * Mark a cipher as a service implementation only usable by another\n * cipher and never by a normal user of the kernel crypto API\n */\n#define CRYPTO_ALG_INTERNAL\t\t0x00002000\n\n/*\n * Transform masks and values (for crt_flags).\n */\n#define CRYPTO_TFM_REQ_MASK\t\t0x000fff00\n#define CRYPTO_TFM_RES_MASK\t\t0xfff00000\n\n#define CRYPTO_TFM_REQ_WEAK_KEY\t\t0x00000100\n#define CRYPTO_TFM_REQ_MAY_SLEEP\t0x00000200\n#define CRYPTO_TFM_REQ_MAY_BACKLOG\t0x00000400\n#define CRYPTO_TFM_RES_WEAK_KEY\t\t0x00100000\n#define CRYPTO_TFM_RES_BAD_KEY_LEN   \t0x00200000\n#define CRYPTO_TFM_RES_BAD_KEY_SCHED \t0x00400000\n#define CRYPTO_TFM_RES_BAD_BLOCK_LEN \t0x00800000\n#define CRYPTO_TFM_RES_BAD_FLAGS \t0x01000000\n\n/*\n * Miscellaneous stuff.\n */\n#define CRYPTO_MAX_ALG_NAME\t\t64\n\n/*\n * The macro CRYPTO_MINALIGN_ATTR (along with the void * type in the actual\n * declaration) is used to ensure that the crypto_tfm context structure is\n * aligned correctly for the given architecture so that there are no alignment\n * faults for C data types.  In particular, this is required on platforms such\n * as arm where pointers are 32-bit aligned but there are data types such as\n * u64 which require 64-bit alignment.\n */\n#define CRYPTO_MINALIGN ARCH_KMALLOC_MINALIGN\n\n#define CRYPTO_MINALIGN_ATTR __attribute__ ((__aligned__(CRYPTO_MINALIGN)))\n\nstruct scatterlist;\nstruct crypto_ablkcipher;\nstruct crypto_async_request;\nstruct crypto_aead;\nstruct crypto_blkcipher;\nstruct crypto_hash;\nstruct crypto_rng;\nstruct crypto_tfm;\nstruct crypto_type;\nstruct aead_givcrypt_request;\nstruct skcipher_givcrypt_request;\n\ntypedef void (*crypto_completion_t)(struct crypto_async_request *req, int err);\n\n/**\n * DOC: Block Cipher Context Data Structures\n *\n * These data structures define the operating context for each block cipher\n * type.\n */\n\nstruct crypto_async_request {\n\tstruct list_head list;\n\tcrypto_completion_t complete;\n\tvoid *data;\n\tstruct crypto_tfm *tfm;\n\n\tu32 flags;\n};\n\nstruct ablkcipher_request {\n\tstruct crypto_async_request base;\n\n\tunsigned int nbytes;\n\n\tvoid *info;\n\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\n/**\n *\tstruct aead_request - AEAD request\n *\t@base: Common attributes for async crypto requests\n *\t@assoclen: Length in bytes of associated data for authentication\n *\t@cryptlen: Length of data to be encrypted or decrypted\n *\t@iv: Initialisation vector\n *\t@assoc: Associated data\n *\t@src: Source data\n *\t@dst: Destination data\n *\t@__ctx: Start of private context data\n */\nstruct aead_request {\n\tstruct crypto_async_request base;\n\n\tunsigned int assoclen;\n\tunsigned int cryptlen;\n\n\tu8 *iv;\n\n\tstruct scatterlist *assoc;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct blkcipher_desc {\n\tstruct crypto_blkcipher *tfm;\n\tvoid *info;\n\tu32 flags;\n};\n\nstruct cipher_desc {\n\tstruct crypto_tfm *tfm;\n\tvoid (*crfn)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tunsigned int (*prfn)(const struct cipher_desc *desc, u8 *dst,\n\t\t\t     const u8 *src, unsigned int nbytes);\n\tvoid *info;\n};\n\nstruct hash_desc {\n\tstruct crypto_hash *tfm;\n\tu32 flags;\n};\n\n/**\n * DOC: Block Cipher Algorithm Definitions\n *\n * These data structures define modular crypto algorithm implementations,\n * managed via crypto_register_alg() and crypto_unregister_alg().\n */\n\n/**\n * struct ablkcipher_alg - asynchronous block cipher definition\n * @min_keysize: Minimum key size supported by the transformation. This is the\n *\t\t smallest key length supported by this transformation algorithm.\n *\t\t This must be set to one of the pre-defined values as this is\n *\t\t not hardware specific. Possible values for this field can be\n *\t\t found via git grep \"_MIN_KEY_SIZE\" include/crypto/\n * @max_keysize: Maximum key size supported by the transformation. This is the\n *\t\t largest key length supported by this transformation algorithm.\n *\t\t This must be set to one of the pre-defined values as this is\n *\t\t not hardware specific. Possible values for this field can be\n *\t\t found via git grep \"_MAX_KEY_SIZE\" include/crypto/\n * @setkey: Set key for the transformation. This function is used to either\n *\t    program a supplied key into the hardware or store the key in the\n *\t    transformation context for programming it later. Note that this\n *\t    function does modify the transformation context. This function can\n *\t    be called multiple times during the existence of the transformation\n *\t    object, so one must make sure the key is properly reprogrammed into\n *\t    the hardware. This function is also responsible for checking the key\n *\t    length for validity. In case a software fallback was put in place in\n *\t    the @cra_init call, this function might need to use the fallback if\n *\t    the algorithm doesn't support all of the key sizes.\n * @encrypt: Encrypt a scatterlist of blocks. This function is used to encrypt\n *\t     the supplied scatterlist containing the blocks of data. The crypto\n *\t     API consumer is responsible for aligning the entries of the\n *\t     scatterlist properly and making sure the chunks are correctly\n *\t     sized. In case a software fallback was put in place in the\n *\t     @cra_init call, this function might need to use the fallback if\n *\t     the algorithm doesn't support all of the key sizes. In case the\n *\t     key was stored in transformation context, the key might need to be\n *\t     re-programmed into the hardware in this function. This function\n *\t     shall not modify the transformation context, as this function may\n *\t     be called in parallel with the same transformation object.\n * @decrypt: Decrypt a single block. This is a reverse counterpart to @encrypt\n *\t     and the conditions are exactly the same.\n * @givencrypt: Update the IV for encryption. With this function, a cipher\n *\t        implementation may provide the function on how to update the IV\n *\t        for encryption.\n * @givdecrypt: Update the IV for decryption. This is the reverse of\n *\t        @givencrypt .\n * @geniv: The transformation implementation may use an \"IV generator\" provided\n *\t   by the kernel crypto API. Several use cases have a predefined\n *\t   approach how IVs are to be updated. For such use cases, the kernel\n *\t   crypto API provides ready-to-use implementations that can be\n *\t   referenced with this variable.\n * @ivsize: IV size applicable for transformation. The consumer must provide an\n *\t    IV of exactly that size to perform the encrypt or decrypt operation.\n *\n * All fields except @givencrypt , @givdecrypt , @geniv and @ivsize are\n * mandatory and must be filled.\n */\nstruct ablkcipher_alg {\n\tint (*setkey)(struct crypto_ablkcipher *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct ablkcipher_request *req);\n\tint (*decrypt)(struct ablkcipher_request *req);\n\tint (*givencrypt)(struct skcipher_givcrypt_request *req);\n\tint (*givdecrypt)(struct skcipher_givcrypt_request *req);\n\n\tconst char *geniv;\n\n\tunsigned int min_keysize;\n\tunsigned int max_keysize;\n\tunsigned int ivsize;\n};\n\n/**\n * struct aead_alg - AEAD cipher definition\n * @maxauthsize: Set the maximum authentication tag size supported by the\n *\t\t transformation. A transformation may support smaller tag sizes.\n *\t\t As the authentication tag is a message digest to ensure the\n *\t\t integrity of the encrypted data, a consumer typically wants the\n *\t\t largest authentication tag possible as defined by this\n *\t\t variable.\n * @setauthsize: Set authentication size for the AEAD transformation. This\n *\t\t function is used to specify the consumer requested size of the\n * \t\t authentication tag to be either generated by the transformation\n *\t\t during encryption or the size of the authentication tag to be\n *\t\t supplied during the decryption operation. This function is also\n *\t\t responsible for checking the authentication tag size for\n *\t\t validity.\n * @setkey: see struct ablkcipher_alg\n * @encrypt: see struct ablkcipher_alg\n * @decrypt: see struct ablkcipher_alg\n * @givencrypt: see struct ablkcipher_alg\n * @givdecrypt: see struct ablkcipher_alg\n * @geniv: see struct ablkcipher_alg\n * @ivsize: see struct ablkcipher_alg\n *\n * All fields except @givencrypt , @givdecrypt , @geniv and @ivsize are\n * mandatory and must be filled.\n */\nstruct aead_alg {\n\tint (*setkey)(struct crypto_aead *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*setauthsize)(struct crypto_aead *tfm, unsigned int authsize);\n\tint (*encrypt)(struct aead_request *req);\n\tint (*decrypt)(struct aead_request *req);\n\tint (*givencrypt)(struct aead_givcrypt_request *req);\n\tint (*givdecrypt)(struct aead_givcrypt_request *req);\n\n\tconst char *geniv;\n\n\tunsigned int ivsize;\n\tunsigned int maxauthsize;\n};\n\n/**\n * struct blkcipher_alg - synchronous block cipher definition\n * @min_keysize: see struct ablkcipher_alg\n * @max_keysize: see struct ablkcipher_alg\n * @setkey: see struct ablkcipher_alg\n * @encrypt: see struct ablkcipher_alg\n * @decrypt: see struct ablkcipher_alg\n * @geniv: see struct ablkcipher_alg\n * @ivsize: see struct ablkcipher_alg\n *\n * All fields except @geniv and @ivsize are mandatory and must be filled.\n */\nstruct blkcipher_alg {\n\tint (*setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct blkcipher_desc *desc,\n\t\t       struct scatterlist *dst, struct scatterlist *src,\n\t\t       unsigned int nbytes);\n\tint (*decrypt)(struct blkcipher_desc *desc,\n\t\t       struct scatterlist *dst, struct scatterlist *src,\n\t\t       unsigned int nbytes);\n\n\tconst char *geniv;\n\n\tunsigned int min_keysize;\n\tunsigned int max_keysize;\n\tunsigned int ivsize;\n};\n\n/**\n * struct cipher_alg - single-block symmetric ciphers definition\n * @cia_min_keysize: Minimum key size supported by the transformation. This is\n *\t\t     the smallest key length supported by this transformation\n *\t\t     algorithm. This must be set to one of the pre-defined\n *\t\t     values as this is not hardware specific. Possible values\n *\t\t     for this field can be found via git grep \"_MIN_KEY_SIZE\"\n *\t\t     include/crypto/\n * @cia_max_keysize: Maximum key size supported by the transformation. This is\n *\t\t    the largest key length supported by this transformation\n *\t\t    algorithm. This must be set to one of the pre-defined values\n *\t\t    as this is not hardware specific. Possible values for this\n *\t\t    field can be found via git grep \"_MAX_KEY_SIZE\"\n *\t\t    include/crypto/\n * @cia_setkey: Set key for the transformation. This function is used to either\n *\t        program a supplied key into the hardware or store the key in the\n *\t        transformation context for programming it later. Note that this\n *\t        function does modify the transformation context. This function\n *\t        can be called multiple times during the existence of the\n *\t        transformation object, so one must make sure the key is properly\n *\t        reprogrammed into the hardware. This function is also\n *\t        responsible for checking the key length for validity.\n * @cia_encrypt: Encrypt a single block. This function is used to encrypt a\n *\t\t single block of data, which must be @cra_blocksize big. This\n *\t\t always operates on a full @cra_blocksize and it is not possible\n *\t\t to encrypt a block of smaller size. The supplied buffers must\n *\t\t therefore also be at least of @cra_blocksize size. Both the\n *\t\t input and output buffers are always aligned to @cra_alignmask.\n *\t\t In case either of the input or output buffer supplied by user\n *\t\t of the crypto API is not aligned to @cra_alignmask, the crypto\n *\t\t API will re-align the buffers. The re-alignment means that a\n *\t\t new buffer will be allocated, the data will be copied into the\n *\t\t new buffer, then the processing will happen on the new buffer,\n *\t\t then the data will be copied back into the original buffer and\n *\t\t finally the new buffer will be freed. In case a software\n *\t\t fallback was put in place in the @cra_init call, this function\n *\t\t might need to use the fallback if the algorithm doesn't support\n *\t\t all of the key sizes. In case the key was stored in\n *\t\t transformation context, the key might need to be re-programmed\n *\t\t into the hardware in this function. This function shall not\n *\t\t modify the transformation context, as this function may be\n *\t\t called in parallel with the same transformation object.\n * @cia_decrypt: Decrypt a single block. This is a reverse counterpart to\n *\t\t @cia_encrypt, and the conditions are exactly the same.\n *\n * All fields are mandatory and must be filled.\n */\nstruct cipher_alg {\n\tunsigned int cia_min_keysize;\n\tunsigned int cia_max_keysize;\n\tint (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t                  unsigned int keylen);\n\tvoid (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tvoid (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n};\n\nstruct compress_alg {\n\tint (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t    unsigned int slen, u8 *dst, unsigned int *dlen);\n\tint (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n};\n\n/**\n * struct old_rng_alg - random number generator definition\n * @rng_make_random: The function defined by this variable obtains a random\n *\t\t     number. The random number generator transform must generate\n *\t\t     the random number out of the context provided with this\n *\t\t     call.\n * @rng_reset: Reset of the random number generator by clearing the entire state.\n *\t       With the invocation of this function call, the random number\n *             generator shall completely reinitialize its state. If the random\n *\t       number generator requires a seed for setting up a new state,\n *\t       the seed must be provided by the consumer while invoking this\n *\t       function. The required size of the seed is defined with\n *\t       @seedsize .\n * @seedsize: The seed size required for a random number generator\n *\t      initialization defined with this variable. Some random number\n *\t      generators like the SP800-90A DRBG does not require a seed as the\n *\t      seeding is implemented internally without the need of support by\n *\t      the consumer. In this case, the seed size is set to zero.\n */\nstruct old_rng_alg {\n\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n\t\t\t       unsigned int dlen);\n\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n\n\tunsigned int seedsize;\n};\n\n\n#define cra_ablkcipher\tcra_u.ablkcipher\n#define cra_aead\tcra_u.aead\n#define cra_blkcipher\tcra_u.blkcipher\n#define cra_cipher\tcra_u.cipher\n#define cra_compress\tcra_u.compress\n#define cra_rng\t\tcra_u.rng\n\n/**\n * struct crypto_alg - definition of a cryptograpic cipher algorithm\n * @cra_flags: Flags describing this transformation. See include/linux/crypto.h\n *\t       CRYPTO_ALG_* flags for the flags which go in here. Those are\n *\t       used for fine-tuning the description of the transformation\n *\t       algorithm.\n * @cra_blocksize: Minimum block size of this transformation. The size in bytes\n *\t\t   of the smallest possible unit which can be transformed with\n *\t\t   this algorithm. The users must respect this value.\n *\t\t   In case of HASH transformation, it is possible for a smaller\n *\t\t   block than @cra_blocksize to be passed to the crypto API for\n *\t\t   transformation, in case of any other transformation type, an\n * \t\t   error will be returned upon any attempt to transform smaller\n *\t\t   than @cra_blocksize chunks.\n * @cra_ctxsize: Size of the operational context of the transformation. This\n *\t\t value informs the kernel crypto API about the memory size\n *\t\t needed to be allocated for the transformation context.\n * @cra_alignmask: Alignment mask for the input and output data buffer. The data\n *\t\t   buffer containing the input data for the algorithm must be\n *\t\t   aligned to this alignment mask. The data buffer for the\n *\t\t   output data must be aligned to this alignment mask. Note that\n *\t\t   the Crypto API will do the re-alignment in software, but\n *\t\t   only under special conditions and there is a performance hit.\n *\t\t   The re-alignment happens at these occasions for different\n *\t\t   @cra_u types: cipher -- For both input data and output data\n *\t\t   buffer; ahash -- For output hash destination buf; shash --\n *\t\t   For output hash destination buf.\n *\t\t   This is needed on hardware which is flawed by design and\n *\t\t   cannot pick data from arbitrary addresses.\n * @cra_priority: Priority of this transformation implementation. In case\n *\t\t  multiple transformations with same @cra_name are available to\n *\t\t  the Crypto API, the kernel will use the one with highest\n *\t\t  @cra_priority.\n * @cra_name: Generic name (usable by multiple implementations) of the\n *\t      transformation algorithm. This is the name of the transformation\n *\t      itself. This field is used by the kernel when looking up the\n *\t      providers of particular transformation.\n * @cra_driver_name: Unique name of the transformation provider. This is the\n *\t\t     name of the provider of the transformation. This can be any\n *\t\t     arbitrary value, but in the usual case, this contains the\n *\t\t     name of the chip or provider and the name of the\n *\t\t     transformation algorithm.\n * @cra_type: Type of the cryptographic transformation. This is a pointer to\n *\t      struct crypto_type, which implements callbacks common for all\n *\t      trasnformation types. There are multiple options:\n *\t      &crypto_blkcipher_type, &crypto_ablkcipher_type,\n *\t      &crypto_ahash_type, &crypto_aead_type, &crypto_rng_type.\n *\t      This field might be empty. In that case, there are no common\n *\t      callbacks. This is the case for: cipher, compress, shash.\n * @cra_u: Callbacks implementing the transformation. This is a union of\n *\t   multiple structures. Depending on the type of transformation selected\n *\t   by @cra_type and @cra_flags above, the associated structure must be\n *\t   filled with callbacks. This field might be empty. This is the case\n *\t   for ahash, shash.\n * @cra_init: Initialize the cryptographic transformation object. This function\n *\t      is used to initialize the cryptographic transformation object.\n *\t      This function is called only once at the instantiation time, right\n *\t      after the transformation context was allocated. In case the\n *\t      cryptographic hardware has some special requirements which need to\n *\t      be handled by software, this function shall check for the precise\n *\t      requirement of the transformation and put any software fallbacks\n *\t      in place.\n * @cra_exit: Deinitialize the cryptographic transformation object. This is a\n *\t      counterpart to @cra_init, used to remove various changes set in\n *\t      @cra_init.\n * @cra_module: Owner of this transformation implementation. Set to THIS_MODULE\n * @cra_list: internally used\n * @cra_users: internally used\n * @cra_refcnt: internally used\n * @cra_destroy: internally used\n *\n * The struct crypto_alg describes a generic Crypto API algorithm and is common\n * for all of the transformations. Any variable not documented here shall not\n * be used by a cipher implementation as it is internal to the Crypto API.\n */\nstruct crypto_alg {\n\tstruct list_head cra_list;\n\tstruct list_head cra_users;\n\n\tu32 cra_flags;\n\tunsigned int cra_blocksize;\n\tunsigned int cra_ctxsize;\n\tunsigned int cra_alignmask;\n\n\tint cra_priority;\n\tatomic_t cra_refcnt;\n\n\tchar cra_name[CRYPTO_MAX_ALG_NAME];\n\tchar cra_driver_name[CRYPTO_MAX_ALG_NAME];\n\n\tconst struct crypto_type *cra_type;\n\n\tunion {\n\t\tstruct ablkcipher_alg ablkcipher;\n\t\tstruct aead_alg aead;\n\t\tstruct blkcipher_alg blkcipher;\n\t\tstruct cipher_alg cipher;\n\t\tstruct compress_alg compress;\n\t\tstruct old_rng_alg rng;\n\t} cra_u;\n\n\tint (*cra_init)(struct crypto_tfm *tfm);\n\tvoid (*cra_exit)(struct crypto_tfm *tfm);\n\tvoid (*cra_destroy)(struct crypto_alg *alg);\n\t\n\tstruct module *cra_module;\n};\n\n/*\n * Algorithm registration interface.\n */\nint crypto_register_alg(struct crypto_alg *alg);\nint crypto_unregister_alg(struct crypto_alg *alg);\nint crypto_register_algs(struct crypto_alg *algs, int count);\nint crypto_unregister_algs(struct crypto_alg *algs, int count);\n\n/*\n * Algorithm query interface.\n */\nint crypto_has_alg(const char *name, u32 type, u32 mask);\n\n/*\n * Transforms: user-instantiated objects which encapsulate algorithms\n * and core processing logic.  Managed via crypto_alloc_*() and\n * crypto_free_*(), as well as the various helpers below.\n */\n\nstruct ablkcipher_tfm {\n\tint (*setkey)(struct crypto_ablkcipher *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct ablkcipher_request *req);\n\tint (*decrypt)(struct ablkcipher_request *req);\n\tint (*givencrypt)(struct skcipher_givcrypt_request *req);\n\tint (*givdecrypt)(struct skcipher_givcrypt_request *req);\n\n\tstruct crypto_ablkcipher *base;\n\n\tunsigned int ivsize;\n\tunsigned int reqsize;\n};\n\nstruct aead_tfm {\n\tint (*setkey)(struct crypto_aead *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct aead_request *req);\n\tint (*decrypt)(struct aead_request *req);\n\tint (*givencrypt)(struct aead_givcrypt_request *req);\n\tint (*givdecrypt)(struct aead_givcrypt_request *req);\n\n\tstruct crypto_aead *base;\n\n\tunsigned int ivsize;\n\tunsigned int authsize;\n\tunsigned int reqsize;\n};\n\nstruct blkcipher_tfm {\n\tvoid *iv;\n\tint (*setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t\t      unsigned int keylen);\n\tint (*encrypt)(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes);\n\tint (*decrypt)(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes);\n};\n\nstruct cipher_tfm {\n\tint (*cit_setkey)(struct crypto_tfm *tfm,\n\t                  const u8 *key, unsigned int keylen);\n\tvoid (*cit_encrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tvoid (*cit_decrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n};\n\nstruct hash_tfm {\n\tint (*init)(struct hash_desc *desc);\n\tint (*update)(struct hash_desc *desc,\n\t\t      struct scatterlist *sg, unsigned int nsg);\n\tint (*final)(struct hash_desc *desc, u8 *out);\n\tint (*digest)(struct hash_desc *desc, struct scatterlist *sg,\n\t\t      unsigned int nsg, u8 *out);\n\tint (*setkey)(struct crypto_hash *tfm, const u8 *key,\n\t\t      unsigned int keylen);\n\tunsigned int digestsize;\n};\n\nstruct compress_tfm {\n\tint (*cot_compress)(struct crypto_tfm *tfm,\n\t                    const u8 *src, unsigned int slen,\n\t                    u8 *dst, unsigned int *dlen);\n\tint (*cot_decompress)(struct crypto_tfm *tfm,\n\t                      const u8 *src, unsigned int slen,\n\t                      u8 *dst, unsigned int *dlen);\n};\n\n#define crt_ablkcipher\tcrt_u.ablkcipher\n#define crt_aead\tcrt_u.aead\n#define crt_blkcipher\tcrt_u.blkcipher\n#define crt_cipher\tcrt_u.cipher\n#define crt_hash\tcrt_u.hash\n#define crt_compress\tcrt_u.compress\n\nstruct crypto_tfm {\n\n\tu32 crt_flags;\n\t\n\tunion {\n\t\tstruct ablkcipher_tfm ablkcipher;\n\t\tstruct aead_tfm aead;\n\t\tstruct blkcipher_tfm blkcipher;\n\t\tstruct cipher_tfm cipher;\n\t\tstruct hash_tfm hash;\n\t\tstruct compress_tfm compress;\n\t} crt_u;\n\n\tvoid (*exit)(struct crypto_tfm *tfm);\n\t\n\tstruct crypto_alg *__crt_alg;\n\n\tvoid *__crt_ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct crypto_ablkcipher {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_aead {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_blkcipher {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_cipher {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_comp {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_hash {\n\tstruct crypto_tfm base;\n};\n\nenum {\n\tCRYPTOA_UNSPEC,\n\tCRYPTOA_ALG,\n\tCRYPTOA_TYPE,\n\tCRYPTOA_U32,\n\t__CRYPTOA_MAX,\n};\n\n#define CRYPTOA_MAX (__CRYPTOA_MAX - 1)\n\n/* Maximum number of (rtattr) parameters for each template. */\n#define CRYPTO_MAX_ATTRS 32\n\nstruct crypto_attr_alg {\n\tchar name[CRYPTO_MAX_ALG_NAME];\n};\n\nstruct crypto_attr_type {\n\tu32 type;\n\tu32 mask;\n};\n\nstruct crypto_attr_u32 {\n\tu32 num;\n};\n\n/* \n * Transform user interface.\n */\n \nstruct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask);\nvoid crypto_destroy_tfm(void *mem, struct crypto_tfm *tfm);\n\nstatic inline void crypto_free_tfm(struct crypto_tfm *tfm)\n{\n\treturn crypto_destroy_tfm(tfm, tfm);\n}\n\nint alg_test(const char *driver, const char *alg, u32 type, u32 mask);\n\n/*\n * Transform helpers which query the underlying algorithm.\n */\nstatic inline const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_name;\n}\n\nstatic inline const char *crypto_tfm_alg_driver_name(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_driver_name;\n}\n\nstatic inline int crypto_tfm_alg_priority(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_priority;\n}\n\nstatic inline u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;\n}\n\nstatic inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_blocksize;\n}\n\nstatic inline unsigned int crypto_tfm_alg_alignmask(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_alignmask;\n}\n\nstatic inline u32 crypto_tfm_get_flags(struct crypto_tfm *tfm)\n{\n\treturn tfm->crt_flags;\n}\n\nstatic inline void crypto_tfm_set_flags(struct crypto_tfm *tfm, u32 flags)\n{\n\ttfm->crt_flags |= flags;\n}\n\nstatic inline void crypto_tfm_clear_flags(struct crypto_tfm *tfm, u32 flags)\n{\n\ttfm->crt_flags &= ~flags;\n}\n\nstatic inline void *crypto_tfm_ctx(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_ctx;\n}\n\nstatic inline unsigned int crypto_tfm_ctx_alignment(void)\n{\n\tstruct crypto_tfm *tfm;\n\treturn __alignof__(tfm->__crt_ctx);\n}\n\n/*\n * API wrappers.\n */\nstatic inline struct crypto_ablkcipher *__crypto_ablkcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\treturn (struct crypto_ablkcipher *)tfm;\n}\n\nstatic inline u32 crypto_skcipher_type(u32 type)\n{\n\ttype &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\n\ttype |= CRYPTO_ALG_TYPE_BLKCIPHER;\n\treturn type;\n}\n\nstatic inline u32 crypto_skcipher_mask(u32 mask)\n{\n\tmask &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\n\tmask |= CRYPTO_ALG_TYPE_BLKCIPHER_MASK;\n\treturn mask;\n}\n\n/**\n * DOC: Asynchronous Block Cipher API\n *\n * Asynchronous block cipher API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_ABLKCIPHER (listed as type \"ablkcipher\" in /proc/crypto).\n *\n * Asynchronous cipher operations imply that the function invocation for a\n * cipher request returns immediately before the completion of the operation.\n * The cipher request is scheduled as a separate kernel thread and therefore\n * load-balanced on the different CPUs via the process scheduler. To allow\n * the kernel crypto API to inform the caller about the completion of a cipher\n * request, the caller must provide a callback function. That function is\n * invoked with the cipher handle when the request completes.\n *\n * To support the asynchronous operation, additional information than just the\n * cipher handle must be supplied to the kernel crypto API. That additional\n * information is given by filling in the ablkcipher_request data structure.\n *\n * For the asynchronous block cipher API, the state is maintained with the tfm\n * cipher handle. A single tfm can be used across multiple calls and in\n * parallel. For asynchronous block cipher calls, context data supplied and\n * only used by the caller can be referenced the request data structure in\n * addition to the IV used for the cipher request. The maintenance of such\n * state information would be important for a crypto driver implementer to\n * have, because when calling the callback function upon completion of the\n * cipher operation, that callback function may need some information about\n * which operation just finished if it invoked multiple in parallel. This\n * state information is unused by the kernel crypto API.\n */\n\n/**\n * crypto_alloc_ablkcipher() - allocate asynchronous block cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      ablkcipher cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for an ablkcipher. The returned struct\n * crypto_ablkcipher is the cipher handle that is required for any subsequent\n * API invocation for that ablkcipher.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstruct crypto_ablkcipher *crypto_alloc_ablkcipher(const char *alg_name,\n\t\t\t\t\t\t  u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_ablkcipher_tfm(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_ablkcipher() - zeroize and free cipher handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_ablkcipher(struct crypto_ablkcipher *tfm)\n{\n\tcrypto_free_tfm(crypto_ablkcipher_tfm(tfm));\n}\n\n/**\n * crypto_has_ablkcipher() - Search for the availability of an ablkcipher.\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      ablkcipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the ablkcipher is known to the kernel crypto API; false\n *\t   otherwise\n */\nstatic inline int crypto_has_ablkcipher(const char *alg_name, u32 type,\n\t\t\t\t\tu32 mask)\n{\n\treturn crypto_has_alg(alg_name, crypto_skcipher_type(type),\n\t\t\t      crypto_skcipher_mask(mask));\n}\n\nstatic inline struct ablkcipher_tfm *crypto_ablkcipher_crt(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn &crypto_ablkcipher_tfm(tfm)->crt_ablkcipher;\n}\n\n/**\n * crypto_ablkcipher_ivsize() - obtain IV size\n * @tfm: cipher handle\n *\n * The size of the IV for the ablkcipher referenced by the cipher handle is\n * returned. This IV size may be zero if the cipher does not need an IV.\n *\n * Return: IV size in bytes\n */\nstatic inline unsigned int crypto_ablkcipher_ivsize(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_ablkcipher_crt(tfm)->ivsize;\n}\n\n/**\n * crypto_ablkcipher_blocksize() - obtain block size of cipher\n * @tfm: cipher handle\n *\n * The block size for the ablkcipher referenced with the cipher handle is\n * returned. The caller may use that information to allocate appropriate\n * memory for the data returned by the encryption or decryption operation\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_ablkcipher_blocksize(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_ablkcipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_ablkcipher_alignmask(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_ablkcipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_ablkcipher_get_flags(struct crypto_ablkcipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_ablkcipher_tfm(tfm));\n}\n\nstatic inline void crypto_ablkcipher_set_flags(struct crypto_ablkcipher *tfm,\n\t\t\t\t\t       u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_ablkcipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_ablkcipher_clear_flags(struct crypto_ablkcipher *tfm,\n\t\t\t\t\t\t u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_ablkcipher_tfm(tfm), flags);\n}\n\n/**\n * crypto_ablkcipher_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the ablkcipher referenced by the cipher\n * handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_ablkcipher_setkey(struct crypto_ablkcipher *tfm,\n\t\t\t\t\t   const u8 *key, unsigned int keylen)\n{\n\tstruct ablkcipher_tfm *crt = crypto_ablkcipher_crt(tfm);\n\n\treturn crt->setkey(crt->base, key, keylen);\n}\n\n/**\n * crypto_ablkcipher_reqtfm() - obtain cipher handle from request\n * @req: ablkcipher_request out of which the cipher handle is to be obtained\n *\n * Return the crypto_ablkcipher handle when furnishing an ablkcipher_request\n * data structure.\n *\n * Return: crypto_ablkcipher handle\n */\nstatic inline struct crypto_ablkcipher *crypto_ablkcipher_reqtfm(\n\tstruct ablkcipher_request *req)\n{\n\treturn __crypto_ablkcipher_cast(req->base.tfm);\n}\n\n/**\n * crypto_ablkcipher_encrypt() - encrypt plaintext\n * @req: reference to the ablkcipher_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Encrypt plaintext data using the ablkcipher_request handle. That data\n * structure and how it is filled with data is discussed with the\n * ablkcipher_request_* functions.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_ablkcipher_encrypt(struct ablkcipher_request *req)\n{\n\tstruct ablkcipher_tfm *crt =\n\t\tcrypto_ablkcipher_crt(crypto_ablkcipher_reqtfm(req));\n\treturn crt->encrypt(req);\n}\n\n/**\n * crypto_ablkcipher_decrypt() - decrypt ciphertext\n * @req: reference to the ablkcipher_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Decrypt ciphertext data using the ablkcipher_request handle. That data\n * structure and how it is filled with data is discussed with the\n * ablkcipher_request_* functions.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_ablkcipher_decrypt(struct ablkcipher_request *req)\n{\n\tstruct ablkcipher_tfm *crt =\n\t\tcrypto_ablkcipher_crt(crypto_ablkcipher_reqtfm(req));\n\treturn crt->decrypt(req);\n}\n\n/**\n * DOC: Asynchronous Cipher Request Handle\n *\n * The ablkcipher_request data structure contains all pointers to data\n * required for the asynchronous cipher operation. This includes the cipher\n * handle (which can be used by multiple ablkcipher_request instances), pointer\n * to plaintext and ciphertext, asynchronous callback function, etc. It acts\n * as a handle to the ablkcipher_request_* API calls in a similar way as\n * ablkcipher handle to the crypto_ablkcipher_* API calls.\n */\n\n/**\n * crypto_ablkcipher_reqsize() - obtain size of the request data structure\n * @tfm: cipher handle\n *\n * Return: number of bytes\n */\nstatic inline unsigned int crypto_ablkcipher_reqsize(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_ablkcipher_crt(tfm)->reqsize;\n}\n\n/**\n * ablkcipher_request_set_tfm() - update cipher handle reference in request\n * @req: request handle to be modified\n * @tfm: cipher handle that shall be added to the request handle\n *\n * Allow the caller to replace the existing ablkcipher handle in the request\n * data structure with a different one.\n */\nstatic inline void ablkcipher_request_set_tfm(\n\tstruct ablkcipher_request *req, struct crypto_ablkcipher *tfm)\n{\n\treq->base.tfm = crypto_ablkcipher_tfm(crypto_ablkcipher_crt(tfm)->base);\n}\n\nstatic inline struct ablkcipher_request *ablkcipher_request_cast(\n\tstruct crypto_async_request *req)\n{\n\treturn container_of(req, struct ablkcipher_request, base);\n}\n\n/**\n * ablkcipher_request_alloc() - allocate request data structure\n * @tfm: cipher handle to be registered with the request\n * @gfp: memory allocation flag that is handed to kmalloc by the API call.\n *\n * Allocate the request data structure that must be used with the ablkcipher\n * encrypt and decrypt API calls. During the allocation, the provided ablkcipher\n * handle is registered in the request data structure.\n *\n * Return: allocated request handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct ablkcipher_request *ablkcipher_request_alloc(\n\tstruct crypto_ablkcipher *tfm, gfp_t gfp)\n{\n\tstruct ablkcipher_request *req;\n\n\treq = kmalloc(sizeof(struct ablkcipher_request) +\n\t\t      crypto_ablkcipher_reqsize(tfm), gfp);\n\n\tif (likely(req))\n\t\tablkcipher_request_set_tfm(req, tfm);\n\n\treturn req;\n}\n\n/**\n * ablkcipher_request_free() - zeroize and free request data structure\n * @req: request data structure cipher handle to be freed\n */\nstatic inline void ablkcipher_request_free(struct ablkcipher_request *req)\n{\n\tkzfree(req);\n}\n\n/**\n * ablkcipher_request_set_callback() - set asynchronous callback function\n * @req: request handle\n * @flags: specify zero or an ORing of the flags\n *         CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and\n *\t   increase the wait queue beyond the initial maximum size;\n *\t   CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep\n * @compl: callback function pointer to be registered with the request handle\n * @data: The data pointer refers to memory that is not used by the kernel\n *\t  crypto API, but provided to the callback function for it to use. Here,\n *\t  the caller can provide a reference to memory the callback function can\n *\t  operate on. As the callback function is invoked asynchronously to the\n *\t  related functionality, it may need to access data structures of the\n *\t  related functionality which can be referenced using this pointer. The\n *\t  callback function can access the memory via the \"data\" field in the\n *\t  crypto_async_request data structure provided to the callback function.\n *\n * This function allows setting the callback function that is triggered once the\n * cipher operation completes.\n *\n * The callback function is registered with the ablkcipher_request handle and\n * must comply with the following template\n *\n *\tvoid callback_function(struct crypto_async_request *req, int error)\n */\nstatic inline void ablkcipher_request_set_callback(\n\tstruct ablkcipher_request *req,\n\tu32 flags, crypto_completion_t compl, void *data)\n{\n\treq->base.complete = compl;\n\treq->base.data = data;\n\treq->base.flags = flags;\n}\n\n/**\n * ablkcipher_request_set_crypt() - set data buffers\n * @req: request handle\n * @src: source scatter / gather list\n * @dst: destination scatter / gather list\n * @nbytes: number of bytes to process from @src\n * @iv: IV for the cipher operation which must comply with the IV size defined\n *      by crypto_ablkcipher_ivsize\n *\n * This function allows setting of the source data and destination data\n * scatter / gather lists.\n *\n * For encryption, the source is treated as the plaintext and the\n * destination is the ciphertext. For a decryption operation, the use is\n * reversed - the source is the ciphertext and the destination is the plaintext.\n */\nstatic inline void ablkcipher_request_set_crypt(\n\tstruct ablkcipher_request *req,\n\tstruct scatterlist *src, struct scatterlist *dst,\n\tunsigned int nbytes, void *iv)\n{\n\treq->src = src;\n\treq->dst = dst;\n\treq->nbytes = nbytes;\n\treq->info = iv;\n}\n\n/**\n * DOC: Authenticated Encryption With Associated Data (AEAD) Cipher API\n *\n * The AEAD cipher API is used with the ciphers of type CRYPTO_ALG_TYPE_AEAD\n * (listed as type \"aead\" in /proc/crypto)\n *\n * The most prominent examples for this type of encryption is GCM and CCM.\n * However, the kernel supports other types of AEAD ciphers which are defined\n * with the following cipher string:\n *\n *\tauthenc(keyed message digest, block cipher)\n *\n * For example: authenc(hmac(sha256), cbc(aes))\n *\n * The example code provided for the asynchronous block cipher operation\n * applies here as well. Naturally all *ablkcipher* symbols must be exchanged\n * the *aead* pendants discussed in the following. In addtion, for the AEAD\n * operation, the aead_request_set_assoc function must be used to set the\n * pointer to the associated data memory location before performing the\n * encryption or decryption operation. In case of an encryption, the associated\n * data memory is filled during the encryption operation. For decryption, the\n * associated data memory must contain data that is used to verify the integrity\n * of the decrypted data. Another deviation from the asynchronous block cipher\n * operation is that the caller should explicitly check for -EBADMSG of the\n * crypto_aead_decrypt. That error indicates an authentication error, i.e.\n * a breach in the integrity of the message. In essence, that -EBADMSG error\n * code is the key bonus an AEAD cipher has over \"standard\" block chaining\n * modes.\n */\n\nstatic inline struct crypto_aead *__crypto_aead_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_aead *)tfm;\n}\n\n/**\n * crypto_alloc_aead() - allocate AEAD cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t     AEAD cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for an AEAD. The returned struct\n * crypto_aead is the cipher handle that is required for any subsequent\n * API invocation for that AEAD.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstruct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_aead_tfm(struct crypto_aead *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_aead() - zeroize and free aead handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_aead(struct crypto_aead *tfm)\n{\n\tcrypto_free_tfm(crypto_aead_tfm(tfm));\n}\n\nstatic inline struct aead_tfm *crypto_aead_crt(struct crypto_aead *tfm)\n{\n\treturn &crypto_aead_tfm(tfm)->crt_aead;\n}\n\n/**\n * crypto_aead_ivsize() - obtain IV size\n * @tfm: cipher handle\n *\n * The size of the IV for the aead referenced by the cipher handle is\n * returned. This IV size may be zero if the cipher does not need an IV.\n *\n * Return: IV size in bytes\n */\nstatic inline unsigned int crypto_aead_ivsize(struct crypto_aead *tfm)\n{\n\treturn crypto_aead_crt(tfm)->ivsize;\n}\n\n/**\n * crypto_aead_authsize() - obtain maximum authentication data size\n * @tfm: cipher handle\n *\n * The maximum size of the authentication data for the AEAD cipher referenced\n * by the AEAD cipher handle is returned. The authentication data size may be\n * zero if the cipher implements a hard-coded maximum.\n *\n * The authentication data may also be known as \"tag value\".\n *\n * Return: authentication data size / tag size in bytes\n */\nstatic inline unsigned int crypto_aead_authsize(struct crypto_aead *tfm)\n{\n\treturn crypto_aead_crt(tfm)->authsize;\n}\n\n/**\n * crypto_aead_blocksize() - obtain block size of cipher\n * @tfm: cipher handle\n *\n * The block size for the AEAD referenced with the cipher handle is returned.\n * The caller may use that information to allocate appropriate memory for the\n * data returned by the encryption or decryption operation\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_aead_blocksize(struct crypto_aead *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_aead_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_aead_alignmask(struct crypto_aead *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_aead_tfm(tfm));\n}\n\nstatic inline u32 crypto_aead_get_flags(struct crypto_aead *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_aead_tfm(tfm));\n}\n\nstatic inline void crypto_aead_set_flags(struct crypto_aead *tfm, u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_aead_tfm(tfm), flags);\n}\n\nstatic inline void crypto_aead_clear_flags(struct crypto_aead *tfm, u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_aead_tfm(tfm), flags);\n}\n\n/**\n * crypto_aead_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the AEAD referenced by the cipher\n * handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t     unsigned int keylen)\n{\n\tstruct aead_tfm *crt = crypto_aead_crt(tfm);\n\n\treturn crt->setkey(crt->base, key, keylen);\n}\n\n/**\n * crypto_aead_setauthsize() - set authentication data size\n * @tfm: cipher handle\n * @authsize: size of the authentication data / tag in bytes\n *\n * Set the authentication data size / tag size. AEAD requires an authentication\n * tag (or MAC) in addition to the associated data.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nint crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize);\n\nstatic inline struct crypto_aead *crypto_aead_reqtfm(struct aead_request *req)\n{\n\treturn __crypto_aead_cast(req->base.tfm);\n}\n\n/**\n * crypto_aead_encrypt() - encrypt plaintext\n * @req: reference to the aead_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Encrypt plaintext data using the aead_request handle. That data structure\n * and how it is filled with data is discussed with the aead_request_*\n * functions.\n *\n * IMPORTANT NOTE The encryption operation creates the authentication data /\n *\t\t  tag. That data is concatenated with the created ciphertext.\n *\t\t  The ciphertext memory size is therefore the given number of\n *\t\t  block cipher blocks + the size defined by the\n *\t\t  crypto_aead_setauthsize invocation. The caller must ensure\n *\t\t  that sufficient memory is available for the ciphertext and\n *\t\t  the authentication tag.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_aead_encrypt(struct aead_request *req)\n{\n\treturn crypto_aead_crt(crypto_aead_reqtfm(req))->encrypt(req);\n}\n\n/**\n * crypto_aead_decrypt() - decrypt ciphertext\n * @req: reference to the ablkcipher_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Decrypt ciphertext data using the aead_request handle. That data structure\n * and how it is filled with data is discussed with the aead_request_*\n * functions.\n *\n * IMPORTANT NOTE The caller must concatenate the ciphertext followed by the\n *\t\t  authentication data / tag. That authentication data / tag\n *\t\t  must have the size defined by the crypto_aead_setauthsize\n *\t\t  invocation.\n *\n *\n * Return: 0 if the cipher operation was successful; -EBADMSG: The AEAD\n *\t   cipher operation performs the authentication of the data during the\n *\t   decryption operation. Therefore, the function returns this error if\n *\t   the authentication of the ciphertext was unsuccessful (i.e. the\n *\t   integrity of the ciphertext or the associated data was violated);\n *\t   < 0 if an error occurred.\n */\nstatic inline int crypto_aead_decrypt(struct aead_request *req)\n{\n\tif (req->cryptlen < crypto_aead_authsize(crypto_aead_reqtfm(req)))\n\t\treturn -EINVAL;\n\n\treturn crypto_aead_crt(crypto_aead_reqtfm(req))->decrypt(req);\n}\n\n/**\n * DOC: Asynchronous AEAD Request Handle\n *\n * The aead_request data structure contains all pointers to data required for\n * the AEAD cipher operation. This includes the cipher handle (which can be\n * used by multiple aead_request instances), pointer to plaintext and\n * ciphertext, asynchronous callback function, etc. It acts as a handle to the\n * aead_request_* API calls in a similar way as AEAD handle to the\n * crypto_aead_* API calls.\n */\n\n/**\n * crypto_aead_reqsize() - obtain size of the request data structure\n * @tfm: cipher handle\n *\n * Return: number of bytes\n */\nstatic inline unsigned int crypto_aead_reqsize(struct crypto_aead *tfm)\n{\n\treturn crypto_aead_crt(tfm)->reqsize;\n}\n\n/**\n * aead_request_set_tfm() - update cipher handle reference in request\n * @req: request handle to be modified\n * @tfm: cipher handle that shall be added to the request handle\n *\n * Allow the caller to replace the existing aead handle in the request\n * data structure with a different one.\n */\nstatic inline void aead_request_set_tfm(struct aead_request *req,\n\t\t\t\t\tstruct crypto_aead *tfm)\n{\n\treq->base.tfm = crypto_aead_tfm(crypto_aead_crt(tfm)->base);\n}\n\n/**\n * aead_request_alloc() - allocate request data structure\n * @tfm: cipher handle to be registered with the request\n * @gfp: memory allocation flag that is handed to kmalloc by the API call.\n *\n * Allocate the request data structure that must be used with the AEAD\n * encrypt and decrypt API calls. During the allocation, the provided aead\n * handle is registered in the request data structure.\n *\n * Return: allocated request handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct aead_request *aead_request_alloc(struct crypto_aead *tfm,\n\t\t\t\t\t\t      gfp_t gfp)\n{\n\tstruct aead_request *req;\n\n\treq = kmalloc(sizeof(*req) + crypto_aead_reqsize(tfm), gfp);\n\n\tif (likely(req))\n\t\taead_request_set_tfm(req, tfm);\n\n\treturn req;\n}\n\n/**\n * aead_request_free() - zeroize and free request data structure\n * @req: request data structure cipher handle to be freed\n */\nstatic inline void aead_request_free(struct aead_request *req)\n{\n\tkzfree(req);\n}\n\n/**\n * aead_request_set_callback() - set asynchronous callback function\n * @req: request handle\n * @flags: specify zero or an ORing of the flags\n *\t   CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and\n *\t   increase the wait queue beyond the initial maximum size;\n *\t   CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep\n * @compl: callback function pointer to be registered with the request handle\n * @data: The data pointer refers to memory that is not used by the kernel\n *\t  crypto API, but provided to the callback function for it to use. Here,\n *\t  the caller can provide a reference to memory the callback function can\n *\t  operate on. As the callback function is invoked asynchronously to the\n *\t  related functionality, it may need to access data structures of the\n *\t  related functionality which can be referenced using this pointer. The\n *\t  callback function can access the memory via the \"data\" field in the\n *\t  crypto_async_request data structure provided to the callback function.\n *\n * Setting the callback function that is triggered once the cipher operation\n * completes\n *\n * The callback function is registered with the aead_request handle and\n * must comply with the following template\n *\n *\tvoid callback_function(struct crypto_async_request *req, int error)\n */\nstatic inline void aead_request_set_callback(struct aead_request *req,\n\t\t\t\t\t     u32 flags,\n\t\t\t\t\t     crypto_completion_t compl,\n\t\t\t\t\t     void *data)\n{\n\treq->base.complete = compl;\n\treq->base.data = data;\n\treq->base.flags = flags;\n}\n\n/**\n * aead_request_set_crypt - set data buffers\n * @req: request handle\n * @src: source scatter / gather list\n * @dst: destination scatter / gather list\n * @cryptlen: number of bytes to process from @src\n * @iv: IV for the cipher operation which must comply with the IV size defined\n *      by crypto_aead_ivsize()\n *\n * Setting the source data and destination data scatter / gather lists.\n *\n * For encryption, the source is treated as the plaintext and the\n * destination is the ciphertext. For a decryption operation, the use is\n * reversed - the source is the ciphertext and the destination is the plaintext.\n *\n * IMPORTANT NOTE AEAD requires an authentication tag (MAC). For decryption,\n *\t\t  the caller must concatenate the ciphertext followed by the\n *\t\t  authentication tag and provide the entire data stream to the\n *\t\t  decryption operation (i.e. the data length used for the\n *\t\t  initialization of the scatterlist and the data length for the\n *\t\t  decryption operation is identical). For encryption, however,\n *\t\t  the authentication tag is created while encrypting the data.\n *\t\t  The destination buffer must hold sufficient space for the\n *\t\t  ciphertext and the authentication tag while the encryption\n *\t\t  invocation must only point to the plaintext data size. The\n *\t\t  following code snippet illustrates the memory usage\n *\t\t  buffer = kmalloc(ptbuflen + (enc ? authsize : 0));\n *\t\t  sg_init_one(&sg, buffer, ptbuflen + (enc ? authsize : 0));\n *\t\t  aead_request_set_crypt(req, &sg, &sg, ptbuflen, iv);\n */\nstatic inline void aead_request_set_crypt(struct aead_request *req,\n\t\t\t\t\t  struct scatterlist *src,\n\t\t\t\t\t  struct scatterlist *dst,\n\t\t\t\t\t  unsigned int cryptlen, u8 *iv)\n{\n\treq->src = src;\n\treq->dst = dst;\n\treq->cryptlen = cryptlen;\n\treq->iv = iv;\n}\n\n/**\n * aead_request_set_assoc() - set the associated data scatter / gather list\n * @req: request handle\n * @assoc: associated data scatter / gather list\n * @assoclen: number of bytes to process from @assoc\n *\n * For encryption, the memory is filled with the associated data. For\n * decryption, the memory must point to the associated data.\n */\nstatic inline void aead_request_set_assoc(struct aead_request *req,\n\t\t\t\t\t  struct scatterlist *assoc,\n\t\t\t\t\t  unsigned int assoclen)\n{\n\treq->assoc = assoc;\n\treq->assoclen = assoclen;\n}\n\n/**\n * DOC: Synchronous Block Cipher API\n *\n * The synchronous block cipher API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_BLKCIPHER (listed as type \"blkcipher\" in /proc/crypto)\n *\n * Synchronous calls, have a context in the tfm. But since a single tfm can be\n * used in multiple calls and in parallel, this info should not be changeable\n * (unless a lock is used). This applies, for example, to the symmetric key.\n * However, the IV is changeable, so there is an iv field in blkcipher_tfm\n * structure for synchronous blkcipher api. So, its the only state info that can\n * be kept for synchronous calls without using a big lock across a tfm.\n *\n * The block cipher API allows the use of a complete cipher, i.e. a cipher\n * consisting of a template (a block chaining mode) and a single block cipher\n * primitive (e.g. AES).\n *\n * The plaintext data buffer and the ciphertext data buffer are pointed to\n * by using scatter/gather lists. The cipher operation is performed\n * on all segments of the provided scatter/gather lists.\n *\n * The kernel crypto API supports a cipher operation \"in-place\" which means that\n * the caller may provide the same scatter/gather list for the plaintext and\n * cipher text. After the completion of the cipher operation, the plaintext\n * data is replaced with the ciphertext data in case of an encryption and vice\n * versa for a decryption. The caller must ensure that the scatter/gather lists\n * for the output data point to sufficiently large buffers, i.e. multiples of\n * the block size of the cipher.\n */\n\nstatic inline struct crypto_blkcipher *__crypto_blkcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\treturn (struct crypto_blkcipher *)tfm;\n}\n\nstatic inline struct crypto_blkcipher *crypto_blkcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\tBUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_BLKCIPHER);\n\treturn __crypto_blkcipher_cast(tfm);\n}\n\n/**\n * crypto_alloc_blkcipher() - allocate synchronous block cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      blkcipher cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a block cipher. The returned struct\n * crypto_blkcipher is the cipher handle that is required for any subsequent\n * API invocation for that block cipher.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct crypto_blkcipher *crypto_alloc_blkcipher(\n\tconst char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_BLKCIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_blkcipher_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_blkcipher_tfm(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_blkcipher() - zeroize and free the block cipher handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_blkcipher(struct crypto_blkcipher *tfm)\n{\n\tcrypto_free_tfm(crypto_blkcipher_tfm(tfm));\n}\n\n/**\n * crypto_has_blkcipher() - Search for the availability of a block cipher\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      block cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the block cipher is known to the kernel crypto API; false\n *\t   otherwise\n */\nstatic inline int crypto_has_blkcipher(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_BLKCIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\n/**\n * crypto_blkcipher_name() - return the name / cra_name from the cipher handle\n * @tfm: cipher handle\n *\n * Return: The character string holding the name of the cipher\n */\nstatic inline const char *crypto_blkcipher_name(struct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_alg_name(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline struct blkcipher_tfm *crypto_blkcipher_crt(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn &crypto_blkcipher_tfm(tfm)->crt_blkcipher;\n}\n\nstatic inline struct blkcipher_alg *crypto_blkcipher_alg(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn &crypto_blkcipher_tfm(tfm)->__crt_alg->cra_blkcipher;\n}\n\n/**\n * crypto_blkcipher_ivsize() - obtain IV size\n * @tfm: cipher handle\n *\n * The size of the IV for the block cipher referenced by the cipher handle is\n * returned. This IV size may be zero if the cipher does not need an IV.\n *\n * Return: IV size in bytes\n */\nstatic inline unsigned int crypto_blkcipher_ivsize(struct crypto_blkcipher *tfm)\n{\n\treturn crypto_blkcipher_alg(tfm)->ivsize;\n}\n\n/**\n * crypto_blkcipher_blocksize() - obtain block size of cipher\n * @tfm: cipher handle\n *\n * The block size for the block cipher referenced with the cipher handle is\n * returned. The caller may use that information to allocate appropriate\n * memory for the data returned by the encryption or decryption operation.\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_blkcipher_blocksize(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_blkcipher_alignmask(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_blkcipher_get_flags(struct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline void crypto_blkcipher_set_flags(struct crypto_blkcipher *tfm,\n\t\t\t\t\t      u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_blkcipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_blkcipher_clear_flags(struct crypto_blkcipher *tfm,\n\t\t\t\t\t\tu32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_blkcipher_tfm(tfm), flags);\n}\n\n/**\n * crypto_blkcipher_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the block cipher referenced by the cipher\n * handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_setkey(struct crypto_blkcipher *tfm,\n\t\t\t\t\t  const u8 *key, unsigned int keylen)\n{\n\treturn crypto_blkcipher_crt(tfm)->setkey(crypto_blkcipher_tfm(tfm),\n\t\t\t\t\t\t key, keylen);\n}\n\n/**\n * crypto_blkcipher_encrypt() - encrypt plaintext\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tciphertext\n * @src: scatter/gather list that holds the plaintext\n * @nbytes: number of bytes of the plaintext to encrypt.\n *\n * Encrypt plaintext data using the IV set by the caller with a preceding\n * call of crypto_blkcipher_set_iv.\n *\n * The blkcipher_desc data structure must be filled by the caller and can\n * reside on the stack. The caller must fill desc as follows: desc.tfm is filled\n * with the block cipher handle; desc.flags is filled with either\n * CRYPTO_TFM_REQ_MAY_SLEEP or 0.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_encrypt(struct blkcipher_desc *desc,\n\t\t\t\t\t   struct scatterlist *dst,\n\t\t\t\t\t   struct scatterlist *src,\n\t\t\t\t\t   unsigned int nbytes)\n{\n\tdesc->info = crypto_blkcipher_crt(desc->tfm)->iv;\n\treturn crypto_blkcipher_crt(desc->tfm)->encrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_encrypt_iv() - encrypt plaintext with dedicated IV\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tciphertext\n * @src: scatter/gather list that holds the plaintext\n * @nbytes: number of bytes of the plaintext to encrypt.\n *\n * Encrypt plaintext data with the use of an IV that is solely used for this\n * cipher operation. Any previously set IV is not used.\n *\n * The blkcipher_desc data structure must be filled by the caller and can\n * reside on the stack. The caller must fill desc as follows: desc.tfm is filled\n * with the block cipher handle; desc.info is filled with the IV to be used for\n * the current operation; desc.flags is filled with either\n * CRYPTO_TFM_REQ_MAY_SLEEP or 0.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_encrypt_iv(struct blkcipher_desc *desc,\n\t\t\t\t\t      struct scatterlist *dst,\n\t\t\t\t\t      struct scatterlist *src,\n\t\t\t\t\t      unsigned int nbytes)\n{\n\treturn crypto_blkcipher_crt(desc->tfm)->encrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_decrypt() - decrypt ciphertext\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tplaintext\n * @src: scatter/gather list that holds the ciphertext\n * @nbytes: number of bytes of the ciphertext to decrypt.\n *\n * Decrypt ciphertext data using the IV set by the caller with a preceding\n * call of crypto_blkcipher_set_iv.\n *\n * The blkcipher_desc data structure must be filled by the caller as documented\n * for the crypto_blkcipher_encrypt call above.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n *\n */\nstatic inline int crypto_blkcipher_decrypt(struct blkcipher_desc *desc,\n\t\t\t\t\t   struct scatterlist *dst,\n\t\t\t\t\t   struct scatterlist *src,\n\t\t\t\t\t   unsigned int nbytes)\n{\n\tdesc->info = crypto_blkcipher_crt(desc->tfm)->iv;\n\treturn crypto_blkcipher_crt(desc->tfm)->decrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_decrypt_iv() - decrypt ciphertext with dedicated IV\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tplaintext\n * @src: scatter/gather list that holds the ciphertext\n * @nbytes: number of bytes of the ciphertext to decrypt.\n *\n * Decrypt ciphertext data with the use of an IV that is solely used for this\n * cipher operation. Any previously set IV is not used.\n *\n * The blkcipher_desc data structure must be filled by the caller as documented\n * for the crypto_blkcipher_encrypt_iv call above.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_decrypt_iv(struct blkcipher_desc *desc,\n\t\t\t\t\t      struct scatterlist *dst,\n\t\t\t\t\t      struct scatterlist *src,\n\t\t\t\t\t      unsigned int nbytes)\n{\n\treturn crypto_blkcipher_crt(desc->tfm)->decrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_set_iv() - set IV for cipher\n * @tfm: cipher handle\n * @src: buffer holding the IV\n * @len: length of the IV in bytes\n *\n * The caller provided IV is set for the block cipher referenced by the cipher\n * handle.\n */\nstatic inline void crypto_blkcipher_set_iv(struct crypto_blkcipher *tfm,\n\t\t\t\t\t   const u8 *src, unsigned int len)\n{\n\tmemcpy(crypto_blkcipher_crt(tfm)->iv, src, len);\n}\n\n/**\n * crypto_blkcipher_get_iv() - obtain IV from cipher\n * @tfm: cipher handle\n * @dst: buffer filled with the IV\n * @len: length of the buffer dst\n *\n * The caller can obtain the IV set for the block cipher referenced by the\n * cipher handle and store it into the user-provided buffer. If the buffer\n * has an insufficient space, the IV is truncated to fit the buffer.\n */\nstatic inline void crypto_blkcipher_get_iv(struct crypto_blkcipher *tfm,\n\t\t\t\t\t   u8 *dst, unsigned int len)\n{\n\tmemcpy(dst, crypto_blkcipher_crt(tfm)->iv, len);\n}\n\n/**\n * DOC: Single Block Cipher API\n *\n * The single block cipher API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_CIPHER (listed as type \"cipher\" in /proc/crypto).\n *\n * Using the single block cipher API calls, operations with the basic cipher\n * primitive can be implemented. These cipher primitives exclude any block\n * chaining operations including IV handling.\n *\n * The purpose of this single block cipher API is to support the implementation\n * of templates or other concepts that only need to perform the cipher operation\n * on one block at a time. Templates invoke the underlying cipher primitive\n * block-wise and process either the input or the output data of these cipher\n * operations.\n */\n\nstatic inline struct crypto_cipher *__crypto_cipher_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_cipher *)tfm;\n}\n\nstatic inline struct crypto_cipher *crypto_cipher_cast(struct crypto_tfm *tfm)\n{\n\tBUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);\n\treturn __crypto_cipher_cast(tfm);\n}\n\n/**\n * crypto_alloc_cipher() - allocate single block cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t     single block cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a single block cipher. The returned struct\n * crypto_cipher is the cipher handle that is required for any subsequent API\n * invocation for that single block cipher.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct crypto_cipher *crypto_alloc_cipher(const char *alg_name,\n\t\t\t\t\t\t\tu32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_CIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_cipher_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_cipher_tfm(struct crypto_cipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_cipher() - zeroize and free the single block cipher handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_cipher(struct crypto_cipher *tfm)\n{\n\tcrypto_free_tfm(crypto_cipher_tfm(tfm));\n}\n\n/**\n * crypto_has_cipher() - Search for the availability of a single block cipher\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t     single block cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the single block cipher is known to the kernel crypto API;\n *\t   false otherwise\n */\nstatic inline int crypto_has_cipher(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_CIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline struct cipher_tfm *crypto_cipher_crt(struct crypto_cipher *tfm)\n{\n\treturn &crypto_cipher_tfm(tfm)->crt_cipher;\n}\n\n/**\n * crypto_cipher_blocksize() - obtain block size for cipher\n * @tfm: cipher handle\n *\n * The block size for the single block cipher referenced with the cipher handle\n * tfm is returned. The caller may use that information to allocate appropriate\n * memory for the data returned by the encryption or decryption operation\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_cipher_blocksize(struct crypto_cipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_cipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_cipher_alignmask(struct crypto_cipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_cipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_cipher_get_flags(struct crypto_cipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_cipher_tfm(tfm));\n}\n\nstatic inline void crypto_cipher_set_flags(struct crypto_cipher *tfm,\n\t\t\t\t\t   u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_cipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_cipher_clear_flags(struct crypto_cipher *tfm,\n\t\t\t\t\t     u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);\n}\n\n/**\n * crypto_cipher_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the single block cipher referenced by the\n * cipher handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_cipher_setkey(struct crypto_cipher *tfm,\n                                       const u8 *key, unsigned int keylen)\n{\n\treturn crypto_cipher_crt(tfm)->cit_setkey(crypto_cipher_tfm(tfm),\n\t\t\t\t\t\t  key, keylen);\n}\n\n/**\n * crypto_cipher_encrypt_one() - encrypt one block of plaintext\n * @tfm: cipher handle\n * @dst: points to the buffer that will be filled with the ciphertext\n * @src: buffer holding the plaintext to be encrypted\n *\n * Invoke the encryption operation of one block. The caller must ensure that\n * the plaintext and ciphertext buffers are at least one block in size.\n */\nstatic inline void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,\n\t\t\t\t\t     u8 *dst, const u8 *src)\n{\n\tcrypto_cipher_crt(tfm)->cit_encrypt_one(crypto_cipher_tfm(tfm),\n\t\t\t\t\t\tdst, src);\n}\n\n/**\n * crypto_cipher_decrypt_one() - decrypt one block of ciphertext\n * @tfm: cipher handle\n * @dst: points to the buffer that will be filled with the plaintext\n * @src: buffer holding the ciphertext to be decrypted\n *\n * Invoke the decryption operation of one block. The caller must ensure that\n * the plaintext and ciphertext buffers are at least one block in size.\n */\nstatic inline void crypto_cipher_decrypt_one(struct crypto_cipher *tfm,\n\t\t\t\t\t     u8 *dst, const u8 *src)\n{\n\tcrypto_cipher_crt(tfm)->cit_decrypt_one(crypto_cipher_tfm(tfm),\n\t\t\t\t\t\tdst, src);\n}\n\n/**\n * DOC: Synchronous Message Digest API\n *\n * The synchronous message digest API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_HASH (listed as type \"hash\" in /proc/crypto)\n */\n\nstatic inline struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_hash *)tfm;\n}\n\nstatic inline struct crypto_hash *crypto_hash_cast(struct crypto_tfm *tfm)\n{\n\tBUG_ON((crypto_tfm_alg_type(tfm) ^ CRYPTO_ALG_TYPE_HASH) &\n\t       CRYPTO_ALG_TYPE_HASH_MASK);\n\treturn __crypto_hash_cast(tfm);\n}\n\n/**\n * crypto_alloc_hash() - allocate synchronous message digest handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      message digest cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a message digest. The returned struct\n * crypto_hash is the cipher handle that is required for any subsequent\n * API invocation for that message digest.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n * of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct crypto_hash *crypto_alloc_hash(const char *alg_name,\n\t\t\t\t\t\t    u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\tmask &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_HASH;\n\tmask |= CRYPTO_ALG_TYPE_HASH_MASK;\n\n\treturn __crypto_hash_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_hash_tfm(struct crypto_hash *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_hash() - zeroize and free message digest handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_hash(struct crypto_hash *tfm)\n{\n\tcrypto_free_tfm(crypto_hash_tfm(tfm));\n}\n\n/**\n * crypto_has_hash() - Search for the availability of a message digest\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      message digest cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the message digest cipher is known to the kernel crypto\n *\t   API; false otherwise\n */\nstatic inline int crypto_has_hash(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\tmask &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_HASH;\n\tmask |= CRYPTO_ALG_TYPE_HASH_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline struct hash_tfm *crypto_hash_crt(struct crypto_hash *tfm)\n{\n\treturn &crypto_hash_tfm(tfm)->crt_hash;\n}\n\n/**\n * crypto_hash_blocksize() - obtain block size for message digest\n * @tfm: cipher handle\n *\n * The block size for the message digest cipher referenced with the cipher\n * handle is returned.\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_hash_blocksize(struct crypto_hash *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_hash_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_hash_alignmask(struct crypto_hash *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_hash_tfm(tfm));\n}\n\n/**\n * crypto_hash_digestsize() - obtain message digest size\n * @tfm: cipher handle\n *\n * The size for the message digest created by the message digest cipher\n * referenced with the cipher handle is returned.\n *\n * Return: message digest size\n */\nstatic inline unsigned int crypto_hash_digestsize(struct crypto_hash *tfm)\n{\n\treturn crypto_hash_crt(tfm)->digestsize;\n}\n\nstatic inline u32 crypto_hash_get_flags(struct crypto_hash *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_hash_tfm(tfm));\n}\n\nstatic inline void crypto_hash_set_flags(struct crypto_hash *tfm, u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_hash_tfm(tfm), flags);\n}\n\nstatic inline void crypto_hash_clear_flags(struct crypto_hash *tfm, u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_hash_tfm(tfm), flags);\n}\n\n/**\n * crypto_hash_init() - (re)initialize message digest handle\n * @desc: cipher request handle that to be filled by caller --\n *\t  desc.tfm is filled with the hash cipher handle;\n *\t  desc.flags is filled with either CRYPTO_TFM_REQ_MAY_SLEEP or 0.\n *\n * The call (re-)initializes the message digest referenced by the hash cipher\n * request handle. Any potentially existing state created by previous\n * operations is discarded.\n *\n * Return: 0 if the message digest initialization was successful; < 0 if an\n *\t   error occurred\n */\nstatic inline int crypto_hash_init(struct hash_desc *desc)\n{\n\treturn crypto_hash_crt(desc->tfm)->init(desc);\n}\n\n/**\n * crypto_hash_update() - add data to message digest for processing\n * @desc: cipher request handle\n * @sg: scatter / gather list pointing to the data to be added to the message\n *      digest\n * @nbytes: number of bytes to be processed from @sg\n *\n * Updates the message digest state of the cipher handle pointed to by the\n * hash cipher request handle with the input data pointed to by the\n * scatter/gather list.\n *\n * Return: 0 if the message digest update was successful; < 0 if an error\n *\t   occurred\n */\nstatic inline int crypto_hash_update(struct hash_desc *desc,\n\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t     unsigned int nbytes)\n{\n\treturn crypto_hash_crt(desc->tfm)->update(desc, sg, nbytes);\n}\n\n/**\n * crypto_hash_final() - calculate message digest\n * @desc: cipher request handle\n * @out: message digest output buffer -- The caller must ensure that the out\n *\t buffer has a sufficient size (e.g. by using the crypto_hash_digestsize\n *\t function).\n *\n * Finalize the message digest operation and create the message digest\n * based on all data added to the cipher handle. The message digest is placed\n * into the output buffer.\n *\n * Return: 0 if the message digest creation was successful; < 0 if an error\n *\t   occurred\n */\nstatic inline int crypto_hash_final(struct hash_desc *desc, u8 *out)\n{\n\treturn crypto_hash_crt(desc->tfm)->final(desc, out);\n}\n\n/**\n * crypto_hash_digest() - calculate message digest for a buffer\n * @desc: see crypto_hash_final()\n * @sg: see crypto_hash_update()\n * @nbytes:  see crypto_hash_update()\n * @out: see crypto_hash_final()\n *\n * This function is a \"short-hand\" for the function calls of crypto_hash_init,\n * crypto_hash_update and crypto_hash_final. The parameters have the same\n * meaning as discussed for those separate three functions.\n *\n * Return: 0 if the message digest creation was successful; < 0 if an error\n *\t   occurred\n */\nstatic inline int crypto_hash_digest(struct hash_desc *desc,\n\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t     unsigned int nbytes, u8 *out)\n{\n\treturn crypto_hash_crt(desc->tfm)->digest(desc, sg, nbytes, out);\n}\n\n/**\n * crypto_hash_setkey() - set key for message digest\n * @hash: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the message digest cipher. The cipher\n * handle must point to a keyed hash in order for this function to succeed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_hash_setkey(struct crypto_hash *hash,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\treturn crypto_hash_crt(hash)->setkey(hash, key, keylen);\n}\n\nstatic inline struct crypto_comp *__crypto_comp_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_comp *)tfm;\n}\n\nstatic inline struct crypto_comp *crypto_comp_cast(struct crypto_tfm *tfm)\n{\n\tBUG_ON((crypto_tfm_alg_type(tfm) ^ CRYPTO_ALG_TYPE_COMPRESS) &\n\t       CRYPTO_ALG_TYPE_MASK);\n\treturn __crypto_comp_cast(tfm);\n}\n\nstatic inline struct crypto_comp *crypto_alloc_comp(const char *alg_name,\n\t\t\t\t\t\t    u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_COMPRESS;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_comp_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_comp_tfm(struct crypto_comp *tfm)\n{\n\treturn &tfm->base;\n}\n\nstatic inline void crypto_free_comp(struct crypto_comp *tfm)\n{\n\tcrypto_free_tfm(crypto_comp_tfm(tfm));\n}\n\nstatic inline int crypto_has_comp(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_COMPRESS;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline const char *crypto_comp_name(struct crypto_comp *tfm)\n{\n\treturn crypto_tfm_alg_name(crypto_comp_tfm(tfm));\n}\n\nstatic inline struct compress_tfm *crypto_comp_crt(struct crypto_comp *tfm)\n{\n\treturn &crypto_comp_tfm(tfm)->crt_compress;\n}\n\nstatic inline int crypto_comp_compress(struct crypto_comp *tfm,\n                                       const u8 *src, unsigned int slen,\n                                       u8 *dst, unsigned int *dlen)\n{\n\treturn crypto_comp_crt(tfm)->cot_compress(crypto_comp_tfm(tfm),\n\t\t\t\t\t\t  src, slen, dst, dlen);\n}\n\nstatic inline int crypto_comp_decompress(struct crypto_comp *tfm,\n                                         const u8 *src, unsigned int slen,\n                                         u8 *dst, unsigned int *dlen)\n{\n\treturn crypto_comp_crt(tfm)->cot_decompress(crypto_comp_tfm(tfm),\n\t\t\t\t\t\t    src, slen, dst, dlen);\n}\n\n#endif\t/* _LINUX_CRYPTO_H */\n\n"], "fixing_code": ["/*\n * Cryptographic API.\n *\n * RNG operations.\n *\n * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/atomic.h>\n#include <crypto/internal/rng.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/cryptouser.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\nstatic DEFINE_MUTEX(crypto_default_rng_lock);\nstruct crypto_rng *crypto_default_rng;\nEXPORT_SYMBOL_GPL(crypto_default_rng);\nstatic int crypto_default_rng_refcnt;\n\nstatic inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n{\n\treturn container_of(tfm, struct crypto_rng, base);\n}\n\nint crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\n\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n\n\tkfree(buf);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_rng_reset);\n\nstatic int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}\n\nstatic unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\n\treturn ralg->seedsize;\n}\n\n#ifdef CONFIG_NET\nstatic int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.seedsize = seedsize(alg);\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n#else\nstatic int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}\n#endif\n\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n\t__attribute__ ((unused));\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tseq_printf(m, \"type         : rng\\n\");\n\tseq_printf(m, \"seedsize     : %u\\n\", seedsize(alg));\n}\n\nstatic const struct crypto_type crypto_rng_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_rng_init_tfm,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_rng_show,\n#endif\n\t.report = crypto_rng_report,\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_MASK,\n\t.type = CRYPTO_ALG_TYPE_RNG,\n\t.tfmsize = offsetof(struct crypto_rng, base),\n};\n\nstruct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_rng);\n\nint crypto_get_default_rng(void)\n{\n\tstruct crypto_rng *rng;\n\tint err;\n\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!crypto_default_rng) {\n\t\trng = crypto_alloc_rng(\"stdrng\", 0, 0);\n\t\terr = PTR_ERR(rng);\n\t\tif (IS_ERR(rng))\n\t\t\tgoto unlock;\n\n\t\terr = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\t\tif (err) {\n\t\t\tcrypto_free_rng(rng);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcrypto_default_rng = rng;\n\t}\n\n\tcrypto_default_rng_refcnt++;\n\terr = 0;\n\nunlock:\n\tmutex_unlock(&crypto_default_rng_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_get_default_rng);\n\nvoid crypto_put_default_rng(void)\n{\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!--crypto_default_rng_refcnt) {\n\t\tcrypto_free_rng(crypto_default_rng);\n\t\tcrypto_default_rng = NULL;\n\t}\n\tmutex_unlock(&crypto_default_rng_lock);\n}\nEXPORT_SYMBOL_GPL(crypto_put_default_rng);\n\nint crypto_register_rng(struct rng_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (alg->seedsize > PAGE_SIZE / 8)\n\t\treturn -EINVAL;\n\n\tbase->cra_type = &crypto_rng_type;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_RNG;\n\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_rng);\n\nvoid crypto_unregister_rng(struct rng_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_rng);\n\nint crypto_register_rngs(struct rng_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_rng(algs + i);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_register_rngs);\n\nvoid crypto_unregister_rngs(struct rng_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_rngs);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Random Number Generator\");\n", "/*\n * RNG: Random Number Generator  algorithms under the crypto API\n *\n * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#ifndef _CRYPTO_INTERNAL_RNG_H\n#define _CRYPTO_INTERNAL_RNG_H\n\n#include <crypto/algapi.h>\n#include <crypto/rng.h>\n\nint crypto_register_rng(struct rng_alg *alg);\nvoid crypto_unregister_rng(struct rng_alg *alg);\nint crypto_register_rngs(struct rng_alg *algs, int count);\nvoid crypto_unregister_rngs(struct rng_alg *algs, int count);\n\nstatic inline void *crypto_rng_ctx(struct crypto_rng *tfm)\n{\n\treturn crypto_tfm_ctx(&tfm->base);\n}\n\nstatic inline void crypto_rng_set_entropy(struct crypto_rng *tfm,\n\t\t\t\t\t  const u8 *data, unsigned int len)\n{\n\tcrypto_rng_alg(tfm)->set_ent(tfm, data, len);\n}\n\n#endif\n", "/*\n * RNG: Random Number Generator  algorithms under the crypto API\n *\n * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#ifndef _CRYPTO_RNG_H\n#define _CRYPTO_RNG_H\n\n#include <linux/crypto.h>\n\nstruct crypto_rng;\n\n/**\n * struct rng_alg - random number generator definition\n *\n * @generate:\tThe function defined by this variable obtains a\n *\t\trandom number. The random number generator transform\n *\t\tmust generate the random number out of the context\n *\t\tprovided with this call, plus any additional data\n *\t\tif provided to the call.\n * @seed:\tSeed or reseed the random number generator.  With the\n *\t\tinvocation of this function call, the random number\n *\t\tgenerator shall become ready fo generation.  If the\n *\t\trandom number generator requires a seed for setting\n *\t\tup a new state, the seed must be provided by the\n *\t\tconsumer while invoking this function. The required\n *\t\tsize of the seed is defined with @seedsize .\n * @set_ent:\tSet entropy that would otherwise be obtained from\n *\t\tentropy source.  Internal use only.\n * @seedsize:\tThe seed size required for a random number generator\n *\t\tinitialization defined with this variable. Some\n *\t\trandom number generators does not require a seed\n *\t\tas the seeding is implemented internally without\n *\t\tthe need of support by the consumer. In this case,\n *\t\tthe seed size is set to zero.\n * @base:\tCommon crypto API algorithm data structure.\n */\nstruct rng_alg {\n\tint (*generate)(struct crypto_rng *tfm,\n\t\t\tconst u8 *src, unsigned int slen,\n\t\t\tu8 *dst, unsigned int dlen);\n\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n\tvoid (*set_ent)(struct crypto_rng *tfm, const u8 *data,\n\t\t\tunsigned int len);\n\n\tunsigned int seedsize;\n\n\tstruct crypto_alg base;\n};\n\nstruct crypto_rng {\n\tstruct crypto_tfm base;\n};\n\nextern struct crypto_rng *crypto_default_rng;\n\nint crypto_get_default_rng(void);\nvoid crypto_put_default_rng(void);\n\n/**\n * DOC: Random number generator API\n *\n * The random number generator API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_RNG (listed as type \"rng\" in /proc/crypto)\n */\n\n/**\n * crypto_alloc_rng() -- allocate RNG handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      message digest cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a random number generator. The returned struct\n * crypto_rng is the cipher handle that is required for any subsequent\n * API invocation for that random number generator.\n *\n * For all random number generators, this call creates a new private copy of\n * the random number generator that does not share a state with other\n * instances. The only exception is the \"krng\" random number generator which\n * is a kernel crypto API use case for the get_random_bytes() function of the\n * /dev/random driver.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstruct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_rng_tfm(struct crypto_rng *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_rng_alg - obtain name of RNG\n * @tfm: cipher handle\n *\n * Return the generic name (cra_name) of the initialized random number generator\n *\n * Return: generic name string\n */\nstatic inline struct rng_alg *crypto_rng_alg(struct crypto_rng *tfm)\n{\n\treturn container_of(crypto_rng_tfm(tfm)->__crt_alg,\n\t\t\t    struct rng_alg, base);\n}\n\n/**\n * crypto_free_rng() - zeroize and free RNG handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_rng(struct crypto_rng *tfm)\n{\n\tcrypto_destroy_tfm(tfm, crypto_rng_tfm(tfm));\n}\n\n/**\n * crypto_rng_generate() - get random number\n * @tfm: cipher handle\n * @src: Input buffer holding additional data, may be NULL\n * @slen: Length of additional data\n * @dst: output buffer holding the random numbers\n * @dlen: length of the output buffer\n *\n * This function fills the caller-allocated buffer with random\n * numbers using the random number generator referenced by the\n * cipher handle.\n *\n * Return: 0 function was successful; < 0 if an error occurred\n */\nstatic inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n}\n\n/**\n * crypto_rng_get_bytes() - get random number\n * @tfm: cipher handle\n * @rdata: output buffer holding the random numbers\n * @dlen: length of the output buffer\n *\n * This function fills the caller-allocated buffer with random numbers using the\n * random number generator referenced by the cipher handle.\n *\n * Return: 0 function was successful; < 0 if an error occurred\n */\nstatic inline int crypto_rng_get_bytes(struct crypto_rng *tfm,\n\t\t\t\t       u8 *rdata, unsigned int dlen)\n{\n\treturn crypto_rng_generate(tfm, NULL, 0, rdata, dlen);\n}\n\n/**\n * crypto_rng_reset() - re-initialize the RNG\n * @tfm: cipher handle\n * @seed: seed input data\n * @slen: length of the seed input data\n *\n * The reset function completely re-initializes the random number generator\n * referenced by the cipher handle by clearing the current state. The new state\n * is initialized with the caller provided seed or automatically, depending\n * on the random number generator type (the ANSI X9.31 RNG requires\n * caller-provided seed, the SP800-90A DRBGs perform an automatic seeding).\n * The seed is provided as a parameter to this function call. The provided seed\n * should have the length of the seed size defined for the random number\n * generator as defined by crypto_rng_seedsize.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nint crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t     unsigned int slen);\n\n/**\n * crypto_rng_seedsize() - obtain seed size of RNG\n * @tfm: cipher handle\n *\n * The function returns the seed size for the random number generator\n * referenced by the cipher handle. This value may be zero if the random\n * number generator does not implement or require a reseeding. For example,\n * the SP800-90A DRBGs implement an automated reseeding after reaching a\n * pre-defined threshold.\n *\n * Return: seed size for the random number generator\n */\nstatic inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn crypto_rng_alg(tfm)->seedsize;\n}\n\n#endif\n", "/*\n * Scatterlist Cryptographic API.\n *\n * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>\n * Copyright (c) 2002 David S. Miller (davem@redhat.com)\n * Copyright (c) 2005 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * Portions derived from Cryptoapi, by Alexander Kjeldaas <astor@fast.no>\n * and Nettle, by Niels M\u00f6ller.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) \n * any later version.\n *\n */\n#ifndef _LINUX_CRYPTO_H\n#define _LINUX_CRYPTO_H\n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n/*\n * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n * arbitrary modules to be loaded. Loading from userspace may still need the\n * unprefixed names, so retains those aliases as well.\n * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n * expands twice on the same line. Instead, use a separate base name for the\n * alias.\n */\n#define MODULE_ALIAS_CRYPTO(name)\t\\\n\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n\t\t__MODULE_INFO(alias, alias_crypto, \"crypto-\" name)\n\n/*\n * Algorithm masks and types.\n */\n#define CRYPTO_ALG_TYPE_MASK\t\t0x0000000f\n#define CRYPTO_ALG_TYPE_CIPHER\t\t0x00000001\n#define CRYPTO_ALG_TYPE_COMPRESS\t0x00000002\n#define CRYPTO_ALG_TYPE_AEAD\t\t0x00000003\n#define CRYPTO_ALG_TYPE_BLKCIPHER\t0x00000004\n#define CRYPTO_ALG_TYPE_ABLKCIPHER\t0x00000005\n#define CRYPTO_ALG_TYPE_GIVCIPHER\t0x00000006\n#define CRYPTO_ALG_TYPE_DIGEST\t\t0x00000008\n#define CRYPTO_ALG_TYPE_HASH\t\t0x00000008\n#define CRYPTO_ALG_TYPE_SHASH\t\t0x00000009\n#define CRYPTO_ALG_TYPE_AHASH\t\t0x0000000a\n#define CRYPTO_ALG_TYPE_RNG\t\t0x0000000c\n#define CRYPTO_ALG_TYPE_PCOMPRESS\t0x0000000f\n\n#define CRYPTO_ALG_TYPE_HASH_MASK\t0x0000000e\n#define CRYPTO_ALG_TYPE_AHASH_MASK\t0x0000000c\n#define CRYPTO_ALG_TYPE_BLKCIPHER_MASK\t0x0000000c\n\n#define CRYPTO_ALG_LARVAL\t\t0x00000010\n#define CRYPTO_ALG_DEAD\t\t\t0x00000020\n#define CRYPTO_ALG_DYING\t\t0x00000040\n#define CRYPTO_ALG_ASYNC\t\t0x00000080\n\n/*\n * Set this bit if and only if the algorithm requires another algorithm of\n * the same type to handle corner cases.\n */\n#define CRYPTO_ALG_NEED_FALLBACK\t0x00000100\n\n/*\n * This bit is set for symmetric key ciphers that have already been wrapped\n * with a generic IV generator to prevent them from being wrapped again.\n */\n#define CRYPTO_ALG_GENIV\t\t0x00000200\n\n/*\n * Set if the algorithm has passed automated run-time testing.  Note that\n * if there is no run-time testing for a given algorithm it is considered\n * to have passed.\n */\n\n#define CRYPTO_ALG_TESTED\t\t0x00000400\n\n/*\n * Set if the algorithm is an instance that is build from templates.\n */\n#define CRYPTO_ALG_INSTANCE\t\t0x00000800\n\n/* Set this bit if the algorithm provided is hardware accelerated but\n * not available to userspace via instruction set or so.\n */\n#define CRYPTO_ALG_KERN_DRIVER_ONLY\t0x00001000\n\n/*\n * Mark a cipher as a service implementation only usable by another\n * cipher and never by a normal user of the kernel crypto API\n */\n#define CRYPTO_ALG_INTERNAL\t\t0x00002000\n\n/*\n * Transform masks and values (for crt_flags).\n */\n#define CRYPTO_TFM_REQ_MASK\t\t0x000fff00\n#define CRYPTO_TFM_RES_MASK\t\t0xfff00000\n\n#define CRYPTO_TFM_REQ_WEAK_KEY\t\t0x00000100\n#define CRYPTO_TFM_REQ_MAY_SLEEP\t0x00000200\n#define CRYPTO_TFM_REQ_MAY_BACKLOG\t0x00000400\n#define CRYPTO_TFM_RES_WEAK_KEY\t\t0x00100000\n#define CRYPTO_TFM_RES_BAD_KEY_LEN   \t0x00200000\n#define CRYPTO_TFM_RES_BAD_KEY_SCHED \t0x00400000\n#define CRYPTO_TFM_RES_BAD_BLOCK_LEN \t0x00800000\n#define CRYPTO_TFM_RES_BAD_FLAGS \t0x01000000\n\n/*\n * Miscellaneous stuff.\n */\n#define CRYPTO_MAX_ALG_NAME\t\t64\n\n/*\n * The macro CRYPTO_MINALIGN_ATTR (along with the void * type in the actual\n * declaration) is used to ensure that the crypto_tfm context structure is\n * aligned correctly for the given architecture so that there are no alignment\n * faults for C data types.  In particular, this is required on platforms such\n * as arm where pointers are 32-bit aligned but there are data types such as\n * u64 which require 64-bit alignment.\n */\n#define CRYPTO_MINALIGN ARCH_KMALLOC_MINALIGN\n\n#define CRYPTO_MINALIGN_ATTR __attribute__ ((__aligned__(CRYPTO_MINALIGN)))\n\nstruct scatterlist;\nstruct crypto_ablkcipher;\nstruct crypto_async_request;\nstruct crypto_aead;\nstruct crypto_blkcipher;\nstruct crypto_hash;\nstruct crypto_tfm;\nstruct crypto_type;\nstruct aead_givcrypt_request;\nstruct skcipher_givcrypt_request;\n\ntypedef void (*crypto_completion_t)(struct crypto_async_request *req, int err);\n\n/**\n * DOC: Block Cipher Context Data Structures\n *\n * These data structures define the operating context for each block cipher\n * type.\n */\n\nstruct crypto_async_request {\n\tstruct list_head list;\n\tcrypto_completion_t complete;\n\tvoid *data;\n\tstruct crypto_tfm *tfm;\n\n\tu32 flags;\n};\n\nstruct ablkcipher_request {\n\tstruct crypto_async_request base;\n\n\tunsigned int nbytes;\n\n\tvoid *info;\n\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\n/**\n *\tstruct aead_request - AEAD request\n *\t@base: Common attributes for async crypto requests\n *\t@assoclen: Length in bytes of associated data for authentication\n *\t@cryptlen: Length of data to be encrypted or decrypted\n *\t@iv: Initialisation vector\n *\t@assoc: Associated data\n *\t@src: Source data\n *\t@dst: Destination data\n *\t@__ctx: Start of private context data\n */\nstruct aead_request {\n\tstruct crypto_async_request base;\n\n\tunsigned int assoclen;\n\tunsigned int cryptlen;\n\n\tu8 *iv;\n\n\tstruct scatterlist *assoc;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct blkcipher_desc {\n\tstruct crypto_blkcipher *tfm;\n\tvoid *info;\n\tu32 flags;\n};\n\nstruct cipher_desc {\n\tstruct crypto_tfm *tfm;\n\tvoid (*crfn)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tunsigned int (*prfn)(const struct cipher_desc *desc, u8 *dst,\n\t\t\t     const u8 *src, unsigned int nbytes);\n\tvoid *info;\n};\n\nstruct hash_desc {\n\tstruct crypto_hash *tfm;\n\tu32 flags;\n};\n\n/**\n * DOC: Block Cipher Algorithm Definitions\n *\n * These data structures define modular crypto algorithm implementations,\n * managed via crypto_register_alg() and crypto_unregister_alg().\n */\n\n/**\n * struct ablkcipher_alg - asynchronous block cipher definition\n * @min_keysize: Minimum key size supported by the transformation. This is the\n *\t\t smallest key length supported by this transformation algorithm.\n *\t\t This must be set to one of the pre-defined values as this is\n *\t\t not hardware specific. Possible values for this field can be\n *\t\t found via git grep \"_MIN_KEY_SIZE\" include/crypto/\n * @max_keysize: Maximum key size supported by the transformation. This is the\n *\t\t largest key length supported by this transformation algorithm.\n *\t\t This must be set to one of the pre-defined values as this is\n *\t\t not hardware specific. Possible values for this field can be\n *\t\t found via git grep \"_MAX_KEY_SIZE\" include/crypto/\n * @setkey: Set key for the transformation. This function is used to either\n *\t    program a supplied key into the hardware or store the key in the\n *\t    transformation context for programming it later. Note that this\n *\t    function does modify the transformation context. This function can\n *\t    be called multiple times during the existence of the transformation\n *\t    object, so one must make sure the key is properly reprogrammed into\n *\t    the hardware. This function is also responsible for checking the key\n *\t    length for validity. In case a software fallback was put in place in\n *\t    the @cra_init call, this function might need to use the fallback if\n *\t    the algorithm doesn't support all of the key sizes.\n * @encrypt: Encrypt a scatterlist of blocks. This function is used to encrypt\n *\t     the supplied scatterlist containing the blocks of data. The crypto\n *\t     API consumer is responsible for aligning the entries of the\n *\t     scatterlist properly and making sure the chunks are correctly\n *\t     sized. In case a software fallback was put in place in the\n *\t     @cra_init call, this function might need to use the fallback if\n *\t     the algorithm doesn't support all of the key sizes. In case the\n *\t     key was stored in transformation context, the key might need to be\n *\t     re-programmed into the hardware in this function. This function\n *\t     shall not modify the transformation context, as this function may\n *\t     be called in parallel with the same transformation object.\n * @decrypt: Decrypt a single block. This is a reverse counterpart to @encrypt\n *\t     and the conditions are exactly the same.\n * @givencrypt: Update the IV for encryption. With this function, a cipher\n *\t        implementation may provide the function on how to update the IV\n *\t        for encryption.\n * @givdecrypt: Update the IV for decryption. This is the reverse of\n *\t        @givencrypt .\n * @geniv: The transformation implementation may use an \"IV generator\" provided\n *\t   by the kernel crypto API. Several use cases have a predefined\n *\t   approach how IVs are to be updated. For such use cases, the kernel\n *\t   crypto API provides ready-to-use implementations that can be\n *\t   referenced with this variable.\n * @ivsize: IV size applicable for transformation. The consumer must provide an\n *\t    IV of exactly that size to perform the encrypt or decrypt operation.\n *\n * All fields except @givencrypt , @givdecrypt , @geniv and @ivsize are\n * mandatory and must be filled.\n */\nstruct ablkcipher_alg {\n\tint (*setkey)(struct crypto_ablkcipher *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct ablkcipher_request *req);\n\tint (*decrypt)(struct ablkcipher_request *req);\n\tint (*givencrypt)(struct skcipher_givcrypt_request *req);\n\tint (*givdecrypt)(struct skcipher_givcrypt_request *req);\n\n\tconst char *geniv;\n\n\tunsigned int min_keysize;\n\tunsigned int max_keysize;\n\tunsigned int ivsize;\n};\n\n/**\n * struct aead_alg - AEAD cipher definition\n * @maxauthsize: Set the maximum authentication tag size supported by the\n *\t\t transformation. A transformation may support smaller tag sizes.\n *\t\t As the authentication tag is a message digest to ensure the\n *\t\t integrity of the encrypted data, a consumer typically wants the\n *\t\t largest authentication tag possible as defined by this\n *\t\t variable.\n * @setauthsize: Set authentication size for the AEAD transformation. This\n *\t\t function is used to specify the consumer requested size of the\n * \t\t authentication tag to be either generated by the transformation\n *\t\t during encryption or the size of the authentication tag to be\n *\t\t supplied during the decryption operation. This function is also\n *\t\t responsible for checking the authentication tag size for\n *\t\t validity.\n * @setkey: see struct ablkcipher_alg\n * @encrypt: see struct ablkcipher_alg\n * @decrypt: see struct ablkcipher_alg\n * @givencrypt: see struct ablkcipher_alg\n * @givdecrypt: see struct ablkcipher_alg\n * @geniv: see struct ablkcipher_alg\n * @ivsize: see struct ablkcipher_alg\n *\n * All fields except @givencrypt , @givdecrypt , @geniv and @ivsize are\n * mandatory and must be filled.\n */\nstruct aead_alg {\n\tint (*setkey)(struct crypto_aead *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*setauthsize)(struct crypto_aead *tfm, unsigned int authsize);\n\tint (*encrypt)(struct aead_request *req);\n\tint (*decrypt)(struct aead_request *req);\n\tint (*givencrypt)(struct aead_givcrypt_request *req);\n\tint (*givdecrypt)(struct aead_givcrypt_request *req);\n\n\tconst char *geniv;\n\n\tunsigned int ivsize;\n\tunsigned int maxauthsize;\n};\n\n/**\n * struct blkcipher_alg - synchronous block cipher definition\n * @min_keysize: see struct ablkcipher_alg\n * @max_keysize: see struct ablkcipher_alg\n * @setkey: see struct ablkcipher_alg\n * @encrypt: see struct ablkcipher_alg\n * @decrypt: see struct ablkcipher_alg\n * @geniv: see struct ablkcipher_alg\n * @ivsize: see struct ablkcipher_alg\n *\n * All fields except @geniv and @ivsize are mandatory and must be filled.\n */\nstruct blkcipher_alg {\n\tint (*setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct blkcipher_desc *desc,\n\t\t       struct scatterlist *dst, struct scatterlist *src,\n\t\t       unsigned int nbytes);\n\tint (*decrypt)(struct blkcipher_desc *desc,\n\t\t       struct scatterlist *dst, struct scatterlist *src,\n\t\t       unsigned int nbytes);\n\n\tconst char *geniv;\n\n\tunsigned int min_keysize;\n\tunsigned int max_keysize;\n\tunsigned int ivsize;\n};\n\n/**\n * struct cipher_alg - single-block symmetric ciphers definition\n * @cia_min_keysize: Minimum key size supported by the transformation. This is\n *\t\t     the smallest key length supported by this transformation\n *\t\t     algorithm. This must be set to one of the pre-defined\n *\t\t     values as this is not hardware specific. Possible values\n *\t\t     for this field can be found via git grep \"_MIN_KEY_SIZE\"\n *\t\t     include/crypto/\n * @cia_max_keysize: Maximum key size supported by the transformation. This is\n *\t\t    the largest key length supported by this transformation\n *\t\t    algorithm. This must be set to one of the pre-defined values\n *\t\t    as this is not hardware specific. Possible values for this\n *\t\t    field can be found via git grep \"_MAX_KEY_SIZE\"\n *\t\t    include/crypto/\n * @cia_setkey: Set key for the transformation. This function is used to either\n *\t        program a supplied key into the hardware or store the key in the\n *\t        transformation context for programming it later. Note that this\n *\t        function does modify the transformation context. This function\n *\t        can be called multiple times during the existence of the\n *\t        transformation object, so one must make sure the key is properly\n *\t        reprogrammed into the hardware. This function is also\n *\t        responsible for checking the key length for validity.\n * @cia_encrypt: Encrypt a single block. This function is used to encrypt a\n *\t\t single block of data, which must be @cra_blocksize big. This\n *\t\t always operates on a full @cra_blocksize and it is not possible\n *\t\t to encrypt a block of smaller size. The supplied buffers must\n *\t\t therefore also be at least of @cra_blocksize size. Both the\n *\t\t input and output buffers are always aligned to @cra_alignmask.\n *\t\t In case either of the input or output buffer supplied by user\n *\t\t of the crypto API is not aligned to @cra_alignmask, the crypto\n *\t\t API will re-align the buffers. The re-alignment means that a\n *\t\t new buffer will be allocated, the data will be copied into the\n *\t\t new buffer, then the processing will happen on the new buffer,\n *\t\t then the data will be copied back into the original buffer and\n *\t\t finally the new buffer will be freed. In case a software\n *\t\t fallback was put in place in the @cra_init call, this function\n *\t\t might need to use the fallback if the algorithm doesn't support\n *\t\t all of the key sizes. In case the key was stored in\n *\t\t transformation context, the key might need to be re-programmed\n *\t\t into the hardware in this function. This function shall not\n *\t\t modify the transformation context, as this function may be\n *\t\t called in parallel with the same transformation object.\n * @cia_decrypt: Decrypt a single block. This is a reverse counterpart to\n *\t\t @cia_encrypt, and the conditions are exactly the same.\n *\n * All fields are mandatory and must be filled.\n */\nstruct cipher_alg {\n\tunsigned int cia_min_keysize;\n\tunsigned int cia_max_keysize;\n\tint (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t                  unsigned int keylen);\n\tvoid (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tvoid (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n};\n\nstruct compress_alg {\n\tint (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t    unsigned int slen, u8 *dst, unsigned int *dlen);\n\tint (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n};\n\n\n#define cra_ablkcipher\tcra_u.ablkcipher\n#define cra_aead\tcra_u.aead\n#define cra_blkcipher\tcra_u.blkcipher\n#define cra_cipher\tcra_u.cipher\n#define cra_compress\tcra_u.compress\n\n/**\n * struct crypto_alg - definition of a cryptograpic cipher algorithm\n * @cra_flags: Flags describing this transformation. See include/linux/crypto.h\n *\t       CRYPTO_ALG_* flags for the flags which go in here. Those are\n *\t       used for fine-tuning the description of the transformation\n *\t       algorithm.\n * @cra_blocksize: Minimum block size of this transformation. The size in bytes\n *\t\t   of the smallest possible unit which can be transformed with\n *\t\t   this algorithm. The users must respect this value.\n *\t\t   In case of HASH transformation, it is possible for a smaller\n *\t\t   block than @cra_blocksize to be passed to the crypto API for\n *\t\t   transformation, in case of any other transformation type, an\n * \t\t   error will be returned upon any attempt to transform smaller\n *\t\t   than @cra_blocksize chunks.\n * @cra_ctxsize: Size of the operational context of the transformation. This\n *\t\t value informs the kernel crypto API about the memory size\n *\t\t needed to be allocated for the transformation context.\n * @cra_alignmask: Alignment mask for the input and output data buffer. The data\n *\t\t   buffer containing the input data for the algorithm must be\n *\t\t   aligned to this alignment mask. The data buffer for the\n *\t\t   output data must be aligned to this alignment mask. Note that\n *\t\t   the Crypto API will do the re-alignment in software, but\n *\t\t   only under special conditions and there is a performance hit.\n *\t\t   The re-alignment happens at these occasions for different\n *\t\t   @cra_u types: cipher -- For both input data and output data\n *\t\t   buffer; ahash -- For output hash destination buf; shash --\n *\t\t   For output hash destination buf.\n *\t\t   This is needed on hardware which is flawed by design and\n *\t\t   cannot pick data from arbitrary addresses.\n * @cra_priority: Priority of this transformation implementation. In case\n *\t\t  multiple transformations with same @cra_name are available to\n *\t\t  the Crypto API, the kernel will use the one with highest\n *\t\t  @cra_priority.\n * @cra_name: Generic name (usable by multiple implementations) of the\n *\t      transformation algorithm. This is the name of the transformation\n *\t      itself. This field is used by the kernel when looking up the\n *\t      providers of particular transformation.\n * @cra_driver_name: Unique name of the transformation provider. This is the\n *\t\t     name of the provider of the transformation. This can be any\n *\t\t     arbitrary value, but in the usual case, this contains the\n *\t\t     name of the chip or provider and the name of the\n *\t\t     transformation algorithm.\n * @cra_type: Type of the cryptographic transformation. This is a pointer to\n *\t      struct crypto_type, which implements callbacks common for all\n *\t      trasnformation types. There are multiple options:\n *\t      &crypto_blkcipher_type, &crypto_ablkcipher_type,\n *\t      &crypto_ahash_type, &crypto_aead_type, &crypto_rng_type.\n *\t      This field might be empty. In that case, there are no common\n *\t      callbacks. This is the case for: cipher, compress, shash.\n * @cra_u: Callbacks implementing the transformation. This is a union of\n *\t   multiple structures. Depending on the type of transformation selected\n *\t   by @cra_type and @cra_flags above, the associated structure must be\n *\t   filled with callbacks. This field might be empty. This is the case\n *\t   for ahash, shash.\n * @cra_init: Initialize the cryptographic transformation object. This function\n *\t      is used to initialize the cryptographic transformation object.\n *\t      This function is called only once at the instantiation time, right\n *\t      after the transformation context was allocated. In case the\n *\t      cryptographic hardware has some special requirements which need to\n *\t      be handled by software, this function shall check for the precise\n *\t      requirement of the transformation and put any software fallbacks\n *\t      in place.\n * @cra_exit: Deinitialize the cryptographic transformation object. This is a\n *\t      counterpart to @cra_init, used to remove various changes set in\n *\t      @cra_init.\n * @cra_module: Owner of this transformation implementation. Set to THIS_MODULE\n * @cra_list: internally used\n * @cra_users: internally used\n * @cra_refcnt: internally used\n * @cra_destroy: internally used\n *\n * The struct crypto_alg describes a generic Crypto API algorithm and is common\n * for all of the transformations. Any variable not documented here shall not\n * be used by a cipher implementation as it is internal to the Crypto API.\n */\nstruct crypto_alg {\n\tstruct list_head cra_list;\n\tstruct list_head cra_users;\n\n\tu32 cra_flags;\n\tunsigned int cra_blocksize;\n\tunsigned int cra_ctxsize;\n\tunsigned int cra_alignmask;\n\n\tint cra_priority;\n\tatomic_t cra_refcnt;\n\n\tchar cra_name[CRYPTO_MAX_ALG_NAME];\n\tchar cra_driver_name[CRYPTO_MAX_ALG_NAME];\n\n\tconst struct crypto_type *cra_type;\n\n\tunion {\n\t\tstruct ablkcipher_alg ablkcipher;\n\t\tstruct aead_alg aead;\n\t\tstruct blkcipher_alg blkcipher;\n\t\tstruct cipher_alg cipher;\n\t\tstruct compress_alg compress;\n\t} cra_u;\n\n\tint (*cra_init)(struct crypto_tfm *tfm);\n\tvoid (*cra_exit)(struct crypto_tfm *tfm);\n\tvoid (*cra_destroy)(struct crypto_alg *alg);\n\t\n\tstruct module *cra_module;\n};\n\n/*\n * Algorithm registration interface.\n */\nint crypto_register_alg(struct crypto_alg *alg);\nint crypto_unregister_alg(struct crypto_alg *alg);\nint crypto_register_algs(struct crypto_alg *algs, int count);\nint crypto_unregister_algs(struct crypto_alg *algs, int count);\n\n/*\n * Algorithm query interface.\n */\nint crypto_has_alg(const char *name, u32 type, u32 mask);\n\n/*\n * Transforms: user-instantiated objects which encapsulate algorithms\n * and core processing logic.  Managed via crypto_alloc_*() and\n * crypto_free_*(), as well as the various helpers below.\n */\n\nstruct ablkcipher_tfm {\n\tint (*setkey)(struct crypto_ablkcipher *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct ablkcipher_request *req);\n\tint (*decrypt)(struct ablkcipher_request *req);\n\tint (*givencrypt)(struct skcipher_givcrypt_request *req);\n\tint (*givdecrypt)(struct skcipher_givcrypt_request *req);\n\n\tstruct crypto_ablkcipher *base;\n\n\tunsigned int ivsize;\n\tunsigned int reqsize;\n};\n\nstruct aead_tfm {\n\tint (*setkey)(struct crypto_aead *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct aead_request *req);\n\tint (*decrypt)(struct aead_request *req);\n\tint (*givencrypt)(struct aead_givcrypt_request *req);\n\tint (*givdecrypt)(struct aead_givcrypt_request *req);\n\n\tstruct crypto_aead *base;\n\n\tunsigned int ivsize;\n\tunsigned int authsize;\n\tunsigned int reqsize;\n};\n\nstruct blkcipher_tfm {\n\tvoid *iv;\n\tint (*setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t\t      unsigned int keylen);\n\tint (*encrypt)(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes);\n\tint (*decrypt)(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes);\n};\n\nstruct cipher_tfm {\n\tint (*cit_setkey)(struct crypto_tfm *tfm,\n\t                  const u8 *key, unsigned int keylen);\n\tvoid (*cit_encrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tvoid (*cit_decrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n};\n\nstruct hash_tfm {\n\tint (*init)(struct hash_desc *desc);\n\tint (*update)(struct hash_desc *desc,\n\t\t      struct scatterlist *sg, unsigned int nsg);\n\tint (*final)(struct hash_desc *desc, u8 *out);\n\tint (*digest)(struct hash_desc *desc, struct scatterlist *sg,\n\t\t      unsigned int nsg, u8 *out);\n\tint (*setkey)(struct crypto_hash *tfm, const u8 *key,\n\t\t      unsigned int keylen);\n\tunsigned int digestsize;\n};\n\nstruct compress_tfm {\n\tint (*cot_compress)(struct crypto_tfm *tfm,\n\t                    const u8 *src, unsigned int slen,\n\t                    u8 *dst, unsigned int *dlen);\n\tint (*cot_decompress)(struct crypto_tfm *tfm,\n\t                      const u8 *src, unsigned int slen,\n\t                      u8 *dst, unsigned int *dlen);\n};\n\n#define crt_ablkcipher\tcrt_u.ablkcipher\n#define crt_aead\tcrt_u.aead\n#define crt_blkcipher\tcrt_u.blkcipher\n#define crt_cipher\tcrt_u.cipher\n#define crt_hash\tcrt_u.hash\n#define crt_compress\tcrt_u.compress\n\nstruct crypto_tfm {\n\n\tu32 crt_flags;\n\t\n\tunion {\n\t\tstruct ablkcipher_tfm ablkcipher;\n\t\tstruct aead_tfm aead;\n\t\tstruct blkcipher_tfm blkcipher;\n\t\tstruct cipher_tfm cipher;\n\t\tstruct hash_tfm hash;\n\t\tstruct compress_tfm compress;\n\t} crt_u;\n\n\tvoid (*exit)(struct crypto_tfm *tfm);\n\t\n\tstruct crypto_alg *__crt_alg;\n\n\tvoid *__crt_ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct crypto_ablkcipher {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_aead {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_blkcipher {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_cipher {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_comp {\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_hash {\n\tstruct crypto_tfm base;\n};\n\nenum {\n\tCRYPTOA_UNSPEC,\n\tCRYPTOA_ALG,\n\tCRYPTOA_TYPE,\n\tCRYPTOA_U32,\n\t__CRYPTOA_MAX,\n};\n\n#define CRYPTOA_MAX (__CRYPTOA_MAX - 1)\n\n/* Maximum number of (rtattr) parameters for each template. */\n#define CRYPTO_MAX_ATTRS 32\n\nstruct crypto_attr_alg {\n\tchar name[CRYPTO_MAX_ALG_NAME];\n};\n\nstruct crypto_attr_type {\n\tu32 type;\n\tu32 mask;\n};\n\nstruct crypto_attr_u32 {\n\tu32 num;\n};\n\n/* \n * Transform user interface.\n */\n \nstruct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask);\nvoid crypto_destroy_tfm(void *mem, struct crypto_tfm *tfm);\n\nstatic inline void crypto_free_tfm(struct crypto_tfm *tfm)\n{\n\treturn crypto_destroy_tfm(tfm, tfm);\n}\n\nint alg_test(const char *driver, const char *alg, u32 type, u32 mask);\n\n/*\n * Transform helpers which query the underlying algorithm.\n */\nstatic inline const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_name;\n}\n\nstatic inline const char *crypto_tfm_alg_driver_name(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_driver_name;\n}\n\nstatic inline int crypto_tfm_alg_priority(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_priority;\n}\n\nstatic inline u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;\n}\n\nstatic inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_blocksize;\n}\n\nstatic inline unsigned int crypto_tfm_alg_alignmask(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_alignmask;\n}\n\nstatic inline u32 crypto_tfm_get_flags(struct crypto_tfm *tfm)\n{\n\treturn tfm->crt_flags;\n}\n\nstatic inline void crypto_tfm_set_flags(struct crypto_tfm *tfm, u32 flags)\n{\n\ttfm->crt_flags |= flags;\n}\n\nstatic inline void crypto_tfm_clear_flags(struct crypto_tfm *tfm, u32 flags)\n{\n\ttfm->crt_flags &= ~flags;\n}\n\nstatic inline void *crypto_tfm_ctx(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_ctx;\n}\n\nstatic inline unsigned int crypto_tfm_ctx_alignment(void)\n{\n\tstruct crypto_tfm *tfm;\n\treturn __alignof__(tfm->__crt_ctx);\n}\n\n/*\n * API wrappers.\n */\nstatic inline struct crypto_ablkcipher *__crypto_ablkcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\treturn (struct crypto_ablkcipher *)tfm;\n}\n\nstatic inline u32 crypto_skcipher_type(u32 type)\n{\n\ttype &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\n\ttype |= CRYPTO_ALG_TYPE_BLKCIPHER;\n\treturn type;\n}\n\nstatic inline u32 crypto_skcipher_mask(u32 mask)\n{\n\tmask &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\n\tmask |= CRYPTO_ALG_TYPE_BLKCIPHER_MASK;\n\treturn mask;\n}\n\n/**\n * DOC: Asynchronous Block Cipher API\n *\n * Asynchronous block cipher API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_ABLKCIPHER (listed as type \"ablkcipher\" in /proc/crypto).\n *\n * Asynchronous cipher operations imply that the function invocation for a\n * cipher request returns immediately before the completion of the operation.\n * The cipher request is scheduled as a separate kernel thread and therefore\n * load-balanced on the different CPUs via the process scheduler. To allow\n * the kernel crypto API to inform the caller about the completion of a cipher\n * request, the caller must provide a callback function. That function is\n * invoked with the cipher handle when the request completes.\n *\n * To support the asynchronous operation, additional information than just the\n * cipher handle must be supplied to the kernel crypto API. That additional\n * information is given by filling in the ablkcipher_request data structure.\n *\n * For the asynchronous block cipher API, the state is maintained with the tfm\n * cipher handle. A single tfm can be used across multiple calls and in\n * parallel. For asynchronous block cipher calls, context data supplied and\n * only used by the caller can be referenced the request data structure in\n * addition to the IV used for the cipher request. The maintenance of such\n * state information would be important for a crypto driver implementer to\n * have, because when calling the callback function upon completion of the\n * cipher operation, that callback function may need some information about\n * which operation just finished if it invoked multiple in parallel. This\n * state information is unused by the kernel crypto API.\n */\n\n/**\n * crypto_alloc_ablkcipher() - allocate asynchronous block cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      ablkcipher cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for an ablkcipher. The returned struct\n * crypto_ablkcipher is the cipher handle that is required for any subsequent\n * API invocation for that ablkcipher.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstruct crypto_ablkcipher *crypto_alloc_ablkcipher(const char *alg_name,\n\t\t\t\t\t\t  u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_ablkcipher_tfm(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_ablkcipher() - zeroize and free cipher handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_ablkcipher(struct crypto_ablkcipher *tfm)\n{\n\tcrypto_free_tfm(crypto_ablkcipher_tfm(tfm));\n}\n\n/**\n * crypto_has_ablkcipher() - Search for the availability of an ablkcipher.\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      ablkcipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the ablkcipher is known to the kernel crypto API; false\n *\t   otherwise\n */\nstatic inline int crypto_has_ablkcipher(const char *alg_name, u32 type,\n\t\t\t\t\tu32 mask)\n{\n\treturn crypto_has_alg(alg_name, crypto_skcipher_type(type),\n\t\t\t      crypto_skcipher_mask(mask));\n}\n\nstatic inline struct ablkcipher_tfm *crypto_ablkcipher_crt(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn &crypto_ablkcipher_tfm(tfm)->crt_ablkcipher;\n}\n\n/**\n * crypto_ablkcipher_ivsize() - obtain IV size\n * @tfm: cipher handle\n *\n * The size of the IV for the ablkcipher referenced by the cipher handle is\n * returned. This IV size may be zero if the cipher does not need an IV.\n *\n * Return: IV size in bytes\n */\nstatic inline unsigned int crypto_ablkcipher_ivsize(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_ablkcipher_crt(tfm)->ivsize;\n}\n\n/**\n * crypto_ablkcipher_blocksize() - obtain block size of cipher\n * @tfm: cipher handle\n *\n * The block size for the ablkcipher referenced with the cipher handle is\n * returned. The caller may use that information to allocate appropriate\n * memory for the data returned by the encryption or decryption operation\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_ablkcipher_blocksize(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_ablkcipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_ablkcipher_alignmask(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_ablkcipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_ablkcipher_get_flags(struct crypto_ablkcipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_ablkcipher_tfm(tfm));\n}\n\nstatic inline void crypto_ablkcipher_set_flags(struct crypto_ablkcipher *tfm,\n\t\t\t\t\t       u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_ablkcipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_ablkcipher_clear_flags(struct crypto_ablkcipher *tfm,\n\t\t\t\t\t\t u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_ablkcipher_tfm(tfm), flags);\n}\n\n/**\n * crypto_ablkcipher_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the ablkcipher referenced by the cipher\n * handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_ablkcipher_setkey(struct crypto_ablkcipher *tfm,\n\t\t\t\t\t   const u8 *key, unsigned int keylen)\n{\n\tstruct ablkcipher_tfm *crt = crypto_ablkcipher_crt(tfm);\n\n\treturn crt->setkey(crt->base, key, keylen);\n}\n\n/**\n * crypto_ablkcipher_reqtfm() - obtain cipher handle from request\n * @req: ablkcipher_request out of which the cipher handle is to be obtained\n *\n * Return the crypto_ablkcipher handle when furnishing an ablkcipher_request\n * data structure.\n *\n * Return: crypto_ablkcipher handle\n */\nstatic inline struct crypto_ablkcipher *crypto_ablkcipher_reqtfm(\n\tstruct ablkcipher_request *req)\n{\n\treturn __crypto_ablkcipher_cast(req->base.tfm);\n}\n\n/**\n * crypto_ablkcipher_encrypt() - encrypt plaintext\n * @req: reference to the ablkcipher_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Encrypt plaintext data using the ablkcipher_request handle. That data\n * structure and how it is filled with data is discussed with the\n * ablkcipher_request_* functions.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_ablkcipher_encrypt(struct ablkcipher_request *req)\n{\n\tstruct ablkcipher_tfm *crt =\n\t\tcrypto_ablkcipher_crt(crypto_ablkcipher_reqtfm(req));\n\treturn crt->encrypt(req);\n}\n\n/**\n * crypto_ablkcipher_decrypt() - decrypt ciphertext\n * @req: reference to the ablkcipher_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Decrypt ciphertext data using the ablkcipher_request handle. That data\n * structure and how it is filled with data is discussed with the\n * ablkcipher_request_* functions.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_ablkcipher_decrypt(struct ablkcipher_request *req)\n{\n\tstruct ablkcipher_tfm *crt =\n\t\tcrypto_ablkcipher_crt(crypto_ablkcipher_reqtfm(req));\n\treturn crt->decrypt(req);\n}\n\n/**\n * DOC: Asynchronous Cipher Request Handle\n *\n * The ablkcipher_request data structure contains all pointers to data\n * required for the asynchronous cipher operation. This includes the cipher\n * handle (which can be used by multiple ablkcipher_request instances), pointer\n * to plaintext and ciphertext, asynchronous callback function, etc. It acts\n * as a handle to the ablkcipher_request_* API calls in a similar way as\n * ablkcipher handle to the crypto_ablkcipher_* API calls.\n */\n\n/**\n * crypto_ablkcipher_reqsize() - obtain size of the request data structure\n * @tfm: cipher handle\n *\n * Return: number of bytes\n */\nstatic inline unsigned int crypto_ablkcipher_reqsize(\n\tstruct crypto_ablkcipher *tfm)\n{\n\treturn crypto_ablkcipher_crt(tfm)->reqsize;\n}\n\n/**\n * ablkcipher_request_set_tfm() - update cipher handle reference in request\n * @req: request handle to be modified\n * @tfm: cipher handle that shall be added to the request handle\n *\n * Allow the caller to replace the existing ablkcipher handle in the request\n * data structure with a different one.\n */\nstatic inline void ablkcipher_request_set_tfm(\n\tstruct ablkcipher_request *req, struct crypto_ablkcipher *tfm)\n{\n\treq->base.tfm = crypto_ablkcipher_tfm(crypto_ablkcipher_crt(tfm)->base);\n}\n\nstatic inline struct ablkcipher_request *ablkcipher_request_cast(\n\tstruct crypto_async_request *req)\n{\n\treturn container_of(req, struct ablkcipher_request, base);\n}\n\n/**\n * ablkcipher_request_alloc() - allocate request data structure\n * @tfm: cipher handle to be registered with the request\n * @gfp: memory allocation flag that is handed to kmalloc by the API call.\n *\n * Allocate the request data structure that must be used with the ablkcipher\n * encrypt and decrypt API calls. During the allocation, the provided ablkcipher\n * handle is registered in the request data structure.\n *\n * Return: allocated request handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct ablkcipher_request *ablkcipher_request_alloc(\n\tstruct crypto_ablkcipher *tfm, gfp_t gfp)\n{\n\tstruct ablkcipher_request *req;\n\n\treq = kmalloc(sizeof(struct ablkcipher_request) +\n\t\t      crypto_ablkcipher_reqsize(tfm), gfp);\n\n\tif (likely(req))\n\t\tablkcipher_request_set_tfm(req, tfm);\n\n\treturn req;\n}\n\n/**\n * ablkcipher_request_free() - zeroize and free request data structure\n * @req: request data structure cipher handle to be freed\n */\nstatic inline void ablkcipher_request_free(struct ablkcipher_request *req)\n{\n\tkzfree(req);\n}\n\n/**\n * ablkcipher_request_set_callback() - set asynchronous callback function\n * @req: request handle\n * @flags: specify zero or an ORing of the flags\n *         CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and\n *\t   increase the wait queue beyond the initial maximum size;\n *\t   CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep\n * @compl: callback function pointer to be registered with the request handle\n * @data: The data pointer refers to memory that is not used by the kernel\n *\t  crypto API, but provided to the callback function for it to use. Here,\n *\t  the caller can provide a reference to memory the callback function can\n *\t  operate on. As the callback function is invoked asynchronously to the\n *\t  related functionality, it may need to access data structures of the\n *\t  related functionality which can be referenced using this pointer. The\n *\t  callback function can access the memory via the \"data\" field in the\n *\t  crypto_async_request data structure provided to the callback function.\n *\n * This function allows setting the callback function that is triggered once the\n * cipher operation completes.\n *\n * The callback function is registered with the ablkcipher_request handle and\n * must comply with the following template\n *\n *\tvoid callback_function(struct crypto_async_request *req, int error)\n */\nstatic inline void ablkcipher_request_set_callback(\n\tstruct ablkcipher_request *req,\n\tu32 flags, crypto_completion_t compl, void *data)\n{\n\treq->base.complete = compl;\n\treq->base.data = data;\n\treq->base.flags = flags;\n}\n\n/**\n * ablkcipher_request_set_crypt() - set data buffers\n * @req: request handle\n * @src: source scatter / gather list\n * @dst: destination scatter / gather list\n * @nbytes: number of bytes to process from @src\n * @iv: IV for the cipher operation which must comply with the IV size defined\n *      by crypto_ablkcipher_ivsize\n *\n * This function allows setting of the source data and destination data\n * scatter / gather lists.\n *\n * For encryption, the source is treated as the plaintext and the\n * destination is the ciphertext. For a decryption operation, the use is\n * reversed - the source is the ciphertext and the destination is the plaintext.\n */\nstatic inline void ablkcipher_request_set_crypt(\n\tstruct ablkcipher_request *req,\n\tstruct scatterlist *src, struct scatterlist *dst,\n\tunsigned int nbytes, void *iv)\n{\n\treq->src = src;\n\treq->dst = dst;\n\treq->nbytes = nbytes;\n\treq->info = iv;\n}\n\n/**\n * DOC: Authenticated Encryption With Associated Data (AEAD) Cipher API\n *\n * The AEAD cipher API is used with the ciphers of type CRYPTO_ALG_TYPE_AEAD\n * (listed as type \"aead\" in /proc/crypto)\n *\n * The most prominent examples for this type of encryption is GCM and CCM.\n * However, the kernel supports other types of AEAD ciphers which are defined\n * with the following cipher string:\n *\n *\tauthenc(keyed message digest, block cipher)\n *\n * For example: authenc(hmac(sha256), cbc(aes))\n *\n * The example code provided for the asynchronous block cipher operation\n * applies here as well. Naturally all *ablkcipher* symbols must be exchanged\n * the *aead* pendants discussed in the following. In addtion, for the AEAD\n * operation, the aead_request_set_assoc function must be used to set the\n * pointer to the associated data memory location before performing the\n * encryption or decryption operation. In case of an encryption, the associated\n * data memory is filled during the encryption operation. For decryption, the\n * associated data memory must contain data that is used to verify the integrity\n * of the decrypted data. Another deviation from the asynchronous block cipher\n * operation is that the caller should explicitly check for -EBADMSG of the\n * crypto_aead_decrypt. That error indicates an authentication error, i.e.\n * a breach in the integrity of the message. In essence, that -EBADMSG error\n * code is the key bonus an AEAD cipher has over \"standard\" block chaining\n * modes.\n */\n\nstatic inline struct crypto_aead *__crypto_aead_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_aead *)tfm;\n}\n\n/**\n * crypto_alloc_aead() - allocate AEAD cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t     AEAD cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for an AEAD. The returned struct\n * crypto_aead is the cipher handle that is required for any subsequent\n * API invocation for that AEAD.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstruct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_aead_tfm(struct crypto_aead *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_aead() - zeroize and free aead handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_aead(struct crypto_aead *tfm)\n{\n\tcrypto_free_tfm(crypto_aead_tfm(tfm));\n}\n\nstatic inline struct aead_tfm *crypto_aead_crt(struct crypto_aead *tfm)\n{\n\treturn &crypto_aead_tfm(tfm)->crt_aead;\n}\n\n/**\n * crypto_aead_ivsize() - obtain IV size\n * @tfm: cipher handle\n *\n * The size of the IV for the aead referenced by the cipher handle is\n * returned. This IV size may be zero if the cipher does not need an IV.\n *\n * Return: IV size in bytes\n */\nstatic inline unsigned int crypto_aead_ivsize(struct crypto_aead *tfm)\n{\n\treturn crypto_aead_crt(tfm)->ivsize;\n}\n\n/**\n * crypto_aead_authsize() - obtain maximum authentication data size\n * @tfm: cipher handle\n *\n * The maximum size of the authentication data for the AEAD cipher referenced\n * by the AEAD cipher handle is returned. The authentication data size may be\n * zero if the cipher implements a hard-coded maximum.\n *\n * The authentication data may also be known as \"tag value\".\n *\n * Return: authentication data size / tag size in bytes\n */\nstatic inline unsigned int crypto_aead_authsize(struct crypto_aead *tfm)\n{\n\treturn crypto_aead_crt(tfm)->authsize;\n}\n\n/**\n * crypto_aead_blocksize() - obtain block size of cipher\n * @tfm: cipher handle\n *\n * The block size for the AEAD referenced with the cipher handle is returned.\n * The caller may use that information to allocate appropriate memory for the\n * data returned by the encryption or decryption operation\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_aead_blocksize(struct crypto_aead *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_aead_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_aead_alignmask(struct crypto_aead *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_aead_tfm(tfm));\n}\n\nstatic inline u32 crypto_aead_get_flags(struct crypto_aead *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_aead_tfm(tfm));\n}\n\nstatic inline void crypto_aead_set_flags(struct crypto_aead *tfm, u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_aead_tfm(tfm), flags);\n}\n\nstatic inline void crypto_aead_clear_flags(struct crypto_aead *tfm, u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_aead_tfm(tfm), flags);\n}\n\n/**\n * crypto_aead_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the AEAD referenced by the cipher\n * handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t     unsigned int keylen)\n{\n\tstruct aead_tfm *crt = crypto_aead_crt(tfm);\n\n\treturn crt->setkey(crt->base, key, keylen);\n}\n\n/**\n * crypto_aead_setauthsize() - set authentication data size\n * @tfm: cipher handle\n * @authsize: size of the authentication data / tag in bytes\n *\n * Set the authentication data size / tag size. AEAD requires an authentication\n * tag (or MAC) in addition to the associated data.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nint crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize);\n\nstatic inline struct crypto_aead *crypto_aead_reqtfm(struct aead_request *req)\n{\n\treturn __crypto_aead_cast(req->base.tfm);\n}\n\n/**\n * crypto_aead_encrypt() - encrypt plaintext\n * @req: reference to the aead_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Encrypt plaintext data using the aead_request handle. That data structure\n * and how it is filled with data is discussed with the aead_request_*\n * functions.\n *\n * IMPORTANT NOTE The encryption operation creates the authentication data /\n *\t\t  tag. That data is concatenated with the created ciphertext.\n *\t\t  The ciphertext memory size is therefore the given number of\n *\t\t  block cipher blocks + the size defined by the\n *\t\t  crypto_aead_setauthsize invocation. The caller must ensure\n *\t\t  that sufficient memory is available for the ciphertext and\n *\t\t  the authentication tag.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_aead_encrypt(struct aead_request *req)\n{\n\treturn crypto_aead_crt(crypto_aead_reqtfm(req))->encrypt(req);\n}\n\n/**\n * crypto_aead_decrypt() - decrypt ciphertext\n * @req: reference to the ablkcipher_request handle that holds all information\n *\t needed to perform the cipher operation\n *\n * Decrypt ciphertext data using the aead_request handle. That data structure\n * and how it is filled with data is discussed with the aead_request_*\n * functions.\n *\n * IMPORTANT NOTE The caller must concatenate the ciphertext followed by the\n *\t\t  authentication data / tag. That authentication data / tag\n *\t\t  must have the size defined by the crypto_aead_setauthsize\n *\t\t  invocation.\n *\n *\n * Return: 0 if the cipher operation was successful; -EBADMSG: The AEAD\n *\t   cipher operation performs the authentication of the data during the\n *\t   decryption operation. Therefore, the function returns this error if\n *\t   the authentication of the ciphertext was unsuccessful (i.e. the\n *\t   integrity of the ciphertext or the associated data was violated);\n *\t   < 0 if an error occurred.\n */\nstatic inline int crypto_aead_decrypt(struct aead_request *req)\n{\n\tif (req->cryptlen < crypto_aead_authsize(crypto_aead_reqtfm(req)))\n\t\treturn -EINVAL;\n\n\treturn crypto_aead_crt(crypto_aead_reqtfm(req))->decrypt(req);\n}\n\n/**\n * DOC: Asynchronous AEAD Request Handle\n *\n * The aead_request data structure contains all pointers to data required for\n * the AEAD cipher operation. This includes the cipher handle (which can be\n * used by multiple aead_request instances), pointer to plaintext and\n * ciphertext, asynchronous callback function, etc. It acts as a handle to the\n * aead_request_* API calls in a similar way as AEAD handle to the\n * crypto_aead_* API calls.\n */\n\n/**\n * crypto_aead_reqsize() - obtain size of the request data structure\n * @tfm: cipher handle\n *\n * Return: number of bytes\n */\nstatic inline unsigned int crypto_aead_reqsize(struct crypto_aead *tfm)\n{\n\treturn crypto_aead_crt(tfm)->reqsize;\n}\n\n/**\n * aead_request_set_tfm() - update cipher handle reference in request\n * @req: request handle to be modified\n * @tfm: cipher handle that shall be added to the request handle\n *\n * Allow the caller to replace the existing aead handle in the request\n * data structure with a different one.\n */\nstatic inline void aead_request_set_tfm(struct aead_request *req,\n\t\t\t\t\tstruct crypto_aead *tfm)\n{\n\treq->base.tfm = crypto_aead_tfm(crypto_aead_crt(tfm)->base);\n}\n\n/**\n * aead_request_alloc() - allocate request data structure\n * @tfm: cipher handle to be registered with the request\n * @gfp: memory allocation flag that is handed to kmalloc by the API call.\n *\n * Allocate the request data structure that must be used with the AEAD\n * encrypt and decrypt API calls. During the allocation, the provided aead\n * handle is registered in the request data structure.\n *\n * Return: allocated request handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct aead_request *aead_request_alloc(struct crypto_aead *tfm,\n\t\t\t\t\t\t      gfp_t gfp)\n{\n\tstruct aead_request *req;\n\n\treq = kmalloc(sizeof(*req) + crypto_aead_reqsize(tfm), gfp);\n\n\tif (likely(req))\n\t\taead_request_set_tfm(req, tfm);\n\n\treturn req;\n}\n\n/**\n * aead_request_free() - zeroize and free request data structure\n * @req: request data structure cipher handle to be freed\n */\nstatic inline void aead_request_free(struct aead_request *req)\n{\n\tkzfree(req);\n}\n\n/**\n * aead_request_set_callback() - set asynchronous callback function\n * @req: request handle\n * @flags: specify zero or an ORing of the flags\n *\t   CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and\n *\t   increase the wait queue beyond the initial maximum size;\n *\t   CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep\n * @compl: callback function pointer to be registered with the request handle\n * @data: The data pointer refers to memory that is not used by the kernel\n *\t  crypto API, but provided to the callback function for it to use. Here,\n *\t  the caller can provide a reference to memory the callback function can\n *\t  operate on. As the callback function is invoked asynchronously to the\n *\t  related functionality, it may need to access data structures of the\n *\t  related functionality which can be referenced using this pointer. The\n *\t  callback function can access the memory via the \"data\" field in the\n *\t  crypto_async_request data structure provided to the callback function.\n *\n * Setting the callback function that is triggered once the cipher operation\n * completes\n *\n * The callback function is registered with the aead_request handle and\n * must comply with the following template\n *\n *\tvoid callback_function(struct crypto_async_request *req, int error)\n */\nstatic inline void aead_request_set_callback(struct aead_request *req,\n\t\t\t\t\t     u32 flags,\n\t\t\t\t\t     crypto_completion_t compl,\n\t\t\t\t\t     void *data)\n{\n\treq->base.complete = compl;\n\treq->base.data = data;\n\treq->base.flags = flags;\n}\n\n/**\n * aead_request_set_crypt - set data buffers\n * @req: request handle\n * @src: source scatter / gather list\n * @dst: destination scatter / gather list\n * @cryptlen: number of bytes to process from @src\n * @iv: IV for the cipher operation which must comply with the IV size defined\n *      by crypto_aead_ivsize()\n *\n * Setting the source data and destination data scatter / gather lists.\n *\n * For encryption, the source is treated as the plaintext and the\n * destination is the ciphertext. For a decryption operation, the use is\n * reversed - the source is the ciphertext and the destination is the plaintext.\n *\n * IMPORTANT NOTE AEAD requires an authentication tag (MAC). For decryption,\n *\t\t  the caller must concatenate the ciphertext followed by the\n *\t\t  authentication tag and provide the entire data stream to the\n *\t\t  decryption operation (i.e. the data length used for the\n *\t\t  initialization of the scatterlist and the data length for the\n *\t\t  decryption operation is identical). For encryption, however,\n *\t\t  the authentication tag is created while encrypting the data.\n *\t\t  The destination buffer must hold sufficient space for the\n *\t\t  ciphertext and the authentication tag while the encryption\n *\t\t  invocation must only point to the plaintext data size. The\n *\t\t  following code snippet illustrates the memory usage\n *\t\t  buffer = kmalloc(ptbuflen + (enc ? authsize : 0));\n *\t\t  sg_init_one(&sg, buffer, ptbuflen + (enc ? authsize : 0));\n *\t\t  aead_request_set_crypt(req, &sg, &sg, ptbuflen, iv);\n */\nstatic inline void aead_request_set_crypt(struct aead_request *req,\n\t\t\t\t\t  struct scatterlist *src,\n\t\t\t\t\t  struct scatterlist *dst,\n\t\t\t\t\t  unsigned int cryptlen, u8 *iv)\n{\n\treq->src = src;\n\treq->dst = dst;\n\treq->cryptlen = cryptlen;\n\treq->iv = iv;\n}\n\n/**\n * aead_request_set_assoc() - set the associated data scatter / gather list\n * @req: request handle\n * @assoc: associated data scatter / gather list\n * @assoclen: number of bytes to process from @assoc\n *\n * For encryption, the memory is filled with the associated data. For\n * decryption, the memory must point to the associated data.\n */\nstatic inline void aead_request_set_assoc(struct aead_request *req,\n\t\t\t\t\t  struct scatterlist *assoc,\n\t\t\t\t\t  unsigned int assoclen)\n{\n\treq->assoc = assoc;\n\treq->assoclen = assoclen;\n}\n\n/**\n * DOC: Synchronous Block Cipher API\n *\n * The synchronous block cipher API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_BLKCIPHER (listed as type \"blkcipher\" in /proc/crypto)\n *\n * Synchronous calls, have a context in the tfm. But since a single tfm can be\n * used in multiple calls and in parallel, this info should not be changeable\n * (unless a lock is used). This applies, for example, to the symmetric key.\n * However, the IV is changeable, so there is an iv field in blkcipher_tfm\n * structure for synchronous blkcipher api. So, its the only state info that can\n * be kept for synchronous calls without using a big lock across a tfm.\n *\n * The block cipher API allows the use of a complete cipher, i.e. a cipher\n * consisting of a template (a block chaining mode) and a single block cipher\n * primitive (e.g. AES).\n *\n * The plaintext data buffer and the ciphertext data buffer are pointed to\n * by using scatter/gather lists. The cipher operation is performed\n * on all segments of the provided scatter/gather lists.\n *\n * The kernel crypto API supports a cipher operation \"in-place\" which means that\n * the caller may provide the same scatter/gather list for the plaintext and\n * cipher text. After the completion of the cipher operation, the plaintext\n * data is replaced with the ciphertext data in case of an encryption and vice\n * versa for a decryption. The caller must ensure that the scatter/gather lists\n * for the output data point to sufficiently large buffers, i.e. multiples of\n * the block size of the cipher.\n */\n\nstatic inline struct crypto_blkcipher *__crypto_blkcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\treturn (struct crypto_blkcipher *)tfm;\n}\n\nstatic inline struct crypto_blkcipher *crypto_blkcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\tBUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_BLKCIPHER);\n\treturn __crypto_blkcipher_cast(tfm);\n}\n\n/**\n * crypto_alloc_blkcipher() - allocate synchronous block cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      blkcipher cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a block cipher. The returned struct\n * crypto_blkcipher is the cipher handle that is required for any subsequent\n * API invocation for that block cipher.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct crypto_blkcipher *crypto_alloc_blkcipher(\n\tconst char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_BLKCIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_blkcipher_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_blkcipher_tfm(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_blkcipher() - zeroize and free the block cipher handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_blkcipher(struct crypto_blkcipher *tfm)\n{\n\tcrypto_free_tfm(crypto_blkcipher_tfm(tfm));\n}\n\n/**\n * crypto_has_blkcipher() - Search for the availability of a block cipher\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      block cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the block cipher is known to the kernel crypto API; false\n *\t   otherwise\n */\nstatic inline int crypto_has_blkcipher(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_BLKCIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\n/**\n * crypto_blkcipher_name() - return the name / cra_name from the cipher handle\n * @tfm: cipher handle\n *\n * Return: The character string holding the name of the cipher\n */\nstatic inline const char *crypto_blkcipher_name(struct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_alg_name(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline struct blkcipher_tfm *crypto_blkcipher_crt(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn &crypto_blkcipher_tfm(tfm)->crt_blkcipher;\n}\n\nstatic inline struct blkcipher_alg *crypto_blkcipher_alg(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn &crypto_blkcipher_tfm(tfm)->__crt_alg->cra_blkcipher;\n}\n\n/**\n * crypto_blkcipher_ivsize() - obtain IV size\n * @tfm: cipher handle\n *\n * The size of the IV for the block cipher referenced by the cipher handle is\n * returned. This IV size may be zero if the cipher does not need an IV.\n *\n * Return: IV size in bytes\n */\nstatic inline unsigned int crypto_blkcipher_ivsize(struct crypto_blkcipher *tfm)\n{\n\treturn crypto_blkcipher_alg(tfm)->ivsize;\n}\n\n/**\n * crypto_blkcipher_blocksize() - obtain block size of cipher\n * @tfm: cipher handle\n *\n * The block size for the block cipher referenced with the cipher handle is\n * returned. The caller may use that information to allocate appropriate\n * memory for the data returned by the encryption or decryption operation.\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_blkcipher_blocksize(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_blkcipher_alignmask(\n\tstruct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_blkcipher_get_flags(struct crypto_blkcipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_blkcipher_tfm(tfm));\n}\n\nstatic inline void crypto_blkcipher_set_flags(struct crypto_blkcipher *tfm,\n\t\t\t\t\t      u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_blkcipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_blkcipher_clear_flags(struct crypto_blkcipher *tfm,\n\t\t\t\t\t\tu32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_blkcipher_tfm(tfm), flags);\n}\n\n/**\n * crypto_blkcipher_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the block cipher referenced by the cipher\n * handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_setkey(struct crypto_blkcipher *tfm,\n\t\t\t\t\t  const u8 *key, unsigned int keylen)\n{\n\treturn crypto_blkcipher_crt(tfm)->setkey(crypto_blkcipher_tfm(tfm),\n\t\t\t\t\t\t key, keylen);\n}\n\n/**\n * crypto_blkcipher_encrypt() - encrypt plaintext\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tciphertext\n * @src: scatter/gather list that holds the plaintext\n * @nbytes: number of bytes of the plaintext to encrypt.\n *\n * Encrypt plaintext data using the IV set by the caller with a preceding\n * call of crypto_blkcipher_set_iv.\n *\n * The blkcipher_desc data structure must be filled by the caller and can\n * reside on the stack. The caller must fill desc as follows: desc.tfm is filled\n * with the block cipher handle; desc.flags is filled with either\n * CRYPTO_TFM_REQ_MAY_SLEEP or 0.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_encrypt(struct blkcipher_desc *desc,\n\t\t\t\t\t   struct scatterlist *dst,\n\t\t\t\t\t   struct scatterlist *src,\n\t\t\t\t\t   unsigned int nbytes)\n{\n\tdesc->info = crypto_blkcipher_crt(desc->tfm)->iv;\n\treturn crypto_blkcipher_crt(desc->tfm)->encrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_encrypt_iv() - encrypt plaintext with dedicated IV\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tciphertext\n * @src: scatter/gather list that holds the plaintext\n * @nbytes: number of bytes of the plaintext to encrypt.\n *\n * Encrypt plaintext data with the use of an IV that is solely used for this\n * cipher operation. Any previously set IV is not used.\n *\n * The blkcipher_desc data structure must be filled by the caller and can\n * reside on the stack. The caller must fill desc as follows: desc.tfm is filled\n * with the block cipher handle; desc.info is filled with the IV to be used for\n * the current operation; desc.flags is filled with either\n * CRYPTO_TFM_REQ_MAY_SLEEP or 0.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_encrypt_iv(struct blkcipher_desc *desc,\n\t\t\t\t\t      struct scatterlist *dst,\n\t\t\t\t\t      struct scatterlist *src,\n\t\t\t\t\t      unsigned int nbytes)\n{\n\treturn crypto_blkcipher_crt(desc->tfm)->encrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_decrypt() - decrypt ciphertext\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tplaintext\n * @src: scatter/gather list that holds the ciphertext\n * @nbytes: number of bytes of the ciphertext to decrypt.\n *\n * Decrypt ciphertext data using the IV set by the caller with a preceding\n * call of crypto_blkcipher_set_iv.\n *\n * The blkcipher_desc data structure must be filled by the caller as documented\n * for the crypto_blkcipher_encrypt call above.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n *\n */\nstatic inline int crypto_blkcipher_decrypt(struct blkcipher_desc *desc,\n\t\t\t\t\t   struct scatterlist *dst,\n\t\t\t\t\t   struct scatterlist *src,\n\t\t\t\t\t   unsigned int nbytes)\n{\n\tdesc->info = crypto_blkcipher_crt(desc->tfm)->iv;\n\treturn crypto_blkcipher_crt(desc->tfm)->decrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_decrypt_iv() - decrypt ciphertext with dedicated IV\n * @desc: reference to the block cipher handle with meta data\n * @dst: scatter/gather list that is filled by the cipher operation with the\n *\tplaintext\n * @src: scatter/gather list that holds the ciphertext\n * @nbytes: number of bytes of the ciphertext to decrypt.\n *\n * Decrypt ciphertext data with the use of an IV that is solely used for this\n * cipher operation. Any previously set IV is not used.\n *\n * The blkcipher_desc data structure must be filled by the caller as documented\n * for the crypto_blkcipher_encrypt_iv call above.\n *\n * Return: 0 if the cipher operation was successful; < 0 if an error occurred\n */\nstatic inline int crypto_blkcipher_decrypt_iv(struct blkcipher_desc *desc,\n\t\t\t\t\t      struct scatterlist *dst,\n\t\t\t\t\t      struct scatterlist *src,\n\t\t\t\t\t      unsigned int nbytes)\n{\n\treturn crypto_blkcipher_crt(desc->tfm)->decrypt(desc, dst, src, nbytes);\n}\n\n/**\n * crypto_blkcipher_set_iv() - set IV for cipher\n * @tfm: cipher handle\n * @src: buffer holding the IV\n * @len: length of the IV in bytes\n *\n * The caller provided IV is set for the block cipher referenced by the cipher\n * handle.\n */\nstatic inline void crypto_blkcipher_set_iv(struct crypto_blkcipher *tfm,\n\t\t\t\t\t   const u8 *src, unsigned int len)\n{\n\tmemcpy(crypto_blkcipher_crt(tfm)->iv, src, len);\n}\n\n/**\n * crypto_blkcipher_get_iv() - obtain IV from cipher\n * @tfm: cipher handle\n * @dst: buffer filled with the IV\n * @len: length of the buffer dst\n *\n * The caller can obtain the IV set for the block cipher referenced by the\n * cipher handle and store it into the user-provided buffer. If the buffer\n * has an insufficient space, the IV is truncated to fit the buffer.\n */\nstatic inline void crypto_blkcipher_get_iv(struct crypto_blkcipher *tfm,\n\t\t\t\t\t   u8 *dst, unsigned int len)\n{\n\tmemcpy(dst, crypto_blkcipher_crt(tfm)->iv, len);\n}\n\n/**\n * DOC: Single Block Cipher API\n *\n * The single block cipher API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_CIPHER (listed as type \"cipher\" in /proc/crypto).\n *\n * Using the single block cipher API calls, operations with the basic cipher\n * primitive can be implemented. These cipher primitives exclude any block\n * chaining operations including IV handling.\n *\n * The purpose of this single block cipher API is to support the implementation\n * of templates or other concepts that only need to perform the cipher operation\n * on one block at a time. Templates invoke the underlying cipher primitive\n * block-wise and process either the input or the output data of these cipher\n * operations.\n */\n\nstatic inline struct crypto_cipher *__crypto_cipher_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_cipher *)tfm;\n}\n\nstatic inline struct crypto_cipher *crypto_cipher_cast(struct crypto_tfm *tfm)\n{\n\tBUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);\n\treturn __crypto_cipher_cast(tfm);\n}\n\n/**\n * crypto_alloc_cipher() - allocate single block cipher handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t     single block cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a single block cipher. The returned struct\n * crypto_cipher is the cipher handle that is required for any subsequent API\n * invocation for that single block cipher.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n *\t   of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct crypto_cipher *crypto_alloc_cipher(const char *alg_name,\n\t\t\t\t\t\t\tu32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_CIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_cipher_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_cipher_tfm(struct crypto_cipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_cipher() - zeroize and free the single block cipher handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_cipher(struct crypto_cipher *tfm)\n{\n\tcrypto_free_tfm(crypto_cipher_tfm(tfm));\n}\n\n/**\n * crypto_has_cipher() - Search for the availability of a single block cipher\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t     single block cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the single block cipher is known to the kernel crypto API;\n *\t   false otherwise\n */\nstatic inline int crypto_has_cipher(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_CIPHER;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline struct cipher_tfm *crypto_cipher_crt(struct crypto_cipher *tfm)\n{\n\treturn &crypto_cipher_tfm(tfm)->crt_cipher;\n}\n\n/**\n * crypto_cipher_blocksize() - obtain block size for cipher\n * @tfm: cipher handle\n *\n * The block size for the single block cipher referenced with the cipher handle\n * tfm is returned. The caller may use that information to allocate appropriate\n * memory for the data returned by the encryption or decryption operation\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_cipher_blocksize(struct crypto_cipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_cipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_cipher_alignmask(struct crypto_cipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_cipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_cipher_get_flags(struct crypto_cipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_cipher_tfm(tfm));\n}\n\nstatic inline void crypto_cipher_set_flags(struct crypto_cipher *tfm,\n\t\t\t\t\t   u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_cipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_cipher_clear_flags(struct crypto_cipher *tfm,\n\t\t\t\t\t     u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);\n}\n\n/**\n * crypto_cipher_setkey() - set key for cipher\n * @tfm: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the single block cipher referenced by the\n * cipher handle.\n *\n * Note, the key length determines the cipher type. Many block ciphers implement\n * different cipher modes depending on the key size, such as AES-128 vs AES-192\n * vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128\n * is performed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_cipher_setkey(struct crypto_cipher *tfm,\n                                       const u8 *key, unsigned int keylen)\n{\n\treturn crypto_cipher_crt(tfm)->cit_setkey(crypto_cipher_tfm(tfm),\n\t\t\t\t\t\t  key, keylen);\n}\n\n/**\n * crypto_cipher_encrypt_one() - encrypt one block of plaintext\n * @tfm: cipher handle\n * @dst: points to the buffer that will be filled with the ciphertext\n * @src: buffer holding the plaintext to be encrypted\n *\n * Invoke the encryption operation of one block. The caller must ensure that\n * the plaintext and ciphertext buffers are at least one block in size.\n */\nstatic inline void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,\n\t\t\t\t\t     u8 *dst, const u8 *src)\n{\n\tcrypto_cipher_crt(tfm)->cit_encrypt_one(crypto_cipher_tfm(tfm),\n\t\t\t\t\t\tdst, src);\n}\n\n/**\n * crypto_cipher_decrypt_one() - decrypt one block of ciphertext\n * @tfm: cipher handle\n * @dst: points to the buffer that will be filled with the plaintext\n * @src: buffer holding the ciphertext to be decrypted\n *\n * Invoke the decryption operation of one block. The caller must ensure that\n * the plaintext and ciphertext buffers are at least one block in size.\n */\nstatic inline void crypto_cipher_decrypt_one(struct crypto_cipher *tfm,\n\t\t\t\t\t     u8 *dst, const u8 *src)\n{\n\tcrypto_cipher_crt(tfm)->cit_decrypt_one(crypto_cipher_tfm(tfm),\n\t\t\t\t\t\tdst, src);\n}\n\n/**\n * DOC: Synchronous Message Digest API\n *\n * The synchronous message digest API is used with the ciphers of type\n * CRYPTO_ALG_TYPE_HASH (listed as type \"hash\" in /proc/crypto)\n */\n\nstatic inline struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_hash *)tfm;\n}\n\nstatic inline struct crypto_hash *crypto_hash_cast(struct crypto_tfm *tfm)\n{\n\tBUG_ON((crypto_tfm_alg_type(tfm) ^ CRYPTO_ALG_TYPE_HASH) &\n\t       CRYPTO_ALG_TYPE_HASH_MASK);\n\treturn __crypto_hash_cast(tfm);\n}\n\n/**\n * crypto_alloc_hash() - allocate synchronous message digest handle\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      message digest cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Allocate a cipher handle for a message digest. The returned struct\n * crypto_hash is the cipher handle that is required for any subsequent\n * API invocation for that message digest.\n *\n * Return: allocated cipher handle in case of success; IS_ERR() is true in case\n * of an error, PTR_ERR() returns the error code.\n */\nstatic inline struct crypto_hash *crypto_alloc_hash(const char *alg_name,\n\t\t\t\t\t\t    u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\tmask &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_HASH;\n\tmask |= CRYPTO_ALG_TYPE_HASH_MASK;\n\n\treturn __crypto_hash_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_hash_tfm(struct crypto_hash *tfm)\n{\n\treturn &tfm->base;\n}\n\n/**\n * crypto_free_hash() - zeroize and free message digest handle\n * @tfm: cipher handle to be freed\n */\nstatic inline void crypto_free_hash(struct crypto_hash *tfm)\n{\n\tcrypto_free_tfm(crypto_hash_tfm(tfm));\n}\n\n/**\n * crypto_has_hash() - Search for the availability of a message digest\n * @alg_name: is the cra_name / name or cra_driver_name / driver name of the\n *\t      message digest cipher\n * @type: specifies the type of the cipher\n * @mask: specifies the mask for the cipher\n *\n * Return: true when the message digest cipher is known to the kernel crypto\n *\t   API; false otherwise\n */\nstatic inline int crypto_has_hash(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\tmask &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_HASH;\n\tmask |= CRYPTO_ALG_TYPE_HASH_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline struct hash_tfm *crypto_hash_crt(struct crypto_hash *tfm)\n{\n\treturn &crypto_hash_tfm(tfm)->crt_hash;\n}\n\n/**\n * crypto_hash_blocksize() - obtain block size for message digest\n * @tfm: cipher handle\n *\n * The block size for the message digest cipher referenced with the cipher\n * handle is returned.\n *\n * Return: block size of cipher\n */\nstatic inline unsigned int crypto_hash_blocksize(struct crypto_hash *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_hash_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_hash_alignmask(struct crypto_hash *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_hash_tfm(tfm));\n}\n\n/**\n * crypto_hash_digestsize() - obtain message digest size\n * @tfm: cipher handle\n *\n * The size for the message digest created by the message digest cipher\n * referenced with the cipher handle is returned.\n *\n * Return: message digest size\n */\nstatic inline unsigned int crypto_hash_digestsize(struct crypto_hash *tfm)\n{\n\treturn crypto_hash_crt(tfm)->digestsize;\n}\n\nstatic inline u32 crypto_hash_get_flags(struct crypto_hash *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_hash_tfm(tfm));\n}\n\nstatic inline void crypto_hash_set_flags(struct crypto_hash *tfm, u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_hash_tfm(tfm), flags);\n}\n\nstatic inline void crypto_hash_clear_flags(struct crypto_hash *tfm, u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_hash_tfm(tfm), flags);\n}\n\n/**\n * crypto_hash_init() - (re)initialize message digest handle\n * @desc: cipher request handle that to be filled by caller --\n *\t  desc.tfm is filled with the hash cipher handle;\n *\t  desc.flags is filled with either CRYPTO_TFM_REQ_MAY_SLEEP or 0.\n *\n * The call (re-)initializes the message digest referenced by the hash cipher\n * request handle. Any potentially existing state created by previous\n * operations is discarded.\n *\n * Return: 0 if the message digest initialization was successful; < 0 if an\n *\t   error occurred\n */\nstatic inline int crypto_hash_init(struct hash_desc *desc)\n{\n\treturn crypto_hash_crt(desc->tfm)->init(desc);\n}\n\n/**\n * crypto_hash_update() - add data to message digest for processing\n * @desc: cipher request handle\n * @sg: scatter / gather list pointing to the data to be added to the message\n *      digest\n * @nbytes: number of bytes to be processed from @sg\n *\n * Updates the message digest state of the cipher handle pointed to by the\n * hash cipher request handle with the input data pointed to by the\n * scatter/gather list.\n *\n * Return: 0 if the message digest update was successful; < 0 if an error\n *\t   occurred\n */\nstatic inline int crypto_hash_update(struct hash_desc *desc,\n\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t     unsigned int nbytes)\n{\n\treturn crypto_hash_crt(desc->tfm)->update(desc, sg, nbytes);\n}\n\n/**\n * crypto_hash_final() - calculate message digest\n * @desc: cipher request handle\n * @out: message digest output buffer -- The caller must ensure that the out\n *\t buffer has a sufficient size (e.g. by using the crypto_hash_digestsize\n *\t function).\n *\n * Finalize the message digest operation and create the message digest\n * based on all data added to the cipher handle. The message digest is placed\n * into the output buffer.\n *\n * Return: 0 if the message digest creation was successful; < 0 if an error\n *\t   occurred\n */\nstatic inline int crypto_hash_final(struct hash_desc *desc, u8 *out)\n{\n\treturn crypto_hash_crt(desc->tfm)->final(desc, out);\n}\n\n/**\n * crypto_hash_digest() - calculate message digest for a buffer\n * @desc: see crypto_hash_final()\n * @sg: see crypto_hash_update()\n * @nbytes:  see crypto_hash_update()\n * @out: see crypto_hash_final()\n *\n * This function is a \"short-hand\" for the function calls of crypto_hash_init,\n * crypto_hash_update and crypto_hash_final. The parameters have the same\n * meaning as discussed for those separate three functions.\n *\n * Return: 0 if the message digest creation was successful; < 0 if an error\n *\t   occurred\n */\nstatic inline int crypto_hash_digest(struct hash_desc *desc,\n\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t     unsigned int nbytes, u8 *out)\n{\n\treturn crypto_hash_crt(desc->tfm)->digest(desc, sg, nbytes, out);\n}\n\n/**\n * crypto_hash_setkey() - set key for message digest\n * @hash: cipher handle\n * @key: buffer holding the key\n * @keylen: length of the key in bytes\n *\n * The caller provided key is set for the message digest cipher. The cipher\n * handle must point to a keyed hash in order for this function to succeed.\n *\n * Return: 0 if the setting of the key was successful; < 0 if an error occurred\n */\nstatic inline int crypto_hash_setkey(struct crypto_hash *hash,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\treturn crypto_hash_crt(hash)->setkey(hash, key, keylen);\n}\n\nstatic inline struct crypto_comp *__crypto_comp_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_comp *)tfm;\n}\n\nstatic inline struct crypto_comp *crypto_comp_cast(struct crypto_tfm *tfm)\n{\n\tBUG_ON((crypto_tfm_alg_type(tfm) ^ CRYPTO_ALG_TYPE_COMPRESS) &\n\t       CRYPTO_ALG_TYPE_MASK);\n\treturn __crypto_comp_cast(tfm);\n}\n\nstatic inline struct crypto_comp *crypto_alloc_comp(const char *alg_name,\n\t\t\t\t\t\t    u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_COMPRESS;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_comp_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_comp_tfm(struct crypto_comp *tfm)\n{\n\treturn &tfm->base;\n}\n\nstatic inline void crypto_free_comp(struct crypto_comp *tfm)\n{\n\tcrypto_free_tfm(crypto_comp_tfm(tfm));\n}\n\nstatic inline int crypto_has_comp(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_COMPRESS;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline const char *crypto_comp_name(struct crypto_comp *tfm)\n{\n\treturn crypto_tfm_alg_name(crypto_comp_tfm(tfm));\n}\n\nstatic inline struct compress_tfm *crypto_comp_crt(struct crypto_comp *tfm)\n{\n\treturn &crypto_comp_tfm(tfm)->crt_compress;\n}\n\nstatic inline int crypto_comp_compress(struct crypto_comp *tfm,\n                                       const u8 *src, unsigned int slen,\n                                       u8 *dst, unsigned int *dlen)\n{\n\treturn crypto_comp_crt(tfm)->cot_compress(crypto_comp_tfm(tfm),\n\t\t\t\t\t\t  src, slen, dst, dlen);\n}\n\nstatic inline int crypto_comp_decompress(struct crypto_comp *tfm,\n                                         const u8 *src, unsigned int slen,\n                                         u8 *dst, unsigned int *dlen)\n{\n\treturn crypto_comp_crt(tfm)->cot_decompress(crypto_comp_tfm(tfm),\n\t\t\t\t\t\t    src, slen, dst, dlen);\n}\n\n#endif\t/* _LINUX_CRYPTO_H */\n\n"], "filenames": ["crypto/rng.c", "include/crypto/internal/rng.h", "include/crypto/rng.h", "include/linux/crypto.h"], "buggy_code_start_loc": [6, 4, 4, 141], "buggy_code_end_loc": [166, 20, 202, 563], "fixing_code_start_loc": [7, 5, 5, 140], "fixing_code_end_loc": [116, 18, 198, 532], "type": "CWE-476", "message": "The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).", "other": {"cve": {"id": "CVE-2017-15116", "sourceIdentifier": "secalert@redhat.com", "published": "2017-11-30T18:29:00.320", "lastModified": "2023-02-12T23:28:30.943", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference)."}, {"lang": "es", "value": "La funci\u00f3n rngapi_reset en crypto/rng.c en el kernel de Linux en versiones anteriores a la 4.2 permite que atacantes provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2", "matchCriteriaId": "8AD4F6C2-134F-40FD-BBA3-BAEB0AF3D8A4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0676", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1062", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1485815", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Permissions Required"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1514609", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"}}