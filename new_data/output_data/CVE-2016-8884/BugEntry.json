{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Sequence/Matrix Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <math.h>\n\n#include \"jasper/jas_seq.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Constructors and destructors.\n\\******************************************************************************/\n\njas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n{\n\tjas_matrix_t *matrix;\n\tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n\treturn matrix;\n}\n\njas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}\n\nvoid jas_matrix_destroy(jas_matrix_t *matrix)\n{\n\tif (matrix->data_) {\n\t\tassert(!(matrix->flags_ & JAS_MATRIX_REF));\n\t\tjas_free(matrix->data_);\n\t\tmatrix->data_ = 0;\n\t}\n\tif (matrix->rows_) {\n\t\tjas_free(matrix->rows_);\n\t\tmatrix->rows_ = 0;\n\t}\n\tjas_free(matrix);\n}\n\njas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x), jas_seq2d_xend(x),\n\t  jas_seq2d_yend(x));\n\tassert(y);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\njas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\n/******************************************************************************\\\n* Bind operations.\n\\******************************************************************************/\n\nvoid jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart, int ystart,\n  int xend, int yend)\n{\n\tjas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,\n\t  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);\n}\n\nvoid jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,\n  int r1, int c1)\n{\n\tint i;\n\n\tif (mat0->data_) {\n\t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n\t\t\tjas_free(mat0->data_);\n\t\t}\n\t\tmat0->data_ = 0;\n\t\tmat0->datasize_ = 0;\n\t}\n\tif (mat0->rows_) {\n\t\tjas_free(mat0->rows_);\n\t\tmat0->rows_ = 0;\n\t}\n\tmat0->flags_ |= JAS_MATRIX_REF;\n\tmat0->numrows_ = r1 - r0 + 1;\n\tmat0->numcols_ = c1 - c0 + 1;\n\tmat0->maxrows_ = mat0->numrows_;\n\tif (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {\n\t\t/*\n\t\t\tThere is no way to indicate failure to the caller.\n\t\t\tSo, we have no choice but to abort.\n\t\t\tIdeally, this function should have a non-void return type.\n\t\t\tIn practice, a non-void return type probably would not help\n\t\t\tmuch anyways as the caller would just have to terminate anyways.\n\t\t*/\n\t\tabort();\n\t}\n\n\tfor (i = 0; i < mat0->numrows_; ++i) {\n\t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;\n\t}\n\n\tmat0->xstart_ = mat1->xstart_ + c0;\n\tmat0->ystart_ = mat1->ystart_ + r0;\n\tmat0->xend_ = mat0->xstart_ + mat0->numcols_;\n\tmat0->yend_ = mat0->ystart_ + mat0->numrows_;\n}\n\n/******************************************************************************\\\n* Arithmetic operations.\n\\******************************************************************************/\n\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tdata = rowstart;\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\tv = *data;\n\t\t\t\tif (v < minval) {\n\t\t\t\t\t*data = minval;\n\t\t\t\t} else if (v > maxval) {\n\t\t\t\t\t*data = maxval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asr(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tassert(n >= 0);\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data >>= n;\n\t\t\t\t*data = jas_seqent_asr(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data <<= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nint jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[numcols * i];\n\t}\n\n\treturn 0;\n}\n\nvoid jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = val;\n\t\t\t}\n\t\t}\n\t}\n}\n\njas_matrix_t *jas_seq2d_input(FILE *in)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tint j;\n\tlong x;\n\tint numrows;\n\tint numcols;\n\tint xoff;\n\tint yoff;\n\n\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)\n\t\treturn 0;\n\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)\n\t\treturn 0;\n\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n\t\treturn 0;\n\n\tif (jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {\n\t\tabort();\n\t}\n\n\t/* Get matrix data. */\n\tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {\n\t\t\tif (fscanf(in, \"%ld\", &x) != 1) {\n\t\t\t\tjas_matrix_destroy(matrix);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));\n\t\t}\n\t}\n\n\treturn matrix;\n}\n\nint jas_seq2d_output(jas_matrix_t *matrix, FILE *out)\n{\n#define MAXLINELEN\t80\n\tint i;\n\tint j;\n\tjas_seqent_t x;\n\tchar buf[MAXLINELEN + 1];\n\tchar sbuf[MAXLINELEN + 1];\n\tint n;\n\n\tfprintf(out, \"%d %d\\n\", jas_seq2d_xstart(matrix),\n\t  jas_seq2d_ystart(matrix));\n\tfprintf(out, \"%d %d\\n\", jas_matrix_numcols(matrix),\n\t  jas_matrix_numrows(matrix));\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < jas_matrix_numrows(matrix); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); ++j) {\n\t\t\tx = jas_matrix_get(matrix, i, j);\n\t\t\tsprintf(sbuf, \"%s%4ld\", (strlen(buf) > 0) ? \" \" : \"\",\n\t\t\t  JAS_CAST(long, x));\n\t\t\tn = strlen(buf);\n\t\t\tif (n + strlen(sbuf) > MAXLINELEN) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t\tstrcat(buf, sbuf);\n\t\t\tif (j == jas_matrix_numcols(matrix) - 1) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tfputs(buf, out);\n\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Windows Bitmap File Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"bmp_cod.h\"\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr);\nstatic bmp_info_t *bmp_getinfo(jas_stream_t *in);\nstatic int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image);\nstatic int bmp_getint16(jas_stream_t *in, int_fast16_t *val);\nstatic int bmp_getint32(jas_stream_t *in, int_fast32_t *val);\nstatic int bmp_gobble(jas_stream_t *in, long n);\n\n/******************************************************************************\\\n* Interface functions.\n\\******************************************************************************/\n\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}\n\nint bmp_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tuchar buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t/* Read the first two characters that constitute the signature. */\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\t/* Put the characters read back onto the stream. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Did we read enough characters? */\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\t/* Is the signature correct for the BMP format? */\n\tif (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Code for aggregate types.\n\\******************************************************************************/\n\nstatic int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr)\n{\n\tif (bmp_getint16(in, &hdr->magic) || hdr->magic != BMP_MAGIC ||\n\t  bmp_getint32(in, &hdr->siz) || bmp_getint16(in, &hdr->reserved1) ||\n\t  bmp_getint16(in, &hdr->reserved2) || bmp_getint32(in, &hdr->off)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic bmp_info_t *bmp_getinfo(jas_stream_t *in)\n{\n\tbmp_info_t *info;\n\tint i;\n\tbmp_palent_t *palent;\n\n\tif (!(info = bmp_info_create())) {\n\t\treturn 0;\n\t}\n\n\tif (bmp_getint32(in, &info->len) || info->len != 40 ||\n\t  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||\n\t  bmp_getint16(in, &info->numplanes) ||\n\t  bmp_getint16(in, &info->depth) || bmp_getint32(in, &info->enctype) ||\n\t  bmp_getint32(in, &info->siz) ||\n\t  bmp_getint32(in, &info->hres) || bmp_getint32(in, &info->vres) ||\n\t  bmp_getint32(in, &info->numcolors) ||\n\t  bmp_getint32(in, &info->mincolors)) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||\n\t  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->enctype != BMP_ENC_RGB) {\n\t\tjas_eprintf(\"unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->numcolors > 0) {\n\t\tif (!(info->palents = jas_alloc2(info->numcolors,\n\t\t  sizeof(bmp_palent_t)))) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tinfo->palents = 0;\n\t}\n\n\tfor (i = 0; i < info->numcolors; ++i) {\n\t\tpalent = &info->palents[i];\n\t\tif ((palent->blu = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->grn = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->red = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->res = jas_stream_getc(in)) == EOF) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn info;\n}\n\nstatic int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Code for primitive types.\n\\******************************************************************************/\n\nstatic int bmp_getint16(jas_stream_t *in, int_fast16_t *val)\n{\n\tint lo;\n\tint hi;\n\tif ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = (hi << 8) | lo;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_gobble(jas_stream_t *in, long n)\n{\n\twhile (--n >= 0) {\n\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Sequence/Matrix Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <math.h>\n\n#include \"jasper/jas_seq.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Constructors and destructors.\n\\******************************************************************************/\n\njas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n{\n\tjas_matrix_t *matrix;\n\tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n\treturn matrix;\n}\n\njas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\treturn 0;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}\n\nvoid jas_matrix_destroy(jas_matrix_t *matrix)\n{\n\tif (matrix->data_) {\n\t\tassert(!(matrix->flags_ & JAS_MATRIX_REF));\n\t\tjas_free(matrix->data_);\n\t\tmatrix->data_ = 0;\n\t}\n\tif (matrix->rows_) {\n\t\tjas_free(matrix->rows_);\n\t\tmatrix->rows_ = 0;\n\t}\n\tjas_free(matrix);\n}\n\njas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x), jas_seq2d_xend(x),\n\t  jas_seq2d_yend(x));\n\tassert(y);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\njas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\n/******************************************************************************\\\n* Bind operations.\n\\******************************************************************************/\n\nvoid jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart, int ystart,\n  int xend, int yend)\n{\n\tjas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,\n\t  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);\n}\n\nvoid jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,\n  int r1, int c1)\n{\n\tint i;\n\n\tif (mat0->data_) {\n\t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n\t\t\tjas_free(mat0->data_);\n\t\t}\n\t\tmat0->data_ = 0;\n\t\tmat0->datasize_ = 0;\n\t}\n\tif (mat0->rows_) {\n\t\tjas_free(mat0->rows_);\n\t\tmat0->rows_ = 0;\n\t}\n\tmat0->flags_ |= JAS_MATRIX_REF;\n\tmat0->numrows_ = r1 - r0 + 1;\n\tmat0->numcols_ = c1 - c0 + 1;\n\tmat0->maxrows_ = mat0->numrows_;\n\tif (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {\n\t\t/*\n\t\t\tThere is no way to indicate failure to the caller.\n\t\t\tSo, we have no choice but to abort.\n\t\t\tIdeally, this function should have a non-void return type.\n\t\t\tIn practice, a non-void return type probably would not help\n\t\t\tmuch anyways as the caller would just have to terminate anyways.\n\t\t*/\n\t\tabort();\n\t}\n\n\tfor (i = 0; i < mat0->numrows_; ++i) {\n\t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;\n\t}\n\n\tmat0->xstart_ = mat1->xstart_ + c0;\n\tmat0->ystart_ = mat1->ystart_ + r0;\n\tmat0->xend_ = mat0->xstart_ + mat0->numcols_;\n\tmat0->yend_ = mat0->ystart_ + mat0->numrows_;\n}\n\n/******************************************************************************\\\n* Arithmetic operations.\n\\******************************************************************************/\n\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tdata = rowstart;\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\tv = *data;\n\t\t\t\tif (v < minval) {\n\t\t\t\t\t*data = minval;\n\t\t\t\t} else if (v > maxval) {\n\t\t\t\t\t*data = maxval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asr(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tassert(n >= 0);\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data >>= n;\n\t\t\t\t*data = jas_seqent_asr(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data <<= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nint jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[numcols * i];\n\t}\n\n\treturn 0;\n}\n\nvoid jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = val;\n\t\t\t}\n\t\t}\n\t}\n}\n\njas_matrix_t *jas_seq2d_input(FILE *in)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tint j;\n\tlong x;\n\tint numrows;\n\tint numcols;\n\tint xoff;\n\tint yoff;\n\n\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)\n\t\treturn 0;\n\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)\n\t\treturn 0;\n\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n\t\treturn 0;\n\n\tif (jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {\n\t\tabort();\n\t}\n\n\t/* Get matrix data. */\n\tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {\n\t\t\tif (fscanf(in, \"%ld\", &x) != 1) {\n\t\t\t\tjas_matrix_destroy(matrix);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));\n\t\t}\n\t}\n\n\treturn matrix;\n}\n\nint jas_seq2d_output(jas_matrix_t *matrix, FILE *out)\n{\n#define MAXLINELEN\t80\n\tint i;\n\tint j;\n\tjas_seqent_t x;\n\tchar buf[MAXLINELEN + 1];\n\tchar sbuf[MAXLINELEN + 1];\n\tint n;\n\n\tfprintf(out, \"%d %d\\n\", jas_seq2d_xstart(matrix),\n\t  jas_seq2d_ystart(matrix));\n\tfprintf(out, \"%d %d\\n\", jas_matrix_numcols(matrix),\n\t  jas_matrix_numrows(matrix));\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < jas_matrix_numrows(matrix); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); ++j) {\n\t\t\tx = jas_matrix_get(matrix, i, j);\n\t\t\tsprintf(sbuf, \"%s%4ld\", (strlen(buf) > 0) ? \" \" : \"\",\n\t\t\t  JAS_CAST(long, x));\n\t\t\tn = strlen(buf);\n\t\t\tif (n + strlen(sbuf) > MAXLINELEN) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t\tstrcat(buf, sbuf);\n\t\t\tif (j == jas_matrix_numcols(matrix) - 1) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tfputs(buf, out);\n\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Windows Bitmap File Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"bmp_cod.h\"\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr);\nstatic bmp_info_t *bmp_getinfo(jas_stream_t *in);\nstatic int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image);\nstatic int bmp_getint16(jas_stream_t *in, int_fast16_t *val);\nstatic int bmp_getint32(jas_stream_t *in, int_fast32_t *val);\nstatic int bmp_gobble(jas_stream_t *in, long n);\n\n/******************************************************************************\\\n* Interface functions.\n\\******************************************************************************/\n\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\timage = 0;\n\tinfo = 0;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t\t//return 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t\t//return 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\t//bmp_info_destroy(info);\n\t\t\t//return 0;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\t//bmp_info_destroy(info);\n\t\t//jas_image_destroy(image);\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}\n\nint bmp_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tuchar buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t/* Read the first two characters that constitute the signature. */\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\t/* Put the characters read back onto the stream. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Did we read enough characters? */\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\t/* Is the signature correct for the BMP format? */\n\tif (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Code for aggregate types.\n\\******************************************************************************/\n\nstatic int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr)\n{\n\tif (bmp_getint16(in, &hdr->magic) || hdr->magic != BMP_MAGIC ||\n\t  bmp_getint32(in, &hdr->siz) || bmp_getint16(in, &hdr->reserved1) ||\n\t  bmp_getint16(in, &hdr->reserved2) || bmp_getint32(in, &hdr->off)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic bmp_info_t *bmp_getinfo(jas_stream_t *in)\n{\n\tbmp_info_t *info;\n\tint i;\n\tbmp_palent_t *palent;\n\n\tif (!(info = bmp_info_create())) {\n\t\treturn 0;\n\t}\n\n\tif (bmp_getint32(in, &info->len) || info->len != 40 ||\n\t  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||\n\t  bmp_getint16(in, &info->numplanes) ||\n\t  bmp_getint16(in, &info->depth) || bmp_getint32(in, &info->enctype) ||\n\t  bmp_getint32(in, &info->siz) ||\n\t  bmp_getint32(in, &info->hres) || bmp_getint32(in, &info->vres) ||\n\t  bmp_getint32(in, &info->numcolors) ||\n\t  bmp_getint32(in, &info->mincolors)) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||\n\t  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->enctype != BMP_ENC_RGB) {\n\t\tjas_eprintf(\"unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->numcolors > 0) {\n\t\tif (!(info->palents = jas_alloc2(info->numcolors,\n\t\t  sizeof(bmp_palent_t)))) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tinfo->palents = 0;\n\t}\n\n\tfor (i = 0; i < info->numcolors; ++i) {\n\t\tpalent = &info->palents[i];\n\t\tif ((palent->blu = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->grn = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->red = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->res = jas_stream_getc(in)) == EOF) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn info;\n}\n\nstatic int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Code for primitive types.\n\\******************************************************************************/\n\nstatic int bmp_getint16(jas_stream_t *in, int_fast16_t *val)\n{\n\tint lo;\n\tint hi;\n\tif ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = (hi << 8) | lo;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_gobble(jas_stream_t *in, long n)\n{\n\twhile (--n >= 0) {\n\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "filenames": ["src/libjasper/base/jas_seq.c", "src/libjasper/bmp/bmp_dec.c"], "buggy_code_start_loc": [104, 109], "buggy_code_end_loc": [104, 210], "fixing_code_start_loc": [105, 110], "fixing_code_end_loc": [109, 238], "type": "CWE-476", "message": "The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690.", "other": {"cve": {"id": "CVE-2016-8884", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-28T14:59:00.297", "lastModified": "2018-01-05T02:31:20.247", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690."}, {"lang": "es", "value": "La funci\u00f3n bmp_getdata en libjasper/bmp/bmp_dec.c en JasPer 1.900.5 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) llamando al comando imginfo con una imagen BMP manipulada. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2016-8690."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:1.900.5:*:*:*:*:*:*:*", "matchCriteriaId": "079E26BB-7765-49FD-9F52-8E1EB8671072"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/10/23/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/23/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93834", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/10/18/jasper-two-null-pointer-dereference-in-bmp_getdata-bmp_dec-c-incomplete-fix-for-cve-2016-8690/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1385499", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/22FCKKHQCQ3S6TZY5G44EFDTMWOJXJRD/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EGI2FZQLOTSZI3VA4ECJERI74SMNQDL4/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698"}}