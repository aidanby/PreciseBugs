{"buggy_code": ["<?php\n\n/**\n * This code is mix of WP and phpBB :)\n * */\nclass erLhcoreClassBBCode\n{    \n   /**\n    * Callback to convert URI match to HTML A element.\n    *\n    * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n    *\n    * @since 2.3.2\n    * @access private\n    *\n    * @param array $matches Single Regex Match.\n    * @return string HTML A element with URI address.\n    */\n   public static function _make_url_clickable_cb( $matches ) {\n       $url = $matches[2];\n       if ( ')' == $matches[3] && strpos( $url, '(' ) ) {\n           // If the trailing character is a closing parethesis, and the URL has an opening parenthesis in it, add the closing parenthesis to the URL.\n           // Then we can let the parenthesis balancer do its thing below.\n           $url .= $matches[3];\n           $suffix = '';\n       } else {\n           $suffix = $matches[3];\n       }\n       // Include parentheses in the URL only if paired\n       while ( substr_count( $url, '(' ) < substr_count( $url, ')' ) ) {\n           $suffix = strrchr( $url, ')' ) . $suffix;\n           $url = substr( $url, 0, strrpos( $url, ')' ) );\n       }\n       $url = self::esc_url($url);\n       if ( empty($url) )\n           return $matches[0];\n       return $matches[1] . \"<a href=\\\"$url\\\" class=\\\"link\\\" rel=\\\"noreferrer\\\" target=\\\"_blank\\\">$url</a>\" . $suffix;\n   }\n   \n   /**\n    * Checks and cleans a URL.\n    *\n    * A number of characters are removed from the URL. If the URL is for displaying\n    * (the default behaviour) ampersands are also replaced. The {@see 'clean_url'} filter\n    * is applied to the returned cleaned URL.\n    *\n    * @since 2.8.0\n    *\n    * @param string $url       The URL to be cleaned.\n    * @param array  $protocols Optional. An array of acceptable protocols.\n    *\t\t                    Defaults to return value of wp_allowed_protocols()\n    * @param string $_context  Private. Use esc_url_raw() for database usage.\n    * @return string The cleaned $url after the {@see 'clean_url'} filter is applied.\n    */\n   public static function esc_url( $url, $protocols = null, $_context = 'display' ) {\n       $original_url = $url;\n       if ( '' == $url )\n           return $url;\n       $url = str_replace( ' ', '%20', $url );\n       $url = preg_replace('|[^a-z0-9-~+_.?#=!&;,/:%@$\\|*\\'()\\[\\]\\\\x80-\\\\xff]|i', '', $url);\n       if ( '' === $url ) {\n           return $url;\n       }\n       if ( 0 !== stripos( $url, 'mailto:' ) ) {\n           $strip = array('%0d', '%0a', '%0D', '%0A');\n           $url = self::_deep_replace($strip, $url);\n       }\n       $url = str_replace(';//', '://', $url);\n       /* If the URL doesn't appear to contain a scheme, we\n        * presume it needs http:// prepended (unless a relative\n        * link starting with /, # or ? or a php file).\n       */\n       if ( strpos($url, ':') === false && ! in_array( $url[0], array( '/', '#', '?' ) ) &&\n           ! preg_match('/^[a-z0-9-]+?\\.php/i', $url) )\n               $url = 'http://' . $url;\n           // Replace ampersands and single quotes only when displaying.\n           if ( 'display' == $_context ) {\n               $url = self::wp_kses_normalize_entities( $url );\n               $url = str_replace( '&amp;', '&#038;', $url );\n               $url = str_replace( \"'\", '&#039;', $url );\n           }\n           if ( ( false !== strpos( $url, '[' ) ) || ( false !== strpos( $url, ']' ) ) ) {\n               $parsed = self::wp_parse_url( $url );\n               $front  = '';\n               if ( isset( $parsed['scheme'] ) ) {\n                   $front .= $parsed['scheme'] . '://';\n               } elseif ( '/' === $url[0] ) {\n                   $front .= '//';\n               }\n               if ( isset( $parsed['user'] ) ) {\n                   $front .= $parsed['user'];\n               }\n               if ( isset( $parsed['pass'] ) ) {\n                   $front .= ':' . $parsed['pass'];\n               }\n               if ( isset( $parsed['user'] ) || isset( $parsed['pass'] ) ) {\n                   $front .= '@';\n               }\n               if ( isset( $parsed['host'] ) ) {\n                   $front .= $parsed['host'];\n               }\n               if ( isset( $parsed['port'] ) ) {\n                   $front .= ':' . $parsed['port'];\n               }\n               $end_dirty = str_replace( $front, '', $url );\n               $end_clean = str_replace( array( '[', ']' ), array( '%5B', '%5D' ), $end_dirty );\n               $url       = str_replace( $end_dirty, $end_clean, $url );\n           }\n           if ( '/' === $url[0] ) {\n               $good_protocol_url = $url;\n           } else {\n               if ( ! is_array( $protocols ) )\n                   $protocols = $protocols = array( 'http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet', 'mms', 'rtsp', 'svn', 'tel', 'fax', 'xmpp', 'webcal', 'urn' );\n               \n               $good_protocol_url = self::wp_kses_bad_protocol( $url, $protocols );\n               if ( strtolower( $good_protocol_url ) != strtolower( $url ) )\n                   return '';\n           }\n\n           /**\n            * Filters a string cleaned and escaped for output as a URL.\n            *\n            * @since 2.3.0\n            *\n            * @param string $good_protocol_url The cleaned URL to be returned.\n            * @param string $original_url      The URL prior to cleaning.\n            * @param string $_context          If 'display', replace ampersands and single quotes only.\n            */\n           return $url;           \n           //self::esc_url( $good_protocol_url, $original_url, $_context ); //apply_filters( 'erLhcoreClassBBCode::clean_url', $good_protocol_url, $original_url, $_context );\n   }\n   \n   /**\n    * A wrapper for PHP's parse_url() function that handles consistency in the return\n    * values across PHP versions.\n    *\n    * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n    * schemeless and relative url's with :// in the path. This function works around\n    * those limitations providing a standard output on PHP 5.2~5.4+.\n    *\n    * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n    * in the query are being handled inconsistently. This function works around those\n    * differences as well.\n    *\n    * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n    * when URL parsing failed.\n    *\n    * @since 4.4.0\n    * @since 4.7.0 The $component parameter was added for parity with PHP's parse_url().\n    *\n    * @param string $url       The URL to parse.\n    * @param int    $component The specific component to retrieve. Use one of the PHP\n    *                          predefined constants to specify which one.\n    *                          Defaults to -1 (= return all parts as an array).\n    *                          @see http://php.net/manual/en/function.parse-url.php\n    * @return mixed False on parse failure; Array of URL components on success;\n    *               When a specific component has been requested: null if the component\n    *               doesn't exist in the given URL; a string or - in the case of\n    *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n    */\n   public static function wp_parse_url( $url, $component = -1 ) {\n       $to_unset = array();\n       $url = strval( $url );\n       if ( '//' === substr( $url, 0, 2 ) ) {\n           $to_unset[] = 'scheme';\n           $url = 'placeholder:' . $url;\n       } elseif ( '/' === substr( $url, 0, 1 ) ) {\n           $to_unset[] = 'scheme';\n           $to_unset[] = 'host';\n           $url = 'placeholder://placeholder' . $url;\n       }\n       $parts = @parse_url( $url );\n       if ( false === $parts ) {\n           // Parsing failure.\n           return $parts;\n       }\n       // Remove the placeholder values.\n       foreach ( $to_unset as $key ) {\n           unset( $parts[ $key ] );\n       }\n       return self::_get_component_from_parsed_url_array( $parts, $component );\n   }\n   \n   /**\n    * Retrieve a specific component from a parsed URL array.\n    *\n    * @internal\n    *\n    * @since 4.7.0\n    *\n    * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n    * @param int    $component The specific component to retrieve. Use one of the PHP\n    *                          predefined constants to specify which one.\n    *                          Defaults to -1 (= return all parts as an array).\n    *                          @see http://php.net/manual/en/function.parse-url.php\n    * @return mixed False on parse failure; Array of URL components on success;\n    *               When a specific component has been requested: null if the component\n    *               doesn't exist in the given URL; a string or - in the case of\n    *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n    */\n   public static function _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n       if ( -1 === $component ) {\n           return $url_parts;\n       }\n       $key = self::_wp_translate_php_url_constant_to_key( $component );\n       if ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n           return $url_parts[ $key ];\n       } else {\n           return null;\n       }\n   }\n   \n   /**\n    * Translate a PHP_URL_* constant to the named array keys PHP uses.\n    *\n    * @internal\n    *\n    * @since 4.7.0\n    *\n    * @see   http://php.net/manual/en/url.constants.php\n    *\n    * @param int $constant PHP_URL_* constant.\n    * @return string|bool The named key or false.\n    */\n   public static function _wp_translate_php_url_constant_to_key( $constant ) {\n       $translation = array(\n           PHP_URL_SCHEME   => 'scheme',\n           PHP_URL_HOST     => 'host',\n           PHP_URL_PORT     => 'port',\n           PHP_URL_USER     => 'user',\n           PHP_URL_PASS     => 'pass',\n           PHP_URL_PATH     => 'path',\n           PHP_URL_QUERY    => 'query',\n           PHP_URL_FRAGMENT => 'fragment',\n       );\n       if ( isset( $translation[ $constant ] ) ) {\n           return $translation[ $constant ];\n       } else {\n           return false;\n       }\n   }\n   \n   \n   /**\n    * Converts and fixes HTML entities.\n    *\n    * This function normalizes HTML entities. It will convert `AT&T` to the correct\n    * `AT&amp;T`, `&#00058;` to `&#58;`, `&#XYZZY;` to `&amp;#XYZZY;` and so on.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string Content to normalize entities\n    * @return string Content with normalized entities\n    */\n   public static function wp_kses_normalize_entities($string) {\n       // Disarm all entities by converting & to &amp;\n       $string = str_replace('&', '&amp;', $string);\n       // Change back the allowed entities in our entity whitelist\n       $string = preg_replace_callback('/&amp;([A-Za-z]{2,8}[0-9]{0,2});/', 'erLhcoreClassBBCode::wp_kses_named_entities', $string);\n       $string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'erLhcoreClassBBCode::wp_kses_normalize_entities2', $string);\n       $string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'erLhcoreClassBBCode::wp_kses_normalize_entities3', $string);\n       return $string;\n   }\n   \n   /**\n    * Callback for wp_kses_normalize_entities() for regular expression.\n    *\n    * This function helps wp_kses_normalize_entities() to only accept valid Unicode\n    * numeric entities in hex form.\n    *\n    * @since 2.7.0\n    * @access private\n    *\n    * @param array $matches preg_replace_callback() matches array\n    * @return string Correctly encoded entity\n    */\n   public static function wp_kses_normalize_entities3($matches) {\n       if ( empty($matches[1]) )\n           return '';\n       $hexchars = $matches[1];\n       return ( ! self::valid_unicode( hexdec( $hexchars ) ) ) ? \"&amp;#x$hexchars;\" : '&#x'.ltrim($hexchars,'0').';';\n   }\n   \n   /**\n    * Helper function to determine if a Unicode value is valid.\n    *\n    * @since 2.7.0\n    *\n    * @param int $i Unicode value\n    * @return bool True if the value was a valid Unicode number\n    */\n   public static function valid_unicode($i) {\n       return ( $i == 0x9 || $i == 0xa || $i == 0xd ||\n           ($i >= 0x20 && $i <= 0xd7ff) ||\n           ($i >= 0xe000 && $i <= 0xfffd) ||\n           ($i >= 0x10000 && $i <= 0x10ffff) );\n   }\n   \n   /**\n    * Callback for wp_kses_normalize_entities() regular expression.\n    *\n    * This function helps wp_kses_normalize_entities() to only accept 16-bit\n    * values and nothing more for `&#number;` entities.\n    *\n    * @access private\n    * @since 1.0.0\n    *\n    * @param array $matches preg_replace_callback() matches array\n    * @return string Correctly encoded entity\n    */\n   public static function wp_kses_normalize_entities2($matches) {\n       if ( empty($matches[1]) )\n           return '';\n       $i = $matches[1];\n       if (self::valid_unicode($i)) {\n           $i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);\n           $i = \"&#$i;\";\n       } else {\n           $i = \"&amp;#$i;\";\n       }\n       return $i;\n   }\n   \n   /**\n    * Callback for wp_kses_normalize_entities() regular expression.\n    *\n    * This function only accepts valid named entity references, which are finite,\n    * case-sensitive, and highly scrutinized by HTML and XML validators.\n    *\n    * @since 3.0.0\n    *\n    * @global array $allowedentitynames\n    *\n    * @param array $matches preg_replace_callback() matches array\n    * @return string Correctly encoded entity\n    */\n   public static function wp_kses_named_entities($matches) {       \n       $allowedentitynames = array(\n           'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',\n           'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',\n           'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',\n           'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',\n           'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',\n           'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',\n           'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',\n           'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',\n           'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',\n           'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',\n           'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',\n           'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',\n           'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',\n           'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',\n           'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',\n           'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',\n           'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',\n           'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',\n           'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',\n           'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',\n           'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',\n           'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',\n           'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',\n           'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',\n           'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',\n           'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',\n           'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',\n           'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',\n           'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',\n           'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',\n           'oline',   'frasl',  'weierp',  'image',  'real',   'trade',\n           'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',\n           'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',\n           'forall',  'part',   'exist',   'empty',  'nabla',  'isin',\n           'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',\n           'radic',   'prop',   'infin',   'ang',    'and',    'or',\n           'cap',     'cup',    'int',     'sim',    'cong',   'asymp',\n           'ne',      'equiv',  'le',      'ge',     'sub',    'sup',\n           'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',\n           'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',\n           'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',\n           'sup1',    'sup2',   'sup3',    'frac14', 'frac12', 'frac34',\n           'there4',\n       );\n       \n       if ( empty($matches[1]) )\n           return '';\n       $i = $matches[1];\n       return ( ! in_array( $i, $allowedentitynames ) ) ? \"&amp;$i;\" : \"&$i;\";\n   }\n   \n   /**\n    * Sanitize string from bad protocols.\n    *\n    * This function removes all non-allowed protocols from the beginning of\n    * $string. It ignores whitespace and the case of the letters, and it does\n    * understand HTML entities. It does its work in a while loop, so it won't be\n    * fooled by a string like \"javascript:javascript:alert(57)\".\n    *\n    * @since 1.0.0\n    *\n    * @param string $string            Content to filter bad protocols from\n    * @param array  $allowed_protocols Allowed protocols to keep\n    * @return string Filtered content\n    */\n   public static function wp_kses_bad_protocol($string, $allowed_protocols) {\n       $string = self::wp_kses_no_null($string);\n       $iterations = 0;\n       do {\n           $original_string = $string;\n           $string = self::wp_kses_bad_protocol_once($string, $allowed_protocols);\n       } while ( $original_string != $string && ++$iterations < 6 );\n       if ( $original_string != $string )\n           return '';\n       return $string;\n   }\n   \n   /**\n    * Removes any invalid control characters in $string.\n    *\n    * Also removes any instance of the '\\0' string.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string\n    * @param array $options Set 'slash_zero' => 'keep' when '\\0' is allowed. Default is 'remove'.\n    * @return string\n    */\n   public static function wp_kses_no_null( $string, $options = null ) {\n       if ( ! isset( $options['slash_zero'] ) ) {\n           $options = array( 'slash_zero' => 'remove' );\n       }\n       $string = preg_replace( '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $string );\n       if ( 'remove' == $options['slash_zero'] ) {\n           $string = preg_replace( '/\\\\\\\\+0+/', '', $string );\n       }\n       return $string;\n   }\n   \n   /**\n    * Sanitizes content from bad protocols and other characters.\n    *\n    * This function searches for URL protocols at the beginning of $string, while\n    * handling whitespace and HTML entities.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string            Content to check for bad protocols\n    * @param string $allowed_protocols Allowed protocols\n    * @return string Sanitized content\n    */\n   public static function wp_kses_bad_protocol_once($string, $allowed_protocols, $count = 1 ) {\n       $string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\n       if ( isset($string2[1]) && ! preg_match('%/\\?%', $string2[0]) ) {\n           $string = trim( $string2[1] );\n           $protocol = self::wp_kses_bad_protocol_once2( $string2[0], $allowed_protocols );\n           if ( 'feed:' == $protocol ) {\n               if ( $count > 2 )\n                   return '';\n               $string = self::wp_kses_bad_protocol_once( $string, $allowed_protocols, ++$count );\n               if ( empty( $string ) )\n                   return $string;\n           }\n           $string = $protocol . $string;\n       }\n       return $string;\n   }\n   \n   \n   /**\n    * Callback for wp_kses_bad_protocol_once() regular expression.\n    *\n    * This function processes URL protocols, checks to see if they're in the\n    * whitelist or not, and returns different data depending on the answer.\n    *\n    * @access private\n    * @since 1.0.0\n    *\n    * @param string $string            URI scheme to check against the whitelist\n    * @param string $allowed_protocols Allowed protocols\n    * @return string Sanitized content\n    */\n   public static function wp_kses_bad_protocol_once2( $string, $allowed_protocols ) {\n       $string2 = self::wp_kses_decode_entities($string);\n       $string2 = preg_replace('/\\s/', '', $string2);\n       $string2 = self::wp_kses_no_null($string2);\n       $string2 = strtolower($string2);\n       $allowed = false;\n       foreach ( (array) $allowed_protocols as $one_protocol )\n           if ( strtolower($one_protocol) == $string2 ) {\n               $allowed = true;\n               break;\n           }\n       if ($allowed)\n           return \"$string2:\";\n       else\n           return '';\n   }\n   \n   /**\n    * Convert all entities to their character counterparts.\n    *\n    * This function decodes numeric HTML entities (`&#65;` and `&#x41;`).\n    * It doesn't do anything with other entities like &auml;, but we don't\n    * need them in the URL protocol whitelisting system anyway.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string Content to change entities\n    * @return string Content after decoded entities\n    */\n   public static function wp_kses_decode_entities($string) {\n       $string = preg_replace_callback('/&#([0-9]+);/', 'erLhcoreClassBBCode::_wp_kses_decode_entities_chr', $string);\n       $string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', 'erLhcoreClassBBCode::_wp_kses_decode_entities_chr_hexdec', $string);\n       return $string;\n   }\n   \n   /**\n    * Regex callback for wp_kses_decode_entities()\n    *\n    * @since 2.9.0\n    *\n    * @param array $match preg match\n    * @return string\n    */\n   public static function _wp_kses_decode_entities_chr( $match ) {\n       return chr( $match[1] );\n   }\n   /**\n    * Regex callback for wp_kses_decode_entities()\n    *\n    * @since 2.9.0\n    *\n    * @param array $match preg match\n    * @return string\n    */\n   public static function _wp_kses_decode_entities_chr_hexdec( $match ) {\n       return chr( hexdec( $match[1] ) );\n   }\n   \n\n   /**\n    * Perform a deep string replace operation to ensure the values in $search are no longer present\n    *\n    * Repeats the replacement operation until it no longer replaces anything so as to remove \"nested\" values\n    * e.g. $subject = '%0%0%0DDD', $search ='%0D', $result ='' rather than the '%0%0DD' that\n    * str_replace would return\n    *\n    * @since 2.8.1\n    * @access private\n    *\n    * @param string|array $search  The value being searched for, otherwise known as the needle.\n    *                              An array may be used to designate multiple needles.\n    * @param string       $subject The string being searched and replaced on, otherwise known as the haystack.\n    * @return string The string with the replaced svalues.\n    */\n   public static function _deep_replace( $search, $subject ) {\n       $subject = (string) $subject;\n       $count = 1;\n       while ( $count ) {\n           $subject = str_replace( $search, '', $subject, $count );\n       }\n       return $subject;\n   }\n\n   public static $replaceEmoji = array(\n       ':\\)' => \"\\u{1F642}\",\n       ':D:' => \"\\u{1F600}\",\n       ':D' => \"\\u{1F600}\",\n       ':\\(' => \"\\u{1F641}\",\n       ':o:' => \"\\u{1F62E}\",\n       ':o' => \"\\u{1F62E}\",\n       ':p:' => \"\\u{1F61B}\",\n       ':p' => \"\\u{1F61B}\",\n       ';\\)' => \"\\u{1F609}\",\n       ';\\(' => \"\\u{1F622}\",\n       ':x' => \"\\u{1F910}\",\n       ':\\*' => \"\\u{1F617}\",\n       ';\\*' => \"\\u{1F618}\",\n       ':\\/' => \"\\u{1F615}\"\n   );\n\n   public static function parseEmoji($text) {\n\n       // Smileys to find...\n       for ($i = 0; $i < 2; $i++) {\n           $text = preg_replace_callback('/(^|\\s)(' .implode(\"|\",array_keys(self::$replaceEmoji)) . ')(\\s|$)/', function($match) {\n               $char = str_replace(array('/','(',')','*'),array('\\/','\\(','\\)','\\*'),$match[2]);\n               return $match[1] . erLhcoreClassBBCode::$replaceEmoji[$char] . $match[3];\n           },  $text);\n       }\n\n       return $text;\n   }\n\n   public static function BBCode2Html($text) {\n    \t$text = trim($text);\n\n       $text = self::parseEmoji($text);\n\n       // Smileys to find...\n       $in = array(\n       );\n\n       // And replace them by...\n       $out = array(\n       );\n    \t\n    \t$in[] = '[/*]';\n    \t$in[] = '[*]';\n    \t$out[] = '</li>';\n    \t$out[] = '<li>';\n    \t    \t\n    \t$text = str_replace($in, $out, $text);\n\n    \t// BBCode to find...\n    \t$in = array( \t '/\\[b\\](.*?)\\[\\/b\\]/ms',\n    \t\t\t\t\t '/\\[i\\](.*?)\\[\\/i\\]/ms',\n    \t\t\t\t\t '/\\[u\\](.*?)\\[\\/u\\]/ms',\n    \t\t\t\t\t '/\\[mark\\](.*?)\\[\\/mark\\]/ms',\n    \t\t\t\t\t '/\\[s\\](.*?)\\[\\/s\\]/ms',\n    \t\t\t\t\t '/\\[list\\=(.*?)\\](.*?)\\[\\/list\\]/ms',\n    \t\t\t\t\t '/\\[list\\](.*?)\\[\\/list\\]/ms',\n    \t\t\t\t\t '/\\[\\*\\]\\s?(.*?)\\n/ms',\n    \t\t\t\t\t '/\\[fs(.*?)\\](.*?)\\[\\/fs(.*?)\\]/ms',\n    \t\t\t\t\t '/\\[color\\=(.*?)\\](.*?)\\[\\/color\\]/ms'\n    \t);\n\n    \t// And replace them by...\n    \t$out = array(\t '<strong>\\1</strong>',\n    \t\t\t\t\t '<em>\\1</em>',\n    \t\t\t\t\t '<u>\\1</u>',\n    \t\t\t\t\t '<mark>\\1</mark>',\n    \t\t\t\t\t '<strike>\\1</strike>',\n    \t\t\t\t\t '<ol start=\"\\1\">\\2</ol>',\n    \t\t\t\t\t '<ul>\\1</ul>',\n    \t\t\t\t\t '<li>\\1</li>',\n    \t\t\t\t\t '<span style=\"font-size:\\1pt\">\\2</span>',\n    \t\t\t\t\t '<span style=\"color:#\\1\">\\2</span>'\n    \t);\n\n    \t$text = preg_replace($in, $out, $text);\n\n    \t// Prepare quote's\n    \t$text = str_replace(\"\\r\\n\",\"\\n\",$text);\n\n    \t// paragraphs\n    \t$text = str_replace(\"\\r\", \"\", $text);\n    \t$text = nl2br($text);\n\n    \t// clean some tags to remain strict\n    \t// not very elegant, but it works. No time to do better ;)\n    \tif (!function_exists('removeBr')) {\n    \t\tfunction removeBr($s) {\n    \t\t\treturn str_replace(\"<br />\", \"\", $s[0]);\n    \t\t}\n    \t}\n\n    \t$text = preg_replace_callback('/<pre>(.*?)<\\/pre>/ms', \"removeBr\", $text);\n    \t$text = preg_replace('/<p><pre>(.*?)<\\/pre><\\/p>/ms', \"<pre>\\\\1</pre>\", $text);\n\n    \t$text = preg_replace_callback('/<ul>(.*?)<\\/ul>/ms', \"removeBr\", $text);\n    \t$text = preg_replace('/<p><ul>(.*?)<\\/ul><\\/p>/ms', \"<ul>\\\\1</ul>\", $text);\n\n    \treturn $text;\n    }\n\n    public static function _make_url_embed_image($matches) {\n\n        $in = htmlspecialchars_decode($matches[2]);\n        $in = trim($in);\n\n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return '[img]' . $matches[2] . '[img]';\n\n        $prepend = '';\n        $append = '';\n        if (isset($matches[1]) && $matches[1] != '' && !empty(self::esc_url($matches[1]))) {\n            $prepend = '<a class=\"link\" rel=\"noreferrer\" target=\"_blank\" href=\"' . $matches[1] . '\">';\n            $append = '</a>';\n        }\n\n        return  \"<div class=\\\"img_embed\\\">{$prepend}<img class='img-fluid' src=\\\"\".$url.\"\\\" alt=\\\"\\\" />{$append}</div>\";\n   }\n\n   public static function _make_embed_map($matches)\n   {\n       $parts = explode(',',trim($matches[1]));\n\n       if (count($parts) == 2 && is_numeric($parts[0]) && is_numeric($parts[1])) {\n           $id = rand(0,1000) . time();\n           return \"<div id='msg-location-\".$id.\"' style='height:300px'><script>lhinst.showMessageLocation(\" . $id . \",\" . (float)$parts[0] . \",\" . (float)$parts[1] . \")</script></div>\";\n       }\n\n       return ;\n   }\n\n   public static function _make_url_embed($matches){\n\n        $in = str_replace('\"','',htmlspecialchars_decode($matches[1]));\n        $in = trim($in);\n        \n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return '[url='.$matches[1].']' . $matches[2] . '[/url]';\n\t\t\t\t\n        return '<a class=\"link\" target=\"_blank\" rel=\"noreferrer\" href=\"'.$url.'\">' . $matches[2] . '</a>';\n   }\n      \n   /**\n    * Callback to convert URL match to HTML A element.\n    *\n    * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n    *\n    * @since 2.3.2\n    * @access private\n    *\n    * @param array $matches Single Regex Match.\n    * @return string HTML A element with URL address.\n    */\n   public static function _make_web_ftp_clickable_cb( $matches ) {\n       $ret = '';\n       $dest = $matches[2];\n       $dest = 'http://' . $dest;\n       // removed trailing [.,;:)] from URL\n       if ( in_array( substr($dest, -1), array('.', ',', ';', ':', ')') ) === true ) {\n           $ret = substr($dest, -1);\n           $dest = substr($dest, 0, strlen($dest)-1);\n       }\n       $dest = self::esc_url($dest);\n       if ( empty($dest) )\n           return $matches[0];\n       \n       return $matches[1] . \"<a href=\\\"$dest\\\" class=\\\"link\\\" rel=\\\"noreferrer\\\" target=\\\"_blank\\\">$dest</a>$ret\";\n   }\n   \n   /**\n     * Callback to convert email address match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with email address.\n     */\n   public static function _make_email_clickable_cb( $matches ) {\n    \t$email = $matches[2] . '@' . $matches[3];\n    \treturn $matches[1] . \"<a rel=\\\"noreferrer\\\" class=\\\"link\\\" href=\\\"mailto:$email\\\">$email</a>\";\n   }\n\n   \n   public static function _make_paypal_button($matches){\n\n         if (filter_var($matches[1],FILTER_VALIDATE_EMAIL)) {\n            return '<form action=\"https://www.paypal.com/cgi-bin/webscr\" method=\"post\">\n            <input type=\"hidden\" name=\"cmd\" value=\"_donations\">\n            <input type=\"hidden\" name=\"business\" value=\"'.$matches[1].'\">\n            <input type=\"hidden\" name=\"lc\" value=\"US\">\n            <input type=\"hidden\" name=\"no_note\" value=\"0\">\n            <input type=\"hidden\" name=\"currency_code\" value=\"USD\">\n            <input type=\"hidden\" name=\"bn\" value=\"PP-DonationsBF:btn_donate_SM.gif:NonHostedGuest\">\n            <input type=\"image\" title=\"Support an artist\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/btn/btn_donate_SM.gif\" border=\"0\" name=\"submit\" alt=\"PayPal - The safer, easier way to pay online!\">\n            <img alt=\"\" border=\"0\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/scr/pixel.gif\" width=\"1\" height=\"1\">\n            </form>';\n        } else {\n            return $matches[0];\n        }\n   }\n\n   public static function _make_button_action($matches) {\n        return \"<button type=\\\"button\\\" class=\\\"btn btn-xs text-white fs13 btn-secondary\\\" onclick=\\\"lhinst.buttonAction($(this),'\" . htmlspecialchars(strip_tags($matches[1])) . \"')\\\">\" . htmlspecialchars($matches[2]) . \"</button>\";\n   }\n\n   public static function _make_youtube_block($matches) {\n\n         $data = parse_url($matches[1]);\n\n         if (isset($data['query'])){\n             parse_str($data['query'],$query);\n             if (stristr($data['host'],'youtube.com') && isset($query['v']) && ($query['v'] != '')) {\n                 return '<iframe class=\"w-100 h-100\" title=\"YouTube video player\" width=\"480\" height=\"300\" src=\"https://www.youtube.com/embed/'.urlencode($query['v']).'\" frameborder=\"0\" allowfullscreen></iframe>';\n             } else {\n                 return $matches[0];\n             }\n         } else {\n             return $matches[0];\n         }\n   }\n\n   public static function _make_upload_link($matches){\n       $data = $matches[1];\n       return '<a class=\"action-image alert-link\" onclick=\"lhinst.chooseFile()\">' . htmlspecialchars($data) . '</a>';\n   }\n\n   public static function _make_url_file($matches)\n   {\n\n   \t\tif (isset($matches[1])){\n   \t\t    $mainData = explode(' ',$matches[1]);\n   \t\t    $parts = explode('_',$mainData[0]);\n   \t\t\t$fileID = $parts[0];\n   \t\t\t$hash = $parts[1];\n   \t\t\t$displayType = isset($parts[2]) ? $parts[2] : null;\n   \t\t\ttry {\n   \t\t\t\t$file = erLhcoreClassModelChatFile::fetch($fileID);\n\n   \t\t\t\tif (is_object($file)) {\n                    // Check that user has permission to see the chat. Let say if user purposely types file bbcode\n                    if ($hash == $file->security_hash) {\n                        $fileExtension = strtolower($file->extension);\n                        if ($fileExtension == 'jpg' || $fileExtension == 'jpeg' || $fileExtension == 'png' || $fileExtension == 'gif'){\n\n                            // Make link if required\n                            $prepend = '';\n                            $append = '';\n                            if (isset($mainData[1])) {\n                                $subpartParts = explode('=',$mainData[1]);\n                                if ($subpartParts[0] == 'link') {\n                                    if (!isset($subpartParts[1])) {\n                                        $prepend = '<a class=\"link\" rel=\"noreferrer\" target=\"_blank\" href=\"//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\\\">\";\n                                        $append = '</a>';\n                                    } else {\n                                        $url = self::esc_url($subpartParts[1]);\n                                        if ($url != ''){\n                                            $prepend = '<a class=\"link\" rel=\"noreferrer\" target=\"_blank\" href=\"' . self::esc_url($subpartParts[1]) . '\">';\n                                            $append = '</a>';\n                                        }\n                                    }\n                                }\n                            } else {\n                                $prepend = '';\n                                $append = '<a class=\"hidden-download\" rel=\"noreferrer\" href=\"//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\".'\"></a>';\n                            }\n                            return $prepend . '<img id=\"img-file-' . $file->id . '\" class=\"img-fluid\" src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\" alt=\"\" />' . $append;\n                        }\n\n                        $audio = '';\n                        if ($fileExtension == 'mp3' || $fileExtension == 'wav' || $fileExtension == 'ogg') {\n                            return '<a rel=\"noreferrer\" class=\"hidden-download audio-download\" href=\"//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\".'\"></a><audio preload=\"none\" style=\"width: 230px\" controls><source src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\" type=\"' . $file->type . '\"></audio>';\n                        } elseif ($fileExtension == 'mp4' || $fileExtension == 'avi' || $fileExtension == 'mov' || $fileExtension == 'ogg' || $fileExtension == '3gpp') {\n                            $audio = '<br><div class=\"embed-responsive embed-responsive-16by9\"><video class=\"embed-responsive-item\" controls><source src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\"></video></div>';\n                        } else if ($fileExtension == 'jpg' || $fileExtension == 'jpeg' || $fileExtension == 'png') {\n                            $audio = ' <a rel=\"noreferrer\" class=\"link\" onclick=\"$(\\'#img-file-' . $file->id . '\\').toggleClass(\\'hide\\')\"><i class=\"material-icons mr-0\">&#xE251;</i></a><br/><img id=\"img-file-' . $file->id . '\" class=\"img-fluid hide\" src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\" alt=\"\" />';\n                        }\n\n                        return \"<a href=\\\"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\" class=\\\"link\\\" >\" . erTranslationClassLhTranslation::getInstance()->getTranslation('file/file', 'Download file') . ' - ' . htmlspecialchars($file->upload_name) . ' [' . $file->extension . ']' . \"</a>\" . $audio;\n                    }\n                }\n\n   \t\t\t} catch (Exception $e) {\n\n   \t\t\t}\n\n   \t\t\treturn '';\n   \t\t}\n   \t\treturn '';\n   }\n\n   public static function _make_url_survey($matches)\n   {\n       if (isset($matches[1])){\n                  \n           list($surveyId, $surveyItemId) = explode('_',str_replace(array('\"','&quot;'),'', $matches[1]));\n           \n           try {\n                             \n               if (is_numeric($surveyItemId) && is_numeric($surveyId)) {\n\n                   $surveyItem = erLhAbstractModelSurveyItem::fetch($surveyItemId);\n\n                   if ($surveyId == $surveyItem->survey_id) \n                   {\n                       $survey = erLhAbstractModelSurvey::fetch($surveyId);\n                       return \"<a href=\\\"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('survey/collected').\"/{$survey->id}?show={$surveyItem->id}\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\" class=\\\"link\\\" >\" . erTranslationClassLhTranslation::getInstance()->getTranslation('file/file','Collected survey data') . ' - ' . htmlspecialchars($survey->name) . \"</a>\";\n                   }\n               }\n               \n           } catch (Exception $e) {\n       \n           }\n       \n           return '';\n       }\n       return '';\n   }\n   \n   public static function _make_url_mail_file($matches){\n\n   \t\tif (isset($matches[1])){\n   \t\t\tlist($fileID,$hash) = explode('_',$matches[1]);\n   \t\t\ttry {\n   \t\t\t\t$file = erLhcoreClassModelChatFile::fetch($fileID);\n\n   \t\t\t\t// Check that user has permission to see the chat. Let say if user purposely types file bbcode\n   \t\t\t\tif ($hash == $file->security_hash) {\n   \t\t\t\t\treturn erLhcoreClassXMP::getBaseHost().$_SERVER['HTTP_HOST'].erLhcoreClassDesign::baseurldirect('file/downloadfile').\"/{$file->id}/{$hash}\";\n   \t\t\t\t}\n   \t\t\t} catch (Exception $e) {\n\n   \t\t\t}\n\n   \t\t\treturn '';\n   \t\t}\n   \t\treturn '';\n   }\n\n   public static function _split_str_by_whitespace( $string, $goal ) {\n        $chunks = array();\n\n        $string_nullspace = strtr( $string, \"\\r\\n\\t\\v\\f \", \"\\000\\000\\000\\000\\000\\000\" );\n\n        while ( $goal < strlen( $string_nullspace ) ) {\n            $pos = strrpos( substr( $string_nullspace, 0, $goal + 1 ), \"\\000\" );\n\n            if ( false === $pos ) {\n                $pos = strpos( $string_nullspace, \"\\000\", $goal + 1 );\n                if ( false === $pos ) {\n                    break;\n                }\n            }\n\n            $chunks[] = substr( $string, 0, $pos + 1 );\n            $string = substr( $string, $pos + 1 );\n            $string_nullspace = substr( $string_nullspace, $pos + 1 );\n        }\n\n        if ( $string ) {\n            $chunks[] = $string;\n        }\n\n        return $chunks;\n    }\n\n   // https://github.com/WordPress/WordPress/blob/6e5e29c5bf49ad2be6a2c3a3d4fb3f5af6853b5b/wp-includes/formatting.php\n   public static function make_clickable_text( $text ) {\n       $r = '';\n       $textarr = preg_split( '/(<[^<>]+>)/', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // split out HTML tags\n       $nested_code_pre = 0; // Keep track of how many levels link is nested inside <pre> or <code>\n       foreach ( $textarr as $piece ) {\n           if ( preg_match( '|^<code[\\s>]|i', $piece ) || preg_match( '|^<pre[\\s>]|i', $piece ) || preg_match( '|^<script[\\s>]|i', $piece ) || preg_match( '|^<style[\\s>]|i', $piece ) )\n               $nested_code_pre++;\n           elseif ( $nested_code_pre && ( '</code>' === strtolower( $piece ) || '</pre>' === strtolower( $piece ) || '</script>' === strtolower( $piece ) || '</style>' === strtolower( $piece ) ) )\n           $nested_code_pre--;\n           if ( $nested_code_pre || empty( $piece ) || ( $piece[0] === '<' && ! preg_match( '|^<\\s*[\\w]{1,20}+://|', $piece ) ) ) {\n               $r .= $piece;\n               continue;\n           }\n           // Long strings might contain expensive edge cases ...\n           if ( 10000 < strlen( $piece ) ) {\n               // ... break it up\n               foreach ( self::_split_str_by_whitespace( $piece, 2100 ) as $chunk ) { // 2100: Extra room for scheme and leading and trailing paretheses\n                   if ( 2101 < strlen( $chunk ) ) {\n                       $r .= $chunk; // Too big, no whitespace: bail.\n                   } else {\n                       $r .= self::make_clickable_text( $chunk );\n                   }\n               }\n           } else {\n               $ret = \" $piece \"; // Pad with whitespace to simplify the regexes\n               $url_clickable = '~\n\t\t\t\t([\\\\s(<.,;:!?])                                        # 1: Leading whitespace, or punctuation\n\t\t\t\t(                                                      # 2: URL\n\t\t\t\t\t[\\\\w]{1,20}+://                                # Scheme and hier-part prefix\n\t\t\t\t\t(?=\\S{1,2000}\\s)                               # Limit to URLs less than about 2000 characters long\n\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]*+         # Non-punctuation URL character\n\t\t\t\t\t(?:                                            # Unroll the Loop: Only allow puctuation URL character if followed by a non-punctuation URL character\n\t\t\t\t\t\t[\\'.,;:!?)]                            # Punctuation URL character\n\t\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]++ # Non-punctuation URL character\n\t\t\t\t\t)*\n\t\t\t\t)\n\t\t\t\t(\\)?)                                                  # 3: Trailing closing parenthesis (for parethesis balancing post processing)\n\t\t\t~xS'; // The regex is a non-anchored pattern and does not have a single fixed starting character.\n               // Tell PCRE to spend more time optimizing since, when used on a page load, it will probably be used several times.\n               $ret = preg_replace_callback( $url_clickable, 'erLhcoreClassBBCode::_make_url_clickable_cb', $ret );\n               $ret = preg_replace_callback( '#([\\s>])((www|ftp)\\.[\\w\\\\x80-\\\\xff\\#$%&~/.\\-;:=,?@\\[\\]+]+)#is', 'erLhcoreClassBBCode::_make_web_ftp_clickable_cb', $ret );\n               $ret = preg_replace_callback( '#([\\s>])([.0-9a-z_+-]+)@(([0-9a-z-]+\\.)+[0-9a-z]{2,})#i', 'erLhcoreClassBBCode::_make_email_clickable_cb', $ret );\n               $ret = substr( $ret, 1, -1 ); // Remove our whitespace padding.\n               $r .= $ret;\n           }\n       }\n       \n       // Cleanup of accidental links within links\n       return preg_replace( '#(<a([ \\r\\n\\t]+[^>]+?>|>))<a [^>]+?>([^>]+?)</a></a>#i', \"$1$3</a>\", $r );\n   }\n\n   public static function makeQuote($matches)\n   {\n       if ($matches[1]) {\n           return '<blockquote class=\"blockquote\"> ' . $matches[1] . ' </blockquote>';\n       } else {\n           return $matches[0];\n       }\n   }\n\n   public static function extractMetaByMessage(& $msg) {\n       $meta = array();\n       if (strpos($msg,'[html_snippet]') !== false) {\n           $matches = array();\n           preg_match_all('/\\[html_snippet\\](.*?)\\[\\/html_snippet\\]/is',$msg,$matches);\n           foreach ($matches[0] as $index => $match) {\n               $msg = str_replace($match,'',$msg);\n               $meta['html_snippet'][] = $matches[1][$index];\n           }\n       }\n       return $meta;\n   }\n\n   public static function makeSubmessages($msg, $paramsMessage = array()) {\n\n       // Links wraps images\n       $msg = preg_replace('#\\[url\\=\"?(.*?)\"?\\]\\[file=\"?(.*?)_img\"?\\]\\[\\/url\\]#is','[file=\\2_img link=\\1]',$msg);\n\n       // pure files\n       $msg = preg_replace('#\\[file=\"?(.*?)_img\"?(.*?)\\]#is','IMG_REPLACE[file=\\1_img\\2]IMG_REPLACE',$msg);\n\n       // Images within links\n       $msg = preg_replace('#\\[url\\=\"?(.*?)\"?\\]\\[img\\](.*?)\\[\\/img\\]\\[\\/url\\]#is','[img=\\1]\\2[/img]',$msg);\n\n       // Pure images\n       $msg = preg_replace('#\\[img(.*?)\\](.*?)\\[\\/img\\]#is','IMG_REPLACE[img\\1]\\2[/img]IMG_REPLACE',$msg);\n\n       $msg = trim($msg);\n\n       $messages = array_filter(explode('IMG_REPLACE', $msg));\n       $totalMessages = count($messages);\n\n       $messagesData = array();\n       foreach ($messages as $indexMessage => $message) {\n           if (trim($message) != '')\n           {\n               $msgRendered = erLhcoreClassBBCode::make_clickable(htmlspecialchars($message), $paramsMessage);\n\n               $messagesDataItem['body'] = $msgRendered;\n               $messagesDataItem['flags'] = [];\n\n               $msgRenderedMedia = strip_tags($msgRendered);\n               $emojiMessage = trim(preg_replace('#([\\x{2B50}-\\x{2B55}]|[\\x{23F0}-\\x{23F3}]|[\\x{231A}-\\x{231B}]|[\\x{1F600}-\\x{1F64F}]|[\\x{1F910}-\\x{1F9FF}]|[\\x{1F300}-\\x{1F5FF}]|[\\x{1F680}-\\x{1F6FF}]|[\\x{2600}-\\x{26FF}]|[\\x{2700}-\\x{27BF}])#u','', $msgRendered));\n\n               if ($msgRenderedMedia == '') {\n                   $messagesDataItem['flags'][] = 'img';\n               }\n\n               if ($emojiMessage == '') {\n                   $messagesDataItem['flags'][] = 'emoji';\n               }\n\n                // New line at the top of message and it's not the first message\n               if (substr($message,0,1) == \"\\n\" && $indexMessage > 0) {\n                   $messagesDataItem['flags'][] = 'nlt';\n               }\n\n               // New line at the end of message and it's not the last message\n               if (substr($message,-1) == \"\\n\" && $indexMessage + 1 != $totalMessages) {\n                   $messagesDataItem['flags'][] = 'nl';\n               }\n\n               $messagesData[] = $messagesDataItem;\n           }\n       }\n\n       return $messagesData;\n   }\n\n   // Converts bbcode and general links to hmtl code\n   public static function make_clickable($ret, $paramsMessage = array()) {\n        $ret = ' ' . $ret;\n\n        $makeLinksClickable = true;\n        \n        erLhcoreClassChatEventDispatcher::getInstance()->dispatch('chat.before_make_clickable',array('msg' => & $ret, 'makeLinksClickable' => & $makeLinksClickable));\n\n        $ret = preg_replace_callback('/\\[img=?(.*?)\\](.*?)\\[\\/img\\]/ms', \"erLhcoreClassBBCode::_make_url_embed_image\", $ret);\n\n        $ret = preg_replace_callback('/\\[loc\\](.*?)\\[\\/loc\\]/ms', \"erLhcoreClassBBCode::_make_embed_map\", $ret);\n\n        $ret = preg_replace_callback('/\\[url\\=\"?(.*?)\"?\\](.*?)\\[\\/url\\]/ms', \"erLhcoreClassBBCode::_make_url_embed\", $ret);\n\n        if (isset($paramsMessage['sender']) && $paramsMessage['sender'] == 0) {\n            $ret = preg_replace('/\\[html\\](.*?)\\[\\/html\\]/ms','',$ret);\n        }\n\n        $ret = preg_replace_callback('/\\[html\\](.*?)\\[\\/html\\]/ms', function ($matches) {\n            $html = htmlspecialchars_decode($matches[1]);\n\n            $html = preg_replace_callback('/\"window\\.parent\\.(.*)\"/ms',function ($matches){\n                return \"'lhinst.executeRemoteCommands([\\\"lhc_eval:\" . $matches[1] . \"\\\"])'\";\n            },$html);\n\n            return $html;\n\n        }, $ret);\n\n\n        if ($makeLinksClickable) {\n            $ret = self::make_clickable_text($ret);           \n        }\n\n    \t$ret = self::BBCode2Html($ret);\n\n    \t// Paypal button\n    \t$ret = preg_replace_callback('#\\[paypal\\](.*?)\\[/paypal\\]#is', 'erLhcoreClassBBCode::_make_paypal_button', $ret);\n\n    \t// Quote\n    \t$ret = preg_replace_callback('#\\[quote\\](.*?)\\[/quote\\]#is', 'erLhcoreClassBBCode::makeQuote', $ret);\n\n    \t// Youtube block\n    \t$ret = preg_replace_callback('#\\[youtube\\](.*?)\\[/youtube\\]#is', 'erLhcoreClassBBCode::_make_youtube_block', $ret);\n\n    \t// File upload link directly in chat message\n    \t$ret = preg_replace_callback('#\\[fupload\\](.*?)\\[/fupload\\]#is', 'erLhcoreClassBBCode::_make_upload_link', $ret);\n\n    \t$ret = preg_replace_callback('#\\[button_action=\"?(.*?)\"?\\](.*?)\\[/button_action\\]#is', 'erLhcoreClassBBCode::_make_button_action', $ret);\n\n    \t$ret = preg_replace('#\\[translation\\](.*?)\\[/translation\\]#is', '<span class=\"tr-msg\">$1</span>', $ret);\n\n    \t// File block\n    \t$ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCode::_make_url_file', $ret);\n    \t\n    \t// Survey\n    \t$ret = preg_replace_callback('#\\[survey=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCode::_make_url_survey', $ret);\n\n    \t$ret = trim($ret);\n\n        erLhcoreClassChatEventDispatcher::getInstance()->dispatch('chat.after_make_clickable',array('msg' => & $ret));\n        \n    \treturn $ret;\n   }\n   \n   public static function parseForMail($ret){\n   \t\t// File block\n   \t\t$ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCode::_make_url_mail_file', $ret);\n   \t\treturn trim($ret);\n   }\n   \n   // Makes plain text from BB code\n   public static function make_plain($ret){\n        $ret = ' ' . $ret;\n\n       // BBCode to find...\n       $in = array( \t '/\\[b\\](.*?)\\[\\/b\\]/ms',\n           '/\\[i\\](.*?)\\[\\/i\\]/ms',\n           '/\\[u\\](.*?)\\[\\/u\\]/ms',\n           '/\\[list\\=(.*?)\\](.*?)\\[\\/list\\]/ms',\n           '/\\[list\\](.*?)\\[\\/list\\]/ms',\n           '/\\[\\*\\]\\s?(.*?)\\n/ms',\n           '/\\[img\\](.*?)\\[\\/img\\]/ms',\n           '/\\[url\\=\"?(.*?)\"?\\](.*?)\\[\\/url\\]/ms',\n           '/\\[quote\\]/ms',\n           '/\\[\\/quote\\]/ms',\n           '/\\[fs(.*?)\\](.*?)\\[\\/fs(.*?)\\]/ms',\n           '/\\n/ms',\n       );\n\n       // And replace them by...\n       $out = array(\t '\\1',\n           '\\1',\n           '\\1',\n           '\\2',\n           '\\1',\n           '\\1',\n           '',\n           '\\2 \\1',\n           '',\n           '',\n           '\\2',\n           ' ',\n       );\n\n    \t$ret = preg_replace($in, $out, $ret);\n\n        $ret = trim($ret);\n        return $ret;\n   }\n\n}\n\n\n?>\n", "<?php\n\n/**\n * This code is mix of WP and phpBB :)\n * */\nclass erLhcoreClassBBCodePlain\n{\n    /**\n     * Callback to convert URI match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with URI address.\n     */\n    public static function _make_url_clickable_cb( $matches ) {\n        $url = $matches[2];\n        if ( ')' == $matches[3] && strpos( $url, '(' ) ) {\n            // If the trailing character is a closing parethesis, and the URL has an opening parenthesis in it, add the closing parenthesis to the URL.\n            // Then we can let the parenthesis balancer do its thing below.\n            $url .= $matches[3];\n            $suffix = '';\n        } else {\n            $suffix = $matches[3];\n        }\n        // Include parentheses in the URL only if paired\n        while ( substr_count( $url, '(' ) < substr_count( $url, ')' ) ) {\n            $suffix = strrchr( $url, ')' ) . $suffix;\n            $url = substr( $url, 0, strrpos( $url, ')' ) );\n        }\n        $url = self::esc_url($url);\n        if ( empty($url) )\n            return $matches[0];\n        return $matches[1] . $url . $suffix;\n    }\n\n    /**\n     * Checks and cleans a URL.\n     *\n     * A number of characters are removed from the URL. If the URL is for displaying\n     * (the default behaviour) ampersands are also replaced. The {@see 'clean_url'} filter\n     * is applied to the returned cleaned URL.\n     *\n     * @since 2.8.0\n     *\n     * @param string $url       The URL to be cleaned.\n     * @param array  $protocols Optional. An array of acceptable protocols.\n     *\t\t                    Defaults to return value of wp_allowed_protocols()\n     * @param string $_context  Private. Use esc_url_raw() for database usage.\n     * @return string The cleaned $url after the {@see 'clean_url'} filter is applied.\n     */\n    public static function esc_url( $url, $protocols = null, $_context = 'display' ) {\n        $original_url = $url;\n        if ( '' == $url )\n            return $url;\n        $url = str_replace( ' ', '%20', $url );\n        $url = preg_replace('|[^a-z0-9-~+_.?#=!&;,/:%@$\\|*\\'()\\[\\]\\\\x80-\\\\xff]|i', '', $url);\n        if ( '' === $url ) {\n            return $url;\n        }\n        if ( 0 !== stripos( $url, 'mailto:' ) ) {\n            $strip = array('%0d', '%0a', '%0D', '%0A');\n            $url = self::_deep_replace($strip, $url);\n        }\n        $url = str_replace(';//', '://', $url);\n        /* If the URL doesn't appear to contain a scheme, we\n         * presume it needs http:// prepended (unless a relative\n         * link starting with /, # or ? or a php file).\n        */\n        if ( strpos($url, ':') === false && ! in_array( $url[0], array( '/', '#', '?' ) ) &&\n            ! preg_match('/^[a-z0-9-]+?\\.php/i', $url) )\n            $url = 'http://' . $url;\n        // Replace ampersands and single quotes only when displaying.\n        if ( 'display' == $_context ) {\n            $url = self::wp_kses_normalize_entities( $url );\n            $url = str_replace( '&amp;', '&#038;', $url );\n            $url = str_replace( \"'\", '&#039;', $url );\n        }\n        if ( ( false !== strpos( $url, '[' ) ) || ( false !== strpos( $url, ']' ) ) ) {\n            $parsed = self::wp_parse_url( $url );\n            $front  = '';\n            if ( isset( $parsed['scheme'] ) ) {\n                $front .= $parsed['scheme'] . '://';\n            } elseif ( '/' === $url[0] ) {\n                $front .= '//';\n            }\n            if ( isset( $parsed['user'] ) ) {\n                $front .= $parsed['user'];\n            }\n            if ( isset( $parsed['pass'] ) ) {\n                $front .= ':' . $parsed['pass'];\n            }\n            if ( isset( $parsed['user'] ) || isset( $parsed['pass'] ) ) {\n                $front .= '@';\n            }\n            if ( isset( $parsed['host'] ) ) {\n                $front .= $parsed['host'];\n            }\n            if ( isset( $parsed['port'] ) ) {\n                $front .= ':' . $parsed['port'];\n            }\n            $end_dirty = str_replace( $front, '', $url );\n            $end_clean = str_replace( array( '[', ']' ), array( '%5B', '%5D' ), $end_dirty );\n            $url       = str_replace( $end_dirty, $end_clean, $url );\n        }\n        if ( '/' === $url[0] ) {\n            $good_protocol_url = $url;\n        } else {\n            if ( ! is_array( $protocols ) )\n                $protocols = $protocols = array( 'http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet', 'mms', 'rtsp', 'svn', 'tel', 'fax', 'xmpp', 'webcal', 'urn' );\n\n            $good_protocol_url = self::wp_kses_bad_protocol( $url, $protocols );\n            if ( strtolower( $good_protocol_url ) != strtolower( $url ) )\n                return '';\n        }\n\n        /**\n         * Filters a string cleaned and escaped for output as a URL.\n         *\n         * @since 2.3.0\n         *\n         * @param string $good_protocol_url The cleaned URL to be returned.\n         * @param string $original_url      The URL prior to cleaning.\n         * @param string $_context          If 'display', replace ampersands and single quotes only.\n         */\n        return $url;\n    }\n\n    /**\n     * A wrapper for PHP's parse_url() function that handles consistency in the return\n     * values across PHP versions.\n     *\n     * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n     * schemeless and relative url's with :// in the path. This function works around\n     * those limitations providing a standard output on PHP 5.2~5.4+.\n     *\n     * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n     * in the query are being handled inconsistently. This function works around those\n     * differences as well.\n     *\n     * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n     * when URL parsing failed.\n     *\n     * @since 4.4.0\n     * @since 4.7.0 The $component parameter was added for parity with PHP's parse_url().\n     *\n     * @param string $url       The URL to parse.\n     * @param int    $component The specific component to retrieve. Use one of the PHP\n     *                          predefined constants to specify which one.\n     *                          Defaults to -1 (= return all parts as an array).\n     *                          @see http://php.net/manual/en/function.parse-url.php\n     * @return mixed False on parse failure; Array of URL components on success;\n     *               When a specific component has been requested: null if the component\n     *               doesn't exist in the given URL; a string or - in the case of\n     *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n     */\n    public static function wp_parse_url( $url, $component = -1 ) {\n        $to_unset = array();\n        $url = strval( $url );\n        if ( '//' === substr( $url, 0, 2 ) ) {\n            $to_unset[] = 'scheme';\n            $url = 'placeholder:' . $url;\n        } elseif ( '/' === substr( $url, 0, 1 ) ) {\n            $to_unset[] = 'scheme';\n            $to_unset[] = 'host';\n            $url = 'placeholder://placeholder' . $url;\n        }\n        $parts = @parse_url( $url );\n        if ( false === $parts ) {\n            // Parsing failure.\n            return $parts;\n        }\n        // Remove the placeholder values.\n        foreach ( $to_unset as $key ) {\n            unset( $parts[ $key ] );\n        }\n        return self::_get_component_from_parsed_url_array( $parts, $component );\n    }\n\n    /**\n     * Retrieve a specific component from a parsed URL array.\n     *\n     * @internal\n     *\n     * @since 4.7.0\n     *\n     * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n     * @param int    $component The specific component to retrieve. Use one of the PHP\n     *                          predefined constants to specify which one.\n     *                          Defaults to -1 (= return all parts as an array).\n     *                          @see http://php.net/manual/en/function.parse-url.php\n     * @return mixed False on parse failure; Array of URL components on success;\n     *               When a specific component has been requested: null if the component\n     *               doesn't exist in the given URL; a string or - in the case of\n     *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n     */\n    public static function _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n        if ( -1 === $component ) {\n            return $url_parts;\n        }\n        $key = self::_wp_translate_php_url_constant_to_key( $component );\n        if ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n            return $url_parts[ $key ];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Translate a PHP_URL_* constant to the named array keys PHP uses.\n     *\n     * @internal\n     *\n     * @since 4.7.0\n     *\n     * @see   http://php.net/manual/en/url.constants.php\n     *\n     * @param int $constant PHP_URL_* constant.\n     * @return string|bool The named key or false.\n     */\n    public static function _wp_translate_php_url_constant_to_key( $constant ) {\n        $translation = array(\n            PHP_URL_SCHEME   => 'scheme',\n            PHP_URL_HOST     => 'host',\n            PHP_URL_PORT     => 'port',\n            PHP_URL_USER     => 'user',\n            PHP_URL_PASS     => 'pass',\n            PHP_URL_PATH     => 'path',\n            PHP_URL_QUERY    => 'query',\n            PHP_URL_FRAGMENT => 'fragment',\n        );\n        if ( isset( $translation[ $constant ] ) ) {\n            return $translation[ $constant ];\n        } else {\n            return false;\n        }\n    }\n\n\n    /**\n     * Converts and fixes HTML entities.\n     *\n     * This function normalizes HTML entities. It will convert `AT&T` to the correct\n     * `AT&amp;T`, `&#00058;` to `&#58;`, `&#XYZZY;` to `&amp;#XYZZY;` and so on.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string Content to normalize entities\n     * @return string Content with normalized entities\n     */\n    public static function wp_kses_normalize_entities($string) {\n        // Disarm all entities by converting & to &amp;\n        $string = str_replace('&', '&amp;', $string);\n        // Change back the allowed entities in our entity whitelist\n        $string = preg_replace_callback('/&amp;([A-Za-z]{2,8}[0-9]{0,2});/', 'erLhcoreClassBBCodePlain::wp_kses_named_entities', $string);\n        $string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'erLhcoreClassBBCodePlain::wp_kses_normalize_entities2', $string);\n        $string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'erLhcoreClassBBCodePlain::wp_kses_normalize_entities3', $string);\n        return $string;\n    }\n\n    /**\n     * Callback for wp_kses_normalize_entities() for regular expression.\n     *\n     * This function helps wp_kses_normalize_entities() to only accept valid Unicode\n     * numeric entities in hex form.\n     *\n     * @since 2.7.0\n     * @access private\n     *\n     * @param array $matches preg_replace_callback() matches array\n     * @return string Correctly encoded entity\n     */\n    public static function wp_kses_normalize_entities3($matches) {\n        if ( empty($matches[1]) )\n            return '';\n        $hexchars = $matches[1];\n        return ( ! self::valid_unicode( hexdec( $hexchars ) ) ) ? \"&amp;#x$hexchars;\" : '&#x'.ltrim($hexchars,'0').';';\n    }\n\n    /**\n     * Helper function to determine if a Unicode value is valid.\n     *\n     * @since 2.7.0\n     *\n     * @param int $i Unicode value\n     * @return bool True if the value was a valid Unicode number\n     */\n    public static function valid_unicode($i) {\n        return ( $i == 0x9 || $i == 0xa || $i == 0xd ||\n            ($i >= 0x20 && $i <= 0xd7ff) ||\n            ($i >= 0xe000 && $i <= 0xfffd) ||\n            ($i >= 0x10000 && $i <= 0x10ffff) );\n    }\n\n    /**\n     * Callback for wp_kses_normalize_entities() regular expression.\n     *\n     * This function helps wp_kses_normalize_entities() to only accept 16-bit\n     * values and nothing more for `&#number;` entities.\n     *\n     * @access private\n     * @since 1.0.0\n     *\n     * @param array $matches preg_replace_callback() matches array\n     * @return string Correctly encoded entity\n     */\n    public static function wp_kses_normalize_entities2($matches) {\n        if ( empty($matches[1]) )\n            return '';\n        $i = $matches[1];\n        if (self::valid_unicode($i)) {\n            $i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);\n            $i = \"&#$i;\";\n        } else {\n            $i = \"&amp;#$i;\";\n        }\n        return $i;\n    }\n\n    /**\n     * Callback for wp_kses_normalize_entities() regular expression.\n     *\n     * This function only accepts valid named entity references, which are finite,\n     * case-sensitive, and highly scrutinized by HTML and XML validators.\n     *\n     * @since 3.0.0\n     *\n     * @global array $allowedentitynames\n     *\n     * @param array $matches preg_replace_callback() matches array\n     * @return string Correctly encoded entity\n     */\n    public static function wp_kses_named_entities($matches) {\n        $allowedentitynames = array(\n            'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',\n            'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',\n            'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',\n            'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',\n            'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',\n            'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',\n            'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',\n            'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',\n            'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',\n            'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',\n            'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',\n            'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',\n            'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',\n            'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',\n            'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',\n            'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',\n            'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',\n            'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',\n            'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',\n            'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',\n            'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',\n            'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',\n            'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',\n            'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',\n            'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',\n            'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',\n            'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',\n            'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',\n            'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',\n            'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',\n            'oline',   'frasl',  'weierp',  'image',  'real',   'trade',\n            'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',\n            'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',\n            'forall',  'part',   'exist',   'empty',  'nabla',  'isin',\n            'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',\n            'radic',   'prop',   'infin',   'ang',    'and',    'or',\n            'cap',     'cup',    'int',     'sim',    'cong',   'asymp',\n            'ne',      'equiv',  'le',      'ge',     'sub',    'sup',\n            'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',\n            'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',\n            'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',\n            'sup1',    'sup2',   'sup3',    'frac14', 'frac12', 'frac34',\n            'there4',\n        );\n\n        if ( empty($matches[1]) )\n            return '';\n        $i = $matches[1];\n        return ( ! in_array( $i, $allowedentitynames ) ) ? \"&amp;$i;\" : \"&$i;\";\n    }\n\n    /**\n     * Sanitize string from bad protocols.\n     *\n     * This function removes all non-allowed protocols from the beginning of\n     * $string. It ignores whitespace and the case of the letters, and it does\n     * understand HTML entities. It does its work in a while loop, so it won't be\n     * fooled by a string like \"javascript:javascript:alert(57)\".\n     *\n     * @since 1.0.0\n     *\n     * @param string $string            Content to filter bad protocols from\n     * @param array  $allowed_protocols Allowed protocols to keep\n     * @return string Filtered content\n     */\n    public static function wp_kses_bad_protocol($string, $allowed_protocols) {\n        $string = self::wp_kses_no_null($string);\n        $iterations = 0;\n        do {\n            $original_string = $string;\n            $string = self::wp_kses_bad_protocol_once($string, $allowed_protocols);\n        } while ( $original_string != $string && ++$iterations < 6 );\n        if ( $original_string != $string )\n            return '';\n        return $string;\n    }\n\n    /**\n     * Removes any invalid control characters in $string.\n     *\n     * Also removes any instance of the '\\0' string.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string\n     * @param array $options Set 'slash_zero' => 'keep' when '\\0' is allowed. Default is 'remove'.\n     * @return string\n     */\n    public static function wp_kses_no_null( $string, $options = null ) {\n        if ( ! isset( $options['slash_zero'] ) ) {\n            $options = array( 'slash_zero' => 'remove' );\n        }\n        $string = preg_replace( '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $string );\n        if ( 'remove' == $options['slash_zero'] ) {\n            $string = preg_replace( '/\\\\\\\\+0+/', '', $string );\n        }\n        return $string;\n    }\n\n    /**\n     * Sanitizes content from bad protocols and other characters.\n     *\n     * This function searches for URL protocols at the beginning of $string, while\n     * handling whitespace and HTML entities.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string            Content to check for bad protocols\n     * @param string $allowed_protocols Allowed protocols\n     * @return string Sanitized content\n     */\n    public static function wp_kses_bad_protocol_once($string, $allowed_protocols, $count = 1 ) {\n        $string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\n        if ( isset($string2[1]) && ! preg_match('%/\\?%', $string2[0]) ) {\n            $string = trim( $string2[1] );\n            $protocol = self::wp_kses_bad_protocol_once2( $string2[0], $allowed_protocols );\n            if ( 'feed:' == $protocol ) {\n                if ( $count > 2 )\n                    return '';\n                $string = self::wp_kses_bad_protocol_once( $string, $allowed_protocols, ++$count );\n                if ( empty( $string ) )\n                    return $string;\n            }\n            $string = $protocol . $string;\n        }\n        return $string;\n    }\n\n\n    /**\n     * Callback for wp_kses_bad_protocol_once() regular expression.\n     *\n     * This function processes URL protocols, checks to see if they're in the\n     * whitelist or not, and returns different data depending on the answer.\n     *\n     * @access private\n     * @since 1.0.0\n     *\n     * @param string $string            URI scheme to check against the whitelist\n     * @param string $allowed_protocols Allowed protocols\n     * @return string Sanitized content\n     */\n    public static function wp_kses_bad_protocol_once2( $string, $allowed_protocols ) {\n        $string2 = self::wp_kses_decode_entities($string);\n        $string2 = preg_replace('/\\s/', '', $string2);\n        $string2 = self::wp_kses_no_null($string2);\n        $string2 = strtolower($string2);\n        $allowed = false;\n        foreach ( (array) $allowed_protocols as $one_protocol )\n            if ( strtolower($one_protocol) == $string2 ) {\n                $allowed = true;\n                break;\n            }\n        if ($allowed)\n            return \"$string2:\";\n        else\n            return '';\n    }\n\n    /**\n     * Convert all entities to their character counterparts.\n     *\n     * This function decodes numeric HTML entities (`&#65;` and `&#x41;`).\n     * It doesn't do anything with other entities like &auml;, but we don't\n     * need them in the URL protocol whitelisting system anyway.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string Content to change entities\n     * @return string Content after decoded entities\n     */\n    public static function wp_kses_decode_entities($string) {\n        $string = preg_replace_callback('/&#([0-9]+);/', 'erLhcoreClassBBCodePlain::_wp_kses_decode_entities_chr', $string);\n        $string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', 'erLhcoreClassBBCodePlain::_wp_kses_decode_entities_chr_hexdec', $string);\n        return $string;\n    }\n\n    /**\n     * Regex callback for wp_kses_decode_entities()\n     *\n     * @since 2.9.0\n     *\n     * @param array $match preg match\n     * @return string\n     */\n    public static function _wp_kses_decode_entities_chr( $match ) {\n        return chr( $match[1] );\n    }\n    /**\n     * Regex callback for wp_kses_decode_entities()\n     *\n     * @since 2.9.0\n     *\n     * @param array $match preg match\n     * @return string\n     */\n    public static function _wp_kses_decode_entities_chr_hexdec( $match ) {\n        return chr( hexdec( $match[1] ) );\n    }\n\n\n    /**\n     * Perform a deep string replace operation to ensure the values in $search are no longer present\n     *\n     * Repeats the replacement operation until it no longer replaces anything so as to remove \"nested\" values\n     * e.g. $subject = '%0%0%0DDD', $search ='%0D', $result ='' rather than the '%0%0DD' that\n     * str_replace would return\n     *\n     * @since 2.8.1\n     * @access private\n     *\n     * @param string|array $search  The value being searched for, otherwise known as the needle.\n     *                              An array may be used to designate multiple needles.\n     * @param string       $subject The string being searched and replaced on, otherwise known as the haystack.\n     * @return string The string with the replaced svalues.\n     */\n    public static function _deep_replace( $search, $subject ) {\n        $subject = (string) $subject;\n        $count = 1;\n        while ( $count ) {\n            $subject = str_replace( $search, '', $subject, $count );\n        }\n        return $subject;\n    }\n\n    public static $replaceEmoji = array(\n        ':\\)' => \"\\u{1F642}\",\n        ':D:' => \"\\u{1F600}\",\n        ':D' => \"\\u{1F600}\",\n        ':\\(' => \"\\u{1F641}\",\n        ':o:' => \"\\u{1F62E}\",\n        ':o' => \"\\u{1F62E}\",\n        ':p:' => \"\\u{1F61B}\",\n        ':p' => \"\\u{1F61B}\",\n        ';\\)' => \"\\u{1F609}\",\n        ';\\(' => \"\\u{1F622}\",\n        ':x' => \"\\u{1F910}\",\n        ':\\*' => \"\\u{1F617}\",\n        ';\\*' => \"\\u{1F618}\",\n        ':\\/' => \"\\u{1F615}\"\n    );\n\n    public static function parseEmoji($text) {\n\n        // Smileys to find...\n        for ($i = 0; $i < 2; $i++) {\n            $text = preg_replace_callback('/(^|\\s)(' .implode(\"|\",array_keys(self::$replaceEmoji)) . ')(\\s|$)/', function($match) {\n                $char = str_replace(array('/','(',')','*'),array('\\/','\\(','\\)','\\*'),$match[2]);\n                return $match[1] . erLhcoreClassBBCodePlain::$replaceEmoji[$char] . $match[3];\n            },  $text);\n        }\n\n        return $text;\n    }\n\n    public static function BBCode2Html($text) {\n        $text = trim($text);\n\n        $text = self::parseEmoji($text);\n\n        // Smileys to find...\n        $in = array(\n        );\n\n        // And replace them by...\n        $out = array(\n        );\n\n        $in[] = '[/*]';\n        $in[] = '[*]';\n        $out[] = '</li>';\n        $out[] = '<li>';\n\n        $text = str_replace($in, $out, $text);\n\n        // BBCode to find...\n        $in = array( \t '/\\[b\\](.*?)\\[\\/b\\]/ms',\n            '/\\[i\\](.*?)\\[\\/i\\]/ms',\n            '/\\[u\\](.*?)\\[\\/u\\]/ms',\n            '/\\[mark\\](.*?)\\[\\/mark\\]/ms',\n            '/\\[s\\](.*?)\\[\\/s\\]/ms',\n            '/\\[list\\=(.*?)\\](.*?)\\[\\/list\\]/ms',\n            '/\\[list\\](.*?)\\[\\/list\\]/ms',\n            '/\\[\\*\\]\\s?(.*?)\\n/ms',\n            '/\\[fs(.*?)\\](.*?)\\[\\/fs(.*?)\\]/ms',\n            '/\\[color\\=(.*?)\\](.*?)\\[\\/color\\]/ms'\n        );\n\n        // And replace them by...\n        $out = array(\t '\\1',\n            '\\1',\n            '\\1',\n            '\\1',\n            '\\1',\n            '\\2',\n            '\\1',\n            '\\1',\n            '\\2',\n            '\\2'\n        );\n\n        $text = preg_replace($in, $out, $text);\n\n        // Prepare quote's\n        $text = str_replace(\"\\r\\n\",\"\\n\",$text);\n\n        // paragraphs\n        $text = str_replace(\"\\r\", \"\", $text);\n\n        return $text;\n    }\n\n    public static function _make_url_embed_image($matches) {\n\n        $in = htmlspecialchars_decode($matches[2]);\n        $in = trim($in);\n\n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return $matches[2];\n\n        $prepend = '';\n\n        if (isset($matches[1]) && $matches[1] != '' && !empty(self::esc_url($matches[1]))) {\n            $prepend = $matches[1];\n        }\n\n        return  $prepend . ' ' . $url;\n    }\n\n    public static function _make_embed_map($matches)\n    {\n        $parts = explode(',',trim($matches[1]));\n\n        if (count($parts) == 2 && is_numeric($parts[0]) && is_numeric($parts[1])) {\n            $id = rand(0,1000) . time();\n            return \"<div id='msg-location-\".$id.\"' style='height:300px'><script>lhinst.showMessageLocation(\" . $id . \",\" . (float)$parts[0] . \",\" . (float)$parts[1] . \")</script></div>\";\n        }\n\n        return ;\n    }\n\n    public static function _make_url_embed($matches){\n\n        $in = str_replace('\"','',htmlspecialchars_decode($matches[1]));\n        $in = trim($in);\n\n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return $matches[1] . ' ' . $matches[2];\n\n        return $url .' '. $matches[2];\n    }\n\n    /**\n     * Callback to convert URL match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with URL address.\n     */\n    public static function _make_web_ftp_clickable_cb( $matches ) {\n        $ret = '';\n        $dest = $matches[2];\n        $dest = 'http://' . $dest;\n        // removed trailing [.,;:)] from URL\n        if ( in_array( substr($dest, -1), array('.', ',', ';', ':', ')') ) === true ) {\n            $ret = substr($dest, -1);\n            $dest = substr($dest, 0, strlen($dest)-1);\n        }\n        $dest = self::esc_url($dest);\n        if ( empty($dest) )\n            return $matches[0];\n\n        return $matches[1] . $dest . ' ' . $ret;\n    }\n\n    /**\n     * Callback to convert email address match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with email address.\n     */\n    public static function _make_email_clickable_cb( $matches ) {\n        $email = $matches[2] . '@' . $matches[3];\n        return $matches[1] . ' ' . $email;\n    }\n\n\n    public static function _make_paypal_button($matches){\n\n        if (filter_var($matches[1],FILTER_VALIDATE_EMAIL)) {\n            return '<form action=\"https://www.paypal.com/cgi-bin/webscr\" method=\"post\">\n            <input type=\"hidden\" name=\"cmd\" value=\"_donations\">\n            <input type=\"hidden\" name=\"business\" value=\"'.$matches[1].'\">\n            <input type=\"hidden\" name=\"lc\" value=\"US\">\n            <input type=\"hidden\" name=\"no_note\" value=\"0\">\n            <input type=\"hidden\" name=\"currency_code\" value=\"USD\">\n            <input type=\"hidden\" name=\"bn\" value=\"PP-DonationsBF:btn_donate_SM.gif:NonHostedGuest\">\n            <input type=\"image\" title=\"Support an artist\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/btn/btn_donate_SM.gif\" border=\"0\" name=\"submit\" alt=\"PayPal - The safer, easier way to pay online!\">\n            <img alt=\"\" border=\"0\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/scr/pixel.gif\" width=\"1\" height=\"1\">\n            </form>';\n        } else {\n            return $matches[0];\n        }\n    }\n\n    public static function _make_youtube_block($matches) {\n\n        $data = parse_url($matches[1]);\n\n        if (isset($data['query'])){\n            parse_str($data['query'],$query);\n            if (stristr($data['host'],'youtube.com') && isset($query['v']) && ($query['v'] != '')) {\n                return '<iframe class=\"youtube-frame\" title=\"YouTube video player\" width=\"480\" height=\"300\" src=\"https://www.youtube.com/embed/'.urlencode($query['v']).'\" frameborder=\"0\" allowfullscreen></iframe>';\n            } else {\n                return $matches[0];\n            }\n        } else {\n            return $matches[0];\n        }\n    }\n\n    public static function _make_url_file($matches)\n    {\n\n        if (isset($matches[1])){\n            $mainData = explode(' ',$matches[1]);\n            $parts = explode('_',$mainData[0]);\n            $fileID = $parts[0];\n            $hash = $parts[1];\n            $displayType = isset($parts[2]) ? $parts[2] : null;\n            try {\n                $file = erLhcoreClassModelChatFile::fetch($fileID);\n\n                if (is_object($file)) {\n                    // Check that user has permission to see the chat. Let say if user purposely types file bbcode\n                    if ($hash == $file->security_hash) {\n                        $fileExtension = strtolower($file->extension);\n                        if ($fileExtension == 'jpg' || $fileExtension == 'jpeg' || $fileExtension == 'png' || $fileExtension == 'gif'){\n\n                            // Make link if required\n                            $prepend = '';\n                            $append = '';\n                            if (isset($mainData[1])) {\n                                $subpartParts = explode('=',$mainData[1]);\n                                if ($subpartParts[0] == 'link') {\n                                    $url = self::esc_url($subpartParts[1]);\n                                    if ($url != ''){\n                                        $prepend = self::esc_url($subpartParts[1]);\n                                        $append = '';\n                                    }\n                                }\n                            } else {\n                                $prepend = '';\n                                $append = (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . '//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\";\n                            }\n\n                            return $prepend . $append;\n                        }\n\n                        if ($fileExtension == 'mp3' || $fileExtension == 'wav' || $fileExtension == 'ogg') {\n                            return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . '//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\";\n                        }\n\n                        return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . \"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash} {$file->upload_name}\" . ' [' . $file->extension . ']';\n                    }\n                }\n\n            } catch (Exception $e) {\n\n            }\n\n            return '';\n        }\n        return '';\n    }\n\n    public static function _make_url_survey($matches)\n    {\n        if (isset($matches[1])){\n\n            list($surveyId, $surveyItemId) = explode('_',str_replace(array('\"','&quot;'),'', $matches[1]));\n\n            try {\n\n                if (is_numeric($surveyItemId) && is_numeric($surveyId)) {\n\n                    $surveyItem = erLhAbstractModelSurveyItem::fetch($surveyItemId);\n\n                    if ($surveyId == $surveyItem->survey_id)\n                    {\n                        $survey = erLhAbstractModelSurvey::fetch($surveyId);\n                        return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . \"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('survey/collected').\"/{$survey->id}?show={$surveyItem->id}\" . erTranslationClassLhTranslation::getInstance()->getTranslation('file/file','Collected survey data') . ' - ' . htmlspecialchars($survey->name);\n                    }\n                }\n\n            } catch (Exception $e) {\n\n            }\n\n            return '';\n        }\n        return '';\n    }\n\n    public static function _make_url_mail_file($matches){\n\n        if (isset($matches[1])){\n            list($fileID,$hash) = explode('_',$matches[1]);\n            try {\n                $file = erLhcoreClassModelChatFile::fetch($fileID);\n\n                // Check that user has permission to see the chat. Let say if user purposely types file bbcode\n                if ($hash == $file->security_hash) {\n                    return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . '//' . $_SERVER['HTTP_HOST'].erLhcoreClassDesign::baseurldirect('file/downloadfile').\"/{$file->id}/{$hash}\";\n                }\n            } catch (Exception $e) {\n\n            }\n\n            return '';\n        }\n        return '';\n    }\n\n    public static function _split_str_by_whitespace( $string, $goal ) {\n        $chunks = array();\n\n        $string_nullspace = strtr( $string, \"\\r\\n\\t\\v\\f \", \"\\000\\000\\000\\000\\000\\000\" );\n\n        while ( $goal < strlen( $string_nullspace ) ) {\n            $pos = strrpos( substr( $string_nullspace, 0, $goal + 1 ), \"\\000\" );\n\n            if ( false === $pos ) {\n                $pos = strpos( $string_nullspace, \"\\000\", $goal + 1 );\n                if ( false === $pos ) {\n                    break;\n                }\n            }\n\n            $chunks[] = substr( $string, 0, $pos + 1 );\n            $string = substr( $string, $pos + 1 );\n            $string_nullspace = substr( $string_nullspace, $pos + 1 );\n        }\n\n        if ( $string ) {\n            $chunks[] = $string;\n        }\n\n        return $chunks;\n    }\n\n    // https://github.com/WordPress/WordPress/blob/6e5e29c5bf49ad2be6a2c3a3d4fb3f5af6853b5b/wp-includes/formatting.php\n    public static function make_clickable_text( $text ) {\n        $r = '';\n        $textarr = preg_split( '/(<[^<>]+>)/', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // split out HTML tags\n        $nested_code_pre = 0; // Keep track of how many levels link is nested inside <pre> or <code>\n        foreach ( $textarr as $piece ) {\n            if ( preg_match( '|^<code[\\s>]|i', $piece ) || preg_match( '|^<pre[\\s>]|i', $piece ) || preg_match( '|^<script[\\s>]|i', $piece ) || preg_match( '|^<style[\\s>]|i', $piece ) )\n                $nested_code_pre++;\n            elseif ( $nested_code_pre && ( '</code>' === strtolower( $piece ) || '</pre>' === strtolower( $piece ) || '</script>' === strtolower( $piece ) || '</style>' === strtolower( $piece ) ) )\n                $nested_code_pre--;\n            if ( $nested_code_pre || empty( $piece ) || ( $piece[0] === '<' && ! preg_match( '|^<\\s*[\\w]{1,20}+://|', $piece ) ) ) {\n                $r .= $piece;\n                continue;\n            }\n            // Long strings might contain expensive edge cases ...\n            if ( 10000 < strlen( $piece ) ) {\n                // ... break it up\n                foreach ( self::_split_str_by_whitespace( $piece, 2100 ) as $chunk ) { // 2100: Extra room for scheme and leading and trailing paretheses\n                    if ( 2101 < strlen( $chunk ) ) {\n                        $r .= $chunk; // Too big, no whitespace: bail.\n                    } else {\n                        $r .= self::make_clickable_text( $chunk );\n                    }\n                }\n            } else {\n                $ret = \" $piece \"; // Pad with whitespace to simplify the regexes\n                $url_clickable = '~\n\t\t\t\t([\\\\s(<.,;:!?])                                        # 1: Leading whitespace, or punctuation\n\t\t\t\t(                                                      # 2: URL\n\t\t\t\t\t[\\\\w]{1,20}+://                                # Scheme and hier-part prefix\n\t\t\t\t\t(?=\\S{1,2000}\\s)                               # Limit to URLs less than about 2000 characters long\n\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]*+         # Non-punctuation URL character\n\t\t\t\t\t(?:                                            # Unroll the Loop: Only allow puctuation URL character if followed by a non-punctuation URL character\n\t\t\t\t\t\t[\\'.,;:!?)]                            # Punctuation URL character\n\t\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]++ # Non-punctuation URL character\n\t\t\t\t\t)*\n\t\t\t\t)\n\t\t\t\t(\\)?)                                                  # 3: Trailing closing parenthesis (for parethesis balancing post processing)\n\t\t\t~xS'; // The regex is a non-anchored pattern and does not have a single fixed starting character.\n                // Tell PCRE to spend more time optimizing since, when used on a page load, it will probably be used several times.\n                $ret = preg_replace_callback( $url_clickable, 'erLhcoreClassBBCodePlain::_make_url_clickable_cb', $ret );\n                $ret = preg_replace_callback( '#([\\s>])((www|ftp)\\.[\\w\\\\x80-\\\\xff\\#$%&~/.\\-;:=,?@\\[\\]+]+)#is', 'erLhcoreClassBBCodePlain::_make_web_ftp_clickable_cb', $ret );\n                $ret = preg_replace_callback( '#([\\s>])([.0-9a-z_+-]+)@(([0-9a-z-]+\\.)+[0-9a-z]{2,})#i', 'erLhcoreClassBBCodePlain::_make_email_clickable_cb', $ret );\n                $ret = substr( $ret, 1, -1 ); // Remove our whitespace padding.\n                $r .= $ret;\n            }\n        }\n\n        // Cleanup of accidental links within links\n        return preg_replace( '#(<a([ \\r\\n\\t]+[^>]+?>|>))<a [^>]+?>([^>]+?)</a></a>#i', \"$1$3</a>\", $r );\n    }\n\n    public static function makeQuote($matches)\n    {\n        if ($matches[1]) {\n            return '<blockquote class=\"blockquote\"> ' . $matches[1] . ' </blockquote>';\n        } else {\n            return $matches[0];\n        }\n    }\n\n    public static function extractMetaByMessage(& $msg) {\n        $meta = array();\n        if (strpos($msg,'[html_snippet]') !== false) {\n            $matches = array();\n            preg_match_all('/\\[html_snippet\\](.*?)\\[\\/html_snippet\\]/is',$msg,$matches);\n            foreach ($matches[0] as $index => $match) {\n                $msg = str_replace($match,'',$msg);\n                $meta['html_snippet'][] = $matches[1][$index];\n            }\n        }\n        return $meta;\n    }\n\n    // Converts bbcode and general links to hmtl code\n    public static function make_clickable($ret, $paramsMessage = array()) {\n        $ret = ' ' . $ret;\n\n        $makeLinksClickable = true;\n\n        $ret = preg_replace_callback('/\\[img=?(.*?)\\](.*?)\\[\\/img\\]/ms', \"erLhcoreClassBBCodePlain::_make_url_embed_image\", $ret);\n\n        $ret = preg_replace_callback('/\\[loc\\](.*?)\\[\\/loc\\]/ms', \"erLhcoreClassBBCodePlain::_make_embed_map\", $ret);\n\n        $ret = preg_replace_callback('/\\[url\\=\"?(.*?)\"?\\](.*?)\\[\\/url\\]/ms', \"erLhcoreClassBBCodePlain::_make_url_embed\", $ret);\n\n        if (isset($paramsMessage['sender']) && $paramsMessage['sender'] == 0) {\n            $ret = preg_replace('/\\[html\\](.*?)\\[\\/html\\]/ms','',$ret);\n        }\n\n        $ret = preg_replace_callback('/\\[html\\](.*?)\\[\\/html\\]/ms', function ($matches) {\n            $html = htmlspecialchars_decode($matches[1]);\n\n            $html = preg_replace_callback('/\"window\\.parent\\.(.*)\"/ms',function ($matches){\n                return \"'lhinst.executeRemoteCommands([\\\"lhc_eval:\" . $matches[1] . \"\\\"])'\";\n            },$html);\n\n            return $html;\n\n        }, $ret);\n\n\n        if ($makeLinksClickable) {\n            $ret = self::make_clickable_text($ret);\n        }\n\n        $ret = self::BBCode2Html($ret);\n\n        // Paypal button\n        $ret = preg_replace_callback('#\\[paypal\\](.*?)\\[/paypal\\]#is', 'erLhcoreClassBBCodePlain::_make_paypal_button', $ret);\n\n        // Quote\n        $ret = preg_replace_callback('#\\[quote\\](.*?)\\[/quote\\]#is', 'erLhcoreClassBBCodePlain::makeQuote', $ret);\n\n        // Youtube block\n        $ret = preg_replace_callback('#\\[youtube\\](.*?)\\[/youtube\\]#is', 'erLhcoreClassBBCodePlain::_make_youtube_block', $ret);\n\n        $ret = preg_replace('#\\[translation\\](.*?)\\[/translation\\]#is', '<span class=\"tr-msg\">$1</span>', $ret);\n\n        // File block\n        $ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCodePlain::_make_url_file', $ret);\n\n        // Survey\n        $ret = preg_replace_callback('#\\[survey=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCodePlain::_make_url_survey', $ret);\n\n        $ret = trim($ret);\n\n        return $ret;\n    }\n\n    public static function parseForMail($ret){\n        // File block\n        $ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCodePlain::_make_url_mail_file', $ret);\n        return trim($ret);\n    }\n\n}\n\n\n?>"], "fixing_code": ["<?php\n\n/**\n * This code is mix of WP and phpBB :)\n * */\nclass erLhcoreClassBBCode\n{    \n   /**\n    * Callback to convert URI match to HTML A element.\n    *\n    * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n    *\n    * @since 2.3.2\n    * @access private\n    *\n    * @param array $matches Single Regex Match.\n    * @return string HTML A element with URI address.\n    */\n   public static function _make_url_clickable_cb( $matches ) {\n       $url = $matches[2];\n       if ( ')' == $matches[3] && strpos( $url, '(' ) ) {\n           // If the trailing character is a closing parethesis, and the URL has an opening parenthesis in it, add the closing parenthesis to the URL.\n           // Then we can let the parenthesis balancer do its thing below.\n           $url .= $matches[3];\n           $suffix = '';\n       } else {\n           $suffix = $matches[3];\n       }\n       // Include parentheses in the URL only if paired\n       while ( substr_count( $url, '(' ) < substr_count( $url, ')' ) ) {\n           $suffix = strrchr( $url, ')' ) . $suffix;\n           $url = substr( $url, 0, strrpos( $url, ')' ) );\n       }\n       $url = self::esc_url($url);\n       if ( empty($url) )\n           return $matches[0];\n       return $matches[1] . \"<a href=\\\"$url\\\" class=\\\"link\\\" rel=\\\"noreferrer\\\" target=\\\"_blank\\\">$url</a>\" . $suffix;\n   }\n   \n   /**\n    * Checks and cleans a URL.\n    *\n    * A number of characters are removed from the URL. If the URL is for displaying\n    * (the default behaviour) ampersands are also replaced. The {@see 'clean_url'} filter\n    * is applied to the returned cleaned URL.\n    *\n    * @since 2.8.0\n    *\n    * @param string $url       The URL to be cleaned.\n    * @param array  $protocols Optional. An array of acceptable protocols.\n    *\t\t                    Defaults to return value of wp_allowed_protocols()\n    * @param string $_context  Private. Use esc_url_raw() for database usage.\n    * @return string The cleaned $url after the {@see 'clean_url'} filter is applied.\n    */\n   public static function esc_url( $url, $protocols = null, $_context = 'display' ) {\n       $original_url = $url;\n       if ( '' == $url )\n           return $url;\n       $url = str_replace( ' ', '%20', $url );\n       $url = preg_replace('|[^a-z0-9-~+_.?#=!&;,/:%@$\\|*\\'()\\[\\]\\\\x80-\\\\xff]|i', '', $url);\n       if ( '' === $url ) {\n           return $url;\n       }\n       if ( 0 !== stripos( $url, 'mailto:' ) ) {\n           $strip = array('%0d', '%0a', '%0D', '%0A');\n           $url = self::_deep_replace($strip, $url);\n       }\n       $url = str_replace(';//', '://', $url);\n       /* If the URL doesn't appear to contain a scheme, we\n        * presume it needs http:// prepended (unless a relative\n        * link starting with /, # or ? or a php file).\n       */\n       if ( strpos($url, ':') === false && ! in_array( $url[0], array( '/', '#', '?' ) ) &&\n           ! preg_match('/^[a-z0-9-]+?\\.php/i', $url) )\n               $url = 'http://' . $url;\n           // Replace ampersands and single quotes only when displaying.\n           if ( 'display' == $_context ) {\n               $url = self::wp_kses_normalize_entities( $url );\n               $url = str_replace( '&amp;', '&#038;', $url );\n               $url = str_replace( \"'\", '&#039;', $url );\n           }\n           if ( ( false !== strpos( $url, '[' ) ) || ( false !== strpos( $url, ']' ) ) ) {\n               $parsed = self::wp_parse_url( $url );\n               $front  = '';\n               if ( isset( $parsed['scheme'] ) ) {\n                   $front .= $parsed['scheme'] . '://';\n               } elseif ( '/' === $url[0] ) {\n                   $front .= '//';\n               }\n               if ( isset( $parsed['user'] ) ) {\n                   $front .= $parsed['user'];\n               }\n               if ( isset( $parsed['pass'] ) ) {\n                   $front .= ':' . $parsed['pass'];\n               }\n               if ( isset( $parsed['user'] ) || isset( $parsed['pass'] ) ) {\n                   $front .= '@';\n               }\n               if ( isset( $parsed['host'] ) ) {\n                   $front .= $parsed['host'];\n               }\n               if ( isset( $parsed['port'] ) ) {\n                   $front .= ':' . $parsed['port'];\n               }\n               $end_dirty = str_replace( $front, '', $url );\n               $end_clean = str_replace( array( '[', ']' ), array( '%5B', '%5D' ), $end_dirty );\n               $url       = str_replace( $end_dirty, $end_clean, $url );\n           }\n           if ( '/' === $url[0] ) {\n               $good_protocol_url = $url;\n           } else {\n               if ( ! is_array( $protocols ) )\n                   $protocols = $protocols = array( 'http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet', 'mms', 'rtsp', 'svn', 'tel', 'fax', 'xmpp', 'webcal', 'urn' );\n               \n               $good_protocol_url = self::wp_kses_bad_protocol( $url, $protocols );\n               if ( strtolower( $good_protocol_url ) != strtolower( $url ) )\n                   return '';\n           }\n\n           /**\n            * Filters a string cleaned and escaped for output as a URL.\n            *\n            * @since 2.3.0\n            *\n            * @param string $good_protocol_url The cleaned URL to be returned.\n            * @param string $original_url      The URL prior to cleaning.\n            * @param string $_context          If 'display', replace ampersands and single quotes only.\n            */\n           return $url;           \n           //self::esc_url( $good_protocol_url, $original_url, $_context ); //apply_filters( 'erLhcoreClassBBCode::clean_url', $good_protocol_url, $original_url, $_context );\n   }\n   \n   /**\n    * A wrapper for PHP's parse_url() function that handles consistency in the return\n    * values across PHP versions.\n    *\n    * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n    * schemeless and relative url's with :// in the path. This function works around\n    * those limitations providing a standard output on PHP 5.2~5.4+.\n    *\n    * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n    * in the query are being handled inconsistently. This function works around those\n    * differences as well.\n    *\n    * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n    * when URL parsing failed.\n    *\n    * @since 4.4.0\n    * @since 4.7.0 The $component parameter was added for parity with PHP's parse_url().\n    *\n    * @param string $url       The URL to parse.\n    * @param int    $component The specific component to retrieve. Use one of the PHP\n    *                          predefined constants to specify which one.\n    *                          Defaults to -1 (= return all parts as an array).\n    *                          @see http://php.net/manual/en/function.parse-url.php\n    * @return mixed False on parse failure; Array of URL components on success;\n    *               When a specific component has been requested: null if the component\n    *               doesn't exist in the given URL; a string or - in the case of\n    *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n    */\n   public static function wp_parse_url( $url, $component = -1 ) {\n       $to_unset = array();\n       $url = strval( $url );\n       if ( '//' === substr( $url, 0, 2 ) ) {\n           $to_unset[] = 'scheme';\n           $url = 'placeholder:' . $url;\n       } elseif ( '/' === substr( $url, 0, 1 ) ) {\n           $to_unset[] = 'scheme';\n           $to_unset[] = 'host';\n           $url = 'placeholder://placeholder' . $url;\n       }\n       $parts = @parse_url( $url );\n       if ( false === $parts ) {\n           // Parsing failure.\n           return $parts;\n       }\n       // Remove the placeholder values.\n       foreach ( $to_unset as $key ) {\n           unset( $parts[ $key ] );\n       }\n       return self::_get_component_from_parsed_url_array( $parts, $component );\n   }\n   \n   /**\n    * Retrieve a specific component from a parsed URL array.\n    *\n    * @internal\n    *\n    * @since 4.7.0\n    *\n    * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n    * @param int    $component The specific component to retrieve. Use one of the PHP\n    *                          predefined constants to specify which one.\n    *                          Defaults to -1 (= return all parts as an array).\n    *                          @see http://php.net/manual/en/function.parse-url.php\n    * @return mixed False on parse failure; Array of URL components on success;\n    *               When a specific component has been requested: null if the component\n    *               doesn't exist in the given URL; a string or - in the case of\n    *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n    */\n   public static function _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n       if ( -1 === $component ) {\n           return $url_parts;\n       }\n       $key = self::_wp_translate_php_url_constant_to_key( $component );\n       if ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n           return $url_parts[ $key ];\n       } else {\n           return null;\n       }\n   }\n   \n   /**\n    * Translate a PHP_URL_* constant to the named array keys PHP uses.\n    *\n    * @internal\n    *\n    * @since 4.7.0\n    *\n    * @see   http://php.net/manual/en/url.constants.php\n    *\n    * @param int $constant PHP_URL_* constant.\n    * @return string|bool The named key or false.\n    */\n   public static function _wp_translate_php_url_constant_to_key( $constant ) {\n       $translation = array(\n           PHP_URL_SCHEME   => 'scheme',\n           PHP_URL_HOST     => 'host',\n           PHP_URL_PORT     => 'port',\n           PHP_URL_USER     => 'user',\n           PHP_URL_PASS     => 'pass',\n           PHP_URL_PATH     => 'path',\n           PHP_URL_QUERY    => 'query',\n           PHP_URL_FRAGMENT => 'fragment',\n       );\n       if ( isset( $translation[ $constant ] ) ) {\n           return $translation[ $constant ];\n       } else {\n           return false;\n       }\n   }\n   \n   \n   /**\n    * Converts and fixes HTML entities.\n    *\n    * This function normalizes HTML entities. It will convert `AT&T` to the correct\n    * `AT&amp;T`, `&#00058;` to `&#58;`, `&#XYZZY;` to `&amp;#XYZZY;` and so on.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string Content to normalize entities\n    * @return string Content with normalized entities\n    */\n   public static function wp_kses_normalize_entities($string) {\n       // Disarm all entities by converting & to &amp;\n       $string = str_replace('&', '&amp;', $string);\n       // Change back the allowed entities in our entity whitelist\n       $string = preg_replace_callback('/&amp;([A-Za-z]{2,8}[0-9]{0,2});/', 'erLhcoreClassBBCode::wp_kses_named_entities', $string);\n       $string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'erLhcoreClassBBCode::wp_kses_normalize_entities2', $string);\n       $string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'erLhcoreClassBBCode::wp_kses_normalize_entities3', $string);\n       return $string;\n   }\n   \n   /**\n    * Callback for wp_kses_normalize_entities() for regular expression.\n    *\n    * This function helps wp_kses_normalize_entities() to only accept valid Unicode\n    * numeric entities in hex form.\n    *\n    * @since 2.7.0\n    * @access private\n    *\n    * @param array $matches preg_replace_callback() matches array\n    * @return string Correctly encoded entity\n    */\n   public static function wp_kses_normalize_entities3($matches) {\n       if ( empty($matches[1]) )\n           return '';\n       $hexchars = $matches[1];\n       return ( ! self::valid_unicode( hexdec( $hexchars ) ) ) ? \"&amp;#x$hexchars;\" : '&#x'.ltrim($hexchars,'0').';';\n   }\n   \n   /**\n    * Helper function to determine if a Unicode value is valid.\n    *\n    * @since 2.7.0\n    *\n    * @param int $i Unicode value\n    * @return bool True if the value was a valid Unicode number\n    */\n   public static function valid_unicode($i) {\n       return ( $i == 0x9 || $i == 0xa || $i == 0xd ||\n           ($i >= 0x20 && $i <= 0xd7ff) ||\n           ($i >= 0xe000 && $i <= 0xfffd) ||\n           ($i >= 0x10000 && $i <= 0x10ffff) );\n   }\n   \n   /**\n    * Callback for wp_kses_normalize_entities() regular expression.\n    *\n    * This function helps wp_kses_normalize_entities() to only accept 16-bit\n    * values and nothing more for `&#number;` entities.\n    *\n    * @access private\n    * @since 1.0.0\n    *\n    * @param array $matches preg_replace_callback() matches array\n    * @return string Correctly encoded entity\n    */\n   public static function wp_kses_normalize_entities2($matches) {\n       if ( empty($matches[1]) )\n           return '';\n       $i = $matches[1];\n       if (self::valid_unicode($i)) {\n           $i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);\n           $i = \"&#$i;\";\n       } else {\n           $i = \"&amp;#$i;\";\n       }\n       return $i;\n   }\n   \n   /**\n    * Callback for wp_kses_normalize_entities() regular expression.\n    *\n    * This function only accepts valid named entity references, which are finite,\n    * case-sensitive, and highly scrutinized by HTML and XML validators.\n    *\n    * @since 3.0.0\n    *\n    * @global array $allowedentitynames\n    *\n    * @param array $matches preg_replace_callback() matches array\n    * @return string Correctly encoded entity\n    */\n   public static function wp_kses_named_entities($matches) {       \n       $allowedentitynames = array(\n           'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',\n           'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',\n           'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',\n           'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',\n           'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',\n           'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',\n           'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',\n           'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',\n           'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',\n           'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',\n           'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',\n           'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',\n           'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',\n           'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',\n           'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',\n           'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',\n           'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',\n           'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',\n           'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',\n           'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',\n           'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',\n           'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',\n           'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',\n           'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',\n           'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',\n           'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',\n           'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',\n           'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',\n           'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',\n           'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',\n           'oline',   'frasl',  'weierp',  'image',  'real',   'trade',\n           'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',\n           'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',\n           'forall',  'part',   'exist',   'empty',  'nabla',  'isin',\n           'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',\n           'radic',   'prop',   'infin',   'ang',    'and',    'or',\n           'cap',     'cup',    'int',     'sim',    'cong',   'asymp',\n           'ne',      'equiv',  'le',      'ge',     'sub',    'sup',\n           'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',\n           'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',\n           'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',\n           'sup1',    'sup2',   'sup3',    'frac14', 'frac12', 'frac34',\n           'there4',\n       );\n       \n       if ( empty($matches[1]) )\n           return '';\n       $i = $matches[1];\n       return ( ! in_array( $i, $allowedentitynames ) ) ? \"&amp;$i;\" : \"&$i;\";\n   }\n   \n   /**\n    * Sanitize string from bad protocols.\n    *\n    * This function removes all non-allowed protocols from the beginning of\n    * $string. It ignores whitespace and the case of the letters, and it does\n    * understand HTML entities. It does its work in a while loop, so it won't be\n    * fooled by a string like \"javascript:javascript:alert(57)\".\n    *\n    * @since 1.0.0\n    *\n    * @param string $string            Content to filter bad protocols from\n    * @param array  $allowed_protocols Allowed protocols to keep\n    * @return string Filtered content\n    */\n   public static function wp_kses_bad_protocol($string, $allowed_protocols) {\n       $string = self::wp_kses_no_null($string);\n       $iterations = 0;\n       do {\n           $original_string = $string;\n           $string = self::wp_kses_bad_protocol_once($string, $allowed_protocols);\n       } while ( $original_string != $string && ++$iterations < 6 );\n       if ( $original_string != $string )\n           return '';\n       return $string;\n   }\n   \n   /**\n    * Removes any invalid control characters in $string.\n    *\n    * Also removes any instance of the '\\0' string.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string\n    * @param array $options Set 'slash_zero' => 'keep' when '\\0' is allowed. Default is 'remove'.\n    * @return string\n    */\n   public static function wp_kses_no_null( $string, $options = null ) {\n       if ( ! isset( $options['slash_zero'] ) ) {\n           $options = array( 'slash_zero' => 'remove' );\n       }\n       $string = preg_replace( '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $string );\n       if ( 'remove' == $options['slash_zero'] ) {\n           $string = preg_replace( '/\\\\\\\\+0+/', '', $string );\n       }\n       return $string;\n   }\n   \n   /**\n    * Sanitizes content from bad protocols and other characters.\n    *\n    * This function searches for URL protocols at the beginning of $string, while\n    * handling whitespace and HTML entities.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string            Content to check for bad protocols\n    * @param string $allowed_protocols Allowed protocols\n    * @return string Sanitized content\n    */\n   public static function wp_kses_bad_protocol_once($string, $allowed_protocols, $count = 1 ) {\n       $string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\n       if ( isset($string2[1]) && ! preg_match('%/\\?%', $string2[0]) ) {\n           $string = trim( $string2[1] );\n           $protocol = self::wp_kses_bad_protocol_once2( $string2[0], $allowed_protocols );\n           if ( 'feed:' == $protocol ) {\n               if ( $count > 2 )\n                   return '';\n               $string = self::wp_kses_bad_protocol_once( $string, $allowed_protocols, ++$count );\n               if ( empty( $string ) )\n                   return $string;\n           }\n           $string = $protocol . $string;\n       }\n       return $string;\n   }\n   \n   \n   /**\n    * Callback for wp_kses_bad_protocol_once() regular expression.\n    *\n    * This function processes URL protocols, checks to see if they're in the\n    * whitelist or not, and returns different data depending on the answer.\n    *\n    * @access private\n    * @since 1.0.0\n    *\n    * @param string $string            URI scheme to check against the whitelist\n    * @param string $allowed_protocols Allowed protocols\n    * @return string Sanitized content\n    */\n   public static function wp_kses_bad_protocol_once2( $string, $allowed_protocols ) {\n       $string2 = self::wp_kses_decode_entities($string);\n       $string2 = preg_replace('/\\s/', '', $string2);\n       $string2 = self::wp_kses_no_null($string2);\n       $string2 = strtolower($string2);\n       $allowed = false;\n       foreach ( (array) $allowed_protocols as $one_protocol )\n           if ( strtolower($one_protocol) == $string2 ) {\n               $allowed = true;\n               break;\n           }\n       if ($allowed)\n           return \"$string2:\";\n       else\n           return '';\n   }\n   \n   /**\n    * Convert all entities to their character counterparts.\n    *\n    * This function decodes numeric HTML entities (`&#65;` and `&#x41;`).\n    * It doesn't do anything with other entities like &auml;, but we don't\n    * need them in the URL protocol whitelisting system anyway.\n    *\n    * @since 1.0.0\n    *\n    * @param string $string Content to change entities\n    * @return string Content after decoded entities\n    */\n   public static function wp_kses_decode_entities($string) {\n       $string = preg_replace_callback('/&#([0-9]+);/', 'erLhcoreClassBBCode::_wp_kses_decode_entities_chr', $string);\n       $string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', 'erLhcoreClassBBCode::_wp_kses_decode_entities_chr_hexdec', $string);\n       return $string;\n   }\n   \n   /**\n    * Regex callback for wp_kses_decode_entities()\n    *\n    * @since 2.9.0\n    *\n    * @param array $match preg match\n    * @return string\n    */\n   public static function _wp_kses_decode_entities_chr( $match ) {\n       return chr( $match[1] );\n   }\n   /**\n    * Regex callback for wp_kses_decode_entities()\n    *\n    * @since 2.9.0\n    *\n    * @param array $match preg match\n    * @return string\n    */\n   public static function _wp_kses_decode_entities_chr_hexdec( $match ) {\n       return chr( hexdec( $match[1] ) );\n   }\n   \n\n   /**\n    * Perform a deep string replace operation to ensure the values in $search are no longer present\n    *\n    * Repeats the replacement operation until it no longer replaces anything so as to remove \"nested\" values\n    * e.g. $subject = '%0%0%0DDD', $search ='%0D', $result ='' rather than the '%0%0DD' that\n    * str_replace would return\n    *\n    * @since 2.8.1\n    * @access private\n    *\n    * @param string|array $search  The value being searched for, otherwise known as the needle.\n    *                              An array may be used to designate multiple needles.\n    * @param string       $subject The string being searched and replaced on, otherwise known as the haystack.\n    * @return string The string with the replaced svalues.\n    */\n   public static function _deep_replace( $search, $subject ) {\n       $subject = (string) $subject;\n       $count = 1;\n       while ( $count ) {\n           $subject = str_replace( $search, '', $subject, $count );\n       }\n       return $subject;\n   }\n\n   public static $replaceEmoji = array(\n       ':\\)' => \"\\u{1F642}\",\n       ':D:' => \"\\u{1F600}\",\n       ':D' => \"\\u{1F600}\",\n       ':\\(' => \"\\u{1F641}\",\n       ':o:' => \"\\u{1F62E}\",\n       ':o' => \"\\u{1F62E}\",\n       ':p:' => \"\\u{1F61B}\",\n       ':p' => \"\\u{1F61B}\",\n       ';\\)' => \"\\u{1F609}\",\n       ';\\(' => \"\\u{1F622}\",\n       ':x' => \"\\u{1F910}\",\n       ':\\*' => \"\\u{1F617}\",\n       ';\\*' => \"\\u{1F618}\",\n       ':\\/' => \"\\u{1F615}\"\n   );\n\n   public static function parseEmoji($text) {\n\n       // Smileys to find...\n       for ($i = 0; $i < 2; $i++) {\n           $text = preg_replace_callback('/(^|\\s)(' .implode(\"|\",array_keys(self::$replaceEmoji)) . ')(\\s|$)/', function($match) {\n               $char = str_replace(array('/','(',')','*'),array('\\/','\\(','\\)','\\*'),$match[2]);\n               return $match[1] . erLhcoreClassBBCode::$replaceEmoji[$char] . $match[3];\n           },  $text);\n       }\n\n       return $text;\n   }\n\n   public static function BBCode2Html($text) {\n    \t$text = trim($text);\n\n       $text = self::parseEmoji($text);\n\n       // Smileys to find...\n       $in = array(\n       );\n\n       // And replace them by...\n       $out = array(\n       );\n    \t\n    \t$in[] = '[/*]';\n    \t$in[] = '[*]';\n    \t$out[] = '</li>';\n    \t$out[] = '<li>';\n    \t    \t\n    \t$text = str_replace($in, $out, $text);\n\n    \t// BBCode to find...\n    \t$in = array( \t '/\\[b\\](.*?)\\[\\/b\\]/ms',\n    \t\t\t\t\t '/\\[i\\](.*?)\\[\\/i\\]/ms',\n    \t\t\t\t\t '/\\[u\\](.*?)\\[\\/u\\]/ms',\n    \t\t\t\t\t '/\\[mark\\](.*?)\\[\\/mark\\]/ms',\n    \t\t\t\t\t '/\\[s\\](.*?)\\[\\/s\\]/ms',\n    \t\t\t\t\t '/\\[list\\=([0-9]+)\\](.*?)\\[\\/list\\]/ms',\n    \t\t\t\t\t '/\\[list\\](.*?)\\[\\/list\\]/ms',\n    \t\t\t\t\t '/\\[\\*\\]\\s?(.*?)\\n/ms',\n    \t\t\t\t\t '/\\[fs([0-9]+)\\](.*?)\\[\\/fs\\]/ms',\n    \t\t\t\t\t '/\\[color\\=([A-Za-z0-9]{2,6})\\](.*?)\\[\\/color\\]/ms'\n    \t);\n\n    \t// And replace them by...\n    \t$out = array(\t '<strong>\\1</strong>',\n    \t\t\t\t\t '<em>\\1</em>',\n    \t\t\t\t\t '<u>\\1</u>',\n    \t\t\t\t\t '<mark>\\1</mark>',\n    \t\t\t\t\t '<strike>\\1</strike>',\n    \t\t\t\t\t '<ol start=\"\\1\">\\2</ol>',\n    \t\t\t\t\t '<ul>\\1</ul>',\n    \t\t\t\t\t '<li>\\1</li>',\n    \t\t\t\t\t '<span style=\"font-size:\\1pt\">\\2</span>',\n    \t\t\t\t\t '<span style=\"color:#\\1\">\\2</span>'\n    \t);\n\n    \t$text = preg_replace($in, $out, $text);\n\n    \t// Prepare quote's\n    \t$text = str_replace(\"\\r\\n\",\"\\n\",$text);\n\n    \t// paragraphs\n    \t$text = str_replace(\"\\r\", \"\", $text);\n    \t$text = nl2br($text);\n\n    \t// clean some tags to remain strict\n    \t// not very elegant, but it works. No time to do better ;)\n    \tif (!function_exists('removeBr')) {\n    \t\tfunction removeBr($s) {\n    \t\t\treturn str_replace(\"<br />\", \"\", $s[0]);\n    \t\t}\n    \t}\n\n    \t$text = preg_replace_callback('/<pre>(.*?)<\\/pre>/ms', \"removeBr\", $text);\n    \t$text = preg_replace('/<p><pre>(.*?)<\\/pre><\\/p>/ms', \"<pre>\\\\1</pre>\", $text);\n\n    \t$text = preg_replace_callback('/<ul>(.*?)<\\/ul>/ms', \"removeBr\", $text);\n    \t$text = preg_replace('/<p><ul>(.*?)<\\/ul><\\/p>/ms', \"<ul>\\\\1</ul>\", $text);\n\n    \treturn $text;\n    }\n\n    public static function _make_url_embed_image($matches) {\n\n        $in = htmlspecialchars_decode($matches[2]);\n        $in = trim($in);\n\n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return '[img]' . $matches[2] . '[img]';\n\n        $prepend = '';\n        $append = '';\n        if (isset($matches[1]) && $matches[1] != '' && !empty(self::esc_url($matches[1]))) {\n            $prepend = '<a class=\"link\" rel=\"noreferrer\" target=\"_blank\" href=\"' . $matches[1] . '\">';\n            $append = '</a>';\n        }\n\n        return  \"<div class=\\\"img_embed\\\">{$prepend}<img class='img-fluid' src=\\\"\".$url.\"\\\" alt=\\\"\\\" />{$append}</div>\";\n   }\n\n   public static function _make_embed_map($matches)\n   {\n       $parts = explode(',',trim($matches[1]));\n\n       if (count($parts) == 2 && is_numeric($parts[0]) && is_numeric($parts[1])) {\n           $id = rand(0,1000) . time();\n           return \"<div id='msg-location-\".$id.\"' style='height:300px'><script>lhinst.showMessageLocation(\" . $id . \",\" . (float)$parts[0] . \",\" . (float)$parts[1] . \")</script></div>\";\n       }\n\n       return ;\n   }\n\n   public static function _make_url_embed($matches){\n\n        $in = str_replace('\"','',htmlspecialchars_decode($matches[1]));\n        $in = trim($in);\n        \n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return '[url='.$matches[1].']' . $matches[2] . '[/url]';\n\t\t\t\t\n        return '<a class=\"link\" target=\"_blank\" rel=\"noreferrer\" href=\"'.$url.'\">' . $matches[2] . '</a>';\n   }\n      \n   /**\n    * Callback to convert URL match to HTML A element.\n    *\n    * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n    *\n    * @since 2.3.2\n    * @access private\n    *\n    * @param array $matches Single Regex Match.\n    * @return string HTML A element with URL address.\n    */\n   public static function _make_web_ftp_clickable_cb( $matches ) {\n       $ret = '';\n       $dest = $matches[2];\n       $dest = 'http://' . $dest;\n       // removed trailing [.,;:)] from URL\n       if ( in_array( substr($dest, -1), array('.', ',', ';', ':', ')') ) === true ) {\n           $ret = substr($dest, -1);\n           $dest = substr($dest, 0, strlen($dest)-1);\n       }\n       $dest = self::esc_url($dest);\n       if ( empty($dest) )\n           return $matches[0];\n       \n       return $matches[1] . \"<a href=\\\"$dest\\\" class=\\\"link\\\" rel=\\\"noreferrer\\\" target=\\\"_blank\\\">$dest</a>$ret\";\n   }\n   \n   /**\n     * Callback to convert email address match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with email address.\n     */\n   public static function _make_email_clickable_cb( $matches ) {\n    \t$email = $matches[2] . '@' . $matches[3];\n    \treturn $matches[1] . \"<a rel=\\\"noreferrer\\\" class=\\\"link\\\" href=\\\"mailto:$email\\\">$email</a>\";\n   }\n\n   \n   public static function _make_paypal_button($matches){\n\n         if (filter_var($matches[1],FILTER_VALIDATE_EMAIL)) {\n            return '<form action=\"https://www.paypal.com/cgi-bin/webscr\" method=\"post\">\n            <input type=\"hidden\" name=\"cmd\" value=\"_donations\">\n            <input type=\"hidden\" name=\"business\" value=\"'.$matches[1].'\">\n            <input type=\"hidden\" name=\"lc\" value=\"US\">\n            <input type=\"hidden\" name=\"no_note\" value=\"0\">\n            <input type=\"hidden\" name=\"currency_code\" value=\"USD\">\n            <input type=\"hidden\" name=\"bn\" value=\"PP-DonationsBF:btn_donate_SM.gif:NonHostedGuest\">\n            <input type=\"image\" title=\"Support an artist\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/btn/btn_donate_SM.gif\" border=\"0\" name=\"submit\" alt=\"PayPal - The safer, easier way to pay online!\">\n            <img alt=\"\" border=\"0\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/scr/pixel.gif\" width=\"1\" height=\"1\">\n            </form>';\n        } else {\n            return $matches[0];\n        }\n   }\n\n   public static function _make_button_action($matches) {\n        return \"<button type=\\\"button\\\" class=\\\"btn btn-xs text-white fs13 btn-secondary\\\" onclick=\\\"lhinst.buttonAction($(this),'\" . htmlspecialchars(strip_tags($matches[1])) . \"')\\\">\" . htmlspecialchars($matches[2]) . \"</button>\";\n   }\n\n   public static function _make_youtube_block($matches) {\n\n         $data = parse_url($matches[1]);\n\n         if (isset($data['query'])){\n             parse_str($data['query'],$query);\n             if (stristr($data['host'],'youtube.com') && isset($query['v']) && ($query['v'] != '')) {\n                 return '<iframe class=\"w-100 h-100\" title=\"YouTube video player\" width=\"480\" height=\"300\" src=\"https://www.youtube.com/embed/'.urlencode($query['v']).'\" frameborder=\"0\" allowfullscreen></iframe>';\n             } else {\n                 return $matches[0];\n             }\n         } else {\n             return $matches[0];\n         }\n   }\n\n   public static function _make_upload_link($matches){\n       $data = $matches[1];\n       return '<a class=\"action-image alert-link\" onclick=\"lhinst.chooseFile()\">' . htmlspecialchars($data) . '</a>';\n   }\n\n   public static function _make_url_file($matches)\n   {\n\n   \t\tif (isset($matches[1])){\n   \t\t    $mainData = explode(' ',$matches[1]);\n   \t\t    $parts = explode('_',$mainData[0]);\n   \t\t\t$fileID = $parts[0];\n   \t\t\t$hash = $parts[1];\n   \t\t\t$displayType = isset($parts[2]) ? $parts[2] : null;\n   \t\t\ttry {\n   \t\t\t\t$file = erLhcoreClassModelChatFile::fetch($fileID);\n\n   \t\t\t\tif (is_object($file)) {\n                    // Check that user has permission to see the chat. Let say if user purposely types file bbcode\n                    if ($hash == $file->security_hash) {\n                        $fileExtension = strtolower($file->extension);\n                        if ($fileExtension == 'jpg' || $fileExtension == 'jpeg' || $fileExtension == 'png' || $fileExtension == 'gif'){\n\n                            // Make link if required\n                            $prepend = '';\n                            $append = '';\n                            if (isset($mainData[1])) {\n                                $subpartParts = explode('=',$mainData[1]);\n                                if ($subpartParts[0] == 'link') {\n                                    if (!isset($subpartParts[1])) {\n                                        $prepend = '<a class=\"link\" rel=\"noreferrer\" target=\"_blank\" href=\"//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\\\">\";\n                                        $append = '</a>';\n                                    } else {\n                                        $url = self::esc_url($subpartParts[1]);\n                                        if ($url != ''){\n                                            $prepend = '<a class=\"link\" rel=\"noreferrer\" target=\"_blank\" href=\"' . self::esc_url($subpartParts[1]) . '\">';\n                                            $append = '</a>';\n                                        }\n                                    }\n                                }\n                            } else {\n                                $prepend = '';\n                                $append = '<a class=\"hidden-download\" rel=\"noreferrer\" href=\"//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\".'\"></a>';\n                            }\n                            return $prepend . '<img id=\"img-file-' . $file->id . '\" class=\"img-fluid\" src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\" alt=\"\" />' . $append;\n                        }\n\n                        $audio = '';\n                        if ($fileExtension == 'mp3' || $fileExtension == 'wav' || $fileExtension == 'ogg') {\n                            return '<a rel=\"noreferrer\" class=\"hidden-download audio-download\" href=\"//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\".'\"></a><audio preload=\"none\" style=\"width: 230px\" controls><source src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\" type=\"' . $file->type . '\"></audio>';\n                        } elseif ($fileExtension == 'mp4' || $fileExtension == 'avi' || $fileExtension == 'mov' || $fileExtension == 'ogg' || $fileExtension == '3gpp') {\n                            $audio = '<br><div class=\"embed-responsive embed-responsive-16by9\"><video class=\"embed-responsive-item\" controls><source src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\"></video></div>';\n                        } else if ($fileExtension == 'jpg' || $fileExtension == 'jpeg' || $fileExtension == 'png') {\n                            $audio = ' <a rel=\"noreferrer\" class=\"link\" onclick=\"$(\\'#img-file-' . $file->id . '\\').toggleClass(\\'hide\\')\"><i class=\"material-icons mr-0\">&#xE251;</i></a><br/><img id=\"img-file-' . $file->id . '\" class=\"img-fluid hide\" src=\"//' . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\" . '\" alt=\"\" />';\n                        }\n\n                        return \"<a href=\\\"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\" class=\\\"link\\\" >\" . erTranslationClassLhTranslation::getInstance()->getTranslation('file/file', 'Download file') . ' - ' . htmlspecialchars($file->upload_name) . ' [' . $file->extension . ']' . \"</a>\" . $audio;\n                    }\n                }\n\n   \t\t\t} catch (Exception $e) {\n\n   \t\t\t}\n\n   \t\t\treturn '';\n   \t\t}\n   \t\treturn '';\n   }\n\n   public static function _make_url_survey($matches)\n   {\n       if (isset($matches[1])){\n                  \n           list($surveyId, $surveyItemId) = explode('_',str_replace(array('\"','&quot;'),'', $matches[1]));\n           \n           try {\n                             \n               if (is_numeric($surveyItemId) && is_numeric($surveyId)) {\n\n                   $surveyItem = erLhAbstractModelSurveyItem::fetch($surveyItemId);\n\n                   if ($surveyId == $surveyItem->survey_id) \n                   {\n                       $survey = erLhAbstractModelSurvey::fetch($surveyId);\n                       return \"<a href=\\\"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('survey/collected').\"/{$survey->id}?show={$surveyItem->id}\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\" class=\\\"link\\\" >\" . erTranslationClassLhTranslation::getInstance()->getTranslation('file/file','Collected survey data') . ' - ' . htmlspecialchars($survey->name) . \"</a>\";\n                   }\n               }\n               \n           } catch (Exception $e) {\n       \n           }\n       \n           return '';\n       }\n       return '';\n   }\n   \n   public static function _make_url_mail_file($matches){\n\n   \t\tif (isset($matches[1])){\n   \t\t\tlist($fileID,$hash) = explode('_',$matches[1]);\n   \t\t\ttry {\n   \t\t\t\t$file = erLhcoreClassModelChatFile::fetch($fileID);\n\n   \t\t\t\t// Check that user has permission to see the chat. Let say if user purposely types file bbcode\n   \t\t\t\tif ($hash == $file->security_hash) {\n   \t\t\t\t\treturn erLhcoreClassXMP::getBaseHost().$_SERVER['HTTP_HOST'].erLhcoreClassDesign::baseurldirect('file/downloadfile').\"/{$file->id}/{$hash}\";\n   \t\t\t\t}\n   \t\t\t} catch (Exception $e) {\n\n   \t\t\t}\n\n   \t\t\treturn '';\n   \t\t}\n   \t\treturn '';\n   }\n\n   public static function _split_str_by_whitespace( $string, $goal ) {\n        $chunks = array();\n\n        $string_nullspace = strtr( $string, \"\\r\\n\\t\\v\\f \", \"\\000\\000\\000\\000\\000\\000\" );\n\n        while ( $goal < strlen( $string_nullspace ) ) {\n            $pos = strrpos( substr( $string_nullspace, 0, $goal + 1 ), \"\\000\" );\n\n            if ( false === $pos ) {\n                $pos = strpos( $string_nullspace, \"\\000\", $goal + 1 );\n                if ( false === $pos ) {\n                    break;\n                }\n            }\n\n            $chunks[] = substr( $string, 0, $pos + 1 );\n            $string = substr( $string, $pos + 1 );\n            $string_nullspace = substr( $string_nullspace, $pos + 1 );\n        }\n\n        if ( $string ) {\n            $chunks[] = $string;\n        }\n\n        return $chunks;\n    }\n\n   // https://github.com/WordPress/WordPress/blob/6e5e29c5bf49ad2be6a2c3a3d4fb3f5af6853b5b/wp-includes/formatting.php\n   public static function make_clickable_text( $text ) {\n       $r = '';\n       $textarr = preg_split( '/(<[^<>]+>)/', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // split out HTML tags\n       $nested_code_pre = 0; // Keep track of how many levels link is nested inside <pre> or <code>\n       foreach ( $textarr as $piece ) {\n           if ( preg_match( '|^<code[\\s>]|i', $piece ) || preg_match( '|^<pre[\\s>]|i', $piece ) || preg_match( '|^<script[\\s>]|i', $piece ) || preg_match( '|^<style[\\s>]|i', $piece ) )\n               $nested_code_pre++;\n           elseif ( $nested_code_pre && ( '</code>' === strtolower( $piece ) || '</pre>' === strtolower( $piece ) || '</script>' === strtolower( $piece ) || '</style>' === strtolower( $piece ) ) )\n           $nested_code_pre--;\n           if ( $nested_code_pre || empty( $piece ) || ( $piece[0] === '<' && ! preg_match( '|^<\\s*[\\w]{1,20}+://|', $piece ) ) ) {\n               $r .= $piece;\n               continue;\n           }\n           // Long strings might contain expensive edge cases ...\n           if ( 10000 < strlen( $piece ) ) {\n               // ... break it up\n               foreach ( self::_split_str_by_whitespace( $piece, 2100 ) as $chunk ) { // 2100: Extra room for scheme and leading and trailing paretheses\n                   if ( 2101 < strlen( $chunk ) ) {\n                       $r .= $chunk; // Too big, no whitespace: bail.\n                   } else {\n                       $r .= self::make_clickable_text( $chunk );\n                   }\n               }\n           } else {\n               $ret = \" $piece \"; // Pad with whitespace to simplify the regexes\n               $url_clickable = '~\n\t\t\t\t([\\\\s(<.,;:!?])                                        # 1: Leading whitespace, or punctuation\n\t\t\t\t(                                                      # 2: URL\n\t\t\t\t\t[\\\\w]{1,20}+://                                # Scheme and hier-part prefix\n\t\t\t\t\t(?=\\S{1,2000}\\s)                               # Limit to URLs less than about 2000 characters long\n\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]*+         # Non-punctuation URL character\n\t\t\t\t\t(?:                                            # Unroll the Loop: Only allow puctuation URL character if followed by a non-punctuation URL character\n\t\t\t\t\t\t[\\'.,;:!?)]                            # Punctuation URL character\n\t\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]++ # Non-punctuation URL character\n\t\t\t\t\t)*\n\t\t\t\t)\n\t\t\t\t(\\)?)                                                  # 3: Trailing closing parenthesis (for parethesis balancing post processing)\n\t\t\t~xS'; // The regex is a non-anchored pattern and does not have a single fixed starting character.\n               // Tell PCRE to spend more time optimizing since, when used on a page load, it will probably be used several times.\n               $ret = preg_replace_callback( $url_clickable, 'erLhcoreClassBBCode::_make_url_clickable_cb', $ret );\n               $ret = preg_replace_callback( '#([\\s>])((www|ftp)\\.[\\w\\\\x80-\\\\xff\\#$%&~/.\\-;:=,?@\\[\\]+]+)#is', 'erLhcoreClassBBCode::_make_web_ftp_clickable_cb', $ret );\n               $ret = preg_replace_callback( '#([\\s>])([.0-9a-z_+-]+)@(([0-9a-z-]+\\.)+[0-9a-z]{2,})#i', 'erLhcoreClassBBCode::_make_email_clickable_cb', $ret );\n               $ret = substr( $ret, 1, -1 ); // Remove our whitespace padding.\n               $r .= $ret;\n           }\n       }\n       \n       // Cleanup of accidental links within links\n       return preg_replace( '#(<a([ \\r\\n\\t]+[^>]+?>|>))<a [^>]+?>([^>]+?)</a></a>#i', \"$1$3</a>\", $r );\n   }\n\n   public static function makeQuote($matches)\n   {\n       if ($matches[1]) {\n           return '<blockquote class=\"blockquote\"> ' . $matches[1] . ' </blockquote>';\n       } else {\n           return $matches[0];\n       }\n   }\n\n   public static function extractMetaByMessage(& $msg) {\n       $meta = array();\n       if (strpos($msg,'[html_snippet]') !== false) {\n           $matches = array();\n           preg_match_all('/\\[html_snippet\\](.*?)\\[\\/html_snippet\\]/is',$msg,$matches);\n           foreach ($matches[0] as $index => $match) {\n               $msg = str_replace($match,'',$msg);\n               $meta['html_snippet'][] = $matches[1][$index];\n           }\n       }\n       return $meta;\n   }\n\n   public static function makeSubmessages($msg, $paramsMessage = array()) {\n\n       // Links wraps images\n       $msg = preg_replace('#\\[url\\=\"?(.*?)\"?\\]\\[file=\"?(.*?)_img\"?\\]\\[\\/url\\]#is','[file=\\2_img link=\\1]',$msg);\n\n       // pure files\n       $msg = preg_replace('#\\[file=\"?(.*?)_img\"?(.*?)\\]#is','IMG_REPLACE[file=\\1_img\\2]IMG_REPLACE',$msg);\n\n       // Images within links\n       $msg = preg_replace('#\\[url\\=\"?(.*?)\"?\\]\\[img\\](.*?)\\[\\/img\\]\\[\\/url\\]#is','[img=\\1]\\2[/img]',$msg);\n\n       // Pure images\n       $msg = preg_replace('#\\[img(.*?)\\](.*?)\\[\\/img\\]#is','IMG_REPLACE[img\\1]\\2[/img]IMG_REPLACE',$msg);\n\n       $msg = trim($msg);\n\n       $messages = array_filter(explode('IMG_REPLACE', $msg));\n       $totalMessages = count($messages);\n\n       $messagesData = array();\n       foreach ($messages as $indexMessage => $message) {\n           if (trim($message) != '')\n           {\n               $msgRendered = erLhcoreClassBBCode::make_clickable(htmlspecialchars($message), $paramsMessage);\n\n               $messagesDataItem['body'] = $msgRendered;\n               $messagesDataItem['flags'] = [];\n\n               $msgRenderedMedia = strip_tags($msgRendered);\n               $emojiMessage = trim(preg_replace('#([\\x{2B50}-\\x{2B55}]|[\\x{23F0}-\\x{23F3}]|[\\x{231A}-\\x{231B}]|[\\x{1F600}-\\x{1F64F}]|[\\x{1F910}-\\x{1F9FF}]|[\\x{1F300}-\\x{1F5FF}]|[\\x{1F680}-\\x{1F6FF}]|[\\x{2600}-\\x{26FF}]|[\\x{2700}-\\x{27BF}])#u','', $msgRendered));\n\n               if ($msgRenderedMedia == '') {\n                   $messagesDataItem['flags'][] = 'img';\n               }\n\n               if ($emojiMessage == '') {\n                   $messagesDataItem['flags'][] = 'emoji';\n               }\n\n                // New line at the top of message and it's not the first message\n               if (substr($message,0,1) == \"\\n\" && $indexMessage > 0) {\n                   $messagesDataItem['flags'][] = 'nlt';\n               }\n\n               // New line at the end of message and it's not the last message\n               if (substr($message,-1) == \"\\n\" && $indexMessage + 1 != $totalMessages) {\n                   $messagesDataItem['flags'][] = 'nl';\n               }\n\n               $messagesData[] = $messagesDataItem;\n           }\n       }\n\n       return $messagesData;\n   }\n\n   // Converts bbcode and general links to hmtl code\n   public static function make_clickable($ret, $paramsMessage = array()) {\n        $ret = ' ' . $ret;\n\n        $makeLinksClickable = true;\n        \n        erLhcoreClassChatEventDispatcher::getInstance()->dispatch('chat.before_make_clickable',array('msg' => & $ret, 'makeLinksClickable' => & $makeLinksClickable));\n\n        $ret = preg_replace_callback('/\\[img=?(.*?)\\](.*?)\\[\\/img\\]/ms', \"erLhcoreClassBBCode::_make_url_embed_image\", $ret);\n\n        $ret = preg_replace_callback('/\\[loc\\](.*?)\\[\\/loc\\]/ms', \"erLhcoreClassBBCode::_make_embed_map\", $ret);\n\n        $ret = preg_replace_callback('/\\[url\\=\"?(.*?)\"?\\](.*?)\\[\\/url\\]/ms', \"erLhcoreClassBBCode::_make_url_embed\", $ret);\n\n        if (isset($paramsMessage['sender']) && $paramsMessage['sender'] == 0) {\n            $ret = preg_replace('/\\[html\\](.*?)\\[\\/html\\]/ms','',$ret);\n        }\n\n        $ret = preg_replace_callback('/\\[html\\](.*?)\\[\\/html\\]/ms', function ($matches) {\n            $html = htmlspecialchars_decode($matches[1]);\n\n            $html = preg_replace_callback('/\"window\\.parent\\.(.*)\"/ms',function ($matches){\n                return \"'lhinst.executeRemoteCommands([\\\"lhc_eval:\" . $matches[1] . \"\\\"])'\";\n            },$html);\n\n            return $html;\n\n        }, $ret);\n\n\n        if ($makeLinksClickable) {\n            $ret = self::make_clickable_text($ret);           \n        }\n\n    \t$ret = self::BBCode2Html($ret);\n\n    \t// Paypal button\n    \t$ret = preg_replace_callback('#\\[paypal\\](.*?)\\[/paypal\\]#is', 'erLhcoreClassBBCode::_make_paypal_button', $ret);\n\n    \t// Quote\n    \t$ret = preg_replace_callback('#\\[quote\\](.*?)\\[/quote\\]#is', 'erLhcoreClassBBCode::makeQuote', $ret);\n\n    \t// Youtube block\n    \t$ret = preg_replace_callback('#\\[youtube\\](.*?)\\[/youtube\\]#is', 'erLhcoreClassBBCode::_make_youtube_block', $ret);\n\n    \t// File upload link directly in chat message\n    \t$ret = preg_replace_callback('#\\[fupload\\](.*?)\\[/fupload\\]#is', 'erLhcoreClassBBCode::_make_upload_link', $ret);\n\n    \t$ret = preg_replace_callback('#\\[button_action=\"?(.*?)\"?\\](.*?)\\[/button_action\\]#is', 'erLhcoreClassBBCode::_make_button_action', $ret);\n\n    \t$ret = preg_replace('#\\[translation\\](.*?)\\[/translation\\]#is', '<span class=\"tr-msg\">$1</span>', $ret);\n\n    \t// File block\n    \t$ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCode::_make_url_file', $ret);\n    \t\n    \t// Survey\n    \t$ret = preg_replace_callback('#\\[survey=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCode::_make_url_survey', $ret);\n\n    \t$ret = trim($ret);\n\n        erLhcoreClassChatEventDispatcher::getInstance()->dispatch('chat.after_make_clickable',array('msg' => & $ret));\n        \n    \treturn $ret;\n   }\n   \n   public static function parseForMail($ret){\n   \t\t// File block\n   \t\t$ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCode::_make_url_mail_file', $ret);\n   \t\treturn trim($ret);\n   }\n   \n   // Makes plain text from BB code\n   public static function make_plain($ret){\n        $ret = ' ' . $ret;\n\n       // BBCode to find...\n       $in = array( \t '/\\[b\\](.*?)\\[\\/b\\]/ms',\n           '/\\[i\\](.*?)\\[\\/i\\]/ms',\n           '/\\[u\\](.*?)\\[\\/u\\]/ms',\n           '/\\[list\\=(.*?)\\](.*?)\\[\\/list\\]/ms',\n           '/\\[list\\](.*?)\\[\\/list\\]/ms',\n           '/\\[\\*\\]\\s?(.*?)\\n/ms',\n           '/\\[img\\](.*?)\\[\\/img\\]/ms',\n           '/\\[url\\=\"?(.*?)\"?\\](.*?)\\[\\/url\\]/ms',\n           '/\\[quote\\]/ms',\n           '/\\[\\/quote\\]/ms',\n           '/\\[fs(.*?)\\](.*?)\\[\\/fs(.*?)\\]/ms',\n           '/\\n/ms',\n       );\n\n       // And replace them by...\n       $out = array(\t '\\1',\n           '\\1',\n           '\\1',\n           '\\2',\n           '\\1',\n           '\\1',\n           '',\n           '\\2 \\1',\n           '',\n           '',\n           '\\2',\n           ' ',\n       );\n\n    \t$ret = preg_replace($in, $out, $ret);\n\n        $ret = trim($ret);\n        return $ret;\n   }\n\n}\n\n\n?>\n", "<?php\n\n/**\n * This code is mix of WP and phpBB :)\n * */\nclass erLhcoreClassBBCodePlain\n{\n    /**\n     * Callback to convert URI match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with URI address.\n     */\n    public static function _make_url_clickable_cb( $matches ) {\n        $url = $matches[2];\n        if ( ')' == $matches[3] && strpos( $url, '(' ) ) {\n            // If the trailing character is a closing parethesis, and the URL has an opening parenthesis in it, add the closing parenthesis to the URL.\n            // Then we can let the parenthesis balancer do its thing below.\n            $url .= $matches[3];\n            $suffix = '';\n        } else {\n            $suffix = $matches[3];\n        }\n        // Include parentheses in the URL only if paired\n        while ( substr_count( $url, '(' ) < substr_count( $url, ')' ) ) {\n            $suffix = strrchr( $url, ')' ) . $suffix;\n            $url = substr( $url, 0, strrpos( $url, ')' ) );\n        }\n        $url = self::esc_url($url);\n        if ( empty($url) )\n            return $matches[0];\n        return $matches[1] . $url . $suffix;\n    }\n\n    /**\n     * Checks and cleans a URL.\n     *\n     * A number of characters are removed from the URL. If the URL is for displaying\n     * (the default behaviour) ampersands are also replaced. The {@see 'clean_url'} filter\n     * is applied to the returned cleaned URL.\n     *\n     * @since 2.8.0\n     *\n     * @param string $url       The URL to be cleaned.\n     * @param array  $protocols Optional. An array of acceptable protocols.\n     *\t\t                    Defaults to return value of wp_allowed_protocols()\n     * @param string $_context  Private. Use esc_url_raw() for database usage.\n     * @return string The cleaned $url after the {@see 'clean_url'} filter is applied.\n     */\n    public static function esc_url( $url, $protocols = null, $_context = 'display' ) {\n        $original_url = $url;\n        if ( '' == $url )\n            return $url;\n        $url = str_replace( ' ', '%20', $url );\n        $url = preg_replace('|[^a-z0-9-~+_.?#=!&;,/:%@$\\|*\\'()\\[\\]\\\\x80-\\\\xff]|i', '', $url);\n        if ( '' === $url ) {\n            return $url;\n        }\n        if ( 0 !== stripos( $url, 'mailto:' ) ) {\n            $strip = array('%0d', '%0a', '%0D', '%0A');\n            $url = self::_deep_replace($strip, $url);\n        }\n        $url = str_replace(';//', '://', $url);\n        /* If the URL doesn't appear to contain a scheme, we\n         * presume it needs http:// prepended (unless a relative\n         * link starting with /, # or ? or a php file).\n        */\n        if ( strpos($url, ':') === false && ! in_array( $url[0], array( '/', '#', '?' ) ) &&\n            ! preg_match('/^[a-z0-9-]+?\\.php/i', $url) )\n            $url = 'http://' . $url;\n        // Replace ampersands and single quotes only when displaying.\n        if ( 'display' == $_context ) {\n            $url = self::wp_kses_normalize_entities( $url );\n            $url = str_replace( '&amp;', '&#038;', $url );\n            $url = str_replace( \"'\", '&#039;', $url );\n        }\n        if ( ( false !== strpos( $url, '[' ) ) || ( false !== strpos( $url, ']' ) ) ) {\n            $parsed = self::wp_parse_url( $url );\n            $front  = '';\n            if ( isset( $parsed['scheme'] ) ) {\n                $front .= $parsed['scheme'] . '://';\n            } elseif ( '/' === $url[0] ) {\n                $front .= '//';\n            }\n            if ( isset( $parsed['user'] ) ) {\n                $front .= $parsed['user'];\n            }\n            if ( isset( $parsed['pass'] ) ) {\n                $front .= ':' . $parsed['pass'];\n            }\n            if ( isset( $parsed['user'] ) || isset( $parsed['pass'] ) ) {\n                $front .= '@';\n            }\n            if ( isset( $parsed['host'] ) ) {\n                $front .= $parsed['host'];\n            }\n            if ( isset( $parsed['port'] ) ) {\n                $front .= ':' . $parsed['port'];\n            }\n            $end_dirty = str_replace( $front, '', $url );\n            $end_clean = str_replace( array( '[', ']' ), array( '%5B', '%5D' ), $end_dirty );\n            $url       = str_replace( $end_dirty, $end_clean, $url );\n        }\n        if ( '/' === $url[0] ) {\n            $good_protocol_url = $url;\n        } else {\n            if ( ! is_array( $protocols ) )\n                $protocols = $protocols = array( 'http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet', 'mms', 'rtsp', 'svn', 'tel', 'fax', 'xmpp', 'webcal', 'urn' );\n\n            $good_protocol_url = self::wp_kses_bad_protocol( $url, $protocols );\n            if ( strtolower( $good_protocol_url ) != strtolower( $url ) )\n                return '';\n        }\n\n        /**\n         * Filters a string cleaned and escaped for output as a URL.\n         *\n         * @since 2.3.0\n         *\n         * @param string $good_protocol_url The cleaned URL to be returned.\n         * @param string $original_url      The URL prior to cleaning.\n         * @param string $_context          If 'display', replace ampersands and single quotes only.\n         */\n        return $url;\n    }\n\n    /**\n     * A wrapper for PHP's parse_url() function that handles consistency in the return\n     * values across PHP versions.\n     *\n     * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n     * schemeless and relative url's with :// in the path. This function works around\n     * those limitations providing a standard output on PHP 5.2~5.4+.\n     *\n     * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n     * in the query are being handled inconsistently. This function works around those\n     * differences as well.\n     *\n     * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n     * when URL parsing failed.\n     *\n     * @since 4.4.0\n     * @since 4.7.0 The $component parameter was added for parity with PHP's parse_url().\n     *\n     * @param string $url       The URL to parse.\n     * @param int    $component The specific component to retrieve. Use one of the PHP\n     *                          predefined constants to specify which one.\n     *                          Defaults to -1 (= return all parts as an array).\n     *                          @see http://php.net/manual/en/function.parse-url.php\n     * @return mixed False on parse failure; Array of URL components on success;\n     *               When a specific component has been requested: null if the component\n     *               doesn't exist in the given URL; a string or - in the case of\n     *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n     */\n    public static function wp_parse_url( $url, $component = -1 ) {\n        $to_unset = array();\n        $url = strval( $url );\n        if ( '//' === substr( $url, 0, 2 ) ) {\n            $to_unset[] = 'scheme';\n            $url = 'placeholder:' . $url;\n        } elseif ( '/' === substr( $url, 0, 1 ) ) {\n            $to_unset[] = 'scheme';\n            $to_unset[] = 'host';\n            $url = 'placeholder://placeholder' . $url;\n        }\n        $parts = @parse_url( $url );\n        if ( false === $parts ) {\n            // Parsing failure.\n            return $parts;\n        }\n        // Remove the placeholder values.\n        foreach ( $to_unset as $key ) {\n            unset( $parts[ $key ] );\n        }\n        return self::_get_component_from_parsed_url_array( $parts, $component );\n    }\n\n    /**\n     * Retrieve a specific component from a parsed URL array.\n     *\n     * @internal\n     *\n     * @since 4.7.0\n     *\n     * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n     * @param int    $component The specific component to retrieve. Use one of the PHP\n     *                          predefined constants to specify which one.\n     *                          Defaults to -1 (= return all parts as an array).\n     *                          @see http://php.net/manual/en/function.parse-url.php\n     * @return mixed False on parse failure; Array of URL components on success;\n     *               When a specific component has been requested: null if the component\n     *               doesn't exist in the given URL; a string or - in the case of\n     *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n     */\n    public static function _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n        if ( -1 === $component ) {\n            return $url_parts;\n        }\n        $key = self::_wp_translate_php_url_constant_to_key( $component );\n        if ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n            return $url_parts[ $key ];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Translate a PHP_URL_* constant to the named array keys PHP uses.\n     *\n     * @internal\n     *\n     * @since 4.7.0\n     *\n     * @see   http://php.net/manual/en/url.constants.php\n     *\n     * @param int $constant PHP_URL_* constant.\n     * @return string|bool The named key or false.\n     */\n    public static function _wp_translate_php_url_constant_to_key( $constant ) {\n        $translation = array(\n            PHP_URL_SCHEME   => 'scheme',\n            PHP_URL_HOST     => 'host',\n            PHP_URL_PORT     => 'port',\n            PHP_URL_USER     => 'user',\n            PHP_URL_PASS     => 'pass',\n            PHP_URL_PATH     => 'path',\n            PHP_URL_QUERY    => 'query',\n            PHP_URL_FRAGMENT => 'fragment',\n        );\n        if ( isset( $translation[ $constant ] ) ) {\n            return $translation[ $constant ];\n        } else {\n            return false;\n        }\n    }\n\n\n    /**\n     * Converts and fixes HTML entities.\n     *\n     * This function normalizes HTML entities. It will convert `AT&T` to the correct\n     * `AT&amp;T`, `&#00058;` to `&#58;`, `&#XYZZY;` to `&amp;#XYZZY;` and so on.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string Content to normalize entities\n     * @return string Content with normalized entities\n     */\n    public static function wp_kses_normalize_entities($string) {\n        // Disarm all entities by converting & to &amp;\n        $string = str_replace('&', '&amp;', $string);\n        // Change back the allowed entities in our entity whitelist\n        $string = preg_replace_callback('/&amp;([A-Za-z]{2,8}[0-9]{0,2});/', 'erLhcoreClassBBCodePlain::wp_kses_named_entities', $string);\n        $string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'erLhcoreClassBBCodePlain::wp_kses_normalize_entities2', $string);\n        $string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'erLhcoreClassBBCodePlain::wp_kses_normalize_entities3', $string);\n        return $string;\n    }\n\n    /**\n     * Callback for wp_kses_normalize_entities() for regular expression.\n     *\n     * This function helps wp_kses_normalize_entities() to only accept valid Unicode\n     * numeric entities in hex form.\n     *\n     * @since 2.7.0\n     * @access private\n     *\n     * @param array $matches preg_replace_callback() matches array\n     * @return string Correctly encoded entity\n     */\n    public static function wp_kses_normalize_entities3($matches) {\n        if ( empty($matches[1]) )\n            return '';\n        $hexchars = $matches[1];\n        return ( ! self::valid_unicode( hexdec( $hexchars ) ) ) ? \"&amp;#x$hexchars;\" : '&#x'.ltrim($hexchars,'0').';';\n    }\n\n    /**\n     * Helper function to determine if a Unicode value is valid.\n     *\n     * @since 2.7.0\n     *\n     * @param int $i Unicode value\n     * @return bool True if the value was a valid Unicode number\n     */\n    public static function valid_unicode($i) {\n        return ( $i == 0x9 || $i == 0xa || $i == 0xd ||\n            ($i >= 0x20 && $i <= 0xd7ff) ||\n            ($i >= 0xe000 && $i <= 0xfffd) ||\n            ($i >= 0x10000 && $i <= 0x10ffff) );\n    }\n\n    /**\n     * Callback for wp_kses_normalize_entities() regular expression.\n     *\n     * This function helps wp_kses_normalize_entities() to only accept 16-bit\n     * values and nothing more for `&#number;` entities.\n     *\n     * @access private\n     * @since 1.0.0\n     *\n     * @param array $matches preg_replace_callback() matches array\n     * @return string Correctly encoded entity\n     */\n    public static function wp_kses_normalize_entities2($matches) {\n        if ( empty($matches[1]) )\n            return '';\n        $i = $matches[1];\n        if (self::valid_unicode($i)) {\n            $i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);\n            $i = \"&#$i;\";\n        } else {\n            $i = \"&amp;#$i;\";\n        }\n        return $i;\n    }\n\n    /**\n     * Callback for wp_kses_normalize_entities() regular expression.\n     *\n     * This function only accepts valid named entity references, which are finite,\n     * case-sensitive, and highly scrutinized by HTML and XML validators.\n     *\n     * @since 3.0.0\n     *\n     * @global array $allowedentitynames\n     *\n     * @param array $matches preg_replace_callback() matches array\n     * @return string Correctly encoded entity\n     */\n    public static function wp_kses_named_entities($matches) {\n        $allowedentitynames = array(\n            'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',\n            'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',\n            'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',\n            'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',\n            'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',\n            'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',\n            'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',\n            'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',\n            'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',\n            'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',\n            'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',\n            'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',\n            'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',\n            'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',\n            'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',\n            'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',\n            'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',\n            'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',\n            'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',\n            'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',\n            'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',\n            'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',\n            'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',\n            'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',\n            'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',\n            'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',\n            'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',\n            'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',\n            'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',\n            'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',\n            'oline',   'frasl',  'weierp',  'image',  'real',   'trade',\n            'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',\n            'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',\n            'forall',  'part',   'exist',   'empty',  'nabla',  'isin',\n            'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',\n            'radic',   'prop',   'infin',   'ang',    'and',    'or',\n            'cap',     'cup',    'int',     'sim',    'cong',   'asymp',\n            'ne',      'equiv',  'le',      'ge',     'sub',    'sup',\n            'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',\n            'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',\n            'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',\n            'sup1',    'sup2',   'sup3',    'frac14', 'frac12', 'frac34',\n            'there4',\n        );\n\n        if ( empty($matches[1]) )\n            return '';\n        $i = $matches[1];\n        return ( ! in_array( $i, $allowedentitynames ) ) ? \"&amp;$i;\" : \"&$i;\";\n    }\n\n    /**\n     * Sanitize string from bad protocols.\n     *\n     * This function removes all non-allowed protocols from the beginning of\n     * $string. It ignores whitespace and the case of the letters, and it does\n     * understand HTML entities. It does its work in a while loop, so it won't be\n     * fooled by a string like \"javascript:javascript:alert(57)\".\n     *\n     * @since 1.0.0\n     *\n     * @param string $string            Content to filter bad protocols from\n     * @param array  $allowed_protocols Allowed protocols to keep\n     * @return string Filtered content\n     */\n    public static function wp_kses_bad_protocol($string, $allowed_protocols) {\n        $string = self::wp_kses_no_null($string);\n        $iterations = 0;\n        do {\n            $original_string = $string;\n            $string = self::wp_kses_bad_protocol_once($string, $allowed_protocols);\n        } while ( $original_string != $string && ++$iterations < 6 );\n        if ( $original_string != $string )\n            return '';\n        return $string;\n    }\n\n    /**\n     * Removes any invalid control characters in $string.\n     *\n     * Also removes any instance of the '\\0' string.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string\n     * @param array $options Set 'slash_zero' => 'keep' when '\\0' is allowed. Default is 'remove'.\n     * @return string\n     */\n    public static function wp_kses_no_null( $string, $options = null ) {\n        if ( ! isset( $options['slash_zero'] ) ) {\n            $options = array( 'slash_zero' => 'remove' );\n        }\n        $string = preg_replace( '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/', '', $string );\n        if ( 'remove' == $options['slash_zero'] ) {\n            $string = preg_replace( '/\\\\\\\\+0+/', '', $string );\n        }\n        return $string;\n    }\n\n    /**\n     * Sanitizes content from bad protocols and other characters.\n     *\n     * This function searches for URL protocols at the beginning of $string, while\n     * handling whitespace and HTML entities.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string            Content to check for bad protocols\n     * @param string $allowed_protocols Allowed protocols\n     * @return string Sanitized content\n     */\n    public static function wp_kses_bad_protocol_once($string, $allowed_protocols, $count = 1 ) {\n        $string2 = preg_split( '/:|&#0*58;|&#x0*3a;/i', $string, 2 );\n        if ( isset($string2[1]) && ! preg_match('%/\\?%', $string2[0]) ) {\n            $string = trim( $string2[1] );\n            $protocol = self::wp_kses_bad_protocol_once2( $string2[0], $allowed_protocols );\n            if ( 'feed:' == $protocol ) {\n                if ( $count > 2 )\n                    return '';\n                $string = self::wp_kses_bad_protocol_once( $string, $allowed_protocols, ++$count );\n                if ( empty( $string ) )\n                    return $string;\n            }\n            $string = $protocol . $string;\n        }\n        return $string;\n    }\n\n\n    /**\n     * Callback for wp_kses_bad_protocol_once() regular expression.\n     *\n     * This function processes URL protocols, checks to see if they're in the\n     * whitelist or not, and returns different data depending on the answer.\n     *\n     * @access private\n     * @since 1.0.0\n     *\n     * @param string $string            URI scheme to check against the whitelist\n     * @param string $allowed_protocols Allowed protocols\n     * @return string Sanitized content\n     */\n    public static function wp_kses_bad_protocol_once2( $string, $allowed_protocols ) {\n        $string2 = self::wp_kses_decode_entities($string);\n        $string2 = preg_replace('/\\s/', '', $string2);\n        $string2 = self::wp_kses_no_null($string2);\n        $string2 = strtolower($string2);\n        $allowed = false;\n        foreach ( (array) $allowed_protocols as $one_protocol )\n            if ( strtolower($one_protocol) == $string2 ) {\n                $allowed = true;\n                break;\n            }\n        if ($allowed)\n            return \"$string2:\";\n        else\n            return '';\n    }\n\n    /**\n     * Convert all entities to their character counterparts.\n     *\n     * This function decodes numeric HTML entities (`&#65;` and `&#x41;`).\n     * It doesn't do anything with other entities like &auml;, but we don't\n     * need them in the URL protocol whitelisting system anyway.\n     *\n     * @since 1.0.0\n     *\n     * @param string $string Content to change entities\n     * @return string Content after decoded entities\n     */\n    public static function wp_kses_decode_entities($string) {\n        $string = preg_replace_callback('/&#([0-9]+);/', 'erLhcoreClassBBCodePlain::_wp_kses_decode_entities_chr', $string);\n        $string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', 'erLhcoreClassBBCodePlain::_wp_kses_decode_entities_chr_hexdec', $string);\n        return $string;\n    }\n\n    /**\n     * Regex callback for wp_kses_decode_entities()\n     *\n     * @since 2.9.0\n     *\n     * @param array $match preg match\n     * @return string\n     */\n    public static function _wp_kses_decode_entities_chr( $match ) {\n        return chr( $match[1] );\n    }\n    /**\n     * Regex callback for wp_kses_decode_entities()\n     *\n     * @since 2.9.0\n     *\n     * @param array $match preg match\n     * @return string\n     */\n    public static function _wp_kses_decode_entities_chr_hexdec( $match ) {\n        return chr( hexdec( $match[1] ) );\n    }\n\n\n    /**\n     * Perform a deep string replace operation to ensure the values in $search are no longer present\n     *\n     * Repeats the replacement operation until it no longer replaces anything so as to remove \"nested\" values\n     * e.g. $subject = '%0%0%0DDD', $search ='%0D', $result ='' rather than the '%0%0DD' that\n     * str_replace would return\n     *\n     * @since 2.8.1\n     * @access private\n     *\n     * @param string|array $search  The value being searched for, otherwise known as the needle.\n     *                              An array may be used to designate multiple needles.\n     * @param string       $subject The string being searched and replaced on, otherwise known as the haystack.\n     * @return string The string with the replaced svalues.\n     */\n    public static function _deep_replace( $search, $subject ) {\n        $subject = (string) $subject;\n        $count = 1;\n        while ( $count ) {\n            $subject = str_replace( $search, '', $subject, $count );\n        }\n        return $subject;\n    }\n\n    public static $replaceEmoji = array(\n        ':\\)' => \"\\u{1F642}\",\n        ':D:' => \"\\u{1F600}\",\n        ':D' => \"\\u{1F600}\",\n        ':\\(' => \"\\u{1F641}\",\n        ':o:' => \"\\u{1F62E}\",\n        ':o' => \"\\u{1F62E}\",\n        ':p:' => \"\\u{1F61B}\",\n        ':p' => \"\\u{1F61B}\",\n        ';\\)' => \"\\u{1F609}\",\n        ';\\(' => \"\\u{1F622}\",\n        ':x' => \"\\u{1F910}\",\n        ':\\*' => \"\\u{1F617}\",\n        ';\\*' => \"\\u{1F618}\",\n        ':\\/' => \"\\u{1F615}\"\n    );\n\n    public static function parseEmoji($text) {\n\n        // Smileys to find...\n        for ($i = 0; $i < 2; $i++) {\n            $text = preg_replace_callback('/(^|\\s)(' .implode(\"|\",array_keys(self::$replaceEmoji)) . ')(\\s|$)/', function($match) {\n                $char = str_replace(array('/','(',')','*'),array('\\/','\\(','\\)','\\*'),$match[2]);\n                return $match[1] . erLhcoreClassBBCodePlain::$replaceEmoji[$char] . $match[3];\n            },  $text);\n        }\n\n        return $text;\n    }\n\n    public static function BBCode2Html($text) {\n        $text = trim($text);\n\n        $text = self::parseEmoji($text);\n\n        // Smileys to find...\n        $in = array(\n        );\n\n        // And replace them by...\n        $out = array(\n        );\n\n        $in[] = '[/*]';\n        $in[] = '[*]';\n        $out[] = '</li>';\n        $out[] = '<li>';\n\n        $text = str_replace($in, $out, $text);\n\n        // BBCode to find...\n        $in = array( \t '/\\[b\\](.*?)\\[\\/b\\]/ms',\n            '/\\[i\\](.*?)\\[\\/i\\]/ms',\n            '/\\[u\\](.*?)\\[\\/u\\]/ms',\n            '/\\[mark\\](.*?)\\[\\/mark\\]/ms',\n            '/\\[s\\](.*?)\\[\\/s\\]/ms',\n            '/\\[list\\=([0-9]+)\\](.*?)\\[\\/list\\]/ms',\n            '/\\[list\\](.*?)\\[\\/list\\]/ms',\n            '/\\[\\*\\]\\s?(.*?)\\n/ms',\n            '/\\[fs([0-9]+)\\](.*?)\\[\\/fs\\]/ms',\n            '/\\[color\\=([A-Za-z0-9]{2,6})\\](.*?)\\[\\/color\\]/ms'\n        );\n\n        // And replace them by...\n        $out = array(\t '\\1',\n            '\\1',\n            '\\1',\n            '\\1',\n            '\\1',\n            '\\2',\n            '\\1',\n            '\\1',\n            '\\2',\n            '\\2'\n        );\n\n        $text = preg_replace($in, $out, $text);\n\n        // Prepare quote's\n        $text = str_replace(\"\\r\\n\",\"\\n\",$text);\n\n        // paragraphs\n        $text = str_replace(\"\\r\", \"\", $text);\n\n        return $text;\n    }\n\n    public static function _make_url_embed_image($matches) {\n\n        $in = htmlspecialchars_decode($matches[2]);\n        $in = trim($in);\n\n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return $matches[2];\n\n        $prepend = '';\n\n        if (isset($matches[1]) && $matches[1] != '' && !empty(self::esc_url($matches[1]))) {\n            $prepend = $matches[1];\n        }\n\n        return  $prepend . ' ' . $url;\n    }\n\n    public static function _make_embed_map($matches)\n    {\n        $parts = explode(',',trim($matches[1]));\n\n        if (count($parts) == 2 && is_numeric($parts[0]) && is_numeric($parts[1])) {\n            $id = rand(0,1000) . time();\n            return \"<div id='msg-location-\".$id.\"' style='height:300px'><script>lhinst.showMessageLocation(\" . $id . \",\" . (float)$parts[0] . \",\" . (float)$parts[1] . \")</script></div>\";\n        }\n\n        return ;\n    }\n\n    public static function _make_url_embed($matches){\n\n        $in = str_replace('\"','',htmlspecialchars_decode($matches[1]));\n        $in = trim($in);\n\n        $url = self::esc_url($in);\n        if ( empty($url) )\n            return $matches[1] . ' ' . $matches[2];\n\n        return $url .' '. $matches[2];\n    }\n\n    /**\n     * Callback to convert URL match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with URL address.\n     */\n    public static function _make_web_ftp_clickable_cb( $matches ) {\n        $ret = '';\n        $dest = $matches[2];\n        $dest = 'http://' . $dest;\n        // removed trailing [.,;:)] from URL\n        if ( in_array( substr($dest, -1), array('.', ',', ';', ':', ')') ) === true ) {\n            $ret = substr($dest, -1);\n            $dest = substr($dest, 0, strlen($dest)-1);\n        }\n        $dest = self::esc_url($dest);\n        if ( empty($dest) )\n            return $matches[0];\n\n        return $matches[1] . $dest . ' ' . $ret;\n    }\n\n    /**\n     * Callback to convert email address match to HTML A element.\n     *\n     * This function was backported from 2.5.0 to 2.3.2. Regex callback for make_clickable().\n     *\n     * @since 2.3.2\n     * @access private\n     *\n     * @param array $matches Single Regex Match.\n     * @return string HTML A element with email address.\n     */\n    public static function _make_email_clickable_cb( $matches ) {\n        $email = $matches[2] . '@' . $matches[3];\n        return $matches[1] . ' ' . $email;\n    }\n\n\n    public static function _make_paypal_button($matches){\n\n        if (filter_var($matches[1],FILTER_VALIDATE_EMAIL)) {\n            return '<form action=\"https://www.paypal.com/cgi-bin/webscr\" method=\"post\">\n            <input type=\"hidden\" name=\"cmd\" value=\"_donations\">\n            <input type=\"hidden\" name=\"business\" value=\"'.$matches[1].'\">\n            <input type=\"hidden\" name=\"lc\" value=\"US\">\n            <input type=\"hidden\" name=\"no_note\" value=\"0\">\n            <input type=\"hidden\" name=\"currency_code\" value=\"USD\">\n            <input type=\"hidden\" name=\"bn\" value=\"PP-DonationsBF:btn_donate_SM.gif:NonHostedGuest\">\n            <input type=\"image\" title=\"Support an artist\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/btn/btn_donate_SM.gif\" border=\"0\" name=\"submit\" alt=\"PayPal - The safer, easier way to pay online!\">\n            <img alt=\"\" border=\"0\" src=\"https://www.paypalobjects.com/WEBSCR-640-20110306-1/en_US/i/scr/pixel.gif\" width=\"1\" height=\"1\">\n            </form>';\n        } else {\n            return $matches[0];\n        }\n    }\n\n    public static function _make_youtube_block($matches) {\n\n        $data = parse_url($matches[1]);\n\n        if (isset($data['query'])){\n            parse_str($data['query'],$query);\n            if (stristr($data['host'],'youtube.com') && isset($query['v']) && ($query['v'] != '')) {\n                return '<iframe class=\"youtube-frame\" title=\"YouTube video player\" width=\"480\" height=\"300\" src=\"https://www.youtube.com/embed/'.urlencode($query['v']).'\" frameborder=\"0\" allowfullscreen></iframe>';\n            } else {\n                return $matches[0];\n            }\n        } else {\n            return $matches[0];\n        }\n    }\n\n    public static function _make_url_file($matches)\n    {\n\n        if (isset($matches[1])){\n            $mainData = explode(' ',$matches[1]);\n            $parts = explode('_',$mainData[0]);\n            $fileID = $parts[0];\n            $hash = $parts[1];\n            $displayType = isset($parts[2]) ? $parts[2] : null;\n            try {\n                $file = erLhcoreClassModelChatFile::fetch($fileID);\n\n                if (is_object($file)) {\n                    // Check that user has permission to see the chat. Let say if user purposely types file bbcode\n                    if ($hash == $file->security_hash) {\n                        $fileExtension = strtolower($file->extension);\n                        if ($fileExtension == 'jpg' || $fileExtension == 'jpeg' || $fileExtension == 'png' || $fileExtension == 'gif'){\n\n                            // Make link if required\n                            $prepend = '';\n                            $append = '';\n                            if (isset($mainData[1])) {\n                                $subpartParts = explode('=',$mainData[1]);\n                                if ($subpartParts[0] == 'link') {\n                                    $url = self::esc_url($subpartParts[1]);\n                                    if ($url != ''){\n                                        $prepend = self::esc_url($subpartParts[1]);\n                                        $append = '';\n                                    }\n                                }\n                            } else {\n                                $prepend = '';\n                                $append = (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . '//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\";\n                            }\n\n                            return $prepend . $append;\n                        }\n\n                        if ($fileExtension == 'mp3' || $fileExtension == 'wav' || $fileExtension == 'ogg') {\n                            return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . '//'. $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash}\";\n                        }\n\n                        return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . \"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('file/downloadfile') . \"/{$file->id}/{$hash} {$file->upload_name}\" . ' [' . $file->extension . ']';\n                    }\n                }\n\n            } catch (Exception $e) {\n\n            }\n\n            return '';\n        }\n        return '';\n    }\n\n    public static function _make_url_survey($matches)\n    {\n        if (isset($matches[1])){\n\n            list($surveyId, $surveyItemId) = explode('_',str_replace(array('\"','&quot;'),'', $matches[1]));\n\n            try {\n\n                if (is_numeric($surveyItemId) && is_numeric($surveyId)) {\n\n                    $surveyItem = erLhAbstractModelSurveyItem::fetch($surveyItemId);\n\n                    if ($surveyId == $surveyItem->survey_id)\n                    {\n                        $survey = erLhAbstractModelSurvey::fetch($surveyId);\n                        return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . \"//\" . $_SERVER['HTTP_HOST'] . erLhcoreClassDesign::baseurl('survey/collected').\"/{$survey->id}?show={$surveyItem->id}\" . erTranslationClassLhTranslation::getInstance()->getTranslation('file/file','Collected survey data') . ' - ' . htmlspecialchars($survey->name);\n                    }\n                }\n\n            } catch (Exception $e) {\n\n            }\n\n            return '';\n        }\n        return '';\n    }\n\n    public static function _make_url_mail_file($matches){\n\n        if (isset($matches[1])){\n            list($fileID,$hash) = explode('_',$matches[1]);\n            try {\n                $file = erLhcoreClassModelChatFile::fetch($fileID);\n\n                // Check that user has permission to see the chat. Let say if user purposely types file bbcode\n                if ($hash == $file->security_hash) {\n                    return (erLhcoreClassSystem::$httpsMode == true ? 'https:' : 'http:') . '//' . $_SERVER['HTTP_HOST'].erLhcoreClassDesign::baseurldirect('file/downloadfile').\"/{$file->id}/{$hash}\";\n                }\n            } catch (Exception $e) {\n\n            }\n\n            return '';\n        }\n        return '';\n    }\n\n    public static function _split_str_by_whitespace( $string, $goal ) {\n        $chunks = array();\n\n        $string_nullspace = strtr( $string, \"\\r\\n\\t\\v\\f \", \"\\000\\000\\000\\000\\000\\000\" );\n\n        while ( $goal < strlen( $string_nullspace ) ) {\n            $pos = strrpos( substr( $string_nullspace, 0, $goal + 1 ), \"\\000\" );\n\n            if ( false === $pos ) {\n                $pos = strpos( $string_nullspace, \"\\000\", $goal + 1 );\n                if ( false === $pos ) {\n                    break;\n                }\n            }\n\n            $chunks[] = substr( $string, 0, $pos + 1 );\n            $string = substr( $string, $pos + 1 );\n            $string_nullspace = substr( $string_nullspace, $pos + 1 );\n        }\n\n        if ( $string ) {\n            $chunks[] = $string;\n        }\n\n        return $chunks;\n    }\n\n    // https://github.com/WordPress/WordPress/blob/6e5e29c5bf49ad2be6a2c3a3d4fb3f5af6853b5b/wp-includes/formatting.php\n    public static function make_clickable_text( $text ) {\n        $r = '';\n        $textarr = preg_split( '/(<[^<>]+>)/', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // split out HTML tags\n        $nested_code_pre = 0; // Keep track of how many levels link is nested inside <pre> or <code>\n        foreach ( $textarr as $piece ) {\n            if ( preg_match( '|^<code[\\s>]|i', $piece ) || preg_match( '|^<pre[\\s>]|i', $piece ) || preg_match( '|^<script[\\s>]|i', $piece ) || preg_match( '|^<style[\\s>]|i', $piece ) )\n                $nested_code_pre++;\n            elseif ( $nested_code_pre && ( '</code>' === strtolower( $piece ) || '</pre>' === strtolower( $piece ) || '</script>' === strtolower( $piece ) || '</style>' === strtolower( $piece ) ) )\n                $nested_code_pre--;\n            if ( $nested_code_pre || empty( $piece ) || ( $piece[0] === '<' && ! preg_match( '|^<\\s*[\\w]{1,20}+://|', $piece ) ) ) {\n                $r .= $piece;\n                continue;\n            }\n            // Long strings might contain expensive edge cases ...\n            if ( 10000 < strlen( $piece ) ) {\n                // ... break it up\n                foreach ( self::_split_str_by_whitespace( $piece, 2100 ) as $chunk ) { // 2100: Extra room for scheme and leading and trailing paretheses\n                    if ( 2101 < strlen( $chunk ) ) {\n                        $r .= $chunk; // Too big, no whitespace: bail.\n                    } else {\n                        $r .= self::make_clickable_text( $chunk );\n                    }\n                }\n            } else {\n                $ret = \" $piece \"; // Pad with whitespace to simplify the regexes\n                $url_clickable = '~\n\t\t\t\t([\\\\s(<.,;:!?])                                        # 1: Leading whitespace, or punctuation\n\t\t\t\t(                                                      # 2: URL\n\t\t\t\t\t[\\\\w]{1,20}+://                                # Scheme and hier-part prefix\n\t\t\t\t\t(?=\\S{1,2000}\\s)                               # Limit to URLs less than about 2000 characters long\n\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]*+         # Non-punctuation URL character\n\t\t\t\t\t(?:                                            # Unroll the Loop: Only allow puctuation URL character if followed by a non-punctuation URL character\n\t\t\t\t\t\t[\\'.,;:!?)]                            # Punctuation URL character\n\t\t\t\t\t\t[\\\\w\\\\x80-\\\\xff#%\\\\~/@\\\\[\\\\]*(+=&$-]++ # Non-punctuation URL character\n\t\t\t\t\t)*\n\t\t\t\t)\n\t\t\t\t(\\)?)                                                  # 3: Trailing closing parenthesis (for parethesis balancing post processing)\n\t\t\t~xS'; // The regex is a non-anchored pattern and does not have a single fixed starting character.\n                // Tell PCRE to spend more time optimizing since, when used on a page load, it will probably be used several times.\n                $ret = preg_replace_callback( $url_clickable, 'erLhcoreClassBBCodePlain::_make_url_clickable_cb', $ret );\n                $ret = preg_replace_callback( '#([\\s>])((www|ftp)\\.[\\w\\\\x80-\\\\xff\\#$%&~/.\\-;:=,?@\\[\\]+]+)#is', 'erLhcoreClassBBCodePlain::_make_web_ftp_clickable_cb', $ret );\n                $ret = preg_replace_callback( '#([\\s>])([.0-9a-z_+-]+)@(([0-9a-z-]+\\.)+[0-9a-z]{2,})#i', 'erLhcoreClassBBCodePlain::_make_email_clickable_cb', $ret );\n                $ret = substr( $ret, 1, -1 ); // Remove our whitespace padding.\n                $r .= $ret;\n            }\n        }\n\n        // Cleanup of accidental links within links\n        return preg_replace( '#(<a([ \\r\\n\\t]+[^>]+?>|>))<a [^>]+?>([^>]+?)</a></a>#i', \"$1$3</a>\", $r );\n    }\n\n    public static function makeQuote($matches)\n    {\n        if ($matches[1]) {\n            return '<blockquote class=\"blockquote\"> ' . $matches[1] . ' </blockquote>';\n        } else {\n            return $matches[0];\n        }\n    }\n\n    public static function extractMetaByMessage(& $msg) {\n        $meta = array();\n        if (strpos($msg,'[html_snippet]') !== false) {\n            $matches = array();\n            preg_match_all('/\\[html_snippet\\](.*?)\\[\\/html_snippet\\]/is',$msg,$matches);\n            foreach ($matches[0] as $index => $match) {\n                $msg = str_replace($match,'',$msg);\n                $meta['html_snippet'][] = $matches[1][$index];\n            }\n        }\n        return $meta;\n    }\n\n    // Converts bbcode and general links to hmtl code\n    public static function make_clickable($ret, $paramsMessage = array()) {\n        $ret = ' ' . $ret;\n\n        $makeLinksClickable = true;\n\n        $ret = preg_replace_callback('/\\[img=?(.*?)\\](.*?)\\[\\/img\\]/ms', \"erLhcoreClassBBCodePlain::_make_url_embed_image\", $ret);\n\n        $ret = preg_replace_callback('/\\[loc\\](.*?)\\[\\/loc\\]/ms', \"erLhcoreClassBBCodePlain::_make_embed_map\", $ret);\n\n        $ret = preg_replace_callback('/\\[url\\=\"?(.*?)\"?\\](.*?)\\[\\/url\\]/ms', \"erLhcoreClassBBCodePlain::_make_url_embed\", $ret);\n\n        if (isset($paramsMessage['sender']) && $paramsMessage['sender'] == 0) {\n            $ret = preg_replace('/\\[html\\](.*?)\\[\\/html\\]/ms','',$ret);\n        }\n\n        $ret = preg_replace_callback('/\\[html\\](.*?)\\[\\/html\\]/ms', function ($matches) {\n            $html = htmlspecialchars_decode($matches[1]);\n\n            $html = preg_replace_callback('/\"window\\.parent\\.(.*)\"/ms',function ($matches){\n                return \"'lhinst.executeRemoteCommands([\\\"lhc_eval:\" . $matches[1] . \"\\\"])'\";\n            },$html);\n\n            return $html;\n\n        }, $ret);\n\n\n        if ($makeLinksClickable) {\n            $ret = self::make_clickable_text($ret);\n        }\n\n        $ret = self::BBCode2Html($ret);\n\n        // Paypal button\n        $ret = preg_replace_callback('#\\[paypal\\](.*?)\\[/paypal\\]#is', 'erLhcoreClassBBCodePlain::_make_paypal_button', $ret);\n\n        // Quote\n        $ret = preg_replace_callback('#\\[quote\\](.*?)\\[/quote\\]#is', 'erLhcoreClassBBCodePlain::makeQuote', $ret);\n\n        // Youtube block\n        $ret = preg_replace_callback('#\\[youtube\\](.*?)\\[/youtube\\]#is', 'erLhcoreClassBBCodePlain::_make_youtube_block', $ret);\n\n        $ret = preg_replace('#\\[translation\\](.*?)\\[/translation\\]#is', '<span class=\"tr-msg\">$1</span>', $ret);\n\n        // File block\n        $ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCodePlain::_make_url_file', $ret);\n\n        // Survey\n        $ret = preg_replace_callback('#\\[survey=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCodePlain::_make_url_survey', $ret);\n\n        $ret = trim($ret);\n\n        return $ret;\n    }\n\n    public static function parseForMail($ret){\n        // File block\n        $ret = preg_replace_callback('#\\[file=\"?(.*?)\"?\\]#is', 'erLhcoreClassBBCodePlain::_make_url_mail_file', $ret);\n        return trim($ret);\n    }\n\n}\n\n\n?>"], "filenames": ["lhc_web/lib/core/lhbbcode/lhbbcode.php", "lhc_web/lib/core/lhbbcode/lhbbcode_cleanup.php"], "buggy_code_start_loc": [620, 619], "buggy_code_end_loc": [625, 624], "fixing_code_start_loc": [620, 619], "fixing_code_end_loc": [625, 624], "type": "CWE-79", "message": "Live Helper Chat before 3.44v allows reflected XSS via the setsettingajax PATH_INFO.", "other": {"cve": {"id": "CVE-2020-26135", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-02T09:15:14.040", "lastModified": "2021-11-30T22:27:45.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Live Helper Chat before 3.44v allows reflected XSS via the setsettingajax PATH_INFO."}, {"lang": "es", "value": "Live Helper Chat versiones anteriores a 3.44v, permite un ataque de tipo XSS reflejado por medio de PATH_INFO de la funci\u00f3n setsettingajax"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:livehelperchat:live_helper_chat:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.44", "matchCriteriaId": "70AF56B3-6672-4C59-A134-77CBD37E3CD9"}]}]}], "references": [{"url": "https://github.com/LiveHelperChat/livehelperchat/commit/a131b937dd6a87271ed1c0c8b8deb8710cf78f58", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rekter0/exploits/tree/master/CVE-2020-26134", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://livehelperchat.com/3.44v-security-update-and-few-other-bits-586a.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.arista.com/en/support/advisories-notices/security-advisories/12602-security-advisory-63", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LiveHelperChat/livehelperchat/commit/a131b937dd6a87271ed1c0c8b8deb8710cf78f58"}}