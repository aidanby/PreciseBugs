{"buggy_code": ["__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport base64\nimport datetime\nimport logging\nimport os\nimport re\nfrom collections import defaultdict\n\nfrom flask import (\n    Response,\n    abort,\n    g,\n    make_response,\n    redirect,\n    render_template,\n    request,\n    send_from_directory,\n    url_for,\n)\n\nimport octoprint.plugin\nfrom octoprint.access.permissions import OctoPrintPermission, Permissions\nfrom octoprint.filemanager import full_extension_tree, get_all_extensions\nfrom octoprint.server import (  # noqa: F401\n    BRANCH,\n    DISPLAY_VERSION,\n    LOCALES,\n    NOT_MODIFIED,\n    VERSION,\n    app,\n    debug,\n    gettext,\n    groupManager,\n    pluginManager,\n    preemptiveCache,\n    userManager,\n)\nfrom octoprint.server.util import has_permissions, require_login_with\nfrom octoprint.settings import settings\nfrom octoprint.util import sv, to_bytes, to_unicode\nfrom octoprint.util.version import get_python_version_string\n\nfrom . import util\n\n_logger = logging.getLogger(__name__)\n\n_templates = {}\n_plugin_names = None\n_plugin_vars = None\n\n_valid_id_re = re.compile(\"[a-z_]+\")\n_valid_div_re = re.compile(\"[a-zA-Z_-]+\")\n\n\ndef _preemptive_unless(base_url=None, additional_unless=None):\n    if base_url is None:\n        base_url = request.url_root\n\n    disabled_for_root = (\n        not settings().getBoolean([\"devel\", \"cache\", \"preemptive\"])\n        or base_url in settings().get([\"server\", \"preemptiveCache\", \"exceptions\"])\n        or not (base_url.startswith(\"http://\") or base_url.startswith(\"https://\"))\n    )\n\n    recording_disabled = request.headers.get(\"X-Preemptive-Recording\", \"no\") == \"yes\"\n\n    if callable(additional_unless):\n        return recording_disabled or disabled_for_root or additional_unless()\n    else:\n        return recording_disabled or disabled_for_root\n\n\ndef _preemptive_data(\n    key, path=None, base_url=None, data=None, additional_request_data=None\n):\n    if path is None:\n        path = request.path\n    if base_url is None:\n        base_url = request.url_root\n\n    d = {\n        \"path\": path,\n        \"base_url\": base_url,\n        \"query_string\": \"l10n={}\".format(g.locale.language if g.locale else \"en\"),\n    }\n\n    if key != \"_default\":\n        d[\"plugin\"] = key\n\n    # add data if we have any\n    if data is not None:\n        try:\n            if callable(data):\n                data = data()\n            if data:\n                if \"query_string\" in data:\n                    data[\"query_string\"] = \"l10n={}&{}\".format(\n                        g.locale.language, data[\"query_string\"]\n                    )\n                d.update(data)\n        except Exception:\n            _logger.exception(\n                f\"Error collecting data for preemptive cache from plugin {key}\"\n            )\n\n    # add additional request data if we have any\n    if callable(additional_request_data):\n        try:\n            ard = additional_request_data()\n            if ard:\n                d.update({\"_additional_request_data\": ard})\n        except Exception:\n            _logger.exception(\n                \"Error retrieving additional data for preemptive cache from plugin {}\".format(\n                    key\n                )\n            )\n\n    return d\n\n\ndef _cache_key(ui, url=None, locale=None, additional_key_data=None):\n    if url is None:\n        url = request.base_url\n    if locale is None:\n        locale = g.locale.language if g.locale else \"en\"\n\n    k = f\"ui:{ui}:{url}:{locale}\"\n    if callable(additional_key_data):\n        try:\n            ak = additional_key_data()\n            if ak:\n                # we have some additional key components, let's attach them\n                if not isinstance(ak, (list, tuple)):\n                    ak = [ak]\n                k = \"{}:{}\".format(k, \":\".join(ak))\n        except Exception:\n            _logger.exception(\n                \"Error while trying to retrieve additional cache key parts for ui {}\".format(\n                    ui\n                )\n            )\n    return k\n\n\ndef _valid_status_for_cache(status_code):\n    return 200 <= status_code < 400\n\n\ndef _add_additional_assets(hook):\n    result = []\n    for name, hook in pluginManager.get_hooks(hook).items():\n        try:\n            assets = hook()\n            if isinstance(assets, (tuple, list)):\n                result += assets\n        except Exception:\n            _logger.exception(\n                f\"Error fetching theming CSS to include from plugin {name}\",\n                extra={\"plugin\": name},\n            )\n    return result\n\n\n@app.route(\"/login\")\n@app.route(\"/login/\")\ndef login():\n    from flask_login import current_user\n\n    redirect_url = request.args.get(\"redirect\", request.script_root + url_for(\"index\"))\n    permissions = sorted(\n        filter(\n            lambda x: x is not None and isinstance(x, OctoPrintPermission),\n            map(\n                lambda x: getattr(Permissions, x.strip()),\n                request.args.get(\"permissions\", \"\").split(\",\"),\n            ),\n        ),\n        key=lambda x: x.get_name(),\n    )\n    if not permissions:\n        permissions = [Permissions.STATUS, Permissions.SETTINGS_READ]\n\n    user_id = request.args.get(\"user_id\", \"\")\n\n    if (not user_id or current_user.get_id() == user_id) and has_permissions(\n        *permissions\n    ):\n        return redirect(redirect_url)\n\n    render_kwargs = {\n        \"theming\": [],\n        \"redirect_url\": redirect_url,\n        \"permission_names\": map(lambda x: x.get_name(), permissions),\n        \"user_id\": user_id,\n        \"logged_in\": not current_user.is_anonymous,\n    }\n\n    try:\n        additional_assets = _add_additional_assets(\"octoprint.theming.login\")\n\n        # backwards compatibility to forcelogin & loginui plugins which were replaced by this built-in dialog\n        additional_assets += _add_additional_assets(\"octoprint.plugin.forcelogin.theming\")\n        additional_assets += _add_additional_assets(\"octoprint.plugin.loginui.theming\")\n\n        render_kwargs.update({\"theming\": additional_assets})\n    except Exception:\n        _logger.exception(\"Error processing theming CSS, ignoring\")\n\n    return render_template(\"login.jinja2\", **render_kwargs)\n\n\n@app.route(\"/recovery\")\n@app.route(\"/recovery/\")\ndef recovery():\n    response = require_login_with(permissions=[Permissions.ADMIN])\n    if response:\n        return response\n\n    render_kwargs = {\"theming\": []}\n\n    try:\n        additional_assets = _add_additional_assets(\"octoprint.theming.recovery\")\n        render_kwargs.update({\"theming\": additional_assets})\n    except Exception:\n        _logger.exception(\"Error processing theming CSS, ignoring\")\n\n    try:\n        from octoprint.plugins.backup import MAX_UPLOAD_SIZE\n        from octoprint.util import get_formatted_size\n\n        render_kwargs.update(\n            {\n                \"plugin_backup_max_upload_size\": MAX_UPLOAD_SIZE,\n                \"plugin_backup_max_upload_size_str\": get_formatted_size(MAX_UPLOAD_SIZE),\n            }\n        )\n    except Exception:\n        _logger.exception(\"Error adding backup upload size info, ignoring\")\n\n    return render_template(\"recovery.jinja2\", **render_kwargs)\n\n\n@app.route(\"/cached.gif\")\ndef in_cache():\n    url = request.base_url.replace(\"/cached.gif\", \"/\")\n    path = request.path.replace(\"/cached.gif\", \"/\")\n    base_url = request.url_root\n\n    # select view from plugins and fall back on default view if no plugin will handle it\n    ui_plugins = pluginManager.get_implementations(\n        octoprint.plugin.UiPlugin, sorting_context=\"UiPlugin.on_ui_render\"\n    )\n    for plugin in ui_plugins:\n        try:\n            if plugin.will_handle_ui(request):\n                ui = plugin._identifier\n                key = _cache_key(\n                    plugin._identifier,\n                    url=url,\n                    additional_key_data=plugin.get_ui_additional_key_data_for_cache,\n                )\n                unless = _preemptive_unless(\n                    url,\n                    additional_unless=plugin.get_ui_preemptive_caching_additional_unless,\n                )\n                data = _preemptive_data(\n                    plugin._identifier,\n                    path=path,\n                    base_url=base_url,\n                    data=plugin.get_ui_data_for_preemptive_caching,\n                    additional_request_data=plugin.get_ui_additional_request_data_for_preemptive_caching,\n                )\n                break\n        except Exception:\n            _logger.exception(\n                f\"Error while calling plugin {plugin._identifier}, skipping it\",\n                extra={\"plugin\": plugin._identifier},\n            )\n    else:\n        ui = \"_default\"\n        key = _cache_key(\"_default\", url=url)\n        unless = _preemptive_unless(url)\n        data = _preemptive_data(\"_default\", path=path, base_url=base_url)\n\n    response = make_response(\n        bytes(\n            base64.b64decode(\"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\")\n        )\n    )\n    response.headers[\"Content-Type\"] = \"image/gif\"\n\n    if unless or not preemptiveCache.has_record(data, root=path):\n        _logger.info(\n            \"Preemptive cache not active for path {}, ui {} and data {!r}, signaling as cached\".format(\n                path, ui, data\n            )\n        )\n        return response\n    elif util.flask.is_in_cache(key):\n        _logger.info(f\"Found path {path} in cache (key: {key}), signaling as cached\")\n        return response\n    elif util.flask.is_cache_bypassed(key):\n        _logger.info(\n            \"Path {} was bypassed from cache (key: {}), signaling as cached\".format(\n                path, key\n            )\n        )\n        return response\n    else:\n        _logger.debug(f\"Path {path} not yet cached (key: {key}), signaling as missing\")\n        return abort(404)\n\n\n@app.route(\"/\")\ndef index():\n    from octoprint.server import connectivityChecker, printer\n\n    global _templates, _plugin_names, _plugin_vars\n\n    preemptive_cache_enabled = settings().getBoolean([\"devel\", \"cache\", \"preemptive\"])\n\n    locale = g.locale.language if g.locale else \"en\"\n\n    # helper to check if wizards are active\n    def wizard_active(templates):\n        return templates is not None and bool(templates[\"wizard\"][\"order\"])\n\n    # we force a refresh if the client forces one and we are not printing or if we have wizards cached\n    client_refresh = util.flask.cache_check_headers()\n    request_refresh = \"_refresh\" in request.values\n    printing = printer.is_printing()\n    if client_refresh and printing:\n        logging.getLogger(__name__).warning(\n            \"Client requested cache refresh via cache-control headers but we are printing. \"\n            \"Not invalidating caches due to resource limitation. Append ?_refresh=true to \"\n            \"the URL if you absolutely require a refresh now\"\n        )\n    client_refresh = client_refresh and not printing\n    force_refresh = (\n        client_refresh or request_refresh or wizard_active(_templates.get(locale))\n    )\n\n    # if we need to refresh our template cache or it's not yet set, process it\n    fetch_template_data(refresh=force_refresh)\n\n    now = datetime.datetime.utcnow()\n\n    enable_timelapse = settings().getBoolean([\"webcam\", \"timelapseEnabled\"])\n    enable_loading_animation = settings().getBoolean([\"devel\", \"showLoadingAnimation\"])\n    enable_sd_support = settings().get([\"feature\", \"sdSupport\"])\n    enable_webcam = settings().getBoolean([\"webcam\", \"webcamEnabled\"]) and bool(\n        settings().get([\"webcam\", \"stream\"])\n    )\n    enable_temperature_graph = settings().get([\"feature\", \"temperatureGraph\"])\n    sockjs_connect_timeout = settings().getInt([\"devel\", \"sockJsConnectTimeout\"])\n\n    def default_template_filter(template_type, template_key):\n        if template_type == \"tab\":\n            return template_key != \"timelapse\" or enable_timelapse\n        else:\n            return True\n\n    default_additional_etag = [\n        enable_timelapse,\n        enable_loading_animation,\n        enable_sd_support,\n        enable_webcam,\n        enable_temperature_graph,\n        sockjs_connect_timeout,\n        connectivityChecker.online,\n        wizard_active(_templates.get(locale)),\n    ] + sorted(\n        \"{}:{}\".format(to_unicode(k, errors=\"replace\"), to_unicode(v, errors=\"replace\"))\n        for k, v in _plugin_vars.items()\n    )\n\n    def get_preemptively_cached_view(\n        key, view, data=None, additional_request_data=None, additional_unless=None\n    ):\n        if (data is None and additional_request_data is None) or g.locale is None:\n            return view\n\n        d = _preemptive_data(\n            key, data=data, additional_request_data=additional_request_data\n        )\n\n        def unless():\n            return _preemptive_unless(\n                base_url=request.url_root, additional_unless=additional_unless\n            )\n\n        # finally decorate our view\n        return util.flask.preemptively_cached(\n            cache=preemptiveCache, data=d, unless=unless\n        )(view)\n\n    def get_cached_view(\n        key,\n        view,\n        additional_key_data=None,\n        additional_files=None,\n        additional_etag=None,\n        custom_files=None,\n        custom_etag=None,\n        custom_lastmodified=None,\n    ):\n        if additional_etag is None:\n            additional_etag = []\n\n        def cache_key():\n            return _cache_key(key, additional_key_data=additional_key_data)\n\n        def collect_files():\n            if callable(custom_files):\n                try:\n                    files = custom_files()\n                    if files:\n                        return files\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve tracked files for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            files = _get_all_templates()\n            files += _get_all_assets()\n            files += _get_all_translationfiles(\n                g.locale.language if g.locale else \"en\", \"messages\"\n            )\n\n            if callable(additional_files):\n                try:\n                    af = additional_files()\n                    if af:\n                        files += af\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve additional tracked files for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            return sorted(set(files))\n\n        def compute_lastmodified(files):\n            if callable(custom_lastmodified):\n                try:\n                    lastmodified = custom_lastmodified()\n                    if lastmodified:\n                        return lastmodified\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve custom LastModified value for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            return _compute_date(files)\n\n        def compute_etag(files, lastmodified, additional=None):\n            if callable(custom_etag):\n                try:\n                    etag = custom_etag()\n                    if etag:\n                        return etag\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve custom ETag value for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            if lastmodified and not isinstance(lastmodified, str):\n                from werkzeug.http import http_date\n\n                lastmodified = http_date(lastmodified)\n            if additional is None:\n                additional = []\n\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                hash.update(to_bytes(value, encoding=\"utf-8\", errors=\"replace\"))\n\n            hash_update(octoprint.__version__)\n            hash_update(get_python_version_string())\n            hash_update(\",\".join(sorted(files)))\n            if lastmodified:\n                hash_update(lastmodified)\n            for add in additional:\n                hash_update(add)\n            return hash.hexdigest()\n\n        current_files = collect_files()\n        current_lastmodified = compute_lastmodified(current_files)\n        current_etag = compute_etag(\n            files=current_files,\n            lastmodified=current_lastmodified,\n            additional=[cache_key()] + additional_etag,\n        )\n\n        def check_etag_and_lastmodified():\n            lastmodified_ok = util.flask.check_lastmodified(current_lastmodified)\n            etag_ok = util.flask.check_etag(current_etag)\n            return lastmodified_ok and etag_ok\n\n        def validate_cache(cached):\n            return force_refresh or (current_etag != cached.get_etag()[0])\n\n        decorated_view = view\n        decorated_view = util.flask.lastmodified(lambda _: current_lastmodified)(\n            decorated_view\n        )\n        decorated_view = util.flask.etagged(lambda _: current_etag)(decorated_view)\n        decorated_view = util.flask.cached(\n            timeout=-1,\n            refreshif=validate_cache,\n            key=cache_key,\n            unless_response=lambda response: util.flask.cache_check_response_headers(\n                response\n            )\n            or util.flask.cache_check_status_code(response, _valid_status_for_cache),\n        )(decorated_view)\n        decorated_view = util.flask.with_client_revalidation(decorated_view)\n        decorated_view = util.flask.conditional(\n            check_etag_and_lastmodified, NOT_MODIFIED\n        )(decorated_view)\n        return decorated_view\n\n    def plugin_view(p):\n        cached = get_cached_view(\n            p._identifier,\n            p.on_ui_render,\n            additional_key_data=p.get_ui_additional_key_data_for_cache,\n            additional_files=p.get_ui_additional_tracked_files,\n            custom_files=p.get_ui_custom_tracked_files,\n            custom_etag=p.get_ui_custom_etag,\n            custom_lastmodified=p.get_ui_custom_lastmodified,\n            additional_etag=p.get_ui_additional_etag(default_additional_etag),\n        )\n\n        if preemptive_cache_enabled and p.get_ui_preemptive_caching_enabled():\n            view = get_preemptively_cached_view(\n                p._identifier,\n                cached,\n                p.get_ui_data_for_preemptive_caching,\n                p.get_ui_additional_request_data_for_preemptive_caching,\n                p.get_ui_preemptive_caching_additional_unless,\n            )\n        else:\n            view = cached\n\n        template_filter = p.get_ui_custom_template_filter(default_template_filter)\n        if template_filter is not None and callable(template_filter):\n            filtered_templates = _filter_templates(_templates[locale], template_filter)\n        else:\n            filtered_templates = _templates[locale]\n\n        render_kwargs = _get_render_kwargs(\n            filtered_templates, _plugin_names, _plugin_vars, now\n        )\n\n        return view(now, request, render_kwargs)\n\n    def default_view():\n        filtered_templates = _filter_templates(\n            _templates[locale], default_template_filter\n        )\n\n        wizard = wizard_active(filtered_templates)\n        accesscontrol_active = userManager.has_been_customized()\n\n        render_kwargs = _get_render_kwargs(\n            filtered_templates, _plugin_names, _plugin_vars, now\n        )\n        render_kwargs.update(\n            {\n                \"enableWebcam\": enable_webcam,\n                \"enableTemperatureGraph\": enable_temperature_graph,\n                \"enableAccessControl\": True,\n                \"accessControlActive\": accesscontrol_active,\n                \"enableLoadingAnimation\": enable_loading_animation,\n                \"enableSdSupport\": enable_sd_support,\n                \"sockJsConnectTimeout\": sockjs_connect_timeout * 1000,\n                \"wizard\": wizard,\n                \"online\": connectivityChecker.online,\n                \"now\": now,\n            }\n        )\n\n        # no plugin took an interest, we'll use the default UI\n        def make_default_ui():\n            r = make_response(render_template(\"index.jinja2\", **render_kwargs))\n            if wizard:\n                # if we have active wizard dialogs, set non caching headers\n                r = util.flask.add_non_caching_response_headers(r)\n            return r\n\n        cached = get_cached_view(\n            \"_default\", make_default_ui, additional_etag=default_additional_etag\n        )\n        preemptively_cached = get_preemptively_cached_view(\"_default\", cached, {}, {})\n        return preemptively_cached()\n\n    default_permissions = [Permissions.STATUS, Permissions.SETTINGS_READ]\n\n    response = None\n\n    forced_view = request.headers.get(\"X-Force-View\", None)\n\n    if forced_view:\n        # we have view forced by the preemptive cache\n        _logger.debug(f\"Forcing rendering of view {forced_view}\")\n        if forced_view != \"_default\":\n            plugin = pluginManager.get_plugin_info(forced_view, require_enabled=True)\n            if plugin is not None and isinstance(\n                plugin.implementation, octoprint.plugin.UiPlugin\n            ):\n                permissions = plugin.implementation.get_ui_permissions()\n                response = require_login_with(permissions=permissions)\n                if not response:\n                    response = plugin_view(plugin.implementation)\n                    if _logger.isEnabledFor(logging.DEBUG) and isinstance(\n                        response, Response\n                    ):\n                        response.headers[\n                            \"X-Ui-Plugin\"\n                        ] = plugin.implementation._identifier\n        else:\n            response = require_login_with(permissions=default_permissions)\n            if not response:\n                response = default_view()\n                if _logger.isEnabledFor(logging.DEBUG) and isinstance(response, Response):\n                    response.headers[\"X-Ui-Plugin\"] = \"_default\"\n\n    else:\n        # select view from plugins and fall back on default view if no plugin will handle it\n        ui_plugins = pluginManager.get_implementations(\n            octoprint.plugin.UiPlugin, sorting_context=\"UiPlugin.on_ui_render\"\n        )\n        for plugin in ui_plugins:\n            try:\n                if plugin.will_handle_ui(request):\n                    # plugin claims responsibility, let it render the UI\n                    permissions = plugin.get_ui_permissions()\n                    response = require_login_with(permissions=permissions)\n                    if not response:\n                        response = plugin_view(plugin)\n                        if response is not None:\n                            if _logger.isEnabledFor(logging.DEBUG) and isinstance(\n                                response, Response\n                            ):\n                                response.headers[\"X-Ui-Plugin\"] = plugin._identifier\n                            break\n                        else:\n                            _logger.warning(\n                                \"UiPlugin {} returned an empty response\".format(\n                                    plugin._identifier\n                                )\n                            )\n            except Exception:\n                _logger.exception(\n                    \"Error while calling plugin {}, skipping it\".format(\n                        plugin._identifier\n                    ),\n                    extra={\"plugin\": plugin._identifier},\n                )\n        else:\n            response = require_login_with(permissions=default_permissions)\n            if not response:\n                response = default_view()\n                if _logger.isEnabledFor(logging.DEBUG) and isinstance(response, Response):\n                    response.headers[\"X-Ui-Plugin\"] = \"_default\"\n\n    if response is None:\n        return abort(404)\n    return response\n\n\ndef _get_render_kwargs(templates, plugin_names, plugin_vars, now):\n    global _logger\n\n    # ~~ a bunch of settings\n\n    first_run = settings().getBoolean([\"server\", \"firstRun\"])\n\n    locales = {}\n    for loc in LOCALES:\n        try:\n            locales[loc.language] = {\n                \"language\": loc.language,\n                \"display\": loc.display_name,\n                \"english\": loc.english_name,\n            }\n        except Exception:\n            _logger.exception(\"Error while collecting available locales\")\n\n    permissions = [permission.as_dict() for permission in Permissions.all()]\n    filetypes = list(sorted(full_extension_tree().keys()))\n    extensions = list(map(lambda ext: f\".{ext}\", get_all_extensions()))\n\n    # ~~ prepare full set of template vars for rendering\n\n    render_kwargs = {\n        \"debug\": debug,\n        \"firstRun\": first_run,\n        \"version\": {\"number\": VERSION, \"display\": DISPLAY_VERSION, \"branch\": BRANCH},\n        \"python_version\": get_python_version_string(),\n        \"templates\": templates,\n        \"pluginNames\": plugin_names,\n        \"locales\": locales,\n        \"permissions\": permissions,\n        \"supportedFiletypes\": filetypes,\n        \"supportedExtensions\": extensions,\n    }\n    render_kwargs.update(plugin_vars)\n\n    return render_kwargs\n\n\ndef fetch_template_data(refresh=False):\n    global _templates, _plugin_names, _plugin_vars\n\n    locale = g.locale.language if g.locale else \"en\"\n\n    if (\n        not refresh\n        and _templates.get(locale) is not None\n        and _plugin_names is not None\n        and _plugin_vars is not None\n    ):\n        return _templates[locale], _plugin_names, _plugin_vars\n\n    first_run = settings().getBoolean([\"server\", \"firstRun\"])\n\n    ##~~ prepare templates\n\n    templates = defaultdict(lambda: {\"order\": [], \"entries\": {}})\n\n    # rules for transforming template configs to template entries\n    template_rules = {\n        \"navbar\": {\n            \"div\": lambda x: \"navbar_plugin_\" + x,\n            \"template\": lambda x: x + \"_navbar.jinja2\",\n            \"to_entry\": lambda data: data,\n        },\n        \"sidebar\": {\n            \"div\": lambda x: \"sidebar_plugin_\" + x,\n            \"template\": lambda x: x + \"_sidebar.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"tab\": {\n            \"div\": lambda x: \"tab_plugin_\" + x,\n            \"template\": lambda x: x + \"_tab.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"settings\": {\n            \"div\": lambda x: \"settings_plugin_\" + x,\n            \"template\": lambda x: x + \"_settings.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"usersettings\": {\n            \"div\": lambda x: \"usersettings_plugin_\" + x,\n            \"template\": lambda x: x + \"_usersettings.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"wizard\": {\n            \"div\": lambda x: \"wizard_plugin_\" + x,\n            \"template\": lambda x: x + \"_wizard.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"about\": {\n            \"div\": lambda x: \"about_plugin_\" + x,\n            \"template\": lambda x: x + \"_about.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"generic\": {\"template\": lambda x: x + \".jinja2\", \"to_entry\": lambda data: data},\n    }\n\n    # sorting orders\n    def wizard_key_extractor(d, k):\n        if d[1].get(\"_key\", None) == \"plugin_corewizard_acl\":\n            # Ultra special case - we MUST always have the ACL wizard first since otherwise any steps that follow and\n            # that require to access APIs to function will run into errors since those APIs won't work before ACL\n            # has been configured. See also #2140\n            return f\"0:{to_unicode(d[0])}\"\n        elif d[1].get(\"mandatory\", False):\n            # Other mandatory steps come before the optional ones\n            return f\"1:{to_unicode(d[0])}\"\n        else:\n            # Finally everything else\n            return f\"2:{to_unicode(d[0])}\"\n\n    template_sorting = {\n        \"navbar\": {\"add\": \"prepend\", \"key\": None},\n        \"sidebar\": {\"add\": \"append\", \"key\": \"name\"},\n        \"tab\": {\"add\": \"append\", \"key\": \"name\"},\n        \"settings\": {\n            \"add\": \"custom_append\",\n            \"key\": \"name\",\n            \"custom_add_entries\": lambda missing: {\n                \"section_plugins\": (gettext(\"Plugins\"), None)\n            },\n            \"custom_add_order\": lambda missing: [\"section_plugins\"] + missing,\n        },\n        \"usersettings\": {\"add\": \"append\", \"key\": \"name\"},\n        \"wizard\": {\"add\": \"append\", \"key\": \"name\", \"key_extractor\": wizard_key_extractor},\n        \"about\": {\"add\": \"append\", \"key\": \"name\"},\n        \"generic\": {\"add\": \"append\", \"key\": None},\n    }\n\n    hooks = pluginManager.get_hooks(\"octoprint.ui.web.templatetypes\")\n    for name, hook in hooks.items():\n        try:\n            result = hook(dict(template_sorting), dict(template_rules))\n        except Exception:\n            _logger.exception(\n                f\"Error while retrieving custom template type \"\n                f\"definitions from plugin {name}\",\n                extra={\"plugin\": name},\n            )\n        else:\n            if not isinstance(result, list):\n                continue\n\n            for entry in result:\n                if not isinstance(entry, tuple) or not len(entry) == 3:\n                    continue\n\n                key, order, rule = entry\n\n                # order defaults\n                if \"add\" not in order:\n                    order[\"add\"] = \"prepend\"\n                if \"key\" not in order:\n                    order[\"key\"] = \"name\"\n\n                # rule defaults\n                if \"div\" not in rule:\n                    # default div name: <hook plugin>_<template_key>_plugin_<plugin>\n                    div = f\"{name}_{key}_plugin_\"\n                    rule[\"div\"] = lambda x: div + x\n                if \"template\" not in rule:\n                    # default template name: <plugin>_plugin_<hook plugin>_<template key>.jinja2\n                    template = f\"_plugin_{name}_{key}.jinja2\"\n                    rule[\"template\"] = lambda x: x + template\n                if \"to_entry\" not in rule:\n                    # default to_entry assumes existing \"name\" property to be used as label for 2-tuple entry data structure (<name>, <properties>)\n                    rule[\"to_entry\"] = lambda data: (data[\"name\"], data)\n\n                template_rules[\"plugin_\" + name + \"_\" + key] = rule\n                template_sorting[\"plugin_\" + name + \"_\" + key] = order\n    template_types = list(template_rules.keys())\n\n    # navbar\n\n    templates[\"navbar\"][\"entries\"] = {\n        \"offlineindicator\": {\n            \"template\": \"navbar/offlineindicator.jinja2\",\n            \"_div\": \"navbar_offlineindicator\",\n            \"custom_bindings\": False,\n        },\n        \"settings\": {\n            \"template\": \"navbar/settings.jinja2\",\n            \"_div\": \"navbar_settings\",\n            \"styles\": [\"display: none;\"],\n            \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.SETTINGS)\",\n        },\n        \"systemmenu\": {\n            \"template\": \"navbar/systemmenu.jinja2\",\n            \"_div\": \"navbar_systemmenu\",\n            \"classes\": [\"dropdown\"],\n            \"styles\": [\"display: none;\"],\n            \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.SYSTEM)\",\n            \"custom_bindings\": False,\n        },\n        \"login\": {\n            \"template\": \"navbar/login.jinja2\",\n            \"_div\": \"navbar_login\",\n            \"classes\": [\"dropdown\"],\n            \"custom_bindings\": False,\n        },\n    }\n\n    # sidebar\n\n    templates[\"sidebar\"][\"entries\"] = {\n        \"connection\": (\n            gettext(\"Connection\"),\n            {\n                \"template\": \"sidebar/connection.jinja2\",\n                \"_div\": \"connection\",\n                \"icon\": \"signal\",\n                \"styles_wrapper\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.CONNECTION)\",\n                \"template_header\": \"sidebar/connection_header.jinja2\",\n            },\n        ),\n        \"state\": (\n            gettext(\"State\"),\n            {\n                \"template\": \"sidebar/state.jinja2\",\n                \"_div\": \"state\",\n                \"icon\": \"info-circle\",\n                \"styles_wrapper\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.STATUS)\",\n            },\n        ),\n        \"files\": (\n            gettext(\"Files\"),\n            {\n                \"template\": \"sidebar/files.jinja2\",\n                \"_div\": \"files\",\n                \"icon\": \"list\",\n                \"classes_content\": [\"overflow_visible\"],\n                \"template_header\": \"sidebar/files_header.jinja2\",\n                \"styles_wrapper\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.FILES_LIST)\",\n            },\n        ),\n    }\n\n    # tabs\n\n    templates[\"tab\"][\"entries\"] = {\n        \"temperature\": (\n            gettext(\"Temperature\"),\n            {\n                \"template\": \"tabs/temperature.jinja2\",\n                \"_div\": \"temp\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasAnyPermissionKo(access.permissions.STATUS, access.permissions.CONTROL)() && visible()\",\n            },\n        ),\n        \"control\": (\n            gettext(\"Control\"),\n            {\n                \"template\": \"tabs/control.jinja2\",\n                \"_div\": \"control\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasAnyPermissionKo(access.permissions.WEBCAM, access.permissions.CONTROL)\",\n            },\n        ),\n        \"terminal\": (\n            gettext(\"Terminal\"),\n            {\n                \"template\": \"tabs/terminal.jinja2\",\n                \"_div\": \"term\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.MONITOR_TERMINAL)\",\n            },\n        ),\n        \"timelapse\": (\n            gettext(\"Timelapse\"),\n            {\n                \"template\": \"tabs/timelapse.jinja2\",\n                \"_div\": \"timelapse\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.TIMELAPSE_LIST)\",\n            },\n        ),\n    }\n\n    # settings dialog\n\n    templates[\"settings\"][\"entries\"] = {\n        \"section_printer\": (gettext(\"Printer\"), None),\n        \"serial\": (\n            gettext(\"Serial Connection\"),\n            {\n                \"template\": \"dialogs/settings/serialconnection.jinja2\",\n                \"_div\": \"settings_serialConnection\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"printerprofiles\": (\n            gettext(\"Printer Profiles\"),\n            {\n                \"template\": \"dialogs/settings/printerprofiles.jinja2\",\n                \"_div\": \"settings_printerProfiles\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"temperatures\": (\n            gettext(\"Temperatures\"),\n            {\n                \"template\": \"dialogs/settings/temperatures.jinja2\",\n                \"_div\": \"settings_temperature\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"terminalfilters\": (\n            gettext(\"Terminal Filters\"),\n            {\n                \"template\": \"dialogs/settings/terminalfilters.jinja2\",\n                \"_div\": \"settings_terminalFilters\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"gcodescripts\": (\n            gettext(\"GCODE Scripts\"),\n            {\n                \"template\": \"dialogs/settings/gcodescripts.jinja2\",\n                \"_div\": \"settings_gcodeScripts\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"section_features\": (gettext(\"Features\"), None),\n        \"features\": (\n            gettext(\"Features\"),\n            {\n                \"template\": \"dialogs/settings/features.jinja2\",\n                \"_div\": \"settings_features\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"webcam\": (\n            gettext(\"Webcam & Timelapse\"),\n            {\n                \"template\": \"dialogs/settings/webcam.jinja2\",\n                \"_div\": \"settings_webcam\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"api\": (\n            gettext(\"API\"),\n            {\n                \"template\": \"dialogs/settings/api.jinja2\",\n                \"_div\": \"settings_api\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"section_octoprint\": (gettext(\"OctoPrint\"), None),\n        \"accesscontrol\": (\n            gettext(\"Access Control\"),\n            {\n                \"template\": \"dialogs/settings/accesscontrol.jinja2\",\n                \"_div\": \"settings_users\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"folders\": (\n            gettext(\"Folders\"),\n            {\n                \"template\": \"dialogs/settings/folders.jinja2\",\n                \"_div\": \"settings_folders\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"appearance\": (\n            gettext(\"Appearance\"),\n            {\n                \"template\": \"dialogs/settings/appearance.jinja2\",\n                \"_div\": \"settings_appearance\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"server\": (\n            gettext(\"Server\"),\n            {\n                \"template\": \"dialogs/settings/server.jinja2\",\n                \"_div\": \"settings_server\",\n                \"custom_bindings\": False,\n            },\n        ),\n    }\n\n    # user settings dialog\n\n    templates[\"usersettings\"][\"entries\"] = {\n        \"access\": (\n            gettext(\"Access\"),\n            {\n                \"template\": \"dialogs/usersettings/access.jinja2\",\n                \"_div\": \"usersettings_access\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"interface\": (\n            gettext(\"Interface\"),\n            {\n                \"template\": \"dialogs/usersettings/interface.jinja2\",\n                \"_div\": \"usersettings_interface\",\n                \"custom_bindings\": False,\n            },\n        ),\n    }\n\n    # wizard\n\n    if first_run:\n\n        def custom_insert_order(existing, missing):\n            if \"firstrunstart\" in missing:\n                missing.remove(\"firstrunstart\")\n            if \"firstrunend\" in missing:\n                missing.remove(\"firstrunend\")\n\n            return [\"firstrunstart\"] + existing + missing + [\"firstrunend\"]\n\n        template_sorting[\"wizard\"].update(\n            {\n                \"add\": \"custom_insert\",\n                \"custom_insert_entries\": lambda missing: {},\n                \"custom_insert_order\": custom_insert_order,\n            }\n        )\n        templates[\"wizard\"][\"entries\"] = {\n            \"firstrunstart\": (\n                gettext(\"Start\"),\n                {\n                    \"template\": \"dialogs/wizard/firstrun_start.jinja2\",\n                    \"_div\": \"wizard_firstrun_start\",\n                },\n            ),\n            \"firstrunend\": (\n                gettext(\"Finish\"),\n                {\n                    \"template\": \"dialogs/wizard/firstrun_end.jinja2\",\n                    \"_div\": \"wizard_firstrun_end\",\n                },\n            ),\n        }\n\n    # about dialog\n\n    templates[\"about\"][\"entries\"] = {\n        \"about\": (\n            \"About OctoPrint\",\n            {\n                \"template\": \"dialogs/about/about.jinja2\",\n                \"_div\": \"about_about\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"license\": (\n            \"OctoPrint License\",\n            {\n                \"template\": \"dialogs/about/license.jinja2\",\n                \"_div\": \"about_license\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"thirdparty\": (\n            \"Third Party Licenses\",\n            {\n                \"template\": \"dialogs/about/thirdparty.jinja2\",\n                \"_div\": \"about_thirdparty\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"authors\": (\n            \"Authors\",\n            {\n                \"template\": \"dialogs/about/authors.jinja2\",\n                \"_div\": \"about_authors\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"supporters\": (\n            \"Supporters\",\n            {\n                \"template\": \"dialogs/about/supporters.jinja2\",\n                \"_div\": \"about_sponsors\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"systeminfo\": (\n            \"System Information\",\n            {\n                \"template\": \"dialogs/about/systeminfo.jinja2\",\n                \"_div\": \"about_systeminfo\",\n                \"custom_bindings\": False,\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.SYSTEM)\",\n            },\n        ),\n    }\n\n    # extract data from template plugins\n\n    template_plugins = pluginManager.get_implementations(octoprint.plugin.TemplatePlugin)\n\n    plugin_vars = {}\n    plugin_names = set()\n    plugin_aliases = {}\n    seen_wizards = settings().get([\"server\", \"seenWizards\"]) if not first_run else {}\n    for implementation in template_plugins:\n        name = implementation._identifier\n        plugin_names.add(name)\n        wizard_required = False\n        wizard_ignored = False\n\n        try:\n            vars = implementation.get_template_vars()\n            configs = implementation.get_template_configs()\n            if isinstance(implementation, octoprint.plugin.WizardPlugin):\n                wizard_required = implementation.is_wizard_required()\n                wizard_ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(\n                    seen_wizards, implementation\n                )\n        except Exception:\n            _logger.exception(\n                \"Error while retrieving template data for plugin {}, ignoring it\".format(\n                    name\n                ),\n                extra={\"plugin\": name},\n            )\n            continue\n\n        if not isinstance(vars, dict):\n            vars = {}\n        if not isinstance(configs, (list, tuple)):\n            configs = []\n\n        for var_name, var_value in vars.items():\n            plugin_vars[\"plugin_\" + name + \"_\" + var_name] = var_value\n\n        try:\n            includes = _process_template_configs(\n                name, implementation, configs, template_rules\n            )\n        except Exception:\n            _logger.exception(\n                \"Error while processing template configs for plugin {}, ignoring it\".format(\n                    name\n                ),\n                extra={\"plugin\": name},\n            )\n\n        if not wizard_required or wizard_ignored:\n            includes[\"wizard\"] = list()\n\n        for t in template_types:\n            plugin_aliases[t] = {}\n            for include in includes[t]:\n                if t == \"navbar\" or t == \"generic\":\n                    data = include\n                else:\n                    data = include[1]\n\n                key = data[\"_key\"]\n                if \"replaces\" in data:\n                    key = data[\"replaces\"]\n                    plugin_aliases[t][data[\"_key\"]] = data[\"replaces\"]\n                templates[t][\"entries\"][key] = include\n\n    # ~~ order internal templates and plugins\n\n    # make sure that\n    # 1) we only have keys in our ordered list that we have entries for and\n    # 2) we have all entries located somewhere within the order\n\n    for t in template_types:\n        default_order = (\n            settings().get(\n                [\"appearance\", \"components\", \"order\", t], merged=True, config={}\n            )\n            or []\n        )\n        configured_order = (\n            settings().get([\"appearance\", \"components\", \"order\", t], merged=True) or []\n        )\n        configured_disabled = (\n            settings().get([\"appearance\", \"components\", \"disabled\", t]) or []\n        )\n\n        # first create the ordered list of all component ids according to the configured order\n        result = []\n        for x in configured_order:\n            if x in plugin_aliases[t]:\n                x = plugin_aliases[t][x]\n            if (\n                x in templates[t][\"entries\"]\n                and x not in configured_disabled\n                and x not in result\n            ):\n                result.append(x)\n        templates[t][\"order\"] = result\n\n        # now append the entries from the default order that are not already in there\n        templates[t][\"order\"] += [\n            x\n            for x in default_order\n            if x not in templates[t][\"order\"]\n            and x in templates[t][\"entries\"]\n            and x not in configured_disabled\n        ]\n\n        all_ordered = set(templates[t][\"order\"])\n        all_disabled = set(configured_disabled)\n\n        # check if anything is missing, if not we are done here\n        missing_in_order = (\n            set(templates[t][\"entries\"].keys())\n            .difference(all_ordered)\n            .difference(all_disabled)\n        )\n        if len(missing_in_order) == 0:\n            continue\n\n        # works with entries that are dicts and entries that are 2-tuples with the\n        # entry data at index 1\n        def config_extractor(item, key, default_value=None):\n            if isinstance(item, dict) and key in item:\n                return item[key] if key in item else default_value\n            elif (\n                isinstance(item, tuple)\n                and len(item) > 1\n                and isinstance(item[1], dict)\n                and key in item[1]\n            ):\n                return item[1][key] if key in item[1] else default_value\n\n            return default_value\n\n        # finally add anything that's not included in our order yet\n        if template_sorting[t][\"key\"] is not None:\n            # we'll use our config extractor as default key extractor\n            extractor = config_extractor\n\n            # if template type provides custom extractor, make sure its exceptions are handled\n            if \"key_extractor\" in template_sorting[t] and callable(\n                template_sorting[t][\"key_extractor\"]\n            ):\n\n                def create_safe_extractor(extractor):\n                    def f(x, k):\n                        try:\n                            return extractor(x, k)\n                        except Exception:\n                            _logger.exception(\n                                \"Error while extracting sorting keys for template {}\".format(\n                                    t\n                                )\n                            )\n                            return None\n\n                    return f\n\n                extractor = create_safe_extractor(template_sorting[t][\"key_extractor\"])\n\n            sort_key = template_sorting[t][\"key\"]\n\n            def key_func(x):\n                config = templates[t][\"entries\"][x]\n                entry_order = config_extractor(config, \"order\", default_value=None)\n                return (\n                    entry_order is None,\n                    sv(entry_order),\n                    sv(extractor(config, sort_key)),\n                )\n\n            sorted_missing = sorted(missing_in_order, key=key_func)\n        else:\n\n            def key_func(x):\n                config = templates[t][\"entries\"][x]\n                entry_order = config_extractor(config, \"order\", default_value=None)\n                return entry_order is None, sv(entry_order)\n\n            sorted_missing = sorted(missing_in_order, key=key_func)\n\n        if template_sorting[t][\"add\"] == \"prepend\":\n            templates[t][\"order\"] = sorted_missing + templates[t][\"order\"]\n        elif template_sorting[t][\"add\"] == \"append\":\n            templates[t][\"order\"] += sorted_missing\n        elif (\n            template_sorting[t][\"add\"] == \"custom_prepend\"\n            and \"custom_add_entries\" in template_sorting[t]\n            and \"custom_add_order\" in template_sorting[t]\n        ):\n            templates[t][\"entries\"].update(\n                template_sorting[t][\"custom_add_entries\"](sorted_missing)\n            )\n            templates[t][\"order\"] = (\n                template_sorting[t][\"custom_add_order\"](sorted_missing)\n                + templates[t][\"order\"]\n            )\n        elif (\n            template_sorting[t][\"add\"] == \"custom_append\"\n            and \"custom_add_entries\" in template_sorting[t]\n            and \"custom_add_order\" in template_sorting[t]\n        ):\n            templates[t][\"entries\"].update(\n                template_sorting[t][\"custom_add_entries\"](sorted_missing)\n            )\n            templates[t][\"order\"] += template_sorting[t][\"custom_add_order\"](\n                sorted_missing\n            )\n        elif (\n            template_sorting[t][\"add\"] == \"custom_insert\"\n            and \"custom_insert_entries\" in template_sorting[t]\n            and \"custom_insert_order\" in template_sorting[t]\n        ):\n            templates[t][\"entries\"].update(\n                template_sorting[t][\"custom_insert_entries\"](sorted_missing)\n            )\n            templates[t][\"order\"] = template_sorting[t][\"custom_insert_order\"](\n                templates[t][\"order\"], sorted_missing\n            )\n\n    _templates[locale] = templates\n    _plugin_names = plugin_names\n    _plugin_vars = plugin_vars\n\n    return templates, plugin_names, plugin_vars\n\n\ndef _process_template_configs(name, implementation, configs, rules):\n    from jinja2.exceptions import TemplateNotFound\n\n    counters = defaultdict(lambda: 1)\n    includes = defaultdict(list)\n\n    for config in configs:\n        if not isinstance(config, dict):\n            continue\n        if \"type\" not in config:\n            continue\n\n        template_type = config[\"type\"]\n        del config[\"type\"]\n\n        if template_type not in rules:\n            continue\n        rule = rules[template_type]\n\n        data = _process_template_config(\n            name, implementation, rule, config=config, counter=counters[template_type]\n        )\n        if data is None:\n            continue\n\n        includes[template_type].append(rule[\"to_entry\"](data))\n        counters[template_type] += 1\n\n    for template_type in rules:\n        if len(includes[template_type]) == 0:\n            # if no template of that type was added by the config, we'll try to use the default template name\n            rule = rules[template_type]\n            data = _process_template_config(name, implementation, rule)\n            if data is not None:\n                try:\n                    app.jinja_env.get_or_select_template(data[\"template\"])\n                except TemplateNotFound:\n                    pass\n                except Exception:\n                    _logger.exception(\n                        \"Error in template {}, not going to include it\".format(\n                            data[\"template\"]\n                        )\n                    )\n                else:\n                    includes[template_type].append(rule[\"to_entry\"](data))\n\n    return includes\n\n\ndef _process_template_config(name, implementation, rule, config=None, counter=1):\n    if \"mandatory\" in rule:\n        for mandatory in rule[\"mandatory\"]:\n            if mandatory not in config:\n                return None\n\n    if config is None:\n        config = {}\n    data = dict(config)\n\n    if \"suffix\" not in data and counter > 1:\n        data[\"suffix\"] = \"_%d\" % counter\n\n    if \"div\" in data:\n        data[\"_div\"] = data[\"div\"]\n    elif \"div\" in rule:\n        data[\"_div\"] = rule[\"div\"](name)\n        if \"suffix\" in data:\n            data[\"_div\"] = data[\"_div\"] + data[\"suffix\"]\n        if not _valid_div_re.match(data[\"_div\"]):\n            _logger.warning(\n                \"Template config {} contains invalid div identifier {}, skipping it\".format(\n                    name, data[\"_div\"]\n                )\n            )\n            return None\n\n    if data.get(\"template\"):\n        data[\"template\"] = implementation.template_folder_key + \"/\" + data[\"template\"]\n    else:\n        data[\"template\"] = (\n            implementation.template_folder_key + \"/\" + rule[\"template\"](name)\n        )\n\n    if data.get(\"template_header\"):\n        data[\"template_header\"] = (\n            implementation.template_folder_key + \"/\" + data[\"template_header\"]\n        )\n\n    if \"name\" not in data:\n        data[\"name\"] = implementation._plugin_name\n\n    if \"custom_bindings\" not in data or data[\"custom_bindings\"]:\n        data_bind = \"allowBindings: true\"\n        if \"data_bind\" in data:\n            data_bind = data_bind + \", \" + data[\"data_bind\"]\n        data_bind = data_bind.replace('\"', '\\\\\"')\n        data[\"data_bind\"] = data_bind\n\n    data[\"_key\"] = \"plugin_\" + name\n    if \"suffix\" in data:\n        data[\"_key\"] += data[\"suffix\"]\n\n    data[\"_plugin\"] = name\n\n    return data\n\n\ndef _filter_templates(templates, template_filter):\n    filtered_templates = {}\n    for template_type, template_collection in templates.items():\n        filtered_entries = {}\n        for template_key, template_entry in template_collection[\"entries\"].items():\n            if template_filter(template_type, template_key):\n                filtered_entries[template_key] = template_entry\n        filtered_templates[template_type] = {\n            \"order\": list(\n                filter(lambda x: x in filtered_entries, template_collection[\"order\"])\n            ),\n            \"entries\": filtered_entries,\n        }\n    return filtered_templates\n\n\n@app.route(\"/robots.txt\")\ndef robotsTxt():\n    return send_from_directory(app.static_folder, \"robots.txt\")\n\n\n@app.route(\"/i18n/<string:locale>/<string:domain>.js\")\n@util.flask.conditional(lambda: _check_etag_and_lastmodified_for_i18n(), NOT_MODIFIED)\n@util.flask.etagged(\n    lambda _: _compute_etag_for_i18n(\n        request.view_args[\"locale\"], request.view_args[\"domain\"]\n    )\n)\n@util.flask.lastmodified(\n    lambda _: _compute_date_for_i18n(\n        request.view_args[\"locale\"], request.view_args[\"domain\"]\n    )\n)\ndef localeJs(locale, domain):\n    messages = {}\n    plural_expr = None\n\n    if locale != \"en\":\n        messages, plural_expr = _get_translations(locale, domain)\n\n    catalog = {\n        \"messages\": messages,\n        \"plural_expr\": plural_expr,\n        \"locale\": locale,\n        \"domain\": domain,\n    }\n\n    from flask import Response\n\n    return Response(\n        render_template(\"i18n.js.jinja2\", catalog=catalog),\n        content_type=\"application/x-javascript; charset=utf-8\",\n    )\n\n\n@app.route(\"/plugin_assets/<string:name>/<path:filename>\")\ndef plugin_assets(name, filename):\n    return redirect(url_for(\"plugin.\" + name + \".static\", filename=filename))\n\n\ndef _compute_etag_for_i18n(locale, domain, files=None, lastmodified=None):\n    if files is None:\n        files = _get_all_translationfiles(locale, domain)\n    if lastmodified is None:\n        lastmodified = _compute_date(files)\n    if lastmodified and not isinstance(lastmodified, str):\n        from werkzeug.http import http_date\n\n        lastmodified = http_date(lastmodified)\n\n    import hashlib\n\n    hash = hashlib.sha1()\n\n    def hash_update(value):\n        hash.update(value.encode(\"utf-8\"))\n\n    hash_update(\",\".join(sorted(files)))\n    if lastmodified:\n        hash_update(lastmodified)\n    return hash.hexdigest()\n\n\ndef _compute_date_for_i18n(locale, domain):\n    return _compute_date(_get_all_translationfiles(locale, domain))\n\n\ndef _compute_date(files):\n    # Note, we do not expect everything in 'files' to exist.\n    import stat\n    from datetime import datetime\n\n    from octoprint.util.tz import UTC_TZ\n\n    max_timestamp = 0\n    for path in files:\n        try:\n            # try to stat file. If an exception is thrown, its because it does not exist.\n            s = os.stat(path)\n            if stat.S_ISREG(s.st_mode) and s.st_mtime > max_timestamp:\n                # is a regular file and has a newer timestamp\n                max_timestamp = s.st_mtime\n        except Exception:\n            # path does not exist.\n            continue\n\n    if max_timestamp:\n        # we set the micros to 0 since microseconds are not speced for HTTP\n        max_timestamp = (\n            datetime.fromtimestamp(max_timestamp)\n            .replace(microsecond=0)\n            .replace(tzinfo=UTC_TZ)\n        )\n    return max_timestamp\n\n\ndef _check_etag_and_lastmodified_for_i18n():\n    locale = request.view_args[\"locale\"]\n    domain = request.view_args[\"domain\"]\n\n    etag_ok = util.flask.check_etag(\n        _compute_etag_for_i18n(request.view_args[\"locale\"], request.view_args[\"domain\"])\n    )\n\n    lastmodified = _compute_date_for_i18n(locale, domain)\n    lastmodified_ok = lastmodified is None or util.flask.check_lastmodified(lastmodified)\n\n    return etag_ok and lastmodified_ok\n\n\ndef _get_all_templates():\n    from octoprint.util.jinja import get_all_template_paths\n\n    return get_all_template_paths(app.jinja_loader)\n\n\ndef _get_all_assets():\n    from octoprint.util.jinja import get_all_asset_paths\n\n    return get_all_asset_paths(app.jinja_env.assets_environment, verifyExist=False)\n\n\ndef _get_all_translationfiles(locale, domain):\n    from flask import _request_ctx_stack\n\n    def get_po_path(basedir, locale, domain):\n        return os.path.join(basedir, locale, \"LC_MESSAGES\", f\"{domain}.po\")\n\n    po_files = []\n\n    user_base_path = os.path.join(\n        settings().getBaseFolder(\"translations\", check_writable=False)\n    )\n    user_plugin_path = os.path.join(user_base_path, \"_plugins\")\n\n    # plugin translations\n    plugins = octoprint.plugin.plugin_manager().enabled_plugins\n    for name, plugin in plugins.items():\n        dirs = [\n            os.path.join(user_plugin_path, name),\n            os.path.join(plugin.location, \"translations\"),\n        ]\n        for dirname in dirs:\n            po_files.append(get_po_path(dirname, locale, domain))\n\n    # core translations\n    ctx = _request_ctx_stack.top\n    base_path = os.path.join(ctx.app.root_path, \"translations\")\n\n    dirs = [user_base_path, base_path]\n    for dirname in dirs:\n        po_files.append(get_po_path(dirname, locale, domain))\n\n    return po_files\n\n\ndef _get_translations(locale, domain):\n    from babel.messages.pofile import read_po\n\n    from octoprint.util import dict_merge\n\n    messages = {}\n    plural_expr = None\n\n    def messages_from_po(path, locale, domain):\n        messages = {}\n        with open(path, encoding=\"utf-8\") as f:\n            catalog = read_po(f, locale=locale, domain=domain)\n\n            for message in catalog:\n                message_id = message.id\n                if isinstance(message_id, (list, tuple)):\n                    message_id = message_id[0]\n                if message.string:\n                    messages[message_id] = message.string\n\n        return messages, catalog.plural_expr\n\n    po_files = _get_all_translationfiles(locale, domain)\n    for po_file in po_files:\n        if not os.path.exists(po_file):\n            continue\n        po_messages, plural_expr = messages_from_po(po_file, locale, domain)\n        if po_messages is not None:\n            messages = dict_merge(messages, po_messages, in_place=True)\n\n    return messages, plural_expr\n"], "fixing_code": ["__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport base64\nimport datetime\nimport logging\nimport os\nimport re\nfrom collections import defaultdict\nfrom urllib.parse import urlparse\n\nfrom flask import (\n    Response,\n    abort,\n    g,\n    make_response,\n    redirect,\n    render_template,\n    request,\n    send_from_directory,\n    url_for,\n)\n\nimport octoprint.plugin\nfrom octoprint.access.permissions import OctoPrintPermission, Permissions\nfrom octoprint.filemanager import full_extension_tree, get_all_extensions\nfrom octoprint.server import (  # noqa: F401\n    BRANCH,\n    DISPLAY_VERSION,\n    LOCALES,\n    NOT_MODIFIED,\n    VERSION,\n    app,\n    debug,\n    gettext,\n    groupManager,\n    pluginManager,\n    preemptiveCache,\n    userManager,\n)\nfrom octoprint.server.util import has_permissions, require_login_with\nfrom octoprint.settings import settings\nfrom octoprint.util import sv, to_bytes, to_unicode\nfrom octoprint.util.version import get_python_version_string\n\nfrom . import util\n\n_logger = logging.getLogger(__name__)\n\n_templates = {}\n_plugin_names = None\n_plugin_vars = None\n\n_valid_id_re = re.compile(\"[a-z_]+\")\n_valid_div_re = re.compile(\"[a-zA-Z_-]+\")\n\n\ndef _preemptive_unless(base_url=None, additional_unless=None):\n    if base_url is None:\n        base_url = request.url_root\n\n    disabled_for_root = (\n        not settings().getBoolean([\"devel\", \"cache\", \"preemptive\"])\n        or base_url in settings().get([\"server\", \"preemptiveCache\", \"exceptions\"])\n        or not (base_url.startswith(\"http://\") or base_url.startswith(\"https://\"))\n    )\n\n    recording_disabled = request.headers.get(\"X-Preemptive-Recording\", \"no\") == \"yes\"\n\n    if callable(additional_unless):\n        return recording_disabled or disabled_for_root or additional_unless()\n    else:\n        return recording_disabled or disabled_for_root\n\n\ndef _preemptive_data(\n    key, path=None, base_url=None, data=None, additional_request_data=None\n):\n    if path is None:\n        path = request.path\n    if base_url is None:\n        base_url = request.url_root\n\n    d = {\n        \"path\": path,\n        \"base_url\": base_url,\n        \"query_string\": \"l10n={}\".format(g.locale.language if g.locale else \"en\"),\n    }\n\n    if key != \"_default\":\n        d[\"plugin\"] = key\n\n    # add data if we have any\n    if data is not None:\n        try:\n            if callable(data):\n                data = data()\n            if data:\n                if \"query_string\" in data:\n                    data[\"query_string\"] = \"l10n={}&{}\".format(\n                        g.locale.language, data[\"query_string\"]\n                    )\n                d.update(data)\n        except Exception:\n            _logger.exception(\n                f\"Error collecting data for preemptive cache from plugin {key}\"\n            )\n\n    # add additional request data if we have any\n    if callable(additional_request_data):\n        try:\n            ard = additional_request_data()\n            if ard:\n                d.update({\"_additional_request_data\": ard})\n        except Exception:\n            _logger.exception(\n                \"Error retrieving additional data for preemptive cache from plugin {}\".format(\n                    key\n                )\n            )\n\n    return d\n\n\ndef _cache_key(ui, url=None, locale=None, additional_key_data=None):\n    if url is None:\n        url = request.base_url\n    if locale is None:\n        locale = g.locale.language if g.locale else \"en\"\n\n    k = f\"ui:{ui}:{url}:{locale}\"\n    if callable(additional_key_data):\n        try:\n            ak = additional_key_data()\n            if ak:\n                # we have some additional key components, let's attach them\n                if not isinstance(ak, (list, tuple)):\n                    ak = [ak]\n                k = \"{}:{}\".format(k, \":\".join(ak))\n        except Exception:\n            _logger.exception(\n                \"Error while trying to retrieve additional cache key parts for ui {}\".format(\n                    ui\n                )\n            )\n    return k\n\n\ndef _valid_status_for_cache(status_code):\n    return 200 <= status_code < 400\n\n\ndef _add_additional_assets(hook):\n    result = []\n    for name, hook in pluginManager.get_hooks(hook).items():\n        try:\n            assets = hook()\n            if isinstance(assets, (tuple, list)):\n                result += assets\n        except Exception:\n            _logger.exception(\n                f\"Error fetching theming CSS to include from plugin {name}\",\n                extra={\"plugin\": name},\n            )\n    return result\n\n\n@app.route(\"/login\")\n@app.route(\"/login/\")\ndef login():\n    from flask_login import current_user\n\n    default_redirect_url = request.script_root + url_for(\"index\")\n    redirect_url = request.args.get(\"redirect\", default_redirect_url)\n\n    parsed = urlparse(redirect_url)  # check if redirect url is valid\n    if parsed.scheme != \"\" or parsed.netloc != \"\":\n        _logger.warning(\n            f\"Got an invalid redirect URL with the login attempt, misconfiguration or attack attempt: {redirect_url}\"\n        )\n        redirect_url = default_redirect_url\n\n    permissions = sorted(\n        filter(\n            lambda x: x is not None and isinstance(x, OctoPrintPermission),\n            map(\n                lambda x: getattr(Permissions, x.strip()),\n                request.args.get(\"permissions\", \"\").split(\",\"),\n            ),\n        ),\n        key=lambda x: x.get_name(),\n    )\n    if not permissions:\n        permissions = [Permissions.STATUS, Permissions.SETTINGS_READ]\n\n    user_id = request.args.get(\"user_id\", \"\")\n\n    if (not user_id or current_user.get_id() == user_id) and has_permissions(\n        *permissions\n    ):\n        return redirect(redirect_url)\n\n    render_kwargs = {\n        \"theming\": [],\n        \"redirect_url\": redirect_url,\n        \"permission_names\": map(lambda x: x.get_name(), permissions),\n        \"user_id\": user_id,\n        \"logged_in\": not current_user.is_anonymous,\n    }\n\n    try:\n        additional_assets = _add_additional_assets(\"octoprint.theming.login\")\n\n        # backwards compatibility to forcelogin & loginui plugins which were replaced by this built-in dialog\n        additional_assets += _add_additional_assets(\"octoprint.plugin.forcelogin.theming\")\n        additional_assets += _add_additional_assets(\"octoprint.plugin.loginui.theming\")\n\n        render_kwargs.update({\"theming\": additional_assets})\n    except Exception:\n        _logger.exception(\"Error processing theming CSS, ignoring\")\n\n    return render_template(\"login.jinja2\", **render_kwargs)\n\n\n@app.route(\"/recovery\")\n@app.route(\"/recovery/\")\ndef recovery():\n    response = require_login_with(permissions=[Permissions.ADMIN])\n    if response:\n        return response\n\n    render_kwargs = {\"theming\": []}\n\n    try:\n        additional_assets = _add_additional_assets(\"octoprint.theming.recovery\")\n        render_kwargs.update({\"theming\": additional_assets})\n    except Exception:\n        _logger.exception(\"Error processing theming CSS, ignoring\")\n\n    try:\n        from octoprint.plugins.backup import MAX_UPLOAD_SIZE\n        from octoprint.util import get_formatted_size\n\n        render_kwargs.update(\n            {\n                \"plugin_backup_max_upload_size\": MAX_UPLOAD_SIZE,\n                \"plugin_backup_max_upload_size_str\": get_formatted_size(MAX_UPLOAD_SIZE),\n            }\n        )\n    except Exception:\n        _logger.exception(\"Error adding backup upload size info, ignoring\")\n\n    return render_template(\"recovery.jinja2\", **render_kwargs)\n\n\n@app.route(\"/cached.gif\")\ndef in_cache():\n    url = request.base_url.replace(\"/cached.gif\", \"/\")\n    path = request.path.replace(\"/cached.gif\", \"/\")\n    base_url = request.url_root\n\n    # select view from plugins and fall back on default view if no plugin will handle it\n    ui_plugins = pluginManager.get_implementations(\n        octoprint.plugin.UiPlugin, sorting_context=\"UiPlugin.on_ui_render\"\n    )\n    for plugin in ui_plugins:\n        try:\n            if plugin.will_handle_ui(request):\n                ui = plugin._identifier\n                key = _cache_key(\n                    plugin._identifier,\n                    url=url,\n                    additional_key_data=plugin.get_ui_additional_key_data_for_cache,\n                )\n                unless = _preemptive_unless(\n                    url,\n                    additional_unless=plugin.get_ui_preemptive_caching_additional_unless,\n                )\n                data = _preemptive_data(\n                    plugin._identifier,\n                    path=path,\n                    base_url=base_url,\n                    data=plugin.get_ui_data_for_preemptive_caching,\n                    additional_request_data=plugin.get_ui_additional_request_data_for_preemptive_caching,\n                )\n                break\n        except Exception:\n            _logger.exception(\n                f\"Error while calling plugin {plugin._identifier}, skipping it\",\n                extra={\"plugin\": plugin._identifier},\n            )\n    else:\n        ui = \"_default\"\n        key = _cache_key(\"_default\", url=url)\n        unless = _preemptive_unless(url)\n        data = _preemptive_data(\"_default\", path=path, base_url=base_url)\n\n    response = make_response(\n        bytes(\n            base64.b64decode(\"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\")\n        )\n    )\n    response.headers[\"Content-Type\"] = \"image/gif\"\n\n    if unless or not preemptiveCache.has_record(data, root=path):\n        _logger.info(\n            \"Preemptive cache not active for path {}, ui {} and data {!r}, signaling as cached\".format(\n                path, ui, data\n            )\n        )\n        return response\n    elif util.flask.is_in_cache(key):\n        _logger.info(f\"Found path {path} in cache (key: {key}), signaling as cached\")\n        return response\n    elif util.flask.is_cache_bypassed(key):\n        _logger.info(\n            \"Path {} was bypassed from cache (key: {}), signaling as cached\".format(\n                path, key\n            )\n        )\n        return response\n    else:\n        _logger.debug(f\"Path {path} not yet cached (key: {key}), signaling as missing\")\n        return abort(404)\n\n\n@app.route(\"/\")\ndef index():\n    from octoprint.server import connectivityChecker, printer\n\n    global _templates, _plugin_names, _plugin_vars\n\n    preemptive_cache_enabled = settings().getBoolean([\"devel\", \"cache\", \"preemptive\"])\n\n    locale = g.locale.language if g.locale else \"en\"\n\n    # helper to check if wizards are active\n    def wizard_active(templates):\n        return templates is not None and bool(templates[\"wizard\"][\"order\"])\n\n    # we force a refresh if the client forces one and we are not printing or if we have wizards cached\n    client_refresh = util.flask.cache_check_headers()\n    request_refresh = \"_refresh\" in request.values\n    printing = printer.is_printing()\n    if client_refresh and printing:\n        logging.getLogger(__name__).warning(\n            \"Client requested cache refresh via cache-control headers but we are printing. \"\n            \"Not invalidating caches due to resource limitation. Append ?_refresh=true to \"\n            \"the URL if you absolutely require a refresh now\"\n        )\n    client_refresh = client_refresh and not printing\n    force_refresh = (\n        client_refresh or request_refresh or wizard_active(_templates.get(locale))\n    )\n\n    # if we need to refresh our template cache or it's not yet set, process it\n    fetch_template_data(refresh=force_refresh)\n\n    now = datetime.datetime.utcnow()\n\n    enable_timelapse = settings().getBoolean([\"webcam\", \"timelapseEnabled\"])\n    enable_loading_animation = settings().getBoolean([\"devel\", \"showLoadingAnimation\"])\n    enable_sd_support = settings().get([\"feature\", \"sdSupport\"])\n    enable_webcam = settings().getBoolean([\"webcam\", \"webcamEnabled\"]) and bool(\n        settings().get([\"webcam\", \"stream\"])\n    )\n    enable_temperature_graph = settings().get([\"feature\", \"temperatureGraph\"])\n    sockjs_connect_timeout = settings().getInt([\"devel\", \"sockJsConnectTimeout\"])\n\n    def default_template_filter(template_type, template_key):\n        if template_type == \"tab\":\n            return template_key != \"timelapse\" or enable_timelapse\n        else:\n            return True\n\n    default_additional_etag = [\n        enable_timelapse,\n        enable_loading_animation,\n        enable_sd_support,\n        enable_webcam,\n        enable_temperature_graph,\n        sockjs_connect_timeout,\n        connectivityChecker.online,\n        wizard_active(_templates.get(locale)),\n    ] + sorted(\n        \"{}:{}\".format(to_unicode(k, errors=\"replace\"), to_unicode(v, errors=\"replace\"))\n        for k, v in _plugin_vars.items()\n    )\n\n    def get_preemptively_cached_view(\n        key, view, data=None, additional_request_data=None, additional_unless=None\n    ):\n        if (data is None and additional_request_data is None) or g.locale is None:\n            return view\n\n        d = _preemptive_data(\n            key, data=data, additional_request_data=additional_request_data\n        )\n\n        def unless():\n            return _preemptive_unless(\n                base_url=request.url_root, additional_unless=additional_unless\n            )\n\n        # finally decorate our view\n        return util.flask.preemptively_cached(\n            cache=preemptiveCache, data=d, unless=unless\n        )(view)\n\n    def get_cached_view(\n        key,\n        view,\n        additional_key_data=None,\n        additional_files=None,\n        additional_etag=None,\n        custom_files=None,\n        custom_etag=None,\n        custom_lastmodified=None,\n    ):\n        if additional_etag is None:\n            additional_etag = []\n\n        def cache_key():\n            return _cache_key(key, additional_key_data=additional_key_data)\n\n        def collect_files():\n            if callable(custom_files):\n                try:\n                    files = custom_files()\n                    if files:\n                        return files\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve tracked files for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            files = _get_all_templates()\n            files += _get_all_assets()\n            files += _get_all_translationfiles(\n                g.locale.language if g.locale else \"en\", \"messages\"\n            )\n\n            if callable(additional_files):\n                try:\n                    af = additional_files()\n                    if af:\n                        files += af\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve additional tracked files for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            return sorted(set(files))\n\n        def compute_lastmodified(files):\n            if callable(custom_lastmodified):\n                try:\n                    lastmodified = custom_lastmodified()\n                    if lastmodified:\n                        return lastmodified\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve custom LastModified value for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            return _compute_date(files)\n\n        def compute_etag(files, lastmodified, additional=None):\n            if callable(custom_etag):\n                try:\n                    etag = custom_etag()\n                    if etag:\n                        return etag\n                except Exception:\n                    _logger.exception(\n                        \"Error while trying to retrieve custom ETag value for plugin {}\".format(\n                            key\n                        )\n                    )\n\n            if lastmodified and not isinstance(lastmodified, str):\n                from werkzeug.http import http_date\n\n                lastmodified = http_date(lastmodified)\n            if additional is None:\n                additional = []\n\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                hash.update(to_bytes(value, encoding=\"utf-8\", errors=\"replace\"))\n\n            hash_update(octoprint.__version__)\n            hash_update(get_python_version_string())\n            hash_update(\",\".join(sorted(files)))\n            if lastmodified:\n                hash_update(lastmodified)\n            for add in additional:\n                hash_update(add)\n            return hash.hexdigest()\n\n        current_files = collect_files()\n        current_lastmodified = compute_lastmodified(current_files)\n        current_etag = compute_etag(\n            files=current_files,\n            lastmodified=current_lastmodified,\n            additional=[cache_key()] + additional_etag,\n        )\n\n        def check_etag_and_lastmodified():\n            lastmodified_ok = util.flask.check_lastmodified(current_lastmodified)\n            etag_ok = util.flask.check_etag(current_etag)\n            return lastmodified_ok and etag_ok\n\n        def validate_cache(cached):\n            return force_refresh or (current_etag != cached.get_etag()[0])\n\n        decorated_view = view\n        decorated_view = util.flask.lastmodified(lambda _: current_lastmodified)(\n            decorated_view\n        )\n        decorated_view = util.flask.etagged(lambda _: current_etag)(decorated_view)\n        decorated_view = util.flask.cached(\n            timeout=-1,\n            refreshif=validate_cache,\n            key=cache_key,\n            unless_response=lambda response: util.flask.cache_check_response_headers(\n                response\n            )\n            or util.flask.cache_check_status_code(response, _valid_status_for_cache),\n        )(decorated_view)\n        decorated_view = util.flask.with_client_revalidation(decorated_view)\n        decorated_view = util.flask.conditional(\n            check_etag_and_lastmodified, NOT_MODIFIED\n        )(decorated_view)\n        return decorated_view\n\n    def plugin_view(p):\n        cached = get_cached_view(\n            p._identifier,\n            p.on_ui_render,\n            additional_key_data=p.get_ui_additional_key_data_for_cache,\n            additional_files=p.get_ui_additional_tracked_files,\n            custom_files=p.get_ui_custom_tracked_files,\n            custom_etag=p.get_ui_custom_etag,\n            custom_lastmodified=p.get_ui_custom_lastmodified,\n            additional_etag=p.get_ui_additional_etag(default_additional_etag),\n        )\n\n        if preemptive_cache_enabled and p.get_ui_preemptive_caching_enabled():\n            view = get_preemptively_cached_view(\n                p._identifier,\n                cached,\n                p.get_ui_data_for_preemptive_caching,\n                p.get_ui_additional_request_data_for_preemptive_caching,\n                p.get_ui_preemptive_caching_additional_unless,\n            )\n        else:\n            view = cached\n\n        template_filter = p.get_ui_custom_template_filter(default_template_filter)\n        if template_filter is not None and callable(template_filter):\n            filtered_templates = _filter_templates(_templates[locale], template_filter)\n        else:\n            filtered_templates = _templates[locale]\n\n        render_kwargs = _get_render_kwargs(\n            filtered_templates, _plugin_names, _plugin_vars, now\n        )\n\n        return view(now, request, render_kwargs)\n\n    def default_view():\n        filtered_templates = _filter_templates(\n            _templates[locale], default_template_filter\n        )\n\n        wizard = wizard_active(filtered_templates)\n        accesscontrol_active = userManager.has_been_customized()\n\n        render_kwargs = _get_render_kwargs(\n            filtered_templates, _plugin_names, _plugin_vars, now\n        )\n        render_kwargs.update(\n            {\n                \"enableWebcam\": enable_webcam,\n                \"enableTemperatureGraph\": enable_temperature_graph,\n                \"enableAccessControl\": True,\n                \"accessControlActive\": accesscontrol_active,\n                \"enableLoadingAnimation\": enable_loading_animation,\n                \"enableSdSupport\": enable_sd_support,\n                \"sockJsConnectTimeout\": sockjs_connect_timeout * 1000,\n                \"wizard\": wizard,\n                \"online\": connectivityChecker.online,\n                \"now\": now,\n            }\n        )\n\n        # no plugin took an interest, we'll use the default UI\n        def make_default_ui():\n            r = make_response(render_template(\"index.jinja2\", **render_kwargs))\n            if wizard:\n                # if we have active wizard dialogs, set non caching headers\n                r = util.flask.add_non_caching_response_headers(r)\n            return r\n\n        cached = get_cached_view(\n            \"_default\", make_default_ui, additional_etag=default_additional_etag\n        )\n        preemptively_cached = get_preemptively_cached_view(\"_default\", cached, {}, {})\n        return preemptively_cached()\n\n    default_permissions = [Permissions.STATUS, Permissions.SETTINGS_READ]\n\n    response = None\n\n    forced_view = request.headers.get(\"X-Force-View\", None)\n\n    if forced_view:\n        # we have view forced by the preemptive cache\n        _logger.debug(f\"Forcing rendering of view {forced_view}\")\n        if forced_view != \"_default\":\n            plugin = pluginManager.get_plugin_info(forced_view, require_enabled=True)\n            if plugin is not None and isinstance(\n                plugin.implementation, octoprint.plugin.UiPlugin\n            ):\n                permissions = plugin.implementation.get_ui_permissions()\n                response = require_login_with(permissions=permissions)\n                if not response:\n                    response = plugin_view(plugin.implementation)\n                    if _logger.isEnabledFor(logging.DEBUG) and isinstance(\n                        response, Response\n                    ):\n                        response.headers[\n                            \"X-Ui-Plugin\"\n                        ] = plugin.implementation._identifier\n        else:\n            response = require_login_with(permissions=default_permissions)\n            if not response:\n                response = default_view()\n                if _logger.isEnabledFor(logging.DEBUG) and isinstance(response, Response):\n                    response.headers[\"X-Ui-Plugin\"] = \"_default\"\n\n    else:\n        # select view from plugins and fall back on default view if no plugin will handle it\n        ui_plugins = pluginManager.get_implementations(\n            octoprint.plugin.UiPlugin, sorting_context=\"UiPlugin.on_ui_render\"\n        )\n        for plugin in ui_plugins:\n            try:\n                if plugin.will_handle_ui(request):\n                    # plugin claims responsibility, let it render the UI\n                    permissions = plugin.get_ui_permissions()\n                    response = require_login_with(permissions=permissions)\n                    if not response:\n                        response = plugin_view(plugin)\n                        if response is not None:\n                            if _logger.isEnabledFor(logging.DEBUG) and isinstance(\n                                response, Response\n                            ):\n                                response.headers[\"X-Ui-Plugin\"] = plugin._identifier\n                            break\n                        else:\n                            _logger.warning(\n                                \"UiPlugin {} returned an empty response\".format(\n                                    plugin._identifier\n                                )\n                            )\n            except Exception:\n                _logger.exception(\n                    \"Error while calling plugin {}, skipping it\".format(\n                        plugin._identifier\n                    ),\n                    extra={\"plugin\": plugin._identifier},\n                )\n        else:\n            response = require_login_with(permissions=default_permissions)\n            if not response:\n                response = default_view()\n                if _logger.isEnabledFor(logging.DEBUG) and isinstance(response, Response):\n                    response.headers[\"X-Ui-Plugin\"] = \"_default\"\n\n    if response is None:\n        return abort(404)\n    return response\n\n\ndef _get_render_kwargs(templates, plugin_names, plugin_vars, now):\n    global _logger\n\n    # ~~ a bunch of settings\n\n    first_run = settings().getBoolean([\"server\", \"firstRun\"])\n\n    locales = {}\n    for loc in LOCALES:\n        try:\n            locales[loc.language] = {\n                \"language\": loc.language,\n                \"display\": loc.display_name,\n                \"english\": loc.english_name,\n            }\n        except Exception:\n            _logger.exception(\"Error while collecting available locales\")\n\n    permissions = [permission.as_dict() for permission in Permissions.all()]\n    filetypes = list(sorted(full_extension_tree().keys()))\n    extensions = list(map(lambda ext: f\".{ext}\", get_all_extensions()))\n\n    # ~~ prepare full set of template vars for rendering\n\n    render_kwargs = {\n        \"debug\": debug,\n        \"firstRun\": first_run,\n        \"version\": {\"number\": VERSION, \"display\": DISPLAY_VERSION, \"branch\": BRANCH},\n        \"python_version\": get_python_version_string(),\n        \"templates\": templates,\n        \"pluginNames\": plugin_names,\n        \"locales\": locales,\n        \"permissions\": permissions,\n        \"supportedFiletypes\": filetypes,\n        \"supportedExtensions\": extensions,\n    }\n    render_kwargs.update(plugin_vars)\n\n    return render_kwargs\n\n\ndef fetch_template_data(refresh=False):\n    global _templates, _plugin_names, _plugin_vars\n\n    locale = g.locale.language if g.locale else \"en\"\n\n    if (\n        not refresh\n        and _templates.get(locale) is not None\n        and _plugin_names is not None\n        and _plugin_vars is not None\n    ):\n        return _templates[locale], _plugin_names, _plugin_vars\n\n    first_run = settings().getBoolean([\"server\", \"firstRun\"])\n\n    ##~~ prepare templates\n\n    templates = defaultdict(lambda: {\"order\": [], \"entries\": {}})\n\n    # rules for transforming template configs to template entries\n    template_rules = {\n        \"navbar\": {\n            \"div\": lambda x: \"navbar_plugin_\" + x,\n            \"template\": lambda x: x + \"_navbar.jinja2\",\n            \"to_entry\": lambda data: data,\n        },\n        \"sidebar\": {\n            \"div\": lambda x: \"sidebar_plugin_\" + x,\n            \"template\": lambda x: x + \"_sidebar.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"tab\": {\n            \"div\": lambda x: \"tab_plugin_\" + x,\n            \"template\": lambda x: x + \"_tab.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"settings\": {\n            \"div\": lambda x: \"settings_plugin_\" + x,\n            \"template\": lambda x: x + \"_settings.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"usersettings\": {\n            \"div\": lambda x: \"usersettings_plugin_\" + x,\n            \"template\": lambda x: x + \"_usersettings.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"wizard\": {\n            \"div\": lambda x: \"wizard_plugin_\" + x,\n            \"template\": lambda x: x + \"_wizard.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"about\": {\n            \"div\": lambda x: \"about_plugin_\" + x,\n            \"template\": lambda x: x + \"_about.jinja2\",\n            \"to_entry\": lambda data: (data[\"name\"], data),\n        },\n        \"generic\": {\"template\": lambda x: x + \".jinja2\", \"to_entry\": lambda data: data},\n    }\n\n    # sorting orders\n    def wizard_key_extractor(d, k):\n        if d[1].get(\"_key\", None) == \"plugin_corewizard_acl\":\n            # Ultra special case - we MUST always have the ACL wizard first since otherwise any steps that follow and\n            # that require to access APIs to function will run into errors since those APIs won't work before ACL\n            # has been configured. See also #2140\n            return f\"0:{to_unicode(d[0])}\"\n        elif d[1].get(\"mandatory\", False):\n            # Other mandatory steps come before the optional ones\n            return f\"1:{to_unicode(d[0])}\"\n        else:\n            # Finally everything else\n            return f\"2:{to_unicode(d[0])}\"\n\n    template_sorting = {\n        \"navbar\": {\"add\": \"prepend\", \"key\": None},\n        \"sidebar\": {\"add\": \"append\", \"key\": \"name\"},\n        \"tab\": {\"add\": \"append\", \"key\": \"name\"},\n        \"settings\": {\n            \"add\": \"custom_append\",\n            \"key\": \"name\",\n            \"custom_add_entries\": lambda missing: {\n                \"section_plugins\": (gettext(\"Plugins\"), None)\n            },\n            \"custom_add_order\": lambda missing: [\"section_plugins\"] + missing,\n        },\n        \"usersettings\": {\"add\": \"append\", \"key\": \"name\"},\n        \"wizard\": {\"add\": \"append\", \"key\": \"name\", \"key_extractor\": wizard_key_extractor},\n        \"about\": {\"add\": \"append\", \"key\": \"name\"},\n        \"generic\": {\"add\": \"append\", \"key\": None},\n    }\n\n    hooks = pluginManager.get_hooks(\"octoprint.ui.web.templatetypes\")\n    for name, hook in hooks.items():\n        try:\n            result = hook(dict(template_sorting), dict(template_rules))\n        except Exception:\n            _logger.exception(\n                f\"Error while retrieving custom template type \"\n                f\"definitions from plugin {name}\",\n                extra={\"plugin\": name},\n            )\n        else:\n            if not isinstance(result, list):\n                continue\n\n            for entry in result:\n                if not isinstance(entry, tuple) or not len(entry) == 3:\n                    continue\n\n                key, order, rule = entry\n\n                # order defaults\n                if \"add\" not in order:\n                    order[\"add\"] = \"prepend\"\n                if \"key\" not in order:\n                    order[\"key\"] = \"name\"\n\n                # rule defaults\n                if \"div\" not in rule:\n                    # default div name: <hook plugin>_<template_key>_plugin_<plugin>\n                    div = f\"{name}_{key}_plugin_\"\n                    rule[\"div\"] = lambda x: div + x\n                if \"template\" not in rule:\n                    # default template name: <plugin>_plugin_<hook plugin>_<template key>.jinja2\n                    template = f\"_plugin_{name}_{key}.jinja2\"\n                    rule[\"template\"] = lambda x: x + template\n                if \"to_entry\" not in rule:\n                    # default to_entry assumes existing \"name\" property to be used as label for 2-tuple entry data structure (<name>, <properties>)\n                    rule[\"to_entry\"] = lambda data: (data[\"name\"], data)\n\n                template_rules[\"plugin_\" + name + \"_\" + key] = rule\n                template_sorting[\"plugin_\" + name + \"_\" + key] = order\n    template_types = list(template_rules.keys())\n\n    # navbar\n\n    templates[\"navbar\"][\"entries\"] = {\n        \"offlineindicator\": {\n            \"template\": \"navbar/offlineindicator.jinja2\",\n            \"_div\": \"navbar_offlineindicator\",\n            \"custom_bindings\": False,\n        },\n        \"settings\": {\n            \"template\": \"navbar/settings.jinja2\",\n            \"_div\": \"navbar_settings\",\n            \"styles\": [\"display: none;\"],\n            \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.SETTINGS)\",\n        },\n        \"systemmenu\": {\n            \"template\": \"navbar/systemmenu.jinja2\",\n            \"_div\": \"navbar_systemmenu\",\n            \"classes\": [\"dropdown\"],\n            \"styles\": [\"display: none;\"],\n            \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.SYSTEM)\",\n            \"custom_bindings\": False,\n        },\n        \"login\": {\n            \"template\": \"navbar/login.jinja2\",\n            \"_div\": \"navbar_login\",\n            \"classes\": [\"dropdown\"],\n            \"custom_bindings\": False,\n        },\n    }\n\n    # sidebar\n\n    templates[\"sidebar\"][\"entries\"] = {\n        \"connection\": (\n            gettext(\"Connection\"),\n            {\n                \"template\": \"sidebar/connection.jinja2\",\n                \"_div\": \"connection\",\n                \"icon\": \"signal\",\n                \"styles_wrapper\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.CONNECTION)\",\n                \"template_header\": \"sidebar/connection_header.jinja2\",\n            },\n        ),\n        \"state\": (\n            gettext(\"State\"),\n            {\n                \"template\": \"sidebar/state.jinja2\",\n                \"_div\": \"state\",\n                \"icon\": \"info-circle\",\n                \"styles_wrapper\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.STATUS)\",\n            },\n        ),\n        \"files\": (\n            gettext(\"Files\"),\n            {\n                \"template\": \"sidebar/files.jinja2\",\n                \"_div\": \"files\",\n                \"icon\": \"list\",\n                \"classes_content\": [\"overflow_visible\"],\n                \"template_header\": \"sidebar/files_header.jinja2\",\n                \"styles_wrapper\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.FILES_LIST)\",\n            },\n        ),\n    }\n\n    # tabs\n\n    templates[\"tab\"][\"entries\"] = {\n        \"temperature\": (\n            gettext(\"Temperature\"),\n            {\n                \"template\": \"tabs/temperature.jinja2\",\n                \"_div\": \"temp\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasAnyPermissionKo(access.permissions.STATUS, access.permissions.CONTROL)() && visible()\",\n            },\n        ),\n        \"control\": (\n            gettext(\"Control\"),\n            {\n                \"template\": \"tabs/control.jinja2\",\n                \"_div\": \"control\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasAnyPermissionKo(access.permissions.WEBCAM, access.permissions.CONTROL)\",\n            },\n        ),\n        \"terminal\": (\n            gettext(\"Terminal\"),\n            {\n                \"template\": \"tabs/terminal.jinja2\",\n                \"_div\": \"term\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.MONITOR_TERMINAL)\",\n            },\n        ),\n        \"timelapse\": (\n            gettext(\"Timelapse\"),\n            {\n                \"template\": \"tabs/timelapse.jinja2\",\n                \"_div\": \"timelapse\",\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.TIMELAPSE_LIST)\",\n            },\n        ),\n    }\n\n    # settings dialog\n\n    templates[\"settings\"][\"entries\"] = {\n        \"section_printer\": (gettext(\"Printer\"), None),\n        \"serial\": (\n            gettext(\"Serial Connection\"),\n            {\n                \"template\": \"dialogs/settings/serialconnection.jinja2\",\n                \"_div\": \"settings_serialConnection\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"printerprofiles\": (\n            gettext(\"Printer Profiles\"),\n            {\n                \"template\": \"dialogs/settings/printerprofiles.jinja2\",\n                \"_div\": \"settings_printerProfiles\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"temperatures\": (\n            gettext(\"Temperatures\"),\n            {\n                \"template\": \"dialogs/settings/temperatures.jinja2\",\n                \"_div\": \"settings_temperature\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"terminalfilters\": (\n            gettext(\"Terminal Filters\"),\n            {\n                \"template\": \"dialogs/settings/terminalfilters.jinja2\",\n                \"_div\": \"settings_terminalFilters\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"gcodescripts\": (\n            gettext(\"GCODE Scripts\"),\n            {\n                \"template\": \"dialogs/settings/gcodescripts.jinja2\",\n                \"_div\": \"settings_gcodeScripts\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"section_features\": (gettext(\"Features\"), None),\n        \"features\": (\n            gettext(\"Features\"),\n            {\n                \"template\": \"dialogs/settings/features.jinja2\",\n                \"_div\": \"settings_features\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"webcam\": (\n            gettext(\"Webcam & Timelapse\"),\n            {\n                \"template\": \"dialogs/settings/webcam.jinja2\",\n                \"_div\": \"settings_webcam\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"api\": (\n            gettext(\"API\"),\n            {\n                \"template\": \"dialogs/settings/api.jinja2\",\n                \"_div\": \"settings_api\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"section_octoprint\": (gettext(\"OctoPrint\"), None),\n        \"accesscontrol\": (\n            gettext(\"Access Control\"),\n            {\n                \"template\": \"dialogs/settings/accesscontrol.jinja2\",\n                \"_div\": \"settings_users\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"folders\": (\n            gettext(\"Folders\"),\n            {\n                \"template\": \"dialogs/settings/folders.jinja2\",\n                \"_div\": \"settings_folders\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"appearance\": (\n            gettext(\"Appearance\"),\n            {\n                \"template\": \"dialogs/settings/appearance.jinja2\",\n                \"_div\": \"settings_appearance\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"server\": (\n            gettext(\"Server\"),\n            {\n                \"template\": \"dialogs/settings/server.jinja2\",\n                \"_div\": \"settings_server\",\n                \"custom_bindings\": False,\n            },\n        ),\n    }\n\n    # user settings dialog\n\n    templates[\"usersettings\"][\"entries\"] = {\n        \"access\": (\n            gettext(\"Access\"),\n            {\n                \"template\": \"dialogs/usersettings/access.jinja2\",\n                \"_div\": \"usersettings_access\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"interface\": (\n            gettext(\"Interface\"),\n            {\n                \"template\": \"dialogs/usersettings/interface.jinja2\",\n                \"_div\": \"usersettings_interface\",\n                \"custom_bindings\": False,\n            },\n        ),\n    }\n\n    # wizard\n\n    if first_run:\n\n        def custom_insert_order(existing, missing):\n            if \"firstrunstart\" in missing:\n                missing.remove(\"firstrunstart\")\n            if \"firstrunend\" in missing:\n                missing.remove(\"firstrunend\")\n\n            return [\"firstrunstart\"] + existing + missing + [\"firstrunend\"]\n\n        template_sorting[\"wizard\"].update(\n            {\n                \"add\": \"custom_insert\",\n                \"custom_insert_entries\": lambda missing: {},\n                \"custom_insert_order\": custom_insert_order,\n            }\n        )\n        templates[\"wizard\"][\"entries\"] = {\n            \"firstrunstart\": (\n                gettext(\"Start\"),\n                {\n                    \"template\": \"dialogs/wizard/firstrun_start.jinja2\",\n                    \"_div\": \"wizard_firstrun_start\",\n                },\n            ),\n            \"firstrunend\": (\n                gettext(\"Finish\"),\n                {\n                    \"template\": \"dialogs/wizard/firstrun_end.jinja2\",\n                    \"_div\": \"wizard_firstrun_end\",\n                },\n            ),\n        }\n\n    # about dialog\n\n    templates[\"about\"][\"entries\"] = {\n        \"about\": (\n            \"About OctoPrint\",\n            {\n                \"template\": \"dialogs/about/about.jinja2\",\n                \"_div\": \"about_about\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"license\": (\n            \"OctoPrint License\",\n            {\n                \"template\": \"dialogs/about/license.jinja2\",\n                \"_div\": \"about_license\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"thirdparty\": (\n            \"Third Party Licenses\",\n            {\n                \"template\": \"dialogs/about/thirdparty.jinja2\",\n                \"_div\": \"about_thirdparty\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"authors\": (\n            \"Authors\",\n            {\n                \"template\": \"dialogs/about/authors.jinja2\",\n                \"_div\": \"about_authors\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"supporters\": (\n            \"Supporters\",\n            {\n                \"template\": \"dialogs/about/supporters.jinja2\",\n                \"_div\": \"about_sponsors\",\n                \"custom_bindings\": False,\n            },\n        ),\n        \"systeminfo\": (\n            \"System Information\",\n            {\n                \"template\": \"dialogs/about/systeminfo.jinja2\",\n                \"_div\": \"about_systeminfo\",\n                \"custom_bindings\": False,\n                \"styles\": [\"display: none;\"],\n                \"data_bind\": \"visible: loginState.hasPermissionKo(access.permissions.SYSTEM)\",\n            },\n        ),\n    }\n\n    # extract data from template plugins\n\n    template_plugins = pluginManager.get_implementations(octoprint.plugin.TemplatePlugin)\n\n    plugin_vars = {}\n    plugin_names = set()\n    plugin_aliases = {}\n    seen_wizards = settings().get([\"server\", \"seenWizards\"]) if not first_run else {}\n    for implementation in template_plugins:\n        name = implementation._identifier\n        plugin_names.add(name)\n        wizard_required = False\n        wizard_ignored = False\n\n        try:\n            vars = implementation.get_template_vars()\n            configs = implementation.get_template_configs()\n            if isinstance(implementation, octoprint.plugin.WizardPlugin):\n                wizard_required = implementation.is_wizard_required()\n                wizard_ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(\n                    seen_wizards, implementation\n                )\n        except Exception:\n            _logger.exception(\n                \"Error while retrieving template data for plugin {}, ignoring it\".format(\n                    name\n                ),\n                extra={\"plugin\": name},\n            )\n            continue\n\n        if not isinstance(vars, dict):\n            vars = {}\n        if not isinstance(configs, (list, tuple)):\n            configs = []\n\n        for var_name, var_value in vars.items():\n            plugin_vars[\"plugin_\" + name + \"_\" + var_name] = var_value\n\n        try:\n            includes = _process_template_configs(\n                name, implementation, configs, template_rules\n            )\n        except Exception:\n            _logger.exception(\n                \"Error while processing template configs for plugin {}, ignoring it\".format(\n                    name\n                ),\n                extra={\"plugin\": name},\n            )\n\n        if not wizard_required or wizard_ignored:\n            includes[\"wizard\"] = list()\n\n        for t in template_types:\n            plugin_aliases[t] = {}\n            for include in includes[t]:\n                if t == \"navbar\" or t == \"generic\":\n                    data = include\n                else:\n                    data = include[1]\n\n                key = data[\"_key\"]\n                if \"replaces\" in data:\n                    key = data[\"replaces\"]\n                    plugin_aliases[t][data[\"_key\"]] = data[\"replaces\"]\n                templates[t][\"entries\"][key] = include\n\n    # ~~ order internal templates and plugins\n\n    # make sure that\n    # 1) we only have keys in our ordered list that we have entries for and\n    # 2) we have all entries located somewhere within the order\n\n    for t in template_types:\n        default_order = (\n            settings().get(\n                [\"appearance\", \"components\", \"order\", t], merged=True, config={}\n            )\n            or []\n        )\n        configured_order = (\n            settings().get([\"appearance\", \"components\", \"order\", t], merged=True) or []\n        )\n        configured_disabled = (\n            settings().get([\"appearance\", \"components\", \"disabled\", t]) or []\n        )\n\n        # first create the ordered list of all component ids according to the configured order\n        result = []\n        for x in configured_order:\n            if x in plugin_aliases[t]:\n                x = plugin_aliases[t][x]\n            if (\n                x in templates[t][\"entries\"]\n                and x not in configured_disabled\n                and x not in result\n            ):\n                result.append(x)\n        templates[t][\"order\"] = result\n\n        # now append the entries from the default order that are not already in there\n        templates[t][\"order\"] += [\n            x\n            for x in default_order\n            if x not in templates[t][\"order\"]\n            and x in templates[t][\"entries\"]\n            and x not in configured_disabled\n        ]\n\n        all_ordered = set(templates[t][\"order\"])\n        all_disabled = set(configured_disabled)\n\n        # check if anything is missing, if not we are done here\n        missing_in_order = (\n            set(templates[t][\"entries\"].keys())\n            .difference(all_ordered)\n            .difference(all_disabled)\n        )\n        if len(missing_in_order) == 0:\n            continue\n\n        # works with entries that are dicts and entries that are 2-tuples with the\n        # entry data at index 1\n        def config_extractor(item, key, default_value=None):\n            if isinstance(item, dict) and key in item:\n                return item[key] if key in item else default_value\n            elif (\n                isinstance(item, tuple)\n                and len(item) > 1\n                and isinstance(item[1], dict)\n                and key in item[1]\n            ):\n                return item[1][key] if key in item[1] else default_value\n\n            return default_value\n\n        # finally add anything that's not included in our order yet\n        if template_sorting[t][\"key\"] is not None:\n            # we'll use our config extractor as default key extractor\n            extractor = config_extractor\n\n            # if template type provides custom extractor, make sure its exceptions are handled\n            if \"key_extractor\" in template_sorting[t] and callable(\n                template_sorting[t][\"key_extractor\"]\n            ):\n\n                def create_safe_extractor(extractor):\n                    def f(x, k):\n                        try:\n                            return extractor(x, k)\n                        except Exception:\n                            _logger.exception(\n                                \"Error while extracting sorting keys for template {}\".format(\n                                    t\n                                )\n                            )\n                            return None\n\n                    return f\n\n                extractor = create_safe_extractor(template_sorting[t][\"key_extractor\"])\n\n            sort_key = template_sorting[t][\"key\"]\n\n            def key_func(x):\n                config = templates[t][\"entries\"][x]\n                entry_order = config_extractor(config, \"order\", default_value=None)\n                return (\n                    entry_order is None,\n                    sv(entry_order),\n                    sv(extractor(config, sort_key)),\n                )\n\n            sorted_missing = sorted(missing_in_order, key=key_func)\n        else:\n\n            def key_func(x):\n                config = templates[t][\"entries\"][x]\n                entry_order = config_extractor(config, \"order\", default_value=None)\n                return entry_order is None, sv(entry_order)\n\n            sorted_missing = sorted(missing_in_order, key=key_func)\n\n        if template_sorting[t][\"add\"] == \"prepend\":\n            templates[t][\"order\"] = sorted_missing + templates[t][\"order\"]\n        elif template_sorting[t][\"add\"] == \"append\":\n            templates[t][\"order\"] += sorted_missing\n        elif (\n            template_sorting[t][\"add\"] == \"custom_prepend\"\n            and \"custom_add_entries\" in template_sorting[t]\n            and \"custom_add_order\" in template_sorting[t]\n        ):\n            templates[t][\"entries\"].update(\n                template_sorting[t][\"custom_add_entries\"](sorted_missing)\n            )\n            templates[t][\"order\"] = (\n                template_sorting[t][\"custom_add_order\"](sorted_missing)\n                + templates[t][\"order\"]\n            )\n        elif (\n            template_sorting[t][\"add\"] == \"custom_append\"\n            and \"custom_add_entries\" in template_sorting[t]\n            and \"custom_add_order\" in template_sorting[t]\n        ):\n            templates[t][\"entries\"].update(\n                template_sorting[t][\"custom_add_entries\"](sorted_missing)\n            )\n            templates[t][\"order\"] += template_sorting[t][\"custom_add_order\"](\n                sorted_missing\n            )\n        elif (\n            template_sorting[t][\"add\"] == \"custom_insert\"\n            and \"custom_insert_entries\" in template_sorting[t]\n            and \"custom_insert_order\" in template_sorting[t]\n        ):\n            templates[t][\"entries\"].update(\n                template_sorting[t][\"custom_insert_entries\"](sorted_missing)\n            )\n            templates[t][\"order\"] = template_sorting[t][\"custom_insert_order\"](\n                templates[t][\"order\"], sorted_missing\n            )\n\n    _templates[locale] = templates\n    _plugin_names = plugin_names\n    _plugin_vars = plugin_vars\n\n    return templates, plugin_names, plugin_vars\n\n\ndef _process_template_configs(name, implementation, configs, rules):\n    from jinja2.exceptions import TemplateNotFound\n\n    counters = defaultdict(lambda: 1)\n    includes = defaultdict(list)\n\n    for config in configs:\n        if not isinstance(config, dict):\n            continue\n        if \"type\" not in config:\n            continue\n\n        template_type = config[\"type\"]\n        del config[\"type\"]\n\n        if template_type not in rules:\n            continue\n        rule = rules[template_type]\n\n        data = _process_template_config(\n            name, implementation, rule, config=config, counter=counters[template_type]\n        )\n        if data is None:\n            continue\n\n        includes[template_type].append(rule[\"to_entry\"](data))\n        counters[template_type] += 1\n\n    for template_type in rules:\n        if len(includes[template_type]) == 0:\n            # if no template of that type was added by the config, we'll try to use the default template name\n            rule = rules[template_type]\n            data = _process_template_config(name, implementation, rule)\n            if data is not None:\n                try:\n                    app.jinja_env.get_or_select_template(data[\"template\"])\n                except TemplateNotFound:\n                    pass\n                except Exception:\n                    _logger.exception(\n                        \"Error in template {}, not going to include it\".format(\n                            data[\"template\"]\n                        )\n                    )\n                else:\n                    includes[template_type].append(rule[\"to_entry\"](data))\n\n    return includes\n\n\ndef _process_template_config(name, implementation, rule, config=None, counter=1):\n    if \"mandatory\" in rule:\n        for mandatory in rule[\"mandatory\"]:\n            if mandatory not in config:\n                return None\n\n    if config is None:\n        config = {}\n    data = dict(config)\n\n    if \"suffix\" not in data and counter > 1:\n        data[\"suffix\"] = \"_%d\" % counter\n\n    if \"div\" in data:\n        data[\"_div\"] = data[\"div\"]\n    elif \"div\" in rule:\n        data[\"_div\"] = rule[\"div\"](name)\n        if \"suffix\" in data:\n            data[\"_div\"] = data[\"_div\"] + data[\"suffix\"]\n        if not _valid_div_re.match(data[\"_div\"]):\n            _logger.warning(\n                \"Template config {} contains invalid div identifier {}, skipping it\".format(\n                    name, data[\"_div\"]\n                )\n            )\n            return None\n\n    if data.get(\"template\"):\n        data[\"template\"] = implementation.template_folder_key + \"/\" + data[\"template\"]\n    else:\n        data[\"template\"] = (\n            implementation.template_folder_key + \"/\" + rule[\"template\"](name)\n        )\n\n    if data.get(\"template_header\"):\n        data[\"template_header\"] = (\n            implementation.template_folder_key + \"/\" + data[\"template_header\"]\n        )\n\n    if \"name\" not in data:\n        data[\"name\"] = implementation._plugin_name\n\n    if \"custom_bindings\" not in data or data[\"custom_bindings\"]:\n        data_bind = \"allowBindings: true\"\n        if \"data_bind\" in data:\n            data_bind = data_bind + \", \" + data[\"data_bind\"]\n        data_bind = data_bind.replace('\"', '\\\\\"')\n        data[\"data_bind\"] = data_bind\n\n    data[\"_key\"] = \"plugin_\" + name\n    if \"suffix\" in data:\n        data[\"_key\"] += data[\"suffix\"]\n\n    data[\"_plugin\"] = name\n\n    return data\n\n\ndef _filter_templates(templates, template_filter):\n    filtered_templates = {}\n    for template_type, template_collection in templates.items():\n        filtered_entries = {}\n        for template_key, template_entry in template_collection[\"entries\"].items():\n            if template_filter(template_type, template_key):\n                filtered_entries[template_key] = template_entry\n        filtered_templates[template_type] = {\n            \"order\": list(\n                filter(lambda x: x in filtered_entries, template_collection[\"order\"])\n            ),\n            \"entries\": filtered_entries,\n        }\n    return filtered_templates\n\n\n@app.route(\"/robots.txt\")\ndef robotsTxt():\n    return send_from_directory(app.static_folder, \"robots.txt\")\n\n\n@app.route(\"/i18n/<string:locale>/<string:domain>.js\")\n@util.flask.conditional(lambda: _check_etag_and_lastmodified_for_i18n(), NOT_MODIFIED)\n@util.flask.etagged(\n    lambda _: _compute_etag_for_i18n(\n        request.view_args[\"locale\"], request.view_args[\"domain\"]\n    )\n)\n@util.flask.lastmodified(\n    lambda _: _compute_date_for_i18n(\n        request.view_args[\"locale\"], request.view_args[\"domain\"]\n    )\n)\ndef localeJs(locale, domain):\n    messages = {}\n    plural_expr = None\n\n    if locale != \"en\":\n        messages, plural_expr = _get_translations(locale, domain)\n\n    catalog = {\n        \"messages\": messages,\n        \"plural_expr\": plural_expr,\n        \"locale\": locale,\n        \"domain\": domain,\n    }\n\n    from flask import Response\n\n    return Response(\n        render_template(\"i18n.js.jinja2\", catalog=catalog),\n        content_type=\"application/x-javascript; charset=utf-8\",\n    )\n\n\n@app.route(\"/plugin_assets/<string:name>/<path:filename>\")\ndef plugin_assets(name, filename):\n    return redirect(url_for(\"plugin.\" + name + \".static\", filename=filename))\n\n\ndef _compute_etag_for_i18n(locale, domain, files=None, lastmodified=None):\n    if files is None:\n        files = _get_all_translationfiles(locale, domain)\n    if lastmodified is None:\n        lastmodified = _compute_date(files)\n    if lastmodified and not isinstance(lastmodified, str):\n        from werkzeug.http import http_date\n\n        lastmodified = http_date(lastmodified)\n\n    import hashlib\n\n    hash = hashlib.sha1()\n\n    def hash_update(value):\n        hash.update(value.encode(\"utf-8\"))\n\n    hash_update(\",\".join(sorted(files)))\n    if lastmodified:\n        hash_update(lastmodified)\n    return hash.hexdigest()\n\n\ndef _compute_date_for_i18n(locale, domain):\n    return _compute_date(_get_all_translationfiles(locale, domain))\n\n\ndef _compute_date(files):\n    # Note, we do not expect everything in 'files' to exist.\n    import stat\n    from datetime import datetime\n\n    from octoprint.util.tz import UTC_TZ\n\n    max_timestamp = 0\n    for path in files:\n        try:\n            # try to stat file. If an exception is thrown, its because it does not exist.\n            s = os.stat(path)\n            if stat.S_ISREG(s.st_mode) and s.st_mtime > max_timestamp:\n                # is a regular file and has a newer timestamp\n                max_timestamp = s.st_mtime\n        except Exception:\n            # path does not exist.\n            continue\n\n    if max_timestamp:\n        # we set the micros to 0 since microseconds are not speced for HTTP\n        max_timestamp = (\n            datetime.fromtimestamp(max_timestamp)\n            .replace(microsecond=0)\n            .replace(tzinfo=UTC_TZ)\n        )\n    return max_timestamp\n\n\ndef _check_etag_and_lastmodified_for_i18n():\n    locale = request.view_args[\"locale\"]\n    domain = request.view_args[\"domain\"]\n\n    etag_ok = util.flask.check_etag(\n        _compute_etag_for_i18n(request.view_args[\"locale\"], request.view_args[\"domain\"])\n    )\n\n    lastmodified = _compute_date_for_i18n(locale, domain)\n    lastmodified_ok = lastmodified is None or util.flask.check_lastmodified(lastmodified)\n\n    return etag_ok and lastmodified_ok\n\n\ndef _get_all_templates():\n    from octoprint.util.jinja import get_all_template_paths\n\n    return get_all_template_paths(app.jinja_loader)\n\n\ndef _get_all_assets():\n    from octoprint.util.jinja import get_all_asset_paths\n\n    return get_all_asset_paths(app.jinja_env.assets_environment, verifyExist=False)\n\n\ndef _get_all_translationfiles(locale, domain):\n    from flask import _request_ctx_stack\n\n    def get_po_path(basedir, locale, domain):\n        return os.path.join(basedir, locale, \"LC_MESSAGES\", f\"{domain}.po\")\n\n    po_files = []\n\n    user_base_path = os.path.join(\n        settings().getBaseFolder(\"translations\", check_writable=False)\n    )\n    user_plugin_path = os.path.join(user_base_path, \"_plugins\")\n\n    # plugin translations\n    plugins = octoprint.plugin.plugin_manager().enabled_plugins\n    for name, plugin in plugins.items():\n        dirs = [\n            os.path.join(user_plugin_path, name),\n            os.path.join(plugin.location, \"translations\"),\n        ]\n        for dirname in dirs:\n            po_files.append(get_po_path(dirname, locale, domain))\n\n    # core translations\n    ctx = _request_ctx_stack.top\n    base_path = os.path.join(ctx.app.root_path, \"translations\")\n\n    dirs = [user_base_path, base_path]\n    for dirname in dirs:\n        po_files.append(get_po_path(dirname, locale, domain))\n\n    return po_files\n\n\ndef _get_translations(locale, domain):\n    from babel.messages.pofile import read_po\n\n    from octoprint.util import dict_merge\n\n    messages = {}\n    plural_expr = None\n\n    def messages_from_po(path, locale, domain):\n        messages = {}\n        with open(path, encoding=\"utf-8\") as f:\n            catalog = read_po(f, locale=locale, domain=domain)\n\n            for message in catalog:\n                message_id = message.id\n                if isinstance(message_id, (list, tuple)):\n                    message_id = message_id[0]\n                if message.string:\n                    messages[message_id] = message.string\n\n        return messages, catalog.plural_expr\n\n    po_files = _get_all_translationfiles(locale, domain)\n    for po_file in po_files:\n        if not os.path.exists(po_file):\n            continue\n        po_messages, plural_expr = messages_from_po(po_file, locale, domain)\n        if po_messages is not None:\n            messages = dict_merge(messages, po_messages, in_place=True)\n\n    return messages, plural_expr\n"], "filenames": ["src/octoprint/server/views.py"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [174], "fixing_code_start_loc": [11], "fixing_code_end_loc": [184], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - DOM in GitHub repository octoprint/octoprint prior to 1.8.0.", "other": {"cve": {"id": "CVE-2022-1430", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-18T14:15:08.130", "lastModified": "2022-05-25T20:13:12.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - DOM in GitHub repository octoprint/octoprint prior to 1.8.0."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - DOM en el repositorio de GitHub octoprint/octoprint versiones anteriores a 1.8.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octoprint:octoprint:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.0", "matchCriteriaId": "CDF4E52F-D6FD-49EF-A45A-1C9659EF2C14"}]}]}], "references": [{"url": "https://github.com/octoprint/octoprint/commit/8087528e4a7ddd15c7d95ff662deb5ef7de90045", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0cd30d71-1e32-4a0b-b4c3-faaa1907b541", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octoprint/octoprint/commit/8087528e4a7ddd15c7d95ff662deb5ef7de90045"}}