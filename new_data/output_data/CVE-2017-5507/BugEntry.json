{"buggy_code": ["2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006). \n  * Enable alpha channel if background color is non-opaque (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n    \n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference \n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\t\t\t \n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            M   M  PPPP    CCCC                              %\n%                            MM MM  P   P  C                                  %\n%                            M M M  PPPP   C                                  %\n%                            M   M  P      C                                  %\n%                            M   M  P       CCCC                              %\n%                                                                             %\n%                                                                             %\n%              Read/Write Magick Persistant Cache Image Format                %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/version-private.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMPCImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M P C                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMPC() returns MagickTrue if the image format type, identified by the\n%  magick string, is an Magick Persistent Cache image.\n%\n%  The format of the IsMPC method is:\n%\n%      MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n{\n  if (length < 14)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"id=MagickCache\",14) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C A C H E I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMPCImage() reads an Magick Persistent Cache image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadMPCImage method is:\n%\n%      Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  Decompression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MagickPathExtent],\n    id[MagickPathExtent],\n    keyword[MagickPathExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MagickPathExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MagickPathExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MagickPathExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment,exception);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MagickPathExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MagickPathExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MagickPathExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'a':\n              case 'A':\n              {\n                if (LocaleCompare(keyword,\"alpha-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->alpha_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"alpha-trait\") == 0)\n                  {\n                    ssize_t\n                      alpha_trait;\n\n                    alpha_trait=ParseCommandOption(MagickPixelTraitOptions,\n                      MagickFalse,options);\n                    if (alpha_trait < 0)\n                      break;\n                    image->alpha_trait=(PixelTrait) alpha_trait;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->background_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->border_color,exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MagickPathExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile,exception);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->resolution.x=geometry_info.rho;\n                    image->resolution.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->resolution.y=image->resolution.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,\n                      MagickFalse,options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MagickPathExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MagickPathExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MagickPathExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              count=ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        /*\n          Create image colormap.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            size_t\n              packet_size;\n\n            unsigned char\n              *colormap;\n\n            /*\n              Read image colormap from file.\n            */\n            packet_size=(size_t) (3UL*depth/8UL);\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M P C I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMPCImage() adds properties for the Cache image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMPCImage method is:\n%\n%      size_t RegisterMPCImage(void)\n%\n*/\nModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MPC\",\"CACHE\",\n    \"Magick Persistent Cache image format\");\n  entry->flags|=CoderStealthFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"MPC\",\"MPC\",\"Magick Persistent Cache image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M P C I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMPCImage() removes format registrations made by the\n%  MPC module from the list of supported formats.\n%\n%  The format of the UnregisterMPCImage method is:\n%\n%      UnregisterMPCImage(void)\n%\n*/\nModuleExport void UnregisterMPCImage(void)\n{\n  (void) UnregisterMagickInfo(\"CACHE\");\n  (void) UnregisterMagickInfo(\"MPC\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M P C I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMPCImage() writes an Magick Persistent Cache image to a file.\n%\n%  The format of the WriteMPCImage method is:\n%\n%      MagickBooleanType WriteMPCImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    cache_filename[MagickPathExtent];\n\n  const char\n    *property,\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  /*\n    Open persistent cache.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  scene=0;\n  offset=0;\n  do\n  {\n    /*\n      Write persistent cache meta-information.\n    */\n    depth=GetImageQuantumDepth(image,MagickTrue);\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    (void) WriteBlobString(image,\"id=MagickCache\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"magick-signature=%u\\n\",\n      GetMagickSignature((const StringInfo *) NULL));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"class=%s  colors=%.20g  alpha-trait=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n      image->alpha_trait));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"columns=%.20g  rows=%.20g depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->colorspace != UndefinedColorspace)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"colorspace=%s\\n\",\n          CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"pixel-intensity=%s\\n\",CommandOptionToMnemonic(\n          MagickPixelIntensityOptions,image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"compression=%s  quality=%.20g\\n\",CommandOptionToMnemonic(\n          MagickCompressOptions,image->compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->resolution.x != 0) || (image->resolution.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"resolution=%gx%g\\n\",image->resolution.x,image->resolution.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"tile-offset=%+ld%+ld\\n\",(long) image->tile_offset.x,(long)\n           image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->iterations,(double) image->delay,(double)\n            image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",\n            (double) image->scene,(double) image->iterations,(double)\n            image->delay,(double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"iterations=%.20g\\n\",(double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"red-primary=\"\n          \"%g,%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"orientation=%s\\n\",CommandOptionToMnemonic(MagickOrientationOptions,\n          image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Generic profile.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MagickPathExtent,\n                \"profile:%s=%.20g\\n\",name,(double)\n                GetStringInfoLength(profile));\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property,exception);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if (isspace((int) ((unsigned char) value[i])) != 0)\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlobString(image,image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profiles.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          return(MagickFalse);\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (depth)\n          {\n            default:\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(image->colormap[i].red);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].green);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].blue);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(image->colormap[i].red);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].green);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].blue);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(\n                image->colormap[i].green);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Initialize persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,\n      exception);\n    if (status == MagickFalse)\n      ThrowWriterException(CacheError,\"UnableToPersistPixelCache\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        status=image->progress_monitor(SaveImagesTag,scene,\n          GetImageListLength(image),image->client_data);\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006). \n  * Enable alpha channel if background color is non-opaque (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n    \n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference \n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\t\t\t \n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            M   M  PPPP    CCCC                              %\n%                            MM MM  P   P  C                                  %\n%                            M M M  PPPP   C                                  %\n%                            M   M  P      C                                  %\n%                            M   M  P       CCCC                              %\n%                                                                             %\n%                                                                             %\n%              Read/Write Magick Persistant Cache Image Format                %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/version-private.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMPCImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M P C                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMPC() returns MagickTrue if the image format type, identified by the\n%  magick string, is an Magick Persistent Cache image.\n%\n%  The format of the IsMPC method is:\n%\n%      MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n{\n  if (length < 14)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"id=MagickCache\",14) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C A C H E I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMPCImage() reads an Magick Persistent Cache image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadMPCImage method is:\n%\n%      Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  Decompression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MagickPathExtent],\n    id[MagickPathExtent],\n    keyword[MagickPathExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MagickPathExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MagickPathExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MagickPathExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment,exception);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MagickPathExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MagickPathExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MagickPathExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'a':\n              case 'A':\n              {\n                if (LocaleCompare(keyword,\"alpha-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->alpha_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"alpha-trait\") == 0)\n                  {\n                    ssize_t\n                      alpha_trait;\n\n                    alpha_trait=ParseCommandOption(MagickPixelTraitOptions,\n                      MagickFalse,options);\n                    if (alpha_trait < 0)\n                      break;\n                    image->alpha_trait=(PixelTrait) alpha_trait;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->background_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->border_color,exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MagickPathExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile,exception);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->resolution.x=geometry_info.rho;\n                    image->resolution.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->resolution.y=image->resolution.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,\n                      MagickFalse,options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MagickPathExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MagickPathExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MagickPathExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              count=ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        /*\n          Create image colormap.\n        */\n        image->colormap=(PixelInfo *) AcquireQuantumMemory(image->colors+1,\n          sizeof(*image->colormap));\n        if (image->colormap == (PixelInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            size_t\n              packet_size;\n\n            unsigned char\n              *colormap;\n\n            /*\n              Read image colormap from file.\n            */\n            packet_size=(size_t) (3UL*depth/8UL);\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M P C I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMPCImage() adds properties for the Cache image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMPCImage method is:\n%\n%      size_t RegisterMPCImage(void)\n%\n*/\nModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MPC\",\"CACHE\",\n    \"Magick Persistent Cache image format\");\n  entry->flags|=CoderStealthFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"MPC\",\"MPC\",\"Magick Persistent Cache image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M P C I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMPCImage() removes format registrations made by the\n%  MPC module from the list of supported formats.\n%\n%  The format of the UnregisterMPCImage method is:\n%\n%      UnregisterMPCImage(void)\n%\n*/\nModuleExport void UnregisterMPCImage(void)\n{\n  (void) UnregisterMagickInfo(\"CACHE\");\n  (void) UnregisterMagickInfo(\"MPC\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M P C I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMPCImage() writes an Magick Persistent Cache image to a file.\n%\n%  The format of the WriteMPCImage method is:\n%\n%      MagickBooleanType WriteMPCImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    cache_filename[MagickPathExtent];\n\n  const char\n    *property,\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  /*\n    Open persistent cache.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  scene=0;\n  offset=0;\n  do\n  {\n    /*\n      Write persistent cache meta-information.\n    */\n    depth=GetImageQuantumDepth(image,MagickTrue);\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    (void) WriteBlobString(image,\"id=MagickCache\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"magick-signature=%u\\n\",\n      GetMagickSignature((const StringInfo *) NULL));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"class=%s  colors=%.20g  alpha-trait=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n      image->alpha_trait));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"columns=%.20g  rows=%.20g depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->colorspace != UndefinedColorspace)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"colorspace=%s\\n\",\n          CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"pixel-intensity=%s\\n\",CommandOptionToMnemonic(\n          MagickPixelIntensityOptions,image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"compression=%s  quality=%.20g\\n\",CommandOptionToMnemonic(\n          MagickCompressOptions,image->compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->resolution.x != 0) || (image->resolution.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"resolution=%gx%g\\n\",image->resolution.x,image->resolution.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"tile-offset=%+ld%+ld\\n\",(long) image->tile_offset.x,(long)\n           image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->iterations,(double) image->delay,(double)\n            image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",\n            (double) image->scene,(double) image->iterations,(double)\n            image->delay,(double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"iterations=%.20g\\n\",(double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"red-primary=\"\n          \"%g,%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"orientation=%s\\n\",CommandOptionToMnemonic(MagickOrientationOptions,\n          image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Generic profile.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MagickPathExtent,\n                \"profile:%s=%.20g\\n\",name,(double)\n                GetStringInfoLength(profile));\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property,exception);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if (isspace((int) ((unsigned char) value[i])) != 0)\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlobString(image,image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profiles.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          return(MagickFalse);\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (depth)\n          {\n            default:\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(image->colormap[i].red);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].green);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].blue);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(image->colormap[i].red);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].green);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].blue);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(\n                image->colormap[i].green);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Initialize persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,\n      exception);\n    if (status == MagickFalse)\n      ThrowWriterException(CacheError,\"UnableToPersistPixelCache\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        status=image->progress_monitor(SaveImagesTag,scene,\n          GetImageListLength(image),image->client_data);\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["ChangeLog", "coders/mpc.c"], "buggy_code_start_loc": [3, 69], "buggy_code_end_loc": [3, 933], "fixing_code_start_loc": [4, 70], "fixing_code_end_loc": [5, 936], "type": "CWE-772", "message": "Memory leak in coders/mpc.c in ImageMagick before 6.9.7-4 and 7.x before 7.0.4-4 allows remote attackers to cause a denial of service (memory consumption) via vectors involving a pixel cache.", "other": {"cve": {"id": "CVE-2017-5507", "sourceIdentifier": "security@debian.org", "published": "2017-03-24T15:59:01.027", "lastModified": "2020-10-15T16:08:43.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory leak in coders/mpc.c in ImageMagick before 6.9.7-4 and 7.x before 7.0.4-4 allows remote attackers to cause a denial of service (memory consumption) via vectors involving a pixel cache."}, {"lang": "es", "value": "La p\u00e9rdida de memoria en los coders/mpc.c en ImageMagick en versiones anteriores a 6.9.7-4 y 7.x en versiones anteriores a 7.0.4-4 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de vectores que implican una cach\u00e9 de p\u00edxeles."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.7-3", "matchCriteriaId": "17C70D1C-A994-459F-AED2-B14049E4043D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3799", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/16/6", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/17/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95752", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=851382", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/blob/6.9.7-4/ChangeLog", "source": "security@debian.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/blob/7.0.4-4/ChangeLog", "source": "security@debian.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/66e283e0a9c141b19fe6c4c39f4a41c0d3188ba8", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-09", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/66e283e0a9c141b19fe6c4c39f4a41c0d3188ba8"}}