{"buggy_code": ["// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Ethcore Webapplications for Parity\n#![warn(missing_docs)]\n#![cfg_attr(feature=\"nightly\", feature(plugin))]\n#![cfg_attr(feature=\"nightly\", plugin(clippy))]\n\nextern crate base32;\nextern crate futures;\nextern crate linked_hash_map;\nextern crate mime_guess;\nextern crate rand;\nextern crate rustc_serialize;\nextern crate serde;\nextern crate serde_json;\nextern crate time;\nextern crate unicase;\nextern crate url as url_lib;\nextern crate zip;\n\nextern crate jsonrpc_core;\nextern crate jsonrpc_http_server;\n\nextern crate ethcore_util as util;\nextern crate fetch;\nextern crate parity_dapps_glue as parity_dapps;\nextern crate parity_hash_fetch as hash_fetch;\nextern crate parity_reactor;\nextern crate parity_ui;\n\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate mime;\n#[macro_use]\nextern crate serde_derive;\n\n#[cfg(test)]\nextern crate ethcore_devtools as devtools;\n#[cfg(test)]\nextern crate env_logger;\n\n\nmod endpoint;\nmod apps;\nmod page;\nmod router;\nmod handlers;\nmod api;\nmod proxypac;\nmod url;\nmod web;\n#[cfg(test)]\nmod tests;\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse std::collections::HashMap;\n\nuse jsonrpc_http_server::{self as http, hyper};\n\nuse fetch::Fetch;\nuse parity_reactor::Remote;\n\npub use hash_fetch::urlhint::ContractClient;\n\n/// Indicates sync status\npub trait SyncStatus: Send + Sync {\n\t/// Returns true if there is a major sync happening.\n\tfn is_major_importing(&self) -> bool;\n}\n\nimpl<F> SyncStatus for F where F: Fn() -> bool + Send + Sync {\n\tfn is_major_importing(&self) -> bool { self() }\n}\n\n/// Validates Web Proxy tokens\npub trait WebProxyTokens: Send + Sync {\n\t/// Should return true if token is a valid web proxy access token.\n\tfn is_web_proxy_token_valid(&self, token: &str) -> bool;\n}\n\nimpl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {\n\tfn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }\n}\n\n/// Current supported endpoints.\npub struct Endpoints {\n\tendpoints: endpoint::Endpoints,\n}\n\nimpl Endpoints {\n\t/// Returns a current list of app endpoints.\n\tpub fn list(&self) -> Vec<apps::App> {\n\t\tself.endpoints.iter().filter_map(|(ref k, ref e)| {\n\t\t\te.info().map(|ref info| apps::App::from_info(k, info))\n\t\t}).collect()\n\t}\n}\n\n/// Dapps server as `jsonrpc-http-server` request middleware.\npub struct Middleware {\n\trouter: router::Router,\n\tendpoints: endpoint::Endpoints,\n}\n\nimpl Middleware {\n\t/// Get local endpoints handle.\n\tpub fn endpoints(&self) -> Endpoints {\n\t\tEndpoints {\n\t\t\tendpoints: self.endpoints.clone(),\n\t\t}\n\t}\n\n\t/// Creates new middleware for UI server.\n\tpub fn ui<F: Fetch + Clone>(\n\t\tremote: Remote,\n\t\tregistrar: Arc<ContractClient>,\n\t\tsync_status: Arc<SyncStatus>,\n\t\tfetch: F,\n\t\tdapps_domain: String,\n\t) -> Self {\n\t\tlet content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(\n\t\t\thash_fetch::urlhint::URLHintContract::new(registrar),\n\t\t\tsync_status,\n\t\t\tremote.clone(),\n\t\t\tfetch.clone(),\n\t\t).embeddable_on(None).allow_dapps(false));\n\t\tlet special = {\n\t\t\tlet mut special = special_endpoints(content_fetcher.clone());\n\t\t\tspecial.insert(router::SpecialEndpoint::Home, Some(apps::ui()));\n\t\t\tspecial\n\t\t};\n\t\tlet router = router::Router::new(\n\t\t\tcontent_fetcher,\n\t\t\tNone,\n\t\t\tspecial,\n\t\t\tNone,\n\t\t\tdapps_domain,\n\t\t);\n\n\t\tMiddleware {\n\t\t\trouter: router,\n\t\t\tendpoints: Default::default(),\n\t\t}\n\t}\n\n\t/// Creates new Dapps server middleware.\n\tpub fn dapps<F: Fetch + Clone>(\n\t\tremote: Remote,\n\t\tui_address: Option<(String, u16)>,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tdapps_domain: String,\n\t\tregistrar: Arc<ContractClient>,\n\t\tsync_status: Arc<SyncStatus>,\n\t\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\t\tfetch: F,\n\t) -> Self {\n\t\tlet content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(\n\t\t\thash_fetch::urlhint::URLHintContract::new(registrar),\n\t\t\tsync_status,\n\t\t\tremote.clone(),\n\t\t\tfetch.clone(),\n\t\t).embeddable_on(ui_address.clone()).allow_dapps(true));\n\t\tlet endpoints = apps::all_endpoints(\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tdapps_domain.clone(),\n\t\t\tui_address.clone(),\n\t\t\tweb_proxy_tokens,\n\t\t\tremote.clone(),\n\t\t\tfetch.clone(),\n\t\t);\n\n\t\tlet special = {\n\t\t\tlet mut special = special_endpoints(content_fetcher.clone());\n\t\t\tspecial.insert(router::SpecialEndpoint::Home, Some(apps::ui_redirection(ui_address.clone())));\n\t\t\tspecial\n\t\t};\n\n\t\tlet router = router::Router::new(\n\t\t\tcontent_fetcher,\n\t\t\tSome(endpoints.clone()),\n\t\t\tspecial,\n\t\t\tui_address,\n\t\t\tdapps_domain,\n\t\t);\n\n\t\tMiddleware {\n\t\t\trouter: router,\n\t\t\tendpoints: endpoints,\n\t\t}\n\t}\n}\n\nimpl http::RequestMiddleware for Middleware {\n\tfn on_request(&self, req: &hyper::server::Request<hyper::net::HttpStream>, control: &hyper::Control) -> http::RequestMiddlewareAction {\n\t\tself.router.on_request(req, control)\n\t}\n}\n\nfn special_endpoints(content_fetcher: Arc<apps::fetcher::Fetcher>) -> HashMap<router::SpecialEndpoint, Option<Box<endpoint::Endpoint>>> {\n\tlet mut special = HashMap::new();\n\tspecial.insert(router::SpecialEndpoint::Rpc, None);\n\tspecial.insert(router::SpecialEndpoint::Utils, Some(apps::utils()));\n\tspecial.insert(router::SpecialEndpoint::Api, Some(api::RestApi::new(content_fetcher)));\n\tspecial\n}\n\nfn address(address: &(String, u16)) -> String {\n\tformat!(\"{}:{}\", address.0, address.1)\n}\n\n/// Random filename\nfn random_filename() -> String {\n\tuse ::rand::Rng;\n\tlet mut rng = ::rand::OsRng::new().unwrap();\n\trng.gen_ascii_chars().take(12).collect()\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse devtools::http_client;\nuse rustc_serialize::hex::FromHex;\nuse tests::helpers::{\n\tserve_with_registrar, serve_with_registrar_and_sync, serve_with_fetch,\n\tserve_with_registrar_and_fetch, serve_with_registrar_and_fetch_and_threads,\n\trequest, assert_security_headers_for_embed,\n};\n\n#[test]\nfn should_resolve_dapp() {\n\t// given\n\tlet (server, registrar) = serve_with_registrar();\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 1472a9e190620cdf6b31f383373e45efcfe869a820c91f9ccd7eb9fb45e4985d.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 404 Not Found\");\n\tassert_eq!(registrar.calls.lock().len(), 2);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\n#[test]\nfn should_return_503_when_syncing_but_should_make_the_calls() {\n\t// given\n\tlet (server, registrar) = serve_with_registrar_and_sync();\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 1472a9e190620cdf6b31f383373e45efcfe869a820c91f9ccd7eb9fb45e4985d.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 503 Service Unavailable\");\n\tassert_eq!(registrar.calls.lock().len(), 2);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\nconst GAVCOIN_DAPP: &'static str = \"00000000000000000000000000000000000000000000000000000000000000609faf32e1e3845e237cc6efd27187cee13b3b99db000000000000000000000000000000000000000000000000d8bd350823e28ff75e74a34215faefdc8a52fd8e00000000000000000000000000000000000000000000000000000000000000116761766f66796f726b2f676176636f696e000000000000000000000000000000\";\nconst GAVCOIN_ICON: &'static str = \"00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8bd350823e28ff75e74a34215faefdc8a52fd8e000000000000000000000000000000000000000000000000000000000000007768747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f657468636f72652f646170702d6173736574732f623838653938336162616131613661363334356238643934343863313562313137646462353430652f746f6b656e732f676176636f696e2d36347836342e706e67000000000000000000\";\n\n#[test]\nfn should_return_502_on_hash_mismatch() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_DAPP.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"94f093625c06887d94d9fee0d5f9cc4aaa46f33d24d1c7e4b5237e7c37d547dd\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 94f093625c06887d94d9fee0d5f9cc4aaa46f33d24d1c7e4b5237e7c37d547dd.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://codeload.github.com/gavofyork/gavcoin/zip/9faf32e1e3845e237cc6efd27187cee13b3b99db\");\n\tfetch.assert_no_more_requests();\n\n\tresponse.assert_status(\"HTTP/1.1 502 Bad Gateway\");\n\tassert!(response.body.contains(\"HashMismatch\"), \"Expected hash mismatch response, got: {:?}\", response.body);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\n#[test]\nfn should_return_error_for_invalid_dapp_zip() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_DAPP.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://codeload.github.com/gavofyork/gavcoin/zip/9faf32e1e3845e237cc6efd27187cee13b3b99db\");\n\tfetch.assert_no_more_requests();\n\n\tresponse.assert_status(\"HTTP/1.1 502 Bad Gateway\");\n\tassert!(response.body.contains(\"InvalidArchive\"), \"Expected invalid zip response, got: {:?}\", response.body);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\n#[test]\nfn should_return_fetched_dapp_content() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_DAPP.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\tfetch.set_response(include_bytes!(\"../../res/gavcoin.zip\"));\n\n\t// when\n\tlet response1 = http_client::request(server.addr(),\n\t\t\"\\\n\t\t\tGET /index.html HTTP/1.1\\r\\n\\\n\t\t\tHost: 9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tlet response2 = http_client::request(server.addr(),\n\t\t\"\\\n\t\t\tGET /manifest.json HTTP/1.1\\r\\n\\\n\t\t\tHost: 9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://codeload.github.com/gavofyork/gavcoin/zip/9faf32e1e3845e237cc6efd27187cee13b3b99db\");\n\tfetch.assert_no_more_requests();\n\n\tresponse1.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response1.headers);\n\tassert_eq!(\n\t\tresponse1.body,\n\t\tr#\"18\n<h1>Hello Gavcoin!</h1>\n\n\"#\n\t);\n\n\tresponse2.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response2.headers);\n\tassert_eq!(\n\t\tresponse2.body,\n\t\tr#\"BE\n{\n  \"id\": \"9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a\",\n  \"name\": \"Gavcoin\",\n  \"description\": \"Gavcoin\",\n  \"version\": \"1.0.0\",\n  \"author\": \"\",\n  \"iconUrl\": \"icon.png\"\n}\n0\n\n\"#\n\t);\n}\n\n#[test]\nfn should_return_fetched_content() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_ICON.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://raw.githubusercontent.com/ethcore/dapp-assets/b88e983abaa1a6a6345b8d9448c15b117ddb540e/tokens/gavcoin-64x64.png\");\n\tfetch.assert_no_more_requests();\n\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tresponse.assert_security_headers_present(None);\n}\n\n#[test]\nfn should_cache_content() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_ICON.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\tlet request_str = \"\\\n\t\tGET / HTTP/1.1\\r\\n\\\n\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\tConnection: close\\r\\n\\\n\t\t\\r\\n\\\n\t\";\n\n\tlet response = http_client::request(server.addr(), request_str);\n\tfetch.assert_requested(\"https://raw.githubusercontent.com/ethcore/dapp-assets/b88e983abaa1a6a6345b8d9448c15b117ddb540e/tokens/gavcoin-64x64.png\");\n\tfetch.assert_no_more_requests();\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\n\t// when\n\tlet response = http_client::request(server.addr(), request_str);\n\n\t// then\n\tfetch.assert_no_more_requests();\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n}\n\n#[test]\nfn should_not_request_content_twice() {\n\tuse std::thread;\n\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch_and_threads(true);\n\tlet gavcoin = GAVCOIN_ICON.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\tlet request_str = \"\\\n\t\tGET / HTTP/1.1\\r\\n\\\n\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\tConnection: close\\r\\n\\\n\t\t\\r\\n\\\n\t\";\n\tlet fire_request = || {\n\t\tlet addr = server.addr().to_owned();\n\t\tlet req = request_str.to_owned();\n\t\tthread::spawn(move || {\n\t\t\thttp_client::request(&addr, &req)\n\t\t})\n\t};\n\tlet control = fetch.manual();\n\n\t// when\n\n\t// Fire two requests at the same time\n\tlet r1 = fire_request();\n\tlet r2 = fire_request();\n\n\t// wait for single request in fetch, the second one should go into waiting state.\n\tcontrol.wait_for_requests(1);\n\tcontrol.respond();\n\n\tlet response1 = r1.join().unwrap();\n\tlet response2 = r2.join().unwrap();\n\n\t// then\n\tfetch.assert_requested(\"https://raw.githubusercontent.com/ethcore/dapp-assets/b88e983abaa1a6a6345b8d9448c15b117ddb540e/tokens/gavcoin-64x64.png\");\n\tfetch.assert_no_more_requests();\n\tresponse1.assert_status(\"HTTP/1.1 200 OK\");\n\tresponse2.assert_status(\"HTTP/1.1 200 OK\");\n}\n\n#[test]\nfn should_encode_and_decode_base32() {\n\tuse base32;\n\n\tlet encoded = base32::encode(base32::Alphabet::Crockford, \"token+https://parity.io\".as_bytes());\n\tassert_eq!(\"EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY\", &encoded);\n\n\tlet data = base32::decode(base32::Alphabet::Crockford, \"EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY\").unwrap();\n\tassert_eq!(\"token+https://parity.io\", &String::from_utf8(data).unwrap());\n}\n\n#[test]\nfn should_stream_web_content() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://parity.io/\");\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_support_base32_encoded_web_urls() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_correctly_handle_long_label_when_splitted() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"xolrg9fePeQyKLnL\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: f1qprwk775k6am35a5wmpk3e9gnpgx3me1sk.mbsfcdqpwx3jd5h7ax39dxq2wvb5dhqpww3fe9t2wrvfdm.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://contribution.melonport.com/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\n\n#[test]\nfn should_support_base32_encoded_web_urls_as_path() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_return_error_on_invalid_token() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"test\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_return_error_on_invalid_protocol() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/token/ftp/parity.io/ HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_disallow_non_get_requests() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tPOST / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tContent-Type: application/json\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\t123\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 405 Method Not Allowed\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_fix_absolute_requests_based_on_referer() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_fix_absolute_requests_based_on_referer_in_url() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/?__referer=web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\n\tfetch.assert_no_more_requests();\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::env;\nuse std::str;\nuse std::net::SocketAddr;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse env_logger::LogBuilder;\nuse jsonrpc_core::IoHandler;\nuse jsonrpc_http_server::{self as http, Host, DomainsValidation};\n\nuse devtools::http_client;\nuse hash_fetch::urlhint::ContractClient;\nuse fetch::{Fetch, Client as FetchClient};\nuse parity_reactor::Remote;\n\nuse {Middleware, SyncStatus, WebProxyTokens};\n\nmod registrar;\nmod fetch;\n\nuse self::registrar::FakeRegistrar;\nuse self::fetch::FakeFetch;\n\nconst SIGNER_PORT: u16 = 18180;\n\nfn init_logger() {\n\t// Initialize logger\n\tif let Ok(log) = env::var(\"RUST_LOG\") {\n\t\tlet mut builder = LogBuilder::new();\n\t\tbuilder.parse(&log);\n\t\tlet _ = builder.init();\t// ignore errors since ./test.sh will call this multiple times.\n\t}\n}\n\npub fn init_server<F, B>(process: F, io: IoHandler, remote: Remote) -> (Server, Arc<FakeRegistrar>) where\n\tF: FnOnce(ServerBuilder) -> ServerBuilder<B>,\n\tB: Fetch,\n{\n\tinit_logger();\n\tlet registrar = Arc::new(FakeRegistrar::new());\n\tlet mut dapps_path = env::temp_dir();\n\tdapps_path.push(\"non-existent-dir-to-prevent-fs-files-from-loading\");\n\n\tlet server = process(ServerBuilder::new(\n\t\t&dapps_path, registrar.clone(), remote,\n\t))\n\t\t.signer_address(Some((\"127.0.0.1\".into(), SIGNER_PORT)))\n\t\t.start_unsecured_http(&\"127.0.0.1:0\".parse().unwrap(), io).unwrap();\n\t(\n\t\tserver,\n\t\tregistrar,\n\t)\n}\n\npub fn serve_with_rpc(io: IoHandler) -> Server {\n\tinit_server(|builder| builder, io, Remote::new_sync()).0\n}\n\npub fn serve_hosts(hosts: Option<Vec<String>>) -> Server {\n\tlet hosts = hosts.map(|hosts| hosts.into_iter().map(Into::into).collect());\n\tinit_server(|builder| builder.allowed_hosts(hosts.into()), Default::default(), Remote::new_sync()).0\n}\n\npub fn serve_with_registrar() -> (Server, Arc<FakeRegistrar>) {\n\tinit_server(|builder| builder, Default::default(), Remote::new_sync())\n}\n\npub fn serve_with_registrar_and_sync() -> (Server, Arc<FakeRegistrar>) {\n\tinit_server(|builder| {\n\t\tbuilder.sync_status(Arc::new(|| true))\n\t}, Default::default(), Remote::new_sync())\n}\n\npub fn serve_with_registrar_and_fetch() -> (Server, FakeFetch, Arc<FakeRegistrar>) {\n\tserve_with_registrar_and_fetch_and_threads(false)\n}\n\npub fn serve_with_registrar_and_fetch_and_threads(multi_threaded: bool) -> (Server, FakeFetch, Arc<FakeRegistrar>) {\n\tlet fetch = FakeFetch::default();\n\tlet f = fetch.clone();\n\tlet (server, reg) = init_server(move |builder| {\n\t\tbuilder.fetch(f.clone())\n\t}, Default::default(), if multi_threaded { Remote::new_thread_per_future() } else { Remote::new_sync() });\n\n\t(server, fetch, reg)\n}\n\npub fn serve_with_fetch(web_token: &'static str) -> (Server, FakeFetch) {\n\tlet fetch = FakeFetch::default();\n\tlet f = fetch.clone();\n\tlet (server, _) = init_server(move |builder| {\n\t\tbuilder\n\t\t\t.fetch(f.clone())\n\t\t\t.web_proxy_tokens(Arc::new(move |token| &token == web_token))\n\t}, Default::default(), Remote::new_sync());\n\n\t(server, fetch)\n}\n\npub fn serve() -> Server {\n\tinit_server(|builder| builder, Default::default(), Remote::new_sync()).0\n}\n\npub fn request(server: Server, request: &str) -> http_client::Response {\n\thttp_client::request(server.addr(), request)\n}\n\npub fn assert_security_headers(headers: &[String]) {\n\thttp_client::assert_security_headers_present(headers, None)\n}\npub fn assert_security_headers_for_embed(headers: &[String]) {\n\thttp_client::assert_security_headers_present(headers, Some(SIGNER_PORT))\n}\n\n\n/// Webapps HTTP+RPC server build.\npub struct ServerBuilder<T: Fetch = FetchClient> {\n\tdapps_path: PathBuf,\n\tregistrar: Arc<ContractClient>,\n\tsync_status: Arc<SyncStatus>,\n\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\tsigner_address: Option<(String, u16)>,\n\tallowed_hosts: DomainsValidation<Host>,\n\tremote: Remote,\n\tfetch: Option<T>,\n}\n\nimpl ServerBuilder {\n\t/// Construct new dapps server\n\tpub fn new<P: AsRef<Path>>(dapps_path: P, registrar: Arc<ContractClient>, remote: Remote) -> Self {\n\t\tServerBuilder {\n\t\t\tdapps_path: dapps_path.as_ref().to_owned(),\n\t\t\tregistrar: registrar,\n\t\t\tsync_status: Arc::new(|| false),\n\t\t\tweb_proxy_tokens: Arc::new(|_| false),\n\t\t\tsigner_address: None,\n\t\t\tallowed_hosts: DomainsValidation::Disabled,\n\t\t\tremote: remote,\n\t\t\tfetch: None,\n\t\t}\n\t}\n}\n\nimpl<T: Fetch> ServerBuilder<T> {\n\t/// Set a fetch client to use.\n\tpub fn fetch<X: Fetch>(self, fetch: X) -> ServerBuilder<X> {\n\t\tServerBuilder {\n\t\t\tdapps_path: self.dapps_path,\n\t\t\tregistrar: self.registrar,\n\t\t\tsync_status: self.sync_status,\n\t\t\tweb_proxy_tokens: self.web_proxy_tokens,\n\t\t\tsigner_address: self.signer_address,\n\t\t\tallowed_hosts: self.allowed_hosts,\n\t\t\tremote: self.remote,\n\t\t\tfetch: Some(fetch),\n\t\t}\n\t}\n\n\t/// Change default sync status.\n\tpub fn sync_status(mut self, status: Arc<SyncStatus>) -> Self {\n\t\tself.sync_status = status;\n\t\tself\n\t}\n\n\t/// Change default web proxy tokens validator.\n\tpub fn web_proxy_tokens(mut self, tokens: Arc<WebProxyTokens>) -> Self {\n\t\tself.web_proxy_tokens = tokens;\n\t\tself\n\t}\n\n\t/// Change default signer port.\n\tpub fn signer_address(mut self, signer_address: Option<(String, u16)>) -> Self {\n\t\tself.signer_address = signer_address;\n\t\tself\n\t}\n\n\t/// Change allowed hosts.\n\t/// `None` - All hosts are allowed\n\t/// `Some(whitelist)` - Allow only whitelisted hosts (+ listen address)\n\tpub fn allowed_hosts(mut self, allowed_hosts: DomainsValidation<Host>) -> Self {\n\t\tself.allowed_hosts = allowed_hosts;\n\t\tself\n\t}\n\n\t/// Asynchronously start server with no authentication,\n\t/// returns result with `Server` handle on success or an error.\n\tpub fn start_unsecured_http(self, addr: &SocketAddr, io: IoHandler) -> Result<Server, http::Error> {\n\t\tlet fetch = self.fetch_client();\n\t\tServer::start_http(\n\t\t\taddr,\n\t\t\tio,\n\t\t\tself.allowed_hosts,\n\t\t\tself.signer_address,\n\t\t\tself.dapps_path,\n\t\t\tvec![],\n\t\t\tself.registrar,\n\t\t\tself.sync_status,\n\t\t\tself.web_proxy_tokens,\n\t\t\tself.remote,\n\t\t\tfetch,\n\t\t)\n\t}\n\n\tfn fetch_client(&self) -> T {\n\t\tmatch self.fetch.clone() {\n\t\t\tSome(fetch) => fetch,\n\t\t\tNone => T::new().unwrap(),\n\t\t}\n\t}\n}\n\nconst DAPPS_DOMAIN: &'static str = \"web3.site\";\n\n/// Webapps HTTP server.\npub struct Server {\n\tserver: Option<http::Server>,\n}\n\nimpl Server {\n\tfn start_http<F: Fetch>(\n\t\taddr: &SocketAddr,\n\t\tio: IoHandler,\n\t\tallowed_hosts: DomainsValidation<Host>,\n\t\tsigner_address: Option<(String, u16)>,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tregistrar: Arc<ContractClient>,\n\t\tsync_status: Arc<SyncStatus>,\n\t\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\t\tremote: Remote,\n\t\tfetch: F,\n\t) -> Result<Server, http::Error> {\n\t\tlet middleware = Middleware::dapps(\n\t\t\tremote,\n\t\t\tsigner_address,\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tDAPPS_DOMAIN.into(),\n\t\t\tregistrar,\n\t\t\tsync_status,\n\t\t\tweb_proxy_tokens,\n\t\t\tfetch,\n\t\t);\n\n\t\tlet mut allowed_hosts: Option<Vec<Host>> = allowed_hosts.into();\n\t\tallowed_hosts.as_mut().map(|mut hosts| {\n\t\t\thosts.push(format!(\"http://*.{}:*\", DAPPS_DOMAIN).into());\n\t\t\thosts.push(format!(\"http://*.{}\", DAPPS_DOMAIN).into());\n\t\t});\n\n\t\thttp::ServerBuilder::new(io)\n\t\t\t.request_middleware(middleware)\n\t\t\t.allowed_hosts(allowed_hosts.into())\n\t\t\t.cors(http::DomainsValidation::Disabled)\n\t\t\t.start_http(addr)\n\t\t\t.map(|server| Server {\n\t\t\t\tserver: Some(server),\n\t\t\t})\n\t}\n\n\t/// Returns address that this server is bound to.\n\tpub fn addr(&self) -> &SocketAddr {\n\t\tself.server.as_ref()\n\t\t\t.expect(\"server is always Some at the start; it's consumed only when object is dropped; qed\")\n\t\t\t.addrs()\n\t\t\t.first()\n\t\t\t.expect(\"You cannot start the server without binding to at least one address; qed\")\n\t}\n}\n\nimpl Drop for Server {\n\tfn drop(&mut self) {\n\t\tself.server.take().unwrap().close()\n\t}\n}\n\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Serving web-based content (proxying)\n\nuse std::sync::Arc;\nuse fetch::{self, Fetch};\nuse parity_reactor::Remote;\n\nuse base32;\nuse hyper::{self, server, net, Next, Encoder, Decoder};\nuse hyper::status::StatusCode;\n\nuse apps;\nuse endpoint::{Endpoint, Handler, EndpointPath};\nuse handlers::{\n\tContentFetcherHandler, ContentHandler, ContentValidator, ValidatorResponse,\n\tStreamingHandler, extract_url,\n};\nuse url::Url;\nuse WebProxyTokens;\n\npub type Embeddable = Option<(String, u16)>;\n\npub struct Web<F> {\n\tembeddable_on: Embeddable,\n\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\tremote: Remote,\n\tfetch: F,\n}\n\nimpl<F: Fetch> Web<F> {\n\tpub fn boxed(embeddable_on: Embeddable, web_proxy_tokens: Arc<WebProxyTokens>, remote: Remote, fetch: F) -> Box<Endpoint> {\n\t\tBox::new(Web {\n\t\t\tembeddable_on: embeddable_on,\n\t\t\tweb_proxy_tokens: web_proxy_tokens,\n\t\t\tremote: remote,\n\t\t\tfetch: fetch,\n\t\t})\n\t}\n}\n\nimpl<F: Fetch> Endpoint for Web<F> {\n\tfn to_async_handler(&self, path: EndpointPath, control: hyper::Control) -> Box<Handler> {\n\t\tBox::new(WebHandler {\n\t\t\tcontrol: control,\n\t\t\tstate: State::Initial,\n\t\t\tpath: path,\n\t\t\tremote: self.remote.clone(),\n\t\t\tfetch: self.fetch.clone(),\n\t\t\tweb_proxy_tokens: self.web_proxy_tokens.clone(),\n\t\t\tembeddable_on: self.embeddable_on.clone(),\n\t\t})\n\t}\n}\n\nstruct WebInstaller {\n\tembeddable_on: Embeddable,\n\treferer: String,\n}\n\nimpl ContentValidator for WebInstaller {\n\ttype Error = String;\n\n\tfn validate_and_install(&self, response: fetch::Response) -> Result<ValidatorResponse, String> {\n\t\tlet status = StatusCode::from_u16(response.status().to_u16());\n\t\tlet is_html = response.is_html();\n\t\tlet mime = response.content_type().unwrap_or(mime!(Text/Html));\n\t\tlet mut handler = StreamingHandler::new(\n\t\t\tresponse,\n\t\t\tstatus,\n\t\t\tmime,\n\t\t\tself.embeddable_on.clone(),\n\t\t);\n\t\tif is_html {\n\t\t\thandler.set_initial_content(&format!(\n\t\t\t\tr#\"<script src=\"/{}/inject.js\"></script><script>history.replaceState({{}}, \"\", \"/?{}{}/{}\")</script>\"#,\n\t\t\t\tapps::UTILS_PATH,\n\t\t\t\tapps::URL_REFERER,\n\t\t\t\tapps::WEB_PATH,\n\t\t\t\t&self.referer,\n\t\t\t));\n\t\t}\n\t\tOk(ValidatorResponse::Streaming(handler))\n\t}\n}\n\nenum State<F: Fetch> {\n\tInitial,\n\tError(ContentHandler),\n\tFetching(ContentFetcherHandler<WebInstaller, F>),\n}\n\nstruct WebHandler<F: Fetch> {\n\tcontrol: hyper::Control,\n\tstate: State<F>,\n\tpath: EndpointPath,\n\tremote: Remote,\n\tfetch: F,\n\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\tembeddable_on: Embeddable,\n}\n\nimpl<F: Fetch> WebHandler<F> {\n\tfn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {\n\t\tlet token_and_url = self.path.app_params.get(0)\n\t\t\t.map(|encoded| encoded.replace('.', \"\"))\n\t\t\t.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))\n\t\t\t.and_then(|data| String::from_utf8(data).ok())\n\t\t\t.ok_or_else(|| State::Error(ContentHandler::error(\n\t\t\t\tStatusCode::BadRequest,\n\t\t\t\t\"Invalid parameter\",\n\t\t\t\t\"Couldn't parse given parameter:\",\n\t\t\t\tself.path.app_params.get(0).map(String::as_str),\n\t\t\t\tself.embeddable_on.clone()\n\t\t\t)))?;\n\n\t\tlet mut token_it = token_and_url.split('+');\n\t\tlet token = token_it.next();\n\t\tlet target_url = token_it.next();\n\n\t\t// Check if token supplied in URL is correct.\n\t\tmatch token {\n\t\t\tSome(token) if self.web_proxy_tokens.is_web_proxy_token_valid(token) => {},\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Access Token\", \"Invalid or old web proxy access token supplied.\", Some(\"Try refreshing the page.\"), self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t}\n\n\t\t// Validate protocol\n\t\tlet mut target_url = match target_url {\n\t\t\tSome(url) if url.starts_with(\"http://\") || url.starts_with(\"https://\") => url.to_owned(),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Protocol\", \"Invalid protocol used.\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\n\t\tif !target_url.ends_with(\"/\") {\n\t\t\ttarget_url = format!(\"{}/\", target_url);\n\t\t}\n\n\t\t// TODO [ToDr] Should just use `path.app_params`\n\t\tlet (path, query) = match (&url, self.path.using_dapps_domains) {\n\t\t\t(&Some(ref url), true) => (&url.path[..], &url.query),\n\t\t\t(&Some(ref url), false) => (&url.path[2..], &url.query),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid URL\", \"Couldn't parse URL\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\n\t\tlet query = match *query {\n\t\t\tSome(ref query) => format!(\"?{}\", query),\n\t\t\tNone => \"\".into(),\n\t\t};\n\n\t\tOk(format!(\"{}{}{}\", target_url, path.join(\"/\"), query))\n\t}\n}\n\nimpl<F: Fetch> server::Handler<net::HttpStream> for WebHandler<F> {\n\tfn on_request(&mut self, request: server::Request<net::HttpStream>) -> Next {\n\t\tlet url = extract_url(&request);\n\t\t// First extract the URL (reject invalid URLs)\n\t\tlet target_url = match self.extract_target_url(url) {\n\t\t\tOk(url) => url,\n\t\t\tErr(error) => {\n\t\t\t\tself.state = error;\n\t\t\t\treturn Next::write();\n\t\t\t}\n\t\t};\n\n\t\tlet mut handler = ContentFetcherHandler::new(\n\t\t\ttarget_url,\n\t\t\tself.path.clone(),\n\t\t\tself.control.clone(),\n\t\t\tWebInstaller {\n\t\t\t\tembeddable_on: self.embeddable_on.clone(),\n\t\t\t\treferer: self.path.app_params.get(0)\n\t\t\t\t\t.expect(\"`target_url` is valid; app_params is not empty;qed\")\n\t\t\t\t\t.to_owned(),\n\t\t\t},\n\t\t\tself.embeddable_on.clone(),\n\t\t\tself.remote.clone(),\n\t\t\tself.fetch.clone(),\n\t\t);\n\t\tlet res = handler.on_request(request);\n\t\tself.state = State::Fetching(handler);\n\n\t\tres\n\t}\n\n\tfn on_request_readable(&mut self, decoder: &mut Decoder<net::HttpStream>) -> Next {\n\t\tmatch self.state {\n\t\t\tState::Initial => Next::end(),\n\t\t\tState::Error(ref mut handler) => handler.on_request_readable(decoder),\n\t\t\tState::Fetching(ref mut handler) => handler.on_request_readable(decoder),\n\t\t}\n\t}\n\n\tfn on_response(&mut self, res: &mut server::Response) -> Next {\n\t\tmatch self.state {\n\t\t\tState::Initial => Next::end(),\n\t\t\tState::Error(ref mut handler) => handler.on_response(res),\n\t\t\tState::Fetching(ref mut handler) => handler.on_response(res),\n\t\t}\n\t}\n\n\tfn on_response_writable(&mut self, encoder: &mut Encoder<net::HttpStream>) -> Next {\n\t\tmatch self.state {\n\t\t\tState::Initial => Next::end(),\n\t\t\tState::Error(ref mut handler) => handler.on_response_writable(encoder),\n\t\t\tState::Fetching(ref mut handler) => handler.on_response_writable(encoder),\n\t\t}\n\t}\n}\n\n\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { inData, inNumber16, inOptions } from '../../format/input';\nimport { outSignerRequest } from '../../format/output';\n\nexport default class Signer {\n  constructor (transport) {\n    this._transport = transport;\n  }\n\n  confirmRequest (requestId, options, password) {\n    return this._transport\n      .execute('signer_confirmRequest', inNumber16(requestId), inOptions(options), password);\n  }\n\n  confirmRequestRaw (requestId, data) {\n    return this._transport\n      .execute('signer_confirmRequestRaw', inNumber16(requestId), inData(data));\n  }\n\n  confirmRequestWithToken (requestId, options, password) {\n    return this._transport\n      .execute('signer_confirmRequestWithToken', inNumber16(requestId), inOptions(options), password);\n  }\n\n  generateAuthorizationToken () {\n    return this._transport\n      .execute('signer_generateAuthorizationToken');\n  }\n\n  generateWebProxyAccessToken () {\n    return this._transport\n      .execute('signer_generateWebProxyAccessToken');\n  }\n\n  rejectRequest (requestId) {\n    return this._transport\n      .execute('signer_rejectRequest', inNumber16(requestId));\n  }\n\n  requestsToConfirm () {\n    return this._transport\n      .execute('signer_requestsToConfirm')\n      .then((requests) => (requests || []).map(outSignerRequest));\n  }\n\n  signerEnabled () {\n    return this._transport\n      .execute('signer_signerEnabled');\n  }\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { Quantity, Data } from '../types';\nimport { fromDecimal, Dummy } from '../helpers';\n\nexport default {\n  generateAuthorizationToken: {\n    desc: 'Generates a new authorization token.',\n    params: [],\n    returns: {\n      type: String,\n      desc: 'The new authorization token.',\n      example: 'bNGY-iIPB-j7zK-RSYZ'\n    }\n  },\n\n  generateWebProxyAccessToken: {\n    desc: 'Generates a new web proxy access token.',\n    params: [],\n    returns: {\n      type: String,\n      desc: 'The new web proxy access token.',\n      example: 'MOWm0tEJjwthDiTU'\n    }\n  },\n\n  requestsToConfirm: {\n    desc: 'Returns a list of the transactions awaiting authorization.',\n    params: [],\n    returns: {\n      // TODO: Types of the fields of transaction objects? Link to a transaction object in another page?\n      type: Array,\n      desc: 'A list of the outstanding transactions.',\n      example: new Dummy('[ ... ]')\n    }\n  },\n\n  confirmRequest: {\n    desc: 'Confirm a request in the signer queue',\n    params: [\n      {\n        type: Quantity,\n        desc: 'The request id.',\n        example: fromDecimal(1)\n      },\n      {\n        type: Object,\n        desc: 'Modify the transaction before confirmation.',\n        details: {\n          gasPrice: {\n            type: Quantity,\n            desc: 'Modify the gas price provided by the sender in Wei.',\n            optional: true\n          },\n          gas: {\n            type: Quantity,\n            desc: 'Gas provided by the sender in Wei.',\n            optional: true\n          },\n          condition: {\n            type: Object,\n            desc: 'Condition for scheduled transaction. Can be either an integer block number `{ block: 1 }` or UTC timestamp (in seconds) `{ timestamp: 1491290692 }`.',\n            optional: true\n          }\n        },\n        example: {}\n      },\n      {\n        type: String,\n        desc: 'The account password',\n        example: 'hunter2'\n      }\n    ],\n    returns: {\n      type: Object,\n      desc: 'The status of the confirmation, depending on the request type.',\n      example: {}\n    }\n  },\n\n  confirmRequestRaw: {\n    desc: 'Confirm a request in the signer queue providing signed request.',\n    params: [\n      {\n        type: Quantity,\n        desc: 'Integer - The request id',\n        example: fromDecimal(1)\n      },\n      {\n        type: Data,\n        desc: 'Signed request (RLP encoded transaction)',\n        example: '0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675'\n      }\n    ],\n    returns: {\n      type: Object,\n      desc: 'The status of the confirmation, depending on the request type.',\n      example: {}\n    }\n  },\n\n  confirmRequestWithToken: {\n    desc: 'Confirm specific request with rolling token.',\n    params: [\n      {\n        type: Quantity,\n        desc: 'The request id.',\n        example: fromDecimal(1)\n      },\n      {\n        type: Object,\n        desc: 'Modify the transaction before confirmation.',\n        details: {\n          gasPrice: {\n            type: Quantity,\n            desc: 'Modify the gas price provided by the sender in Wei.',\n            optional: true\n          },\n          gas: {\n            type: Quantity,\n            desc: 'Gas provided by the sender in Wei.',\n            optional: true\n          },\n          condition: {\n            type: Object,\n            desc: 'Conditional submission of the transaction. Can be either an integer block number `{ block: 1 }` or UTC timestamp (in seconds) `{ time: 1491290692 }` or `null`.',\n            optional: true\n          }\n        },\n        example: {}\n      },\n      {\n        type: String,\n        desc: 'Password (initially) or a token returned by the previous call.',\n        example: 'hunter2'\n      }\n    ],\n    returns: {\n      type: Object,\n      desc: 'Status.',\n      details: {\n        result: {\n          type: Object,\n          desc: 'The status of the confirmation, depending on the request type.'\n        },\n        token: {\n          type: String,\n          desc: 'Token used to authenticate the next request.'\n        }\n      },\n      example: {\n        result: new Dummy('{ ... }'),\n        token: 'cAF2w5LE7XUZ3v3N'\n      }\n    }\n  },\n\n  rejectRequest: {\n    desc: 'Rejects a request in the signer queue',\n    params: [\n      {\n        type: Quantity,\n        desc: 'Integer - The request id',\n        example: fromDecimal(1)\n      }\n    ],\n    returns: {\n      type: Boolean,\n      desc: 'The status of the rejection',\n      example: true\n    }\n  },\n\n  signerEnabled: {\n    nodoc: 'Not present in Rust code',\n    desc: 'Returns whether signer is enabled/disabled.',\n    params: [],\n    returns: {\n      type: Boolean,\n      desc: '`true` when enabled, `false` when disabled.',\n      example: true\n    }\n  }\n};\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { action, computed, observable, transaction } from 'mobx';\nimport localStore from 'store';\nimport { parse as parseUrl } from 'url';\n\nimport { encodePath, encodeUrl } from '~/util/dapplink';\n\nconst DEFAULT_URL = 'https://oasisdex.com';\nconst LS_LAST_ADDRESS = '_parity::webLastAddress';\n\nconst hasProtocol = /^https?:\\/\\//;\n\nlet instance = null;\n\nexport default class Store {\n  @observable counter = Date.now();\n  @observable currentUrl = null;\n  @observable history = [];\n  @observable isLoading = false;\n  @observable parsedUrl = null;\n  @observable nextUrl = null;\n  @observable token = null;\n\n  constructor (api) {\n    this._api = api;\n\n    this.nextUrl = this.currentUrl = this.loadLastUrl();\n  }\n\n  @computed get encodedPath () {\n    return `${this._api.dappsUrl}/web/${encodePath(this.token, this.currentUrl)}?t=${this.counter}`;\n  }\n\n  @computed get encodedUrl () {\n    return `http://${encodeUrl(this.token, this.currentUrl)}:${this._api.dappsPort}?t=${this.counter}`;\n  }\n\n  @computed get frameId () {\n    return `_web_iframe_${this.counter}`;\n  }\n\n  @computed get isPristine () {\n    return this.currentUrl === this.nextUrl;\n  }\n\n  @action gotoUrl = (_url) => {\n    transaction(() => {\n      let url = (_url || this.nextUrl).trim().replace(/\\/+$/, '');\n\n      if (!hasProtocol.test(url)) {\n        url = `https://${url}`;\n      }\n\n      this.setNextUrl(url);\n      this.setCurrentUrl(this.nextUrl);\n    });\n  }\n\n  @action reload = () => {\n    transaction(() => {\n      this.setLoading(true);\n      this.counter = Date.now();\n    });\n  }\n\n  @action restoreUrl = () => {\n    this.setNextUrl(this.currentUrl);\n  }\n\n  @action setHistory = (urls) => {\n    this.history = Object\n      .keys(urls)\n      .filter((url) => url && !url.startsWith(this._api.dappsUrl) && url.indexOf('127.0.0.1') === -1)\n      .sort((urlA, urlB) => {\n        const timeA = urls[urlA].getTime();\n        const timeB = urls[urlB].getTime();\n\n        if (timeA > timeB) {\n          return -1;\n        } else if (timeA < timeB) {\n          return 1;\n        }\n\n        return 0;\n      })\n      .map((url) => {\n        const hostname = url.replace(/^http[s]?:\\/\\//, '').split('/')[0];\n\n        return {\n          hostname,\n          timestamp: urls[url],\n          url\n        };\n      });\n  }\n\n  @action setLoading = (isLoading) => {\n    this.isLoading = isLoading;\n  }\n\n  @action setToken = (token) => {\n    this.token = token;\n  }\n\n  @action setCurrentUrl = (_url) => {\n    const url = _url || this.currentUrl;\n\n    transaction(() => {\n      this.currentUrl = url;\n      this.parsedUrl = parseUrl(url);\n\n      this.saveLastUrl();\n\n      this.reload();\n    });\n  }\n\n  @action setNextUrl = (url) => {\n    this.nextUrl = url;\n  }\n\n  generateToken = () => {\n    this.setToken(null);\n\n    return this._api.signer\n      .generateWebProxyAccessToken()\n      .then((token) => {\n        this.setToken(token);\n      })\n      .catch((error) => {\n        console.warn('generateToken', error);\n      });\n  }\n\n  loadHistory = () => {\n    return this._api.parity\n      .listRecentDapps()\n      .then((apps) => {\n        this.setHistory(apps);\n      })\n      .catch((error) => {\n        console.warn('loadHistory', error);\n      });\n  }\n\n  loadLastUrl = () => {\n    return localStore.get(LS_LAST_ADDRESS) || DEFAULT_URL;\n  }\n\n  saveLastUrl = () => {\n    return localStore.set(LS_LAST_ADDRESS, this.currentUrl);\n  }\n\n  static get (api) {\n    if (!instance) {\n      instance = new Store(api);\n    }\n\n    return instance;\n  }\n}\n\nexport {\n  DEFAULT_URL,\n  LS_LAST_ADDRESS\n};\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sinon from 'sinon';\n\nimport Store from './store';\n\nconst TEST_HISTORY_URLA = 'http://testingA';\nconst TEST_HISTORY_URLB = 'http://testingB';\nconst TEST_HISTORY = {\n  '': new Date(678),\n  [TEST_HISTORY_URLA]: new Date(123),\n  [TEST_HISTORY_URLB]: new Date(456)\n};\nconst TEST_TOKEN = 'testing-123';\nconst TEST_URL1 = 'http://some.test.domain.com';\nconst TEST_URL2 = 'http://something.different.com';\n\nlet api;\nlet store;\n\nfunction createApi () {\n  api = {\n    dappsPort: 8545,\n    dappsUrl: 'http://home.web3.site:8545',\n    parity: {\n      listRecentDapps: sinon.stub().resolves(TEST_HISTORY)\n    },\n    signer: {\n      generateWebProxyAccessToken: sinon.stub().resolves(TEST_TOKEN)\n    }\n  };\n\n  return api;\n}\n\nfunction create () {\n  store = new Store(createApi());\n\n  return store;\n}\n\ndescribe('views/Web/Store', () => {\n  beforeEach(() => {\n    create();\n  });\n\n  describe('@action', () => {\n    describe('gotoUrl', () => {\n      it('uses the nextUrl when none specified', () => {\n        store.setNextUrl('https://parity.io');\n        store.gotoUrl();\n\n        expect(store.currentUrl).to.equal('https://parity.io');\n      });\n\n      it('adds https when no protocol', () => {\n        store.gotoUrl('google.com');\n\n        expect(store.currentUrl).to.equal('https://google.com');\n      });\n    });\n\n    describe('restoreUrl', () => {\n      it('sets the nextUrl to the currentUrl', () => {\n        store.setCurrentUrl(TEST_URL1);\n        store.setNextUrl(TEST_URL2);\n        store.restoreUrl();\n\n        expect(store.nextUrl).to.equal(TEST_URL1);\n      });\n    });\n\n    describe('setCurrentUrl', () => {\n      beforeEach(() => {\n        store.setCurrentUrl(TEST_URL1);\n      });\n\n      it('sets the url', () => {\n        expect(store.currentUrl).to.equal(TEST_URL1);\n      });\n    });\n\n    describe('setHistory', () => {\n      let history;\n\n      beforeEach(() => {\n        store.setHistory(TEST_HISTORY);\n        history = store.history.peek();\n      });\n\n      it('sets the history', () => {\n        expect(history.length).to.equal(2);\n      });\n\n      it('adds hostname to entries', () => {\n        expect(history[1].hostname).to.be.ok;\n      });\n\n      it('removes hostname http prefixes', () => {\n        expect(history[1].hostname.indexOf('http')).to.equal(-1);\n      });\n\n      it('sorts the entries according to recently accessed', () => {\n        expect(history[0].url).to.equal(TEST_HISTORY_URLB);\n        expect(history[1].url).to.equal(TEST_HISTORY_URLA);\n      });\n    });\n\n    describe('setLoading', () => {\n      beforeEach(() => {\n        store.setLoading(true);\n      });\n\n      it('sets the loading state (true)', () => {\n        expect(store.isLoading).to.be.true;\n      });\n\n      it('sets the loading state (false)', () => {\n        store.setLoading(false);\n\n        expect(store.isLoading).to.be.false;\n      });\n    });\n\n    describe('setNextUrl', () => {\n      it('sets the url', () => {\n        store.setNextUrl(TEST_URL1);\n\n        expect(store.nextUrl).to.equal(TEST_URL1);\n      });\n    });\n\n    describe('setToken', () => {\n      it('sets the token', () => {\n        store.setToken(TEST_TOKEN);\n\n        expect(store.token).to.equal(TEST_TOKEN);\n      });\n    });\n  });\n\n  describe('@computed', () => {\n    describe('encodedUrl', () => {\n      describe('encodedPath', () => {\n        it('encodes current', () => {\n          store.setCurrentUrl(TEST_URL1);\n          expect(store.encodedPath).to.match(\n            /http:\\/\\/home\\.web3\\.site:8545\\/web\\/DSTPRV1BD1T78W1T5WQQ6VVDCMQ78SBKEGQ68VVDC5MPWBK3DXPG\\?t=[0-9]*$/\n          );\n        });\n      });\n\n      it('encodes current', () => {\n        store.setCurrentUrl(TEST_URL1);\n        expect(store.encodedUrl).to.match(\n          /^http:\\/\\/DSTPRV1BD1T78W1T5WQQ6VVDCMQ78SBKEGQ68VVDC5MPWBK3DXPG\\.web\\.web3\\.site:8545\\?t=[0-9]*$/\n        );\n      });\n    });\n\n    describe('frameId', () => {\n      it('creates an id', () => {\n        expect(store.frameId).to.be.ok;\n      });\n    });\n\n    describe('isPristine', () => {\n      it('is true when current === next', () => {\n        store.setCurrentUrl(TEST_URL1);\n        store.setNextUrl(TEST_URL1);\n\n        expect(store.isPristine).to.be.true;\n      });\n\n      it('is false when current !== next', () => {\n        store.setCurrentUrl(TEST_URL1);\n        store.setNextUrl(TEST_URL2);\n\n        expect(store.isPristine).to.be.false;\n      });\n    });\n  });\n\n  describe('operations', () => {\n    describe('generateToken', () => {\n      beforeEach(() => {\n        return store.generateToken();\n      });\n\n      it('calls signer_generateWebProxyAccessToken', () => {\n        expect(api.signer.generateWebProxyAccessToken).to.have.been.calledOnce;\n      });\n\n      it('sets the token as retrieved', () => {\n        expect(store.token).to.equal(TEST_TOKEN);\n      });\n    });\n\n    describe('loadHistory', () => {\n      beforeEach(() => {\n        return store.loadHistory();\n      });\n\n      it('calls parity_listRecentDapps', () => {\n        expect(api.parity.listRecentDapps).to.have.been.calledOnce;\n      });\n\n      it('sets the history as retrieved', () => {\n        expect(store.history.peek().length).not.to.equal(0);\n      });\n    });\n  });\n});\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { observer } from 'mobx-react';\nimport React, { Component, PropTypes } from 'react';\nimport { FormattedMessage } from 'react-intl';\n\nimport AddressBar from './AddressBar';\nimport Store from './store';\n\nimport styles from './web.css';\n\n@observer\nexport default class Web extends Component {\n  static contextTypes = {\n    api: PropTypes.object.isRequired\n  }\n\n  static propTypes = {\n    params: PropTypes.object.isRequired\n  }\n\n  store = Store.get(this.context.api);\n\n  componentDidMount () {\n    this.store.gotoUrl(this.props.params.url);\n    return this.store.generateToken();\n  }\n\n  componentWillReceiveProps (props) {\n    this.store.gotoUrl(props.params.url);\n  }\n\n  render () {\n    const { currentUrl, token } = this.store;\n\n    if (!token) {\n      return (\n        <div className={ styles.wrapper }>\n          <h1 className={ styles.loading }>\n            <FormattedMessage\n              id='web.requestToken'\n              defaultMessage='Requesting access token...'\n            />\n          </h1>\n        </div>\n      );\n    }\n\n    return currentUrl\n      ? this.renderFrame()\n      : null;\n  }\n\n  renderFrame () {\n    const { encodedPath, frameId } = this.store;\n\n    return (\n      <div className={ styles.wrapper }>\n        <AddressBar\n          className={ styles.url }\n          store={ this.store }\n        />\n        <iframe\n          className={ styles.frame }\n          frameBorder={ 0 }\n          id={ frameId }\n          name={ frameId }\n          onLoad={ this.iframeOnLoad }\n          sandbox='allow-forms allow-same-origin allow-scripts'\n          scrolling='auto'\n          src={ encodedPath }\n        />\n      </div>\n    );\n  }\n\n  iframeOnLoad = () => {\n    this.store.setLoading(false);\n  };\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\nuse dir::default_data_path;\nuse ethcore::client::{Client, BlockChainClient, BlockId};\nuse ethcore::transaction::{Transaction, Action};\nuse ethsync::LightSync;\nuse futures::{future, IntoFuture, Future, BoxFuture};\nuse hash_fetch::fetch::Client as FetchClient;\nuse hash_fetch::urlhint::ContractClient;\nuse helpers::replace_home;\nuse light::client::Client as LightClient;\nuse light::on_demand::{self, OnDemand};\nuse rpc;\nuse rpc_apis::SignerService;\nuse parity_reactor;\nuse util::{Bytes, Address};\n\n#[derive(Debug, PartialEq, Clone)]\npub struct Configuration {\n\tpub enabled: bool,\n\tpub dapps_path: PathBuf,\n\tpub extra_dapps: Vec<PathBuf>,\n}\n\nimpl Default for Configuration {\n\tfn default() -> Self {\n\t\tlet data_dir = default_data_path();\n\t\tConfiguration {\n\t\t\tenabled: true,\n\t\t\tdapps_path: replace_home(&data_dir, \"$BASE/dapps\").into(),\n\t\t\textra_dapps: vec![],\n\t\t}\n\t}\n}\n\nimpl Configuration {\n\tpub fn address(&self, address: Option<(String, u16)>) -> Option<(String, u16)> {\n\t\tmatch self.enabled {\n\t\t\ttrue => address,\n\t\t\tfalse => None,\n\t\t}\n\t}\n}\n\n/// Registrar implementation of the full client.\npub struct FullRegistrar {\n\t/// Handle to the full client.\n\tpub client: Arc<Client>,\n}\n\nimpl ContractClient for FullRegistrar {\n\tfn registrar(&self) -> Result<Address, String> {\n\t\tself.client.additional_params().get(\"registrar\")\n\t\t\t .ok_or_else(|| \"Registrar not defined.\".into())\n\t\t\t .and_then(|registrar| {\n\t\t\t\t registrar.parse().map_err(|e| format!(\"Invalid registrar address: {:?}\", e))\n\t\t\t })\n\t}\n\n\tfn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {\n\t\tself.client.call_contract(BlockId::Latest, address, data)\n\t\t\t.into_future()\n\t\t\t.boxed()\n\t}\n}\n\n/// Registrar implementation for the light client.\npub struct LightRegistrar {\n\t/// The light client.\n\tpub client: Arc<LightClient>,\n\t/// Handle to the on-demand service.\n\tpub on_demand: Arc<OnDemand>,\n\t/// Handle to the light network service.\n\tpub sync: Arc<LightSync>,\n}\n\nimpl ContractClient for LightRegistrar {\n\tfn registrar(&self) -> Result<Address, String> {\n\t\tself.client.engine().additional_params().get(\"registrar\")\n\t\t\t .ok_or_else(|| \"Registrar not defined.\".into())\n\t\t\t .and_then(|registrar| {\n\t\t\t\t registrar.parse().map_err(|e| format!(\"Invalid registrar address: {:?}\", e))\n\t\t\t })\n\t}\n\n\tfn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {\n\t\tlet (header, env_info) = (self.client.best_block_header(), self.client.latest_env_info());\n\n\t\tlet maybe_future = self.sync.with_context(move |ctx| {\n\t\t\tself.on_demand\n\t\t\t\t.request(ctx, on_demand::request::TransactionProof {\n\t\t\t\t\ttx: Transaction {\n\t\t\t\t\t\tnonce: self.client.engine().account_start_nonce(),\n\t\t\t\t\t\taction: Action::Call(address),\n\t\t\t\t\t\tgas: 50_000_000.into(),\n\t\t\t\t\t\tgas_price: 0.into(),\n\t\t\t\t\t\tvalue: 0.into(),\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t}.fake_sign(Address::default()),\n\t\t\t\t\theader: header.into(),\n\t\t\t\t\tenv_info: env_info,\n\t\t\t\t\tengine: self.client.engine().clone(),\n\t\t\t\t})\n\t\t\t\t.expect(\"No back-references; therefore all back-refs valid; qed\")\n\t\t\t\t.then(|res| match res {\n\t\t\t\t\tOk(Ok(executed)) => Ok(executed.output),\n\t\t\t\t\tOk(Err(e)) => Err(format!(\"Failed to execute transaction: {}\", e)),\n\t\t\t\t\tErr(_) => Err(format!(\"On-demand service dropped request unexpectedly.\")),\n\t\t\t\t})\n\t\t});\n\n\t\tmatch maybe_future {\n\t\t\tSome(fut) => fut.boxed(),\n\t\t\tNone => future::err(\"cannot query registry: network disabled\".into()).boxed(),\n\t\t}\n\t}\n}\n\n// TODO: light client implementation forwarding to OnDemand and waiting for future\n// to resolve.\n#[derive(Clone)]\npub struct Dependencies {\n\tpub sync_status: Arc<SyncStatus>,\n\tpub contract_client: Arc<ContractClient>,\n\tpub remote: parity_reactor::TokioRemote,\n\tpub fetch: FetchClient,\n\tpub signer: Arc<SignerService>,\n\tpub ui_address: Option<(String, u16)>,\n}\n\npub fn new(configuration: Configuration, deps: Dependencies) -> Result<Option<Middleware>, String> {\n\tif !configuration.enabled {\n\t\treturn Ok(None);\n\t}\n\n\tserver::dapps_middleware(\n\t\tdeps,\n\t\tconfiguration.dapps_path,\n\t\tconfiguration.extra_dapps,\n\t\trpc::DAPPS_DOMAIN.into(),\n\t).map(Some)\n}\n\npub fn new_ui(enabled: bool, deps: Dependencies) -> Result<Option<Middleware>, String> {\n\tif !enabled {\n\t\treturn Ok(None);\n\t}\n\n\tserver::ui_middleware(\n\t\tdeps,\n\t\trpc::DAPPS_DOMAIN.into(),\n\t).map(Some)\n}\n\npub use self::server::{SyncStatus, Middleware, service};\n\n#[cfg(not(feature = \"dapps\"))]\nmod server {\n\tuse super::Dependencies;\n\tuse std::sync::Arc;\n\tuse std::path::PathBuf;\n\tuse parity_rpc::{hyper, RequestMiddleware, RequestMiddlewareAction};\n\tuse rpc_apis;\n\n\tpub type SyncStatus = Fn() -> bool;\n\n\tpub struct Middleware;\n\timpl RequestMiddleware for Middleware {\n\t\tfn on_request(\n\t\t\t&self, _req: &hyper::server::Request<hyper::net::HttpStream>, _control: &hyper::Control\n\t\t) -> RequestMiddlewareAction {\n\t\t\tunreachable!()\n\t\t}\n\t}\n\n\tpub fn dapps_middleware(\n\t\t_deps: Dependencies,\n\t\t_dapps_path: PathBuf,\n\t\t_extra_dapps: Vec<PathBuf>,\n\t\t_dapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tErr(\"Your Parity version has been compiled without WebApps support.\".into())\n\t}\n\n\tpub fn ui_middleware(\n\t\t_deps: Dependencies,\n\t\t_dapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tErr(\"Your Parity version has been compiled without UI support.\".into())\n\t}\n\n\tpub fn service(_: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {\n\t\tNone\n\t}\n}\n\n#[cfg(feature = \"dapps\")]\nmod server {\n\tuse super::Dependencies;\n\tuse std::path::PathBuf;\n\tuse std::sync::Arc;\n\tuse rpc_apis;\n\n\tuse parity_dapps;\n\tuse parity_reactor;\n\n\tpub use parity_dapps::Middleware;\n\tpub use parity_dapps::SyncStatus;\n\n\tpub fn dapps_middleware(\n\t\tdeps: Dependencies,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tdapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tlet signer = deps.signer;\n\t\tlet parity_remote = parity_reactor::Remote::new(deps.remote.clone());\n\t\tlet web_proxy_tokens = Arc::new(move |token| signer.is_valid_web_proxy_access_token(&token));\n\n\t\tOk(parity_dapps::Middleware::dapps(\n\t\t\tparity_remote,\n\t\t\tdeps.ui_address,\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tdapps_domain,\n\t\t\tdeps.contract_client,\n\t\t\tdeps.sync_status,\n\t\t\tweb_proxy_tokens,\n\t\t\tdeps.fetch,\n\t\t))\n\t}\n\n\tpub fn ui_middleware(\n\t\tdeps: Dependencies,\n\t\tdapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tlet parity_remote = parity_reactor::Remote::new(deps.remote.clone());\n\t\tOk(parity_dapps::Middleware::ui(\n\t\t\tparity_remote,\n\t\t\tdeps.contract_client,\n\t\t\tdeps.sync_status,\n\t\t\tdeps.fetch,\n\t\t\tdapps_domain,\n\t\t))\n\t}\n\n\tpub fn service(middleware: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {\n\t\tmiddleware.as_ref().map(|m| Arc::new(DappsServiceWrapper {\n\t\t\tendpoints: m.endpoints()\n\t\t}) as Arc<rpc_apis::DappsService>)\n\t}\n\n\tpub struct DappsServiceWrapper {\n\t\tendpoints: parity_dapps::Endpoints,\n\t}\n\n\timpl rpc_apis::DappsService for DappsServiceWrapper {\n\t\tfn list_dapps(&self) -> Vec<rpc_apis::LocalDapp> {\n\t\t\tself.endpoints.list()\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|app| rpc_apis::LocalDapp {\n\t\t\t\t\tid: app.id,\n\t\t\t\t\tname: app.name,\n\t\t\t\t\tdescription: app.description,\n\t\t\t\t\tversion: app.version,\n\t\t\t\t\tauthor: app.author,\n\t\t\t\t\ticon_url: app.icon_url,\n\t\t\t\t})\n\t\t\t\t.collect()\n\t\t}\n\t}\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::sync::Arc;\nuse std::ops::Deref;\nuse util::Mutex;\nuse transient_hashmap::TransientHashMap;\n\nuse ethstore::random_string;\n\nuse v1::helpers::signing_queue::{ConfirmationsQueue};\n\nconst TOKEN_LIFETIME_SECS: u32 = 3600;\n\n/// Manages communication with Signer crate\npub struct SignerService {\n\tis_enabled: bool,\n\tqueue: Arc<ConfirmationsQueue>,\n\tweb_proxy_tokens: Mutex<TransientHashMap<String, ()>>,\n\tgenerate_new_token: Box<Fn() -> Result<String, String> + Send + Sync + 'static>,\n}\n\nimpl SignerService {\n\t/// Creates new Signer Service given function to generate new tokens.\n\tpub fn new<F>(new_token: F, is_enabled: bool) -> Self\n\t\twhere F: Fn() -> Result<String, String> + Send + Sync + 'static {\n\t\tSignerService {\n\t\t\tqueue: Arc::new(ConfirmationsQueue::default()),\n\t\t\tweb_proxy_tokens: Mutex::new(TransientHashMap::new(TOKEN_LIFETIME_SECS)),\n\t\t\tgenerate_new_token: Box::new(new_token),\n\t\t\tis_enabled: is_enabled,\n\t\t}\n\t}\n\n\t/// Checks if the token is valid web proxy access token.\n\tpub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {\n\t\tself.web_proxy_tokens.lock().contains_key(&token)\n\t}\n\n\t/// Generates a new web proxy access token.\n\tpub fn generate_web_proxy_access_token(&self) -> String {\n\t\tlet token = random_string(16);\n\t\tlet mut tokens = self.web_proxy_tokens.lock();\n\t\ttokens.prune();\n\t\ttokens.insert(token.clone(), ());\n\t\ttoken\n\t}\n\n\t/// Generates new signer authorization token.\n\tpub fn generate_token(&self) -> Result<String, String> {\n\t\t(self.generate_new_token)()\n\t}\n\n\t/// Returns a reference to `ConfirmationsQueue`\n\tpub fn queue(&self) -> Arc<ConfirmationsQueue> {\n\t\tself.queue.clone()\n\t}\n\n\t/// Returns true if Signer is enabled.\n\tpub fn is_enabled(&self) -> bool {\n\t\tself.is_enabled\n\t}\n\n\t#[cfg(test)]\n\t/// Creates new Signer Service for tests.\n\tpub fn new_test(is_enabled: bool) -> Self {\n\t\tSignerService::new(|| Ok(\"new_token\".into()), is_enabled)\n\t}\n}\n\nimpl Deref for SignerService {\n\ttype Target = ConfirmationsQueue;\n\tfn deref(&self) -> &Self::Target {\n\t\t&self.queue\n\t}\n}\n\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Transactions Confirmations rpc implementation\n\nuse std::sync::Arc;\n\nuse ethcore::account_provider::AccountProvider;\nuse ethcore::transaction::{SignedTransaction, PendingTransaction};\nuse ethkey;\nuse futures::{future, BoxFuture, Future, IntoFuture};\nuse parity_reactor::Remote;\nuse rlp::UntrustedRlp;\nuse util::Mutex;\n\nuse jsonrpc_core::{futures, Error};\nuse jsonrpc_pubsub::SubscriptionId;\nuse jsonrpc_macros::pubsub::{Sink, Subscriber};\nuse v1::helpers::accounts::unwrap_provider;\nuse v1::helpers::dispatch::{self, Dispatcher, WithToken, eth_data_hash};\nuse v1::helpers::{errors, SignerService, SigningQueue, ConfirmationPayload, FilledTransactionRequest, Subscribers};\nuse v1::metadata::Metadata;\nuse v1::traits::Signer;\nuse v1::types::{TransactionModification, ConfirmationRequest, ConfirmationResponse, ConfirmationResponseWithToken, U256, Bytes};\n\n/// Transactions confirmation (personal) rpc implementation.\npub struct SignerClient<D: Dispatcher> {\n\tsigner: Arc<SignerService>,\n\taccounts: Option<Arc<AccountProvider>>,\n\tdispatcher: D,\n\tsubscribers: Arc<Mutex<Subscribers<Sink<Vec<ConfirmationRequest>>>>>,\n}\n\nimpl<D: Dispatcher + 'static> SignerClient<D> {\n\t/// Create new instance of signer client.\n\tpub fn new(\n\t\tstore: &Option<Arc<AccountProvider>>,\n\t\tdispatcher: D,\n\t\tsigner: &Arc<SignerService>,\n\t\tremote: Remote,\n\t) -> Self {\n\t\tlet subscribers = Arc::new(Mutex::new(Subscribers::default()));\n\t\tlet subs = Arc::downgrade(&subscribers);\n\t\tlet s = Arc::downgrade(signer);\n\t\tsigner.queue().on_event(move |_event| {\n\t\t\tif let (Some(s), Some(subs)) = (s.upgrade(), subs.upgrade()) {\n\t\t\t\tlet requests = s.requests().into_iter().map(Into::into).collect::<Vec<ConfirmationRequest>>();\n\t\t\t\tfor subscription in subs.lock().values() {\n\t\t\t\t\tlet subscription: &Sink<_> = subscription;\n\t\t\t\t\tremote.spawn(subscription\n\t\t\t\t\t\t.notify(Ok(requests.clone()))\n\t\t\t\t\t\t.map(|_| ())\n\t\t\t\t\t\t.map_err(|e| warn!(target: \"rpc\", \"Unable to send notification: {}\", e))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tSignerClient {\n\t\t\tsigner: signer.clone(),\n\t\t\taccounts: store.clone(),\n\t\t\tdispatcher: dispatcher,\n\t\t\tsubscribers: subscribers,\n\t\t}\n\t}\n\n\tfn account_provider(&self) -> Result<Arc<AccountProvider>, Error> {\n\t\tunwrap_provider(&self.accounts)\n\t}\n\n\tfn confirm_internal<F, T>(&self, id: U256, modification: TransactionModification, f: F) -> BoxFuture<WithToken<ConfirmationResponse>, Error> where\n\t\tF: FnOnce(D, Arc<AccountProvider>, ConfirmationPayload) -> T,\n\t\tT: IntoFuture<Item=WithToken<ConfirmationResponse>, Error=Error>,\n\t\tT::Future: Send + 'static\n\t{\n\t\tlet id = id.into();\n\t\tlet dispatcher = self.dispatcher.clone();\n\n\t\tlet setup = || {\n\t\t\tOk((self.account_provider()?, self.signer.clone()))\n\t\t};\n\n\t\tlet (accounts, signer) = match setup() {\n\t\t\tOk(x) => x,\n\t\t\tErr(e) => return future::err(e).boxed(),\n\t\t};\n\n\t\tsigner.peek(&id).map(|confirmation| {\n\t\t\tlet mut payload = confirmation.payload.clone();\n\t\t\t// Modify payload\n\t\t\tif let ConfirmationPayload::SendTransaction(ref mut request) = payload {\n\t\t\t\tif let Some(sender) = modification.sender.clone() {\n\t\t\t\t\trequest.from = sender.into();\n\t\t\t\t\t// Altering sender should always reset the nonce.\n\t\t\t\t\trequest.nonce = None;\n\t\t\t\t}\n\t\t\t\tif let Some(gas_price) = modification.gas_price {\n\t\t\t\t\trequest.gas_price = gas_price.into();\n\t\t\t\t}\n\t\t\t\tif let Some(gas) = modification.gas {\n\t\t\t\t\trequest.gas = gas.into();\n\t\t\t\t}\n\t\t\t\tif let Some(ref condition) = modification.condition {\n\t\t\t\t\trequest.condition = condition.clone().map(Into::into);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet fut = f(dispatcher, accounts, payload);\n\t\t\tfut.into_future().then(move |result| {\n\t\t\t\t// Execute\n\t\t\t\tif let Ok(ref response) = result {\n\t\t\t\t\tsigner.request_confirmed(id, Ok((*response).clone()));\n\t\t\t\t}\n\n\t\t\t\tresult\n\t\t\t}).boxed()\n\t\t})\n\t\t.unwrap_or_else(|| future::err(errors::invalid_params(\"Unknown RequestID\", id)).boxed())\n\t}\n\n\tfn verify_transaction<F>(bytes: Bytes, request: FilledTransactionRequest, process: F) -> Result<ConfirmationResponse, Error> where\n\t\tF: FnOnce(PendingTransaction) -> Result<ConfirmationResponse, Error>,\n\t{\n\t\tlet signed_transaction = UntrustedRlp::new(&bytes.0).as_val().map_err(errors::from_rlp_error)?;\n\t\tlet signed_transaction = SignedTransaction::new(signed_transaction).map_err(|e| errors::invalid_params(\"Invalid signature.\", e))?;\n\t\tlet sender = signed_transaction.sender();\n\n\t\t// Verification\n\t\tlet sender_matches = sender == request.from;\n\t\tlet data_matches = signed_transaction.data == request.data;\n\t\tlet value_matches = signed_transaction.value == request.value;\n\t\tlet nonce_matches = match request.nonce {\n\t\t\tSome(nonce) => signed_transaction.nonce == nonce,\n\t\t\tNone => true,\n\t\t};\n\n\t\t// Dispatch if everything is ok\n\t\tif sender_matches && data_matches && value_matches && nonce_matches {\n\t\t\tlet pending_transaction = PendingTransaction::new(signed_transaction, request.condition.map(Into::into));\n\t\t\tprocess(pending_transaction)\n\t\t} else {\n\t\t\tlet mut error = Vec::new();\n\t\t\tif !sender_matches { error.push(\"from\") }\n\t\t\tif !data_matches { error.push(\"data\") }\n\t\t\tif !value_matches { error.push(\"value\") }\n\t\t\tif !nonce_matches { error.push(\"nonce\") }\n\n\t\t\tErr(errors::invalid_params(\"Sent transaction does not match the request.\", error))\n\t\t}\n\t}\n}\n\nimpl<D: Dispatcher + 'static> Signer for SignerClient<D> {\n\ttype Metadata = Metadata;\n\n\tfn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error> {\n\t\tOk(self.signer.requests()\n\t\t\t.into_iter()\n\t\t\t.map(Into::into)\n\t\t\t.collect()\n\t\t)\n\t}\n\n\t// TODO [ToDr] TransactionModification is redundant for some calls\n\t// might be better to replace it in future\n\tfn confirm_request(&self, id: U256, modification: TransactionModification, pass: String)\n\t\t-> BoxFuture<ConfirmationResponse, Error>\n\t{\n\t\tself.confirm_internal(id, modification, move |dis, accounts, payload| {\n\t\t\tdispatch::execute(dis, accounts, payload, dispatch::SignWith::Password(pass))\n\t\t}).map(|v| v.into_value()).boxed()\n\t}\n\n\tfn confirm_request_with_token(&self, id: U256, modification: TransactionModification, token: String)\n\t\t-> BoxFuture<ConfirmationResponseWithToken, Error>\n\t{\n\t\tself.confirm_internal(id, modification, move |dis, accounts, payload| {\n\t\t\tdispatch::execute(dis, accounts, payload, dispatch::SignWith::Token(token))\n\t\t}).and_then(|v| match v {\n\t\t\tWithToken::No(_) => Err(errors::internal(\"Unexpected response without token.\", \"\")),\n\t\t\tWithToken::Yes(response, token) => Ok(ConfirmationResponseWithToken {\n\t\t\t\tresult: response,\n\t\t\t\ttoken: token,\n\t\t\t}),\n\t\t}).boxed()\n\t}\n\n\tfn confirm_request_raw(&self, id: U256, bytes: Bytes) -> Result<ConfirmationResponse, Error> {\n\t\tlet id = id.into();\n\n\t\tself.signer.peek(&id).map(|confirmation| {\n\t\t\tlet result = match confirmation.payload {\n\t\t\t\tConfirmationPayload::SendTransaction(request) => {\n\t\t\t\t\tSelf::verify_transaction(bytes, request, |pending_transaction| {\n\t\t\t\t\t\tself.dispatcher.dispatch_transaction(pending_transaction)\n\t\t\t\t\t\t\t.map(Into::into)\n\t\t\t\t\t\t\t.map(ConfirmationResponse::SendTransaction)\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tConfirmationPayload::SignTransaction(request) => {\n\t\t\t\t\tSelf::verify_transaction(bytes, request, |pending_transaction| {\n\t\t\t\t\t\tOk(ConfirmationResponse::SignTransaction(pending_transaction.transaction.into()))\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tConfirmationPayload::EthSignMessage(address, data) => {\n\t\t\t\t\tlet expected_hash = eth_data_hash(data);\n\t\t\t\t\tlet signature = ethkey::Signature::from_electrum(&bytes.0);\n\t\t\t\t\tmatch ethkey::verify_address(&address, &signature, &expected_hash) {\n\t\t\t\t\t\tOk(true) => Ok(ConfirmationResponse::Signature(bytes.0.as_slice().into())),\n\t\t\t\t\t\tOk(false) => Err(errors::invalid_params(\"Sender address does not match the signature.\", ())),\n\t\t\t\t\t\tErr(err) => Err(errors::invalid_params(\"Invalid signature received.\", err)),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tConfirmationPayload::Decrypt(_address, _data) => {\n\t\t\t\t\t// TODO [ToDr]: Decrypt can we verify if the answer is correct?\n\t\t\t\t\tOk(ConfirmationResponse::Decrypt(bytes))\n\t\t\t\t},\n\t\t\t};\n\t\t\tif let Ok(ref response) = result {\n\t\t\t\tself.signer.request_confirmed(id, Ok(response.clone()));\n\t\t\t}\n\t\t\tresult\n\t\t}).unwrap_or_else(|| Err(errors::invalid_params(\"Unknown RequestID\", id)))\n\t}\n\n\tfn reject_request(&self, id: U256) -> Result<bool, Error> {\n\t\tlet res = self.signer.request_rejected(id.into());\n\t\tOk(res.is_some())\n\t}\n\n\tfn generate_token(&self) -> Result<String, Error> {\n\t\tself.signer.generate_token()\n\t\t\t.map_err(|e| errors::token(e))\n\t}\n\n\tfn generate_web_proxy_token(&self) -> Result<String, Error> {\n\t\tOk(self.signer.generate_web_proxy_access_token())\n\t}\n\n\tfn subscribe_pending(&self, _meta: Self::Metadata, sub: Subscriber<Vec<ConfirmationRequest>>) {\n\t\tself.subscribers.lock().push(sub)\n\t}\n\n\tfn unsubscribe_pending(&self, id: SubscriptionId) -> BoxFuture<bool, Error> {\n\t\tlet res = self.subscribers.lock().remove(&id).is_some();\n\t\tfutures::future::ok(res).boxed()\n\t}\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Parity Signer-related rpc interface.\nuse jsonrpc_core::Error;\nuse jsonrpc_pubsub::SubscriptionId;\nuse jsonrpc_macros::pubsub::Subscriber;\nuse futures::BoxFuture;\n\nuse v1::types::{U256, Bytes, TransactionModification, ConfirmationRequest, ConfirmationResponse, ConfirmationResponseWithToken};\n\nbuild_rpc_trait! {\n\t/// Signer extension for confirmations rpc interface.\n\tpub trait Signer {\n\t\ttype Metadata;\n\n\t\t/// Returns a list of items to confirm.\n\t\t#[rpc(name = \"signer_requestsToConfirm\")]\n\t\tfn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error>;\n\n\t\t/// Confirm specific request.\n\t\t#[rpc(async, name = \"signer_confirmRequest\")]\n\t\tfn confirm_request(&self, U256, TransactionModification, String) -> BoxFuture<ConfirmationResponse, Error>;\n\n\t\t/// Confirm specific request with token.\n\t\t#[rpc(async, name = \"signer_confirmRequestWithToken\")]\n\t\tfn confirm_request_with_token(&self, U256, TransactionModification, String) -> BoxFuture<ConfirmationResponseWithToken, Error>;\n\n\t\t/// Confirm specific request with already signed data.\n\t\t#[rpc(name = \"signer_confirmRequestRaw\")]\n\t\tfn confirm_request_raw(&self, U256, Bytes) -> Result<ConfirmationResponse, Error>;\n\n\t\t/// Reject the confirmation request.\n\t\t#[rpc(name = \"signer_rejectRequest\")]\n\t\tfn reject_request(&self, U256) -> Result<bool, Error>;\n\n\t\t/// Generates new authorization token.\n\t\t#[rpc(name = \"signer_generateAuthorizationToken\")]\n\t\tfn generate_token(&self) -> Result<String, Error>;\n\n\t\t/// Generates new web proxy access token.\n\t\t#[rpc(name = \"signer_generateWebProxyAccessToken\")]\n\t\tfn generate_web_proxy_token(&self) -> Result<String, Error>;\n\n\t\t#[pubsub(name = \"signer_pending\")] {\n\t\t\t/// Subscribe to new pending requests on signer interface.\n\t\t\t#[rpc(name = \"signer_subscribePending\")]\n\t\t\tfn subscribe_pending(&self, Self::Metadata, Subscriber<Vec<ConfirmationRequest>>);\n\n\t\t\t/// Unsubscribe from pending requests subscription.\n\t\t\t#[rpc(name = \"signer_unsubscribePending\")]\n\t\t\tfn unsubscribe_pending(&self, SubscriptionId) -> BoxFuture<bool, Error>;\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Ethcore Webapplications for Parity\n#![warn(missing_docs)]\n#![cfg_attr(feature=\"nightly\", feature(plugin))]\n#![cfg_attr(feature=\"nightly\", plugin(clippy))]\n\nextern crate base32;\nextern crate futures;\nextern crate linked_hash_map;\nextern crate mime_guess;\nextern crate rand;\nextern crate rustc_serialize;\nextern crate serde;\nextern crate serde_json;\nextern crate time;\nextern crate unicase;\nextern crate url as url_lib;\nextern crate zip;\n\nextern crate jsonrpc_core;\nextern crate jsonrpc_http_server;\n\nextern crate ethcore_util as util;\nextern crate fetch;\nextern crate parity_dapps_glue as parity_dapps;\nextern crate parity_hash_fetch as hash_fetch;\nextern crate parity_reactor;\nextern crate parity_ui;\n\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate mime;\n#[macro_use]\nextern crate serde_derive;\n\n#[cfg(test)]\nextern crate ethcore_devtools as devtools;\n#[cfg(test)]\nextern crate env_logger;\n\n\nmod endpoint;\nmod apps;\nmod page;\nmod router;\nmod handlers;\nmod api;\nmod proxypac;\nmod url;\nmod web;\n#[cfg(test)]\nmod tests;\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse std::collections::HashMap;\n\nuse jsonrpc_http_server::{self as http, hyper, Origin};\n\nuse fetch::Fetch;\nuse parity_reactor::Remote;\n\npub use hash_fetch::urlhint::ContractClient;\n\n/// Indicates sync status\npub trait SyncStatus: Send + Sync {\n\t/// Returns true if there is a major sync happening.\n\tfn is_major_importing(&self) -> bool;\n}\n\nimpl<F> SyncStatus for F where F: Fn() -> bool + Send + Sync {\n\tfn is_major_importing(&self) -> bool { self() }\n}\n\n/// Validates Web Proxy tokens\npub trait WebProxyTokens: Send + Sync {\n\t/// Should return a domain allowed to be accessed by this token or `None` if the token is not valid\n\tfn domain(&self, token: &str) -> Option<Origin>;\n}\n\nimpl<F> WebProxyTokens for F where F: Fn(String) -> Option<Origin> + Send + Sync {\n\tfn domain(&self, token: &str) -> Option<Origin> { self(token.to_owned()) }\n}\n\n/// Current supported endpoints.\npub struct Endpoints {\n\tendpoints: endpoint::Endpoints,\n}\n\nimpl Endpoints {\n\t/// Returns a current list of app endpoints.\n\tpub fn list(&self) -> Vec<apps::App> {\n\t\tself.endpoints.iter().filter_map(|(ref k, ref e)| {\n\t\t\te.info().map(|ref info| apps::App::from_info(k, info))\n\t\t}).collect()\n\t}\n}\n\n/// Dapps server as `jsonrpc-http-server` request middleware.\npub struct Middleware {\n\trouter: router::Router,\n\tendpoints: endpoint::Endpoints,\n}\n\nimpl Middleware {\n\t/// Get local endpoints handle.\n\tpub fn endpoints(&self) -> Endpoints {\n\t\tEndpoints {\n\t\t\tendpoints: self.endpoints.clone(),\n\t\t}\n\t}\n\n\t/// Creates new middleware for UI server.\n\tpub fn ui<F: Fetch + Clone>(\n\t\tremote: Remote,\n\t\tregistrar: Arc<ContractClient>,\n\t\tsync_status: Arc<SyncStatus>,\n\t\tfetch: F,\n\t\tdapps_domain: String,\n\t) -> Self {\n\t\tlet content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(\n\t\t\thash_fetch::urlhint::URLHintContract::new(registrar),\n\t\t\tsync_status,\n\t\t\tremote.clone(),\n\t\t\tfetch.clone(),\n\t\t).embeddable_on(None).allow_dapps(false));\n\t\tlet special = {\n\t\t\tlet mut special = special_endpoints(content_fetcher.clone());\n\t\t\tspecial.insert(router::SpecialEndpoint::Home, Some(apps::ui()));\n\t\t\tspecial\n\t\t};\n\t\tlet router = router::Router::new(\n\t\t\tcontent_fetcher,\n\t\t\tNone,\n\t\t\tspecial,\n\t\t\tNone,\n\t\t\tdapps_domain,\n\t\t);\n\n\t\tMiddleware {\n\t\t\trouter: router,\n\t\t\tendpoints: Default::default(),\n\t\t}\n\t}\n\n\t/// Creates new Dapps server middleware.\n\tpub fn dapps<F: Fetch + Clone>(\n\t\tremote: Remote,\n\t\tui_address: Option<(String, u16)>,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tdapps_domain: String,\n\t\tregistrar: Arc<ContractClient>,\n\t\tsync_status: Arc<SyncStatus>,\n\t\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\t\tfetch: F,\n\t) -> Self {\n\t\tlet content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(\n\t\t\thash_fetch::urlhint::URLHintContract::new(registrar),\n\t\t\tsync_status,\n\t\t\tremote.clone(),\n\t\t\tfetch.clone(),\n\t\t).embeddable_on(ui_address.clone()).allow_dapps(true));\n\t\tlet endpoints = apps::all_endpoints(\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tdapps_domain.clone(),\n\t\t\tui_address.clone(),\n\t\t\tweb_proxy_tokens,\n\t\t\tremote.clone(),\n\t\t\tfetch.clone(),\n\t\t);\n\n\t\tlet special = {\n\t\t\tlet mut special = special_endpoints(content_fetcher.clone());\n\t\t\tspecial.insert(router::SpecialEndpoint::Home, Some(apps::ui_redirection(ui_address.clone())));\n\t\t\tspecial\n\t\t};\n\n\t\tlet router = router::Router::new(\n\t\t\tcontent_fetcher,\n\t\t\tSome(endpoints.clone()),\n\t\t\tspecial,\n\t\t\tui_address,\n\t\t\tdapps_domain,\n\t\t);\n\n\t\tMiddleware {\n\t\t\trouter: router,\n\t\t\tendpoints: endpoints,\n\t\t}\n\t}\n}\n\nimpl http::RequestMiddleware for Middleware {\n\tfn on_request(&self, req: &hyper::server::Request<hyper::net::HttpStream>, control: &hyper::Control) -> http::RequestMiddlewareAction {\n\t\tself.router.on_request(req, control)\n\t}\n}\n\nfn special_endpoints(content_fetcher: Arc<apps::fetcher::Fetcher>) -> HashMap<router::SpecialEndpoint, Option<Box<endpoint::Endpoint>>> {\n\tlet mut special = HashMap::new();\n\tspecial.insert(router::SpecialEndpoint::Rpc, None);\n\tspecial.insert(router::SpecialEndpoint::Utils, Some(apps::utils()));\n\tspecial.insert(router::SpecialEndpoint::Api, Some(api::RestApi::new(content_fetcher)));\n\tspecial\n}\n\nfn address(address: &(String, u16)) -> String {\n\tformat!(\"{}:{}\", address.0, address.1)\n}\n\n/// Random filename\nfn random_filename() -> String {\n\tuse ::rand::Rng;\n\tlet mut rng = ::rand::OsRng::new().unwrap();\n\trng.gen_ascii_chars().take(12).collect()\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse devtools::http_client;\nuse rustc_serialize::hex::FromHex;\nuse tests::helpers::{\n\tserve_with_registrar, serve_with_registrar_and_sync, serve_with_fetch,\n\tserve_with_registrar_and_fetch, serve_with_registrar_and_fetch_and_threads,\n\trequest, assert_security_headers_for_embed,\n};\n\n#[test]\nfn should_resolve_dapp() {\n\t// given\n\tlet (server, registrar) = serve_with_registrar();\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 1472a9e190620cdf6b31f383373e45efcfe869a820c91f9ccd7eb9fb45e4985d.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 404 Not Found\");\n\tassert_eq!(registrar.calls.lock().len(), 2);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\n#[test]\nfn should_return_503_when_syncing_but_should_make_the_calls() {\n\t// given\n\tlet (server, registrar) = serve_with_registrar_and_sync();\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 1472a9e190620cdf6b31f383373e45efcfe869a820c91f9ccd7eb9fb45e4985d.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 503 Service Unavailable\");\n\tassert_eq!(registrar.calls.lock().len(), 2);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\nconst GAVCOIN_DAPP: &'static str = \"00000000000000000000000000000000000000000000000000000000000000609faf32e1e3845e237cc6efd27187cee13b3b99db000000000000000000000000000000000000000000000000d8bd350823e28ff75e74a34215faefdc8a52fd8e00000000000000000000000000000000000000000000000000000000000000116761766f66796f726b2f676176636f696e000000000000000000000000000000\";\nconst GAVCOIN_ICON: &'static str = \"00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8bd350823e28ff75e74a34215faefdc8a52fd8e000000000000000000000000000000000000000000000000000000000000007768747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f657468636f72652f646170702d6173736574732f623838653938336162616131613661363334356238643934343863313562313137646462353430652f746f6b656e732f676176636f696e2d36347836342e706e67000000000000000000\";\n\n#[test]\nfn should_return_502_on_hash_mismatch() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_DAPP.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"94f093625c06887d94d9fee0d5f9cc4aaa46f33d24d1c7e4b5237e7c37d547dd\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 94f093625c06887d94d9fee0d5f9cc4aaa46f33d24d1c7e4b5237e7c37d547dd.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://codeload.github.com/gavofyork/gavcoin/zip/9faf32e1e3845e237cc6efd27187cee13b3b99db\");\n\tfetch.assert_no_more_requests();\n\n\tresponse.assert_status(\"HTTP/1.1 502 Bad Gateway\");\n\tassert!(response.body.contains(\"HashMismatch\"), \"Expected hash mismatch response, got: {:?}\", response.body);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\n#[test]\nfn should_return_error_for_invalid_dapp_zip() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_DAPP.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://codeload.github.com/gavofyork/gavcoin/zip/9faf32e1e3845e237cc6efd27187cee13b3b99db\");\n\tfetch.assert_no_more_requests();\n\n\tresponse.assert_status(\"HTTP/1.1 502 Bad Gateway\");\n\tassert!(response.body.contains(\"InvalidArchive\"), \"Expected invalid zip response, got: {:?}\", response.body);\n\tassert_security_headers_for_embed(&response.headers);\n}\n\n#[test]\nfn should_return_fetched_dapp_content() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_DAPP.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\tfetch.set_response(include_bytes!(\"../../res/gavcoin.zip\"));\n\n\t// when\n\tlet response1 = http_client::request(server.addr(),\n\t\t\"\\\n\t\t\tGET /index.html HTTP/1.1\\r\\n\\\n\t\t\tHost: 9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tlet response2 = http_client::request(server.addr(),\n\t\t\"\\\n\t\t\tGET /manifest.json HTTP/1.1\\r\\n\\\n\t\t\tHost: 9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://codeload.github.com/gavofyork/gavcoin/zip/9faf32e1e3845e237cc6efd27187cee13b3b99db\");\n\tfetch.assert_no_more_requests();\n\n\tresponse1.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response1.headers);\n\tassert_eq!(\n\t\tresponse1.body,\n\t\tr#\"18\n<h1>Hello Gavcoin!</h1>\n\n\"#\n\t);\n\n\tresponse2.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response2.headers);\n\tassert_eq!(\n\t\tresponse2.body,\n\t\tr#\"BE\n{\n  \"id\": \"9c94e154dab8acf859b30ee80fc828fb1d38359d938751b65db71d460588d82a\",\n  \"name\": \"Gavcoin\",\n  \"description\": \"Gavcoin\",\n  \"version\": \"1.0.0\",\n  \"author\": \"\",\n  \"iconUrl\": \"icon.png\"\n}\n0\n\n\"#\n\t);\n}\n\n#[test]\nfn should_return_fetched_content() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_ICON.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tassert_eq!(registrar.calls.lock().len(), 4);\n\n\tfetch.assert_requested(\"https://raw.githubusercontent.com/ethcore/dapp-assets/b88e983abaa1a6a6345b8d9448c15b117ddb540e/tokens/gavcoin-64x64.png\");\n\tfetch.assert_no_more_requests();\n\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tresponse.assert_security_headers_present(None);\n}\n\n#[test]\nfn should_cache_content() {\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch();\n\tlet gavcoin = GAVCOIN_ICON.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\tlet request_str = \"\\\n\t\tGET / HTTP/1.1\\r\\n\\\n\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\tConnection: close\\r\\n\\\n\t\t\\r\\n\\\n\t\";\n\n\tlet response = http_client::request(server.addr(), request_str);\n\tfetch.assert_requested(\"https://raw.githubusercontent.com/ethcore/dapp-assets/b88e983abaa1a6a6345b8d9448c15b117ddb540e/tokens/gavcoin-64x64.png\");\n\tfetch.assert_no_more_requests();\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\n\t// when\n\tlet response = http_client::request(server.addr(), request_str);\n\n\t// then\n\tfetch.assert_no_more_requests();\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n}\n\n#[test]\nfn should_not_request_content_twice() {\n\tuse std::thread;\n\n\t// given\n\tlet (server, fetch, registrar) = serve_with_registrar_and_fetch_and_threads(true);\n\tlet gavcoin = GAVCOIN_ICON.from_hex().unwrap();\n\tregistrar.set_result(\n\t\t\"2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e\".parse().unwrap(),\n\t\tOk(gavcoin.clone())\n\t);\n\tlet request_str = \"\\\n\t\tGET / HTTP/1.1\\r\\n\\\n\t\tHost: 2be00befcf008bc0e7d9cdefc194db9c75352e8632f48498b5a6bfce9f02c88e.web3.site\\r\\n\\\n\t\tConnection: close\\r\\n\\\n\t\t\\r\\n\\\n\t\";\n\tlet fire_request = || {\n\t\tlet addr = server.addr().to_owned();\n\t\tlet req = request_str.to_owned();\n\t\tthread::spawn(move || {\n\t\t\thttp_client::request(&addr, &req)\n\t\t})\n\t};\n\tlet control = fetch.manual();\n\n\t// when\n\n\t// Fire two requests at the same time\n\tlet r1 = fire_request();\n\tlet r2 = fire_request();\n\n\t// wait for single request in fetch, the second one should go into waiting state.\n\tcontrol.wait_for_requests(1);\n\tcontrol.respond();\n\n\tlet response1 = r1.join().unwrap();\n\tlet response2 = r2.join().unwrap();\n\n\t// then\n\tfetch.assert_requested(\"https://raw.githubusercontent.com/ethcore/dapp-assets/b88e983abaa1a6a6345b8d9448c15b117ddb540e/tokens/gavcoin-64x64.png\");\n\tfetch.assert_no_more_requests();\n\tresponse1.assert_status(\"HTTP/1.1 200 OK\");\n\tresponse2.assert_status(\"HTTP/1.1 200 OK\");\n}\n\n#[test]\nfn should_encode_and_decode_base32() {\n\tuse base32;\n\n\tlet encoded = base32::encode(base32::Alphabet::Crockford, \"token+https://parity.io\".as_bytes());\n\tassert_eq!(\"EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY\", &encoded);\n\n\tlet data = base32::decode(base32::Alphabet::Crockford, \"EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY\").unwrap();\n\tassert_eq!(\"token+https://parity.io\", &String::from_utf8(data).unwrap());\n}\n\n#[test]\nfn should_stream_web_content() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://parity.io/\");\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_support_base32_encoded_web_urls() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_correctly_handle_long_label_when_splitted() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"xolrg9fePeQyKLnL\", \"https://contribution.melonport.com\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: f1qprwk775k6am35a5wmpk3e9gnpgx3me1sk.mbsfcdqpwx3jd5h7ax39dxq2wvb5dhqpww3fe9t2wrvfdm.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://contribution.melonport.com/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\n\n#[test]\nfn should_support_base32_encoded_web_urls_as_path() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_return_error_on_non_whitelisted_domain() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://ethcore.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_return_error_on_invalid_token() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"test\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_return_error_on_invalid_protocol() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"ftp://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/token/ftp/parity.io/ HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_disallow_non_get_requests() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tPOST / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tContent-Type: application/json\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\t123\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 405 Method Not Allowed\");\n\tassert_security_headers_for_embed(&response.headers);\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_fix_absolute_requests_based_on_referer() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\n\tfetch.assert_no_more_requests();\n}\n\n#[test]\nfn should_fix_absolute_requests_based_on_referer_in_url() {\n\t// given\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\n\t// when\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/?__referer=web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\n\t// then\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\n\tfetch.assert_no_more_requests();\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::env;\nuse std::str;\nuse std::net::SocketAddr;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse env_logger::LogBuilder;\nuse jsonrpc_core::IoHandler;\nuse jsonrpc_http_server::{self as http, Host, DomainsValidation};\n\nuse devtools::http_client;\nuse hash_fetch::urlhint::ContractClient;\nuse fetch::{Fetch, Client as FetchClient};\nuse parity_reactor::Remote;\n\nuse {Middleware, SyncStatus, WebProxyTokens};\n\nmod registrar;\nmod fetch;\n\nuse self::registrar::FakeRegistrar;\nuse self::fetch::FakeFetch;\n\nconst SIGNER_PORT: u16 = 18180;\n\nfn init_logger() {\n\t// Initialize logger\n\tif let Ok(log) = env::var(\"RUST_LOG\") {\n\t\tlet mut builder = LogBuilder::new();\n\t\tbuilder.parse(&log);\n\t\tlet _ = builder.init();\t// ignore errors since ./test.sh will call this multiple times.\n\t}\n}\n\npub fn init_server<F, B>(process: F, io: IoHandler, remote: Remote) -> (Server, Arc<FakeRegistrar>) where\n\tF: FnOnce(ServerBuilder) -> ServerBuilder<B>,\n\tB: Fetch,\n{\n\tinit_logger();\n\tlet registrar = Arc::new(FakeRegistrar::new());\n\tlet mut dapps_path = env::temp_dir();\n\tdapps_path.push(\"non-existent-dir-to-prevent-fs-files-from-loading\");\n\n\tlet server = process(ServerBuilder::new(\n\t\t&dapps_path, registrar.clone(), remote,\n\t))\n\t\t.signer_address(Some((\"127.0.0.1\".into(), SIGNER_PORT)))\n\t\t.start_unsecured_http(&\"127.0.0.1:0\".parse().unwrap(), io).unwrap();\n\t(\n\t\tserver,\n\t\tregistrar,\n\t)\n}\n\npub fn serve_with_rpc(io: IoHandler) -> Server {\n\tinit_server(|builder| builder, io, Remote::new_sync()).0\n}\n\npub fn serve_hosts(hosts: Option<Vec<String>>) -> Server {\n\tlet hosts = hosts.map(|hosts| hosts.into_iter().map(Into::into).collect());\n\tinit_server(|builder| builder.allowed_hosts(hosts.into()), Default::default(), Remote::new_sync()).0\n}\n\npub fn serve_with_registrar() -> (Server, Arc<FakeRegistrar>) {\n\tinit_server(|builder| builder, Default::default(), Remote::new_sync())\n}\n\npub fn serve_with_registrar_and_sync() -> (Server, Arc<FakeRegistrar>) {\n\tinit_server(|builder| {\n\t\tbuilder.sync_status(Arc::new(|| true))\n\t}, Default::default(), Remote::new_sync())\n}\n\npub fn serve_with_registrar_and_fetch() -> (Server, FakeFetch, Arc<FakeRegistrar>) {\n\tserve_with_registrar_and_fetch_and_threads(false)\n}\n\npub fn serve_with_registrar_and_fetch_and_threads(multi_threaded: bool) -> (Server, FakeFetch, Arc<FakeRegistrar>) {\n\tlet fetch = FakeFetch::default();\n\tlet f = fetch.clone();\n\tlet (server, reg) = init_server(move |builder| {\n\t\tbuilder.fetch(f.clone())\n\t}, Default::default(), if multi_threaded { Remote::new_thread_per_future() } else { Remote::new_sync() });\n\n\t(server, fetch, reg)\n}\n\npub fn serve_with_fetch(web_token: &'static str, domain: &'static str) -> (Server, FakeFetch) {\n\tlet fetch = FakeFetch::default();\n\tlet f = fetch.clone();\n\tlet (server, _) = init_server(move |builder| {\n\t\tbuilder\n\t\t\t.fetch(f.clone())\n\t\t\t.web_proxy_tokens(Arc::new(move |token| {\n\t\t\t\tif &token == web_token { Some(domain.into()) } else { None }\n\t\t\t}))\n\t}, Default::default(), Remote::new_sync());\n\n\t(server, fetch)\n}\n\npub fn serve() -> Server {\n\tinit_server(|builder| builder, Default::default(), Remote::new_sync()).0\n}\n\npub fn request(server: Server, request: &str) -> http_client::Response {\n\thttp_client::request(server.addr(), request)\n}\n\npub fn assert_security_headers(headers: &[String]) {\n\thttp_client::assert_security_headers_present(headers, None)\n}\npub fn assert_security_headers_for_embed(headers: &[String]) {\n\thttp_client::assert_security_headers_present(headers, Some(SIGNER_PORT))\n}\n\n\n/// Webapps HTTP+RPC server build.\npub struct ServerBuilder<T: Fetch = FetchClient> {\n\tdapps_path: PathBuf,\n\tregistrar: Arc<ContractClient>,\n\tsync_status: Arc<SyncStatus>,\n\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\tsigner_address: Option<(String, u16)>,\n\tallowed_hosts: DomainsValidation<Host>,\n\tremote: Remote,\n\tfetch: Option<T>,\n}\n\nimpl ServerBuilder {\n\t/// Construct new dapps server\n\tpub fn new<P: AsRef<Path>>(dapps_path: P, registrar: Arc<ContractClient>, remote: Remote) -> Self {\n\t\tServerBuilder {\n\t\t\tdapps_path: dapps_path.as_ref().to_owned(),\n\t\t\tregistrar: registrar,\n\t\t\tsync_status: Arc::new(|| false),\n\t\t\tweb_proxy_tokens: Arc::new(|_| None),\n\t\t\tsigner_address: None,\n\t\t\tallowed_hosts: DomainsValidation::Disabled,\n\t\t\tremote: remote,\n\t\t\tfetch: None,\n\t\t}\n\t}\n}\n\nimpl<T: Fetch> ServerBuilder<T> {\n\t/// Set a fetch client to use.\n\tpub fn fetch<X: Fetch>(self, fetch: X) -> ServerBuilder<X> {\n\t\tServerBuilder {\n\t\t\tdapps_path: self.dapps_path,\n\t\t\tregistrar: self.registrar,\n\t\t\tsync_status: self.sync_status,\n\t\t\tweb_proxy_tokens: self.web_proxy_tokens,\n\t\t\tsigner_address: self.signer_address,\n\t\t\tallowed_hosts: self.allowed_hosts,\n\t\t\tremote: self.remote,\n\t\t\tfetch: Some(fetch),\n\t\t}\n\t}\n\n\t/// Change default sync status.\n\tpub fn sync_status(mut self, status: Arc<SyncStatus>) -> Self {\n\t\tself.sync_status = status;\n\t\tself\n\t}\n\n\t/// Change default web proxy tokens validator.\n\tpub fn web_proxy_tokens(mut self, tokens: Arc<WebProxyTokens>) -> Self {\n\t\tself.web_proxy_tokens = tokens;\n\t\tself\n\t}\n\n\t/// Change default signer port.\n\tpub fn signer_address(mut self, signer_address: Option<(String, u16)>) -> Self {\n\t\tself.signer_address = signer_address;\n\t\tself\n\t}\n\n\t/// Change allowed hosts.\n\t/// `None` - All hosts are allowed\n\t/// `Some(whitelist)` - Allow only whitelisted hosts (+ listen address)\n\tpub fn allowed_hosts(mut self, allowed_hosts: DomainsValidation<Host>) -> Self {\n\t\tself.allowed_hosts = allowed_hosts;\n\t\tself\n\t}\n\n\t/// Asynchronously start server with no authentication,\n\t/// returns result with `Server` handle on success or an error.\n\tpub fn start_unsecured_http(self, addr: &SocketAddr, io: IoHandler) -> Result<Server, http::Error> {\n\t\tlet fetch = self.fetch_client();\n\t\tServer::start_http(\n\t\t\taddr,\n\t\t\tio,\n\t\t\tself.allowed_hosts,\n\t\t\tself.signer_address,\n\t\t\tself.dapps_path,\n\t\t\tvec![],\n\t\t\tself.registrar,\n\t\t\tself.sync_status,\n\t\t\tself.web_proxy_tokens,\n\t\t\tself.remote,\n\t\t\tfetch,\n\t\t)\n\t}\n\n\tfn fetch_client(&self) -> T {\n\t\tmatch self.fetch.clone() {\n\t\t\tSome(fetch) => fetch,\n\t\t\tNone => T::new().unwrap(),\n\t\t}\n\t}\n}\n\nconst DAPPS_DOMAIN: &'static str = \"web3.site\";\n\n/// Webapps HTTP server.\npub struct Server {\n\tserver: Option<http::Server>,\n}\n\nimpl Server {\n\tfn start_http<F: Fetch>(\n\t\taddr: &SocketAddr,\n\t\tio: IoHandler,\n\t\tallowed_hosts: DomainsValidation<Host>,\n\t\tsigner_address: Option<(String, u16)>,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tregistrar: Arc<ContractClient>,\n\t\tsync_status: Arc<SyncStatus>,\n\t\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\t\tremote: Remote,\n\t\tfetch: F,\n\t) -> Result<Server, http::Error> {\n\t\tlet middleware = Middleware::dapps(\n\t\t\tremote,\n\t\t\tsigner_address,\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tDAPPS_DOMAIN.into(),\n\t\t\tregistrar,\n\t\t\tsync_status,\n\t\t\tweb_proxy_tokens,\n\t\t\tfetch,\n\t\t);\n\n\t\tlet mut allowed_hosts: Option<Vec<Host>> = allowed_hosts.into();\n\t\tallowed_hosts.as_mut().map(|mut hosts| {\n\t\t\thosts.push(format!(\"http://*.{}:*\", DAPPS_DOMAIN).into());\n\t\t\thosts.push(format!(\"http://*.{}\", DAPPS_DOMAIN).into());\n\t\t});\n\n\t\thttp::ServerBuilder::new(io)\n\t\t\t.request_middleware(middleware)\n\t\t\t.allowed_hosts(allowed_hosts.into())\n\t\t\t.cors(http::DomainsValidation::Disabled)\n\t\t\t.start_http(addr)\n\t\t\t.map(|server| Server {\n\t\t\t\tserver: Some(server),\n\t\t\t})\n\t}\n\n\t/// Returns address that this server is bound to.\n\tpub fn addr(&self) -> &SocketAddr {\n\t\tself.server.as_ref()\n\t\t\t.expect(\"server is always Some at the start; it's consumed only when object is dropped; qed\")\n\t\t\t.addrs()\n\t\t\t.first()\n\t\t\t.expect(\"You cannot start the server without binding to at least one address; qed\")\n\t}\n}\n\nimpl Drop for Server {\n\tfn drop(&mut self) {\n\t\tself.server.take().unwrap().close()\n\t}\n}\n\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Serving web-based content (proxying)\n\nuse std::sync::Arc;\nuse fetch::{self, Fetch};\nuse parity_reactor::Remote;\n\nuse base32;\nuse hyper::{self, server, net, Next, Encoder, Decoder};\nuse hyper::status::StatusCode;\n\nuse apps;\nuse endpoint::{Endpoint, Handler, EndpointPath};\nuse handlers::{\n\tContentFetcherHandler, ContentHandler, ContentValidator, ValidatorResponse,\n\tStreamingHandler, extract_url,\n};\nuse url::Url;\nuse WebProxyTokens;\n\npub type Embeddable = Option<(String, u16)>;\n\npub struct Web<F> {\n\tembeddable_on: Embeddable,\n\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\tremote: Remote,\n\tfetch: F,\n}\n\nimpl<F: Fetch> Web<F> {\n\tpub fn boxed(embeddable_on: Embeddable, web_proxy_tokens: Arc<WebProxyTokens>, remote: Remote, fetch: F) -> Box<Endpoint> {\n\t\tBox::new(Web {\n\t\t\tembeddable_on: embeddable_on,\n\t\t\tweb_proxy_tokens: web_proxy_tokens,\n\t\t\tremote: remote,\n\t\t\tfetch: fetch,\n\t\t})\n\t}\n}\n\nimpl<F: Fetch> Endpoint for Web<F> {\n\tfn to_async_handler(&self, path: EndpointPath, control: hyper::Control) -> Box<Handler> {\n\t\tBox::new(WebHandler {\n\t\t\tcontrol: control,\n\t\t\tstate: State::Initial,\n\t\t\tpath: path,\n\t\t\tremote: self.remote.clone(),\n\t\t\tfetch: self.fetch.clone(),\n\t\t\tweb_proxy_tokens: self.web_proxy_tokens.clone(),\n\t\t\tembeddable_on: self.embeddable_on.clone(),\n\t\t})\n\t}\n}\n\nstruct WebInstaller {\n\tembeddable_on: Embeddable,\n\treferer: String,\n}\n\nimpl ContentValidator for WebInstaller {\n\ttype Error = String;\n\n\tfn validate_and_install(&self, response: fetch::Response) -> Result<ValidatorResponse, String> {\n\t\tlet status = StatusCode::from_u16(response.status().to_u16());\n\t\tlet is_html = response.is_html();\n\t\tlet mime = response.content_type().unwrap_or(mime!(Text/Html));\n\t\tlet mut handler = StreamingHandler::new(\n\t\t\tresponse,\n\t\t\tstatus,\n\t\t\tmime,\n\t\t\tself.embeddable_on.clone(),\n\t\t);\n\t\tif is_html {\n\t\t\thandler.set_initial_content(&format!(\n\t\t\t\tr#\"<script src=\"/{}/inject.js\"></script><script>history.replaceState({{}}, \"\", \"/?{}{}/{}\")</script>\"#,\n\t\t\t\tapps::UTILS_PATH,\n\t\t\t\tapps::URL_REFERER,\n\t\t\t\tapps::WEB_PATH,\n\t\t\t\t&self.referer,\n\t\t\t));\n\t\t}\n\t\tOk(ValidatorResponse::Streaming(handler))\n\t}\n}\n\nenum State<F: Fetch> {\n\tInitial,\n\tError(ContentHandler),\n\tFetching(ContentFetcherHandler<WebInstaller, F>),\n}\n\nstruct WebHandler<F: Fetch> {\n\tcontrol: hyper::Control,\n\tstate: State<F>,\n\tpath: EndpointPath,\n\tremote: Remote,\n\tfetch: F,\n\tweb_proxy_tokens: Arc<WebProxyTokens>,\n\tembeddable_on: Embeddable,\n}\n\nimpl<F: Fetch> WebHandler<F> {\n\tfn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {\n\t\tlet token_and_url = self.path.app_params.get(0)\n\t\t\t.map(|encoded| encoded.replace('.', \"\"))\n\t\t\t.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))\n\t\t\t.and_then(|data| String::from_utf8(data).ok())\n\t\t\t.ok_or_else(|| State::Error(ContentHandler::error(\n\t\t\t\tStatusCode::BadRequest,\n\t\t\t\t\"Invalid parameter\",\n\t\t\t\t\"Couldn't parse given parameter:\",\n\t\t\t\tself.path.app_params.get(0).map(String::as_str),\n\t\t\t\tself.embeddable_on.clone()\n\t\t\t)))?;\n\n\t\tlet mut token_it = token_and_url.split('+');\n\t\tlet token = token_it.next();\n\t\tlet target_url = token_it.next();\n\n\t\t// Check if token supplied in URL is correct.\n\t\tlet domain = match token.and_then(|token| self.web_proxy_tokens.domain(token)) {\n\t\t\tSome(domain) => domain,\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Access Token\", \"Invalid or old web proxy access token supplied.\", Some(\"Try refreshing the page.\"), self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\n\t\t// Validate protocol\n\t\tlet mut target_url = match target_url {\n\t\t\tSome(url) if url.starts_with(\"http://\") || url.starts_with(\"https://\") => url.to_owned(),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Protocol\", \"Invalid protocol used.\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\n\t\tif !target_url.starts_with(&*domain) {\n\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\tStatusCode::BadRequest, \"Invalid Domain\", \"Dapp attempted to access invalid domain.\", Some(&target_url), self.embeddable_on.clone(),\n\t\t\t)));\n\t\t}\n\n\t\tif !target_url.ends_with(\"/\") {\n\t\t\ttarget_url = format!(\"{}/\", target_url);\n\t\t}\n\n\t\t// TODO [ToDr] Should just use `path.app_params`\n\t\tlet (path, query) = match (&url, self.path.using_dapps_domains) {\n\t\t\t(&Some(ref url), true) => (&url.path[..], &url.query),\n\t\t\t(&Some(ref url), false) => (&url.path[2..], &url.query),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid URL\", \"Couldn't parse URL\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\n\t\tlet query = match *query {\n\t\t\tSome(ref query) => format!(\"?{}\", query),\n\t\t\tNone => \"\".into(),\n\t\t};\n\n\t\tOk(format!(\"{}{}{}\", target_url, path.join(\"/\"), query))\n\t}\n}\n\nimpl<F: Fetch> server::Handler<net::HttpStream> for WebHandler<F> {\n\tfn on_request(&mut self, request: server::Request<net::HttpStream>) -> Next {\n\t\tlet url = extract_url(&request);\n\t\t// First extract the URL (reject invalid URLs)\n\t\tlet target_url = match self.extract_target_url(url) {\n\t\t\tOk(url) => url,\n\t\t\tErr(error) => {\n\t\t\t\tself.state = error;\n\t\t\t\treturn Next::write();\n\t\t\t}\n\t\t};\n\n\t\tlet mut handler = ContentFetcherHandler::new(\n\t\t\ttarget_url,\n\t\t\tself.path.clone(),\n\t\t\tself.control.clone(),\n\t\t\tWebInstaller {\n\t\t\t\tembeddable_on: self.embeddable_on.clone(),\n\t\t\t\treferer: self.path.app_params.get(0)\n\t\t\t\t\t.expect(\"`target_url` is valid; app_params is not empty;qed\")\n\t\t\t\t\t.to_owned(),\n\t\t\t},\n\t\t\tself.embeddable_on.clone(),\n\t\t\tself.remote.clone(),\n\t\t\tself.fetch.clone(),\n\t\t);\n\t\tlet res = handler.on_request(request);\n\t\tself.state = State::Fetching(handler);\n\n\t\tres\n\t}\n\n\tfn on_request_readable(&mut self, decoder: &mut Decoder<net::HttpStream>) -> Next {\n\t\tmatch self.state {\n\t\t\tState::Initial => Next::end(),\n\t\t\tState::Error(ref mut handler) => handler.on_request_readable(decoder),\n\t\t\tState::Fetching(ref mut handler) => handler.on_request_readable(decoder),\n\t\t}\n\t}\n\n\tfn on_response(&mut self, res: &mut server::Response) -> Next {\n\t\tmatch self.state {\n\t\t\tState::Initial => Next::end(),\n\t\t\tState::Error(ref mut handler) => handler.on_response(res),\n\t\t\tState::Fetching(ref mut handler) => handler.on_response(res),\n\t\t}\n\t}\n\n\tfn on_response_writable(&mut self, encoder: &mut Encoder<net::HttpStream>) -> Next {\n\t\tmatch self.state {\n\t\t\tState::Initial => Next::end(),\n\t\t\tState::Error(ref mut handler) => handler.on_response_writable(encoder),\n\t\t\tState::Fetching(ref mut handler) => handler.on_response_writable(encoder),\n\t\t}\n\t}\n}\n\n\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { inData, inNumber16, inOptions } from '../../format/input';\nimport { outSignerRequest } from '../../format/output';\n\nexport default class Signer {\n  constructor (transport) {\n    this._transport = transport;\n  }\n\n  confirmRequest (requestId, options, password) {\n    return this._transport\n      .execute('signer_confirmRequest', inNumber16(requestId), inOptions(options), password);\n  }\n\n  confirmRequestRaw (requestId, data) {\n    return this._transport\n      .execute('signer_confirmRequestRaw', inNumber16(requestId), inData(data));\n  }\n\n  confirmRequestWithToken (requestId, options, password) {\n    return this._transport\n      .execute('signer_confirmRequestWithToken', inNumber16(requestId), inOptions(options), password);\n  }\n\n  generateAuthorizationToken () {\n    return this._transport\n      .execute('signer_generateAuthorizationToken');\n  }\n\n  generateWebProxyAccessToken (domain) {\n    return this._transport\n      .execute('signer_generateWebProxyAccessToken', domain);\n  }\n\n  rejectRequest (requestId) {\n    return this._transport\n      .execute('signer_rejectRequest', inNumber16(requestId));\n  }\n\n  requestsToConfirm () {\n    return this._transport\n      .execute('signer_requestsToConfirm')\n      .then((requests) => (requests || []).map(outSignerRequest));\n  }\n\n  signerEnabled () {\n    return this._transport\n      .execute('signer_signerEnabled');\n  }\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { Quantity, Data } from '../types';\nimport { fromDecimal, Dummy } from '../helpers';\n\nexport default {\n  generateAuthorizationToken: {\n    desc: 'Generates a new authorization token.',\n    params: [],\n    returns: {\n      type: String,\n      desc: 'The new authorization token.',\n      example: 'bNGY-iIPB-j7zK-RSYZ'\n    }\n  },\n\n  generateWebProxyAccessToken: {\n    desc: 'Generates a new web proxy access token.',\n    params: [{\n      type: String,\n      desc: 'Domain for which the token is valid. Only requests to this domain will be allowed.',\n      example: 'https://parity.io'\n    }],\n    returns: {\n      type: String,\n      desc: 'The new web proxy access token.',\n      example: 'MOWm0tEJjwthDiTU'\n    }\n  },\n\n  requestsToConfirm: {\n    desc: 'Returns a list of the transactions awaiting authorization.',\n    params: [],\n    returns: {\n      // TODO: Types of the fields of transaction objects? Link to a transaction object in another page?\n      type: Array,\n      desc: 'A list of the outstanding transactions.',\n      example: new Dummy('[ ... ]')\n    }\n  },\n\n  confirmRequest: {\n    desc: 'Confirm a request in the signer queue',\n    params: [\n      {\n        type: Quantity,\n        desc: 'The request id.',\n        example: fromDecimal(1)\n      },\n      {\n        type: Object,\n        desc: 'Modify the transaction before confirmation.',\n        details: {\n          gasPrice: {\n            type: Quantity,\n            desc: 'Modify the gas price provided by the sender in Wei.',\n            optional: true\n          },\n          gas: {\n            type: Quantity,\n            desc: 'Gas provided by the sender in Wei.',\n            optional: true\n          },\n          condition: {\n            type: Object,\n            desc: 'Condition for scheduled transaction. Can be either an integer block number `{ block: 1 }` or UTC timestamp (in seconds) `{ timestamp: 1491290692 }`.',\n            optional: true\n          }\n        },\n        example: {}\n      },\n      {\n        type: String,\n        desc: 'The account password',\n        example: 'hunter2'\n      }\n    ],\n    returns: {\n      type: Object,\n      desc: 'The status of the confirmation, depending on the request type.',\n      example: {}\n    }\n  },\n\n  confirmRequestRaw: {\n    desc: 'Confirm a request in the signer queue providing signed request.',\n    params: [\n      {\n        type: Quantity,\n        desc: 'Integer - The request id',\n        example: fromDecimal(1)\n      },\n      {\n        type: Data,\n        desc: 'Signed request (RLP encoded transaction)',\n        example: '0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675'\n      }\n    ],\n    returns: {\n      type: Object,\n      desc: 'The status of the confirmation, depending on the request type.',\n      example: {}\n    }\n  },\n\n  confirmRequestWithToken: {\n    desc: 'Confirm specific request with rolling token.',\n    params: [\n      {\n        type: Quantity,\n        desc: 'The request id.',\n        example: fromDecimal(1)\n      },\n      {\n        type: Object,\n        desc: 'Modify the transaction before confirmation.',\n        details: {\n          gasPrice: {\n            type: Quantity,\n            desc: 'Modify the gas price provided by the sender in Wei.',\n            optional: true\n          },\n          gas: {\n            type: Quantity,\n            desc: 'Gas provided by the sender in Wei.',\n            optional: true\n          },\n          condition: {\n            type: Object,\n            desc: 'Conditional submission of the transaction. Can be either an integer block number `{ block: 1 }` or UTC timestamp (in seconds) `{ time: 1491290692 }` or `null`.',\n            optional: true\n          }\n        },\n        example: {}\n      },\n      {\n        type: String,\n        desc: 'Password (initially) or a token returned by the previous call.',\n        example: 'hunter2'\n      }\n    ],\n    returns: {\n      type: Object,\n      desc: 'Status.',\n      details: {\n        result: {\n          type: Object,\n          desc: 'The status of the confirmation, depending on the request type.'\n        },\n        token: {\n          type: String,\n          desc: 'Token used to authenticate the next request.'\n        }\n      },\n      example: {\n        result: new Dummy('{ ... }'),\n        token: 'cAF2w5LE7XUZ3v3N'\n      }\n    }\n  },\n\n  rejectRequest: {\n    desc: 'Rejects a request in the signer queue',\n    params: [\n      {\n        type: Quantity,\n        desc: 'Integer - The request id',\n        example: fromDecimal(1)\n      }\n    ],\n    returns: {\n      type: Boolean,\n      desc: 'The status of the rejection',\n      example: true\n    }\n  },\n\n  signerEnabled: {\n    nodoc: 'Not present in Rust code',\n    desc: 'Returns whether signer is enabled/disabled.',\n    params: [],\n    returns: {\n      type: Boolean,\n      desc: '`true` when enabled, `false` when disabled.',\n      example: true\n    }\n  }\n};\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { action, computed, observable, transaction } from 'mobx';\nimport localStore from 'store';\nimport { parse as parseUrl } from 'url';\n\nimport { encodePath, encodeUrl } from '~/util/dapplink';\n\nconst DEFAULT_URL = 'https://oasisdex.com';\nconst LS_LAST_ADDRESS = '_parity::webLastAddress';\n\nconst hasProtocol = /^https?:\\/\\//;\n\nlet instance = null;\n\nexport default class Store {\n  @observable counter = Date.now();\n  @observable currentUrl = null;\n  @observable history = [];\n  @observable isLoading = false;\n  @observable parsedUrl = null;\n  @observable nextUrl = null;\n  @observable token = null;\n\n  constructor (api) {\n    this._api = api;\n\n    this.nextUrl = this.currentUrl = this.loadLastUrl();\n  }\n\n  @computed get encodedPath () {\n    return `${this._api.dappsUrl}/web/${encodePath(this.token, this.currentUrl)}?t=${this.counter}`;\n  }\n\n  @computed get encodedUrl () {\n    return `http://${encodeUrl(this.token, this.currentUrl)}:${this._api.dappsPort}?t=${this.counter}`;\n  }\n\n  @computed get frameId () {\n    return `_web_iframe_${this.counter}`;\n  }\n\n  @computed get isPristine () {\n    return this.currentUrl === this.nextUrl;\n  }\n\n  @action gotoUrl = (_url) => {\n    let url = (_url || this.nextUrl).trim().replace(/\\/+$/, '');\n\n    if (!hasProtocol.test(url)) {\n      url = `https://${url}`;\n    }\n\n    return this.generateToken(url).then(() => {\n      transaction(() => {\n        this.setNextUrl(url);\n        this.setCurrentUrl(this.nextUrl);\n      });\n    });\n  }\n\n  @action reload = () => {\n    transaction(() => {\n      this.setLoading(true);\n      this.counter = Date.now();\n    });\n  }\n\n  @action restoreUrl = () => {\n    this.setNextUrl(this.currentUrl);\n  }\n\n  @action setHistory = (urls) => {\n    this.history = Object\n      .keys(urls)\n      .filter((url) => url && !url.startsWith(this._api.dappsUrl) && url.indexOf('127.0.0.1') === -1)\n      .sort((urlA, urlB) => {\n        const timeA = urls[urlA].getTime();\n        const timeB = urls[urlB].getTime();\n\n        if (timeA > timeB) {\n          return -1;\n        } else if (timeA < timeB) {\n          return 1;\n        }\n\n        return 0;\n      })\n      .map((url) => {\n        const hostname = url.replace(/^http[s]?:\\/\\//, '').split('/')[0];\n\n        return {\n          hostname,\n          timestamp: urls[url],\n          url\n        };\n      });\n  }\n\n  @action setLoading = (isLoading) => {\n    this.isLoading = isLoading;\n  }\n\n  @action setToken = (token) => {\n    this.token = token;\n  }\n\n  @action setCurrentUrl = (_url) => {\n    const url = _url || this.currentUrl;\n\n    transaction(() => {\n      this.currentUrl = url;\n      this.parsedUrl = parseUrl(url);\n\n      this.saveLastUrl();\n\n      this.reload();\n    });\n  }\n\n  @action setNextUrl = (url) => {\n    this.nextUrl = url;\n  }\n\n  generateToken = (_url) => {\n    this.setToken(null);\n\n    return this._api.signer\n      .generateWebProxyAccessToken(_url)\n      .then((token) => {\n        this.setToken(token);\n      })\n      .catch((error) => {\n        console.warn('generateToken', error);\n      });\n  }\n\n  loadHistory = () => {\n    return this._api.parity\n      .listRecentDapps()\n      .then((apps) => {\n        this.setHistory(apps);\n      })\n      .catch((error) => {\n        console.warn('loadHistory', error);\n      });\n  }\n\n  loadLastUrl = () => {\n    return localStore.get(LS_LAST_ADDRESS) || DEFAULT_URL;\n  }\n\n  saveLastUrl = () => {\n    return localStore.set(LS_LAST_ADDRESS, this.currentUrl);\n  }\n\n  static get (api) {\n    if (!instance) {\n      instance = new Store(api);\n    }\n\n    return instance;\n  }\n}\n\nexport {\n  DEFAULT_URL,\n  LS_LAST_ADDRESS\n};\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sinon from 'sinon';\n\nimport Store from './store';\n\nconst TEST_HISTORY_URLA = 'http://testingA';\nconst TEST_HISTORY_URLB = 'http://testingB';\nconst TEST_HISTORY = {\n  '': new Date(678),\n  [TEST_HISTORY_URLA]: new Date(123),\n  [TEST_HISTORY_URLB]: new Date(456)\n};\nconst TEST_TOKEN = 'testing-123';\nconst TEST_URL1 = 'http://some.test.domain.com';\nconst TEST_URL2 = 'http://something.different.com';\n\nlet api;\nlet store;\n\nfunction createApi () {\n  api = {\n    dappsPort: 8545,\n    dappsUrl: 'http://home.web3.site:8545',\n    parity: {\n      listRecentDapps: sinon.stub().resolves(TEST_HISTORY)\n    },\n    signer: {\n      generateWebProxyAccessToken: sinon.stub().resolves(TEST_TOKEN)\n    }\n  };\n\n  return api;\n}\n\nfunction create () {\n  store = new Store(createApi());\n\n  return store;\n}\n\ndescribe('views/Web/Store', () => {\n  beforeEach(() => {\n    create();\n  });\n\n  describe('@action', () => {\n    describe('gotoUrl', () => {\n      it('uses the nextUrl when none specified', () => {\n        store.setNextUrl('https://parity.io');\n\n        return store.gotoUrl().then(() => {\n          expect(store.currentUrl).to.equal('https://parity.io');\n        });\n      });\n\n      it('adds https when no protocol', () => {\n        return store.gotoUrl('google.com').then(() => {\n          expect(store.currentUrl).to.equal('https://google.com');\n        });\n      });\n    });\n\n    describe('restoreUrl', () => {\n      it('sets the nextUrl to the currentUrl', () => {\n        store.setCurrentUrl(TEST_URL1);\n        store.setNextUrl(TEST_URL2);\n        store.restoreUrl();\n\n        expect(store.nextUrl).to.equal(TEST_URL1);\n      });\n    });\n\n    describe('setCurrentUrl', () => {\n      beforeEach(() => {\n        store.setCurrentUrl(TEST_URL1);\n      });\n\n      it('sets the url', () => {\n        expect(store.currentUrl).to.equal(TEST_URL1);\n      });\n    });\n\n    describe('setHistory', () => {\n      let history;\n\n      beforeEach(() => {\n        store.setHistory(TEST_HISTORY);\n        history = store.history.peek();\n      });\n\n      it('sets the history', () => {\n        expect(history.length).to.equal(2);\n      });\n\n      it('adds hostname to entries', () => {\n        expect(history[1].hostname).to.be.ok;\n      });\n\n      it('removes hostname http prefixes', () => {\n        expect(history[1].hostname.indexOf('http')).to.equal(-1);\n      });\n\n      it('sorts the entries according to recently accessed', () => {\n        expect(history[0].url).to.equal(TEST_HISTORY_URLB);\n        expect(history[1].url).to.equal(TEST_HISTORY_URLA);\n      });\n    });\n\n    describe('setLoading', () => {\n      beforeEach(() => {\n        store.setLoading(true);\n      });\n\n      it('sets the loading state (true)', () => {\n        expect(store.isLoading).to.be.true;\n      });\n\n      it('sets the loading state (false)', () => {\n        store.setLoading(false);\n\n        expect(store.isLoading).to.be.false;\n      });\n    });\n\n    describe('setNextUrl', () => {\n      it('sets the url', () => {\n        store.setNextUrl(TEST_URL1);\n\n        expect(store.nextUrl).to.equal(TEST_URL1);\n      });\n    });\n\n    describe('setToken', () => {\n      it('sets the token', () => {\n        store.setToken(TEST_TOKEN);\n\n        expect(store.token).to.equal(TEST_TOKEN);\n      });\n    });\n  });\n\n  describe('@computed', () => {\n    describe('encodedUrl', () => {\n      describe('encodedPath', () => {\n        it('encodes current', () => {\n          store.setCurrentUrl(TEST_URL1);\n          expect(store.encodedPath).to.match(\n            /http:\\/\\/home\\.web3\\.site:8545\\/web\\/DSTPRV1BD1T78W1T5WQQ6VVDCMQ78SBKEGQ68VVDC5MPWBK3DXPG\\?t=[0-9]*$/\n          );\n        });\n      });\n\n      it('encodes current', () => {\n        store.setCurrentUrl(TEST_URL1);\n        expect(store.encodedUrl).to.match(\n          /^http:\\/\\/DSTPRV1BD1T78W1T5WQQ6VVDCMQ78SBKEGQ68VVDC5MPWBK3DXPG\\.web\\.web3\\.site:8545\\?t=[0-9]*$/\n        );\n      });\n    });\n\n    describe('frameId', () => {\n      it('creates an id', () => {\n        expect(store.frameId).to.be.ok;\n      });\n    });\n\n    describe('isPristine', () => {\n      it('is true when current === next', () => {\n        store.setCurrentUrl(TEST_URL1);\n        store.setNextUrl(TEST_URL1);\n\n        expect(store.isPristine).to.be.true;\n      });\n\n      it('is false when current !== next', () => {\n        store.setCurrentUrl(TEST_URL1);\n        store.setNextUrl(TEST_URL2);\n\n        expect(store.isPristine).to.be.false;\n      });\n    });\n  });\n\n  describe('operations', () => {\n    describe('generateToken', () => {\n      beforeEach(() => {\n        return store.generateToken();\n      });\n\n      it('calls signer_generateWebProxyAccessToken', () => {\n        expect(api.signer.generateWebProxyAccessToken).to.have.been.calledOnce;\n      });\n\n      it('sets the token as retrieved', () => {\n        expect(store.token).to.equal(TEST_TOKEN);\n      });\n    });\n\n    describe('loadHistory', () => {\n      beforeEach(() => {\n        return store.loadHistory();\n      });\n\n      it('calls parity_listRecentDapps', () => {\n        expect(api.parity.listRecentDapps).to.have.been.calledOnce;\n      });\n\n      it('sets the history as retrieved', () => {\n        expect(store.history.peek().length).not.to.equal(0);\n      });\n    });\n  });\n});\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nimport { observer } from 'mobx-react';\nimport React, { Component, PropTypes } from 'react';\nimport { FormattedMessage } from 'react-intl';\n\nimport AddressBar from './AddressBar';\nimport Store from './store';\n\nimport styles from './web.css';\n\n@observer\nexport default class Web extends Component {\n  static contextTypes = {\n    api: PropTypes.object.isRequired\n  }\n\n  static propTypes = {\n    params: PropTypes.object.isRequired\n  }\n\n  store = Store.get(this.context.api);\n\n  componentDidMount () {\n    this.store.gotoUrl(this.props.params.url);\n  }\n\n  componentWillReceiveProps (props) {\n    this.store.gotoUrl(props.params.url);\n  }\n\n  render () {\n    const { currentUrl, token } = this.store;\n\n    if (!token) {\n      return (\n        <div className={ styles.wrapper }>\n          <h1 className={ styles.loading }>\n            <FormattedMessage\n              id='web.requestToken'\n              defaultMessage='Requesting access token...'\n            />\n          </h1>\n        </div>\n      );\n    }\n\n    return currentUrl\n      ? this.renderFrame()\n      : null;\n  }\n\n  renderFrame () {\n    const { encodedPath, frameId } = this.store;\n\n    return (\n      <div className={ styles.wrapper }>\n        <AddressBar\n          className={ styles.url }\n          store={ this.store }\n        />\n        <iframe\n          className={ styles.frame }\n          frameBorder={ 0 }\n          id={ frameId }\n          name={ frameId }\n          onLoad={ this.iframeOnLoad }\n          sandbox='allow-forms allow-same-origin allow-scripts'\n          scrolling='auto'\n          src={ encodedPath }\n        />\n      </div>\n    );\n  }\n\n  iframeOnLoad = () => {\n    this.store.setLoading(false);\n  };\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\nuse dir::default_data_path;\nuse ethcore::client::{Client, BlockChainClient, BlockId};\nuse ethcore::transaction::{Transaction, Action};\nuse ethsync::LightSync;\nuse futures::{future, IntoFuture, Future, BoxFuture};\nuse hash_fetch::fetch::Client as FetchClient;\nuse hash_fetch::urlhint::ContractClient;\nuse helpers::replace_home;\nuse light::client::Client as LightClient;\nuse light::on_demand::{self, OnDemand};\nuse rpc;\nuse rpc_apis::SignerService;\nuse parity_reactor;\nuse util::{Bytes, Address};\n\n#[derive(Debug, PartialEq, Clone)]\npub struct Configuration {\n\tpub enabled: bool,\n\tpub dapps_path: PathBuf,\n\tpub extra_dapps: Vec<PathBuf>,\n}\n\nimpl Default for Configuration {\n\tfn default() -> Self {\n\t\tlet data_dir = default_data_path();\n\t\tConfiguration {\n\t\t\tenabled: true,\n\t\t\tdapps_path: replace_home(&data_dir, \"$BASE/dapps\").into(),\n\t\t\textra_dapps: vec![],\n\t\t}\n\t}\n}\n\nimpl Configuration {\n\tpub fn address(&self, address: Option<(String, u16)>) -> Option<(String, u16)> {\n\t\tmatch self.enabled {\n\t\t\ttrue => address,\n\t\t\tfalse => None,\n\t\t}\n\t}\n}\n\n/// Registrar implementation of the full client.\npub struct FullRegistrar {\n\t/// Handle to the full client.\n\tpub client: Arc<Client>,\n}\n\nimpl ContractClient for FullRegistrar {\n\tfn registrar(&self) -> Result<Address, String> {\n\t\tself.client.additional_params().get(\"registrar\")\n\t\t\t .ok_or_else(|| \"Registrar not defined.\".into())\n\t\t\t .and_then(|registrar| {\n\t\t\t\t registrar.parse().map_err(|e| format!(\"Invalid registrar address: {:?}\", e))\n\t\t\t })\n\t}\n\n\tfn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {\n\t\tself.client.call_contract(BlockId::Latest, address, data)\n\t\t\t.into_future()\n\t\t\t.boxed()\n\t}\n}\n\n/// Registrar implementation for the light client.\npub struct LightRegistrar {\n\t/// The light client.\n\tpub client: Arc<LightClient>,\n\t/// Handle to the on-demand service.\n\tpub on_demand: Arc<OnDemand>,\n\t/// Handle to the light network service.\n\tpub sync: Arc<LightSync>,\n}\n\nimpl ContractClient for LightRegistrar {\n\tfn registrar(&self) -> Result<Address, String> {\n\t\tself.client.engine().additional_params().get(\"registrar\")\n\t\t\t .ok_or_else(|| \"Registrar not defined.\".into())\n\t\t\t .and_then(|registrar| {\n\t\t\t\t registrar.parse().map_err(|e| format!(\"Invalid registrar address: {:?}\", e))\n\t\t\t })\n\t}\n\n\tfn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {\n\t\tlet (header, env_info) = (self.client.best_block_header(), self.client.latest_env_info());\n\n\t\tlet maybe_future = self.sync.with_context(move |ctx| {\n\t\t\tself.on_demand\n\t\t\t\t.request(ctx, on_demand::request::TransactionProof {\n\t\t\t\t\ttx: Transaction {\n\t\t\t\t\t\tnonce: self.client.engine().account_start_nonce(),\n\t\t\t\t\t\taction: Action::Call(address),\n\t\t\t\t\t\tgas: 50_000_000.into(),\n\t\t\t\t\t\tgas_price: 0.into(),\n\t\t\t\t\t\tvalue: 0.into(),\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t}.fake_sign(Address::default()),\n\t\t\t\t\theader: header.into(),\n\t\t\t\t\tenv_info: env_info,\n\t\t\t\t\tengine: self.client.engine().clone(),\n\t\t\t\t})\n\t\t\t\t.expect(\"No back-references; therefore all back-refs valid; qed\")\n\t\t\t\t.then(|res| match res {\n\t\t\t\t\tOk(Ok(executed)) => Ok(executed.output),\n\t\t\t\t\tOk(Err(e)) => Err(format!(\"Failed to execute transaction: {}\", e)),\n\t\t\t\t\tErr(_) => Err(format!(\"On-demand service dropped request unexpectedly.\")),\n\t\t\t\t})\n\t\t});\n\n\t\tmatch maybe_future {\n\t\t\tSome(fut) => fut.boxed(),\n\t\t\tNone => future::err(\"cannot query registry: network disabled\".into()).boxed(),\n\t\t}\n\t}\n}\n\n// TODO: light client implementation forwarding to OnDemand and waiting for future\n// to resolve.\n#[derive(Clone)]\npub struct Dependencies {\n\tpub sync_status: Arc<SyncStatus>,\n\tpub contract_client: Arc<ContractClient>,\n\tpub remote: parity_reactor::TokioRemote,\n\tpub fetch: FetchClient,\n\tpub signer: Arc<SignerService>,\n\tpub ui_address: Option<(String, u16)>,\n}\n\npub fn new(configuration: Configuration, deps: Dependencies) -> Result<Option<Middleware>, String> {\n\tif !configuration.enabled {\n\t\treturn Ok(None);\n\t}\n\n\tserver::dapps_middleware(\n\t\tdeps,\n\t\tconfiguration.dapps_path,\n\t\tconfiguration.extra_dapps,\n\t\trpc::DAPPS_DOMAIN.into(),\n\t).map(Some)\n}\n\npub fn new_ui(enabled: bool, deps: Dependencies) -> Result<Option<Middleware>, String> {\n\tif !enabled {\n\t\treturn Ok(None);\n\t}\n\n\tserver::ui_middleware(\n\t\tdeps,\n\t\trpc::DAPPS_DOMAIN.into(),\n\t).map(Some)\n}\n\npub use self::server::{SyncStatus, Middleware, service};\n\n#[cfg(not(feature = \"dapps\"))]\nmod server {\n\tuse super::Dependencies;\n\tuse std::sync::Arc;\n\tuse std::path::PathBuf;\n\tuse parity_rpc::{hyper, RequestMiddleware, RequestMiddlewareAction};\n\tuse rpc_apis;\n\n\tpub type SyncStatus = Fn() -> bool;\n\n\tpub struct Middleware;\n\timpl RequestMiddleware for Middleware {\n\t\tfn on_request(\n\t\t\t&self, _req: &hyper::server::Request<hyper::net::HttpStream>, _control: &hyper::Control\n\t\t) -> RequestMiddlewareAction {\n\t\t\tunreachable!()\n\t\t}\n\t}\n\n\tpub fn dapps_middleware(\n\t\t_deps: Dependencies,\n\t\t_dapps_path: PathBuf,\n\t\t_extra_dapps: Vec<PathBuf>,\n\t\t_dapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tErr(\"Your Parity version has been compiled without WebApps support.\".into())\n\t}\n\n\tpub fn ui_middleware(\n\t\t_deps: Dependencies,\n\t\t_dapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tErr(\"Your Parity version has been compiled without UI support.\".into())\n\t}\n\n\tpub fn service(_: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {\n\t\tNone\n\t}\n}\n\n#[cfg(feature = \"dapps\")]\nmod server {\n\tuse super::Dependencies;\n\tuse std::path::PathBuf;\n\tuse std::sync::Arc;\n\tuse rpc_apis;\n\n\tuse parity_dapps;\n\tuse parity_reactor;\n\n\tpub use parity_dapps::Middleware;\n\tpub use parity_dapps::SyncStatus;\n\n\tpub fn dapps_middleware(\n\t\tdeps: Dependencies,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tdapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tlet signer = deps.signer;\n\t\tlet parity_remote = parity_reactor::Remote::new(deps.remote.clone());\n\t\tlet web_proxy_tokens = Arc::new(move |token| signer.web_proxy_access_token_domain(&token));\n\n\t\tOk(parity_dapps::Middleware::dapps(\n\t\t\tparity_remote,\n\t\t\tdeps.ui_address,\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tdapps_domain,\n\t\t\tdeps.contract_client,\n\t\t\tdeps.sync_status,\n\t\t\tweb_proxy_tokens,\n\t\t\tdeps.fetch,\n\t\t))\n\t}\n\n\tpub fn ui_middleware(\n\t\tdeps: Dependencies,\n\t\tdapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tlet parity_remote = parity_reactor::Remote::new(deps.remote.clone());\n\t\tOk(parity_dapps::Middleware::ui(\n\t\t\tparity_remote,\n\t\t\tdeps.contract_client,\n\t\t\tdeps.sync_status,\n\t\t\tdeps.fetch,\n\t\t\tdapps_domain,\n\t\t))\n\t}\n\n\tpub fn service(middleware: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {\n\t\tmiddleware.as_ref().map(|m| Arc::new(DappsServiceWrapper {\n\t\t\tendpoints: m.endpoints()\n\t\t}) as Arc<rpc_apis::DappsService>)\n\t}\n\n\tpub struct DappsServiceWrapper {\n\t\tendpoints: parity_dapps::Endpoints,\n\t}\n\n\timpl rpc_apis::DappsService for DappsServiceWrapper {\n\t\tfn list_dapps(&self) -> Vec<rpc_apis::LocalDapp> {\n\t\t\tself.endpoints.list()\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|app| rpc_apis::LocalDapp {\n\t\t\t\t\tid: app.id,\n\t\t\t\t\tname: app.name,\n\t\t\t\t\tdescription: app.description,\n\t\t\t\t\tversion: app.version,\n\t\t\t\t\tauthor: app.author,\n\t\t\t\t\ticon_url: app.icon_url,\n\t\t\t\t})\n\t\t\t\t.collect()\n\t\t}\n\t}\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::sync::Arc;\nuse std::ops::Deref;\nuse http::Origin;\nuse util::Mutex;\nuse transient_hashmap::TransientHashMap;\n\nuse ethstore::random_string;\n\nuse v1::helpers::signing_queue::{ConfirmationsQueue};\n\nconst TOKEN_LIFETIME_SECS: u32 = 3600;\n\n/// Manages communication with Signer crate\npub struct SignerService {\n\tis_enabled: bool,\n\tqueue: Arc<ConfirmationsQueue>,\n\tweb_proxy_tokens: Mutex<TransientHashMap<String, Origin>>,\n\tgenerate_new_token: Box<Fn() -> Result<String, String> + Send + Sync + 'static>,\n}\n\nimpl SignerService {\n\t/// Creates new Signer Service given function to generate new tokens.\n\tpub fn new<F>(new_token: F, is_enabled: bool) -> Self\n\t\twhere F: Fn() -> Result<String, String> + Send + Sync + 'static {\n\t\tSignerService {\n\t\t\tqueue: Arc::new(ConfirmationsQueue::default()),\n\t\t\tweb_proxy_tokens: Mutex::new(TransientHashMap::new(TOKEN_LIFETIME_SECS)),\n\t\t\tgenerate_new_token: Box::new(new_token),\n\t\t\tis_enabled: is_enabled,\n\t\t}\n\t}\n\n\t/// Checks if the token is valid web proxy access token.\n\tpub fn web_proxy_access_token_domain(&self, token: &String) -> Option<Origin> {\n\t\tself.web_proxy_tokens.lock().get(token).cloned()\n\t}\n\n\t/// Generates a new web proxy access token.\n\tpub fn generate_web_proxy_access_token(&self, domain: Origin) -> String {\n\t\tlet token = random_string(16);\n\t\tlet mut tokens = self.web_proxy_tokens.lock();\n\t\ttokens.prune();\n\t\ttokens.insert(token.clone(), domain);\n\t\ttoken\n\t}\n\n\t/// Generates new signer authorization token.\n\tpub fn generate_token(&self) -> Result<String, String> {\n\t\t(self.generate_new_token)()\n\t}\n\n\t/// Returns a reference to `ConfirmationsQueue`\n\tpub fn queue(&self) -> Arc<ConfirmationsQueue> {\n\t\tself.queue.clone()\n\t}\n\n\t/// Returns true if Signer is enabled.\n\tpub fn is_enabled(&self) -> bool {\n\t\tself.is_enabled\n\t}\n\n\t#[cfg(test)]\n\t/// Creates new Signer Service for tests.\n\tpub fn new_test(is_enabled: bool) -> Self {\n\t\tSignerService::new(|| Ok(\"new_token\".into()), is_enabled)\n\t}\n}\n\nimpl Deref for SignerService {\n\ttype Target = ConfirmationsQueue;\n\tfn deref(&self) -> &Self::Target {\n\t\t&self.queue\n\t}\n}\n\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Transactions Confirmations rpc implementation\n\nuse std::sync::Arc;\n\nuse ethcore::account_provider::AccountProvider;\nuse ethcore::transaction::{SignedTransaction, PendingTransaction};\nuse ethkey;\nuse futures::{future, BoxFuture, Future, IntoFuture};\nuse parity_reactor::Remote;\nuse rlp::UntrustedRlp;\nuse util::Mutex;\n\nuse jsonrpc_core::{futures, Error};\nuse jsonrpc_pubsub::SubscriptionId;\nuse jsonrpc_macros::pubsub::{Sink, Subscriber};\nuse v1::helpers::accounts::unwrap_provider;\nuse v1::helpers::dispatch::{self, Dispatcher, WithToken, eth_data_hash};\nuse v1::helpers::{errors, SignerService, SigningQueue, ConfirmationPayload, FilledTransactionRequest, Subscribers};\nuse v1::metadata::Metadata;\nuse v1::traits::Signer;\nuse v1::types::{TransactionModification, ConfirmationRequest, ConfirmationResponse, ConfirmationResponseWithToken, U256, Bytes};\n\n/// Transactions confirmation (personal) rpc implementation.\npub struct SignerClient<D: Dispatcher> {\n\tsigner: Arc<SignerService>,\n\taccounts: Option<Arc<AccountProvider>>,\n\tdispatcher: D,\n\tsubscribers: Arc<Mutex<Subscribers<Sink<Vec<ConfirmationRequest>>>>>,\n}\n\nimpl<D: Dispatcher + 'static> SignerClient<D> {\n\t/// Create new instance of signer client.\n\tpub fn new(\n\t\tstore: &Option<Arc<AccountProvider>>,\n\t\tdispatcher: D,\n\t\tsigner: &Arc<SignerService>,\n\t\tremote: Remote,\n\t) -> Self {\n\t\tlet subscribers = Arc::new(Mutex::new(Subscribers::default()));\n\t\tlet subs = Arc::downgrade(&subscribers);\n\t\tlet s = Arc::downgrade(signer);\n\t\tsigner.queue().on_event(move |_event| {\n\t\t\tif let (Some(s), Some(subs)) = (s.upgrade(), subs.upgrade()) {\n\t\t\t\tlet requests = s.requests().into_iter().map(Into::into).collect::<Vec<ConfirmationRequest>>();\n\t\t\t\tfor subscription in subs.lock().values() {\n\t\t\t\t\tlet subscription: &Sink<_> = subscription;\n\t\t\t\t\tremote.spawn(subscription\n\t\t\t\t\t\t.notify(Ok(requests.clone()))\n\t\t\t\t\t\t.map(|_| ())\n\t\t\t\t\t\t.map_err(|e| warn!(target: \"rpc\", \"Unable to send notification: {}\", e))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tSignerClient {\n\t\t\tsigner: signer.clone(),\n\t\t\taccounts: store.clone(),\n\t\t\tdispatcher: dispatcher,\n\t\t\tsubscribers: subscribers,\n\t\t}\n\t}\n\n\tfn account_provider(&self) -> Result<Arc<AccountProvider>, Error> {\n\t\tunwrap_provider(&self.accounts)\n\t}\n\n\tfn confirm_internal<F, T>(&self, id: U256, modification: TransactionModification, f: F) -> BoxFuture<WithToken<ConfirmationResponse>, Error> where\n\t\tF: FnOnce(D, Arc<AccountProvider>, ConfirmationPayload) -> T,\n\t\tT: IntoFuture<Item=WithToken<ConfirmationResponse>, Error=Error>,\n\t\tT::Future: Send + 'static\n\t{\n\t\tlet id = id.into();\n\t\tlet dispatcher = self.dispatcher.clone();\n\n\t\tlet setup = || {\n\t\t\tOk((self.account_provider()?, self.signer.clone()))\n\t\t};\n\n\t\tlet (accounts, signer) = match setup() {\n\t\t\tOk(x) => x,\n\t\t\tErr(e) => return future::err(e).boxed(),\n\t\t};\n\n\t\tsigner.peek(&id).map(|confirmation| {\n\t\t\tlet mut payload = confirmation.payload.clone();\n\t\t\t// Modify payload\n\t\t\tif let ConfirmationPayload::SendTransaction(ref mut request) = payload {\n\t\t\t\tif let Some(sender) = modification.sender.clone() {\n\t\t\t\t\trequest.from = sender.into();\n\t\t\t\t\t// Altering sender should always reset the nonce.\n\t\t\t\t\trequest.nonce = None;\n\t\t\t\t}\n\t\t\t\tif let Some(gas_price) = modification.gas_price {\n\t\t\t\t\trequest.gas_price = gas_price.into();\n\t\t\t\t}\n\t\t\t\tif let Some(gas) = modification.gas {\n\t\t\t\t\trequest.gas = gas.into();\n\t\t\t\t}\n\t\t\t\tif let Some(ref condition) = modification.condition {\n\t\t\t\t\trequest.condition = condition.clone().map(Into::into);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet fut = f(dispatcher, accounts, payload);\n\t\t\tfut.into_future().then(move |result| {\n\t\t\t\t// Execute\n\t\t\t\tif let Ok(ref response) = result {\n\t\t\t\t\tsigner.request_confirmed(id, Ok((*response).clone()));\n\t\t\t\t}\n\n\t\t\t\tresult\n\t\t\t}).boxed()\n\t\t})\n\t\t.unwrap_or_else(|| future::err(errors::invalid_params(\"Unknown RequestID\", id)).boxed())\n\t}\n\n\tfn verify_transaction<F>(bytes: Bytes, request: FilledTransactionRequest, process: F) -> Result<ConfirmationResponse, Error> where\n\t\tF: FnOnce(PendingTransaction) -> Result<ConfirmationResponse, Error>,\n\t{\n\t\tlet signed_transaction = UntrustedRlp::new(&bytes.0).as_val().map_err(errors::from_rlp_error)?;\n\t\tlet signed_transaction = SignedTransaction::new(signed_transaction).map_err(|e| errors::invalid_params(\"Invalid signature.\", e))?;\n\t\tlet sender = signed_transaction.sender();\n\n\t\t// Verification\n\t\tlet sender_matches = sender == request.from;\n\t\tlet data_matches = signed_transaction.data == request.data;\n\t\tlet value_matches = signed_transaction.value == request.value;\n\t\tlet nonce_matches = match request.nonce {\n\t\t\tSome(nonce) => signed_transaction.nonce == nonce,\n\t\t\tNone => true,\n\t\t};\n\n\t\t// Dispatch if everything is ok\n\t\tif sender_matches && data_matches && value_matches && nonce_matches {\n\t\t\tlet pending_transaction = PendingTransaction::new(signed_transaction, request.condition.map(Into::into));\n\t\t\tprocess(pending_transaction)\n\t\t} else {\n\t\t\tlet mut error = Vec::new();\n\t\t\tif !sender_matches { error.push(\"from\") }\n\t\t\tif !data_matches { error.push(\"data\") }\n\t\t\tif !value_matches { error.push(\"value\") }\n\t\t\tif !nonce_matches { error.push(\"nonce\") }\n\n\t\t\tErr(errors::invalid_params(\"Sent transaction does not match the request.\", error))\n\t\t}\n\t}\n}\n\nimpl<D: Dispatcher + 'static> Signer for SignerClient<D> {\n\ttype Metadata = Metadata;\n\n\tfn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error> {\n\t\tOk(self.signer.requests()\n\t\t\t.into_iter()\n\t\t\t.map(Into::into)\n\t\t\t.collect()\n\t\t)\n\t}\n\n\t// TODO [ToDr] TransactionModification is redundant for some calls\n\t// might be better to replace it in future\n\tfn confirm_request(&self, id: U256, modification: TransactionModification, pass: String)\n\t\t-> BoxFuture<ConfirmationResponse, Error>\n\t{\n\t\tself.confirm_internal(id, modification, move |dis, accounts, payload| {\n\t\t\tdispatch::execute(dis, accounts, payload, dispatch::SignWith::Password(pass))\n\t\t}).map(|v| v.into_value()).boxed()\n\t}\n\n\tfn confirm_request_with_token(&self, id: U256, modification: TransactionModification, token: String)\n\t\t-> BoxFuture<ConfirmationResponseWithToken, Error>\n\t{\n\t\tself.confirm_internal(id, modification, move |dis, accounts, payload| {\n\t\t\tdispatch::execute(dis, accounts, payload, dispatch::SignWith::Token(token))\n\t\t}).and_then(|v| match v {\n\t\t\tWithToken::No(_) => Err(errors::internal(\"Unexpected response without token.\", \"\")),\n\t\t\tWithToken::Yes(response, token) => Ok(ConfirmationResponseWithToken {\n\t\t\t\tresult: response,\n\t\t\t\ttoken: token,\n\t\t\t}),\n\t\t}).boxed()\n\t}\n\n\tfn confirm_request_raw(&self, id: U256, bytes: Bytes) -> Result<ConfirmationResponse, Error> {\n\t\tlet id = id.into();\n\n\t\tself.signer.peek(&id).map(|confirmation| {\n\t\t\tlet result = match confirmation.payload {\n\t\t\t\tConfirmationPayload::SendTransaction(request) => {\n\t\t\t\t\tSelf::verify_transaction(bytes, request, |pending_transaction| {\n\t\t\t\t\t\tself.dispatcher.dispatch_transaction(pending_transaction)\n\t\t\t\t\t\t\t.map(Into::into)\n\t\t\t\t\t\t\t.map(ConfirmationResponse::SendTransaction)\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tConfirmationPayload::SignTransaction(request) => {\n\t\t\t\t\tSelf::verify_transaction(bytes, request, |pending_transaction| {\n\t\t\t\t\t\tOk(ConfirmationResponse::SignTransaction(pending_transaction.transaction.into()))\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tConfirmationPayload::EthSignMessage(address, data) => {\n\t\t\t\t\tlet expected_hash = eth_data_hash(data);\n\t\t\t\t\tlet signature = ethkey::Signature::from_electrum(&bytes.0);\n\t\t\t\t\tmatch ethkey::verify_address(&address, &signature, &expected_hash) {\n\t\t\t\t\t\tOk(true) => Ok(ConfirmationResponse::Signature(bytes.0.as_slice().into())),\n\t\t\t\t\t\tOk(false) => Err(errors::invalid_params(\"Sender address does not match the signature.\", ())),\n\t\t\t\t\t\tErr(err) => Err(errors::invalid_params(\"Invalid signature received.\", err)),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tConfirmationPayload::Decrypt(_address, _data) => {\n\t\t\t\t\t// TODO [ToDr]: Decrypt can we verify if the answer is correct?\n\t\t\t\t\tOk(ConfirmationResponse::Decrypt(bytes))\n\t\t\t\t},\n\t\t\t};\n\t\t\tif let Ok(ref response) = result {\n\t\t\t\tself.signer.request_confirmed(id, Ok(response.clone()));\n\t\t\t}\n\t\t\tresult\n\t\t}).unwrap_or_else(|| Err(errors::invalid_params(\"Unknown RequestID\", id)))\n\t}\n\n\tfn reject_request(&self, id: U256) -> Result<bool, Error> {\n\t\tlet res = self.signer.request_rejected(id.into());\n\t\tOk(res.is_some())\n\t}\n\n\tfn generate_token(&self) -> Result<String, Error> {\n\t\tself.signer.generate_token()\n\t\t\t.map_err(|e| errors::token(e))\n\t}\n\n\tfn generate_web_proxy_token(&self, domain: String) -> Result<String, Error> {\n\t\tOk(self.signer.generate_web_proxy_access_token(domain.into()))\n\t}\n\n\tfn subscribe_pending(&self, _meta: Self::Metadata, sub: Subscriber<Vec<ConfirmationRequest>>) {\n\t\tself.subscribers.lock().push(sub)\n\t}\n\n\tfn unsubscribe_pending(&self, id: SubscriptionId) -> BoxFuture<bool, Error> {\n\t\tlet res = self.subscribers.lock().remove(&id).is_some();\n\t\tfutures::future::ok(res).boxed()\n\t}\n}\n", "// Copyright 2015-2017 Parity Technologies (UK) Ltd.\n// This file is part of Parity.\n\n// Parity is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Parity is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Parity.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Parity Signer-related rpc interface.\nuse jsonrpc_core::Error;\nuse jsonrpc_pubsub::SubscriptionId;\nuse jsonrpc_macros::pubsub::Subscriber;\nuse futures::BoxFuture;\n\nuse v1::types::{U256, Bytes, TransactionModification, ConfirmationRequest, ConfirmationResponse, ConfirmationResponseWithToken};\n\nbuild_rpc_trait! {\n\t/// Signer extension for confirmations rpc interface.\n\tpub trait Signer {\n\t\ttype Metadata;\n\n\t\t/// Returns a list of items to confirm.\n\t\t#[rpc(name = \"signer_requestsToConfirm\")]\n\t\tfn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error>;\n\n\t\t/// Confirm specific request.\n\t\t#[rpc(async, name = \"signer_confirmRequest\")]\n\t\tfn confirm_request(&self, U256, TransactionModification, String) -> BoxFuture<ConfirmationResponse, Error>;\n\n\t\t/// Confirm specific request with token.\n\t\t#[rpc(async, name = \"signer_confirmRequestWithToken\")]\n\t\tfn confirm_request_with_token(&self, U256, TransactionModification, String) -> BoxFuture<ConfirmationResponseWithToken, Error>;\n\n\t\t/// Confirm specific request with already signed data.\n\t\t#[rpc(name = \"signer_confirmRequestRaw\")]\n\t\tfn confirm_request_raw(&self, U256, Bytes) -> Result<ConfirmationResponse, Error>;\n\n\t\t/// Reject the confirmation request.\n\t\t#[rpc(name = \"signer_rejectRequest\")]\n\t\tfn reject_request(&self, U256) -> Result<bool, Error>;\n\n\t\t/// Generates new authorization token.\n\t\t#[rpc(name = \"signer_generateAuthorizationToken\")]\n\t\tfn generate_token(&self) -> Result<String, Error>;\n\n\t\t/// Generates new web proxy access token for particular domain.\n\t\t#[rpc(name = \"signer_generateWebProxyAccessToken\")]\n\t\tfn generate_web_proxy_token(&self, String) -> Result<String, Error>;\n\n\t\t#[pubsub(name = \"signer_pending\")] {\n\t\t\t/// Subscribe to new pending requests on signer interface.\n\t\t\t#[rpc(name = \"signer_subscribePending\")]\n\t\t\tfn subscribe_pending(&self, Self::Metadata, Subscriber<Vec<ConfirmationRequest>>);\n\n\t\t\t/// Unsubscribe from pending requests subscription.\n\t\t\t#[rpc(name = \"signer_unsubscribePending\")]\n\t\t\tfn unsubscribe_pending(&self, SubscriptionId) -> BoxFuture<bool, Error>;\n\t\t}\n\t}\n}\n"], "filenames": ["dapps/src/lib.rs", "dapps/src/tests/fetch.rs", "dapps/src/tests/helpers/mod.rs", "dapps/src/web.rs", "js/src/api/rpc/signer/signer.js", "js/src/jsonrpc/interfaces/signer.js", "js/src/views/Web/store.js", "js/src/views/Web/store.spec.js", "js/src/views/Web/web.js", "parity/dapps.rs", "rpc/src/v1/helpers/signer.rs", "rpc/src/v1/impls/signer.rs", "rpc/src/v1/traits/signer.rs"], "buggy_code_start_loc": [74, 315, 103, 136, 45, 33, 62, 65, 40, 235, 18, 248, 54], "buggy_code_end_loc": [99, 501, 151, 153, 48, 34, 142, 74, 41, 236, 59, 250, 57], "fixing_code_start_loc": [74, 315, 103, 136, 45, 33, 62, 65, 39, 235, 19, 248, 54], "fixing_code_end_loc": [99, 523, 153, 160, 48, 38, 144, 75, 39, 236, 60, 250, 57], "type": "CWE-346", "message": "Parity Browser 1.6.10 and earlier allows remote attackers to bypass the Same Origin Policy and obtain sensitive information by requesting other websites via the Parity web proxy engine (reusing the current website's token, which is not bound to an origin).", "other": {"cve": {"id": "CVE-2017-18016", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-11T16:29:01.487", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parity Browser 1.6.10 and earlier allows remote attackers to bypass the Same Origin Policy and obtain sensitive information by requesting other websites via the Parity web proxy engine (reusing the current website's token, which is not bound to an origin)."}, {"lang": "es", "value": "Parity Browser 1.6.10 y anteriores permite que atacantes remotos omitan la pol\u00edtica del mismo origen y obtengan informaci\u00f3n sensible mediante peticiones a otros sitios por medio del motor web proxy de Parity (reutilizando el token de la p\u00e1gina web actual, que no est\u00e1 enlazado a un origen)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parity:browser:1.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "03806D4C-D3B4-499F-895F-7C8E2356657D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2018/01/10/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/parity/commit/53609f703e2f1af76441344ac3b72811c726a215", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tintinweb/pub/tree/master/pocs/cve-2017-18016", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/43499/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/paritytech/parity/commit/53609f703e2f1af76441344ac3b72811c726a215"}}