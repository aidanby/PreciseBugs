{"buggy_code": ["<?php\nnamespace TYPO3\\Form\\Core\\Runtime;\n\n/*                                                                        *\n * This script belongs to the TYPO3 Flow package \"TYPO3.Form\".            *\n *                                                                        *\n * It is free software; you can redistribute it and/or modify it under    *\n * the terms of the GNU Lesser General Public License, either version 3   *\n * of the License, or (at your option) any later version.                 *\n *                                                                        *\n * The TYPO3 project - inspiring people to share!                         *\n *                                                                        */\n\nuse TYPO3\\Flow\\Annotations as Flow;\nuse TYPO3\\Flow\\Mvc\\ActionRequest;\n\n/**\n * This class implements the *runtime logic* of a form, i.e. deciding which\n * page is shown currently, what the current values of the form are, trigger\n * validation and property mapping.\n *\n * **This class is not meant to be subclassed by developers.**\n *\n * You generally receive an instance of this class by calling {@link \\TYPO3\\Form\\Core\\Model\\FormDefinition::bind}.\n *\n * Rendering a Form\n * ================\n *\n * That's easy, just call render() on the FormRuntime:\n *\n * /---code php\n * $form = $formDefinition->bind($request, $response);\n * $renderedForm = $form->render();\n * \\---\n *\n * Accessing Form Values\n * =====================\n *\n * In order to get the values the user has entered into the form, you can access\n * this object like an array: If a form field with the identifier *firstName*\n * exists, you can do **$form['firstName']** to retrieve its current value.\n *\n * You can also set values in the same way.\n *\n * Rendering Internals\n * ===================\n *\n * The FormRuntime asks the FormDefinition about the configured Renderer\n * which should be used ({@link \\TYPO3\\Form\\Core\\Model\\FormDefinition::getRendererClassName}),\n * and then trigger render() on this element.\n *\n * This makes it possible to declaratively define how a form should be rendered.\n *\n * @api\n */\nclass FormRuntime implements \\TYPO3\\Form\\Core\\Model\\Renderable\\RootRenderableInterface, \\ArrayAccess {\n\n\t/**\n\t * @var \\TYPO3\\Form\\Core\\Model\\FormDefinition\n\t * @internal\n\t */\n\tprotected $formDefinition;\n\n\t/**\n\t * @var \\TYPO3\\Flow\\Mvc\\ActionRequest\n\t * @internal\n\t */\n\tprotected $request;\n\n\t/**\n\t * @var \\TYPO3\\Flow\\Http\\Response\n\t * @internal\n\t */\n\tprotected $response;\n\n\t/**\n\t * @var \\TYPO3\\Form\\Core\\Runtime\\FormState\n\t * @internal\n\t */\n\tprotected $formState;\n\n\t/**\n\t * The current page is the page which will be displayed to the user\n\t * during rendering.\n\t *\n\t * If $currentPage is NULL, the *last* page has been submitted and\n\t * finishing actions need to take place. You should use $this->isAfterLastPage()\n\t * instead of explicitely checking for NULL.\n\t *\n\t * @var \\TYPO3\\Form\\Core\\Model\\Page\n\t * @internal\n\t */\n\tprotected $currentPage = NULL;\n\n\t/**\n\t * Reference to the page which has been shown on the last request (i.e.\n\t * we have to handle the submitted data from lastDisplayedPage)\n\t *\n\t * @var \\TYPO3\\Form\\Core\\Model\\Page\n\t * @internal\n\t */\n\tprotected $lastDisplayedPage = NULL;\n\n\t/**\n\t * @Flow\\Inject\n\t * @var \\TYPO3\\Flow\\Security\\Cryptography\\HashService\n\t * @internal\n\t */\n\tprotected $hashService;\n\n\t/**\n\t * Workaround...\n\t *\n\t * @Flow\\Inject\n\t * @var \\TYPO3\\Flow\\Mvc\\FlashMessageContainer\n\t * @internal\n\t */\n\tprotected $flashMessageContainer;\n\n\t/**\n\t * @param \\TYPO3\\Form\\Core\\Model\\FormDefinition $formDefinition\n\t * @param \\TYPO3\\Flow\\Mvc\\ActionRequest $request\n\t * @param \\TYPO3\\Flow\\Http\\Response $response\n\t * @throws \\TYPO3\\Form\\Exception\\IdentifierNotValidException\n\t * @internal\n\t */\n\tpublic function __construct(\\TYPO3\\Form\\Core\\Model\\FormDefinition $formDefinition, \\TYPO3\\Flow\\Mvc\\ActionRequest $request, \\TYPO3\\Flow\\Http\\Response $response) {\n\t\t$this->formDefinition = $formDefinition;\n\t\t$rootRequest = $request->getMainRequest() ?: $request;\n\t\t$pluginArguments = $rootRequest->getPluginArguments();\n\t\t$this->request = new ActionRequest($request);\n\t\t$formIdentifier = $this->formDefinition->getIdentifier();\n\t\t$this->request->setArgumentNamespace('--' . $formIdentifier);\n\t\tif (isset($pluginArguments[$formIdentifier])) {\n\t\t\t$this->request->setArguments($pluginArguments[$formIdentifier]);\n\t\t}\n\n\t\t$this->response = $response;\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tpublic function initializeObject() {\n\t\t$this->initializeFormStateFromRequest();\n\t\t$this->initializeCurrentPageFromRequest();\n\n\t\tif (!$this->isFirstRequest()) {\n\t\t\t$this->processSubmittedFormValues();\n\t\t}\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tprotected function initializeFormStateFromRequest() {\n\t\t$serializedFormStateWithHmac = $this->request->getInternalArgument('__state');\n\t\tif ($serializedFormStateWithHmac === NULL) {\n\t\t\t$this->formState = new FormState();\n\t\t} else {\n\t\t\t$serializedFormState = $this->hashService->validateAndStripHmac($serializedFormStateWithHmac);\n\t\t\t$this->formState = unserialize(base64_decode($serializedFormState));\n\t\t}\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tprotected function initializeCurrentPageFromRequest() {\n\t\tif (!$this->formState->isFormSubmitted()) {\n\t\t\t$this->currentPage = $this->formDefinition->getPageByIndex(0);\n\t\t\treturn;\n\t\t}\n\t\t$this->lastDisplayedPage = $this->formDefinition->getPageByIndex($this->formState->getLastDisplayedPageIndex());\n\n\t\t// We know now that lastDisplayedPage is filled\n\t\t$currentPageIndex = (integer)$this->request->getInternalArgument('__currentPage');\n\t\tif ($currentPageIndex > $this->lastDisplayedPage->getIndex() + 1) {\n\t\t\t\t// We only allow jumps to following pages\n\t\t\t$currentPageIndex = $this->lastDisplayedPage->getIndex() + 1;\n\t\t}\n\n\t\t// We now know that the user did not try to skip a page\n\t\tif ($currentPageIndex === count($this->formDefinition->getPages())) {\n\t\t\t\t// Last Page\n\t\t\t$this->currentPage = NULL;\n\t\t} else {\n\t\t\t$this->currentPage = $this->formDefinition->getPageByIndex($currentPageIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Returns TRUE if the last page of the form has been submitted, otherwise FALSE\n\t *\n\t * @return boolean\n\t */\n\tprotected function isAfterLastPage() {\n\t\treturn ($this->currentPage === NULL);\n\t}\n\n\t/**\n\t * Returns TRUE if no previous page is stored in the FormState, otherwise FALSE\n\t *\n\t * @return boolean\n\t */\n\tprotected function isFirstRequest() {\n\t\treturn ($this->lastDisplayedPage === NULL);\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tprotected function processSubmittedFormValues() {\n\t\t$result = $this->mapAndValidatePage($this->lastDisplayedPage);\n\t\tif ($result->hasErrors() && !$this->userWentBackToPreviousStep()) {\n\t\t\t$this->currentPage = $this->lastDisplayedPage;\n\t\t\t$this->request->setArgument('__submittedArguments', $this->request->getArguments());\n\t\t\t$this->request->setArgument('__submittedArgumentValidationResults', $result);\n\t\t}\n\t}\n\n\t/**\n\t * returns TRUE if the user went back to any previous step in the form.\n\t *\n\t * @return boolean\n\t */\n\tprotected function userWentBackToPreviousStep() {\n\t\treturn !$this->isAfterLastPage() && !$this->isFirstRequest() && $this->currentPage->getIndex() < $this->lastDisplayedPage->getIndex();\n\t}\n\n\t/**\n\t * @param \\TYPO3\\Form\\Core\\Model\\Page $page\n\t * @return \\TYPO3\\Flow\\Error\\Result\n\t * @internal\n\t */\n\tprotected function mapAndValidatePage(\\TYPO3\\Form\\Core\\Model\\Page $page) {\n\t\t$result = new \\TYPO3\\Flow\\Error\\Result();\n\t\t$requestArguments = $this->request->getArguments();\n\n\t\t$propertyPathsForWhichPropertyMappingShouldHappen = array();\n\t\t$registerPropertyPaths = function($propertyPath) use (&$propertyPathsForWhichPropertyMappingShouldHappen) {\n\t\t\t$propertyPathParts = explode ('.', $propertyPath);\n\t\t\t$accumulatedPropertyPathParts = array();\n\t\t\tforeach ($propertyPathParts as $propertyPathPart) {\n\t\t\t\t$accumulatedPropertyPathParts[] = $propertyPathPart;\n\t\t\t\t$temporaryPropertyPath = implode('.', $accumulatedPropertyPathParts);\n\t\t\t\t$propertyPathsForWhichPropertyMappingShouldHappen[$temporaryPropertyPath] = $temporaryPropertyPath;\n\t\t\t}\n\t\t};\n\n\t\tforeach ($page->getElementsRecursively() as $element) {\n\t\t\t$value = \\TYPO3\\Flow\\Utility\\Arrays::getValueByPath($requestArguments, $element->getIdentifier());\n\t\t\t$element->onSubmit($this, $value);\n\n\t\t\t$this->formState->setFormValue($element->getIdentifier(), $value);\n\t\t\t$registerPropertyPaths($element->getIdentifier());\n\t\t}\n\n\t\t// The more parts the path has, the more early it is processed\n\t\tusort($propertyPathsForWhichPropertyMappingShouldHappen, function($a, $b) {\n\t\t\treturn substr_count($b, '.') - substr_count($a, '.');\n\t\t});\n\n\t\t$processingRules = $this->formDefinition->getProcessingRules();\n\t\tforeach ($propertyPathsForWhichPropertyMappingShouldHappen as $propertyPath) {\n\t\t\tif (isset($processingRules[$propertyPath])) {\n\t\t\t\t$processingRule = $processingRules[$propertyPath];\n\t\t\t\t$value = $this->formState->getFormValue($propertyPath);\n\t\t\t\ttry {\n\t\t\t\t\t$value = $processingRule->process($value);\n\t\t\t\t} catch (\\TYPO3\\Flow\\Property\\Exception $exception) {\n\t\t\t\t\tthrow new \\TYPO3\\Form\\Exception\\PropertyMappingException('Failed to process FormValue at \"' . $propertyPath . '\" from \"' . gettype($value) . '\" to \"' . $processingRule->getDataType() . '\"', 1355218921, $exception);\n\t\t\t\t}\n\t\t\t\t$result->forProperty($propertyPath)->merge($processingRule->getProcessingMessages());\n\t\t\t\t$this->formState->setFormValue($propertyPath, $value);\n\t\t\t}\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Override the current page taken from the request, rendering the page with index $pageIndex instead.\n\t *\n\t * This is typically not needed in production code, but it is very helpful when displaying\n\t * some kind of \"preview\" of the form.\n\t *\n\t * @param integer $pageIndex\n\t * @return void\n\t * @api\n\t */\n\tpublic function overrideCurrentPage($pageIndex) {\n\t\t$this->currentPage = $this->formDefinition->getPageByIndex($pageIndex);\n\t}\n\n\t/**\n\t * Render this form.\n\t *\n\t * @return string rendered form\n\t * @api\n\t * @throws \\TYPO3\\Form\\Exception\\RenderingException\n\t */\n\tpublic function render() {\n\t\tif ($this->isAfterLastPage()) {\n\t\t\t$this->invokeFinishers();\n\t\t\treturn $this->response->getContent();\n\t\t}\n\n\t\t$this->formState->setLastDisplayedPageIndex($this->currentPage->getIndex());\n\n\t\tif ($this->formDefinition->getRendererClassName() === NULL) {\n\t\t\tthrow new \\TYPO3\\Form\\Exception\\RenderingException(sprintf('The form definition \"%s\" does not have a rendererClassName set.', $this->formDefinition->getIdentifier()), 1326095912);\n\t\t}\n\t\t$rendererClassName = $this->formDefinition->getRendererClassName();\n\t\t$renderer = new $rendererClassName();\n\t\tif (!($renderer instanceof \\TYPO3\\Form\\Core\\Renderer\\RendererInterface)) {\n\t\t\tthrow new \\TYPO3\\Form\\Exception\\RenderingException(sprintf('The renderer \"%s\" des not implement RendererInterface', $rendererClassName), 1326096024);\n\t\t}\n\n\t\t$controllerContext = $this->getControllerContext();\n\t\t$renderer->setControllerContext($controllerContext);\n\n\t\t$renderer->setFormRuntime($this);\n\t\treturn $renderer->renderRenderable($this);\n\t}\n\n\t/**\n\t * Executes all finishers of this form\n\t *\n\t * @return void\n\t * @internal\n\t */\n\tprotected function invokeFinishers() {\n\t\t$finisherContext = new \\TYPO3\\Form\\Core\\Model\\FinisherContext($this);\n\t\tforeach ($this->formDefinition->getFinishers() as $finisher) {\n\t\t\t$finisher->execute($finisherContext);\n\t\t\tif ($finisherContext->isCancelled()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return string The identifier of underlying form\n\t * @api\n\t */\n\tpublic function getIdentifier() {\n\t\treturn $this->formDefinition->getIdentifier();\n\t}\n\n\t/**\n\t * Get the request this object is bound to.\n\t *\n\t * This is mostly relevant inside Finishers, where you f.e. want to redirect\n\t * the user to another page.\n\t *\n\t * @return \\TYPO3\\Flow\\Mvc\\ActionRequest the request this object is bound to\n\t * @api\n\t */\n\tpublic function getRequest() {\n\t\treturn $this->request;\n\t}\n\n\t/**\n\t * Get the response this object is bound to.\n\t *\n\t * This is mostly relevant inside Finishers, where you f.e. want to set response\n\t * headers or output content.\n\t *\n\t * @return \\TYPO3\\Flow\\Http\\Response the response this object is bound to\n\t * @api\n\t */\n\tpublic function getResponse() {\n\t\treturn $this->response;\n\t}\n\n\t/**\n\t * Returns the currently selected page\n\t *\n\t * @return \\TYPO3\\Form\\Core\\Model\\Page\n\t * @api\n\t */\n\tpublic function getCurrentPage() {\n\t\treturn $this->currentPage;\n\t}\n\n\t/**\n\t * Returns the previous page of the currently selected one or NULL if there is no previous page\n\t *\n\t * @return \\TYPO3\\Form\\Core\\Model\\Page\n\t * @api\n\t */\n\tpublic function getPreviousPage() {\n\t\t$previousPageIndex = $this->currentPage->getIndex() - 1;\n\t\tif ($this->formDefinition->hasPageWithIndex($previousPageIndex)) {\n\t\t\treturn $this->formDefinition->getPageByIndex($previousPageIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the next page of the currently selected one or NULL if there is no next page\n\t *\n\t * @return \\TYPO3\\Form\\Core\\Model\\Page\n\t * @api\n\t */\n\tpublic function getNextPage() {\n\t\t$nextPageIndex = $this->currentPage->getIndex() + 1;\n\t\tif ($this->formDefinition->hasPageWithIndex($nextPageIndex)) {\n\t\t\treturn $this->formDefinition->getPageByIndex($nextPageIndex);\n\t\t}\n\t}\n\n\t/**\n\t * @return \\TYPO3\\Flow\\Mvc\\Controller\\ControllerContext\n\t * @internal\n\t */\n\tprotected function getControllerContext() {\n\t\t$uriBuilder = new \\TYPO3\\Flow\\Mvc\\Routing\\UriBuilder();\n\t\t$uriBuilder->setRequest($this->request);\n\n\t\treturn new \\TYPO3\\Flow\\Mvc\\Controller\\ControllerContext(\n\t\t\t$this->request,\n\t\t\t$this->response,\n\t\t\tnew \\TYPO3\\Flow\\Mvc\\Controller\\Arguments(array()),\n\t\t\t$uriBuilder,\n\t\t\t$this->flashMessageContainer\n\t\t);\n\t}\n\n\t/**\n\t * Abstract \"type\" of this Renderable. Is used during the rendering process\n\t * to determine the template file or the View PHP class being used to render\n\t * the particular element.\n\t *\n\t * @return string\n\t * @api\n\t */\n\tpublic function getType() {\n\t\treturn $this->formDefinition->getType();\n\t}\n\n\t/**\n\t * @param string $identifier\n\t * @return mixed\n\t * @api\n\t */\n\tpublic function offsetExists($identifier) {\n\t\treturn ($this->getElementValue($identifier) !== NULL);\n\t}\n\n\t/**\n\t * Returns the value of the specified element\n\t *\n\t * @param string $identifier\n\t * @return mixed\n\t * @api\n\t */\n\tprotected function getElementValue($identifier) {\n\t\t$formValue = $this->formState->getFormValue($identifier);\n\t\tif ($formValue !== NULL) {\n\t\t\treturn $formValue;\n\t\t}\n\t\treturn $this->formDefinition->getElementDefaultValueByIdentifier($identifier);\n\t}\n\n\t/**\n\t * @param string $identifier\n\t * @return mixed\n\t * @api\n\t */\n\tpublic function offsetGet($identifier) {\n\t\treturn $this->getElementValue($identifier);\n\t}\n\n\t/**\n\t * @param string $identifier\n\t * @param mixed $value\n\t * @return void\n\t * @api\n\t */\n\tpublic function offsetSet($identifier, $value) {\n\t\t$this->formState->setFormValue($identifier, $value);\n\t}\n\n\t/**\n\t * @api\n\t * @param string $identifier\n\t * @return void\n\t */\n\tpublic function offsetUnset($identifier) {\n\t\t$this->formState->setFormValue($identifier, NULL);\n\t}\n\n\t/**\n\t * @return array<TYPO3\\Form\\Core\\Model\\Page> The Form's pages in the correct order\n\t * @api\n\t */\n\tpublic function getPages() {\n\t\treturn $this->formDefinition->getPages();\n\t}\n\n\t/**\n\t * @return \\TYPO3\\Form\\Core\\Runtime\\FormState\n\t * @internal\n\t */\n\tpublic function getFormState() {\n\t\treturn $this->formState;\n\t}\n\n\t/**\n\t * Get all rendering options\n\t *\n\t * @return array associative array of rendering options\n\t * @api\n\t */\n\tpublic function getRenderingOptions() {\n\t\treturn $this->formDefinition->getRenderingOptions();\n\t}\n\n\t/**\n\t * Get the renderer class name to be used to display this renderable;\n\t * must implement RendererInterface\n\t *\n\t * @return string the renderer class name\n\t * @api\n\t */\n\tpublic function getRendererClassName() {\n\t\treturn $this->formDefinition->getRendererClassName();\n\t}\n\n\t/**\n\t * Get the label which shall be displayed next to the form element\n\t *\n\t * @return string\n\t * @api\n\t */\n\tpublic function getLabel() {\n\t\treturn $this->formDefinition->getLabel();\n\t}\n\n\t/**\n\t * This is a callback that is invoked by the Renderer before the corresponding element is rendered.\n\t * Use this to access previously submitted values and/or modify the $formRuntime before an element\n\t * is outputted to the browser.\n\t *\n\t * @param \\TYPO3\\Form\\Core\\Runtime\\FormRuntime $formRuntime\n\t * @return void\n\t * @api\n\t */\n\tpublic function beforeRendering(\\TYPO3\\Form\\Core\\Runtime\\FormRuntime $formRuntime) {\n\t}\n}\n", "<?php\nnamespace TYPO3\\Form\\Tests\\Functional;\n\n/*                                                                        *\n * This script belongs to the TYPO3 Flow package \"TYPO3.Form\".            *\n *                                                                        *\n * It is free software; you can redistribute it and/or modify it under    *\n * the terms of the GNU Lesser General Public License, either version 3   *\n * of the License, or (at your option) any later version.                 *\n *                                                                        *\n * The TYPO3 project - inspiring people to share!                         *\n *                                                                        */\nuse Symfony\\Component\\DomCrawler\\Field\\InputFormField;\n\n/**\n * Testcase for Simple Form\n *\n * @group large\n */\nclass SimpleFormTest extends AbstractFunctionalTestCase {\n\t/**\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfFirstPage() {\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text1-1']->setValue('My Text on the first page');\n\n\t\t$this->gotoNextFormPage($form);\n\n\t\t$this->gotoPreviousFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('My Text on the first page', $form['--three-page-form-with-validation']['text1-1']->getValue());\n\t}\n\n\t/**\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfSecondPage() {\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('My Text on the second page');\n\t\t$this->gotoPreviousFormPage($form);\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('My Text on the second page', $form['--three-page-form-with-validation']['text2-1']->getValue());\n\t}\n\n\t/**\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfSecondPageAndTriggersValidationOnlyWhenGoingForward() {\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('My Text on the second page');\n\t\t$this->gotoPreviousFormPage($form);\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\t\t$r = $this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$this->assertSame(' error', $this->browser->getCrawler()->filterXPath('//*[contains(@class,\"error\")]//input[@id=\"three-page-form-with-validation-text2-1\"]')->attr('class'));\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('42');\n\t\t$this->gotoNextFormPage($form);\n\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('', $form['--three-page-form-with-validation']['text3-1']->getValue());\n\t}\n\n}\n"], "fixing_code": ["<?php\nnamespace TYPO3\\Form\\Core\\Runtime;\n\n/*                                                                        *\n * This script belongs to the TYPO3 Flow package \"TYPO3.Form\".            *\n *                                                                        *\n * It is free software; you can redistribute it and/or modify it under    *\n * the terms of the GNU Lesser General Public License, either version 3   *\n * of the License, or (at your option) any later version.                 *\n *                                                                        *\n * The TYPO3 project - inspiring people to share!                         *\n *                                                                        */\n\nuse TYPO3\\Flow\\Annotations as Flow;\nuse TYPO3\\Flow\\Mvc\\ActionRequest;\n\n/**\n * This class implements the *runtime logic* of a form, i.e. deciding which\n * page is shown currently, what the current values of the form are, trigger\n * validation and property mapping.\n *\n * **This class is not meant to be subclassed by developers.**\n *\n * You generally receive an instance of this class by calling {@link \\TYPO3\\Form\\Core\\Model\\FormDefinition::bind}.\n *\n * Rendering a Form\n * ================\n *\n * That's easy, just call render() on the FormRuntime:\n *\n * /---code php\n * $form = $formDefinition->bind($request, $response);\n * $renderedForm = $form->render();\n * \\---\n *\n * Accessing Form Values\n * =====================\n *\n * In order to get the values the user has entered into the form, you can access\n * this object like an array: If a form field with the identifier *firstName*\n * exists, you can do **$form['firstName']** to retrieve its current value.\n *\n * You can also set values in the same way.\n *\n * Rendering Internals\n * ===================\n *\n * The FormRuntime asks the FormDefinition about the configured Renderer\n * which should be used ({@link \\TYPO3\\Form\\Core\\Model\\FormDefinition::getRendererClassName}),\n * and then trigger render() on this element.\n *\n * This makes it possible to declaratively define how a form should be rendered.\n *\n * @api\n */\nclass FormRuntime implements \\TYPO3\\Form\\Core\\Model\\Renderable\\RootRenderableInterface, \\ArrayAccess {\n\n\t/**\n\t * @var \\TYPO3\\Form\\Core\\Model\\FormDefinition\n\t * @internal\n\t */\n\tprotected $formDefinition;\n\n\t/**\n\t * @var \\TYPO3\\Flow\\Mvc\\ActionRequest\n\t * @internal\n\t */\n\tprotected $request;\n\n\t/**\n\t * @var \\TYPO3\\Flow\\Http\\Response\n\t * @internal\n\t */\n\tprotected $response;\n\n\t/**\n\t * @var \\TYPO3\\Form\\Core\\Runtime\\FormState\n\t * @internal\n\t */\n\tprotected $formState;\n\n\t/**\n\t * The current page is the page which will be displayed to the user\n\t * during rendering.\n\t *\n\t * If $currentPage is NULL, the *last* page has been submitted and\n\t * finishing actions need to take place. You should use $this->isAfterLastPage()\n\t * instead of explicitely checking for NULL.\n\t *\n\t * @var \\TYPO3\\Form\\Core\\Model\\Page\n\t * @internal\n\t */\n\tprotected $currentPage = NULL;\n\n\t/**\n\t * Reference to the page which has been shown on the last request (i.e.\n\t * we have to handle the submitted data from lastDisplayedPage)\n\t *\n\t * @var \\TYPO3\\Form\\Core\\Model\\Page\n\t * @internal\n\t */\n\tprotected $lastDisplayedPage = NULL;\n\n\t/**\n\t * @Flow\\Inject\n\t * @var \\TYPO3\\Flow\\Security\\Cryptography\\HashService\n\t * @internal\n\t */\n\tprotected $hashService;\n\n\t/**\n\t * Workaround...\n\t *\n\t * @Flow\\Inject\n\t * @var \\TYPO3\\Flow\\Mvc\\FlashMessageContainer\n\t * @internal\n\t */\n\tprotected $flashMessageContainer;\n\n\t/**\n\t * @param \\TYPO3\\Form\\Core\\Model\\FormDefinition $formDefinition\n\t * @param \\TYPO3\\Flow\\Mvc\\ActionRequest $request\n\t * @param \\TYPO3\\Flow\\Http\\Response $response\n\t * @throws \\TYPO3\\Form\\Exception\\IdentifierNotValidException\n\t * @internal\n\t */\n\tpublic function __construct(\\TYPO3\\Form\\Core\\Model\\FormDefinition $formDefinition, \\TYPO3\\Flow\\Mvc\\ActionRequest $request, \\TYPO3\\Flow\\Http\\Response $response) {\n\t\t$this->formDefinition = $formDefinition;\n\t\t$rootRequest = $request->getMainRequest() ?: $request;\n\t\t$pluginArguments = $rootRequest->getPluginArguments();\n\t\t$this->request = new ActionRequest($request);\n\t\t$formIdentifier = $this->formDefinition->getIdentifier();\n\t\t$this->request->setArgumentNamespace('--' . $formIdentifier);\n\t\tif (isset($pluginArguments[$formIdentifier])) {\n\t\t\t$this->request->setArguments($pluginArguments[$formIdentifier]);\n\t\t}\n\n\t\t$this->response = $response;\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tpublic function initializeObject() {\n\t\t$this->initializeFormStateFromRequest();\n\t\t$this->initializeCurrentPageFromRequest();\n\n\t\tif (!$this->isFirstRequest() && $this->getRequest()->getHttpRequest()->getMethod() === 'POST') {\n\t\t\t$this->processSubmittedFormValues();\n\t\t}\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tprotected function initializeFormStateFromRequest() {\n\t\t$serializedFormStateWithHmac = $this->request->getInternalArgument('__state');\n\t\tif ($serializedFormStateWithHmac === NULL) {\n\t\t\t$this->formState = new FormState();\n\t\t} else {\n\t\t\t$serializedFormState = $this->hashService->validateAndStripHmac($serializedFormStateWithHmac);\n\t\t\t$this->formState = unserialize(base64_decode($serializedFormState));\n\t\t}\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tprotected function initializeCurrentPageFromRequest() {\n\t\tif (!$this->formState->isFormSubmitted()) {\n\t\t\t$this->currentPage = $this->formDefinition->getPageByIndex(0);\n\t\t\treturn;\n\t\t}\n\t\t$this->lastDisplayedPage = $this->formDefinition->getPageByIndex($this->formState->getLastDisplayedPageIndex());\n\n\t\t// We know now that lastDisplayedPage is filled\n\t\t$currentPageIndex = (integer)$this->request->getInternalArgument('__currentPage');\n\t\tif ($currentPageIndex > $this->lastDisplayedPage->getIndex() + 1) {\n\t\t\t\t// We only allow jumps to following pages\n\t\t\t$currentPageIndex = $this->lastDisplayedPage->getIndex() + 1;\n\t\t}\n\n\t\t// We now know that the user did not try to skip a page\n\t\tif ($currentPageIndex === count($this->formDefinition->getPages())) {\n\t\t\t\t// Last Page\n\t\t\t$this->currentPage = NULL;\n\t\t} else {\n\t\t\t$this->currentPage = $this->formDefinition->getPageByIndex($currentPageIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Returns TRUE if the last page of the form has been submitted, otherwise FALSE\n\t *\n\t * @return boolean\n\t */\n\tprotected function isAfterLastPage() {\n\t\treturn ($this->currentPage === NULL);\n\t}\n\n\t/**\n\t * Returns TRUE if no previous page is stored in the FormState, otherwise FALSE\n\t *\n\t * @return boolean\n\t */\n\tprotected function isFirstRequest() {\n\t\treturn ($this->lastDisplayedPage === NULL);\n\t}\n\n\t/**\n\t * @return void\n\t * @internal\n\t */\n\tprotected function processSubmittedFormValues() {\n\t\t$result = $this->mapAndValidatePage($this->lastDisplayedPage);\n\t\tif ($result->hasErrors() && !$this->userWentBackToPreviousStep()) {\n\t\t\t$this->currentPage = $this->lastDisplayedPage;\n\t\t\t$this->request->setArgument('__submittedArguments', $this->request->getArguments());\n\t\t\t$this->request->setArgument('__submittedArgumentValidationResults', $result);\n\t\t}\n\t}\n\n\t/**\n\t * returns TRUE if the user went back to any previous step in the form.\n\t *\n\t * @return boolean\n\t */\n\tprotected function userWentBackToPreviousStep() {\n\t\treturn !$this->isAfterLastPage() && !$this->isFirstRequest() && $this->currentPage->getIndex() < $this->lastDisplayedPage->getIndex();\n\t}\n\n\t/**\n\t * @param \\TYPO3\\Form\\Core\\Model\\Page $page\n\t * @return \\TYPO3\\Flow\\Error\\Result\n\t * @internal\n\t */\n\tprotected function mapAndValidatePage(\\TYPO3\\Form\\Core\\Model\\Page $page) {\n\t\t$result = new \\TYPO3\\Flow\\Error\\Result();\n\t\t$requestArguments = $this->request->getArguments();\n\n\t\t$propertyPathsForWhichPropertyMappingShouldHappen = array();\n\t\t$registerPropertyPaths = function($propertyPath) use (&$propertyPathsForWhichPropertyMappingShouldHappen) {\n\t\t\t$propertyPathParts = explode ('.', $propertyPath);\n\t\t\t$accumulatedPropertyPathParts = array();\n\t\t\tforeach ($propertyPathParts as $propertyPathPart) {\n\t\t\t\t$accumulatedPropertyPathParts[] = $propertyPathPart;\n\t\t\t\t$temporaryPropertyPath = implode('.', $accumulatedPropertyPathParts);\n\t\t\t\t$propertyPathsForWhichPropertyMappingShouldHappen[$temporaryPropertyPath] = $temporaryPropertyPath;\n\t\t\t}\n\t\t};\n\n\t\tforeach ($page->getElementsRecursively() as $element) {\n\t\t\t$value = \\TYPO3\\Flow\\Utility\\Arrays::getValueByPath($requestArguments, $element->getIdentifier());\n\t\t\t$element->onSubmit($this, $value);\n\n\t\t\t$this->formState->setFormValue($element->getIdentifier(), $value);\n\t\t\t$registerPropertyPaths($element->getIdentifier());\n\t\t}\n\n\t\t// The more parts the path has, the more early it is processed\n\t\tusort($propertyPathsForWhichPropertyMappingShouldHappen, function($a, $b) {\n\t\t\treturn substr_count($b, '.') - substr_count($a, '.');\n\t\t});\n\n\t\t$processingRules = $this->formDefinition->getProcessingRules();\n\t\tforeach ($propertyPathsForWhichPropertyMappingShouldHappen as $propertyPath) {\n\t\t\tif (isset($processingRules[$propertyPath])) {\n\t\t\t\t$processingRule = $processingRules[$propertyPath];\n\t\t\t\t$value = $this->formState->getFormValue($propertyPath);\n\t\t\t\ttry {\n\t\t\t\t\t$value = $processingRule->process($value);\n\t\t\t\t} catch (\\TYPO3\\Flow\\Property\\Exception $exception) {\n\t\t\t\t\tthrow new \\TYPO3\\Form\\Exception\\PropertyMappingException('Failed to process FormValue at \"' . $propertyPath . '\" from \"' . gettype($value) . '\" to \"' . $processingRule->getDataType() . '\"', 1355218921, $exception);\n\t\t\t\t}\n\t\t\t\t$result->forProperty($propertyPath)->merge($processingRule->getProcessingMessages());\n\t\t\t\t$this->formState->setFormValue($propertyPath, $value);\n\t\t\t}\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Override the current page taken from the request, rendering the page with index $pageIndex instead.\n\t *\n\t * This is typically not needed in production code, but it is very helpful when displaying\n\t * some kind of \"preview\" of the form.\n\t *\n\t * @param integer $pageIndex\n\t * @return void\n\t * @api\n\t */\n\tpublic function overrideCurrentPage($pageIndex) {\n\t\t$this->currentPage = $this->formDefinition->getPageByIndex($pageIndex);\n\t}\n\n\t/**\n\t * Render this form.\n\t *\n\t * @return string rendered form\n\t * @api\n\t * @throws \\TYPO3\\Form\\Exception\\RenderingException\n\t */\n\tpublic function render() {\n\t\tif ($this->isAfterLastPage()) {\n\t\t\t$this->invokeFinishers();\n\t\t\treturn $this->response->getContent();\n\t\t}\n\n\t\t$this->formState->setLastDisplayedPageIndex($this->currentPage->getIndex());\n\n\t\tif ($this->formDefinition->getRendererClassName() === NULL) {\n\t\t\tthrow new \\TYPO3\\Form\\Exception\\RenderingException(sprintf('The form definition \"%s\" does not have a rendererClassName set.', $this->formDefinition->getIdentifier()), 1326095912);\n\t\t}\n\t\t$rendererClassName = $this->formDefinition->getRendererClassName();\n\t\t$renderer = new $rendererClassName();\n\t\tif (!($renderer instanceof \\TYPO3\\Form\\Core\\Renderer\\RendererInterface)) {\n\t\t\tthrow new \\TYPO3\\Form\\Exception\\RenderingException(sprintf('The renderer \"%s\" des not implement RendererInterface', $rendererClassName), 1326096024);\n\t\t}\n\n\t\t$controllerContext = $this->getControllerContext();\n\t\t$renderer->setControllerContext($controllerContext);\n\n\t\t$renderer->setFormRuntime($this);\n\t\treturn $renderer->renderRenderable($this);\n\t}\n\n\t/**\n\t * Executes all finishers of this form\n\t *\n\t * @return void\n\t * @internal\n\t */\n\tprotected function invokeFinishers() {\n\t\t$finisherContext = new \\TYPO3\\Form\\Core\\Model\\FinisherContext($this);\n\t\tforeach ($this->formDefinition->getFinishers() as $finisher) {\n\t\t\t$finisher->execute($finisherContext);\n\t\t\tif ($finisherContext->isCancelled()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return string The identifier of underlying form\n\t * @api\n\t */\n\tpublic function getIdentifier() {\n\t\treturn $this->formDefinition->getIdentifier();\n\t}\n\n\t/**\n\t * Get the request this object is bound to.\n\t *\n\t * This is mostly relevant inside Finishers, where you f.e. want to redirect\n\t * the user to another page.\n\t *\n\t * @return \\TYPO3\\Flow\\Mvc\\ActionRequest the request this object is bound to\n\t * @api\n\t */\n\tpublic function getRequest() {\n\t\treturn $this->request;\n\t}\n\n\t/**\n\t * Get the response this object is bound to.\n\t *\n\t * This is mostly relevant inside Finishers, where you f.e. want to set response\n\t * headers or output content.\n\t *\n\t * @return \\TYPO3\\Flow\\Http\\Response the response this object is bound to\n\t * @api\n\t */\n\tpublic function getResponse() {\n\t\treturn $this->response;\n\t}\n\n\t/**\n\t * Returns the currently selected page\n\t *\n\t * @return \\TYPO3\\Form\\Core\\Model\\Page\n\t * @api\n\t */\n\tpublic function getCurrentPage() {\n\t\treturn $this->currentPage;\n\t}\n\n\t/**\n\t * Returns the previous page of the currently selected one or NULL if there is no previous page\n\t *\n\t * @return \\TYPO3\\Form\\Core\\Model\\Page\n\t * @api\n\t */\n\tpublic function getPreviousPage() {\n\t\t$previousPageIndex = $this->currentPage->getIndex() - 1;\n\t\tif ($this->formDefinition->hasPageWithIndex($previousPageIndex)) {\n\t\t\treturn $this->formDefinition->getPageByIndex($previousPageIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the next page of the currently selected one or NULL if there is no next page\n\t *\n\t * @return \\TYPO3\\Form\\Core\\Model\\Page\n\t * @api\n\t */\n\tpublic function getNextPage() {\n\t\t$nextPageIndex = $this->currentPage->getIndex() + 1;\n\t\tif ($this->formDefinition->hasPageWithIndex($nextPageIndex)) {\n\t\t\treturn $this->formDefinition->getPageByIndex($nextPageIndex);\n\t\t}\n\t}\n\n\t/**\n\t * @return \\TYPO3\\Flow\\Mvc\\Controller\\ControllerContext\n\t * @internal\n\t */\n\tprotected function getControllerContext() {\n\t\t$uriBuilder = new \\TYPO3\\Flow\\Mvc\\Routing\\UriBuilder();\n\t\t$uriBuilder->setRequest($this->request);\n\n\t\treturn new \\TYPO3\\Flow\\Mvc\\Controller\\ControllerContext(\n\t\t\t$this->request,\n\t\t\t$this->response,\n\t\t\tnew \\TYPO3\\Flow\\Mvc\\Controller\\Arguments(array()),\n\t\t\t$uriBuilder,\n\t\t\t$this->flashMessageContainer\n\t\t);\n\t}\n\n\t/**\n\t * Abstract \"type\" of this Renderable. Is used during the rendering process\n\t * to determine the template file or the View PHP class being used to render\n\t * the particular element.\n\t *\n\t * @return string\n\t * @api\n\t */\n\tpublic function getType() {\n\t\treturn $this->formDefinition->getType();\n\t}\n\n\t/**\n\t * @param string $identifier\n\t * @return mixed\n\t * @api\n\t */\n\tpublic function offsetExists($identifier) {\n\t\treturn ($this->getElementValue($identifier) !== NULL);\n\t}\n\n\t/**\n\t * Returns the value of the specified element\n\t *\n\t * @param string $identifier\n\t * @return mixed\n\t * @api\n\t */\n\tprotected function getElementValue($identifier) {\n\t\t$formValue = $this->formState->getFormValue($identifier);\n\t\tif ($formValue !== NULL) {\n\t\t\treturn $formValue;\n\t\t}\n\t\treturn $this->formDefinition->getElementDefaultValueByIdentifier($identifier);\n\t}\n\n\t/**\n\t * @param string $identifier\n\t * @return mixed\n\t * @api\n\t */\n\tpublic function offsetGet($identifier) {\n\t\treturn $this->getElementValue($identifier);\n\t}\n\n\t/**\n\t * @param string $identifier\n\t * @param mixed $value\n\t * @return void\n\t * @api\n\t */\n\tpublic function offsetSet($identifier, $value) {\n\t\t$this->formState->setFormValue($identifier, $value);\n\t}\n\n\t/**\n\t * @api\n\t * @param string $identifier\n\t * @return void\n\t */\n\tpublic function offsetUnset($identifier) {\n\t\t$this->formState->setFormValue($identifier, NULL);\n\t}\n\n\t/**\n\t * @return array<TYPO3\\Form\\Core\\Model\\Page> The Form's pages in the correct order\n\t * @api\n\t */\n\tpublic function getPages() {\n\t\treturn $this->formDefinition->getPages();\n\t}\n\n\t/**\n\t * @return \\TYPO3\\Form\\Core\\Runtime\\FormState\n\t * @internal\n\t */\n\tpublic function getFormState() {\n\t\treturn $this->formState;\n\t}\n\n\t/**\n\t * Get all rendering options\n\t *\n\t * @return array associative array of rendering options\n\t * @api\n\t */\n\tpublic function getRenderingOptions() {\n\t\treturn $this->formDefinition->getRenderingOptions();\n\t}\n\n\t/**\n\t * Get the renderer class name to be used to display this renderable;\n\t * must implement RendererInterface\n\t *\n\t * @return string the renderer class name\n\t * @api\n\t */\n\tpublic function getRendererClassName() {\n\t\treturn $this->formDefinition->getRendererClassName();\n\t}\n\n\t/**\n\t * Get the label which shall be displayed next to the form element\n\t *\n\t * @return string\n\t * @api\n\t */\n\tpublic function getLabel() {\n\t\treturn $this->formDefinition->getLabel();\n\t}\n\n\t/**\n\t * This is a callback that is invoked by the Renderer before the corresponding element is rendered.\n\t * Use this to access previously submitted values and/or modify the $formRuntime before an element\n\t * is outputted to the browser.\n\t *\n\t * @param \\TYPO3\\Form\\Core\\Runtime\\FormRuntime $formRuntime\n\t * @return void\n\t * @api\n\t */\n\tpublic function beforeRendering(\\TYPO3\\Form\\Core\\Runtime\\FormRuntime $formRuntime) {\n\t}\n}\n", "<?php\nnamespace TYPO3\\Form\\Tests\\Functional;\n\n/*                                                                        *\n * This script belongs to the TYPO3 Flow package \"TYPO3.Form\".            *\n *                                                                        *\n * It is free software; you can redistribute it and/or modify it under    *\n * the terms of the GNU Lesser General Public License, either version 3   *\n * of the License, or (at your option) any later version.                 *\n *                                                                        *\n * The TYPO3 project - inspiring people to share!                         *\n *                                                                        */\nuse Symfony\\Component\\DomCrawler\\Field\\InputFormField;\n\n/**\n * Testcase for Simple Form\n *\n * @group large\n */\nclass SimpleFormTest extends AbstractFunctionalTestCase {\n\t/**\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfFirstPage() {\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text1-1']->setValue('My Text on the first page');\n\n\t\t$this->gotoNextFormPage($form);\n\n\t\t$this->gotoPreviousFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('My Text on the first page', $form['--three-page-form-with-validation']['text1-1']->getValue());\n\t}\n\n\t/**\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfSecondPage() {\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('My Text on the second page');\n\t\t$this->gotoPreviousFormPage($form);\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('My Text on the second page', $form['--three-page-form-with-validation']['text2-1']->getValue());\n\t}\n\n\t/**\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfSecondPageAndTriggersValidationOnlyWhenGoingForward() {\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('My Text on the second page');\n\t\t$this->gotoPreviousFormPage($form);\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$this->assertSame(' error', $this->browser->getCrawler()->filterXPath('//*[contains(@class,\"error\")]//input[@id=\"three-page-form-with-validation-text2-1\"]')->attr('class'));\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('42');\n\t\t$this->gotoNextFormPage($form);\n\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('', $form['--three-page-form-with-validation']['text3-1']->getValue());\n\t}\n\n\n\t/**\n\t * This is an edge-case which occurs if somebody makes the formState persistent, which can happen when subclassing the FormRuntime.\n\t *\n\t * The goal is to build a GET request *only* containing the form state, and nothing else. Furthermore, we need to make sure\n\t * that we do NOT send any of the parameters with the form; as we only want the form state to be applied.\n\t *\n\t * So, if the form state contains some values, we want to be sure these values are re-displayed.\n\t *\n\t * @test\n\t */\n\tpublic function goingForthAndBackStoresFormValuesOfSecondPageEvenWhenSecondPageIsManuallyCalledAsGetRequest() {\n\t\t// 1. TEST SETUP: FORM STATE PREPARATION\n\t\t// - go to the 2nd page of the form, and fill in text2-1.\n\t\t$this->browser->request('http://localhost/test/form/simpleform/ThreePageFormWithValidation');\n\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t$form = $this->browser->getForm();\n\t\t$form['--three-page-form-with-validation']['text2-1']->setValue('My Text on the second page');\n\n\t\t// - then, go back and forth, in order to get an *up-to-date* form state having the right values inside.\n\t\t$this->gotoPreviousFormPage($form);\n\t\t$this->gotoNextFormPage($this->browser->getForm());\n\n\t\t// 2. TEST SETUP: BUILD GET REQUEST ONLY CONTAINING FORM STATE\n\t\t$form = $this->browser->getForm();\n\t\t\\TYPO3\\Flow\\Reflection\\ObjectAccess::setProperty($form, 'method', 'GET', TRUE);\n\n\t\t// we want to stay on the current page, that's why we send __currentPage = 1. (== 2nd page of the form)\n\t\t$doc = new \\DOMDocument();\n\t\t$doc->loadXML('<input type=\"hidden\" name=\"--three-page-form-with-validation[__currentPage]\" value=\"1\" />');\n\t\t$node = $doc->getElementsByTagName('input')->item(0);\n\t\t$form->set(new InputFormField($node));\n\n\t\t// We do *not* send any form content with us, as we want to test these are properly reconstituted from the form state.\n\t\t$form->offsetUnset('--three-page-form-with-validation[text2-1]');\n\n\t\t// 3. TEST RUN\n\t\t// submit the GET request ONLY containing formState.\n\t\t$this->browser->submit($form);\n\n\t\t// now, make sure the text2-1 (which has been persisted in the form state) gets reconstituted and shown properly.\n\t\t$form = $this->browser->getForm();\n\t\t$this->assertSame('My Text on the second page', $form['--three-page-form-with-validation']['text2-1']->getValue());\n\t}\n\n}\n"], "filenames": ["Classes/TYPO3/Form/Core/Runtime/FormRuntime.php", "Tests/Functional/SimpleFormTest.php"], "buggy_code_start_loc": [149, 67], "buggy_code_end_loc": [150, 77], "fixing_code_start_loc": [149, 67], "fixing_code_end_loc": [150, 125], "type": "CWE-20", "message": "neos/forms is an open source framework to build web forms. By crafting a special `GET` request containing a valid form state, a form can be submitted without invoking any validators. Form state is secured with an HMAC that is still verified. That means that this issue can only be exploited if Form Finishers cause side effects even if no form values have been sent. Form Finishers can be adjusted in a way that they only execute an action if the submitted form contains some expected data. Alternatively a custom Finisher can be added as first finisher. This regression was introduced with https://github.com/neos/form/commit/049d415295be8d4a0478ccba97dba1bb81649567", "other": {"cve": {"id": "CVE-2021-32697", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-21T19:15:08.073", "lastModified": "2021-06-29T14:53:56.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "neos/forms is an open source framework to build web forms. By crafting a special `GET` request containing a valid form state, a form can be submitted without invoking any validators. Form state is secured with an HMAC that is still verified. That means that this issue can only be exploited if Form Finishers cause side effects even if no form values have been sent. Form Finishers can be adjusted in a way that they only execute an action if the submitted form contains some expected data. Alternatively a custom Finisher can be added as first finisher. This regression was introduced with https://github.com/neos/form/commit/049d415295be8d4a0478ccba97dba1bb81649567"}, {"lang": "es", "value": "neos/forms es un framework de c\u00f3digo abierto para construir formularios web. Al dise\u00f1ar una petici\u00f3n especial \"GET\" que contenga un estado de formulario v\u00e1lido, un formulario puede ser enviado sin invocar ning\u00fan validador. El estado del formulario est\u00e1 asegurado con un HMAC que sigue siendo comprobado. Esto significa que este problema s\u00f3lo puede ser explotado si los Form Finishers causan efectos secundarios incluso si no se han enviado valores de formulario. Los finalizadores de formularios pueden ajustarse de manera que s\u00f3lo ejecuten una acci\u00f3n si el formulario enviado contiene algunos datos esperados. Alternativamente se puede a\u00f1adir un finalizador personalizado como primer finalizador. Esta regresi\u00f3n se introdujo con https://github.com/neos/form/commit/049d415295be8d4a0478ccba97dba1bb81649567"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neos:form:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.2.0", "versionEndExcluding": "4.3.3", "matchCriteriaId": "B2F4EB15-C82B-4C52-89D3-8230FE945E74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neos:form:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.9", "matchCriteriaId": "11B52CB3-C5EC-4D14-B7EF-D19137425459"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neos:form:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.1.0", "versionEndExcluding": "5.1.3", "matchCriteriaId": "73FD3D5A-F8E8-4241-BB47-785226A371D8"}]}]}], "references": [{"url": "https://github.com/neos/form-ghsa-m5vx-8chx-qvmm/pull/1", "source": "security-advisories@github.com", "tags": ["Broken Link"]}, {"url": "https://github.com/neos/form/commit/049d415295be8d4a0478ccba97dba1bb81649567", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/neos/form/commit/69de4219b1f58157e2be6b05811463875d75c246", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/neos/form/releases/tag/5.1.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/neos/form/security/advisories/GHSA-m5vx-8chx-qvmm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neos/form/commit/049d415295be8d4a0478ccba97dba1bb81649567"}}