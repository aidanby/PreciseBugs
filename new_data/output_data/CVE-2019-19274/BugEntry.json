{"buggy_code": ["/*\n * This file includes functions to transform a concrete syntax tree (CST) to\n * an abstract syntax tree (AST). The main function is PyAST_FromNode().\n *\n */\n#include \"Python.h\"\n#include \"Python-ast.h\"\n#include \"node.h\"\n#include \"ast.h\"\n#include \"token.h\"\n#include \"pythonrun.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n\n#define MAXLEVEL 200    /* Max parentheses level */\n\nstatic int validate_stmts(asdl_seq *);\nstatic int validate_exprs(asdl_seq *, expr_context_ty, int);\nstatic int validate_nonempty_seq(asdl_seq *, const char *, const char *);\nstatic int validate_stmt(stmt_ty);\nstatic int validate_expr(expr_ty, expr_context_ty);\n\nstatic int\nvalidate_comprehension(asdl_seq *gens)\n{\n    Py_ssize_t i;\n    if (!asdl_seq_LEN(gens)) {\n        PyErr_SetString(PyExc_ValueError, \"comprehension with no generators\");\n        return 0;\n    }\n    for (i = 0; i < asdl_seq_LEN(gens); i++) {\n        comprehension_ty comp = asdl_seq_GET(gens, i);\n        if (!validate_expr(comp->target, Store) ||\n            !validate_expr(comp->iter, Load) ||\n            !validate_exprs(comp->ifs, Load, 0))\n            return 0;\n    }\n    return 1;\n}\n\nstatic int\nvalidate_slice(slice_ty slice)\n{\n    switch (slice->kind) {\n    case Slice_kind:\n        return (!slice->v.Slice.lower || validate_expr(slice->v.Slice.lower, Load)) &&\n            (!slice->v.Slice.upper || validate_expr(slice->v.Slice.upper, Load)) &&\n            (!slice->v.Slice.step || validate_expr(slice->v.Slice.step, Load));\n    case ExtSlice_kind: {\n        Py_ssize_t i;\n        if (!validate_nonempty_seq(slice->v.ExtSlice.dims, \"dims\", \"ExtSlice\"))\n            return 0;\n        for (i = 0; i < asdl_seq_LEN(slice->v.ExtSlice.dims); i++)\n            if (!validate_slice(asdl_seq_GET(slice->v.ExtSlice.dims, i)))\n                return 0;\n        return 1;\n    }\n    case Index_kind:\n        return validate_expr(slice->v.Index.value, Load);\n    default:\n        PyErr_SetString(PyExc_SystemError, \"unknown slice node\");\n        return 0;\n    }\n}\n\nstatic int\nvalidate_keywords(asdl_seq *keywords)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(keywords); i++)\n        if (!validate_expr(((keyword_ty)asdl_seq_GET(keywords, i))->value, Load))\n            return 0;\n    return 1;\n}\n\nstatic int\nvalidate_args(asdl_seq *args)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(args); i++) {\n        arg_ty arg = asdl_seq_GET(args, i);\n        if (arg->annotation && !validate_expr(arg->annotation, Load))\n            return 0;\n    }\n    return 1;\n}\n\nstatic const char *\nexpr_context_name(expr_context_ty ctx)\n{\n    switch (ctx) {\n    case Load:\n        return \"Load\";\n    case Store:\n        return \"Store\";\n    case Del:\n        return \"Del\";\n    case AugLoad:\n        return \"AugLoad\";\n    case AugStore:\n        return \"AugStore\";\n    case Param:\n        return \"Param\";\n    default:\n        Py_UNREACHABLE();\n    }\n}\n\nstatic int\nvalidate_arguments(arguments_ty args)\n{\n    if (!validate_args(args->args))\n        return 0;\n    if (args->vararg && args->vararg->annotation\n        && !validate_expr(args->vararg->annotation, Load)) {\n            return 0;\n    }\n    if (!validate_args(args->kwonlyargs))\n        return 0;\n    if (args->kwarg && args->kwarg->annotation\n        && !validate_expr(args->kwarg->annotation, Load)) {\n            return 0;\n    }\n    if (asdl_seq_LEN(args->defaults) > asdl_seq_LEN(args->args)) {\n        PyErr_SetString(PyExc_ValueError, \"more positional defaults than args on arguments\");\n        return 0;\n    }\n    if (asdl_seq_LEN(args->kw_defaults) != asdl_seq_LEN(args->kwonlyargs)) {\n        PyErr_SetString(PyExc_ValueError, \"length of kwonlyargs is not the same as \"\n                        \"kw_defaults on arguments\");\n        return 0;\n    }\n    return validate_exprs(args->defaults, Load, 0) && validate_exprs(args->kw_defaults, Load, 1);\n}\n\nstatic int\nvalidate_constant(PyObject *value)\n{\n    if (value == Py_None || value == Py_Ellipsis)\n        return 1;\n\n    if (PyLong_CheckExact(value)\n            || PyFloat_CheckExact(value)\n            || PyComplex_CheckExact(value)\n            || PyBool_Check(value)\n            || PyUnicode_CheckExact(value)\n            || PyBytes_CheckExact(value))\n        return 1;\n\n    if (PyTuple_CheckExact(value) || PyFrozenSet_CheckExact(value)) {\n        PyObject *it;\n\n        it = PyObject_GetIter(value);\n        if (it == NULL)\n            return 0;\n\n        while (1) {\n            PyObject *item = PyIter_Next(it);\n            if (item == NULL) {\n                if (PyErr_Occurred()) {\n                    Py_DECREF(it);\n                    return 0;\n                }\n                break;\n            }\n\n            if (!validate_constant(item)) {\n                Py_DECREF(it);\n                Py_DECREF(item);\n                return 0;\n            }\n            Py_DECREF(item);\n        }\n\n        Py_DECREF(it);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int\nvalidate_expr(expr_ty exp, expr_context_ty ctx)\n{\n    int check_ctx = 1;\n    expr_context_ty actual_ctx;\n\n    /* First check expression context. */\n    switch (exp->kind) {\n    case Attribute_kind:\n        actual_ctx = exp->v.Attribute.ctx;\n        break;\n    case Subscript_kind:\n        actual_ctx = exp->v.Subscript.ctx;\n        break;\n    case Starred_kind:\n        actual_ctx = exp->v.Starred.ctx;\n        break;\n    case Name_kind:\n        actual_ctx = exp->v.Name.ctx;\n        break;\n    case List_kind:\n        actual_ctx = exp->v.List.ctx;\n        break;\n    case Tuple_kind:\n        actual_ctx = exp->v.Tuple.ctx;\n        break;\n    default:\n        if (ctx != Load) {\n            PyErr_Format(PyExc_ValueError, \"expression which can't be \"\n                         \"assigned to in %s context\", expr_context_name(ctx));\n            return 0;\n        }\n        check_ctx = 0;\n        /* set actual_ctx to prevent gcc warning */\n        actual_ctx = 0;\n    }\n    if (check_ctx && actual_ctx != ctx) {\n        PyErr_Format(PyExc_ValueError, \"expression must have %s context but has %s instead\",\n                     expr_context_name(ctx), expr_context_name(actual_ctx));\n        return 0;\n    }\n\n    /* Now validate expression. */\n    switch (exp->kind) {\n    case BoolOp_kind:\n        if (asdl_seq_LEN(exp->v.BoolOp.values) < 2) {\n            PyErr_SetString(PyExc_ValueError, \"BoolOp with less than 2 values\");\n            return 0;\n        }\n        return validate_exprs(exp->v.BoolOp.values, Load, 0);\n    case BinOp_kind:\n        return validate_expr(exp->v.BinOp.left, Load) &&\n            validate_expr(exp->v.BinOp.right, Load);\n    case UnaryOp_kind:\n        return validate_expr(exp->v.UnaryOp.operand, Load);\n    case Lambda_kind:\n        return validate_arguments(exp->v.Lambda.args) &&\n            validate_expr(exp->v.Lambda.body, Load);\n    case IfExp_kind:\n        return validate_expr(exp->v.IfExp.test, Load) &&\n            validate_expr(exp->v.IfExp.body, Load) &&\n            validate_expr(exp->v.IfExp.orelse, Load);\n    case Dict_kind:\n        if (asdl_seq_LEN(exp->v.Dict.keys) != asdl_seq_LEN(exp->v.Dict.values)) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Dict doesn't have the same number of keys as values\");\n            return 0;\n        }\n        /* null_ok=1 for keys expressions to allow dict unpacking to work in\n           dict literals, i.e. ``{**{a:b}}`` */\n        return validate_exprs(exp->v.Dict.keys, Load, /*null_ok=*/ 1) &&\n            validate_exprs(exp->v.Dict.values, Load, /*null_ok=*/ 0);\n    case Set_kind:\n        return validate_exprs(exp->v.Set.elts, Load, 0);\n#define COMP(NAME) \\\n        case NAME ## _kind: \\\n            return validate_comprehension(exp->v.NAME.generators) && \\\n                validate_expr(exp->v.NAME.elt, Load);\n    COMP(ListComp)\n    COMP(SetComp)\n    COMP(GeneratorExp)\n#undef COMP\n    case DictComp_kind:\n        return validate_comprehension(exp->v.DictComp.generators) &&\n            validate_expr(exp->v.DictComp.key, Load) &&\n            validate_expr(exp->v.DictComp.value, Load);\n    case Yield_kind:\n        return !exp->v.Yield.value || validate_expr(exp->v.Yield.value, Load);\n    case YieldFrom_kind:\n        return validate_expr(exp->v.YieldFrom.value, Load);\n    case Await_kind:\n        return validate_expr(exp->v.Await.value, Load);\n    case Compare_kind:\n        if (!asdl_seq_LEN(exp->v.Compare.comparators)) {\n            PyErr_SetString(PyExc_ValueError, \"Compare with no comparators\");\n            return 0;\n        }\n        if (asdl_seq_LEN(exp->v.Compare.comparators) !=\n            asdl_seq_LEN(exp->v.Compare.ops)) {\n            PyErr_SetString(PyExc_ValueError, \"Compare has a different number \"\n                            \"of comparators and operands\");\n            return 0;\n        }\n        return validate_exprs(exp->v.Compare.comparators, Load, 0) &&\n            validate_expr(exp->v.Compare.left, Load);\n    case Call_kind:\n        return validate_expr(exp->v.Call.func, Load) &&\n            validate_exprs(exp->v.Call.args, Load, 0) &&\n            validate_keywords(exp->v.Call.keywords);\n    case Constant_kind:\n        if (!validate_constant(exp->v.Constant.value)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"got an invalid type in Constant: %s\",\n                         Py_TYPE(exp->v.Constant.value)->tp_name);\n            return 0;\n        }\n        return 1;\n    case JoinedStr_kind:\n        return validate_exprs(exp->v.JoinedStr.values, Load, 0);\n    case FormattedValue_kind:\n        if (validate_expr(exp->v.FormattedValue.value, Load) == 0)\n            return 0;\n        if (exp->v.FormattedValue.format_spec)\n            return validate_expr(exp->v.FormattedValue.format_spec, Load);\n        return 1;\n    case Attribute_kind:\n        return validate_expr(exp->v.Attribute.value, Load);\n    case Subscript_kind:\n        return validate_slice(exp->v.Subscript.slice) &&\n            validate_expr(exp->v.Subscript.value, Load);\n    case Starred_kind:\n        return validate_expr(exp->v.Starred.value, ctx);\n    case List_kind:\n        return validate_exprs(exp->v.List.elts, ctx, 0);\n    case Tuple_kind:\n        return validate_exprs(exp->v.Tuple.elts, ctx, 0);\n    case NamedExpr_kind:\n        return validate_expr(exp->v.NamedExpr.value, Load);\n    /* This last case doesn't have any checking. */\n    case Name_kind:\n        return 1;\n    }\n    PyErr_SetString(PyExc_SystemError, \"unexpected expression\");\n    return 0;\n}\n\nstatic int\nvalidate_nonempty_seq(asdl_seq *seq, const char *what, const char *owner)\n{\n    if (asdl_seq_LEN(seq))\n        return 1;\n    PyErr_Format(PyExc_ValueError, \"empty %s on %s\", what, owner);\n    return 0;\n}\n\nstatic int\nvalidate_assignlist(asdl_seq *targets, expr_context_ty ctx)\n{\n    return validate_nonempty_seq(targets, \"targets\", ctx == Del ? \"Delete\" : \"Assign\") &&\n        validate_exprs(targets, ctx, 0);\n}\n\nstatic int\nvalidate_body(asdl_seq *body, const char *owner)\n{\n    return validate_nonempty_seq(body, \"body\", owner) && validate_stmts(body);\n}\n\nstatic int\nvalidate_stmt(stmt_ty stmt)\n{\n    Py_ssize_t i;\n    switch (stmt->kind) {\n    case FunctionDef_kind:\n        return validate_body(stmt->v.FunctionDef.body, \"FunctionDef\") &&\n            validate_arguments(stmt->v.FunctionDef.args) &&\n            validate_exprs(stmt->v.FunctionDef.decorator_list, Load, 0) &&\n            (!stmt->v.FunctionDef.returns ||\n             validate_expr(stmt->v.FunctionDef.returns, Load));\n    case ClassDef_kind:\n        return validate_body(stmt->v.ClassDef.body, \"ClassDef\") &&\n            validate_exprs(stmt->v.ClassDef.bases, Load, 0) &&\n            validate_keywords(stmt->v.ClassDef.keywords) &&\n            validate_exprs(stmt->v.ClassDef.decorator_list, Load, 0);\n    case Return_kind:\n        return !stmt->v.Return.value || validate_expr(stmt->v.Return.value, Load);\n    case Delete_kind:\n        return validate_assignlist(stmt->v.Delete.targets, Del);\n    case Assign_kind:\n        return validate_assignlist(stmt->v.Assign.targets, Store) &&\n            validate_expr(stmt->v.Assign.value, Load);\n    case AugAssign_kind:\n        return validate_expr(stmt->v.AugAssign.target, Store) &&\n            validate_expr(stmt->v.AugAssign.value, Load);\n    case AnnAssign_kind:\n        if (stmt->v.AnnAssign.target->kind != Name_kind &&\n            stmt->v.AnnAssign.simple) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"AnnAssign with simple non-Name target\");\n            return 0;\n        }\n        return validate_expr(stmt->v.AnnAssign.target, Store) &&\n               (!stmt->v.AnnAssign.value ||\n                validate_expr(stmt->v.AnnAssign.value, Load)) &&\n               validate_expr(stmt->v.AnnAssign.annotation, Load);\n    case For_kind:\n        return validate_expr(stmt->v.For.target, Store) &&\n            validate_expr(stmt->v.For.iter, Load) &&\n            validate_body(stmt->v.For.body, \"For\") &&\n            validate_stmts(stmt->v.For.orelse);\n    case AsyncFor_kind:\n        return validate_expr(stmt->v.AsyncFor.target, Store) &&\n            validate_expr(stmt->v.AsyncFor.iter, Load) &&\n            validate_body(stmt->v.AsyncFor.body, \"AsyncFor\") &&\n            validate_stmts(stmt->v.AsyncFor.orelse);\n    case While_kind:\n        return validate_expr(stmt->v.While.test, Load) &&\n            validate_body(stmt->v.While.body, \"While\") &&\n            validate_stmts(stmt->v.While.orelse);\n    case If_kind:\n        return validate_expr(stmt->v.If.test, Load) &&\n            validate_body(stmt->v.If.body, \"If\") &&\n            validate_stmts(stmt->v.If.orelse);\n    case With_kind:\n        if (!validate_nonempty_seq(stmt->v.With.items, \"items\", \"With\"))\n            return 0;\n        for (i = 0; i < asdl_seq_LEN(stmt->v.With.items); i++) {\n            withitem_ty item = asdl_seq_GET(stmt->v.With.items, i);\n            if (!validate_expr(item->context_expr, Load) ||\n                (item->optional_vars && !validate_expr(item->optional_vars, Store)))\n                return 0;\n        }\n        return validate_body(stmt->v.With.body, \"With\");\n    case AsyncWith_kind:\n        if (!validate_nonempty_seq(stmt->v.AsyncWith.items, \"items\", \"AsyncWith\"))\n            return 0;\n        for (i = 0; i < asdl_seq_LEN(stmt->v.AsyncWith.items); i++) {\n            withitem_ty item = asdl_seq_GET(stmt->v.AsyncWith.items, i);\n            if (!validate_expr(item->context_expr, Load) ||\n                (item->optional_vars && !validate_expr(item->optional_vars, Store)))\n                return 0;\n        }\n        return validate_body(stmt->v.AsyncWith.body, \"AsyncWith\");\n    case Raise_kind:\n        if (stmt->v.Raise.exc) {\n            return validate_expr(stmt->v.Raise.exc, Load) &&\n                (!stmt->v.Raise.cause || validate_expr(stmt->v.Raise.cause, Load));\n        }\n        if (stmt->v.Raise.cause) {\n            PyErr_SetString(PyExc_ValueError, \"Raise with cause but no exception\");\n            return 0;\n        }\n        return 1;\n    case Try_kind:\n        if (!validate_body(stmt->v.Try.body, \"Try\"))\n            return 0;\n        if (!asdl_seq_LEN(stmt->v.Try.handlers) &&\n            !asdl_seq_LEN(stmt->v.Try.finalbody)) {\n            PyErr_SetString(PyExc_ValueError, \"Try has neither except handlers nor finalbody\");\n            return 0;\n        }\n        if (!asdl_seq_LEN(stmt->v.Try.handlers) &&\n            asdl_seq_LEN(stmt->v.Try.orelse)) {\n            PyErr_SetString(PyExc_ValueError, \"Try has orelse but no except handlers\");\n            return 0;\n        }\n        for (i = 0; i < asdl_seq_LEN(stmt->v.Try.handlers); i++) {\n            excepthandler_ty handler = asdl_seq_GET(stmt->v.Try.handlers, i);\n            if ((handler->v.ExceptHandler.type &&\n                 !validate_expr(handler->v.ExceptHandler.type, Load)) ||\n                !validate_body(handler->v.ExceptHandler.body, \"ExceptHandler\"))\n                return 0;\n        }\n        return (!asdl_seq_LEN(stmt->v.Try.finalbody) ||\n                validate_stmts(stmt->v.Try.finalbody)) &&\n            (!asdl_seq_LEN(stmt->v.Try.orelse) ||\n             validate_stmts(stmt->v.Try.orelse));\n    case Assert_kind:\n        return validate_expr(stmt->v.Assert.test, Load) &&\n            (!stmt->v.Assert.msg || validate_expr(stmt->v.Assert.msg, Load));\n    case Import_kind:\n        return validate_nonempty_seq(stmt->v.Import.names, \"names\", \"Import\");\n    case ImportFrom_kind:\n        if (stmt->v.ImportFrom.level < 0) {\n            PyErr_SetString(PyExc_ValueError, \"Negative ImportFrom level\");\n            return 0;\n        }\n        return validate_nonempty_seq(stmt->v.ImportFrom.names, \"names\", \"ImportFrom\");\n    case Global_kind:\n        return validate_nonempty_seq(stmt->v.Global.names, \"names\", \"Global\");\n    case Nonlocal_kind:\n        return validate_nonempty_seq(stmt->v.Nonlocal.names, \"names\", \"Nonlocal\");\n    case Expr_kind:\n        return validate_expr(stmt->v.Expr.value, Load);\n    case AsyncFunctionDef_kind:\n        return validate_body(stmt->v.AsyncFunctionDef.body, \"AsyncFunctionDef\") &&\n            validate_arguments(stmt->v.AsyncFunctionDef.args) &&\n            validate_exprs(stmt->v.AsyncFunctionDef.decorator_list, Load, 0) &&\n            (!stmt->v.AsyncFunctionDef.returns ||\n             validate_expr(stmt->v.AsyncFunctionDef.returns, Load));\n    case Pass_kind:\n    case Break_kind:\n    case Continue_kind:\n        return 1;\n    default:\n        PyErr_SetString(PyExc_SystemError, \"unexpected statement\");\n        return 0;\n    }\n}\n\nstatic int\nvalidate_stmts(asdl_seq *seq)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(seq); i++) {\n        stmt_ty stmt = asdl_seq_GET(seq, i);\n        if (stmt) {\n            if (!validate_stmt(stmt))\n                return 0;\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError,\n                            \"None disallowed in statement list\");\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int\nvalidate_exprs(asdl_seq *exprs, expr_context_ty ctx, int null_ok)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(exprs); i++) {\n        expr_ty expr = asdl_seq_GET(exprs, i);\n        if (expr) {\n            if (!validate_expr(expr, ctx))\n                return 0;\n        }\n        else if (!null_ok) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"None disallowed in expression list\");\n            return 0;\n        }\n\n    }\n    return 1;\n}\n\nint\nPyAST_Validate(mod_ty mod)\n{\n    int res = 0;\n\n    switch (mod->kind) {\n    case Module_kind:\n        res = validate_stmts(mod->v.Module.body);\n        break;\n    case Interactive_kind:\n        res = validate_stmts(mod->v.Interactive.body);\n        break;\n    case Expression_kind:\n        res = validate_expr(mod->v.Expression.body, Load);\n        break;\n    case Suite_kind:\n        PyErr_SetString(PyExc_ValueError, \"Suite is not valid in the CPython compiler\");\n        break;\n    default:\n        PyErr_SetString(PyExc_SystemError, \"impossible module node\");\n        res = 0;\n        break;\n    }\n    return res;\n}\n\n/* This is done here, so defines like \"test\" don't interfere with AST use above. */\n#include \"grammar.h\"\n#include \"parsetok.h\"\n#include \"graminit.h\"\n\n/* Data structure used internally */\nstruct compiling {\n    PyArena *c_arena; /* Arena for allocating memory. */\n    PyObject *c_filename; /* filename */\n    PyObject *c_normalize; /* Normalization function from unicodedata. */\n    int c_feature_version; /* Latest minor version of Python for allowed features */\n};\n\nstatic asdl_seq *seq_for_testlist(struct compiling *, const node *);\nstatic expr_ty ast_for_expr(struct compiling *, const node *);\nstatic stmt_ty ast_for_stmt(struct compiling *, const node *);\nstatic asdl_seq *ast_for_suite(struct compiling *c, const node *n);\nstatic asdl_seq *ast_for_exprlist(struct compiling *, const node *,\n                                  expr_context_ty);\nstatic expr_ty ast_for_testlist(struct compiling *, const node *);\nstatic stmt_ty ast_for_classdef(struct compiling *, const node *, asdl_seq *);\n\nstatic stmt_ty ast_for_with_stmt(struct compiling *, const node *, bool);\nstatic stmt_ty ast_for_for_stmt(struct compiling *, const node *, bool);\n\n/* Note different signature for ast_for_call */\nstatic expr_ty ast_for_call(struct compiling *, const node *, expr_ty,\n                            const node *, const node *);\n\nstatic PyObject *parsenumber(struct compiling *, const char *);\nstatic expr_ty parsestrplus(struct compiling *, const node *n);\nstatic void get_last_end_pos(asdl_seq *, int *, int *);\n\n#define COMP_GENEXP   0\n#define COMP_LISTCOMP 1\n#define COMP_SETCOMP  2\n\nstatic int\ninit_normalization(struct compiling *c)\n{\n    PyObject *m = PyImport_ImportModuleNoBlock(\"unicodedata\");\n    if (!m)\n        return 0;\n    c->c_normalize = PyObject_GetAttrString(m, \"normalize\");\n    Py_DECREF(m);\n    if (!c->c_normalize)\n        return 0;\n    return 1;\n}\n\nstatic identifier\nnew_identifier(const char *n, struct compiling *c)\n{\n    PyObject *id = PyUnicode_DecodeUTF8(n, strlen(n), NULL);\n    if (!id)\n        return NULL;\n    /* PyUnicode_DecodeUTF8 should always return a ready string. */\n    assert(PyUnicode_IS_READY(id));\n    /* Check whether there are non-ASCII characters in the\n       identifier; if so, normalize to NFKC. */\n    if (!PyUnicode_IS_ASCII(id)) {\n        PyObject *id2;\n        _Py_IDENTIFIER(NFKC);\n        if (!c->c_normalize && !init_normalization(c)) {\n            Py_DECREF(id);\n            return NULL;\n        }\n        PyObject *form = _PyUnicode_FromId(&PyId_NFKC);\n        if (form == NULL) {\n            Py_DECREF(id);\n            return NULL;\n        }\n        PyObject *args[2] = {form, id};\n        id2 = _PyObject_FastCall(c->c_normalize, args, 2);\n        Py_DECREF(id);\n        if (!id2)\n            return NULL;\n        if (!PyUnicode_Check(id2)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"unicodedata.normalize() must return a string, not \"\n                         \"%.200s\",\n                         Py_TYPE(id2)->tp_name);\n            Py_DECREF(id2);\n            return NULL;\n        }\n        id = id2;\n    }\n    PyUnicode_InternInPlace(&id);\n    if (PyArena_AddPyObject(c->c_arena, id) < 0) {\n        Py_DECREF(id);\n        return NULL;\n    }\n    return id;\n}\n\n#define NEW_IDENTIFIER(n) new_identifier(STR(n), c)\n\nstatic int\nast_error(struct compiling *c, const node *n, const char *errmsg, ...)\n{\n    PyObject *value, *errstr, *loc, *tmp;\n    va_list va;\n\n    va_start(va, errmsg);\n    errstr = PyUnicode_FromFormatV(errmsg, va);\n    va_end(va);\n    if (!errstr) {\n        return 0;\n    }\n    loc = PyErr_ProgramTextObject(c->c_filename, LINENO(n));\n    if (!loc) {\n        Py_INCREF(Py_None);\n        loc = Py_None;\n    }\n    tmp = Py_BuildValue(\"(OiiN)\", c->c_filename, LINENO(n), n->n_col_offset + 1, loc);\n    if (!tmp) {\n        Py_DECREF(errstr);\n        return 0;\n    }\n    value = PyTuple_Pack(2, errstr, tmp);\n    Py_DECREF(errstr);\n    Py_DECREF(tmp);\n    if (value) {\n        PyErr_SetObject(PyExc_SyntaxError, value);\n        Py_DECREF(value);\n    }\n    return 0;\n}\n\n/* num_stmts() returns number of contained statements.\n\n   Use this routine to determine how big a sequence is needed for\n   the statements in a parse tree.  Its raison d'etre is this bit of\n   grammar:\n\n   stmt: simple_stmt | compound_stmt\n   simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\n\n   A simple_stmt can contain multiple small_stmt elements joined\n   by semicolons.  If the arg is a simple_stmt, the number of\n   small_stmt elements is returned.\n*/\n\nstatic string\nnew_type_comment(const char *s, struct compiling *c)\n{\n    PyObject *res = PyUnicode_DecodeUTF8(s, strlen(s), NULL);\n    if (res == NULL)\n        return NULL;\n    if (PyArena_AddPyObject(c->c_arena, res) < 0) {\n        Py_DECREF(res);\n        return NULL;\n    }\n    return res;\n}\n#define NEW_TYPE_COMMENT(n) new_type_comment(STR(n), c)\n\nstatic int\nnum_stmts(const node *n)\n{\n    int i, l;\n    node *ch;\n\n    switch (TYPE(n)) {\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE)\n                return 0;\n            else\n                return num_stmts(CHILD(n, 0));\n        case file_input:\n            l = 0;\n            for (i = 0; i < NCH(n); i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == stmt)\n                    l += num_stmts(ch);\n            }\n            return l;\n        case stmt:\n            return num_stmts(CHILD(n, 0));\n        case compound_stmt:\n            return 1;\n        case simple_stmt:\n            return NCH(n) / 2; /* Divide by 2 to remove count of semi-colons */\n        case suite:\n        case func_body_suite:\n            /* func_body_suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */\n            /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n            if (NCH(n) == 1)\n                return num_stmts(CHILD(n, 0));\n            else {\n                i = 2;\n                l = 0;\n                if (TYPE(CHILD(n, 1)) == TYPE_COMMENT)\n                    i += 2;\n                for (; i < (NCH(n) - 1); i++)\n                    l += num_stmts(CHILD(n, i));\n                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    Py_UNREACHABLE();\n}\n\n/* Transform the CST rooted at node * to the appropriate AST\n*/\n\nmod_ty\nPyAST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                     PyObject *filename, PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n    node *ch;\n    struct compiling c;\n    mod_ty res = NULL;\n    asdl_seq *argtypes = NULL;\n    expr_ty ret, arg;\n\n    c.c_arena = arena;\n    /* borrowed reference */\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_feature_version = flags->cf_feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n    k = 0;\n    switch (TYPE(n)) {\n        case file_input:\n            stmts = _Py_asdl_seq_new(num_stmts(n), arena);\n            if (!stmts)\n                goto out;\n            for (i = 0; i < NCH(n) - 1; i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == NEWLINE)\n                    continue;\n                REQ(ch, stmt);\n                num = num_stmts(ch);\n                if (num == 1) {\n                    s = ast_for_stmt(&c, ch);\n                    if (!s)\n                        goto out;\n                    asdl_seq_SET(stmts, k++, s);\n                }\n                else {\n                    ch = CHILD(ch, 0);\n                    REQ(ch, simple_stmt);\n                    for (j = 0; j < num; j++) {\n                        s = ast_for_stmt(&c, CHILD(ch, j * 2));\n                        if (!s)\n                            goto out;\n                        asdl_seq_SET(stmts, k++, s);\n                    }\n                }\n            }\n\n            /* Type ignores are stored under the ENDMARKER in file_input. */\n            ch = CHILD(n, NCH(n) - 1);\n            REQ(ch, ENDMARKER);\n            num = NCH(ch);\n            type_ignores = _Py_asdl_seq_new(num, arena);\n            if (!type_ignores)\n                goto out;\n\n            for (i = 0; i < num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                   goto out;\n               asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n            expr_ty testlist_ast;\n\n            /* XXX Why not comp_for here? */\n            testlist_ast = ast_for_testlist(&c, CHILD(n, 0));\n            if (!testlist_ast)\n                goto out;\n            res = Expression(testlist_ast, arena);\n            break;\n        }\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE) {\n                stmts = _Py_asdl_seq_new(1, arena);\n                if (!stmts)\n                    goto out;\n                asdl_seq_SET(stmts, 0, Pass(n->n_lineno, n->n_col_offset,\n                                            n->n_end_lineno, n->n_end_col_offset,\n                                            arena));\n                if (!asdl_seq_GET(stmts, 0))\n                    goto out;\n                res = Interactive(stmts, arena);\n            }\n            else {\n                n = CHILD(n, 0);\n                num = num_stmts(n);\n                stmts = _Py_asdl_seq_new(num, arena);\n                if (!stmts)\n                    goto out;\n                if (num == 1) {\n                    s = ast_for_stmt(&c, n);\n                    if (!s)\n                        goto out;\n                    asdl_seq_SET(stmts, 0, s);\n                }\n                else {\n                    /* Only a simple_stmt can contain multiple statements. */\n                    REQ(n, simple_stmt);\n                    for (i = 0; i < NCH(n); i += 2) {\n                        if (TYPE(CHILD(n, i)) == NEWLINE)\n                            break;\n                        s = ast_for_stmt(&c, CHILD(n, i));\n                        if (!s)\n                            goto out;\n                        asdl_seq_SET(stmts, i / 2, s);\n                    }\n                }\n\n                res = Interactive(stmts, arena);\n            }\n            break;\n        case func_type_input:\n            n = CHILD(n, 0);\n            REQ(n, func_type);\n\n            if (TYPE(CHILD(n, 1)) == typelist) {\n                ch = CHILD(n, 1);\n                /* this is overly permissive -- we don't pay any attention to\n                 * stars on the args -- just parse them into an ordered list */\n                num = 0;\n                for (i = 0; i < NCH(ch); i++) {\n                    if (TYPE(CHILD(ch, i)) == test) {\n                        num++;\n                    }\n                }\n\n                argtypes = _Py_asdl_seq_new(num, arena);\n                if (!argtypes)\n                    goto out;\n\n                j = 0;\n                for (i = 0; i < NCH(ch); i++) {\n                    if (TYPE(CHILD(ch, i)) == test) {\n                        arg = ast_for_expr(&c, CHILD(ch, i));\n                        if (!arg)\n                            goto out;\n                        asdl_seq_SET(argtypes, j++, arg);\n                    }\n                }\n            }\n            else {\n                argtypes = _Py_asdl_seq_new(0, arena);\n                if (!argtypes)\n                    goto out;\n            }\n\n            ret = ast_for_expr(&c, CHILD(n, NCH(n) - 1));\n            if (!ret)\n                goto out;\n            res = FunctionType(argtypes, ret, arena);\n            break;\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid node %d for PyAST_FromNode\", TYPE(n));\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n    }\n    return res;\n}\n\nmod_ty\nPyAST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n               PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)\n        return NULL;\n    mod = PyAST_FromNodeObject(n, flags, filename, arena);\n    Py_DECREF(filename);\n    return mod;\n\n}\n\n/* Return the AST repr. of the operator represented as syntax (|, ^, etc.)\n*/\n\nstatic operator_ty\nget_operator(struct compiling *c, const node *n)\n{\n    switch (TYPE(n)) {\n        case VBAR:\n            return BitOr;\n        case CIRCUMFLEX:\n            return BitXor;\n        case AMPER:\n            return BitAnd;\n        case LEFTSHIFT:\n            return LShift;\n        case RIGHTSHIFT:\n            return RShift;\n        case PLUS:\n            return Add;\n        case MINUS:\n            return Sub;\n        case STAR:\n            return Mult;\n        case AT:\n            if (c->c_feature_version < 5) {\n                ast_error(c, n,\n                          \"The '@' operator is only supported in Python 3.5 and greater\");\n                return (operator_ty)0;\n            }\n            return MatMult;\n        case SLASH:\n            return Div;\n        case DOUBLESLASH:\n            return FloorDiv;\n        case PERCENT:\n            return Mod;\n        default:\n            return (operator_ty)0;\n    }\n}\n\nstatic const char * const FORBIDDEN[] = {\n    \"None\",\n    \"True\",\n    \"False\",\n    \"__debug__\",\n    NULL,\n};\n\nstatic int\nforbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    const char * const *p = FORBIDDEN;\n    if (!full_checks) {\n        /* In most cases, the parser will protect True, False, and None\n           from being assign to. */\n        p += 3;\n    }\n    for (; *p; p++) {\n        if (_PyUnicode_EqualToASCIIString(name, *p)) {\n            ast_error(c, n, \"cannot assign to %U\", name);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic expr_ty\ncopy_location(expr_ty e, const node *n)\n{\n    if (e) {\n        e->lineno = LINENO(n);\n        e->col_offset = n->n_col_offset;\n        e->end_lineno = n->n_end_lineno;\n        e->end_col_offset = n->n_end_col_offset;\n    }\n    return e;\n}\n\nstatic const char *\nget_expr_name(expr_ty e)\n{\n    switch (e->kind) {\n        case Attribute_kind:\n            return \"attribute\";\n        case Subscript_kind:\n            return \"subscript\";\n        case Starred_kind:\n            return \"starred\";\n        case Name_kind:\n            return \"name\";\n        case List_kind:\n            return \"list\";\n        case Tuple_kind:\n            return \"tuple\";\n        case Lambda_kind:\n            return \"lambda\";\n        case Call_kind:\n            return \"function call\";\n        case BoolOp_kind:\n        case BinOp_kind:\n        case UnaryOp_kind:\n            return \"operator\";\n        case GeneratorExp_kind:\n            return \"generator expression\";\n        case Yield_kind:\n        case YieldFrom_kind:\n            return \"yield expression\";\n        case Await_kind:\n            return \"await expression\";\n        case ListComp_kind:\n            return \"list comprehension\";\n        case SetComp_kind:\n            return \"set comprehension\";\n        case DictComp_kind:\n            return \"dict comprehension\";\n        case Dict_kind:\n            return \"dict display\";\n        case Set_kind:\n            return \"set display\";\n        case JoinedStr_kind:\n        case FormattedValue_kind:\n            return \"f-string expression\";\n        case Constant_kind: {\n            PyObject *value = e->v.Constant.value;\n            if (value == Py_None) {\n                return \"None\";\n            }\n            if (value == Py_False) {\n                return \"False\";\n            }\n            if (value == Py_True) {\n                return \"True\";\n            }\n            if (value == Py_Ellipsis) {\n                return \"Ellipsis\";\n            }\n            return \"literal\";\n        }\n        case Compare_kind:\n            return \"comparison\";\n        case IfExp_kind:\n            return \"conditional expression\";\n        case NamedExpr_kind:\n            return \"named expression\";\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"unexpected expression in assignment %d (line %d)\",\n                         e->kind, e->lineno);\n            return NULL;\n    }\n}\n\n/* Set the context ctx for expr_ty e, recursively traversing e.\n\n   Only sets context for expr kinds that \"can appear in assignment context\"\n   (according to ../Parser/Python.asdl).  For other expr kinds, it sets\n   an appropriate syntax error and returns false.\n*/\n\nstatic int\nset_context(struct compiling *c, expr_ty e, expr_context_ty ctx, const node *n)\n{\n    asdl_seq *s = NULL;\n\n    /* The ast defines augmented store and load contexts, but the\n       implementation here doesn't actually use them.  The code may be\n       a little more complex than necessary as a result.  It also means\n       that expressions in an augmented assignment have a Store context.\n       Consider restructuring so that augmented assignment uses\n       set_context(), too.\n    */\n    assert(ctx != AugStore && ctx != AugLoad);\n\n    switch (e->kind) {\n        case Attribute_kind:\n            e->v.Attribute.ctx = ctx;\n            if (ctx == Store && forbidden_name(c, e->v.Attribute.attr, n, 1))\n                return 0;\n            break;\n        case Subscript_kind:\n            e->v.Subscript.ctx = ctx;\n            break;\n        case Starred_kind:\n            e->v.Starred.ctx = ctx;\n            if (!set_context(c, e->v.Starred.value, ctx, n))\n                return 0;\n            break;\n        case Name_kind:\n            if (ctx == Store) {\n                if (forbidden_name(c, e->v.Name.id, n, 0))\n                    return 0; /* forbidden_name() calls ast_error() */\n            }\n            e->v.Name.ctx = ctx;\n            break;\n        case List_kind:\n            e->v.List.ctx = ctx;\n            s = e->v.List.elts;\n            break;\n        case Tuple_kind:\n            e->v.Tuple.ctx = ctx;\n            s = e->v.Tuple.elts;\n            break;\n        default: {\n            const char *expr_name = get_expr_name(e);\n            if (expr_name != NULL) {\n                ast_error(c, n, \"cannot %s %s\",\n                          ctx == Store ? \"assign to\" : \"delete\",\n                          expr_name);\n            }\n            return 0;\n        }\n    }\n\n    /* If the LHS is a list or tuple, we need to set the assignment\n       context for all the contained elements.\n    */\n    if (s) {\n        Py_ssize_t i;\n\n        for (i = 0; i < asdl_seq_LEN(s); i++) {\n            if (!set_context(c, (expr_ty)asdl_seq_GET(s, i), ctx, n))\n                return 0;\n        }\n    }\n    return 1;\n}\n\nstatic operator_ty\nast_for_augassign(struct compiling *c, const node *n)\n{\n    REQ(n, augassign);\n    n = CHILD(n, 0);\n    switch (STR(n)[0]) {\n        case '+':\n            return Add;\n        case '-':\n            return Sub;\n        case '/':\n            if (STR(n)[1] == '/')\n                return FloorDiv;\n            else\n                return Div;\n        case '%':\n            return Mod;\n        case '<':\n            return LShift;\n        case '>':\n            return RShift;\n        case '&':\n            return BitAnd;\n        case '^':\n            return BitXor;\n        case '|':\n            return BitOr;\n        case '*':\n            if (STR(n)[1] == '*')\n                return Pow;\n            else\n                return Mult;\n        case '@':\n            if (c->c_feature_version < 5) {\n                ast_error(c, n,\n                          \"The '@' operator is only supported in Python 3.5 and greater\");\n                return (operator_ty)0;\n            }\n            return MatMult;\n        default:\n            PyErr_Format(PyExc_SystemError, \"invalid augassign: %s\", STR(n));\n            return (operator_ty)0;\n    }\n}\n\nstatic cmpop_ty\nast_for_comp_op(struct compiling *c, const node *n)\n{\n    /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'\n               |'is' 'not'\n    */\n    REQ(n, comp_op);\n    if (NCH(n) == 1) {\n        n = CHILD(n, 0);\n        switch (TYPE(n)) {\n            case LESS:\n                return Lt;\n            case GREATER:\n                return Gt;\n            case EQEQUAL:                       /* == */\n                return Eq;\n            case LESSEQUAL:\n                return LtE;\n            case GREATEREQUAL:\n                return GtE;\n            case NOTEQUAL:\n                return NotEq;\n            case NAME:\n                if (strcmp(STR(n), \"in\") == 0)\n                    return In;\n                if (strcmp(STR(n), \"is\") == 0)\n                    return Is;\n                /* fall through */\n            default:\n                PyErr_Format(PyExc_SystemError, \"invalid comp_op: %s\",\n                             STR(n));\n                return (cmpop_ty)0;\n        }\n    }\n    else if (NCH(n) == 2) {\n        /* handle \"not in\" and \"is not\" */\n        switch (TYPE(CHILD(n, 0))) {\n            case NAME:\n                if (strcmp(STR(CHILD(n, 1)), \"in\") == 0)\n                    return NotIn;\n                if (strcmp(STR(CHILD(n, 0)), \"is\") == 0)\n                    return IsNot;\n                /* fall through */\n            default:\n                PyErr_Format(PyExc_SystemError, \"invalid comp_op: %s %s\",\n                             STR(CHILD(n, 0)), STR(CHILD(n, 1)));\n                return (cmpop_ty)0;\n        }\n    }\n    PyErr_Format(PyExc_SystemError, \"invalid comp_op: has %d children\",\n                 NCH(n));\n    return (cmpop_ty)0;\n}\n\nstatic asdl_seq *\nseq_for_testlist(struct compiling *c, const node *n)\n{\n    /* testlist: test (',' test)* [',']\n       testlist_star_expr: test|star_expr (',' test|star_expr)* [',']\n    */\n    asdl_seq *seq;\n    expr_ty expression;\n    int i;\n    assert(TYPE(n) == testlist || TYPE(n) == testlist_star_expr || TYPE(n) == testlist_comp);\n\n    seq = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n    if (!seq)\n        return NULL;\n\n    for (i = 0; i < NCH(n); i += 2) {\n        const node *ch = CHILD(n, i);\n        assert(TYPE(ch) == test || TYPE(ch) == test_nocond || TYPE(ch) == star_expr || TYPE(ch) == namedexpr_test);\n\n        expression = ast_for_expr(c, ch);\n        if (!expression)\n            return NULL;\n\n        assert(i / 2 < seq->size);\n        asdl_seq_SET(seq, i / 2, expression);\n    }\n    return seq;\n}\n\nstatic arg_ty\nast_for_arg(struct compiling *c, const node *n)\n{\n    identifier name;\n    expr_ty annotation = NULL;\n    node *ch;\n    arg_ty ret;\n\n    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);\n    ch = CHILD(n, 0);\n    name = NEW_IDENTIFIER(ch);\n    if (!name)\n        return NULL;\n    if (forbidden_name(c, name, ch, 0))\n        return NULL;\n\n    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {\n        annotation = ast_for_expr(c, CHILD(n, 2));\n        if (!annotation)\n            return NULL;\n    }\n\n    ret = arg(name, annotation, NULL, LINENO(n), n->n_col_offset,\n              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    if (!ret)\n        return NULL;\n    return ret;\n}\n\n/* returns -1 if failed to handle keyword only arguments\n   returns new position to keep processing if successful\n               (',' tfpdef ['=' test])*\n                     ^^^\n   start pointing here\n */\nstatic int\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; /* '=' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME ':' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}\n\n/* Create AST for argument list. */\n\nstatic arguments_ty\nast_for_arguments(struct compiling *c, const node *n)\n{\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) /* () as argument list */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    /* First count the number of positional args & defaults.  The\n       variable i is the loop index for this for loop and the next.\n       The next loop picks up where the first leaves off.\n    */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            /* skip star */\n            i++;\n            if (i < NCH(n) && /* skip argument following star */\n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    /* count the number of keyword only args &\n       defaults for keyword only args */\n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Py_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Py_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Py_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    /* The length of kwonlyargs and kwdefaults are same\n       since we set NULL as default for keyword only argument w/o default\n       - we have sequence data structure, but no dictionary */\n    kwdefaults = (nkwonlyargs ?\n                   _Py_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                              \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                              \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; /* now follows keyword only arguments */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                  \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; /* res has new position to process */\n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                i += 2; /* the star and the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; /* res has new position to process */\n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}\n\nstatic expr_ty\nast_for_dotted_name(struct compiling *c, const node *n)\n{\n    expr_ty e;\n    identifier id;\n    int lineno, col_offset;\n    int i;\n    node *ch;\n\n    REQ(n, dotted_name);\n\n    lineno = LINENO(n);\n    col_offset = n->n_col_offset;\n\n    ch = CHILD(n, 0);\n    id = NEW_IDENTIFIER(ch);\n    if (!id)\n        return NULL;\n    e = Name(id, Load, lineno, col_offset,\n             ch->n_end_lineno, ch->n_end_col_offset, c->c_arena);\n    if (!e)\n        return NULL;\n\n    for (i = 2; i < NCH(n); i+=2) {\n        id = NEW_IDENTIFIER(CHILD(n, i));\n        if (!id)\n            return NULL;\n        e = Attribute(e, id, Load, lineno, col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        if (!e)\n            return NULL;\n    }\n\n    return e;\n}\n\nstatic expr_ty\nast_for_decorator(struct compiling *c, const node *n)\n{\n    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\n    expr_ty d = NULL;\n    expr_ty name_expr;\n\n    REQ(n, decorator);\n    REQ(CHILD(n, 0), AT);\n    REQ(RCHILD(n, -1), NEWLINE);\n\n    name_expr = ast_for_dotted_name(c, CHILD(n, 1));\n    if (!name_expr)\n        return NULL;\n\n    if (NCH(n) == 3) { /* No arguments */\n        d = name_expr;\n        name_expr = NULL;\n    }\n    else if (NCH(n) == 5) { /* Call with no arguments */\n        d = Call(name_expr, NULL, NULL, LINENO(n),\n                 n->n_col_offset, n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        if (!d)\n            return NULL;\n        name_expr = NULL;\n    }\n    else {\n        d = ast_for_call(c, CHILD(n, 3), name_expr, CHILD(n, 2), CHILD(n, 4));\n        if (!d)\n            return NULL;\n        name_expr = NULL;\n    }\n\n    return d;\n}\n\nstatic asdl_seq*\nast_for_decorators(struct compiling *c, const node *n)\n{\n    asdl_seq* decorator_seq;\n    expr_ty d;\n    int i;\n\n    REQ(n, decorators);\n    decorator_seq = _Py_asdl_seq_new(NCH(n), c->c_arena);\n    if (!decorator_seq)\n        return NULL;\n\n    for (i = 0; i < NCH(n); i++) {\n        d = ast_for_decorator(c, CHILD(n, i));\n        if (!d)\n            return NULL;\n        asdl_seq_SET(decorator_seq, i, d);\n    }\n    return decorator_seq;\n}\n\nstatic stmt_ty\nast_for_funcdef_impl(struct compiling *c, const node *n0,\n                     asdl_seq *decorator_seq, bool is_async)\n{\n    /* funcdef: 'def' NAME parameters ['->' test] ':' [TYPE_COMMENT] suite */\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    identifier name;\n    arguments_ty args;\n    asdl_seq *body;\n    expr_ty returns = NULL;\n    int name_i = 1;\n    int end_lineno, end_col_offset;\n    node *tc;\n    string type_comment = NULL;\n\n    if (is_async && c->c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async functions are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    REQ(n, funcdef);\n\n    name = NEW_IDENTIFIER(CHILD(n, name_i));\n    if (!name)\n        return NULL;\n    if (forbidden_name(c, name, CHILD(n, name_i), 0))\n        return NULL;\n    args = ast_for_arguments(c, CHILD(n, name_i + 1));\n    if (!args)\n        return NULL;\n    if (TYPE(CHILD(n, name_i+2)) == RARROW) {\n        returns = ast_for_expr(c, CHILD(n, name_i + 3));\n        if (!returns)\n            return NULL;\n        name_i += 2;\n    }\n    if (TYPE(CHILD(n, name_i + 3)) == TYPE_COMMENT) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, name_i + 3));\n        if (!type_comment)\n            return NULL;\n        name_i += 1;\n    }\n    body = ast_for_suite(c, CHILD(n, name_i + 3));\n    if (!body)\n        return NULL;\n    get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (NCH(CHILD(n, name_i + 3)) > 1) {\n        /* Check if the suite has a type comment in it. */\n        tc = CHILD(CHILD(n, name_i + 3), 1);\n\n        if (TYPE(tc) == TYPE_COMMENT) {\n            if (type_comment != NULL) {\n                ast_error(c, n, \"Cannot have two type comments on def\");\n                return NULL;\n            }\n            type_comment = NEW_TYPE_COMMENT(tc);\n            if (!type_comment)\n                return NULL;\n        }\n    }\n\n    if (is_async)\n        return AsyncFunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                                LINENO(n0), n0->n_col_offset, end_lineno, end_col_offset, c->c_arena);\n    else\n        return FunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                           LINENO(n), n->n_col_offset, end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: ASYNC funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), ASYNC);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}\n\nstatic stmt_ty\nast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* funcdef: 'def' NAME parameters ['->' test] ':' suite */\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                false /* is_async */);\n}\n\n\nstatic stmt_ty\nast_for_async_stmt(struct compiling *c, const node *n)\n{\n    /* async_stmt: ASYNC (funcdef | with_stmt | for_stmt) */\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), ASYNC);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, n, NULL,\n                                        true /* is_async */);\n        case with_stmt:\n            return ast_for_with_stmt(c, n,\n                                     true /* is_async */);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, n,\n                                    true /* is_async */);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}\n\nstatic stmt_ty\nast_for_decorated(struct compiling *c, const node *n)\n{\n    /* decorated: decorators (classdef | funcdef | async_funcdef) */\n    stmt_ty thing = NULL;\n    asdl_seq *decorator_seq = NULL;\n\n    REQ(n, decorated);\n\n    decorator_seq = ast_for_decorators(c, CHILD(n, 0));\n    if (!decorator_seq)\n      return NULL;\n\n    assert(TYPE(CHILD(n, 1)) == funcdef ||\n           TYPE(CHILD(n, 1)) == async_funcdef ||\n           TYPE(CHILD(n, 1)) == classdef);\n\n    if (TYPE(CHILD(n, 1)) == funcdef) {\n      thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == classdef) {\n      thing = ast_for_classdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == async_funcdef) {\n      thing = ast_for_async_funcdef(c, CHILD(n, 1), decorator_seq);\n    }\n    return thing;\n}\n\nstatic expr_ty\nast_for_namedexpr(struct compiling *c, const node *n)\n{\n    /* if_stmt: 'if' namedexpr_test ':' suite ('elif' namedexpr_test ':' suite)*\n         ['else' ':' suite]\n       namedexpr_test: test [':=' test]\n       argument: ( test [comp_for] |\n            test ':=' test |\n            test '=' test |\n            '**' test |\n            '*' test )\n    */\n    expr_ty target, value;\n\n    target = ast_for_expr(c, CHILD(n, 0));\n    if (!target)\n        return NULL;\n\n    value = ast_for_expr(c, CHILD(n, 2));\n    if (!value)\n        return NULL;\n\n    if (target->kind != Name_kind) {\n        const char *expr_name = get_expr_name(target);\n        if (expr_name != NULL) {\n            ast_error(c, n, \"cannot use named assignment with %s\", expr_name);\n        }\n        return NULL;\n    }\n\n    if (!set_context(c, target, Store, n))\n        return NULL;\n\n    return NamedExpr(target, value, LINENO(n), n->n_col_offset, n->n_end_lineno,\n                     n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_lambdef(struct compiling *c, const node *n)\n{\n    /* lambdef: 'lambda' [varargslist] ':' test\n       lambdef_nocond: 'lambda' [varargslist] ':' test_nocond */\n    arguments_ty args;\n    expr_ty expression;\n\n    if (NCH(n) == 3) {\n        args = arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        if (!args)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(n, 2));\n        if (!expression)\n            return NULL;\n    }\n    else {\n        args = ast_for_arguments(c, CHILD(n, 1));\n        if (!args)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(n, 3));\n        if (!expression)\n            return NULL;\n    }\n\n    return Lambda(args, expression, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_ifexpr(struct compiling *c, const node *n)\n{\n    /* test: or_test 'if' or_test 'else' test */\n    expr_ty expression, body, orelse;\n\n    assert(NCH(n) == 5);\n    body = ast_for_expr(c, CHILD(n, 0));\n    if (!body)\n        return NULL;\n    expression = ast_for_expr(c, CHILD(n, 2));\n    if (!expression)\n        return NULL;\n    orelse = ast_for_expr(c, CHILD(n, 4));\n    if (!orelse)\n        return NULL;\n    return IfExp(expression, body, orelse, LINENO(n), n->n_col_offset,\n                 n->n_end_lineno, n->n_end_col_offset,\n                 c->c_arena);\n}\n\n/*\n   Count the number of 'for' loops in a comprehension.\n\n   Helper for ast_for_comprehension().\n*/\n\nstatic int\ncount_comp_fors(struct compiling *c, const node *n)\n{\n    int n_fors = 0;\n\n  count_comp_for:\n    n_fors++;\n    REQ(n, comp_for);\n    if (NCH(n) == 2) {\n        REQ(CHILD(n, 0), ASYNC);\n        n = CHILD(n, 1);\n    }\n    else if (NCH(n) == 1) {\n        n = CHILD(n, 0);\n    }\n    else {\n        goto error;\n    }\n    if (NCH(n) == (5)) {\n        n = CHILD(n, 4);\n    }\n    else {\n        return n_fors;\n    }\n  count_comp_iter:\n    REQ(n, comp_iter);\n    n = CHILD(n, 0);\n    if (TYPE(n) == comp_for)\n        goto count_comp_for;\n    else if (TYPE(n) == comp_if) {\n        if (NCH(n) == 3) {\n            n = CHILD(n, 2);\n            goto count_comp_iter;\n        }\n        else\n            return n_fors;\n    }\n\n  error:\n    /* Should never be reached */\n    PyErr_SetString(PyExc_SystemError,\n                    \"logic error in count_comp_fors\");\n    return -1;\n}\n\n/* Count the number of 'if' statements in a comprehension.\n\n   Helper for ast_for_comprehension().\n*/\n\nstatic int\ncount_comp_ifs(struct compiling *c, const node *n)\n{\n    int n_ifs = 0;\n\n    while (1) {\n        REQ(n, comp_iter);\n        if (TYPE(CHILD(n, 0)) == comp_for)\n            return n_ifs;\n        n = CHILD(n, 0);\n        REQ(n, comp_if);\n        n_ifs++;\n        if (NCH(n) == 2)\n            return n_ifs;\n        n = CHILD(n, 2);\n    }\n}\n\nstatic asdl_seq *\nast_for_comprehension(struct compiling *c, const node *n)\n{\n    int i, n_fors;\n    asdl_seq *comps;\n\n    n_fors = count_comp_fors(c, n);\n    if (n_fors == -1)\n        return NULL;\n\n    comps = _Py_asdl_seq_new(n_fors, c->c_arena);\n    if (!comps)\n        return NULL;\n\n    for (i = 0; i < n_fors; i++) {\n        comprehension_ty comp;\n        asdl_seq *t;\n        expr_ty expression, first;\n        node *for_ch;\n        node *sync_n;\n        int is_async = 0;\n\n        REQ(n, comp_for);\n\n        if (NCH(n) == 2) {\n            is_async = 1;\n            REQ(CHILD(n, 0), ASYNC);\n            sync_n = CHILD(n, 1);\n        }\n        else {\n            sync_n = CHILD(n, 0);\n        }\n        REQ(sync_n, sync_comp_for);\n\n        /* Async comprehensions only allowed in Python 3.6 and greater */\n        if (is_async && c->c_feature_version < 6) {\n            ast_error(c, n,\n                      \"Async comprehensions are only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n\n        for_ch = CHILD(sync_n, 1);\n        t = ast_for_exprlist(c, for_ch, Store);\n        if (!t)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(sync_n, 3));\n        if (!expression)\n            return NULL;\n\n        /* Check the # of children rather than the length of t, since\n           (x for x, in ...) has 1 element in t, but still requires a Tuple. */\n        first = (expr_ty)asdl_seq_GET(t, 0);\n        if (NCH(for_ch) == 1)\n            comp = comprehension(first, expression, NULL,\n                                 is_async, c->c_arena);\n        else\n            comp = comprehension(Tuple(t, Store, first->lineno, first->col_offset,\n                                       for_ch->n_end_lineno, for_ch->n_end_col_offset,\n                                       c->c_arena),\n                                 expression, NULL, is_async, c->c_arena);\n        if (!comp)\n            return NULL;\n\n        if (NCH(sync_n) == 5) {\n            int j, n_ifs;\n            asdl_seq *ifs;\n\n            n = CHILD(sync_n, 4);\n            n_ifs = count_comp_ifs(c, n);\n            if (n_ifs == -1)\n                return NULL;\n\n            ifs = _Py_asdl_seq_new(n_ifs, c->c_arena);\n            if (!ifs)\n                return NULL;\n\n            for (j = 0; j < n_ifs; j++) {\n                REQ(n, comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, comp_if);\n\n                expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression)\n                    return NULL;\n                asdl_seq_SET(ifs, j, expression);\n                if (NCH(n) == 3)\n                    n = CHILD(n, 2);\n            }\n            /* on exit, must guarantee that n is a comp_for */\n            if (TYPE(n) == comp_iter)\n                n = CHILD(n, 0);\n            comp->ifs = ifs;\n        }\n        asdl_seq_SET(comps, i, comp);\n    }\n    return comps;\n}\n\nstatic expr_ty\nast_for_itercomp(struct compiling *c, const node *n, int type)\n{\n    /* testlist_comp: (test|star_expr)\n     *                ( comp_for | (',' (test|star_expr))* [','] ) */\n    expr_ty elt;\n    asdl_seq *comps;\n    node *ch;\n\n    assert(NCH(n) > 1);\n\n    ch = CHILD(n, 0);\n    elt = ast_for_expr(c, ch);\n    if (!elt)\n        return NULL;\n    if (elt->kind == Starred_kind) {\n        ast_error(c, ch, \"iterable unpacking cannot be used in comprehension\");\n        return NULL;\n    }\n\n    comps = ast_for_comprehension(c, CHILD(n, 1));\n    if (!comps)\n        return NULL;\n\n    if (type == COMP_GENEXP)\n        return GeneratorExp(elt, comps, LINENO(n), n->n_col_offset,\n                            n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    else if (type == COMP_LISTCOMP)\n        return ListComp(elt, comps, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    else if (type == COMP_SETCOMP)\n        return SetComp(elt, comps, LINENO(n), n->n_col_offset,\n                       n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    else\n        /* Should never happen */\n        return NULL;\n}\n\n/* Fills in the key, value pair corresponding to the dict element.  In case\n * of an unpacking, key is NULL.  *i is advanced by the number of ast\n * elements.  Iff successful, nonzero is returned.\n */\nstatic int\nast_for_dictelement(struct compiling *c, const node *n, int *i,\n                    expr_ty *key, expr_ty *value)\n{\n    expr_ty expression;\n    if (TYPE(CHILD(n, *i)) == DOUBLESTAR) {\n        assert(NCH(n) - *i >= 2);\n\n        expression = ast_for_expr(c, CHILD(n, *i + 1));\n        if (!expression)\n            return 0;\n        *key = NULL;\n        *value = expression;\n\n        *i += 2;\n    }\n    else {\n        assert(NCH(n) - *i >= 3);\n\n        expression = ast_for_expr(c, CHILD(n, *i));\n        if (!expression)\n            return 0;\n        *key = expression;\n\n        REQ(CHILD(n, *i + 1), COLON);\n\n        expression = ast_for_expr(c, CHILD(n, *i + 2));\n        if (!expression)\n            return 0;\n        *value = expression;\n\n        *i += 3;\n    }\n    return 1;\n}\n\nstatic expr_ty\nast_for_dictcomp(struct compiling *c, const node *n)\n{\n    expr_ty key, value;\n    asdl_seq *comps;\n    int i = 0;\n\n    if (!ast_for_dictelement(c, n, &i, &key, &value))\n        return NULL;\n    assert(key);\n    assert(NCH(n) - i >= 1);\n\n    comps = ast_for_comprehension(c, CHILD(n, i));\n    if (!comps)\n        return NULL;\n\n    return DictComp(key, value, comps, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_dictdisplay(struct compiling *c, const node *n)\n{\n    int i;\n    int j;\n    int size;\n    asdl_seq *keys, *values;\n\n    size = (NCH(n) + 1) / 3; /* +1 in case no trailing comma */\n    keys = _Py_asdl_seq_new(size, c->c_arena);\n    if (!keys)\n        return NULL;\n\n    values = _Py_asdl_seq_new(size, c->c_arena);\n    if (!values)\n        return NULL;\n\n    j = 0;\n    for (i = 0; i < NCH(n); i++) {\n        expr_ty key, value;\n\n        if (!ast_for_dictelement(c, n, &i, &key, &value))\n            return NULL;\n        asdl_seq_SET(keys, j, key);\n        asdl_seq_SET(values, j, value);\n\n        j++;\n    }\n    keys->size = j;\n    values->size = j;\n    return Dict(keys, values, LINENO(n), n->n_col_offset,\n                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_genexp(struct compiling *c, const node *n)\n{\n    assert(TYPE(n) == (testlist_comp) || TYPE(n) == (argument));\n    return ast_for_itercomp(c, n, COMP_GENEXP);\n}\n\nstatic expr_ty\nast_for_listcomp(struct compiling *c, const node *n)\n{\n    assert(TYPE(n) == (testlist_comp));\n    return ast_for_itercomp(c, n, COMP_LISTCOMP);\n}\n\nstatic expr_ty\nast_for_setcomp(struct compiling *c, const node *n)\n{\n    assert(TYPE(n) == (dictorsetmaker));\n    return ast_for_itercomp(c, n, COMP_SETCOMP);\n}\n\nstatic expr_ty\nast_for_setdisplay(struct compiling *c, const node *n)\n{\n    int i;\n    int size;\n    asdl_seq *elts;\n\n    assert(TYPE(n) == (dictorsetmaker));\n    size = (NCH(n) + 1) / 2; /* +1 in case no trailing comma */\n    elts = _Py_asdl_seq_new(size, c->c_arena);\n    if (!elts)\n        return NULL;\n    for (i = 0; i < NCH(n); i += 2) {\n        expr_ty expression;\n        expression = ast_for_expr(c, CHILD(n, i));\n        if (!expression)\n            return NULL;\n        asdl_seq_SET(elts, i / 2, expression);\n    }\n    return Set(elts, LINENO(n), n->n_col_offset,\n               n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_atom(struct compiling *c, const node *n)\n{\n    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'\n       | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+\n       | '...' | 'None' | 'True' | 'False'\n    */\n    node *ch = CHILD(n, 0);\n\n    switch (TYPE(ch)) {\n    case NAME: {\n        PyObject *name;\n        const char *s = STR(ch);\n        size_t len = strlen(s);\n        if (len >= 4 && len <= 5) {\n            if (!strcmp(s, \"None\"))\n                return Constant(Py_None, NULL, LINENO(n), n->n_col_offset,\n                                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            if (!strcmp(s, \"True\"))\n                return Constant(Py_True, NULL, LINENO(n), n->n_col_offset,\n                                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            if (!strcmp(s, \"False\"))\n                return Constant(Py_False, NULL, LINENO(n), n->n_col_offset,\n                                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        name = new_identifier(s, c);\n        if (!name)\n            return NULL;\n        /* All names start in Load context, but may later be changed. */\n        return Name(name, Load, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    case STRING: {\n        expr_ty str = parsestrplus(c, n);\n        if (!str) {\n            const char *errtype = NULL;\n            if (PyErr_ExceptionMatches(PyExc_UnicodeError))\n                errtype = \"unicode error\";\n            else if (PyErr_ExceptionMatches(PyExc_ValueError))\n                errtype = \"value error\";\n            if (errtype) {\n                PyObject *type, *value, *tback, *errstr;\n                PyErr_Fetch(&type, &value, &tback);\n                errstr = PyObject_Str(value);\n                if (errstr) {\n                    ast_error(c, n, \"(%s) %U\", errtype, errstr);\n                    Py_DECREF(errstr);\n                }\n                else {\n                    PyErr_Clear();\n                    ast_error(c, n, \"(%s) unknown error\", errtype);\n                }\n                Py_DECREF(type);\n                Py_XDECREF(value);\n                Py_XDECREF(tback);\n            }\n            return NULL;\n        }\n        return str;\n    }\n    case NUMBER: {\n        PyObject *pynum;\n        /* Underscores in numeric literals are only allowed in Python 3.6 or greater */\n        /* Check for underscores here rather than in parse_number so we can report a line number on error */\n        if (c->c_feature_version < 6 && strchr(STR(ch), '_') != NULL) {\n            ast_error(c, ch,\n                      \"Underscores in numeric literals are only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n        pynum = parsenumber(c, STR(ch));\n        if (!pynum)\n            return NULL;\n\n        if (PyArena_AddPyObject(c->c_arena, pynum) < 0) {\n            Py_DECREF(pynum);\n            return NULL;\n        }\n        return Constant(pynum, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    case ELLIPSIS: /* Ellipsis */\n        return Constant(Py_Ellipsis, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    case LPAR: /* some parenthesized expressions */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RPAR)\n            return Tuple(NULL, Load, LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n\n        if (TYPE(ch) == yield_expr)\n            return ast_for_expr(c, ch);\n\n        /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n        if (NCH(ch) == 1) {\n            return ast_for_testlist(c, ch);\n        }\n\n        if (TYPE(CHILD(ch, 1)) == comp_for) {\n            return copy_location(ast_for_genexp(c, ch), n);\n        }\n        else {\n            return copy_location(ast_for_testlist(c, ch), n);\n        }\n    case LSQB: /* list (or list comprehension) */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RSQB)\n            return List(NULL, Load, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n\n        REQ(ch, testlist_comp);\n        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {\n            asdl_seq *elts = seq_for_testlist(c, ch);\n            if (!elts)\n                return NULL;\n\n            return List(elts, Load, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        else {\n            return copy_location(ast_for_listcomp(c, ch), n);\n        }\n    case LBRACE: {\n        /* dictorsetmaker: ( ((test ':' test | '**' test)\n         *                    (comp_for | (',' (test ':' test | '**' test))* [','])) |\n         *                   ((test | '*' test)\n         *                    (comp_for | (',' (test | '*' test))* [','])) ) */\n        expr_ty res;\n        ch = CHILD(n, 1);\n        if (TYPE(ch) == RBRACE) {\n            /* It's an empty dict. */\n            return Dict(NULL, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        else {\n            int is_dict = (TYPE(CHILD(ch, 0)) == DOUBLESTAR);\n            if (NCH(ch) == 1 ||\n                    (NCH(ch) > 1 &&\n                     TYPE(CHILD(ch, 1)) == COMMA)) {\n                /* It's a set display. */\n                res = ast_for_setdisplay(c, ch);\n            }\n            else if (NCH(ch) > 1 &&\n                    TYPE(CHILD(ch, 1)) == comp_for) {\n                /* It's a set comprehension. */\n                res = ast_for_setcomp(c, ch);\n            }\n            else if (NCH(ch) > 3 - is_dict &&\n                    TYPE(CHILD(ch, 3 - is_dict)) == comp_for) {\n                /* It's a dictionary comprehension. */\n                if (is_dict) {\n                    ast_error(c, n,\n                              \"dict unpacking cannot be used in dict comprehension\");\n                    return NULL;\n                }\n                res = ast_for_dictcomp(c, ch);\n            }\n            else {\n                /* It's a dictionary display. */\n                res = ast_for_dictdisplay(c, ch);\n            }\n            return copy_location(res, n);\n        }\n    }\n    default:\n        PyErr_Format(PyExc_SystemError, \"unhandled atom %d\", TYPE(ch));\n        return NULL;\n    }\n}\n\nstatic slice_ty\nast_for_slice(struct compiling *c, const node *n)\n{\n    node *ch;\n    expr_ty lower = NULL, upper = NULL, step = NULL;\n\n    REQ(n, subscript);\n\n    /*\n       subscript: test | [test] ':' [test] [sliceop]\n       sliceop: ':' [test]\n    */\n    ch = CHILD(n, 0);\n    if (NCH(n) == 1 && TYPE(ch) == test) {\n        /* 'step' variable hold no significance in terms of being used over\n           other vars */\n        step = ast_for_expr(c, ch);\n        if (!step)\n            return NULL;\n\n        return Index(step, c->c_arena);\n    }\n\n    if (TYPE(ch) == test) {\n        lower = ast_for_expr(c, ch);\n        if (!lower)\n            return NULL;\n    }\n\n    /* If there's an upper bound it's in the second or third position. */\n    if (TYPE(ch) == COLON) {\n        if (NCH(n) > 1) {\n            node *n2 = CHILD(n, 1);\n\n            if (TYPE(n2) == test) {\n                upper = ast_for_expr(c, n2);\n                if (!upper)\n                    return NULL;\n            }\n        }\n    } else if (NCH(n) > 2) {\n        node *n2 = CHILD(n, 2);\n\n        if (TYPE(n2) == test) {\n            upper = ast_for_expr(c, n2);\n            if (!upper)\n                return NULL;\n        }\n    }\n\n    ch = CHILD(n, NCH(n) - 1);\n    if (TYPE(ch) == sliceop) {\n        if (NCH(ch) != 1) {\n            ch = CHILD(ch, 1);\n            if (TYPE(ch) == test) {\n                step = ast_for_expr(c, ch);\n                if (!step)\n                    return NULL;\n            }\n        }\n    }\n\n    return Slice(lower, upper, step, c->c_arena);\n}\n\nstatic expr_ty\nast_for_binop(struct compiling *c, const node *n)\n{\n    /* Must account for a sequence of expressions.\n       How should A op B op C by represented?\n       BinOp(BinOp(A, op, B), op, C).\n    */\n\n    int i, nops;\n    expr_ty expr1, expr2, result;\n    operator_ty newoperator;\n\n    expr1 = ast_for_expr(c, CHILD(n, 0));\n    if (!expr1)\n        return NULL;\n\n    expr2 = ast_for_expr(c, CHILD(n, 2));\n    if (!expr2)\n        return NULL;\n\n    newoperator = get_operator(c, CHILD(n, 1));\n    if (!newoperator)\n        return NULL;\n\n    result = BinOp(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,\n                   CHILD(n, 2)->n_end_lineno, CHILD(n, 2)->n_end_col_offset,\n                   c->c_arena);\n    if (!result)\n        return NULL;\n\n    nops = (NCH(n) - 1) / 2;\n    for (i = 1; i < nops; i++) {\n        expr_ty tmp_result, tmp;\n        const node* next_oper = CHILD(n, i * 2 + 1);\n\n        newoperator = get_operator(c, next_oper);\n        if (!newoperator)\n            return NULL;\n\n        tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));\n        if (!tmp)\n            return NULL;\n\n        tmp_result = BinOp(result, newoperator, tmp,\n                           LINENO(next_oper), next_oper->n_col_offset,\n                           CHILD(n, i * 2 + 2)->n_end_lineno,\n                           CHILD(n, i * 2 + 2)->n_end_col_offset,\n                           c->c_arena);\n        if (!tmp_result)\n            return NULL;\n        result = tmp_result;\n    }\n    return result;\n}\n\nstatic expr_ty\nast_for_trailer(struct compiling *c, const node *n, expr_ty left_expr)\n{\n    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n       subscriptlist: subscript (',' subscript)* [',']\n       subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n     */\n    const node *n_copy = n;\n    REQ(n, trailer);\n    if (TYPE(CHILD(n, 0)) == LPAR) {\n        if (NCH(n) == 2)\n            return Call(left_expr, NULL, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        else\n            return ast_for_call(c, CHILD(n, 1), left_expr, CHILD(n, 0), CHILD(n, 2));\n    }\n    else if (TYPE(CHILD(n, 0)) == DOT) {\n        PyObject *attr_id = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!attr_id)\n            return NULL;\n        return Attribute(left_expr, attr_id, Load,\n                         LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else {\n        REQ(CHILD(n, 0), LSQB);\n        REQ(CHILD(n, 2), RSQB);\n        n = CHILD(n, 1);\n        if (NCH(n) == 1) {\n            slice_ty slc = ast_for_slice(c, CHILD(n, 0));\n            if (!slc)\n                return NULL;\n            return Subscript(left_expr, slc, Load, LINENO(n), n->n_col_offset,\n                             n_copy->n_end_lineno, n_copy->n_end_col_offset,\n                             c->c_arena);\n        }\n        else {\n            /* The grammar is ambiguous here. The ambiguity is resolved\n               by treating the sequence as a tuple literal if there are\n               no slice features.\n            */\n            Py_ssize_t j;\n            slice_ty slc;\n            expr_ty e;\n            int simple = 1;\n            asdl_seq *slices, *elts;\n            slices = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n            if (!slices)\n                return NULL;\n            for (j = 0; j < NCH(n); j += 2) {\n                slc = ast_for_slice(c, CHILD(n, j));\n                if (!slc)\n                    return NULL;\n                if (slc->kind != Index_kind)\n                    simple = 0;\n                asdl_seq_SET(slices, j / 2, slc);\n            }\n            if (!simple) {\n                return Subscript(left_expr, ExtSlice(slices, c->c_arena),\n                                 Load, LINENO(n), n->n_col_offset,\n                                 n_copy->n_end_lineno, n_copy->n_end_col_offset, c->c_arena);\n            }\n            /* extract Index values and put them in a Tuple */\n            elts = _Py_asdl_seq_new(asdl_seq_LEN(slices), c->c_arena);\n            if (!elts)\n                return NULL;\n            for (j = 0; j < asdl_seq_LEN(slices); ++j) {\n                slc = (slice_ty)asdl_seq_GET(slices, j);\n                assert(slc->kind == Index_kind  && slc->v.Index.value);\n                asdl_seq_SET(elts, j, slc->v.Index.value);\n            }\n            e = Tuple(elts, Load, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            if (!e)\n                return NULL;\n            return Subscript(left_expr, Index(e, c->c_arena),\n                             Load, LINENO(n), n->n_col_offset,\n                             n_copy->n_end_lineno, n_copy->n_end_col_offset, c->c_arena);\n        }\n    }\n}\n\nstatic expr_ty\nast_for_factor(struct compiling *c, const node *n)\n{\n    expr_ty expression;\n\n    expression = ast_for_expr(c, CHILD(n, 1));\n    if (!expression)\n        return NULL;\n\n    switch (TYPE(CHILD(n, 0))) {\n        case PLUS:\n            return UnaryOp(UAdd, expression, LINENO(n), n->n_col_offset,\n                           n->n_end_lineno, n->n_end_col_offset,\n                           c->c_arena);\n        case MINUS:\n            return UnaryOp(USub, expression, LINENO(n), n->n_col_offset,\n                           n->n_end_lineno, n->n_end_col_offset,\n                           c->c_arena);\n        case TILDE:\n            return UnaryOp(Invert, expression, LINENO(n), n->n_col_offset,\n                           n->n_end_lineno, n->n_end_col_offset,\n                           c->c_arena);\n    }\n    PyErr_Format(PyExc_SystemError, \"unhandled factor: %d\",\n                 TYPE(CHILD(n, 0)));\n    return NULL;\n}\n\nstatic expr_ty\nast_for_atom_expr(struct compiling *c, const node *n)\n{\n    int i, nch, start = 0;\n    expr_ty e, tmp;\n\n    REQ(n, atom_expr);\n    nch = NCH(n);\n\n    if (TYPE(CHILD(n, 0)) == AWAIT) {\n        if (c->c_feature_version < 5) {\n            ast_error(c, n,\n                      \"Await expressions are only supported in Python 3.5 and greater\");\n            return NULL;\n        }\n        start = 1;\n        assert(nch > 1);\n    }\n\n    e = ast_for_atom(c, CHILD(n, start));\n    if (!e)\n        return NULL;\n    if (nch == 1)\n        return e;\n    if (start && nch == 2) {\n        return Await(e, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n\n    for (i = start + 1; i < nch; i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) != trailer)\n            break;\n        tmp = ast_for_trailer(c, ch, e);\n        if (!tmp)\n            return NULL;\n        tmp->lineno = e->lineno;\n        tmp->col_offset = e->col_offset;\n        e = tmp;\n    }\n\n    if (start) {\n        /* there was an 'await' */\n        return Await(e, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else {\n        return e;\n    }\n}\n\nstatic expr_ty\nast_for_power(struct compiling *c, const node *n)\n{\n    /* power: atom trailer* ('**' factor)*\n     */\n    expr_ty e;\n    REQ(n, power);\n    e = ast_for_atom_expr(c, CHILD(n, 0));\n    if (!e)\n        return NULL;\n    if (NCH(n) == 1)\n        return e;\n    if (TYPE(CHILD(n, NCH(n) - 1)) == factor) {\n        expr_ty f = ast_for_expr(c, CHILD(n, NCH(n) - 1));\n        if (!f)\n            return NULL;\n        e = BinOp(e, Pow, f, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    return e;\n}\n\nstatic expr_ty\nast_for_starred(struct compiling *c, const node *n)\n{\n    expr_ty tmp;\n    REQ(n, star_expr);\n\n    tmp = ast_for_expr(c, CHILD(n, 1));\n    if (!tmp)\n        return NULL;\n\n    /* The Load context is changed later. */\n    return Starred(tmp, Load, LINENO(n), n->n_col_offset,\n                   n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\n\n/* Do not name a variable 'expr'!  Will cause a compile error.\n*/\n\nstatic expr_ty\nast_for_expr(struct compiling *c, const node *n)\n{\n    /* handle the full range of simple expressions\n       namedexpr_test: test [':=' test]\n       test: or_test ['if' or_test 'else' test] | lambdef\n       test_nocond: or_test | lambdef_nocond\n       or_test: and_test ('or' and_test)*\n       and_test: not_test ('and' not_test)*\n       not_test: 'not' not_test | comparison\n       comparison: expr (comp_op expr)*\n       expr: xor_expr ('|' xor_expr)*\n       xor_expr: and_expr ('^' and_expr)*\n       and_expr: shift_expr ('&' shift_expr)*\n       shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n       arith_expr: term (('+'|'-') term)*\n       term: factor (('*'|'@'|'/'|'%'|'//') factor)*\n       factor: ('+'|'-'|'~') factor | power\n       power: atom_expr ['**' factor]\n       atom_expr: [AWAIT] atom trailer*\n       yield_expr: 'yield' [yield_arg]\n    */\n\n    asdl_seq *seq;\n    int i;\n\n loop:\n    switch (TYPE(n)) {\n        case namedexpr_test:\n            if (NCH(n) == 3)\n                return ast_for_namedexpr(c, n);\n            /* Fallthrough */\n        case test:\n        case test_nocond:\n            if (TYPE(CHILD(n, 0)) == lambdef ||\n                TYPE(CHILD(n, 0)) == lambdef_nocond)\n                return ast_for_lambdef(c, CHILD(n, 0));\n            else if (NCH(n) > 1)\n                return ast_for_ifexpr(c, n);\n            /* Fallthrough */\n        case or_test:\n        case and_test:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            seq = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n            if (!seq)\n                return NULL;\n            for (i = 0; i < NCH(n); i += 2) {\n                expr_ty e = ast_for_expr(c, CHILD(n, i));\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(seq, i / 2, e);\n            }\n            if (!strcmp(STR(CHILD(n, 1)), \"and\"))\n                return BoolOp(And, seq, LINENO(n), n->n_col_offset,\n                              n->n_end_lineno, n->n_end_col_offset,\n                              c->c_arena);\n            assert(!strcmp(STR(CHILD(n, 1)), \"or\"));\n            return BoolOp(Or, seq, LINENO(n), n->n_col_offset,\n                          n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        case not_test:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            else {\n                expr_ty expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression)\n                    return NULL;\n\n                return UnaryOp(Not, expression, LINENO(n), n->n_col_offset,\n                               n->n_end_lineno, n->n_end_col_offset,\n                               c->c_arena);\n            }\n        case comparison:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            else {\n                expr_ty expression;\n                asdl_int_seq *ops;\n                asdl_seq *cmps;\n                ops = _Py_asdl_int_seq_new(NCH(n) / 2, c->c_arena);\n                if (!ops)\n                    return NULL;\n                cmps = _Py_asdl_seq_new(NCH(n) / 2, c->c_arena);\n                if (!cmps) {\n                    return NULL;\n                }\n                for (i = 1; i < NCH(n); i += 2) {\n                    cmpop_ty newoperator;\n\n                    newoperator = ast_for_comp_op(c, CHILD(n, i));\n                    if (!newoperator) {\n                        return NULL;\n                    }\n\n                    expression = ast_for_expr(c, CHILD(n, i + 1));\n                    if (!expression) {\n                        return NULL;\n                    }\n\n                    asdl_seq_SET(ops, i / 2, newoperator);\n                    asdl_seq_SET(cmps, i / 2, expression);\n                }\n                expression = ast_for_expr(c, CHILD(n, 0));\n                if (!expression) {\n                    return NULL;\n                }\n\n                return Compare(expression, ops, cmps, LINENO(n), n->n_col_offset,\n                               n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            }\n            break;\n\n        case star_expr:\n            return ast_for_starred(c, n);\n        /* The next five cases all handle BinOps.  The main body of code\n           is the same in each case, but the switch turned inside out to\n           reuse the code for each type of operator.\n         */\n        case expr:\n        case xor_expr:\n        case and_expr:\n        case shift_expr:\n        case arith_expr:\n        case term:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            return ast_for_binop(c, n);\n        case yield_expr: {\n            node *an = NULL;\n            node *en = NULL;\n            int is_from = 0;\n            expr_ty exp = NULL;\n            if (NCH(n) > 1)\n                an = CHILD(n, 1); /* yield_arg */\n            if (an) {\n                en = CHILD(an, NCH(an) - 1);\n                if (NCH(an) == 2) {\n                    is_from = 1;\n                    exp = ast_for_expr(c, en);\n                }\n                else\n                    exp = ast_for_testlist(c, en);\n                if (!exp)\n                    return NULL;\n            }\n            if (is_from)\n                return YieldFrom(exp, LINENO(n), n->n_col_offset,\n                                 n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            return Yield(exp, LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        case factor:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            return ast_for_factor(c, n);\n        case power:\n            return ast_for_power(c, n);\n        default:\n            PyErr_Format(PyExc_SystemError, \"unhandled expr: %d\", TYPE(n));\n            return NULL;\n    }\n    /* should never get here unless if error is set */\n    return NULL;\n}\n\nstatic expr_ty\nast_for_call(struct compiling *c, const node *n, expr_ty func,\n             const node *maybegenbeg, const node *closepar)\n{\n    /*\n      arglist: argument (',' argument)*  [',']\n      argument: ( test [comp_for] | '*' test | test '=' test | '**' test )\n    */\n\n    int i, nargs, nkeywords;\n    int ndoublestars;\n    asdl_seq *args;\n    asdl_seq *keywords;\n\n    REQ(n, arglist);\n\n    nargs = 0;\n    nkeywords = 0;\n    for (i = 0; i < NCH(n); i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) == argument) {\n            if (NCH(ch) == 1)\n                nargs++;\n            else if (TYPE(CHILD(ch, 1)) == comp_for) {\n                nargs++;\n                if (!maybegenbeg) {\n                    ast_error(c, ch, \"invalid syntax\");\n                    return NULL;\n                }\n                if (NCH(n) > 1) {\n                    ast_error(c, ch, \"Generator expression must be parenthesized\");\n                    return NULL;\n                }\n            }\n            else if (TYPE(CHILD(ch, 0)) == STAR)\n                nargs++;\n            else if (TYPE(CHILD(ch, 1)) == COLONEQUAL) {\n                nargs++;\n            }\n            else\n                /* TYPE(CHILD(ch, 0)) == DOUBLESTAR or keyword argument */\n                nkeywords++;\n        }\n    }\n\n    args = _Py_asdl_seq_new(nargs, c->c_arena);\n    if (!args)\n        return NULL;\n    keywords = _Py_asdl_seq_new(nkeywords, c->c_arena);\n    if (!keywords)\n        return NULL;\n\n    nargs = 0;  /* positional arguments + iterable argument unpackings */\n    nkeywords = 0;  /* keyword arguments + keyword argument unpackings */\n    ndoublestars = 0;  /* just keyword argument unpackings */\n    for (i = 0; i < NCH(n); i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) == argument) {\n            expr_ty e;\n            node *chch = CHILD(ch, 0);\n            if (NCH(ch) == 1) {\n                /* a positional argument */\n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument unpacking\");\n                    }\n                    else {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument\");\n                    }\n                    return NULL;\n                }\n                e = ast_for_expr(c, chch);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else if (TYPE(chch) == STAR) {\n                /* an iterable argument unpacking */\n                expr_ty starred;\n                if (ndoublestars) {\n                    ast_error(c, chch,\n                              \"iterable argument unpacking follows \"\n                              \"keyword argument unpacking\");\n                    return NULL;\n                }\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e)\n                    return NULL;\n                starred = Starred(e, Load, LINENO(chch),\n                        chch->n_col_offset,\n                        chch->n_end_lineno, chch->n_end_col_offset,\n                        c->c_arena);\n                if (!starred)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, starred);\n\n            }\n            else if (TYPE(chch) == DOUBLESTAR) {\n                /* a keyword argument unpacking */\n                keyword_ty kw;\n                i++;\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e)\n                    return NULL;\n                kw = keyword(NULL, e, c->c_arena);\n                asdl_seq_SET(keywords, nkeywords++, kw);\n                ndoublestars++;\n            }\n            else if (TYPE(CHILD(ch, 1)) == comp_for) {\n                /* the lone generator expression */\n                e = copy_location(ast_for_genexp(c, ch), maybegenbeg);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else if (TYPE(CHILD(ch, 1)) == COLONEQUAL) {\n                /* treat colon equal as positional argument */\n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument unpacking\");\n                    }\n                    else {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument\");\n                    }\n                    return NULL;\n                }\n                e = ast_for_namedexpr(c, ch);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else {\n                /* a keyword argument */\n                keyword_ty kw;\n                identifier key, tmp;\n                int k;\n\n                // To remain LL(1), the grammar accepts any test (basically, any\n                // expression) in the keyword slot of a call site.  So, we need\n                // to manually enforce that the keyword is a NAME here.\n                static const int name_tree[] = {\n                    test,\n                    or_test,\n                    and_test,\n                    not_test,\n                    comparison,\n                    expr,\n                    xor_expr,\n                    and_expr,\n                    shift_expr,\n                    arith_expr,\n                    term,\n                    factor,\n                    power,\n                    atom_expr,\n                    atom,\n                    0,\n                };\n                node *expr_node = chch;\n                for (int i = 0; name_tree[i]; i++) {\n                    if (TYPE(expr_node) != name_tree[i])\n                        break;\n                    if (NCH(expr_node) != 1)\n                        break;\n                    expr_node = CHILD(expr_node, 0);\n                }\n                if (TYPE(expr_node) != NAME) {\n                    ast_error(c, chch,\n                              \"expression cannot contain assignment, \"\n                              \"perhaps you meant \\\"==\\\"?\");\n                    return NULL;\n                }\n                key = new_identifier(STR(expr_node), c);\n                if (key == NULL) {\n                    return NULL;\n                }\n                if (forbidden_name(c, key, chch, 1)) {\n                    return NULL;\n                }\n                for (k = 0; k < nkeywords; k++) {\n                    tmp = ((keyword_ty)asdl_seq_GET(keywords, k))->arg;\n                    if (tmp && !PyUnicode_Compare(tmp, key)) {\n                        ast_error(c, chch,\n                                  \"keyword argument repeated\");\n                        return NULL;\n                    }\n                }\n                e = ast_for_expr(c, CHILD(ch, 2));\n                if (!e)\n                    return NULL;\n                kw = keyword(key, e, c->c_arena);\n                if (!kw)\n                    return NULL;\n                asdl_seq_SET(keywords, nkeywords++, kw);\n            }\n        }\n    }\n\n    return Call(func, args, keywords, func->lineno, func->col_offset,\n                closepar->n_end_lineno, closepar->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_testlist(struct compiling *c, const node* n)\n{\n    /* testlist_comp: test (comp_for | (',' test)* [',']) */\n    /* testlist: test (',' test)* [','] */\n    assert(NCH(n) > 0);\n    if (TYPE(n) == testlist_comp) {\n        if (NCH(n) > 1)\n            assert(TYPE(CHILD(n, 1)) != comp_for);\n    }\n    else {\n        assert(TYPE(n) == testlist ||\n               TYPE(n) == testlist_star_expr);\n    }\n    if (NCH(n) == 1)\n        return ast_for_expr(c, CHILD(n, 0));\n    else {\n        asdl_seq *tmp = seq_for_testlist(c, n);\n        if (!tmp)\n            return NULL;\n        return Tuple(tmp, Load, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n}\n\nstatic stmt_ty\nast_for_expr_stmt(struct compiling *c, const node *n)\n{\n    REQ(n, expr_stmt);\n    /* expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |\n                     [('=' (yield_expr|testlist_star_expr))+ [TYPE_COMMENT]] )\n       annassign: ':' test ['=' (yield_expr|testlist)]\n       testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']\n       augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |\n                   '<<=' | '>>=' | '**=' | '//=')\n       test: ... here starts the operator precedence dance\n     */\n    int num = NCH(n);\n\n    if (num == 1) {\n        expr_ty e = ast_for_testlist(c, CHILD(n, 0));\n        if (!e)\n            return NULL;\n\n        return Expr(e, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (TYPE(CHILD(n, 1)) == augassign) {\n        expr_ty expr1, expr2;\n        operator_ty newoperator;\n        node *ch = CHILD(n, 0);\n\n        expr1 = ast_for_testlist(c, ch);\n        if (!expr1)\n            return NULL;\n        if(!set_context(c, expr1, Store, ch))\n            return NULL;\n        /* set_context checks that most expressions are not the left side.\n          Augmented assignments can only have a name, a subscript, or an\n          attribute on the left, though, so we have to explicitly check for\n          those. */\n        switch (expr1->kind) {\n            case Name_kind:\n            case Attribute_kind:\n            case Subscript_kind:\n                break;\n            default:\n                ast_error(c, ch, \"illegal expression for augmented assignment\");\n                return NULL;\n        }\n\n        ch = CHILD(n, 2);\n        if (TYPE(ch) == testlist)\n            expr2 = ast_for_testlist(c, ch);\n        else\n            expr2 = ast_for_expr(c, ch);\n        if (!expr2)\n            return NULL;\n\n        newoperator = ast_for_augassign(c, CHILD(n, 1));\n        if (!newoperator)\n            return NULL;\n\n        return AugAssign(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (TYPE(CHILD(n, 1)) == annassign) {\n        expr_ty expr1, expr2, expr3;\n        node *ch = CHILD(n, 0);\n        node *deep, *ann = CHILD(n, 1);\n        int simple = 1;\n\n        /* AnnAssigns are only allowed in Python 3.6 or greater */\n        if (c->c_feature_version < 6) {\n            ast_error(c, ch,\n                      \"Variable annotation syntax is only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n\n        /* we keep track of parens to qualify (x) as expression not name */\n        deep = ch;\n        while (NCH(deep) == 1) {\n            deep = CHILD(deep, 0);\n        }\n        if (NCH(deep) > 0 && TYPE(CHILD(deep, 0)) == LPAR) {\n            simple = 0;\n        }\n        expr1 = ast_for_testlist(c, ch);\n        if (!expr1) {\n            return NULL;\n        }\n        switch (expr1->kind) {\n            case Name_kind:\n                if (forbidden_name(c, expr1->v.Name.id, n, 0)) {\n                    return NULL;\n                }\n                expr1->v.Name.ctx = Store;\n                break;\n            case Attribute_kind:\n                if (forbidden_name(c, expr1->v.Attribute.attr, n, 1)) {\n                    return NULL;\n                }\n                expr1->v.Attribute.ctx = Store;\n                break;\n            case Subscript_kind:\n                expr1->v.Subscript.ctx = Store;\n                break;\n            case List_kind:\n                ast_error(c, ch,\n                          \"only single target (not list) can be annotated\");\n                return NULL;\n            case Tuple_kind:\n                ast_error(c, ch,\n                          \"only single target (not tuple) can be annotated\");\n                return NULL;\n            default:\n                ast_error(c, ch,\n                          \"illegal target for annotation\");\n                return NULL;\n        }\n\n        if (expr1->kind != Name_kind) {\n            simple = 0;\n        }\n        ch = CHILD(ann, 1);\n        expr2 = ast_for_expr(c, ch);\n        if (!expr2) {\n            return NULL;\n        }\n        if (NCH(ann) == 2) {\n            return AnnAssign(expr1, expr2, NULL, simple,\n                             LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        else {\n            ch = CHILD(ann, 3);\n            if (TYPE(ch) == testlist) {\n                expr3 = ast_for_testlist(c, ch);\n            }\n            else {\n                expr3 = ast_for_expr(c, ch);\n            }\n            if (!expr3) {\n                return NULL;\n            }\n            return AnnAssign(expr1, expr2, expr3, simple,\n                             LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n    }\n    else {\n        int i, nch_minus_type, has_type_comment;\n        asdl_seq *targets;\n        node *value;\n        expr_ty expression;\n        string type_comment;\n\n        /* a normal assignment */\n        REQ(CHILD(n, 1), EQUAL);\n\n        has_type_comment = TYPE(CHILD(n, num - 1)) == TYPE_COMMENT;\n        nch_minus_type = num - has_type_comment;\n\n        targets = _Py_asdl_seq_new(nch_minus_type / 2, c->c_arena);\n        if (!targets)\n            return NULL;\n        for (i = 0; i < nch_minus_type - 2; i += 2) {\n            expr_ty e;\n            node *ch = CHILD(n, i);\n            if (TYPE(ch) == yield_expr) {\n                ast_error(c, ch, \"assignment to yield expression not possible\");\n                return NULL;\n            }\n            e = ast_for_testlist(c, ch);\n            if (!e)\n              return NULL;\n\n            /* set context to assign */\n            if (!set_context(c, e, Store, CHILD(n, i)))\n              return NULL;\n\n            asdl_seq_SET(targets, i / 2, e);\n        }\n        value = CHILD(n, nch_minus_type - 1);\n        if (TYPE(value) == testlist_star_expr)\n            expression = ast_for_testlist(c, value);\n        else\n            expression = ast_for_expr(c, value);\n        if (!expression)\n            return NULL;\n        if (has_type_comment) {\n            type_comment = NEW_TYPE_COMMENT(CHILD(n, nch_minus_type));\n            if (!type_comment)\n                return NULL;\n        }\n        else\n            type_comment = NULL;\n        return Assign(targets, expression, type_comment, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n}\n\n\nstatic asdl_seq *\nast_for_exprlist(struct compiling *c, const node *n, expr_context_ty context)\n{\n    asdl_seq *seq;\n    int i;\n    expr_ty e;\n\n    REQ(n, exprlist);\n\n    seq = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n    if (!seq)\n        return NULL;\n    for (i = 0; i < NCH(n); i += 2) {\n        e = ast_for_expr(c, CHILD(n, i));\n        if (!e)\n            return NULL;\n        asdl_seq_SET(seq, i / 2, e);\n        if (context && !set_context(c, e, context, CHILD(n, i)))\n            return NULL;\n    }\n    return seq;\n}\n\nstatic stmt_ty\nast_for_del_stmt(struct compiling *c, const node *n)\n{\n    asdl_seq *expr_list;\n\n    /* del_stmt: 'del' exprlist */\n    REQ(n, del_stmt);\n\n    expr_list = ast_for_exprlist(c, CHILD(n, 1), Del);\n    if (!expr_list)\n        return NULL;\n    return Delete(expr_list, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_flow_stmt(struct compiling *c, const node *n)\n{\n    /*\n      flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n                 | yield_stmt\n      break_stmt: 'break'\n      continue_stmt: 'continue'\n      return_stmt: 'return' [testlist]\n      yield_stmt: yield_expr\n      yield_expr: 'yield' testlist | 'yield' 'from' test\n      raise_stmt: 'raise' [test [',' test [',' test]]]\n    */\n    node *ch;\n\n    REQ(n, flow_stmt);\n    ch = CHILD(n, 0);\n    switch (TYPE(ch)) {\n        case break_stmt:\n            return Break(LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        case continue_stmt:\n            return Continue(LINENO(n), n->n_col_offset,\n                            n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        case yield_stmt: { /* will reduce to yield_expr */\n            expr_ty exp = ast_for_expr(c, CHILD(ch, 0));\n            if (!exp)\n                return NULL;\n            return Expr(exp, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        case return_stmt:\n            if (NCH(ch) == 1)\n                return Return(NULL, LINENO(n), n->n_col_offset,\n                              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            else {\n                expr_ty expression = ast_for_testlist(c, CHILD(ch, 1));\n                if (!expression)\n                    return NULL;\n                return Return(expression, LINENO(n), n->n_col_offset,\n                              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            }\n        case raise_stmt:\n            if (NCH(ch) == 1)\n                return Raise(NULL, NULL, LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            else if (NCH(ch) >= 2) {\n                expr_ty cause = NULL;\n                expr_ty expression = ast_for_expr(c, CHILD(ch, 1));\n                if (!expression)\n                    return NULL;\n                if (NCH(ch) == 4) {\n                    cause = ast_for_expr(c, CHILD(ch, 3));\n                    if (!cause)\n                        return NULL;\n                }\n                return Raise(expression, cause, LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            }\n            /* fall through */\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"unexpected flow_stmt: %d\", TYPE(ch));\n            return NULL;\n    }\n}\n\nstatic alias_ty\nalias_for_import_name(struct compiling *c, const node *n, int store)\n{\n    /*\n      import_as_name: NAME ['as' NAME]\n      dotted_as_name: dotted_name ['as' NAME]\n      dotted_name: NAME ('.' NAME)*\n    */\n    identifier str, name;\n\n loop:\n    switch (TYPE(n)) {\n        case import_as_name: {\n            node *name_node = CHILD(n, 0);\n            str = NULL;\n            name = NEW_IDENTIFIER(name_node);\n            if (!name)\n                return NULL;\n            if (NCH(n) == 3) {\n                node *str_node = CHILD(n, 2);\n                str = NEW_IDENTIFIER(str_node);\n                if (!str)\n                    return NULL;\n                if (store && forbidden_name(c, str, str_node, 0))\n                    return NULL;\n            }\n            else {\n                if (forbidden_name(c, name, name_node, 0))\n                    return NULL;\n            }\n            return alias(name, str, c->c_arena);\n        }\n        case dotted_as_name:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            else {\n                node *asname_node = CHILD(n, 2);\n                alias_ty a = alias_for_import_name(c, CHILD(n, 0), 0);\n                if (!a)\n                    return NULL;\n                assert(!a->asname);\n                a->asname = NEW_IDENTIFIER(asname_node);\n                if (!a->asname)\n                    return NULL;\n                if (forbidden_name(c, a->asname, asname_node, 0))\n                    return NULL;\n                return a;\n            }\n            break;\n        case dotted_name:\n            if (NCH(n) == 1) {\n                node *name_node = CHILD(n, 0);\n                name = NEW_IDENTIFIER(name_node);\n                if (!name)\n                    return NULL;\n                if (store && forbidden_name(c, name, name_node, 0))\n                    return NULL;\n                return alias(name, NULL, c->c_arena);\n            }\n            else {\n                /* Create a string of the form \"a.b.c\" */\n                int i;\n                size_t len;\n                char *s;\n                PyObject *uni;\n\n                len = 0;\n                for (i = 0; i < NCH(n); i += 2)\n                    /* length of string plus one for the dot */\n                    len += strlen(STR(CHILD(n, i))) + 1;\n                len--; /* the last name doesn't have a dot */\n                str = PyBytes_FromStringAndSize(NULL, len);\n                if (!str)\n                    return NULL;\n                s = PyBytes_AS_STRING(str);\n                if (!s)\n                    return NULL;\n                for (i = 0; i < NCH(n); i += 2) {\n                    char *sch = STR(CHILD(n, i));\n                    strcpy(s, STR(CHILD(n, i)));\n                    s += strlen(sch);\n                    *s++ = '.';\n                }\n                --s;\n                *s = '\\0';\n                uni = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(str),\n                                           PyBytes_GET_SIZE(str),\n                                           NULL);\n                Py_DECREF(str);\n                if (!uni)\n                    return NULL;\n                str = uni;\n                PyUnicode_InternInPlace(&str);\n                if (PyArena_AddPyObject(c->c_arena, str) < 0) {\n                    Py_DECREF(str);\n                    return NULL;\n                }\n                return alias(str, NULL, c->c_arena);\n            }\n            break;\n        case STAR:\n            str = PyUnicode_InternFromString(\"*\");\n            if (!str)\n                return NULL;\n            if (PyArena_AddPyObject(c->c_arena, str) < 0) {\n                Py_DECREF(str);\n                return NULL;\n            }\n            return alias(str, NULL, c->c_arena);\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"unexpected import name: %d\", TYPE(n));\n            return NULL;\n    }\n\n    PyErr_SetString(PyExc_SystemError, \"unhandled import name condition\");\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_import_stmt(struct compiling *c, const node *n)\n{\n    /*\n      import_stmt: import_name | import_from\n      import_name: 'import' dotted_as_names\n      import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+)\n                   'import' ('*' | '(' import_as_names ')' | import_as_names)\n    */\n    int lineno;\n    int col_offset;\n    int i;\n    asdl_seq *aliases;\n\n    REQ(n, import_stmt);\n    lineno = LINENO(n);\n    col_offset = n->n_col_offset;\n    n = CHILD(n, 0);\n    if (TYPE(n) == import_name) {\n        n = CHILD(n, 1);\n        REQ(n, dotted_as_names);\n        aliases = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n        if (!aliases)\n                return NULL;\n        for (i = 0; i < NCH(n); i += 2) {\n            alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);\n            if (!import_alias)\n                return NULL;\n            asdl_seq_SET(aliases, i / 2, import_alias);\n        }\n        // Even though n is modified above, the end position is not changed\n        return Import(aliases, lineno, col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (TYPE(n) == import_from) {\n        int n_children;\n        int idx, ndots = 0;\n        const node *n_copy = n;\n        alias_ty mod = NULL;\n        identifier modname = NULL;\n\n       /* Count the number of dots (for relative imports) and check for the\n          optional module name */\n        for (idx = 1; idx < NCH(n); idx++) {\n            if (TYPE(CHILD(n, idx)) == dotted_name) {\n                mod = alias_for_import_name(c, CHILD(n, idx), 0);\n                if (!mod)\n                    return NULL;\n                idx++;\n                break;\n            } else if (TYPE(CHILD(n, idx)) == ELLIPSIS) {\n                /* three consecutive dots are tokenized as one ELLIPSIS */\n                ndots += 3;\n                continue;\n            } else if (TYPE(CHILD(n, idx)) != DOT) {\n                break;\n            }\n            ndots++;\n        }\n        idx++; /* skip over the 'import' keyword */\n        switch (TYPE(CHILD(n, idx))) {\n        case STAR:\n            /* from ... import * */\n            n = CHILD(n, idx);\n            n_children = 1;\n            break;\n        case LPAR:\n            /* from ... import (x, y, z) */\n            n = CHILD(n, idx + 1);\n            n_children = NCH(n);\n            break;\n        case import_as_names:\n            /* from ... import x, y, z */\n            n = CHILD(n, idx);\n            n_children = NCH(n);\n            if (n_children % 2 == 0) {\n                ast_error(c, n,\n                          \"trailing comma not allowed without\"\n                          \" surrounding parentheses\");\n                return NULL;\n            }\n            break;\n        default:\n            ast_error(c, n, \"Unexpected node-type in from-import\");\n            return NULL;\n        }\n\n        aliases = _Py_asdl_seq_new((n_children + 1) / 2, c->c_arena);\n        if (!aliases)\n            return NULL;\n\n        /* handle \"from ... import *\" special b/c there's no children */\n        if (TYPE(n) == STAR) {\n            alias_ty import_alias = alias_for_import_name(c, n, 1);\n            if (!import_alias)\n                return NULL;\n            asdl_seq_SET(aliases, 0, import_alias);\n        }\n        else {\n            for (i = 0; i < NCH(n); i += 2) {\n                alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);\n                if (!import_alias)\n                    return NULL;\n                asdl_seq_SET(aliases, i / 2, import_alias);\n            }\n        }\n        if (mod != NULL)\n            modname = mod->name;\n        return ImportFrom(modname, aliases, ndots, lineno, col_offset,\n                          n_copy->n_end_lineno, n_copy->n_end_col_offset,\n                          c->c_arena);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"unknown import statement: starts with command '%s'\",\n                 STR(CHILD(n, 0)));\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_global_stmt(struct compiling *c, const node *n)\n{\n    /* global_stmt: 'global' NAME (',' NAME)* */\n    identifier name;\n    asdl_seq *s;\n    int i;\n\n    REQ(n, global_stmt);\n    s = _Py_asdl_seq_new(NCH(n) / 2, c->c_arena);\n    if (!s)\n        return NULL;\n    for (i = 1; i < NCH(n); i += 2) {\n        name = NEW_IDENTIFIER(CHILD(n, i));\n        if (!name)\n            return NULL;\n        asdl_seq_SET(s, i / 2, name);\n    }\n    return Global(s, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_nonlocal_stmt(struct compiling *c, const node *n)\n{\n    /* nonlocal_stmt: 'nonlocal' NAME (',' NAME)* */\n    identifier name;\n    asdl_seq *s;\n    int i;\n\n    REQ(n, nonlocal_stmt);\n    s = _Py_asdl_seq_new(NCH(n) / 2, c->c_arena);\n    if (!s)\n        return NULL;\n    for (i = 1; i < NCH(n); i += 2) {\n        name = NEW_IDENTIFIER(CHILD(n, i));\n        if (!name)\n            return NULL;\n        asdl_seq_SET(s, i / 2, name);\n    }\n    return Nonlocal(s, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_assert_stmt(struct compiling *c, const node *n)\n{\n    /* assert_stmt: 'assert' test [',' test] */\n    REQ(n, assert_stmt);\n    if (NCH(n) == 2) {\n        expr_ty expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        return Assert(expression, NULL, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (NCH(n) == 4) {\n        expr_ty expr1, expr2;\n\n        expr1 = ast_for_expr(c, CHILD(n, 1));\n        if (!expr1)\n            return NULL;\n        expr2 = ast_for_expr(c, CHILD(n, 3));\n        if (!expr2)\n            return NULL;\n\n        return Assert(expr1, expr2, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"improper number of parts to 'assert' statement: %d\",\n                 NCH(n));\n    return NULL;\n}\n\nstatic asdl_seq *\nast_for_suite(struct compiling *c, const node *n)\n{\n    /* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */\n    asdl_seq *seq;\n    stmt_ty s;\n    int i, total, num, end, pos = 0;\n    node *ch;\n\n    if (TYPE(n) != func_body_suite) {\n        REQ(n, suite);\n    }\n\n    total = num_stmts(n);\n    seq = _Py_asdl_seq_new(total, c->c_arena);\n    if (!seq)\n        return NULL;\n    if (TYPE(CHILD(n, 0)) == simple_stmt) {\n        n = CHILD(n, 0);\n        /* simple_stmt always ends with a NEWLINE,\n           and may have a trailing SEMI\n        */\n        end = NCH(n) - 1;\n        if (TYPE(CHILD(n, end - 1)) == SEMI)\n            end--;\n        /* loop by 2 to skip semi-colons */\n        for (i = 0; i < end; i += 2) {\n            ch = CHILD(n, i);\n            s = ast_for_stmt(c, ch);\n            if (!s)\n                return NULL;\n            asdl_seq_SET(seq, pos++, s);\n        }\n    }\n    else {\n        i = 2;\n        if (TYPE(CHILD(n, 1)) == TYPE_COMMENT) {\n            i += 2;\n            REQ(CHILD(n, 2), NEWLINE);\n        }\n\n        for (; i < (NCH(n) - 1); i++) {\n            ch = CHILD(n, i);\n            REQ(ch, stmt);\n            num = num_stmts(ch);\n            if (num == 1) {\n                /* small_stmt or compound_stmt with only one child */\n                s = ast_for_stmt(c, ch);\n                if (!s)\n                    return NULL;\n                asdl_seq_SET(seq, pos++, s);\n            }\n            else {\n                int j;\n                ch = CHILD(ch, 0);\n                REQ(ch, simple_stmt);\n                for (j = 0; j < NCH(ch); j += 2) {\n                    /* statement terminates with a semi-colon ';' */\n                    if (NCH(CHILD(ch, j)) == 0) {\n                        assert((j + 1) == NCH(ch));\n                        break;\n                    }\n                    s = ast_for_stmt(c, CHILD(ch, j));\n                    if (!s)\n                        return NULL;\n                    asdl_seq_SET(seq, pos++, s);\n                }\n            }\n        }\n    }\n    assert(pos == seq->size);\n    return seq;\n}\n\nstatic void\nget_last_end_pos(asdl_seq *s, int *end_lineno, int *end_col_offset)\n{\n    Py_ssize_t tot = asdl_seq_LEN(s);\n    // There must be no empty suites.\n    assert(tot > 0);\n    stmt_ty last = asdl_seq_GET(s, tot - 1);\n    *end_lineno = last->end_lineno;\n    *end_col_offset = last->end_col_offset;\n}\n\nstatic stmt_ty\nast_for_if_stmt(struct compiling *c, const node *n)\n{\n    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\n       ['else' ':' suite]\n    */\n    char *s;\n    int end_lineno, end_col_offset;\n\n    REQ(n, if_stmt);\n\n    if (NCH(n) == 4) {\n        expr_ty expression;\n        asdl_seq *suite_seq;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, CHILD(n, 3));\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return If(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,\n                  end_lineno, end_col_offset, c->c_arena);\n    }\n\n    s = STR(CHILD(n, 4));\n    /* s[2], the third character in the string, will be\n       's' for el_s_e, or\n       'i' for el_i_f\n    */\n    if (s[2] == 's') {\n        expr_ty expression;\n        asdl_seq *seq1, *seq2;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        seq1 = ast_for_suite(c, CHILD(n, 3));\n        if (!seq1)\n            return NULL;\n        seq2 = ast_for_suite(c, CHILD(n, 6));\n        if (!seq2)\n            return NULL;\n        get_last_end_pos(seq2, &end_lineno, &end_col_offset);\n\n        return If(expression, seq1, seq2, LINENO(n), n->n_col_offset,\n                  end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (s[2] == 'i') {\n        int i, n_elif, has_else = 0;\n        expr_ty expression;\n        asdl_seq *suite_seq;\n        asdl_seq *orelse = NULL;\n        n_elif = NCH(n) - 4;\n        /* must reference the child n_elif+1 since 'else' token is third,\n           not fourth, child from the end. */\n        if (TYPE(CHILD(n, (n_elif + 1))) == NAME\n            && STR(CHILD(n, (n_elif + 1)))[2] == 's') {\n            has_else = 1;\n            n_elif -= 3;\n        }\n        n_elif /= 4;\n\n        if (has_else) {\n            asdl_seq *suite_seq2;\n\n            orelse = _Py_asdl_seq_new(1, c->c_arena);\n            if (!orelse)\n                return NULL;\n            expression = ast_for_expr(c, CHILD(n, NCH(n) - 6));\n            if (!expression)\n                return NULL;\n            suite_seq = ast_for_suite(c, CHILD(n, NCH(n) - 4));\n            if (!suite_seq)\n                return NULL;\n            suite_seq2 = ast_for_suite(c, CHILD(n, NCH(n) - 1));\n            if (!suite_seq2)\n                return NULL;\n            get_last_end_pos(suite_seq2, &end_lineno, &end_col_offset);\n\n            asdl_seq_SET(orelse, 0,\n                         If(expression, suite_seq, suite_seq2,\n                            LINENO(CHILD(n, NCH(n) - 6)),\n                            CHILD(n, NCH(n) - 6)->n_col_offset,\n                            end_lineno, end_col_offset, c->c_arena));\n            /* the just-created orelse handled the last elif */\n            n_elif--;\n        }\n\n        for (i = 0; i < n_elif; i++) {\n            int off = 5 + (n_elif - i - 1) * 4;\n            asdl_seq *newobj = _Py_asdl_seq_new(1, c->c_arena);\n            if (!newobj)\n                return NULL;\n            expression = ast_for_expr(c, CHILD(n, off));\n            if (!expression)\n                return NULL;\n            suite_seq = ast_for_suite(c, CHILD(n, off + 2));\n            if (!suite_seq)\n                return NULL;\n\n            if (orelse != NULL) {\n                get_last_end_pos(orelse, &end_lineno, &end_col_offset);\n            } else {\n                get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n            }\n            asdl_seq_SET(newobj, 0,\n                         If(expression, suite_seq, orelse,\n                            LINENO(CHILD(n, off)),\n                            CHILD(n, off)->n_col_offset,\n                            end_lineno, end_col_offset, c->c_arena));\n            orelse = newobj;\n        }\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, CHILD(n, 3));\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(orelse, &end_lineno, &end_col_offset);\n        return If(expression, suite_seq, orelse,\n                  LINENO(n), n->n_col_offset,\n                  end_lineno, end_col_offset, c->c_arena);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"unexpected token in 'if' statement: %s\", s);\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_while_stmt(struct compiling *c, const node *n)\n{\n    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\n    REQ(n, while_stmt);\n    int end_lineno, end_col_offset;\n\n    if (NCH(n) == 4) {\n        expr_ty expression;\n        asdl_seq *suite_seq;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, CHILD(n, 3));\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n        return While(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,\n                     end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (NCH(n) == 7) {\n        expr_ty expression;\n        asdl_seq *seq1, *seq2;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        seq1 = ast_for_suite(c, CHILD(n, 3));\n        if (!seq1)\n            return NULL;\n        seq2 = ast_for_suite(c, CHILD(n, 6));\n        if (!seq2)\n            return NULL;\n        get_last_end_pos(seq2, &end_lineno, &end_col_offset);\n\n        return While(expression, seq1, seq2, LINENO(n), n->n_col_offset,\n                     end_lineno, end_col_offset, c->c_arena);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"wrong number of tokens for 'while' statement: %d\",\n                 NCH(n));\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    int has_type_comment;\n    string type_comment;\n\n    if (is_async && c->c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async for loops are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    /* for_stmt: 'for' exprlist 'in' testlist ':' [TYPE_COMMENT] suite ['else' ':' suite] */\n    REQ(n, for_stmt);\n\n    has_type_comment = TYPE(CHILD(n, 5)) == TYPE_COMMENT;\n\n    if (NCH(n) == 9 + has_type_comment) {\n        seq = ast_for_suite(c, CHILD(n, 8 + has_type_comment));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    /* Check the # of children rather than the length of _target, since\n       for x, in ... has 1 element in _target, but still requires a Tuple. */\n    first = (expr_ty)asdl_seq_GET(_target, 0);\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5 + has_type_comment));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, 5));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq, type_comment,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq, type_comment,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic excepthandler_ty\nast_for_except_clause(struct compiling *c, const node *exc, node *body)\n{\n    /* except_clause: 'except' [test ['as' test]] */\n    int end_lineno, end_col_offset;\n    REQ(exc, except_clause);\n    REQ(body, suite);\n\n    if (NCH(exc) == 1) {\n        asdl_seq *suite_seq = ast_for_suite(c, body);\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return ExceptHandler(NULL, NULL, suite_seq, LINENO(exc),\n                             exc->n_col_offset,\n                             end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (NCH(exc) == 2) {\n        expr_ty expression;\n        asdl_seq *suite_seq;\n\n        expression = ast_for_expr(c, CHILD(exc, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, body);\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return ExceptHandler(expression, NULL, suite_seq, LINENO(exc),\n                             exc->n_col_offset,\n                             end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (NCH(exc) == 4) {\n        asdl_seq *suite_seq;\n        expr_ty expression;\n        identifier e = NEW_IDENTIFIER(CHILD(exc, 3));\n        if (!e)\n            return NULL;\n        if (forbidden_name(c, e, CHILD(exc, 3), 0))\n            return NULL;\n        expression = ast_for_expr(c, CHILD(exc, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, body);\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return ExceptHandler(expression, e, suite_seq, LINENO(exc),\n                             exc->n_col_offset,\n                             end_lineno, end_col_offset, c->c_arena);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"wrong number of children for 'except' clause: %d\",\n                 NCH(exc));\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_try_stmt(struct compiling *c, const node *n)\n{\n    const int nch = NCH(n);\n    int end_lineno, end_col_offset, n_except = (nch - 3)/3;\n    asdl_seq *body, *handlers = NULL, *orelse = NULL, *finally = NULL;\n    excepthandler_ty last_handler;\n\n    REQ(n, try_stmt);\n\n    body = ast_for_suite(c, CHILD(n, 2));\n    if (body == NULL)\n        return NULL;\n\n    if (TYPE(CHILD(n, nch - 3)) == NAME) {\n        if (strcmp(STR(CHILD(n, nch - 3)), \"finally\") == 0) {\n            if (nch >= 9 && TYPE(CHILD(n, nch - 6)) == NAME) {\n                /* we can assume it's an \"else\",\n                   because nch >= 9 for try-else-finally and\n                   it would otherwise have a type of except_clause */\n                orelse = ast_for_suite(c, CHILD(n, nch - 4));\n                if (orelse == NULL)\n                    return NULL;\n                n_except--;\n            }\n\n            finally = ast_for_suite(c, CHILD(n, nch - 1));\n            if (finally == NULL)\n                return NULL;\n            n_except--;\n        }\n        else {\n            /* we can assume it's an \"else\",\n               otherwise it would have a type of except_clause */\n            orelse = ast_for_suite(c, CHILD(n, nch - 1));\n            if (orelse == NULL)\n                return NULL;\n            n_except--;\n        }\n    }\n    else if (TYPE(CHILD(n, nch - 3)) != except_clause) {\n        ast_error(c, n, \"malformed 'try' statement\");\n        return NULL;\n    }\n\n    if (n_except > 0) {\n        int i;\n        /* process except statements to create a try ... except */\n        handlers = _Py_asdl_seq_new(n_except, c->c_arena);\n        if (handlers == NULL)\n            return NULL;\n\n        for (i = 0; i < n_except; i++) {\n            excepthandler_ty e = ast_for_except_clause(c, CHILD(n, 3 + i * 3),\n                                                       CHILD(n, 5 + i * 3));\n            if (!e)\n                return NULL;\n            asdl_seq_SET(handlers, i, e);\n        }\n    }\n\n    assert(finally != NULL || asdl_seq_LEN(handlers));\n        if (finally != NULL) {\n        // finally is always last\n        get_last_end_pos(finally, &end_lineno, &end_col_offset);\n    } else if (orelse != NULL) {\n        // otherwise else is last\n        get_last_end_pos(orelse, &end_lineno, &end_col_offset);\n    } else {\n        // inline the get_last_end_pos logic due to layout mismatch\n        last_handler = (excepthandler_ty) asdl_seq_GET(handlers, n_except - 1);\n        end_lineno = last_handler->end_lineno;\n        end_col_offset = last_handler->end_col_offset;\n    }\n    return Try(body, handlers, orelse, finally, LINENO(n), n->n_col_offset,\n               end_lineno, end_col_offset, c->c_arena);\n}\n\n/* with_item: test ['as' expr] */\nstatic withitem_ty\nast_for_with_item(struct compiling *c, const node *n)\n{\n    expr_ty context_expr, optional_vars = NULL;\n\n    REQ(n, with_item);\n    context_expr = ast_for_expr(c, CHILD(n, 0));\n    if (!context_expr)\n        return NULL;\n    if (NCH(n) == 3) {\n        optional_vars = ast_for_expr(c, CHILD(n, 2));\n\n        if (!optional_vars) {\n            return NULL;\n        }\n        if (!set_context(c, optional_vars, Store, n)) {\n            return NULL;\n        }\n    }\n\n    return withitem(context_expr, optional_vars, c->c_arena);\n}\n\n/* with_stmt: 'with' with_item (',' with_item)*  ':' [TYPE_COMMENT] suite */\nstatic stmt_ty\nast_for_with_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    int i, n_items, nch_minus_type, has_type_comment, end_lineno, end_col_offset;\n    asdl_seq *items, *body;\n    string type_comment;\n\n    if (is_async && c->c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async with statements are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    REQ(n, with_stmt);\n\n    has_type_comment = TYPE(CHILD(n, NCH(n) - 2)) == TYPE_COMMENT;\n    nch_minus_type = NCH(n) - has_type_comment;\n\n    n_items = (nch_minus_type - 2) / 2;\n    items = _Py_asdl_seq_new(n_items, c->c_arena);\n    if (!items)\n        return NULL;\n    for (i = 1; i < nch_minus_type - 2; i += 2) {\n        withitem_ty item = ast_for_with_item(c, CHILD(n, i));\n        if (!item)\n            return NULL;\n        asdl_seq_SET(items, (i - 1) / 2, item);\n    }\n\n    body = ast_for_suite(c, CHILD(n, NCH(n) - 1));\n    if (!body)\n        return NULL;\n    get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, NCH(n) - 2));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncWith(items, body, type_comment, LINENO(n0), n0->n_col_offset,\n                         end_lineno, end_col_offset, c->c_arena);\n    else\n        return With(items, body, type_comment, LINENO(n), n->n_col_offset,\n                    end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_classdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */\n    PyObject *classname;\n    asdl_seq *s;\n    expr_ty call;\n    int end_lineno, end_col_offset;\n\n    REQ(n, classdef);\n\n    if (NCH(n) == 4) { /* class NAME ':' suite */\n        s = ast_for_suite(c, CHILD(n, 3));\n        if (!s)\n            return NULL;\n        get_last_end_pos(s, &end_lineno, &end_col_offset);\n\n        classname = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!classname)\n            return NULL;\n        if (forbidden_name(c, classname, CHILD(n, 3), 0))\n            return NULL;\n        return ClassDef(classname, NULL, NULL, s, decorator_seq,\n                        LINENO(n), n->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    }\n\n    if (TYPE(CHILD(n, 3)) == RPAR) { /* class NAME '(' ')' ':' suite */\n        s = ast_for_suite(c, CHILD(n, 5));\n        if (!s)\n            return NULL;\n        get_last_end_pos(s, &end_lineno, &end_col_offset);\n\n        classname = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!classname)\n            return NULL;\n        if (forbidden_name(c, classname, CHILD(n, 3), 0))\n            return NULL;\n        return ClassDef(classname, NULL, NULL, s, decorator_seq,\n                        LINENO(n), n->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    }\n\n    /* class NAME '(' arglist ')' ':' suite */\n    /* build up a fake Call node so we can extract its pieces */\n    {\n        PyObject *dummy_name;\n        expr_ty dummy;\n        dummy_name = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!dummy_name)\n            return NULL;\n        dummy = Name(dummy_name, Load, LINENO(n), n->n_col_offset,\n                     CHILD(n, 1)->n_end_lineno, CHILD(n, 1)->n_end_col_offset,\n                     c->c_arena);\n        call = ast_for_call(c, CHILD(n, 3), dummy, NULL, CHILD(n, 4));\n        if (!call)\n            return NULL;\n    }\n    s = ast_for_suite(c, CHILD(n, 6));\n    if (!s)\n        return NULL;\n    get_last_end_pos(s, &end_lineno, &end_col_offset);\n\n    classname = NEW_IDENTIFIER(CHILD(n, 1));\n    if (!classname)\n        return NULL;\n    if (forbidden_name(c, classname, CHILD(n, 1), 0))\n        return NULL;\n\n    return ClassDef(classname, call->v.Call.args, call->v.Call.keywords, s,\n                    decorator_seq, LINENO(n), n->n_col_offset,\n                    end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_stmt(struct compiling *c, const node *n)\n{\n    if (TYPE(n) == stmt) {\n        assert(NCH(n) == 1);\n        n = CHILD(n, 0);\n    }\n    if (TYPE(n) == simple_stmt) {\n        assert(num_stmts(n) == 1);\n        n = CHILD(n, 0);\n    }\n    if (TYPE(n) == small_stmt) {\n        n = CHILD(n, 0);\n        /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt\n                  | import_stmt | global_stmt | nonlocal_stmt | assert_stmt\n        */\n        switch (TYPE(n)) {\n            case expr_stmt:\n                return ast_for_expr_stmt(c, n);\n            case del_stmt:\n                return ast_for_del_stmt(c, n);\n            case pass_stmt:\n                return Pass(LINENO(n), n->n_col_offset,\n                            n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            case flow_stmt:\n                return ast_for_flow_stmt(c, n);\n            case import_stmt:\n                return ast_for_import_stmt(c, n);\n            case global_stmt:\n                return ast_for_global_stmt(c, n);\n            case nonlocal_stmt:\n                return ast_for_nonlocal_stmt(c, n);\n            case assert_stmt:\n                return ast_for_assert_stmt(c, n);\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unhandled small_stmt: TYPE=%d NCH=%d\\n\",\n                             TYPE(n), NCH(n));\n                return NULL;\n        }\n    }\n    else {\n        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\n                        | funcdef | classdef | decorated | async_stmt\n        */\n        node *ch = CHILD(n, 0);\n        REQ(n, compound_stmt);\n        switch (TYPE(ch)) {\n            case if_stmt:\n                return ast_for_if_stmt(c, ch);\n            case while_stmt:\n                return ast_for_while_stmt(c, ch);\n            case for_stmt:\n                return ast_for_for_stmt(c, ch, 0);\n            case try_stmt:\n                return ast_for_try_stmt(c, ch);\n            case with_stmt:\n                return ast_for_with_stmt(c, ch, 0);\n            case funcdef:\n                return ast_for_funcdef(c, ch, NULL);\n            case classdef:\n                return ast_for_classdef(c, ch, NULL);\n            case decorated:\n                return ast_for_decorated(c, ch);\n            case async_stmt:\n                return ast_for_async_stmt(c, ch);\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unhandled compound_stmt: TYPE=%d NCH=%d\\n\",\n                             TYPE(n), NCH(n));\n                return NULL;\n        }\n    }\n}\n\nstatic PyObject *\nparsenumber_raw(struct compiling *c, const char *s)\n{\n    const char *end;\n    long x;\n    double dx;\n    Py_complex compl;\n    int imflag;\n\n    assert(s != NULL);\n    errno = 0;\n    end = s + strlen(s) - 1;\n    imflag = *end == 'j' || *end == 'J';\n    if (s[0] == '0') {\n        x = (long) PyOS_strtoul(s, (char **)&end, 0);\n        if (x < 0 && errno == 0) {\n            return PyLong_FromString(s, (char **)0, 0);\n        }\n    }\n    else\n        x = PyOS_strtol(s, (char **)&end, 0);\n    if (*end == '\\0') {\n        if (errno != 0)\n            return PyLong_FromString(s, (char **)0, 0);\n        return PyLong_FromLong(x);\n    }\n    /* XXX Huge floats may silently fail */\n    if (imflag) {\n        compl.real = 0.;\n        compl.imag = PyOS_string_to_double(s, (char **)&end, NULL);\n        if (compl.imag == -1.0 && PyErr_Occurred())\n            return NULL;\n        return PyComplex_FromCComplex(compl);\n    }\n    else\n    {\n        dx = PyOS_string_to_double(s, NULL, NULL);\n        if (dx == -1.0 && PyErr_Occurred())\n            return NULL;\n        return PyFloat_FromDouble(dx);\n    }\n}\n\nstatic PyObject *\nparsenumber(struct compiling *c, const char *s)\n{\n    char *dup, *end;\n    PyObject *res = NULL;\n\n    assert(s != NULL);\n\n    if (strchr(s, '_') == NULL) {\n        return parsenumber_raw(c, s);\n    }\n    /* Create a duplicate without underscores. */\n    dup = PyMem_Malloc(strlen(s) + 1);\n    if (dup == NULL) {\n        return PyErr_NoMemory();\n    }\n    end = dup;\n    for (; *s; s++) {\n        if (*s != '_') {\n            *end++ = *s;\n        }\n    }\n    *end = '\\0';\n    res = parsenumber_raw(c, dup);\n    PyMem_Free(dup);\n    return res;\n}\n\nstatic PyObject *\ndecode_utf8(struct compiling *c, const char **sPtr, const char *end)\n{\n    const char *s, *t;\n    t = s = *sPtr;\n    /* while (s < end && *s != '\\\\') s++; */ /* inefficient for u\"..\" */\n    while (s < end && (*s & 0x80)) s++;\n    *sPtr = s;\n    return PyUnicode_DecodeUTF8(t, s - t, NULL);\n}\n\nstatic int\nwarn_invalid_escape_sequence(struct compiling *c, const node *n,\n                             unsigned char first_invalid_escape_char)\n{\n    PyObject *msg = PyUnicode_FromFormat(\"invalid escape sequence \\\\%c\",\n                                         first_invalid_escape_char);\n    if (msg == NULL) {\n        return -1;\n    }\n    if (PyErr_WarnExplicitObject(PyExc_SyntaxWarning, msg,\n                                   c->c_filename, LINENO(n),\n                                   NULL, NULL) < 0)\n    {\n        if (PyErr_ExceptionMatches(PyExc_SyntaxWarning)) {\n            /* Replace the SyntaxWarning exception with a SyntaxError\n               to get a more accurate error report */\n            PyErr_Clear();\n            ast_error(c, n, \"%U\", msg);\n        }\n        Py_DECREF(msg);\n        return -1;\n    }\n    Py_DECREF(msg);\n    return 0;\n}\n\nstatic PyObject *\ndecode_unicode_with_escapes(struct compiling *c, const node *n, const char *s,\n                            size_t len)\n{\n    PyObject *v, *u;\n    char *buf;\n    char *p;\n    const char *end;\n\n    /* check for integer overflow */\n    if (len > SIZE_MAX / 6)\n        return NULL;\n    /* \"\u00e4\" (2 bytes) may become \"\\U000000E4\" (10 bytes), or 1:5\n       \"\\\u00e4\" (3 bytes) may become \"\\u005c\\U000000E4\" (16 bytes), or ~1:6 */\n    u = PyBytes_FromStringAndSize((char *)NULL, len * 6);\n    if (u == NULL)\n        return NULL;\n    p = buf = PyBytes_AsString(u);\n    end = s + len;\n    while (s < end) {\n        if (*s == '\\\\') {\n            *p++ = *s++;\n            if (s >= end || *s & 0x80) {\n                strcpy(p, \"u005c\");\n                p += 5;\n                if (s >= end)\n                    break;\n            }\n        }\n        if (*s & 0x80) { /* XXX inefficient */\n            PyObject *w;\n            int kind;\n            void *data;\n            Py_ssize_t len, i;\n            w = decode_utf8(c, &s, end);\n            if (w == NULL) {\n                Py_DECREF(u);\n                return NULL;\n            }\n            kind = PyUnicode_KIND(w);\n            data = PyUnicode_DATA(w);\n            len = PyUnicode_GET_LENGTH(w);\n            for (i = 0; i < len; i++) {\n                Py_UCS4 chr = PyUnicode_READ(kind, data, i);\n                sprintf(p, \"\\\\U%08x\", chr);\n                p += 10;\n            }\n            /* Should be impossible to overflow */\n            assert(p - buf <= PyBytes_GET_SIZE(u));\n            Py_DECREF(w);\n        } else {\n            *p++ = *s++;\n        }\n    }\n    len = p - buf;\n    s = buf;\n\n    const char *first_invalid_escape;\n    v = _PyUnicode_DecodeUnicodeEscape(s, len, NULL, &first_invalid_escape);\n\n    if (v != NULL && first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {\n            /* We have not decref u before because first_invalid_escape points\n               inside u. */\n            Py_XDECREF(u);\n            Py_DECREF(v);\n            return NULL;\n        }\n    }\n    Py_XDECREF(u);\n    return v;\n}\n\nstatic PyObject *\ndecode_bytes_with_escapes(struct compiling *c, const node *n, const char *s,\n                          size_t len)\n{\n    const char *first_invalid_escape;\n    PyObject *result = _PyBytes_DecodeEscape(s, len, NULL, 0, NULL,\n                                             &first_invalid_escape);\n    if (result == NULL)\n        return NULL;\n\n    if (first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    }\n    return result;\n}\n\n/* Shift locations for the given node and all its children by adding `lineno`\n   and `col_offset` to existing locations. */\nstatic void fstring_shift_node_locations(node *n, int lineno, int col_offset)\n{\n    n->n_col_offset = n->n_col_offset + col_offset;\n    n->n_end_col_offset = n->n_end_col_offset + col_offset;\n    for (int i = 0; i < NCH(n); ++i) {\n        if (n->n_lineno && n->n_lineno < CHILD(n, i)->n_lineno) {\n            /* Shifting column offsets unnecessary if there's been newlines. */\n            col_offset = 0;\n        }\n        fstring_shift_node_locations(CHILD(n, i), lineno, col_offset);\n    }\n    n->n_lineno = n->n_lineno + lineno;\n    n->n_end_lineno = n->n_end_lineno + lineno;\n}\n\n/* Fix locations for the given node and its children.\n\n   `parent` is the enclosing node.\n   `n` is the node which locations are going to be fixed relative to parent.\n   `expr_str` is the child node's string representation, including braces.\n*/\nstatic void\nfstring_fix_node_location(const node *parent, node *n, char *expr_str)\n{\n    char *substr = NULL;\n    char *start;\n    int lines = LINENO(parent) - 1;\n    int cols = parent->n_col_offset;\n    /* Find the full fstring to fix location information in `n`. */\n    while (parent && parent->n_type != STRING)\n        parent = parent->n_child;\n    if (parent && parent->n_str) {\n        substr = strstr(parent->n_str, expr_str);\n        if (substr) {\n            start = substr;\n            while (start > parent->n_str) {\n                if (start[0] == '\\n')\n                    break;\n                start--;\n            }\n            cols += (int)(substr - start);\n            /* adjust the start based on the number of newlines encountered\n               before the f-string expression */\n            for (char* p = parent->n_str; p < substr; p++) {\n                if (*p == '\\n') {\n                    lines++;\n                }\n            }\n        }\n    }\n    fstring_shift_node_locations(n, lines, cols);\n}\n\n/* Compile this expression in to an expr_ty.  Add parens around the\n   expression, in order to allow leading spaces in the expression. */\nstatic expr_ty\nfstring_compile_expr(const char *expr_start, const char *expr_end,\n                     struct compiling *c, const node *n)\n\n{\n    PyCompilerFlags cf;\n    node *mod_n;\n    mod_ty mod;\n    char *str;\n    Py_ssize_t len;\n    const char *s;\n\n    assert(expr_end >= expr_start);\n    assert(*(expr_start-1) == '{');\n    assert(*expr_end == '}' || *expr_end == '!' || *expr_end == ':');\n\n    /* If the substring is all whitespace, it's an error.  We need to catch this\n       here, and not when we call PyParser_SimpleParseStringFlagsFilename,\n       because turning the expression '' in to '()' would go from being invalid\n       to valid. */\n    for (s = expr_start; s != expr_end; s++) {\n        char c = *s;\n        /* The Python parser ignores only the following whitespace\n           characters (\\r already is converted to \\n). */\n        if (!(c == ' ' || c == '\\t' || c == '\\n' || c == '\\f')) {\n            break;\n        }\n    }\n    if (s == expr_end) {\n        ast_error(c, n, \"f-string: empty expression not allowed\");\n        return NULL;\n    }\n\n    len = expr_end - expr_start;\n    /* Allocate 3 extra bytes: open paren, close paren, null byte. */\n    str = PyMem_RawMalloc(len + 3);\n    if (str == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    str[0] = '(';\n    memcpy(str+1, expr_start, len);\n    str[len+1] = ')';\n    str[len+2] = 0;\n\n    cf.cf_flags = PyCF_ONLY_AST;\n    cf.cf_feature_version = PY_MINOR_VERSION;\n    mod_n = PyParser_SimpleParseStringFlagsFilename(str, \"<fstring>\",\n                                                    Py_eval_input, 0);\n    if (!mod_n) {\n        PyMem_RawFree(str);\n        return NULL;\n    }\n    /* Reuse str to find the correct column offset. */\n    str[0] = '{';\n    str[len+1] = '}';\n    fstring_fix_node_location(n, mod_n, str);\n    mod = PyAST_FromNode(mod_n, &cf, \"<fstring>\", c->c_arena);\n    PyMem_RawFree(str);\n    PyNode_Free(mod_n);\n    if (!mod)\n        return NULL;\n    return mod->v.Expression.body;\n}\n\n/* Return -1 on error.\n\n   Return 0 if we reached the end of the literal.\n\n   Return 1 if we haven't reached the end of the literal, but we want\n   the caller to process the literal up to this point. Used for\n   doubled braces.\n*/\nstatic int\nfstring_find_literal(const char **str, const char *end, int raw,\n                     PyObject **literal, int recurse_lvl,\n                     struct compiling *c, const node *n)\n{\n    /* Get any literal string. It ends when we hit an un-doubled left\n       brace (which isn't part of a unicode name escape such as\n       \"\\N{EULER CONSTANT}\"), or the end of the string. */\n\n    const char *s = *str;\n    const char *literal_start = s;\n    int result = 0;\n\n    assert(*literal == NULL);\n    while (s < end) {\n        char ch = *s++;\n        if (!raw && ch == '\\\\' && s < end) {\n            ch = *s++;\n            if (ch == 'N') {\n                if (s < end && *s++ == '{') {\n                    while (s < end && *s++ != '}') {\n                    }\n                    continue;\n                }\n                break;\n            }\n            if (ch == '{' && warn_invalid_escape_sequence(c, n, ch) < 0) {\n                return -1;\n            }\n        }\n        if (ch == '{' || ch == '}') {\n            /* Check for doubled braces, but only at the top level. If\n               we checked at every level, then f'{0:{3}}' would fail\n               with the two closing braces. */\n            if (recurse_lvl == 0) {\n                if (s < end && *s == ch) {\n                    /* We're going to tell the caller that the literal ends\n                       here, but that they should continue scanning. But also\n                       skip over the second brace when we resume scanning. */\n                    *str = s + 1;\n                    result = 1;\n                    goto done;\n                }\n\n                /* Where a single '{' is the start of a new expression, a\n                   single '}' is not allowed. */\n                if (ch == '}') {\n                    *str = s - 1;\n                    ast_error(c, n, \"f-string: single '}' is not allowed\");\n                    return -1;\n                }\n            }\n            /* We're either at a '{', which means we're starting another\n               expression; or a '}', which means we're at the end of this\n               f-string (for a nested format_spec). */\n            s--;\n            break;\n        }\n    }\n    *str = s;\n    assert(s <= end);\n    assert(s == end || *s == '{' || *s == '}');\ndone:\n    if (literal_start != s) {\n        if (raw)\n            *literal = PyUnicode_DecodeUTF8Stateful(literal_start,\n                                                    s - literal_start,\n                                                    NULL, NULL);\n        else\n            *literal = decode_unicode_with_escapes(c, n, literal_start,\n                                                   s - literal_start);\n        if (!*literal)\n            return -1;\n    }\n    return result;\n}\n\n/* Forward declaration because parsing is recursive. */\nstatic expr_ty\nfstring_parse(const char **str, const char *end, int raw, int recurse_lvl,\n              struct compiling *c, const node *n);\n\n/* Parse the f-string at *str, ending at end.  We know *str starts an\n   expression (so it must be a '{'). Returns the FormattedValue node,\n   which includes the expression, conversion character, and\n   format_spec expression.\n\n   Note that I don't do a perfect job here: I don't make sure that a\n   closing brace doesn't match an opening paren, for example. It\n   doesn't need to error on all invalid expressions, just correctly\n   find the end of all valid ones. Any errors inside the expression\n   will be caught when we parse it later. */\nstatic int\nfstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,\n                  expr_ty *expression, struct compiling *c, const node *n)\n{\n    /* Return -1 on error, else 0. */\n\n    const char *expr_start;\n    const char *expr_end;\n    expr_ty simple_expression;\n    expr_ty format_spec = NULL; /* Optional format specifier. */\n    int conversion = -1; /* The conversion char. -1 if not specified. */\n\n    /* 0 if we're not in a string, else the quote char we're trying to\n       match (single or double quote). */\n    char quote_char = 0;\n\n    /* If we're inside a string, 1=normal, 3=triple-quoted. */\n    int string_type = 0;\n\n    /* Keep track of nesting level for braces/parens/brackets in\n       expressions. */\n    Py_ssize_t nested_depth = 0;\n    char parenstack[MAXLEVEL];\n\n    /* Can only nest one level deep. */\n    if (recurse_lvl >= 2) {\n        ast_error(c, n, \"f-string: expressions nested too deeply\");\n        return -1;\n    }\n\n    /* The first char must be a left brace, or we wouldn't have gotten\n       here. Skip over it. */\n    assert(**str == '{');\n    *str += 1;\n\n    expr_start = *str;\n    for (; *str < end; (*str)++) {\n        char ch;\n\n        /* Loop invariants. */\n        assert(nested_depth >= 0);\n        assert(*str >= expr_start && *str < end);\n        if (quote_char)\n            assert(string_type == 1 || string_type == 3);\n        else\n            assert(string_type == 0);\n\n        ch = **str;\n        /* Nowhere inside an expression is a backslash allowed. */\n        if (ch == '\\\\') {\n            /* Error: can't include a backslash character, inside\n               parens or strings or not. */\n            ast_error(c, n,\n                      \"f-string expression part \"\n                      \"cannot include a backslash\");\n            return -1;\n        }\n        if (quote_char) {\n            /* We're inside a string. See if we're at the end. */\n            /* This code needs to implement the same non-error logic\n               as tok_get from tokenizer.c, at the letter_quote\n               label. To actually share that code would be a\n               nightmare. But, it's unlikely to change and is small,\n               so duplicate it here. Note we don't need to catch all\n               of the errors, since they'll be caught when parsing the\n               expression. We just need to match the non-error\n               cases. Thus we can ignore \\n in single-quoted strings,\n               for example. Or non-terminated strings. */\n            if (ch == quote_char) {\n                /* Does this match the string_type (single or triple\n                   quoted)? */\n                if (string_type == 3) {\n                    if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {\n                        /* We're at the end of a triple quoted string. */\n                        *str += 2;\n                        string_type = 0;\n                        quote_char = 0;\n                        continue;\n                    }\n                } else {\n                    /* We're at the end of a normal string. */\n                    quote_char = 0;\n                    string_type = 0;\n                    continue;\n                }\n            }\n        } else if (ch == '\\'' || ch == '\"') {\n            /* Is this a triple quoted string? */\n            if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {\n                string_type = 3;\n                *str += 2;\n            } else {\n                /* Start of a normal string. */\n                string_type = 1;\n            }\n            /* Start looking for the end of the string. */\n            quote_char = ch;\n        } else if (ch == '[' || ch == '{' || ch == '(') {\n            if (nested_depth >= MAXLEVEL) {\n                ast_error(c, n, \"f-string: too many nested parenthesis\");\n                return -1;\n            }\n            parenstack[nested_depth] = ch;\n            nested_depth++;\n        } else if (ch == '#') {\n            /* Error: can't include a comment character, inside parens\n               or not. */\n            ast_error(c, n, \"f-string expression part cannot include '#'\");\n            return -1;\n        } else if (nested_depth == 0 &&\n                   (ch == '!' || ch == ':' || ch == '}')) {\n            /* First, test for the special case of \"!=\". Since '=' is\n               not an allowed conversion character, nothing is lost in\n               this test. */\n            if (ch == '!' && *str+1 < end && *(*str+1) == '=') {\n                /* This isn't a conversion character, just continue. */\n                continue;\n            }\n            /* Normal way out of this loop. */\n            break;\n        } else if (ch == ']' || ch == '}' || ch == ')') {\n            if (!nested_depth) {\n                ast_error(c, n, \"f-string: unmatched '%c'\", ch);\n                return -1;\n            }\n            nested_depth--;\n            int opening = parenstack[nested_depth];\n            if (!((opening == '(' && ch == ')') ||\n                  (opening == '[' && ch == ']') ||\n                  (opening == '{' && ch == '}')))\n            {\n                ast_error(c, n,\n                          \"f-string: closing parenthesis '%c' \"\n                          \"does not match opening parenthesis '%c'\",\n                          ch, opening);\n                return -1;\n            }\n        } else {\n            /* Just consume this char and loop around. */\n        }\n    }\n    expr_end = *str;\n    /* If we leave this loop in a string or with mismatched parens, we\n       don't care. We'll get a syntax error when compiling the\n       expression. But, we can produce a better error message, so\n       let's just do that.*/\n    if (quote_char) {\n        ast_error(c, n, \"f-string: unterminated string\");\n        return -1;\n    }\n    if (nested_depth) {\n        int opening = parenstack[nested_depth - 1];\n        ast_error(c, n, \"f-string: unmatched '%c'\", opening);\n        return -1;\n    }\n\n    if (*str >= end)\n        goto unexpected_end_of_string;\n\n    /* Compile the expression as soon as possible, so we show errors\n       related to the expression before errors related to the\n       conversion or format_spec. */\n    simple_expression = fstring_compile_expr(expr_start, expr_end, c, n);\n    if (!simple_expression)\n        return -1;\n\n    /* Check for a conversion char, if present. */\n    if (**str == '!') {\n        *str += 1;\n        if (*str >= end)\n            goto unexpected_end_of_string;\n\n        conversion = **str;\n        *str += 1;\n\n        /* Validate the conversion. */\n        if (!(conversion == 's' || conversion == 'r'\n              || conversion == 'a')) {\n            ast_error(c, n,\n                      \"f-string: invalid conversion character: \"\n                      \"expected 's', 'r', or 'a'\");\n            return -1;\n        }\n    }\n\n    /* Check for the format spec, if present. */\n    if (*str >= end)\n        goto unexpected_end_of_string;\n    if (**str == ':') {\n        *str += 1;\n        if (*str >= end)\n            goto unexpected_end_of_string;\n\n        /* Parse the format spec. */\n        format_spec = fstring_parse(str, end, raw, recurse_lvl+1, c, n);\n        if (!format_spec)\n            return -1;\n    }\n\n    if (*str >= end || **str != '}')\n        goto unexpected_end_of_string;\n\n    /* We're at a right brace. Consume it. */\n    assert(*str < end);\n    assert(**str == '}');\n    *str += 1;\n\n    /* And now create the FormattedValue node that represents this\n       entire expression with the conversion and format spec. */\n    *expression = FormattedValue(simple_expression, conversion,\n                                 format_spec, LINENO(n), n->n_col_offset,\n                                 n->n_end_lineno, n->n_end_col_offset,\n                                 c->c_arena);\n    if (!*expression)\n        return -1;\n\n    return 0;\n\nunexpected_end_of_string:\n    ast_error(c, n, \"f-string: expecting '}'\");\n    return -1;\n}\n\n/* Return -1 on error.\n\n   Return 0 if we have a literal (possible zero length) and an\n   expression (zero length if at the end of the string.\n\n   Return 1 if we have a literal, but no expression, and we want the\n   caller to call us again. This is used to deal with doubled\n   braces.\n\n   When called multiple times on the string 'a{{b{0}c', this function\n   will return:\n\n   1. the literal 'a{' with no expression, and a return value\n      of 1. Despite the fact that there's no expression, the return\n      value of 1 means we're not finished yet.\n\n   2. the literal 'b' and the expression '0', with a return value of\n      0. The fact that there's an expression means we're not finished.\n\n   3. literal 'c' with no expression and a return value of 0. The\n      combination of the return value of 0 with no expression means\n      we're finished.\n*/\nstatic int\nfstring_find_literal_and_expr(const char **str, const char *end, int raw,\n                              int recurse_lvl, PyObject **literal,\n                              expr_ty *expression,\n                              struct compiling *c, const node *n)\n{\n    int result;\n\n    assert(*literal == NULL && *expression == NULL);\n\n    /* Get any literal string. */\n    result = fstring_find_literal(str, end, raw, literal, recurse_lvl, c, n);\n    if (result < 0)\n        goto error;\n\n    assert(result == 0 || result == 1);\n\n    if (result == 1)\n        /* We have a literal, but don't look at the expression. */\n        return 1;\n\n    if (*str >= end || **str == '}')\n        /* We're at the end of the string or the end of a nested\n           f-string: no expression. The top-level error case where we\n           expect to be at the end of the string but we're at a '}' is\n           handled later. */\n        return 0;\n\n    /* We must now be the start of an expression, on a '{'. */\n    assert(**str == '{');\n\n    if (fstring_find_expr(str, end, raw, recurse_lvl, expression, c, n) < 0)\n        goto error;\n\n    return 0;\n\nerror:\n    Py_CLEAR(*literal);\n    return -1;\n}\n\n#define EXPRLIST_N_CACHED  64\n\ntypedef struct {\n    /* Incrementally build an array of expr_ty, so be used in an\n       asdl_seq. Cache some small but reasonably sized number of\n       expr_ty's, and then after that start dynamically allocating,\n       doubling the number allocated each time. Note that the f-string\n       f'{0}a{1}' contains 3 expr_ty's: 2 FormattedValue's, and one\n       Constant for the literal 'a'. So you add expr_ty's about twice as\n       fast as you add exressions in an f-string. */\n\n    Py_ssize_t allocated;  /* Number we've allocated. */\n    Py_ssize_t size;       /* Number we've used. */\n    expr_ty    *p;         /* Pointer to the memory we're actually\n                              using. Will point to 'data' until we\n                              start dynamically allocating. */\n    expr_ty    data[EXPRLIST_N_CACHED];\n} ExprList;\n\n#ifdef NDEBUG\n#define ExprList_check_invariants(l)\n#else\nstatic void\nExprList_check_invariants(ExprList *l)\n{\n    /* Check our invariants. Make sure this object is \"live\", and\n       hasn't been deallocated. */\n    assert(l->size >= 0);\n    assert(l->p != NULL);\n    if (l->size <= EXPRLIST_N_CACHED)\n        assert(l->data == l->p);\n}\n#endif\n\nstatic void\nExprList_Init(ExprList *l)\n{\n    l->allocated = EXPRLIST_N_CACHED;\n    l->size = 0;\n\n    /* Until we start allocating dynamically, p points to data. */\n    l->p = l->data;\n\n    ExprList_check_invariants(l);\n}\n\nstatic int\nExprList_Append(ExprList *l, expr_ty exp)\n{\n    ExprList_check_invariants(l);\n    if (l->size >= l->allocated) {\n        /* We need to alloc (or realloc) the memory. */\n        Py_ssize_t new_size = l->allocated * 2;\n\n        /* See if we've ever allocated anything dynamically. */\n        if (l->p == l->data) {\n            Py_ssize_t i;\n            /* We're still using the cached data. Switch to\n               alloc-ing. */\n            l->p = PyMem_RawMalloc(sizeof(expr_ty) * new_size);\n            if (!l->p)\n                return -1;\n            /* Copy the cached data into the new buffer. */\n            for (i = 0; i < l->size; i++)\n                l->p[i] = l->data[i];\n        } else {\n            /* Just realloc. */\n            expr_ty *tmp = PyMem_RawRealloc(l->p, sizeof(expr_ty) * new_size);\n            if (!tmp) {\n                PyMem_RawFree(l->p);\n                l->p = NULL;\n                return -1;\n            }\n            l->p = tmp;\n        }\n\n        l->allocated = new_size;\n        assert(l->allocated == 2 * l->size);\n    }\n\n    l->p[l->size++] = exp;\n\n    ExprList_check_invariants(l);\n    return 0;\n}\n\nstatic void\nExprList_Dealloc(ExprList *l)\n{\n    ExprList_check_invariants(l);\n\n    /* If there's been an error, or we've never dynamically allocated,\n       do nothing. */\n    if (!l->p || l->p == l->data) {\n        /* Do nothing. */\n    } else {\n        /* We have dynamically allocated. Free the memory. */\n        PyMem_RawFree(l->p);\n    }\n    l->p = NULL;\n    l->size = -1;\n}\n\nstatic asdl_seq *\nExprList_Finish(ExprList *l, PyArena *arena)\n{\n    asdl_seq *seq;\n\n    ExprList_check_invariants(l);\n\n    /* Allocate the asdl_seq and copy the expressions in to it. */\n    seq = _Py_asdl_seq_new(l->size, arena);\n    if (seq) {\n        Py_ssize_t i;\n        for (i = 0; i < l->size; i++)\n            asdl_seq_SET(seq, i, l->p[i]);\n    }\n    ExprList_Dealloc(l);\n    return seq;\n}\n\n/* The FstringParser is designed to add a mix of strings and\n   f-strings, and concat them together as needed. Ultimately, it\n   generates an expr_ty. */\ntypedef struct {\n    PyObject *last_str;\n    ExprList expr_list;\n    int fmode;\n} FstringParser;\n\n#ifdef NDEBUG\n#define FstringParser_check_invariants(state)\n#else\nstatic void\nFstringParser_check_invariants(FstringParser *state)\n{\n    if (state->last_str)\n        assert(PyUnicode_CheckExact(state->last_str));\n    ExprList_check_invariants(&state->expr_list);\n}\n#endif\n\nstatic void\nFstringParser_Init(FstringParser *state)\n{\n    state->last_str = NULL;\n    state->fmode = 0;\n    ExprList_Init(&state->expr_list);\n    FstringParser_check_invariants(state);\n}\n\nstatic void\nFstringParser_Dealloc(FstringParser *state)\n{\n    FstringParser_check_invariants(state);\n\n    Py_XDECREF(state->last_str);\n    ExprList_Dealloc(&state->expr_list);\n}\n\n/* Constants for the following */\nstatic PyObject *u_kind;\n\n/* Compute 'kind' field for string Constant (either 'u' or None) */\nstatic PyObject *\nmake_kind(struct compiling *c, const node *n)\n{\n    char *s = NULL;\n    PyObject *kind = NULL;\n\n    /* Find the first string literal, if any */\n    while (TYPE(n) != STRING) {\n        if (NCH(n) == 0)\n            return NULL;\n        n = CHILD(n, 0);\n    }\n    REQ(n, STRING);\n\n    /* If it starts with 'u', return a PyUnicode \"u\" string */\n    s = STR(n);\n    if (s && *s == 'u') {\n        if (!u_kind) {\n            u_kind = PyUnicode_InternFromString(\"u\");\n            if (!u_kind)\n                return NULL;\n        }\n        kind = u_kind;\n        if (PyArena_AddPyObject(c->c_arena, kind) < 0) {\n            return NULL;\n        }\n        Py_INCREF(kind);\n    }\n    return kind;\n}\n\n/* Make a Constant node, but decref the PyUnicode object being added. */\nstatic expr_ty\nmake_str_node_and_del(PyObject **str, struct compiling *c, const node* n)\n{\n    PyObject *s = *str;\n    PyObject *kind = NULL;\n    *str = NULL;\n    assert(PyUnicode_CheckExact(s));\n    if (PyArena_AddPyObject(c->c_arena, s) < 0) {\n        Py_DECREF(s);\n        return NULL;\n    }\n    kind = make_kind(c, n);\n    if (kind == NULL && PyErr_Occurred())\n        return NULL;\n    return Constant(s, kind, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\n/* Add a non-f-string (that is, a regular literal string). str is\n   decref'd. */\nstatic int\nFstringParser_ConcatAndDel(FstringParser *state, PyObject *str)\n{\n    FstringParser_check_invariants(state);\n\n    assert(PyUnicode_CheckExact(str));\n\n    if (PyUnicode_GET_LENGTH(str) == 0) {\n        Py_DECREF(str);\n        return 0;\n    }\n\n    if (!state->last_str) {\n        /* We didn't have a string before, so just remember this one. */\n        state->last_str = str;\n    } else {\n        /* Concatenate this with the previous string. */\n        PyUnicode_AppendAndDel(&state->last_str, str);\n        if (!state->last_str)\n            return -1;\n    }\n    FstringParser_check_invariants(state);\n    return 0;\n}\n\n/* Parse an f-string. The f-string is in *str to end, with no\n   'f' or quotes. */\nstatic int\nFstringParser_ConcatFstring(FstringParser *state, const char **str,\n                            const char *end, int raw, int recurse_lvl,\n                            struct compiling *c, const node *n)\n{\n    FstringParser_check_invariants(state);\n    state->fmode = 1;\n\n    /* Parse the f-string. */\n    while (1) {\n        PyObject *literal = NULL;\n        expr_ty expression = NULL;\n\n        /* If there's a zero length literal in front of the\n           expression, literal will be NULL. If we're at the end of\n           the f-string, expression will be NULL (unless result == 1,\n           see below). */\n        int result = fstring_find_literal_and_expr(str, end, raw, recurse_lvl,\n                                                   &literal, &expression,\n                                                   c, n);\n        if (result < 0)\n            return -1;\n\n        /* Add the literal, if any. */\n        if (!literal) {\n            /* Do nothing. Just leave last_str alone (and possibly\n               NULL). */\n        } else if (!state->last_str) {\n            /*  Note that the literal can be zero length, if the\n                input string is \"\\\\\\n\" or \"\\\\\\r\", among others. */\n            state->last_str = literal;\n            literal = NULL;\n        } else {\n            /* We have a literal, concatenate it. */\n            assert(PyUnicode_GET_LENGTH(literal) != 0);\n            if (FstringParser_ConcatAndDel(state, literal) < 0)\n                return -1;\n            literal = NULL;\n        }\n\n        /* We've dealt with the literal now. It can't be leaked on further\n           errors. */\n        assert(literal == NULL);\n\n        /* See if we should just loop around to get the next literal\n           and expression, while ignoring the expression this\n           time. This is used for un-doubling braces, as an\n           optimization. */\n        if (result == 1)\n            continue;\n\n        if (!expression)\n            /* We're done with this f-string. */\n            break;\n\n        /* We know we have an expression. Convert any existing string\n           to a Constant node. */\n        if (!state->last_str) {\n            /* Do nothing. No previous literal. */\n        } else {\n            /* Convert the existing last_str literal to a Constant node. */\n            expr_ty str = make_str_node_and_del(&state->last_str, c, n);\n            if (!str || ExprList_Append(&state->expr_list, str) < 0)\n                return -1;\n        }\n\n        if (ExprList_Append(&state->expr_list, expression) < 0)\n            return -1;\n    }\n\n    /* If recurse_lvl is zero, then we must be at the end of the\n       string. Otherwise, we must be at a right brace. */\n\n    if (recurse_lvl == 0 && *str < end-1) {\n        ast_error(c, n, \"f-string: unexpected end of string\");\n        return -1;\n    }\n    if (recurse_lvl != 0 && **str != '}') {\n        ast_error(c, n, \"f-string: expecting '}'\");\n        return -1;\n    }\n\n    FstringParser_check_invariants(state);\n    return 0;\n}\n\n/* Convert the partial state reflected in last_str and expr_list to an\n   expr_ty. The expr_ty can be a Constant, or a JoinedStr. */\nstatic expr_ty\nFstringParser_Finish(FstringParser *state, struct compiling *c,\n                     const node *n)\n{\n    asdl_seq *seq;\n\n    FstringParser_check_invariants(state);\n\n    /* If we're just a constant string with no expressions, return\n       that. */\n    if (!state->fmode) {\n        assert(!state->expr_list.size);\n        if (!state->last_str) {\n            /* Create a zero length string. */\n            state->last_str = PyUnicode_FromStringAndSize(NULL, 0);\n            if (!state->last_str)\n                goto error;\n        }\n        return make_str_node_and_del(&state->last_str, c, n);\n    }\n\n    /* Create a Constant node out of last_str, if needed. It will be the\n       last node in our expression list. */\n    if (state->last_str) {\n        expr_ty str = make_str_node_and_del(&state->last_str, c, n);\n        if (!str || ExprList_Append(&state->expr_list, str) < 0)\n            goto error;\n    }\n    /* This has already been freed. */\n    assert(state->last_str == NULL);\n\n    seq = ExprList_Finish(&state->expr_list, c->c_arena);\n    if (!seq)\n        goto error;\n\n    return JoinedStr(seq, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n\nerror:\n    FstringParser_Dealloc(state);\n    return NULL;\n}\n\n/* Given an f-string (with no 'f' or quotes) that's in *str and ends\n   at end, parse it into an expr_ty.  Return NULL on error.  Adjust\n   str to point past the parsed portion. */\nstatic expr_ty\nfstring_parse(const char **str, const char *end, int raw, int recurse_lvl,\n              struct compiling *c, const node *n)\n{\n    FstringParser state;\n\n    FstringParser_Init(&state);\n    if (FstringParser_ConcatFstring(&state, str, end, raw, recurse_lvl,\n                                    c, n) < 0) {\n        FstringParser_Dealloc(&state);\n        return NULL;\n    }\n\n    return FstringParser_Finish(&state, c, n);\n}\n\n/* n is a Python string literal, including the bracketing quote\n   characters, and r, b, u, &/or f prefixes (if any), and embedded\n   escape sequences (if any). parsestr parses it, and sets *result to\n   decoded Python string object.  If the string is an f-string, set\n   *fstr and *fstrlen to the unparsed string object.  Return 0 if no\n   errors occurred.\n*/\nstatic int\nparsestr(struct compiling *c, const node *n, int *bytesmode, int *rawmode,\n         PyObject **result, const char **fstr, Py_ssize_t *fstrlen)\n{\n    size_t len;\n    const char *s = STR(n);\n    int quote = Py_CHARMASK(*s);\n    int fmode = 0;\n    *bytesmode = 0;\n    *rawmode = 0;\n    *result = NULL;\n    *fstr = NULL;\n    if (Py_ISALPHA(quote)) {\n        while (!*bytesmode || !*rawmode) {\n            if (quote == 'b' || quote == 'B') {\n                quote = *++s;\n                *bytesmode = 1;\n            }\n            else if (quote == 'u' || quote == 'U') {\n                quote = *++s;\n            }\n            else if (quote == 'r' || quote == 'R') {\n                quote = *++s;\n                *rawmode = 1;\n            }\n            else if (quote == 'f' || quote == 'F') {\n                quote = *++s;\n                fmode = 1;\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /* fstrings are only allowed in Python 3.6 and greater */\n    if (fmode && c->c_feature_version < 6) {\n        ast_error(c, n, \"Format strings are only supported in Python 3.6 and greater\");\n        return -1;\n    }\n\n    if (fmode && *bytesmode) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    if (quote != '\\'' && quote != '\\\"') {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    /* Skip the leading quote char. */\n    s++;\n    len = strlen(s);\n    if (len > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"string to parse is too long\");\n        return -1;\n    }\n    if (s[--len] != quote) {\n        /* Last quote char must match the first. */\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    if (len >= 4 && s[0] == quote && s[1] == quote) {\n        /* A triple quoted string. We've already skipped one quote at\n           the start and one at the end of the string. Now skip the\n           two at the start. */\n        s += 2;\n        len -= 2;\n        /* And check that the last two match. */\n        if (s[--len] != quote || s[--len] != quote) {\n            PyErr_BadInternalCall();\n            return -1;\n        }\n    }\n\n    if (fmode) {\n        /* Just return the bytes. The caller will parse the resulting\n           string. */\n        *fstr = s;\n        *fstrlen = len;\n        return 0;\n    }\n\n    /* Not an f-string. */\n    /* Avoid invoking escape decoding routines if possible. */\n    *rawmode = *rawmode || strchr(s, '\\\\') == NULL;\n    if (*bytesmode) {\n        /* Disallow non-ASCII characters. */\n        const char *ch;\n        for (ch = s; *ch; ch++) {\n            if (Py_CHARMASK(*ch) >= 0x80) {\n                ast_error(c, n,\n                          \"bytes can only contain ASCII \"\n                          \"literal characters.\");\n                return -1;\n            }\n        }\n        if (*rawmode)\n            *result = PyBytes_FromStringAndSize(s, len);\n        else\n            *result = decode_bytes_with_escapes(c, n, s, len);\n    } else {\n        if (*rawmode)\n            *result = PyUnicode_DecodeUTF8Stateful(s, len, NULL, NULL);\n        else\n            *result = decode_unicode_with_escapes(c, n, s, len);\n    }\n    return *result == NULL ? -1 : 0;\n}\n\n/* Accepts a STRING+ atom, and produces an expr_ty node. Run through\n   each STRING atom, and process it as needed. For bytes, just\n   concatenate them together, and the result will be a Constant node. For\n   normal strings and f-strings, concatenate them together. The result\n   will be a Constant node if there were no f-strings; a FormattedValue\n   node if there's just an f-string (with no leading or trailing\n   literals), or a JoinedStr node if there are multiple f-strings or\n   any literals involved. */\nstatic expr_ty\nparsestrplus(struct compiling *c, const node *n)\n{\n    int bytesmode = 0;\n    PyObject *bytes_str = NULL;\n    int i;\n\n    FstringParser state;\n    FstringParser_Init(&state);\n\n    for (i = 0; i < NCH(n); i++) {\n        int this_bytesmode;\n        int this_rawmode;\n        PyObject *s;\n        const char *fstr;\n        Py_ssize_t fstrlen = -1;  /* Silence a compiler warning. */\n\n        REQ(CHILD(n, i), STRING);\n        if (parsestr(c, CHILD(n, i), &this_bytesmode, &this_rawmode, &s,\n                     &fstr, &fstrlen) != 0)\n            goto error;\n\n        /* Check that we're not mixing bytes with unicode. */\n        if (i != 0 && bytesmode != this_bytesmode) {\n            ast_error(c, n, \"cannot mix bytes and nonbytes literals\");\n            /* s is NULL if the current string part is an f-string. */\n            Py_XDECREF(s);\n            goto error;\n        }\n        bytesmode = this_bytesmode;\n\n        if (fstr != NULL) {\n            int result;\n            assert(s == NULL && !bytesmode);\n            /* This is an f-string. Parse and concatenate it. */\n            result = FstringParser_ConcatFstring(&state, &fstr, fstr+fstrlen,\n                                                 this_rawmode, 0, c, n);\n            if (result < 0)\n                goto error;\n        } else {\n            /* A string or byte string. */\n            assert(s != NULL && fstr == NULL);\n\n            assert(bytesmode ? PyBytes_CheckExact(s) :\n                   PyUnicode_CheckExact(s));\n\n            if (bytesmode) {\n                /* For bytes, concat as we go. */\n                if (i == 0) {\n                    /* First time, just remember this value. */\n                    bytes_str = s;\n                } else {\n                    PyBytes_ConcatAndDel(&bytes_str, s);\n                    if (!bytes_str)\n                        goto error;\n                }\n            } else {\n                /* This is a regular string. Concatenate it. */\n                if (FstringParser_ConcatAndDel(&state, s) < 0)\n                    goto error;\n            }\n        }\n    }\n    if (bytesmode) {\n        /* Just return the bytes object and we're done. */\n        if (PyArena_AddPyObject(c->c_arena, bytes_str) < 0)\n            goto error;\n        return Constant(bytes_str, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n\n    /* We're not a bytes string, bytes_str should never have been set. */\n    assert(bytes_str == NULL);\n\n    return FstringParser_Finish(&state, c, n);\n\nerror:\n    Py_XDECREF(bytes_str);\n    FstringParser_Dealloc(&state);\n    return NULL;\n}\n\nPyObject *\n_PyAST_GetDocString(asdl_seq *body)\n{\n    if (!asdl_seq_LEN(body)) {\n        return NULL;\n    }\n    stmt_ty st = (stmt_ty)asdl_seq_GET(body, 0);\n    if (st->kind != Expr_kind) {\n        return NULL;\n    }\n    expr_ty e = st->v.Expr.value;\n    if (e->kind == Constant_kind && PyUnicode_CheckExact(e->v.Constant.value)) {\n        return e->v.Constant.value;\n    }\n    return NULL;\n}\n"], "fixing_code": ["/*\n * This file includes functions to transform a concrete syntax tree (CST) to\n * an abstract syntax tree (AST). The main function is PyAST_FromNode().\n *\n */\n#include \"Python.h\"\n#include \"Python-ast.h\"\n#include \"node.h\"\n#include \"ast.h\"\n#include \"token.h\"\n#include \"pythonrun.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n\n#define MAXLEVEL 200    /* Max parentheses level */\n\nstatic int validate_stmts(asdl_seq *);\nstatic int validate_exprs(asdl_seq *, expr_context_ty, int);\nstatic int validate_nonempty_seq(asdl_seq *, const char *, const char *);\nstatic int validate_stmt(stmt_ty);\nstatic int validate_expr(expr_ty, expr_context_ty);\n\nstatic int\nvalidate_comprehension(asdl_seq *gens)\n{\n    Py_ssize_t i;\n    if (!asdl_seq_LEN(gens)) {\n        PyErr_SetString(PyExc_ValueError, \"comprehension with no generators\");\n        return 0;\n    }\n    for (i = 0; i < asdl_seq_LEN(gens); i++) {\n        comprehension_ty comp = asdl_seq_GET(gens, i);\n        if (!validate_expr(comp->target, Store) ||\n            !validate_expr(comp->iter, Load) ||\n            !validate_exprs(comp->ifs, Load, 0))\n            return 0;\n    }\n    return 1;\n}\n\nstatic int\nvalidate_slice(slice_ty slice)\n{\n    switch (slice->kind) {\n    case Slice_kind:\n        return (!slice->v.Slice.lower || validate_expr(slice->v.Slice.lower, Load)) &&\n            (!slice->v.Slice.upper || validate_expr(slice->v.Slice.upper, Load)) &&\n            (!slice->v.Slice.step || validate_expr(slice->v.Slice.step, Load));\n    case ExtSlice_kind: {\n        Py_ssize_t i;\n        if (!validate_nonempty_seq(slice->v.ExtSlice.dims, \"dims\", \"ExtSlice\"))\n            return 0;\n        for (i = 0; i < asdl_seq_LEN(slice->v.ExtSlice.dims); i++)\n            if (!validate_slice(asdl_seq_GET(slice->v.ExtSlice.dims, i)))\n                return 0;\n        return 1;\n    }\n    case Index_kind:\n        return validate_expr(slice->v.Index.value, Load);\n    default:\n        PyErr_SetString(PyExc_SystemError, \"unknown slice node\");\n        return 0;\n    }\n}\n\nstatic int\nvalidate_keywords(asdl_seq *keywords)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(keywords); i++)\n        if (!validate_expr(((keyword_ty)asdl_seq_GET(keywords, i))->value, Load))\n            return 0;\n    return 1;\n}\n\nstatic int\nvalidate_args(asdl_seq *args)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(args); i++) {\n        arg_ty arg = asdl_seq_GET(args, i);\n        if (arg->annotation && !validate_expr(arg->annotation, Load))\n            return 0;\n    }\n    return 1;\n}\n\nstatic const char *\nexpr_context_name(expr_context_ty ctx)\n{\n    switch (ctx) {\n    case Load:\n        return \"Load\";\n    case Store:\n        return \"Store\";\n    case Del:\n        return \"Del\";\n    case AugLoad:\n        return \"AugLoad\";\n    case AugStore:\n        return \"AugStore\";\n    case Param:\n        return \"Param\";\n    default:\n        Py_UNREACHABLE();\n    }\n}\n\nstatic int\nvalidate_arguments(arguments_ty args)\n{\n    if (!validate_args(args->args))\n        return 0;\n    if (args->vararg && args->vararg->annotation\n        && !validate_expr(args->vararg->annotation, Load)) {\n            return 0;\n    }\n    if (!validate_args(args->kwonlyargs))\n        return 0;\n    if (args->kwarg && args->kwarg->annotation\n        && !validate_expr(args->kwarg->annotation, Load)) {\n            return 0;\n    }\n    if (asdl_seq_LEN(args->defaults) > asdl_seq_LEN(args->args)) {\n        PyErr_SetString(PyExc_ValueError, \"more positional defaults than args on arguments\");\n        return 0;\n    }\n    if (asdl_seq_LEN(args->kw_defaults) != asdl_seq_LEN(args->kwonlyargs)) {\n        PyErr_SetString(PyExc_ValueError, \"length of kwonlyargs is not the same as \"\n                        \"kw_defaults on arguments\");\n        return 0;\n    }\n    return validate_exprs(args->defaults, Load, 0) && validate_exprs(args->kw_defaults, Load, 1);\n}\n\nstatic int\nvalidate_constant(PyObject *value)\n{\n    if (value == Py_None || value == Py_Ellipsis)\n        return 1;\n\n    if (PyLong_CheckExact(value)\n            || PyFloat_CheckExact(value)\n            || PyComplex_CheckExact(value)\n            || PyBool_Check(value)\n            || PyUnicode_CheckExact(value)\n            || PyBytes_CheckExact(value))\n        return 1;\n\n    if (PyTuple_CheckExact(value) || PyFrozenSet_CheckExact(value)) {\n        PyObject *it;\n\n        it = PyObject_GetIter(value);\n        if (it == NULL)\n            return 0;\n\n        while (1) {\n            PyObject *item = PyIter_Next(it);\n            if (item == NULL) {\n                if (PyErr_Occurred()) {\n                    Py_DECREF(it);\n                    return 0;\n                }\n                break;\n            }\n\n            if (!validate_constant(item)) {\n                Py_DECREF(it);\n                Py_DECREF(item);\n                return 0;\n            }\n            Py_DECREF(item);\n        }\n\n        Py_DECREF(it);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int\nvalidate_expr(expr_ty exp, expr_context_ty ctx)\n{\n    int check_ctx = 1;\n    expr_context_ty actual_ctx;\n\n    /* First check expression context. */\n    switch (exp->kind) {\n    case Attribute_kind:\n        actual_ctx = exp->v.Attribute.ctx;\n        break;\n    case Subscript_kind:\n        actual_ctx = exp->v.Subscript.ctx;\n        break;\n    case Starred_kind:\n        actual_ctx = exp->v.Starred.ctx;\n        break;\n    case Name_kind:\n        actual_ctx = exp->v.Name.ctx;\n        break;\n    case List_kind:\n        actual_ctx = exp->v.List.ctx;\n        break;\n    case Tuple_kind:\n        actual_ctx = exp->v.Tuple.ctx;\n        break;\n    default:\n        if (ctx != Load) {\n            PyErr_Format(PyExc_ValueError, \"expression which can't be \"\n                         \"assigned to in %s context\", expr_context_name(ctx));\n            return 0;\n        }\n        check_ctx = 0;\n        /* set actual_ctx to prevent gcc warning */\n        actual_ctx = 0;\n    }\n    if (check_ctx && actual_ctx != ctx) {\n        PyErr_Format(PyExc_ValueError, \"expression must have %s context but has %s instead\",\n                     expr_context_name(ctx), expr_context_name(actual_ctx));\n        return 0;\n    }\n\n    /* Now validate expression. */\n    switch (exp->kind) {\n    case BoolOp_kind:\n        if (asdl_seq_LEN(exp->v.BoolOp.values) < 2) {\n            PyErr_SetString(PyExc_ValueError, \"BoolOp with less than 2 values\");\n            return 0;\n        }\n        return validate_exprs(exp->v.BoolOp.values, Load, 0);\n    case BinOp_kind:\n        return validate_expr(exp->v.BinOp.left, Load) &&\n            validate_expr(exp->v.BinOp.right, Load);\n    case UnaryOp_kind:\n        return validate_expr(exp->v.UnaryOp.operand, Load);\n    case Lambda_kind:\n        return validate_arguments(exp->v.Lambda.args) &&\n            validate_expr(exp->v.Lambda.body, Load);\n    case IfExp_kind:\n        return validate_expr(exp->v.IfExp.test, Load) &&\n            validate_expr(exp->v.IfExp.body, Load) &&\n            validate_expr(exp->v.IfExp.orelse, Load);\n    case Dict_kind:\n        if (asdl_seq_LEN(exp->v.Dict.keys) != asdl_seq_LEN(exp->v.Dict.values)) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"Dict doesn't have the same number of keys as values\");\n            return 0;\n        }\n        /* null_ok=1 for keys expressions to allow dict unpacking to work in\n           dict literals, i.e. ``{**{a:b}}`` */\n        return validate_exprs(exp->v.Dict.keys, Load, /*null_ok=*/ 1) &&\n            validate_exprs(exp->v.Dict.values, Load, /*null_ok=*/ 0);\n    case Set_kind:\n        return validate_exprs(exp->v.Set.elts, Load, 0);\n#define COMP(NAME) \\\n        case NAME ## _kind: \\\n            return validate_comprehension(exp->v.NAME.generators) && \\\n                validate_expr(exp->v.NAME.elt, Load);\n    COMP(ListComp)\n    COMP(SetComp)\n    COMP(GeneratorExp)\n#undef COMP\n    case DictComp_kind:\n        return validate_comprehension(exp->v.DictComp.generators) &&\n            validate_expr(exp->v.DictComp.key, Load) &&\n            validate_expr(exp->v.DictComp.value, Load);\n    case Yield_kind:\n        return !exp->v.Yield.value || validate_expr(exp->v.Yield.value, Load);\n    case YieldFrom_kind:\n        return validate_expr(exp->v.YieldFrom.value, Load);\n    case Await_kind:\n        return validate_expr(exp->v.Await.value, Load);\n    case Compare_kind:\n        if (!asdl_seq_LEN(exp->v.Compare.comparators)) {\n            PyErr_SetString(PyExc_ValueError, \"Compare with no comparators\");\n            return 0;\n        }\n        if (asdl_seq_LEN(exp->v.Compare.comparators) !=\n            asdl_seq_LEN(exp->v.Compare.ops)) {\n            PyErr_SetString(PyExc_ValueError, \"Compare has a different number \"\n                            \"of comparators and operands\");\n            return 0;\n        }\n        return validate_exprs(exp->v.Compare.comparators, Load, 0) &&\n            validate_expr(exp->v.Compare.left, Load);\n    case Call_kind:\n        return validate_expr(exp->v.Call.func, Load) &&\n            validate_exprs(exp->v.Call.args, Load, 0) &&\n            validate_keywords(exp->v.Call.keywords);\n    case Constant_kind:\n        if (!validate_constant(exp->v.Constant.value)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"got an invalid type in Constant: %s\",\n                         Py_TYPE(exp->v.Constant.value)->tp_name);\n            return 0;\n        }\n        return 1;\n    case JoinedStr_kind:\n        return validate_exprs(exp->v.JoinedStr.values, Load, 0);\n    case FormattedValue_kind:\n        if (validate_expr(exp->v.FormattedValue.value, Load) == 0)\n            return 0;\n        if (exp->v.FormattedValue.format_spec)\n            return validate_expr(exp->v.FormattedValue.format_spec, Load);\n        return 1;\n    case Attribute_kind:\n        return validate_expr(exp->v.Attribute.value, Load);\n    case Subscript_kind:\n        return validate_slice(exp->v.Subscript.slice) &&\n            validate_expr(exp->v.Subscript.value, Load);\n    case Starred_kind:\n        return validate_expr(exp->v.Starred.value, ctx);\n    case List_kind:\n        return validate_exprs(exp->v.List.elts, ctx, 0);\n    case Tuple_kind:\n        return validate_exprs(exp->v.Tuple.elts, ctx, 0);\n    case NamedExpr_kind:\n        return validate_expr(exp->v.NamedExpr.value, Load);\n    /* This last case doesn't have any checking. */\n    case Name_kind:\n        return 1;\n    }\n    PyErr_SetString(PyExc_SystemError, \"unexpected expression\");\n    return 0;\n}\n\nstatic int\nvalidate_nonempty_seq(asdl_seq *seq, const char *what, const char *owner)\n{\n    if (asdl_seq_LEN(seq))\n        return 1;\n    PyErr_Format(PyExc_ValueError, \"empty %s on %s\", what, owner);\n    return 0;\n}\n\nstatic int\nvalidate_assignlist(asdl_seq *targets, expr_context_ty ctx)\n{\n    return validate_nonempty_seq(targets, \"targets\", ctx == Del ? \"Delete\" : \"Assign\") &&\n        validate_exprs(targets, ctx, 0);\n}\n\nstatic int\nvalidate_body(asdl_seq *body, const char *owner)\n{\n    return validate_nonempty_seq(body, \"body\", owner) && validate_stmts(body);\n}\n\nstatic int\nvalidate_stmt(stmt_ty stmt)\n{\n    Py_ssize_t i;\n    switch (stmt->kind) {\n    case FunctionDef_kind:\n        return validate_body(stmt->v.FunctionDef.body, \"FunctionDef\") &&\n            validate_arguments(stmt->v.FunctionDef.args) &&\n            validate_exprs(stmt->v.FunctionDef.decorator_list, Load, 0) &&\n            (!stmt->v.FunctionDef.returns ||\n             validate_expr(stmt->v.FunctionDef.returns, Load));\n    case ClassDef_kind:\n        return validate_body(stmt->v.ClassDef.body, \"ClassDef\") &&\n            validate_exprs(stmt->v.ClassDef.bases, Load, 0) &&\n            validate_keywords(stmt->v.ClassDef.keywords) &&\n            validate_exprs(stmt->v.ClassDef.decorator_list, Load, 0);\n    case Return_kind:\n        return !stmt->v.Return.value || validate_expr(stmt->v.Return.value, Load);\n    case Delete_kind:\n        return validate_assignlist(stmt->v.Delete.targets, Del);\n    case Assign_kind:\n        return validate_assignlist(stmt->v.Assign.targets, Store) &&\n            validate_expr(stmt->v.Assign.value, Load);\n    case AugAssign_kind:\n        return validate_expr(stmt->v.AugAssign.target, Store) &&\n            validate_expr(stmt->v.AugAssign.value, Load);\n    case AnnAssign_kind:\n        if (stmt->v.AnnAssign.target->kind != Name_kind &&\n            stmt->v.AnnAssign.simple) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"AnnAssign with simple non-Name target\");\n            return 0;\n        }\n        return validate_expr(stmt->v.AnnAssign.target, Store) &&\n               (!stmt->v.AnnAssign.value ||\n                validate_expr(stmt->v.AnnAssign.value, Load)) &&\n               validate_expr(stmt->v.AnnAssign.annotation, Load);\n    case For_kind:\n        return validate_expr(stmt->v.For.target, Store) &&\n            validate_expr(stmt->v.For.iter, Load) &&\n            validate_body(stmt->v.For.body, \"For\") &&\n            validate_stmts(stmt->v.For.orelse);\n    case AsyncFor_kind:\n        return validate_expr(stmt->v.AsyncFor.target, Store) &&\n            validate_expr(stmt->v.AsyncFor.iter, Load) &&\n            validate_body(stmt->v.AsyncFor.body, \"AsyncFor\") &&\n            validate_stmts(stmt->v.AsyncFor.orelse);\n    case While_kind:\n        return validate_expr(stmt->v.While.test, Load) &&\n            validate_body(stmt->v.While.body, \"While\") &&\n            validate_stmts(stmt->v.While.orelse);\n    case If_kind:\n        return validate_expr(stmt->v.If.test, Load) &&\n            validate_body(stmt->v.If.body, \"If\") &&\n            validate_stmts(stmt->v.If.orelse);\n    case With_kind:\n        if (!validate_nonempty_seq(stmt->v.With.items, \"items\", \"With\"))\n            return 0;\n        for (i = 0; i < asdl_seq_LEN(stmt->v.With.items); i++) {\n            withitem_ty item = asdl_seq_GET(stmt->v.With.items, i);\n            if (!validate_expr(item->context_expr, Load) ||\n                (item->optional_vars && !validate_expr(item->optional_vars, Store)))\n                return 0;\n        }\n        return validate_body(stmt->v.With.body, \"With\");\n    case AsyncWith_kind:\n        if (!validate_nonempty_seq(stmt->v.AsyncWith.items, \"items\", \"AsyncWith\"))\n            return 0;\n        for (i = 0; i < asdl_seq_LEN(stmt->v.AsyncWith.items); i++) {\n            withitem_ty item = asdl_seq_GET(stmt->v.AsyncWith.items, i);\n            if (!validate_expr(item->context_expr, Load) ||\n                (item->optional_vars && !validate_expr(item->optional_vars, Store)))\n                return 0;\n        }\n        return validate_body(stmt->v.AsyncWith.body, \"AsyncWith\");\n    case Raise_kind:\n        if (stmt->v.Raise.exc) {\n            return validate_expr(stmt->v.Raise.exc, Load) &&\n                (!stmt->v.Raise.cause || validate_expr(stmt->v.Raise.cause, Load));\n        }\n        if (stmt->v.Raise.cause) {\n            PyErr_SetString(PyExc_ValueError, \"Raise with cause but no exception\");\n            return 0;\n        }\n        return 1;\n    case Try_kind:\n        if (!validate_body(stmt->v.Try.body, \"Try\"))\n            return 0;\n        if (!asdl_seq_LEN(stmt->v.Try.handlers) &&\n            !asdl_seq_LEN(stmt->v.Try.finalbody)) {\n            PyErr_SetString(PyExc_ValueError, \"Try has neither except handlers nor finalbody\");\n            return 0;\n        }\n        if (!asdl_seq_LEN(stmt->v.Try.handlers) &&\n            asdl_seq_LEN(stmt->v.Try.orelse)) {\n            PyErr_SetString(PyExc_ValueError, \"Try has orelse but no except handlers\");\n            return 0;\n        }\n        for (i = 0; i < asdl_seq_LEN(stmt->v.Try.handlers); i++) {\n            excepthandler_ty handler = asdl_seq_GET(stmt->v.Try.handlers, i);\n            if ((handler->v.ExceptHandler.type &&\n                 !validate_expr(handler->v.ExceptHandler.type, Load)) ||\n                !validate_body(handler->v.ExceptHandler.body, \"ExceptHandler\"))\n                return 0;\n        }\n        return (!asdl_seq_LEN(stmt->v.Try.finalbody) ||\n                validate_stmts(stmt->v.Try.finalbody)) &&\n            (!asdl_seq_LEN(stmt->v.Try.orelse) ||\n             validate_stmts(stmt->v.Try.orelse));\n    case Assert_kind:\n        return validate_expr(stmt->v.Assert.test, Load) &&\n            (!stmt->v.Assert.msg || validate_expr(stmt->v.Assert.msg, Load));\n    case Import_kind:\n        return validate_nonempty_seq(stmt->v.Import.names, \"names\", \"Import\");\n    case ImportFrom_kind:\n        if (stmt->v.ImportFrom.level < 0) {\n            PyErr_SetString(PyExc_ValueError, \"Negative ImportFrom level\");\n            return 0;\n        }\n        return validate_nonempty_seq(stmt->v.ImportFrom.names, \"names\", \"ImportFrom\");\n    case Global_kind:\n        return validate_nonempty_seq(stmt->v.Global.names, \"names\", \"Global\");\n    case Nonlocal_kind:\n        return validate_nonempty_seq(stmt->v.Nonlocal.names, \"names\", \"Nonlocal\");\n    case Expr_kind:\n        return validate_expr(stmt->v.Expr.value, Load);\n    case AsyncFunctionDef_kind:\n        return validate_body(stmt->v.AsyncFunctionDef.body, \"AsyncFunctionDef\") &&\n            validate_arguments(stmt->v.AsyncFunctionDef.args) &&\n            validate_exprs(stmt->v.AsyncFunctionDef.decorator_list, Load, 0) &&\n            (!stmt->v.AsyncFunctionDef.returns ||\n             validate_expr(stmt->v.AsyncFunctionDef.returns, Load));\n    case Pass_kind:\n    case Break_kind:\n    case Continue_kind:\n        return 1;\n    default:\n        PyErr_SetString(PyExc_SystemError, \"unexpected statement\");\n        return 0;\n    }\n}\n\nstatic int\nvalidate_stmts(asdl_seq *seq)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(seq); i++) {\n        stmt_ty stmt = asdl_seq_GET(seq, i);\n        if (stmt) {\n            if (!validate_stmt(stmt))\n                return 0;\n        }\n        else {\n            PyErr_SetString(PyExc_ValueError,\n                            \"None disallowed in statement list\");\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int\nvalidate_exprs(asdl_seq *exprs, expr_context_ty ctx, int null_ok)\n{\n    Py_ssize_t i;\n    for (i = 0; i < asdl_seq_LEN(exprs); i++) {\n        expr_ty expr = asdl_seq_GET(exprs, i);\n        if (expr) {\n            if (!validate_expr(expr, ctx))\n                return 0;\n        }\n        else if (!null_ok) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"None disallowed in expression list\");\n            return 0;\n        }\n\n    }\n    return 1;\n}\n\nint\nPyAST_Validate(mod_ty mod)\n{\n    int res = 0;\n\n    switch (mod->kind) {\n    case Module_kind:\n        res = validate_stmts(mod->v.Module.body);\n        break;\n    case Interactive_kind:\n        res = validate_stmts(mod->v.Interactive.body);\n        break;\n    case Expression_kind:\n        res = validate_expr(mod->v.Expression.body, Load);\n        break;\n    case Suite_kind:\n        PyErr_SetString(PyExc_ValueError, \"Suite is not valid in the CPython compiler\");\n        break;\n    default:\n        PyErr_SetString(PyExc_SystemError, \"impossible module node\");\n        res = 0;\n        break;\n    }\n    return res;\n}\n\n/* This is done here, so defines like \"test\" don't interfere with AST use above. */\n#include \"grammar.h\"\n#include \"parsetok.h\"\n#include \"graminit.h\"\n\n/* Data structure used internally */\nstruct compiling {\n    PyArena *c_arena; /* Arena for allocating memory. */\n    PyObject *c_filename; /* filename */\n    PyObject *c_normalize; /* Normalization function from unicodedata. */\n    int c_feature_version; /* Latest minor version of Python for allowed features */\n};\n\nstatic asdl_seq *seq_for_testlist(struct compiling *, const node *);\nstatic expr_ty ast_for_expr(struct compiling *, const node *);\nstatic stmt_ty ast_for_stmt(struct compiling *, const node *);\nstatic asdl_seq *ast_for_suite(struct compiling *c, const node *n);\nstatic asdl_seq *ast_for_exprlist(struct compiling *, const node *,\n                                  expr_context_ty);\nstatic expr_ty ast_for_testlist(struct compiling *, const node *);\nstatic stmt_ty ast_for_classdef(struct compiling *, const node *, asdl_seq *);\n\nstatic stmt_ty ast_for_with_stmt(struct compiling *, const node *, bool);\nstatic stmt_ty ast_for_for_stmt(struct compiling *, const node *, bool);\n\n/* Note different signature for ast_for_call */\nstatic expr_ty ast_for_call(struct compiling *, const node *, expr_ty,\n                            const node *, const node *);\n\nstatic PyObject *parsenumber(struct compiling *, const char *);\nstatic expr_ty parsestrplus(struct compiling *, const node *n);\nstatic void get_last_end_pos(asdl_seq *, int *, int *);\n\n#define COMP_GENEXP   0\n#define COMP_LISTCOMP 1\n#define COMP_SETCOMP  2\n\nstatic int\ninit_normalization(struct compiling *c)\n{\n    PyObject *m = PyImport_ImportModuleNoBlock(\"unicodedata\");\n    if (!m)\n        return 0;\n    c->c_normalize = PyObject_GetAttrString(m, \"normalize\");\n    Py_DECREF(m);\n    if (!c->c_normalize)\n        return 0;\n    return 1;\n}\n\nstatic identifier\nnew_identifier(const char *n, struct compiling *c)\n{\n    PyObject *id = PyUnicode_DecodeUTF8(n, strlen(n), NULL);\n    if (!id)\n        return NULL;\n    /* PyUnicode_DecodeUTF8 should always return a ready string. */\n    assert(PyUnicode_IS_READY(id));\n    /* Check whether there are non-ASCII characters in the\n       identifier; if so, normalize to NFKC. */\n    if (!PyUnicode_IS_ASCII(id)) {\n        PyObject *id2;\n        _Py_IDENTIFIER(NFKC);\n        if (!c->c_normalize && !init_normalization(c)) {\n            Py_DECREF(id);\n            return NULL;\n        }\n        PyObject *form = _PyUnicode_FromId(&PyId_NFKC);\n        if (form == NULL) {\n            Py_DECREF(id);\n            return NULL;\n        }\n        PyObject *args[2] = {form, id};\n        id2 = _PyObject_FastCall(c->c_normalize, args, 2);\n        Py_DECREF(id);\n        if (!id2)\n            return NULL;\n        if (!PyUnicode_Check(id2)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"unicodedata.normalize() must return a string, not \"\n                         \"%.200s\",\n                         Py_TYPE(id2)->tp_name);\n            Py_DECREF(id2);\n            return NULL;\n        }\n        id = id2;\n    }\n    PyUnicode_InternInPlace(&id);\n    if (PyArena_AddPyObject(c->c_arena, id) < 0) {\n        Py_DECREF(id);\n        return NULL;\n    }\n    return id;\n}\n\n#define NEW_IDENTIFIER(n) new_identifier(STR(n), c)\n\nstatic int\nast_error(struct compiling *c, const node *n, const char *errmsg, ...)\n{\n    PyObject *value, *errstr, *loc, *tmp;\n    va_list va;\n\n    va_start(va, errmsg);\n    errstr = PyUnicode_FromFormatV(errmsg, va);\n    va_end(va);\n    if (!errstr) {\n        return 0;\n    }\n    loc = PyErr_ProgramTextObject(c->c_filename, LINENO(n));\n    if (!loc) {\n        Py_INCREF(Py_None);\n        loc = Py_None;\n    }\n    tmp = Py_BuildValue(\"(OiiN)\", c->c_filename, LINENO(n), n->n_col_offset + 1, loc);\n    if (!tmp) {\n        Py_DECREF(errstr);\n        return 0;\n    }\n    value = PyTuple_Pack(2, errstr, tmp);\n    Py_DECREF(errstr);\n    Py_DECREF(tmp);\n    if (value) {\n        PyErr_SetObject(PyExc_SyntaxError, value);\n        Py_DECREF(value);\n    }\n    return 0;\n}\n\n/* num_stmts() returns number of contained statements.\n\n   Use this routine to determine how big a sequence is needed for\n   the statements in a parse tree.  Its raison d'etre is this bit of\n   grammar:\n\n   stmt: simple_stmt | compound_stmt\n   simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\n\n   A simple_stmt can contain multiple small_stmt elements joined\n   by semicolons.  If the arg is a simple_stmt, the number of\n   small_stmt elements is returned.\n*/\n\nstatic string\nnew_type_comment(const char *s, struct compiling *c)\n{\n    PyObject *res = PyUnicode_DecodeUTF8(s, strlen(s), NULL);\n    if (res == NULL)\n        return NULL;\n    if (PyArena_AddPyObject(c->c_arena, res) < 0) {\n        Py_DECREF(res);\n        return NULL;\n    }\n    return res;\n}\n#define NEW_TYPE_COMMENT(n) new_type_comment(STR(n), c)\n\nstatic int\nnum_stmts(const node *n)\n{\n    int i, l;\n    node *ch;\n\n    switch (TYPE(n)) {\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE)\n                return 0;\n            else\n                return num_stmts(CHILD(n, 0));\n        case file_input:\n            l = 0;\n            for (i = 0; i < NCH(n); i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == stmt)\n                    l += num_stmts(ch);\n            }\n            return l;\n        case stmt:\n            return num_stmts(CHILD(n, 0));\n        case compound_stmt:\n            return 1;\n        case simple_stmt:\n            return NCH(n) / 2; /* Divide by 2 to remove count of semi-colons */\n        case suite:\n        case func_body_suite:\n            /* func_body_suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */\n            /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n            if (NCH(n) == 1)\n                return num_stmts(CHILD(n, 0));\n            else {\n                i = 2;\n                l = 0;\n                if (TYPE(CHILD(n, 1)) == TYPE_COMMENT)\n                    i += 2;\n                for (; i < (NCH(n) - 1); i++)\n                    l += num_stmts(CHILD(n, i));\n                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    Py_UNREACHABLE();\n}\n\n/* Transform the CST rooted at node * to the appropriate AST\n*/\n\nmod_ty\nPyAST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                     PyObject *filename, PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n    node *ch;\n    struct compiling c;\n    mod_ty res = NULL;\n    asdl_seq *argtypes = NULL;\n    expr_ty ret, arg;\n\n    c.c_arena = arena;\n    /* borrowed reference */\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_feature_version = flags->cf_feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n    k = 0;\n    switch (TYPE(n)) {\n        case file_input:\n            stmts = _Py_asdl_seq_new(num_stmts(n), arena);\n            if (!stmts)\n                goto out;\n            for (i = 0; i < NCH(n) - 1; i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == NEWLINE)\n                    continue;\n                REQ(ch, stmt);\n                num = num_stmts(ch);\n                if (num == 1) {\n                    s = ast_for_stmt(&c, ch);\n                    if (!s)\n                        goto out;\n                    asdl_seq_SET(stmts, k++, s);\n                }\n                else {\n                    ch = CHILD(ch, 0);\n                    REQ(ch, simple_stmt);\n                    for (j = 0; j < num; j++) {\n                        s = ast_for_stmt(&c, CHILD(ch, j * 2));\n                        if (!s)\n                            goto out;\n                        asdl_seq_SET(stmts, k++, s);\n                    }\n                }\n            }\n\n            /* Type ignores are stored under the ENDMARKER in file_input. */\n            ch = CHILD(n, NCH(n) - 1);\n            REQ(ch, ENDMARKER);\n            num = NCH(ch);\n            type_ignores = _Py_asdl_seq_new(num, arena);\n            if (!type_ignores)\n                goto out;\n\n            for (i = 0; i < num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                   goto out;\n               asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n            expr_ty testlist_ast;\n\n            /* XXX Why not comp_for here? */\n            testlist_ast = ast_for_testlist(&c, CHILD(n, 0));\n            if (!testlist_ast)\n                goto out;\n            res = Expression(testlist_ast, arena);\n            break;\n        }\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE) {\n                stmts = _Py_asdl_seq_new(1, arena);\n                if (!stmts)\n                    goto out;\n                asdl_seq_SET(stmts, 0, Pass(n->n_lineno, n->n_col_offset,\n                                            n->n_end_lineno, n->n_end_col_offset,\n                                            arena));\n                if (!asdl_seq_GET(stmts, 0))\n                    goto out;\n                res = Interactive(stmts, arena);\n            }\n            else {\n                n = CHILD(n, 0);\n                num = num_stmts(n);\n                stmts = _Py_asdl_seq_new(num, arena);\n                if (!stmts)\n                    goto out;\n                if (num == 1) {\n                    s = ast_for_stmt(&c, n);\n                    if (!s)\n                        goto out;\n                    asdl_seq_SET(stmts, 0, s);\n                }\n                else {\n                    /* Only a simple_stmt can contain multiple statements. */\n                    REQ(n, simple_stmt);\n                    for (i = 0; i < NCH(n); i += 2) {\n                        if (TYPE(CHILD(n, i)) == NEWLINE)\n                            break;\n                        s = ast_for_stmt(&c, CHILD(n, i));\n                        if (!s)\n                            goto out;\n                        asdl_seq_SET(stmts, i / 2, s);\n                    }\n                }\n\n                res = Interactive(stmts, arena);\n            }\n            break;\n        case func_type_input:\n            n = CHILD(n, 0);\n            REQ(n, func_type);\n\n            if (TYPE(CHILD(n, 1)) == typelist) {\n                ch = CHILD(n, 1);\n                /* this is overly permissive -- we don't pay any attention to\n                 * stars on the args -- just parse them into an ordered list */\n                num = 0;\n                for (i = 0; i < NCH(ch); i++) {\n                    if (TYPE(CHILD(ch, i)) == test) {\n                        num++;\n                    }\n                }\n\n                argtypes = _Py_asdl_seq_new(num, arena);\n                if (!argtypes)\n                    goto out;\n\n                j = 0;\n                for (i = 0; i < NCH(ch); i++) {\n                    if (TYPE(CHILD(ch, i)) == test) {\n                        arg = ast_for_expr(&c, CHILD(ch, i));\n                        if (!arg)\n                            goto out;\n                        asdl_seq_SET(argtypes, j++, arg);\n                    }\n                }\n            }\n            else {\n                argtypes = _Py_asdl_seq_new(0, arena);\n                if (!argtypes)\n                    goto out;\n            }\n\n            ret = ast_for_expr(&c, CHILD(n, NCH(n) - 1));\n            if (!ret)\n                goto out;\n            res = FunctionType(argtypes, ret, arena);\n            break;\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid node %d for PyAST_FromNode\", TYPE(n));\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n    }\n    return res;\n}\n\nmod_ty\nPyAST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n               PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)\n        return NULL;\n    mod = PyAST_FromNodeObject(n, flags, filename, arena);\n    Py_DECREF(filename);\n    return mod;\n\n}\n\n/* Return the AST repr. of the operator represented as syntax (|, ^, etc.)\n*/\n\nstatic operator_ty\nget_operator(struct compiling *c, const node *n)\n{\n    switch (TYPE(n)) {\n        case VBAR:\n            return BitOr;\n        case CIRCUMFLEX:\n            return BitXor;\n        case AMPER:\n            return BitAnd;\n        case LEFTSHIFT:\n            return LShift;\n        case RIGHTSHIFT:\n            return RShift;\n        case PLUS:\n            return Add;\n        case MINUS:\n            return Sub;\n        case STAR:\n            return Mult;\n        case AT:\n            if (c->c_feature_version < 5) {\n                ast_error(c, n,\n                          \"The '@' operator is only supported in Python 3.5 and greater\");\n                return (operator_ty)0;\n            }\n            return MatMult;\n        case SLASH:\n            return Div;\n        case DOUBLESLASH:\n            return FloorDiv;\n        case PERCENT:\n            return Mod;\n        default:\n            return (operator_ty)0;\n    }\n}\n\nstatic const char * const FORBIDDEN[] = {\n    \"None\",\n    \"True\",\n    \"False\",\n    \"__debug__\",\n    NULL,\n};\n\nstatic int\nforbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    const char * const *p = FORBIDDEN;\n    if (!full_checks) {\n        /* In most cases, the parser will protect True, False, and None\n           from being assign to. */\n        p += 3;\n    }\n    for (; *p; p++) {\n        if (_PyUnicode_EqualToASCIIString(name, *p)) {\n            ast_error(c, n, \"cannot assign to %U\", name);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic expr_ty\ncopy_location(expr_ty e, const node *n)\n{\n    if (e) {\n        e->lineno = LINENO(n);\n        e->col_offset = n->n_col_offset;\n        e->end_lineno = n->n_end_lineno;\n        e->end_col_offset = n->n_end_col_offset;\n    }\n    return e;\n}\n\nstatic const char *\nget_expr_name(expr_ty e)\n{\n    switch (e->kind) {\n        case Attribute_kind:\n            return \"attribute\";\n        case Subscript_kind:\n            return \"subscript\";\n        case Starred_kind:\n            return \"starred\";\n        case Name_kind:\n            return \"name\";\n        case List_kind:\n            return \"list\";\n        case Tuple_kind:\n            return \"tuple\";\n        case Lambda_kind:\n            return \"lambda\";\n        case Call_kind:\n            return \"function call\";\n        case BoolOp_kind:\n        case BinOp_kind:\n        case UnaryOp_kind:\n            return \"operator\";\n        case GeneratorExp_kind:\n            return \"generator expression\";\n        case Yield_kind:\n        case YieldFrom_kind:\n            return \"yield expression\";\n        case Await_kind:\n            return \"await expression\";\n        case ListComp_kind:\n            return \"list comprehension\";\n        case SetComp_kind:\n            return \"set comprehension\";\n        case DictComp_kind:\n            return \"dict comprehension\";\n        case Dict_kind:\n            return \"dict display\";\n        case Set_kind:\n            return \"set display\";\n        case JoinedStr_kind:\n        case FormattedValue_kind:\n            return \"f-string expression\";\n        case Constant_kind: {\n            PyObject *value = e->v.Constant.value;\n            if (value == Py_None) {\n                return \"None\";\n            }\n            if (value == Py_False) {\n                return \"False\";\n            }\n            if (value == Py_True) {\n                return \"True\";\n            }\n            if (value == Py_Ellipsis) {\n                return \"Ellipsis\";\n            }\n            return \"literal\";\n        }\n        case Compare_kind:\n            return \"comparison\";\n        case IfExp_kind:\n            return \"conditional expression\";\n        case NamedExpr_kind:\n            return \"named expression\";\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"unexpected expression in assignment %d (line %d)\",\n                         e->kind, e->lineno);\n            return NULL;\n    }\n}\n\n/* Set the context ctx for expr_ty e, recursively traversing e.\n\n   Only sets context for expr kinds that \"can appear in assignment context\"\n   (according to ../Parser/Python.asdl).  For other expr kinds, it sets\n   an appropriate syntax error and returns false.\n*/\n\nstatic int\nset_context(struct compiling *c, expr_ty e, expr_context_ty ctx, const node *n)\n{\n    asdl_seq *s = NULL;\n\n    /* The ast defines augmented store and load contexts, but the\n       implementation here doesn't actually use them.  The code may be\n       a little more complex than necessary as a result.  It also means\n       that expressions in an augmented assignment have a Store context.\n       Consider restructuring so that augmented assignment uses\n       set_context(), too.\n    */\n    assert(ctx != AugStore && ctx != AugLoad);\n\n    switch (e->kind) {\n        case Attribute_kind:\n            e->v.Attribute.ctx = ctx;\n            if (ctx == Store && forbidden_name(c, e->v.Attribute.attr, n, 1))\n                return 0;\n            break;\n        case Subscript_kind:\n            e->v.Subscript.ctx = ctx;\n            break;\n        case Starred_kind:\n            e->v.Starred.ctx = ctx;\n            if (!set_context(c, e->v.Starred.value, ctx, n))\n                return 0;\n            break;\n        case Name_kind:\n            if (ctx == Store) {\n                if (forbidden_name(c, e->v.Name.id, n, 0))\n                    return 0; /* forbidden_name() calls ast_error() */\n            }\n            e->v.Name.ctx = ctx;\n            break;\n        case List_kind:\n            e->v.List.ctx = ctx;\n            s = e->v.List.elts;\n            break;\n        case Tuple_kind:\n            e->v.Tuple.ctx = ctx;\n            s = e->v.Tuple.elts;\n            break;\n        default: {\n            const char *expr_name = get_expr_name(e);\n            if (expr_name != NULL) {\n                ast_error(c, n, \"cannot %s %s\",\n                          ctx == Store ? \"assign to\" : \"delete\",\n                          expr_name);\n            }\n            return 0;\n        }\n    }\n\n    /* If the LHS is a list or tuple, we need to set the assignment\n       context for all the contained elements.\n    */\n    if (s) {\n        Py_ssize_t i;\n\n        for (i = 0; i < asdl_seq_LEN(s); i++) {\n            if (!set_context(c, (expr_ty)asdl_seq_GET(s, i), ctx, n))\n                return 0;\n        }\n    }\n    return 1;\n}\n\nstatic operator_ty\nast_for_augassign(struct compiling *c, const node *n)\n{\n    REQ(n, augassign);\n    n = CHILD(n, 0);\n    switch (STR(n)[0]) {\n        case '+':\n            return Add;\n        case '-':\n            return Sub;\n        case '/':\n            if (STR(n)[1] == '/')\n                return FloorDiv;\n            else\n                return Div;\n        case '%':\n            return Mod;\n        case '<':\n            return LShift;\n        case '>':\n            return RShift;\n        case '&':\n            return BitAnd;\n        case '^':\n            return BitXor;\n        case '|':\n            return BitOr;\n        case '*':\n            if (STR(n)[1] == '*')\n                return Pow;\n            else\n                return Mult;\n        case '@':\n            if (c->c_feature_version < 5) {\n                ast_error(c, n,\n                          \"The '@' operator is only supported in Python 3.5 and greater\");\n                return (operator_ty)0;\n            }\n            return MatMult;\n        default:\n            PyErr_Format(PyExc_SystemError, \"invalid augassign: %s\", STR(n));\n            return (operator_ty)0;\n    }\n}\n\nstatic cmpop_ty\nast_for_comp_op(struct compiling *c, const node *n)\n{\n    /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'\n               |'is' 'not'\n    */\n    REQ(n, comp_op);\n    if (NCH(n) == 1) {\n        n = CHILD(n, 0);\n        switch (TYPE(n)) {\n            case LESS:\n                return Lt;\n            case GREATER:\n                return Gt;\n            case EQEQUAL:                       /* == */\n                return Eq;\n            case LESSEQUAL:\n                return LtE;\n            case GREATEREQUAL:\n                return GtE;\n            case NOTEQUAL:\n                return NotEq;\n            case NAME:\n                if (strcmp(STR(n), \"in\") == 0)\n                    return In;\n                if (strcmp(STR(n), \"is\") == 0)\n                    return Is;\n                /* fall through */\n            default:\n                PyErr_Format(PyExc_SystemError, \"invalid comp_op: %s\",\n                             STR(n));\n                return (cmpop_ty)0;\n        }\n    }\n    else if (NCH(n) == 2) {\n        /* handle \"not in\" and \"is not\" */\n        switch (TYPE(CHILD(n, 0))) {\n            case NAME:\n                if (strcmp(STR(CHILD(n, 1)), \"in\") == 0)\n                    return NotIn;\n                if (strcmp(STR(CHILD(n, 0)), \"is\") == 0)\n                    return IsNot;\n                /* fall through */\n            default:\n                PyErr_Format(PyExc_SystemError, \"invalid comp_op: %s %s\",\n                             STR(CHILD(n, 0)), STR(CHILD(n, 1)));\n                return (cmpop_ty)0;\n        }\n    }\n    PyErr_Format(PyExc_SystemError, \"invalid comp_op: has %d children\",\n                 NCH(n));\n    return (cmpop_ty)0;\n}\n\nstatic asdl_seq *\nseq_for_testlist(struct compiling *c, const node *n)\n{\n    /* testlist: test (',' test)* [',']\n       testlist_star_expr: test|star_expr (',' test|star_expr)* [',']\n    */\n    asdl_seq *seq;\n    expr_ty expression;\n    int i;\n    assert(TYPE(n) == testlist || TYPE(n) == testlist_star_expr || TYPE(n) == testlist_comp);\n\n    seq = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n    if (!seq)\n        return NULL;\n\n    for (i = 0; i < NCH(n); i += 2) {\n        const node *ch = CHILD(n, i);\n        assert(TYPE(ch) == test || TYPE(ch) == test_nocond || TYPE(ch) == star_expr || TYPE(ch) == namedexpr_test);\n\n        expression = ast_for_expr(c, ch);\n        if (!expression)\n            return NULL;\n\n        assert(i / 2 < seq->size);\n        asdl_seq_SET(seq, i / 2, expression);\n    }\n    return seq;\n}\n\nstatic arg_ty\nast_for_arg(struct compiling *c, const node *n)\n{\n    identifier name;\n    expr_ty annotation = NULL;\n    node *ch;\n    arg_ty ret;\n\n    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);\n    ch = CHILD(n, 0);\n    name = NEW_IDENTIFIER(ch);\n    if (!name)\n        return NULL;\n    if (forbidden_name(c, name, ch, 0))\n        return NULL;\n\n    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {\n        annotation = ast_for_expr(c, CHILD(n, 2));\n        if (!annotation)\n            return NULL;\n    }\n\n    ret = arg(name, annotation, NULL, LINENO(n), n->n_col_offset,\n              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    if (!ret)\n        return NULL;\n    return ret;\n}\n\n/* returns -1 if failed to handle keyword only arguments\n   returns new position to keep processing if successful\n               (',' tfpdef ['=' test])*\n                     ^^^\n   start pointing here\n */\nstatic int\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; /* '=' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME ':' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}\n\n/* Create AST for argument list. */\n\nstatic arguments_ty\nast_for_arguments(struct compiling *c, const node *n)\n{\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) /* () as argument list */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    /* First count the number of positional args & defaults.  The\n       variable i is the loop index for this for loop and the next.\n       The next loop picks up where the first leaves off.\n    */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            /* skip star */\n            i++;\n            if (i < NCH(n) && /* skip argument following star */\n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    /* count the number of keyword only args &\n       defaults for keyword only args */\n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Py_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Py_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Py_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    /* The length of kwonlyargs and kwdefaults are same\n       since we set NULL as default for keyword only argument w/o default\n       - we have sequence data structure, but no dictionary */\n    kwdefaults = (nkwonlyargs ?\n                   _Py_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                              \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                              \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; /* now follows keyword only arguments */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                  \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; /* res has new position to process */\n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                i += 2; /* the star and the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; /* res has new position to process */\n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}\n\nstatic expr_ty\nast_for_dotted_name(struct compiling *c, const node *n)\n{\n    expr_ty e;\n    identifier id;\n    int lineno, col_offset;\n    int i;\n    node *ch;\n\n    REQ(n, dotted_name);\n\n    lineno = LINENO(n);\n    col_offset = n->n_col_offset;\n\n    ch = CHILD(n, 0);\n    id = NEW_IDENTIFIER(ch);\n    if (!id)\n        return NULL;\n    e = Name(id, Load, lineno, col_offset,\n             ch->n_end_lineno, ch->n_end_col_offset, c->c_arena);\n    if (!e)\n        return NULL;\n\n    for (i = 2; i < NCH(n); i+=2) {\n        id = NEW_IDENTIFIER(CHILD(n, i));\n        if (!id)\n            return NULL;\n        e = Attribute(e, id, Load, lineno, col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        if (!e)\n            return NULL;\n    }\n\n    return e;\n}\n\nstatic expr_ty\nast_for_decorator(struct compiling *c, const node *n)\n{\n    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\n    expr_ty d = NULL;\n    expr_ty name_expr;\n\n    REQ(n, decorator);\n    REQ(CHILD(n, 0), AT);\n    REQ(RCHILD(n, -1), NEWLINE);\n\n    name_expr = ast_for_dotted_name(c, CHILD(n, 1));\n    if (!name_expr)\n        return NULL;\n\n    if (NCH(n) == 3) { /* No arguments */\n        d = name_expr;\n        name_expr = NULL;\n    }\n    else if (NCH(n) == 5) { /* Call with no arguments */\n        d = Call(name_expr, NULL, NULL, LINENO(n),\n                 n->n_col_offset, n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        if (!d)\n            return NULL;\n        name_expr = NULL;\n    }\n    else {\n        d = ast_for_call(c, CHILD(n, 3), name_expr, CHILD(n, 2), CHILD(n, 4));\n        if (!d)\n            return NULL;\n        name_expr = NULL;\n    }\n\n    return d;\n}\n\nstatic asdl_seq*\nast_for_decorators(struct compiling *c, const node *n)\n{\n    asdl_seq* decorator_seq;\n    expr_ty d;\n    int i;\n\n    REQ(n, decorators);\n    decorator_seq = _Py_asdl_seq_new(NCH(n), c->c_arena);\n    if (!decorator_seq)\n        return NULL;\n\n    for (i = 0; i < NCH(n); i++) {\n        d = ast_for_decorator(c, CHILD(n, i));\n        if (!d)\n            return NULL;\n        asdl_seq_SET(decorator_seq, i, d);\n    }\n    return decorator_seq;\n}\n\nstatic stmt_ty\nast_for_funcdef_impl(struct compiling *c, const node *n0,\n                     asdl_seq *decorator_seq, bool is_async)\n{\n    /* funcdef: 'def' NAME parameters ['->' test] ':' [TYPE_COMMENT] suite */\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    identifier name;\n    arguments_ty args;\n    asdl_seq *body;\n    expr_ty returns = NULL;\n    int name_i = 1;\n    int end_lineno, end_col_offset;\n    node *tc;\n    string type_comment = NULL;\n\n    if (is_async && c->c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async functions are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    REQ(n, funcdef);\n\n    name = NEW_IDENTIFIER(CHILD(n, name_i));\n    if (!name)\n        return NULL;\n    if (forbidden_name(c, name, CHILD(n, name_i), 0))\n        return NULL;\n    args = ast_for_arguments(c, CHILD(n, name_i + 1));\n    if (!args)\n        return NULL;\n    if (TYPE(CHILD(n, name_i+2)) == RARROW) {\n        returns = ast_for_expr(c, CHILD(n, name_i + 3));\n        if (!returns)\n            return NULL;\n        name_i += 2;\n    }\n    if (TYPE(CHILD(n, name_i + 3)) == TYPE_COMMENT) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, name_i + 3));\n        if (!type_comment)\n            return NULL;\n        name_i += 1;\n    }\n    body = ast_for_suite(c, CHILD(n, name_i + 3));\n    if (!body)\n        return NULL;\n    get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (NCH(CHILD(n, name_i + 3)) > 1) {\n        /* Check if the suite has a type comment in it. */\n        tc = CHILD(CHILD(n, name_i + 3), 1);\n\n        if (TYPE(tc) == TYPE_COMMENT) {\n            if (type_comment != NULL) {\n                ast_error(c, n, \"Cannot have two type comments on def\");\n                return NULL;\n            }\n            type_comment = NEW_TYPE_COMMENT(tc);\n            if (!type_comment)\n                return NULL;\n        }\n    }\n\n    if (is_async)\n        return AsyncFunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                                LINENO(n0), n0->n_col_offset, end_lineno, end_col_offset, c->c_arena);\n    else\n        return FunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                           LINENO(n), n->n_col_offset, end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: ASYNC funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), ASYNC);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}\n\nstatic stmt_ty\nast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* funcdef: 'def' NAME parameters ['->' test] ':' suite */\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                false /* is_async */);\n}\n\n\nstatic stmt_ty\nast_for_async_stmt(struct compiling *c, const node *n)\n{\n    /* async_stmt: ASYNC (funcdef | with_stmt | for_stmt) */\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), ASYNC);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, n, NULL,\n                                        true /* is_async */);\n        case with_stmt:\n            return ast_for_with_stmt(c, n,\n                                     true /* is_async */);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, n,\n                                    true /* is_async */);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}\n\nstatic stmt_ty\nast_for_decorated(struct compiling *c, const node *n)\n{\n    /* decorated: decorators (classdef | funcdef | async_funcdef) */\n    stmt_ty thing = NULL;\n    asdl_seq *decorator_seq = NULL;\n\n    REQ(n, decorated);\n\n    decorator_seq = ast_for_decorators(c, CHILD(n, 0));\n    if (!decorator_seq)\n      return NULL;\n\n    assert(TYPE(CHILD(n, 1)) == funcdef ||\n           TYPE(CHILD(n, 1)) == async_funcdef ||\n           TYPE(CHILD(n, 1)) == classdef);\n\n    if (TYPE(CHILD(n, 1)) == funcdef) {\n      thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == classdef) {\n      thing = ast_for_classdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == async_funcdef) {\n      thing = ast_for_async_funcdef(c, CHILD(n, 1), decorator_seq);\n    }\n    return thing;\n}\n\nstatic expr_ty\nast_for_namedexpr(struct compiling *c, const node *n)\n{\n    /* if_stmt: 'if' namedexpr_test ':' suite ('elif' namedexpr_test ':' suite)*\n         ['else' ':' suite]\n       namedexpr_test: test [':=' test]\n       argument: ( test [comp_for] |\n            test ':=' test |\n            test '=' test |\n            '**' test |\n            '*' test )\n    */\n    expr_ty target, value;\n\n    target = ast_for_expr(c, CHILD(n, 0));\n    if (!target)\n        return NULL;\n\n    value = ast_for_expr(c, CHILD(n, 2));\n    if (!value)\n        return NULL;\n\n    if (target->kind != Name_kind) {\n        const char *expr_name = get_expr_name(target);\n        if (expr_name != NULL) {\n            ast_error(c, n, \"cannot use named assignment with %s\", expr_name);\n        }\n        return NULL;\n    }\n\n    if (!set_context(c, target, Store, n))\n        return NULL;\n\n    return NamedExpr(target, value, LINENO(n), n->n_col_offset, n->n_end_lineno,\n                     n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_lambdef(struct compiling *c, const node *n)\n{\n    /* lambdef: 'lambda' [varargslist] ':' test\n       lambdef_nocond: 'lambda' [varargslist] ':' test_nocond */\n    arguments_ty args;\n    expr_ty expression;\n\n    if (NCH(n) == 3) {\n        args = arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        if (!args)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(n, 2));\n        if (!expression)\n            return NULL;\n    }\n    else {\n        args = ast_for_arguments(c, CHILD(n, 1));\n        if (!args)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(n, 3));\n        if (!expression)\n            return NULL;\n    }\n\n    return Lambda(args, expression, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_ifexpr(struct compiling *c, const node *n)\n{\n    /* test: or_test 'if' or_test 'else' test */\n    expr_ty expression, body, orelse;\n\n    assert(NCH(n) == 5);\n    body = ast_for_expr(c, CHILD(n, 0));\n    if (!body)\n        return NULL;\n    expression = ast_for_expr(c, CHILD(n, 2));\n    if (!expression)\n        return NULL;\n    orelse = ast_for_expr(c, CHILD(n, 4));\n    if (!orelse)\n        return NULL;\n    return IfExp(expression, body, orelse, LINENO(n), n->n_col_offset,\n                 n->n_end_lineno, n->n_end_col_offset,\n                 c->c_arena);\n}\n\n/*\n   Count the number of 'for' loops in a comprehension.\n\n   Helper for ast_for_comprehension().\n*/\n\nstatic int\ncount_comp_fors(struct compiling *c, const node *n)\n{\n    int n_fors = 0;\n\n  count_comp_for:\n    n_fors++;\n    REQ(n, comp_for);\n    if (NCH(n) == 2) {\n        REQ(CHILD(n, 0), ASYNC);\n        n = CHILD(n, 1);\n    }\n    else if (NCH(n) == 1) {\n        n = CHILD(n, 0);\n    }\n    else {\n        goto error;\n    }\n    if (NCH(n) == (5)) {\n        n = CHILD(n, 4);\n    }\n    else {\n        return n_fors;\n    }\n  count_comp_iter:\n    REQ(n, comp_iter);\n    n = CHILD(n, 0);\n    if (TYPE(n) == comp_for)\n        goto count_comp_for;\n    else if (TYPE(n) == comp_if) {\n        if (NCH(n) == 3) {\n            n = CHILD(n, 2);\n            goto count_comp_iter;\n        }\n        else\n            return n_fors;\n    }\n\n  error:\n    /* Should never be reached */\n    PyErr_SetString(PyExc_SystemError,\n                    \"logic error in count_comp_fors\");\n    return -1;\n}\n\n/* Count the number of 'if' statements in a comprehension.\n\n   Helper for ast_for_comprehension().\n*/\n\nstatic int\ncount_comp_ifs(struct compiling *c, const node *n)\n{\n    int n_ifs = 0;\n\n    while (1) {\n        REQ(n, comp_iter);\n        if (TYPE(CHILD(n, 0)) == comp_for)\n            return n_ifs;\n        n = CHILD(n, 0);\n        REQ(n, comp_if);\n        n_ifs++;\n        if (NCH(n) == 2)\n            return n_ifs;\n        n = CHILD(n, 2);\n    }\n}\n\nstatic asdl_seq *\nast_for_comprehension(struct compiling *c, const node *n)\n{\n    int i, n_fors;\n    asdl_seq *comps;\n\n    n_fors = count_comp_fors(c, n);\n    if (n_fors == -1)\n        return NULL;\n\n    comps = _Py_asdl_seq_new(n_fors, c->c_arena);\n    if (!comps)\n        return NULL;\n\n    for (i = 0; i < n_fors; i++) {\n        comprehension_ty comp;\n        asdl_seq *t;\n        expr_ty expression, first;\n        node *for_ch;\n        node *sync_n;\n        int is_async = 0;\n\n        REQ(n, comp_for);\n\n        if (NCH(n) == 2) {\n            is_async = 1;\n            REQ(CHILD(n, 0), ASYNC);\n            sync_n = CHILD(n, 1);\n        }\n        else {\n            sync_n = CHILD(n, 0);\n        }\n        REQ(sync_n, sync_comp_for);\n\n        /* Async comprehensions only allowed in Python 3.6 and greater */\n        if (is_async && c->c_feature_version < 6) {\n            ast_error(c, n,\n                      \"Async comprehensions are only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n\n        for_ch = CHILD(sync_n, 1);\n        t = ast_for_exprlist(c, for_ch, Store);\n        if (!t)\n            return NULL;\n        expression = ast_for_expr(c, CHILD(sync_n, 3));\n        if (!expression)\n            return NULL;\n\n        /* Check the # of children rather than the length of t, since\n           (x for x, in ...) has 1 element in t, but still requires a Tuple. */\n        first = (expr_ty)asdl_seq_GET(t, 0);\n        if (NCH(for_ch) == 1)\n            comp = comprehension(first, expression, NULL,\n                                 is_async, c->c_arena);\n        else\n            comp = comprehension(Tuple(t, Store, first->lineno, first->col_offset,\n                                       for_ch->n_end_lineno, for_ch->n_end_col_offset,\n                                       c->c_arena),\n                                 expression, NULL, is_async, c->c_arena);\n        if (!comp)\n            return NULL;\n\n        if (NCH(sync_n) == 5) {\n            int j, n_ifs;\n            asdl_seq *ifs;\n\n            n = CHILD(sync_n, 4);\n            n_ifs = count_comp_ifs(c, n);\n            if (n_ifs == -1)\n                return NULL;\n\n            ifs = _Py_asdl_seq_new(n_ifs, c->c_arena);\n            if (!ifs)\n                return NULL;\n\n            for (j = 0; j < n_ifs; j++) {\n                REQ(n, comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, comp_if);\n\n                expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression)\n                    return NULL;\n                asdl_seq_SET(ifs, j, expression);\n                if (NCH(n) == 3)\n                    n = CHILD(n, 2);\n            }\n            /* on exit, must guarantee that n is a comp_for */\n            if (TYPE(n) == comp_iter)\n                n = CHILD(n, 0);\n            comp->ifs = ifs;\n        }\n        asdl_seq_SET(comps, i, comp);\n    }\n    return comps;\n}\n\nstatic expr_ty\nast_for_itercomp(struct compiling *c, const node *n, int type)\n{\n    /* testlist_comp: (test|star_expr)\n     *                ( comp_for | (',' (test|star_expr))* [','] ) */\n    expr_ty elt;\n    asdl_seq *comps;\n    node *ch;\n\n    assert(NCH(n) > 1);\n\n    ch = CHILD(n, 0);\n    elt = ast_for_expr(c, ch);\n    if (!elt)\n        return NULL;\n    if (elt->kind == Starred_kind) {\n        ast_error(c, ch, \"iterable unpacking cannot be used in comprehension\");\n        return NULL;\n    }\n\n    comps = ast_for_comprehension(c, CHILD(n, 1));\n    if (!comps)\n        return NULL;\n\n    if (type == COMP_GENEXP)\n        return GeneratorExp(elt, comps, LINENO(n), n->n_col_offset,\n                            n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    else if (type == COMP_LISTCOMP)\n        return ListComp(elt, comps, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    else if (type == COMP_SETCOMP)\n        return SetComp(elt, comps, LINENO(n), n->n_col_offset,\n                       n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    else\n        /* Should never happen */\n        return NULL;\n}\n\n/* Fills in the key, value pair corresponding to the dict element.  In case\n * of an unpacking, key is NULL.  *i is advanced by the number of ast\n * elements.  Iff successful, nonzero is returned.\n */\nstatic int\nast_for_dictelement(struct compiling *c, const node *n, int *i,\n                    expr_ty *key, expr_ty *value)\n{\n    expr_ty expression;\n    if (TYPE(CHILD(n, *i)) == DOUBLESTAR) {\n        assert(NCH(n) - *i >= 2);\n\n        expression = ast_for_expr(c, CHILD(n, *i + 1));\n        if (!expression)\n            return 0;\n        *key = NULL;\n        *value = expression;\n\n        *i += 2;\n    }\n    else {\n        assert(NCH(n) - *i >= 3);\n\n        expression = ast_for_expr(c, CHILD(n, *i));\n        if (!expression)\n            return 0;\n        *key = expression;\n\n        REQ(CHILD(n, *i + 1), COLON);\n\n        expression = ast_for_expr(c, CHILD(n, *i + 2));\n        if (!expression)\n            return 0;\n        *value = expression;\n\n        *i += 3;\n    }\n    return 1;\n}\n\nstatic expr_ty\nast_for_dictcomp(struct compiling *c, const node *n)\n{\n    expr_ty key, value;\n    asdl_seq *comps;\n    int i = 0;\n\n    if (!ast_for_dictelement(c, n, &i, &key, &value))\n        return NULL;\n    assert(key);\n    assert(NCH(n) - i >= 1);\n\n    comps = ast_for_comprehension(c, CHILD(n, i));\n    if (!comps)\n        return NULL;\n\n    return DictComp(key, value, comps, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_dictdisplay(struct compiling *c, const node *n)\n{\n    int i;\n    int j;\n    int size;\n    asdl_seq *keys, *values;\n\n    size = (NCH(n) + 1) / 3; /* +1 in case no trailing comma */\n    keys = _Py_asdl_seq_new(size, c->c_arena);\n    if (!keys)\n        return NULL;\n\n    values = _Py_asdl_seq_new(size, c->c_arena);\n    if (!values)\n        return NULL;\n\n    j = 0;\n    for (i = 0; i < NCH(n); i++) {\n        expr_ty key, value;\n\n        if (!ast_for_dictelement(c, n, &i, &key, &value))\n            return NULL;\n        asdl_seq_SET(keys, j, key);\n        asdl_seq_SET(values, j, value);\n\n        j++;\n    }\n    keys->size = j;\n    values->size = j;\n    return Dict(keys, values, LINENO(n), n->n_col_offset,\n                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_genexp(struct compiling *c, const node *n)\n{\n    assert(TYPE(n) == (testlist_comp) || TYPE(n) == (argument));\n    return ast_for_itercomp(c, n, COMP_GENEXP);\n}\n\nstatic expr_ty\nast_for_listcomp(struct compiling *c, const node *n)\n{\n    assert(TYPE(n) == (testlist_comp));\n    return ast_for_itercomp(c, n, COMP_LISTCOMP);\n}\n\nstatic expr_ty\nast_for_setcomp(struct compiling *c, const node *n)\n{\n    assert(TYPE(n) == (dictorsetmaker));\n    return ast_for_itercomp(c, n, COMP_SETCOMP);\n}\n\nstatic expr_ty\nast_for_setdisplay(struct compiling *c, const node *n)\n{\n    int i;\n    int size;\n    asdl_seq *elts;\n\n    assert(TYPE(n) == (dictorsetmaker));\n    size = (NCH(n) + 1) / 2; /* +1 in case no trailing comma */\n    elts = _Py_asdl_seq_new(size, c->c_arena);\n    if (!elts)\n        return NULL;\n    for (i = 0; i < NCH(n); i += 2) {\n        expr_ty expression;\n        expression = ast_for_expr(c, CHILD(n, i));\n        if (!expression)\n            return NULL;\n        asdl_seq_SET(elts, i / 2, expression);\n    }\n    return Set(elts, LINENO(n), n->n_col_offset,\n               n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_atom(struct compiling *c, const node *n)\n{\n    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'\n       | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+\n       | '...' | 'None' | 'True' | 'False'\n    */\n    node *ch = CHILD(n, 0);\n\n    switch (TYPE(ch)) {\n    case NAME: {\n        PyObject *name;\n        const char *s = STR(ch);\n        size_t len = strlen(s);\n        if (len >= 4 && len <= 5) {\n            if (!strcmp(s, \"None\"))\n                return Constant(Py_None, NULL, LINENO(n), n->n_col_offset,\n                                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            if (!strcmp(s, \"True\"))\n                return Constant(Py_True, NULL, LINENO(n), n->n_col_offset,\n                                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            if (!strcmp(s, \"False\"))\n                return Constant(Py_False, NULL, LINENO(n), n->n_col_offset,\n                                n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        name = new_identifier(s, c);\n        if (!name)\n            return NULL;\n        /* All names start in Load context, but may later be changed. */\n        return Name(name, Load, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    case STRING: {\n        expr_ty str = parsestrplus(c, n);\n        if (!str) {\n            const char *errtype = NULL;\n            if (PyErr_ExceptionMatches(PyExc_UnicodeError))\n                errtype = \"unicode error\";\n            else if (PyErr_ExceptionMatches(PyExc_ValueError))\n                errtype = \"value error\";\n            if (errtype) {\n                PyObject *type, *value, *tback, *errstr;\n                PyErr_Fetch(&type, &value, &tback);\n                errstr = PyObject_Str(value);\n                if (errstr) {\n                    ast_error(c, n, \"(%s) %U\", errtype, errstr);\n                    Py_DECREF(errstr);\n                }\n                else {\n                    PyErr_Clear();\n                    ast_error(c, n, \"(%s) unknown error\", errtype);\n                }\n                Py_DECREF(type);\n                Py_XDECREF(value);\n                Py_XDECREF(tback);\n            }\n            return NULL;\n        }\n        return str;\n    }\n    case NUMBER: {\n        PyObject *pynum;\n        /* Underscores in numeric literals are only allowed in Python 3.6 or greater */\n        /* Check for underscores here rather than in parse_number so we can report a line number on error */\n        if (c->c_feature_version < 6 && strchr(STR(ch), '_') != NULL) {\n            ast_error(c, ch,\n                      \"Underscores in numeric literals are only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n        pynum = parsenumber(c, STR(ch));\n        if (!pynum)\n            return NULL;\n\n        if (PyArena_AddPyObject(c->c_arena, pynum) < 0) {\n            Py_DECREF(pynum);\n            return NULL;\n        }\n        return Constant(pynum, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    case ELLIPSIS: /* Ellipsis */\n        return Constant(Py_Ellipsis, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    case LPAR: /* some parenthesized expressions */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RPAR)\n            return Tuple(NULL, Load, LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n\n        if (TYPE(ch) == yield_expr)\n            return ast_for_expr(c, ch);\n\n        /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n        if (NCH(ch) == 1) {\n            return ast_for_testlist(c, ch);\n        }\n\n        if (TYPE(CHILD(ch, 1)) == comp_for) {\n            return copy_location(ast_for_genexp(c, ch), n);\n        }\n        else {\n            return copy_location(ast_for_testlist(c, ch), n);\n        }\n    case LSQB: /* list (or list comprehension) */\n        ch = CHILD(n, 1);\n\n        if (TYPE(ch) == RSQB)\n            return List(NULL, Load, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n\n        REQ(ch, testlist_comp);\n        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {\n            asdl_seq *elts = seq_for_testlist(c, ch);\n            if (!elts)\n                return NULL;\n\n            return List(elts, Load, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        else {\n            return copy_location(ast_for_listcomp(c, ch), n);\n        }\n    case LBRACE: {\n        /* dictorsetmaker: ( ((test ':' test | '**' test)\n         *                    (comp_for | (',' (test ':' test | '**' test))* [','])) |\n         *                   ((test | '*' test)\n         *                    (comp_for | (',' (test | '*' test))* [','])) ) */\n        expr_ty res;\n        ch = CHILD(n, 1);\n        if (TYPE(ch) == RBRACE) {\n            /* It's an empty dict. */\n            return Dict(NULL, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        else {\n            int is_dict = (TYPE(CHILD(ch, 0)) == DOUBLESTAR);\n            if (NCH(ch) == 1 ||\n                    (NCH(ch) > 1 &&\n                     TYPE(CHILD(ch, 1)) == COMMA)) {\n                /* It's a set display. */\n                res = ast_for_setdisplay(c, ch);\n            }\n            else if (NCH(ch) > 1 &&\n                    TYPE(CHILD(ch, 1)) == comp_for) {\n                /* It's a set comprehension. */\n                res = ast_for_setcomp(c, ch);\n            }\n            else if (NCH(ch) > 3 - is_dict &&\n                    TYPE(CHILD(ch, 3 - is_dict)) == comp_for) {\n                /* It's a dictionary comprehension. */\n                if (is_dict) {\n                    ast_error(c, n,\n                              \"dict unpacking cannot be used in dict comprehension\");\n                    return NULL;\n                }\n                res = ast_for_dictcomp(c, ch);\n            }\n            else {\n                /* It's a dictionary display. */\n                res = ast_for_dictdisplay(c, ch);\n            }\n            return copy_location(res, n);\n        }\n    }\n    default:\n        PyErr_Format(PyExc_SystemError, \"unhandled atom %d\", TYPE(ch));\n        return NULL;\n    }\n}\n\nstatic slice_ty\nast_for_slice(struct compiling *c, const node *n)\n{\n    node *ch;\n    expr_ty lower = NULL, upper = NULL, step = NULL;\n\n    REQ(n, subscript);\n\n    /*\n       subscript: test | [test] ':' [test] [sliceop]\n       sliceop: ':' [test]\n    */\n    ch = CHILD(n, 0);\n    if (NCH(n) == 1 && TYPE(ch) == test) {\n        /* 'step' variable hold no significance in terms of being used over\n           other vars */\n        step = ast_for_expr(c, ch);\n        if (!step)\n            return NULL;\n\n        return Index(step, c->c_arena);\n    }\n\n    if (TYPE(ch) == test) {\n        lower = ast_for_expr(c, ch);\n        if (!lower)\n            return NULL;\n    }\n\n    /* If there's an upper bound it's in the second or third position. */\n    if (TYPE(ch) == COLON) {\n        if (NCH(n) > 1) {\n            node *n2 = CHILD(n, 1);\n\n            if (TYPE(n2) == test) {\n                upper = ast_for_expr(c, n2);\n                if (!upper)\n                    return NULL;\n            }\n        }\n    } else if (NCH(n) > 2) {\n        node *n2 = CHILD(n, 2);\n\n        if (TYPE(n2) == test) {\n            upper = ast_for_expr(c, n2);\n            if (!upper)\n                return NULL;\n        }\n    }\n\n    ch = CHILD(n, NCH(n) - 1);\n    if (TYPE(ch) == sliceop) {\n        if (NCH(ch) != 1) {\n            ch = CHILD(ch, 1);\n            if (TYPE(ch) == test) {\n                step = ast_for_expr(c, ch);\n                if (!step)\n                    return NULL;\n            }\n        }\n    }\n\n    return Slice(lower, upper, step, c->c_arena);\n}\n\nstatic expr_ty\nast_for_binop(struct compiling *c, const node *n)\n{\n    /* Must account for a sequence of expressions.\n       How should A op B op C by represented?\n       BinOp(BinOp(A, op, B), op, C).\n    */\n\n    int i, nops;\n    expr_ty expr1, expr2, result;\n    operator_ty newoperator;\n\n    expr1 = ast_for_expr(c, CHILD(n, 0));\n    if (!expr1)\n        return NULL;\n\n    expr2 = ast_for_expr(c, CHILD(n, 2));\n    if (!expr2)\n        return NULL;\n\n    newoperator = get_operator(c, CHILD(n, 1));\n    if (!newoperator)\n        return NULL;\n\n    result = BinOp(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,\n                   CHILD(n, 2)->n_end_lineno, CHILD(n, 2)->n_end_col_offset,\n                   c->c_arena);\n    if (!result)\n        return NULL;\n\n    nops = (NCH(n) - 1) / 2;\n    for (i = 1; i < nops; i++) {\n        expr_ty tmp_result, tmp;\n        const node* next_oper = CHILD(n, i * 2 + 1);\n\n        newoperator = get_operator(c, next_oper);\n        if (!newoperator)\n            return NULL;\n\n        tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));\n        if (!tmp)\n            return NULL;\n\n        tmp_result = BinOp(result, newoperator, tmp,\n                           LINENO(next_oper), next_oper->n_col_offset,\n                           CHILD(n, i * 2 + 2)->n_end_lineno,\n                           CHILD(n, i * 2 + 2)->n_end_col_offset,\n                           c->c_arena);\n        if (!tmp_result)\n            return NULL;\n        result = tmp_result;\n    }\n    return result;\n}\n\nstatic expr_ty\nast_for_trailer(struct compiling *c, const node *n, expr_ty left_expr)\n{\n    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n       subscriptlist: subscript (',' subscript)* [',']\n       subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n     */\n    const node *n_copy = n;\n    REQ(n, trailer);\n    if (TYPE(CHILD(n, 0)) == LPAR) {\n        if (NCH(n) == 2)\n            return Call(left_expr, NULL, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        else\n            return ast_for_call(c, CHILD(n, 1), left_expr, CHILD(n, 0), CHILD(n, 2));\n    }\n    else if (TYPE(CHILD(n, 0)) == DOT) {\n        PyObject *attr_id = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!attr_id)\n            return NULL;\n        return Attribute(left_expr, attr_id, Load,\n                         LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else {\n        REQ(CHILD(n, 0), LSQB);\n        REQ(CHILD(n, 2), RSQB);\n        n = CHILD(n, 1);\n        if (NCH(n) == 1) {\n            slice_ty slc = ast_for_slice(c, CHILD(n, 0));\n            if (!slc)\n                return NULL;\n            return Subscript(left_expr, slc, Load, LINENO(n), n->n_col_offset,\n                             n_copy->n_end_lineno, n_copy->n_end_col_offset,\n                             c->c_arena);\n        }\n        else {\n            /* The grammar is ambiguous here. The ambiguity is resolved\n               by treating the sequence as a tuple literal if there are\n               no slice features.\n            */\n            Py_ssize_t j;\n            slice_ty slc;\n            expr_ty e;\n            int simple = 1;\n            asdl_seq *slices, *elts;\n            slices = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n            if (!slices)\n                return NULL;\n            for (j = 0; j < NCH(n); j += 2) {\n                slc = ast_for_slice(c, CHILD(n, j));\n                if (!slc)\n                    return NULL;\n                if (slc->kind != Index_kind)\n                    simple = 0;\n                asdl_seq_SET(slices, j / 2, slc);\n            }\n            if (!simple) {\n                return Subscript(left_expr, ExtSlice(slices, c->c_arena),\n                                 Load, LINENO(n), n->n_col_offset,\n                                 n_copy->n_end_lineno, n_copy->n_end_col_offset, c->c_arena);\n            }\n            /* extract Index values and put them in a Tuple */\n            elts = _Py_asdl_seq_new(asdl_seq_LEN(slices), c->c_arena);\n            if (!elts)\n                return NULL;\n            for (j = 0; j < asdl_seq_LEN(slices); ++j) {\n                slc = (slice_ty)asdl_seq_GET(slices, j);\n                assert(slc->kind == Index_kind  && slc->v.Index.value);\n                asdl_seq_SET(elts, j, slc->v.Index.value);\n            }\n            e = Tuple(elts, Load, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            if (!e)\n                return NULL;\n            return Subscript(left_expr, Index(e, c->c_arena),\n                             Load, LINENO(n), n->n_col_offset,\n                             n_copy->n_end_lineno, n_copy->n_end_col_offset, c->c_arena);\n        }\n    }\n}\n\nstatic expr_ty\nast_for_factor(struct compiling *c, const node *n)\n{\n    expr_ty expression;\n\n    expression = ast_for_expr(c, CHILD(n, 1));\n    if (!expression)\n        return NULL;\n\n    switch (TYPE(CHILD(n, 0))) {\n        case PLUS:\n            return UnaryOp(UAdd, expression, LINENO(n), n->n_col_offset,\n                           n->n_end_lineno, n->n_end_col_offset,\n                           c->c_arena);\n        case MINUS:\n            return UnaryOp(USub, expression, LINENO(n), n->n_col_offset,\n                           n->n_end_lineno, n->n_end_col_offset,\n                           c->c_arena);\n        case TILDE:\n            return UnaryOp(Invert, expression, LINENO(n), n->n_col_offset,\n                           n->n_end_lineno, n->n_end_col_offset,\n                           c->c_arena);\n    }\n    PyErr_Format(PyExc_SystemError, \"unhandled factor: %d\",\n                 TYPE(CHILD(n, 0)));\n    return NULL;\n}\n\nstatic expr_ty\nast_for_atom_expr(struct compiling *c, const node *n)\n{\n    int i, nch, start = 0;\n    expr_ty e, tmp;\n\n    REQ(n, atom_expr);\n    nch = NCH(n);\n\n    if (TYPE(CHILD(n, 0)) == AWAIT) {\n        if (c->c_feature_version < 5) {\n            ast_error(c, n,\n                      \"Await expressions are only supported in Python 3.5 and greater\");\n            return NULL;\n        }\n        start = 1;\n        assert(nch > 1);\n    }\n\n    e = ast_for_atom(c, CHILD(n, start));\n    if (!e)\n        return NULL;\n    if (nch == 1)\n        return e;\n    if (start && nch == 2) {\n        return Await(e, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n\n    for (i = start + 1; i < nch; i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) != trailer)\n            break;\n        tmp = ast_for_trailer(c, ch, e);\n        if (!tmp)\n            return NULL;\n        tmp->lineno = e->lineno;\n        tmp->col_offset = e->col_offset;\n        e = tmp;\n    }\n\n    if (start) {\n        /* there was an 'await' */\n        return Await(e, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else {\n        return e;\n    }\n}\n\nstatic expr_ty\nast_for_power(struct compiling *c, const node *n)\n{\n    /* power: atom trailer* ('**' factor)*\n     */\n    expr_ty e;\n    REQ(n, power);\n    e = ast_for_atom_expr(c, CHILD(n, 0));\n    if (!e)\n        return NULL;\n    if (NCH(n) == 1)\n        return e;\n    if (TYPE(CHILD(n, NCH(n) - 1)) == factor) {\n        expr_ty f = ast_for_expr(c, CHILD(n, NCH(n) - 1));\n        if (!f)\n            return NULL;\n        e = BinOp(e, Pow, f, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    return e;\n}\n\nstatic expr_ty\nast_for_starred(struct compiling *c, const node *n)\n{\n    expr_ty tmp;\n    REQ(n, star_expr);\n\n    tmp = ast_for_expr(c, CHILD(n, 1));\n    if (!tmp)\n        return NULL;\n\n    /* The Load context is changed later. */\n    return Starred(tmp, Load, LINENO(n), n->n_col_offset,\n                   n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\n\n/* Do not name a variable 'expr'!  Will cause a compile error.\n*/\n\nstatic expr_ty\nast_for_expr(struct compiling *c, const node *n)\n{\n    /* handle the full range of simple expressions\n       namedexpr_test: test [':=' test]\n       test: or_test ['if' or_test 'else' test] | lambdef\n       test_nocond: or_test | lambdef_nocond\n       or_test: and_test ('or' and_test)*\n       and_test: not_test ('and' not_test)*\n       not_test: 'not' not_test | comparison\n       comparison: expr (comp_op expr)*\n       expr: xor_expr ('|' xor_expr)*\n       xor_expr: and_expr ('^' and_expr)*\n       and_expr: shift_expr ('&' shift_expr)*\n       shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n       arith_expr: term (('+'|'-') term)*\n       term: factor (('*'|'@'|'/'|'%'|'//') factor)*\n       factor: ('+'|'-'|'~') factor | power\n       power: atom_expr ['**' factor]\n       atom_expr: [AWAIT] atom trailer*\n       yield_expr: 'yield' [yield_arg]\n    */\n\n    asdl_seq *seq;\n    int i;\n\n loop:\n    switch (TYPE(n)) {\n        case namedexpr_test:\n            if (NCH(n) == 3)\n                return ast_for_namedexpr(c, n);\n            /* Fallthrough */\n        case test:\n        case test_nocond:\n            if (TYPE(CHILD(n, 0)) == lambdef ||\n                TYPE(CHILD(n, 0)) == lambdef_nocond)\n                return ast_for_lambdef(c, CHILD(n, 0));\n            else if (NCH(n) > 1)\n                return ast_for_ifexpr(c, n);\n            /* Fallthrough */\n        case or_test:\n        case and_test:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            seq = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n            if (!seq)\n                return NULL;\n            for (i = 0; i < NCH(n); i += 2) {\n                expr_ty e = ast_for_expr(c, CHILD(n, i));\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(seq, i / 2, e);\n            }\n            if (!strcmp(STR(CHILD(n, 1)), \"and\"))\n                return BoolOp(And, seq, LINENO(n), n->n_col_offset,\n                              n->n_end_lineno, n->n_end_col_offset,\n                              c->c_arena);\n            assert(!strcmp(STR(CHILD(n, 1)), \"or\"));\n            return BoolOp(Or, seq, LINENO(n), n->n_col_offset,\n                          n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        case not_test:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            else {\n                expr_ty expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression)\n                    return NULL;\n\n                return UnaryOp(Not, expression, LINENO(n), n->n_col_offset,\n                               n->n_end_lineno, n->n_end_col_offset,\n                               c->c_arena);\n            }\n        case comparison:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            else {\n                expr_ty expression;\n                asdl_int_seq *ops;\n                asdl_seq *cmps;\n                ops = _Py_asdl_int_seq_new(NCH(n) / 2, c->c_arena);\n                if (!ops)\n                    return NULL;\n                cmps = _Py_asdl_seq_new(NCH(n) / 2, c->c_arena);\n                if (!cmps) {\n                    return NULL;\n                }\n                for (i = 1; i < NCH(n); i += 2) {\n                    cmpop_ty newoperator;\n\n                    newoperator = ast_for_comp_op(c, CHILD(n, i));\n                    if (!newoperator) {\n                        return NULL;\n                    }\n\n                    expression = ast_for_expr(c, CHILD(n, i + 1));\n                    if (!expression) {\n                        return NULL;\n                    }\n\n                    asdl_seq_SET(ops, i / 2, newoperator);\n                    asdl_seq_SET(cmps, i / 2, expression);\n                }\n                expression = ast_for_expr(c, CHILD(n, 0));\n                if (!expression) {\n                    return NULL;\n                }\n\n                return Compare(expression, ops, cmps, LINENO(n), n->n_col_offset,\n                               n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            }\n            break;\n\n        case star_expr:\n            return ast_for_starred(c, n);\n        /* The next five cases all handle BinOps.  The main body of code\n           is the same in each case, but the switch turned inside out to\n           reuse the code for each type of operator.\n         */\n        case expr:\n        case xor_expr:\n        case and_expr:\n        case shift_expr:\n        case arith_expr:\n        case term:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            return ast_for_binop(c, n);\n        case yield_expr: {\n            node *an = NULL;\n            node *en = NULL;\n            int is_from = 0;\n            expr_ty exp = NULL;\n            if (NCH(n) > 1)\n                an = CHILD(n, 1); /* yield_arg */\n            if (an) {\n                en = CHILD(an, NCH(an) - 1);\n                if (NCH(an) == 2) {\n                    is_from = 1;\n                    exp = ast_for_expr(c, en);\n                }\n                else\n                    exp = ast_for_testlist(c, en);\n                if (!exp)\n                    return NULL;\n            }\n            if (is_from)\n                return YieldFrom(exp, LINENO(n), n->n_col_offset,\n                                 n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            return Yield(exp, LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        case factor:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            return ast_for_factor(c, n);\n        case power:\n            return ast_for_power(c, n);\n        default:\n            PyErr_Format(PyExc_SystemError, \"unhandled expr: %d\", TYPE(n));\n            return NULL;\n    }\n    /* should never get here unless if error is set */\n    return NULL;\n}\n\nstatic expr_ty\nast_for_call(struct compiling *c, const node *n, expr_ty func,\n             const node *maybegenbeg, const node *closepar)\n{\n    /*\n      arglist: argument (',' argument)*  [',']\n      argument: ( test [comp_for] | '*' test | test '=' test | '**' test )\n    */\n\n    int i, nargs, nkeywords;\n    int ndoublestars;\n    asdl_seq *args;\n    asdl_seq *keywords;\n\n    REQ(n, arglist);\n\n    nargs = 0;\n    nkeywords = 0;\n    for (i = 0; i < NCH(n); i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) == argument) {\n            if (NCH(ch) == 1)\n                nargs++;\n            else if (TYPE(CHILD(ch, 1)) == comp_for) {\n                nargs++;\n                if (!maybegenbeg) {\n                    ast_error(c, ch, \"invalid syntax\");\n                    return NULL;\n                }\n                if (NCH(n) > 1) {\n                    ast_error(c, ch, \"Generator expression must be parenthesized\");\n                    return NULL;\n                }\n            }\n            else if (TYPE(CHILD(ch, 0)) == STAR)\n                nargs++;\n            else if (TYPE(CHILD(ch, 1)) == COLONEQUAL) {\n                nargs++;\n            }\n            else\n                /* TYPE(CHILD(ch, 0)) == DOUBLESTAR or keyword argument */\n                nkeywords++;\n        }\n    }\n\n    args = _Py_asdl_seq_new(nargs, c->c_arena);\n    if (!args)\n        return NULL;\n    keywords = _Py_asdl_seq_new(nkeywords, c->c_arena);\n    if (!keywords)\n        return NULL;\n\n    nargs = 0;  /* positional arguments + iterable argument unpackings */\n    nkeywords = 0;  /* keyword arguments + keyword argument unpackings */\n    ndoublestars = 0;  /* just keyword argument unpackings */\n    for (i = 0; i < NCH(n); i++) {\n        node *ch = CHILD(n, i);\n        if (TYPE(ch) == argument) {\n            expr_ty e;\n            node *chch = CHILD(ch, 0);\n            if (NCH(ch) == 1) {\n                /* a positional argument */\n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument unpacking\");\n                    }\n                    else {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument\");\n                    }\n                    return NULL;\n                }\n                e = ast_for_expr(c, chch);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else if (TYPE(chch) == STAR) {\n                /* an iterable argument unpacking */\n                expr_ty starred;\n                if (ndoublestars) {\n                    ast_error(c, chch,\n                              \"iterable argument unpacking follows \"\n                              \"keyword argument unpacking\");\n                    return NULL;\n                }\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e)\n                    return NULL;\n                starred = Starred(e, Load, LINENO(chch),\n                        chch->n_col_offset,\n                        chch->n_end_lineno, chch->n_end_col_offset,\n                        c->c_arena);\n                if (!starred)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, starred);\n\n            }\n            else if (TYPE(chch) == DOUBLESTAR) {\n                /* a keyword argument unpacking */\n                keyword_ty kw;\n                i++;\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e)\n                    return NULL;\n                kw = keyword(NULL, e, c->c_arena);\n                asdl_seq_SET(keywords, nkeywords++, kw);\n                ndoublestars++;\n            }\n            else if (TYPE(CHILD(ch, 1)) == comp_for) {\n                /* the lone generator expression */\n                e = copy_location(ast_for_genexp(c, ch), maybegenbeg);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else if (TYPE(CHILD(ch, 1)) == COLONEQUAL) {\n                /* treat colon equal as positional argument */\n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument unpacking\");\n                    }\n                    else {\n                        ast_error(c, chch,\n                                  \"positional argument follows \"\n                                  \"keyword argument\");\n                    }\n                    return NULL;\n                }\n                e = ast_for_namedexpr(c, ch);\n                if (!e)\n                    return NULL;\n                asdl_seq_SET(args, nargs++, e);\n            }\n            else {\n                /* a keyword argument */\n                keyword_ty kw;\n                identifier key, tmp;\n                int k;\n\n                // To remain LL(1), the grammar accepts any test (basically, any\n                // expression) in the keyword slot of a call site.  So, we need\n                // to manually enforce that the keyword is a NAME here.\n                static const int name_tree[] = {\n                    test,\n                    or_test,\n                    and_test,\n                    not_test,\n                    comparison,\n                    expr,\n                    xor_expr,\n                    and_expr,\n                    shift_expr,\n                    arith_expr,\n                    term,\n                    factor,\n                    power,\n                    atom_expr,\n                    atom,\n                    0,\n                };\n                node *expr_node = chch;\n                for (int i = 0; name_tree[i]; i++) {\n                    if (TYPE(expr_node) != name_tree[i])\n                        break;\n                    if (NCH(expr_node) != 1)\n                        break;\n                    expr_node = CHILD(expr_node, 0);\n                }\n                if (TYPE(expr_node) != NAME) {\n                    ast_error(c, chch,\n                              \"expression cannot contain assignment, \"\n                              \"perhaps you meant \\\"==\\\"?\");\n                    return NULL;\n                }\n                key = new_identifier(STR(expr_node), c);\n                if (key == NULL) {\n                    return NULL;\n                }\n                if (forbidden_name(c, key, chch, 1)) {\n                    return NULL;\n                }\n                for (k = 0; k < nkeywords; k++) {\n                    tmp = ((keyword_ty)asdl_seq_GET(keywords, k))->arg;\n                    if (tmp && !PyUnicode_Compare(tmp, key)) {\n                        ast_error(c, chch,\n                                  \"keyword argument repeated\");\n                        return NULL;\n                    }\n                }\n                e = ast_for_expr(c, CHILD(ch, 2));\n                if (!e)\n                    return NULL;\n                kw = keyword(key, e, c->c_arena);\n                if (!kw)\n                    return NULL;\n                asdl_seq_SET(keywords, nkeywords++, kw);\n            }\n        }\n    }\n\n    return Call(func, args, keywords, func->lineno, func->col_offset,\n                closepar->n_end_lineno, closepar->n_end_col_offset, c->c_arena);\n}\n\nstatic expr_ty\nast_for_testlist(struct compiling *c, const node* n)\n{\n    /* testlist_comp: test (comp_for | (',' test)* [',']) */\n    /* testlist: test (',' test)* [','] */\n    assert(NCH(n) > 0);\n    if (TYPE(n) == testlist_comp) {\n        if (NCH(n) > 1)\n            assert(TYPE(CHILD(n, 1)) != comp_for);\n    }\n    else {\n        assert(TYPE(n) == testlist ||\n               TYPE(n) == testlist_star_expr);\n    }\n    if (NCH(n) == 1)\n        return ast_for_expr(c, CHILD(n, 0));\n    else {\n        asdl_seq *tmp = seq_for_testlist(c, n);\n        if (!tmp)\n            return NULL;\n        return Tuple(tmp, Load, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n}\n\nstatic stmt_ty\nast_for_expr_stmt(struct compiling *c, const node *n)\n{\n    REQ(n, expr_stmt);\n    /* expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |\n                     [('=' (yield_expr|testlist_star_expr))+ [TYPE_COMMENT]] )\n       annassign: ':' test ['=' (yield_expr|testlist)]\n       testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']\n       augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |\n                   '<<=' | '>>=' | '**=' | '//=')\n       test: ... here starts the operator precedence dance\n     */\n    int num = NCH(n);\n\n    if (num == 1) {\n        expr_ty e = ast_for_testlist(c, CHILD(n, 0));\n        if (!e)\n            return NULL;\n\n        return Expr(e, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (TYPE(CHILD(n, 1)) == augassign) {\n        expr_ty expr1, expr2;\n        operator_ty newoperator;\n        node *ch = CHILD(n, 0);\n\n        expr1 = ast_for_testlist(c, ch);\n        if (!expr1)\n            return NULL;\n        if(!set_context(c, expr1, Store, ch))\n            return NULL;\n        /* set_context checks that most expressions are not the left side.\n          Augmented assignments can only have a name, a subscript, or an\n          attribute on the left, though, so we have to explicitly check for\n          those. */\n        switch (expr1->kind) {\n            case Name_kind:\n            case Attribute_kind:\n            case Subscript_kind:\n                break;\n            default:\n                ast_error(c, ch, \"illegal expression for augmented assignment\");\n                return NULL;\n        }\n\n        ch = CHILD(n, 2);\n        if (TYPE(ch) == testlist)\n            expr2 = ast_for_testlist(c, ch);\n        else\n            expr2 = ast_for_expr(c, ch);\n        if (!expr2)\n            return NULL;\n\n        newoperator = ast_for_augassign(c, CHILD(n, 1));\n        if (!newoperator)\n            return NULL;\n\n        return AugAssign(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (TYPE(CHILD(n, 1)) == annassign) {\n        expr_ty expr1, expr2, expr3;\n        node *ch = CHILD(n, 0);\n        node *deep, *ann = CHILD(n, 1);\n        int simple = 1;\n\n        /* AnnAssigns are only allowed in Python 3.6 or greater */\n        if (c->c_feature_version < 6) {\n            ast_error(c, ch,\n                      \"Variable annotation syntax is only supported in Python 3.6 and greater\");\n            return NULL;\n        }\n\n        /* we keep track of parens to qualify (x) as expression not name */\n        deep = ch;\n        while (NCH(deep) == 1) {\n            deep = CHILD(deep, 0);\n        }\n        if (NCH(deep) > 0 && TYPE(CHILD(deep, 0)) == LPAR) {\n            simple = 0;\n        }\n        expr1 = ast_for_testlist(c, ch);\n        if (!expr1) {\n            return NULL;\n        }\n        switch (expr1->kind) {\n            case Name_kind:\n                if (forbidden_name(c, expr1->v.Name.id, n, 0)) {\n                    return NULL;\n                }\n                expr1->v.Name.ctx = Store;\n                break;\n            case Attribute_kind:\n                if (forbidden_name(c, expr1->v.Attribute.attr, n, 1)) {\n                    return NULL;\n                }\n                expr1->v.Attribute.ctx = Store;\n                break;\n            case Subscript_kind:\n                expr1->v.Subscript.ctx = Store;\n                break;\n            case List_kind:\n                ast_error(c, ch,\n                          \"only single target (not list) can be annotated\");\n                return NULL;\n            case Tuple_kind:\n                ast_error(c, ch,\n                          \"only single target (not tuple) can be annotated\");\n                return NULL;\n            default:\n                ast_error(c, ch,\n                          \"illegal target for annotation\");\n                return NULL;\n        }\n\n        if (expr1->kind != Name_kind) {\n            simple = 0;\n        }\n        ch = CHILD(ann, 1);\n        expr2 = ast_for_expr(c, ch);\n        if (!expr2) {\n            return NULL;\n        }\n        if (NCH(ann) == 2) {\n            return AnnAssign(expr1, expr2, NULL, simple,\n                             LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        else {\n            ch = CHILD(ann, 3);\n            if (TYPE(ch) == testlist) {\n                expr3 = ast_for_testlist(c, ch);\n            }\n            else {\n                expr3 = ast_for_expr(c, ch);\n            }\n            if (!expr3) {\n                return NULL;\n            }\n            return AnnAssign(expr1, expr2, expr3, simple,\n                             LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n    }\n    else {\n        int i, nch_minus_type, has_type_comment;\n        asdl_seq *targets;\n        node *value;\n        expr_ty expression;\n        string type_comment;\n\n        /* a normal assignment */\n        REQ(CHILD(n, 1), EQUAL);\n\n        has_type_comment = TYPE(CHILD(n, num - 1)) == TYPE_COMMENT;\n        nch_minus_type = num - has_type_comment;\n\n        targets = _Py_asdl_seq_new(nch_minus_type / 2, c->c_arena);\n        if (!targets)\n            return NULL;\n        for (i = 0; i < nch_minus_type - 2; i += 2) {\n            expr_ty e;\n            node *ch = CHILD(n, i);\n            if (TYPE(ch) == yield_expr) {\n                ast_error(c, ch, \"assignment to yield expression not possible\");\n                return NULL;\n            }\n            e = ast_for_testlist(c, ch);\n            if (!e)\n              return NULL;\n\n            /* set context to assign */\n            if (!set_context(c, e, Store, CHILD(n, i)))\n              return NULL;\n\n            asdl_seq_SET(targets, i / 2, e);\n        }\n        value = CHILD(n, nch_minus_type - 1);\n        if (TYPE(value) == testlist_star_expr)\n            expression = ast_for_testlist(c, value);\n        else\n            expression = ast_for_expr(c, value);\n        if (!expression)\n            return NULL;\n        if (has_type_comment) {\n            type_comment = NEW_TYPE_COMMENT(CHILD(n, nch_minus_type));\n            if (!type_comment)\n                return NULL;\n        }\n        else\n            type_comment = NULL;\n        return Assign(targets, expression, type_comment, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n}\n\n\nstatic asdl_seq *\nast_for_exprlist(struct compiling *c, const node *n, expr_context_ty context)\n{\n    asdl_seq *seq;\n    int i;\n    expr_ty e;\n\n    REQ(n, exprlist);\n\n    seq = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n    if (!seq)\n        return NULL;\n    for (i = 0; i < NCH(n); i += 2) {\n        e = ast_for_expr(c, CHILD(n, i));\n        if (!e)\n            return NULL;\n        asdl_seq_SET(seq, i / 2, e);\n        if (context && !set_context(c, e, context, CHILD(n, i)))\n            return NULL;\n    }\n    return seq;\n}\n\nstatic stmt_ty\nast_for_del_stmt(struct compiling *c, const node *n)\n{\n    asdl_seq *expr_list;\n\n    /* del_stmt: 'del' exprlist */\n    REQ(n, del_stmt);\n\n    expr_list = ast_for_exprlist(c, CHILD(n, 1), Del);\n    if (!expr_list)\n        return NULL;\n    return Delete(expr_list, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_flow_stmt(struct compiling *c, const node *n)\n{\n    /*\n      flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n                 | yield_stmt\n      break_stmt: 'break'\n      continue_stmt: 'continue'\n      return_stmt: 'return' [testlist]\n      yield_stmt: yield_expr\n      yield_expr: 'yield' testlist | 'yield' 'from' test\n      raise_stmt: 'raise' [test [',' test [',' test]]]\n    */\n    node *ch;\n\n    REQ(n, flow_stmt);\n    ch = CHILD(n, 0);\n    switch (TYPE(ch)) {\n        case break_stmt:\n            return Break(LINENO(n), n->n_col_offset,\n                         n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        case continue_stmt:\n            return Continue(LINENO(n), n->n_col_offset,\n                            n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        case yield_stmt: { /* will reduce to yield_expr */\n            expr_ty exp = ast_for_expr(c, CHILD(ch, 0));\n            if (!exp)\n                return NULL;\n            return Expr(exp, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n        }\n        case return_stmt:\n            if (NCH(ch) == 1)\n                return Return(NULL, LINENO(n), n->n_col_offset,\n                              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            else {\n                expr_ty expression = ast_for_testlist(c, CHILD(ch, 1));\n                if (!expression)\n                    return NULL;\n                return Return(expression, LINENO(n), n->n_col_offset,\n                              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            }\n        case raise_stmt:\n            if (NCH(ch) == 1)\n                return Raise(NULL, NULL, LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            else if (NCH(ch) >= 2) {\n                expr_ty cause = NULL;\n                expr_ty expression = ast_for_expr(c, CHILD(ch, 1));\n                if (!expression)\n                    return NULL;\n                if (NCH(ch) == 4) {\n                    cause = ast_for_expr(c, CHILD(ch, 3));\n                    if (!cause)\n                        return NULL;\n                }\n                return Raise(expression, cause, LINENO(n), n->n_col_offset,\n                             n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            }\n            /* fall through */\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"unexpected flow_stmt: %d\", TYPE(ch));\n            return NULL;\n    }\n}\n\nstatic alias_ty\nalias_for_import_name(struct compiling *c, const node *n, int store)\n{\n    /*\n      import_as_name: NAME ['as' NAME]\n      dotted_as_name: dotted_name ['as' NAME]\n      dotted_name: NAME ('.' NAME)*\n    */\n    identifier str, name;\n\n loop:\n    switch (TYPE(n)) {\n        case import_as_name: {\n            node *name_node = CHILD(n, 0);\n            str = NULL;\n            name = NEW_IDENTIFIER(name_node);\n            if (!name)\n                return NULL;\n            if (NCH(n) == 3) {\n                node *str_node = CHILD(n, 2);\n                str = NEW_IDENTIFIER(str_node);\n                if (!str)\n                    return NULL;\n                if (store && forbidden_name(c, str, str_node, 0))\n                    return NULL;\n            }\n            else {\n                if (forbidden_name(c, name, name_node, 0))\n                    return NULL;\n            }\n            return alias(name, str, c->c_arena);\n        }\n        case dotted_as_name:\n            if (NCH(n) == 1) {\n                n = CHILD(n, 0);\n                goto loop;\n            }\n            else {\n                node *asname_node = CHILD(n, 2);\n                alias_ty a = alias_for_import_name(c, CHILD(n, 0), 0);\n                if (!a)\n                    return NULL;\n                assert(!a->asname);\n                a->asname = NEW_IDENTIFIER(asname_node);\n                if (!a->asname)\n                    return NULL;\n                if (forbidden_name(c, a->asname, asname_node, 0))\n                    return NULL;\n                return a;\n            }\n            break;\n        case dotted_name:\n            if (NCH(n) == 1) {\n                node *name_node = CHILD(n, 0);\n                name = NEW_IDENTIFIER(name_node);\n                if (!name)\n                    return NULL;\n                if (store && forbidden_name(c, name, name_node, 0))\n                    return NULL;\n                return alias(name, NULL, c->c_arena);\n            }\n            else {\n                /* Create a string of the form \"a.b.c\" */\n                int i;\n                size_t len;\n                char *s;\n                PyObject *uni;\n\n                len = 0;\n                for (i = 0; i < NCH(n); i += 2)\n                    /* length of string plus one for the dot */\n                    len += strlen(STR(CHILD(n, i))) + 1;\n                len--; /* the last name doesn't have a dot */\n                str = PyBytes_FromStringAndSize(NULL, len);\n                if (!str)\n                    return NULL;\n                s = PyBytes_AS_STRING(str);\n                if (!s)\n                    return NULL;\n                for (i = 0; i < NCH(n); i += 2) {\n                    char *sch = STR(CHILD(n, i));\n                    strcpy(s, STR(CHILD(n, i)));\n                    s += strlen(sch);\n                    *s++ = '.';\n                }\n                --s;\n                *s = '\\0';\n                uni = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(str),\n                                           PyBytes_GET_SIZE(str),\n                                           NULL);\n                Py_DECREF(str);\n                if (!uni)\n                    return NULL;\n                str = uni;\n                PyUnicode_InternInPlace(&str);\n                if (PyArena_AddPyObject(c->c_arena, str) < 0) {\n                    Py_DECREF(str);\n                    return NULL;\n                }\n                return alias(str, NULL, c->c_arena);\n            }\n            break;\n        case STAR:\n            str = PyUnicode_InternFromString(\"*\");\n            if (!str)\n                return NULL;\n            if (PyArena_AddPyObject(c->c_arena, str) < 0) {\n                Py_DECREF(str);\n                return NULL;\n            }\n            return alias(str, NULL, c->c_arena);\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"unexpected import name: %d\", TYPE(n));\n            return NULL;\n    }\n\n    PyErr_SetString(PyExc_SystemError, \"unhandled import name condition\");\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_import_stmt(struct compiling *c, const node *n)\n{\n    /*\n      import_stmt: import_name | import_from\n      import_name: 'import' dotted_as_names\n      import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+)\n                   'import' ('*' | '(' import_as_names ')' | import_as_names)\n    */\n    int lineno;\n    int col_offset;\n    int i;\n    asdl_seq *aliases;\n\n    REQ(n, import_stmt);\n    lineno = LINENO(n);\n    col_offset = n->n_col_offset;\n    n = CHILD(n, 0);\n    if (TYPE(n) == import_name) {\n        n = CHILD(n, 1);\n        REQ(n, dotted_as_names);\n        aliases = _Py_asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);\n        if (!aliases)\n                return NULL;\n        for (i = 0; i < NCH(n); i += 2) {\n            alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);\n            if (!import_alias)\n                return NULL;\n            asdl_seq_SET(aliases, i / 2, import_alias);\n        }\n        // Even though n is modified above, the end position is not changed\n        return Import(aliases, lineno, col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (TYPE(n) == import_from) {\n        int n_children;\n        int idx, ndots = 0;\n        const node *n_copy = n;\n        alias_ty mod = NULL;\n        identifier modname = NULL;\n\n       /* Count the number of dots (for relative imports) and check for the\n          optional module name */\n        for (idx = 1; idx < NCH(n); idx++) {\n            if (TYPE(CHILD(n, idx)) == dotted_name) {\n                mod = alias_for_import_name(c, CHILD(n, idx), 0);\n                if (!mod)\n                    return NULL;\n                idx++;\n                break;\n            } else if (TYPE(CHILD(n, idx)) == ELLIPSIS) {\n                /* three consecutive dots are tokenized as one ELLIPSIS */\n                ndots += 3;\n                continue;\n            } else if (TYPE(CHILD(n, idx)) != DOT) {\n                break;\n            }\n            ndots++;\n        }\n        idx++; /* skip over the 'import' keyword */\n        switch (TYPE(CHILD(n, idx))) {\n        case STAR:\n            /* from ... import * */\n            n = CHILD(n, idx);\n            n_children = 1;\n            break;\n        case LPAR:\n            /* from ... import (x, y, z) */\n            n = CHILD(n, idx + 1);\n            n_children = NCH(n);\n            break;\n        case import_as_names:\n            /* from ... import x, y, z */\n            n = CHILD(n, idx);\n            n_children = NCH(n);\n            if (n_children % 2 == 0) {\n                ast_error(c, n,\n                          \"trailing comma not allowed without\"\n                          \" surrounding parentheses\");\n                return NULL;\n            }\n            break;\n        default:\n            ast_error(c, n, \"Unexpected node-type in from-import\");\n            return NULL;\n        }\n\n        aliases = _Py_asdl_seq_new((n_children + 1) / 2, c->c_arena);\n        if (!aliases)\n            return NULL;\n\n        /* handle \"from ... import *\" special b/c there's no children */\n        if (TYPE(n) == STAR) {\n            alias_ty import_alias = alias_for_import_name(c, n, 1);\n            if (!import_alias)\n                return NULL;\n            asdl_seq_SET(aliases, 0, import_alias);\n        }\n        else {\n            for (i = 0; i < NCH(n); i += 2) {\n                alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);\n                if (!import_alias)\n                    return NULL;\n                asdl_seq_SET(aliases, i / 2, import_alias);\n            }\n        }\n        if (mod != NULL)\n            modname = mod->name;\n        return ImportFrom(modname, aliases, ndots, lineno, col_offset,\n                          n_copy->n_end_lineno, n_copy->n_end_col_offset,\n                          c->c_arena);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"unknown import statement: starts with command '%s'\",\n                 STR(CHILD(n, 0)));\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_global_stmt(struct compiling *c, const node *n)\n{\n    /* global_stmt: 'global' NAME (',' NAME)* */\n    identifier name;\n    asdl_seq *s;\n    int i;\n\n    REQ(n, global_stmt);\n    s = _Py_asdl_seq_new(NCH(n) / 2, c->c_arena);\n    if (!s)\n        return NULL;\n    for (i = 1; i < NCH(n); i += 2) {\n        name = NEW_IDENTIFIER(CHILD(n, i));\n        if (!name)\n            return NULL;\n        asdl_seq_SET(s, i / 2, name);\n    }\n    return Global(s, LINENO(n), n->n_col_offset,\n                  n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_nonlocal_stmt(struct compiling *c, const node *n)\n{\n    /* nonlocal_stmt: 'nonlocal' NAME (',' NAME)* */\n    identifier name;\n    asdl_seq *s;\n    int i;\n\n    REQ(n, nonlocal_stmt);\n    s = _Py_asdl_seq_new(NCH(n) / 2, c->c_arena);\n    if (!s)\n        return NULL;\n    for (i = 1; i < NCH(n); i += 2) {\n        name = NEW_IDENTIFIER(CHILD(n, i));\n        if (!name)\n            return NULL;\n        asdl_seq_SET(s, i / 2, name);\n    }\n    return Nonlocal(s, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_assert_stmt(struct compiling *c, const node *n)\n{\n    /* assert_stmt: 'assert' test [',' test] */\n    REQ(n, assert_stmt);\n    if (NCH(n) == 2) {\n        expr_ty expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        return Assert(expression, NULL, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    else if (NCH(n) == 4) {\n        expr_ty expr1, expr2;\n\n        expr1 = ast_for_expr(c, CHILD(n, 1));\n        if (!expr1)\n            return NULL;\n        expr2 = ast_for_expr(c, CHILD(n, 3));\n        if (!expr2)\n            return NULL;\n\n        return Assert(expr1, expr2, LINENO(n), n->n_col_offset,\n                      n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"improper number of parts to 'assert' statement: %d\",\n                 NCH(n));\n    return NULL;\n}\n\nstatic asdl_seq *\nast_for_suite(struct compiling *c, const node *n)\n{\n    /* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */\n    asdl_seq *seq;\n    stmt_ty s;\n    int i, total, num, end, pos = 0;\n    node *ch;\n\n    if (TYPE(n) != func_body_suite) {\n        REQ(n, suite);\n    }\n\n    total = num_stmts(n);\n    seq = _Py_asdl_seq_new(total, c->c_arena);\n    if (!seq)\n        return NULL;\n    if (TYPE(CHILD(n, 0)) == simple_stmt) {\n        n = CHILD(n, 0);\n        /* simple_stmt always ends with a NEWLINE,\n           and may have a trailing SEMI\n        */\n        end = NCH(n) - 1;\n        if (TYPE(CHILD(n, end - 1)) == SEMI)\n            end--;\n        /* loop by 2 to skip semi-colons */\n        for (i = 0; i < end; i += 2) {\n            ch = CHILD(n, i);\n            s = ast_for_stmt(c, ch);\n            if (!s)\n                return NULL;\n            asdl_seq_SET(seq, pos++, s);\n        }\n    }\n    else {\n        i = 2;\n        if (TYPE(CHILD(n, 1)) == TYPE_COMMENT) {\n            i += 2;\n            REQ(CHILD(n, 2), NEWLINE);\n        }\n\n        for (; i < (NCH(n) - 1); i++) {\n            ch = CHILD(n, i);\n            REQ(ch, stmt);\n            num = num_stmts(ch);\n            if (num == 1) {\n                /* small_stmt or compound_stmt with only one child */\n                s = ast_for_stmt(c, ch);\n                if (!s)\n                    return NULL;\n                asdl_seq_SET(seq, pos++, s);\n            }\n            else {\n                int j;\n                ch = CHILD(ch, 0);\n                REQ(ch, simple_stmt);\n                for (j = 0; j < NCH(ch); j += 2) {\n                    /* statement terminates with a semi-colon ';' */\n                    if (NCH(CHILD(ch, j)) == 0) {\n                        assert((j + 1) == NCH(ch));\n                        break;\n                    }\n                    s = ast_for_stmt(c, CHILD(ch, j));\n                    if (!s)\n                        return NULL;\n                    asdl_seq_SET(seq, pos++, s);\n                }\n            }\n        }\n    }\n    assert(pos == seq->size);\n    return seq;\n}\n\nstatic void\nget_last_end_pos(asdl_seq *s, int *end_lineno, int *end_col_offset)\n{\n    Py_ssize_t tot = asdl_seq_LEN(s);\n    // There must be no empty suites.\n    assert(tot > 0);\n    stmt_ty last = asdl_seq_GET(s, tot - 1);\n    *end_lineno = last->end_lineno;\n    *end_col_offset = last->end_col_offset;\n}\n\nstatic stmt_ty\nast_for_if_stmt(struct compiling *c, const node *n)\n{\n    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\n       ['else' ':' suite]\n    */\n    char *s;\n    int end_lineno, end_col_offset;\n\n    REQ(n, if_stmt);\n\n    if (NCH(n) == 4) {\n        expr_ty expression;\n        asdl_seq *suite_seq;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, CHILD(n, 3));\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return If(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,\n                  end_lineno, end_col_offset, c->c_arena);\n    }\n\n    s = STR(CHILD(n, 4));\n    /* s[2], the third character in the string, will be\n       's' for el_s_e, or\n       'i' for el_i_f\n    */\n    if (s[2] == 's') {\n        expr_ty expression;\n        asdl_seq *seq1, *seq2;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        seq1 = ast_for_suite(c, CHILD(n, 3));\n        if (!seq1)\n            return NULL;\n        seq2 = ast_for_suite(c, CHILD(n, 6));\n        if (!seq2)\n            return NULL;\n        get_last_end_pos(seq2, &end_lineno, &end_col_offset);\n\n        return If(expression, seq1, seq2, LINENO(n), n->n_col_offset,\n                  end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (s[2] == 'i') {\n        int i, n_elif, has_else = 0;\n        expr_ty expression;\n        asdl_seq *suite_seq;\n        asdl_seq *orelse = NULL;\n        n_elif = NCH(n) - 4;\n        /* must reference the child n_elif+1 since 'else' token is third,\n           not fourth, child from the end. */\n        if (TYPE(CHILD(n, (n_elif + 1))) == NAME\n            && STR(CHILD(n, (n_elif + 1)))[2] == 's') {\n            has_else = 1;\n            n_elif -= 3;\n        }\n        n_elif /= 4;\n\n        if (has_else) {\n            asdl_seq *suite_seq2;\n\n            orelse = _Py_asdl_seq_new(1, c->c_arena);\n            if (!orelse)\n                return NULL;\n            expression = ast_for_expr(c, CHILD(n, NCH(n) - 6));\n            if (!expression)\n                return NULL;\n            suite_seq = ast_for_suite(c, CHILD(n, NCH(n) - 4));\n            if (!suite_seq)\n                return NULL;\n            suite_seq2 = ast_for_suite(c, CHILD(n, NCH(n) - 1));\n            if (!suite_seq2)\n                return NULL;\n            get_last_end_pos(suite_seq2, &end_lineno, &end_col_offset);\n\n            asdl_seq_SET(orelse, 0,\n                         If(expression, suite_seq, suite_seq2,\n                            LINENO(CHILD(n, NCH(n) - 6)),\n                            CHILD(n, NCH(n) - 6)->n_col_offset,\n                            end_lineno, end_col_offset, c->c_arena));\n            /* the just-created orelse handled the last elif */\n            n_elif--;\n        }\n\n        for (i = 0; i < n_elif; i++) {\n            int off = 5 + (n_elif - i - 1) * 4;\n            asdl_seq *newobj = _Py_asdl_seq_new(1, c->c_arena);\n            if (!newobj)\n                return NULL;\n            expression = ast_for_expr(c, CHILD(n, off));\n            if (!expression)\n                return NULL;\n            suite_seq = ast_for_suite(c, CHILD(n, off + 2));\n            if (!suite_seq)\n                return NULL;\n\n            if (orelse != NULL) {\n                get_last_end_pos(orelse, &end_lineno, &end_col_offset);\n            } else {\n                get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n            }\n            asdl_seq_SET(newobj, 0,\n                         If(expression, suite_seq, orelse,\n                            LINENO(CHILD(n, off)),\n                            CHILD(n, off)->n_col_offset,\n                            end_lineno, end_col_offset, c->c_arena));\n            orelse = newobj;\n        }\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, CHILD(n, 3));\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(orelse, &end_lineno, &end_col_offset);\n        return If(expression, suite_seq, orelse,\n                  LINENO(n), n->n_col_offset,\n                  end_lineno, end_col_offset, c->c_arena);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"unexpected token in 'if' statement: %s\", s);\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_while_stmt(struct compiling *c, const node *n)\n{\n    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\n    REQ(n, while_stmt);\n    int end_lineno, end_col_offset;\n\n    if (NCH(n) == 4) {\n        expr_ty expression;\n        asdl_seq *suite_seq;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, CHILD(n, 3));\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n        return While(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,\n                     end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (NCH(n) == 7) {\n        expr_ty expression;\n        asdl_seq *seq1, *seq2;\n\n        expression = ast_for_expr(c, CHILD(n, 1));\n        if (!expression)\n            return NULL;\n        seq1 = ast_for_suite(c, CHILD(n, 3));\n        if (!seq1)\n            return NULL;\n        seq2 = ast_for_suite(c, CHILD(n, 6));\n        if (!seq2)\n            return NULL;\n        get_last_end_pos(seq2, &end_lineno, &end_col_offset);\n\n        return While(expression, seq1, seq2, LINENO(n), n->n_col_offset,\n                     end_lineno, end_col_offset, c->c_arena);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"wrong number of tokens for 'while' statement: %d\",\n                 NCH(n));\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    int has_type_comment;\n    string type_comment;\n\n    if (is_async && c->c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async for loops are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    /* for_stmt: 'for' exprlist 'in' testlist ':' [TYPE_COMMENT] suite ['else' ':' suite] */\n    REQ(n, for_stmt);\n\n    has_type_comment = TYPE(CHILD(n, 5)) == TYPE_COMMENT;\n\n    if (NCH(n) == 9 + has_type_comment) {\n        seq = ast_for_suite(c, CHILD(n, 8 + has_type_comment));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    /* Check the # of children rather than the length of _target, since\n       for x, in ... has 1 element in _target, but still requires a Tuple. */\n    first = (expr_ty)asdl_seq_GET(_target, 0);\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5 + has_type_comment));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, 5));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq, type_comment,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq, type_comment,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic excepthandler_ty\nast_for_except_clause(struct compiling *c, const node *exc, node *body)\n{\n    /* except_clause: 'except' [test ['as' test]] */\n    int end_lineno, end_col_offset;\n    REQ(exc, except_clause);\n    REQ(body, suite);\n\n    if (NCH(exc) == 1) {\n        asdl_seq *suite_seq = ast_for_suite(c, body);\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return ExceptHandler(NULL, NULL, suite_seq, LINENO(exc),\n                             exc->n_col_offset,\n                             end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (NCH(exc) == 2) {\n        expr_ty expression;\n        asdl_seq *suite_seq;\n\n        expression = ast_for_expr(c, CHILD(exc, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, body);\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return ExceptHandler(expression, NULL, suite_seq, LINENO(exc),\n                             exc->n_col_offset,\n                             end_lineno, end_col_offset, c->c_arena);\n    }\n    else if (NCH(exc) == 4) {\n        asdl_seq *suite_seq;\n        expr_ty expression;\n        identifier e = NEW_IDENTIFIER(CHILD(exc, 3));\n        if (!e)\n            return NULL;\n        if (forbidden_name(c, e, CHILD(exc, 3), 0))\n            return NULL;\n        expression = ast_for_expr(c, CHILD(exc, 1));\n        if (!expression)\n            return NULL;\n        suite_seq = ast_for_suite(c, body);\n        if (!suite_seq)\n            return NULL;\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n\n        return ExceptHandler(expression, e, suite_seq, LINENO(exc),\n                             exc->n_col_offset,\n                             end_lineno, end_col_offset, c->c_arena);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"wrong number of children for 'except' clause: %d\",\n                 NCH(exc));\n    return NULL;\n}\n\nstatic stmt_ty\nast_for_try_stmt(struct compiling *c, const node *n)\n{\n    const int nch = NCH(n);\n    int end_lineno, end_col_offset, n_except = (nch - 3)/3;\n    asdl_seq *body, *handlers = NULL, *orelse = NULL, *finally = NULL;\n    excepthandler_ty last_handler;\n\n    REQ(n, try_stmt);\n\n    body = ast_for_suite(c, CHILD(n, 2));\n    if (body == NULL)\n        return NULL;\n\n    if (TYPE(CHILD(n, nch - 3)) == NAME) {\n        if (strcmp(STR(CHILD(n, nch - 3)), \"finally\") == 0) {\n            if (nch >= 9 && TYPE(CHILD(n, nch - 6)) == NAME) {\n                /* we can assume it's an \"else\",\n                   because nch >= 9 for try-else-finally and\n                   it would otherwise have a type of except_clause */\n                orelse = ast_for_suite(c, CHILD(n, nch - 4));\n                if (orelse == NULL)\n                    return NULL;\n                n_except--;\n            }\n\n            finally = ast_for_suite(c, CHILD(n, nch - 1));\n            if (finally == NULL)\n                return NULL;\n            n_except--;\n        }\n        else {\n            /* we can assume it's an \"else\",\n               otherwise it would have a type of except_clause */\n            orelse = ast_for_suite(c, CHILD(n, nch - 1));\n            if (orelse == NULL)\n                return NULL;\n            n_except--;\n        }\n    }\n    else if (TYPE(CHILD(n, nch - 3)) != except_clause) {\n        ast_error(c, n, \"malformed 'try' statement\");\n        return NULL;\n    }\n\n    if (n_except > 0) {\n        int i;\n        /* process except statements to create a try ... except */\n        handlers = _Py_asdl_seq_new(n_except, c->c_arena);\n        if (handlers == NULL)\n            return NULL;\n\n        for (i = 0; i < n_except; i++) {\n            excepthandler_ty e = ast_for_except_clause(c, CHILD(n, 3 + i * 3),\n                                                       CHILD(n, 5 + i * 3));\n            if (!e)\n                return NULL;\n            asdl_seq_SET(handlers, i, e);\n        }\n    }\n\n    assert(finally != NULL || asdl_seq_LEN(handlers));\n        if (finally != NULL) {\n        // finally is always last\n        get_last_end_pos(finally, &end_lineno, &end_col_offset);\n    } else if (orelse != NULL) {\n        // otherwise else is last\n        get_last_end_pos(orelse, &end_lineno, &end_col_offset);\n    } else {\n        // inline the get_last_end_pos logic due to layout mismatch\n        last_handler = (excepthandler_ty) asdl_seq_GET(handlers, n_except - 1);\n        end_lineno = last_handler->end_lineno;\n        end_col_offset = last_handler->end_col_offset;\n    }\n    return Try(body, handlers, orelse, finally, LINENO(n), n->n_col_offset,\n               end_lineno, end_col_offset, c->c_arena);\n}\n\n/* with_item: test ['as' expr] */\nstatic withitem_ty\nast_for_with_item(struct compiling *c, const node *n)\n{\n    expr_ty context_expr, optional_vars = NULL;\n\n    REQ(n, with_item);\n    context_expr = ast_for_expr(c, CHILD(n, 0));\n    if (!context_expr)\n        return NULL;\n    if (NCH(n) == 3) {\n        optional_vars = ast_for_expr(c, CHILD(n, 2));\n\n        if (!optional_vars) {\n            return NULL;\n        }\n        if (!set_context(c, optional_vars, Store, n)) {\n            return NULL;\n        }\n    }\n\n    return withitem(context_expr, optional_vars, c->c_arena);\n}\n\n/* with_stmt: 'with' with_item (',' with_item)*  ':' [TYPE_COMMENT] suite */\nstatic stmt_ty\nast_for_with_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    int i, n_items, nch_minus_type, has_type_comment, end_lineno, end_col_offset;\n    asdl_seq *items, *body;\n    string type_comment;\n\n    if (is_async && c->c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async with statements are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    REQ(n, with_stmt);\n\n    has_type_comment = TYPE(CHILD(n, NCH(n) - 2)) == TYPE_COMMENT;\n    nch_minus_type = NCH(n) - has_type_comment;\n\n    n_items = (nch_minus_type - 2) / 2;\n    items = _Py_asdl_seq_new(n_items, c->c_arena);\n    if (!items)\n        return NULL;\n    for (i = 1; i < nch_minus_type - 2; i += 2) {\n        withitem_ty item = ast_for_with_item(c, CHILD(n, i));\n        if (!item)\n            return NULL;\n        asdl_seq_SET(items, (i - 1) / 2, item);\n    }\n\n    body = ast_for_suite(c, CHILD(n, NCH(n) - 1));\n    if (!body)\n        return NULL;\n    get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, NCH(n) - 2));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncWith(items, body, type_comment, LINENO(n0), n0->n_col_offset,\n                         end_lineno, end_col_offset, c->c_arena);\n    else\n        return With(items, body, type_comment, LINENO(n), n->n_col_offset,\n                    end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_classdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */\n    PyObject *classname;\n    asdl_seq *s;\n    expr_ty call;\n    int end_lineno, end_col_offset;\n\n    REQ(n, classdef);\n\n    if (NCH(n) == 4) { /* class NAME ':' suite */\n        s = ast_for_suite(c, CHILD(n, 3));\n        if (!s)\n            return NULL;\n        get_last_end_pos(s, &end_lineno, &end_col_offset);\n\n        classname = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!classname)\n            return NULL;\n        if (forbidden_name(c, classname, CHILD(n, 3), 0))\n            return NULL;\n        return ClassDef(classname, NULL, NULL, s, decorator_seq,\n                        LINENO(n), n->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    }\n\n    if (TYPE(CHILD(n, 3)) == RPAR) { /* class NAME '(' ')' ':' suite */\n        s = ast_for_suite(c, CHILD(n, 5));\n        if (!s)\n            return NULL;\n        get_last_end_pos(s, &end_lineno, &end_col_offset);\n\n        classname = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!classname)\n            return NULL;\n        if (forbidden_name(c, classname, CHILD(n, 3), 0))\n            return NULL;\n        return ClassDef(classname, NULL, NULL, s, decorator_seq,\n                        LINENO(n), n->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    }\n\n    /* class NAME '(' arglist ')' ':' suite */\n    /* build up a fake Call node so we can extract its pieces */\n    {\n        PyObject *dummy_name;\n        expr_ty dummy;\n        dummy_name = NEW_IDENTIFIER(CHILD(n, 1));\n        if (!dummy_name)\n            return NULL;\n        dummy = Name(dummy_name, Load, LINENO(n), n->n_col_offset,\n                     CHILD(n, 1)->n_end_lineno, CHILD(n, 1)->n_end_col_offset,\n                     c->c_arena);\n        call = ast_for_call(c, CHILD(n, 3), dummy, NULL, CHILD(n, 4));\n        if (!call)\n            return NULL;\n    }\n    s = ast_for_suite(c, CHILD(n, 6));\n    if (!s)\n        return NULL;\n    get_last_end_pos(s, &end_lineno, &end_col_offset);\n\n    classname = NEW_IDENTIFIER(CHILD(n, 1));\n    if (!classname)\n        return NULL;\n    if (forbidden_name(c, classname, CHILD(n, 1), 0))\n        return NULL;\n\n    return ClassDef(classname, call->v.Call.args, call->v.Call.keywords, s,\n                    decorator_seq, LINENO(n), n->n_col_offset,\n                    end_lineno, end_col_offset, c->c_arena);\n}\n\nstatic stmt_ty\nast_for_stmt(struct compiling *c, const node *n)\n{\n    if (TYPE(n) == stmt) {\n        assert(NCH(n) == 1);\n        n = CHILD(n, 0);\n    }\n    if (TYPE(n) == simple_stmt) {\n        assert(num_stmts(n) == 1);\n        n = CHILD(n, 0);\n    }\n    if (TYPE(n) == small_stmt) {\n        n = CHILD(n, 0);\n        /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt\n                  | import_stmt | global_stmt | nonlocal_stmt | assert_stmt\n        */\n        switch (TYPE(n)) {\n            case expr_stmt:\n                return ast_for_expr_stmt(c, n);\n            case del_stmt:\n                return ast_for_del_stmt(c, n);\n            case pass_stmt:\n                return Pass(LINENO(n), n->n_col_offset,\n                            n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n            case flow_stmt:\n                return ast_for_flow_stmt(c, n);\n            case import_stmt:\n                return ast_for_import_stmt(c, n);\n            case global_stmt:\n                return ast_for_global_stmt(c, n);\n            case nonlocal_stmt:\n                return ast_for_nonlocal_stmt(c, n);\n            case assert_stmt:\n                return ast_for_assert_stmt(c, n);\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unhandled small_stmt: TYPE=%d NCH=%d\\n\",\n                             TYPE(n), NCH(n));\n                return NULL;\n        }\n    }\n    else {\n        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\n                        | funcdef | classdef | decorated | async_stmt\n        */\n        node *ch = CHILD(n, 0);\n        REQ(n, compound_stmt);\n        switch (TYPE(ch)) {\n            case if_stmt:\n                return ast_for_if_stmt(c, ch);\n            case while_stmt:\n                return ast_for_while_stmt(c, ch);\n            case for_stmt:\n                return ast_for_for_stmt(c, ch, 0);\n            case try_stmt:\n                return ast_for_try_stmt(c, ch);\n            case with_stmt:\n                return ast_for_with_stmt(c, ch, 0);\n            case funcdef:\n                return ast_for_funcdef(c, ch, NULL);\n            case classdef:\n                return ast_for_classdef(c, ch, NULL);\n            case decorated:\n                return ast_for_decorated(c, ch);\n            case async_stmt:\n                return ast_for_async_stmt(c, ch);\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unhandled compound_stmt: TYPE=%d NCH=%d\\n\",\n                             TYPE(n), NCH(n));\n                return NULL;\n        }\n    }\n}\n\nstatic PyObject *\nparsenumber_raw(struct compiling *c, const char *s)\n{\n    const char *end;\n    long x;\n    double dx;\n    Py_complex compl;\n    int imflag;\n\n    assert(s != NULL);\n    errno = 0;\n    end = s + strlen(s) - 1;\n    imflag = *end == 'j' || *end == 'J';\n    if (s[0] == '0') {\n        x = (long) PyOS_strtoul(s, (char **)&end, 0);\n        if (x < 0 && errno == 0) {\n            return PyLong_FromString(s, (char **)0, 0);\n        }\n    }\n    else\n        x = PyOS_strtol(s, (char **)&end, 0);\n    if (*end == '\\0') {\n        if (errno != 0)\n            return PyLong_FromString(s, (char **)0, 0);\n        return PyLong_FromLong(x);\n    }\n    /* XXX Huge floats may silently fail */\n    if (imflag) {\n        compl.real = 0.;\n        compl.imag = PyOS_string_to_double(s, (char **)&end, NULL);\n        if (compl.imag == -1.0 && PyErr_Occurred())\n            return NULL;\n        return PyComplex_FromCComplex(compl);\n    }\n    else\n    {\n        dx = PyOS_string_to_double(s, NULL, NULL);\n        if (dx == -1.0 && PyErr_Occurred())\n            return NULL;\n        return PyFloat_FromDouble(dx);\n    }\n}\n\nstatic PyObject *\nparsenumber(struct compiling *c, const char *s)\n{\n    char *dup, *end;\n    PyObject *res = NULL;\n\n    assert(s != NULL);\n\n    if (strchr(s, '_') == NULL) {\n        return parsenumber_raw(c, s);\n    }\n    /* Create a duplicate without underscores. */\n    dup = PyMem_Malloc(strlen(s) + 1);\n    if (dup == NULL) {\n        return PyErr_NoMemory();\n    }\n    end = dup;\n    for (; *s; s++) {\n        if (*s != '_') {\n            *end++ = *s;\n        }\n    }\n    *end = '\\0';\n    res = parsenumber_raw(c, dup);\n    PyMem_Free(dup);\n    return res;\n}\n\nstatic PyObject *\ndecode_utf8(struct compiling *c, const char **sPtr, const char *end)\n{\n    const char *s, *t;\n    t = s = *sPtr;\n    /* while (s < end && *s != '\\\\') s++; */ /* inefficient for u\"..\" */\n    while (s < end && (*s & 0x80)) s++;\n    *sPtr = s;\n    return PyUnicode_DecodeUTF8(t, s - t, NULL);\n}\n\nstatic int\nwarn_invalid_escape_sequence(struct compiling *c, const node *n,\n                             unsigned char first_invalid_escape_char)\n{\n    PyObject *msg = PyUnicode_FromFormat(\"invalid escape sequence \\\\%c\",\n                                         first_invalid_escape_char);\n    if (msg == NULL) {\n        return -1;\n    }\n    if (PyErr_WarnExplicitObject(PyExc_SyntaxWarning, msg,\n                                   c->c_filename, LINENO(n),\n                                   NULL, NULL) < 0)\n    {\n        if (PyErr_ExceptionMatches(PyExc_SyntaxWarning)) {\n            /* Replace the SyntaxWarning exception with a SyntaxError\n               to get a more accurate error report */\n            PyErr_Clear();\n            ast_error(c, n, \"%U\", msg);\n        }\n        Py_DECREF(msg);\n        return -1;\n    }\n    Py_DECREF(msg);\n    return 0;\n}\n\nstatic PyObject *\ndecode_unicode_with_escapes(struct compiling *c, const node *n, const char *s,\n                            size_t len)\n{\n    PyObject *v, *u;\n    char *buf;\n    char *p;\n    const char *end;\n\n    /* check for integer overflow */\n    if (len > SIZE_MAX / 6)\n        return NULL;\n    /* \"\u00e4\" (2 bytes) may become \"\\U000000E4\" (10 bytes), or 1:5\n       \"\\\u00e4\" (3 bytes) may become \"\\u005c\\U000000E4\" (16 bytes), or ~1:6 */\n    u = PyBytes_FromStringAndSize((char *)NULL, len * 6);\n    if (u == NULL)\n        return NULL;\n    p = buf = PyBytes_AsString(u);\n    end = s + len;\n    while (s < end) {\n        if (*s == '\\\\') {\n            *p++ = *s++;\n            if (s >= end || *s & 0x80) {\n                strcpy(p, \"u005c\");\n                p += 5;\n                if (s >= end)\n                    break;\n            }\n        }\n        if (*s & 0x80) { /* XXX inefficient */\n            PyObject *w;\n            int kind;\n            void *data;\n            Py_ssize_t len, i;\n            w = decode_utf8(c, &s, end);\n            if (w == NULL) {\n                Py_DECREF(u);\n                return NULL;\n            }\n            kind = PyUnicode_KIND(w);\n            data = PyUnicode_DATA(w);\n            len = PyUnicode_GET_LENGTH(w);\n            for (i = 0; i < len; i++) {\n                Py_UCS4 chr = PyUnicode_READ(kind, data, i);\n                sprintf(p, \"\\\\U%08x\", chr);\n                p += 10;\n            }\n            /* Should be impossible to overflow */\n            assert(p - buf <= PyBytes_GET_SIZE(u));\n            Py_DECREF(w);\n        } else {\n            *p++ = *s++;\n        }\n    }\n    len = p - buf;\n    s = buf;\n\n    const char *first_invalid_escape;\n    v = _PyUnicode_DecodeUnicodeEscape(s, len, NULL, &first_invalid_escape);\n\n    if (v != NULL && first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {\n            /* We have not decref u before because first_invalid_escape points\n               inside u. */\n            Py_XDECREF(u);\n            Py_DECREF(v);\n            return NULL;\n        }\n    }\n    Py_XDECREF(u);\n    return v;\n}\n\nstatic PyObject *\ndecode_bytes_with_escapes(struct compiling *c, const node *n, const char *s,\n                          size_t len)\n{\n    const char *first_invalid_escape;\n    PyObject *result = _PyBytes_DecodeEscape(s, len, NULL, 0, NULL,\n                                             &first_invalid_escape);\n    if (result == NULL)\n        return NULL;\n\n    if (first_invalid_escape != NULL) {\n        if (warn_invalid_escape_sequence(c, n, *first_invalid_escape) < 0) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    }\n    return result;\n}\n\n/* Shift locations for the given node and all its children by adding `lineno`\n   and `col_offset` to existing locations. */\nstatic void fstring_shift_node_locations(node *n, int lineno, int col_offset)\n{\n    n->n_col_offset = n->n_col_offset + col_offset;\n    n->n_end_col_offset = n->n_end_col_offset + col_offset;\n    for (int i = 0; i < NCH(n); ++i) {\n        if (n->n_lineno && n->n_lineno < CHILD(n, i)->n_lineno) {\n            /* Shifting column offsets unnecessary if there's been newlines. */\n            col_offset = 0;\n        }\n        fstring_shift_node_locations(CHILD(n, i), lineno, col_offset);\n    }\n    n->n_lineno = n->n_lineno + lineno;\n    n->n_end_lineno = n->n_end_lineno + lineno;\n}\n\n/* Fix locations for the given node and its children.\n\n   `parent` is the enclosing node.\n   `n` is the node which locations are going to be fixed relative to parent.\n   `expr_str` is the child node's string representation, including braces.\n*/\nstatic void\nfstring_fix_node_location(const node *parent, node *n, char *expr_str)\n{\n    char *substr = NULL;\n    char *start;\n    int lines = LINENO(parent) - 1;\n    int cols = parent->n_col_offset;\n    /* Find the full fstring to fix location information in `n`. */\n    while (parent && parent->n_type != STRING)\n        parent = parent->n_child;\n    if (parent && parent->n_str) {\n        substr = strstr(parent->n_str, expr_str);\n        if (substr) {\n            start = substr;\n            while (start > parent->n_str) {\n                if (start[0] == '\\n')\n                    break;\n                start--;\n            }\n            cols += (int)(substr - start);\n            /* adjust the start based on the number of newlines encountered\n               before the f-string expression */\n            for (char* p = parent->n_str; p < substr; p++) {\n                if (*p == '\\n') {\n                    lines++;\n                }\n            }\n        }\n    }\n    fstring_shift_node_locations(n, lines, cols);\n}\n\n/* Compile this expression in to an expr_ty.  Add parens around the\n   expression, in order to allow leading spaces in the expression. */\nstatic expr_ty\nfstring_compile_expr(const char *expr_start, const char *expr_end,\n                     struct compiling *c, const node *n)\n\n{\n    PyCompilerFlags cf;\n    node *mod_n;\n    mod_ty mod;\n    char *str;\n    Py_ssize_t len;\n    const char *s;\n\n    assert(expr_end >= expr_start);\n    assert(*(expr_start-1) == '{');\n    assert(*expr_end == '}' || *expr_end == '!' || *expr_end == ':');\n\n    /* If the substring is all whitespace, it's an error.  We need to catch this\n       here, and not when we call PyParser_SimpleParseStringFlagsFilename,\n       because turning the expression '' in to '()' would go from being invalid\n       to valid. */\n    for (s = expr_start; s != expr_end; s++) {\n        char c = *s;\n        /* The Python parser ignores only the following whitespace\n           characters (\\r already is converted to \\n). */\n        if (!(c == ' ' || c == '\\t' || c == '\\n' || c == '\\f')) {\n            break;\n        }\n    }\n    if (s == expr_end) {\n        ast_error(c, n, \"f-string: empty expression not allowed\");\n        return NULL;\n    }\n\n    len = expr_end - expr_start;\n    /* Allocate 3 extra bytes: open paren, close paren, null byte. */\n    str = PyMem_RawMalloc(len + 3);\n    if (str == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    str[0] = '(';\n    memcpy(str+1, expr_start, len);\n    str[len+1] = ')';\n    str[len+2] = 0;\n\n    cf.cf_flags = PyCF_ONLY_AST;\n    cf.cf_feature_version = PY_MINOR_VERSION;\n    mod_n = PyParser_SimpleParseStringFlagsFilename(str, \"<fstring>\",\n                                                    Py_eval_input, 0);\n    if (!mod_n) {\n        PyMem_RawFree(str);\n        return NULL;\n    }\n    /* Reuse str to find the correct column offset. */\n    str[0] = '{';\n    str[len+1] = '}';\n    fstring_fix_node_location(n, mod_n, str);\n    mod = PyAST_FromNode(mod_n, &cf, \"<fstring>\", c->c_arena);\n    PyMem_RawFree(str);\n    PyNode_Free(mod_n);\n    if (!mod)\n        return NULL;\n    return mod->v.Expression.body;\n}\n\n/* Return -1 on error.\n\n   Return 0 if we reached the end of the literal.\n\n   Return 1 if we haven't reached the end of the literal, but we want\n   the caller to process the literal up to this point. Used for\n   doubled braces.\n*/\nstatic int\nfstring_find_literal(const char **str, const char *end, int raw,\n                     PyObject **literal, int recurse_lvl,\n                     struct compiling *c, const node *n)\n{\n    /* Get any literal string. It ends when we hit an un-doubled left\n       brace (which isn't part of a unicode name escape such as\n       \"\\N{EULER CONSTANT}\"), or the end of the string. */\n\n    const char *s = *str;\n    const char *literal_start = s;\n    int result = 0;\n\n    assert(*literal == NULL);\n    while (s < end) {\n        char ch = *s++;\n        if (!raw && ch == '\\\\' && s < end) {\n            ch = *s++;\n            if (ch == 'N') {\n                if (s < end && *s++ == '{') {\n                    while (s < end && *s++ != '}') {\n                    }\n                    continue;\n                }\n                break;\n            }\n            if (ch == '{' && warn_invalid_escape_sequence(c, n, ch) < 0) {\n                return -1;\n            }\n        }\n        if (ch == '{' || ch == '}') {\n            /* Check for doubled braces, but only at the top level. If\n               we checked at every level, then f'{0:{3}}' would fail\n               with the two closing braces. */\n            if (recurse_lvl == 0) {\n                if (s < end && *s == ch) {\n                    /* We're going to tell the caller that the literal ends\n                       here, but that they should continue scanning. But also\n                       skip over the second brace when we resume scanning. */\n                    *str = s + 1;\n                    result = 1;\n                    goto done;\n                }\n\n                /* Where a single '{' is the start of a new expression, a\n                   single '}' is not allowed. */\n                if (ch == '}') {\n                    *str = s - 1;\n                    ast_error(c, n, \"f-string: single '}' is not allowed\");\n                    return -1;\n                }\n            }\n            /* We're either at a '{', which means we're starting another\n               expression; or a '}', which means we're at the end of this\n               f-string (for a nested format_spec). */\n            s--;\n            break;\n        }\n    }\n    *str = s;\n    assert(s <= end);\n    assert(s == end || *s == '{' || *s == '}');\ndone:\n    if (literal_start != s) {\n        if (raw)\n            *literal = PyUnicode_DecodeUTF8Stateful(literal_start,\n                                                    s - literal_start,\n                                                    NULL, NULL);\n        else\n            *literal = decode_unicode_with_escapes(c, n, literal_start,\n                                                   s - literal_start);\n        if (!*literal)\n            return -1;\n    }\n    return result;\n}\n\n/* Forward declaration because parsing is recursive. */\nstatic expr_ty\nfstring_parse(const char **str, const char *end, int raw, int recurse_lvl,\n              struct compiling *c, const node *n);\n\n/* Parse the f-string at *str, ending at end.  We know *str starts an\n   expression (so it must be a '{'). Returns the FormattedValue node,\n   which includes the expression, conversion character, and\n   format_spec expression.\n\n   Note that I don't do a perfect job here: I don't make sure that a\n   closing brace doesn't match an opening paren, for example. It\n   doesn't need to error on all invalid expressions, just correctly\n   find the end of all valid ones. Any errors inside the expression\n   will be caught when we parse it later. */\nstatic int\nfstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,\n                  expr_ty *expression, struct compiling *c, const node *n)\n{\n    /* Return -1 on error, else 0. */\n\n    const char *expr_start;\n    const char *expr_end;\n    expr_ty simple_expression;\n    expr_ty format_spec = NULL; /* Optional format specifier. */\n    int conversion = -1; /* The conversion char. -1 if not specified. */\n\n    /* 0 if we're not in a string, else the quote char we're trying to\n       match (single or double quote). */\n    char quote_char = 0;\n\n    /* If we're inside a string, 1=normal, 3=triple-quoted. */\n    int string_type = 0;\n\n    /* Keep track of nesting level for braces/parens/brackets in\n       expressions. */\n    Py_ssize_t nested_depth = 0;\n    char parenstack[MAXLEVEL];\n\n    /* Can only nest one level deep. */\n    if (recurse_lvl >= 2) {\n        ast_error(c, n, \"f-string: expressions nested too deeply\");\n        return -1;\n    }\n\n    /* The first char must be a left brace, or we wouldn't have gotten\n       here. Skip over it. */\n    assert(**str == '{');\n    *str += 1;\n\n    expr_start = *str;\n    for (; *str < end; (*str)++) {\n        char ch;\n\n        /* Loop invariants. */\n        assert(nested_depth >= 0);\n        assert(*str >= expr_start && *str < end);\n        if (quote_char)\n            assert(string_type == 1 || string_type == 3);\n        else\n            assert(string_type == 0);\n\n        ch = **str;\n        /* Nowhere inside an expression is a backslash allowed. */\n        if (ch == '\\\\') {\n            /* Error: can't include a backslash character, inside\n               parens or strings or not. */\n            ast_error(c, n,\n                      \"f-string expression part \"\n                      \"cannot include a backslash\");\n            return -1;\n        }\n        if (quote_char) {\n            /* We're inside a string. See if we're at the end. */\n            /* This code needs to implement the same non-error logic\n               as tok_get from tokenizer.c, at the letter_quote\n               label. To actually share that code would be a\n               nightmare. But, it's unlikely to change and is small,\n               so duplicate it here. Note we don't need to catch all\n               of the errors, since they'll be caught when parsing the\n               expression. We just need to match the non-error\n               cases. Thus we can ignore \\n in single-quoted strings,\n               for example. Or non-terminated strings. */\n            if (ch == quote_char) {\n                /* Does this match the string_type (single or triple\n                   quoted)? */\n                if (string_type == 3) {\n                    if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {\n                        /* We're at the end of a triple quoted string. */\n                        *str += 2;\n                        string_type = 0;\n                        quote_char = 0;\n                        continue;\n                    }\n                } else {\n                    /* We're at the end of a normal string. */\n                    quote_char = 0;\n                    string_type = 0;\n                    continue;\n                }\n            }\n        } else if (ch == '\\'' || ch == '\"') {\n            /* Is this a triple quoted string? */\n            if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {\n                string_type = 3;\n                *str += 2;\n            } else {\n                /* Start of a normal string. */\n                string_type = 1;\n            }\n            /* Start looking for the end of the string. */\n            quote_char = ch;\n        } else if (ch == '[' || ch == '{' || ch == '(') {\n            if (nested_depth >= MAXLEVEL) {\n                ast_error(c, n, \"f-string: too many nested parenthesis\");\n                return -1;\n            }\n            parenstack[nested_depth] = ch;\n            nested_depth++;\n        } else if (ch == '#') {\n            /* Error: can't include a comment character, inside parens\n               or not. */\n            ast_error(c, n, \"f-string expression part cannot include '#'\");\n            return -1;\n        } else if (nested_depth == 0 &&\n                   (ch == '!' || ch == ':' || ch == '}')) {\n            /* First, test for the special case of \"!=\". Since '=' is\n               not an allowed conversion character, nothing is lost in\n               this test. */\n            if (ch == '!' && *str+1 < end && *(*str+1) == '=') {\n                /* This isn't a conversion character, just continue. */\n                continue;\n            }\n            /* Normal way out of this loop. */\n            break;\n        } else if (ch == ']' || ch == '}' || ch == ')') {\n            if (!nested_depth) {\n                ast_error(c, n, \"f-string: unmatched '%c'\", ch);\n                return -1;\n            }\n            nested_depth--;\n            int opening = parenstack[nested_depth];\n            if (!((opening == '(' && ch == ')') ||\n                  (opening == '[' && ch == ']') ||\n                  (opening == '{' && ch == '}')))\n            {\n                ast_error(c, n,\n                          \"f-string: closing parenthesis '%c' \"\n                          \"does not match opening parenthesis '%c'\",\n                          ch, opening);\n                return -1;\n            }\n        } else {\n            /* Just consume this char and loop around. */\n        }\n    }\n    expr_end = *str;\n    /* If we leave this loop in a string or with mismatched parens, we\n       don't care. We'll get a syntax error when compiling the\n       expression. But, we can produce a better error message, so\n       let's just do that.*/\n    if (quote_char) {\n        ast_error(c, n, \"f-string: unterminated string\");\n        return -1;\n    }\n    if (nested_depth) {\n        int opening = parenstack[nested_depth - 1];\n        ast_error(c, n, \"f-string: unmatched '%c'\", opening);\n        return -1;\n    }\n\n    if (*str >= end)\n        goto unexpected_end_of_string;\n\n    /* Compile the expression as soon as possible, so we show errors\n       related to the expression before errors related to the\n       conversion or format_spec. */\n    simple_expression = fstring_compile_expr(expr_start, expr_end, c, n);\n    if (!simple_expression)\n        return -1;\n\n    /* Check for a conversion char, if present. */\n    if (**str == '!') {\n        *str += 1;\n        if (*str >= end)\n            goto unexpected_end_of_string;\n\n        conversion = **str;\n        *str += 1;\n\n        /* Validate the conversion. */\n        if (!(conversion == 's' || conversion == 'r'\n              || conversion == 'a')) {\n            ast_error(c, n,\n                      \"f-string: invalid conversion character: \"\n                      \"expected 's', 'r', or 'a'\");\n            return -1;\n        }\n    }\n\n    /* Check for the format spec, if present. */\n    if (*str >= end)\n        goto unexpected_end_of_string;\n    if (**str == ':') {\n        *str += 1;\n        if (*str >= end)\n            goto unexpected_end_of_string;\n\n        /* Parse the format spec. */\n        format_spec = fstring_parse(str, end, raw, recurse_lvl+1, c, n);\n        if (!format_spec)\n            return -1;\n    }\n\n    if (*str >= end || **str != '}')\n        goto unexpected_end_of_string;\n\n    /* We're at a right brace. Consume it. */\n    assert(*str < end);\n    assert(**str == '}');\n    *str += 1;\n\n    /* And now create the FormattedValue node that represents this\n       entire expression with the conversion and format spec. */\n    *expression = FormattedValue(simple_expression, conversion,\n                                 format_spec, LINENO(n), n->n_col_offset,\n                                 n->n_end_lineno, n->n_end_col_offset,\n                                 c->c_arena);\n    if (!*expression)\n        return -1;\n\n    return 0;\n\nunexpected_end_of_string:\n    ast_error(c, n, \"f-string: expecting '}'\");\n    return -1;\n}\n\n/* Return -1 on error.\n\n   Return 0 if we have a literal (possible zero length) and an\n   expression (zero length if at the end of the string.\n\n   Return 1 if we have a literal, but no expression, and we want the\n   caller to call us again. This is used to deal with doubled\n   braces.\n\n   When called multiple times on the string 'a{{b{0}c', this function\n   will return:\n\n   1. the literal 'a{' with no expression, and a return value\n      of 1. Despite the fact that there's no expression, the return\n      value of 1 means we're not finished yet.\n\n   2. the literal 'b' and the expression '0', with a return value of\n      0. The fact that there's an expression means we're not finished.\n\n   3. literal 'c' with no expression and a return value of 0. The\n      combination of the return value of 0 with no expression means\n      we're finished.\n*/\nstatic int\nfstring_find_literal_and_expr(const char **str, const char *end, int raw,\n                              int recurse_lvl, PyObject **literal,\n                              expr_ty *expression,\n                              struct compiling *c, const node *n)\n{\n    int result;\n\n    assert(*literal == NULL && *expression == NULL);\n\n    /* Get any literal string. */\n    result = fstring_find_literal(str, end, raw, literal, recurse_lvl, c, n);\n    if (result < 0)\n        goto error;\n\n    assert(result == 0 || result == 1);\n\n    if (result == 1)\n        /* We have a literal, but don't look at the expression. */\n        return 1;\n\n    if (*str >= end || **str == '}')\n        /* We're at the end of the string or the end of a nested\n           f-string: no expression. The top-level error case where we\n           expect to be at the end of the string but we're at a '}' is\n           handled later. */\n        return 0;\n\n    /* We must now be the start of an expression, on a '{'. */\n    assert(**str == '{');\n\n    if (fstring_find_expr(str, end, raw, recurse_lvl, expression, c, n) < 0)\n        goto error;\n\n    return 0;\n\nerror:\n    Py_CLEAR(*literal);\n    return -1;\n}\n\n#define EXPRLIST_N_CACHED  64\n\ntypedef struct {\n    /* Incrementally build an array of expr_ty, so be used in an\n       asdl_seq. Cache some small but reasonably sized number of\n       expr_ty's, and then after that start dynamically allocating,\n       doubling the number allocated each time. Note that the f-string\n       f'{0}a{1}' contains 3 expr_ty's: 2 FormattedValue's, and one\n       Constant for the literal 'a'. So you add expr_ty's about twice as\n       fast as you add exressions in an f-string. */\n\n    Py_ssize_t allocated;  /* Number we've allocated. */\n    Py_ssize_t size;       /* Number we've used. */\n    expr_ty    *p;         /* Pointer to the memory we're actually\n                              using. Will point to 'data' until we\n                              start dynamically allocating. */\n    expr_ty    data[EXPRLIST_N_CACHED];\n} ExprList;\n\n#ifdef NDEBUG\n#define ExprList_check_invariants(l)\n#else\nstatic void\nExprList_check_invariants(ExprList *l)\n{\n    /* Check our invariants. Make sure this object is \"live\", and\n       hasn't been deallocated. */\n    assert(l->size >= 0);\n    assert(l->p != NULL);\n    if (l->size <= EXPRLIST_N_CACHED)\n        assert(l->data == l->p);\n}\n#endif\n\nstatic void\nExprList_Init(ExprList *l)\n{\n    l->allocated = EXPRLIST_N_CACHED;\n    l->size = 0;\n\n    /* Until we start allocating dynamically, p points to data. */\n    l->p = l->data;\n\n    ExprList_check_invariants(l);\n}\n\nstatic int\nExprList_Append(ExprList *l, expr_ty exp)\n{\n    ExprList_check_invariants(l);\n    if (l->size >= l->allocated) {\n        /* We need to alloc (or realloc) the memory. */\n        Py_ssize_t new_size = l->allocated * 2;\n\n        /* See if we've ever allocated anything dynamically. */\n        if (l->p == l->data) {\n            Py_ssize_t i;\n            /* We're still using the cached data. Switch to\n               alloc-ing. */\n            l->p = PyMem_RawMalloc(sizeof(expr_ty) * new_size);\n            if (!l->p)\n                return -1;\n            /* Copy the cached data into the new buffer. */\n            for (i = 0; i < l->size; i++)\n                l->p[i] = l->data[i];\n        } else {\n            /* Just realloc. */\n            expr_ty *tmp = PyMem_RawRealloc(l->p, sizeof(expr_ty) * new_size);\n            if (!tmp) {\n                PyMem_RawFree(l->p);\n                l->p = NULL;\n                return -1;\n            }\n            l->p = tmp;\n        }\n\n        l->allocated = new_size;\n        assert(l->allocated == 2 * l->size);\n    }\n\n    l->p[l->size++] = exp;\n\n    ExprList_check_invariants(l);\n    return 0;\n}\n\nstatic void\nExprList_Dealloc(ExprList *l)\n{\n    ExprList_check_invariants(l);\n\n    /* If there's been an error, or we've never dynamically allocated,\n       do nothing. */\n    if (!l->p || l->p == l->data) {\n        /* Do nothing. */\n    } else {\n        /* We have dynamically allocated. Free the memory. */\n        PyMem_RawFree(l->p);\n    }\n    l->p = NULL;\n    l->size = -1;\n}\n\nstatic asdl_seq *\nExprList_Finish(ExprList *l, PyArena *arena)\n{\n    asdl_seq *seq;\n\n    ExprList_check_invariants(l);\n\n    /* Allocate the asdl_seq and copy the expressions in to it. */\n    seq = _Py_asdl_seq_new(l->size, arena);\n    if (seq) {\n        Py_ssize_t i;\n        for (i = 0; i < l->size; i++)\n            asdl_seq_SET(seq, i, l->p[i]);\n    }\n    ExprList_Dealloc(l);\n    return seq;\n}\n\n/* The FstringParser is designed to add a mix of strings and\n   f-strings, and concat them together as needed. Ultimately, it\n   generates an expr_ty. */\ntypedef struct {\n    PyObject *last_str;\n    ExprList expr_list;\n    int fmode;\n} FstringParser;\n\n#ifdef NDEBUG\n#define FstringParser_check_invariants(state)\n#else\nstatic void\nFstringParser_check_invariants(FstringParser *state)\n{\n    if (state->last_str)\n        assert(PyUnicode_CheckExact(state->last_str));\n    ExprList_check_invariants(&state->expr_list);\n}\n#endif\n\nstatic void\nFstringParser_Init(FstringParser *state)\n{\n    state->last_str = NULL;\n    state->fmode = 0;\n    ExprList_Init(&state->expr_list);\n    FstringParser_check_invariants(state);\n}\n\nstatic void\nFstringParser_Dealloc(FstringParser *state)\n{\n    FstringParser_check_invariants(state);\n\n    Py_XDECREF(state->last_str);\n    ExprList_Dealloc(&state->expr_list);\n}\n\n/* Constants for the following */\nstatic PyObject *u_kind;\n\n/* Compute 'kind' field for string Constant (either 'u' or None) */\nstatic PyObject *\nmake_kind(struct compiling *c, const node *n)\n{\n    char *s = NULL;\n    PyObject *kind = NULL;\n\n    /* Find the first string literal, if any */\n    while (TYPE(n) != STRING) {\n        if (NCH(n) == 0)\n            return NULL;\n        n = CHILD(n, 0);\n    }\n    REQ(n, STRING);\n\n    /* If it starts with 'u', return a PyUnicode \"u\" string */\n    s = STR(n);\n    if (s && *s == 'u') {\n        if (!u_kind) {\n            u_kind = PyUnicode_InternFromString(\"u\");\n            if (!u_kind)\n                return NULL;\n        }\n        kind = u_kind;\n        if (PyArena_AddPyObject(c->c_arena, kind) < 0) {\n            return NULL;\n        }\n        Py_INCREF(kind);\n    }\n    return kind;\n}\n\n/* Make a Constant node, but decref the PyUnicode object being added. */\nstatic expr_ty\nmake_str_node_and_del(PyObject **str, struct compiling *c, const node* n)\n{\n    PyObject *s = *str;\n    PyObject *kind = NULL;\n    *str = NULL;\n    assert(PyUnicode_CheckExact(s));\n    if (PyArena_AddPyObject(c->c_arena, s) < 0) {\n        Py_DECREF(s);\n        return NULL;\n    }\n    kind = make_kind(c, n);\n    if (kind == NULL && PyErr_Occurred())\n        return NULL;\n    return Constant(s, kind, LINENO(n), n->n_col_offset,\n                    n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n}\n\n/* Add a non-f-string (that is, a regular literal string). str is\n   decref'd. */\nstatic int\nFstringParser_ConcatAndDel(FstringParser *state, PyObject *str)\n{\n    FstringParser_check_invariants(state);\n\n    assert(PyUnicode_CheckExact(str));\n\n    if (PyUnicode_GET_LENGTH(str) == 0) {\n        Py_DECREF(str);\n        return 0;\n    }\n\n    if (!state->last_str) {\n        /* We didn't have a string before, so just remember this one. */\n        state->last_str = str;\n    } else {\n        /* Concatenate this with the previous string. */\n        PyUnicode_AppendAndDel(&state->last_str, str);\n        if (!state->last_str)\n            return -1;\n    }\n    FstringParser_check_invariants(state);\n    return 0;\n}\n\n/* Parse an f-string. The f-string is in *str to end, with no\n   'f' or quotes. */\nstatic int\nFstringParser_ConcatFstring(FstringParser *state, const char **str,\n                            const char *end, int raw, int recurse_lvl,\n                            struct compiling *c, const node *n)\n{\n    FstringParser_check_invariants(state);\n    state->fmode = 1;\n\n    /* Parse the f-string. */\n    while (1) {\n        PyObject *literal = NULL;\n        expr_ty expression = NULL;\n\n        /* If there's a zero length literal in front of the\n           expression, literal will be NULL. If we're at the end of\n           the f-string, expression will be NULL (unless result == 1,\n           see below). */\n        int result = fstring_find_literal_and_expr(str, end, raw, recurse_lvl,\n                                                   &literal, &expression,\n                                                   c, n);\n        if (result < 0)\n            return -1;\n\n        /* Add the literal, if any. */\n        if (!literal) {\n            /* Do nothing. Just leave last_str alone (and possibly\n               NULL). */\n        } else if (!state->last_str) {\n            /*  Note that the literal can be zero length, if the\n                input string is \"\\\\\\n\" or \"\\\\\\r\", among others. */\n            state->last_str = literal;\n            literal = NULL;\n        } else {\n            /* We have a literal, concatenate it. */\n            assert(PyUnicode_GET_LENGTH(literal) != 0);\n            if (FstringParser_ConcatAndDel(state, literal) < 0)\n                return -1;\n            literal = NULL;\n        }\n\n        /* We've dealt with the literal now. It can't be leaked on further\n           errors. */\n        assert(literal == NULL);\n\n        /* See if we should just loop around to get the next literal\n           and expression, while ignoring the expression this\n           time. This is used for un-doubling braces, as an\n           optimization. */\n        if (result == 1)\n            continue;\n\n        if (!expression)\n            /* We're done with this f-string. */\n            break;\n\n        /* We know we have an expression. Convert any existing string\n           to a Constant node. */\n        if (!state->last_str) {\n            /* Do nothing. No previous literal. */\n        } else {\n            /* Convert the existing last_str literal to a Constant node. */\n            expr_ty str = make_str_node_and_del(&state->last_str, c, n);\n            if (!str || ExprList_Append(&state->expr_list, str) < 0)\n                return -1;\n        }\n\n        if (ExprList_Append(&state->expr_list, expression) < 0)\n            return -1;\n    }\n\n    /* If recurse_lvl is zero, then we must be at the end of the\n       string. Otherwise, we must be at a right brace. */\n\n    if (recurse_lvl == 0 && *str < end-1) {\n        ast_error(c, n, \"f-string: unexpected end of string\");\n        return -1;\n    }\n    if (recurse_lvl != 0 && **str != '}') {\n        ast_error(c, n, \"f-string: expecting '}'\");\n        return -1;\n    }\n\n    FstringParser_check_invariants(state);\n    return 0;\n}\n\n/* Convert the partial state reflected in last_str and expr_list to an\n   expr_ty. The expr_ty can be a Constant, or a JoinedStr. */\nstatic expr_ty\nFstringParser_Finish(FstringParser *state, struct compiling *c,\n                     const node *n)\n{\n    asdl_seq *seq;\n\n    FstringParser_check_invariants(state);\n\n    /* If we're just a constant string with no expressions, return\n       that. */\n    if (!state->fmode) {\n        assert(!state->expr_list.size);\n        if (!state->last_str) {\n            /* Create a zero length string. */\n            state->last_str = PyUnicode_FromStringAndSize(NULL, 0);\n            if (!state->last_str)\n                goto error;\n        }\n        return make_str_node_and_del(&state->last_str, c, n);\n    }\n\n    /* Create a Constant node out of last_str, if needed. It will be the\n       last node in our expression list. */\n    if (state->last_str) {\n        expr_ty str = make_str_node_and_del(&state->last_str, c, n);\n        if (!str || ExprList_Append(&state->expr_list, str) < 0)\n            goto error;\n    }\n    /* This has already been freed. */\n    assert(state->last_str == NULL);\n\n    seq = ExprList_Finish(&state->expr_list, c->c_arena);\n    if (!seq)\n        goto error;\n\n    return JoinedStr(seq, LINENO(n), n->n_col_offset,\n                     n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n\nerror:\n    FstringParser_Dealloc(state);\n    return NULL;\n}\n\n/* Given an f-string (with no 'f' or quotes) that's in *str and ends\n   at end, parse it into an expr_ty.  Return NULL on error.  Adjust\n   str to point past the parsed portion. */\nstatic expr_ty\nfstring_parse(const char **str, const char *end, int raw, int recurse_lvl,\n              struct compiling *c, const node *n)\n{\n    FstringParser state;\n\n    FstringParser_Init(&state);\n    if (FstringParser_ConcatFstring(&state, str, end, raw, recurse_lvl,\n                                    c, n) < 0) {\n        FstringParser_Dealloc(&state);\n        return NULL;\n    }\n\n    return FstringParser_Finish(&state, c, n);\n}\n\n/* n is a Python string literal, including the bracketing quote\n   characters, and r, b, u, &/or f prefixes (if any), and embedded\n   escape sequences (if any). parsestr parses it, and sets *result to\n   decoded Python string object.  If the string is an f-string, set\n   *fstr and *fstrlen to the unparsed string object.  Return 0 if no\n   errors occurred.\n*/\nstatic int\nparsestr(struct compiling *c, const node *n, int *bytesmode, int *rawmode,\n         PyObject **result, const char **fstr, Py_ssize_t *fstrlen)\n{\n    size_t len;\n    const char *s = STR(n);\n    int quote = Py_CHARMASK(*s);\n    int fmode = 0;\n    *bytesmode = 0;\n    *rawmode = 0;\n    *result = NULL;\n    *fstr = NULL;\n    if (Py_ISALPHA(quote)) {\n        while (!*bytesmode || !*rawmode) {\n            if (quote == 'b' || quote == 'B') {\n                quote = *++s;\n                *bytesmode = 1;\n            }\n            else if (quote == 'u' || quote == 'U') {\n                quote = *++s;\n            }\n            else if (quote == 'r' || quote == 'R') {\n                quote = *++s;\n                *rawmode = 1;\n            }\n            else if (quote == 'f' || quote == 'F') {\n                quote = *++s;\n                fmode = 1;\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /* fstrings are only allowed in Python 3.6 and greater */\n    if (fmode && c->c_feature_version < 6) {\n        ast_error(c, n, \"Format strings are only supported in Python 3.6 and greater\");\n        return -1;\n    }\n\n    if (fmode && *bytesmode) {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    if (quote != '\\'' && quote != '\\\"') {\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    /* Skip the leading quote char. */\n    s++;\n    len = strlen(s);\n    if (len > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"string to parse is too long\");\n        return -1;\n    }\n    if (s[--len] != quote) {\n        /* Last quote char must match the first. */\n        PyErr_BadInternalCall();\n        return -1;\n    }\n    if (len >= 4 && s[0] == quote && s[1] == quote) {\n        /* A triple quoted string. We've already skipped one quote at\n           the start and one at the end of the string. Now skip the\n           two at the start. */\n        s += 2;\n        len -= 2;\n        /* And check that the last two match. */\n        if (s[--len] != quote || s[--len] != quote) {\n            PyErr_BadInternalCall();\n            return -1;\n        }\n    }\n\n    if (fmode) {\n        /* Just return the bytes. The caller will parse the resulting\n           string. */\n        *fstr = s;\n        *fstrlen = len;\n        return 0;\n    }\n\n    /* Not an f-string. */\n    /* Avoid invoking escape decoding routines if possible. */\n    *rawmode = *rawmode || strchr(s, '\\\\') == NULL;\n    if (*bytesmode) {\n        /* Disallow non-ASCII characters. */\n        const char *ch;\n        for (ch = s; *ch; ch++) {\n            if (Py_CHARMASK(*ch) >= 0x80) {\n                ast_error(c, n,\n                          \"bytes can only contain ASCII \"\n                          \"literal characters.\");\n                return -1;\n            }\n        }\n        if (*rawmode)\n            *result = PyBytes_FromStringAndSize(s, len);\n        else\n            *result = decode_bytes_with_escapes(c, n, s, len);\n    } else {\n        if (*rawmode)\n            *result = PyUnicode_DecodeUTF8Stateful(s, len, NULL, NULL);\n        else\n            *result = decode_unicode_with_escapes(c, n, s, len);\n    }\n    return *result == NULL ? -1 : 0;\n}\n\n/* Accepts a STRING+ atom, and produces an expr_ty node. Run through\n   each STRING atom, and process it as needed. For bytes, just\n   concatenate them together, and the result will be a Constant node. For\n   normal strings and f-strings, concatenate them together. The result\n   will be a Constant node if there were no f-strings; a FormattedValue\n   node if there's just an f-string (with no leading or trailing\n   literals), or a JoinedStr node if there are multiple f-strings or\n   any literals involved. */\nstatic expr_ty\nparsestrplus(struct compiling *c, const node *n)\n{\n    int bytesmode = 0;\n    PyObject *bytes_str = NULL;\n    int i;\n\n    FstringParser state;\n    FstringParser_Init(&state);\n\n    for (i = 0; i < NCH(n); i++) {\n        int this_bytesmode;\n        int this_rawmode;\n        PyObject *s;\n        const char *fstr;\n        Py_ssize_t fstrlen = -1;  /* Silence a compiler warning. */\n\n        REQ(CHILD(n, i), STRING);\n        if (parsestr(c, CHILD(n, i), &this_bytesmode, &this_rawmode, &s,\n                     &fstr, &fstrlen) != 0)\n            goto error;\n\n        /* Check that we're not mixing bytes with unicode. */\n        if (i != 0 && bytesmode != this_bytesmode) {\n            ast_error(c, n, \"cannot mix bytes and nonbytes literals\");\n            /* s is NULL if the current string part is an f-string. */\n            Py_XDECREF(s);\n            goto error;\n        }\n        bytesmode = this_bytesmode;\n\n        if (fstr != NULL) {\n            int result;\n            assert(s == NULL && !bytesmode);\n            /* This is an f-string. Parse and concatenate it. */\n            result = FstringParser_ConcatFstring(&state, &fstr, fstr+fstrlen,\n                                                 this_rawmode, 0, c, n);\n            if (result < 0)\n                goto error;\n        } else {\n            /* A string or byte string. */\n            assert(s != NULL && fstr == NULL);\n\n            assert(bytesmode ? PyBytes_CheckExact(s) :\n                   PyUnicode_CheckExact(s));\n\n            if (bytesmode) {\n                /* For bytes, concat as we go. */\n                if (i == 0) {\n                    /* First time, just remember this value. */\n                    bytes_str = s;\n                } else {\n                    PyBytes_ConcatAndDel(&bytes_str, s);\n                    if (!bytes_str)\n                        goto error;\n                }\n            } else {\n                /* This is a regular string. Concatenate it. */\n                if (FstringParser_ConcatAndDel(&state, s) < 0)\n                    goto error;\n            }\n        }\n    }\n    if (bytesmode) {\n        /* Just return the bytes object and we're done. */\n        if (PyArena_AddPyObject(c->c_arena, bytes_str) < 0)\n            goto error;\n        return Constant(bytes_str, NULL, LINENO(n), n->n_col_offset,\n                        n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    }\n\n    /* We're not a bytes string, bytes_str should never have been set. */\n    assert(bytes_str == NULL);\n\n    return FstringParser_Finish(&state, c, n);\n\nerror:\n    Py_XDECREF(bytes_str);\n    FstringParser_Dealloc(&state);\n    return NULL;\n}\n\nPyObject *\n_PyAST_GetDocString(asdl_seq *body)\n{\n    if (!asdl_seq_LEN(body)) {\n        return NULL;\n    }\n    stmt_ty st = (stmt_ty)asdl_seq_GET(body, 0);\n    if (st->kind != Expr_kind) {\n        return NULL;\n    }\n    expr_ty e = st->v.Expr.value;\n    if (e->kind == Constant_kind && PyUnicode_CheckExact(e->v.Constant.value)) {\n        return e->v.Constant.value;\n    }\n    return NULL;\n}\n"], "filenames": ["Python/ast.c"], "buggy_code_start_loc": [1403], "buggy_code_end_loc": [1603], "fixing_code_start_loc": [1403], "fixing_code_end_loc": [1603], "type": "CWE-125", "message": "typed_ast 1.3.0 and 1.3.1 has a handle_keywordonly_args out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)", "other": {"cve": {"id": "CVE-2019-19274", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-26T15:15:12.770", "lastModified": "2020-03-14T02:15:10.400", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "typed_ast 1.3.0 and 1.3.1 has a handle_keywordonly_args out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)"}, {"lang": "es", "value": "typed_ast versiones 1.3.0 y 1.3.1, presenta una lectura fuera de l\u00edmites de la funci\u00f3n handle_keywordonly_args. Un atacante con la capacidad de causar que un int\u00e9rprete de Python analice el origen de Python (pero no necesariamente lo ejecute) puede bloquear el proceso del int\u00e9rprete. Esto podr\u00eda ser una preocupaci\u00f3n, por ejemplo, en un servicio basado en la web que analiza (pero no ejecuta) el c\u00f3digo Python. (Este problema tambi\u00e9n afect\u00f3 a determinadas versiones previas de Python 3.8.0-alpha)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python:typed_ast:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "A89928A4-7430-4874-BE50-9870FB8388D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:python:typed_ast:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "31501157-938B-4795-AF8E-C23C5BC1AD2D"}]}]}], "references": [{"url": "https://bugs.python.org/issue36495", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/python/cpython/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/python/cpython/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LG5H4Q6LFVRX7SFXLBEJMNQFI4T5SCEA/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/python/cpython/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e"}}