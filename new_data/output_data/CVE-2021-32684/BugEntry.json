{"buggy_code": ["const logger = require('@scandipwa/scandipwa-dev-utils/logger');\nconst { docker } = require('../config');\nconst executeInContainer = require('../tasks/execute');\n\nmodule.exports = (yargs) => {\n    yargs.command('exec <container name> [commands...]', 'Execute command in docker container', () => {}, async (argv) => {\n        const containers = docker.getContainers();\n        const services = Object.keys(containers);\n\n        if (services.includes(argv.containername) || services.some((service) => service.includes(argv.containername))) {\n            const container = containers[argv.containername]\n                ? containers[argv.containername]\n                : Object.entries(containers).find(([key]) => key.includes(argv.containername))[1];\n\n            if (argv.commands.length === 0) {\n                // if we have default connect command then use it\n                if (container.connectCommand) {\n                    // eslint-disable-next-line no-param-reassign\n                    argv.commands = container.connectCommand;\n                } else {\n                    // otherwise fall back to bash (if it exists inside container)\n                    argv.commands.push('bash');\n                }\n            }\n            await executeInContainer({\n                containerName: container.name,\n                commands: argv.commands\n            });\n\n            return;\n        }\n\n        logger.error(`No container found \"${argv.containername}\"`);\n    });\n};\n", "const logger = require('@scandipwa/scandipwa-dev-utils/logger');\nconst { docker } = require('../config');\nconst { execAsyncSpawn } = require('../util/exec-async-command');\n\nmodule.exports = (yargs) => {\n    yargs.command(\n        'logs <scope>',\n        'Display application logs.',\n        (yargs) => {\n            yargs.option(\n                'tail',\n                {\n                    alias: 'n',\n                    describe: 'Number of lines to show from the end of the logs',\n                    type: 'number'\n                }\n            );\n\n            yargs.option(\n                'details',\n                {\n                    describe: 'Show extra details provided to logs',\n                    type: 'boolean',\n                    default: false\n                }\n            );\n\n            yargs.option(\n                'follow',\n                {\n                    alias: 'f',\n                    describe: 'Follow log output',\n                    type: 'boolean',\n                    default: false\n                }\n            );\n\n            yargs.option(\n                'timestamps',\n                {\n                    alias: 't',\n                    describe: 'Show timestamps',\n                    type: 'boolean',\n                    default: false\n                }\n            );\n            yargs.option(\n                'since',\n                {\n                    describe: 'Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)',\n                    type: 'string'\n                }\n            );\n            yargs.option(\n                'until',\n                {\n                    describe: 'Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)',\n                    type: 'string'\n                }\n            );\n        },\n        async (argv) => {\n            const containers = docker.getContainers();\n            const services = Object.keys(containers);\n\n            if (services.includes(argv.scope) || services.some((service) => service.includes(argv.scope))) {\n                const containerName = containers[argv.scope] ? argv.scope : Object.keys(containers).find((key) => key.includes(argv.scope));\n                const commandArguments = [\n                    argv.follow && '--follow',\n                    argv.tail && `--tail ${argv.tail}`,\n                    argv.details && '--details',\n                    argv.timestamps && '--timestamps',\n                    argv.since && `--since ${argv.since}`,\n                    argv.until && `--until ${argv.until}`\n                ].filter(Boolean).join(' ');\n                const command = `docker logs ${containers[containerName].name} ${commandArguments}`;\n                await execAsyncSpawn(command, {\n                    callback: logger.log\n                });\n\n                return;\n            }\n\n            if (argv.scope === 'magento' || 'magento'.includes(argv.scope)) {\n                await execAsyncSpawn('tail -f var/log/system.log', {\n                    callback: logger.log\n                });\n\n                return;\n            }\n\n            logger.error(`No service found \"${argv.scope}\"`);\n            process.exit(1);\n        }\n    );\n};\n"], "fixing_code": ["const logger = require('@scandipwa/scandipwa-dev-utils/logger');\nconst { docker } = require('../config');\nconst executeInContainer = require('../tasks/execute');\n\nmodule.exports = (yargs) => {\n    yargs.command('exec <container name> [commands...]', 'Execute command in docker container', () => {}, async (argv) => {\n        const containers = (await docker).getContainers();\n        const services = Object.keys(containers);\n\n        if (services.includes(argv.containername) || services.some((service) => service.includes(argv.containername))) {\n            const container = containers[argv.containername]\n                ? containers[argv.containername]\n                : Object.entries(containers).find(([key]) => key.includes(argv.containername))[1];\n\n            if (argv.commands.length === 0) {\n                // if we have default connect command then use it\n                if (container.connectCommand) {\n                    // eslint-disable-next-line no-param-reassign\n                    argv.commands = container.connectCommand;\n                } else {\n                    // otherwise fall back to bash (if it exists inside container)\n                    argv.commands.push('bash');\n                }\n            }\n            await executeInContainer({\n                containerName: container.name,\n                commands: argv.commands\n            });\n\n            return;\n        }\n\n        logger.error(`No container found \"${argv.containername}\"`);\n    });\n};\n", "const logger = require('@scandipwa/scandipwa-dev-utils/logger');\nconst { docker } = require('../config');\nconst { execAsyncSpawn } = require('../util/exec-async-command');\n\nmodule.exports = (yargs) => {\n    yargs.command(\n        'logs <scope>',\n        'Display application logs.',\n        (yargs) => {\n            yargs.option(\n                'tail',\n                {\n                    alias: 'n',\n                    describe: 'Number of lines to show from the end of the logs',\n                    type: 'number'\n                }\n            );\n\n            yargs.option(\n                'details',\n                {\n                    describe: 'Show extra details provided to logs',\n                    type: 'boolean',\n                    default: false\n                }\n            );\n\n            yargs.option(\n                'follow',\n                {\n                    alias: 'f',\n                    describe: 'Follow log output',\n                    type: 'boolean',\n                    default: false\n                }\n            );\n\n            yargs.option(\n                'timestamps',\n                {\n                    alias: 't',\n                    describe: 'Show timestamps',\n                    type: 'boolean',\n                    default: false\n                }\n            );\n            yargs.option(\n                'since',\n                {\n                    describe: 'Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)',\n                    type: 'string'\n                }\n            );\n            yargs.option(\n                'until',\n                {\n                    describe: 'Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)',\n                    type: 'string'\n                }\n            );\n        },\n        async (argv) => {\n            const containers = (await docker).getContainers();\n            const services = Object.keys(containers);\n\n            if (services.includes(argv.scope) || services.some((service) => service.includes(argv.scope))) {\n                const containerName = containers[argv.scope] ? argv.scope : Object.keys(containers).find((key) => key.includes(argv.scope));\n                const commandArguments = [\n                    argv.follow && '--follow',\n                    argv.tail && `--tail ${argv.tail}`,\n                    argv.details && '--details',\n                    argv.timestamps && '--timestamps',\n                    argv.since && `--since ${argv.since}`,\n                    argv.until && `--until ${argv.until}`\n                ].filter(Boolean).join(' ');\n                const command = `docker logs ${containers[containerName].name} ${commandArguments}`;\n                await execAsyncSpawn(command, {\n                    callback: logger.log\n                });\n\n                return;\n            }\n\n            if (argv.scope === 'magento' || 'magento'.includes(argv.scope)) {\n                await execAsyncSpawn('tail -f var/log/system.log', {\n                    callback: logger.log\n                });\n\n                return;\n            }\n\n            logger.error(`No service found \"${argv.scope}\"`);\n            process.exit(1);\n        }\n    );\n};\n"], "filenames": ["build-packages/magento-scripts/lib/commands/execute.js", "build-packages/magento-scripts/lib/commands/logs.js"], "buggy_code_start_loc": [7, 63], "buggy_code_end_loc": [8, 64], "fixing_code_start_loc": [7, 63], "fixing_code_end_loc": [8, 64], "type": "CWE-670", "message": "magento-scripts contains scripts and configuration used by Create Magento App, a zero-configuration tool-chain which allows one to deploy Magento 2. In versions 1.5.1 and 1.5.2, after changing the function from synchronous to asynchronous there wasn't implemented handler in the start, stop, exec, and logs commands, effectively making them unusable. Version 1.5.3 contains patches for the problems.", "other": {"cve": {"id": "CVE-2021-32684", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-14T23:15:07.547", "lastModified": "2021-06-29T15:36:35.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "magento-scripts contains scripts and configuration used by Create Magento App, a zero-configuration tool-chain which allows one to deploy Magento 2. In versions 1.5.1 and 1.5.2, after changing the function from synchronous to asynchronous there wasn't implemented handler in the start, stop, exec, and logs commands, effectively making them unusable. Version 1.5.3 contains patches for the problems."}, {"lang": "es", "value": "magento-scripts contiene los scripts y la configuraci\u00f3n usada por Create Magento App, una cadena de herramientas de cero configuraci\u00f3n que permite desplegar Magento 2. En versiones 1.5.1 y 1.5.2, despu\u00e9s de cambiar la funci\u00f3n de s\u00edncrona a as\u00edncrona no se implement\u00f3 un manejador en los comandos start, stop, exec y logs, haci\u00e9ndolos efectivamente inutilizables. La versi\u00f3n 1.5.3 contiene parches para los problemas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scandipwa:magento-scripts:1.5.1:*:*:*:*:node.js:*:*", "matchCriteriaId": "4DE0AD57-D33F-46BF-8476-5EB6F39462C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scandipwa:magento-scripts:1.5.2:*:*:*:*:node.js:*:*", "matchCriteriaId": "C86ECCAC-F0F9-49A9-A09D-C272184D862E"}]}]}], "references": [{"url": "https://github.com/scandipwa/create-magento-app/commit/89115db7031e181eb8fb4ec2822bc6cab88e7071", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/scandipwa/create-magento-app/security/advisories/GHSA-52qp-gwwh-qrg4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/scandipwa/create-magento-app/commit/89115db7031e181eb8fb4ec2822bc6cab88e7071"}}