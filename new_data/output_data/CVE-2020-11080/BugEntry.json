{"buggy_code": ["# Generated documents\nset(APIDOCS\n  macros.rst\n  enums.rst\n  types.rst\n  nghttp2_check_header_name.rst\n  nghttp2_check_header_value.rst\n  nghttp2_hd_deflate_bound.rst\n  nghttp2_hd_deflate_change_table_size.rst\n  nghttp2_hd_deflate_del.rst\n  nghttp2_hd_deflate_get_dynamic_table_size.rst\n  nghttp2_hd_deflate_get_max_dynamic_table_size.rst\n  nghttp2_hd_deflate_get_num_table_entries.rst\n  nghttp2_hd_deflate_get_table_entry.rst\n  nghttp2_hd_deflate_hd.rst\n  nghttp2_hd_deflate_hd_vec.rst\n  nghttp2_hd_deflate_new.rst\n  nghttp2_hd_deflate_new2.rst\n  nghttp2_hd_inflate_change_table_size.rst\n  nghttp2_hd_inflate_del.rst\n  nghttp2_hd_inflate_end_headers.rst\n  nghttp2_hd_inflate_get_dynamic_table_size.rst\n  nghttp2_hd_inflate_get_max_dynamic_table_size.rst\n  nghttp2_hd_inflate_get_num_table_entries.rst\n  nghttp2_hd_inflate_get_table_entry.rst\n  nghttp2_hd_inflate_hd.rst\n  nghttp2_hd_inflate_hd2.rst\n  nghttp2_hd_inflate_new.rst\n  nghttp2_hd_inflate_new2.rst\n  nghttp2_http2_strerror.rst\n  nghttp2_is_fatal.rst\n  nghttp2_nv_compare_name.rst\n  nghttp2_option_del.rst\n  nghttp2_option_new.rst\n  nghttp2_option_set_builtin_recv_extension_type.rst\n  nghttp2_option_set_max_deflate_dynamic_table_size.rst\n  nghttp2_option_set_max_reserved_remote_streams.rst\n  nghttp2_option_set_max_send_header_block_length.rst\n  nghttp2_option_set_no_auto_ping_ack.rst\n  nghttp2_option_set_no_auto_window_update.rst\n  nghttp2_option_set_no_http_messaging.rst\n  nghttp2_option_set_no_recv_client_magic.rst\n  nghttp2_option_set_peer_max_concurrent_streams.rst\n  nghttp2_option_set_user_recv_extension_type.rst\n  nghttp2_pack_settings_payload.rst\n  nghttp2_priority_spec_check_default.rst\n  nghttp2_priority_spec_default_init.rst\n  nghttp2_priority_spec_init.rst\n  nghttp2_rcbuf_decref.rst\n  nghttp2_rcbuf_get_buf.rst\n  nghttp2_rcbuf_incref.rst\n  nghttp2_rcbuf_is_static.rst\n  nghttp2_select_next_protocol.rst\n  nghttp2_session_callbacks_del.rst\n  nghttp2_session_callbacks_new.rst\n  nghttp2_session_callbacks_set_before_frame_send_callback.rst\n  nghttp2_session_callbacks_set_data_source_read_length_callback.rst\n  nghttp2_session_callbacks_set_error_callback.rst\n  nghttp2_session_callbacks_set_on_begin_frame_callback.rst\n  nghttp2_session_callbacks_set_on_begin_headers_callback.rst\n  nghttp2_session_callbacks_set_on_data_chunk_recv_callback.rst\n  nghttp2_session_callbacks_set_on_extension_chunk_recv_callback.rst\n  nghttp2_session_callbacks_set_on_frame_not_send_callback.rst\n  nghttp2_session_callbacks_set_on_frame_recv_callback.rst\n  nghttp2_session_callbacks_set_on_frame_send_callback.rst\n  nghttp2_session_callbacks_set_on_header_callback.rst\n  nghttp2_session_callbacks_set_on_header_callback2.rst\n  nghttp2_session_callbacks_set_on_invalid_frame_recv_callback.rst\n  nghttp2_session_callbacks_set_on_invalid_header_callback.rst\n  nghttp2_session_callbacks_set_on_invalid_header_callback2.rst\n  nghttp2_session_callbacks_set_on_stream_close_callback.rst\n  nghttp2_session_callbacks_set_pack_extension_callback.rst\n  nghttp2_session_callbacks_set_recv_callback.rst\n  nghttp2_session_callbacks_set_select_padding_callback.rst\n  nghttp2_session_callbacks_set_send_callback.rst\n  nghttp2_session_callbacks_set_send_data_callback.rst\n  nghttp2_session_callbacks_set_unpack_extension_callback.rst\n  nghttp2_session_change_stream_priority.rst\n  nghttp2_session_check_request_allowed.rst\n  nghttp2_session_check_server_session.rst\n  nghttp2_session_client_new.rst\n  nghttp2_session_client_new2.rst\n  nghttp2_session_client_new3.rst\n  nghttp2_session_consume.rst\n  nghttp2_session_consume_connection.rst\n  nghttp2_session_consume_stream.rst\n  nghttp2_session_create_idle_stream.rst\n  nghttp2_session_del.rst\n  nghttp2_session_find_stream.rst\n  nghttp2_session_get_effective_local_window_size.rst\n  nghttp2_session_get_effective_recv_data_length.rst\n  nghttp2_session_get_hd_deflate_dynamic_table_size.rst\n  nghttp2_session_get_hd_inflate_dynamic_table_size.rst\n  nghttp2_session_get_last_proc_stream_id.rst\n  nghttp2_session_get_local_settings.rst\n  nghttp2_session_get_local_window_size.rst\n  nghttp2_session_get_next_stream_id.rst\n  nghttp2_session_get_outbound_queue_size.rst\n  nghttp2_session_get_remote_settings.rst\n  nghttp2_session_get_remote_window_size.rst\n  nghttp2_session_get_root_stream.rst\n  nghttp2_session_get_stream_effective_local_window_size.rst\n  nghttp2_session_get_stream_effective_recv_data_length.rst\n  nghttp2_session_get_stream_local_close.rst\n  nghttp2_session_get_stream_local_window_size.rst\n  nghttp2_session_get_stream_remote_close.rst\n  nghttp2_session_get_stream_remote_window_size.rst\n  nghttp2_session_get_stream_user_data.rst\n  nghttp2_session_mem_recv.rst\n  nghttp2_session_mem_send.rst\n  nghttp2_session_recv.rst\n  nghttp2_session_resume_data.rst\n  nghttp2_session_send.rst\n  nghttp2_session_server_new.rst\n  nghttp2_session_server_new2.rst\n  nghttp2_session_server_new3.rst\n  nghttp2_session_set_local_window_size.rst\n  nghttp2_session_set_next_stream_id.rst\n  nghttp2_session_set_stream_user_data.rst\n  nghttp2_session_terminate_session.rst\n  nghttp2_session_terminate_session2.rst\n  nghttp2_session_upgrade.rst\n  nghttp2_session_upgrade2.rst\n  nghttp2_session_want_read.rst\n  nghttp2_session_want_write.rst\n  nghttp2_set_debug_vprintf_callback.rst\n  nghttp2_stream_get_first_child.rst\n  nghttp2_stream_get_next_sibling.rst\n  nghttp2_stream_get_parent.rst\n  nghttp2_stream_get_previous_sibling.rst\n  nghttp2_stream_get_state.rst\n  nghttp2_stream_get_sum_dependency_weight.rst\n  nghttp2_stream_get_weight.rst\n  nghttp2_strerror.rst\n  nghttp2_submit_altsvc.rst\n  nghttp2_submit_data.rst\n  nghttp2_submit_extension.rst\n  nghttp2_submit_goaway.rst\n  nghttp2_submit_headers.rst\n  nghttp2_submit_ping.rst\n  nghttp2_submit_priority.rst\n  nghttp2_submit_push_promise.rst\n  nghttp2_submit_request.rst\n  nghttp2_submit_response.rst\n  nghttp2_submit_rst_stream.rst\n  nghttp2_submit_settings.rst\n  nghttp2_submit_shutdown_notice.rst\n  nghttp2_submit_trailer.rst\n  nghttp2_submit_window_update.rst\n  nghttp2_version.rst\n)\n\nset(MAN_PAGES\n  nghttp.1\n  nghttpd.1\n  nghttpx.1\n  h2load.1\n)\n\n# Other .rst files from the source tree that need to be copied\n# XXX move them to sources/ and create .in files?\nset(RST_FILES\n  README.rst\n  programmers-guide.rst\n  nghttp.1.rst\n  nghttpd.1.rst\n  nghttpx.1.rst\n  h2load.1.rst\n)\n\n# XXX unused for now\nset(EXTRA_DIST\n  mkapiref.py\n  ${RST_FILES}\n  ${APIDOCS}\n  sources/index.rst\n  sources/tutorial-client.rst\n  sources/tutorial-server.rst\n  sources/tutorial-hpack.rst\n  sources/nghttpx-howto.rst\n  sources/h2load-howto.rst\n  sources/libnghttp2_asio.rst\n  sources/python-apiref.rst\n  sources/building-android-binary.rst\n  sources/contribute.rst\n  _exts/sphinxcontrib/LICENSE.rubydomain\n  _exts/sphinxcontrib/__init__.py\n  _exts/sphinxcontrib/rubydomain.py\n  _themes/sphinx_rtd_theme/__init__.py\n  _themes/sphinx_rtd_theme/breadcrumbs.html\n  _themes/sphinx_rtd_theme/footer.html\n  _themes/sphinx_rtd_theme/layout.html\n  _themes/sphinx_rtd_theme/layout_old.html\n  _themes/sphinx_rtd_theme/search.html\n  _themes/sphinx_rtd_theme/searchbox.html\n  _themes/sphinx_rtd_theme/static/css/badge_only.css\n  _themes/sphinx_rtd_theme/static/css/theme.css\n  _themes/sphinx_rtd_theme/static/fonts/FontAwesome.otf\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.svg\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff\n  _themes/sphinx_rtd_theme/static/js/theme.js\n  _themes/sphinx_rtd_theme/theme.conf\n  _themes/sphinx_rtd_theme/versions.html\n  ${MAN_PAGES}\n  bash_completion/nghttp\n  bash_completion/nghttpd\n  bash_completion/nghttpx\n  bash_completion/h2load\n)\n\n# Based on Makefile for Sphinx documentation\n\n# You can set these variables from the command line.\nset(SPHINXOPTS)\nset(SPHINXBUILD sphinx-build)\nset(PAPER)\nset(BUILDDIR    manual)\n\n# Internal variables.\nset(PAPEROPT_a4     -D latex_paper_size=a4)\nset(PAPEROPT_letter -D latex_paper_size=letter)\nset(ALLSPHINXOPTS   -d ${BUILDDIR}/doctrees ${PAPEROPT_${PAPER}} ${SPHINXOPTS} .)\n\n# \"Please use `make <target>' where <target> is one of\"\n# \"  html       to make standalone HTML files\"\n# \"  dirhtml    to make HTML files named index.html in directories\"\n# \"  singlehtml to make a single large HTML file\"\n# \"  pickle     to make pickle files\"\n# \"  json       to make JSON files\"\n# \"  htmlhelp   to make HTML files and a HTML help project\"\n# \"  qthelp     to make HTML files and a qthelp project\"\n# \"  devhelp    to make HTML files and a Devhelp project\"\n# \"  epub       to make an epub\"\n# \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n# \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n# \"  text       to make text files\"\n# \"  man        to make manual pages\"\n# \"  changes    to make an overview of all changed/added/deprecated items\"\n# \"  linkcheck  to check all external links for integrity\"\n# \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n\n\n# Copy files for out-of-tree builds\nif(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)\n  set(RST_BUILD_FILES)\n  foreach(rstfile IN LISTS RST_FILES)\n    set(outfile \"${CMAKE_CURRENT_BINARY_DIR}/${rstfile}\")\n    add_custom_command(OUTPUT \"${outfile}\"\n      COMMAND ${CMAKE_COMMAND} -E copy\n              \"${CMAKE_CURRENT_SOURCE_DIR}/${rstfile}\" \"${outfile}\"\n      DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/${rstfile}\"\n    )\n    list(APPEND RST_BUILD_FILES \"${outfile}\")\n  endforeach()\nelse()\n  set(RST_BUILD_FILES \"${RST_FILES}\")\nendif()\n\nset(apiref_SOURCES\n  ${CMAKE_BINARY_DIR}/lib/includes/nghttp2/nghttp2ver.h\n  ${CMAKE_SOURCE_DIR}/lib/includes/nghttp2/nghttp2.h\n)\n# Generates apiref.rst and other files\nadd_custom_command(\n  OUTPUT\n    apiref.rst\n    ${APIDOCS}\n  COMMAND\n    \"${PYTHON_EXECUTABLE}\" \"${CMAKE_CURRENT_SOURCE_DIR}/mkapiref.py\"\n    apiref.rst macros.rst enums.rst types.rst .\n    ${apiref_SOURCES}\n  DEPENDS\n    ${RST_BUILD_FILES}\n    ${apiref_SOURCES}\n)\n\n\n\nset_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES \"${BUILDDIR}\")\n\n# Invokes sphinx-build and prints the given messages when completed\nfunction(sphinxbuild builder)\n  set(echo_commands)\n  foreach(message IN LISTS ARGN)\n    list(APPEND echo_commands COMMAND ${CMAKE_COMMAND} -E echo \"${message}\")\n  endforeach()\n  add_custom_target(${builder}\n    COMMAND \"${SPHINXBUILD}\" -b ${builder} ${ALLSPHINXOPTS} \"${BUILDDIR}/${builder}\"\n    COMMAND ${CMAKE_COMMAND} -E echo\n    ${echo_commands}\n    VERBATIM\n    DEPENDS apiref.rst\n  )\nendfunction()\n\nforeach(builder html dirhtml singlehtml)\n  sphinxbuild(${builder}\n    \"Build finished. The HTML pages are in ${BUILDDIR}/${builder}.\")\nendforeach()\nsphinxbuild(pickle  \"Build finished; now you can process the pickle files.\")\nsphinxbuild(json    \"Build finished; now you can process the JSON files.\")\nsphinxbuild(htmlhelp\n  \"Build finished; now you can run HTML Help Workshop with the\"\n  \".hhp project file in ${BUILDDIR}/htmlhelp.\"\n)\nsphinxbuild(qthelp\n  \"Build finished; now you can run \\\"qcollectiongenerator\\\" with the\"\n  \".qhcp project file in ${BUILDDIR}/qthelp, like this:\"\n  \"# qcollectiongenerator ${BUILDDIR}/qthelp/nghttp2.qhcp\"\n  \"To view the help file:\"\n  \"# assistant -collectionFile ${BUILDDIR}/qthelp/nghttp2.qhc\"\n)\nsphinxbuild(devhelp\n  \"Build finished.\"\n  \"To view the help file:\"\n  \"# mkdir -p ~/.local/share/devhelp/nghttp2\"\n  \"# ln -s ${BUILDDIR}/devhelp ~/.local/share/devhelp/nghttp2\"\n  \"# devhelp\"\n)\nsphinxbuild(epub    \"Build finished. The epub file is in ${BUILDDIR}/epub.\")\nsphinxbuild(latex\n  \"Build finished; the LaTeX files are in ${BUILDDIR}/latex.\"\n  \"Run `make' in that directory to run these through (pdf)latex\"\n  \"(use `make latexpdf' here to do that automatically).\"\n)\n\n# Invoke the Makefile generated by sphinx\nadd_custom_target(latexpdf\n  COMMAND ${CMAKE_COMMAND} -E echo \"Running LaTeX files through pdflatex...\"\n  COMMAND make -C \"${BUILDDIR}/latex\" all-pdf\n  COMMAND ${CMAKE_COMMAND} -E echo \"pdflatex finished; the PDF files are in ${BUILDDIR}/latex.\"\n  DEPENDS latex\n)\n\nsphinxbuild(text    \"Build finished. The text files are in ${BUILDDIR}/text.\")\nsphinxbuild(man     \"Build finished. The manual pages are in ${BUILDDIR}/man.\")\nsphinxbuild(changes \"The overview file is in ${BUILDDIR}/changes.\")\nsphinxbuild(linkcheck\n  \"Link check complete; look for any errors in the above output\"\n  \"or in ${BUILDDIR}/linkcheck/output.txt.\"\n)\nsphinxbuild(doctest\n  \"Testing of doctests in the sources finished, look at the\"\n  \"results in ${BUILDDIR}/doctest/output.txt.\"\n)\n\nforeach(_man_page IN LISTS MAN_PAGES)\n  install(FILES ${_man_page}\n    DESTINATION \"${CMAKE_INSTALL_MANDIR}/man1\"\n  )\nendforeach()\n", "# nghttp2 - HTTP/2 C Library\n\n# Copyright (c) 2012 Tatsuhiro Tsujikawa\n\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nman_MANS = nghttp.1 nghttpd.1 nghttpx.1 h2load.1\n\nAPIDOCS= \\\n\tmacros.rst \\\n\tenums.rst \\\n\ttypes.rst \\\n\tnghttp2_check_authority.rst \\\n\tnghttp2_check_header_name.rst \\\n\tnghttp2_check_header_value.rst \\\n\tnghttp2_hd_deflate_bound.rst \\\n\tnghttp2_hd_deflate_change_table_size.rst \\\n\tnghttp2_hd_deflate_del.rst \\\n\tnghttp2_hd_deflate_get_dynamic_table_size.rst \\\n\tnghttp2_hd_deflate_get_max_dynamic_table_size.rst \\\n\tnghttp2_hd_deflate_get_num_table_entries.rst \\\n\tnghttp2_hd_deflate_get_table_entry.rst \\\n\tnghttp2_hd_deflate_hd.rst \\\n\tnghttp2_hd_deflate_hd_vec.rst \\\n\tnghttp2_hd_deflate_new.rst \\\n\tnghttp2_hd_deflate_new2.rst \\\n\tnghttp2_hd_inflate_change_table_size.rst \\\n\tnghttp2_hd_inflate_del.rst \\\n\tnghttp2_hd_inflate_end_headers.rst \\\n\tnghttp2_hd_inflate_get_dynamic_table_size.rst \\\n\tnghttp2_hd_inflate_get_max_dynamic_table_size.rst \\\n\tnghttp2_hd_inflate_get_num_table_entries.rst \\\n\tnghttp2_hd_inflate_get_table_entry.rst \\\n\tnghttp2_hd_inflate_hd.rst \\\n\tnghttp2_hd_inflate_hd2.rst \\\n\tnghttp2_hd_inflate_new.rst \\\n\tnghttp2_hd_inflate_new2.rst \\\n\tnghttp2_http2_strerror.rst \\\n\tnghttp2_is_fatal.rst \\\n\tnghttp2_nv_compare_name.rst \\\n\tnghttp2_option_del.rst \\\n\tnghttp2_option_new.rst \\\n\tnghttp2_option_set_builtin_recv_extension_type.rst \\\n\tnghttp2_option_set_max_deflate_dynamic_table_size.rst \\\n\tnghttp2_option_set_max_reserved_remote_streams.rst \\\n\tnghttp2_option_set_max_send_header_block_length.rst \\\n\tnghttp2_option_set_no_auto_ping_ack.rst \\\n\tnghttp2_option_set_no_auto_window_update.rst \\\n\tnghttp2_option_set_no_closed_streams.rst \\\n\tnghttp2_option_set_no_http_messaging.rst \\\n\tnghttp2_option_set_no_recv_client_magic.rst \\\n\tnghttp2_option_set_peer_max_concurrent_streams.rst \\\n\tnghttp2_option_set_user_recv_extension_type.rst \\\n\tnghttp2_option_set_max_outbound_ack.rst \\\n\tnghttp2_pack_settings_payload.rst \\\n\tnghttp2_priority_spec_check_default.rst \\\n\tnghttp2_priority_spec_default_init.rst \\\n\tnghttp2_priority_spec_init.rst \\\n\tnghttp2_rcbuf_decref.rst \\\n\tnghttp2_rcbuf_get_buf.rst \\\n\tnghttp2_rcbuf_incref.rst \\\n\tnghttp2_rcbuf_is_static.rst \\\n\tnghttp2_select_next_protocol.rst \\\n\tnghttp2_session_callbacks_del.rst \\\n\tnghttp2_session_callbacks_new.rst \\\n\tnghttp2_session_callbacks_set_before_frame_send_callback.rst \\\n\tnghttp2_session_callbacks_set_data_source_read_length_callback.rst \\\n\tnghttp2_session_callbacks_set_error_callback.rst \\\n\tnghttp2_session_callbacks_set_error_callback2.rst \\\n\tnghttp2_session_callbacks_set_on_begin_frame_callback.rst \\\n\tnghttp2_session_callbacks_set_on_begin_headers_callback.rst \\\n\tnghttp2_session_callbacks_set_on_data_chunk_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_extension_chunk_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_frame_not_send_callback.rst \\\n\tnghttp2_session_callbacks_set_on_frame_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_frame_send_callback.rst \\\n\tnghttp2_session_callbacks_set_on_header_callback.rst \\\n\tnghttp2_session_callbacks_set_on_header_callback2.rst \\\n\tnghttp2_session_callbacks_set_on_invalid_frame_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_invalid_header_callback.rst \\\n\tnghttp2_session_callbacks_set_on_invalid_header_callback2.rst \\\n\tnghttp2_session_callbacks_set_on_stream_close_callback.rst \\\n\tnghttp2_session_callbacks_set_pack_extension_callback.rst \\\n\tnghttp2_session_callbacks_set_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_select_padding_callback.rst \\\n\tnghttp2_session_callbacks_set_send_callback.rst \\\n\tnghttp2_session_callbacks_set_send_data_callback.rst \\\n\tnghttp2_session_callbacks_set_unpack_extension_callback.rst \\\n\tnghttp2_session_change_stream_priority.rst \\\n\tnghttp2_session_check_request_allowed.rst \\\n\tnghttp2_session_check_server_session.rst \\\n\tnghttp2_session_client_new.rst \\\n\tnghttp2_session_client_new2.rst \\\n\tnghttp2_session_client_new3.rst \\\n\tnghttp2_session_consume.rst \\\n\tnghttp2_session_consume_connection.rst \\\n\tnghttp2_session_consume_stream.rst \\\n\tnghttp2_session_create_idle_stream.rst \\\n\tnghttp2_session_del.rst \\\n\tnghttp2_session_find_stream.rst \\\n\tnghttp2_session_get_effective_local_window_size.rst \\\n\tnghttp2_session_get_effective_recv_data_length.rst \\\n\tnghttp2_session_get_hd_deflate_dynamic_table_size.rst \\\n\tnghttp2_session_get_hd_inflate_dynamic_table_size.rst \\\n\tnghttp2_session_get_last_proc_stream_id.rst \\\n\tnghttp2_session_get_local_settings.rst \\\n\tnghttp2_session_get_local_window_size.rst \\\n\tnghttp2_session_get_next_stream_id.rst \\\n\tnghttp2_session_get_outbound_queue_size.rst \\\n\tnghttp2_session_get_remote_settings.rst \\\n\tnghttp2_session_get_remote_window_size.rst \\\n\tnghttp2_session_get_root_stream.rst \\\n\tnghttp2_session_get_stream_effective_local_window_size.rst \\\n\tnghttp2_session_get_stream_effective_recv_data_length.rst \\\n\tnghttp2_session_get_stream_local_close.rst \\\n\tnghttp2_session_get_stream_local_window_size.rst \\\n\tnghttp2_session_get_stream_remote_close.rst \\\n\tnghttp2_session_get_stream_remote_window_size.rst \\\n\tnghttp2_session_get_stream_user_data.rst \\\n\tnghttp2_session_mem_recv.rst \\\n\tnghttp2_session_mem_send.rst \\\n\tnghttp2_session_recv.rst \\\n\tnghttp2_session_resume_data.rst \\\n\tnghttp2_session_send.rst \\\n\tnghttp2_session_server_new.rst \\\n\tnghttp2_session_server_new2.rst \\\n\tnghttp2_session_server_new3.rst \\\n\tnghttp2_session_set_local_window_size.rst \\\n\tnghttp2_session_set_next_stream_id.rst \\\n\tnghttp2_session_set_stream_user_data.rst \\\n\tnghttp2_session_set_user_data.rst \\\n\tnghttp2_session_terminate_session.rst \\\n\tnghttp2_session_terminate_session2.rst \\\n\tnghttp2_session_upgrade.rst \\\n\tnghttp2_session_upgrade2.rst \\\n\tnghttp2_session_want_read.rst \\\n\tnghttp2_session_want_write.rst \\\n\tnghttp2_set_debug_vprintf_callback.rst \\\n\tnghttp2_stream_get_first_child.rst \\\n\tnghttp2_stream_get_next_sibling.rst \\\n\tnghttp2_stream_get_parent.rst \\\n\tnghttp2_stream_get_previous_sibling.rst \\\n\tnghttp2_stream_get_state.rst \\\n\tnghttp2_stream_get_sum_dependency_weight.rst \\\n\tnghttp2_stream_get_weight.rst \\\n\tnghttp2_strerror.rst \\\n\tnghttp2_submit_altsvc.rst \\\n\tnghttp2_submit_data.rst \\\n\tnghttp2_submit_extension.rst \\\n\tnghttp2_submit_goaway.rst \\\n\tnghttp2_submit_headers.rst \\\n\tnghttp2_submit_origin.rst \\\n\tnghttp2_submit_ping.rst \\\n\tnghttp2_submit_priority.rst \\\n\tnghttp2_submit_push_promise.rst \\\n\tnghttp2_submit_request.rst \\\n\tnghttp2_submit_response.rst \\\n\tnghttp2_submit_rst_stream.rst \\\n\tnghttp2_submit_settings.rst \\\n\tnghttp2_submit_shutdown_notice.rst \\\n\tnghttp2_submit_trailer.rst \\\n\tnghttp2_submit_window_update.rst \\\n\tnghttp2_version.rst\n\nRST_FILES = \\\n\tREADME.rst \\\n\tprogrammers-guide.rst \\\n\tnghttp.1.rst \\\n\tnghttpd.1.rst \\\n\tnghttpx.1.rst \\\n\th2load.1.rst\n\nEXTRA_DIST = \\\n\tCMakeLists.txt \\\n\tmkapiref.py \\\n\t$(RST_FILES) \\\n\t$(APIDOCS) \\\n\tsources/index.rst \\\n\tsources/tutorial-client.rst \\\n\tsources/tutorial-server.rst \\\n\tsources/tutorial-hpack.rst \\\n\tsources/nghttpx-howto.rst \\\n\tsources/h2load-howto.rst \\\n\tsources/libnghttp2_asio.rst \\\n\tsources/python-apiref.rst \\\n\tsources/building-android-binary.rst \\\n\tsources/contribute.rst \\\n\t_exts/sphinxcontrib/LICENSE.rubydomain \\\n\t_exts/sphinxcontrib/__init__.py \\\n\t_exts/sphinxcontrib/rubydomain.py \\\n\t_themes/sphinx_rtd_theme/__init__.py \\\n\t_themes/sphinx_rtd_theme/breadcrumbs.html \\\n\t_themes/sphinx_rtd_theme/footer.html \\\n\t_themes/sphinx_rtd_theme/layout.html \\\n\t_themes/sphinx_rtd_theme/layout_old.html \\\n\t_themes/sphinx_rtd_theme/search.html \\\n\t_themes/sphinx_rtd_theme/searchbox.html \\\n\t_themes/sphinx_rtd_theme/static/css/badge_only.css \\\n\t_themes/sphinx_rtd_theme/static/css/theme.css \\\n\t_themes/sphinx_rtd_theme/static/fonts/FontAwesome.otf \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.svg \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff \\\n\t_themes/sphinx_rtd_theme/static/js/theme.js \\\n\t_themes/sphinx_rtd_theme/theme.conf \\\n\t_themes/sphinx_rtd_theme/versions.html \\\n\t$(man_MANS) \\\n\tbash_completion/nghttp \\\n\tbash_completion/nghttpd \\\n\tbash_completion/nghttpx \\\n\tbash_completion/h2load\n\n# Makefile for Sphinx documentation\n#\n\n# You can set these variables from the command line.\nSPHINXOPTS    =\nSPHINXBUILD   = sphinx-build\nPAPER         =\nBUILDDIR      = manual\n\n# Internal variables.\nPAPEROPT_a4     = -D latex_paper_size=a4\nPAPEROPT_letter = -D latex_paper_size=letter\nALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .\n\n.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest\n\nhelp:\n\t@echo \"Please use \\`make <target>' where <target> is one of\"\n\t@echo \"  html       to make standalone HTML files\"\n\t@echo \"  dirhtml    to make HTML files named index.html in directories\"\n\t@echo \"  singlehtml to make a single large HTML file\"\n\t@echo \"  pickle     to make pickle files\"\n\t@echo \"  json       to make JSON files\"\n\t@echo \"  htmlhelp   to make HTML files and a HTML help project\"\n\t@echo \"  qthelp     to make HTML files and a qthelp project\"\n\t@echo \"  devhelp    to make HTML files and a Devhelp project\"\n\t@echo \"  epub       to make an epub\"\n\t@echo \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n\t@echo \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n\t@echo \"  text       to make text files\"\n\t@echo \"  man        to make manual pages\"\n\t@echo \"  changes    to make an overview of all changed/added/deprecated items\"\n\t@echo \"  linkcheck  to check all external links for integrity\"\n\t@echo \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n\napiref.rst: \\\n\t$(top_builddir)/lib/includes/nghttp2/nghttp2ver.h \\\n\t$(top_srcdir)/lib/includes/nghttp2/nghttp2.h\n\tfor i in $(RST_FILES); do [ -e $(builddir)/$$i ] || cp $(srcdir)/$$i $(builddir); done\n\t$(PYTHON) $(top_srcdir)/doc/mkapiref.py \\\n\tapiref.rst macros.rst enums.rst types.rst . $^\n\n$(APIDOCS): apiref.rst\n\nclean-local:\n\tif [ $(srcdir) != $(builddir) ]; then for i in $(RST_FILES); do rm -f $(builddir)/$$i; done fi\n\t-rm -f apiref.rst\n\t-rm -f $(APIDOCS)\n\t-rm -rf $(BUILDDIR)/*\n\nhtml-local: apiref.rst\n\t$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/html.\"\n\ndirhtml:\n\t$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/dirhtml.\"\n\nsinglehtml:\n\t$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml\n\t@echo\n\t@echo \"Build finished. The HTML page is in $(BUILDDIR)/singlehtml.\"\n\npickle:\n\t$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle\n\t@echo\n\t@echo \"Build finished; now you can process the pickle files.\"\n\njson:\n\t$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json\n\t@echo\n\t@echo \"Build finished; now you can process the JSON files.\"\n\nhtmlhelp:\n\t$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp\n\t@echo\n\t@echo \"Build finished; now you can run HTML Help Workshop with the\" \\\n\t      \".hhp project file in $(BUILDDIR)/htmlhelp.\"\n\nqthelp:\n\t$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp\n\t@echo\n\t@echo \"Build finished; now you can run \"qcollectiongenerator\" with the\" \\\n\t      \".qhcp project file in $(BUILDDIR)/qthelp, like this:\"\n\t@echo \"# qcollectiongenerator $(BUILDDIR)/qthelp/nghttp2.qhcp\"\n\t@echo \"To view the help file:\"\n\t@echo \"# assistant -collectionFile $(BUILDDIR)/qthelp/nghttp2.qhc\"\n\ndevhelp:\n\t$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp\n\t@echo\n\t@echo \"Build finished.\"\n\t@echo \"To view the help file:\"\n\t@echo \"# mkdir -p $$HOME/.local/share/devhelp/nghttp2\"\n\t@echo \"# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/nghttp2\"\n\t@echo \"# devhelp\"\n\nepub:\n\t$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub\n\t@echo\n\t@echo \"Build finished. The epub file is in $(BUILDDIR)/epub.\"\n\nlatex:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo\n\t@echo \"Build finished; the LaTeX files are in $(BUILDDIR)/latex.\"\n\t@echo \"Run \\`make' in that directory to run these through (pdf)latex\" \\\n\t      \"(use \\`make latexpdf' here to do that automatically).\"\n\nlatexpdf:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo \"Running LaTeX files through pdflatex...\"\n\t$(MAKE) -C $(BUILDDIR)/latex all-pdf\n\t@echo \"pdflatex finished; the PDF files are in $(BUILDDIR)/latex.\"\n\ntext:\n\t$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text\n\t@echo\n\t@echo \"Build finished. The text files are in $(BUILDDIR)/text.\"\n\nman: apiref.rst\n\t$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man\n\t@echo\n\t@echo \"Build finished. The manual pages are in $(BUILDDIR)/man.\"\n\nchanges:\n\t$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes\n\t@echo\n\t@echo \"The overview file is in $(BUILDDIR)/changes.\"\n\nlinkcheck:\n\t$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck\n\t@echo\n\t@echo \"Link check complete; look for any errors in the above output \" \\\n\t      \"or in $(BUILDDIR)/linkcheck/output.txt.\"\n\ndoctest:\n\t$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest\n\t@echo \"Testing of doctests in the sources finished, look at the \" \\\n\t      \"results in $(BUILDDIR)/doctest/output.txt.\"\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2013, 2014 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_H\n#define NGHTTP2_H\n\n/* Define WIN32 when build target is Win32 API (borrowed from\n   libcurl) */\n#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n#  define WIN32\n#endif\n\n/* Compatibility for non-Clang compilers */\n#ifndef __has_declspec_attribute\n#  define __has_declspec_attribute(x) 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdlib.h>\n#if defined(_MSC_VER) && (_MSC_VER < 1800)\n/* MSVC < 2013 does not have inttypes.h because it is not C99\n   compliant.  See compiler macros and version number in\n   https://sourceforge.net/p/predef/wiki/Compilers/ */\n#  include <stdint.h>\n#else /* !defined(_MSC_VER) || (_MSC_VER >= 1800) */\n#  include <inttypes.h>\n#endif /* !defined(_MSC_VER) || (_MSC_VER >= 1800) */\n#include <sys/types.h>\n#include <stdarg.h>\n\n#include <nghttp2/nghttp2ver.h>\n\n#ifdef NGHTTP2_STATICLIB\n#  define NGHTTP2_EXTERN\n#elif defined(WIN32) || (__has_declspec_attribute(dllexport) &&                \\\n                         __has_declspec_attribute(dllimport))\n#  ifdef BUILDING_NGHTTP2\n#    define NGHTTP2_EXTERN __declspec(dllexport)\n#  else /* !BUILDING_NGHTTP2 */\n#    define NGHTTP2_EXTERN __declspec(dllimport)\n#  endif /* !BUILDING_NGHTTP2 */\n#else    /* !defined(WIN32) */\n#  ifdef BUILDING_NGHTTP2\n#    define NGHTTP2_EXTERN __attribute__((visibility(\"default\")))\n#  else /* !BUILDING_NGHTTP2 */\n#    define NGHTTP2_EXTERN\n#  endif /* !BUILDING_NGHTTP2 */\n#endif   /* !defined(WIN32) */\n\n/**\n * @macro\n *\n * The protocol version identification string of this library\n * supports.  This identifier is used if HTTP/2 is used over TLS.\n */\n#define NGHTTP2_PROTO_VERSION_ID \"h2\"\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_PROTO_VERSION_ID`.\n */\n#define NGHTTP2_PROTO_VERSION_ID_LEN 2\n\n/**\n * @macro\n *\n * The serialized form of ALPN protocol identifier this library\n * supports.  Notice that first byte is the length of following\n * protocol identifier.  This is the same wire format of `TLS ALPN\n * extension <https://tools.ietf.org/html/rfc7301>`_.  This is useful\n * to process incoming ALPN tokens in wire format.\n */\n#define NGHTTP2_PROTO_ALPN \"\\x2h2\"\n\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_PROTO_ALPN`.\n */\n#define NGHTTP2_PROTO_ALPN_LEN (sizeof(NGHTTP2_PROTO_ALPN) - 1)\n\n/**\n * @macro\n *\n * The protocol version identification string of this library\n * supports.  This identifier is used if HTTP/2 is used over cleartext\n * TCP.\n */\n#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID \"h2c\"\n\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_CLEARTEXT_PROTO_VERSION_ID`.\n */\n#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID_LEN 3\n\nstruct nghttp2_session;\n/**\n * @struct\n *\n * The primary structure to hold the resources needed for a HTTP/2\n * session.  The details of this structure are intentionally hidden\n * from the public API.\n */\ntypedef struct nghttp2_session nghttp2_session;\n\n/**\n * @macro\n *\n * The age of :type:`nghttp2_info`\n */\n#define NGHTTP2_VERSION_AGE 1\n\n/**\n * @struct\n *\n * This struct is what `nghttp2_version()` returns.  It holds\n * information about the particular nghttp2 version.\n */\ntypedef struct {\n  /**\n   * Age of this struct.  This instance of nghttp2 sets it to\n   * :macro:`NGHTTP2_VERSION_AGE` but a future version may bump it and\n   * add more struct fields at the bottom\n   */\n  int age;\n  /**\n   * the :macro:`NGHTTP2_VERSION_NUM` number (since age ==1)\n   */\n  int version_num;\n  /**\n   * points to the :macro:`NGHTTP2_VERSION` string (since age ==1)\n   */\n  const char *version_str;\n  /**\n   * points to the :macro:`NGHTTP2_PROTO_VERSION_ID` string this\n   * instance implements (since age ==1)\n   */\n  const char *proto_str;\n  /* -------- the above fields all exist when age == 1 */\n} nghttp2_info;\n\n/**\n * @macro\n *\n * The default weight of stream dependency.\n */\n#define NGHTTP2_DEFAULT_WEIGHT 16\n\n/**\n * @macro\n *\n * The maximum weight of stream dependency.\n */\n#define NGHTTP2_MAX_WEIGHT 256\n\n/**\n * @macro\n *\n * The minimum weight of stream dependency.\n */\n#define NGHTTP2_MIN_WEIGHT 1\n\n/**\n * @macro\n *\n * The maximum window size\n */\n#define NGHTTP2_MAX_WINDOW_SIZE ((int32_t)((1U << 31) - 1))\n\n/**\n * @macro\n *\n * The initial window size for stream level flow control.\n */\n#define NGHTTP2_INITIAL_WINDOW_SIZE ((1 << 16) - 1)\n/**\n * @macro\n *\n * The initial window size for connection level flow control.\n */\n#define NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ((1 << 16) - 1)\n\n/**\n * @macro\n *\n * The default header table size.\n */\n#define NGHTTP2_DEFAULT_HEADER_TABLE_SIZE (1 << 12)\n\n/**\n * @macro\n *\n * The client magic string, which is the first 24 bytes byte string of\n * client connection preface.\n */\n#define NGHTTP2_CLIENT_MAGIC \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\"\n\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_CLIENT_MAGIC`.\n */\n#define NGHTTP2_CLIENT_MAGIC_LEN 24\n\n/**\n * @enum\n *\n * Error codes used in this library.  The code range is [-999, -500],\n * inclusive. The following values are defined:\n */\ntypedef enum {\n  /**\n   * Invalid argument passed.\n   */\n  NGHTTP2_ERR_INVALID_ARGUMENT = -501,\n  /**\n   * Out of buffer space.\n   */\n  NGHTTP2_ERR_BUFFER_ERROR = -502,\n  /**\n   * The specified protocol version is not supported.\n   */\n  NGHTTP2_ERR_UNSUPPORTED_VERSION = -503,\n  /**\n   * Used as a return value from :type:`nghttp2_send_callback`,\n   * :type:`nghttp2_recv_callback` and\n   * :type:`nghttp2_send_data_callback` to indicate that the operation\n   * would block.\n   */\n  NGHTTP2_ERR_WOULDBLOCK = -504,\n  /**\n   * General protocol error\n   */\n  NGHTTP2_ERR_PROTO = -505,\n  /**\n   * The frame is invalid.\n   */\n  NGHTTP2_ERR_INVALID_FRAME = -506,\n  /**\n   * The peer performed a shutdown on the connection.\n   */\n  NGHTTP2_ERR_EOF = -507,\n  /**\n   * Used as a return value from\n   * :func:`nghttp2_data_source_read_callback` to indicate that data\n   * transfer is postponed.  See\n   * :func:`nghttp2_data_source_read_callback` for details.\n   */\n  NGHTTP2_ERR_DEFERRED = -508,\n  /**\n   * Stream ID has reached the maximum value.  Therefore no stream ID\n   * is available.\n   */\n  NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE = -509,\n  /**\n   * The stream is already closed; or the stream ID is invalid.\n   */\n  NGHTTP2_ERR_STREAM_CLOSED = -510,\n  /**\n   * RST_STREAM has been added to the outbound queue.  The stream is\n   * in closing state.\n   */\n  NGHTTP2_ERR_STREAM_CLOSING = -511,\n  /**\n   * The transmission is not allowed for this stream (e.g., a frame\n   * with END_STREAM flag set has already sent).\n   */\n  NGHTTP2_ERR_STREAM_SHUT_WR = -512,\n  /**\n   * The stream ID is invalid.\n   */\n  NGHTTP2_ERR_INVALID_STREAM_ID = -513,\n  /**\n   * The state of the stream is not valid (e.g., DATA cannot be sent\n   * to the stream if response HEADERS has not been sent).\n   */\n  NGHTTP2_ERR_INVALID_STREAM_STATE = -514,\n  /**\n   * Another DATA frame has already been deferred.\n   */\n  NGHTTP2_ERR_DEFERRED_DATA_EXIST = -515,\n  /**\n   * Starting new stream is not allowed (e.g., GOAWAY has been sent\n   * and/or received).\n   */\n  NGHTTP2_ERR_START_STREAM_NOT_ALLOWED = -516,\n  /**\n   * GOAWAY has already been sent.\n   */\n  NGHTTP2_ERR_GOAWAY_ALREADY_SENT = -517,\n  /**\n   * The received frame contains the invalid header block (e.g., There\n   * are duplicate header names; or the header names are not encoded\n   * in US-ASCII character set and not lower cased; or the header name\n   * is zero-length string; or the header value contains multiple\n   * in-sequence NUL bytes).\n   */\n  NGHTTP2_ERR_INVALID_HEADER_BLOCK = -518,\n  /**\n   * Indicates that the context is not suitable to perform the\n   * requested operation.\n   */\n  NGHTTP2_ERR_INVALID_STATE = -519,\n  /**\n   * The user callback function failed due to the temporal error.\n   */\n  NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE = -521,\n  /**\n   * The length of the frame is invalid, either too large or too small.\n   */\n  NGHTTP2_ERR_FRAME_SIZE_ERROR = -522,\n  /**\n   * Header block inflate/deflate error.\n   */\n  NGHTTP2_ERR_HEADER_COMP = -523,\n  /**\n   * Flow control error\n   */\n  NGHTTP2_ERR_FLOW_CONTROL = -524,\n  /**\n   * Insufficient buffer size given to function.\n   */\n  NGHTTP2_ERR_INSUFF_BUFSIZE = -525,\n  /**\n   * Callback was paused by the application\n   */\n  NGHTTP2_ERR_PAUSE = -526,\n  /**\n   * There are too many in-flight SETTING frame and no more\n   * transmission of SETTINGS is allowed.\n   */\n  NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS = -527,\n  /**\n   * The server push is disabled.\n   */\n  NGHTTP2_ERR_PUSH_DISABLED = -528,\n  /**\n   * DATA or HEADERS frame for a given stream has been already\n   * submitted and has not been fully processed yet.  Application\n   * should wait for the transmission of the previously submitted\n   * frame before submitting another.\n   */\n  NGHTTP2_ERR_DATA_EXIST = -529,\n  /**\n   * The current session is closing due to a connection error or\n   * `nghttp2_session_terminate_session()` is called.\n   */\n  NGHTTP2_ERR_SESSION_CLOSING = -530,\n  /**\n   * Invalid HTTP header field was received and stream is going to be\n   * closed.\n   */\n  NGHTTP2_ERR_HTTP_HEADER = -531,\n  /**\n   * Violation in HTTP messaging rule.\n   */\n  NGHTTP2_ERR_HTTP_MESSAGING = -532,\n  /**\n   * Stream was refused.\n   */\n  NGHTTP2_ERR_REFUSED_STREAM = -533,\n  /**\n   * Unexpected internal error, but recovered.\n   */\n  NGHTTP2_ERR_INTERNAL = -534,\n  /**\n   * Indicates that a processing was canceled.\n   */\n  NGHTTP2_ERR_CANCEL = -535,\n  /**\n   * When a local endpoint expects to receive SETTINGS frame, it\n   * receives an other type of frame.\n   */\n  NGHTTP2_ERR_SETTINGS_EXPECTED = -536,\n  /**\n   * The errors < :enum:`NGHTTP2_ERR_FATAL` mean that the library is\n   * under unexpected condition and processing was terminated (e.g.,\n   * out of memory).  If application receives this error code, it must\n   * stop using that :type:`nghttp2_session` object and only allowed\n   * operation for that object is deallocate it using\n   * `nghttp2_session_del()`.\n   */\n  NGHTTP2_ERR_FATAL = -900,\n  /**\n   * Out of memory.  This is a fatal error.\n   */\n  NGHTTP2_ERR_NOMEM = -901,\n  /**\n   * The user callback function failed.  This is a fatal error.\n   */\n  NGHTTP2_ERR_CALLBACK_FAILURE = -902,\n  /**\n   * Invalid client magic (see :macro:`NGHTTP2_CLIENT_MAGIC`) was\n   * received and further processing is not possible.\n   */\n  NGHTTP2_ERR_BAD_CLIENT_MAGIC = -903,\n  /**\n   * Possible flooding by peer was detected in this HTTP/2 session.\n   * Flooding is measured by how many PING and SETTINGS frames with\n   * ACK flag set are queued for transmission.  These frames are\n   * response for the peer initiated frames, and peer can cause memory\n   * exhaustion on server side to send these frames forever and does\n   * not read network.\n   */\n  NGHTTP2_ERR_FLOODED = -904\n} nghttp2_error;\n\n/**\n * @struct\n *\n * The object representing single contiguous buffer.\n */\ntypedef struct {\n  /**\n   * The pointer to the buffer.\n   */\n  uint8_t *base;\n  /**\n   * The length of the buffer.\n   */\n  size_t len;\n} nghttp2_vec;\n\nstruct nghttp2_rcbuf;\n\n/**\n * @struct\n *\n * The object representing reference counted buffer.  The details of\n * this structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_rcbuf nghttp2_rcbuf;\n\n/**\n * @function\n *\n * Increments the reference count of |rcbuf| by 1.\n */\nNGHTTP2_EXTERN void nghttp2_rcbuf_incref(nghttp2_rcbuf *rcbuf);\n\n/**\n * @function\n *\n * Decrements the reference count of |rcbuf| by 1.  If the reference\n * count becomes zero, the object pointed by |rcbuf| will be freed.\n * In this case, application must not use |rcbuf| again.\n */\nNGHTTP2_EXTERN void nghttp2_rcbuf_decref(nghttp2_rcbuf *rcbuf);\n\n/**\n * @function\n *\n * Returns the underlying buffer managed by |rcbuf|.\n */\nNGHTTP2_EXTERN nghttp2_vec nghttp2_rcbuf_get_buf(nghttp2_rcbuf *rcbuf);\n\n/**\n * @function\n *\n * Returns nonzero if the underlying buffer is statically allocated,\n * and 0 otherwise. This can be useful for language bindings that wish\n * to avoid creating duplicate strings for these buffers.\n */\nNGHTTP2_EXTERN int nghttp2_rcbuf_is_static(const nghttp2_rcbuf *rcbuf);\n\n/**\n * @enum\n *\n * The flags for header field name/value pair.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_NV_FLAG_NONE = 0,\n  /**\n   * Indicates that this name/value pair must not be indexed (\"Literal\n   * Header Field never Indexed\" representation must be used in HPACK\n   * encoding).  Other implementation calls this bit as \"sensitive\".\n   */\n  NGHTTP2_NV_FLAG_NO_INDEX = 0x01,\n  /**\n   * This flag is set solely by application.  If this flag is set, the\n   * library does not make a copy of header field name.  This could\n   * improve performance.\n   */\n  NGHTTP2_NV_FLAG_NO_COPY_NAME = 0x02,\n  /**\n   * This flag is set solely by application.  If this flag is set, the\n   * library does not make a copy of header field value.  This could\n   * improve performance.\n   */\n  NGHTTP2_NV_FLAG_NO_COPY_VALUE = 0x04\n} nghttp2_nv_flag;\n\n/**\n * @struct\n *\n * The name/value pair, which mainly used to represent header fields.\n */\ntypedef struct {\n  /**\n   * The |name| byte string.  If this struct is presented from library\n   * (e.g., :type:`nghttp2_on_frame_recv_callback`), |name| is\n   * guaranteed to be NULL-terminated.  For some callbacks\n   * (:type:`nghttp2_before_frame_send_callback`,\n   * :type:`nghttp2_on_frame_send_callback`, and\n   * :type:`nghttp2_on_frame_not_send_callback`), it may not be\n   * NULL-terminated if header field is passed from application with\n   * the flag :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`).  When application\n   * is constructing this struct, |name| is not required to be\n   * NULL-terminated.\n   */\n  uint8_t *name;\n  /**\n   * The |value| byte string.  If this struct is presented from\n   * library (e.g., :type:`nghttp2_on_frame_recv_callback`), |value|\n   * is guaranteed to be NULL-terminated.  For some callbacks\n   * (:type:`nghttp2_before_frame_send_callback`,\n   * :type:`nghttp2_on_frame_send_callback`, and\n   * :type:`nghttp2_on_frame_not_send_callback`), it may not be\n   * NULL-terminated if header field is passed from application with\n   * the flag :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE`).  When\n   * application is constructing this struct, |value| is not required\n   * to be NULL-terminated.\n   */\n  uint8_t *value;\n  /**\n   * The length of the |name|, excluding terminating NULL.\n   */\n  size_t namelen;\n  /**\n   * The length of the |value|, excluding terminating NULL.\n   */\n  size_t valuelen;\n  /**\n   * Bitwise OR of one or more of :type:`nghttp2_nv_flag`.\n   */\n  uint8_t flags;\n} nghttp2_nv;\n\n/**\n * @enum\n *\n * The frame types in HTTP/2 specification.\n */\ntypedef enum {\n  /**\n   * The DATA frame.\n   */\n  NGHTTP2_DATA = 0,\n  /**\n   * The HEADERS frame.\n   */\n  NGHTTP2_HEADERS = 0x01,\n  /**\n   * The PRIORITY frame.\n   */\n  NGHTTP2_PRIORITY = 0x02,\n  /**\n   * The RST_STREAM frame.\n   */\n  NGHTTP2_RST_STREAM = 0x03,\n  /**\n   * The SETTINGS frame.\n   */\n  NGHTTP2_SETTINGS = 0x04,\n  /**\n   * The PUSH_PROMISE frame.\n   */\n  NGHTTP2_PUSH_PROMISE = 0x05,\n  /**\n   * The PING frame.\n   */\n  NGHTTP2_PING = 0x06,\n  /**\n   * The GOAWAY frame.\n   */\n  NGHTTP2_GOAWAY = 0x07,\n  /**\n   * The WINDOW_UPDATE frame.\n   */\n  NGHTTP2_WINDOW_UPDATE = 0x08,\n  /**\n   * The CONTINUATION frame.  This frame type won't be passed to any\n   * callbacks because the library processes this frame type and its\n   * preceding HEADERS/PUSH_PROMISE as a single frame.\n   */\n  NGHTTP2_CONTINUATION = 0x09,\n  /**\n   * The ALTSVC frame, which is defined in `RFC 7383\n   * <https://tools.ietf.org/html/rfc7838#section-4>`_.\n   */\n  NGHTTP2_ALTSVC = 0x0a,\n  /**\n   * The ORIGIN frame, which is defined by `RFC 8336\n   * <https://tools.ietf.org/html/rfc8336>`_.\n   */\n  NGHTTP2_ORIGIN = 0x0c\n} nghttp2_frame_type;\n\n/**\n * @enum\n *\n * The flags for HTTP/2 frames.  This enum defines all flags for all\n * frames.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_FLAG_NONE = 0,\n  /**\n   * The END_STREAM flag.\n   */\n  NGHTTP2_FLAG_END_STREAM = 0x01,\n  /**\n   * The END_HEADERS flag.\n   */\n  NGHTTP2_FLAG_END_HEADERS = 0x04,\n  /**\n   * The ACK flag.\n   */\n  NGHTTP2_FLAG_ACK = 0x01,\n  /**\n   * The PADDED flag.\n   */\n  NGHTTP2_FLAG_PADDED = 0x08,\n  /**\n   * The PRIORITY flag.\n   */\n  NGHTTP2_FLAG_PRIORITY = 0x20\n} nghttp2_flag;\n\n/**\n * @enum\n * The SETTINGS ID.\n */\ntypedef enum {\n  /**\n   * SETTINGS_HEADER_TABLE_SIZE\n   */\n  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE = 0x01,\n  /**\n   * SETTINGS_ENABLE_PUSH\n   */\n  NGHTTP2_SETTINGS_ENABLE_PUSH = 0x02,\n  /**\n   * SETTINGS_MAX_CONCURRENT_STREAMS\n   */\n  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = 0x03,\n  /**\n   * SETTINGS_INITIAL_WINDOW_SIZE\n   */\n  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE = 0x04,\n  /**\n   * SETTINGS_MAX_FRAME_SIZE\n   */\n  NGHTTP2_SETTINGS_MAX_FRAME_SIZE = 0x05,\n  /**\n   * SETTINGS_MAX_HEADER_LIST_SIZE\n   */\n  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = 0x06,\n  /**\n   * SETTINGS_ENABLE_CONNECT_PROTOCOL\n   * (`RFC 8441 <https://tools.ietf.org/html/rfc8441>`_)\n   */\n  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL = 0x08\n} nghttp2_settings_id;\n/* Note: If we add SETTINGS, update the capacity of\n   NGHTTP2_INBOUND_NUM_IV as well */\n\n/**\n * @macro\n *\n * .. warning::\n *\n *   Deprecated.  The initial max concurrent streams is 0xffffffffu.\n *\n * Default maximum number of incoming concurrent streams.  Use\n * `nghttp2_submit_settings()` with\n * :enum:`NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS` to change the\n * maximum number of incoming concurrent streams.\n *\n * .. note::\n *\n *   The maximum number of outgoing concurrent streams is 100 by\n *   default.\n */\n#define NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS ((1U << 31) - 1)\n\n/**\n * @enum\n * The status codes for the RST_STREAM and GOAWAY frames.\n */\ntypedef enum {\n  /**\n   * No errors.\n   */\n  NGHTTP2_NO_ERROR = 0x00,\n  /**\n   * PROTOCOL_ERROR\n   */\n  NGHTTP2_PROTOCOL_ERROR = 0x01,\n  /**\n   * INTERNAL_ERROR\n   */\n  NGHTTP2_INTERNAL_ERROR = 0x02,\n  /**\n   * FLOW_CONTROL_ERROR\n   */\n  NGHTTP2_FLOW_CONTROL_ERROR = 0x03,\n  /**\n   * SETTINGS_TIMEOUT\n   */\n  NGHTTP2_SETTINGS_TIMEOUT = 0x04,\n  /**\n   * STREAM_CLOSED\n   */\n  NGHTTP2_STREAM_CLOSED = 0x05,\n  /**\n   * FRAME_SIZE_ERROR\n   */\n  NGHTTP2_FRAME_SIZE_ERROR = 0x06,\n  /**\n   * REFUSED_STREAM\n   */\n  NGHTTP2_REFUSED_STREAM = 0x07,\n  /**\n   * CANCEL\n   */\n  NGHTTP2_CANCEL = 0x08,\n  /**\n   * COMPRESSION_ERROR\n   */\n  NGHTTP2_COMPRESSION_ERROR = 0x09,\n  /**\n   * CONNECT_ERROR\n   */\n  NGHTTP2_CONNECT_ERROR = 0x0a,\n  /**\n   * ENHANCE_YOUR_CALM\n   */\n  NGHTTP2_ENHANCE_YOUR_CALM = 0x0b,\n  /**\n   * INADEQUATE_SECURITY\n   */\n  NGHTTP2_INADEQUATE_SECURITY = 0x0c,\n  /**\n   * HTTP_1_1_REQUIRED\n   */\n  NGHTTP2_HTTP_1_1_REQUIRED = 0x0d\n} nghttp2_error_code;\n\n/**\n * @struct\n * The frame header.\n */\ntypedef struct {\n  /**\n   * The length field of this frame, excluding frame header.\n   */\n  size_t length;\n  /**\n   * The stream identifier (aka, stream ID)\n   */\n  int32_t stream_id;\n  /**\n   * The type of this frame.  See `nghttp2_frame_type`.\n   */\n  uint8_t type;\n  /**\n   * The flags.\n   */\n  uint8_t flags;\n  /**\n   * Reserved bit in frame header.  Currently, this is always set to 0\n   * and application should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_frame_hd;\n\n/**\n * @union\n *\n * This union represents the some kind of data source passed to\n * :type:`nghttp2_data_source_read_callback`.\n */\ntypedef union {\n  /**\n   * The integer field, suitable for a file descriptor.\n   */\n  int fd;\n  /**\n   * The pointer to an arbitrary object.\n   */\n  void *ptr;\n} nghttp2_data_source;\n\n/**\n * @enum\n *\n * The flags used to set in |data_flags| output parameter in\n * :type:`nghttp2_data_source_read_callback`.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_DATA_FLAG_NONE = 0,\n  /**\n   * Indicates EOF was sensed.\n   */\n  NGHTTP2_DATA_FLAG_EOF = 0x01,\n  /**\n   * Indicates that END_STREAM flag must not be set even if\n   * NGHTTP2_DATA_FLAG_EOF is set.  Usually this flag is used to send\n   * trailer fields with `nghttp2_submit_request()` or\n   * `nghttp2_submit_response()`.\n   */\n  NGHTTP2_DATA_FLAG_NO_END_STREAM = 0x02,\n  /**\n   * Indicates that application will send complete DATA frame in\n   * :type:`nghttp2_send_data_callback`.\n   */\n  NGHTTP2_DATA_FLAG_NO_COPY = 0x04\n} nghttp2_data_flag;\n\n/**\n * @functypedef\n *\n * Callback function invoked when the library wants to read data from\n * the |source|.  The read data is sent in the stream |stream_id|.\n * The implementation of this function must read at most |length|\n * bytes of data from |source| (or possibly other places) and store\n * them in |buf| and return number of data stored in |buf|.  If EOF is\n * reached, set :enum:`NGHTTP2_DATA_FLAG_EOF` flag in |*data_flags|.\n *\n * Sometime it is desirable to avoid copying data into |buf| and let\n * application to send data directly.  To achieve this, set\n * :enum:`NGHTTP2_DATA_FLAG_NO_COPY` to |*data_flags| (and possibly\n * other flags, just like when we do copy), and return the number of\n * bytes to send without copying data into |buf|.  The library, seeing\n * :enum:`NGHTTP2_DATA_FLAG_NO_COPY`, will invoke\n * :type:`nghttp2_send_data_callback`.  The application must send\n * complete DATA frame in that callback.\n *\n * If this callback is set by `nghttp2_submit_request()`,\n * `nghttp2_submit_response()` or `nghttp2_submit_headers()` and\n * `nghttp2_submit_data()` with flag parameter\n * :enum:`NGHTTP2_FLAG_END_STREAM` set, and\n * :enum:`NGHTTP2_DATA_FLAG_EOF` flag is set to |*data_flags|, DATA\n * frame will have END_STREAM flag set.  Usually, this is expected\n * behaviour and all are fine.  One exception is send trailer fields.\n * You cannot send trailer fields after sending frame with END_STREAM\n * set.  To avoid this problem, one can set\n * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM` along with\n * :enum:`NGHTTP2_DATA_FLAG_EOF` to signal the library not to set\n * END_STREAM in DATA frame.  Then application can use\n * `nghttp2_submit_trailer()` to send trailer fields.\n * `nghttp2_submit_trailer()` can be called inside this callback.\n *\n * If the application wants to postpone DATA frames (e.g.,\n * asynchronous I/O, or reading data blocks for long time), it is\n * achieved by returning :enum:`NGHTTP2_ERR_DEFERRED` without reading\n * any data in this invocation.  The library removes DATA frame from\n * the outgoing queue temporarily.  To move back deferred DATA frame\n * to outgoing queue, call `nghttp2_session_resume_data()`.\n *\n * By default, |length| is limited to 16KiB at maximum.  If peer\n * allows larger frames, application can enlarge transmission buffer\n * size.  See :type:`nghttp2_data_source_read_length_callback` for\n * more details.\n *\n * If the application just wants to return from\n * `nghttp2_session_send()` or `nghttp2_session_mem_send()` without\n * sending anything, return :enum:`NGHTTP2_ERR_PAUSE`.\n *\n * In case of error, there are 2 choices. Returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close the stream\n * by issuing RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  If a\n * different error code is desirable, use\n * `nghttp2_submit_rst_stream()` with a desired error code and then\n * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Returning\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session\n * failure.\n */\ntypedef ssize_t (*nghttp2_data_source_read_callback)(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t length,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data);\n\n/**\n * @struct\n *\n * This struct represents the data source and the way to read a chunk\n * of data from it.\n */\ntypedef struct {\n  /**\n   * The data source.\n   */\n  nghttp2_data_source source;\n  /**\n   * The callback function to read a chunk of data from the |source|.\n   */\n  nghttp2_data_source_read_callback read_callback;\n} nghttp2_data_provider;\n\n/**\n * @struct\n *\n * The DATA frame.  The received data is delivered via\n * :type:`nghttp2_on_data_chunk_recv_callback`.\n */\ntypedef struct {\n  nghttp2_frame_hd hd;\n  /**\n   * The length of the padding in this frame.  This includes PAD_HIGH\n   * and PAD_LOW.\n   */\n  size_t padlen;\n} nghttp2_data;\n\n/**\n * @enum\n *\n * The category of HEADERS, which indicates the role of the frame.  In\n * HTTP/2 spec, request, response, push response and other arbitrary\n * headers (e.g., trailer fields) are all called just HEADERS.  To\n * give the application the role of incoming HEADERS frame, we define\n * several categories.\n */\ntypedef enum {\n  /**\n   * The HEADERS frame is opening new stream, which is analogous to\n   * SYN_STREAM in SPDY.\n   */\n  NGHTTP2_HCAT_REQUEST = 0,\n  /**\n   * The HEADERS frame is the first response headers, which is\n   * analogous to SYN_REPLY in SPDY.\n   */\n  NGHTTP2_HCAT_RESPONSE = 1,\n  /**\n   * The HEADERS frame is the first headers sent against reserved\n   * stream.\n   */\n  NGHTTP2_HCAT_PUSH_RESPONSE = 2,\n  /**\n   * The HEADERS frame which does not apply for the above categories,\n   * which is analogous to HEADERS in SPDY.  If non-final response\n   * (e.g., status 1xx) is used, final response HEADERS frame will be\n   * categorized here.\n   */\n  NGHTTP2_HCAT_HEADERS = 3\n} nghttp2_headers_category;\n\n/**\n * @struct\n *\n * The structure to specify stream dependency.\n */\ntypedef struct {\n  /**\n   * The stream ID of the stream to depend on.  Specifying 0 makes\n   * stream not depend any other stream.\n   */\n  int32_t stream_id;\n  /**\n   * The weight of this dependency.\n   */\n  int32_t weight;\n  /**\n   * nonzero means exclusive dependency\n   */\n  uint8_t exclusive;\n} nghttp2_priority_spec;\n\n/**\n * @struct\n *\n * The HEADERS frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The length of the padding in this frame.  This includes PAD_HIGH\n   * and PAD_LOW.\n   */\n  size_t padlen;\n  /**\n   * The priority specification\n   */\n  nghttp2_priority_spec pri_spec;\n  /**\n   * The name/value pairs.\n   */\n  nghttp2_nv *nva;\n  /**\n   * The number of name/value pairs in |nva|.\n   */\n  size_t nvlen;\n  /**\n   * The category of this HEADERS frame.\n   */\n  nghttp2_headers_category cat;\n} nghttp2_headers;\n\n/**\n * @struct\n *\n * The PRIORITY frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The priority specification.\n   */\n  nghttp2_priority_spec pri_spec;\n} nghttp2_priority;\n\n/**\n * @struct\n *\n * The RST_STREAM frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The error code.  See :type:`nghttp2_error_code`.\n   */\n  uint32_t error_code;\n} nghttp2_rst_stream;\n\n/**\n * @struct\n *\n * The SETTINGS ID/Value pair.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The SETTINGS ID.  See :type:`nghttp2_settings_id`.\n   */\n  int32_t settings_id;\n  /**\n   * The value of this entry.\n   */\n  uint32_t value;\n} nghttp2_settings_entry;\n\n/**\n * @struct\n *\n * The SETTINGS frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The number of SETTINGS ID/Value pairs in |iv|.\n   */\n  size_t niv;\n  /**\n   * The pointer to the array of SETTINGS ID/Value pair.\n   */\n  nghttp2_settings_entry *iv;\n} nghttp2_settings;\n\n/**\n * @struct\n *\n * The PUSH_PROMISE frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The length of the padding in this frame.  This includes PAD_HIGH\n   * and PAD_LOW.\n   */\n  size_t padlen;\n  /**\n   * The name/value pairs.\n   */\n  nghttp2_nv *nva;\n  /**\n   * The number of name/value pairs in |nva|.\n   */\n  size_t nvlen;\n  /**\n   * The promised stream ID\n   */\n  int32_t promised_stream_id;\n  /**\n   * Reserved bit.  Currently this is always set to 0 and application\n   * should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_push_promise;\n\n/**\n * @struct\n *\n * The PING frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The opaque data\n   */\n  uint8_t opaque_data[8];\n} nghttp2_ping;\n\n/**\n * @struct\n *\n * The GOAWAY frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The last stream stream ID.\n   */\n  int32_t last_stream_id;\n  /**\n   * The error code.  See :type:`nghttp2_error_code`.\n   */\n  uint32_t error_code;\n  /**\n   * The additional debug data\n   */\n  uint8_t *opaque_data;\n  /**\n   * The length of |opaque_data| member.\n   */\n  size_t opaque_data_len;\n  /**\n   * Reserved bit.  Currently this is always set to 0 and application\n   * should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_goaway;\n\n/**\n * @struct\n *\n * The WINDOW_UPDATE frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The window size increment.\n   */\n  int32_t window_size_increment;\n  /**\n   * Reserved bit.  Currently this is always set to 0 and application\n   * should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_window_update;\n\n/**\n * @struct\n *\n * The extension frame.  It has following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The pointer to extension payload.  The exact pointer type is\n   * determined by hd.type.\n   *\n   * Currently, no extension is supported.  This is a place holder for\n   * the future extensions.\n   */\n  void *payload;\n} nghttp2_extension;\n\n/**\n * @union\n *\n * This union includes all frames to pass them to various function\n * calls as nghttp2_frame type.  The CONTINUATION frame is omitted\n * from here because the library deals with it internally.\n */\ntypedef union {\n  /**\n   * The frame header, which is convenient to inspect frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The DATA frame.\n   */\n  nghttp2_data data;\n  /**\n   * The HEADERS frame.\n   */\n  nghttp2_headers headers;\n  /**\n   * The PRIORITY frame.\n   */\n  nghttp2_priority priority;\n  /**\n   * The RST_STREAM frame.\n   */\n  nghttp2_rst_stream rst_stream;\n  /**\n   * The SETTINGS frame.\n   */\n  nghttp2_settings settings;\n  /**\n   * The PUSH_PROMISE frame.\n   */\n  nghttp2_push_promise push_promise;\n  /**\n   * The PING frame.\n   */\n  nghttp2_ping ping;\n  /**\n   * The GOAWAY frame.\n   */\n  nghttp2_goaway goaway;\n  /**\n   * The WINDOW_UPDATE frame.\n   */\n  nghttp2_window_update window_update;\n  /**\n   * The extension frame.\n   */\n  nghttp2_extension ext;\n} nghttp2_frame;\n\n/**\n * @functypedef\n *\n * Callback function invoked when |session| wants to send data to the\n * remote peer.  The implementation of this function must send at most\n * |length| bytes of data stored in |data|.  The |flags| is currently\n * not used and always 0. It must return the number of bytes sent if\n * it succeeds.  If it cannot send any single byte without blocking,\n * it must return :enum:`NGHTTP2_ERR_WOULDBLOCK`.  For other errors,\n * it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * This callback is required if the application uses\n * `nghttp2_session_send()` to send data to the remote endpoint.  If\n * the application uses solely `nghttp2_session_mem_send()` instead,\n * this callback function is unnecessary.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_send_callback()`.\n *\n * .. note::\n *\n *   The |length| may be very small.  If that is the case, and\n *   application disables Nagle algorithm (``TCP_NODELAY``), then just\n *   writing |data| to the network stack leads to very small packet,\n *   and it is very inefficient.  An application should be responsible\n *   to buffer up small chunks of data as necessary to avoid this\n *   situation.\n */\ntypedef ssize_t (*nghttp2_send_callback)(nghttp2_session *session,\n                                         const uint8_t *data, size_t length,\n                                         int flags, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when :enum:`NGHTTP2_DATA_FLAG_NO_COPY` is\n * used in :type:`nghttp2_data_source_read_callback` to send complete\n * DATA frame.\n *\n * The |frame| is a DATA frame to send.  The |framehd| is the\n * serialized frame header (9 bytes). The |length| is the length of\n * application data to send (this does not include padding).  The\n * |source| is the same pointer passed to\n * :type:`nghttp2_data_source_read_callback`.\n *\n * The application first must send frame header |framehd| of length 9\n * bytes.  If ``frame->data.padlen > 0``, send 1 byte of value\n * ``frame->data.padlen - 1``.  Then send exactly |length| bytes of\n * application data.  Finally, if ``frame->data.padlen > 1``, send\n * ``frame->data.padlen - 1`` bytes of zero as padding.\n *\n * The application has to send complete DATA frame in this callback.\n * If all data were written successfully, return 0.\n *\n * If it cannot send any data at all, just return\n * :enum:`NGHTTP2_ERR_WOULDBLOCK`; the library will call this callback\n * with the same parameters later (It is recommended to send complete\n * DATA frame at once in this function to deal with error; if partial\n * frame data has already sent, it is impossible to send another data\n * in that state, and all we can do is tear down connection).  When\n * data is fully processed, but application wants to make\n * `nghttp2_session_mem_send()` or `nghttp2_session_send()` return\n * immediately without processing next frames, return\n * :enum:`NGHTTP2_ERR_PAUSE`.  If application decided to reset this\n * stream, return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`, then\n * the library will send RST_STREAM with INTERNAL_ERROR as error code.\n * The application can also return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, which will result in\n * connection closure.  Returning any other value is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.\n */\ntypedef int (*nghttp2_send_data_callback)(nghttp2_session *session,\n                                          nghttp2_frame *frame,\n                                          const uint8_t *framehd, size_t length,\n                                          nghttp2_data_source *source,\n                                          void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when |session| wants to receive data from\n * the remote peer.  The implementation of this function must read at\n * most |length| bytes of data and store it in |buf|.  The |flags| is\n * currently not used and always 0.  It must return the number of\n * bytes written in |buf| if it succeeds.  If it cannot read any\n * single byte without blocking, it must return\n * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  If it gets EOF before it reads any\n * single byte, it must return :enum:`NGHTTP2_ERR_EOF`.  For other\n * errors, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n * Returning 0 is treated as :enum:`NGHTTP2_ERR_WOULDBLOCK`.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * This callback is required if the application uses\n * `nghttp2_session_recv()` to receive data from the remote endpoint.\n * If the application uses solely `nghttp2_session_mem_recv()`\n * instead, this callback function is unnecessary.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_recv_callback()`.\n */\ntypedef ssize_t (*nghttp2_recv_callback)(nghttp2_session *session, uint8_t *buf,\n                                         size_t length, int flags,\n                                         void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when a frame is received.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``\n * member of their data structure are always ``NULL`` and 0\n * respectively.  The header name/value pairs are emitted via\n * :type:`nghttp2_on_header_callback`.\n *\n * For HEADERS, PUSH_PROMISE and DATA frames, this callback may be\n * called after stream is closed (see\n * :type:`nghttp2_on_stream_close_callback`).  The application should\n * check that stream is still alive using its own stream management or\n * :func:`nghttp2_session_get_stream_user_data()`.\n *\n * Only HEADERS and DATA frame can signal the end of incoming data.\n * If ``frame->hd.flags & NGHTTP2_FLAG_END_STREAM`` is nonzero, the\n * |frame| is the last frame from the remote peer in this stream.\n *\n * This callback won't be called for CONTINUATION frames.\n * HEADERS/PUSH_PROMISE + CONTINUATIONs are treated as single frame.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero value is returned, it is treated as fatal error and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_frame_recv_callback()`.\n */\ntypedef int (*nghttp2_on_frame_recv_callback)(nghttp2_session *session,\n                                              const nghttp2_frame *frame,\n                                              void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when an invalid non-DATA frame is\n * received.  The error is indicated by the |lib_error_code|, which is\n * one of the values defined in :type:`nghttp2_error`.  When this\n * callback function is invoked, the library automatically submits\n * either RST_STREAM or GOAWAY frame.  The |user_data| pointer is the\n * third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``\n * member of their data structure are always ``NULL`` and 0\n * respectively.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_invalid_frame_recv_callback()`.\n */\ntypedef int (*nghttp2_on_invalid_frame_recv_callback)(\n    nghttp2_session *session, const nghttp2_frame *frame, int lib_error_code,\n    void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a chunk of data in DATA frame is\n * received.  The |stream_id| is the stream ID this DATA frame belongs\n * to.  The |flags| is the flags of DATA frame which this data chunk\n * is contained.  ``(flags & NGHTTP2_FLAG_END_STREAM) != 0`` does not\n * necessarily mean this chunk of data is the last one in the stream.\n * You should use :type:`nghttp2_on_frame_recv_callback` to know all\n * data frames are received.  The |user_data| pointer is the third\n * argument passed in to the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * If the application uses `nghttp2_session_mem_recv()`, it can return\n * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`\n * return without processing further input bytes.  The memory by\n * pointed by the |data| is retained until\n * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.\n * The application must retain the input bytes which was used to\n * produce the |data| parameter, because it may refer to the memory\n * region included in the input bytes.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error, and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_data_chunk_recv_callback()`.\n */\ntypedef int (*nghttp2_on_data_chunk_recv_callback)(nghttp2_session *session,\n                                                   uint8_t flags,\n                                                   int32_t stream_id,\n                                                   const uint8_t *data,\n                                                   size_t len, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked just before the non-DATA frame |frame| is\n * sent.  The |user_data| pointer is the third argument passed in to\n * the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * The implementation of this function must return 0 if it succeeds.\n * It can also return :enum:`NGHTTP2_ERR_CANCEL` to cancel the\n * transmission of the given frame.\n *\n * If there is a fatal error while executing this callback, the\n * implementation should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`,\n * which makes `nghttp2_session_send()` and\n * `nghttp2_session_mem_send()` functions immediately return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * If the other value is returned, it is treated as if\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.  But the\n * implementation should not rely on this since the library may define\n * new return value to extend its capability.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_before_frame_send_callback()`.\n */\ntypedef int (*nghttp2_before_frame_send_callback)(nghttp2_session *session,\n                                                  const nghttp2_frame *frame,\n                                                  void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked after the frame |frame| is sent.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_frame_send_callback()`.\n */\ntypedef int (*nghttp2_on_frame_send_callback)(nghttp2_session *session,\n                                              const nghttp2_frame *frame,\n                                              void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked after the non-DATA frame |frame| is not\n * sent because of the error.  The error is indicated by the\n * |lib_error_code|, which is one of the values defined in\n * :type:`nghttp2_error`.  The |user_data| pointer is the third\n * argument passed in to the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * `nghttp2_session_get_stream_user_data()` can be used to get\n * associated data.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_frame_not_send_callback()`.\n */\ntypedef int (*nghttp2_on_frame_not_send_callback)(nghttp2_session *session,\n                                                  const nghttp2_frame *frame,\n                                                  int lib_error_code,\n                                                  void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the stream |stream_id| is closed.\n * The reason of closure is indicated by the |error_code|.  The\n * |error_code| is usually one of :enum:`nghttp2_error_code`, but that\n * is not guaranteed.  The stream_user_data, which was specified in\n * `nghttp2_submit_request()` or `nghttp2_submit_headers()`, is still\n * available in this function.  The |user_data| pointer is the third\n * argument passed in to the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * This function is also called for a stream in reserved state.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_recv()`, `nghttp2_session_mem_recv()`,\n * `nghttp2_session_send()`, and `nghttp2_session_mem_send()`\n * functions immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_stream_close_callback()`.\n */\ntypedef int (*nghttp2_on_stream_close_callback)(nghttp2_session *session,\n                                                int32_t stream_id,\n                                                uint32_t error_code,\n                                                void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the reception of header block in\n * HEADERS or PUSH_PROMISE is started.  Each header name/value pair\n * will be emitted by :type:`nghttp2_on_header_callback`.\n *\n * The ``frame->hd.flags`` may not have\n * :enum:`NGHTTP2_FLAG_END_HEADERS` flag set, which indicates that one\n * or more CONTINUATION frames are involved.  But the application does\n * not need to care about that because the header name/value pairs are\n * emitted transparently regardless of CONTINUATION frames.\n *\n * The server applications probably create an object to store\n * information about new stream if ``frame->hd.type ==\n * NGHTTP2_HEADERS`` and ``frame->headers.cat ==\n * NGHTTP2_HCAT_REQUEST``.  If |session| is configured as server side,\n * ``frame->headers.cat`` is either ``NGHTTP2_HCAT_REQUEST``\n * containing request headers or ``NGHTTP2_HCAT_HEADERS`` containing\n * trailer fields and never get PUSH_PROMISE in this callback.\n *\n * For the client applications, ``frame->hd.type`` is either\n * ``NGHTTP2_HEADERS`` or ``NGHTTP2_PUSH_PROMISE``.  In case of\n * ``NGHTTP2_HEADERS``, ``frame->headers.cat ==\n * NGHTTP2_HCAT_RESPONSE`` means that it is the first response\n * headers, but it may be non-final response which is indicated by 1xx\n * status code.  In this case, there may be zero or more HEADERS frame\n * with ``frame->headers.cat == NGHTTP2_HCAT_HEADERS`` which has\n * non-final response code and finally client gets exactly one HEADERS\n * frame with ``frame->headers.cat == NGHTTP2_HCAT_HEADERS``\n * containing final response headers (non-1xx status code).  The\n * trailer fields also has ``frame->headers.cat ==\n * NGHTTP2_HCAT_HEADERS`` which does not contain any status code.\n *\n * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close\n * the stream (promised stream if frame is PUSH_PROMISE) by issuing\n * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,\n * :type:`nghttp2_on_header_callback` and\n * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a\n * different error code is desirable, use\n * `nghttp2_submit_rst_stream()` with a desired error code and then\n * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use\n * ``frame->push_promise.promised_stream_id`` as stream_id parameter\n * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.\n *\n * The implementation of this function must return 0 if it succeeds.\n * It can return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` to\n * reset the stream (promised stream if frame is PUSH_PROMISE).  For\n * critical errors, it must return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the other value is\n * returned, it is treated as if :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n * is returned.  If :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,\n * `nghttp2_session_mem_recv()` function will immediately return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_begin_headers_callback()`.\n */\ntypedef int (*nghttp2_on_begin_headers_callback)(nghttp2_session *session,\n                                                 const nghttp2_frame *frame,\n                                                 void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a header name/value pair is received\n * for the |frame|.  The |name| of length |namelen| is header name.\n * The |value| of length |valuelen| is header value.  The |flags| is\n * bitwise OR of one or more of :type:`nghttp2_nv_flag`.\n *\n * If :enum:`NGHTTP2_NV_FLAG_NO_INDEX` is set in |flags|, the receiver\n * must not index this name/value pair when forwarding it to the next\n * hop.  More specifically, \"Literal Header Field never Indexed\"\n * representation must be used in HPACK encoding.\n *\n * When this callback is invoked, ``frame->hd.type`` is either\n * :enum:`NGHTTP2_HEADERS` or :enum:`NGHTTP2_PUSH_PROMISE`.  After all\n * header name/value pairs are processed with this callback, and no\n * error has been detected, :type:`nghttp2_on_frame_recv_callback`\n * will be invoked.  If there is an error in decompression,\n * :type:`nghttp2_on_frame_recv_callback` for the |frame| will not be\n * invoked.\n *\n * Both |name| and |value| are guaranteed to be NULL-terminated.  The\n * |namelen| and |valuelen| do not include terminal NULL.  If\n * `nghttp2_option_set_no_http_messaging()` is used with nonzero\n * value, NULL character may be included in |name| or |value| before\n * terminating NULL.\n *\n * Please note that unless `nghttp2_option_set_no_http_messaging()` is\n * used, nghttp2 library does perform validation against the |name|\n * and the |value| using `nghttp2_check_header_name()` and\n * `nghttp2_check_header_value()`.  In addition to this, nghttp2\n * performs validation based on HTTP Messaging rule, which is briefly\n * explained in :ref:`http-messaging` section.\n *\n * If the application uses `nghttp2_session_mem_recv()`, it can return\n * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`\n * return without processing further input bytes.  The memory pointed\n * by |frame|, |name| and |value| parameters are retained until\n * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.\n * The application must retain the input bytes which was used to\n * produce these parameters, because it may refer to the memory region\n * included in the input bytes.\n *\n * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close\n * the stream (promised stream if frame is PUSH_PROMISE) by issuing\n * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,\n * :type:`nghttp2_on_header_callback` and\n * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a\n * different error code is desirable, use\n * `nghttp2_submit_rst_stream()` with a desired error code and then\n * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use\n * ``frame->push_promise.promised_stream_id`` as stream_id parameter\n * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.\n *\n * The implementation of this function must return 0 if it succeeds.\n * It may return :enum:`NGHTTP2_ERR_PAUSE` or\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  For other critical\n * failures, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If\n * the other nonzero value is returned, it is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_header_callback()`.\n *\n * .. warning::\n *\n *   Application should properly limit the total buffer size to store\n *   incoming header fields.  Without it, peer may send large number\n *   of header fields or large header fields to cause out of memory in\n *   local endpoint.  Due to how HPACK works, peer can do this\n *   effectively without using much memory on their own.\n */\ntypedef int (*nghttp2_on_header_callback)(nghttp2_session *session,\n                                          const nghttp2_frame *frame,\n                                          const uint8_t *name, size_t namelen,\n                                          const uint8_t *value, size_t valuelen,\n                                          uint8_t flags, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a header name/value pair is received\n * for the |frame|.  The |name| is header name.  The |value| is header\n * value.  The |flags| is bitwise OR of one or more of\n * :type:`nghttp2_nv_flag`.\n *\n * This callback behaves like :type:`nghttp2_on_header_callback`,\n * except that |name| and |value| are stored in reference counted\n * buffer.  If application wishes to keep these references without\n * copying them, use `nghttp2_rcbuf_incref()` to increment their\n * reference count.  It is the application's responsibility to call\n * `nghttp2_rcbuf_decref()` if they called `nghttp2_rcbuf_incref()` so\n * as not to leak memory.  If the |session| is created by\n * `nghttp2_session_server_new3()` or `nghttp2_session_client_new3()`,\n * the function to free memory is the one belongs to the mem\n * parameter.  As long as this free function alives, |name| and\n * |value| can live after |session| was destroyed.\n */\ntypedef int (*nghttp2_on_header_callback2)(nghttp2_session *session,\n                                           const nghttp2_frame *frame,\n                                           nghttp2_rcbuf *name,\n                                           nghttp2_rcbuf *value, uint8_t flags,\n                                           void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a invalid header name/value pair is\n * received for the |frame|.\n *\n * The parameter and behaviour are similar to\n * :type:`nghttp2_on_header_callback`.  The difference is that this\n * callback is only invoked when a invalid header name/value pair is\n * received which is treated as stream error if this callback is not\n * set.  Only invalid regular header field are passed to this\n * callback.  In other words, invalid pseudo header field is not\n * passed to this callback.  Also header fields which includes upper\n * cased latter are also treated as error without passing them to this\n * callback.\n *\n * This callback is only considered if HTTP messaging validation is\n * turned on (which is on by default, see\n * `nghttp2_option_set_no_http_messaging()`).\n *\n * With this callback, application inspects the incoming invalid\n * field, and it also can reset stream from this callback by returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  By default, the\n * error code is :enum:`NGHTTP2_PROTOCOL_ERROR`.  To change the error\n * code, call `nghttp2_submit_rst_stream()` with the error code of\n * choice in addition to returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.\n *\n * If 0 is returned, the header field is ignored, and the stream is\n * not reset.\n */\ntypedef int (*nghttp2_on_invalid_header_callback)(\n    nghttp2_session *session, const nghttp2_frame *frame, const uint8_t *name,\n    size_t namelen, const uint8_t *value, size_t valuelen, uint8_t flags,\n    void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a invalid header name/value pair is\n * received for the |frame|.\n *\n * The parameter and behaviour are similar to\n * :type:`nghttp2_on_header_callback2`.  The difference is that this\n * callback is only invoked when a invalid header name/value pair is\n * received which is silently ignored if this callback is not set.\n * Only invalid regular header field are passed to this callback.  In\n * other words, invalid pseudo header field is not passed to this\n * callback.  Also header fields which includes upper cased latter are\n * also treated as error without passing them to this callback.\n *\n * This callback is only considered if HTTP messaging validation is\n * turned on (which is on by default, see\n * `nghttp2_option_set_no_http_messaging()`).\n *\n * With this callback, application inspects the incoming invalid\n * field, and it also can reset stream from this callback by returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  By default, the\n * error code is :enum:`NGHTTP2_INTERNAL_ERROR`.  To change the error\n * code, call `nghttp2_submit_rst_stream()` with the error code of\n * choice in addition to returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.\n */\ntypedef int (*nghttp2_on_invalid_header_callback2)(\n    nghttp2_session *session, const nghttp2_frame *frame, nghttp2_rcbuf *name,\n    nghttp2_rcbuf *value, uint8_t flags, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the library asks application how\n * many padding bytes are required for the transmission of the\n * |frame|.  The application must choose the total length of payload\n * including padded bytes in range [frame->hd.length, max_payloadlen],\n * inclusive.  Choosing number not in this range will be treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Returning\n * ``frame->hd.length`` means no padding is added.  Returning\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will make\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_select_padding_callback()`.\n */\ntypedef ssize_t (*nghttp2_select_padding_callback)(nghttp2_session *session,\n                                                   const nghttp2_frame *frame,\n                                                   size_t max_payloadlen,\n                                                   void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library wants to get max length of\n * data to send data to the remote peer.  The implementation of this\n * function should return a value in the following range.  [1,\n * min(|session_remote_window_size|, |stream_remote_window_size|,\n * |remote_max_frame_size|)].  If a value greater than this range is\n * returned than the max allow value will be used.  Returning a value\n * smaller than this range is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The |frame_type| is provided\n * for future extensibility and identifies the type of frame (see\n * :type:`nghttp2_frame_type`) for which to get the length for.\n * Currently supported frame types are: :enum:`NGHTTP2_DATA`.\n *\n * This callback can be used to control the length in bytes for which\n * :type:`nghttp2_data_source_read_callback` is allowed to send to the\n * remote endpoint.  This callback is optional.  Returning\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session\n * failure.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_data_source_read_length_callback()`.\n */\ntypedef ssize_t (*nghttp2_data_source_read_length_callback)(\n    nghttp2_session *session, uint8_t frame_type, int32_t stream_id,\n    int32_t session_remote_window_size, int32_t stream_remote_window_size,\n    uint32_t remote_max_frame_size, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a frame header is received.  The\n * |hd| points to received frame header.\n *\n * Unlike :type:`nghttp2_on_frame_recv_callback`, this callback will\n * also be called when frame header of CONTINUATION frame is received.\n *\n * If both :type:`nghttp2_on_begin_frame_callback` and\n * :type:`nghttp2_on_begin_headers_callback` are set and HEADERS or\n * PUSH_PROMISE is received, :type:`nghttp2_on_begin_frame_callback`\n * will be called first.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero value is returned, it is treated as fatal error and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_begin_frame_callback()`.\n */\ntypedef int (*nghttp2_on_begin_frame_callback)(nghttp2_session *session,\n                                               const nghttp2_frame_hd *hd,\n                                               void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when chunk of extension frame payload is\n * received.  The |hd| points to frame header.  The received\n * chunk is |data| of length |len|.\n *\n * The implementation of this function must return 0 if it succeeds.\n *\n * To abort processing this extension frame, return\n * :enum:`NGHTTP2_ERR_CANCEL`.\n *\n * If fatal error occurred, application should return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the\n * other values are returned, currently they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n */\ntypedef int (*nghttp2_on_extension_chunk_recv_callback)(\n    nghttp2_session *session, const nghttp2_frame_hd *hd, const uint8_t *data,\n    size_t len, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library asks the application to\n * unpack extension payload from its wire format.  The extension\n * payload has been passed to the application using\n * :type:`nghttp2_on_extension_chunk_recv_callback`.  The frame header\n * is already unpacked by the library and provided as |hd|.\n *\n * To receive extension frames, the application must tell desired\n * extension frame type to the library using\n * `nghttp2_option_set_user_recv_extension_type()`.\n *\n * The implementation of this function may store the pointer to the\n * created object as a result of unpacking in |*payload|, and returns\n * 0.  The pointer stored in |*payload| is opaque to the library, and\n * the library does not own its pointer.  |*payload| is initialized as\n * ``NULL``.  The |*payload| is available as ``frame->ext.payload`` in\n * :type:`nghttp2_on_frame_recv_callback`.  Therefore if application\n * can free that memory inside :type:`nghttp2_on_frame_recv_callback`\n * callback.  Of course, application has a liberty not ot use\n * |*payload|, and do its own mechanism to process extension frames.\n *\n * To abort processing this extension frame, return\n * :enum:`NGHTTP2_ERR_CANCEL`.\n *\n * If fatal error occurred, application should return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the\n * other values are returned, currently they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n */\ntypedef int (*nghttp2_unpack_extension_callback)(nghttp2_session *session,\n                                                 void **payload,\n                                                 const nghttp2_frame_hd *hd,\n                                                 void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library asks the application to pack\n * extension payload in its wire format.  The frame header will be\n * packed by library.  Application must pack payload only.\n * ``frame->ext.payload`` is the object passed to\n * `nghttp2_submit_extension()` as payload parameter.  Application\n * must pack extension payload to the |buf| of its capacity |len|\n * bytes.  The |len| is at least 16KiB.\n *\n * The implementation of this function should return the number of\n * bytes written into |buf| when it succeeds.\n *\n * To abort processing this extension frame, return\n * :enum:`NGHTTP2_ERR_CANCEL`, and\n * :type:`nghttp2_on_frame_not_send_callback` will be invoked.\n *\n * If fatal error occurred, application should return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the\n * other values are returned, currently they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the return value is\n * strictly larger than |len|, it is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n */\ntypedef ssize_t (*nghttp2_pack_extension_callback)(nghttp2_session *session,\n                                                   uint8_t *buf, size_t len,\n                                                   const nghttp2_frame *frame,\n                                                   void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library provides the error message\n * intended for human consumption.  This callback is solely for\n * debugging purpose.  The |msg| is typically NULL-terminated string\n * of length |len|.  |len| does not include the sentinel NULL\n * character.\n *\n * This function is deprecated.  The new application should use\n * :type:`nghttp2_error_callback2`.\n *\n * The format of error message may change between nghttp2 library\n * versions.  The application should not depend on the particular\n * format.\n *\n * Normally, application should return 0 from this callback.  If fatal\n * error occurred while doing something in this callback, application\n * should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * library will return immediately with return value\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Currently, if nonzero value\n * is returned from this callback, they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, but application should not\n * rely on this details.\n */\ntypedef int (*nghttp2_error_callback)(nghttp2_session *session, const char *msg,\n                                      size_t len, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library provides the error code, and\n * message.  This callback is solely for debugging purpose.\n * |lib_error_code| is one of error code defined in\n * :enum:`nghttp2_error`.  The |msg| is typically NULL-terminated\n * string of length |len|, and intended for human consumption.  |len|\n * does not include the sentinel NULL character.\n *\n * The format of error message may change between nghttp2 library\n * versions.  The application should not depend on the particular\n * format.\n *\n * Normally, application should return 0 from this callback.  If fatal\n * error occurred while doing something in this callback, application\n * should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * library will return immediately with return value\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Currently, if nonzero value\n * is returned from this callback, they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, but application should not\n * rely on this details.\n */\ntypedef int (*nghttp2_error_callback2)(nghttp2_session *session,\n                                       int lib_error_code, const char *msg,\n                                       size_t len, void *user_data);\n\nstruct nghttp2_session_callbacks;\n\n/**\n * @struct\n *\n * Callback functions for :type:`nghttp2_session`.  The details of\n * this structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_session_callbacks nghttp2_session_callbacks;\n\n/**\n * @function\n *\n * Initializes |*callbacks_ptr| with NULL values.\n *\n * The initialized object can be used when initializing multiple\n * :type:`nghttp2_session` objects.\n *\n * When the application finished using this object, it can use\n * `nghttp2_session_callbacks_del()` to free its memory.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_callbacks_new(nghttp2_session_callbacks **callbacks_ptr);\n\n/**\n * @function\n *\n * Frees any resources allocated for |callbacks|.  If |callbacks| is\n * ``NULL``, this function does nothing.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_del(nghttp2_session_callbacks *callbacks);\n\n/**\n * @function\n *\n * Sets callback function invoked when a session wants to send data to\n * the remote peer.  This callback is not necessary if the application\n * uses solely `nghttp2_session_mem_send()` to serialize data to\n * transmit.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_send_callback(\n    nghttp2_session_callbacks *cbs, nghttp2_send_callback send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the a session wants to receive\n * data from the remote peer.  This callback is not necessary if the\n * application uses solely `nghttp2_session_mem_recv()` to process\n * received data.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_recv_callback(\n    nghttp2_session_callbacks *cbs, nghttp2_recv_callback recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when a frame is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_frame_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_frame_recv_callback on_frame_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when an invalid non-DATA frame is\n * received.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_set_on_invalid_frame_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_invalid_frame_recv_callback on_invalid_frame_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a chunk of data in DATA frame\n * is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_data_chunk_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_data_chunk_recv_callback on_data_chunk_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked before a non-DATA frame is sent.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_before_frame_send_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_before_frame_send_callback before_frame_send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked after a frame is sent.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_frame_send_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_frame_send_callback on_frame_send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a non-DATA frame is not sent\n * because of an error.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_frame_not_send_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_frame_not_send_callback on_frame_not_send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the stream is closed.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_stream_close_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_stream_close_callback on_stream_close_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the reception of header block\n * in HEADERS or PUSH_PROMISE is started.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_begin_headers_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_begin_headers_callback on_begin_headers_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a header name/value pair is\n * received.  If both\n * `nghttp2_session_callbacks_set_on_header_callback()` and\n * `nghttp2_session_callbacks_set_on_header_callback2()` are used to\n * set callbacks, the latter has the precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_header_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_header_callback on_header_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a header name/value pair is\n * received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_header_callback2(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_header_callback2 on_header_callback2);\n\n/**\n * @function\n *\n * Sets callback function invoked when a invalid header name/value\n * pair is received.  If both\n * `nghttp2_session_callbacks_set_on_invalid_header_callback()` and\n * `nghttp2_session_callbacks_set_on_invalid_header_callback2()` are\n * used to set callbacks, the latter takes the precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_invalid_header_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_invalid_header_callback on_invalid_header_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a invalid header name/value\n * pair is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_invalid_header_callback2(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_invalid_header_callback2 on_invalid_header_callback2);\n\n/**\n * @function\n *\n * Sets callback function invoked when the library asks application\n * how many padding bytes are required for the transmission of the\n * given frame.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_select_padding_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_select_padding_callback select_padding_callback);\n\n/**\n * @function\n *\n * Sets callback function determine the length allowed in\n * :type:`nghttp2_data_source_read_callback`.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_set_data_source_read_length_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_data_source_read_length_callback data_source_read_length_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a frame header is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_begin_frame_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_begin_frame_callback on_begin_frame_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when\n * :enum:`NGHTTP2_DATA_FLAG_NO_COPY` is used in\n * :type:`nghttp2_data_source_read_callback` to avoid data copy.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_send_data_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_send_data_callback send_data_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the library asks the\n * application to pack extension frame payload in wire format.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_pack_extension_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_pack_extension_callback pack_extension_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the library asks the\n * application to unpack extension frame payload from wire format.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_unpack_extension_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_unpack_extension_callback unpack_extension_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when chunk of extension frame\n * payload is received.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_set_on_extension_chunk_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_extension_chunk_recv_callback on_extension_chunk_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when library tells error message to\n * the application.\n *\n * This function is deprecated.  The new application should use\n * `nghttp2_session_callbacks_set_error_callback2()`.\n *\n * If both :type:`nghttp2_error_callback` and\n * :type:`nghttp2_error_callback2` are set, the latter takes\n * precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_error_callback(\n    nghttp2_session_callbacks *cbs, nghttp2_error_callback error_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when library tells error code, and\n * message to the application.\n *\n * If both :type:`nghttp2_error_callback` and\n * :type:`nghttp2_error_callback2` are set, the latter takes\n * precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_error_callback2(\n    nghttp2_session_callbacks *cbs, nghttp2_error_callback2 error_callback2);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace malloc().  The |mem_user_data|\n * is the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void *(*nghttp2_malloc)(size_t size, void *mem_user_data);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace free().  The |mem_user_data| is\n * the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void (*nghttp2_free)(void *ptr, void *mem_user_data);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace calloc().  The |mem_user_data|\n * is the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void *(*nghttp2_calloc)(size_t nmemb, size_t size, void *mem_user_data);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace realloc().  The |mem_user_data|\n * is the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void *(*nghttp2_realloc)(void *ptr, size_t size, void *mem_user_data);\n\n/**\n * @struct\n *\n * Custom memory allocator functions and user defined pointer.  The\n * |mem_user_data| member is passed to each allocator function.  This\n * can be used, for example, to achieve per-session memory pool.\n *\n * In the following example code, ``my_malloc``, ``my_free``,\n * ``my_calloc`` and ``my_realloc`` are the replacement of the\n * standard allocators ``malloc``, ``free``, ``calloc`` and\n * ``realloc`` respectively::\n *\n *     void *my_malloc_cb(size_t size, void *mem_user_data) {\n *       return my_malloc(size);\n *     }\n *\n *     void my_free_cb(void *ptr, void *mem_user_data) { my_free(ptr); }\n *\n *     void *my_calloc_cb(size_t nmemb, size_t size, void *mem_user_data) {\n *       return my_calloc(nmemb, size);\n *     }\n *\n *     void *my_realloc_cb(void *ptr, size_t size, void *mem_user_data) {\n *       return my_realloc(ptr, size);\n *     }\n *\n *     void session_new() {\n *       nghttp2_session *session;\n *       nghttp2_session_callbacks *callbacks;\n *       nghttp2_mem mem = {NULL, my_malloc_cb, my_free_cb, my_calloc_cb,\n *                          my_realloc_cb};\n *\n *       ...\n *\n *       nghttp2_session_client_new3(&session, callbacks, NULL, NULL, &mem);\n *\n *       ...\n *     }\n */\ntypedef struct {\n  /**\n   * An arbitrary user supplied data.  This is passed to each\n   * allocator function.\n   */\n  void *mem_user_data;\n  /**\n   * Custom allocator function to replace malloc().\n   */\n  nghttp2_malloc malloc;\n  /**\n   * Custom allocator function to replace free().\n   */\n  nghttp2_free free;\n  /**\n   * Custom allocator function to replace calloc().\n   */\n  nghttp2_calloc calloc;\n  /**\n   * Custom allocator function to replace realloc().\n   */\n  nghttp2_realloc realloc;\n} nghttp2_mem;\n\nstruct nghttp2_option;\n\n/**\n * @struct\n *\n * Configuration options for :type:`nghttp2_session`.  The details of\n * this structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_option nghttp2_option;\n\n/**\n * @function\n *\n * Initializes |*option_ptr| with default values.\n *\n * When the application finished using this object, it can use\n * `nghttp2_option_del()` to free its memory.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_option_new(nghttp2_option **option_ptr);\n\n/**\n * @function\n *\n * Frees any resources allocated for |option|.  If |option| is\n * ``NULL``, this function does nothing.\n */\nNGHTTP2_EXTERN void nghttp2_option_del(nghttp2_option *option);\n\n/**\n * @function\n *\n * This option prevents the library from sending WINDOW_UPDATE for a\n * connection automatically.  If this option is set to nonzero, the\n * library won't send WINDOW_UPDATE for DATA until application calls\n * `nghttp2_session_consume()` to indicate the consumed amount of\n * data.  Don't use `nghttp2_submit_window_update()` for this purpose.\n * By default, this option is set to zero.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_no_auto_window_update(nghttp2_option *option, int val);\n\n/**\n * @function\n *\n * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of\n * remote endpoint as if it is received in SETTINGS frame.  Without\n * specifying this option, the maximum number of outgoing concurrent\n * streams is initially limited to 100 to avoid issues when the local\n * endpoint submits lots of requests before receiving initial SETTINGS\n * frame from the remote endpoint, since sending them at once to the\n * remote endpoint could lead to rejection of some of the requests.\n * This value will be overwritten when the local endpoint receives\n * initial SETTINGS frame from the remote endpoint, either to the\n * value advertised in SETTINGS_MAX_CONCURRENT_STREAMS or to the\n * default value (unlimited) if none was advertised.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_peer_max_concurrent_streams(nghttp2_option *option,\n                                               uint32_t val);\n\n/**\n * @function\n *\n * By default, nghttp2 library, if configured as server, requires\n * first 24 bytes of client magic byte string (MAGIC).  In most cases,\n * this will simplify the implementation of server.  But sometimes\n * server may want to detect the application protocol based on first\n * few bytes on clear text communication.\n *\n * If this option is used with nonzero |val|, nghttp2 library does not\n * handle MAGIC.  It still checks following SETTINGS frame.  This\n * means that applications should deal with MAGIC by themselves.\n *\n * If this option is not used or used with zero value, if MAGIC does\n * not match :macro:`NGHTTP2_CLIENT_MAGIC`, `nghttp2_session_recv()`\n * and `nghttp2_session_mem_recv()` will return error\n * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`, which is fatal error.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_no_recv_client_magic(nghttp2_option *option, int val);\n\n/**\n * @function\n *\n * By default, nghttp2 library enforces subset of HTTP Messaging rules\n * described in `HTTP/2 specification, section 8\n * <https://tools.ietf.org/html/rfc7540#section-8>`_.  See\n * :ref:`http-messaging` section for details.  For those applications\n * who use nghttp2 library as non-HTTP use, give nonzero to |val| to\n * disable this enforcement.  Please note that disabling this feature\n * does not change the fundamental client and server model of HTTP.\n * That is, even if the validation is disabled, only client can send\n * requests.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_no_http_messaging(nghttp2_option *option,\n                                                         int val);\n\n/**\n * @function\n *\n * RFC 7540 does not enforce any limit on the number of incoming\n * reserved streams (in RFC 7540 terms, streams in reserved (remote)\n * state).  This only affects client side, since only server can push\n * streams.  Malicious server can push arbitrary number of streams,\n * and make client's memory exhausted.  This option can set the\n * maximum number of such incoming streams to avoid possible memory\n * exhaustion.  If this option is set, and pushed streams are\n * automatically closed on reception, without calling user provided\n * callback, if they exceed the given limit.  The default value is\n * 200.  If session is configured as server side, this option has no\n * effect.  Server can control the number of streams to push.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_max_reserved_remote_streams(nghttp2_option *option,\n                                               uint32_t val);\n\n/**\n * @function\n *\n * Sets extension frame type the application is willing to handle with\n * user defined callbacks (see\n * :type:`nghttp2_on_extension_chunk_recv_callback` and\n * :type:`nghttp2_unpack_extension_callback`).  The |type| is\n * extension frame type, and must be strictly greater than 0x9.\n * Otherwise, this function does nothing.  The application can call\n * this function multiple times to set more than one frame type to\n * receive.  The application does not have to call this function if it\n * just sends extension frames.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_user_recv_extension_type(nghttp2_option *option,\n                                            uint8_t type);\n\n/**\n * @function\n *\n * Sets extension frame type the application is willing to receive\n * using builtin handler.  The |type| is the extension frame type to\n * receive, and must be strictly greater than 0x9.  Otherwise, this\n * function does nothing.  The application can call this function\n * multiple times to set more than one frame type to receive.  The\n * application does not have to call this function if it just sends\n * extension frames.\n *\n * If same frame type is passed to both\n * `nghttp2_option_set_builtin_recv_extension_type()` and\n * `nghttp2_option_set_user_recv_extension_type()`, the latter takes\n * precedence.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_builtin_recv_extension_type(nghttp2_option *option,\n                                               uint8_t type);\n\n/**\n * @function\n *\n * This option prevents the library from sending PING frame with ACK\n * flag set automatically when PING frame without ACK flag set is\n * received.  If this option is set to nonzero, the library won't send\n * PING frame with ACK flag set in the response for incoming PING\n * frame.  The application can send PING frame with ACK flag set using\n * `nghttp2_submit_ping()` with :enum:`NGHTTP2_FLAG_ACK` as flags\n * parameter.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_no_auto_ping_ack(nghttp2_option *option,\n                                                        int val);\n\n/**\n * @function\n *\n * This option sets the maximum length of header block (a set of\n * header fields per one HEADERS frame) to send.  The length of a\n * given set of header fields is calculated using\n * `nghttp2_hd_deflate_bound()`.  The default value is 64KiB.  If\n * application attempts to send header fields larger than this limit,\n * the transmission of the frame fails with error code\n * :enum:`NGHTTP2_ERR_FRAME_SIZE_ERROR`.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_max_send_header_block_length(nghttp2_option *option,\n                                                size_t val);\n\n/**\n * @function\n *\n * This option sets the maximum dynamic table size for deflating\n * header fields.  The default value is 4KiB.  In HTTP/2, receiver of\n * deflated header block can specify maximum dynamic table size.  The\n * actual maximum size is the minimum of the size receiver specified\n * and this option value.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_max_deflate_dynamic_table_size(nghttp2_option *option,\n                                                  size_t val);\n\n/**\n * @function\n *\n * This option prevents the library from retaining closed streams to\n * maintain the priority tree.  If this option is set to nonzero,\n * applications can discard closed stream completely to save memory.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_no_closed_streams(nghttp2_option *option,\n                                                         int val);\n\n/**\n * @function\n *\n * This function sets the maximum number of outgoing SETTINGS ACK and\n * PING ACK frames retained in :type:`nghttp2_session` object.  If\n * more than those frames are retained, the peer is considered to be\n * misbehaving and session will be closed.  The default value is 1000.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_max_outbound_ack(nghttp2_option *option,\n                                                        size_t val);\n\n/**\n * @function\n *\n * Initializes |*session_ptr| for client use.  The all members of\n * |callbacks| are copied to |*session_ptr|.  Therefore |*session_ptr|\n * does not store |callbacks|.  The |user_data| is an arbitrary user\n * supplied data, which will be passed to the callback functions.\n *\n * The :type:`nghttp2_send_callback` must be specified.  If the\n * application code uses `nghttp2_session_recv()`, the\n * :type:`nghttp2_recv_callback` must be specified.  The other members\n * of |callbacks| can be ``NULL``.\n *\n * If this function fails, |*session_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_client_new(nghttp2_session **session_ptr,\n                           const nghttp2_session_callbacks *callbacks,\n                           void *user_data);\n\n/**\n * @function\n *\n * Initializes |*session_ptr| for server use.  The all members of\n * |callbacks| are copied to |*session_ptr|. Therefore |*session_ptr|\n * does not store |callbacks|.  The |user_data| is an arbitrary user\n * supplied data, which will be passed to the callback functions.\n *\n * The :type:`nghttp2_send_callback` must be specified.  If the\n * application code uses `nghttp2_session_recv()`, the\n * :type:`nghttp2_recv_callback` must be specified.  The other members\n * of |callbacks| can be ``NULL``.\n *\n * If this function fails, |*session_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_server_new(nghttp2_session **session_ptr,\n                           const nghttp2_session_callbacks *callbacks,\n                           void *user_data);\n\n/**\n * @function\n *\n * Like `nghttp2_session_client_new()`, but with additional options\n * specified in the |option|.\n *\n * The |option| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_client_new()`.\n *\n * This function does not take ownership |option|.  The application is\n * responsible for freeing |option| if it finishes using the object.\n *\n * The library code does not refer to |option| after this function\n * returns.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_client_new2(nghttp2_session **session_ptr,\n                            const nghttp2_session_callbacks *callbacks,\n                            void *user_data, const nghttp2_option *option);\n\n/**\n * @function\n *\n * Like `nghttp2_session_server_new()`, but with additional options\n * specified in the |option|.\n *\n * The |option| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_server_new()`.\n *\n * This function does not take ownership |option|.  The application is\n * responsible for freeing |option| if it finishes using the object.\n *\n * The library code does not refer to |option| after this function\n * returns.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_server_new2(nghttp2_session **session_ptr,\n                            const nghttp2_session_callbacks *callbacks,\n                            void *user_data, const nghttp2_option *option);\n\n/**\n * @function\n *\n * Like `nghttp2_session_client_new2()`, but with additional custom\n * memory allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_client_new2()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_client_new3(\n    nghttp2_session **session_ptr, const nghttp2_session_callbacks *callbacks,\n    void *user_data, const nghttp2_option *option, nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Like `nghttp2_session_server_new2()`, but with additional custom\n * memory allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_server_new2()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_server_new3(\n    nghttp2_session **session_ptr, const nghttp2_session_callbacks *callbacks,\n    void *user_data, const nghttp2_option *option, nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Frees any resources allocated for |session|.  If |session| is\n * ``NULL``, this function does nothing.\n */\nNGHTTP2_EXTERN void nghttp2_session_del(nghttp2_session *session);\n\n/**\n * @function\n *\n * Sends pending frames to the remote peer.\n *\n * This function retrieves the highest prioritized frame from the\n * outbound queue and sends it to the remote peer.  It does this as\n * many as possible until the user callback\n * :type:`nghttp2_send_callback` returns\n * :enum:`NGHTTP2_ERR_WOULDBLOCK` or the outbound queue becomes empty.\n * This function calls several callback functions which are passed\n * when initializing the |session|.  Here is the simple time chart\n * which tells when each callback is invoked:\n *\n * 1. Get the next frame to send from outbound queue.\n *\n * 2. Prepare transmission of the frame.\n *\n * 3. If the control frame cannot be sent because some preconditions\n *    are not met (e.g., request HEADERS cannot be sent after GOAWAY),\n *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort\n *    the following steps.\n *\n * 4. If the frame is HEADERS, PUSH_PROMISE or DATA,\n *    :type:`nghttp2_select_padding_callback` is invoked.\n *\n * 5. If the frame is request HEADERS, the stream is opened here.\n *\n * 6. :type:`nghttp2_before_frame_send_callback` is invoked.\n *\n * 7. If :enum:`NGHTTP2_ERR_CANCEL` is returned from\n *    :type:`nghttp2_before_frame_send_callback`, the current frame\n *    transmission is canceled, and\n *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort\n *    the following steps.\n *\n * 8. :type:`nghttp2_send_callback` is invoked one or more times to\n *    send the frame.\n *\n * 9. :type:`nghttp2_on_frame_send_callback` is invoked.\n *\n * 10. If the transmission of the frame triggers closure of the\n *     stream, the stream is closed and\n *     :type:`nghttp2_on_stream_close_callback` is invoked.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n *     The callback function failed.\n */\nNGHTTP2_EXTERN int nghttp2_session_send(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the serialized data to send.\n *\n * This function behaves like `nghttp2_session_send()` except that it\n * does not use :type:`nghttp2_send_callback` to transmit data.\n * Instead, it assigns the pointer to the serialized data to the\n * |*data_ptr| and returns its length.  The other callbacks are called\n * in the same way as they are in `nghttp2_session_send()`.\n *\n * If no data is available to send, this function returns 0.\n *\n * This function may not return all serialized data in one invocation.\n * To get all data, call this function repeatedly until it returns 0\n * or one of negative error codes.\n *\n * The assigned |*data_ptr| is valid until the next call of\n * `nghttp2_session_mem_send()` or `nghttp2_session_send()`.\n *\n * The caller must send all data before sending the next chunk of\n * data.\n *\n * This function returns the length of the data pointed by the\n * |*data_ptr| if it succeeds, or one of the following negative error\n * codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n *\n * .. note::\n *\n *   This function may produce very small byte string.  If that is the\n *   case, and application disables Nagle algorithm (``TCP_NODELAY``),\n *   then writing this small chunk leads to very small packet, and it\n *   is very inefficient.  An application should be responsible to\n *   buffer up small chunks of data as necessary to avoid this\n *   situation.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_session_mem_send(nghttp2_session *session,\n                                                const uint8_t **data_ptr);\n\n/**\n * @function\n *\n * Receives frames from the remote peer.\n *\n * This function receives as many frames as possible until the user\n * callback :type:`nghttp2_recv_callback` returns\n * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  This function calls several\n * callback functions which are passed when initializing the\n * |session|.  Here is the simple time chart which tells when each\n * callback is invoked:\n *\n * 1. :type:`nghttp2_recv_callback` is invoked one or more times to\n *    receive frame header.\n *\n * 2. When frame header is received,\n *    :type:`nghttp2_on_begin_frame_callback` is invoked.\n *\n * 3. If the frame is DATA frame:\n *\n *    1. :type:`nghttp2_recv_callback` is invoked to receive DATA\n *       payload. For each chunk of data,\n *       :type:`nghttp2_on_data_chunk_recv_callback` is invoked.\n *\n *    2. If one DATA frame is completely received,\n *       :type:`nghttp2_on_frame_recv_callback` is invoked.  If the\n *       reception of the frame triggers the closure of the stream,\n *       :type:`nghttp2_on_stream_close_callback` is invoked.\n *\n * 4. If the frame is the control frame:\n *\n *    1. :type:`nghttp2_recv_callback` is invoked one or more times to\n *       receive whole frame.\n *\n *    2. If the received frame is valid, then following actions are\n *       taken.  If the frame is either HEADERS or PUSH_PROMISE,\n *       :type:`nghttp2_on_begin_headers_callback` is invoked.  Then\n *       :type:`nghttp2_on_header_callback` is invoked for each header\n *       name/value pair.  For invalid header field,\n *       :type:`nghttp2_on_invalid_header_callback` is called.  After\n *       all name/value pairs are emitted successfully,\n *       :type:`nghttp2_on_frame_recv_callback` is invoked.  For other\n *       frames, :type:`nghttp2_on_frame_recv_callback` is invoked.\n *       If the reception of the frame triggers the closure of the\n *       stream, :type:`nghttp2_on_stream_close_callback` is invoked.\n *\n *    3. If the received frame is unpacked but is interpreted as\n *       invalid, :type:`nghttp2_on_invalid_frame_recv_callback` is\n *       invoked.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_EOF`\n *     The remote peer did shutdown on the connection.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n *     The callback function failed.\n * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`\n *     Invalid client magic was detected.  This error only returns\n *     when |session| was configured as server and\n *     `nghttp2_option_set_no_recv_client_magic()` is not used with\n *     nonzero value.\n * :enum:`NGHTTP2_ERR_FLOODED`\n *     Flooding was detected in this HTTP/2 session, and it must be\n *     closed.  This is most likely caused by misbehaviour of peer.\n */\nNGHTTP2_EXTERN int nghttp2_session_recv(nghttp2_session *session);\n\n/**\n * @function\n *\n * Processes data |in| as an input from the remote endpoint.  The\n * |inlen| indicates the number of bytes in the |in|.\n *\n * This function behaves like `nghttp2_session_recv()` except that it\n * does not use :type:`nghttp2_recv_callback` to receive data; the\n * |in| is the only data for the invocation of this function.  If all\n * bytes are processed, this function returns.  The other callbacks\n * are called in the same way as they are in `nghttp2_session_recv()`.\n *\n * In the current implementation, this function always tries to\n * processes all input data unless either an error occurs or\n * :enum:`NGHTTP2_ERR_PAUSE` is returned from\n * :type:`nghttp2_on_header_callback` or\n * :type:`nghttp2_on_data_chunk_recv_callback`.  If\n * :enum:`NGHTTP2_ERR_PAUSE` is used, the return value includes the\n * number of bytes which was used to produce the data or frame for the\n * callback.\n *\n * This function returns the number of processed bytes, or one of the\n * following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n *     The callback function failed.\n * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`\n *     Invalid client magic was detected.  This error only returns\n *     when |session| was configured as server and\n *     `nghttp2_option_set_no_recv_client_magic()` is not used with\n *     nonzero value.\n * :enum:`NGHTTP2_ERR_FLOODED`\n *     Flooding was detected in this HTTP/2 session, and it must be\n *     closed.  This is most likely caused by misbehaviour of peer.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_session_mem_recv(nghttp2_session *session,\n                                                const uint8_t *in,\n                                                size_t inlen);\n\n/**\n * @function\n *\n * Puts back previously deferred DATA frame in the stream |stream_id|\n * to the outbound queue.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The stream does not exist; or no deferred data exist.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_resume_data(nghttp2_session *session,\n                                               int32_t stream_id);\n\n/**\n * @function\n *\n * Returns nonzero value if |session| wants to receive data from the\n * remote peer.\n *\n * If both `nghttp2_session_want_read()` and\n * `nghttp2_session_want_write()` return 0, the application should\n * drop the connection.\n */\nNGHTTP2_EXTERN int nghttp2_session_want_read(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns nonzero value if |session| wants to send data to the remote\n * peer.\n *\n * If both `nghttp2_session_want_read()` and\n * `nghttp2_session_want_write()` return 0, the application should\n * drop the connection.\n */\nNGHTTP2_EXTERN int nghttp2_session_want_write(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns stream_user_data for the stream |stream_id|.  The\n * stream_user_data is provided by `nghttp2_submit_request()`,\n * `nghttp2_submit_headers()` or\n * `nghttp2_session_set_stream_user_data()`.  Unless it is set using\n * `nghttp2_session_set_stream_user_data()`, if the stream is\n * initiated by the remote endpoint, stream_user_data is always\n * ``NULL``.  If the stream does not exist, this function returns\n * ``NULL``.\n */\nNGHTTP2_EXTERN void *\nnghttp2_session_get_stream_user_data(nghttp2_session *session,\n                                     int32_t stream_id);\n\n/**\n * @function\n *\n * Sets the |stream_user_data| to the stream denoted by the\n * |stream_id|.  If a stream user data is already set to the stream,\n * it is replaced with the |stream_user_data|.  It is valid to specify\n * ``NULL`` in the |stream_user_data|, which nullifies the associated\n * data pointer.\n *\n * It is valid to set the |stream_user_data| to the stream reserved by\n * PUSH_PROMISE frame.\n *\n * This function returns 0 if it succeeds, or one of following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The stream does not exist\n */\nNGHTTP2_EXTERN int\nnghttp2_session_set_stream_user_data(nghttp2_session *session,\n                                     int32_t stream_id, void *stream_user_data);\n\n/**\n * @function\n *\n * Sets |user_data| to |session|, overwriting the existing user data\n * specified in `nghttp2_session_client_new()`, or\n * `nghttp2_session_server_new()`.\n */\nNGHTTP2_EXTERN void nghttp2_session_set_user_data(nghttp2_session *session,\n                                                  void *user_data);\n\n/**\n * @function\n *\n * Returns the number of frames in the outbound queue.  This does not\n * include the deferred DATA frames.\n */\nNGHTTP2_EXTERN size_t\nnghttp2_session_get_outbound_queue_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the number of DATA payload in bytes received without\n * WINDOW_UPDATE transmission for the stream |stream_id|.  The local\n * (receive) window size can be adjusted by\n * `nghttp2_submit_window_update()`.  This function takes into account\n * that and returns effective data length.  In particular, if the\n * local window size is reduced by submitting negative\n * window_size_increment with `nghttp2_submit_window_update()`, this\n * function returns the number of bytes less than actually received.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_effective_recv_data_length(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the local (receive) window size for the stream |stream_id|.\n * The local window size can be adjusted by\n * `nghttp2_submit_window_update()`.  This function takes into account\n * that and returns effective window size.\n *\n * This function does not take into account the amount of received\n * data from the remote endpoint.  Use\n * `nghttp2_session_get_stream_local_window_size()` to know the amount\n * of data the remote endpoint can send without receiving stream level\n * WINDOW_UPDATE frame.  Note that each stream is still subject to the\n * connection level flow control.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_effective_local_window_size(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the amount of flow-controlled payload (e.g., DATA) that the\n * remote endpoint can send without receiving stream level\n * WINDOW_UPDATE frame.  It is also subject to the connection level\n * flow control.  So the actual amount of data to send is\n * min(`nghttp2_session_get_stream_local_window_size()`,\n * `nghttp2_session_get_local_window_size()`).\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_local_window_size(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the number of DATA payload in bytes received without\n * WINDOW_UPDATE transmission for a connection.  The local (receive)\n * window size can be adjusted by `nghttp2_submit_window_update()`.\n * This function takes into account that and returns effective data\n * length.  In particular, if the local window size is reduced by\n * submitting negative window_size_increment with\n * `nghttp2_submit_window_update()`, this function returns the number\n * of bytes less than actually received.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_effective_recv_data_length(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the local (receive) window size for a connection.  The\n * local window size can be adjusted by\n * `nghttp2_submit_window_update()`.  This function takes into account\n * that and returns effective window size.\n *\n * This function does not take into account the amount of received\n * data from the remote endpoint.  Use\n * `nghttp2_session_get_local_window_size()` to know the amount of\n * data the remote endpoint can send without receiving\n * connection-level WINDOW_UPDATE frame.  Note that each stream is\n * still subject to the stream level flow control.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_effective_local_window_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the amount of flow-controlled payload (e.g., DATA) that the\n * remote endpoint can send without receiving connection level\n * WINDOW_UPDATE frame.  Note that each stream is still subject to the\n * stream level flow control (see\n * `nghttp2_session_get_stream_local_window_size()`).\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_local_window_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the remote window size for a given stream |stream_id|.\n *\n * This is the amount of flow-controlled payload (e.g., DATA) that the\n * local endpoint can send without stream level WINDOW_UPDATE.  There\n * is also connection level flow control, so the effective size of\n * payload that the local endpoint can actually send is\n * min(`nghttp2_session_get_stream_remote_window_size()`,\n * `nghttp2_session_get_remote_window_size()`).\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_remote_window_size(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the remote window size for a connection.\n *\n * This function always succeeds.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_remote_window_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns 1 if local peer half closed the given stream |stream_id|.\n * Returns 0 if it did not.  Returns -1 if no such stream exists.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_get_stream_local_close(nghttp2_session *session,\n                                       int32_t stream_id);\n\n/**\n * @function\n *\n * Returns 1 if remote peer half closed the given stream |stream_id|.\n * Returns 0 if it did not.  Returns -1 if no such stream exists.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_get_stream_remote_close(nghttp2_session *session,\n                                        int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the current dynamic table size of HPACK inflater, including\n * the overhead 32 bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN size_t\nnghttp2_session_get_hd_inflate_dynamic_table_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the current dynamic table size of HPACK deflater including\n * the overhead 32 bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN size_t\nnghttp2_session_get_hd_deflate_dynamic_table_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Signals the session so that the connection should be terminated.\n *\n * The last stream ID is the minimum value between the stream ID of a\n * stream for which :type:`nghttp2_on_frame_recv_callback` was called\n * most recently and the last stream ID we have sent to the peer\n * previously.\n *\n * The |error_code| is the error code of this GOAWAY frame.  The\n * pre-defined error code is one of :enum:`nghttp2_error_code`.\n *\n * After the transmission, both `nghttp2_session_want_read()` and\n * `nghttp2_session_want_write()` return 0.\n *\n * This function should be called when the connection should be\n * terminated after sending GOAWAY.  If the remaining streams should\n * be processed after GOAWAY, use `nghttp2_submit_goaway()` instead.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_terminate_session(nghttp2_session *session,\n                                                     uint32_t error_code);\n\n/**\n * @function\n *\n * Signals the session so that the connection should be terminated.\n *\n * This function behaves like `nghttp2_session_terminate_session()`,\n * but the last stream ID can be specified by the application for fine\n * grained control of stream.  The HTTP/2 specification does not allow\n * last_stream_id to be increased.  So the actual value sent as\n * last_stream_id is the minimum value between the given\n * |last_stream_id| and the last_stream_id we have previously sent to\n * the peer.\n *\n * The |last_stream_id| is peer's stream ID or 0.  So if |session| is\n * initialized as client, |last_stream_id| must be even or 0.  If\n * |session| is initialized as server, |last_stream_id| must be odd or\n * 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |last_stream_id| is invalid.\n */\nNGHTTP2_EXTERN int nghttp2_session_terminate_session2(nghttp2_session *session,\n                                                      int32_t last_stream_id,\n                                                      uint32_t error_code);\n\n/**\n * @function\n *\n * Signals to the client that the server started graceful shutdown\n * procedure.\n *\n * This function is only usable for server.  If this function is\n * called with client side session, this function returns\n * :enum:`NGHTTP2_ERR_INVALID_STATE`.\n *\n * To gracefully shutdown HTTP/2 session, server should call this\n * function to send GOAWAY with last_stream_id (1u << 31) - 1.  And\n * after some delay (e.g., 1 RTT), send another GOAWAY with the stream\n * ID that the server has some processing using\n * `nghttp2_submit_goaway()`.  See also\n * `nghttp2_session_get_last_proc_stream_id()`.\n *\n * Unlike `nghttp2_submit_goaway()`, this function just sends GOAWAY\n * and does nothing more.  This is a mere indication to the client\n * that session shutdown is imminent.  The application should call\n * `nghttp2_submit_goaway()` with appropriate last_stream_id after\n * this call.\n *\n * If one or more GOAWAY frame have been already sent by either\n * `nghttp2_submit_goaway()` or `nghttp2_session_terminate_session()`,\n * this function has no effect.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The |session| is initialized as client.\n */\nNGHTTP2_EXTERN int nghttp2_submit_shutdown_notice(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the value of SETTINGS |id| notified by a remote endpoint.\n * The |id| must be one of values defined in\n * :enum:`nghttp2_settings_id`.\n */\nNGHTTP2_EXTERN uint32_t nghttp2_session_get_remote_settings(\n    nghttp2_session *session, nghttp2_settings_id id);\n\n/**\n * @function\n *\n * Returns the value of SETTINGS |id| of local endpoint acknowledged\n * by the remote endpoint.  The |id| must be one of the values defined\n * in :enum:`nghttp2_settings_id`.\n */\nNGHTTP2_EXTERN uint32_t nghttp2_session_get_local_settings(\n    nghttp2_session *session, nghttp2_settings_id id);\n\n/**\n * @function\n *\n * Tells the |session| that next stream ID is |next_stream_id|.  The\n * |next_stream_id| must be equal or greater than the value returned\n * by `nghttp2_session_get_next_stream_id()`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |next_stream_id| is strictly less than the value\n *     `nghttp2_session_get_next_stream_id()` returns; or\n *     |next_stream_id| is invalid (e.g., even integer for client, or\n *     odd integer for server).\n */\nNGHTTP2_EXTERN int nghttp2_session_set_next_stream_id(nghttp2_session *session,\n                                                      int32_t next_stream_id);\n\n/**\n * @function\n *\n * Returns the next outgoing stream ID.  Notice that return type is\n * uint32_t.  If we run out of stream ID for this session, this\n * function returns 1 << 31.\n */\nNGHTTP2_EXTERN uint32_t\nnghttp2_session_get_next_stream_id(nghttp2_session *session);\n\n/**\n * @function\n *\n * Tells the |session| that |size| bytes for a stream denoted by\n * |stream_id| were consumed by application and are ready to\n * WINDOW_UPDATE.  The consumed bytes are counted towards both\n * connection and stream level WINDOW_UPDATE (see\n * `nghttp2_session_consume_connection()` and\n * `nghttp2_session_consume_stream()` to update consumption\n * independently).  This function is intended to be used without\n * automatic window update (see\n * `nghttp2_option_set_no_auto_window_update()`).\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     Automatic WINDOW_UPDATE is not disabled.\n */\nNGHTTP2_EXTERN int nghttp2_session_consume(nghttp2_session *session,\n                                           int32_t stream_id, size_t size);\n\n/**\n * @function\n *\n * Like `nghttp2_session_consume()`, but this only tells library that\n * |size| bytes were consumed only for connection level.  Note that\n * HTTP/2 maintains connection and stream level flow control windows\n * independently.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     Automatic WINDOW_UPDATE is not disabled.\n */\nNGHTTP2_EXTERN int nghttp2_session_consume_connection(nghttp2_session *session,\n                                                      size_t size);\n\n/**\n * @function\n *\n * Like `nghttp2_session_consume()`, but this only tells library that\n * |size| bytes were consumed only for stream denoted by |stream_id|.\n * Note that HTTP/2 maintains connection and stream level flow control\n * windows independently.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     Automatic WINDOW_UPDATE is not disabled.\n */\nNGHTTP2_EXTERN int nghttp2_session_consume_stream(nghttp2_session *session,\n                                                  int32_t stream_id,\n                                                  size_t size);\n\n/**\n * @function\n *\n * Changes priority of existing stream denoted by |stream_id|.  The\n * new priority specification is |pri_spec|.\n *\n * The priority is changed silently and instantly, and no PRIORITY\n * frame will be sent to notify the peer of this change.  This\n * function may be useful for server to change the priority of pushed\n * stream.\n *\n * If |session| is initialized as server, and ``pri_spec->stream_id``\n * points to the idle stream, the idle stream is created if it does\n * not exist.  The created idle stream will depend on root stream\n * (stream 0) with weight 16.\n *\n * Otherwise, if stream denoted by ``pri_spec->stream_id`` is not\n * found, we use default priority instead of given |pri_spec|.  That\n * is make stream depend on root stream with weight 16.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     Attempted to depend on itself; or no stream exist for the given\n *     |stream_id|; or |stream_id| is 0\n */\nNGHTTP2_EXTERN int\nnghttp2_session_change_stream_priority(nghttp2_session *session,\n                                       int32_t stream_id,\n                                       const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Creates idle stream with the given |stream_id|, and priority\n * |pri_spec|.\n *\n * The stream creation is done without sending PRIORITY frame, which\n * means that peer does not know about the existence of this idle\n * stream in the local endpoint.\n *\n * RFC 7540 does not disallow the use of creation of idle stream with\n * odd or even stream ID regardless of client or server.  So this\n * function can create odd or even stream ID regardless of client or\n * server.  But probably it is a bit safer to use the stream ID the\n * local endpoint can initiate (in other words, use odd stream ID for\n * client, and even stream ID for server), to avoid potential\n * collision from peer's instruction.  Also we can use\n * `nghttp2_session_set_next_stream_id()` to avoid to open created\n * idle streams accidentally if we follow this recommendation.\n *\n * If |session| is initialized as server, and ``pri_spec->stream_id``\n * points to the idle stream, the idle stream is created if it does\n * not exist.  The created idle stream will depend on root stream\n * (stream 0) with weight 16.\n *\n * Otherwise, if stream denoted by ``pri_spec->stream_id`` is not\n * found, we use default priority instead of given |pri_spec|.  That\n * is make stream depend on root stream with weight 16.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     Attempted to depend on itself; or stream denoted by |stream_id|\n *     already exists; or |stream_id| cannot be used to create idle\n *     stream (in other words, local endpoint has already opened\n *     stream ID greater than or equal to the given stream ID; or\n *     |stream_id| is 0\n */\nNGHTTP2_EXTERN int\nnghttp2_session_create_idle_stream(nghttp2_session *session, int32_t stream_id,\n                                   const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Performs post-process of HTTP Upgrade request.  This function can\n * be called from both client and server, but the behavior is very\n * different in each other.\n *\n * .. warning::\n *\n *   This function is deprecated in favor of\n *   `nghttp2_session_upgrade2()`, because this function lacks the\n *   parameter to tell the library the request method used in the\n *   original HTTP request.  This information is required for client\n *   to validate actual response body length against content-length\n *   header field (see `nghttp2_option_set_no_http_messaging()`).  If\n *   HEAD is used in request, the length of response body must be 0\n *   regardless of value included in content-length header field.\n *\n * If called from client side, the |settings_payload| must be the\n * value sent in ``HTTP2-Settings`` header field and must be decoded\n * by base64url decoder.  The |settings_payloadlen| is the length of\n * |settings_payload|.  The |settings_payload| is unpacked and its\n * setting values will be submitted using `nghttp2_submit_settings()`.\n * This means that the client application code does not need to submit\n * SETTINGS by itself.  The stream with stream ID=1 is opened and the\n * |stream_user_data| is used for its stream_user_data.  The opened\n * stream becomes half-closed (local) state.\n *\n * If called from server side, the |settings_payload| must be the\n * value received in ``HTTP2-Settings`` header field and must be\n * decoded by base64url decoder.  The |settings_payloadlen| is the\n * length of |settings_payload|.  It is treated as if the SETTINGS\n * frame with that payload is received.  Thus, callback functions for\n * the reception of SETTINGS frame will be invoked.  The stream with\n * stream ID=1 is opened.  The |stream_user_data| is ignored.  The\n * opened stream becomes half-closed (remote).\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |settings_payload| is badly formed.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The stream ID 1 is already used or closed; or is not available.\n */\nNGHTTP2_EXTERN int nghttp2_session_upgrade(nghttp2_session *session,\n                                           const uint8_t *settings_payload,\n                                           size_t settings_payloadlen,\n                                           void *stream_user_data);\n\n/**\n * @function\n *\n * Performs post-process of HTTP Upgrade request.  This function can\n * be called from both client and server, but the behavior is very\n * different in each other.\n *\n * If called from client side, the |settings_payload| must be the\n * value sent in ``HTTP2-Settings`` header field and must be decoded\n * by base64url decoder.  The |settings_payloadlen| is the length of\n * |settings_payload|.  The |settings_payload| is unpacked and its\n * setting values will be submitted using `nghttp2_submit_settings()`.\n * This means that the client application code does not need to submit\n * SETTINGS by itself.  The stream with stream ID=1 is opened and the\n * |stream_user_data| is used for its stream_user_data.  The opened\n * stream becomes half-closed (local) state.\n *\n * If called from server side, the |settings_payload| must be the\n * value received in ``HTTP2-Settings`` header field and must be\n * decoded by base64url decoder.  The |settings_payloadlen| is the\n * length of |settings_payload|.  It is treated as if the SETTINGS\n * frame with that payload is received.  Thus, callback functions for\n * the reception of SETTINGS frame will be invoked.  The stream with\n * stream ID=1 is opened.  The |stream_user_data| is ignored.  The\n * opened stream becomes half-closed (remote).\n *\n * If the request method is HEAD, pass nonzero value to\n * |head_request|.  Otherwise, pass 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |settings_payload| is badly formed.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The stream ID 1 is already used or closed; or is not available.\n */\nNGHTTP2_EXTERN int nghttp2_session_upgrade2(nghttp2_session *session,\n                                            const uint8_t *settings_payload,\n                                            size_t settings_payloadlen,\n                                            int head_request,\n                                            void *stream_user_data);\n\n/**\n * @function\n *\n * Serializes the SETTINGS values |iv| in the |buf|.  The size of the\n * |buf| is specified by |buflen|.  The number of entries in the |iv|\n * array is given by |niv|.  The required space in |buf| for the |niv|\n * entries is ``6*niv`` bytes and if the given buffer is too small, an\n * error is returned.  This function is used mainly for creating a\n * SETTINGS payload to be sent with the ``HTTP2-Settings`` header\n * field in an HTTP Upgrade request.  The data written in |buf| is NOT\n * base64url encoded and the application is responsible for encoding.\n *\n * This function returns the number of bytes written in |buf|, or one\n * of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |iv| contains duplicate settings ID or invalid value.\n *\n * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`\n *     The provided |buflen| size is too small to hold the output.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_pack_settings_payload(\n    uint8_t *buf, size_t buflen, const nghttp2_settings_entry *iv, size_t niv);\n\n/**\n * @function\n *\n * Returns string describing the |lib_error_code|.  The\n * |lib_error_code| must be one of the :enum:`nghttp2_error`.\n */\nNGHTTP2_EXTERN const char *nghttp2_strerror(int lib_error_code);\n\n/**\n * @function\n *\n * Returns string representation of HTTP/2 error code |error_code|\n * (e.g., ``PROTOCOL_ERROR`` is returned if ``error_code ==\n * NGHTTP2_PROTOCOL_ERROR``).  If string representation is unknown for\n * given |error_code|, this function returns string ``unknown``.\n */\nNGHTTP2_EXTERN const char *nghttp2_http2_strerror(uint32_t error_code);\n\n/**\n * @function\n *\n * Initializes |pri_spec| with the |stream_id| of the stream to depend\n * on with |weight| and its exclusive flag.  If |exclusive| is\n * nonzero, exclusive flag is set.\n *\n * The |weight| must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.\n */\nNGHTTP2_EXTERN void nghttp2_priority_spec_init(nghttp2_priority_spec *pri_spec,\n                                               int32_t stream_id,\n                                               int32_t weight, int exclusive);\n\n/**\n * @function\n *\n * Initializes |pri_spec| with the default values.  The default values\n * are: stream_id = 0, weight = :macro:`NGHTTP2_DEFAULT_WEIGHT` and\n * exclusive = 0.\n */\nNGHTTP2_EXTERN void\nnghttp2_priority_spec_default_init(nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Returns nonzero if the |pri_spec| is filled with default values.\n */\nNGHTTP2_EXTERN int\nnghttp2_priority_spec_check_default(const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Submits HEADERS frame and optionally one or more DATA frames.\n *\n * The |pri_spec| is priority specification of this request.  ``NULL``\n * means the default priority (see\n * `nghttp2_priority_spec_default_init()`).  To specify the priority,\n * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,\n * this function will copy its data members.\n *\n * The ``pri_spec->weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec->weight`` is\n * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes\n * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than\n * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * HTTP/2 specification has requirement about header fields in the\n * request HEADERS.  See the specification for more details.\n *\n * If |data_prd| is not ``NULL``, it provides data which will be sent\n * in subsequent DATA frames.  In this case, a method that allows\n * request message bodies\n * (https://tools.ietf.org/html/rfc7231#section-4) must be specified\n * with ``:method`` key in |nva| (e.g. ``POST``).  This function does\n * not take ownership of the |data_prd|.  The function copies the\n * members of the |data_prd|.  If |data_prd| is ``NULL``, HEADERS have\n * END_STREAM set.  The |stream_user_data| is data associated to the\n * stream opened by this request and can be an arbitrary pointer,\n * which can be retrieved later by\n * `nghttp2_session_get_stream_user_data()`.\n *\n * This function returns assigned stream ID if it succeeds, or one of\n * the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`\n *     No stream ID is available because maximum stream ID was\n *     reached.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     Trying to depend on itself (new stream ID equals\n *     ``pri_spec->stream_id``).\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The |session| is server session.\n *\n * .. warning::\n *\n *   This function returns assigned stream ID if it succeeds.  But\n *   that stream is not created yet.  The application must not submit\n *   frame to that stream ID before\n *   :type:`nghttp2_before_frame_send_callback` is called for this\n *   frame.  This means `nghttp2_session_get_stream_user_data()` does\n *   not work before the callback.  But\n *   `nghttp2_session_set_stream_user_data()` handles this situation\n *   specially, and it can set data to a stream during this period.\n *\n */\nNGHTTP2_EXTERN int32_t nghttp2_submit_request(\n    nghttp2_session *session, const nghttp2_priority_spec *pri_spec,\n    const nghttp2_nv *nva, size_t nvlen, const nghttp2_data_provider *data_prd,\n    void *stream_user_data);\n\n/**\n * @function\n *\n * Submits response HEADERS frame and optionally one or more DATA\n * frames against the stream |stream_id|.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * HTTP/2 specification has requirement about header fields in the\n * response HEADERS.  See the specification for more details.\n *\n * If |data_prd| is not ``NULL``, it provides data which will be sent\n * in subsequent DATA frames.  This function does not take ownership\n * of the |data_prd|.  The function copies the members of the\n * |data_prd|.  If |data_prd| is ``NULL``, HEADERS will have\n * END_STREAM flag set.\n *\n * This method can be used as normal HTTP response and push response.\n * When pushing a resource using this function, the |session| must be\n * configured using `nghttp2_session_server_new()` or its variants and\n * the target stream denoted by the |stream_id| must be reserved using\n * `nghttp2_submit_push_promise()`.\n *\n * To send non-final response headers (e.g., HTTP status 101), don't\n * use this function because this function half-closes the outbound\n * stream.  Instead, use `nghttp2_submit_headers()` for this purpose.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_DATA_EXIST`\n *     DATA or HEADERS has been already submitted and not fully\n *     processed yet.  Normally, this does not happen, but when\n *     application wrongly calls `nghttp2_submit_response()` twice,\n *     this may happen.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The |session| is client session.\n *\n * .. warning::\n *\n *   Calling this function twice for the same stream ID may lead to\n *   program crash.  It is generally considered to a programming error\n *   to commit response twice.\n */\nNGHTTP2_EXTERN int\nnghttp2_submit_response(nghttp2_session *session, int32_t stream_id,\n                        const nghttp2_nv *nva, size_t nvlen,\n                        const nghttp2_data_provider *data_prd);\n\n/**\n * @function\n *\n * Submits trailer fields HEADERS against the stream |stream_id|.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application must not include pseudo-header\n * fields (headers whose names starts with \":\") in |nva|.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * For server, trailer fields must follow response HEADERS or response\n * DATA without END_STREAM flat set.  The library does not enforce\n * this requirement, and applications should do this for themselves.\n * If `nghttp2_submit_trailer()` is called before any response HEADERS\n * submission (usually by `nghttp2_submit_response()`), the content of\n * |nva| will be sent as response headers, which will result in error.\n *\n * This function has the same effect with `nghttp2_submit_headers()`,\n * with flags = :enum:`NGHTTP2_FLAG_END_STREAM` and both pri_spec and\n * stream_user_data to NULL.\n *\n * To submit trailer fields after `nghttp2_submit_response()` is\n * called, the application has to specify\n * :type:`nghttp2_data_provider` to `nghttp2_submit_response()`.\n * Inside of :type:`nghttp2_data_source_read_callback`, when setting\n * :enum:`NGHTTP2_DATA_FLAG_EOF`, also set\n * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM`.  After that, the\n * application can send trailer fields using\n * `nghttp2_submit_trailer()`.  `nghttp2_submit_trailer()` can be used\n * inside :type:`nghttp2_data_source_read_callback`.\n *\n * This function returns 0 if it succeeds and |stream_id| is -1.\n * Otherwise, this function returns 0 if it succeeds, or one of the\n * following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n */\nNGHTTP2_EXTERN int nghttp2_submit_trailer(nghttp2_session *session,\n                                          int32_t stream_id,\n                                          const nghttp2_nv *nva, size_t nvlen);\n\n/**\n * @function\n *\n * Submits HEADERS frame. The |flags| is bitwise OR of the\n * following values:\n *\n * * :enum:`NGHTTP2_FLAG_END_STREAM`\n *\n * If |flags| includes :enum:`NGHTTP2_FLAG_END_STREAM`, this frame has\n * END_STREAM flag set.\n *\n * The library handles the CONTINUATION frame internally and it\n * correctly sets END_HEADERS to the last sequence of the PUSH_PROMISE\n * or CONTINUATION frame.\n *\n * If the |stream_id| is -1, this frame is assumed as request (i.e.,\n * request HEADERS frame which opens new stream).  In this case, the\n * assigned stream ID will be returned.  Otherwise, specify stream ID\n * in |stream_id|.\n *\n * The |pri_spec| is priority specification of this request.  ``NULL``\n * means the default priority (see\n * `nghttp2_priority_spec_default_init()`).  To specify the priority,\n * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,\n * this function will copy its data members.\n *\n * The ``pri_spec->weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec->weight`` is\n * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes\n * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than\n * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * The |stream_user_data| is a pointer to an arbitrary data which is\n * associated to the stream this frame will open.  Therefore it is\n * only used if this frame opens streams, in other words, it changes\n * stream state from idle or reserved to open.\n *\n * This function is low-level in a sense that the application code can\n * specify flags directly.  For usual HTTP request,\n * `nghttp2_submit_request()` is useful.  Likewise, for HTTP response,\n * prefer `nghttp2_submit_response()`.\n *\n * This function returns newly assigned stream ID if it succeeds and\n * |stream_id| is -1.  Otherwise, this function returns 0 if it\n * succeeds, or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`\n *     No stream ID is available because maximum stream ID was\n *     reached.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0; or trying to depend on itself (stream ID\n *     equals ``pri_spec->stream_id``).\n * :enum:`NGHTTP2_ERR_DATA_EXIST`\n *     DATA or HEADERS has been already submitted and not fully\n *     processed yet.  This happens if stream denoted by |stream_id|\n *     is in reserved state.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The |stream_id| is -1, and |session| is server session.\n *\n * .. warning::\n *\n *   This function returns assigned stream ID if it succeeds and\n *   |stream_id| is -1.  But that stream is not opened yet.  The\n *   application must not submit frame to that stream ID before\n *   :type:`nghttp2_before_frame_send_callback` is called for this\n *   frame.\n *\n */\nNGHTTP2_EXTERN int32_t nghttp2_submit_headers(\n    nghttp2_session *session, uint8_t flags, int32_t stream_id,\n    const nghttp2_priority_spec *pri_spec, const nghttp2_nv *nva, size_t nvlen,\n    void *stream_user_data);\n\n/**\n * @function\n *\n * Submits one or more DATA frames to the stream |stream_id|.  The\n * data to be sent are provided by |data_prd|.  If |flags| contains\n * :enum:`NGHTTP2_FLAG_END_STREAM`, the last DATA frame has END_STREAM\n * flag set.\n *\n * This function does not take ownership of the |data_prd|.  The\n * function copies the members of the |data_prd|.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_DATA_EXIST`\n *     DATA or HEADERS has been already submitted and not fully\n *     processed yet.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_STREAM_CLOSED`\n *     The stream was already closed; or the |stream_id| is invalid.\n *\n * .. note::\n *\n *   Currently, only one DATA or HEADERS is allowed for a stream at a\n *   time.  Submitting these frames more than once before first DATA\n *   or HEADERS is finished results in :enum:`NGHTTP2_ERR_DATA_EXIST`\n *   error code.  The earliest callback which tells that previous\n *   frame is done is :type:`nghttp2_on_frame_send_callback`.  In side\n *   that callback, new data can be submitted using\n *   `nghttp2_submit_data()`.  Of course, all data except for last one\n *   must not have :enum:`NGHTTP2_FLAG_END_STREAM` flag set in\n *   |flags|.  This sounds a bit complicated, and we recommend to use\n *   `nghttp2_submit_request()` and `nghttp2_submit_response()` to\n *   avoid this cascading issue.  The experience shows that for HTTP\n *   use, these two functions are enough to implement both client and\n *   server.\n */\nNGHTTP2_EXTERN int nghttp2_submit_data(nghttp2_session *session, uint8_t flags,\n                                       int32_t stream_id,\n                                       const nghttp2_data_provider *data_prd);\n\n/**\n * @function\n *\n * Submits PRIORITY frame to change the priority of stream |stream_id|\n * to the priority specification |pri_spec|.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |pri_spec| is priority specification of this request.  ``NULL``\n * is not allowed for this function. To specify the priority, use\n * `nghttp2_priority_spec_init()`.  This function will copy its data\n * members.\n *\n * The ``pri_spec->weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec->weight`` is\n * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes\n * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than\n * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0; or the |pri_spec| is NULL; or trying to\n *     depend on itself.\n */\nNGHTTP2_EXTERN int\nnghttp2_submit_priority(nghttp2_session *session, uint8_t flags,\n                        int32_t stream_id,\n                        const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Submits RST_STREAM frame to cancel/reject the stream |stream_id|\n * with the error code |error_code|.\n *\n * The pre-defined error code is one of :enum:`nghttp2_error_code`.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n */\nNGHTTP2_EXTERN int nghttp2_submit_rst_stream(nghttp2_session *session,\n                                             uint8_t flags, int32_t stream_id,\n                                             uint32_t error_code);\n\n/**\n * @function\n *\n * Stores local settings and submits SETTINGS frame.  The |iv| is the\n * pointer to the array of :type:`nghttp2_settings_entry`.  The |niv|\n * indicates the number of :type:`nghttp2_settings_entry`.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * This function does not take ownership of the |iv|.  This function\n * copies all the elements in the |iv|.\n *\n * While updating individual stream's local window size, if the window\n * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,\n * RST_STREAM is issued against such a stream.\n *\n * SETTINGS with :enum:`NGHTTP2_FLAG_ACK` is automatically submitted\n * by the library and application could not send it at its will.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |iv| contains invalid value (e.g., initial window size\n *     strictly greater than (1 << 31) - 1.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_submit_settings(nghttp2_session *session,\n                                           uint8_t flags,\n                                           const nghttp2_settings_entry *iv,\n                                           size_t niv);\n\n/**\n * @function\n *\n * Submits PUSH_PROMISE frame.\n *\n * The |flags| is currently ignored.  The library handles the\n * CONTINUATION frame internally and it correctly sets END_HEADERS to\n * the last sequence of the PUSH_PROMISE or CONTINUATION frame.\n *\n * The |stream_id| must be client initiated stream ID.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * The |promised_stream_user_data| is a pointer to an arbitrary data\n * which is associated to the promised stream this frame will open and\n * make it in reserved state.  It is available using\n * `nghttp2_session_get_stream_user_data()`.  The application can\n * access it in :type:`nghttp2_before_frame_send_callback` and\n * :type:`nghttp2_on_frame_send_callback` of this frame.\n *\n * The client side is not allowed to use this function.\n *\n * To submit response headers and data, use\n * `nghttp2_submit_response()`.\n *\n * This function returns assigned promised stream ID if it succeeds,\n * or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     This function was invoked when |session| is initialized as\n *     client.\n * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`\n *     No stream ID is available because maximum stream ID was\n *     reached.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0; The |stream_id| does not designate stream\n *     that peer initiated.\n * :enum:`NGHTTP2_ERR_STREAM_CLOSED`\n *     The stream was already closed; or the |stream_id| is invalid.\n *\n * .. warning::\n *\n *   This function returns assigned promised stream ID if it succeeds.\n *   As of 1.16.0, stream object for pushed resource is created when\n *   this function succeeds.  In that case, the application can submit\n *   push response for the promised frame.\n *\n *   In 1.15.0 or prior versions, pushed stream is not opened yet when\n *   this function succeeds.  The application must not submit frame to\n *   that stream ID before :type:`nghttp2_before_frame_send_callback`\n *   is called for this frame.\n *\n */\nNGHTTP2_EXTERN int32_t nghttp2_submit_push_promise(\n    nghttp2_session *session, uint8_t flags, int32_t stream_id,\n    const nghttp2_nv *nva, size_t nvlen, void *promised_stream_user_data);\n\n/**\n * @function\n *\n * Submits PING frame.  You don't have to send PING back when you\n * received PING frame.  The library automatically submits PING frame\n * in this case.\n *\n * The |flags| is bitwise OR of 0 or more of the following value.\n *\n * * :enum:`NGHTTP2_FLAG_ACK`\n *\n * Unless `nghttp2_option_set_no_auto_ping_ack()` is used, the |flags|\n * should be :enum:`NGHTTP2_FLAG_NONE`.\n *\n * If the |opaque_data| is non ``NULL``, then it should point to the 8\n * bytes array of memory to specify opaque data to send with PING\n * frame.  If the |opaque_data| is ``NULL``, zero-cleared 8 bytes will\n * be sent as opaque data.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_submit_ping(nghttp2_session *session, uint8_t flags,\n                                       const uint8_t *opaque_data);\n\n/**\n * @function\n *\n * Submits GOAWAY frame with the last stream ID |last_stream_id| and\n * the error code |error_code|.\n *\n * The pre-defined error code is one of :enum:`nghttp2_error_code`.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |last_stream_id| is peer's stream ID or 0.  So if |session| is\n * initialized as client, |last_stream_id| must be even or 0.  If\n * |session| is initialized as server, |last_stream_id| must be odd or\n * 0.\n *\n * The HTTP/2 specification says last_stream_id must not be increased\n * from the value previously sent.  So the actual value sent as\n * last_stream_id is the minimum value between the given\n * |last_stream_id| and the last_stream_id previously sent to the\n * peer.\n *\n * If the |opaque_data| is not ``NULL`` and |opaque_data_len| is not\n * zero, those data will be sent as additional debug data.  The\n * library makes a copy of the memory region pointed by |opaque_data|\n * with the length |opaque_data_len|, so the caller does not need to\n * keep this memory after the return of this function.  If the\n * |opaque_data_len| is 0, the |opaque_data| could be ``NULL``.\n *\n * After successful transmission of GOAWAY, following things happen.\n * All incoming streams having strictly more than |last_stream_id| are\n * closed.  All incoming HEADERS which starts new stream are simply\n * ignored.  After all active streams are handled, both\n * `nghttp2_session_want_read()` and `nghttp2_session_want_write()`\n * return 0 and the application can close session.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |opaque_data_len| is too large; the |last_stream_id| is\n *     invalid.\n */\nNGHTTP2_EXTERN int nghttp2_submit_goaway(nghttp2_session *session,\n                                         uint8_t flags, int32_t last_stream_id,\n                                         uint32_t error_code,\n                                         const uint8_t *opaque_data,\n                                         size_t opaque_data_len);\n\n/**\n * @function\n *\n * Returns the last stream ID of a stream for which\n * :type:`nghttp2_on_frame_recv_callback` was invoked most recently.\n * The returned value can be used as last_stream_id parameter for\n * `nghttp2_submit_goaway()` and\n * `nghttp2_session_terminate_session2()`.\n *\n * This function always succeeds.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_last_proc_stream_id(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns nonzero if new request can be sent from local endpoint.\n *\n * This function return 0 if request is not allowed for this session.\n * There are several reasons why request is not allowed.  Some of the\n * reasons are: session is server; stream ID has been spent; GOAWAY\n * has been sent or received.\n *\n * The application can call `nghttp2_submit_request()` without\n * consulting this function.  In that case, `nghttp2_submit_request()`\n * may return error.  Or, request is failed to sent, and\n * :type:`nghttp2_on_stream_close_callback` is called.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_check_request_allowed(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns nonzero if |session| is initialized as server side session.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_check_server_session(nghttp2_session *session);\n\n/**\n * @function\n *\n * Submits WINDOW_UPDATE frame.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |stream_id| is the stream ID to send this WINDOW_UPDATE.  To\n * send connection level WINDOW_UPDATE, specify 0 to |stream_id|.\n *\n * If the |window_size_increment| is positive, the WINDOW_UPDATE with\n * that value as window_size_increment is queued.  If the\n * |window_size_increment| is larger than the received bytes from the\n * remote endpoint, the local window size is increased by that\n * difference.  If the sole purpose is to increase the local window\n * size, consider to use `nghttp2_session_set_local_window_size()`.\n *\n * If the |window_size_increment| is negative, the local window size\n * is decreased by -|window_size_increment|.  If automatic\n * WINDOW_UPDATE is enabled\n * (`nghttp2_option_set_no_auto_window_update()`), and the library\n * decided that the WINDOW_UPDATE should be submitted, then\n * WINDOW_UPDATE is queued with the current received bytes count.  If\n * the sole purpose is to decrease the local window size, consider to\n * use `nghttp2_session_set_local_window_size()`.\n *\n * If the |window_size_increment| is 0, the function does nothing and\n * returns 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_FLOW_CONTROL`\n *     The local window size overflow or gets negative.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_submit_window_update(nghttp2_session *session,\n                                                uint8_t flags,\n                                                int32_t stream_id,\n                                                int32_t window_size_increment);\n\n/**\n * @function\n *\n * Set local window size (local endpoints's window size) to the given\n * |window_size| for the given stream denoted by |stream_id|.  To\n * change connection level window size, specify 0 to |stream_id|.  To\n * increase window size, this function may submit WINDOW_UPDATE frame\n * to transmission queue.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * This sounds similar to `nghttp2_submit_window_update()`, but there\n * are 2 differences.  The first difference is that this function\n * takes the absolute value of window size to set, rather than the\n * delta.  To change the window size, this may be easier to use since\n * the application just declares the intended window size, rather than\n * calculating delta.  The second difference is that\n * `nghttp2_submit_window_update()` affects the received bytes count\n * which has not acked yet.  By the specification of\n * `nghttp2_submit_window_update()`, to strictly increase the local\n * window size, we have to submit delta including all received bytes\n * count, which might not be desirable in some cases.  On the other\n * hand, this function does not affect the received bytes count.  It\n * just sets the local window size to the given value.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is negative.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_set_local_window_size(nghttp2_session *session, uint8_t flags,\n                                      int32_t stream_id, int32_t window_size);\n\n/**\n * @function\n *\n * Submits extension frame.\n *\n * Application can pass arbitrary frame flags and stream ID in |flags|\n * and |stream_id| respectively.  The |payload| is opaque pointer, and\n * it can be accessible though ``frame->ext.payload`` in\n * :type:`nghttp2_pack_extension_callback`.  The library will not own\n * passed |payload| pointer.\n *\n * The application must set :type:`nghttp2_pack_extension_callback`\n * using `nghttp2_session_callbacks_set_pack_extension_callback()`.\n *\n * The application should retain the memory pointed by |payload| until\n * the transmission of extension frame is done (which is indicated by\n * :type:`nghttp2_on_frame_send_callback`), or transmission fails\n * (which is indicated by :type:`nghttp2_on_frame_not_send_callback`).\n * If application does not touch this memory region after packing it\n * into a wire format, application can free it inside\n * :type:`nghttp2_pack_extension_callback`.\n *\n * The standard HTTP/2 frame cannot be sent with this function, so\n * |type| must be strictly grater than 0x9.  Otherwise, this function\n * will fail with error code :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     If :type:`nghttp2_pack_extension_callback` is not set.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     If  |type| specifies  standard  HTTP/2 frame  type.  The  frame\n *     types  in the  rage [0x0,  0x9], both  inclusive, are  standard\n *     HTTP/2 frame type, and cannot be sent using this function.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory\n */\nNGHTTP2_EXTERN int nghttp2_submit_extension(nghttp2_session *session,\n                                            uint8_t type, uint8_t flags,\n                                            int32_t stream_id, void *payload);\n\n/**\n * @struct\n *\n * The payload of ALTSVC frame.  ALTSVC frame is a non-critical\n * extension to HTTP/2.  If this frame is received, and\n * `nghttp2_option_set_user_recv_extension_type()` is not set, and\n * `nghttp2_option_set_builtin_recv_extension_type()` is set for\n * :enum:`NGHTTP2_ALTSVC`, ``nghttp2_extension.payload`` will point to\n * this struct.\n *\n * It has the following members:\n */\ntypedef struct {\n  /**\n   * The pointer to origin which this alternative service is\n   * associated with.  This is not necessarily NULL-terminated.\n   */\n  uint8_t *origin;\n  /**\n   * The length of the |origin|.\n   */\n  size_t origin_len;\n  /**\n   * The pointer to Alt-Svc field value contained in ALTSVC frame.\n   * This is not necessarily NULL-terminated.\n   */\n  uint8_t *field_value;\n  /**\n   * The length of the |field_value|.\n   */\n  size_t field_value_len;\n} nghttp2_ext_altsvc;\n\n/**\n * @function\n *\n * Submits ALTSVC frame.\n *\n * ALTSVC frame is a non-critical extension to HTTP/2, and defined in\n * `RFC 7383 <https://tools.ietf.org/html/rfc7838#section-4>`_.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |origin| points to the origin this alternative service is\n * associated with.  The |origin_len| is the length of the origin.  If\n * |stream_id| is 0, the origin must be specified.  If |stream_id| is\n * not zero, the origin must be empty (in other words, |origin_len|\n * must be 0).\n *\n * The ALTSVC frame is only usable from server side.  If this function\n * is invoked with client side session, this function returns\n * :enum:`NGHTTP2_ERR_INVALID_STATE`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The function is called from client side session\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The sum of |origin_len| and |field_value_len| is larger than\n *     16382; or |origin_len| is 0 while |stream_id| is 0; or\n *     |origin_len| is not 0 while |stream_id| is not 0.\n */\nNGHTTP2_EXTERN int nghttp2_submit_altsvc(nghttp2_session *session,\n                                         uint8_t flags, int32_t stream_id,\n                                         const uint8_t *origin,\n                                         size_t origin_len,\n                                         const uint8_t *field_value,\n                                         size_t field_value_len);\n\n/**\n * @struct\n *\n * The single entry of an origin.\n */\ntypedef struct {\n  /**\n   * The pointer to origin.  No validation is made against this field\n   * by the library.  This is not necessarily NULL-terminated.\n   */\n  uint8_t *origin;\n  /**\n   * The length of the |origin|.\n   */\n  size_t origin_len;\n} nghttp2_origin_entry;\n\n/**\n * @struct\n *\n * The payload of ORIGIN frame.  ORIGIN frame is a non-critical\n * extension to HTTP/2 and defined by `RFC 8336\n * <https://tools.ietf.org/html/rfc8336>`_.\n *\n * If this frame is received, and\n * `nghttp2_option_set_user_recv_extension_type()` is not set, and\n * `nghttp2_option_set_builtin_recv_extension_type()` is set for\n * :enum:`NGHTTP2_ORIGIN`, ``nghttp2_extension.payload`` will point to\n * this struct.\n *\n * It has the following members:\n */\ntypedef struct {\n  /**\n   * The number of origins contained in |ov|.\n   */\n  size_t nov;\n  /**\n   * The pointer to the array of origins contained in ORIGIN frame.\n   */\n  nghttp2_origin_entry *ov;\n} nghttp2_ext_origin;\n\n/**\n * @function\n *\n * Submits ORIGIN frame.\n *\n * ORIGIN frame is a non-critical extension to HTTP/2 and defined by\n * `RFC 8336 <https://tools.ietf.org/html/rfc8336>`_.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |ov| points to the array of origins.  The |nov| specifies the\n * number of origins included in |ov|.  This function creates copies\n * of all elements in |ov|.\n *\n * The ORIGIN frame is only usable by a server.  If this function is\n * invoked with client side session, this function returns\n * :enum:`NGHTTP2_ERR_INVALID_STATE`.\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The function is called from client side session.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     There are too many origins, or an origin is too large to fit\n *     into a default frame payload.\n */\nNGHTTP2_EXTERN int nghttp2_submit_origin(nghttp2_session *session,\n                                         uint8_t flags,\n                                         const nghttp2_origin_entry *ov,\n                                         size_t nov);\n\n/**\n * @function\n *\n * Compares ``lhs->name`` of length ``lhs->namelen`` bytes and\n * ``rhs->name`` of length ``rhs->namelen`` bytes.  Returns negative\n * integer if ``lhs->name`` is found to be less than ``rhs->name``; or\n * returns positive integer if ``lhs->name`` is found to be greater\n * than ``rhs->name``; or returns 0 otherwise.\n */\nNGHTTP2_EXTERN int nghttp2_nv_compare_name(const nghttp2_nv *lhs,\n                                           const nghttp2_nv *rhs);\n\n/**\n * @function\n *\n * A helper function for dealing with NPN in client side or ALPN in\n * server side.  The |in| contains peer's protocol list in preferable\n * order.  The format of |in| is length-prefixed and not\n * null-terminated.  For example, ``h2`` and\n * ``http/1.1`` stored in |in| like this::\n *\n *     in[0] = 2\n *     in[1..2] = \"h2\"\n *     in[3] = 8\n *     in[4..11] = \"http/1.1\"\n *     inlen = 12\n *\n * The selection algorithm is as follows:\n *\n * 1. If peer's list contains HTTP/2 protocol the library supports,\n *    it is selected and returns 1. The following step is not taken.\n *\n * 2. If peer's list contains ``http/1.1``, this function selects\n *    ``http/1.1`` and returns 0.  The following step is not taken.\n *\n * 3. This function selects nothing and returns -1 (So called\n *    non-overlap case).  In this case, |out| and |outlen| are left\n *    untouched.\n *\n * Selecting ``h2`` means that ``h2`` is written into |*out| and its\n * length (which is 2) is assigned to |*outlen|.\n *\n * For ALPN, refer to https://tools.ietf.org/html/rfc7301\n *\n * See http://technotes.googlecode.com/git/nextprotoneg.html for more\n * details about NPN.\n *\n * For NPN, to use this method you should do something like::\n *\n *     static int select_next_proto_cb(SSL* ssl,\n *                                     unsigned char **out,\n *                                     unsigned char *outlen,\n *                                     const unsigned char *in,\n *                                     unsigned int inlen,\n *                                     void *arg)\n *     {\n *         int rv;\n *         rv = nghttp2_select_next_protocol(out, outlen, in, inlen);\n *         if (rv == -1) {\n *             return SSL_TLSEXT_ERR_NOACK;\n *         }\n *         if (rv == 1) {\n *             ((MyType*)arg)->http2_selected = 1;\n *         }\n *         return SSL_TLSEXT_ERR_OK;\n *     }\n *     ...\n *     SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb, my_obj);\n *\n */\nNGHTTP2_EXTERN int nghttp2_select_next_protocol(unsigned char **out,\n                                                unsigned char *outlen,\n                                                const unsigned char *in,\n                                                unsigned int inlen);\n\n/**\n * @function\n *\n * Returns a pointer to a nghttp2_info struct with version information\n * about the run-time library in use.  The |least_version| argument\n * can be set to a 24 bit numerical value for the least accepted\n * version number and if the condition is not met, this function will\n * return a ``NULL``.  Pass in 0 to skip the version checking.\n */\nNGHTTP2_EXTERN nghttp2_info *nghttp2_version(int least_version);\n\n/**\n * @function\n *\n * Returns nonzero if the :type:`nghttp2_error` library error code\n * |lib_error| is fatal.\n */\nNGHTTP2_EXTERN int nghttp2_is_fatal(int lib_error_code);\n\n/**\n * @function\n *\n * Returns nonzero if HTTP header field name |name| of length |len| is\n * valid according to http://tools.ietf.org/html/rfc7230#section-3.2\n *\n * Because this is a header field name in HTTP2, the upper cased alphabet\n * is treated as error.\n */\nNGHTTP2_EXTERN int nghttp2_check_header_name(const uint8_t *name, size_t len);\n\n/**\n * @function\n *\n * Returns nonzero if HTTP header field value |value| of length |len|\n * is valid according to\n * http://tools.ietf.org/html/rfc7230#section-3.2\n */\nNGHTTP2_EXTERN int nghttp2_check_header_value(const uint8_t *value, size_t len);\n\n/**\n * @function\n *\n * Returns nonzero if the |value| which is supposed to the value of\n * :authority or host header field is valid according to\n * https://tools.ietf.org/html/rfc3986#section-3.2\n *\n * |value| is valid if it merely consists of the allowed characters.\n * In particular, it does not check whether |value| follows the syntax\n * of authority.\n */\nNGHTTP2_EXTERN int nghttp2_check_authority(const uint8_t *value, size_t len);\n\n/* HPACK API */\n\nstruct nghttp2_hd_deflater;\n\n/**\n * @struct\n *\n * HPACK deflater object.\n */\ntypedef struct nghttp2_hd_deflater nghttp2_hd_deflater;\n\n/**\n * @function\n *\n * Initializes |*deflater_ptr| for deflating name/values pairs.\n *\n * The |max_deflate_dynamic_table_size| is the upper bound of header\n * table size the deflater will use.\n *\n * If this function fails, |*deflater_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_deflate_new(nghttp2_hd_deflater **deflater_ptr,\n                       size_t max_deflate_dynamic_table_size);\n\n/**\n * @function\n *\n * Like `nghttp2_hd_deflate_new()`, but with additional custom memory\n * allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_hd_deflate_new()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_deflate_new2(nghttp2_hd_deflater **deflater_ptr,\n                        size_t max_deflate_dynamic_table_size,\n                        nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Deallocates any resources allocated for |deflater|.\n */\nNGHTTP2_EXTERN void nghttp2_hd_deflate_del(nghttp2_hd_deflater *deflater);\n\n/**\n * @function\n *\n * Changes header table size of the |deflater| to\n * |settings_max_dynamic_table_size| bytes.  This may trigger eviction\n * in the dynamic table.\n *\n * The |settings_max_dynamic_table_size| should be the value received\n * in SETTINGS_HEADER_TABLE_SIZE.\n *\n * The deflater never uses more memory than\n * ``max_deflate_dynamic_table_size`` bytes specified in\n * `nghttp2_hd_deflate_new()`.  Therefore, if\n * |settings_max_dynamic_table_size| >\n * ``max_deflate_dynamic_table_size``, resulting maximum table size\n * becomes ``max_deflate_dynamic_table_size``.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_deflate_change_table_size(nghttp2_hd_deflater *deflater,\n                                     size_t settings_max_dynamic_table_size);\n\n/**\n * @function\n *\n * Deflates the |nva|, which has the |nvlen| name/value pairs, into\n * the |buf| of length |buflen|.\n *\n * If |buf| is not large enough to store the deflated header block,\n * this function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The\n * caller should use `nghttp2_hd_deflate_bound()` to know the upper\n * bound of buffer size required to deflate given header name/value\n * pairs.\n *\n * Once this function fails, subsequent call of this function always\n * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.\n *\n * After this function returns, it is safe to delete the |nva|.\n *\n * This function returns the number of bytes written to |buf| if it\n * succeeds, or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Deflation process has failed.\n * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`\n *     The provided |buflen| size is too small to hold the output.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_deflate_hd(nghttp2_hd_deflater *deflater,\n                                             uint8_t *buf, size_t buflen,\n                                             const nghttp2_nv *nva,\n                                             size_t nvlen);\n\n/**\n * @function\n *\n * Deflates the |nva|, which has the |nvlen| name/value pairs, into\n * the |veclen| size of buf vector |vec|.  The each size of buffer\n * must be set in len field of :type:`nghttp2_vec`.  If and only if\n * one chunk is filled up completely, next chunk will be used.  If\n * |vec| is not large enough to store the deflated header block, this\n * function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The caller\n * should use `nghttp2_hd_deflate_bound()` to know the upper bound of\n * buffer size required to deflate given header name/value pairs.\n *\n * Once this function fails, subsequent call of this function always\n * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.\n *\n * After this function returns, it is safe to delete the |nva|.\n *\n * This function returns the number of bytes written to |vec| if it\n * succeeds, or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Deflation process has failed.\n * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`\n *     The provided |buflen| size is too small to hold the output.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_deflate_hd_vec(nghttp2_hd_deflater *deflater,\n                                                 const nghttp2_vec *vec,\n                                                 size_t veclen,\n                                                 const nghttp2_nv *nva,\n                                                 size_t nvlen);\n\n/**\n * @function\n *\n * Returns an upper bound on the compressed size after deflation of\n * |nva| of length |nvlen|.\n */\nNGHTTP2_EXTERN size_t nghttp2_hd_deflate_bound(nghttp2_hd_deflater *deflater,\n                                               const nghttp2_nv *nva,\n                                               size_t nvlen);\n\n/**\n * @function\n *\n * Returns the number of entries that header table of |deflater|\n * contains.  This is the sum of the number of static table and\n * dynamic table, so the return value is at least 61.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_deflate_get_num_table_entries(nghttp2_hd_deflater *deflater);\n\n/**\n * @function\n *\n * Returns the table entry denoted by |idx| from header table of\n * |deflater|.  The |idx| is 1-based, and idx=1 returns first entry of\n * static table.  idx=62 returns first entry of dynamic table if it\n * exists.  Specifying idx=0 is error, and this function returns NULL.\n * If |idx| is strictly greater than the number of entries the tables\n * contain, this function returns NULL.\n */\nNGHTTP2_EXTERN\nconst nghttp2_nv *\nnghttp2_hd_deflate_get_table_entry(nghttp2_hd_deflater *deflater, size_t idx);\n\n/**\n * @function\n *\n * Returns the used dynamic table size, including the overhead 32\n * bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_deflate_get_dynamic_table_size(nghttp2_hd_deflater *deflater);\n\n/**\n * @function\n *\n * Returns the maximum dynamic table size.\n */\nNGHTTP2_EXTERN\nsize_t\nnghttp2_hd_deflate_get_max_dynamic_table_size(nghttp2_hd_deflater *deflater);\n\nstruct nghttp2_hd_inflater;\n\n/**\n * @struct\n *\n * HPACK inflater object.\n */\ntypedef struct nghttp2_hd_inflater nghttp2_hd_inflater;\n\n/**\n * @function\n *\n * Initializes |*inflater_ptr| for inflating name/values pairs.\n *\n * If this function fails, |*inflater_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_hd_inflate_new(nghttp2_hd_inflater **inflater_ptr);\n\n/**\n * @function\n *\n * Like `nghttp2_hd_inflate_new()`, but with additional custom memory\n * allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_hd_inflate_new()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n */\nNGHTTP2_EXTERN int nghttp2_hd_inflate_new2(nghttp2_hd_inflater **inflater_ptr,\n                                           nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Deallocates any resources allocated for |inflater|.\n */\nNGHTTP2_EXTERN void nghttp2_hd_inflate_del(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Changes header table size in the |inflater|.  This may trigger\n * eviction in the dynamic table.\n *\n * The |settings_max_dynamic_table_size| should be the value\n * transmitted in SETTINGS_HEADER_TABLE_SIZE.\n *\n * This function must not be called while header block is being\n * inflated.  In other words, this function must be called after\n * initialization of |inflater|, but before calling\n * `nghttp2_hd_inflate_hd2()`, or after\n * `nghttp2_hd_inflate_end_headers()`.  Otherwise,\n * `NGHTTP2_ERR_INVALID_STATE` was returned.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The function is called while header block is being inflated.\n *     Probably, application missed to call\n *     `nghttp2_hd_inflate_end_headers()`.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_inflate_change_table_size(nghttp2_hd_inflater *inflater,\n                                     size_t settings_max_dynamic_table_size);\n\n/**\n * @enum\n *\n * The flags for header inflation.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_HD_INFLATE_NONE = 0,\n  /**\n   * Indicates all headers were inflated.\n   */\n  NGHTTP2_HD_INFLATE_FINAL = 0x01,\n  /**\n   * Indicates a header was emitted.\n   */\n  NGHTTP2_HD_INFLATE_EMIT = 0x02\n} nghttp2_hd_inflate_flag;\n\n/**\n * @function\n *\n * .. warning::\n *\n *   Deprecated.  Use `nghttp2_hd_inflate_hd2()` instead.\n *\n * Inflates name/value block stored in |in| with length |inlen|.  This\n * function performs decompression.  For each successful emission of\n * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in\n * |*inflate_flags| and name/value pair is assigned to the |nv_out|\n * and the function returns.  The caller must not free the members of\n * |nv_out|.\n *\n * The |nv_out| may include pointers to the memory region in the |in|.\n * The caller must retain the |in| while the |nv_out| is used.\n *\n * The application should call this function repeatedly until the\n * ``(*inflate_flags) & NGHTTP2_HD_INFLATE_FINAL`` is nonzero and\n * return value is non-negative.  This means the all input values are\n * processed successfully.  Then the application must call\n * `nghttp2_hd_inflate_end_headers()` to prepare for the next header\n * block input.\n *\n * The caller can feed complete compressed header block.  It also can\n * feed it in several chunks.  The caller must set |in_final| to\n * nonzero if the given input is the last block of the compressed\n * header.\n *\n * This function returns the number of bytes processed if it succeeds,\n * or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Inflation process has failed.\n * :enum:`NGHTTP2_ERR_BUFFER_ERROR`\n *     The header field name or value is too large.\n *\n * Example follows::\n *\n *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,\n *                              uint8_t *in, size_t inlen, int final)\n *     {\n *         ssize_t rv;\n *\n *         for(;;) {\n *             nghttp2_nv nv;\n *             int inflate_flags = 0;\n *\n *             rv = nghttp2_hd_inflate_hd(hd_inflater, &nv, &inflate_flags,\n *                                        in, inlen, final);\n *\n *             if(rv < 0) {\n *                 fprintf(stderr, \"inflate failed with error code %zd\", rv);\n *                 return -1;\n *             }\n *\n *             in += rv;\n *             inlen -= rv;\n *\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_EMIT) {\n *                 fwrite(nv.name, nv.namelen, 1, stderr);\n *                 fprintf(stderr, \": \");\n *                 fwrite(nv.value, nv.valuelen, 1, stderr);\n *                 fprintf(stderr, \"\\n\");\n *             }\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\n *                 nghttp2_hd_inflate_end_headers(hd_inflater);\n *                 break;\n *             }\n *             if((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 &&\n *                inlen == 0) {\n *                break;\n *             }\n *         }\n *\n *         return 0;\n *     }\n *\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_inflate_hd(nghttp2_hd_inflater *inflater,\n                                             nghttp2_nv *nv_out,\n                                             int *inflate_flags, uint8_t *in,\n                                             size_t inlen, int in_final);\n\n/**\n * @function\n *\n * Inflates name/value block stored in |in| with length |inlen|.  This\n * function performs decompression.  For each successful emission of\n * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in\n * |*inflate_flags| and name/value pair is assigned to the |nv_out|\n * and the function returns.  The caller must not free the members of\n * |nv_out|.\n *\n * The |nv_out| may include pointers to the memory region in the |in|.\n * The caller must retain the |in| while the |nv_out| is used.\n *\n * The application should call this function repeatedly until the\n * ``(*inflate_flags) & NGHTTP2_HD_INFLATE_FINAL`` is nonzero and\n * return value is non-negative.  If that happens, all given input\n * data (|inlen| bytes) are processed successfully.  Then the\n * application must call `nghttp2_hd_inflate_end_headers()` to prepare\n * for the next header block input.\n *\n * In other words, if |in_final| is nonzero, and this function returns\n * |inlen|, you can assert that :enum:`NGHTTP2_HD_INFLATE_FINAL` is\n * set in |*inflate_flags|.\n *\n * The caller can feed complete compressed header block.  It also can\n * feed it in several chunks.  The caller must set |in_final| to\n * nonzero if the given input is the last block of the compressed\n * header.\n *\n * This function returns the number of bytes processed if it succeeds,\n * or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Inflation process has failed.\n * :enum:`NGHTTP2_ERR_BUFFER_ERROR`\n *     The header field name or value is too large.\n *\n * Example follows::\n *\n *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,\n *                              uint8_t *in, size_t inlen, int final)\n *     {\n *         ssize_t rv;\n *\n *         for(;;) {\n *             nghttp2_nv nv;\n *             int inflate_flags = 0;\n *\n *             rv = nghttp2_hd_inflate_hd2(hd_inflater, &nv, &inflate_flags,\n *                                         in, inlen, final);\n *\n *             if(rv < 0) {\n *                 fprintf(stderr, \"inflate failed with error code %zd\", rv);\n *                 return -1;\n *             }\n *\n *             in += rv;\n *             inlen -= rv;\n *\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_EMIT) {\n *                 fwrite(nv.name, nv.namelen, 1, stderr);\n *                 fprintf(stderr, \": \");\n *                 fwrite(nv.value, nv.valuelen, 1, stderr);\n *                 fprintf(stderr, \"\\n\");\n *             }\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\n *                 nghttp2_hd_inflate_end_headers(hd_inflater);\n *                 break;\n *             }\n *             if((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 &&\n *                inlen == 0) {\n *                break;\n *             }\n *         }\n *\n *         return 0;\n *     }\n *\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_inflate_hd2(nghttp2_hd_inflater *inflater,\n                                              nghttp2_nv *nv_out,\n                                              int *inflate_flags,\n                                              const uint8_t *in, size_t inlen,\n                                              int in_final);\n\n/**\n * @function\n *\n * Signals the end of decompression for one header block.\n *\n * This function returns 0 if it succeeds. Currently this function\n * always succeeds.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_inflate_end_headers(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Returns the number of entries that header table of |inflater|\n * contains.  This is the sum of the number of static table and\n * dynamic table, so the return value is at least 61.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_inflate_get_num_table_entries(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Returns the table entry denoted by |idx| from header table of\n * |inflater|.  The |idx| is 1-based, and idx=1 returns first entry of\n * static table.  idx=62 returns first entry of dynamic table if it\n * exists.  Specifying idx=0 is error, and this function returns NULL.\n * If |idx| is strictly greater than the number of entries the tables\n * contain, this function returns NULL.\n */\nNGHTTP2_EXTERN\nconst nghttp2_nv *\nnghttp2_hd_inflate_get_table_entry(nghttp2_hd_inflater *inflater, size_t idx);\n\n/**\n * @function\n *\n * Returns the used dynamic table size, including the overhead 32\n * bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_inflate_get_dynamic_table_size(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Returns the maximum dynamic table size.\n */\nNGHTTP2_EXTERN\nsize_t\nnghttp2_hd_inflate_get_max_dynamic_table_size(nghttp2_hd_inflater *inflater);\n\nstruct nghttp2_stream;\n\n/**\n * @struct\n *\n * The structure to represent HTTP/2 stream.  The details of this\n * structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_stream nghttp2_stream;\n\n/**\n * @function\n *\n * Returns pointer to :type:`nghttp2_stream` object denoted by\n * |stream_id|.  If stream was not found, returns NULL.\n *\n * Returns imaginary root stream (see\n * `nghttp2_session_get_root_stream()`) if 0 is given in |stream_id|.\n *\n * Unless |stream_id| == 0, the returned pointer is valid until next\n * call of `nghttp2_session_send()`, `nghttp2_session_mem_send()`,\n * `nghttp2_session_recv()`, and `nghttp2_session_mem_recv()`.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_session_find_stream(nghttp2_session *session, int32_t stream_id);\n\n/**\n * @enum\n *\n * State of stream as described in RFC 7540.\n */\ntypedef enum {\n  /**\n   * idle state.\n   */\n  NGHTTP2_STREAM_STATE_IDLE = 1,\n  /**\n   * open state.\n   */\n  NGHTTP2_STREAM_STATE_OPEN,\n  /**\n   * reserved (local) state.\n   */\n  NGHTTP2_STREAM_STATE_RESERVED_LOCAL,\n  /**\n   * reserved (remote) state.\n   */\n  NGHTTP2_STREAM_STATE_RESERVED_REMOTE,\n  /**\n   * half closed (local) state.\n   */\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL,\n  /**\n   * half closed (remote) state.\n   */\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE,\n  /**\n   * closed state.\n   */\n  NGHTTP2_STREAM_STATE_CLOSED\n} nghttp2_stream_proto_state;\n\n/**\n * @function\n *\n * Returns state of |stream|.  The root stream retrieved by\n * `nghttp2_session_get_root_stream()` will have stream state\n * :enum:`NGHTTP2_STREAM_STATE_IDLE`.\n */\nNGHTTP2_EXTERN nghttp2_stream_proto_state\nnghttp2_stream_get_state(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns root of dependency tree, which is imaginary stream with\n * stream ID 0.  The returned pointer is valid until |session| is\n * freed by `nghttp2_session_del()`.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_session_get_root_stream(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the parent stream of |stream| in dependency tree.  Returns\n * NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_parent(nghttp2_stream *stream);\n\nNGHTTP2_EXTERN int32_t nghttp2_stream_get_stream_id(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the next sibling stream of |stream| in dependency tree.\n * Returns NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_next_sibling(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the previous sibling stream of |stream| in dependency tree.\n * Returns NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_previous_sibling(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the first child stream of |stream| in dependency tree.\n * Returns NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_first_child(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns dependency weight to the parent stream of |stream|.\n */\nNGHTTP2_EXTERN int32_t nghttp2_stream_get_weight(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the sum of the weight for |stream|'s children.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_stream_get_sum_dependency_weight(nghttp2_stream *stream);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the library outputs debug logging.\n * The function is called with arguments suitable for ``vfprintf(3)``\n *\n * The debug output is only enabled if the library is built with\n * ``DEBUGBUILD`` macro defined.\n */\ntypedef void (*nghttp2_debug_vprintf_callback)(const char *format,\n                                               va_list args);\n\n/**\n * @function\n *\n * Sets a debug output callback called by the library when built with\n * ``DEBUGBUILD`` macro defined.  If this option is not used, debug\n * log is written into standard error output.\n *\n * For builds without ``DEBUGBUILD`` macro defined, this function is\n * noop.\n *\n * Note that building with ``DEBUGBUILD`` may cause significant\n * performance penalty to libnghttp2 because of extra processing.  It\n * should be used for debugging purpose only.\n *\n * .. Warning::\n *\n *   Building with ``DEBUGBUILD`` may cause significant performance\n *   penalty to libnghttp2 because of extra processing.  It should be\n *   used for debugging purpose only.  We write this two times because\n *   this is important.\n */\nNGHTTP2_EXTERN void nghttp2_set_debug_vprintf_callback(\n    nghttp2_debug_vprintf_callback debug_vprintf_callback);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NGHTTP2_H */\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_helper.h\"\n\n#include <assert.h>\n#include <string.h>\n\n#include \"nghttp2_net.h\"\n\nvoid nghttp2_put_uint16be(uint8_t *buf, uint16_t n) {\n  uint16_t x = htons(n);\n  memcpy(buf, &x, sizeof(uint16_t));\n}\n\nvoid nghttp2_put_uint32be(uint8_t *buf, uint32_t n) {\n  uint32_t x = htonl(n);\n  memcpy(buf, &x, sizeof(uint32_t));\n}\n\nuint16_t nghttp2_get_uint16(const uint8_t *data) {\n  uint16_t n;\n  memcpy(&n, data, sizeof(uint16_t));\n  return ntohs(n);\n}\n\nuint32_t nghttp2_get_uint32(const uint8_t *data) {\n  uint32_t n;\n  memcpy(&n, data, sizeof(uint32_t));\n  return ntohl(n);\n}\n\n/* Generated by gendowncasetbl.py */\nstatic const uint8_t DOWNCASE_TBL[] = {\n    0 /* NUL  */,   1 /* SOH  */,   2 /* STX  */,   3 /* ETX  */,\n    4 /* EOT  */,   5 /* ENQ  */,   6 /* ACK  */,   7 /* BEL  */,\n    8 /* BS   */,   9 /* HT   */,   10 /* LF   */,  11 /* VT   */,\n    12 /* FF   */,  13 /* CR   */,  14 /* SO   */,  15 /* SI   */,\n    16 /* DLE  */,  17 /* DC1  */,  18 /* DC2  */,  19 /* DC3  */,\n    20 /* DC4  */,  21 /* NAK  */,  22 /* SYN  */,  23 /* ETB  */,\n    24 /* CAN  */,  25 /* EM   */,  26 /* SUB  */,  27 /* ESC  */,\n    28 /* FS   */,  29 /* GS   */,  30 /* RS   */,  31 /* US   */,\n    32 /* SPC  */,  33 /* !    */,  34 /* \"    */,  35 /* #    */,\n    36 /* $    */,  37 /* %    */,  38 /* &    */,  39 /* '    */,\n    40 /* (    */,  41 /* )    */,  42 /* *    */,  43 /* +    */,\n    44 /* ,    */,  45 /* -    */,  46 /* .    */,  47 /* /    */,\n    48 /* 0    */,  49 /* 1    */,  50 /* 2    */,  51 /* 3    */,\n    52 /* 4    */,  53 /* 5    */,  54 /* 6    */,  55 /* 7    */,\n    56 /* 8    */,  57 /* 9    */,  58 /* :    */,  59 /* ;    */,\n    60 /* <    */,  61 /* =    */,  62 /* >    */,  63 /* ?    */,\n    64 /* @    */,  97 /* A    */,  98 /* B    */,  99 /* C    */,\n    100 /* D    */, 101 /* E    */, 102 /* F    */, 103 /* G    */,\n    104 /* H    */, 105 /* I    */, 106 /* J    */, 107 /* K    */,\n    108 /* L    */, 109 /* M    */, 110 /* N    */, 111 /* O    */,\n    112 /* P    */, 113 /* Q    */, 114 /* R    */, 115 /* S    */,\n    116 /* T    */, 117 /* U    */, 118 /* V    */, 119 /* W    */,\n    120 /* X    */, 121 /* Y    */, 122 /* Z    */, 91 /* [    */,\n    92 /* \\    */,  93 /* ]    */,  94 /* ^    */,  95 /* _    */,\n    96 /* `    */,  97 /* a    */,  98 /* b    */,  99 /* c    */,\n    100 /* d    */, 101 /* e    */, 102 /* f    */, 103 /* g    */,\n    104 /* h    */, 105 /* i    */, 106 /* j    */, 107 /* k    */,\n    108 /* l    */, 109 /* m    */, 110 /* n    */, 111 /* o    */,\n    112 /* p    */, 113 /* q    */, 114 /* r    */, 115 /* s    */,\n    116 /* t    */, 117 /* u    */, 118 /* v    */, 119 /* w    */,\n    120 /* x    */, 121 /* y    */, 122 /* z    */, 123 /* {    */,\n    124 /* |    */, 125 /* }    */, 126 /* ~    */, 127 /* DEL  */,\n    128 /* 0x80 */, 129 /* 0x81 */, 130 /* 0x82 */, 131 /* 0x83 */,\n    132 /* 0x84 */, 133 /* 0x85 */, 134 /* 0x86 */, 135 /* 0x87 */,\n    136 /* 0x88 */, 137 /* 0x89 */, 138 /* 0x8a */, 139 /* 0x8b */,\n    140 /* 0x8c */, 141 /* 0x8d */, 142 /* 0x8e */, 143 /* 0x8f */,\n    144 /* 0x90 */, 145 /* 0x91 */, 146 /* 0x92 */, 147 /* 0x93 */,\n    148 /* 0x94 */, 149 /* 0x95 */, 150 /* 0x96 */, 151 /* 0x97 */,\n    152 /* 0x98 */, 153 /* 0x99 */, 154 /* 0x9a */, 155 /* 0x9b */,\n    156 /* 0x9c */, 157 /* 0x9d */, 158 /* 0x9e */, 159 /* 0x9f */,\n    160 /* 0xa0 */, 161 /* 0xa1 */, 162 /* 0xa2 */, 163 /* 0xa3 */,\n    164 /* 0xa4 */, 165 /* 0xa5 */, 166 /* 0xa6 */, 167 /* 0xa7 */,\n    168 /* 0xa8 */, 169 /* 0xa9 */, 170 /* 0xaa */, 171 /* 0xab */,\n    172 /* 0xac */, 173 /* 0xad */, 174 /* 0xae */, 175 /* 0xaf */,\n    176 /* 0xb0 */, 177 /* 0xb1 */, 178 /* 0xb2 */, 179 /* 0xb3 */,\n    180 /* 0xb4 */, 181 /* 0xb5 */, 182 /* 0xb6 */, 183 /* 0xb7 */,\n    184 /* 0xb8 */, 185 /* 0xb9 */, 186 /* 0xba */, 187 /* 0xbb */,\n    188 /* 0xbc */, 189 /* 0xbd */, 190 /* 0xbe */, 191 /* 0xbf */,\n    192 /* 0xc0 */, 193 /* 0xc1 */, 194 /* 0xc2 */, 195 /* 0xc3 */,\n    196 /* 0xc4 */, 197 /* 0xc5 */, 198 /* 0xc6 */, 199 /* 0xc7 */,\n    200 /* 0xc8 */, 201 /* 0xc9 */, 202 /* 0xca */, 203 /* 0xcb */,\n    204 /* 0xcc */, 205 /* 0xcd */, 206 /* 0xce */, 207 /* 0xcf */,\n    208 /* 0xd0 */, 209 /* 0xd1 */, 210 /* 0xd2 */, 211 /* 0xd3 */,\n    212 /* 0xd4 */, 213 /* 0xd5 */, 214 /* 0xd6 */, 215 /* 0xd7 */,\n    216 /* 0xd8 */, 217 /* 0xd9 */, 218 /* 0xda */, 219 /* 0xdb */,\n    220 /* 0xdc */, 221 /* 0xdd */, 222 /* 0xde */, 223 /* 0xdf */,\n    224 /* 0xe0 */, 225 /* 0xe1 */, 226 /* 0xe2 */, 227 /* 0xe3 */,\n    228 /* 0xe4 */, 229 /* 0xe5 */, 230 /* 0xe6 */, 231 /* 0xe7 */,\n    232 /* 0xe8 */, 233 /* 0xe9 */, 234 /* 0xea */, 235 /* 0xeb */,\n    236 /* 0xec */, 237 /* 0xed */, 238 /* 0xee */, 239 /* 0xef */,\n    240 /* 0xf0 */, 241 /* 0xf1 */, 242 /* 0xf2 */, 243 /* 0xf3 */,\n    244 /* 0xf4 */, 245 /* 0xf5 */, 246 /* 0xf6 */, 247 /* 0xf7 */,\n    248 /* 0xf8 */, 249 /* 0xf9 */, 250 /* 0xfa */, 251 /* 0xfb */,\n    252 /* 0xfc */, 253 /* 0xfd */, 254 /* 0xfe */, 255 /* 0xff */,\n};\n\nvoid nghttp2_downcase(uint8_t *s, size_t len) {\n  size_t i;\n  for (i = 0; i < len; ++i) {\n    s[i] = DOWNCASE_TBL[s[i]];\n  }\n}\n\n/*\n *   local_window_size\n *   ^  *\n *   |  *    recv_window_size\n *   |  *  * ^\n *   |  *  * |\n *  0+++++++++\n *   |  *  *   \\\n *   |  *  *   | This rage is hidden in flow control.  But it must be\n *   v  *  *   / kept in order to restore it when window size is enlarged.\n *   recv_reduction\n *   (+ for negative direction)\n *\n *   recv_window_size could be negative if we decrease\n *   local_window_size more than recv_window_size:\n *\n *   local_window_size\n *   ^  *\n *   |  *\n *   |  *\n *   0++++++++\n *   |  *    ^ recv_window_size (negative)\n *   |  *    |\n *   v  *  *\n *   recv_reduction\n */\nint nghttp2_adjust_local_window_size(int32_t *local_window_size_ptr,\n                                     int32_t *recv_window_size_ptr,\n                                     int32_t *recv_reduction_ptr,\n                                     int32_t *delta_ptr) {\n  if (*delta_ptr > 0) {\n    int32_t recv_reduction_delta;\n    int32_t delta;\n    int32_t new_recv_window_size =\n        nghttp2_max(0, *recv_window_size_ptr) - *delta_ptr;\n\n    if (new_recv_window_size >= 0) {\n      *recv_window_size_ptr = new_recv_window_size;\n      return 0;\n    }\n\n    delta = -new_recv_window_size;\n\n    /* The delta size is strictly more than received bytes. Increase\n       local_window_size by that difference |delta|. */\n    if (*local_window_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - delta) {\n      return NGHTTP2_ERR_FLOW_CONTROL;\n    }\n    *local_window_size_ptr += delta;\n    /* If there is recv_reduction due to earlier window_size\n       reduction, we have to adjust it too. */\n    recv_reduction_delta = nghttp2_min(*recv_reduction_ptr, delta);\n    *recv_reduction_ptr -= recv_reduction_delta;\n    if (*recv_window_size_ptr < 0) {\n      *recv_window_size_ptr += recv_reduction_delta;\n    } else {\n      /* If *recv_window_size_ptr > 0, then those bytes are going to\n         be returned to the remote peer (by WINDOW_UPDATE with the\n         adjusted *delta_ptr), so it is effectively 0 now.  We set to\n         *recv_reduction_delta, because caller does not take into\n         account it in *delta_ptr. */\n      *recv_window_size_ptr = recv_reduction_delta;\n    }\n    /* recv_reduction_delta must be paid from *delta_ptr, since it was\n       added in window size reduction (see below). */\n    *delta_ptr -= recv_reduction_delta;\n\n    return 0;\n  }\n\n  if (*local_window_size_ptr + *delta_ptr < 0 ||\n      *recv_window_size_ptr < INT32_MIN - *delta_ptr ||\n      *recv_reduction_ptr > INT32_MAX + *delta_ptr) {\n    return NGHTTP2_ERR_FLOW_CONTROL;\n  }\n  /* Decreasing local window size. Note that we achieve this without\n     noticing to the remote peer. To do this, we cut\n     recv_window_size by -delta. This means that we don't send\n     WINDOW_UPDATE for -delta bytes. */\n  *local_window_size_ptr += *delta_ptr;\n  *recv_window_size_ptr += *delta_ptr;\n  *recv_reduction_ptr -= *delta_ptr;\n  *delta_ptr = 0;\n\n  return 0;\n}\n\nint nghttp2_increase_local_window_size(int32_t *local_window_size_ptr,\n                                       int32_t *recv_window_size_ptr,\n                                       int32_t *recv_reduction_ptr,\n                                       int32_t *delta_ptr) {\n  int32_t recv_reduction_delta;\n  int32_t delta;\n\n  delta = *delta_ptr;\n\n  assert(delta >= 0);\n\n  /* The delta size is strictly more than received bytes. Increase\n     local_window_size by that difference |delta|. */\n  if (*local_window_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - delta) {\n    return NGHTTP2_ERR_FLOW_CONTROL;\n  }\n\n  *local_window_size_ptr += delta;\n  /* If there is recv_reduction due to earlier window_size\n     reduction, we have to adjust it too. */\n  recv_reduction_delta = nghttp2_min(*recv_reduction_ptr, delta);\n  *recv_reduction_ptr -= recv_reduction_delta;\n\n  *recv_window_size_ptr += recv_reduction_delta;\n\n  /* recv_reduction_delta must be paid from *delta_ptr, since it was\n     added in window size reduction (see below). */\n  *delta_ptr -= recv_reduction_delta;\n\n  return 0;\n}\n\nint nghttp2_should_send_window_update(int32_t local_window_size,\n                                      int32_t recv_window_size) {\n  return recv_window_size > 0 && recv_window_size >= local_window_size / 2;\n}\n\nconst char *nghttp2_strerror(int error_code) {\n  switch (error_code) {\n  case 0:\n    return \"Success\";\n  case NGHTTP2_ERR_INVALID_ARGUMENT:\n    return \"Invalid argument\";\n  case NGHTTP2_ERR_BUFFER_ERROR:\n    return \"Out of buffer space\";\n  case NGHTTP2_ERR_UNSUPPORTED_VERSION:\n    return \"Unsupported SPDY version\";\n  case NGHTTP2_ERR_WOULDBLOCK:\n    return \"Operation would block\";\n  case NGHTTP2_ERR_PROTO:\n    return \"Protocol error\";\n  case NGHTTP2_ERR_INVALID_FRAME:\n    return \"Invalid frame octets\";\n  case NGHTTP2_ERR_EOF:\n    return \"EOF\";\n  case NGHTTP2_ERR_DEFERRED:\n    return \"Data transfer deferred\";\n  case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n    return \"No more Stream ID available\";\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return \"Stream was already closed or invalid\";\n  case NGHTTP2_ERR_STREAM_CLOSING:\n    return \"Stream is closing\";\n  case NGHTTP2_ERR_STREAM_SHUT_WR:\n    return \"The transmission is not allowed for this stream\";\n  case NGHTTP2_ERR_INVALID_STREAM_ID:\n    return \"Stream ID is invalid\";\n  case NGHTTP2_ERR_INVALID_STREAM_STATE:\n    return \"Invalid stream state\";\n  case NGHTTP2_ERR_DEFERRED_DATA_EXIST:\n    return \"Another DATA frame has already been deferred\";\n  case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED:\n    return \"request HEADERS is not allowed\";\n  case NGHTTP2_ERR_GOAWAY_ALREADY_SENT:\n    return \"GOAWAY has already been sent\";\n  case NGHTTP2_ERR_INVALID_HEADER_BLOCK:\n    return \"Invalid header block\";\n  case NGHTTP2_ERR_INVALID_STATE:\n    return \"Invalid state\";\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return \"The user callback function failed due to the temporal error\";\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return \"The length of the frame is invalid\";\n  case NGHTTP2_ERR_HEADER_COMP:\n    return \"Header compression/decompression error\";\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return \"Flow control error\";\n  case NGHTTP2_ERR_INSUFF_BUFSIZE:\n    return \"Insufficient buffer size given to function\";\n  case NGHTTP2_ERR_PAUSE:\n    return \"Callback was paused by the application\";\n  case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS:\n    return \"Too many inflight SETTINGS\";\n  case NGHTTP2_ERR_PUSH_DISABLED:\n    return \"Server push is disabled by peer\";\n  case NGHTTP2_ERR_DATA_EXIST:\n    return \"DATA or HEADERS frame has already been submitted for the stream\";\n  case NGHTTP2_ERR_SESSION_CLOSING:\n    return \"The current session is closing\";\n  case NGHTTP2_ERR_HTTP_HEADER:\n    return \"Invalid HTTP header field was received\";\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return \"Violation in HTTP messaging rule\";\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return \"Stream was refused\";\n  case NGHTTP2_ERR_INTERNAL:\n    return \"Internal error\";\n  case NGHTTP2_ERR_CANCEL:\n    return \"Cancel\";\n  case NGHTTP2_ERR_SETTINGS_EXPECTED:\n    return \"When a local endpoint expects to receive SETTINGS frame, it \"\n           \"receives an other type of frame\";\n  case NGHTTP2_ERR_NOMEM:\n    return \"Out of memory\";\n  case NGHTTP2_ERR_CALLBACK_FAILURE:\n    return \"The user callback function failed\";\n  case NGHTTP2_ERR_BAD_CLIENT_MAGIC:\n    return \"Received bad client magic byte string\";\n  case NGHTTP2_ERR_FLOODED:\n    return \"Flooding was detected in this HTTP/2 session, and it must be \"\n           \"closed\";\n  default:\n    return \"Unknown error code\";\n  }\n}\n\n/* Generated by gennmchartbl.py */\nstatic const int VALID_HD_NAME_CHARS[] = {\n    0 /* NUL  */, 0 /* SOH  */, 0 /* STX  */, 0 /* ETX  */,\n    0 /* EOT  */, 0 /* ENQ  */, 0 /* ACK  */, 0 /* BEL  */,\n    0 /* BS   */, 0 /* HT   */, 0 /* LF   */, 0 /* VT   */,\n    0 /* FF   */, 0 /* CR   */, 0 /* SO   */, 0 /* SI   */,\n    0 /* DLE  */, 0 /* DC1  */, 0 /* DC2  */, 0 /* DC3  */,\n    0 /* DC4  */, 0 /* NAK  */, 0 /* SYN  */, 0 /* ETB  */,\n    0 /* CAN  */, 0 /* EM   */, 0 /* SUB  */, 0 /* ESC  */,\n    0 /* FS   */, 0 /* GS   */, 0 /* RS   */, 0 /* US   */,\n    0 /* SPC  */, 1 /* !    */, 0 /* \"    */, 1 /* #    */,\n    1 /* $    */, 1 /* %    */, 1 /* &    */, 1 /* '    */,\n    0 /* (    */, 0 /* )    */, 1 /* *    */, 1 /* +    */,\n    0 /* ,    */, 1 /* -    */, 1 /* .    */, 0 /* /    */,\n    1 /* 0    */, 1 /* 1    */, 1 /* 2    */, 1 /* 3    */,\n    1 /* 4    */, 1 /* 5    */, 1 /* 6    */, 1 /* 7    */,\n    1 /* 8    */, 1 /* 9    */, 0 /* :    */, 0 /* ;    */,\n    0 /* <    */, 0 /* =    */, 0 /* >    */, 0 /* ?    */,\n    0 /* @    */, 0 /* A    */, 0 /* B    */, 0 /* C    */,\n    0 /* D    */, 0 /* E    */, 0 /* F    */, 0 /* G    */,\n    0 /* H    */, 0 /* I    */, 0 /* J    */, 0 /* K    */,\n    0 /* L    */, 0 /* M    */, 0 /* N    */, 0 /* O    */,\n    0 /* P    */, 0 /* Q    */, 0 /* R    */, 0 /* S    */,\n    0 /* T    */, 0 /* U    */, 0 /* V    */, 0 /* W    */,\n    0 /* X    */, 0 /* Y    */, 0 /* Z    */, 0 /* [    */,\n    0 /* \\    */, 0 /* ]    */, 1 /* ^    */, 1 /* _    */,\n    1 /* `    */, 1 /* a    */, 1 /* b    */, 1 /* c    */,\n    1 /* d    */, 1 /* e    */, 1 /* f    */, 1 /* g    */,\n    1 /* h    */, 1 /* i    */, 1 /* j    */, 1 /* k    */,\n    1 /* l    */, 1 /* m    */, 1 /* n    */, 1 /* o    */,\n    1 /* p    */, 1 /* q    */, 1 /* r    */, 1 /* s    */,\n    1 /* t    */, 1 /* u    */, 1 /* v    */, 1 /* w    */,\n    1 /* x    */, 1 /* y    */, 1 /* z    */, 0 /* {    */,\n    1 /* |    */, 0 /* }    */, 1 /* ~    */, 0 /* DEL  */,\n    0 /* 0x80 */, 0 /* 0x81 */, 0 /* 0x82 */, 0 /* 0x83 */,\n    0 /* 0x84 */, 0 /* 0x85 */, 0 /* 0x86 */, 0 /* 0x87 */,\n    0 /* 0x88 */, 0 /* 0x89 */, 0 /* 0x8a */, 0 /* 0x8b */,\n    0 /* 0x8c */, 0 /* 0x8d */, 0 /* 0x8e */, 0 /* 0x8f */,\n    0 /* 0x90 */, 0 /* 0x91 */, 0 /* 0x92 */, 0 /* 0x93 */,\n    0 /* 0x94 */, 0 /* 0x95 */, 0 /* 0x96 */, 0 /* 0x97 */,\n    0 /* 0x98 */, 0 /* 0x99 */, 0 /* 0x9a */, 0 /* 0x9b */,\n    0 /* 0x9c */, 0 /* 0x9d */, 0 /* 0x9e */, 0 /* 0x9f */,\n    0 /* 0xa0 */, 0 /* 0xa1 */, 0 /* 0xa2 */, 0 /* 0xa3 */,\n    0 /* 0xa4 */, 0 /* 0xa5 */, 0 /* 0xa6 */, 0 /* 0xa7 */,\n    0 /* 0xa8 */, 0 /* 0xa9 */, 0 /* 0xaa */, 0 /* 0xab */,\n    0 /* 0xac */, 0 /* 0xad */, 0 /* 0xae */, 0 /* 0xaf */,\n    0 /* 0xb0 */, 0 /* 0xb1 */, 0 /* 0xb2 */, 0 /* 0xb3 */,\n    0 /* 0xb4 */, 0 /* 0xb5 */, 0 /* 0xb6 */, 0 /* 0xb7 */,\n    0 /* 0xb8 */, 0 /* 0xb9 */, 0 /* 0xba */, 0 /* 0xbb */,\n    0 /* 0xbc */, 0 /* 0xbd */, 0 /* 0xbe */, 0 /* 0xbf */,\n    0 /* 0xc0 */, 0 /* 0xc1 */, 0 /* 0xc2 */, 0 /* 0xc3 */,\n    0 /* 0xc4 */, 0 /* 0xc5 */, 0 /* 0xc6 */, 0 /* 0xc7 */,\n    0 /* 0xc8 */, 0 /* 0xc9 */, 0 /* 0xca */, 0 /* 0xcb */,\n    0 /* 0xcc */, 0 /* 0xcd */, 0 /* 0xce */, 0 /* 0xcf */,\n    0 /* 0xd0 */, 0 /* 0xd1 */, 0 /* 0xd2 */, 0 /* 0xd3 */,\n    0 /* 0xd4 */, 0 /* 0xd5 */, 0 /* 0xd6 */, 0 /* 0xd7 */,\n    0 /* 0xd8 */, 0 /* 0xd9 */, 0 /* 0xda */, 0 /* 0xdb */,\n    0 /* 0xdc */, 0 /* 0xdd */, 0 /* 0xde */, 0 /* 0xdf */,\n    0 /* 0xe0 */, 0 /* 0xe1 */, 0 /* 0xe2 */, 0 /* 0xe3 */,\n    0 /* 0xe4 */, 0 /* 0xe5 */, 0 /* 0xe6 */, 0 /* 0xe7 */,\n    0 /* 0xe8 */, 0 /* 0xe9 */, 0 /* 0xea */, 0 /* 0xeb */,\n    0 /* 0xec */, 0 /* 0xed */, 0 /* 0xee */, 0 /* 0xef */,\n    0 /* 0xf0 */, 0 /* 0xf1 */, 0 /* 0xf2 */, 0 /* 0xf3 */,\n    0 /* 0xf4 */, 0 /* 0xf5 */, 0 /* 0xf6 */, 0 /* 0xf7 */,\n    0 /* 0xf8 */, 0 /* 0xf9 */, 0 /* 0xfa */, 0 /* 0xfb */,\n    0 /* 0xfc */, 0 /* 0xfd */, 0 /* 0xfe */, 0 /* 0xff */\n};\n\nint nghttp2_check_header_name(const uint8_t *name, size_t len) {\n  const uint8_t *last;\n  if (len == 0) {\n    return 0;\n  }\n  if (*name == ':') {\n    if (len == 1) {\n      return 0;\n    }\n    ++name;\n    --len;\n  }\n  for (last = name + len; name != last; ++name) {\n    if (!VALID_HD_NAME_CHARS[*name]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n/* Generated by genvchartbl.py */\nstatic const int VALID_HD_VALUE_CHARS[] = {\n    0 /* NUL  */, 0 /* SOH  */, 0 /* STX  */, 0 /* ETX  */,\n    0 /* EOT  */, 0 /* ENQ  */, 0 /* ACK  */, 0 /* BEL  */,\n    0 /* BS   */, 1 /* HT   */, 0 /* LF   */, 0 /* VT   */,\n    0 /* FF   */, 0 /* CR   */, 0 /* SO   */, 0 /* SI   */,\n    0 /* DLE  */, 0 /* DC1  */, 0 /* DC2  */, 0 /* DC3  */,\n    0 /* DC4  */, 0 /* NAK  */, 0 /* SYN  */, 0 /* ETB  */,\n    0 /* CAN  */, 0 /* EM   */, 0 /* SUB  */, 0 /* ESC  */,\n    0 /* FS   */, 0 /* GS   */, 0 /* RS   */, 0 /* US   */,\n    1 /* SPC  */, 1 /* !    */, 1 /* \"    */, 1 /* #    */,\n    1 /* $    */, 1 /* %    */, 1 /* &    */, 1 /* '    */,\n    1 /* (    */, 1 /* )    */, 1 /* *    */, 1 /* +    */,\n    1 /* ,    */, 1 /* -    */, 1 /* .    */, 1 /* /    */,\n    1 /* 0    */, 1 /* 1    */, 1 /* 2    */, 1 /* 3    */,\n    1 /* 4    */, 1 /* 5    */, 1 /* 6    */, 1 /* 7    */,\n    1 /* 8    */, 1 /* 9    */, 1 /* :    */, 1 /* ;    */,\n    1 /* <    */, 1 /* =    */, 1 /* >    */, 1 /* ?    */,\n    1 /* @    */, 1 /* A    */, 1 /* B    */, 1 /* C    */,\n    1 /* D    */, 1 /* E    */, 1 /* F    */, 1 /* G    */,\n    1 /* H    */, 1 /* I    */, 1 /* J    */, 1 /* K    */,\n    1 /* L    */, 1 /* M    */, 1 /* N    */, 1 /* O    */,\n    1 /* P    */, 1 /* Q    */, 1 /* R    */, 1 /* S    */,\n    1 /* T    */, 1 /* U    */, 1 /* V    */, 1 /* W    */,\n    1 /* X    */, 1 /* Y    */, 1 /* Z    */, 1 /* [    */,\n    1 /* \\    */, 1 /* ]    */, 1 /* ^    */, 1 /* _    */,\n    1 /* `    */, 1 /* a    */, 1 /* b    */, 1 /* c    */,\n    1 /* d    */, 1 /* e    */, 1 /* f    */, 1 /* g    */,\n    1 /* h    */, 1 /* i    */, 1 /* j    */, 1 /* k    */,\n    1 /* l    */, 1 /* m    */, 1 /* n    */, 1 /* o    */,\n    1 /* p    */, 1 /* q    */, 1 /* r    */, 1 /* s    */,\n    1 /* t    */, 1 /* u    */, 1 /* v    */, 1 /* w    */,\n    1 /* x    */, 1 /* y    */, 1 /* z    */, 1 /* {    */,\n    1 /* |    */, 1 /* }    */, 1 /* ~    */, 0 /* DEL  */,\n    1 /* 0x80 */, 1 /* 0x81 */, 1 /* 0x82 */, 1 /* 0x83 */,\n    1 /* 0x84 */, 1 /* 0x85 */, 1 /* 0x86 */, 1 /* 0x87 */,\n    1 /* 0x88 */, 1 /* 0x89 */, 1 /* 0x8a */, 1 /* 0x8b */,\n    1 /* 0x8c */, 1 /* 0x8d */, 1 /* 0x8e */, 1 /* 0x8f */,\n    1 /* 0x90 */, 1 /* 0x91 */, 1 /* 0x92 */, 1 /* 0x93 */,\n    1 /* 0x94 */, 1 /* 0x95 */, 1 /* 0x96 */, 1 /* 0x97 */,\n    1 /* 0x98 */, 1 /* 0x99 */, 1 /* 0x9a */, 1 /* 0x9b */,\n    1 /* 0x9c */, 1 /* 0x9d */, 1 /* 0x9e */, 1 /* 0x9f */,\n    1 /* 0xa0 */, 1 /* 0xa1 */, 1 /* 0xa2 */, 1 /* 0xa3 */,\n    1 /* 0xa4 */, 1 /* 0xa5 */, 1 /* 0xa6 */, 1 /* 0xa7 */,\n    1 /* 0xa8 */, 1 /* 0xa9 */, 1 /* 0xaa */, 1 /* 0xab */,\n    1 /* 0xac */, 1 /* 0xad */, 1 /* 0xae */, 1 /* 0xaf */,\n    1 /* 0xb0 */, 1 /* 0xb1 */, 1 /* 0xb2 */, 1 /* 0xb3 */,\n    1 /* 0xb4 */, 1 /* 0xb5 */, 1 /* 0xb6 */, 1 /* 0xb7 */,\n    1 /* 0xb8 */, 1 /* 0xb9 */, 1 /* 0xba */, 1 /* 0xbb */,\n    1 /* 0xbc */, 1 /* 0xbd */, 1 /* 0xbe */, 1 /* 0xbf */,\n    1 /* 0xc0 */, 1 /* 0xc1 */, 1 /* 0xc2 */, 1 /* 0xc3 */,\n    1 /* 0xc4 */, 1 /* 0xc5 */, 1 /* 0xc6 */, 1 /* 0xc7 */,\n    1 /* 0xc8 */, 1 /* 0xc9 */, 1 /* 0xca */, 1 /* 0xcb */,\n    1 /* 0xcc */, 1 /* 0xcd */, 1 /* 0xce */, 1 /* 0xcf */,\n    1 /* 0xd0 */, 1 /* 0xd1 */, 1 /* 0xd2 */, 1 /* 0xd3 */,\n    1 /* 0xd4 */, 1 /* 0xd5 */, 1 /* 0xd6 */, 1 /* 0xd7 */,\n    1 /* 0xd8 */, 1 /* 0xd9 */, 1 /* 0xda */, 1 /* 0xdb */,\n    1 /* 0xdc */, 1 /* 0xdd */, 1 /* 0xde */, 1 /* 0xdf */,\n    1 /* 0xe0 */, 1 /* 0xe1 */, 1 /* 0xe2 */, 1 /* 0xe3 */,\n    1 /* 0xe4 */, 1 /* 0xe5 */, 1 /* 0xe6 */, 1 /* 0xe7 */,\n    1 /* 0xe8 */, 1 /* 0xe9 */, 1 /* 0xea */, 1 /* 0xeb */,\n    1 /* 0xec */, 1 /* 0xed */, 1 /* 0xee */, 1 /* 0xef */,\n    1 /* 0xf0 */, 1 /* 0xf1 */, 1 /* 0xf2 */, 1 /* 0xf3 */,\n    1 /* 0xf4 */, 1 /* 0xf5 */, 1 /* 0xf6 */, 1 /* 0xf7 */,\n    1 /* 0xf8 */, 1 /* 0xf9 */, 1 /* 0xfa */, 1 /* 0xfb */,\n    1 /* 0xfc */, 1 /* 0xfd */, 1 /* 0xfe */, 1 /* 0xff */\n};\n\nint nghttp2_check_header_value(const uint8_t *value, size_t len) {\n  const uint8_t *last;\n  for (last = value + len; value != last; ++value) {\n    if (!VALID_HD_VALUE_CHARS[*value]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n/* Generated by genauthroitychartbl.py */\nstatic char VALID_AUTHORITY_CHARS[] = {\n    0 /* NUL  */, 0 /* SOH  */, 0 /* STX  */, 0 /* ETX  */,\n    0 /* EOT  */, 0 /* ENQ  */, 0 /* ACK  */, 0 /* BEL  */,\n    0 /* BS   */, 0 /* HT   */, 0 /* LF   */, 0 /* VT   */,\n    0 /* FF   */, 0 /* CR   */, 0 /* SO   */, 0 /* SI   */,\n    0 /* DLE  */, 0 /* DC1  */, 0 /* DC2  */, 0 /* DC3  */,\n    0 /* DC4  */, 0 /* NAK  */, 0 /* SYN  */, 0 /* ETB  */,\n    0 /* CAN  */, 0 /* EM   */, 0 /* SUB  */, 0 /* ESC  */,\n    0 /* FS   */, 0 /* GS   */, 0 /* RS   */, 0 /* US   */,\n    0 /* SPC  */, 1 /* !    */, 0 /* \"    */, 0 /* #    */,\n    1 /* $    */, 1 /* %    */, 1 /* &    */, 1 /* '    */,\n    1 /* (    */, 1 /* )    */, 1 /* *    */, 1 /* +    */,\n    1 /* ,    */, 1 /* -    */, 1 /* .    */, 0 /* /    */,\n    1 /* 0    */, 1 /* 1    */, 1 /* 2    */, 1 /* 3    */,\n    1 /* 4    */, 1 /* 5    */, 1 /* 6    */, 1 /* 7    */,\n    1 /* 8    */, 1 /* 9    */, 1 /* :    */, 1 /* ;    */,\n    0 /* <    */, 1 /* =    */, 0 /* >    */, 0 /* ?    */,\n    1 /* @    */, 1 /* A    */, 1 /* B    */, 1 /* C    */,\n    1 /* D    */, 1 /* E    */, 1 /* F    */, 1 /* G    */,\n    1 /* H    */, 1 /* I    */, 1 /* J    */, 1 /* K    */,\n    1 /* L    */, 1 /* M    */, 1 /* N    */, 1 /* O    */,\n    1 /* P    */, 1 /* Q    */, 1 /* R    */, 1 /* S    */,\n    1 /* T    */, 1 /* U    */, 1 /* V    */, 1 /* W    */,\n    1 /* X    */, 1 /* Y    */, 1 /* Z    */, 1 /* [    */,\n    0 /* \\    */, 1 /* ]    */, 0 /* ^    */, 1 /* _    */,\n    0 /* `    */, 1 /* a    */, 1 /* b    */, 1 /* c    */,\n    1 /* d    */, 1 /* e    */, 1 /* f    */, 1 /* g    */,\n    1 /* h    */, 1 /* i    */, 1 /* j    */, 1 /* k    */,\n    1 /* l    */, 1 /* m    */, 1 /* n    */, 1 /* o    */,\n    1 /* p    */, 1 /* q    */, 1 /* r    */, 1 /* s    */,\n    1 /* t    */, 1 /* u    */, 1 /* v    */, 1 /* w    */,\n    1 /* x    */, 1 /* y    */, 1 /* z    */, 0 /* {    */,\n    0 /* |    */, 0 /* }    */, 1 /* ~    */, 0 /* DEL  */,\n    0 /* 0x80 */, 0 /* 0x81 */, 0 /* 0x82 */, 0 /* 0x83 */,\n    0 /* 0x84 */, 0 /* 0x85 */, 0 /* 0x86 */, 0 /* 0x87 */,\n    0 /* 0x88 */, 0 /* 0x89 */, 0 /* 0x8a */, 0 /* 0x8b */,\n    0 /* 0x8c */, 0 /* 0x8d */, 0 /* 0x8e */, 0 /* 0x8f */,\n    0 /* 0x90 */, 0 /* 0x91 */, 0 /* 0x92 */, 0 /* 0x93 */,\n    0 /* 0x94 */, 0 /* 0x95 */, 0 /* 0x96 */, 0 /* 0x97 */,\n    0 /* 0x98 */, 0 /* 0x99 */, 0 /* 0x9a */, 0 /* 0x9b */,\n    0 /* 0x9c */, 0 /* 0x9d */, 0 /* 0x9e */, 0 /* 0x9f */,\n    0 /* 0xa0 */, 0 /* 0xa1 */, 0 /* 0xa2 */, 0 /* 0xa3 */,\n    0 /* 0xa4 */, 0 /* 0xa5 */, 0 /* 0xa6 */, 0 /* 0xa7 */,\n    0 /* 0xa8 */, 0 /* 0xa9 */, 0 /* 0xaa */, 0 /* 0xab */,\n    0 /* 0xac */, 0 /* 0xad */, 0 /* 0xae */, 0 /* 0xaf */,\n    0 /* 0xb0 */, 0 /* 0xb1 */, 0 /* 0xb2 */, 0 /* 0xb3 */,\n    0 /* 0xb4 */, 0 /* 0xb5 */, 0 /* 0xb6 */, 0 /* 0xb7 */,\n    0 /* 0xb8 */, 0 /* 0xb9 */, 0 /* 0xba */, 0 /* 0xbb */,\n    0 /* 0xbc */, 0 /* 0xbd */, 0 /* 0xbe */, 0 /* 0xbf */,\n    0 /* 0xc0 */, 0 /* 0xc1 */, 0 /* 0xc2 */, 0 /* 0xc3 */,\n    0 /* 0xc4 */, 0 /* 0xc5 */, 0 /* 0xc6 */, 0 /* 0xc7 */,\n    0 /* 0xc8 */, 0 /* 0xc9 */, 0 /* 0xca */, 0 /* 0xcb */,\n    0 /* 0xcc */, 0 /* 0xcd */, 0 /* 0xce */, 0 /* 0xcf */,\n    0 /* 0xd0 */, 0 /* 0xd1 */, 0 /* 0xd2 */, 0 /* 0xd3 */,\n    0 /* 0xd4 */, 0 /* 0xd5 */, 0 /* 0xd6 */, 0 /* 0xd7 */,\n    0 /* 0xd8 */, 0 /* 0xd9 */, 0 /* 0xda */, 0 /* 0xdb */,\n    0 /* 0xdc */, 0 /* 0xdd */, 0 /* 0xde */, 0 /* 0xdf */,\n    0 /* 0xe0 */, 0 /* 0xe1 */, 0 /* 0xe2 */, 0 /* 0xe3 */,\n    0 /* 0xe4 */, 0 /* 0xe5 */, 0 /* 0xe6 */, 0 /* 0xe7 */,\n    0 /* 0xe8 */, 0 /* 0xe9 */, 0 /* 0xea */, 0 /* 0xeb */,\n    0 /* 0xec */, 0 /* 0xed */, 0 /* 0xee */, 0 /* 0xef */,\n    0 /* 0xf0 */, 0 /* 0xf1 */, 0 /* 0xf2 */, 0 /* 0xf3 */,\n    0 /* 0xf4 */, 0 /* 0xf5 */, 0 /* 0xf6 */, 0 /* 0xf7 */,\n    0 /* 0xf8 */, 0 /* 0xf9 */, 0 /* 0xfa */, 0 /* 0xfb */,\n    0 /* 0xfc */, 0 /* 0xfd */, 0 /* 0xfe */, 0 /* 0xff */\n};\n\nint nghttp2_check_authority(const uint8_t *value, size_t len) {\n  const uint8_t *last;\n  for (last = value + len; value != last; ++value) {\n    if (!VALID_AUTHORITY_CHARS[*value]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nuint8_t *nghttp2_cpymem(uint8_t *dest, const void *src, size_t len) {\n  if (len == 0) {\n    return dest;\n  }\n\n  memcpy(dest, src, len);\n\n  return dest + len;\n}\n\nconst char *nghttp2_http2_strerror(uint32_t error_code) {\n  switch (error_code) {\n  case NGHTTP2_NO_ERROR:\n    return \"NO_ERROR\";\n  case NGHTTP2_PROTOCOL_ERROR:\n    return \"PROTOCOL_ERROR\";\n  case NGHTTP2_INTERNAL_ERROR:\n    return \"INTERNAL_ERROR\";\n  case NGHTTP2_FLOW_CONTROL_ERROR:\n    return \"FLOW_CONTROL_ERROR\";\n  case NGHTTP2_SETTINGS_TIMEOUT:\n    return \"SETTINGS_TIMEOUT\";\n  case NGHTTP2_STREAM_CLOSED:\n    return \"STREAM_CLOSED\";\n  case NGHTTP2_FRAME_SIZE_ERROR:\n    return \"FRAME_SIZE_ERROR\";\n  case NGHTTP2_REFUSED_STREAM:\n    return \"REFUSED_STREAM\";\n  case NGHTTP2_CANCEL:\n    return \"CANCEL\";\n  case NGHTTP2_COMPRESSION_ERROR:\n    return \"COMPRESSION_ERROR\";\n  case NGHTTP2_CONNECT_ERROR:\n    return \"CONNECT_ERROR\";\n  case NGHTTP2_ENHANCE_YOUR_CALM:\n    return \"ENHANCE_YOUR_CALM\";\n  case NGHTTP2_INADEQUATE_SECURITY:\n    return \"INADEQUATE_SECURITY\";\n  case NGHTTP2_HTTP_1_1_REQUIRED:\n    return \"HTTP_1_1_REQUIRED\";\n  default:\n    return \"unknown\";\n  }\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2014 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_option.h\"\n\n#include \"nghttp2_session.h\"\n\nint nghttp2_option_new(nghttp2_option **option_ptr) {\n  *option_ptr = calloc(1, sizeof(nghttp2_option));\n\n  if (*option_ptr == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  return 0;\n}\n\nvoid nghttp2_option_del(nghttp2_option *option) { free(option); }\n\nvoid nghttp2_option_set_no_auto_window_update(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE;\n  option->no_auto_window_update = val;\n}\n\nvoid nghttp2_option_set_peer_max_concurrent_streams(nghttp2_option *option,\n                                                    uint32_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS;\n  option->peer_max_concurrent_streams = val;\n}\n\nvoid nghttp2_option_set_no_recv_client_magic(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC;\n  option->no_recv_client_magic = val;\n}\n\nvoid nghttp2_option_set_no_http_messaging(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_HTTP_MESSAGING;\n  option->no_http_messaging = val;\n}\n\nvoid nghttp2_option_set_max_reserved_remote_streams(nghttp2_option *option,\n                                                    uint32_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS;\n  option->max_reserved_remote_streams = val;\n}\n\nstatic void set_ext_type(uint8_t *ext_types, uint8_t type) {\n  ext_types[type / 8] = (uint8_t)(ext_types[type / 8] | (1 << (type & 0x7)));\n}\n\nvoid nghttp2_option_set_user_recv_extension_type(nghttp2_option *option,\n                                                 uint8_t type) {\n  if (type < 10) {\n    return;\n  }\n\n  option->opt_set_mask |= NGHTTP2_OPT_USER_RECV_EXT_TYPES;\n  set_ext_type(option->user_recv_ext_types, type);\n}\n\nvoid nghttp2_option_set_builtin_recv_extension_type(nghttp2_option *option,\n                                                    uint8_t type) {\n  switch (type) {\n  case NGHTTP2_ALTSVC:\n    option->opt_set_mask |= NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES;\n    option->builtin_recv_ext_types |= NGHTTP2_TYPEMASK_ALTSVC;\n    return;\n  case NGHTTP2_ORIGIN:\n    option->opt_set_mask |= NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES;\n    option->builtin_recv_ext_types |= NGHTTP2_TYPEMASK_ORIGIN;\n    return;\n  default:\n    return;\n  }\n}\n\nvoid nghttp2_option_set_no_auto_ping_ack(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_AUTO_PING_ACK;\n  option->no_auto_ping_ack = val;\n}\n\nvoid nghttp2_option_set_max_send_header_block_length(nghttp2_option *option,\n                                                     size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH;\n  option->max_send_header_block_length = val;\n}\n\nvoid nghttp2_option_set_max_deflate_dynamic_table_size(nghttp2_option *option,\n                                                       size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE;\n  option->max_deflate_dynamic_table_size = val;\n}\n\nvoid nghttp2_option_set_no_closed_streams(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_CLOSED_STREAMS;\n  option->no_closed_streams = val;\n}\n\nvoid nghttp2_option_set_max_outbound_ack(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_OUTBOUND_ACK;\n  option->max_outbound_ack = val;\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2014 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_OPTION_H\n#define NGHTTP2_OPTION_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <nghttp2/nghttp2.h>\n\n/**\n * Configuration options\n */\ntypedef enum {\n  /**\n   * This option prevents the library from sending WINDOW_UPDATE for a\n   * connection automatically.  If this option is set to nonzero, the\n   * library won't send WINDOW_UPDATE for DATA until application calls\n   * nghttp2_session_consume() to indicate the amount of consumed\n   * DATA.  By default, this option is set to zero.\n   */\n  NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE = 1,\n  /**\n   * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of\n   * remote endpoint as if it is received in SETTINGS frame. Without\n   * specifying this option, before the local endpoint receives\n   * SETTINGS_MAX_CONCURRENT_STREAMS in SETTINGS frame from remote\n   * endpoint, SETTINGS_MAX_CONCURRENT_STREAMS is unlimited. This may\n   * cause problem if local endpoint submits lots of requests\n   * initially and sending them at once to the remote peer may lead to\n   * the rejection of some requests. Specifying this option to the\n   * sensible value, say 100, may avoid this kind of issue. This value\n   * will be overwritten if the local endpoint receives\n   * SETTINGS_MAX_CONCURRENT_STREAMS from the remote endpoint.\n   */\n  NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS = 1 << 1,\n  NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC = 1 << 2,\n  NGHTTP2_OPT_NO_HTTP_MESSAGING = 1 << 3,\n  NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS = 1 << 4,\n  NGHTTP2_OPT_USER_RECV_EXT_TYPES = 1 << 5,\n  NGHTTP2_OPT_NO_AUTO_PING_ACK = 1 << 6,\n  NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES = 1 << 7,\n  NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH = 1 << 8,\n  NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE = 1 << 9,\n  NGHTTP2_OPT_NO_CLOSED_STREAMS = 1 << 10,\n  NGHTTP2_OPT_MAX_OUTBOUND_ACK = 1 << 11,\n} nghttp2_option_flag;\n\n/**\n * Struct to store option values for nghttp2_session.\n */\nstruct nghttp2_option {\n  /**\n   * NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH\n   */\n  size_t max_send_header_block_length;\n  /**\n   * NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE\n   */\n  size_t max_deflate_dynamic_table_size;\n  /**\n   * NGHTTP2_OPT_MAX_OUTBOUND_ACK\n   */\n  size_t max_outbound_ack;\n  /**\n   * Bitwise OR of nghttp2_option_flag to determine that which fields\n   * are specified.\n   */\n  uint32_t opt_set_mask;\n  /**\n   * NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS\n   */\n  uint32_t peer_max_concurrent_streams;\n  /**\n   * NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS\n   */\n  uint32_t max_reserved_remote_streams;\n  /**\n   * NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES\n   */\n  uint32_t builtin_recv_ext_types;\n  /**\n   * NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE\n   */\n  int no_auto_window_update;\n  /**\n   * NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC\n   */\n  int no_recv_client_magic;\n  /**\n   * NGHTTP2_OPT_NO_HTTP_MESSAGING\n   */\n  int no_http_messaging;\n  /**\n   * NGHTTP2_OPT_NO_AUTO_PING_ACK\n   */\n  int no_auto_ping_ack;\n  /**\n   * NGHTTP2_OPT_NO_CLOSED_STREAMS\n   */\n  int no_closed_streams;\n  /**\n   * NGHTTP2_OPT_USER_RECV_EXT_TYPES\n   */\n  uint8_t user_recv_ext_types[32];\n};\n\n#endif /* NGHTTP2_OPTION_H */\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_session.h\"\n\n#include <string.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdarg.h>\n\n#include \"nghttp2_helper.h\"\n#include \"nghttp2_net.h\"\n#include \"nghttp2_priority_spec.h\"\n#include \"nghttp2_option.h\"\n#include \"nghttp2_http.h\"\n#include \"nghttp2_pq.h\"\n#include \"nghttp2_debug.h\"\n\n/*\n * Returns non-zero if the number of outgoing opened streams is larger\n * than or equal to\n * remote_settings.max_concurrent_streams.\n */\nstatic int\nsession_is_outgoing_concurrent_streams_max(nghttp2_session *session) {\n  return session->remote_settings.max_concurrent_streams <=\n         session->num_outgoing_streams;\n}\n\n/*\n * Returns non-zero if the number of incoming opened streams is larger\n * than or equal to\n * local_settings.max_concurrent_streams.\n */\nstatic int\nsession_is_incoming_concurrent_streams_max(nghttp2_session *session) {\n  return session->local_settings.max_concurrent_streams <=\n         session->num_incoming_streams;\n}\n\n/*\n * Returns non-zero if the number of incoming opened streams is larger\n * than or equal to\n * session->pending_local_max_concurrent_stream.\n */\nstatic int\nsession_is_incoming_concurrent_streams_pending_max(nghttp2_session *session) {\n  return session->pending_local_max_concurrent_stream <=\n         session->num_incoming_streams;\n}\n\n/*\n * Returns non-zero if |lib_error| is non-fatal error.\n */\nstatic int is_non_fatal(int lib_error_code) {\n  return lib_error_code < 0 && lib_error_code > NGHTTP2_ERR_FATAL;\n}\n\nint nghttp2_is_fatal(int lib_error_code) {\n  return lib_error_code < NGHTTP2_ERR_FATAL;\n}\n\nstatic int session_enforce_http_messaging(nghttp2_session *session) {\n  return (session->opt_flags & NGHTTP2_OPTMASK_NO_HTTP_MESSAGING) == 0;\n}\n\n/*\n * Returns nonzero if |frame| is trailer headers.\n */\nstatic int session_trailer_headers(nghttp2_session *session,\n                                   nghttp2_stream *stream,\n                                   nghttp2_frame *frame) {\n  if (!stream || frame->hd.type != NGHTTP2_HEADERS) {\n    return 0;\n  }\n  if (session->server) {\n    return frame->headers.cat == NGHTTP2_HCAT_HEADERS;\n  }\n\n  return frame->headers.cat == NGHTTP2_HCAT_HEADERS &&\n         (stream->http_flags & NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE) == 0;\n}\n\n/* Returns nonzero if the |stream| is in reserved(remote) state */\nstatic int state_reserved_remote(nghttp2_session *session,\n                                 nghttp2_stream *stream) {\n  return stream->state == NGHTTP2_STREAM_RESERVED &&\n         !nghttp2_session_is_my_stream_id(session, stream->stream_id);\n}\n\n/* Returns nonzero if the |stream| is in reserved(local) state */\nstatic int state_reserved_local(nghttp2_session *session,\n                                nghttp2_stream *stream) {\n  return stream->state == NGHTTP2_STREAM_RESERVED &&\n         nghttp2_session_is_my_stream_id(session, stream->stream_id);\n}\n\n/*\n * Checks whether received stream_id is valid.  This function returns\n * 1 if it succeeds, or 0.\n */\nstatic int session_is_new_peer_stream_id(nghttp2_session *session,\n                                         int32_t stream_id) {\n  return stream_id != 0 &&\n         !nghttp2_session_is_my_stream_id(session, stream_id) &&\n         session->last_recv_stream_id < stream_id;\n}\n\nstatic int session_detect_idle_stream(nghttp2_session *session,\n                                      int32_t stream_id) {\n  /* Assume that stream object with stream_id does not exist */\n  if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n    if (session->last_sent_stream_id < stream_id) {\n      return 1;\n    }\n    return 0;\n  }\n  if (session_is_new_peer_stream_id(session, stream_id)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic int check_ext_type_set(const uint8_t *ext_types, uint8_t type) {\n  return (ext_types[type / 8] & (1 << (type & 0x7))) > 0;\n}\n\nstatic int session_call_error_callback(nghttp2_session *session,\n                                       int lib_error_code, const char *fmt,\n                                       ...) {\n  size_t bufsize;\n  va_list ap;\n  char *buf;\n  int rv;\n  nghttp2_mem *mem;\n\n  if (!session->callbacks.error_callback &&\n      !session->callbacks.error_callback2) {\n    return 0;\n  }\n\n  mem = &session->mem;\n\n  va_start(ap, fmt);\n  rv = vsnprintf(NULL, 0, fmt, ap);\n  va_end(ap);\n\n  if (rv < 0) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  bufsize = (size_t)(rv + 1);\n\n  buf = nghttp2_mem_malloc(mem, bufsize);\n  if (buf == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  va_start(ap, fmt);\n  rv = vsnprintf(buf, bufsize, fmt, ap);\n  va_end(ap);\n\n  if (rv < 0) {\n    nghttp2_mem_free(mem, buf);\n    /* vsnprintf may return error because of various things we can\n       imagine, but typically we don't want to drop session just for\n       debug callback. */\n    DEBUGF(\"error_callback: vsnprintf failed. The template was %s\\n\", fmt);\n    return 0;\n  }\n\n  if (session->callbacks.error_callback2) {\n    rv = session->callbacks.error_callback2(session, lib_error_code, buf,\n                                            (size_t)rv, session->user_data);\n  } else {\n    rv = session->callbacks.error_callback(session, buf, (size_t)rv,\n                                           session->user_data);\n  }\n\n  nghttp2_mem_free(mem, buf);\n\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  return 0;\n}\n\nstatic int session_terminate_session(nghttp2_session *session,\n                                     int32_t last_stream_id,\n                                     uint32_t error_code, const char *reason) {\n  int rv;\n  const uint8_t *debug_data;\n  size_t debug_datalen;\n\n  if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND) {\n    return 0;\n  }\n\n  /* Ignore all incoming frames because we are going to tear down the\n     session. */\n  session->iframe.state = NGHTTP2_IB_IGN_ALL;\n\n  if (reason == NULL) {\n    debug_data = NULL;\n    debug_datalen = 0;\n  } else {\n    debug_data = (const uint8_t *)reason;\n    debug_datalen = strlen(reason);\n  }\n\n  rv = nghttp2_session_add_goaway(session, last_stream_id, error_code,\n                                  debug_data, debug_datalen,\n                                  NGHTTP2_GOAWAY_AUX_TERM_ON_SEND);\n\n  if (rv != 0) {\n    return rv;\n  }\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_TERM_ON_SEND;\n\n  return 0;\n}\n\nint nghttp2_session_terminate_session(nghttp2_session *session,\n                                      uint32_t error_code) {\n  return session_terminate_session(session, session->last_proc_stream_id,\n                                   error_code, NULL);\n}\n\nint nghttp2_session_terminate_session2(nghttp2_session *session,\n                                       int32_t last_stream_id,\n                                       uint32_t error_code) {\n  return session_terminate_session(session, last_stream_id, error_code, NULL);\n}\n\nint nghttp2_session_terminate_session_with_reason(nghttp2_session *session,\n                                                  uint32_t error_code,\n                                                  const char *reason) {\n  return session_terminate_session(session, session->last_proc_stream_id,\n                                   error_code, reason);\n}\n\nint nghttp2_session_is_my_stream_id(nghttp2_session *session,\n                                    int32_t stream_id) {\n  int rem;\n  if (stream_id == 0) {\n    return 0;\n  }\n  rem = stream_id & 0x1;\n  if (session->server) {\n    return rem == 0;\n  }\n  return rem == 1;\n}\n\nnghttp2_stream *nghttp2_session_get_stream(nghttp2_session *session,\n                                           int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = (nghttp2_stream *)nghttp2_map_find(&session->streams, stream_id);\n\n  if (stream == NULL || (stream->flags & NGHTTP2_STREAM_FLAG_CLOSED) ||\n      stream->state == NGHTTP2_STREAM_IDLE) {\n    return NULL;\n  }\n\n  return stream;\n}\n\nnghttp2_stream *nghttp2_session_get_stream_raw(nghttp2_session *session,\n                                               int32_t stream_id) {\n  return (nghttp2_stream *)nghttp2_map_find(&session->streams, stream_id);\n}\n\nstatic void session_inbound_frame_reset(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_mem *mem = &session->mem;\n  /* A bit risky code, since if this function is called from\n     nghttp2_session_new(), we rely on the fact that\n     iframe->frame.hd.type is 0, so that no free is performed. */\n  switch (iframe->frame.hd.type) {\n  case NGHTTP2_DATA:\n    break;\n  case NGHTTP2_HEADERS:\n    nghttp2_frame_headers_free(&iframe->frame.headers, mem);\n    break;\n  case NGHTTP2_PRIORITY:\n    nghttp2_frame_priority_free(&iframe->frame.priority);\n    break;\n  case NGHTTP2_RST_STREAM:\n    nghttp2_frame_rst_stream_free(&iframe->frame.rst_stream);\n    break;\n  case NGHTTP2_SETTINGS:\n    nghttp2_frame_settings_free(&iframe->frame.settings, mem);\n\n    nghttp2_mem_free(mem, iframe->iv);\n\n    iframe->iv = NULL;\n    iframe->niv = 0;\n    iframe->max_niv = 0;\n\n    break;\n  case NGHTTP2_PUSH_PROMISE:\n    nghttp2_frame_push_promise_free(&iframe->frame.push_promise, mem);\n    break;\n  case NGHTTP2_PING:\n    nghttp2_frame_ping_free(&iframe->frame.ping);\n    break;\n  case NGHTTP2_GOAWAY:\n    nghttp2_frame_goaway_free(&iframe->frame.goaway, mem);\n    break;\n  case NGHTTP2_WINDOW_UPDATE:\n    nghttp2_frame_window_update_free(&iframe->frame.window_update);\n    break;\n  default:\n    /* extension frame */\n    if (check_ext_type_set(session->user_recv_ext_types,\n                           iframe->frame.hd.type)) {\n      nghttp2_frame_extension_free(&iframe->frame.ext);\n    } else {\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_ALTSVC:\n        if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC) == 0) {\n          break;\n        }\n        nghttp2_frame_altsvc_free(&iframe->frame.ext, mem);\n        break;\n      case NGHTTP2_ORIGIN:\n        if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN) == 0) {\n          break;\n        }\n        nghttp2_frame_origin_free(&iframe->frame.ext, mem);\n        break;\n      }\n    }\n\n    break;\n  }\n\n  memset(&iframe->frame, 0, sizeof(nghttp2_frame));\n  memset(&iframe->ext_frame_payload, 0, sizeof(nghttp2_ext_frame_payload));\n\n  iframe->state = NGHTTP2_IB_READ_HEAD;\n\n  nghttp2_buf_wrap_init(&iframe->sbuf, iframe->raw_sbuf,\n                        sizeof(iframe->raw_sbuf));\n  iframe->sbuf.mark += NGHTTP2_FRAME_HDLEN;\n\n  nghttp2_buf_free(&iframe->lbuf, mem);\n  nghttp2_buf_wrap_init(&iframe->lbuf, NULL, 0);\n\n  iframe->raw_lbuf = NULL;\n\n  iframe->payloadleft = 0;\n  iframe->padlen = 0;\n}\n\nstatic void init_settings(nghttp2_settings_storage *settings) {\n  settings->header_table_size = NGHTTP2_HD_DEFAULT_MAX_BUFFER_SIZE;\n  settings->enable_push = 1;\n  settings->max_concurrent_streams = NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  settings->initial_window_size = NGHTTP2_INITIAL_WINDOW_SIZE;\n  settings->max_frame_size = NGHTTP2_MAX_FRAME_SIZE_MIN;\n  settings->max_header_list_size = UINT32_MAX;\n}\n\nstatic void active_outbound_item_reset(nghttp2_active_outbound_item *aob,\n                                       nghttp2_mem *mem) {\n  DEBUGF(\"send: reset nghttp2_active_outbound_item\\n\");\n  DEBUGF(\"send: aob->item = %p\\n\", aob->item);\n  nghttp2_outbound_item_free(aob->item, mem);\n  nghttp2_mem_free(mem, aob->item);\n  aob->item = NULL;\n  nghttp2_bufs_reset(&aob->framebufs);\n  aob->state = NGHTTP2_OB_POP_ITEM;\n}\n\nint nghttp2_enable_strict_preface = 1;\n\nstatic int session_new(nghttp2_session **session_ptr,\n                       const nghttp2_session_callbacks *callbacks,\n                       void *user_data, int server,\n                       const nghttp2_option *option, nghttp2_mem *mem) {\n  int rv;\n  size_t nbuffer;\n  size_t max_deflate_dynamic_table_size =\n      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;\n\n  if (mem == NULL) {\n    mem = nghttp2_mem_default();\n  }\n\n  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));\n  if (*session_ptr == NULL) {\n    rv = NGHTTP2_ERR_NOMEM;\n    goto fail_session;\n  }\n\n  (*session_ptr)->mem = *mem;\n  mem = &(*session_ptr)->mem;\n\n  /* next_stream_id is initialized in either\n     nghttp2_session_client_new2 or nghttp2_session_server_new2 */\n\n  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,\n                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,\n                      mem);\n\n  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n  (*session_ptr)->recv_window_size = 0;\n  (*session_ptr)->consumed_size = 0;\n  (*session_ptr)->recv_reduction = 0;\n  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n\n  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;\n  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;\n  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;\n\n  (*session_ptr)->pending_local_max_concurrent_stream =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  (*session_ptr)->pending_enable_push = 1;\n\n  if (server) {\n    (*session_ptr)->server = 1;\n  }\n\n  init_settings(&(*session_ptr)->remote_settings);\n  init_settings(&(*session_ptr)->local_settings);\n\n  (*session_ptr)->max_incoming_reserved_streams =\n      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;\n\n  /* Limit max outgoing concurrent streams to sensible value */\n  (*session_ptr)->remote_settings.max_concurrent_streams = 100;\n\n  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n\n  if (option) {\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n        option->no_auto_window_update) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {\n\n      (*session_ptr)->remote_settings.max_concurrent_streams =\n          option->peer_max_concurrent_streams;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {\n\n      (*session_ptr)->max_incoming_reserved_streams =\n          option->max_reserved_remote_streams;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&\n        option->no_recv_client_magic) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&\n        option->no_http_messaging) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {\n      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,\n             sizeof((*session_ptr)->user_recv_ext_types));\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {\n      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&\n        option->no_auto_ping_ack) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {\n      (*session_ptr)->max_send_header_block_length =\n          option->max_send_header_block_length;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {\n      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&\n        option->no_closed_streams) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n    }\n  }\n\n  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,\n                                max_deflate_dynamic_table_size, mem);\n  if (rv != 0) {\n    goto fail_hd_deflater;\n  }\n  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);\n  if (rv != 0) {\n    goto fail_hd_inflater;\n  }\n  rv = nghttp2_map_init(&(*session_ptr)->streams, mem);\n  if (rv != 0) {\n    goto fail_map;\n  }\n\n  nbuffer = ((*session_ptr)->max_send_header_block_length +\n             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /\n            NGHTTP2_FRAMEBUF_CHUNKLEN;\n\n  if (nbuffer == 0) {\n    nbuffer = 1;\n  }\n\n  /* 1 for Pad Field. */\n  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,\n                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,\n                          NGHTTP2_FRAME_HDLEN + 1, mem);\n  if (rv != 0) {\n    goto fail_aob_framebuf;\n  }\n\n  active_outbound_item_reset(&(*session_ptr)->aob, mem);\n\n  (*session_ptr)->callbacks = *callbacks;\n  (*session_ptr)->user_data = user_data;\n\n  session_inbound_frame_reset(*session_ptr);\n\n  if (nghttp2_enable_strict_preface) {\n    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;\n\n    if (server && ((*session_ptr)->opt_flags &\n                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {\n      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;\n      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;\n    } else {\n      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n    }\n\n    if (!server) {\n      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;\n      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,\n                       NGHTTP2_CLIENT_MAGIC_LEN);\n    }\n  }\n\n  return 0;\n\nfail_aob_framebuf:\n  nghttp2_map_free(&(*session_ptr)->streams);\nfail_map:\n  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);\nfail_hd_inflater:\n  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);\nfail_hd_deflater:\n  nghttp2_mem_free(mem, *session_ptr);\nfail_session:\n  return rv;\n}\n\nint nghttp2_session_client_new(nghttp2_session **session_ptr,\n                               const nghttp2_session_callbacks *callbacks,\n                               void *user_data) {\n  return nghttp2_session_client_new3(session_ptr, callbacks, user_data, NULL,\n                                     NULL);\n}\n\nint nghttp2_session_client_new2(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option) {\n  return nghttp2_session_client_new3(session_ptr, callbacks, user_data, option,\n                                     NULL);\n}\n\nint nghttp2_session_client_new3(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option,\n                                nghttp2_mem *mem) {\n  int rv;\n  nghttp2_session *session;\n\n  rv = session_new(&session, callbacks, user_data, 0, option, mem);\n\n  if (rv != 0) {\n    return rv;\n  }\n  /* IDs for use in client */\n  session->next_stream_id = 1;\n\n  *session_ptr = session;\n\n  return 0;\n}\n\nint nghttp2_session_server_new(nghttp2_session **session_ptr,\n                               const nghttp2_session_callbacks *callbacks,\n                               void *user_data) {\n  return nghttp2_session_server_new3(session_ptr, callbacks, user_data, NULL,\n                                     NULL);\n}\n\nint nghttp2_session_server_new2(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option) {\n  return nghttp2_session_server_new3(session_ptr, callbacks, user_data, option,\n                                     NULL);\n}\n\nint nghttp2_session_server_new3(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option,\n                                nghttp2_mem *mem) {\n  int rv;\n  nghttp2_session *session;\n\n  rv = session_new(&session, callbacks, user_data, 1, option, mem);\n\n  if (rv != 0) {\n    return rv;\n  }\n  /* IDs for use in client */\n  session->next_stream_id = 2;\n\n  *session_ptr = session;\n\n  return 0;\n}\n\nstatic int free_streams(nghttp2_map_entry *entry, void *ptr) {\n  nghttp2_session *session;\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  session = (nghttp2_session *)ptr;\n  mem = &session->mem;\n  stream = (nghttp2_stream *)entry;\n  item = stream->item;\n\n  if (item && !item->queued && item != session->aob.item) {\n    nghttp2_outbound_item_free(item, mem);\n    nghttp2_mem_free(mem, item);\n  }\n\n  nghttp2_stream_free(stream);\n  nghttp2_mem_free(mem, stream);\n\n  return 0;\n}\n\nstatic void ob_q_free(nghttp2_outbound_queue *q, nghttp2_mem *mem) {\n  nghttp2_outbound_item *item, *next;\n  for (item = q->head; item;) {\n    next = item->qnext;\n    nghttp2_outbound_item_free(item, mem);\n    nghttp2_mem_free(mem, item);\n    item = next;\n  }\n}\n\nstatic int inflight_settings_new(nghttp2_inflight_settings **settings_ptr,\n                                 const nghttp2_settings_entry *iv, size_t niv,\n                                 nghttp2_mem *mem) {\n  *settings_ptr = nghttp2_mem_malloc(mem, sizeof(nghttp2_inflight_settings));\n  if (!*settings_ptr) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  if (niv > 0) {\n    (*settings_ptr)->iv = nghttp2_frame_iv_copy(iv, niv, mem);\n    if (!(*settings_ptr)->iv) {\n      nghttp2_mem_free(mem, *settings_ptr);\n      return NGHTTP2_ERR_NOMEM;\n    }\n  } else {\n    (*settings_ptr)->iv = NULL;\n  }\n\n  (*settings_ptr)->niv = niv;\n  (*settings_ptr)->next = NULL;\n\n  return 0;\n}\n\nstatic void inflight_settings_del(nghttp2_inflight_settings *settings,\n                                  nghttp2_mem *mem) {\n  if (!settings) {\n    return;\n  }\n\n  nghttp2_mem_free(mem, settings->iv);\n  nghttp2_mem_free(mem, settings);\n}\n\nvoid nghttp2_session_del(nghttp2_session *session) {\n  nghttp2_mem *mem;\n  nghttp2_inflight_settings *settings;\n\n  if (session == NULL) {\n    return;\n  }\n\n  mem = &session->mem;\n\n  for (settings = session->inflight_settings_head; settings;) {\n    nghttp2_inflight_settings *next = settings->next;\n    inflight_settings_del(settings, mem);\n    settings = next;\n  }\n\n  nghttp2_stream_free(&session->root);\n\n  /* Have to free streams first, so that we can check\n     stream->item->queued */\n  nghttp2_map_each_free(&session->streams, free_streams, session);\n  nghttp2_map_free(&session->streams);\n\n  ob_q_free(&session->ob_urgent, mem);\n  ob_q_free(&session->ob_reg, mem);\n  ob_q_free(&session->ob_syn, mem);\n\n  active_outbound_item_reset(&session->aob, mem);\n  session_inbound_frame_reset(session);\n  nghttp2_hd_deflate_free(&session->hd_deflater);\n  nghttp2_hd_inflate_free(&session->hd_inflater);\n  nghttp2_bufs_free(&session->aob.framebufs);\n  nghttp2_mem_free(mem, session);\n}\n\nint nghttp2_session_reprioritize_stream(\n    nghttp2_session *session, nghttp2_stream *stream,\n    const nghttp2_priority_spec *pri_spec_in) {\n  int rv;\n  nghttp2_stream *dep_stream = NULL;\n  nghttp2_priority_spec pri_spec_default;\n  const nghttp2_priority_spec *pri_spec = pri_spec_in;\n\n  assert(pri_spec->stream_id != stream->stream_id);\n\n  if (!nghttp2_stream_in_dep_tree(stream)) {\n    return 0;\n  }\n\n  if (pri_spec->stream_id != 0) {\n    dep_stream = nghttp2_session_get_stream_raw(session, pri_spec->stream_id);\n\n    if (!dep_stream &&\n        session_detect_idle_stream(session, pri_spec->stream_id)) {\n\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n\n      dep_stream = nghttp2_session_open_stream(\n          session, pri_spec->stream_id, NGHTTP2_FLAG_NONE, &pri_spec_default,\n          NGHTTP2_STREAM_IDLE, NULL);\n\n      if (dep_stream == NULL) {\n        return NGHTTP2_ERR_NOMEM;\n      }\n    } else if (!dep_stream || !nghttp2_stream_in_dep_tree(dep_stream)) {\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n      pri_spec = &pri_spec_default;\n    }\n  }\n\n  if (pri_spec->stream_id == 0) {\n    dep_stream = &session->root;\n  } else if (nghttp2_stream_dep_find_ancestor(dep_stream, stream)) {\n    DEBUGF(\"stream: cycle detected, dep_stream(%p)=%d stream(%p)=%d\\n\",\n           dep_stream, dep_stream->stream_id, stream, stream->stream_id);\n\n    nghttp2_stream_dep_remove_subtree(dep_stream);\n    rv = nghttp2_stream_dep_add_subtree(stream->dep_prev, dep_stream);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  assert(dep_stream);\n\n  if (dep_stream == stream->dep_prev && !pri_spec->exclusive) {\n    /* This is minor optimization when just weight is changed. */\n    nghttp2_stream_change_weight(stream, pri_spec->weight);\n\n    return 0;\n  }\n\n  nghttp2_stream_dep_remove_subtree(stream);\n\n  /* We have to update weight after removing stream from tree */\n  stream->weight = pri_spec->weight;\n\n  if (pri_spec->exclusive) {\n    rv = nghttp2_stream_dep_insert_subtree(dep_stream, stream);\n  } else {\n    rv = nghttp2_stream_dep_add_subtree(dep_stream, stream);\n  }\n\n  if (rv != 0) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_add_item(nghttp2_session *session,\n                             nghttp2_outbound_item *item) {\n  /* TODO Return error if stream is not found for the frame requiring\n     stream presence. */\n  int rv = 0;\n  nghttp2_stream *stream;\n  nghttp2_frame *frame;\n\n  frame = &item->frame;\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n  switch (frame->hd.type) {\n  case NGHTTP2_DATA:\n    if (!stream) {\n      return NGHTTP2_ERR_STREAM_CLOSED;\n    }\n\n    if (stream->item) {\n      return NGHTTP2_ERR_DATA_EXIST;\n    }\n\n    rv = nghttp2_stream_attach_item(stream, item);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    return 0;\n  case NGHTTP2_HEADERS:\n    /* We push request HEADERS and push response HEADERS to\n       dedicated queue because their transmission is affected by\n       SETTINGS_MAX_CONCURRENT_STREAMS */\n    /* TODO If 2 HEADERS are submitted for reserved stream, then\n       both of them are queued into ob_syn, which is not\n       desirable. */\n    if (frame->headers.cat == NGHTTP2_HCAT_REQUEST ||\n        (stream && stream->state == NGHTTP2_STREAM_RESERVED)) {\n      nghttp2_outbound_queue_push(&session->ob_syn, item);\n      item->queued = 1;\n      return 0;\n      ;\n    }\n\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  case NGHTTP2_SETTINGS:\n  case NGHTTP2_PING:\n    nghttp2_outbound_queue_push(&session->ob_urgent, item);\n    item->queued = 1;\n    return 0;\n  case NGHTTP2_RST_STREAM:\n    if (stream) {\n      stream->state = NGHTTP2_STREAM_CLOSING;\n    }\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  case NGHTTP2_PUSH_PROMISE: {\n    nghttp2_headers_aux_data *aux_data;\n    nghttp2_priority_spec pri_spec;\n\n    aux_data = &item->aux_data.headers;\n\n    if (!stream) {\n      return NGHTTP2_ERR_STREAM_CLOSED;\n    }\n\n    nghttp2_priority_spec_init(&pri_spec, stream->stream_id,\n                               NGHTTP2_DEFAULT_WEIGHT, 0);\n\n    if (!nghttp2_session_open_stream(\n            session, frame->push_promise.promised_stream_id,\n            NGHTTP2_STREAM_FLAG_NONE, &pri_spec, NGHTTP2_STREAM_RESERVED,\n            aux_data->stream_user_data)) {\n      return NGHTTP2_ERR_NOMEM;\n    }\n\n    /* We don't have to call nghttp2_session_adjust_closed_stream()\n       here, since stream->stream_id is local stream_id, and it does\n       not affect closed stream count. */\n\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n\n    return 0;\n  }\n  case NGHTTP2_WINDOW_UPDATE:\n    if (stream) {\n      stream->window_update_queued = 1;\n    } else if (frame->hd.stream_id == 0) {\n      session->window_update_queued = 1;\n    }\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  default:\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  }\n}\n\nint nghttp2_session_add_rst_stream(nghttp2_session *session, int32_t stream_id,\n                                   uint32_t error_code) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream && stream->state == NGHTTP2_STREAM_CLOSING) {\n    return 0;\n  }\n\n  /* Cancel pending request HEADERS in ob_syn if this RST_STREAM\n     refers to that stream. */\n  if (!session->server && nghttp2_session_is_my_stream_id(session, stream_id) &&\n      nghttp2_outbound_queue_top(&session->ob_syn)) {\n    nghttp2_headers_aux_data *aux_data;\n    nghttp2_frame *headers_frame;\n\n    headers_frame = &nghttp2_outbound_queue_top(&session->ob_syn)->frame;\n    assert(headers_frame->hd.type == NGHTTP2_HEADERS);\n\n    if (headers_frame->hd.stream_id <= stream_id &&\n        (uint32_t)stream_id < session->next_stream_id) {\n\n      for (item = session->ob_syn.head; item; item = item->qnext) {\n        aux_data = &item->aux_data.headers;\n\n        if (item->frame.hd.stream_id < stream_id) {\n          continue;\n        }\n\n        /* stream_id in ob_syn queue must be strictly increasing.  If\n           we found larger ID, then we can break here. */\n        if (item->frame.hd.stream_id > stream_id || aux_data->canceled) {\n          break;\n        }\n\n        aux_data->error_code = error_code;\n        aux_data->canceled = 1;\n\n        return 0;\n      }\n    }\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_rst_stream_init(&frame->rst_stream, stream_id, error_code);\n  rv = nghttp2_session_add_item(session, item);\n  if (rv != 0) {\n    nghttp2_frame_rst_stream_free(&frame->rst_stream);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n  return 0;\n}\n\nnghttp2_stream *nghttp2_session_open_stream(nghttp2_session *session,\n                                            int32_t stream_id, uint8_t flags,\n                                            nghttp2_priority_spec *pri_spec_in,\n                                            nghttp2_stream_state initial_state,\n                                            void *stream_user_data) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_stream *dep_stream = NULL;\n  int stream_alloc = 0;\n  nghttp2_priority_spec pri_spec_default;\n  nghttp2_priority_spec *pri_spec = pri_spec_in;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n\n  if (stream) {\n    assert(stream->state == NGHTTP2_STREAM_IDLE);\n    assert(nghttp2_stream_in_dep_tree(stream));\n    nghttp2_session_detach_idle_stream(session, stream);\n    rv = nghttp2_stream_dep_remove(stream);\n    if (rv != 0) {\n      return NULL;\n    }\n  } else {\n    stream = nghttp2_mem_malloc(mem, sizeof(nghttp2_stream));\n    if (stream == NULL) {\n      return NULL;\n    }\n\n    stream_alloc = 1;\n  }\n\n  if (pri_spec->stream_id != 0) {\n    dep_stream = nghttp2_session_get_stream_raw(session, pri_spec->stream_id);\n\n    if (!dep_stream &&\n        session_detect_idle_stream(session, pri_spec->stream_id)) {\n      /* Depends on idle stream, which does not exist in memory.\n         Assign default priority for it. */\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n\n      dep_stream = nghttp2_session_open_stream(\n          session, pri_spec->stream_id, NGHTTP2_FLAG_NONE, &pri_spec_default,\n          NGHTTP2_STREAM_IDLE, NULL);\n\n      if (dep_stream == NULL) {\n        if (stream_alloc) {\n          nghttp2_mem_free(mem, stream);\n        }\n\n        return NULL;\n      }\n    } else if (!dep_stream || !nghttp2_stream_in_dep_tree(dep_stream)) {\n      /* If dep_stream is not part of dependency tree, stream will get\n         default priority.  This handles the case when\n         pri_spec->stream_id == stream_id.  This happens because we\n         don't check pri_spec->stream_id against new stream ID in\n         nghttp2_submit_request.  This also handles the case when idle\n         stream created by PRIORITY frame was opened.  Somehow we\n         first remove the idle stream from dependency tree.  This is\n         done to simplify code base, but ideally we should retain old\n         dependency.  But I'm not sure this adds values. */\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n      pri_spec = &pri_spec_default;\n    }\n  }\n\n  if (initial_state == NGHTTP2_STREAM_RESERVED) {\n    flags |= NGHTTP2_STREAM_FLAG_PUSH;\n  }\n\n  if (stream_alloc) {\n    nghttp2_stream_init(stream, stream_id, flags, initial_state,\n                        pri_spec->weight,\n                        (int32_t)session->remote_settings.initial_window_size,\n                        (int32_t)session->local_settings.initial_window_size,\n                        stream_user_data, mem);\n\n    rv = nghttp2_map_insert(&session->streams, &stream->map_entry);\n    if (rv != 0) {\n      nghttp2_stream_free(stream);\n      nghttp2_mem_free(mem, stream);\n      return NULL;\n    }\n  } else {\n    stream->flags = flags;\n    stream->state = initial_state;\n    stream->weight = pri_spec->weight;\n    stream->stream_user_data = stream_user_data;\n  }\n\n  switch (initial_state) {\n  case NGHTTP2_STREAM_RESERVED:\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      /* reserved (local) */\n      nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    } else {\n      /* reserved (remote) */\n      nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n      ++session->num_incoming_reserved_streams;\n    }\n    /* Reserved stream does not count in the concurrent streams\n       limit. That is one of the DOS vector. */\n    break;\n  case NGHTTP2_STREAM_IDLE:\n    /* Idle stream does not count toward the concurrent streams limit.\n       This is used as anchor node in dependency tree. */\n    nghttp2_session_keep_idle_stream(session, stream);\n    break;\n  default:\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      ++session->num_outgoing_streams;\n    } else {\n      ++session->num_incoming_streams;\n    }\n  }\n\n  if (pri_spec->stream_id == 0) {\n    dep_stream = &session->root;\n  }\n\n  assert(dep_stream);\n\n  if (pri_spec->exclusive) {\n    rv = nghttp2_stream_dep_insert(dep_stream, stream);\n    if (rv != 0) {\n      return NULL;\n    }\n  } else {\n    nghttp2_stream_dep_add(dep_stream, stream);\n  }\n\n  return stream;\n}\n\nint nghttp2_session_close_stream(nghttp2_session *session, int32_t stream_id,\n                                 uint32_t error_code) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n  int is_my_stream_id;\n\n  mem = &session->mem;\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  DEBUGF(\"stream: stream(%p)=%d close\\n\", stream, stream->stream_id);\n\n  if (stream->item) {\n    nghttp2_outbound_item *item;\n\n    item = stream->item;\n\n    rv = nghttp2_stream_detach_item(stream);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    /* If item is queued, it will be deleted when it is popped\n       (nghttp2_session_prep_frame() will fail).  If session->aob.item\n       points to this item, let active_outbound_item_reset()\n       free the item. */\n    if (!item->queued && item != session->aob.item) {\n      nghttp2_outbound_item_free(item, mem);\n      nghttp2_mem_free(mem, item);\n    }\n  }\n\n  /* We call on_stream_close_callback even if stream->state is\n     NGHTTP2_STREAM_INITIAL. This will happen while sending request\n     HEADERS, a local endpoint receives RST_STREAM for that stream. It\n     may be PROTOCOL_ERROR, but without notifying stream closure will\n     hang the stream in a local endpoint.\n  */\n\n  if (session->callbacks.on_stream_close_callback) {\n    if (session->callbacks.on_stream_close_callback(\n            session, stream_id, error_code, session->user_data) != 0) {\n\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n\n  is_my_stream_id = nghttp2_session_is_my_stream_id(session, stream_id);\n\n  /* pushed streams which is not opened yet is not counted toward max\n     concurrent limits */\n  if ((stream->flags & NGHTTP2_STREAM_FLAG_PUSH)) {\n    if (!is_my_stream_id) {\n      --session->num_incoming_reserved_streams;\n    }\n  } else {\n    if (is_my_stream_id) {\n      --session->num_outgoing_streams;\n    } else {\n      --session->num_incoming_streams;\n    }\n  }\n\n  /* Closes both directions just in case they are not closed yet */\n  stream->flags |= NGHTTP2_STREAM_FLAG_CLOSED;\n\n  if ((session->opt_flags & NGHTTP2_OPTMASK_NO_CLOSED_STREAMS) == 0 &&\n      session->server && !is_my_stream_id &&\n      nghttp2_stream_in_dep_tree(stream)) {\n    /* On server side, retain stream at most MAX_CONCURRENT_STREAMS\n       combined with the current active incoming streams to make\n       dependency tree work better. */\n    nghttp2_session_keep_closed_stream(session, stream);\n  } else {\n    rv = nghttp2_session_destroy_stream(session, stream);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  return 0;\n}\n\nint nghttp2_session_destroy_stream(nghttp2_session *session,\n                                   nghttp2_stream *stream) {\n  nghttp2_mem *mem;\n  int rv;\n\n  DEBUGF(\"stream: destroy closed stream(%p)=%d\\n\", stream, stream->stream_id);\n\n  mem = &session->mem;\n\n  if (nghttp2_stream_in_dep_tree(stream)) {\n    rv = nghttp2_stream_dep_remove(stream);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  nghttp2_map_remove(&session->streams, stream->stream_id);\n  nghttp2_stream_free(stream);\n  nghttp2_mem_free(mem, stream);\n\n  return 0;\n}\n\nvoid nghttp2_session_keep_closed_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream) {\n  DEBUGF(\"stream: keep closed stream(%p)=%d, state=%d\\n\", stream,\n         stream->stream_id, stream->state);\n\n  if (session->closed_stream_tail) {\n    session->closed_stream_tail->closed_next = stream;\n    stream->closed_prev = session->closed_stream_tail;\n  } else {\n    session->closed_stream_head = stream;\n  }\n  session->closed_stream_tail = stream;\n\n  ++session->num_closed_streams;\n}\n\nvoid nghttp2_session_keep_idle_stream(nghttp2_session *session,\n                                      nghttp2_stream *stream) {\n  DEBUGF(\"stream: keep idle stream(%p)=%d, state=%d\\n\", stream,\n         stream->stream_id, stream->state);\n\n  if (session->idle_stream_tail) {\n    session->idle_stream_tail->closed_next = stream;\n    stream->closed_prev = session->idle_stream_tail;\n  } else {\n    session->idle_stream_head = stream;\n  }\n  session->idle_stream_tail = stream;\n\n  ++session->num_idle_streams;\n}\n\nvoid nghttp2_session_detach_idle_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream) {\n  nghttp2_stream *prev_stream, *next_stream;\n\n  DEBUGF(\"stream: detach idle stream(%p)=%d, state=%d\\n\", stream,\n         stream->stream_id, stream->state);\n\n  prev_stream = stream->closed_prev;\n  next_stream = stream->closed_next;\n\n  if (prev_stream) {\n    prev_stream->closed_next = next_stream;\n  } else {\n    session->idle_stream_head = next_stream;\n  }\n\n  if (next_stream) {\n    next_stream->closed_prev = prev_stream;\n  } else {\n    session->idle_stream_tail = prev_stream;\n  }\n\n  stream->closed_prev = NULL;\n  stream->closed_next = NULL;\n\n  --session->num_idle_streams;\n}\n\nint nghttp2_session_adjust_closed_stream(nghttp2_session *session) {\n  size_t num_stream_max;\n  int rv;\n\n  if (session->local_settings.max_concurrent_streams ==\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS) {\n    num_stream_max = session->pending_local_max_concurrent_stream;\n  } else {\n    num_stream_max = session->local_settings.max_concurrent_streams;\n  }\n\n  DEBUGF(\"stream: adjusting kept closed streams num_closed_streams=%zu, \"\n         \"num_incoming_streams=%zu, max_concurrent_streams=%zu\\n\",\n         session->num_closed_streams, session->num_incoming_streams,\n         num_stream_max);\n\n  while (session->num_closed_streams > 0 &&\n         session->num_closed_streams + session->num_incoming_streams >\n             num_stream_max) {\n    nghttp2_stream *head_stream;\n    nghttp2_stream *next;\n\n    head_stream = session->closed_stream_head;\n\n    assert(head_stream);\n\n    next = head_stream->closed_next;\n\n    rv = nghttp2_session_destroy_stream(session, head_stream);\n    if (rv != 0) {\n      return rv;\n    }\n\n    /* head_stream is now freed */\n\n    session->closed_stream_head = next;\n\n    if (session->closed_stream_head) {\n      session->closed_stream_head->closed_prev = NULL;\n    } else {\n      session->closed_stream_tail = NULL;\n    }\n\n    --session->num_closed_streams;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_adjust_idle_stream(nghttp2_session *session) {\n  size_t max;\n  int rv;\n\n  /* Make minimum number of idle streams 16, and maximum 100, which\n     are arbitrary chosen numbers. */\n  max = nghttp2_min(\n      100, nghttp2_max(\n               16, nghttp2_min(session->local_settings.max_concurrent_streams,\n                               session->pending_local_max_concurrent_stream)));\n\n  DEBUGF(\"stream: adjusting kept idle streams num_idle_streams=%zu, max=%zu\\n\",\n         session->num_idle_streams, max);\n\n  while (session->num_idle_streams > max) {\n    nghttp2_stream *head;\n    nghttp2_stream *next;\n\n    head = session->idle_stream_head;\n    assert(head);\n\n    next = head->closed_next;\n\n    rv = nghttp2_session_destroy_stream(session, head);\n    if (rv != 0) {\n      return rv;\n    }\n\n    /* head is now destroyed */\n\n    session->idle_stream_head = next;\n\n    if (session->idle_stream_head) {\n      session->idle_stream_head->closed_prev = NULL;\n    } else {\n      session->idle_stream_tail = NULL;\n    }\n\n    --session->num_idle_streams;\n  }\n\n  return 0;\n}\n\n/*\n * Closes stream with stream ID |stream_id| if both transmission and\n * reception of the stream were disallowed. The |error_code| indicates\n * the reason of the closure.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *   The stream is not found.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *   The callback function failed.\n */\nint nghttp2_session_close_stream_if_shut_rdwr(nghttp2_session *session,\n                                              nghttp2_stream *stream) {\n  if ((stream->shut_flags & NGHTTP2_SHUT_RDWR) == NGHTTP2_SHUT_RDWR) {\n    return nghttp2_session_close_stream(session, stream->stream_id,\n                                        NGHTTP2_NO_ERROR);\n  }\n  return 0;\n}\n\n/*\n * Returns nonzero if local endpoint allows reception of new stream\n * from remote.\n */\nstatic int session_allow_incoming_new_stream(nghttp2_session *session) {\n  return (session->goaway_flags &\n          (NGHTTP2_GOAWAY_TERM_ON_SEND | NGHTTP2_GOAWAY_SENT)) == 0;\n}\n\n/*\n * This function returns nonzero if session is closing.\n */\nstatic int session_is_closing(nghttp2_session *session) {\n  return (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND) != 0 ||\n         (nghttp2_session_want_read(session) == 0 &&\n          nghttp2_session_want_write(session) == 0);\n}\n\n/*\n * Check that we can send a frame to the |stream|. This function\n * returns 0 if we can send a frame to the |frame|, or one of the\n * following negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *   The stream is already closed.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *   The stream is half-closed for transmission.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_for_stream_send(nghttp2_session *session,\n                                             nghttp2_stream *stream) {\n  if (stream == NULL) {\n    return NGHTTP2_ERR_STREAM_CLOSED;\n  }\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n  if (stream->shut_flags & NGHTTP2_SHUT_WR) {\n    return NGHTTP2_ERR_STREAM_SHUT_WR;\n  }\n  return 0;\n}\n\nint nghttp2_session_check_request_allowed(nghttp2_session *session) {\n  return !session->server && session->next_stream_id <= INT32_MAX &&\n         (session->goaway_flags & NGHTTP2_GOAWAY_RECV) == 0 &&\n         !session_is_closing(session);\n}\n\n/*\n * This function checks request HEADERS frame, which opens stream, can\n * be sent at this time.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_START_STREAM_NOT_ALLOWED\n *     New stream cannot be created because of GOAWAY: session is\n *     going down or received last_stream_id is strictly less than\n *     frame->hd.stream_id.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     request HEADERS was canceled by RST_STREAM while it is in queue.\n */\nstatic int session_predicate_request_headers_send(nghttp2_session *session,\n                                                  nghttp2_outbound_item *item) {\n  if (item->aux_data.headers.canceled) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  /* If we are terminating session (NGHTTP2_GOAWAY_TERM_ON_SEND),\n     GOAWAY was received from peer, or session is about to close, new\n     request is not allowed. */\n  if ((session->goaway_flags & NGHTTP2_GOAWAY_RECV) ||\n      session_is_closing(session)) {\n    return NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n  }\n  return 0;\n}\n\n/*\n * This function checks HEADERS, which is the first frame from the\n * server, with the |stream| can be sent at this time.  The |stream|\n * can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_INVALID_STREAM_ID\n *     The stream ID is invalid.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *     This session is closing.\n * NGHTTP2_ERR_PROTO\n *     Client side attempted to send response.\n */\nstatic int session_predicate_response_headers_send(nghttp2_session *session,\n                                                   nghttp2_stream *stream) {\n  int rv;\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n  if (!session->server) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n    return NGHTTP2_ERR_INVALID_STREAM_ID;\n  }\n  switch (stream->state) {\n  case NGHTTP2_STREAM_OPENING:\n    return 0;\n  case NGHTTP2_STREAM_CLOSING:\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  default:\n    return NGHTTP2_ERR_INVALID_STREAM_STATE;\n  }\n}\n\n/*\n * This function checks HEADERS for reserved stream can be sent. The\n * |stream| must be reserved state and the |session| is server side.\n * The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *   The stream is already closed.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *   The stream is half-closed for transmission.\n * NGHTTP2_ERR_PROTO\n *   The stream is not reserved state\n * NGHTTP2_ERR_STREAM_CLOSED\n *   RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n * NGHTTP2_ERR_START_STREAM_NOT_ALLOWED\n *   New stream cannot be created because GOAWAY is already sent or\n *   received.\n * NGHTTP2_ERR_PROTO\n *   Client side attempted to send push response.\n */\nstatic int\nsession_predicate_push_response_headers_send(nghttp2_session *session,\n                                             nghttp2_stream *stream) {\n  int rv;\n  /* TODO Should disallow HEADERS if GOAWAY has already been issued? */\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n  if (!session->server) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (stream->state != NGHTTP2_STREAM_RESERVED) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (session->goaway_flags & NGHTTP2_GOAWAY_RECV) {\n    return NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n  }\n  return 0;\n}\n\n/*\n * This function checks HEADERS, which is neither stream-opening nor\n * first response header, with the |stream| can be sent at this time.\n * The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_headers_send(nghttp2_session *session,\n                                          nghttp2_stream *stream) {\n  int rv;\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n\n  switch (stream->state) {\n  case NGHTTP2_STREAM_OPENED:\n    return 0;\n  case NGHTTP2_STREAM_CLOSING:\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  default:\n    if (nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n      return 0;\n    }\n    return NGHTTP2_ERR_INVALID_STREAM_STATE;\n  }\n}\n\n/*\n * This function checks PUSH_PROMISE frame |frame| with the |stream|\n * can be sent at this time.  The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_START_STREAM_NOT_ALLOWED\n *     New stream cannot be created because GOAWAY is already sent or\n *     received.\n * NGHTTP2_ERR_PROTO\n *     The client side attempts to send PUSH_PROMISE, or the server\n *     sends PUSH_PROMISE for the stream not initiated by the client.\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_PUSH_DISABLED\n *     The remote peer disabled reception of PUSH_PROMISE.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_push_promise_send(nghttp2_session *session,\n                                               nghttp2_stream *stream) {\n  int rv;\n\n  if (!session->server) {\n    return NGHTTP2_ERR_PROTO;\n  }\n\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n\n  assert(stream);\n\n  if (session->remote_settings.enable_push == 0) {\n    return NGHTTP2_ERR_PUSH_DISABLED;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  if (session->goaway_flags & NGHTTP2_GOAWAY_RECV) {\n    return NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n  }\n  return 0;\n}\n\n/*\n * This function checks WINDOW_UPDATE with the stream ID |stream_id|\n * can be sent at this time. Note that END_STREAM flag of the previous\n * frame does not affect the transmission of the WINDOW_UPDATE frame.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_window_update_send(nghttp2_session *session,\n                                                int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n\n  if (stream_id == 0) {\n    /* Connection-level window update */\n    return 0;\n  }\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_STREAM_CLOSED;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  if (state_reserved_local(session, stream)) {\n    return NGHTTP2_ERR_INVALID_STREAM_STATE;\n  }\n  return 0;\n}\n\nstatic int session_predicate_altsvc_send(nghttp2_session *session,\n                                         int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n\n  if (stream_id == 0) {\n    return 0;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_STREAM_CLOSED;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n\n  return 0;\n}\n\nstatic int session_predicate_origin_send(nghttp2_session *session) {\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n  return 0;\n}\n\n/* Take into account settings max frame size and both connection-level\n   flow control here */\nstatic ssize_t\nnghttp2_session_enforce_flow_control_limits(nghttp2_session *session,\n                                            nghttp2_stream *stream,\n                                            ssize_t requested_window_size) {\n  DEBUGF(\"send: remote windowsize connection=%d, remote maxframsize=%u, \"\n         \"stream(id %d)=%d\\n\",\n         session->remote_window_size, session->remote_settings.max_frame_size,\n         stream->stream_id, stream->remote_window_size);\n\n  return nghttp2_min(nghttp2_min(nghttp2_min(requested_window_size,\n                                             stream->remote_window_size),\n                                 session->remote_window_size),\n                     (int32_t)session->remote_settings.max_frame_size);\n}\n\n/*\n * Returns the maximum length of next data read. If the\n * connection-level and/or stream-wise flow control are enabled, the\n * return value takes into account those current window sizes. The remote\n * settings for max frame size is also taken into account.\n */\nstatic size_t nghttp2_session_next_data_read(nghttp2_session *session,\n                                             nghttp2_stream *stream) {\n  ssize_t window_size;\n\n  window_size = nghttp2_session_enforce_flow_control_limits(\n      session, stream, NGHTTP2_DATA_PAYLOADLEN);\n\n  DEBUGF(\"send: available window=%zd\\n\", window_size);\n\n  return window_size > 0 ? (size_t)window_size : 0;\n}\n\n/*\n * This function checks DATA with the |stream| can be sent at this\n * time.  The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int nghttp2_session_predicate_data_send(nghttp2_session *session,\n                                               nghttp2_stream *stream) {\n  int rv;\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n  if (nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n    /* Request body data */\n    /* If stream->state is NGHTTP2_STREAM_CLOSING, RST_STREAM was\n       queued but not yet sent. In this case, we won't send DATA\n       frames. */\n    if (stream->state == NGHTTP2_STREAM_CLOSING) {\n      return NGHTTP2_ERR_STREAM_CLOSING;\n    }\n    if (stream->state == NGHTTP2_STREAM_RESERVED) {\n      return NGHTTP2_ERR_INVALID_STREAM_STATE;\n    }\n    return 0;\n  }\n  /* Response body data */\n  if (stream->state == NGHTTP2_STREAM_OPENED) {\n    return 0;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  return NGHTTP2_ERR_INVALID_STREAM_STATE;\n}\n\nstatic ssize_t session_call_select_padding(nghttp2_session *session,\n                                           const nghttp2_frame *frame,\n                                           size_t max_payloadlen) {\n  ssize_t rv;\n\n  if (frame->hd.length >= max_payloadlen) {\n    return (ssize_t)frame->hd.length;\n  }\n\n  if (session->callbacks.select_padding_callback) {\n    size_t max_paddedlen;\n\n    max_paddedlen =\n        nghttp2_min(frame->hd.length + NGHTTP2_MAX_PADLEN, max_payloadlen);\n\n    rv = session->callbacks.select_padding_callback(\n        session, frame, max_paddedlen, session->user_data);\n    if (rv < (ssize_t)frame->hd.length || rv > (ssize_t)max_paddedlen) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    return rv;\n  }\n  return (ssize_t)frame->hd.length;\n}\n\n/* Add padding to HEADERS or PUSH_PROMISE. We use\n   frame->headers.padlen in this function to use the fact that\n   frame->push_promise has also padlen in the same position. */\nstatic int session_headers_add_pad(nghttp2_session *session,\n                                   nghttp2_frame *frame) {\n  int rv;\n  ssize_t padded_payloadlen;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  size_t padlen;\n  size_t max_payloadlen;\n\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  max_payloadlen = nghttp2_min(NGHTTP2_MAX_PAYLOADLEN,\n                               frame->hd.length + NGHTTP2_MAX_PADLEN);\n\n  padded_payloadlen =\n      session_call_select_padding(session, frame, max_payloadlen);\n\n  if (nghttp2_is_fatal((int)padded_payloadlen)) {\n    return (int)padded_payloadlen;\n  }\n\n  padlen = (size_t)padded_payloadlen - frame->hd.length;\n\n  DEBUGF(\"send: padding selected: payloadlen=%zd, padlen=%zu\\n\",\n         padded_payloadlen, padlen);\n\n  rv = nghttp2_frame_add_pad(framebufs, &frame->hd, padlen, 0);\n\n  if (rv != 0) {\n    return rv;\n  }\n\n  frame->headers.padlen = padlen;\n\n  return 0;\n}\n\nstatic size_t session_estimate_headers_payload(nghttp2_session *session,\n                                               const nghttp2_nv *nva,\n                                               size_t nvlen,\n                                               size_t additional) {\n  return nghttp2_hd_deflate_bound(&session->hd_deflater, nva, nvlen) +\n         additional;\n}\n\nstatic int session_pack_extension(nghttp2_session *session, nghttp2_bufs *bufs,\n                                  nghttp2_frame *frame) {\n  ssize_t rv;\n  nghttp2_buf *buf;\n  size_t buflen;\n  size_t framelen;\n\n  assert(session->callbacks.pack_extension_callback);\n\n  buf = &bufs->head->buf;\n  buflen = nghttp2_min(nghttp2_buf_avail(buf), NGHTTP2_MAX_PAYLOADLEN);\n\n  rv = session->callbacks.pack_extension_callback(session, buf->last, buflen,\n                                                  frame, session->user_data);\n  if (rv == NGHTTP2_ERR_CANCEL) {\n    return (int)rv;\n  }\n\n  if (rv < 0 || (size_t)rv > buflen) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  framelen = (size_t)rv;\n\n  frame->hd.length = framelen;\n\n  assert(buf->pos == buf->last);\n  buf->last += framelen;\n  buf->pos -= NGHTTP2_FRAME_HDLEN;\n\n  nghttp2_frame_pack_frame_hd(buf->pos, &frame->hd);\n\n  return 0;\n}\n\n/*\n * This function serializes frame for transmission.\n *\n * This function returns 0 if it succeeds, or one of negative error\n * codes, including both fatal and non-fatal ones.\n */\nstatic int session_prep_frame(nghttp2_session *session,\n                              nghttp2_outbound_item *item) {\n  int rv;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  frame = &item->frame;\n\n  switch (frame->hd.type) {\n  case NGHTTP2_DATA: {\n    size_t next_readmax;\n    nghttp2_stream *stream;\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n    if (stream) {\n      assert(stream->item == item);\n    }\n\n    rv = nghttp2_session_predicate_data_send(session, stream);\n    if (rv != 0) {\n      // If stream was already closed, nghttp2_session_get_stream()\n      // returns NULL, but item is still attached to the stream.\n      // Search stream including closed again.\n      stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n      if (stream) {\n        int rv2;\n\n        rv2 = nghttp2_stream_detach_item(stream);\n\n        if (nghttp2_is_fatal(rv2)) {\n          return rv2;\n        }\n      }\n\n      return rv;\n    }\n    /* Assuming stream is not NULL */\n    assert(stream);\n    next_readmax = nghttp2_session_next_data_read(session, stream);\n\n    if (next_readmax == 0) {\n\n      /* This must be true since we only pop DATA frame item from\n         queue when session->remote_window_size > 0 */\n      assert(session->remote_window_size > 0);\n\n      rv = nghttp2_stream_defer_item(stream,\n                                     NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session->aob.item = NULL;\n      active_outbound_item_reset(&session->aob, mem);\n      return NGHTTP2_ERR_DEFERRED;\n    }\n\n    rv = nghttp2_session_pack_data(session, &session->aob.framebufs,\n                                   next_readmax, frame, &item->aux_data.data,\n                                   stream);\n    if (rv == NGHTTP2_ERR_PAUSE) {\n      return rv;\n    }\n    if (rv == NGHTTP2_ERR_DEFERRED) {\n      rv = nghttp2_stream_defer_item(stream, NGHTTP2_STREAM_FLAG_DEFERRED_USER);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session->aob.item = NULL;\n      active_outbound_item_reset(&session->aob, mem);\n      return NGHTTP2_ERR_DEFERRED;\n    }\n    if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n      rv = nghttp2_stream_detach_item(stream);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      rv = nghttp2_session_add_rst_stream(session, frame->hd.stream_id,\n                                          NGHTTP2_INTERNAL_ERROR);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n    if (rv != 0) {\n      int rv2;\n\n      rv2 = nghttp2_stream_detach_item(stream);\n\n      if (nghttp2_is_fatal(rv2)) {\n        return rv2;\n      }\n\n      return rv;\n    }\n    return 0;\n  }\n  case NGHTTP2_HEADERS: {\n    nghttp2_headers_aux_data *aux_data;\n    size_t estimated_payloadlen;\n\n    aux_data = &item->aux_data.headers;\n\n    if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n      /* initial HEADERS, which opens stream */\n      nghttp2_stream *stream;\n\n      stream = nghttp2_session_open_stream(\n          session, frame->hd.stream_id, NGHTTP2_STREAM_FLAG_NONE,\n          &frame->headers.pri_spec, NGHTTP2_STREAM_INITIAL,\n          aux_data->stream_user_data);\n\n      if (stream == NULL) {\n        return NGHTTP2_ERR_NOMEM;\n      }\n\n      /* We don't call nghttp2_session_adjust_closed_stream() here,\n         since we don't keep closed stream in client side */\n\n      rv = session_predicate_request_headers_send(session, item);\n      if (rv != 0) {\n        return rv;\n      }\n\n      if (session_enforce_http_messaging(session)) {\n        nghttp2_http_record_request_method(stream, frame);\n      }\n    } else {\n      nghttp2_stream *stream;\n\n      stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n      if (stream && stream->state == NGHTTP2_STREAM_RESERVED) {\n        rv = session_predicate_push_response_headers_send(session, stream);\n        if (rv == 0) {\n          frame->headers.cat = NGHTTP2_HCAT_PUSH_RESPONSE;\n\n          if (aux_data->stream_user_data) {\n            stream->stream_user_data = aux_data->stream_user_data;\n          }\n        }\n      } else if (session_predicate_response_headers_send(session, stream) ==\n                 0) {\n        frame->headers.cat = NGHTTP2_HCAT_RESPONSE;\n        rv = 0;\n      } else {\n        frame->headers.cat = NGHTTP2_HCAT_HEADERS;\n\n        rv = session_predicate_headers_send(session, stream);\n      }\n\n      if (rv != 0) {\n        return rv;\n      }\n    }\n\n    estimated_payloadlen = session_estimate_headers_payload(\n        session, frame->headers.nva, frame->headers.nvlen,\n        NGHTTP2_PRIORITY_SPECLEN);\n\n    if (estimated_payloadlen > session->max_send_header_block_length) {\n      return NGHTTP2_ERR_FRAME_SIZE_ERROR;\n    }\n\n    rv = nghttp2_frame_pack_headers(&session->aob.framebufs, &frame->headers,\n                                    &session->hd_deflater);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    DEBUGF(\"send: before padding, HEADERS serialized in %zd bytes\\n\",\n           nghttp2_bufs_len(&session->aob.framebufs));\n\n    rv = session_headers_add_pad(session, frame);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    DEBUGF(\"send: HEADERS finally serialized in %zd bytes\\n\",\n           nghttp2_bufs_len(&session->aob.framebufs));\n\n    if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n      assert(session->last_sent_stream_id < frame->hd.stream_id);\n      session->last_sent_stream_id = frame->hd.stream_id;\n    }\n\n    return 0;\n  }\n  case NGHTTP2_PRIORITY: {\n    if (session_is_closing(session)) {\n      return NGHTTP2_ERR_SESSION_CLOSING;\n    }\n    /* PRIORITY frame can be sent at any time and to any stream\n       ID. */\n    nghttp2_frame_pack_priority(&session->aob.framebufs, &frame->priority);\n\n    /* Peer can send PRIORITY frame against idle stream to create\n       \"anchor\" in dependency tree.  Only client can do this in\n       nghttp2.  In nghttp2, only server retains non-active (closed\n       or idle) streams in memory, so we don't open stream here. */\n    return 0;\n  }\n  case NGHTTP2_RST_STREAM:\n    if (session_is_closing(session)) {\n      return NGHTTP2_ERR_SESSION_CLOSING;\n    }\n    nghttp2_frame_pack_rst_stream(&session->aob.framebufs, &frame->rst_stream);\n    return 0;\n  case NGHTTP2_SETTINGS: {\n    if (frame->hd.flags & NGHTTP2_FLAG_ACK) {\n      assert(session->obq_flood_counter_ > 0);\n      --session->obq_flood_counter_;\n      /* When session is about to close, don't send SETTINGS ACK.\n         We are required to send SETTINGS without ACK though; for\n         example, we have to send SETTINGS as a part of connection\n         preface. */\n      if (session_is_closing(session)) {\n        return NGHTTP2_ERR_SESSION_CLOSING;\n      }\n    }\n\n    rv = nghttp2_frame_pack_settings(&session->aob.framebufs, &frame->settings);\n    if (rv != 0) {\n      return rv;\n    }\n    return 0;\n  }\n  case NGHTTP2_PUSH_PROMISE: {\n    nghttp2_stream *stream;\n    size_t estimated_payloadlen;\n\n    /* stream could be NULL if associated stream was already\n       closed. */\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n    /* predicate should fail if stream is NULL. */\n    rv = session_predicate_push_promise_send(session, stream);\n    if (rv != 0) {\n      return rv;\n    }\n\n    assert(stream);\n\n    estimated_payloadlen = session_estimate_headers_payload(\n        session, frame->push_promise.nva, frame->push_promise.nvlen, 0);\n\n    if (estimated_payloadlen > session->max_send_header_block_length) {\n      return NGHTTP2_ERR_FRAME_SIZE_ERROR;\n    }\n\n    rv = nghttp2_frame_pack_push_promise(\n        &session->aob.framebufs, &frame->push_promise, &session->hd_deflater);\n    if (rv != 0) {\n      return rv;\n    }\n    rv = session_headers_add_pad(session, frame);\n    if (rv != 0) {\n      return rv;\n    }\n\n    assert(session->last_sent_stream_id + 2 <=\n           frame->push_promise.promised_stream_id);\n    session->last_sent_stream_id = frame->push_promise.promised_stream_id;\n\n    return 0;\n  }\n  case NGHTTP2_PING:\n    if (frame->hd.flags & NGHTTP2_FLAG_ACK) {\n      assert(session->obq_flood_counter_ > 0);\n      --session->obq_flood_counter_;\n    }\n    /* PING frame is allowed to be sent unless termination GOAWAY is\n       sent */\n    if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND) {\n      return NGHTTP2_ERR_SESSION_CLOSING;\n    }\n    nghttp2_frame_pack_ping(&session->aob.framebufs, &frame->ping);\n    return 0;\n  case NGHTTP2_GOAWAY:\n    rv = nghttp2_frame_pack_goaway(&session->aob.framebufs, &frame->goaway);\n    if (rv != 0) {\n      return rv;\n    }\n    session->local_last_stream_id = frame->goaway.last_stream_id;\n\n    return 0;\n  case NGHTTP2_WINDOW_UPDATE:\n    rv = session_predicate_window_update_send(session, frame->hd.stream_id);\n    if (rv != 0) {\n      return rv;\n    }\n    nghttp2_frame_pack_window_update(&session->aob.framebufs,\n                                     &frame->window_update);\n    return 0;\n  case NGHTTP2_CONTINUATION:\n    /* We never handle CONTINUATION here. */\n    assert(0);\n    return 0;\n  default: {\n    nghttp2_ext_aux_data *aux_data;\n\n    /* extension frame */\n\n    aux_data = &item->aux_data.ext;\n\n    if (aux_data->builtin == 0) {\n      if (session_is_closing(session)) {\n        return NGHTTP2_ERR_SESSION_CLOSING;\n      }\n\n      return session_pack_extension(session, &session->aob.framebufs, frame);\n    }\n\n    switch (frame->hd.type) {\n    case NGHTTP2_ALTSVC:\n      rv = session_predicate_altsvc_send(session, frame->hd.stream_id);\n      if (rv != 0) {\n        return rv;\n      }\n\n      nghttp2_frame_pack_altsvc(&session->aob.framebufs, &frame->ext);\n\n      return 0;\n    case NGHTTP2_ORIGIN:\n      rv = session_predicate_origin_send(session);\n      if (rv != 0) {\n        return rv;\n      }\n\n      rv = nghttp2_frame_pack_origin(&session->aob.framebufs, &frame->ext);\n      if (rv != 0) {\n        return rv;\n      }\n\n      return 0;\n    default:\n      /* Unreachable here */\n      assert(0);\n      return 0;\n    }\n  }\n  }\n}\n\nnghttp2_outbound_item *\nnghttp2_session_get_next_ob_item(nghttp2_session *session) {\n  if (nghttp2_outbound_queue_top(&session->ob_urgent)) {\n    return nghttp2_outbound_queue_top(&session->ob_urgent);\n  }\n\n  if (nghttp2_outbound_queue_top(&session->ob_reg)) {\n    return nghttp2_outbound_queue_top(&session->ob_reg);\n  }\n\n  if (!session_is_outgoing_concurrent_streams_max(session)) {\n    if (nghttp2_outbound_queue_top(&session->ob_syn)) {\n      return nghttp2_outbound_queue_top(&session->ob_syn);\n    }\n  }\n\n  if (session->remote_window_size > 0) {\n    return nghttp2_stream_next_outbound_item(&session->root);\n  }\n\n  return NULL;\n}\n\nnghttp2_outbound_item *\nnghttp2_session_pop_next_ob_item(nghttp2_session *session) {\n  nghttp2_outbound_item *item;\n\n  item = nghttp2_outbound_queue_top(&session->ob_urgent);\n  if (item) {\n    nghttp2_outbound_queue_pop(&session->ob_urgent);\n    item->queued = 0;\n    return item;\n  }\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n  if (item) {\n    nghttp2_outbound_queue_pop(&session->ob_reg);\n    item->queued = 0;\n    return item;\n  }\n\n  if (!session_is_outgoing_concurrent_streams_max(session)) {\n    item = nghttp2_outbound_queue_top(&session->ob_syn);\n    if (item) {\n      nghttp2_outbound_queue_pop(&session->ob_syn);\n      item->queued = 0;\n      return item;\n    }\n  }\n\n  if (session->remote_window_size > 0) {\n    return nghttp2_stream_next_outbound_item(&session->root);\n  }\n\n  return NULL;\n}\n\nstatic int session_call_before_frame_send(nghttp2_session *session,\n                                          nghttp2_frame *frame) {\n  int rv;\n  if (session->callbacks.before_frame_send_callback) {\n    rv = session->callbacks.before_frame_send_callback(session, frame,\n                                                       session->user_data);\n    if (rv == NGHTTP2_ERR_CANCEL) {\n      return rv;\n    }\n\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_call_on_frame_send(nghttp2_session *session,\n                                      nghttp2_frame *frame) {\n  int rv;\n  if (session->callbacks.on_frame_send_callback) {\n    rv = session->callbacks.on_frame_send_callback(session, frame,\n                                                   session->user_data);\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int find_stream_on_goaway_func(nghttp2_map_entry *entry, void *ptr) {\n  nghttp2_close_stream_on_goaway_arg *arg;\n  nghttp2_stream *stream;\n\n  arg = (nghttp2_close_stream_on_goaway_arg *)ptr;\n  stream = (nghttp2_stream *)entry;\n\n  if (nghttp2_session_is_my_stream_id(arg->session, stream->stream_id)) {\n    if (arg->incoming) {\n      return 0;\n    }\n  } else if (!arg->incoming) {\n    return 0;\n  }\n\n  if (stream->state != NGHTTP2_STREAM_IDLE &&\n      (stream->flags & NGHTTP2_STREAM_FLAG_CLOSED) == 0 &&\n      stream->stream_id > arg->last_stream_id) {\n    /* We are collecting streams to close because we cannot call\n       nghttp2_session_close_stream() inside nghttp2_map_each().\n       Reuse closed_next member.. bad choice? */\n    assert(stream->closed_next == NULL);\n    assert(stream->closed_prev == NULL);\n\n    if (arg->head) {\n      stream->closed_next = arg->head;\n      arg->head = stream;\n    } else {\n      arg->head = stream;\n    }\n  }\n\n  return 0;\n}\n\n/* Closes non-idle and non-closed streams whose stream ID >\n   last_stream_id.  If incoming is nonzero, we are going to close\n   incoming streams.  Otherwise, close outgoing streams. */\nstatic int session_close_stream_on_goaway(nghttp2_session *session,\n                                          int32_t last_stream_id,\n                                          int incoming) {\n  int rv;\n  nghttp2_stream *stream, *next_stream;\n  nghttp2_close_stream_on_goaway_arg arg = {session, NULL, last_stream_id,\n                                            incoming};\n\n  rv = nghttp2_map_each(&session->streams, find_stream_on_goaway_func, &arg);\n  assert(rv == 0);\n\n  stream = arg.head;\n  while (stream) {\n    next_stream = stream->closed_next;\n    stream->closed_next = NULL;\n    rv = nghttp2_session_close_stream(session, stream->stream_id,\n                                      NGHTTP2_REFUSED_STREAM);\n\n    /* stream may be deleted here */\n\n    stream = next_stream;\n\n    if (nghttp2_is_fatal(rv)) {\n      /* Clean up closed_next member just in case */\n      while (stream) {\n        next_stream = stream->closed_next;\n        stream->closed_next = NULL;\n        stream = next_stream;\n      }\n      return rv;\n    }\n  }\n\n  return 0;\n}\n\nstatic void reschedule_stream(nghttp2_stream *stream) {\n  stream->last_writelen = stream->item->frame.hd.length;\n\n  nghttp2_stream_reschedule(stream);\n}\n\nstatic int session_update_stream_consumed_size(nghttp2_session *session,\n                                               nghttp2_stream *stream,\n                                               size_t delta_size);\n\nstatic int session_update_connection_consumed_size(nghttp2_session *session,\n                                                   size_t delta_size);\n\n/*\n * Called after a frame is sent.  This function runs\n * on_frame_send_callback and handles stream closure upon END_STREAM\n * or RST_STREAM.  This function does not reset session->aob.  It is a\n * responsibility of session_after_frame_sent2.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nstatic int session_after_frame_sent1(nghttp2_session *session) {\n  int rv;\n  nghttp2_active_outbound_item *aob = &session->aob;\n  nghttp2_outbound_item *item = aob->item;\n  nghttp2_bufs *framebufs = &aob->framebufs;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n\n  frame = &item->frame;\n\n  if (frame->hd.type == NGHTTP2_DATA) {\n    nghttp2_data_aux_data *aux_data;\n\n    aux_data = &item->aux_data.data;\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    /* We update flow control window after a frame was completely\n       sent. This is possible because we choose payload length not to\n       exceed the window */\n    session->remote_window_size -= (int32_t)frame->hd.length;\n    if (stream) {\n      stream->remote_window_size -= (int32_t)frame->hd.length;\n    }\n\n    if (stream && aux_data->eof) {\n      rv = nghttp2_stream_detach_item(stream);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      /* Call on_frame_send_callback after\n         nghttp2_stream_detach_item(), so that application can issue\n         nghttp2_submit_data() in the callback. */\n      if (session->callbacks.on_frame_send_callback) {\n        rv = session_call_on_frame_send(session, frame);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      }\n\n      if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n        int stream_closed;\n\n        stream_closed =\n            (stream->shut_flags & NGHTTP2_SHUT_RDWR) == NGHTTP2_SHUT_RDWR;\n\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n\n        rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        /* stream may be NULL if it was closed */\n        if (stream_closed) {\n          stream = NULL;\n        }\n      }\n      return 0;\n    }\n\n    if (session->callbacks.on_frame_send_callback) {\n      rv = session_call_on_frame_send(session, frame);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    return 0;\n  }\n\n  /* non-DATA frame */\n\n  if (frame->hd.type == NGHTTP2_HEADERS ||\n      frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n    if (nghttp2_bufs_next_present(framebufs)) {\n      DEBUGF(\"send: CONTINUATION exists, just return\\n\");\n      return 0;\n    }\n  }\n  rv = session_call_on_frame_send(session, frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  switch (frame->hd.type) {\n  case NGHTTP2_HEADERS: {\n    nghttp2_headers_aux_data *aux_data;\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n      return 0;\n    }\n\n    switch (frame->headers.cat) {\n    case NGHTTP2_HCAT_REQUEST: {\n      stream->state = NGHTTP2_STREAM_OPENING;\n      if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n      }\n      rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      /* We assume aux_data is a pointer to nghttp2_headers_aux_data */\n      aux_data = &item->aux_data.headers;\n      if (aux_data->data_prd.read_callback) {\n        /* nghttp2_submit_data() makes a copy of aux_data->data_prd */\n        rv = nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM,\n                                 frame->hd.stream_id, &aux_data->data_prd);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        /* TODO nghttp2_submit_data() may fail if stream has already\n           DATA frame item.  We might have to handle it here. */\n      }\n      return 0;\n    }\n    case NGHTTP2_HCAT_PUSH_RESPONSE:\n      stream->flags = (uint8_t)(stream->flags & ~NGHTTP2_STREAM_FLAG_PUSH);\n      ++session->num_outgoing_streams;\n    /* Fall through */\n    case NGHTTP2_HCAT_RESPONSE:\n      stream->state = NGHTTP2_STREAM_OPENED;\n    /* Fall through */\n    case NGHTTP2_HCAT_HEADERS:\n      if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n      }\n      rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      /* We assume aux_data is a pointer to nghttp2_headers_aux_data */\n      aux_data = &item->aux_data.headers;\n      if (aux_data->data_prd.read_callback) {\n        rv = nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM,\n                                 frame->hd.stream_id, &aux_data->data_prd);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        /* TODO nghttp2_submit_data() may fail if stream has already\n           DATA frame item.  We might have to handle it here. */\n      }\n      return 0;\n    default:\n      /* Unreachable */\n      assert(0);\n      return 0;\n    }\n  }\n  case NGHTTP2_PRIORITY:\n    if (session->server) {\n      return 0;\n      ;\n    }\n\n    stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n\n    if (!stream) {\n      if (!session_detect_idle_stream(session, frame->hd.stream_id)) {\n        return 0;\n      }\n\n      stream = nghttp2_session_open_stream(\n          session, frame->hd.stream_id, NGHTTP2_FLAG_NONE,\n          &frame->priority.pri_spec, NGHTTP2_STREAM_IDLE, NULL);\n      if (!stream) {\n        return NGHTTP2_ERR_NOMEM;\n      }\n    } else {\n      rv = nghttp2_session_reprioritize_stream(session, stream,\n                                               &frame->priority.pri_spec);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    rv = nghttp2_session_adjust_idle_stream(session);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n\n    return 0;\n  case NGHTTP2_RST_STREAM:\n    rv = nghttp2_session_close_stream(session, frame->hd.stream_id,\n                                      frame->rst_stream.error_code);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n    return 0;\n  case NGHTTP2_GOAWAY: {\n    nghttp2_goaway_aux_data *aux_data;\n\n    aux_data = &item->aux_data.goaway;\n\n    if ((aux_data->flags & NGHTTP2_GOAWAY_AUX_SHUTDOWN_NOTICE) == 0) {\n\n      if (aux_data->flags & NGHTTP2_GOAWAY_AUX_TERM_ON_SEND) {\n        session->goaway_flags |= NGHTTP2_GOAWAY_TERM_SENT;\n      }\n\n      session->goaway_flags |= NGHTTP2_GOAWAY_SENT;\n\n      rv = session_close_stream_on_goaway(session, frame->goaway.last_stream_id,\n                                          1);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    return 0;\n  }\n  case NGHTTP2_WINDOW_UPDATE:\n    if (frame->hd.stream_id == 0) {\n      session->window_update_queued = 0;\n      if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n        rv = session_update_connection_consumed_size(session, 0);\n      } else {\n        rv = nghttp2_session_update_recv_connection_window_size(session, 0);\n      }\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      return 0;\n    }\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n      return 0;\n    }\n\n    stream->window_update_queued = 0;\n\n    /* We don't have to send WINDOW_UPDATE if END_STREAM from peer\n       is seen. */\n    if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n      return 0;\n    }\n\n    if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n      rv = session_update_stream_consumed_size(session, stream, 0);\n    } else {\n      rv =\n          nghttp2_session_update_recv_stream_window_size(session, stream, 0, 1);\n    }\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n\n    return 0;\n  default:\n    return 0;\n  }\n}\n\n/*\n * Called after a frame is sent and session_after_frame_sent1.  This\n * function is responsible to reset session->aob.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nstatic int session_after_frame_sent2(nghttp2_session *session) {\n  int rv;\n  nghttp2_active_outbound_item *aob = &session->aob;\n  nghttp2_outbound_item *item = aob->item;\n  nghttp2_bufs *framebufs = &aob->framebufs;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n  nghttp2_stream *stream;\n  nghttp2_data_aux_data *aux_data;\n\n  mem = &session->mem;\n  frame = &item->frame;\n\n  if (frame->hd.type != NGHTTP2_DATA) {\n\n    if (frame->hd.type == NGHTTP2_HEADERS ||\n        frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n\n      if (nghttp2_bufs_next_present(framebufs)) {\n        framebufs->cur = framebufs->cur->next;\n\n        DEBUGF(\"send: next CONTINUATION frame, %zu bytes\\n\",\n               nghttp2_buf_len(&framebufs->cur->buf));\n\n        return 0;\n      }\n    }\n\n    active_outbound_item_reset(&session->aob, mem);\n\n    return 0;\n  }\n\n  /* DATA frame */\n\n  aux_data = &item->aux_data.data;\n\n  /* On EOF, we have already detached data.  Please note that\n     application may issue nghttp2_submit_data() in\n     on_frame_send_callback (call from session_after_frame_sent1),\n     which attach data to stream.  We don't want to detach it. */\n  if (aux_data->eof) {\n    active_outbound_item_reset(aob, mem);\n\n    return 0;\n  }\n\n  /* Reset no_copy here because next write may not use this. */\n  aux_data->no_copy = 0;\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n  /* If session is closed or RST_STREAM was queued, we won't send\n     further data. */\n  if (nghttp2_session_predicate_data_send(session, stream) != 0) {\n    if (stream) {\n      rv = nghttp2_stream_detach_item(stream);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    active_outbound_item_reset(aob, mem);\n\n    return 0;\n  }\n\n  aob->item = NULL;\n  active_outbound_item_reset(&session->aob, mem);\n\n  return 0;\n}\n\nstatic int session_call_send_data(nghttp2_session *session,\n                                  nghttp2_outbound_item *item,\n                                  nghttp2_bufs *framebufs) {\n  int rv;\n  nghttp2_buf *buf;\n  size_t length;\n  nghttp2_frame *frame;\n  nghttp2_data_aux_data *aux_data;\n\n  buf = &framebufs->cur->buf;\n  frame = &item->frame;\n  length = frame->hd.length - frame->data.padlen;\n  aux_data = &item->aux_data.data;\n\n  rv = session->callbacks.send_data_callback(session, frame, buf->pos, length,\n                                             &aux_data->data_prd.source,\n                                             session->user_data);\n\n  switch (rv) {\n  case 0:\n  case NGHTTP2_ERR_WOULDBLOCK:\n  case NGHTTP2_ERR_PAUSE:\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return rv;\n  default:\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n}\n\nstatic ssize_t nghttp2_session_mem_send_internal(nghttp2_session *session,\n                                                 const uint8_t **data_ptr,\n                                                 int fast_cb) {\n  int rv;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  /* We may have idle streams more than we expect (e.g.,\n     nghttp2_session_change_stream_priority() or\n     nghttp2_session_create_idle_stream()).  Adjust them here. */\n  rv = nghttp2_session_adjust_idle_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  for (;;) {\n    switch (aob->state) {\n    case NGHTTP2_OB_POP_ITEM: {\n      nghttp2_outbound_item *item;\n\n      item = nghttp2_session_pop_next_ob_item(session);\n      if (item == NULL) {\n        return 0;\n      }\n\n      rv = session_prep_frame(session, item);\n      if (rv == NGHTTP2_ERR_PAUSE) {\n        return 0;\n      }\n      if (rv == NGHTTP2_ERR_DEFERRED) {\n        DEBUGF(\"send: frame transmission deferred\\n\");\n        break;\n      }\n      if (rv < 0) {\n        int32_t opened_stream_id = 0;\n        uint32_t error_code = NGHTTP2_INTERNAL_ERROR;\n\n        DEBUGF(\"send: frame preparation failed with %s\\n\",\n               nghttp2_strerror(rv));\n        /* TODO If the error comes from compressor, the connection\n           must be closed. */\n        if (item->frame.hd.type != NGHTTP2_DATA &&\n            session->callbacks.on_frame_not_send_callback && is_non_fatal(rv)) {\n          nghttp2_frame *frame = &item->frame;\n          /* The library is responsible for the transmission of\n             WINDOW_UPDATE frame, so we don't call error callback for\n             it. */\n          if (frame->hd.type != NGHTTP2_WINDOW_UPDATE &&\n              session->callbacks.on_frame_not_send_callback(\n                  session, frame, rv, session->user_data) != 0) {\n\n            nghttp2_outbound_item_free(item, mem);\n            nghttp2_mem_free(mem, item);\n\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n          }\n        }\n        /* We have to close stream opened by failed request HEADERS\n           or PUSH_PROMISE. */\n        switch (item->frame.hd.type) {\n        case NGHTTP2_HEADERS:\n          if (item->frame.headers.cat == NGHTTP2_HCAT_REQUEST) {\n            opened_stream_id = item->frame.hd.stream_id;\n            if (item->aux_data.headers.canceled) {\n              error_code = item->aux_data.headers.error_code;\n            } else {\n              /* Set error_code to REFUSED_STREAM so that application\n                 can send request again. */\n              error_code = NGHTTP2_REFUSED_STREAM;\n            }\n          }\n          break;\n        case NGHTTP2_PUSH_PROMISE:\n          opened_stream_id = item->frame.push_promise.promised_stream_id;\n          break;\n        }\n        if (opened_stream_id) {\n          /* careful not to override rv */\n          int rv2;\n          rv2 = nghttp2_session_close_stream(session, opened_stream_id,\n                                             error_code);\n\n          if (nghttp2_is_fatal(rv2)) {\n            return rv2;\n          }\n        }\n\n        nghttp2_outbound_item_free(item, mem);\n        nghttp2_mem_free(mem, item);\n        active_outbound_item_reset(aob, mem);\n\n        if (rv == NGHTTP2_ERR_HEADER_COMP) {\n          /* If header compression error occurred, should terminiate\n             connection. */\n          rv = nghttp2_session_terminate_session(session,\n                                                 NGHTTP2_INTERNAL_ERROR);\n        }\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        break;\n      }\n\n      aob->item = item;\n\n      nghttp2_bufs_rewind(framebufs);\n\n      if (item->frame.hd.type != NGHTTP2_DATA) {\n        nghttp2_frame *frame;\n\n        frame = &item->frame;\n\n        DEBUGF(\"send: next frame: payloadlen=%zu, type=%u, flags=0x%02x, \"\n               \"stream_id=%d\\n\",\n               frame->hd.length, frame->hd.type, frame->hd.flags,\n               frame->hd.stream_id);\n\n        rv = session_call_before_frame_send(session, frame);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (rv == NGHTTP2_ERR_CANCEL) {\n          int32_t opened_stream_id = 0;\n          uint32_t error_code = NGHTTP2_INTERNAL_ERROR;\n\n          if (session->callbacks.on_frame_not_send_callback) {\n            if (session->callbacks.on_frame_not_send_callback(\n                    session, frame, rv, session->user_data) != 0) {\n              return NGHTTP2_ERR_CALLBACK_FAILURE;\n            }\n          }\n\n          /* We have to close stream opened by canceled request\n             HEADERS or PUSH_PROMISE. */\n          switch (item->frame.hd.type) {\n          case NGHTTP2_HEADERS:\n            if (item->frame.headers.cat == NGHTTP2_HCAT_REQUEST) {\n              opened_stream_id = item->frame.hd.stream_id;\n              /* We don't have to check\n                 item->aux_data.headers.canceled since it has already\n                 been checked. */\n              /* Set error_code to REFUSED_STREAM so that application\n                 can send request again. */\n              error_code = NGHTTP2_REFUSED_STREAM;\n            }\n            break;\n          case NGHTTP2_PUSH_PROMISE:\n            opened_stream_id = item->frame.push_promise.promised_stream_id;\n            break;\n          }\n          if (opened_stream_id) {\n            /* careful not to override rv */\n            int rv2;\n            rv2 = nghttp2_session_close_stream(session, opened_stream_id,\n                                               error_code);\n\n            if (nghttp2_is_fatal(rv2)) {\n              return rv2;\n            }\n          }\n\n          active_outbound_item_reset(aob, mem);\n\n          break;\n        }\n      } else {\n        DEBUGF(\"send: next frame: DATA\\n\");\n\n        if (item->aux_data.data.no_copy) {\n          aob->state = NGHTTP2_OB_SEND_NO_COPY;\n          break;\n        }\n      }\n\n      DEBUGF(\"send: start transmitting frame type=%u, length=%zd\\n\",\n             framebufs->cur->buf.pos[3],\n             framebufs->cur->buf.last - framebufs->cur->buf.pos);\n\n      aob->state = NGHTTP2_OB_SEND_DATA;\n\n      break;\n    }\n    case NGHTTP2_OB_SEND_DATA: {\n      size_t datalen;\n      nghttp2_buf *buf;\n\n      buf = &framebufs->cur->buf;\n\n      if (buf->pos == buf->last) {\n        DEBUGF(\"send: end transmission of a frame\\n\");\n\n        /* Frame has completely sent */\n        if (fast_cb) {\n          rv = session_after_frame_sent2(session);\n        } else {\n          rv = session_after_frame_sent1(session);\n          if (rv < 0) {\n            /* FATAL */\n            assert(nghttp2_is_fatal(rv));\n            return rv;\n          }\n          rv = session_after_frame_sent2(session);\n        }\n        if (rv < 0) {\n          /* FATAL */\n          assert(nghttp2_is_fatal(rv));\n          return rv;\n        }\n        /* We have already adjusted the next state */\n        break;\n      }\n\n      *data_ptr = buf->pos;\n      datalen = nghttp2_buf_len(buf);\n\n      /* We increment the offset here. If send_callback does not send\n         everything, we will adjust it. */\n      buf->pos += datalen;\n\n      return (ssize_t)datalen;\n    }\n    case NGHTTP2_OB_SEND_NO_COPY: {\n      nghttp2_stream *stream;\n      nghttp2_frame *frame;\n      int pause;\n\n      DEBUGF(\"send: no copy DATA\\n\");\n\n      frame = &aob->item->frame;\n\n      stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n      if (stream == NULL) {\n        DEBUGF(\"send: no copy DATA cancelled because stream was closed\\n\");\n\n        active_outbound_item_reset(aob, mem);\n\n        break;\n      }\n\n      rv = session_call_send_data(session, aob->item, framebufs);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n        rv = nghttp2_stream_detach_item(stream);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = nghttp2_session_add_rst_stream(session, frame->hd.stream_id,\n                                            NGHTTP2_INTERNAL_ERROR);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        active_outbound_item_reset(aob, mem);\n\n        break;\n      }\n\n      if (rv == NGHTTP2_ERR_WOULDBLOCK) {\n        return 0;\n      }\n\n      pause = (rv == NGHTTP2_ERR_PAUSE);\n\n      rv = session_after_frame_sent1(session);\n      if (rv < 0) {\n        assert(nghttp2_is_fatal(rv));\n        return rv;\n      }\n      rv = session_after_frame_sent2(session);\n      if (rv < 0) {\n        assert(nghttp2_is_fatal(rv));\n        return rv;\n      }\n\n      /* We have already adjusted the next state */\n\n      if (pause) {\n        return 0;\n      }\n\n      break;\n    }\n    case NGHTTP2_OB_SEND_CLIENT_MAGIC: {\n      size_t datalen;\n      nghttp2_buf *buf;\n\n      buf = &framebufs->cur->buf;\n\n      if (buf->pos == buf->last) {\n        DEBUGF(\"send: end transmission of client magic\\n\");\n        active_outbound_item_reset(aob, mem);\n        break;\n      }\n\n      *data_ptr = buf->pos;\n      datalen = nghttp2_buf_len(buf);\n\n      buf->pos += datalen;\n\n      return (ssize_t)datalen;\n    }\n    }\n  }\n}\n\nssize_t nghttp2_session_mem_send(nghttp2_session *session,\n                                 const uint8_t **data_ptr) {\n  int rv;\n  ssize_t len;\n\n  *data_ptr = NULL;\n\n  len = nghttp2_session_mem_send_internal(session, data_ptr, 1);\n  if (len <= 0) {\n    return len;\n  }\n\n  if (session->aob.item) {\n    /* We have to call session_after_frame_sent1 here to handle stream\n       closure upon transmission of frames.  Otherwise, END_STREAM may\n       be reached to client before we call nghttp2_session_mem_send\n       again and we may get exceeding number of incoming streams. */\n    rv = session_after_frame_sent1(session);\n    if (rv < 0) {\n      assert(nghttp2_is_fatal(rv));\n      return (ssize_t)rv;\n    }\n  }\n\n  return len;\n}\n\nint nghttp2_session_send(nghttp2_session *session) {\n  const uint8_t *data = NULL;\n  ssize_t datalen;\n  ssize_t sentlen;\n  nghttp2_bufs *framebufs;\n\n  framebufs = &session->aob.framebufs;\n\n  for (;;) {\n    datalen = nghttp2_session_mem_send_internal(session, &data, 0);\n    if (datalen <= 0) {\n      return (int)datalen;\n    }\n    sentlen = session->callbacks.send_callback(session, data, (size_t)datalen,\n                                               0, session->user_data);\n    if (sentlen < 0) {\n      if (sentlen == NGHTTP2_ERR_WOULDBLOCK) {\n        /* Transmission canceled. Rewind the offset */\n        framebufs->cur->buf.pos -= datalen;\n\n        return 0;\n      }\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    /* Rewind the offset to the amount of unsent bytes */\n    framebufs->cur->buf.pos -= datalen - sentlen;\n  }\n}\n\nstatic ssize_t session_recv(nghttp2_session *session, uint8_t *buf,\n                            size_t len) {\n  ssize_t rv;\n  rv = session->callbacks.recv_callback(session, buf, len, 0,\n                                        session->user_data);\n  if (rv > 0) {\n    if ((size_t)rv > len) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  } else if (rv < 0 && rv != NGHTTP2_ERR_WOULDBLOCK && rv != NGHTTP2_ERR_EOF) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n  return rv;\n}\n\nstatic int session_call_on_begin_frame(nghttp2_session *session,\n                                       const nghttp2_frame_hd *hd) {\n  int rv;\n\n  if (session->callbacks.on_begin_frame_callback) {\n\n    rv = session->callbacks.on_begin_frame_callback(session, hd,\n                                                    session->user_data);\n\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n\n  return 0;\n}\n\nstatic int session_call_on_frame_received(nghttp2_session *session,\n                                          nghttp2_frame *frame) {\n  int rv;\n  if (session->callbacks.on_frame_recv_callback) {\n    rv = session->callbacks.on_frame_recv_callback(session, frame,\n                                                   session->user_data);\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_call_on_begin_headers(nghttp2_session *session,\n                                         nghttp2_frame *frame) {\n  int rv;\n  DEBUGF(\"recv: call on_begin_headers callback stream_id=%d\\n\",\n         frame->hd.stream_id);\n  if (session->callbacks.on_begin_headers_callback) {\n    rv = session->callbacks.on_begin_headers_callback(session, frame,\n                                                      session->user_data);\n    if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n      return rv;\n    }\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_call_on_header(nghttp2_session *session,\n                                  const nghttp2_frame *frame,\n                                  const nghttp2_hd_nv *nv) {\n  int rv = 0;\n  if (session->callbacks.on_header_callback2) {\n    rv = session->callbacks.on_header_callback2(\n        session, frame, nv->name, nv->value, nv->flags, session->user_data);\n  } else if (session->callbacks.on_header_callback) {\n    rv = session->callbacks.on_header_callback(\n        session, frame, nv->name->base, nv->name->len, nv->value->base,\n        nv->value->len, nv->flags, session->user_data);\n  }\n\n  if (rv == NGHTTP2_ERR_PAUSE || rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n    return rv;\n  }\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  return 0;\n}\n\nstatic int session_call_on_invalid_header(nghttp2_session *session,\n                                          const nghttp2_frame *frame,\n                                          const nghttp2_hd_nv *nv) {\n  int rv;\n  if (session->callbacks.on_invalid_header_callback2) {\n    rv = session->callbacks.on_invalid_header_callback2(\n        session, frame, nv->name, nv->value, nv->flags, session->user_data);\n  } else if (session->callbacks.on_invalid_header_callback) {\n    rv = session->callbacks.on_invalid_header_callback(\n        session, frame, nv->name->base, nv->name->len, nv->value->base,\n        nv->value->len, nv->flags, session->user_data);\n  } else {\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  }\n\n  if (rv == NGHTTP2_ERR_PAUSE || rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n    return rv;\n  }\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  return 0;\n}\n\nstatic int\nsession_call_on_extension_chunk_recv_callback(nghttp2_session *session,\n                                              const uint8_t *data, size_t len) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  if (session->callbacks.on_extension_chunk_recv_callback) {\n    rv = session->callbacks.on_extension_chunk_recv_callback(\n        session, &frame->hd, data, len, session->user_data);\n    if (rv == NGHTTP2_ERR_CANCEL) {\n      return rv;\n    }\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n\n  return 0;\n}\n\nstatic int session_call_unpack_extension_callback(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  void *payload = NULL;\n\n  rv = session->callbacks.unpack_extension_callback(\n      session, &payload, &frame->hd, session->user_data);\n  if (rv == NGHTTP2_ERR_CANCEL) {\n    return rv;\n  }\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  frame->ext.payload = payload;\n\n  return 0;\n}\n\n/*\n * Handles frame size error.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *   Out of memory.\n */\nstatic int session_handle_frame_size_error(nghttp2_session *session) {\n  /* TODO Currently no callback is called for this error, because we\n     call this callback before reading any payload */\n  return nghttp2_session_terminate_session(session, NGHTTP2_FRAME_SIZE_ERROR);\n}\n\nstatic uint32_t get_error_code_from_lib_error_code(int lib_error_code) {\n  switch (lib_error_code) {\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return NGHTTP2_STREAM_CLOSED;\n  case NGHTTP2_ERR_HEADER_COMP:\n    return NGHTTP2_COMPRESSION_ERROR;\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return NGHTTP2_FRAME_SIZE_ERROR;\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return NGHTTP2_FLOW_CONTROL_ERROR;\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return NGHTTP2_REFUSED_STREAM;\n  case NGHTTP2_ERR_PROTO:\n  case NGHTTP2_ERR_HTTP_HEADER:\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return NGHTTP2_PROTOCOL_ERROR;\n  default:\n    return NGHTTP2_INTERNAL_ERROR;\n  }\n}\n\n/*\n * Calls on_invalid_frame_recv_callback if it is set to |session|.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *   User defined callback function fails.\n */\nstatic int session_call_on_invalid_frame_recv_callback(nghttp2_session *session,\n                                                       nghttp2_frame *frame,\n                                                       int lib_error_code) {\n  if (session->callbacks.on_invalid_frame_recv_callback) {\n    if (session->callbacks.on_invalid_frame_recv_callback(\n            session, frame, lib_error_code, session->user_data) != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_handle_invalid_stream2(nghttp2_session *session,\n                                          int32_t stream_id,\n                                          nghttp2_frame *frame,\n                                          int lib_error_code) {\n  int rv;\n  rv = nghttp2_session_add_rst_stream(\n      session, stream_id, get_error_code_from_lib_error_code(lib_error_code));\n  if (rv != 0) {\n    return rv;\n  }\n  if (session->callbacks.on_invalid_frame_recv_callback) {\n    if (session->callbacks.on_invalid_frame_recv_callback(\n            session, frame, lib_error_code, session->user_data) != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_handle_invalid_stream(nghttp2_session *session,\n                                         nghttp2_frame *frame,\n                                         int lib_error_code) {\n  return session_handle_invalid_stream2(session, frame->hd.stream_id, frame,\n                                        lib_error_code);\n}\n\nstatic int session_inflate_handle_invalid_stream(nghttp2_session *session,\n                                                 nghttp2_frame *frame,\n                                                 int lib_error_code) {\n  int rv;\n  rv = session_handle_invalid_stream(session, frame, lib_error_code);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n}\n\n/*\n * Handles invalid frame which causes connection error.\n */\nstatic int session_handle_invalid_connection(nghttp2_session *session,\n                                             nghttp2_frame *frame,\n                                             int lib_error_code,\n                                             const char *reason) {\n  if (session->callbacks.on_invalid_frame_recv_callback) {\n    if (session->callbacks.on_invalid_frame_recv_callback(\n            session, frame, lib_error_code, session->user_data) != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return nghttp2_session_terminate_session_with_reason(\n      session, get_error_code_from_lib_error_code(lib_error_code), reason);\n}\n\nstatic int session_inflate_handle_invalid_connection(nghttp2_session *session,\n                                                     nghttp2_frame *frame,\n                                                     int lib_error_code,\n                                                     const char *reason) {\n  int rv;\n  rv =\n      session_handle_invalid_connection(session, frame, lib_error_code, reason);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n}\n\n/*\n * Inflates header block in the memory pointed by |in| with |inlen|\n * bytes. If this function returns NGHTTP2_ERR_PAUSE, the caller must\n * call this function again, until it returns 0 or one of negative\n * error code.  If |call_header_cb| is zero, the on_header_callback\n * are not invoked and the function never return NGHTTP2_ERR_PAUSE. If\n * the given |in| is the last chunk of header block, the |final| must\n * be nonzero. If header block is successfully processed (which is\n * indicated by the return value 0, NGHTTP2_ERR_PAUSE or\n * NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE), the number of processed\n * input bytes is assigned to the |*readlen_ptr|.\n *\n * This function return 0 if it succeeds, or one of the negative error\n * codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n * NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE\n *     The callback returns this error code, indicating that this\n *     stream should be RST_STREAMed.\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_PAUSE\n *     The callback function returned NGHTTP2_ERR_PAUSE\n * NGHTTP2_ERR_HEADER_COMP\n *     Header decompression failed\n */\nstatic int inflate_header_block(nghttp2_session *session, nghttp2_frame *frame,\n                                size_t *readlen_ptr, uint8_t *in, size_t inlen,\n                                int final, int call_header_cb) {\n  ssize_t proclen;\n  int rv;\n  int inflate_flags;\n  nghttp2_hd_nv nv;\n  nghttp2_stream *stream;\n  nghttp2_stream *subject_stream;\n  int trailer = 0;\n\n  *readlen_ptr = 0;\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n  if (frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n    subject_stream = nghttp2_session_get_stream(\n        session, frame->push_promise.promised_stream_id);\n  } else {\n    subject_stream = stream;\n    trailer = session_trailer_headers(session, stream, frame);\n  }\n\n  DEBUGF(\"recv: decoding header block %zu bytes\\n\", inlen);\n  for (;;) {\n    inflate_flags = 0;\n    proclen = nghttp2_hd_inflate_hd_nv(&session->hd_inflater, &nv,\n                                       &inflate_flags, in, inlen, final);\n    if (nghttp2_is_fatal((int)proclen)) {\n      return (int)proclen;\n    }\n    if (proclen < 0) {\n      if (session->iframe.state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n        if (subject_stream && subject_stream->state != NGHTTP2_STREAM_CLOSING) {\n          /* Adding RST_STREAM here is very important. It prevents\n             from invoking subsequent callbacks for the same stream\n             ID. */\n          rv = nghttp2_session_add_rst_stream(\n              session, subject_stream->stream_id, NGHTTP2_COMPRESSION_ERROR);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n      }\n      rv =\n          nghttp2_session_terminate_session(session, NGHTTP2_COMPRESSION_ERROR);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      return NGHTTP2_ERR_HEADER_COMP;\n    }\n    in += proclen;\n    inlen -= (size_t)proclen;\n    *readlen_ptr += (size_t)proclen;\n\n    DEBUGF(\"recv: proclen=%zd\\n\", proclen);\n\n    if (call_header_cb && (inflate_flags & NGHTTP2_HD_INFLATE_EMIT)) {\n      rv = 0;\n      if (subject_stream) {\n        if (session_enforce_http_messaging(session)) {\n          rv = nghttp2_http_on_header(session, subject_stream, frame, &nv,\n                                      trailer);\n\n          if (rv == NGHTTP2_ERR_IGN_HTTP_HEADER) {\n            /* Don't overwrite rv here */\n            int rv2;\n\n            rv2 = session_call_on_invalid_header(session, frame, &nv);\n            if (rv2 == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n              rv = NGHTTP2_ERR_HTTP_HEADER;\n            } else {\n              if (rv2 != 0) {\n                return rv2;\n              }\n\n              /* header is ignored */\n              DEBUGF(\"recv: HTTP ignored: type=%u, id=%d, header %.*s: %.*s\\n\",\n                     frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                     nv.name->base, (int)nv.value->len, nv.value->base);\n\n              rv2 = session_call_error_callback(\n                  session, NGHTTP2_ERR_HTTP_HEADER,\n                  \"Ignoring received invalid HTTP header field: frame type: \"\n                  \"%u, stream: %d, name: [%.*s], value: [%.*s]\",\n                  frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                  nv.name->base, (int)nv.value->len, nv.value->base);\n\n              if (nghttp2_is_fatal(rv2)) {\n                return rv2;\n              }\n            }\n          }\n\n          if (rv == NGHTTP2_ERR_HTTP_HEADER) {\n            DEBUGF(\"recv: HTTP error: type=%u, id=%d, header %.*s: %.*s\\n\",\n                   frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                   nv.name->base, (int)nv.value->len, nv.value->base);\n\n            rv = session_call_error_callback(\n                session, NGHTTP2_ERR_HTTP_HEADER,\n                \"Invalid HTTP header field was received: frame type: \"\n                \"%u, stream: %d, name: [%.*s], value: [%.*s]\",\n                frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                nv.name->base, (int)nv.value->len, nv.value->base);\n\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n\n            rv = session_handle_invalid_stream2(session,\n                                                subject_stream->stream_id,\n                                                frame, NGHTTP2_ERR_HTTP_HEADER);\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n          }\n        }\n        if (rv == 0) {\n          rv = session_call_on_header(session, frame, &nv);\n          /* This handles NGHTTP2_ERR_PAUSE and\n             NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE as well */\n          if (rv != 0) {\n            return rv;\n          }\n        }\n      }\n    }\n    if (inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\n      nghttp2_hd_inflate_end_headers(&session->hd_inflater);\n      break;\n    }\n    if ((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 && inlen == 0) {\n      break;\n    }\n  }\n  return 0;\n}\n\n/*\n * Call this function when HEADERS frame was completely received.\n *\n * This function returns 0 if it succeeds, or one of negative error\n * codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nstatic int session_end_stream_headers_received(nghttp2_session *session,\n                                               nghttp2_frame *frame,\n                                               nghttp2_stream *stream) {\n  int rv;\n  if ((frame->hd.flags & NGHTTP2_FLAG_END_STREAM) == 0) {\n    return 0;\n  }\n\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nstatic int session_after_header_block_received(nghttp2_session *session) {\n  int rv = 0;\n  nghttp2_frame *frame = &session->iframe.frame;\n  nghttp2_stream *stream;\n\n  /* We don't call on_frame_recv_callback if stream has been closed\n     already or being closed. */\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream || stream->state == NGHTTP2_STREAM_CLOSING) {\n    return 0;\n  }\n\n  if (session_enforce_http_messaging(session)) {\n    if (frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n      nghttp2_stream *subject_stream;\n\n      subject_stream = nghttp2_session_get_stream(\n          session, frame->push_promise.promised_stream_id);\n      if (subject_stream) {\n        rv = nghttp2_http_on_request_headers(subject_stream, frame);\n      }\n    } else {\n      assert(frame->hd.type == NGHTTP2_HEADERS);\n      switch (frame->headers.cat) {\n      case NGHTTP2_HCAT_REQUEST:\n        rv = nghttp2_http_on_request_headers(stream, frame);\n        break;\n      case NGHTTP2_HCAT_RESPONSE:\n      case NGHTTP2_HCAT_PUSH_RESPONSE:\n        rv = nghttp2_http_on_response_headers(stream);\n        break;\n      case NGHTTP2_HCAT_HEADERS:\n        if (stream->http_flags & NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE) {\n          assert(!session->server);\n          rv = nghttp2_http_on_response_headers(stream);\n        } else {\n          rv = nghttp2_http_on_trailer_headers(stream, frame);\n        }\n        break;\n      default:\n        assert(0);\n      }\n      if (rv == 0 && (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)) {\n        rv = nghttp2_http_on_remote_end_stream(stream);\n      }\n    }\n    if (rv != 0) {\n      int32_t stream_id;\n\n      if (frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n        stream_id = frame->push_promise.promised_stream_id;\n      } else {\n        stream_id = frame->hd.stream_id;\n      }\n\n      rv = session_handle_invalid_stream2(session, stream_id, frame,\n                                          NGHTTP2_ERR_HTTP_MESSAGING);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (frame->hd.type == NGHTTP2_HEADERS &&\n          (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)) {\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n        /* Don't call nghttp2_session_close_stream_if_shut_rdwr\n           because RST_STREAM has been submitted. */\n      }\n      return 0;\n    }\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (frame->hd.type != NGHTTP2_HEADERS) {\n    return 0;\n  }\n\n  return session_end_stream_headers_received(session, frame, stream);\n}\n\nint nghttp2_session_on_request_headers_received(nghttp2_session *session,\n                                                nghttp2_frame *frame) {\n  int rv = 0;\n  nghttp2_stream *stream;\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"request HEADERS: stream_id == 0\");\n  }\n\n  /* If client receives idle stream from server, it is invalid\n     regardless stream ID is even or odd.  This is because client is\n     not expected to receive request from server. */\n  if (!session->server) {\n    if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n      return session_inflate_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_PROTO,\n          \"request HEADERS: client received request\");\n    }\n\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  assert(session->server);\n\n  if (!session_is_new_peer_stream_id(session, frame->hd.stream_id)) {\n    if (frame->hd.stream_id == 0 ||\n        nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n      return session_inflate_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_PROTO,\n          \"request HEADERS: invalid stream_id\");\n    }\n\n    /* RFC 7540 says if an endpoint receives a HEADERS with invalid\n     * stream ID (e.g, numerically smaller than previous), it MUST\n     * issue connection error with error code PROTOCOL_ERROR.  It is a\n     * bit hard to detect this, since we cannot remember all streams\n     * we observed so far.\n     *\n     * You might imagine this is really easy.  But no.  HTTP/2 is\n     * asynchronous protocol, and usually client and server do not\n     * share the complete picture of open/closed stream status.  For\n     * example, after server sends RST_STREAM for a stream, client may\n     * send trailer HEADERS for that stream.  If naive server detects\n     * that, and issued connection error, then it is a bug of server\n     * implementation since client is not wrong if it did not get\n     * RST_STREAM when it issued trailer HEADERS.\n     *\n     * At the moment, we are very conservative here.  We only use\n     * connection error if stream ID refers idle stream, or we are\n     * sure that stream is half-closed(remote) or closed.  Otherwise\n     * we just ignore HEADERS for now.\n     */\n    stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n    if (stream && (stream->shut_flags & NGHTTP2_SHUT_RD)) {\n      return session_inflate_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_STREAM_CLOSED, \"HEADERS: stream closed\");\n    }\n\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n  session->last_recv_stream_id = frame->hd.stream_id;\n\n  if (session_is_incoming_concurrent_streams_max(session)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"request HEADERS: max concurrent streams exceeded\");\n  }\n\n  if (!session_allow_incoming_new_stream(session)) {\n    /* We just ignore stream after GOAWAY was sent */\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (frame->headers.pri_spec.stream_id == frame->hd.stream_id) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"request HEADERS: depend on itself\");\n  }\n\n  if (session_is_incoming_concurrent_streams_pending_max(session)) {\n    return session_inflate_handle_invalid_stream(session, frame,\n                                                 NGHTTP2_ERR_REFUSED_STREAM);\n  }\n\n  stream = nghttp2_session_open_stream(\n      session, frame->hd.stream_id, NGHTTP2_STREAM_FLAG_NONE,\n      &frame->headers.pri_spec, NGHTTP2_STREAM_OPENING, NULL);\n  if (!stream) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  rv = nghttp2_session_adjust_closed_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  session->last_proc_stream_id = session->last_recv_stream_id;\n\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_on_response_headers_received(nghttp2_session *session,\n                                                 nghttp2_frame *frame,\n                                                 nghttp2_stream *stream) {\n  int rv;\n  /* This function is only called if stream->state ==\n     NGHTTP2_STREAM_OPENING and stream_id is local side initiated. */\n  assert(stream->state == NGHTTP2_STREAM_OPENING &&\n         nghttp2_session_is_my_stream_id(session, frame->hd.stream_id));\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"response HEADERS: stream_id == 0\");\n  }\n  if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n    /* half closed (remote): from the spec:\n\n       If an endpoint receives additional frames for a stream that is\n       in this state it MUST respond with a stream error (Section\n       5.4.2) of type STREAM_CLOSED.\n\n       We go further, and make it connection error.\n    */\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_STREAM_CLOSED, \"HEADERS: stream closed\");\n  }\n  stream->state = NGHTTP2_STREAM_OPENED;\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_on_push_response_headers_received(nghttp2_session *session,\n                                                      nghttp2_frame *frame,\n                                                      nghttp2_stream *stream) {\n  int rv = 0;\n  assert(stream->state == NGHTTP2_STREAM_RESERVED);\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"push response HEADERS: stream_id == 0\");\n  }\n\n  if (session->server) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"HEADERS: no HEADERS allowed from client in reserved state\");\n  }\n\n  if (session_is_incoming_concurrent_streams_max(session)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"push response HEADERS: max concurrent streams exceeded\");\n  }\n\n  if (!session_allow_incoming_new_stream(session)) {\n    /* We don't accept new stream after GOAWAY was sent. */\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (session_is_incoming_concurrent_streams_pending_max(session)) {\n    return session_inflate_handle_invalid_stream(session, frame,\n                                                 NGHTTP2_ERR_REFUSED_STREAM);\n  }\n\n  nghttp2_stream_promise_fulfilled(stream);\n  if (!nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n    --session->num_incoming_reserved_streams;\n  }\n  ++session->num_incoming_streams;\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_on_headers_received(nghttp2_session *session,\n                                        nghttp2_frame *frame,\n                                        nghttp2_stream *stream) {\n  int rv = 0;\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"HEADERS: stream_id == 0\");\n  }\n  if ((stream->shut_flags & NGHTTP2_SHUT_RD)) {\n    /* half closed (remote): from the spec:\n\n       If an endpoint receives additional frames for a stream that is\n       in this state it MUST respond with a stream error (Section\n       5.4.2) of type STREAM_CLOSED.\n\n       we go further, and make it connection error.\n    */\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_STREAM_CLOSED, \"HEADERS: stream closed\");\n  }\n  if (nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n    if (stream->state == NGHTTP2_STREAM_OPENED) {\n      rv = session_call_on_begin_headers(session, frame);\n      if (rv != 0) {\n        return rv;\n      }\n      return 0;\n    }\n\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n  /* If this is remote peer initiated stream, it is OK unless it\n     has sent END_STREAM frame already. But if stream is in\n     NGHTTP2_STREAM_CLOSING, we discard the frame. This is a race\n     condition. */\n  if (stream->state != NGHTTP2_STREAM_CLOSING) {\n    rv = session_call_on_begin_headers(session, frame);\n    if (rv != 0) {\n      return rv;\n    }\n    return 0;\n  }\n  return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n}\n\nstatic int session_process_headers_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  nghttp2_stream *stream;\n\n  rv = nghttp2_frame_unpack_headers_payload(&frame->headers, iframe->sbuf.pos);\n\n  if (rv != 0) {\n    return nghttp2_session_terminate_session_with_reason(\n        session, NGHTTP2_PROTOCOL_ERROR, \"HEADERS: could not unpack\");\n  }\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream) {\n    frame->headers.cat = NGHTTP2_HCAT_REQUEST;\n    return nghttp2_session_on_request_headers_received(session, frame);\n  }\n\n  if (stream->state == NGHTTP2_STREAM_RESERVED) {\n    frame->headers.cat = NGHTTP2_HCAT_PUSH_RESPONSE;\n    return nghttp2_session_on_push_response_headers_received(session, frame,\n                                                             stream);\n  }\n\n  if (stream->state == NGHTTP2_STREAM_OPENING &&\n      nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n    frame->headers.cat = NGHTTP2_HCAT_RESPONSE;\n    return nghttp2_session_on_response_headers_received(session, frame, stream);\n  }\n\n  frame->headers.cat = NGHTTP2_HCAT_HEADERS;\n  return nghttp2_session_on_headers_received(session, frame, stream);\n}\n\nint nghttp2_session_on_priority_received(nghttp2_session *session,\n                                         nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (frame->hd.stream_id == 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"PRIORITY: stream_id == 0\");\n  }\n\n  if (frame->priority.pri_spec.stream_id == frame->hd.stream_id) {\n    return nghttp2_session_terminate_session_with_reason(\n        session, NGHTTP2_PROTOCOL_ERROR, \"depend on itself\");\n  }\n\n  if (!session->server) {\n    /* Re-prioritization works only in server */\n    return session_call_on_frame_received(session, frame);\n  }\n\n  stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n\n  if (!stream) {\n    /* PRIORITY against idle stream can create anchor node in\n       dependency tree. */\n    if (!session_detect_idle_stream(session, frame->hd.stream_id)) {\n      return 0;\n    }\n\n    stream = nghttp2_session_open_stream(\n        session, frame->hd.stream_id, NGHTTP2_STREAM_FLAG_NONE,\n        &frame->priority.pri_spec, NGHTTP2_STREAM_IDLE, NULL);\n\n    if (stream == NULL) {\n      return NGHTTP2_ERR_NOMEM;\n    }\n\n    rv = nghttp2_session_adjust_idle_stream(session);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  } else {\n    rv = nghttp2_session_reprioritize_stream(session, stream,\n                                             &frame->priority.pri_spec);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n\n    rv = nghttp2_session_adjust_idle_stream(session);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_priority_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_priority_payload(&frame->priority, iframe->sbuf.pos);\n\n  return nghttp2_session_on_priority_received(session, frame);\n}\n\nint nghttp2_session_on_rst_stream_received(nghttp2_session *session,\n                                           nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n  if (frame->hd.stream_id == 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"RST_STREAM: stream_id == 0\");\n  }\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"RST_STREAM: stream in idle\");\n  }\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (stream) {\n    /* We may use stream->shut_flags for strict error checking. */\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  rv = nghttp2_session_close_stream(session, frame->hd.stream_id,\n                                    frame->rst_stream.error_code);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return 0;\n}\n\nstatic int session_process_rst_stream_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_rst_stream_payload(&frame->rst_stream, iframe->sbuf.pos);\n\n  return nghttp2_session_on_rst_stream_received(session, frame);\n}\n\nstatic int update_remote_initial_window_size_func(nghttp2_map_entry *entry,\n                                                  void *ptr) {\n  int rv;\n  nghttp2_update_window_size_arg *arg;\n  nghttp2_stream *stream;\n\n  arg = (nghttp2_update_window_size_arg *)ptr;\n  stream = (nghttp2_stream *)entry;\n\n  rv = nghttp2_stream_update_remote_initial_window_size(\n      stream, arg->new_window_size, arg->old_window_size);\n  if (rv != 0) {\n    return nghttp2_session_add_rst_stream(arg->session, stream->stream_id,\n                                          NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n\n  /* If window size gets positive, push deferred DATA frame to\n     outbound queue. */\n  if (stream->remote_window_size > 0 &&\n      nghttp2_stream_check_deferred_by_flow_control(stream)) {\n\n    rv = nghttp2_stream_resume_deferred_item(\n        stream, NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n  return 0;\n}\n\n/*\n * Updates the remote initial window size of all active streams.  If\n * error occurs, all streams may not be updated.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nstatic int\nsession_update_remote_initial_window_size(nghttp2_session *session,\n                                          int32_t new_initial_window_size) {\n  nghttp2_update_window_size_arg arg;\n\n  arg.session = session;\n  arg.new_window_size = new_initial_window_size;\n  arg.old_window_size = (int32_t)session->remote_settings.initial_window_size;\n\n  return nghttp2_map_each(&session->streams,\n                          update_remote_initial_window_size_func, &arg);\n}\n\nstatic int update_local_initial_window_size_func(nghttp2_map_entry *entry,\n                                                 void *ptr) {\n  int rv;\n  nghttp2_update_window_size_arg *arg;\n  nghttp2_stream *stream;\n  arg = (nghttp2_update_window_size_arg *)ptr;\n  stream = (nghttp2_stream *)entry;\n  rv = nghttp2_stream_update_local_initial_window_size(\n      stream, arg->new_window_size, arg->old_window_size);\n  if (rv != 0) {\n    return nghttp2_session_add_rst_stream(arg->session, stream->stream_id,\n                                          NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n  if (!(arg->session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) &&\n      stream->window_update_queued == 0 &&\n      nghttp2_should_send_window_update(stream->local_window_size,\n                                        stream->recv_window_size)) {\n\n    rv = nghttp2_session_add_window_update(arg->session, NGHTTP2_FLAG_NONE,\n                                           stream->stream_id,\n                                           stream->recv_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n\n    stream->recv_window_size = 0;\n  }\n  return 0;\n}\n\n/*\n * Updates the local initial window size of all active streams.  If\n * error occurs, all streams may not be updated.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nstatic int\nsession_update_local_initial_window_size(nghttp2_session *session,\n                                         int32_t new_initial_window_size,\n                                         int32_t old_initial_window_size) {\n  nghttp2_update_window_size_arg arg;\n  arg.session = session;\n  arg.new_window_size = new_initial_window_size;\n  arg.old_window_size = old_initial_window_size;\n  return nghttp2_map_each(&session->streams,\n                          update_local_initial_window_size_func, &arg);\n}\n\n/*\n * Apply SETTINGS values |iv| having |niv| elements to the local\n * settings.  We assumes that all values in |iv| is correct, since we\n * validated them in nghttp2_session_add_settings() already.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_HEADER_COMP\n *     The header table size is out of range\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_update_local_settings(nghttp2_session *session,\n                                          nghttp2_settings_entry *iv,\n                                          size_t niv) {\n  int rv;\n  size_t i;\n  int32_t new_initial_window_size = -1;\n  uint32_t header_table_size = 0;\n  uint32_t min_header_table_size = UINT32_MAX;\n  uint8_t header_table_size_seen = 0;\n  /* For NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE, use the value last\n     seen.  For NGHTTP2_SETTINGS_HEADER_TABLE_SIZE, use both minimum\n     value and last seen value. */\n  for (i = 0; i < niv; ++i) {\n    switch (iv[i].settings_id) {\n    case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n      header_table_size_seen = 1;\n      header_table_size = iv[i].value;\n      min_header_table_size = nghttp2_min(min_header_table_size, iv[i].value);\n      break;\n    case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n      new_initial_window_size = (int32_t)iv[i].value;\n      break;\n    }\n  }\n  if (header_table_size_seen) {\n    if (min_header_table_size < header_table_size) {\n      rv = nghttp2_hd_inflate_change_table_size(&session->hd_inflater,\n                                                min_header_table_size);\n      if (rv != 0) {\n        return rv;\n      }\n    }\n\n    rv = nghttp2_hd_inflate_change_table_size(&session->hd_inflater,\n                                              header_table_size);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n  if (new_initial_window_size != -1) {\n    rv = session_update_local_initial_window_size(\n        session, new_initial_window_size,\n        (int32_t)session->local_settings.initial_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  for (i = 0; i < niv; ++i) {\n    switch (iv[i].settings_id) {\n    case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n      session->local_settings.header_table_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_PUSH:\n      session->local_settings.enable_push = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n      session->local_settings.max_concurrent_streams = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n      session->local_settings.initial_window_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n      session->local_settings.max_frame_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n      session->local_settings.max_header_list_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n      session->local_settings.enable_connect_protocol = iv[i].value;\n      break;\n    }\n  }\n\n  return 0;\n}\n\nint nghttp2_session_on_settings_received(nghttp2_session *session,\n                                         nghttp2_frame *frame, int noack) {\n  int rv;\n  size_t i;\n  nghttp2_mem *mem;\n  nghttp2_inflight_settings *settings;\n\n  mem = &session->mem;\n\n  if (frame->hd.stream_id != 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"SETTINGS: stream_id != 0\");\n  }\n  if (frame->hd.flags & NGHTTP2_FLAG_ACK) {\n    if (frame->settings.niv != 0) {\n      return session_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_FRAME_SIZE_ERROR,\n          \"SETTINGS: ACK and payload != 0\");\n    }\n\n    settings = session->inflight_settings_head;\n\n    if (!settings) {\n      return session_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_PROTO, \"SETTINGS: unexpected ACK\");\n    }\n\n    rv = nghttp2_session_update_local_settings(session, settings->iv,\n                                               settings->niv);\n\n    session->inflight_settings_head = settings->next;\n\n    inflight_settings_del(settings, mem);\n\n    if (rv != 0) {\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      return session_handle_invalid_connection(session, frame, rv, NULL);\n    }\n    return session_call_on_frame_received(session, frame);\n  }\n\n  if (!session->remote_settings_received) {\n    session->remote_settings.max_concurrent_streams =\n        NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n    session->remote_settings_received = 1;\n  }\n\n  for (i = 0; i < frame->settings.niv; ++i) {\n    nghttp2_settings_entry *entry = &frame->settings.iv[i];\n\n    switch (entry->settings_id) {\n    case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n\n      rv = nghttp2_hd_deflate_change_table_size(&session->hd_deflater,\n                                                entry->value);\n      if (rv != 0) {\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        } else {\n          return session_handle_invalid_connection(\n              session, frame, NGHTTP2_ERR_HEADER_COMP, NULL);\n        }\n      }\n\n      session->remote_settings.header_table_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_PUSH:\n\n      if (entry->value != 0 && entry->value != 1) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: invalid SETTINGS_ENBLE_PUSH\");\n      }\n\n      if (!session->server && entry->value != 0) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: server attempted to enable push\");\n      }\n\n      session->remote_settings.enable_push = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n\n      session->remote_settings.max_concurrent_streams = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n\n      /* Update the initial window size of the all active streams */\n      /* Check that initial_window_size < (1u << 31) */\n      if (entry->value > NGHTTP2_MAX_WINDOW_SIZE) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_FLOW_CONTROL,\n            \"SETTINGS: too large SETTINGS_INITIAL_WINDOW_SIZE\");\n      }\n\n      rv = session_update_remote_initial_window_size(session,\n                                                     (int32_t)entry->value);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (rv != 0) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_FLOW_CONTROL, NULL);\n      }\n\n      session->remote_settings.initial_window_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n\n      if (entry->value < NGHTTP2_MAX_FRAME_SIZE_MIN ||\n          entry->value > NGHTTP2_MAX_FRAME_SIZE_MAX) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: invalid SETTINGS_MAX_FRAME_SIZE\");\n      }\n\n      session->remote_settings.max_frame_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n\n      session->remote_settings.max_header_list_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n\n      if (entry->value != 0 && entry->value != 1) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: invalid SETTINGS_ENABLE_CONNECT_PROTOCOL\");\n      }\n\n      if (!session->server &&\n          session->remote_settings.enable_connect_protocol &&\n          entry->value == 0) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: server attempted to disable \"\n            \"SETTINGS_ENABLE_CONNECT_PROTOCOL\");\n      }\n\n      session->remote_settings.enable_connect_protocol = entry->value;\n\n      break;\n    }\n  }\n\n  if (!noack && !session_is_closing(session)) {\n    rv = nghttp2_session_add_settings(session, NGHTTP2_FLAG_ACK, NULL, 0);\n\n    if (rv != 0) {\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      return session_handle_invalid_connection(session, frame,\n                                               NGHTTP2_ERR_INTERNAL, NULL);\n    }\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_settings_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  size_t i;\n  nghttp2_settings_entry min_header_size_entry;\n\n  if (iframe->max_niv) {\n    min_header_size_entry = iframe->iv[iframe->max_niv - 1];\n\n    if (min_header_size_entry.value < UINT32_MAX) {\n      /* If we have less value, then we must have\n         SETTINGS_HEADER_TABLE_SIZE in i < iframe->niv */\n      for (i = 0; i < iframe->niv; ++i) {\n        if (iframe->iv[i].settings_id == NGHTTP2_SETTINGS_HEADER_TABLE_SIZE) {\n          break;\n        }\n      }\n\n      assert(i < iframe->niv);\n\n      if (min_header_size_entry.value != iframe->iv[i].value) {\n        iframe->iv[iframe->niv++] = iframe->iv[i];\n        iframe->iv[i] = min_header_size_entry;\n      }\n    }\n  }\n\n  nghttp2_frame_unpack_settings_payload(&frame->settings, iframe->iv,\n                                        iframe->niv);\n\n  iframe->iv = NULL;\n  iframe->niv = 0;\n  iframe->max_niv = 0;\n\n  return nghttp2_session_on_settings_received(session, frame, 0 /* ACK */);\n}\n\nint nghttp2_session_on_push_promise_received(nghttp2_session *session,\n                                             nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_stream *promised_stream;\n  nghttp2_priority_spec pri_spec;\n\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: stream_id == 0\");\n  }\n  if (session->server || session->local_settings.enable_push == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: push disabled\");\n  }\n\n  if (!nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: invalid stream_id\");\n  }\n\n  if (!session_allow_incoming_new_stream(session)) {\n    /* We just discard PUSH_PROMISE after GOAWAY was sent */\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (!session_is_new_peer_stream_id(session,\n                                     frame->push_promise.promised_stream_id)) {\n    /* The spec says if an endpoint receives a PUSH_PROMISE with\n       illegal stream ID is subject to a connection error of type\n       PROTOCOL_ERROR. */\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"PUSH_PROMISE: invalid promised_stream_id\");\n  }\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: stream in idle\");\n  }\n\n  session->last_recv_stream_id = frame->push_promise.promised_stream_id;\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream || stream->state == NGHTTP2_STREAM_CLOSING ||\n      !session->pending_enable_push ||\n      session->num_incoming_reserved_streams >=\n          session->max_incoming_reserved_streams) {\n    /* Currently, client does not retain closed stream, so we don't\n       check NGHTTP2_SHUT_RD condition here. */\n\n    rv = nghttp2_session_add_rst_stream(\n        session, frame->push_promise.promised_stream_id, NGHTTP2_CANCEL);\n    if (rv != 0) {\n      return rv;\n    }\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_STREAM_CLOSED,\n        \"PUSH_PROMISE: stream closed\");\n  }\n\n  nghttp2_priority_spec_init(&pri_spec, stream->stream_id,\n                             NGHTTP2_DEFAULT_WEIGHT, 0);\n\n  promised_stream = nghttp2_session_open_stream(\n      session, frame->push_promise.promised_stream_id, NGHTTP2_STREAM_FLAG_NONE,\n      &pri_spec, NGHTTP2_STREAM_RESERVED, NULL);\n\n  if (!promised_stream) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't call nghttp2_session_adjust_closed_stream(), since we\n     don't keep closed stream in client side */\n\n  session->last_proc_stream_id = session->last_recv_stream_id;\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nstatic int session_process_push_promise_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  rv = nghttp2_frame_unpack_push_promise_payload(&frame->push_promise,\n                                                 iframe->sbuf.pos);\n\n  if (rv != 0) {\n    return nghttp2_session_terminate_session_with_reason(\n        session, NGHTTP2_PROTOCOL_ERROR, \"PUSH_PROMISE: could not unpack\");\n  }\n\n  return nghttp2_session_on_push_promise_received(session, frame);\n}\n\nint nghttp2_session_on_ping_received(nghttp2_session *session,\n                                     nghttp2_frame *frame) {\n  int rv = 0;\n  if (frame->hd.stream_id != 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"PING: stream_id != 0\");\n  }\n  if ((session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_PING_ACK) == 0 &&\n      (frame->hd.flags & NGHTTP2_FLAG_ACK) == 0 &&\n      !session_is_closing(session)) {\n    /* Peer sent ping, so ping it back */\n    rv = nghttp2_session_add_ping(session, NGHTTP2_FLAG_ACK,\n                                  frame->ping.opaque_data);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_ping_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_ping_payload(&frame->ping, iframe->sbuf.pos);\n\n  return nghttp2_session_on_ping_received(session, frame);\n}\n\nint nghttp2_session_on_goaway_received(nghttp2_session *session,\n                                       nghttp2_frame *frame) {\n  int rv;\n\n  if (frame->hd.stream_id != 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"GOAWAY: stream_id != 0\");\n  }\n  /* Spec says Endpoints MUST NOT increase the value they send in the\n     last stream identifier. */\n  if ((frame->goaway.last_stream_id > 0 &&\n       !nghttp2_session_is_my_stream_id(session,\n                                        frame->goaway.last_stream_id)) ||\n      session->remote_last_stream_id < frame->goaway.last_stream_id) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"GOAWAY: invalid last_stream_id\");\n  }\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_RECV;\n\n  session->remote_last_stream_id = frame->goaway.last_stream_id;\n\n  rv = session_call_on_frame_received(session, frame);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return session_close_stream_on_goaway(session, frame->goaway.last_stream_id,\n                                        0);\n}\n\nstatic int session_process_goaway_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_goaway_payload(&frame->goaway, iframe->sbuf.pos,\n                                      iframe->lbuf.pos,\n                                      nghttp2_buf_len(&iframe->lbuf));\n\n  nghttp2_buf_wrap_init(&iframe->lbuf, NULL, 0);\n\n  return nghttp2_session_on_goaway_received(session, frame);\n}\n\nstatic int\nsession_on_connection_window_update_received(nghttp2_session *session,\n                                             nghttp2_frame *frame) {\n  /* Handle connection-level flow control */\n  if (frame->window_update.window_size_increment == 0) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"WINDOW_UPDATE: window_size_increment == 0\");\n  }\n\n  if (NGHTTP2_MAX_WINDOW_SIZE - frame->window_update.window_size_increment <\n      session->remote_window_size) {\n    return session_handle_invalid_connection(session, frame,\n                                             NGHTTP2_ERR_FLOW_CONTROL, NULL);\n  }\n  session->remote_window_size += frame->window_update.window_size_increment;\n\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_on_stream_window_update_received(nghttp2_session *session,\n                                                    nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"WINDOW_UPDATE to idle stream\");\n  }\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream) {\n    return 0;\n  }\n  if (state_reserved_remote(session, stream)) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"WINDOW_UPADATE to reserved stream\");\n  }\n  if (frame->window_update.window_size_increment == 0) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"WINDOW_UPDATE: window_size_increment == 0\");\n  }\n  if (NGHTTP2_MAX_WINDOW_SIZE - frame->window_update.window_size_increment <\n      stream->remote_window_size) {\n    return session_handle_invalid_stream(session, frame,\n                                         NGHTTP2_ERR_FLOW_CONTROL);\n  }\n  stream->remote_window_size += frame->window_update.window_size_increment;\n\n  if (stream->remote_window_size > 0 &&\n      nghttp2_stream_check_deferred_by_flow_control(stream)) {\n\n    rv = nghttp2_stream_resume_deferred_item(\n        stream, NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n  return session_call_on_frame_received(session, frame);\n}\n\nint nghttp2_session_on_window_update_received(nghttp2_session *session,\n                                              nghttp2_frame *frame) {\n  if (frame->hd.stream_id == 0) {\n    return session_on_connection_window_update_received(session, frame);\n  } else {\n    return session_on_stream_window_update_received(session, frame);\n  }\n}\n\nstatic int session_process_window_update_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_window_update_payload(&frame->window_update,\n                                             iframe->sbuf.pos);\n\n  return nghttp2_session_on_window_update_received(session, frame);\n}\n\nint nghttp2_session_on_altsvc_received(nghttp2_session *session,\n                                       nghttp2_frame *frame) {\n  nghttp2_ext_altsvc *altsvc;\n  nghttp2_stream *stream;\n\n  altsvc = frame->ext.payload;\n\n  /* session->server case has been excluded */\n\n  if (frame->hd.stream_id == 0) {\n    if (altsvc->origin_len == 0) {\n      return session_call_on_invalid_frame_recv_callback(session, frame,\n                                                         NGHTTP2_ERR_PROTO);\n    }\n  } else {\n    if (altsvc->origin_len > 0) {\n      return session_call_on_invalid_frame_recv_callback(session, frame,\n                                                         NGHTTP2_ERR_PROTO);\n    }\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n      return 0;\n    }\n\n    if (stream->state == NGHTTP2_STREAM_CLOSING) {\n      return 0;\n    }\n  }\n\n  if (altsvc->field_value_len == 0) {\n    return session_call_on_invalid_frame_recv_callback(session, frame,\n                                                       NGHTTP2_ERR_PROTO);\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nint nghttp2_session_on_origin_received(nghttp2_session *session,\n                                       nghttp2_frame *frame) {\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_altsvc_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_altsvc_payload(\n      &frame->ext, nghttp2_get_uint16(iframe->sbuf.pos), iframe->lbuf.pos,\n      nghttp2_buf_len(&iframe->lbuf));\n\n  /* nghttp2_frame_unpack_altsvc_payload steals buffer from\n     iframe->lbuf */\n  nghttp2_buf_wrap_init(&iframe->lbuf, NULL, 0);\n\n  return nghttp2_session_on_altsvc_received(session, frame);\n}\n\nstatic int session_process_origin_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  nghttp2_mem *mem = &session->mem;\n  int rv;\n\n  rv = nghttp2_frame_unpack_origin_payload(&frame->ext, iframe->lbuf.pos,\n                                           nghttp2_buf_len(&iframe->lbuf), mem);\n  if (rv != 0) {\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n    /* Ignore ORIGIN frame which cannot be parsed. */\n    return 0;\n  }\n\n  return nghttp2_session_on_origin_received(session, frame);\n}\n\nstatic int session_process_extension_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  rv = session_call_unpack_extension_callback(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  /* This handles the case where rv == NGHTTP2_ERR_CANCEL as well */\n  if (rv != 0) {\n    return 0;\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nint nghttp2_session_on_data_received(nghttp2_session *session,\n                                     nghttp2_frame *frame) {\n  int rv = 0;\n  nghttp2_stream *stream;\n\n  /* We don't call on_frame_recv_callback if stream has been closed\n     already or being closed. */\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream || stream->state == NGHTTP2_STREAM_CLOSING) {\n    /* This should be treated as stream error, but it results in lots\n       of RST_STREAM. So just ignore frame against nonexistent stream\n       for now. */\n    return 0;\n  }\n\n  if (session_enforce_http_messaging(session) &&\n      (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)) {\n    if (nghttp2_http_on_remote_end_stream(stream) != 0) {\n      rv = nghttp2_session_add_rst_stream(session, stream->stream_id,\n                                          NGHTTP2_PROTOCOL_ERROR);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n      /* Don't call nghttp2_session_close_stream_if_shut_rdwr because\n         RST_STREAM has been submitted. */\n      return 0;\n    }\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n  return 0;\n}\n\n/* For errors, this function only returns FATAL error. */\nstatic int session_process_data_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_frame *public_data_frame = &session->iframe.frame;\n  rv = nghttp2_session_on_data_received(session, public_data_frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return 0;\n}\n\n/*\n * Now we have SETTINGS synchronization, flow control error can be\n * detected strictly. If DATA frame is received with length > 0 and\n * current received window size + delta length is strictly larger than\n * local window size, it is subject to FLOW_CONTROL_ERROR, so return\n * -1. Note that local_window_size is calculated after SETTINGS ACK is\n * received from peer, so peer must honor this limit. If the resulting\n * recv_window_size is strictly larger than NGHTTP2_MAX_WINDOW_SIZE,\n * return -1 too.\n */\nstatic int adjust_recv_window_size(int32_t *recv_window_size_ptr, size_t delta,\n                                   int32_t local_window_size) {\n  if (*recv_window_size_ptr > local_window_size - (int32_t)delta ||\n      *recv_window_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - (int32_t)delta) {\n    return -1;\n  }\n  *recv_window_size_ptr += (int32_t)delta;\n  return 0;\n}\n\nint nghttp2_session_update_recv_stream_window_size(nghttp2_session *session,\n                                                   nghttp2_stream *stream,\n                                                   size_t delta_size,\n                                                   int send_window_update) {\n  int rv;\n  rv = adjust_recv_window_size(&stream->recv_window_size, delta_size,\n                               stream->local_window_size);\n  if (rv != 0) {\n    return nghttp2_session_add_rst_stream(session, stream->stream_id,\n                                          NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n  /* We don't have to send WINDOW_UPDATE if the data received is the\n     last chunk in the incoming stream. */\n  /* We have to use local_settings here because it is the constraint\n     the remote endpoint should honor. */\n  if (send_window_update &&\n      !(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) &&\n      stream->window_update_queued == 0 &&\n      nghttp2_should_send_window_update(stream->local_window_size,\n                                        stream->recv_window_size)) {\n    rv = nghttp2_session_add_window_update(session, NGHTTP2_FLAG_NONE,\n                                           stream->stream_id,\n                                           stream->recv_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n\n    stream->recv_window_size = 0;\n  }\n  return 0;\n}\n\nint nghttp2_session_update_recv_connection_window_size(nghttp2_session *session,\n                                                       size_t delta_size) {\n  int rv;\n  rv = adjust_recv_window_size(&session->recv_window_size, delta_size,\n                               session->local_window_size);\n  if (rv != 0) {\n    return nghttp2_session_terminate_session(session,\n                                             NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) &&\n      session->window_update_queued == 0 &&\n      nghttp2_should_send_window_update(session->local_window_size,\n                                        session->recv_window_size)) {\n    /* Use stream ID 0 to update connection-level flow control\n       window */\n    rv = nghttp2_session_add_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                           session->recv_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n\n    session->recv_window_size = 0;\n  }\n  return 0;\n}\n\nstatic int session_update_consumed_size(nghttp2_session *session,\n                                        int32_t *consumed_size_ptr,\n                                        int32_t *recv_window_size_ptr,\n                                        uint8_t window_update_queued,\n                                        int32_t stream_id, size_t delta_size,\n                                        int32_t local_window_size) {\n  int32_t recv_size;\n  int rv;\n\n  if ((size_t)*consumed_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - delta_size) {\n    return nghttp2_session_terminate_session(session,\n                                             NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n\n  *consumed_size_ptr += (int32_t)delta_size;\n\n  if (window_update_queued == 0) {\n    /* recv_window_size may be smaller than consumed_size, because it\n       may be decreased by negative value with\n       nghttp2_submit_window_update(). */\n    recv_size = nghttp2_min(*consumed_size_ptr, *recv_window_size_ptr);\n\n    if (nghttp2_should_send_window_update(local_window_size, recv_size)) {\n      rv = nghttp2_session_add_window_update(session, NGHTTP2_FLAG_NONE,\n                                             stream_id, recv_size);\n\n      if (rv != 0) {\n        return rv;\n      }\n\n      *recv_window_size_ptr -= recv_size;\n      *consumed_size_ptr -= recv_size;\n    }\n  }\n\n  return 0;\n}\n\nstatic int session_update_stream_consumed_size(nghttp2_session *session,\n                                               nghttp2_stream *stream,\n                                               size_t delta_size) {\n  return session_update_consumed_size(\n      session, &stream->consumed_size, &stream->recv_window_size,\n      stream->window_update_queued, stream->stream_id, delta_size,\n      stream->local_window_size);\n}\n\nstatic int session_update_connection_consumed_size(nghttp2_session *session,\n                                                   size_t delta_size) {\n  return session_update_consumed_size(\n      session, &session->consumed_size, &session->recv_window_size,\n      session->window_update_queued, 0, delta_size, session->local_window_size);\n}\n\n/*\n * Checks that we can receive the DATA frame for stream, which is\n * indicated by |session->iframe.frame.hd.stream_id|. If it is a\n * connection error situation, GOAWAY frame will be issued by this\n * function.\n *\n * If the DATA frame is allowed, returns 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_IGN_PAYLOAD\n *   The reception of DATA frame is connection error; or should be\n *   ignored.\n * NGHTTP2_ERR_NOMEM\n *   Out of memory.\n */\nstatic int session_on_data_received_fail_fast(nghttp2_session *session) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_inbound_frame *iframe;\n  int32_t stream_id;\n  const char *failure_reason;\n  uint32_t error_code = NGHTTP2_PROTOCOL_ERROR;\n\n  iframe = &session->iframe;\n  stream_id = iframe->frame.hd.stream_id;\n\n  if (stream_id == 0) {\n    /* The spec says that if a DATA frame is received whose stream ID\n       is 0, the recipient MUST respond with a connection error of\n       type PROTOCOL_ERROR. */\n    failure_reason = \"DATA: stream_id == 0\";\n    goto fail;\n  }\n\n  if (session_detect_idle_stream(session, stream_id)) {\n    failure_reason = \"DATA: stream in idle\";\n    error_code = NGHTTP2_PROTOCOL_ERROR;\n    goto fail;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (!stream) {\n    stream = nghttp2_session_get_stream_raw(session, stream_id);\n    if (stream && (stream->shut_flags & NGHTTP2_SHUT_RD)) {\n      failure_reason = \"DATA: stream closed\";\n      error_code = NGHTTP2_STREAM_CLOSED;\n      goto fail;\n    }\n\n    return NGHTTP2_ERR_IGN_PAYLOAD;\n  }\n  if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n    failure_reason = \"DATA: stream in half-closed(remote)\";\n    error_code = NGHTTP2_STREAM_CLOSED;\n    goto fail;\n  }\n\n  if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n    if (stream->state == NGHTTP2_STREAM_CLOSING) {\n      return NGHTTP2_ERR_IGN_PAYLOAD;\n    }\n    if (stream->state != NGHTTP2_STREAM_OPENED) {\n      failure_reason = \"DATA: stream not opened\";\n      goto fail;\n    }\n    return 0;\n  }\n  if (stream->state == NGHTTP2_STREAM_RESERVED) {\n    failure_reason = \"DATA: stream in reserved\";\n    goto fail;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_IGN_PAYLOAD;\n  }\n  return 0;\nfail:\n  rv = nghttp2_session_terminate_session_with_reason(session, error_code,\n                                                     failure_reason);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return NGHTTP2_ERR_IGN_PAYLOAD;\n}\n\nstatic size_t inbound_frame_payload_readlen(nghttp2_inbound_frame *iframe,\n                                            const uint8_t *in,\n                                            const uint8_t *last) {\n  return nghttp2_min((size_t)(last - in), iframe->payloadleft);\n}\n\n/*\n * Resets iframe->sbuf and advance its mark pointer by |left| bytes.\n */\nstatic void inbound_frame_set_mark(nghttp2_inbound_frame *iframe, size_t left) {\n  nghttp2_buf_reset(&iframe->sbuf);\n  iframe->sbuf.mark += left;\n}\n\nstatic size_t inbound_frame_buf_read(nghttp2_inbound_frame *iframe,\n                                     const uint8_t *in, const uint8_t *last) {\n  size_t readlen;\n\n  readlen =\n      nghttp2_min((size_t)(last - in), nghttp2_buf_mark_avail(&iframe->sbuf));\n\n  iframe->sbuf.last = nghttp2_cpymem(iframe->sbuf.last, in, readlen);\n\n  return readlen;\n}\n\n/*\n * Unpacks SETTINGS entry in iframe->sbuf.\n */\nstatic void inbound_frame_set_settings_entry(nghttp2_inbound_frame *iframe) {\n  nghttp2_settings_entry iv;\n  nghttp2_settings_entry *min_header_table_size_entry;\n  size_t i;\n\n  nghttp2_frame_unpack_settings_entry(&iv, iframe->sbuf.pos);\n\n  switch (iv.settings_id) {\n  case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n  case NGHTTP2_SETTINGS_ENABLE_PUSH:\n  case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n  case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n  case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n  case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n  case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n    break;\n  default:\n    DEBUGF(\"recv: unknown settings id=0x%02x\\n\", iv.settings_id);\n\n    iframe->iv[iframe->niv++] = iv;\n\n    return;\n  }\n\n  for (i = 0; i < iframe->niv; ++i) {\n    if (iframe->iv[i].settings_id == iv.settings_id) {\n      iframe->iv[i] = iv;\n      break;\n    }\n  }\n\n  if (i == iframe->niv) {\n    iframe->iv[iframe->niv++] = iv;\n  }\n\n  if (iv.settings_id == NGHTTP2_SETTINGS_HEADER_TABLE_SIZE) {\n    /* Keep track of minimum value of SETTINGS_HEADER_TABLE_SIZE */\n    min_header_table_size_entry = &iframe->iv[iframe->max_niv - 1];\n\n    if (iv.value < min_header_table_size_entry->value) {\n      min_header_table_size_entry->value = iv.value;\n    }\n  }\n}\n\n/*\n * Checks PADDED flags and set iframe->sbuf to read them accordingly.\n * If padding is set, this function returns 1.  If no padding is set,\n * this function returns 0.  On error, returns -1.\n */\nstatic int inbound_frame_handle_pad(nghttp2_inbound_frame *iframe,\n                                    nghttp2_frame_hd *hd) {\n  if (hd->flags & NGHTTP2_FLAG_PADDED) {\n    if (hd->length < 1) {\n      return -1;\n    }\n    inbound_frame_set_mark(iframe, 1);\n    return 1;\n  }\n  DEBUGF(\"recv: no padding in payload\\n\");\n  return 0;\n}\n\n/*\n * Computes number of padding based on flags. This function returns\n * the calculated length if it succeeds, or -1.\n */\nstatic ssize_t inbound_frame_compute_pad(nghttp2_inbound_frame *iframe) {\n  size_t padlen;\n\n  /* 1 for Pad Length field */\n  padlen = (size_t)(iframe->sbuf.pos[0] + 1);\n\n  DEBUGF(\"recv: padlen=%zu\\n\", padlen);\n\n  /* We cannot use iframe->frame.hd.length because of CONTINUATION */\n  if (padlen - 1 > iframe->payloadleft) {\n    return -1;\n  }\n\n  iframe->padlen = padlen;\n\n  return (ssize_t)padlen;\n}\n\n/*\n * This function returns the effective payload length in the data of\n * length |readlen| when the remaning payload is |payloadleft|. The\n * |payloadleft| does not include |readlen|. If padding was started\n * strictly before this data chunk, this function returns -1.\n */\nstatic ssize_t inbound_frame_effective_readlen(nghttp2_inbound_frame *iframe,\n                                               size_t payloadleft,\n                                               size_t readlen) {\n  size_t trail_padlen =\n      nghttp2_frame_trail_padlen(&iframe->frame, iframe->padlen);\n\n  if (trail_padlen > payloadleft) {\n    size_t padlen;\n    padlen = trail_padlen - payloadleft;\n    if (readlen < padlen) {\n      return -1;\n    }\n    return (ssize_t)(readlen - padlen);\n  }\n  return (ssize_t)(readlen);\n}\n\nssize_t nghttp2_session_mem_recv(nghttp2_session *session, const uint8_t *in,\n                                 size_t inlen) {\n  const uint8_t *first = in, *last = in + inlen;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  size_t readlen;\n  ssize_t padlen;\n  int rv;\n  int busy = 0;\n  nghttp2_frame_hd cont_hd;\n  nghttp2_stream *stream;\n  size_t pri_fieldlen;\n  nghttp2_mem *mem;\n\n  DEBUGF(\"recv: connection recv_window_size=%d, local_window=%d\\n\",\n         session->recv_window_size, session->local_window_size);\n\n  mem = &session->mem;\n\n  /* We may have idle streams more than we expect (e.g.,\n     nghttp2_session_change_stream_priority() or\n     nghttp2_session_create_idle_stream()).  Adjust them here. */\n  rv = nghttp2_session_adjust_idle_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (!nghttp2_session_want_read(session)) {\n    return (ssize_t)inlen;\n  }\n\n  for (;;) {\n    switch (iframe->state) {\n    case NGHTTP2_IB_READ_CLIENT_MAGIC:\n      readlen = nghttp2_min(inlen, iframe->payloadleft);\n\n      if (memcmp(&NGHTTP2_CLIENT_MAGIC[NGHTTP2_CLIENT_MAGIC_LEN -\n                                       iframe->payloadleft],\n                 in, readlen) != 0) {\n        return NGHTTP2_ERR_BAD_CLIENT_MAGIC;\n      }\n\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      if (iframe->payloadleft == 0) {\n        session_inbound_frame_reset(session);\n        iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n      }\n\n      break;\n    case NGHTTP2_IB_READ_FIRST_SETTINGS:\n      DEBUGF(\"recv: [IB_READ_FIRST_SETTINGS]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      if (iframe->sbuf.pos[3] != NGHTTP2_SETTINGS ||\n          (iframe->sbuf.pos[4] & NGHTTP2_FLAG_ACK)) {\n        rv = session_call_error_callback(\n            session, NGHTTP2_ERR_SETTINGS_EXPECTED,\n            \"Remote peer returned unexpected data while we expected \"\n            \"SETTINGS frame.  Perhaps, peer does not support HTTP/2 \"\n            \"properly.\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"SETTINGS expected\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      }\n\n      iframe->state = NGHTTP2_IB_READ_HEAD;\n\n    /* Fall through */\n    case NGHTTP2_IB_READ_HEAD: {\n      int on_begin_frame_called = 0;\n\n      DEBUGF(\"recv: [IB_READ_HEAD]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      nghttp2_frame_unpack_frame_hd(&iframe->frame.hd, iframe->sbuf.pos);\n      iframe->payloadleft = iframe->frame.hd.length;\n\n      DEBUGF(\"recv: payloadlen=%zu, type=%u, flags=0x%02x, stream_id=%d\\n\",\n             iframe->frame.hd.length, iframe->frame.hd.type,\n             iframe->frame.hd.flags, iframe->frame.hd.stream_id);\n\n      if (iframe->frame.hd.length > session->local_settings.max_frame_size) {\n        DEBUGF(\"recv: length is too large %zu > %u\\n\", iframe->frame.hd.length,\n               session->local_settings.max_frame_size);\n\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_FRAME_SIZE_ERROR, \"too large frame size\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_DATA: {\n        DEBUGF(\"recv: DATA\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_PADDED);\n        /* Check stream is open. If it is not open or closing,\n           ignore payload. */\n        busy = 1;\n\n        rv = session_on_data_received_fail_fast(session);\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n        if (rv == NGHTTP2_ERR_IGN_PAYLOAD) {\n          DEBUGF(\"recv: DATA not allowed stream_id=%d\\n\",\n                 iframe->frame.hd.stream_id);\n          iframe->state = NGHTTP2_IB_IGN_DATA;\n          break;\n        }\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"DATA: insufficient padding space\");\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (ssize_t)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_PAD_DATA;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_DATA;\n        break;\n      }\n      case NGHTTP2_HEADERS:\n\n        DEBUGF(\"recv: HEADERS\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS |\n             NGHTTP2_FLAG_PADDED | NGHTTP2_FLAG_PRIORITY);\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"HEADERS: insufficient padding space\");\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (ssize_t)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n          break;\n        }\n\n        pri_fieldlen = nghttp2_frame_priority_len(iframe->frame.hd.flags);\n\n        if (pri_fieldlen > 0) {\n          if (iframe->payloadleft < pri_fieldlen) {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n            break;\n          }\n\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n          inbound_frame_set_mark(iframe, pri_fieldlen);\n\n          break;\n        }\n\n        /* Call on_begin_frame_callback here because\n           session_process_headers_frame() may call\n           on_begin_headers_callback */\n        rv = session_call_on_begin_frame(session, &iframe->frame.hd);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        on_begin_frame_called = 1;\n\n        rv = session_process_headers_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.hd.stream_id, NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PRIORITY:\n        DEBUGF(\"recv: PRIORITY\\n\");\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft != NGHTTP2_PRIORITY_SPECLEN) {\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, NGHTTP2_PRIORITY_SPECLEN);\n\n        break;\n      case NGHTTP2_RST_STREAM:\n      case NGHTTP2_WINDOW_UPDATE:\n#ifdef DEBUGBUILD\n        switch (iframe->frame.hd.type) {\n        case NGHTTP2_RST_STREAM:\n          DEBUGF(\"recv: RST_STREAM\\n\");\n          break;\n        case NGHTTP2_WINDOW_UPDATE:\n          DEBUGF(\"recv: WINDOW_UPDATE\\n\");\n          break;\n        }\n#endif /* DEBUGBUILD */\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft != 4) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, 4);\n\n        break;\n      case NGHTTP2_SETTINGS:\n        DEBUGF(\"recv: SETTINGS\\n\");\n\n        iframe->frame.hd.flags &= NGHTTP2_FLAG_ACK;\n\n        if ((iframe->frame.hd.length % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) ||\n            ((iframe->frame.hd.flags & NGHTTP2_FLAG_ACK) &&\n             iframe->payloadleft > 0)) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_SETTINGS;\n\n        if (iframe->payloadleft) {\n          nghttp2_settings_entry *min_header_table_size_entry;\n\n          /* We allocate iv with additional one entry, to store the\n             minimum header table size. */\n          iframe->max_niv =\n              iframe->frame.hd.length / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH + 1;\n\n          iframe->iv = nghttp2_mem_malloc(mem, sizeof(nghttp2_settings_entry) *\n                                                   iframe->max_niv);\n\n          if (!iframe->iv) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          min_header_table_size_entry = &iframe->iv[iframe->max_niv - 1];\n          min_header_table_size_entry->settings_id =\n              NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n          min_header_table_size_entry->value = UINT32_MAX;\n\n          inbound_frame_set_mark(iframe, NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH);\n          break;\n        }\n\n        busy = 1;\n\n        inbound_frame_set_mark(iframe, 0);\n\n        break;\n      case NGHTTP2_PUSH_PROMISE:\n        DEBUGF(\"recv: PUSH_PROMISE\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED);\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"PUSH_PROMISE: insufficient padding space\");\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (ssize_t)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n          break;\n        }\n\n        if (iframe->payloadleft < 4) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, 4);\n\n        break;\n      case NGHTTP2_PING:\n        DEBUGF(\"recv: PING\\n\");\n\n        iframe->frame.hd.flags &= NGHTTP2_FLAG_ACK;\n\n        if (iframe->payloadleft != 8) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n        inbound_frame_set_mark(iframe, 8);\n\n        break;\n      case NGHTTP2_GOAWAY:\n        DEBUGF(\"recv: GOAWAY\\n\");\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft < 8) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n        inbound_frame_set_mark(iframe, 8);\n\n        break;\n      case NGHTTP2_CONTINUATION:\n        DEBUGF(\"recv: unexpected CONTINUATION\\n\");\n\n        /* Receiving CONTINUATION in this state are subject to\n           connection error of type PROTOCOL_ERROR */\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"CONTINUATION: unexpected\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      default:\n        DEBUGF(\"recv: extension frame\\n\");\n\n        if (check_ext_type_set(session->user_recv_ext_types,\n                               iframe->frame.hd.type)) {\n          if (!session->callbacks.unpack_extension_callback) {\n            /* Silently ignore unknown frame type. */\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n            break;\n          }\n\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_READ_EXTENSION_PAYLOAD;\n\n          break;\n        } else {\n          switch (iframe->frame.hd.type) {\n          case NGHTTP2_ALTSVC:\n            if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC) ==\n                0) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: ALTSVC\\n\");\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n            iframe->frame.ext.payload = &iframe->ext_frame_payload.altsvc;\n\n            if (session->server) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            if (iframe->payloadleft < 2) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, 2);\n\n            break;\n          case NGHTTP2_ORIGIN:\n            if (!(session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: ORIGIN\\n\");\n\n            iframe->frame.ext.payload = &iframe->ext_frame_payload.origin;\n\n            if (session->server || iframe->frame.hd.stream_id ||\n                (iframe->frame.hd.flags & 0xf0)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n            if (iframe->payloadleft) {\n              iframe->raw_lbuf = nghttp2_mem_malloc(mem, iframe->payloadleft);\n\n              if (iframe->raw_lbuf == NULL) {\n                return NGHTTP2_ERR_NOMEM;\n              }\n\n              nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf,\n                                    iframe->payloadleft);\n            } else {\n              busy = 1;\n            }\n\n            iframe->state = NGHTTP2_IB_READ_ORIGIN_PAYLOAD;\n\n            break;\n          default:\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n            break;\n          }\n        }\n      }\n\n      if (!on_begin_frame_called) {\n        switch (iframe->state) {\n        case NGHTTP2_IB_IGN_HEADER_BLOCK:\n        case NGHTTP2_IB_IGN_PAYLOAD:\n        case NGHTTP2_IB_FRAME_SIZE_ERROR:\n        case NGHTTP2_IB_IGN_DATA:\n        case NGHTTP2_IB_IGN_ALL:\n          break;\n        default:\n          rv = session_call_on_begin_frame(session, &iframe->frame.hd);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n      }\n\n      break;\n    }\n    case NGHTTP2_IB_READ_NBYTE:\n      DEBUGF(\"recv: [IB_READ_NBYTE]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n      iframe->payloadleft -= readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu, left=%zd\\n\", readlen,\n             iframe->payloadleft, nghttp2_buf_mark_avail(&iframe->sbuf));\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_HEADERS:\n        if (iframe->padlen == 0 &&\n            (iframe->frame.hd.flags & NGHTTP2_FLAG_PADDED)) {\n          pri_fieldlen = nghttp2_frame_priority_len(iframe->frame.hd.flags);\n          padlen = inbound_frame_compute_pad(iframe);\n          if (padlen < 0 ||\n              (size_t)padlen + pri_fieldlen > 1 + iframe->payloadleft) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_PROTOCOL_ERROR, \"HEADERS: invalid padding\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (ssize_t)inlen;\n          }\n          iframe->frame.headers.padlen = (size_t)padlen;\n\n          if (pri_fieldlen > 0) {\n            if (iframe->payloadleft < pri_fieldlen) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, pri_fieldlen);\n            break;\n          } else {\n            /* Truncate buffers used for padding spec */\n            inbound_frame_set_mark(iframe, 0);\n          }\n        }\n\n        rv = session_process_headers_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.hd.stream_id, NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PRIORITY:\n        rv = session_process_priority_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_RST_STREAM:\n        rv = session_process_rst_stream_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_PUSH_PROMISE:\n        if (iframe->padlen == 0 &&\n            (iframe->frame.hd.flags & NGHTTP2_FLAG_PADDED)) {\n          padlen = inbound_frame_compute_pad(iframe);\n          if (padlen < 0 || (size_t)padlen + 4 /* promised stream id */\n                                > 1 + iframe->payloadleft) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_PROTOCOL_ERROR,\n                \"PUSH_PROMISE: invalid padding\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (ssize_t)inlen;\n          }\n\n          iframe->frame.push_promise.padlen = (size_t)padlen;\n\n          if (iframe->payloadleft < 4) {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n            break;\n          }\n\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n          inbound_frame_set_mark(iframe, 4);\n\n          break;\n        }\n\n        rv = session_process_push_promise_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.push_promise.promised_stream_id,\n              NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PING:\n        rv = session_process_ping_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_GOAWAY: {\n        size_t debuglen;\n\n        /* 8 is Last-stream-ID + Error Code */\n        debuglen = iframe->frame.hd.length - 8;\n\n        if (debuglen > 0) {\n          iframe->raw_lbuf = nghttp2_mem_malloc(mem, debuglen);\n\n          if (iframe->raw_lbuf == NULL) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf, debuglen);\n        }\n\n        busy = 1;\n\n        iframe->state = NGHTTP2_IB_READ_GOAWAY_DEBUG;\n\n        break;\n      }\n      case NGHTTP2_WINDOW_UPDATE:\n        rv = session_process_window_update_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_ALTSVC: {\n        size_t origin_len;\n\n        origin_len = nghttp2_get_uint16(iframe->sbuf.pos);\n\n        DEBUGF(\"recv: origin_len=%zu\\n\", origin_len);\n\n        if (origin_len > iframe->payloadleft) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        if (iframe->frame.hd.length > 2) {\n          iframe->raw_lbuf =\n              nghttp2_mem_malloc(mem, iframe->frame.hd.length - 2);\n\n          if (iframe->raw_lbuf == NULL) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf,\n                                iframe->frame.hd.length);\n        }\n\n        busy = 1;\n\n        iframe->state = NGHTTP2_IB_READ_ALTSVC_PAYLOAD;\n\n        break;\n      }\n      default:\n        /* This is unknown frame */\n        session_inbound_frame_reset(session);\n\n        break;\n      }\n      break;\n    case NGHTTP2_IB_READ_HEADER_BLOCK:\n    case NGHTTP2_IB_IGN_HEADER_BLOCK: {\n      ssize_t data_readlen;\n      size_t trail_padlen;\n      int final;\n#ifdef DEBUGBUILD\n      if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n        DEBUGF(\"recv: [IB_READ_HEADER_BLOCK]\\n\");\n      } else {\n        DEBUGF(\"recv: [IB_IGN_HEADER_BLOCK]\\n\");\n      }\n#endif /* DEBUGBUILD */\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft - readlen);\n\n      data_readlen = inbound_frame_effective_readlen(\n          iframe, iframe->payloadleft - readlen, readlen);\n\n      if (data_readlen == -1) {\n        /* everything is padding */\n        data_readlen = 0;\n      }\n\n      trail_padlen = nghttp2_frame_trail_padlen(&iframe->frame, iframe->padlen);\n\n      final = (iframe->frame.hd.flags & NGHTTP2_FLAG_END_HEADERS) &&\n              iframe->payloadleft - (size_t)data_readlen == trail_padlen;\n\n      if (data_readlen > 0 || (data_readlen == 0 && final)) {\n        size_t hd_proclen = 0;\n\n        DEBUGF(\"recv: block final=%d\\n\", final);\n\n        rv =\n            inflate_header_block(session, &iframe->frame, &hd_proclen,\n                                 (uint8_t *)in, (size_t)data_readlen, final,\n                                 iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_PAUSE) {\n          in += hd_proclen;\n          iframe->payloadleft -= hd_proclen;\n\n          return in - first;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          /* The application says no more headers. We decompress the\n             rest of the header block but not invoke on_header_callback\n             and on_frame_recv_callback. */\n          in += hd_proclen;\n          iframe->payloadleft -= hd_proclen;\n\n          /* Use promised stream ID for PUSH_PROMISE */\n          rv = nghttp2_session_add_rst_stream(\n              session,\n              iframe->frame.hd.type == NGHTTP2_PUSH_PROMISE\n                  ? iframe->frame.push_promise.promised_stream_id\n                  : iframe->frame.hd.stream_id,\n              NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          busy = 1;\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        in += readlen;\n        iframe->payloadleft -= readlen;\n\n        if (rv == NGHTTP2_ERR_HEADER_COMP) {\n          /* GOAWAY is already issued */\n          if (iframe->payloadleft == 0) {\n            session_inbound_frame_reset(session);\n          } else {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n          }\n          break;\n        }\n      } else {\n        in += readlen;\n        iframe->payloadleft -= readlen;\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      if ((iframe->frame.hd.flags & NGHTTP2_FLAG_END_HEADERS) == 0) {\n\n        inbound_frame_set_mark(iframe, NGHTTP2_FRAME_HDLEN);\n\n        iframe->padlen = 0;\n\n        if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_EXPECT_CONTINUATION;\n        } else {\n          iframe->state = NGHTTP2_IB_IGN_CONTINUATION;\n        }\n      } else {\n        if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n          rv = session_after_header_block_received(session);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n        session_inbound_frame_reset(session);\n      }\n      break;\n    }\n    case NGHTTP2_IB_IGN_PAYLOAD:\n      DEBUGF(\"recv: [IB_IGN_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_HEADERS:\n      case NGHTTP2_PUSH_PROMISE:\n      case NGHTTP2_CONTINUATION:\n        /* Mark inflater bad so that we won't perform further decoding */\n        session->hd_inflater.ctx.bad = 1;\n        break;\n      default:\n        break;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_FRAME_SIZE_ERROR:\n      DEBUGF(\"recv: [IB_FRAME_SIZE_ERROR]\\n\");\n\n      rv = session_handle_frame_size_error(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      assert(iframe->state == NGHTTP2_IB_IGN_ALL);\n\n      return (ssize_t)inlen;\n    case NGHTTP2_IB_READ_SETTINGS:\n      DEBUGF(\"recv: [IB_READ_SETTINGS]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        break;\n      }\n\n      if (readlen > 0) {\n        inbound_frame_set_settings_entry(iframe);\n      }\n      if (iframe->payloadleft) {\n        inbound_frame_set_mark(iframe, NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH);\n        break;\n      }\n\n      rv = session_process_settings_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_GOAWAY_DEBUG:\n      DEBUGF(\"recv: [IB_READ_GOAWAY_DEBUG]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_goaway_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_EXPECT_CONTINUATION:\n    case NGHTTP2_IB_IGN_CONTINUATION:\n#ifdef DEBUGBUILD\n      if (iframe->state == NGHTTP2_IB_EXPECT_CONTINUATION) {\n        fprintf(stderr, \"recv: [IB_EXPECT_CONTINUATION]\\n\");\n      } else {\n        fprintf(stderr, \"recv: [IB_IGN_CONTINUATION]\\n\");\n      }\n#endif /* DEBUGBUILD */\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      nghttp2_frame_unpack_frame_hd(&cont_hd, iframe->sbuf.pos);\n      iframe->payloadleft = cont_hd.length;\n\n      DEBUGF(\"recv: payloadlen=%zu, type=%u, flags=0x%02x, stream_id=%d\\n\",\n             cont_hd.length, cont_hd.type, cont_hd.flags, cont_hd.stream_id);\n\n      if (cont_hd.type != NGHTTP2_CONTINUATION ||\n          cont_hd.stream_id != iframe->frame.hd.stream_id) {\n        DEBUGF(\"recv: expected stream_id=%d, type=%d, but got stream_id=%d, \"\n               \"type=%u\\n\",\n               iframe->frame.hd.stream_id, NGHTTP2_CONTINUATION,\n               cont_hd.stream_id, cont_hd.type);\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR,\n            \"unexpected non-CONTINUATION frame or stream_id is invalid\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      }\n\n      /* CONTINUATION won't bear NGHTTP2_PADDED flag */\n\n      iframe->frame.hd.flags = (uint8_t)(\n          iframe->frame.hd.flags | (cont_hd.flags & NGHTTP2_FLAG_END_HEADERS));\n      iframe->frame.hd.length += cont_hd.length;\n\n      busy = 1;\n\n      if (iframe->state == NGHTTP2_IB_EXPECT_CONTINUATION) {\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        rv = session_call_on_begin_frame(session, &cont_hd);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      } else {\n        iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n      }\n\n      break;\n    case NGHTTP2_IB_READ_PAD_DATA:\n      DEBUGF(\"recv: [IB_READ_PAD_DATA]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n      iframe->payloadleft -= readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu, left=%zu\\n\", readlen,\n             iframe->payloadleft, nghttp2_buf_mark_avail(&iframe->sbuf));\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      /* Pad Length field is subject to flow control */\n      rv = nghttp2_session_update_recv_connection_window_size(session, readlen);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      /* Pad Length field is consumed immediately */\n      rv =\n          nghttp2_session_consume(session, iframe->frame.hd.stream_id, readlen);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      stream = nghttp2_session_get_stream(session, iframe->frame.hd.stream_id);\n      if (stream) {\n        rv = nghttp2_session_update_recv_stream_window_size(\n            session, stream, readlen,\n            iframe->payloadleft ||\n                (iframe->frame.hd.flags & NGHTTP2_FLAG_END_STREAM) == 0);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      }\n\n      busy = 1;\n\n      padlen = inbound_frame_compute_pad(iframe);\n      if (padlen < 0) {\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"DATA: invalid padding\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        return (ssize_t)inlen;\n      }\n\n      iframe->frame.data.padlen = (size_t)padlen;\n\n      iframe->state = NGHTTP2_IB_READ_DATA;\n\n      break;\n    case NGHTTP2_IB_READ_DATA:\n      stream = nghttp2_session_get_stream(session, iframe->frame.hd.stream_id);\n\n      if (!stream) {\n        busy = 1;\n        iframe->state = NGHTTP2_IB_IGN_DATA;\n        break;\n      }\n\n      DEBUGF(\"recv: [IB_READ_DATA]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        ssize_t data_readlen;\n\n        rv = nghttp2_session_update_recv_connection_window_size(session,\n                                                                readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        rv = nghttp2_session_update_recv_stream_window_size(\n            session, stream, readlen,\n            iframe->payloadleft ||\n                (iframe->frame.hd.flags & NGHTTP2_FLAG_END_STREAM) == 0);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        data_readlen = inbound_frame_effective_readlen(\n            iframe, iframe->payloadleft, readlen);\n\n        if (data_readlen == -1) {\n          /* everything is padding */\n          data_readlen = 0;\n        }\n\n        padlen = (ssize_t)readlen - data_readlen;\n\n        if (padlen > 0) {\n          /* Padding is considered as \"consumed\" immediately */\n          rv = nghttp2_session_consume(session, iframe->frame.hd.stream_id,\n                                       (size_t)padlen);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (ssize_t)inlen;\n          }\n        }\n\n        DEBUGF(\"recv: data_readlen=%zd\\n\", data_readlen);\n\n        if (data_readlen > 0) {\n          if (session_enforce_http_messaging(session)) {\n            if (nghttp2_http_on_data_chunk(stream, (size_t)data_readlen) != 0) {\n              if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n                /* Consume all data for connection immediately here */\n                rv = session_update_connection_consumed_size(\n                    session, (size_t)data_readlen);\n\n                if (nghttp2_is_fatal(rv)) {\n                  return rv;\n                }\n\n                if (iframe->state == NGHTTP2_IB_IGN_DATA) {\n                  return (ssize_t)inlen;\n                }\n              }\n\n              rv = nghttp2_session_add_rst_stream(\n                  session, iframe->frame.hd.stream_id, NGHTTP2_PROTOCOL_ERROR);\n              if (nghttp2_is_fatal(rv)) {\n                return rv;\n              }\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_DATA;\n              break;\n            }\n          }\n          if (session->callbacks.on_data_chunk_recv_callback) {\n            rv = session->callbacks.on_data_chunk_recv_callback(\n                session, iframe->frame.hd.flags, iframe->frame.hd.stream_id,\n                in - readlen, (size_t)data_readlen, session->user_data);\n            if (rv == NGHTTP2_ERR_PAUSE) {\n              return in - first;\n            }\n\n            if (nghttp2_is_fatal(rv)) {\n              return NGHTTP2_ERR_CALLBACK_FAILURE;\n            }\n          }\n        }\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      rv = session_process_data_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_IGN_DATA:\n      DEBUGF(\"recv: [IB_IGN_DATA]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        /* Update connection-level flow control window for ignored\n           DATA frame too */\n        rv = nghttp2_session_update_recv_connection_window_size(session,\n                                                                readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n\n          /* Ignored DATA is considered as \"consumed\" immediately. */\n          rv = session_update_connection_consumed_size(session, readlen);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (ssize_t)inlen;\n          }\n        }\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_IGN_ALL:\n      return (ssize_t)inlen;\n    case NGHTTP2_IB_READ_EXTENSION_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_EXTENSION_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        rv = session_call_on_extension_chunk_recv_callback(\n            session, in - readlen, readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (rv != 0) {\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n          break;\n        }\n      }\n\n      if (iframe->payloadleft > 0) {\n        break;\n      }\n\n      rv = session_process_extension_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_ALTSVC_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_ALTSVC_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_altsvc_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_ORIGIN_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_ORIGIN_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_origin_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    }\n\n    if (!busy && in == last) {\n      break;\n    }\n\n    busy = 0;\n  }\n\n  assert(in == last);\n\n  return in - first;\n}\n\nint nghttp2_session_recv(nghttp2_session *session) {\n  uint8_t buf[NGHTTP2_INBOUND_BUFFER_LENGTH];\n  while (1) {\n    ssize_t readlen;\n    readlen = session_recv(session, buf, sizeof(buf));\n    if (readlen > 0) {\n      ssize_t proclen = nghttp2_session_mem_recv(session, buf, (size_t)readlen);\n      if (proclen < 0) {\n        return (int)proclen;\n      }\n      assert(proclen == readlen);\n    } else if (readlen == 0 || readlen == NGHTTP2_ERR_WOULDBLOCK) {\n      return 0;\n    } else if (readlen == NGHTTP2_ERR_EOF) {\n      return NGHTTP2_ERR_EOF;\n    } else if (readlen < 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n}\n\n/*\n * Returns the number of active streams, which includes streams in\n * reserved state.\n */\nstatic size_t session_get_num_active_streams(nghttp2_session *session) {\n  return nghttp2_map_size(&session->streams) - session->num_closed_streams -\n         session->num_idle_streams;\n}\n\nint nghttp2_session_want_read(nghttp2_session *session) {\n  size_t num_active_streams;\n\n  /* If this flag is set, we don't want to read. The application\n     should drop the connection. */\n  if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_SENT) {\n    return 0;\n  }\n\n  num_active_streams = session_get_num_active_streams(session);\n\n  /* Unless termination GOAWAY is sent or received, we always want to\n     read incoming frames. */\n\n  if (num_active_streams > 0) {\n    return 1;\n  }\n\n  /* If there is no active streams and GOAWAY has been sent or\n     received, we are done with this session. */\n  return (session->goaway_flags &\n          (NGHTTP2_GOAWAY_SENT | NGHTTP2_GOAWAY_RECV)) == 0;\n}\n\nint nghttp2_session_want_write(nghttp2_session *session) {\n  /* If these flag is set, we don't want to write any data. The\n     application should drop the connection. */\n  if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_SENT) {\n    return 0;\n  }\n\n  /*\n   * Unless termination GOAWAY is sent or received, we want to write\n   * frames if there is pending ones. If pending frame is request/push\n   * response HEADERS and concurrent stream limit is reached, we don't\n   * want to write them.\n   */\n  return session->aob.item || nghttp2_outbound_queue_top(&session->ob_urgent) ||\n         nghttp2_outbound_queue_top(&session->ob_reg) ||\n         (!nghttp2_pq_empty(&session->root.obq) &&\n          session->remote_window_size > 0) ||\n         (nghttp2_outbound_queue_top(&session->ob_syn) &&\n          !session_is_outgoing_concurrent_streams_max(session));\n}\n\nint nghttp2_session_add_ping(nghttp2_session *session, uint8_t flags,\n                             const uint8_t *opaque_data) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if ((flags & NGHTTP2_FLAG_ACK) &&\n      session->obq_flood_counter_ >= session->max_outbound_ack) {\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_ping_init(&frame->ping, flags, opaque_data);\n\n  rv = nghttp2_session_add_item(session, item);\n\n  if (rv != 0) {\n    nghttp2_frame_ping_free(&frame->ping);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n\n  if (flags & NGHTTP2_FLAG_ACK) {\n    ++session->obq_flood_counter_;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_add_goaway(nghttp2_session *session, int32_t last_stream_id,\n                               uint32_t error_code, const uint8_t *opaque_data,\n                               size_t opaque_data_len, uint8_t aux_flags) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  uint8_t *opaque_data_copy = NULL;\n  nghttp2_goaway_aux_data *aux_data;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if (nghttp2_session_is_my_stream_id(session, last_stream_id)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (opaque_data_len) {\n    if (opaque_data_len + 8 > NGHTTP2_MAX_PAYLOADLEN) {\n      return NGHTTP2_ERR_INVALID_ARGUMENT;\n    }\n    opaque_data_copy = nghttp2_mem_malloc(mem, opaque_data_len);\n    if (opaque_data_copy == NULL) {\n      return NGHTTP2_ERR_NOMEM;\n    }\n    memcpy(opaque_data_copy, opaque_data, opaque_data_len);\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    nghttp2_mem_free(mem, opaque_data_copy);\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  /* last_stream_id must not be increased from the value previously\n     sent */\n  last_stream_id = nghttp2_min(last_stream_id, session->local_last_stream_id);\n\n  nghttp2_frame_goaway_init(&frame->goaway, last_stream_id, error_code,\n                            opaque_data_copy, opaque_data_len);\n\n  aux_data = &item->aux_data.goaway;\n  aux_data->flags = aux_flags;\n\n  rv = nghttp2_session_add_item(session, item);\n  if (rv != 0) {\n    nghttp2_frame_goaway_free(&frame->goaway, mem);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_add_window_update(nghttp2_session *session, uint8_t flags,\n                                      int32_t stream_id,\n                                      int32_t window_size_increment) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_window_update_init(&frame->window_update, flags, stream_id,\n                                   window_size_increment);\n\n  rv = nghttp2_session_add_item(session, item);\n\n  if (rv != 0) {\n    nghttp2_frame_window_update_free(&frame->window_update);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n  return 0;\n}\n\nstatic void\nsession_append_inflight_settings(nghttp2_session *session,\n                                 nghttp2_inflight_settings *settings) {\n  nghttp2_inflight_settings **i;\n\n  for (i = &session->inflight_settings_head; *i; i = &(*i)->next)\n    ;\n\n  *i = settings;\n}\n\nint nghttp2_session_add_settings(nghttp2_session *session, uint8_t flags,\n                                 const nghttp2_settings_entry *iv, size_t niv) {\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_settings_entry *iv_copy;\n  size_t i;\n  int rv;\n  nghttp2_mem *mem;\n  nghttp2_inflight_settings *inflight_settings = NULL;\n\n  mem = &session->mem;\n\n  if (flags & NGHTTP2_FLAG_ACK) {\n    if (niv != 0) {\n      return NGHTTP2_ERR_INVALID_ARGUMENT;\n    }\n\n    if (session->obq_flood_counter_ >= session->max_outbound_ack) {\n      return NGHTTP2_ERR_FLOODED;\n    }\n  }\n\n  if (!nghttp2_iv_check(iv, niv)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  if (niv > 0) {\n    iv_copy = nghttp2_frame_iv_copy(iv, niv, mem);\n    if (iv_copy == NULL) {\n      nghttp2_mem_free(mem, item);\n      return NGHTTP2_ERR_NOMEM;\n    }\n  } else {\n    iv_copy = NULL;\n  }\n\n  if ((flags & NGHTTP2_FLAG_ACK) == 0) {\n    rv = inflight_settings_new(&inflight_settings, iv, niv, mem);\n    if (rv != 0) {\n      assert(nghttp2_is_fatal(rv));\n      nghttp2_mem_free(mem, iv_copy);\n      nghttp2_mem_free(mem, item);\n      return rv;\n    }\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_settings_init(&frame->settings, flags, iv_copy, niv);\n  rv = nghttp2_session_add_item(session, item);\n  if (rv != 0) {\n    /* The only expected error is fatal one */\n    assert(nghttp2_is_fatal(rv));\n\n    inflight_settings_del(inflight_settings, mem);\n\n    nghttp2_frame_settings_free(&frame->settings, mem);\n    nghttp2_mem_free(mem, item);\n\n    return rv;\n  }\n\n  if (flags & NGHTTP2_FLAG_ACK) {\n    ++session->obq_flood_counter_;\n  } else {\n    session_append_inflight_settings(session, inflight_settings);\n  }\n\n  /* Extract NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS and ENABLE_PUSH\n     here.  We use it to refuse the incoming stream and PUSH_PROMISE\n     with RST_STREAM. */\n\n  for (i = niv; i > 0; --i) {\n    if (iv[i - 1].settings_id == NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS) {\n      session->pending_local_max_concurrent_stream = iv[i - 1].value;\n      break;\n    }\n  }\n\n  for (i = niv; i > 0; --i) {\n    if (iv[i - 1].settings_id == NGHTTP2_SETTINGS_ENABLE_PUSH) {\n      session->pending_enable_push = (uint8_t)iv[i - 1].value;\n      break;\n    }\n  }\n\n  for (i = niv; i > 0; --i) {\n    if (iv[i - 1].settings_id == NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL) {\n      session->pending_enable_connect_protocol = (uint8_t)iv[i - 1].value;\n      break;\n    }\n  }\n\n  return 0;\n}\n\nint nghttp2_session_pack_data(nghttp2_session *session, nghttp2_bufs *bufs,\n                              size_t datamax, nghttp2_frame *frame,\n                              nghttp2_data_aux_data *aux_data,\n                              nghttp2_stream *stream) {\n  int rv;\n  uint32_t data_flags;\n  ssize_t payloadlen;\n  ssize_t padded_payloadlen;\n  nghttp2_buf *buf;\n  size_t max_payloadlen;\n\n  assert(bufs->head == bufs->cur);\n\n  buf = &bufs->cur->buf;\n\n  if (session->callbacks.read_length_callback) {\n\n    payloadlen = session->callbacks.read_length_callback(\n        session, frame->hd.type, stream->stream_id, session->remote_window_size,\n        stream->remote_window_size, session->remote_settings.max_frame_size,\n        session->user_data);\n\n    DEBUGF(\"send: read_length_callback=%zd\\n\", payloadlen);\n\n    payloadlen = nghttp2_session_enforce_flow_control_limits(session, stream,\n                                                             payloadlen);\n\n    DEBUGF(\"send: read_length_callback after flow control=%zd\\n\", payloadlen);\n\n    if (payloadlen <= 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n\n    if ((size_t)payloadlen > nghttp2_buf_avail(buf)) {\n      /* Resize the current buffer(s).  The reason why we do +1 for\n         buffer size is for possible padding field. */\n      rv = nghttp2_bufs_realloc(&session->aob.framebufs,\n                                (size_t)(NGHTTP2_FRAME_HDLEN + 1 + payloadlen));\n\n      if (rv != 0) {\n        DEBUGF(\"send: realloc buffer failed rv=%d\", rv);\n        /* If reallocation failed, old buffers are still in tact.  So\n           use safe limit. */\n        payloadlen = (ssize_t)datamax;\n\n        DEBUGF(\"send: use safe limit payloadlen=%zd\", payloadlen);\n      } else {\n        assert(&session->aob.framebufs == bufs);\n\n        buf = &bufs->cur->buf;\n      }\n    }\n    datamax = (size_t)payloadlen;\n  }\n\n  /* Current max DATA length is less then buffer chunk size */\n  assert(nghttp2_buf_avail(buf) >= datamax);\n\n  data_flags = NGHTTP2_DATA_FLAG_NONE;\n  payloadlen = aux_data->data_prd.read_callback(\n      session, frame->hd.stream_id, buf->pos, datamax, &data_flags,\n      &aux_data->data_prd.source, session->user_data);\n\n  if (payloadlen == NGHTTP2_ERR_DEFERRED ||\n      payloadlen == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ||\n      payloadlen == NGHTTP2_ERR_PAUSE) {\n    DEBUGF(\"send: DATA postponed due to %s\\n\",\n           nghttp2_strerror((int)payloadlen));\n\n    return (int)payloadlen;\n  }\n\n  if (payloadlen < 0 || datamax < (size_t)payloadlen) {\n    /* This is the error code when callback is failed. */\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  buf->last = buf->pos + payloadlen;\n  buf->pos -= NGHTTP2_FRAME_HDLEN;\n\n  /* Clear flags, because this may contain previous flags of previous\n     DATA */\n  frame->hd.flags = NGHTTP2_FLAG_NONE;\n\n  if (data_flags & NGHTTP2_DATA_FLAG_EOF) {\n    aux_data->eof = 1;\n    /* If NGHTTP2_DATA_FLAG_NO_END_STREAM is set, don't set\n       NGHTTP2_FLAG_END_STREAM */\n    if ((aux_data->flags & NGHTTP2_FLAG_END_STREAM) &&\n        (data_flags & NGHTTP2_DATA_FLAG_NO_END_STREAM) == 0) {\n      frame->hd.flags |= NGHTTP2_FLAG_END_STREAM;\n    }\n  }\n\n  if (data_flags & NGHTTP2_DATA_FLAG_NO_COPY) {\n    if (session->callbacks.send_data_callback == NULL) {\n      DEBUGF(\"NGHTTP2_DATA_FLAG_NO_COPY requires send_data_callback set\\n\");\n\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    aux_data->no_copy = 1;\n  }\n\n  frame->hd.length = (size_t)payloadlen;\n  frame->data.padlen = 0;\n\n  max_payloadlen = nghttp2_min(datamax, frame->hd.length + NGHTTP2_MAX_PADLEN);\n\n  padded_payloadlen =\n      session_call_select_padding(session, frame, max_payloadlen);\n\n  if (nghttp2_is_fatal((int)padded_payloadlen)) {\n    return (int)padded_payloadlen;\n  }\n\n  frame->data.padlen = (size_t)(padded_payloadlen - payloadlen);\n\n  nghttp2_frame_pack_frame_hd(buf->pos, &frame->hd);\n\n  rv = nghttp2_frame_add_pad(bufs, &frame->hd, frame->data.padlen,\n                             aux_data->no_copy);\n  if (rv != 0) {\n    return rv;\n  }\n\n  reschedule_stream(stream);\n\n  if (frame->hd.length == 0 && (data_flags & NGHTTP2_DATA_FLAG_EOF) &&\n      (data_flags & NGHTTP2_DATA_FLAG_NO_END_STREAM)) {\n    /* DATA payload length is 0, and DATA frame does not bear\n       END_STREAM.  In this case, there is no point to send 0 length\n       DATA frame. */\n    return NGHTTP2_ERR_CANCEL;\n  }\n\n  return 0;\n}\n\nvoid *nghttp2_session_get_stream_user_data(nghttp2_session *session,\n                                           int32_t stream_id) {\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream) {\n    return stream->stream_user_data;\n  } else {\n    return NULL;\n  }\n}\n\nint nghttp2_session_set_stream_user_data(nghttp2_session *session,\n                                         int32_t stream_id,\n                                         void *stream_user_data) {\n  nghttp2_stream *stream;\n  nghttp2_frame *frame;\n  nghttp2_outbound_item *item;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream) {\n    stream->stream_user_data = stream_user_data;\n    return 0;\n  }\n\n  if (session->server || !nghttp2_session_is_my_stream_id(session, stream_id) ||\n      !nghttp2_outbound_queue_top(&session->ob_syn)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  frame = &nghttp2_outbound_queue_top(&session->ob_syn)->frame;\n  assert(frame->hd.type == NGHTTP2_HEADERS);\n\n  if (frame->hd.stream_id > stream_id ||\n      (uint32_t)stream_id >= session->next_stream_id) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  for (item = session->ob_syn.head; item; item = item->qnext) {\n    if (item->frame.hd.stream_id < stream_id) {\n      continue;\n    }\n\n    if (item->frame.hd.stream_id > stream_id) {\n      break;\n    }\n\n    item->aux_data.headers.stream_user_data = stream_user_data;\n    return 0;\n  }\n\n  return NGHTTP2_ERR_INVALID_ARGUMENT;\n}\n\nint nghttp2_session_resume_data(nghttp2_session *session, int32_t stream_id) {\n  int rv;\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL || !nghttp2_stream_check_deferred_item(stream)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  rv = nghttp2_stream_resume_deferred_item(stream,\n                                           NGHTTP2_STREAM_FLAG_DEFERRED_USER);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nsize_t nghttp2_session_get_outbound_queue_size(nghttp2_session *session) {\n  return nghttp2_outbound_queue_size(&session->ob_urgent) +\n         nghttp2_outbound_queue_size(&session->ob_reg) +\n         nghttp2_outbound_queue_size(&session->ob_syn);\n  /* TODO account for item attached to stream */\n}\n\nint32_t\nnghttp2_session_get_stream_effective_recv_data_length(nghttp2_session *session,\n                                                      int32_t stream_id) {\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n  return stream->recv_window_size < 0 ? 0 : stream->recv_window_size;\n}\n\nint32_t\nnghttp2_session_get_stream_effective_local_window_size(nghttp2_session *session,\n                                                       int32_t stream_id) {\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n  return stream->local_window_size;\n}\n\nint32_t nghttp2_session_get_stream_local_window_size(nghttp2_session *session,\n                                                     int32_t stream_id) {\n  nghttp2_stream *stream;\n  int32_t size;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n\n  size = stream->local_window_size - stream->recv_window_size;\n\n  /* size could be negative if local endpoint reduced\n     SETTINGS_INITIAL_WINDOW_SIZE */\n  if (size < 0) {\n    return 0;\n  }\n\n  return size;\n}\n\nint32_t\nnghttp2_session_get_effective_recv_data_length(nghttp2_session *session) {\n  return session->recv_window_size < 0 ? 0 : session->recv_window_size;\n}\n\nint32_t\nnghttp2_session_get_effective_local_window_size(nghttp2_session *session) {\n  return session->local_window_size;\n}\n\nint32_t nghttp2_session_get_local_window_size(nghttp2_session *session) {\n  return session->local_window_size - session->recv_window_size;\n}\n\nint32_t nghttp2_session_get_stream_remote_window_size(nghttp2_session *session,\n                                                      int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n\n  /* stream->remote_window_size can be negative when\n     SETTINGS_INITIAL_WINDOW_SIZE is changed. */\n  return nghttp2_max(0, stream->remote_window_size);\n}\n\nint32_t nghttp2_session_get_remote_window_size(nghttp2_session *session) {\n  return session->remote_window_size;\n}\n\nuint32_t nghttp2_session_get_remote_settings(nghttp2_session *session,\n                                             nghttp2_settings_id id) {\n  switch (id) {\n  case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n    return session->remote_settings.header_table_size;\n  case NGHTTP2_SETTINGS_ENABLE_PUSH:\n    return session->remote_settings.enable_push;\n  case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n    return session->remote_settings.max_concurrent_streams;\n  case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n    return session->remote_settings.initial_window_size;\n  case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n    return session->remote_settings.max_frame_size;\n  case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n    return session->remote_settings.max_header_list_size;\n  case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n    return session->remote_settings.enable_connect_protocol;\n  }\n\n  assert(0);\n  abort(); /* if NDEBUG is set */\n}\n\nuint32_t nghttp2_session_get_local_settings(nghttp2_session *session,\n                                            nghttp2_settings_id id) {\n  switch (id) {\n  case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n    return session->local_settings.header_table_size;\n  case NGHTTP2_SETTINGS_ENABLE_PUSH:\n    return session->local_settings.enable_push;\n  case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n    return session->local_settings.max_concurrent_streams;\n  case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n    return session->local_settings.initial_window_size;\n  case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n    return session->local_settings.max_frame_size;\n  case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n    return session->local_settings.max_header_list_size;\n  case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n    return session->local_settings.enable_connect_protocol;\n  }\n\n  assert(0);\n  abort(); /* if NDEBUG is set */\n}\n\nstatic int nghttp2_session_upgrade_internal(nghttp2_session *session,\n                                            const uint8_t *settings_payload,\n                                            size_t settings_payloadlen,\n                                            void *stream_user_data) {\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n  nghttp2_settings_entry *iv;\n  size_t niv;\n  int rv;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if ((!session->server && session->next_stream_id != 1) ||\n      (session->server && session->last_recv_stream_id >= 1)) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n  rv = nghttp2_frame_unpack_settings_payload2(&iv, &niv, settings_payload,\n                                              settings_payloadlen, mem);\n  if (rv != 0) {\n    return rv;\n  }\n\n  if (session->server) {\n    nghttp2_frame_hd_init(&frame.hd, settings_payloadlen, NGHTTP2_SETTINGS,\n                          NGHTTP2_FLAG_NONE, 0);\n    frame.settings.iv = iv;\n    frame.settings.niv = niv;\n    rv = nghttp2_session_on_settings_received(session, &frame, 1 /* No ACK */);\n  } else {\n    rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, niv);\n  }\n  nghttp2_mem_free(mem, iv);\n  if (rv != 0) {\n    return rv;\n  }\n\n  nghttp2_priority_spec_default_init(&pri_spec);\n\n  stream = nghttp2_session_open_stream(\n      session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec, NGHTTP2_STREAM_OPENING,\n      session->server ? NULL : stream_user_data);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't call nghttp2_session_adjust_closed_stream(), since this\n     should be the first stream open. */\n\n  if (session->server) {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    session->last_recv_stream_id = 1;\n    session->last_proc_stream_id = 1;\n  } else {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n    session->last_sent_stream_id = 1;\n    session->next_stream_id += 2;\n  }\n  return 0;\n}\n\nint nghttp2_session_upgrade(nghttp2_session *session,\n                            const uint8_t *settings_payload,\n                            size_t settings_payloadlen,\n                            void *stream_user_data) {\n  int rv;\n  nghttp2_stream *stream;\n\n  rv = nghttp2_session_upgrade_internal(session, settings_payload,\n                                        settings_payloadlen, stream_user_data);\n  if (rv != 0) {\n    return rv;\n  }\n\n  stream = nghttp2_session_get_stream(session, 1);\n  assert(stream);\n\n  /* We have no information about request header fields when Upgrade\n     was happened.  So we don't know the request method here.  If\n     request method is HEAD, we have a trouble because we may have\n     nonzero content-length header field in response headers, and we\n     will going to check it against the actual DATA frames, but we may\n     get mismatch because HEAD response body must be empty.  Because\n     of this reason, nghttp2_session_upgrade() was deprecated in favor\n     of nghttp2_session_upgrade2(), which has |head_request| parameter\n     to indicate that request method is HEAD or not. */\n  stream->http_flags |= NGHTTP2_HTTP_FLAG_METH_UPGRADE_WORKAROUND;\n  return 0;\n}\n\nint nghttp2_session_upgrade2(nghttp2_session *session,\n                             const uint8_t *settings_payload,\n                             size_t settings_payloadlen, int head_request,\n                             void *stream_user_data) {\n  int rv;\n  nghttp2_stream *stream;\n\n  rv = nghttp2_session_upgrade_internal(session, settings_payload,\n                                        settings_payloadlen, stream_user_data);\n  if (rv != 0) {\n    return rv;\n  }\n\n  stream = nghttp2_session_get_stream(session, 1);\n  assert(stream);\n\n  if (head_request) {\n    stream->http_flags |= NGHTTP2_HTTP_FLAG_METH_HEAD;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_get_stream_local_close(nghttp2_session *session,\n                                           int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return -1;\n  }\n\n  return (stream->shut_flags & NGHTTP2_SHUT_WR) != 0;\n}\n\nint nghttp2_session_get_stream_remote_close(nghttp2_session *session,\n                                            int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return -1;\n  }\n\n  return (stream->shut_flags & NGHTTP2_SHUT_RD) != 0;\n}\n\nint nghttp2_session_consume(nghttp2_session *session, int32_t stream_id,\n                            size_t size) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (stream_id == 0) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE)) {\n    return NGHTTP2_ERR_INVALID_STATE;\n  }\n\n  rv = session_update_connection_consumed_size(session, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return 0;\n  }\n\n  rv = session_update_stream_consumed_size(session, stream, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_consume_connection(nghttp2_session *session, size_t size) {\n  int rv;\n\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE)) {\n    return NGHTTP2_ERR_INVALID_STATE;\n  }\n\n  rv = session_update_connection_consumed_size(session, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_consume_stream(nghttp2_session *session, int32_t stream_id,\n                                   size_t size) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (stream_id == 0) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE)) {\n    return NGHTTP2_ERR_INVALID_STATE;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return 0;\n  }\n\n  rv = session_update_stream_consumed_size(session, stream, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_set_next_stream_id(nghttp2_session *session,\n                                       int32_t next_stream_id) {\n  if (next_stream_id <= 0 ||\n      session->next_stream_id > (uint32_t)next_stream_id) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (session->server) {\n    if (next_stream_id % 2) {\n      return NGHTTP2_ERR_INVALID_ARGUMENT;\n    }\n  } else if (next_stream_id % 2 == 0) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  session->next_stream_id = (uint32_t)next_stream_id;\n  return 0;\n}\n\nuint32_t nghttp2_session_get_next_stream_id(nghttp2_session *session) {\n  return session->next_stream_id;\n}\n\nint32_t nghttp2_session_get_last_proc_stream_id(nghttp2_session *session) {\n  return session->last_proc_stream_id;\n}\n\nnghttp2_stream *nghttp2_session_find_stream(nghttp2_session *session,\n                                            int32_t stream_id) {\n  if (stream_id == 0) {\n    return &session->root;\n  }\n\n  return nghttp2_session_get_stream_raw(session, stream_id);\n}\n\nnghttp2_stream *nghttp2_session_get_root_stream(nghttp2_session *session) {\n  return &session->root;\n}\n\nint nghttp2_session_check_server_session(nghttp2_session *session) {\n  return session->server;\n}\n\nint nghttp2_session_change_stream_priority(\n    nghttp2_session *session, int32_t stream_id,\n    const nghttp2_priority_spec *pri_spec) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec_copy;\n\n  if (stream_id == 0 || stream_id == pri_spec->stream_id) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n  if (!stream) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  pri_spec_copy = *pri_spec;\n  nghttp2_priority_spec_normalize_weight(&pri_spec_copy);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec_copy);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  /* We don't intentionally call nghttp2_session_adjust_idle_stream()\n     so that idle stream created by this function, and existing ones\n     are kept for application.  We will adjust number of idle stream\n     in nghttp2_session_mem_send or nghttp2_session_mem_recv is\n     called. */\n  return 0;\n}\n\nint nghttp2_session_create_idle_stream(nghttp2_session *session,\n                                       int32_t stream_id,\n                                       const nghttp2_priority_spec *pri_spec) {\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec_copy;\n\n  if (stream_id == 0 || stream_id == pri_spec->stream_id ||\n      !session_detect_idle_stream(session, stream_id)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n  if (stream) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  pri_spec_copy = *pri_spec;\n  nghttp2_priority_spec_normalize_weight(&pri_spec_copy);\n\n  stream =\n      nghttp2_session_open_stream(session, stream_id, NGHTTP2_STREAM_FLAG_NONE,\n                                  &pri_spec_copy, NGHTTP2_STREAM_IDLE, NULL);\n  if (!stream) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't intentionally call nghttp2_session_adjust_idle_stream()\n     so that idle stream created by this function, and existing ones\n     are kept for application.  We will adjust number of idle stream\n     in nghttp2_session_mem_send or nghttp2_session_mem_recv is\n     called. */\n  return 0;\n}\n\nsize_t\nnghttp2_session_get_hd_inflate_dynamic_table_size(nghttp2_session *session) {\n  return nghttp2_hd_inflate_get_dynamic_table_size(&session->hd_inflater);\n}\n\nsize_t\nnghttp2_session_get_hd_deflate_dynamic_table_size(nghttp2_session *session) {\n  return nghttp2_hd_deflate_get_dynamic_table_size(&session->hd_deflater);\n}\n\nvoid nghttp2_session_set_user_data(nghttp2_session *session, void *user_data) {\n  session->user_data = user_data;\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_SESSION_H\n#define NGHTTP2_SESSION_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <nghttp2/nghttp2.h>\n#include \"nghttp2_map.h\"\n#include \"nghttp2_frame.h\"\n#include \"nghttp2_hd.h\"\n#include \"nghttp2_stream.h\"\n#include \"nghttp2_outbound_item.h\"\n#include \"nghttp2_int.h\"\n#include \"nghttp2_buf.h\"\n#include \"nghttp2_callbacks.h\"\n#include \"nghttp2_mem.h\"\n\n/* The global variable for tests where we want to disable strict\n   preface handling. */\nextern int nghttp2_enable_strict_preface;\n\n/*\n * Option flags.\n */\ntypedef enum {\n  NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE = 1 << 0,\n  NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC = 1 << 1,\n  NGHTTP2_OPTMASK_NO_HTTP_MESSAGING = 1 << 2,\n  NGHTTP2_OPTMASK_NO_AUTO_PING_ACK = 1 << 3,\n  NGHTTP2_OPTMASK_NO_CLOSED_STREAMS = 1 << 4\n} nghttp2_optmask;\n\n/*\n * bitmask for built-in type to enable the default handling for that\n * type of the frame.\n */\ntypedef enum {\n  NGHTTP2_TYPEMASK_NONE = 0,\n  NGHTTP2_TYPEMASK_ALTSVC = 1 << 0,\n  NGHTTP2_TYPEMASK_ORIGIN = 1 << 1\n} nghttp2_typemask;\n\ntypedef enum {\n  NGHTTP2_OB_POP_ITEM,\n  NGHTTP2_OB_SEND_DATA,\n  NGHTTP2_OB_SEND_NO_COPY,\n  NGHTTP2_OB_SEND_CLIENT_MAGIC\n} nghttp2_outbound_state;\n\ntypedef struct {\n  nghttp2_outbound_item *item;\n  nghttp2_bufs framebufs;\n  nghttp2_outbound_state state;\n} nghttp2_active_outbound_item;\n\n/* Buffer length for inbound raw byte stream used in\n   nghttp2_session_recv(). */\n#define NGHTTP2_INBOUND_BUFFER_LENGTH 16384\n\n/* The default maximum number of incoming reserved streams */\n#define NGHTTP2_MAX_INCOMING_RESERVED_STREAMS 200\n\n/* Even if we have less SETTINGS_MAX_CONCURRENT_STREAMS than this\n   number, we keep NGHTTP2_MIN_IDLE_STREAMS streams in idle state */\n#define NGHTTP2_MIN_IDLE_STREAMS 16\n\n/* The maximum number of items in outbound queue, which is considered\n   as flooding caused by peer.  All frames are not considered here.\n   We only consider PING + ACK and SETTINGS + ACK.  This is because\n   they both are response to the frame initiated by peer and peer can\n   send as many of them as they want.  If peer does not read network,\n   response frames are stacked up, which leads to memory exhaustion.\n   The value selected here is arbitrary, but safe value and if we have\n   these frames in this number, it is considered suspicious. */\n#define NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM 1000\n\n/* The default value of maximum number of concurrent streams. */\n#define NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS 0xffffffffu\n\n/* Internal state when receiving incoming frame */\ntypedef enum {\n  /* Receiving frame header */\n  NGHTTP2_IB_READ_CLIENT_MAGIC,\n  NGHTTP2_IB_READ_FIRST_SETTINGS,\n  NGHTTP2_IB_READ_HEAD,\n  NGHTTP2_IB_READ_NBYTE,\n  NGHTTP2_IB_READ_HEADER_BLOCK,\n  NGHTTP2_IB_IGN_HEADER_BLOCK,\n  NGHTTP2_IB_IGN_PAYLOAD,\n  NGHTTP2_IB_FRAME_SIZE_ERROR,\n  NGHTTP2_IB_READ_SETTINGS,\n  NGHTTP2_IB_READ_GOAWAY_DEBUG,\n  NGHTTP2_IB_EXPECT_CONTINUATION,\n  NGHTTP2_IB_IGN_CONTINUATION,\n  NGHTTP2_IB_READ_PAD_DATA,\n  NGHTTP2_IB_READ_DATA,\n  NGHTTP2_IB_IGN_DATA,\n  NGHTTP2_IB_IGN_ALL,\n  NGHTTP2_IB_READ_ALTSVC_PAYLOAD,\n  NGHTTP2_IB_READ_ORIGIN_PAYLOAD,\n  NGHTTP2_IB_READ_EXTENSION_PAYLOAD\n} nghttp2_inbound_state;\n\ntypedef struct {\n  nghttp2_frame frame;\n  /* Storage for extension frame payload.  frame->ext.payload points\n     to this structure to avoid frequent memory allocation. */\n  nghttp2_ext_frame_payload ext_frame_payload;\n  /* The received SETTINGS entry.  For the standard settings entries,\n     we only keep the last seen value.  For\n     SETTINGS_HEADER_TABLE_SIZE, we also keep minimum value in the\n     last index. */\n  nghttp2_settings_entry *iv;\n  /* buffer pointers to small buffer, raw_sbuf */\n  nghttp2_buf sbuf;\n  /* buffer pointers to large buffer, raw_lbuf */\n  nghttp2_buf lbuf;\n  /* Large buffer, malloced on demand */\n  uint8_t *raw_lbuf;\n  /* The number of entry filled in |iv| */\n  size_t niv;\n  /* The number of entries |iv| can store. */\n  size_t max_niv;\n  /* How many bytes we still need to receive for current frame */\n  size_t payloadleft;\n  /* padding length for the current frame */\n  size_t padlen;\n  nghttp2_inbound_state state;\n  /* Small buffer.  Currently the largest contiguous chunk to buffer\n     is frame header.  We buffer part of payload, but they are smaller\n     than frame header. */\n  uint8_t raw_sbuf[NGHTTP2_FRAME_HDLEN];\n} nghttp2_inbound_frame;\n\ntypedef struct {\n  uint32_t header_table_size;\n  uint32_t enable_push;\n  uint32_t max_concurrent_streams;\n  uint32_t initial_window_size;\n  uint32_t max_frame_size;\n  uint32_t max_header_list_size;\n  uint32_t enable_connect_protocol;\n} nghttp2_settings_storage;\n\ntypedef enum {\n  NGHTTP2_GOAWAY_NONE = 0,\n  /* Flag means that connection should be terminated after sending GOAWAY. */\n  NGHTTP2_GOAWAY_TERM_ON_SEND = 0x1,\n  /* Flag means GOAWAY to terminate session has been sent */\n  NGHTTP2_GOAWAY_TERM_SENT = 0x2,\n  /* Flag means GOAWAY was sent */\n  NGHTTP2_GOAWAY_SENT = 0x4,\n  /* Flag means GOAWAY was received */\n  NGHTTP2_GOAWAY_RECV = 0x8\n} nghttp2_goaway_flag;\n\n/* nghttp2_inflight_settings stores the SETTINGS entries which local\n   endpoint has sent to the remote endpoint, and has not received ACK\n   yet. */\nstruct nghttp2_inflight_settings {\n  struct nghttp2_inflight_settings *next;\n  nghttp2_settings_entry *iv;\n  size_t niv;\n};\n\ntypedef struct nghttp2_inflight_settings nghttp2_inflight_settings;\n\nstruct nghttp2_session {\n  nghttp2_map /* <nghttp2_stream*> */ streams;\n  /* root of dependency tree*/\n  nghttp2_stream root;\n  /* Queue for outbound urgent frames (PING and SETTINGS) */\n  nghttp2_outbound_queue ob_urgent;\n  /* Queue for non-DATA frames */\n  nghttp2_outbound_queue ob_reg;\n  /* Queue for outbound stream-creating HEADERS (request or push\n     response) frame, which are subject to\n     SETTINGS_MAX_CONCURRENT_STREAMS limit. */\n  nghttp2_outbound_queue ob_syn;\n  nghttp2_active_outbound_item aob;\n  nghttp2_inbound_frame iframe;\n  nghttp2_hd_deflater hd_deflater;\n  nghttp2_hd_inflater hd_inflater;\n  nghttp2_session_callbacks callbacks;\n  /* Memory allocator */\n  nghttp2_mem mem;\n  void *user_data;\n  /* Points to the latest incoming closed stream.  NULL if there is no\n     closed stream.  Only used when session is initialized as\n     server. */\n  nghttp2_stream *closed_stream_head;\n  /* Points to the oldest incoming closed stream.  NULL if there is no\n     closed stream.  Only used when session is initialized as\n     server. */\n  nghttp2_stream *closed_stream_tail;\n  /* Points to the latest idle stream.  NULL if there is no idle\n     stream.  Only used when session is initialized as server .*/\n  nghttp2_stream *idle_stream_head;\n  /* Points to the oldest idle stream.  NULL if there is no idle\n     stream.  Only used when session is initialized as erver. */\n  nghttp2_stream *idle_stream_tail;\n  /* Queue of In-flight SETTINGS values.  SETTINGS bearing ACK is not\n     considered as in-flight. */\n  nghttp2_inflight_settings *inflight_settings_head;\n  /* The number of outgoing streams. This will be capped by\n     remote_settings.max_concurrent_streams. */\n  size_t num_outgoing_streams;\n  /* The number of incoming streams. This will be capped by\n     local_settings.max_concurrent_streams. */\n  size_t num_incoming_streams;\n  /* The number of incoming reserved streams.  This is the number of\n     streams in reserved (remote) state.  RFC 7540 does not limit this\n     number.  nghttp2 offers\n     nghttp2_option_set_max_reserved_remote_streams() to achieve this.\n     If it is used, num_incoming_streams is capped by\n     max_incoming_reserved_streams.  Client application should\n     consider to set this because without that server can send\n     arbitrary number of PUSH_PROMISE, and exhaust client's memory. */\n  size_t num_incoming_reserved_streams;\n  /* The maximum number of incoming reserved streams (reserved\n     (remote) state).  RST_STREAM will be sent for the pushed stream\n     which exceeds this limit. */\n  size_t max_incoming_reserved_streams;\n  /* The number of closed streams still kept in |streams| hash.  The\n     closed streams can be accessed through single linked list\n     |closed_stream_head|.  The current implementation only keeps\n     incoming streams and session is initialized as server. */\n  size_t num_closed_streams;\n  /* The number of idle streams kept in |streams| hash.  The idle\n     streams can be accessed through doubly linked list\n     |idle_stream_head|.  The current implementation only keeps idle\n     streams if session is initialized as server. */\n  size_t num_idle_streams;\n  /* The number of bytes allocated for nvbuf */\n  size_t nvbuflen;\n  /* Counter for detecting flooding in outbound queue.  If it exceeds\n     max_outbound_ack, session will be closed. */\n  size_t obq_flood_counter_;\n  /* The maximum number of outgoing SETTINGS ACK and PING ACK in\n     outbound queue. */\n  size_t max_outbound_ack;\n  /* The maximum length of header block to send.  Calculated by the\n     same way as nghttp2_hd_deflate_bound() does. */\n  size_t max_send_header_block_length;\n  /* Next Stream ID. Made unsigned int to detect >= (1 << 31). */\n  uint32_t next_stream_id;\n  /* The last stream ID this session initiated.  For client session,\n     this is the last stream ID it has sent.  For server session, it\n     is the last promised stream ID sent in PUSH_PROMISE. */\n  int32_t last_sent_stream_id;\n  /* The largest stream ID received so far */\n  int32_t last_recv_stream_id;\n  /* The largest stream ID which has been processed in some way. This\n     value will be used as last-stream-id when sending GOAWAY\n     frame. */\n  int32_t last_proc_stream_id;\n  /* Counter of unique ID of PING. Wraps when it exceeds\n     NGHTTP2_MAX_UNIQUE_ID */\n  uint32_t next_unique_id;\n  /* This is the last-stream-ID we have sent in GOAWAY */\n  int32_t local_last_stream_id;\n  /* This is the value in GOAWAY frame received from remote endpoint. */\n  int32_t remote_last_stream_id;\n  /* Current sender window size. This value is computed against the\n     current initial window size of remote endpoint. */\n  int32_t remote_window_size;\n  /* Keep track of the number of bytes received without\n     WINDOW_UPDATE. This could be negative after submitting negative\n     value to WINDOW_UPDATE. */\n  int32_t recv_window_size;\n  /* The number of bytes consumed by the application and now is\n     subject to WINDOW_UPDATE.  This is only used when auto\n     WINDOW_UPDATE is turned off. */\n  int32_t consumed_size;\n  /* The amount of recv_window_size cut using submitting negative\n     value to WINDOW_UPDATE */\n  int32_t recv_reduction;\n  /* window size for local flow control. It is initially set to\n     NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE and could be\n     increased/decreased by submitting WINDOW_UPDATE. See\n     nghttp2_submit_window_update(). */\n  int32_t local_window_size;\n  /* This flag is used to indicate that the local endpoint received initial\n     SETTINGS frame from the remote endpoint. */\n  uint8_t remote_settings_received;\n  /* Settings value received from the remote endpoint. */\n  nghttp2_settings_storage remote_settings;\n  /* Settings value of the local endpoint. */\n  nghttp2_settings_storage local_settings;\n  /* Option flags. This is bitwise-OR of 0 or more of nghttp2_optmask. */\n  uint32_t opt_flags;\n  /* Unacked local SETTINGS_MAX_CONCURRENT_STREAMS value. We use this\n     to refuse the incoming stream if it exceeds this value. */\n  uint32_t pending_local_max_concurrent_stream;\n  /* The bitwise OR of zero or more of nghttp2_typemask to indicate\n     that the default handling of extension frame is enabled. */\n  uint32_t builtin_recv_ext_types;\n  /* Unacked local ENABLE_PUSH value.  We use this to refuse\n     PUSH_PROMISE before SETTINGS ACK is received. */\n  uint8_t pending_enable_push;\n  /* Unacked local ENABLE_CONNECT_PROTOCOL value.  We use this to\n     accept :protocol header field before SETTINGS_ACK is received. */\n  uint8_t pending_enable_connect_protocol;\n  /* Nonzero if the session is server side. */\n  uint8_t server;\n  /* Flags indicating GOAWAY is sent and/or received. The flags are\n     composed by bitwise OR-ing nghttp2_goaway_flag. */\n  uint8_t goaway_flags;\n  /* This flag is used to reduce excessive queuing of WINDOW_UPDATE to\n     this session.  The nonzero does not necessarily mean\n     WINDOW_UPDATE is not queued. */\n  uint8_t window_update_queued;\n  /* Bitfield of extension frame types that application is willing to\n     receive.  To designate the bit of given frame type i, use\n     user_recv_ext_types[i / 8] & (1 << (i & 0x7)).  First 10 frame\n     types are standard frame types and not used in this bitfield.  If\n     bit is set, it indicates that incoming frame with that type is\n     passed to user defined callbacks, otherwise they are ignored. */\n  uint8_t user_recv_ext_types[32];\n};\n\n/* Struct used when updating initial window size of each active\n   stream. */\ntypedef struct {\n  nghttp2_session *session;\n  int32_t new_window_size, old_window_size;\n} nghttp2_update_window_size_arg;\n\ntypedef struct {\n  nghttp2_session *session;\n  /* linked list of streams to close */\n  nghttp2_stream *head;\n  int32_t last_stream_id;\n  /* nonzero if GOAWAY is sent to peer, which means we are going to\n     close incoming streams.  zero if GOAWAY is received from peer and\n     we are going to close outgoing streams. */\n  int incoming;\n} nghttp2_close_stream_on_goaway_arg;\n\n/* TODO stream timeout etc */\n\n/*\n * Returns nonzero value if |stream_id| is initiated by local\n * endpoint.\n */\nint nghttp2_session_is_my_stream_id(nghttp2_session *session,\n                                    int32_t stream_id);\n\n/*\n * Adds |item| to the outbound queue in |session|.  When this function\n * succeeds, it takes ownership of |item|. So caller must not free it\n * on success.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_STREAM_CLOSED\n *     Stream already closed (DATA and PUSH_PROMISE frame only)\n */\nint nghttp2_session_add_item(nghttp2_session *session,\n                             nghttp2_outbound_item *item);\n\n/*\n * Adds RST_STREAM frame for the stream |stream_id| with the error\n * code |error_code|. This is a convenient function built on top of\n * nghttp2_session_add_frame() to add RST_STREAM easily.\n *\n * This function simply returns 0 without adding RST_STREAM frame if\n * given stream is in NGHTTP2_STREAM_CLOSING state, because multiple\n * RST_STREAM for a stream is redundant.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_add_rst_stream(nghttp2_session *session, int32_t stream_id,\n                                   uint32_t error_code);\n\n/*\n * Adds PING frame. This is a convenient functin built on top of\n * nghttp2_session_add_frame() to add PING easily.\n *\n * If the |opaque_data| is not NULL, it must point to 8 bytes memory\n * region of data. The data pointed by |opaque_data| is copied. It can\n * be NULL. In this case, 8 bytes NULL is used.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue; this only happens\n *     if NGHTTP2_FLAG_ACK is set in |flags|\n */\nint nghttp2_session_add_ping(nghttp2_session *session, uint8_t flags,\n                             const uint8_t *opaque_data);\n\n/*\n * Adds GOAWAY frame with the last-stream-ID |last_stream_id| and the\n * error code |error_code|. This is a convenient function built on top\n * of nghttp2_session_add_frame() to add GOAWAY easily.  The\n * |aux_flags| are bitwise-OR of one or more of\n * nghttp2_goaway_aux_flag.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The |opaque_data_len| is too large.\n */\nint nghttp2_session_add_goaway(nghttp2_session *session, int32_t last_stream_id,\n                               uint32_t error_code, const uint8_t *opaque_data,\n                               size_t opaque_data_len, uint8_t aux_flags);\n\n/*\n * Adds WINDOW_UPDATE frame with stream ID |stream_id| and\n * window-size-increment |window_size_increment|. This is a convenient\n * function built on top of nghttp2_session_add_frame() to add\n * WINDOW_UPDATE easily.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_add_window_update(nghttp2_session *session, uint8_t flags,\n                                      int32_t stream_id,\n                                      int32_t window_size_increment);\n\n/*\n * Adds SETTINGS frame.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue; this only happens\n *     if NGHTTP2_FLAG_ACK is set in |flags|\n */\nint nghttp2_session_add_settings(nghttp2_session *session, uint8_t flags,\n                                 const nghttp2_settings_entry *iv, size_t niv);\n\n/*\n * Creates new stream in |session| with stream ID |stream_id|,\n * priority |pri_spec| and flags |flags|.  The |flags| is bitwise OR\n * of nghttp2_stream_flag.  Since this function is called when initial\n * HEADERS is sent or received, these flags are taken from it.  The\n * state of stream is set to |initial_state|. The |stream_user_data|\n * is a pointer to the arbitrary user supplied data to be associated\n * to this stream.\n *\n * If |initial_state| is NGHTTP2_STREAM_RESERVED, this function sets\n * NGHTTP2_STREAM_FLAG_PUSH flag set.\n *\n * This function returns a pointer to created new stream object, or\n * NULL.\n *\n * This function adjusts neither the number of closed streams or idle\n * streams.  The caller should manually call\n * nghttp2_session_adjust_closed_stream() or\n * nghttp2_session_adjust_idle_stream() respectively.\n */\nnghttp2_stream *nghttp2_session_open_stream(nghttp2_session *session,\n                                            int32_t stream_id, uint8_t flags,\n                                            nghttp2_priority_spec *pri_spec,\n                                            nghttp2_stream_state initial_state,\n                                            void *stream_user_data);\n\n/*\n * Closes stream whose stream ID is |stream_id|. The reason of closure\n * is indicated by the |error_code|. When closing the stream,\n * on_stream_close_callback will be called.\n *\n * If the session is initialized as server and |stream| is incoming\n * stream, stream is just marked closed and this function calls\n * nghttp2_session_keep_closed_stream() with |stream|.  Otherwise,\n * |stream| will be deleted from memory.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The specified stream does not exist.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_close_stream(nghttp2_session *session, int32_t stream_id,\n                                 uint32_t error_code);\n\n/*\n * Deletes |stream| from memory.  After this function returns, stream\n * cannot be accessed.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_destroy_stream(nghttp2_session *session,\n                                   nghttp2_stream *stream);\n\n/*\n * Tries to keep incoming closed stream |stream|.  Due to the\n * limitation of maximum number of streams in memory, |stream| is not\n * closed and just deleted from memory (see\n * nghttp2_session_destroy_stream).\n */\nvoid nghttp2_session_keep_closed_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream);\n\n/*\n * Appends |stream| to linked list |session->idle_stream_head|.  We\n * apply fixed limit for list size.  To fit into that limit, one or\n * more oldest streams are removed from list as necessary.\n */\nvoid nghttp2_session_keep_idle_stream(nghttp2_session *session,\n                                      nghttp2_stream *stream);\n\n/*\n * Detaches |stream| from idle streams linked list.\n */\nvoid nghttp2_session_detach_idle_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream);\n\n/*\n * Deletes closed stream to ensure that number of incoming streams\n * including active and closed is in the maximum number of allowed\n * stream.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_adjust_closed_stream(nghttp2_session *session);\n\n/*\n * Deletes idle stream to ensure that number of idle streams is in\n * certain limit.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_adjust_idle_stream(nghttp2_session *session);\n\n/*\n * If further receptions and transmissions over the stream |stream_id|\n * are disallowed, close the stream with error code NGHTTP2_NO_ERROR.\n *\n * This function returns 0 if it\n * succeeds, or one of the following negative error codes:\n *\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The specified stream does not exist.\n */\nint nghttp2_session_close_stream_if_shut_rdwr(nghttp2_session *session,\n                                              nghttp2_stream *stream);\n\nint nghttp2_session_on_request_headers_received(nghttp2_session *session,\n                                                nghttp2_frame *frame);\n\nint nghttp2_session_on_response_headers_received(nghttp2_session *session,\n                                                 nghttp2_frame *frame,\n                                                 nghttp2_stream *stream);\n\nint nghttp2_session_on_push_response_headers_received(nghttp2_session *session,\n                                                      nghttp2_frame *frame,\n                                                      nghttp2_stream *stream);\n\n/*\n * Called when HEADERS is received, assuming |frame| is properly\n * initialized.  This function does first validate received frame and\n * then open stream and call callback functions.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_IGN_HEADER_BLOCK\n *     Frame was rejected and header block must be decoded but\n *     result must be ignored.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_headers_received(nghttp2_session *session,\n                                        nghttp2_frame *frame,\n                                        nghttp2_stream *stream);\n\n/*\n * Called when PRIORITY is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_priority_received(nghttp2_session *session,\n                                         nghttp2_frame *frame);\n\n/*\n * Called when RST_STREAM is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_rst_stream_received(nghttp2_session *session,\n                                           nghttp2_frame *frame);\n\n/*\n * Called when SETTINGS is received, assuming |frame| is properly\n * initialized. If |noack| is non-zero, SETTINGS with ACK will not be\n * submitted. If |frame| has NGHTTP2_FLAG_ACK flag set, no SETTINGS\n * with ACK will not be submitted regardless of |noack|.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue, and this is most\n *     likely caused by misbehaviour of peer.\n */\nint nghttp2_session_on_settings_received(nghttp2_session *session,\n                                         nghttp2_frame *frame, int noack);\n\n/*\n * Called when PUSH_PROMISE is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_IGN_HEADER_BLOCK\n *     Frame was rejected and header block must be decoded but\n *     result must be ignored.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_push_promise_received(nghttp2_session *session,\n                                             nghttp2_frame *frame);\n\n/*\n * Called when PING is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue, and this is most\n *     likely caused by misbehaviour of peer.\n */\nint nghttp2_session_on_ping_received(nghttp2_session *session,\n                                     nghttp2_frame *frame);\n\n/*\n * Called when GOAWAY is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_goaway_received(nghttp2_session *session,\n                                       nghttp2_frame *frame);\n\n/*\n * Called when WINDOW_UPDATE is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_window_update_received(nghttp2_session *session,\n                                              nghttp2_frame *frame);\n\n/*\n * Called when ALTSVC is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_altsvc_received(nghttp2_session *session,\n                                       nghttp2_frame *frame);\n\n/*\n * Called when ORIGIN is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_origin_received(nghttp2_session *session,\n                                       nghttp2_frame *frame);\n\n/*\n * Called when DATA is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_data_received(nghttp2_session *session,\n                                     nghttp2_frame *frame);\n\n/*\n * Returns nghttp2_stream* object whose stream ID is |stream_id|.  It\n * could be NULL if such stream does not exist.  This function returns\n * NULL if stream is marked as closed.\n */\nnghttp2_stream *nghttp2_session_get_stream(nghttp2_session *session,\n                                           int32_t stream_id);\n\n/*\n * This function behaves like nghttp2_session_get_stream(), but it\n * returns stream object even if it is marked as closed or in\n * NGHTTP2_STREAM_IDLE state.\n */\nnghttp2_stream *nghttp2_session_get_stream_raw(nghttp2_session *session,\n                                               int32_t stream_id);\n\n/*\n * Packs DATA frame |frame| in wire frame format and stores it in\n * |bufs|.  Payload will be read using |aux_data->data_prd|.  The\n * length of payload is at most |datamax| bytes.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_DEFERRED\n *     The DATA frame is postponed.\n * NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE\n *     The read_callback failed (stream error).\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed (session error).\n */\nint nghttp2_session_pack_data(nghttp2_session *session, nghttp2_bufs *bufs,\n                              size_t datamax, nghttp2_frame *frame,\n                              nghttp2_data_aux_data *aux_data,\n                              nghttp2_stream *stream);\n\n/*\n * Pops and returns next item to send.  If there is no such item,\n * returns NULL.  This function takes into account max concurrent\n * streams.  That means if session->ob_syn has item and max concurrent\n * streams is reached, the even if other queues contain items, then\n * this function returns NULL.\n */\nnghttp2_outbound_item *\nnghttp2_session_pop_next_ob_item(nghttp2_session *session);\n\n/*\n * Returns next item to send.  If there is no such item, this function\n * returns NULL.  This function takes into account max concurrent\n * streams.  That means if session->ob_syn has item and max concurrent\n * streams is reached, the even if other queues contain items, then\n * this function returns NULL.\n */\nnghttp2_outbound_item *\nnghttp2_session_get_next_ob_item(nghttp2_session *session);\n\n/*\n * Updates local settings with the |iv|. The number of elements in the\n * array pointed by the |iv| is given by the |niv|.  This function\n * assumes that the all settings_id member in |iv| are in range 1 to\n * NGHTTP2_SETTINGS_MAX, inclusive.\n *\n * While updating individual stream's local window size, if the window\n * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,\n * RST_STREAM is issued against such a stream.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_update_local_settings(nghttp2_session *session,\n                                          nghttp2_settings_entry *iv,\n                                          size_t niv);\n\n/*\n * Re-prioritize |stream|. The new priority specification is\n * |pri_spec|.  Caller must ensure that stream->hd.stream_id !=\n * pri_spec->stream_id.\n *\n * This function does not adjust the number of idle streams.  The\n * caller should call nghttp2_session_adjust_idle_stream() later.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_reprioritize_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream,\n                                        const nghttp2_priority_spec *pri_spec);\n\n/*\n * Terminates current |session| with the |error_code|.  The |reason|\n * is NULL-terminated debug string.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The |reason| is too long.\n */\nint nghttp2_session_terminate_session_with_reason(nghttp2_session *session,\n                                                  uint32_t error_code,\n                                                  const char *reason);\n\n/*\n * Accumulates received bytes |delta_size| for connection-level flow\n * control and decides whether to send WINDOW_UPDATE to the\n * connection.  If NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE is set,\n * WINDOW_UPDATE will not be sent.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_update_recv_connection_window_size(nghttp2_session *session,\n                                                       size_t delta_size);\n\n/*\n * Accumulates received bytes |delta_size| for stream-level flow\n * control and decides whether to send WINDOW_UPDATE to that stream.\n * If NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE is set, WINDOW_UPDATE will not\n * be sent.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_update_recv_stream_window_size(nghttp2_session *session,\n                                                   nghttp2_stream *stream,\n                                                   size_t delta_size,\n                                                   int send_window_update);\n\n#endif /* NGHTTP2_SESSION_H */\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <string.h>\n#include <CUnit/Basic.h>\n/* include test cases' include files here */\n#include \"nghttp2_pq_test.h\"\n#include \"nghttp2_map_test.h\"\n#include \"nghttp2_queue_test.h\"\n#include \"nghttp2_session_test.h\"\n#include \"nghttp2_frame_test.h\"\n#include \"nghttp2_stream_test.h\"\n#include \"nghttp2_hd_test.h\"\n#include \"nghttp2_npn_test.h\"\n#include \"nghttp2_helper_test.h\"\n#include \"nghttp2_buf_test.h\"\n\nextern int nghttp2_enable_strict_preface;\n\nstatic int init_suite1(void) { return 0; }\n\nstatic int clean_suite1(void) { return 0; }\n\nint main() {\n  CU_pSuite pSuite = NULL;\n  unsigned int num_tests_failed;\n\n  nghttp2_enable_strict_preface = 0;\n\n  /* initialize the CUnit test registry */\n  if (CUE_SUCCESS != CU_initialize_registry())\n    return (int)CU_get_error();\n\n  /* add a suite to the registry */\n  pSuite = CU_add_suite(\"libnghttp2_TestSuite\", init_suite1, clean_suite1);\n  if (NULL == pSuite) {\n    CU_cleanup_registry();\n    return (int)CU_get_error();\n  }\n\n  /* add the tests to the suite */\n  if (!CU_add_test(pSuite, \"pq\", test_nghttp2_pq) ||\n      !CU_add_test(pSuite, \"pq_update\", test_nghttp2_pq_update) ||\n      !CU_add_test(pSuite, \"pq_remove\", test_nghttp2_pq_remove) ||\n      !CU_add_test(pSuite, \"map\", test_nghttp2_map) ||\n      !CU_add_test(pSuite, \"map_functional\", test_nghttp2_map_functional) ||\n      !CU_add_test(pSuite, \"map_each_free\", test_nghttp2_map_each_free) ||\n      !CU_add_test(pSuite, \"queue\", test_nghttp2_queue) ||\n      !CU_add_test(pSuite, \"npn\", test_nghttp2_npn) ||\n      !CU_add_test(pSuite, \"session_recv\", test_nghttp2_session_recv) ||\n      !CU_add_test(pSuite, \"session_recv_invalid_stream_id\",\n                   test_nghttp2_session_recv_invalid_stream_id) ||\n      !CU_add_test(pSuite, \"session_recv_invalid_frame\",\n                   test_nghttp2_session_recv_invalid_frame) ||\n      !CU_add_test(pSuite, \"session_recv_eof\", test_nghttp2_session_recv_eof) ||\n      !CU_add_test(pSuite, \"session_recv_data\",\n                   test_nghttp2_session_recv_data) ||\n      !CU_add_test(pSuite, \"session_recv_data_no_auto_flow_control\",\n                   test_nghttp2_session_recv_data_no_auto_flow_control) ||\n      !CU_add_test(pSuite, \"session_recv_continuation\",\n                   test_nghttp2_session_recv_continuation) ||\n      !CU_add_test(pSuite, \"session_recv_headers_with_priority\",\n                   test_nghttp2_session_recv_headers_with_priority) ||\n      !CU_add_test(pSuite, \"session_recv_headers_with_padding\",\n                   test_nghttp2_session_recv_headers_with_padding) ||\n      !CU_add_test(pSuite, \"session_recv_headers_early_response\",\n                   test_nghttp2_session_recv_headers_early_response) ||\n      !CU_add_test(pSuite, \"session_recv_headers_for_closed_stream\",\n                   test_nghttp2_session_recv_headers_for_closed_stream) ||\n      !CU_add_test(pSuite, \"session_server_recv_push_response\",\n                   test_nghttp2_session_server_recv_push_response) ||\n      !CU_add_test(pSuite, \"session_recv_premature_headers\",\n                   test_nghttp2_session_recv_premature_headers) ||\n      !CU_add_test(pSuite, \"session_recv_unknown_frame\",\n                   test_nghttp2_session_recv_unknown_frame) ||\n      !CU_add_test(pSuite, \"session_recv_unexpected_continuation\",\n                   test_nghttp2_session_recv_unexpected_continuation) ||\n      !CU_add_test(pSuite, \"session_recv_settings_header_table_size\",\n                   test_nghttp2_session_recv_settings_header_table_size) ||\n      !CU_add_test(pSuite, \"session_recv_too_large_frame_length\",\n                   test_nghttp2_session_recv_too_large_frame_length) ||\n      !CU_add_test(pSuite, \"session_recv_extension\",\n                   test_nghttp2_session_recv_extension) ||\n      !CU_add_test(pSuite, \"session_recv_altsvc\",\n                   test_nghttp2_session_recv_altsvc) ||\n      !CU_add_test(pSuite, \"session_recv_origin\",\n                   test_nghttp2_session_recv_origin) ||\n      !CU_add_test(pSuite, \"session_continue\", test_nghttp2_session_continue) ||\n      !CU_add_test(pSuite, \"session_add_frame\",\n                   test_nghttp2_session_add_frame) ||\n      !CU_add_test(pSuite, \"session_on_request_headers_received\",\n                   test_nghttp2_session_on_request_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_response_headers_received\",\n                   test_nghttp2_session_on_response_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_headers_received\",\n                   test_nghttp2_session_on_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_push_response_headers_received\",\n                   test_nghttp2_session_on_push_response_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_priority_received\",\n                   test_nghttp2_session_on_priority_received) ||\n      !CU_add_test(pSuite, \"session_on_rst_stream_received\",\n                   test_nghttp2_session_on_rst_stream_received) ||\n      !CU_add_test(pSuite, \"session_on_settings_received\",\n                   test_nghttp2_session_on_settings_received) ||\n      !CU_add_test(pSuite, \"session_on_push_promise_received\",\n                   test_nghttp2_session_on_push_promise_received) ||\n      !CU_add_test(pSuite, \"session_on_ping_received\",\n                   test_nghttp2_session_on_ping_received) ||\n      !CU_add_test(pSuite, \"session_on_goaway_received\",\n                   test_nghttp2_session_on_goaway_received) ||\n      !CU_add_test(pSuite, \"session_on_window_update_received\",\n                   test_nghttp2_session_on_window_update_received) ||\n      !CU_add_test(pSuite, \"session_on_data_received\",\n                   test_nghttp2_session_on_data_received) ||\n      !CU_add_test(pSuite, \"session_on_data_received_fail_fast\",\n                   test_nghttp2_session_on_data_received_fail_fast) ||\n      !CU_add_test(pSuite, \"session_on_altsvc_received\",\n                   test_nghttp2_session_on_altsvc_received) ||\n      !CU_add_test(pSuite, \"session_send_headers_start_stream\",\n                   test_nghttp2_session_send_headers_start_stream) ||\n      !CU_add_test(pSuite, \"session_send_headers_reply\",\n                   test_nghttp2_session_send_headers_reply) ||\n      !CU_add_test(pSuite, \"session_send_headers_frame_size_error\",\n                   test_nghttp2_session_send_headers_frame_size_error) ||\n      !CU_add_test(pSuite, \"session_send_headers_push_reply\",\n                   test_nghttp2_session_send_headers_push_reply) ||\n      !CU_add_test(pSuite, \"session_send_rst_stream\",\n                   test_nghttp2_session_send_rst_stream) ||\n      !CU_add_test(pSuite, \"session_send_push_promise\",\n                   test_nghttp2_session_send_push_promise) ||\n      !CU_add_test(pSuite, \"session_is_my_stream_id\",\n                   test_nghttp2_session_is_my_stream_id) ||\n      !CU_add_test(pSuite, \"session_upgrade2\", test_nghttp2_session_upgrade2) ||\n      !CU_add_test(pSuite, \"session_reprioritize_stream\",\n                   test_nghttp2_session_reprioritize_stream) ||\n      !CU_add_test(\n          pSuite, \"session_reprioritize_stream_with_idle_stream_dep\",\n          test_nghttp2_session_reprioritize_stream_with_idle_stream_dep) ||\n      !CU_add_test(pSuite, \"submit_data\", test_nghttp2_submit_data) ||\n      !CU_add_test(pSuite, \"submit_data_read_length_too_large\",\n                   test_nghttp2_submit_data_read_length_too_large) ||\n      !CU_add_test(pSuite, \"submit_data_read_length_smallest\",\n                   test_nghttp2_submit_data_read_length_smallest) ||\n      !CU_add_test(pSuite, \"submit_data_twice\",\n                   test_nghttp2_submit_data_twice) ||\n      !CU_add_test(pSuite, \"submit_request_with_data\",\n                   test_nghttp2_submit_request_with_data) ||\n      !CU_add_test(pSuite, \"submit_request_without_data\",\n                   test_nghttp2_submit_request_without_data) ||\n      !CU_add_test(pSuite, \"submit_response_with_data\",\n                   test_nghttp2_submit_response_with_data) ||\n      !CU_add_test(pSuite, \"submit_response_without_data\",\n                   test_nghttp2_submit_response_without_data) ||\n      !CU_add_test(pSuite, \"Submit_response_push_response\",\n                   test_nghttp2_submit_response_push_response) ||\n      !CU_add_test(pSuite, \"submit_trailer\", test_nghttp2_submit_trailer) ||\n      !CU_add_test(pSuite, \"submit_headers_start_stream\",\n                   test_nghttp2_submit_headers_start_stream) ||\n      !CU_add_test(pSuite, \"submit_headers_reply\",\n                   test_nghttp2_submit_headers_reply) ||\n      !CU_add_test(pSuite, \"submit_headers_push_reply\",\n                   test_nghttp2_submit_headers_push_reply) ||\n      !CU_add_test(pSuite, \"submit_headers\", test_nghttp2_submit_headers) ||\n      !CU_add_test(pSuite, \"submit_headers_continuation\",\n                   test_nghttp2_submit_headers_continuation) ||\n      !CU_add_test(pSuite, \"submit_headers_continuation_extra_large\",\n                   test_nghttp2_submit_headers_continuation_extra_large) ||\n      !CU_add_test(pSuite, \"submit_priority\", test_nghttp2_submit_priority) ||\n      !CU_add_test(pSuite, \"session_submit_settings\",\n                   test_nghttp2_submit_settings) ||\n      !CU_add_test(pSuite, \"session_submit_settings_update_local_window_size\",\n                   test_nghttp2_submit_settings_update_local_window_size) ||\n      !CU_add_test(pSuite, \"session_submit_settings_multiple_times\",\n                   test_nghttp2_submit_settings_multiple_times) ||\n      !CU_add_test(pSuite, \"session_submit_push_promise\",\n                   test_nghttp2_submit_push_promise) ||\n      !CU_add_test(pSuite, \"submit_window_update\",\n                   test_nghttp2_submit_window_update) ||\n      !CU_add_test(pSuite, \"submit_window_update_local_window_size\",\n                   test_nghttp2_submit_window_update_local_window_size) ||\n      !CU_add_test(pSuite, \"submit_shutdown_notice\",\n                   test_nghttp2_submit_shutdown_notice) ||\n      !CU_add_test(pSuite, \"submit_invalid_nv\",\n                   test_nghttp2_submit_invalid_nv) ||\n      !CU_add_test(pSuite, \"submit_extension\", test_nghttp2_submit_extension) ||\n      !CU_add_test(pSuite, \"submit_altsvc\", test_nghttp2_submit_altsvc) ||\n      !CU_add_test(pSuite, \"submit_origin\", test_nghttp2_submit_origin) ||\n      !CU_add_test(pSuite, \"session_open_stream\",\n                   test_nghttp2_session_open_stream) ||\n      !CU_add_test(pSuite, \"session_open_stream_with_idle_stream_dep\",\n                   test_nghttp2_session_open_stream_with_idle_stream_dep) ||\n      !CU_add_test(pSuite, \"session_get_next_ob_item\",\n                   test_nghttp2_session_get_next_ob_item) ||\n      !CU_add_test(pSuite, \"session_pop_next_ob_item\",\n                   test_nghttp2_session_pop_next_ob_item) ||\n      !CU_add_test(pSuite, \"session_reply_fail\",\n                   test_nghttp2_session_reply_fail) ||\n      !CU_add_test(pSuite, \"session_max_concurrent_streams\",\n                   test_nghttp2_session_max_concurrent_streams) ||\n      !CU_add_test(pSuite, \"session_stop_data_with_rst_stream\",\n                   test_nghttp2_session_stop_data_with_rst_stream) ||\n      !CU_add_test(pSuite, \"session_defer_data\",\n                   test_nghttp2_session_defer_data) ||\n      !CU_add_test(pSuite, \"session_flow_control\",\n                   test_nghttp2_session_flow_control) ||\n      !CU_add_test(pSuite, \"session_flow_control_data_recv\",\n                   test_nghttp2_session_flow_control_data_recv) ||\n      !CU_add_test(pSuite, \"session_flow_control_data_with_padding_recv\",\n                   test_nghttp2_session_flow_control_data_with_padding_recv) ||\n      !CU_add_test(pSuite, \"session_data_read_temporal_failure\",\n                   test_nghttp2_session_data_read_temporal_failure) ||\n      !CU_add_test(pSuite, \"session_on_stream_close\",\n                   test_nghttp2_session_on_stream_close) ||\n      !CU_add_test(pSuite, \"session_on_ctrl_not_send\",\n                   test_nghttp2_session_on_ctrl_not_send) ||\n      !CU_add_test(pSuite, \"session_get_outbound_queue_size\",\n                   test_nghttp2_session_get_outbound_queue_size) ||\n      !CU_add_test(pSuite, \"session_get_effective_local_window_size\",\n                   test_nghttp2_session_get_effective_local_window_size) ||\n      !CU_add_test(pSuite, \"session_set_option\",\n                   test_nghttp2_session_set_option) ||\n      !CU_add_test(pSuite, \"session_data_backoff_by_high_pri_frame\",\n                   test_nghttp2_session_data_backoff_by_high_pri_frame) ||\n      !CU_add_test(pSuite, \"session_pack_data_with_padding\",\n                   test_nghttp2_session_pack_data_with_padding) ||\n      !CU_add_test(pSuite, \"session_pack_headers_with_padding\",\n                   test_nghttp2_session_pack_headers_with_padding) ||\n      !CU_add_test(pSuite, \"pack_settings_payload\",\n                   test_nghttp2_pack_settings_payload) ||\n      !CU_add_test(pSuite, \"session_stream_dep_add\",\n                   test_nghttp2_session_stream_dep_add) ||\n      !CU_add_test(pSuite, \"session_stream_dep_remove\",\n                   test_nghttp2_session_stream_dep_remove) ||\n      !CU_add_test(pSuite, \"session_stream_dep_add_subtree\",\n                   test_nghttp2_session_stream_dep_add_subtree) ||\n      !CU_add_test(pSuite, \"session_stream_dep_remove_subtree\",\n                   test_nghttp2_session_stream_dep_remove_subtree) ||\n      !CU_add_test(\n          pSuite, \"session_stream_dep_all_your_stream_are_belong_to_us\",\n          test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us) ||\n      !CU_add_test(pSuite, \"session_stream_attach_item\",\n                   test_nghttp2_session_stream_attach_item) ||\n      !CU_add_test(pSuite, \"session_stream_attach_item_subtree\",\n                   test_nghttp2_session_stream_attach_item_subtree) ||\n      !CU_add_test(pSuite, \"session_stream_get_state\",\n                   test_nghttp2_session_stream_get_state) ||\n      !CU_add_test(pSuite, \"session_stream_get_something\",\n                   test_nghttp2_session_stream_get_something) ||\n      !CU_add_test(pSuite, \"session_find_stream\",\n                   test_nghttp2_session_find_stream) ||\n      !CU_add_test(pSuite, \"session_keep_closed_stream\",\n                   test_nghttp2_session_keep_closed_stream) ||\n      !CU_add_test(pSuite, \"session_keep_idle_stream\",\n                   test_nghttp2_session_keep_idle_stream) ||\n      !CU_add_test(pSuite, \"session_detach_idle_stream\",\n                   test_nghttp2_session_detach_idle_stream) ||\n      !CU_add_test(pSuite, \"session_large_dep_tree\",\n                   test_nghttp2_session_large_dep_tree) ||\n      !CU_add_test(pSuite, \"session_graceful_shutdown\",\n                   test_nghttp2_session_graceful_shutdown) ||\n      !CU_add_test(pSuite, \"session_on_header_temporal_failure\",\n                   test_nghttp2_session_on_header_temporal_failure) ||\n      !CU_add_test(pSuite, \"session_recv_client_magic\",\n                   test_nghttp2_session_recv_client_magic) ||\n      !CU_add_test(pSuite, \"session_delete_data_item\",\n                   test_nghttp2_session_delete_data_item) ||\n      !CU_add_test(pSuite, \"session_open_idle_stream\",\n                   test_nghttp2_session_open_idle_stream) ||\n      !CU_add_test(pSuite, \"session_cancel_reserved_remote\",\n                   test_nghttp2_session_cancel_reserved_remote) ||\n      !CU_add_test(pSuite, \"session_reset_pending_headers\",\n                   test_nghttp2_session_reset_pending_headers) ||\n      !CU_add_test(pSuite, \"session_send_data_callback\",\n                   test_nghttp2_session_send_data_callback) ||\n      !CU_add_test(pSuite, \"session_on_begin_headers_temporal_failure\",\n                   test_nghttp2_session_on_begin_headers_temporal_failure) ||\n      !CU_add_test(pSuite, \"session_defer_then_close\",\n                   test_nghttp2_session_defer_then_close) ||\n      !CU_add_test(pSuite, \"session_detach_item_from_closed_stream\",\n                   test_nghttp2_session_detach_item_from_closed_stream) ||\n      !CU_add_test(pSuite, \"session_flooding\", test_nghttp2_session_flooding) ||\n      !CU_add_test(pSuite, \"session_change_stream_priority\",\n                   test_nghttp2_session_change_stream_priority) ||\n      !CU_add_test(pSuite, \"session_create_idle_stream\",\n                   test_nghttp2_session_create_idle_stream) ||\n      !CU_add_test(pSuite, \"session_repeated_priority_change\",\n                   test_nghttp2_session_repeated_priority_change) ||\n      !CU_add_test(pSuite, \"session_repeated_priority_submission\",\n                   test_nghttp2_session_repeated_priority_submission) ||\n      !CU_add_test(pSuite, \"session_set_local_window_size\",\n                   test_nghttp2_session_set_local_window_size) ||\n      !CU_add_test(pSuite, \"session_cancel_from_before_frame_send\",\n                   test_nghttp2_session_cancel_from_before_frame_send) ||\n      !CU_add_test(pSuite, \"session_removed_closed_stream\",\n                   test_nghttp2_session_removed_closed_stream) ||\n      !CU_add_test(pSuite, \"session_pause_data\",\n                   test_nghttp2_session_pause_data) ||\n      !CU_add_test(pSuite, \"session_no_closed_streams\",\n                   test_nghttp2_session_no_closed_streams) ||\n      !CU_add_test(pSuite, \"session_set_stream_user_data\",\n                   test_nghttp2_session_set_stream_user_data) ||\n      !CU_add_test(pSuite, \"http_mandatory_headers\",\n                   test_nghttp2_http_mandatory_headers) ||\n      !CU_add_test(pSuite, \"http_content_length\",\n                   test_nghttp2_http_content_length) ||\n      !CU_add_test(pSuite, \"http_content_length_mismatch\",\n                   test_nghttp2_http_content_length_mismatch) ||\n      !CU_add_test(pSuite, \"http_non_final_response\",\n                   test_nghttp2_http_non_final_response) ||\n      !CU_add_test(pSuite, \"http_trailer_headers\",\n                   test_nghttp2_http_trailer_headers) ||\n      !CU_add_test(pSuite, \"http_ignore_regular_header\",\n                   test_nghttp2_http_ignore_regular_header) ||\n      !CU_add_test(pSuite, \"http_ignore_content_length\",\n                   test_nghttp2_http_ignore_content_length) ||\n      !CU_add_test(pSuite, \"http_record_request_method\",\n                   test_nghttp2_http_record_request_method) ||\n      !CU_add_test(pSuite, \"http_push_promise\",\n                   test_nghttp2_http_push_promise) ||\n      !CU_add_test(pSuite, \"http_head_method_upgrade_workaround\",\n                   test_nghttp2_http_head_method_upgrade_workaround) ||\n      !CU_add_test(pSuite, \"frame_pack_headers\",\n                   test_nghttp2_frame_pack_headers) ||\n      !CU_add_test(pSuite, \"frame_pack_headers_frame_too_large\",\n                   test_nghttp2_frame_pack_headers_frame_too_large) ||\n      !CU_add_test(pSuite, \"frame_pack_priority\",\n                   test_nghttp2_frame_pack_priority) ||\n      !CU_add_test(pSuite, \"frame_pack_rst_stream\",\n                   test_nghttp2_frame_pack_rst_stream) ||\n      !CU_add_test(pSuite, \"frame_pack_settings\",\n                   test_nghttp2_frame_pack_settings) ||\n      !CU_add_test(pSuite, \"frame_pack_push_promise\",\n                   test_nghttp2_frame_pack_push_promise) ||\n      !CU_add_test(pSuite, \"frame_pack_ping\", test_nghttp2_frame_pack_ping) ||\n      !CU_add_test(pSuite, \"frame_pack_goaway\",\n                   test_nghttp2_frame_pack_goaway) ||\n      !CU_add_test(pSuite, \"frame_pack_window_update\",\n                   test_nghttp2_frame_pack_window_update) ||\n      !CU_add_test(pSuite, \"frame_pack_altsvc\",\n                   test_nghttp2_frame_pack_altsvc) ||\n      !CU_add_test(pSuite, \"frame_pack_origin\",\n                   test_nghttp2_frame_pack_origin) ||\n      !CU_add_test(pSuite, \"nv_array_copy\", test_nghttp2_nv_array_copy) ||\n      !CU_add_test(pSuite, \"iv_check\", test_nghttp2_iv_check) ||\n      !CU_add_test(pSuite, \"hd_deflate\", test_nghttp2_hd_deflate) ||\n      !CU_add_test(pSuite, \"hd_deflate_same_indexed_repr\",\n                   test_nghttp2_hd_deflate_same_indexed_repr) ||\n      !CU_add_test(pSuite, \"hd_inflate_indexed\",\n                   test_nghttp2_hd_inflate_indexed) ||\n      !CU_add_test(pSuite, \"hd_inflate_indname_noinc\",\n                   test_nghttp2_hd_inflate_indname_noinc) ||\n      !CU_add_test(pSuite, \"hd_inflate_indname_inc\",\n                   test_nghttp2_hd_inflate_indname_inc) ||\n      !CU_add_test(pSuite, \"hd_inflate_indname_inc_eviction\",\n                   test_nghttp2_hd_inflate_indname_inc_eviction) ||\n      !CU_add_test(pSuite, \"hd_inflate_newname_noinc\",\n                   test_nghttp2_hd_inflate_newname_noinc) ||\n      !CU_add_test(pSuite, \"hd_inflate_newname_inc\",\n                   test_nghttp2_hd_inflate_newname_inc) ||\n      !CU_add_test(pSuite, \"hd_inflate_clearall_inc\",\n                   test_nghttp2_hd_inflate_clearall_inc) ||\n      !CU_add_test(pSuite, \"hd_inflate_zero_length_huffman\",\n                   test_nghttp2_hd_inflate_zero_length_huffman) ||\n      !CU_add_test(pSuite, \"hd_inflate_expect_table_size_update\",\n                   test_nghttp2_hd_inflate_expect_table_size_update) ||\n      !CU_add_test(pSuite, \"hd_inflate_unexpected_table_size_update\",\n                   test_nghttp2_hd_inflate_unexpected_table_size_update) ||\n      !CU_add_test(pSuite, \"hd_ringbuf_reserve\",\n                   test_nghttp2_hd_ringbuf_reserve) ||\n      !CU_add_test(pSuite, \"hd_change_table_size\",\n                   test_nghttp2_hd_change_table_size) ||\n      !CU_add_test(pSuite, \"hd_deflate_inflate\",\n                   test_nghttp2_hd_deflate_inflate) ||\n      !CU_add_test(pSuite, \"hd_no_index\", test_nghttp2_hd_no_index) ||\n      !CU_add_test(pSuite, \"hd_deflate_bound\", test_nghttp2_hd_deflate_bound) ||\n      !CU_add_test(pSuite, \"hd_public_api\", test_nghttp2_hd_public_api) ||\n      !CU_add_test(pSuite, \"hd_deflate_hd_vec\",\n                   test_nghttp2_hd_deflate_hd_vec) ||\n      !CU_add_test(pSuite, \"hd_decode_length\", test_nghttp2_hd_decode_length) ||\n      !CU_add_test(pSuite, \"hd_huff_encode\", test_nghttp2_hd_huff_encode) ||\n      !CU_add_test(pSuite, \"hd_huff_decode\", test_nghttp2_hd_huff_decode) ||\n      !CU_add_test(pSuite, \"adjust_local_window_size\",\n                   test_nghttp2_adjust_local_window_size) ||\n      !CU_add_test(pSuite, \"check_header_name\",\n                   test_nghttp2_check_header_name) ||\n      !CU_add_test(pSuite, \"check_header_value\",\n                   test_nghttp2_check_header_value) ||\n      !CU_add_test(pSuite, \"bufs_add\", test_nghttp2_bufs_add) ||\n      !CU_add_test(pSuite, \"bufs_add_stack_buffer_overflow_bug\",\n                   test_nghttp2_bufs_add_stack_buffer_overflow_bug) ||\n      !CU_add_test(pSuite, \"bufs_addb\", test_nghttp2_bufs_addb) ||\n      !CU_add_test(pSuite, \"bufs_orb\", test_nghttp2_bufs_orb) ||\n      !CU_add_test(pSuite, \"bufs_remove\", test_nghttp2_bufs_remove) ||\n      !CU_add_test(pSuite, \"bufs_reset\", test_nghttp2_bufs_reset) ||\n      !CU_add_test(pSuite, \"bufs_advance\", test_nghttp2_bufs_advance) ||\n      !CU_add_test(pSuite, \"bufs_next_present\",\n                   test_nghttp2_bufs_next_present) ||\n      !CU_add_test(pSuite, \"bufs_realloc\", test_nghttp2_bufs_realloc)) {\n    CU_cleanup_registry();\n    return (int)CU_get_error();\n  }\n\n  /* Run all tests using the CUnit Basic interface */\n  CU_basic_set_mode(CU_BRM_VERBOSE);\n  CU_basic_run_tests();\n  num_tests_failed = CU_get_number_of_tests_failed();\n  CU_cleanup_registry();\n  if (CU_get_error() == CUE_SUCCESS) {\n    return (int)num_tests_failed;\n  } else {\n    printf(\"CUnit Error: %s\\n\", CU_get_error_msg());\n    return (int)CU_get_error();\n  }\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2013 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_session_test.h\"\n\n#include <stdio.h>\n#include <assert.h>\n\n#include <CUnit/CUnit.h>\n\n#include \"nghttp2_session.h\"\n#include \"nghttp2_stream.h\"\n#include \"nghttp2_net.h\"\n#include \"nghttp2_helper.h\"\n#include \"nghttp2_test_helper.h\"\n#include \"nghttp2_priority_spec.h\"\n\ntypedef struct {\n  uint8_t buf[65535];\n  size_t length;\n} accumulator;\n\ntypedef struct {\n  uint8_t data[8192];\n  uint8_t *datamark;\n  uint8_t *datalimit;\n  size_t feedseq[8192];\n  size_t seqidx;\n} scripted_data_feed;\n\ntypedef struct {\n  accumulator *acc;\n  scripted_data_feed *df;\n  int frame_recv_cb_called, invalid_frame_recv_cb_called;\n  uint8_t recv_frame_type;\n  nghttp2_frame_hd recv_frame_hd;\n  int frame_send_cb_called;\n  uint8_t sent_frame_type;\n  int before_frame_send_cb_called;\n  int frame_not_send_cb_called;\n  uint8_t not_sent_frame_type;\n  int not_sent_error;\n  int stream_close_cb_called;\n  uint32_t stream_close_error_code;\n  size_t data_source_length;\n  int32_t stream_id;\n  size_t block_count;\n  int data_chunk_recv_cb_called;\n  const nghttp2_frame *frame;\n  size_t fixed_sendlen;\n  int header_cb_called;\n  int invalid_header_cb_called;\n  int begin_headers_cb_called;\n  nghttp2_nv nv;\n  size_t data_chunk_len;\n  size_t padlen;\n  int begin_frame_cb_called;\n  nghttp2_buf scratchbuf;\n  size_t data_source_read_cb_paused;\n} my_user_data;\n\nstatic const nghttp2_nv reqnv[] = {\n    MAKE_NV(\":method\", \"GET\"),\n    MAKE_NV(\":path\", \"/\"),\n    MAKE_NV(\":scheme\", \"https\"),\n    MAKE_NV(\":authority\", \"localhost\"),\n};\n\nstatic const nghttp2_nv resnv[] = {\n    MAKE_NV(\":status\", \"200\"),\n};\n\nstatic const nghttp2_nv trailernv[] = {\n    // from http://tools.ietf.org/html/rfc6249#section-7\n    MAKE_NV(\"digest\", \"SHA-256=\"\n                      \"MWVkMWQxYTRiMzk5MDQ0MzI3NGU5NDEyZTk5OWY1ZGFmNzgyZTJlODYz\"\n                      \"YjRjYzFhOTlmNTQwYzI2M2QwM2U2MQ==\"),\n};\n\nstatic void scripted_data_feed_init2(scripted_data_feed *df,\n                                     nghttp2_bufs *bufs) {\n  nghttp2_buf_chain *ci;\n  nghttp2_buf *buf;\n  uint8_t *ptr;\n  size_t len;\n\n  memset(df, 0, sizeof(scripted_data_feed));\n  ptr = df->data;\n  len = 0;\n\n  for (ci = bufs->head; ci; ci = ci->next) {\n    buf = &ci->buf;\n    ptr = nghttp2_cpymem(ptr, buf->pos, nghttp2_buf_len(buf));\n    len += nghttp2_buf_len(buf);\n  }\n\n  df->datamark = df->data;\n  df->datalimit = df->data + len;\n  df->feedseq[0] = len;\n}\n\nstatic ssize_t null_send_callback(nghttp2_session *session, const uint8_t *data,\n                                  size_t len, int flags, void *user_data) {\n  (void)session;\n  (void)data;\n  (void)flags;\n  (void)user_data;\n\n  return (ssize_t)len;\n}\n\nstatic ssize_t fail_send_callback(nghttp2_session *session, const uint8_t *data,\n                                  size_t len, int flags, void *user_data) {\n  (void)session;\n  (void)data;\n  (void)len;\n  (void)flags;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nstatic ssize_t fixed_bytes_send_callback(nghttp2_session *session,\n                                         const uint8_t *data, size_t len,\n                                         int flags, void *user_data) {\n  size_t fixed_sendlen = ((my_user_data *)user_data)->fixed_sendlen;\n  (void)session;\n  (void)data;\n  (void)flags;\n\n  return (ssize_t)(fixed_sendlen < len ? fixed_sendlen : len);\n}\n\nstatic ssize_t scripted_recv_callback(nghttp2_session *session, uint8_t *data,\n                                      size_t len, int flags, void *user_data) {\n  scripted_data_feed *df = ((my_user_data *)user_data)->df;\n  size_t wlen = df->feedseq[df->seqidx] > len ? len : df->feedseq[df->seqidx];\n  (void)session;\n  (void)flags;\n\n  memcpy(data, df->datamark, wlen);\n  df->datamark += wlen;\n  df->feedseq[df->seqidx] -= wlen;\n  if (df->feedseq[df->seqidx] == 0) {\n    ++df->seqidx;\n  }\n  return (ssize_t)wlen;\n}\n\nstatic ssize_t eof_recv_callback(nghttp2_session *session, uint8_t *data,\n                                 size_t len, int flags, void *user_data) {\n  (void)session;\n  (void)data;\n  (void)len;\n  (void)flags;\n  (void)user_data;\n\n  return NGHTTP2_ERR_EOF;\n}\n\nstatic ssize_t accumulator_send_callback(nghttp2_session *session,\n                                         const uint8_t *buf, size_t len,\n                                         int flags, void *user_data) {\n  accumulator *acc = ((my_user_data *)user_data)->acc;\n  (void)session;\n  (void)flags;\n\n  assert(acc->length + len < sizeof(acc->buf));\n  memcpy(acc->buf + acc->length, buf, len);\n  acc->length += len;\n  return (ssize_t)len;\n}\n\nstatic int on_begin_frame_callback(nghttp2_session *session,\n                                   const nghttp2_frame_hd *hd,\n                                   void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)hd;\n\n  ++ud->begin_frame_cb_called;\n  return 0;\n}\n\nstatic int on_frame_recv_callback(nghttp2_session *session,\n                                  const nghttp2_frame *frame, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  ++ud->frame_recv_cb_called;\n  ud->recv_frame_type = frame->hd.type;\n  ud->recv_frame_hd = frame->hd;\n\n  return 0;\n}\n\nstatic int on_invalid_frame_recv_callback(nghttp2_session *session,\n                                          const nghttp2_frame *frame,\n                                          int lib_error_code, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)frame;\n  (void)lib_error_code;\n\n  ++ud->invalid_frame_recv_cb_called;\n  return 0;\n}\n\nstatic int on_frame_send_callback(nghttp2_session *session,\n                                  const nghttp2_frame *frame, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  ++ud->frame_send_cb_called;\n  ud->sent_frame_type = frame->hd.type;\n  return 0;\n}\n\nstatic int on_frame_not_send_callback(nghttp2_session *session,\n                                      const nghttp2_frame *frame, int lib_error,\n                                      void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  ++ud->frame_not_send_cb_called;\n  ud->not_sent_frame_type = frame->hd.type;\n  ud->not_sent_error = lib_error;\n  return 0;\n}\n\nstatic int cancel_before_frame_send_callback(nghttp2_session *session,\n                                             const nghttp2_frame *frame,\n                                             void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)frame;\n\n  ++ud->before_frame_send_cb_called;\n  return NGHTTP2_ERR_CANCEL;\n}\n\nstatic int on_data_chunk_recv_callback(nghttp2_session *session, uint8_t flags,\n                                       int32_t stream_id, const uint8_t *data,\n                                       size_t len, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n  (void)stream_id;\n  (void)data;\n\n  ++ud->data_chunk_recv_cb_called;\n  ud->data_chunk_len = len;\n  return 0;\n}\n\nstatic int pause_on_data_chunk_recv_callback(nghttp2_session *session,\n                                             uint8_t flags, int32_t stream_id,\n                                             const uint8_t *data, size_t len,\n                                             void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n  (void)stream_id;\n  (void)data;\n  (void)len;\n\n  ++ud->data_chunk_recv_cb_called;\n  return NGHTTP2_ERR_PAUSE;\n}\n\nstatic ssize_t select_padding_callback(nghttp2_session *session,\n                                       const nghttp2_frame *frame,\n                                       size_t max_payloadlen, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  return (ssize_t)nghttp2_min(max_payloadlen, frame->hd.length + ud->padlen);\n}\n\nstatic ssize_t too_large_data_source_length_callback(\n    nghttp2_session *session, uint8_t frame_type, int32_t stream_id,\n    int32_t session_remote_window_size, int32_t stream_remote_window_size,\n    uint32_t remote_max_frame_size, void *user_data) {\n  (void)session;\n  (void)frame_type;\n  (void)stream_id;\n  (void)session_remote_window_size;\n  (void)stream_remote_window_size;\n  (void)remote_max_frame_size;\n  (void)user_data;\n\n  return NGHTTP2_MAX_FRAME_SIZE_MAX + 1;\n}\n\nstatic ssize_t smallest_length_data_source_length_callback(\n    nghttp2_session *session, uint8_t frame_type, int32_t stream_id,\n    int32_t session_remote_window_size, int32_t stream_remote_window_size,\n    uint32_t remote_max_frame_size, void *user_data) {\n  (void)session;\n  (void)frame_type;\n  (void)stream_id;\n  (void)session_remote_window_size;\n  (void)stream_remote_window_size;\n  (void)remote_max_frame_size;\n  (void)user_data;\n\n  return 1;\n}\n\nstatic ssize_t fixed_length_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  size_t wlen;\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)source;\n\n  if (len < ud->data_source_length) {\n    wlen = len;\n  } else {\n    wlen = ud->data_source_length;\n  }\n  ud->data_source_length -= wlen;\n  if (ud->data_source_length == 0) {\n    *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n  }\n  return (ssize_t)wlen;\n}\n\nstatic ssize_t temporal_failure_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)data_flags;\n  (void)source;\n  (void)user_data;\n\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic ssize_t fail_data_source_read_callback(nghttp2_session *session,\n                                              int32_t stream_id, uint8_t *buf,\n                                              size_t len, uint32_t *data_flags,\n                                              nghttp2_data_source *source,\n                                              void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)data_flags;\n  (void)source;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nstatic ssize_t no_end_stream_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)source;\n  (void)user_data;\n\n  *data_flags |= NGHTTP2_DATA_FLAG_EOF | NGHTTP2_DATA_FLAG_NO_END_STREAM;\n  return 0;\n}\n\nstatic ssize_t no_copy_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  size_t wlen;\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)source;\n\n  if (len < ud->data_source_length) {\n    wlen = len;\n  } else {\n    wlen = ud->data_source_length;\n  }\n\n  ud->data_source_length -= wlen;\n\n  *data_flags |= NGHTTP2_DATA_FLAG_NO_COPY;\n\n  if (ud->data_source_length == 0) {\n    *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n  }\n  return (ssize_t)wlen;\n}\n\nstatic int send_data_callback(nghttp2_session *session, nghttp2_frame *frame,\n                              const uint8_t *framehd, size_t length,\n                              nghttp2_data_source *source, void *user_data) {\n  accumulator *acc = ((my_user_data *)user_data)->acc;\n  (void)session;\n  (void)source;\n\n  memcpy(acc->buf + acc->length, framehd, NGHTTP2_FRAME_HDLEN);\n  acc->length += NGHTTP2_FRAME_HDLEN;\n\n  if (frame->data.padlen) {\n    *(acc->buf + acc->length++) = (uint8_t)(frame->data.padlen - 1);\n  }\n\n  acc->length += length;\n\n  if (frame->data.padlen) {\n    acc->length += frame->data.padlen - 1;\n  }\n\n  return 0;\n}\n\nstatic ssize_t block_count_send_callback(nghttp2_session *session,\n                                         const uint8_t *data, size_t len,\n                                         int flags, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)data;\n  (void)flags;\n\n  if (ud->block_count == 0) {\n    return NGHTTP2_ERR_WOULDBLOCK;\n  }\n\n  --ud->block_count;\n  return (ssize_t)len;\n}\n\nstatic int on_header_callback(nghttp2_session *session,\n                              const nghttp2_frame *frame, const uint8_t *name,\n                              size_t namelen, const uint8_t *value,\n                              size_t valuelen, uint8_t flags, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n\n  ++ud->header_cb_called;\n  ud->nv.name = (uint8_t *)name;\n  ud->nv.namelen = namelen;\n  ud->nv.value = (uint8_t *)value;\n  ud->nv.valuelen = valuelen;\n\n  ud->frame = frame;\n  return 0;\n}\n\nstatic int pause_on_header_callback(nghttp2_session *session,\n                                    const nghttp2_frame *frame,\n                                    const uint8_t *name, size_t namelen,\n                                    const uint8_t *value, size_t valuelen,\n                                    uint8_t flags, void *user_data) {\n  on_header_callback(session, frame, name, namelen, value, valuelen, flags,\n                     user_data);\n  return NGHTTP2_ERR_PAUSE;\n}\n\nstatic int temporal_failure_on_header_callback(\n    nghttp2_session *session, const nghttp2_frame *frame, const uint8_t *name,\n    size_t namelen, const uint8_t *value, size_t valuelen, uint8_t flags,\n    void *user_data) {\n  on_header_callback(session, frame, name, namelen, value, valuelen, flags,\n                     user_data);\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic int on_invalid_header_callback(nghttp2_session *session,\n                                      const nghttp2_frame *frame,\n                                      const uint8_t *name, size_t namelen,\n                                      const uint8_t *value, size_t valuelen,\n                                      uint8_t flags, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n\n  ++ud->invalid_header_cb_called;\n  ud->nv.name = (uint8_t *)name;\n  ud->nv.namelen = namelen;\n  ud->nv.value = (uint8_t *)value;\n  ud->nv.valuelen = valuelen;\n\n  ud->frame = frame;\n  return 0;\n}\n\nstatic int pause_on_invalid_header_callback(nghttp2_session *session,\n                                            const nghttp2_frame *frame,\n                                            const uint8_t *name, size_t namelen,\n                                            const uint8_t *value,\n                                            size_t valuelen, uint8_t flags,\n                                            void *user_data) {\n  on_invalid_header_callback(session, frame, name, namelen, value, valuelen,\n                             flags, user_data);\n  return NGHTTP2_ERR_PAUSE;\n}\n\nstatic int reset_on_invalid_header_callback(nghttp2_session *session,\n                                            const nghttp2_frame *frame,\n                                            const uint8_t *name, size_t namelen,\n                                            const uint8_t *value,\n                                            size_t valuelen, uint8_t flags,\n                                            void *user_data) {\n  on_invalid_header_callback(session, frame, name, namelen, value, valuelen,\n                             flags, user_data);\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic int on_begin_headers_callback(nghttp2_session *session,\n                                     const nghttp2_frame *frame,\n                                     void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)frame;\n\n  ++ud->begin_headers_cb_called;\n  return 0;\n}\n\nstatic int temporal_failure_on_begin_headers_callback(\n    nghttp2_session *session, const nghttp2_frame *frame, void *user_data) {\n  on_begin_headers_callback(session, frame, user_data);\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic ssize_t defer_data_source_read_callback(nghttp2_session *session,\n                                               int32_t stream_id, uint8_t *buf,\n                                               size_t len, uint32_t *data_flags,\n                                               nghttp2_data_source *source,\n                                               void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)data_flags;\n  (void)source;\n  (void)user_data;\n\n  return NGHTTP2_ERR_DEFERRED;\n}\n\nstatic int on_stream_close_callback(nghttp2_session *session, int32_t stream_id,\n                                    nghttp2_error_code error_code,\n                                    void *user_data) {\n  my_user_data *my_data = (my_user_data *)user_data;\n  (void)session;\n  (void)stream_id;\n  (void)error_code;\n\n  ++my_data->stream_close_cb_called;\n  my_data->stream_close_error_code = error_code;\n\n  return 0;\n}\n\nstatic ssize_t pack_extension_callback(nghttp2_session *session, uint8_t *buf,\n                                       size_t len, const nghttp2_frame *frame,\n                                       void *user_data) {\n  nghttp2_buf *p = frame->ext.payload;\n  (void)session;\n  (void)len;\n  (void)user_data;\n\n  memcpy(buf, p->pos, nghttp2_buf_len(p));\n\n  return (ssize_t)nghttp2_buf_len(p);\n}\n\nstatic int on_extension_chunk_recv_callback(nghttp2_session *session,\n                                            const nghttp2_frame_hd *hd,\n                                            const uint8_t *data, size_t len,\n                                            void *user_data) {\n  my_user_data *my_data = (my_user_data *)user_data;\n  nghttp2_buf *buf = &my_data->scratchbuf;\n  (void)session;\n  (void)hd;\n\n  buf->last = nghttp2_cpymem(buf->last, data, len);\n\n  return 0;\n}\n\nstatic int cancel_on_extension_chunk_recv_callback(nghttp2_session *session,\n                                                   const nghttp2_frame_hd *hd,\n                                                   const uint8_t *data,\n                                                   size_t len,\n                                                   void *user_data) {\n  (void)session;\n  (void)hd;\n  (void)data;\n  (void)len;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CANCEL;\n}\n\nstatic int unpack_extension_callback(nghttp2_session *session, void **payload,\n                                     const nghttp2_frame_hd *hd,\n                                     void *user_data) {\n  my_user_data *my_data = (my_user_data *)user_data;\n  nghttp2_buf *buf = &my_data->scratchbuf;\n  (void)session;\n  (void)hd;\n\n  *payload = buf;\n\n  return 0;\n}\n\nstatic int cancel_unpack_extension_callback(nghttp2_session *session,\n                                            void **payload,\n                                            const nghttp2_frame_hd *hd,\n                                            void *user_data) {\n  (void)session;\n  (void)payload;\n  (void)hd;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CANCEL;\n}\n\nstatic nghttp2_settings_entry *dup_iv(const nghttp2_settings_entry *iv,\n                                      size_t niv) {\n  return nghttp2_frame_iv_copy(iv, niv, nghttp2_mem_default());\n}\n\nstatic nghttp2_priority_spec pri_spec_default = {0, NGHTTP2_DEFAULT_WEIGHT, 0};\n\nvoid test_nghttp2_session_recv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  scripted_data_feed df;\n  my_user_data user_data;\n  nghttp2_bufs bufs;\n  size_t framelen;\n  nghttp2_frame frame;\n  size_t i;\n  nghttp2_outbound_item *item;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_hd_deflater deflater;\n  int rv;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.recv_callback = scripted_recv_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_begin_frame_callback = on_begin_frame_callback;\n\n  user_data.df = &df;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  scripted_data_feed_init2(&df, &bufs);\n\n  framelen = nghttp2_bufs_len(&bufs);\n\n  /* Send 1 byte per each read */\n  for (i = 0; i < framelen; ++i) {\n    df.feedseq[i] = 1;\n  }\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  user_data.frame_recv_cb_called = 0;\n  user_data.begin_frame_cb_called = 0;\n\n  while (df.seqidx < framelen) {\n    CU_ASSERT(0 == nghttp2_session_recv(session));\n  }\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(1 == user_data.begin_frame_cb_called);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Receive PRIORITY */\n  nghttp2_frame_priority_init(&frame.priority, 5, &pri_spec_default);\n\n  rv = nghttp2_frame_pack_priority(&bufs, &frame.priority);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  scripted_data_feed_init2(&df, &bufs);\n\n  user_data.frame_recv_cb_called = 0;\n  user_data.begin_frame_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(1 == user_data.begin_frame_cb_called);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Some tests for frame too large */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  /* Receive PING with too large payload */\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_NONE, NULL);\n\n  rv = nghttp2_frame_pack_ping(&bufs, &frame.ping);\n\n  CU_ASSERT(0 == rv);\n\n  /* Add extra 16 bytes */\n  nghttp2_bufs_seek_last_present(&bufs);\n  assert(nghttp2_buf_len(&bufs.cur->buf) >= 16);\n\n  bufs.cur->buf.last += 16;\n  nghttp2_put_uint32be(\n      bufs.cur->buf.pos,\n      (uint32_t)(((frame.hd.length + 16) << 8) + bufs.cur->buf.pos[3]));\n\n  nghttp2_frame_ping_free(&frame.ping);\n\n  scripted_data_feed_init2(&df, &bufs);\n  user_data.frame_recv_cb_called = 0;\n  user_data.begin_frame_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(0 == user_data.frame_recv_cb_called);\n  CU_ASSERT(0 == user_data.begin_frame_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FRAME_SIZE_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_invalid_stream_id(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  scripted_data_feed df;\n  my_user_data user_data;\n  nghttp2_bufs bufs;\n  nghttp2_frame frame;\n  nghttp2_hd_deflater deflater;\n  int rv;\n  nghttp2_mem *mem;\n  nghttp2_nv *nva;\n  size_t nvlen;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.recv_callback = scripted_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  user_data.df = &df;\n  user_data.invalid_frame_recv_cb_called = 0;\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  scripted_data_feed_init2(&df, &bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_invalid_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  scripted_data_feed df;\n  my_user_data user_data;\n  nghttp2_bufs bufs;\n  nghttp2_frame frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_hd_deflater deflater;\n  int rv;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.recv_callback = scripted_recv_callback;\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  user_data.df = &df;\n  user_data.frame_send_cb_called = 0;\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  nghttp2_hd_deflate_init(&deflater, mem);\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  scripted_data_feed_init2(&df, &bufs);\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == user_data.frame_send_cb_called);\n\n  /* Receive exactly same bytes of HEADERS is treated as error, because it has\n   * pseudo headers and without END_STREAM flag set */\n  scripted_data_feed_init2(&df, &bufs);\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_RST_STREAM == user_data.sent_frame_type);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_eof(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.recv_callback = eof_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  CU_ASSERT(NGHTTP2_ERR_EOF == nghttp2_session_recv(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  uint8_t data[8092];\n  ssize_t rv;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n  nghttp2_frame_hd hd;\n  int i;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_data_chunk_recv_callback = on_data_chunk_recv_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  /* Create DATA frame with length 4KiB */\n  memset(data, 0, sizeof(data));\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  /* stream 1 is not opened, so it must be responded with connection\n     error.  This is not mandated by the spec */\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  /* Create stream 1 with CLOSING state. DATA is ignored. */\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_CLOSING);\n\n  /* Set initial window size 16383 to check stream flow control,\n     isolating it from the connection flow control */\n  stream->local_window_size = 16383;\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NULL == item);\n\n  /* This is normal case. DATA is acceptable. */\n  stream->state = NGHTTP2_STREAM_OPENED;\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(1 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  /* Now we got data more than initial-window-size / 2, WINDOW_UPDATE\n     must be queued */\n  CU_ASSERT(1 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Set initial window size to 1MiB, so that we can check connection\n     flow control individually */\n  stream->local_window_size = 1 << 20;\n  /* Connection flow control takes into account DATA which is received\n     in the error condition. We have received 4096 * 4 bytes of\n     DATA. Additional 4 DATA frames, connection flow control will kick\n     in. */\n  for (i = 0; i < 5; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Reception of DATA with stream ID = 0 causes connection error */\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 0;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_session_del(session);\n\n  /* Check window_update_queued flag in both session and stream */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  stream = open_recv_stream(session, 1);\n\n  /* Send 32767 bytes of DATA.  In our current flow control algorithm,\n     it triggers first WINDOW_UPDATE of window_size_increment\n     32767. */\n  for (i = 0; i < 7; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n\n  hd.length = 4095;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4095);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4095 == rv);\n\n  /* Now 2 WINDOW_UPDATEs for session and stream should be queued. */\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(1 == stream->window_update_queued);\n  CU_ASSERT(1 == session->window_update_queued);\n\n  /* Then send 32768 bytes of DATA.  Since we have not sent queued\n     WINDOW_UDPATE frame, recv_window_size should not be decreased */\n  hd.length = 4096;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  for (i = 0; i < 8; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n\n  /* WINDOW_UPDATE is blocked for session and stream, so\n     recv_window_size must not be decreased. */\n  CU_ASSERT(32768 == stream->recv_window_size);\n  CU_ASSERT(32768 == session->recv_window_size);\n  CU_ASSERT(1 == stream->window_update_queued);\n  CU_ASSERT(1 == session->window_update_queued);\n\n  ud.frame_send_cb_called = 0;\n\n  /* This sends queued WINDOW_UPDATES.  And then check\n     recv_window_size, and queue WINDOW_UPDATEs for both session and\n     stream, and send them at once. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(4 == ud.frame_send_cb_called);\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(0 == stream->window_update_queued);\n  CU_ASSERT(0 == session->window_update_queued);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_data_no_auto_flow_control(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_option *option;\n  nghttp2_frame_hd hd;\n  size_t padlen;\n  uint8_t data[8192];\n  ssize_t rv;\n  size_t sendlen;\n  nghttp2_stream *stream;\n  size_t i;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  /* Create DATA frame with length 4KiB + 11 bytes padding*/\n  padlen = 11;\n  memset(data, 0, sizeof(data));\n  hd.length = 4096 + 1 + padlen;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_PADDED;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  data[NGHTTP2_FRAME_HDLEN] = (uint8_t)padlen;\n\n  /* First create stream 1, then close it.  Check that data is\n     consumed for connection in this situation */\n  open_recv_stream(session, 1);\n\n  /* Receive first 100 bytes */\n  sendlen = 100;\n  rv = nghttp2_session_mem_recv(session, data, sendlen);\n  CU_ASSERT((ssize_t)sendlen == rv);\n\n  /* We consumed pad length field (1 byte) */\n  CU_ASSERT(1 == session->consumed_size);\n\n  /* close stream here */\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1, NGHTTP2_NO_ERROR);\n  nghttp2_session_send(session);\n\n  /* stream 1 has been closed, and we disabled auto flow-control, so\n     data must be immediately consumed for connection. */\n  rv = nghttp2_session_mem_recv(session, data + sendlen,\n                                NGHTTP2_FRAME_HDLEN + hd.length - sendlen);\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length - sendlen) == rv);\n\n  /* We already consumed pad length field (1 byte), so do +1 here */\n  CU_ASSERT((int32_t)(NGHTTP2_FRAME_HDLEN + hd.length - sendlen + 1) ==\n            session->consumed_size);\n\n  nghttp2_session_del(session);\n\n  /* Reuse DATA created previously. */\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  /* Now we are expecting final response header, which means receiving\n     DATA for that stream is illegal. */\n  stream = open_recv_stream(session, 1);\n  stream->http_flags |= NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE;\n\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + hd.length);\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length) == rv);\n\n  /* Whole payload must be consumed now because HTTP messaging rule\n     was not honored. */\n  CU_ASSERT((int32_t)hd.length == session->consumed_size);\n\n  nghttp2_session_del(session);\n\n  /* Check window_update_queued flag in both session and stream */\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  stream = open_recv_stream(session, 1);\n\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  /* Receive up to 65535 bytes of DATA */\n  for (i = 0; i < 15; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n\n  hd.length = 4095;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4095);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4095 == rv);\n\n  CU_ASSERT(65535 == session->recv_window_size);\n  CU_ASSERT(65535 == stream->recv_window_size);\n\n  /* The first call of nghttp2_session_consume_connection() will queue\n     WINDOW_UPDATE.  Next call does not. */\n  nghttp2_session_consume_connection(session, 32767);\n  nghttp2_session_consume_connection(session, 32768);\n\n  CU_ASSERT(32768 == session->recv_window_size);\n  CU_ASSERT(65535 == stream->recv_window_size);\n  CU_ASSERT(1 == session->window_update_queued);\n  CU_ASSERT(0 == stream->window_update_queued);\n\n  ud.frame_send_cb_called = 0;\n\n  /* This will send WINDOW_UPDATE, and check whether we should send\n     WINDOW_UPDATE, and queue and send it at once. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(65535 == stream->recv_window_size);\n  CU_ASSERT(0 == session->window_update_queued);\n  CU_ASSERT(0 == stream->window_update_queued);\n  CU_ASSERT(2 == ud.frame_send_cb_called);\n\n  /* Do the same for stream */\n  nghttp2_session_consume_stream(session, 1, 32767);\n  nghttp2_session_consume_stream(session, 1, 32768);\n\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(32768 == stream->recv_window_size);\n  CU_ASSERT(0 == session->window_update_queued);\n  CU_ASSERT(1 == stream->window_update_queued);\n\n  ud.frame_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == session->window_update_queued);\n  CU_ASSERT(0 == stream->window_update_queued);\n  CU_ASSERT(2 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_recv_continuation(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  uint8_t data[1024];\n  size_t datalen;\n  nghttp2_frame_hd cont_hd;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_header_callback = on_header_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_begin_frame_callback = on_begin_frame_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* Make 1 HEADERS and insert CONTINUATION header */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_NONE, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  /* make sure that all data is in the first buf */\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* HEADERS's payload is 1 byte */\n  memcpy(data, buf->pos, NGHTTP2_FRAME_HDLEN + 1);\n  datalen = NGHTTP2_FRAME_HDLEN + 1;\n  buf->pos += NGHTTP2_FRAME_HDLEN + 1;\n\n  nghttp2_put_uint32be(data, (uint32_t)((1 << 8) + data[3]));\n\n  /* First CONTINUATION, 2 bytes */\n  nghttp2_frame_hd_init(&cont_hd, 2, NGHTTP2_CONTINUATION, NGHTTP2_FLAG_NONE,\n                        1);\n\n  nghttp2_frame_pack_frame_hd(data + datalen, &cont_hd);\n  datalen += NGHTTP2_FRAME_HDLEN;\n\n  memcpy(data + datalen, buf->pos, cont_hd.length);\n  datalen += cont_hd.length;\n  buf->pos += cont_hd.length;\n\n  /* Second CONTINUATION, rest of the bytes */\n  nghttp2_frame_hd_init(&cont_hd, nghttp2_buf_len(buf), NGHTTP2_CONTINUATION,\n                        NGHTTP2_FLAG_END_HEADERS, 1);\n\n  nghttp2_frame_pack_frame_hd(data + datalen, &cont_hd);\n  datalen += NGHTTP2_FRAME_HDLEN;\n\n  memcpy(data + datalen, buf->pos, cont_hd.length);\n  datalen += cont_hd.length;\n  buf->pos += cont_hd.length;\n\n  CU_ASSERT(0 == nghttp2_buf_len(buf));\n\n  ud.header_cb_called = 0;\n  ud.begin_frame_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n  CU_ASSERT((ssize_t)datalen == rv);\n  CU_ASSERT(4 == ud.header_cb_called);\n  CU_ASSERT(3 == ud.begin_frame_cb_called);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* HEADERS with padding followed by CONTINUATION */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_NONE, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n\n  nghttp2_bufs_reset(&bufs);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* make sure that all data is in the first buf */\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  /* HEADERS payload is 3 byte (1 for padding field, 1 for padding) */\n  memcpy(data, buf->pos, NGHTTP2_FRAME_HDLEN);\n  nghttp2_put_uint32be(data, (uint32_t)((3 << 8) + data[3]));\n  data[4] |= NGHTTP2_FLAG_PADDED;\n  /* padding field */\n  data[NGHTTP2_FRAME_HDLEN] = 1;\n  data[NGHTTP2_FRAME_HDLEN + 1] = buf->pos[NGHTTP2_FRAME_HDLEN];\n  /* padding */\n  data[NGHTTP2_FRAME_HDLEN + 2] = 0;\n  datalen = NGHTTP2_FRAME_HDLEN + 3;\n  buf->pos += NGHTTP2_FRAME_HDLEN + 1;\n\n  /* CONTINUATION, rest of the bytes */\n  nghttp2_frame_hd_init(&cont_hd, nghttp2_buf_len(buf), NGHTTP2_CONTINUATION,\n                        NGHTTP2_FLAG_END_HEADERS, 1);\n  nghttp2_frame_pack_frame_hd(data + datalen, &cont_hd);\n  datalen += NGHTTP2_FRAME_HDLEN;\n\n  memcpy(data + datalen, buf->pos, cont_hd.length);\n  datalen += cont_hd.length;\n  buf->pos += cont_hd.length;\n\n  CU_ASSERT(0 == nghttp2_buf_len(buf));\n\n  ud.header_cb_called = 0;\n  ud.begin_frame_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n\n  CU_ASSERT((ssize_t)datalen == rv);\n  CU_ASSERT(4 == ud.header_cb_called);\n  CU_ASSERT(2 == ud.begin_frame_cb_called);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Expecting CONTINUATION, but get the other frame */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* HEADERS without END_HEADERS flag */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_NONE, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  nghttp2_bufs_reset(&bufs);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* make sure that all data is in the first buf */\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  memcpy(data, buf->pos, nghttp2_buf_len(buf));\n  datalen = nghttp2_buf_len(buf);\n\n  /* Followed by PRIORITY */\n  nghttp2_priority_spec_default_init(&pri_spec);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n  nghttp2_bufs_reset(&bufs);\n\n  rv = nghttp2_frame_pack_priority(&bufs, &frame.priority);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  memcpy(data + datalen, buf->pos, nghttp2_buf_len(buf));\n  datalen += nghttp2_buf_len(buf);\n\n  ud.begin_headers_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n  CU_ASSERT((ssize_t)datalen == rv);\n\n  CU_ASSERT(1 == ud.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_GOAWAY ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_headers_with_priority(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  nghttp2_outbound_item *item;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_recv_stream(session, 1);\n\n  /* With NGHTTP2_FLAG_PRIORITY without exclusive flag set */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 99, 0);\n\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             3, NGHTTP2_HCAT_HEADERS, &pri_spec, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 3);\n\n  CU_ASSERT(99 == stream->weight);\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* With NGHTTP2_FLAG_PRIORITY, but cut last 1 byte to make it\n     invalid. */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 99, 0);\n\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             5, NGHTTP2_HCAT_HEADERS, &pri_spec, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > NGHTTP2_FRAME_HDLEN + 5);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  /* Make payload shorter than required length to store priority\n     group */\n  nghttp2_put_uint32be(buf->pos, (uint32_t)((4 << 8) + buf->pos[3]));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 5);\n\n  CU_ASSERT(NULL == stream);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FRAME_SIZE_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Check dep_stream_id == stream_id */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 0, 0);\n\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             1, NGHTTP2_HCAT_HEADERS, &pri_spec, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL == stream);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_headers_with_padding(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  ssize_t rv;\n\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n\n  /* HEADERS: Wrong padding length */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  nghttp2_session_send(session);\n\n  nghttp2_frame_hd_init(&hd, 10, NGHTTP2_HEADERS,\n                        NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY |\n                            NGHTTP2_FLAG_PADDED,\n                        1);\n  buf = &bufs.head->buf;\n  nghttp2_frame_pack_frame_hd(buf->last, &hd);\n  buf->last += NGHTTP2_FRAME_HDLEN;\n  /* padding is 6 bytes */\n  *buf->last++ = 5;\n  /* priority field */\n  nghttp2_put_uint32be(buf->last, 3);\n  buf->last += sizeof(uint32_t);\n  *buf->last++ = 1;\n  /* rest is garbage */\n  memset(buf->last, 0, 4);\n  buf->last += 4;\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_session_del(session);\n\n  /* PUSH_PROMISE: Wrong padding length */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_session_send(session);\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_hd_init(&hd, 9, NGHTTP2_PUSH_PROMISE,\n                        NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED, 1);\n  buf = &bufs.head->buf;\n  nghttp2_frame_pack_frame_hd(buf->last, &hd);\n  buf->last += NGHTTP2_FRAME_HDLEN;\n  /* padding is 6 bytes */\n  *buf->last++ = 5;\n  /* promised stream ID field */\n  nghttp2_put_uint32be(buf->last, 2);\n  buf->last += sizeof(uint32_t);\n  /* rest is garbage */\n  memset(buf->last, 0, 4);\n  buf->last += 4;\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nstatic int response_on_begin_frame_callback(nghttp2_session *session,\n                                            const nghttp2_frame_hd *hd,\n                                            void *user_data) {\n  int rv;\n  (void)user_data;\n\n  if (hd->type != NGHTTP2_HEADERS) {\n    return 0;\n  }\n\n  rv = nghttp2_submit_response(session, hd->stream_id, resnv, ARRLEN(resnv),\n                               NULL);\n\n  CU_ASSERT(0 == rv);\n\n  return 0;\n}\n\nvoid test_nghttp2_session_recv_headers_early_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  ssize_t rv;\n  nghttp2_stream *stream;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_begin_frame_callback = response_on_begin_frame_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                             1, NGHTTP2_HCAT_REQUEST, NULL, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n\n  /* Only receive 9 bytes headers, and invoke\n     on_begin_frame_callback */\n  rv = nghttp2_session_mem_recv(session, buf->pos, 9);\n\n  CU_ASSERT(9 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  rv =\n      nghttp2_session_mem_recv(session, buf->pos + 9, nghttp2_buf_len(buf) - 9);\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) - 9 == rv);\n\n  stream = nghttp2_session_get_stream_raw(session, 1);\n\n  CU_ASSERT(stream->flags & NGHTTP2_STREAM_FLAG_CLOSED);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_recv_headers_for_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n  const uint8_t *data;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_header_callback = on_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* Make sure that on_header callback never be invoked for closed\n     stream */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, NGHTTP2_FRAME_HDLEN);\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL != stream);\n\n  rv = nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1,\n                                 NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(rv > 0);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL == stream);\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos + NGHTTP2_FRAME_HDLEN,\n                                nghttp2_buf_len(buf) - NGHTTP2_FRAME_HDLEN);\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) - NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_server_recv_push_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_mem *mem;\n  nghttp2_frame frame;\n  nghttp2_hd_deflater deflater;\n  nghttp2_nv *nva;\n  size_t nvlen;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nvlen = ARRLEN(resnv);\n  nghttp2_nv_array_copy(&nva, resnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, &pri_spec_default, nva,\n                             nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n\n  ud.invalid_frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_premature_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n  uint32_t payloadlen;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  /* Intentionally feed payload cutting last 1 byte off */\n  payloadlen = nghttp2_get_uint32(buf->pos) >> 8;\n  nghttp2_put_uint32be(buf->pos, ((payloadlen - 1) << 8) + buf->pos[3]);\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf) - 1);\n\n  CU_ASSERT((ssize_t)(nghttp2_buf_len(buf) - 1) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_COMPRESSION_ERROR == item->frame.rst_stream.error_code);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Test for PUSH_PROMISE */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_sent_stream3(session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec_default,\n                    NGHTTP2_STREAM_OPENING, NULL);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  buf = &bufs.head->buf;\n  payloadlen = nghttp2_get_uint32(buf->pos) >> 8;\n  /* Intentionally feed payload cutting last 1 byte off */\n  nghttp2_put_uint32be(buf->pos, ((payloadlen - 1) << 8) + buf->pos[3]);\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf) - 1);\n\n  CU_ASSERT((ssize_t)(nghttp2_buf_len(buf) - 1) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_COMPRESSION_ERROR == item->frame.rst_stream.error_code);\n  CU_ASSERT(2 == item->frame.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_recv_unknown_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  uint8_t data[16384];\n  size_t datalen;\n  nghttp2_frame_hd hd;\n  ssize_t rv;\n\n  nghttp2_frame_hd_init(&hd, 16000, 99, NGHTTP2_FLAG_NONE, 0);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  datalen = NGHTTP2_FRAME_HDLEN + hd.length;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  ud.frame_recv_cb_called = 0;\n\n  /* Unknown frame must be ignored */\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n\n  CU_ASSERT(rv == (ssize_t)datalen);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_unexpected_continuation(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  uint8_t data[16384];\n  size_t datalen;\n  nghttp2_frame_hd hd;\n  ssize_t rv;\n  nghttp2_outbound_item *item;\n\n  nghttp2_frame_hd_init(&hd, 16000, NGHTTP2_CONTINUATION,\n                        NGHTTP2_FLAG_END_HEADERS, 1);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  datalen = NGHTTP2_FRAME_HDLEN + hd.length;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  ud.frame_recv_cb_called = 0;\n\n  /* unexpected CONTINUATION must be treated as connection error */\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n\n  CU_ASSERT(rv == (ssize_t)datalen);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_settings_header_table_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_settings_entry iv[3];\n  nghttp2_nv nv = MAKE_NV(\":authority\", \"example.org\");\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3000;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16384;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 2),\n                              2);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(3000 == session->remote_settings.header_table_size);\n  CU_ASSERT(16384 == session->remote_settings.initial_window_size);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* 2 SETTINGS_HEADER_TABLE_SIZE */\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3001;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16383;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[2].value = 3001;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 3),\n                              3);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)(nghttp2_buf_len(buf)) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(3001 == session->remote_settings.header_table_size);\n  CU_ASSERT(16383 == session->remote_settings.initial_window_size);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* 2 SETTINGS_HEADER_TABLE_SIZE; first entry clears dynamic header\n     table. */\n\n  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);\n  nghttp2_session_send(session);\n\n  CU_ASSERT(0 < session->hd_deflater.ctx.hd_table.len);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 0;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16382;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[2].value = 4096;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 3),\n                              3);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(4096 == session->remote_settings.header_table_size);\n  CU_ASSERT(16382 == session->remote_settings.initial_window_size);\n  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* 2 SETTINGS_HEADER_TABLE_SIZE; second entry clears dynamic header\n     table. */\n\n  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);\n  nghttp2_session_send(session);\n\n  CU_ASSERT(0 < session->hd_deflater.ctx.hd_table.len);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3000;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16381;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[2].value = 0;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 3),\n                              3);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(0 == session->remote_settings.header_table_size);\n  CU_ASSERT(16381 == session->remote_settings.initial_window_size);\n  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_too_large_frame_length(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t buf[NGHTTP2_FRAME_HDLEN];\n  nghttp2_outbound_item *item;\n  nghttp2_frame_hd hd;\n\n  /* Initial max frame size is NGHTTP2_MAX_FRAME_SIZE_MIN */\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_FRAME_SIZE_MIN + 1, NGHTTP2_HEADERS,\n                        NGHTTP2_FLAG_NONE, 1);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_frame_pack_frame_hd(buf, &hd);\n\n  CU_ASSERT(sizeof(buf) == nghttp2_session_mem_recv(session, buf, sizeof(buf)));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_extension(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_buf buf;\n  nghttp2_frame_hd hd;\n  nghttp2_mem *mem;\n  const char data[] = \"Hello World!\";\n  ssize_t rv;\n  nghttp2_option *option;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.on_extension_chunk_recv_callback = on_extension_chunk_recv_callback;\n  callbacks.unpack_extension_callback = unpack_extension_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_user_recv_extension_type(option, 111);\n\n  nghttp2_buf_init2(&ud.scratchbuf, 4096, mem);\n  nghttp2_buf_init2(&buf, 4096, mem);\n\n  nghttp2_frame_hd_init(&hd, sizeof(data), 111, 0xab, 1000000007);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  buf.last = nghttp2_cpymem(buf.last, data, sizeof(data));\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&ud.recv_frame_hd, 0, 0, 0, 0);\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + hd.length == (size_t)rv);\n  CU_ASSERT(111 == ud.recv_frame_hd.type);\n  CU_ASSERT(0xab == ud.recv_frame_hd.flags);\n  CU_ASSERT(1000000007 == ud.recv_frame_hd.stream_id);\n  CU_ASSERT(0 == memcmp(data, ud.scratchbuf.pos, sizeof(data)));\n\n  nghttp2_session_del(session);\n\n  /* cancel in on_extension_chunk_recv_callback */\n  nghttp2_buf_reset(&ud.scratchbuf);\n\n  callbacks.on_extension_chunk_recv_callback =\n      cancel_on_extension_chunk_recv_callback;\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + hd.length == (size_t)rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* cancel in unpack_extension_callback */\n  nghttp2_buf_reset(&ud.scratchbuf);\n\n  callbacks.on_extension_chunk_recv_callback = on_extension_chunk_recv_callback;\n  callbacks.unpack_extension_callback = cancel_unpack_extension_callback;\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + hd.length == (size_t)rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  nghttp2_buf_free(&buf, mem);\n  nghttp2_buf_free(&ud.scratchbuf, mem);\n\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_recv_altsvc(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_buf buf;\n  nghttp2_frame_hd hd;\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_option *option;\n  static const uint8_t origin[] = \"nghttp2.org\";\n  static const uint8_t field_value[] = \"h2=\\\":443\\\"\";\n\n  mem = nghttp2_mem_default();\n\n  nghttp2_buf_init2(&buf, NGHTTP2_FRAME_HDLEN + NGHTTP2_MAX_FRAME_SIZE_MIN,\n                    mem);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 + sizeof(field_value) - 1,\n                        NGHTTP2_ALTSVC, NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ALTSVC == ud.recv_frame_hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == ud.recv_frame_hd.flags);\n  CU_ASSERT(0 == ud.recv_frame_hd.stream_id);\n\n  nghttp2_session_del(session);\n\n  /* size of origin is larger than frame length */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 - 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1 - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* zero-length value */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n\n  ud.invalid_frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* non-empty origin to a stream other than 0 */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 + sizeof(field_value) - 1,\n                        NGHTTP2_ALTSVC, NGHTTP2_FLAG_NONE, 1);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.invalid_frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* empty origin to stream 0 */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(field_value) - 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, 0);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.invalid_frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* send large frame (16KiB) */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_FRAME_SIZE_MIN, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  memset(buf.last, 0, nghttp2_buf_avail(&buf));\n  buf.last += nghttp2_buf_avail(&buf);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ALTSVC == ud.recv_frame_hd.type);\n  CU_ASSERT(NGHTTP2_MAX_FRAME_SIZE_MIN == ud.recv_frame_hd.length);\n\n  nghttp2_session_del(session);\n\n  /* send too large frame */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  session->local_settings.max_frame_size = NGHTTP2_MAX_FRAME_SIZE_MIN - 1;\n\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_FRAME_SIZE_MIN + 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  memset(buf.last, 0, nghttp2_buf_avail(&buf));\n  buf.last += nghttp2_buf_avail(&buf);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* received by server */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 + sizeof(field_value) - 1,\n                        NGHTTP2_ALTSVC, NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  nghttp2_buf_free(&buf, mem);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_recv_origin(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  nghttp2_option *option;\n  nghttp2_extension frame;\n  nghttp2_ext_origin origin;\n  nghttp2_origin_entry ov;\n  static const uint8_t nghttp2[] = \"https://nghttp2.org\";\n\n  frame_pack_bufs_init(&bufs);\n\n  frame.payload = &origin;\n\n  ov.origin = (uint8_t *)nghttp2;\n  ov.origin_len = sizeof(nghttp2) - 1;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ORIGIN);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ORIGIN == ud.recv_frame_hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == ud.recv_frame_hd.flags);\n  CU_ASSERT(0 == ud.recv_frame_hd.stream_id);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* The length of origin is larger than payload length. */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_put_uint16be(bufs.head->buf.pos + NGHTTP2_FRAME_HDLEN,\n                       (uint16_t)sizeof(nghttp2));\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* A frame should be ignored if it is sent to a stream other than\n     stream 0. */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  frame.hd.stream_id = 1;\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* A frame should be ignored if the reserved flag is set */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  frame.hd.flags = 0xf0;\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* A frame should be ignored if it is received by a server. */\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* Receiving empty ORIGIN frame */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, NULL, 0);\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ORIGIN == ud.recv_frame_hd.type);\n\n  nghttp2_session_del(session);\n\n  nghttp2_option_del(option);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_continue(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  const nghttp2_nv nv1[] = {MAKE_NV(\":method\", \"GET\"), MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv nv2[] = {MAKE_NV(\"user-agent\", \"nghttp2/1.0.0\"),\n                            MAKE_NV(\"alpha\", \"bravo\")};\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  size_t framelen1, framelen2;\n  ssize_t rv;\n  uint8_t buffer[4096];\n  nghttp2_buf databuf;\n  nghttp2_frame frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  const nghttp2_frame *recv_frame;\n  nghttp2_frame_hd data_hd;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n  nghttp2_buf_wrap_init(&databuf, buffer, sizeof(buffer));\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_data_chunk_recv_callback = pause_on_data_chunk_recv_callback;\n  callbacks.on_header_callback = pause_on_header_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  /* disable strict HTTP layering checks */\n  session->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* Make 2 HEADERS frames */\n  nvlen = ARRLEN(nv1);\n  nghttp2_nv_array_copy(&nva, nv1, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  framelen1 = nghttp2_buf_len(buf);\n  databuf.last = nghttp2_cpymem(databuf.last, buf->pos, nghttp2_buf_len(buf));\n\n  nvlen = ARRLEN(nv2);\n  nghttp2_nv_array_copy(&nva, nv2, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  nghttp2_bufs_reset(&bufs);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  framelen2 = nghttp2_buf_len(buf);\n  databuf.last = nghttp2_cpymem(databuf.last, buf->pos, nghttp2_buf_len(buf));\n\n  /* Receive 1st HEADERS and pause */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  recv_frame = user_data.frame;\n  CU_ASSERT(NGHTTP2_HEADERS == recv_frame->hd.type);\n  CU_ASSERT(framelen1 - NGHTTP2_FRAME_HDLEN == recv_frame->hd.length);\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv1[0], &user_data.nv));\n\n  /* get 2nd header field */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv1[1], &user_data.nv));\n\n  /* will call end_headers_callback and receive 2nd HEADERS and pause */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  recv_frame = user_data.frame;\n  CU_ASSERT(NGHTTP2_HEADERS == recv_frame->hd.type);\n  CU_ASSERT(framelen2 - NGHTTP2_FRAME_HDLEN == recv_frame->hd.length);\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv2[0], &user_data.nv));\n\n  /* get 2nd header field */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv2[1], &user_data.nv));\n\n  /* No input data, frame_recv_callback is called */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  user_data.frame_recv_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.header_cb_called);\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  /* Receive DATA */\n  nghttp2_frame_hd_init(&data_hd, 16, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 1);\n\n  nghttp2_buf_reset(&databuf);\n  nghttp2_frame_pack_frame_hd(databuf.pos, &data_hd);\n\n  /* Intentionally specify larger buffer size to see pause is kicked\n     in. */\n  databuf.last = databuf.end;\n\n  user_data.frame_recv_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(16 + NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(0 == user_data.frame_recv_cb_called);\n\n  /* Next nghttp2_session_mem_recv invokes on_frame_recv_callback and\n     pause again in on_data_chunk_recv_callback since we pass same\n     DATA frame. */\n  user_data.frame_recv_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n  CU_ASSERT(16 + NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  /* And finally call on_frame_recv_callback with 0 size input */\n  user_data.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, NULL, 0);\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_add_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  my_user_data user_data;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n\n  acc.length = 0;\n  user_data.acc = &acc;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &user_data));\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_frame_headers_init(\n      &frame->headers, NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n      (int32_t)session->next_stream_id, NGHTTP2_HCAT_REQUEST, NULL, nva, nvlen);\n\n  session->next_stream_id += 2;\n\n  CU_ASSERT(0 == nghttp2_session_add_item(session, item));\n  CU_ASSERT(NULL != nghttp2_outbound_queue_top(&session->ob_syn));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_HEADERS == acc.buf[3]);\n  CU_ASSERT((NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY) == acc.buf[4]);\n  /* check stream id */\n  CU_ASSERT(1 == nghttp2_get_uint32(&acc.buf[5]));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_request_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  int32_t stream_id = 1;\n  nghttp2_nv malformed_nva[] = {MAKE_NV(\":path\", \"\\x01\")};\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 255, 0);\n\n  nghttp2_frame_headers_init(\n      &frame.headers, NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n      stream_id, NGHTTP2_HCAT_REQUEST, &pri_spec, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  stream = nghttp2_session_get_stream(session, stream_id);\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n  CU_ASSERT(255 == stream->weight);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* More than un-ACKed max concurrent streams leads REFUSED_STREAM */\n  session->pending_local_max_concurrent_stream = 1;\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             3, NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  session->local_settings.max_concurrent_streams =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n\n  /* Stream ID less than or equal to the previouly received request\n     HEADERS is just ignored due to race condition */\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             3, NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* Stream ID is our side and it is idle stream ID, then treat it as\n     connection error */\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             2, NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  /* Check malformed headers. The library accept it. */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  nvlen = ARRLEN(malformed_nva);\n  nghttp2_nv_array_copy(&nva, malformed_nva, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             1, NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  /* Check client side */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  /* Receiving peer's idle stream ID is subject to connection error */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  /* Receiving our's idle stream ID is subject to connection error */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  session->next_stream_id = 5;\n  session->last_sent_stream_id = 3;\n\n  /* Stream ID which is not idle and not in stream map is just\n     ignored */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  /* Stream ID which is equal to local_last_stream_id is ok. */\n  session->local_last_stream_id = 3;\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  CU_ASSERT(0 == nghttp2_session_on_request_headers_received(session, &frame));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* If GOAWAY has been sent, new stream is ignored */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 5,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_SENT;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  /* HEADERS to closed stream */\n  stream = open_recv_stream(session, 1);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_response_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_response_headers_received(session, &frame,\n                                                              stream));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENED);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  /* stream closed */\n  frame.hd.flags |= NGHTTP2_FLAG_END_STREAM;\n\n  CU_ASSERT(0 == nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(2 == user_data.begin_headers_cb_called);\n\n  /* Check to see when NGHTTP2_STREAM_CLOSING, incoming HEADERS is\n     discarded. */\n  stream = open_sent_stream2(session, 3, NGHTTP2_STREAM_CLOSING);\n  frame.hd.stream_id = 3;\n  frame.hd.flags = NGHTTP2_FLAG_END_HEADERS;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_headers_received(session, &frame, stream));\n  /* See no counters are updated */\n  CU_ASSERT(2 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n\n  /* Server initiated stream */\n  stream = open_recv_stream(session, 2);\n\n  frame.hd.flags = NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM;\n  frame.hd.stream_id = 2;\n\n  CU_ASSERT(0 == nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(3 == user_data.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n\n  /* Further reception of HEADERS is subject to stream error */\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_push_response_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  /* nghttp2_session_on_push_response_headers_received assumes\n     stream's state is NGHTTP2_STREAM_RESERVED and session->server is\n     0. */\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(0 == nghttp2_session_on_push_response_headers_received(\n                     session, &frame, stream));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(0 == (stream->flags & NGHTTP2_STREAM_FLAG_PUSH));\n\n  /* If un-ACKed max concurrent streams limit is exceeded,\n     RST_STREAMed */\n  session->pending_local_max_concurrent_stream = 1;\n  stream = open_recv_stream2(session, 4, NGHTTP2_STREAM_RESERVED);\n  frame.hd.stream_id = 4;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_response_headers_received(session, &frame,\n                                                              stream));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_REFUSED_STREAM == item->frame.rst_stream.error_code);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == session->num_incoming_streams);\n\n  /* If ACKed max concurrent streams limit is exceeded, GOAWAY is\n     issued */\n  session->local_settings.max_concurrent_streams = 1;\n\n  stream = open_recv_stream2(session, 6, NGHTTP2_STREAM_RESERVED);\n  frame.hd.stream_id = 6;\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_response_headers_received(session, &frame,\n                                                              stream));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_priority_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream, *dep_stream;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_outbound_item *item;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  stream = open_recv_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 2, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  /* depend on stream 0 */\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  CU_ASSERT(2 == stream->weight);\n\n  stream = open_sent_stream(session, 2);\n  dep_stream = open_recv_stream(session, 3);\n\n  frame.hd.stream_id = 2;\n\n  /* using dependency stream */\n  nghttp2_priority_spec_init(&frame.priority.pri_spec, 3, 1, 0);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n  CU_ASSERT(dep_stream == stream->dep_prev);\n\n  /* PRIORITY against idle stream */\n\n  frame.hd.stream_id = 100;\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  stream = nghttp2_session_get_stream_raw(session, frame.hd.stream_id);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(dep_stream == stream->dep_prev);\n\n  nghttp2_frame_priority_free(&frame.priority);\n  nghttp2_session_del(session);\n\n  /* Check dep_stream_id == stream_id case */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  open_recv_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 0, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_priority_free(&frame.priority);\n  nghttp2_session_del(session);\n\n  /* Check again dep_stream_id == stream_id, and stream_id is idle */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 16, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_priority_free(&frame.priority);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_rst_stream_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  open_recv_stream(session, 1);\n\n  nghttp2_frame_rst_stream_init(&frame.rst_stream, 1, NGHTTP2_PROTOCOL_ERROR);\n\n  CU_ASSERT(0 == nghttp2_session_on_rst_stream_received(session, &frame));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_frame_rst_stream_free(&frame.rst_stream);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_settings_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_stream *stream1, *stream2;\n  nghttp2_frame frame;\n  const size_t niv = 5;\n  nghttp2_settings_entry iv[255];\n  nghttp2_outbound_item *item;\n  nghttp2_nv nv = MAKE_NV(\":authority\", \"example.org\");\n  nghttp2_mem *mem;\n  nghttp2_option *option;\n\n  mem = nghttp2_mem_default();\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 50;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[1].value = 1000000009;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[2].value = 64 * 1024;\n\n  iv[3].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[3].value = 1024;\n\n  iv[4].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;\n  iv[4].value = 0;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  session->remote_settings.initial_window_size = 16 * 1024;\n\n  stream1 = open_sent_stream(session, 1);\n  stream2 = open_recv_stream(session, 2);\n\n  /* Set window size for each streams and will see how settings\n     updates these values */\n  stream1->remote_window_size = 16 * 1024;\n  stream2->remote_window_size = -48 * 1024;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE,\n                              dup_iv(iv, niv), niv);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  CU_ASSERT(1000000009 == session->remote_settings.max_concurrent_streams);\n  CU_ASSERT(64 * 1024 == session->remote_settings.initial_window_size);\n  CU_ASSERT(1024 == session->remote_settings.header_table_size);\n  CU_ASSERT(0 == session->remote_settings.enable_push);\n\n  CU_ASSERT(64 * 1024 == stream1->remote_window_size);\n  CU_ASSERT(0 == stream2->remote_window_size);\n\n  frame.settings.iv[2].value = 16 * 1024;\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  CU_ASSERT(16 * 1024 == stream1->remote_window_size);\n  CU_ASSERT(-48 * 1024 == stream2->remote_window_size);\n\n  CU_ASSERT(16 * 1024 == nghttp2_session_get_stream_remote_window_size(\n                             session, stream1->stream_id));\n  CU_ASSERT(0 == nghttp2_session_get_stream_remote_window_size(\n                     session, stream2->stream_id));\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  nghttp2_session_del(session);\n\n  /* Check ACK with niv > 0 */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, dup_iv(iv, 1),\n                              1);\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check ACK against no inflight SETTINGS */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check that 2 SETTINGS_HEADER_TABLE_SIZE 0 and 4096 are included\n     and header table size is once cleared to 0. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(session->hd_deflater.ctx.hd_table.len > 0);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 0;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[1].value = 2048;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 2),\n                              2);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);\n  CU_ASSERT(2048 == session->hd_deflater.ctx.hd_table_bufsize_max);\n  CU_ASSERT(2048 == session->remote_settings.header_table_size);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check that remote SETTINGS_MAX_CONCURRENT_STREAMS is set to a value set by\n     nghttp2_option_set_peer_max_concurrent_streams() and reset to the default\n     value (unlimited) after receiving initial SETTINGS frame from the peer. */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_peer_max_concurrent_streams(option, 1000);\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n  CU_ASSERT(1000 == session->remote_settings.max_concurrent_streams);\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, NULL, 0);\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==\n            session->remote_settings.max_concurrent_streams);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Check too large SETTINGS_MAX_FRAME_SIZE */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_FRAME_SIZE;\n  iv[0].value = NGHTTP2_MAX_FRAME_SIZE_MAX + 1;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),\n                              1);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check the case where stream window size overflows */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream1 = open_recv_stream(session, 1);\n\n  /* This will increment window size by 1 */\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   1);\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[0].value = NGHTTP2_MAX_WINDOW_SIZE;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),\n                              1);\n\n  /* Now window size gets NGHTTP2_MAX_WINDOW_SIZE + 1, which is\n     unacceptable situation in protocol spec. */\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_STREAM_CLOSING == stream1->state);\n\n  nghttp2_session_del(session);\n\n  /* It is invalid that peer disables ENABLE_CONNECT_PROTOCOL once it\n     has been enabled. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  session->remote_settings.enable_connect_protocol = 1;\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL;\n  iv[0].value = 0;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),\n                              1);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_push_promise_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream, *promised_stream;\n  nghttp2_outbound_item *item;\n  nghttp2_nv malformed_nva[] = {MAKE_NV(\":path\", \"\\x01\")};\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_mem *mem;\n  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_ENABLE_PUSH, 0};\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  promised_stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == promised_stream->state);\n  CU_ASSERT(2 == session->last_recv_stream_id);\n\n  /* Attempt to PUSH_PROMISE against half close (remote) */\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  frame.push_promise.promised_stream_id = 4;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 4));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_STREAM_CLOSED == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(4 == session->last_recv_stream_id);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  /* Attempt to PUSH_PROMISE against stream in closing state */\n  stream->state = NGHTTP2_STREAM_CLOSING;\n  frame.push_promise.promised_stream_id = 6;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 6));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(6 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_CANCEL == item->frame.rst_stream.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Attempt to PUSH_PROMISE against idle stream */\n  frame.hd.stream_id = 3;\n  frame.push_promise.promised_stream_id = 8;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 8));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  /* Same ID twice */\n  frame.hd.stream_id = 1;\n  frame.push_promise.promised_stream_id = 2;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 2));\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 8));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* After GOAWAY, PUSH_PROMISE will be discarded */\n  frame.push_promise.promised_stream_id = 10;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 10));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  /* Attempt to PUSH_PROMISE against reserved (remote) stream */\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  2, 4, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* Disable PUSH */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_sent_stream(session, 1);\n\n  session->local_settings.enable_push = 0;\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* Check malformed headers. We accept malformed headers */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_sent_stream(session, 1);\n\n  nvlen = ARRLEN(malformed_nva);\n  nghttp2_nv_array_copy(&nva, malformed_nva, nvlen, mem);\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, nva, nvlen);\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* If local_settings.enable_push = 0 is pending, but not acked from\n     peer, incoming PUSH_PROMISE is rejected */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_sent_stream(session, 1);\n\n  /* Submit settings with ENABLE_PUSH = 0 (thus disabling push) */\n  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, NULL, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* Check max_incoming_reserved_streams */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  session->max_incoming_reserved_streams = 1;\n\n  open_sent_stream(session, 1);\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 4, NULL, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_CANCEL == item->frame.rst_stream.error_code);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_ping_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_outbound_item *top;\n  const uint8_t opaque_data[] = \"01234567\";\n  nghttp2_option *option;\n\n  user_data.frame_recv_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_ACK, opaque_data);\n\n  CU_ASSERT(0 == nghttp2_session_on_ping_received(session, &frame));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  /* Since this ping frame has ACK flag set, no further action is\n     performed. */\n  CU_ASSERT(NULL == nghttp2_outbound_queue_top(&session->ob_urgent));\n\n  /* Clear the flag, and receive it again */\n  frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n  CU_ASSERT(0 == nghttp2_session_on_ping_received(session, &frame));\n  CU_ASSERT(2 == user_data.frame_recv_cb_called);\n  top = nghttp2_outbound_queue_top(&session->ob_urgent);\n  CU_ASSERT(NGHTTP2_PING == top->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_ACK == top->frame.hd.flags);\n  CU_ASSERT(memcmp(opaque_data, top->frame.ping.opaque_data, 8) == 0);\n\n  nghttp2_frame_ping_free(&frame.ping);\n  nghttp2_session_del(session);\n\n  /* Use nghttp2_option_set_no_auto_ping_ack() */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_ping_ack(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, &user_data, option);\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_NONE, NULL);\n\n  user_data.frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_ping_received(session, &frame));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(NULL == nghttp2_outbound_queue_top(&session->ob_urgent));\n\n  nghttp2_frame_ping_free(&frame.ping);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_on_goaway_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  int i;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  user_data.frame_recv_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  for (i = 1; i <= 7; ++i) {\n    if (nghttp2_session_is_my_stream_id(session, i)) {\n      open_sent_stream(session, i);\n    } else {\n      open_recv_stream(session, i);\n    }\n  }\n\n  nghttp2_frame_goaway_init(&frame.goaway, 3, NGHTTP2_PROTOCOL_ERROR, NULL, 0);\n\n  user_data.stream_close_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_goaway_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(3 == session->remote_last_stream_id);\n  /* on_stream_close should be callsed for 2 times (stream 5 and 7) */\n  CU_ASSERT(2 == user_data.stream_close_cb_called);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 1));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 2));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 3));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 4));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 5));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 6));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 7));\n\n  nghttp2_frame_goaway_free(&frame.goaway, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_window_update_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *data_item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n  user_data.frame_recv_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  data_item = create_data_ob_item(mem);\n\n  CU_ASSERT(0 == nghttp2_stream_attach_item(stream, data_item));\n\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   16 * 1024);\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 16 * 1024 ==\n            stream->remote_window_size);\n\n  CU_ASSERT(0 == nghttp2_stream_defer_item(\n                     stream, NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL));\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(2 == user_data.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 16 * 1024 * 2 ==\n            stream->remote_window_size);\n  CU_ASSERT(0 == (stream->flags & NGHTTP2_STREAM_FLAG_DEFERRED_ALL));\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  /* Receiving WINDOW_UPDATE on reserved (remote) stream is a\n     connection error */\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 2,\n                                   4096);\n\n  CU_ASSERT(!(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  nghttp2_session_del(session);\n\n  /* Receiving WINDOW_UPDATE on reserved (local) stream is allowed */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 2,\n                                   4096);\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(!(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 4096 == stream->remote_window_size);\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_data_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_outbound_item *top;\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_recv_stream(session, 2);\n\n  nghttp2_frame_hd_init(&frame.hd, 4096, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 2);\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  CU_ASSERT(0 == stream->shut_flags);\n\n  frame.hd.flags = NGHTTP2_FLAG_END_STREAM;\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  CU_ASSERT(NGHTTP2_SHUT_RD == stream->shut_flags);\n\n  /* If NGHTTP2_STREAM_CLOSING state, DATA frame is discarded. */\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_CLOSING);\n\n  frame.hd.flags = NGHTTP2_FLAG_NONE;\n  frame.hd.stream_id = 1;\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  CU_ASSERT(NULL == nghttp2_outbound_queue_top(&session->ob_reg));\n\n  /* Check INVALID_STREAM case: DATA frame with stream ID which does\n     not exist. */\n\n  frame.hd.stream_id = 3;\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  top = nghttp2_outbound_queue_top(&session->ob_reg);\n  /* DATA against nonexistent stream is just ignored for now. */\n  CU_ASSERT(top == NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_data_received_fail_fast(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t buf[9];\n  nghttp2_stream *stream;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 1);\n  nghttp2_frame_pack_frame_hd(buf, &hd);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* DATA to closed (remote) */\n  stream = open_recv_stream(session, 1);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n\n  CU_ASSERT((ssize_t)sizeof(buf) ==\n            nghttp2_session_mem_recv(session, buf, sizeof(buf)));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* DATA to closed stream with explicit closed (remote) */\n  stream = open_recv_stream(session, 1);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT((ssize_t)sizeof(buf) ==\n            nghttp2_session_mem_recv(session, buf, sizeof(buf)));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_altsvc_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_option *option;\n  uint8_t origin[] = \"nghttp2.org\";\n  uint8_t field_value[] = \"h2=\\\":443\\\"\";\n  int rv;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  /* We just pass the strings without making a copy.  This is OK,\n     since we never call nghttp2_frame_altsvc_free(). */\n  nghttp2_frame_altsvc_init(&frame.ext, 0, origin, sizeof(origin) - 1,\n                            field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Receiving empty origin with stream ID == 0 */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  nghttp2_frame_altsvc_init(&frame.ext, 0, origin, 0, field_value,\n                            sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Receiving non-empty origin with stream ID != 0 */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_altsvc_init(&frame.ext, 1, origin, sizeof(origin) - 1,\n                            field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Receiving empty origin with stream ID != 0; this is OK */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_altsvc_init(&frame.ext, 1, origin, 0, field_value,\n                            sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Stream does not exist; ALTSVC will be ignored. */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  nghttp2_frame_altsvc_init(&frame.ext, 1, origin, 0, field_value,\n                            sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_send_headers_start_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS,\n                             (int32_t)session->next_stream_id,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n  session->next_stream_id += 2;\n\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_headers_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, NULL));\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_headers_frame_size_error(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  size_t vallen = NGHTTP2_HD_MAX_NV;\n  nghttp2_nv nv[28];\n  size_t nnv = ARRLEN(nv);\n  size_t i;\n  my_user_data ud;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  for (i = 0; i < nnv; ++i) {\n    nv[i].name = (uint8_t *)\"header\";\n    nv[i].namelen = strlen((const char *)nv[i].name);\n    nv[i].value = mem->malloc(vallen + 1, NULL);\n    memset(nv[i].value, '0' + (int)i, vallen);\n    nv[i].value[vallen] = '\\0';\n    nv[i].valuelen = vallen;\n    nv[i].flags = NGHTTP2_NV_FLAG_NONE;\n  }\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nvlen = nnv;\n  nghttp2_nv_array_copy(&nva, nv, nvlen, mem);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS,\n                             (int32_t)session->next_stream_id,\n                             NGHTTP2_HCAT_REQUEST, NULL, nva, nvlen);\n\n  session->next_stream_id += 2;\n\n  nghttp2_session_add_item(session, item);\n\n  ud.frame_not_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_FRAME_SIZE_ERROR == ud.not_sent_error);\n\n  for (i = 0; i < nnv; ++i) {\n    mem->free(nv[i].value, NULL);\n  }\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_headers_push_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, NULL));\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == session->num_outgoing_streams);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == session->num_outgoing_streams);\n  stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(0 == (stream->flags & NGHTTP2_STREAM_FLAG_PUSH));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_rst_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  open_sent_stream(session, 1);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_rst_stream_init(&frame->rst_stream, 1, NGHTTP2_PROTOCOL_ERROR);\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_push_promise(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_settings_entry iv;\n  my_user_data ud;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  open_recv_stream(session, 1);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_push_promise_init(&frame->push_promise,\n                                  NGHTTP2_FLAG_END_HEADERS, 1,\n                                  (int32_t)session->next_stream_id, NULL, 0);\n\n  session->next_stream_id += 2;\n\n  nghttp2_session_add_item(session, item);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == stream->state);\n\n  /* Received ENABLE_PUSH = 0 */\n  iv.settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;\n  iv.value = 0;\n  frame = mem->malloc(sizeof(nghttp2_frame), NULL);\n  nghttp2_frame_settings_init(&frame->settings, NGHTTP2_FLAG_NONE,\n                              dup_iv(&iv, 1), 1);\n  nghttp2_session_on_settings_received(session, frame, 1);\n  nghttp2_frame_settings_free(&frame->settings, mem);\n  mem->free(frame, NULL);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_push_promise_init(&frame->push_promise,\n                                  NGHTTP2_FLAG_END_HEADERS, 1, -1, NULL, 0);\n  nghttp2_session_add_item(session, item);\n\n  ud.frame_not_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_PUSH_PROMISE == ud.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_PUSH_DISABLED == ud.not_sent_error);\n\n  nghttp2_session_del(session);\n\n  /* PUSH_PROMISE from client is error */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  open_sent_stream(session, 1);\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_push_promise_init(&frame->push_promise,\n                                  NGHTTP2_FLAG_END_HEADERS, 1, -1, NULL, 0);\n  nghttp2_session_add_item(session, item);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 3));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_is_my_stream_id(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 0));\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 1));\n  CU_ASSERT(1 == nghttp2_session_is_my_stream_id(session, 2));\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 0));\n  CU_ASSERT(1 == nghttp2_session_is_my_stream_id(session, 1));\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 2));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_upgrade2(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t settings_payload[128];\n  size_t settings_payloadlen;\n  nghttp2_settings_entry iv[16];\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *item;\n  ssize_t rv;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 1;\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 4095;\n  settings_payloadlen = (size_t)nghttp2_pack_settings_payload(\n      settings_payload, sizeof(settings_payload), iv, 2);\n\n  /* Check client side */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, &callbacks));\n  CU_ASSERT(1 == session->last_sent_stream_id);\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(stream != NULL);\n  CU_ASSERT(&callbacks == stream->stream_user_data);\n  CU_ASSERT(NGHTTP2_SHUT_WR == stream->shut_flags);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);\n  CU_ASSERT(2 == item->frame.settings.niv);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            item->frame.settings.iv[0].settings_id);\n  CU_ASSERT(1 == item->frame.settings.iv[0].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE ==\n            item->frame.settings.iv[1].settings_id);\n  CU_ASSERT(4095 == item->frame.settings.iv[1].value);\n\n  /* Call nghttp2_session_upgrade2() again is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_session_upgrade2(session, settings_payload,\n                                     settings_payloadlen, 0, &callbacks));\n  nghttp2_session_del(session);\n\n  /* Make sure that response from server can be received */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, &callbacks));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, resnv,\n                    ARRLEN(resnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  buf = &bufs.head->buf;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT(rv == (ssize_t)nghttp2_buf_len(buf));\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Check server side */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, &callbacks));\n  CU_ASSERT(1 == session->last_recv_stream_id);\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(stream != NULL);\n  CU_ASSERT(NULL == stream->stream_user_data);\n  CU_ASSERT(NGHTTP2_SHUT_RD == stream->shut_flags);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(1 == session->remote_settings.max_concurrent_streams);\n  CU_ASSERT(4095 == session->remote_settings.initial_window_size);\n  /* Call nghttp2_session_upgrade2() again is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_session_upgrade2(session, settings_payload,\n                                     settings_payloadlen, 0, &callbacks));\n  nghttp2_session_del(session);\n\n  /* Empty SETTINGS is OK */\n  settings_payloadlen = (size_t)nghttp2_pack_settings_payload(\n      settings_payload, sizeof(settings_payload), NULL, 0);\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, NULL));\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_reprioritize_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_stream *dep_stream;\n  nghttp2_priority_spec pri_spec;\n  int rv;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream = open_recv_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 10, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(10 == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n\n  /* If depenency to idle stream which is not in depdenency tree yet */\n\n  nghttp2_priority_spec_init(&pri_spec, 3, 99, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(99 == stream->weight);\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  dep_stream = nghttp2_session_get_stream_raw(session, 3);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == dep_stream->weight);\n\n  dep_stream = open_recv_stream(session, 3);\n\n  /* Change weight */\n  pri_spec.weight = 128;\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(128 == stream->weight);\n  CU_ASSERT(dep_stream == stream->dep_prev);\n\n  /* Change weight again to test short-path case */\n  pri_spec.weight = 100;\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(100 == stream->weight);\n  CU_ASSERT(dep_stream == stream->dep_prev);\n  CU_ASSERT(100 == dep_stream->sum_dep_weight);\n\n  /* Test circular dependency; stream 1 is first removed and becomes\n     root.  Then stream 3 depends on it. */\n  nghttp2_priority_spec_init(&pri_spec, 1, 1, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, dep_stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == dep_stream->weight);\n  CU_ASSERT(stream == dep_stream->dep_prev);\n\n  /* Making priority to closed stream will result in default\n     priority */\n  session->last_recv_stream_id = 9;\n\n  nghttp2_priority_spec_init(&pri_spec, 5, 5, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* circular dependency; in case of stream which is not a direct\n     descendant of root.  Use exclusive dependency. */\n  stream = open_recv_stream(session, 1);\n  stream = open_recv_stream_with_dep(session, 3, stream);\n  stream = open_recv_stream_with_dep(session, 5, stream);\n  stream = open_recv_stream_with_dep(session, 7, stream);\n  open_recv_stream_with_dep(session, 9, stream);\n\n  nghttp2_priority_spec_init(&pri_spec, 7, 1, 1);\n\n  stream = nghttp2_session_get_stream(session, 3);\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(7 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 7);\n\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 9);\n\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 5);\n\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* circular dependency; in case of stream which is not a direct\n     descendant of root.  Without exclusive dependency. */\n  stream = open_recv_stream(session, 1);\n  stream = open_recv_stream_with_dep(session, 3, stream);\n  stream = open_recv_stream_with_dep(session, 5, stream);\n  stream = open_recv_stream_with_dep(session, 7, stream);\n  open_recv_stream_with_dep(session, 9, stream);\n\n  nghttp2_priority_spec_init(&pri_spec, 7, 1, 0);\n\n  stream = nghttp2_session_get_stream(session, 3);\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(7 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 7);\n\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 9);\n\n  CU_ASSERT(7 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 5);\n\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_reprioritize_stream_with_idle_stream_dep(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream = open_recv_stream(session, 1);\n\n  session->pending_local_max_concurrent_stream = 1;\n\n  nghttp2_priority_spec_init(&pri_spec, 101, 10, 0);\n\n  nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  /* idle stream is not counteed to max concurrent streams */\n\n  CU_ASSERT(10 == stream->weight);\n  CU_ASSERT(101 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 101);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_frame *frame;\n  nghttp2_frame_hd hd;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_buf *buf;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  frame = &aob->item->frame;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_data_read_length_too_large(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_frame *frame;\n  nghttp2_frame_hd hd;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_buf *buf;\n  size_t payloadlen;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.read_length_callback = too_large_data_source_length_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  frame = &aob->item->frame;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  CU_ASSERT(16384 == hd.length)\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n\n  /* Check that buffers are expanded */\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  ud.data_source_length = NGHTTP2_MAX_FRAME_SIZE_MAX;\n\n  session->remote_settings.max_frame_size = NGHTTP2_MAX_FRAME_SIZE_MAX;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  aob = &session->aob;\n\n  frame = &aob->item->frame;\n\n  framebufs = &aob->framebufs;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  payloadlen = nghttp2_min(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE,\n                           NGHTTP2_INITIAL_WINDOW_SIZE);\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 1 + payloadlen ==\n            (size_t)nghttp2_buf_cap(buf));\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  CU_ASSERT(payloadlen == hd.length);\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_data_read_length_smallest(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_frame *frame;\n  nghttp2_frame_hd hd;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_buf *buf;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.read_length_callback = smallest_length_data_source_length_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  frame = &aob->item->frame;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  CU_ASSERT(1 == hd.length)\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n}\n\nstatic ssize_t submit_data_twice_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)source;\n  (void)user_data;\n\n  *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n  return (ssize_t)nghttp2_min(len, 16);\n}\n\nstatic int submit_data_twice_on_frame_send_callback(nghttp2_session *session,\n                                                    const nghttp2_frame *frame,\n                                                    void *user_data) {\n  static int called = 0;\n  int rv;\n  nghttp2_data_provider data_prd;\n  (void)user_data;\n\n  if (called == 0) {\n    called = 1;\n\n    data_prd.read_callback = submit_data_twice_data_source_read_callback;\n\n    rv = nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM,\n                             frame->hd.stream_id, &data_prd);\n    CU_ASSERT(0 == rv);\n  }\n\n  return 0;\n}\n\nvoid test_nghttp2_submit_data_twice(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  accumulator acc;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.on_frame_send_callback = submit_data_twice_on_frame_send_callback;\n\n  data_prd.read_callback = submit_data_twice_data_source_read_callback;\n\n  acc.length = 0;\n  ud.acc = &acc;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, 1, &data_prd));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* We should have sent 2 DATA frame with 16 bytes payload each */\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN * 2 + 16 * 2 == acc.length);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_request_with_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = 64 * 1024 - 1;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                        &data_prd, NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.data_source_length);\n\n  nghttp2_session_del(session);\n\n  /* nghttp2_submit_request() with server session is error */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(NGHTTP2_ERR_PROTO == nghttp2_submit_request(session, NULL, reqnv,\n                                                        ARRLEN(reqnv), NULL,\n                                                        NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_request_without_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  nghttp2_data_provider data_prd = {{-1}, NULL};\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  nghttp2_priority_spec pri_spec;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                        &data_prd, NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(item->frame.hd.flags & NGHTTP2_FLAG_END_STREAM);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(reqnv) == out.nvlen);\n  assert_nv_equal(reqnv, out.nva, out.nvlen, mem);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nva_out_reset(&out, mem);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_inflate_free(&inflater);\n\n  /* Try to depend on itself is error */\n  nghttp2_priority_spec_init(&pri_spec, (int32_t)session->next_stream_id, 16,\n                             0);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_request(session, &pri_spec, reqnv, ARRLEN(reqnv),\n                                   NULL, NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_response_with_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = 64 * 1024 - 1;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv),\n                                         &data_prd));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(resnv) == item->frame.headers.nvlen);\n  assert_nv_equal(resnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.data_source_length);\n\n  nghttp2_session_del(session);\n\n  /* Various error cases */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  /* Calling nghttp2_submit_response() with client session is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv), NULL));\n\n  /* Stream ID <= 0 is error */\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_response(session, 0, resnv, ARRLEN(resnv), NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_response_without_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  nghttp2_data_provider data_prd = {{-1}, NULL};\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv),\n                                         &data_prd));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(resnv) == item->frame.headers.nvlen);\n  assert_nv_equal(resnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(item->frame.hd.flags & NGHTTP2_FLAG_END_STREAM);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(resnv) == out.nvlen);\n  assert_nv_equal(resnv, out.nva, out.nvlen, mem);\n\n  nva_out_reset(&out, mem);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_hd_inflate_free(&inflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_response_push_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_RECV;\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_response(session, 2, resnv, ARRLEN(resnv), NULL));\n\n  ud.frame_not_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_trailer(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  nghttp2_data_provider data_prd;\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  data_prd.read_callback = no_end_stream_data_source_read_callback;\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv),\n                                         &data_prd));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_trailer(session, 1, trailernv, ARRLEN(trailernv)));\n\n  session->callbacks.send_callback = accumulator_send_callback;\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_HCAT_HEADERS == item->frame.headers.cat);\n  CU_ASSERT(item->frame.hd.flags & NGHTTP2_FLAG_END_STREAM);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(trailernv) == out.nvlen);\n  assert_nv_equal(trailernv, out.nva, out.nvlen, mem);\n\n  nva_out_reset(&out, mem);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_hd_inflate_free(&inflater);\n  nghttp2_session_del(session);\n\n  /* Specifying stream ID <= 0 is error */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  open_recv_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_trailer(session, 0, trailernv, ARRLEN(trailernv)));\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_trailer(session, -1, trailernv, ARRLEN(trailernv)));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_start_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n  CU_ASSERT(1 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                        NULL, reqnv, ARRLEN(reqnv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT((NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM) ==\n            item->frame.hd.flags);\n  CU_ASSERT(0 == (item->frame.hd.flags & NGHTTP2_FLAG_PRIORITY));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, resnv, ARRLEN(resnv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(resnv) == item->frame.headers.nvlen);\n  assert_nv_equal(resnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  /* The transimission will be canceled because the stream 1 is not\n     open. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  stream = open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, resnv, ARRLEN(resnv), NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  CU_ASSERT(stream->shut_flags & NGHTTP2_SHUT_WR);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_push_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_stream *stream;\n  int foo;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  stream = open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 2, NULL,\n                                        resnv, ARRLEN(resnv), &foo));\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(&foo == stream->stream_user_data);\n\n  nghttp2_session_del(session);\n\n  /* Sending HEADERS from client against stream in reserved state is\n     error */\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 2, NULL,\n                                        reqnv, ARRLEN(reqnv), NULL));\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n  accumulator acc;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  nghttp2_priority_spec pri_spec;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, reqnv, ARRLEN(reqnv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  /* The transimission will be canceled because the stream 1 is not\n     open. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  stream = open_sent_stream(session, 1);\n\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, reqnv, ARRLEN(reqnv), NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  CU_ASSERT(stream->shut_flags & NGHTTP2_SHUT_WR);\n\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(reqnv) == out.nvlen);\n  assert_nv_equal(reqnv, out.nva, out.nvlen, mem);\n\n  nva_out_reset(&out, mem);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_hd_inflate_free(&inflater);\n\n  /* Try to depend on itself */\n  nghttp2_priority_spec_init(&pri_spec, 3, 16, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 3, &pri_spec,\n                                   reqnv, ARRLEN(reqnv), NULL));\n\n  session->next_stream_id = 5;\n  nghttp2_priority_spec_init(&pri_spec, 5, 16, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, -1, &pri_spec,\n                                   reqnv, ARRLEN(reqnv), NULL));\n\n  nghttp2_session_del(session);\n\n  /* Error cases with invalid stream ID */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Sending nghttp2_submit_headers() with stream_id == 1 and server\n     session is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, -1, NULL, reqnv,\n                                   ARRLEN(reqnv), NULL));\n\n  /* Sending stream ID <= 0 is error */\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 0, NULL, resnv,\n                                   ARRLEN(resnv), NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_continuation(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv nv[] = {\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n      MAKE_NV(\"h1\", \"\"),\n  };\n  nghttp2_outbound_item *item;\n  uint8_t data[4096];\n  size_t i;\n  my_user_data ud;\n\n  memset(data, '0', sizeof(data));\n  for (i = 0; i < ARRLEN(nv); ++i) {\n    nv[i].valuelen = sizeof(data);\n    nv[i].value = data;\n  }\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  CU_ASSERT(1 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                        NULL, nv, ARRLEN(nv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n  CU_ASSERT(0 == (item->frame.hd.flags & NGHTTP2_FLAG_PRIORITY));\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_continuation_extra_large(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv nv[] = {\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n  };\n  nghttp2_outbound_item *item;\n  uint8_t data[16384];\n  size_t i;\n  my_user_data ud;\n  nghttp2_option *opt;\n\n  memset(data, '0', sizeof(data));\n  for (i = 0; i < ARRLEN(nv); ++i) {\n    nv[i].valuelen = sizeof(data);\n    nv[i].value = data;\n  }\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  /* The default size of max send header block length is too small to\n     send these header fields.  Expand it. */\n  nghttp2_option_new(&opt);\n  nghttp2_option_set_max_send_header_block_length(opt, 102400);\n\n  CU_ASSERT(0 == nghttp2_session_client_new2(&session, &callbacks, &ud, opt));\n  CU_ASSERT(1 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                        NULL, nv, ARRLEN(nv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n  CU_ASSERT(0 == (item->frame.hd.flags & NGHTTP2_FLAG_PRIORITY));\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(opt);\n}\n\nvoid test_nghttp2_submit_priority(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  my_user_data ud;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  stream = open_sent_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 3, 0);\n\n  /* depends on stream 0 */\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(3 == stream->weight);\n\n  /* submit against idle stream */\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 3, &pri_spec));\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_settings(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_settings_entry iv[7];\n  nghttp2_frame ack_frame;\n  const int32_t UNKNOWN_ID = 1000000007;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 5;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16 * 1024;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[2].value = 50;\n\n  iv[3].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[3].value = 111;\n\n  iv[4].settings_id = UNKNOWN_ID;\n  iv[4].value = 999;\n\n  iv[5].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[5].value = 1023;\n\n  iv[6].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[6].value = (uint32_t)NGHTTP2_MAX_WINDOW_SIZE + 1;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 7));\n\n  /* Make sure that local settings are not changed */\n  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==\n            session->local_settings.max_concurrent_streams);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            session->local_settings.initial_window_size);\n\n  /* Now sends without 6th one */\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 6));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);\n\n  frame = &item->frame;\n  CU_ASSERT(6 == frame->settings.niv);\n  CU_ASSERT(5 == frame->settings.iv[0].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            frame->settings.iv[0].settings_id);\n\n  CU_ASSERT(16 * 1024 == frame->settings.iv[1].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE ==\n            frame->settings.iv[1].settings_id);\n\n  CU_ASSERT(UNKNOWN_ID == frame->settings.iv[4].settings_id);\n  CU_ASSERT(999 == frame->settings.iv[4].value);\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  CU_ASSERT(50 == session->pending_local_max_concurrent_stream);\n\n  /* before receiving SETTINGS ACK, local settings have still default\n     values */\n  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==\n            nghttp2_session_get_local_settings(\n                session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_local_settings(\n                session, NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE));\n\n  nghttp2_frame_settings_init(&ack_frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n  nghttp2_frame_settings_free(&ack_frame.settings, mem);\n\n  CU_ASSERT(16 * 1024 == session->local_settings.initial_window_size);\n  CU_ASSERT(1023 == session->hd_inflater.ctx.hd_table_bufsize_max);\n  CU_ASSERT(111 == session->hd_inflater.min_hd_table_bufsize_max);\n  CU_ASSERT(50 == session->local_settings.max_concurrent_streams);\n\n  CU_ASSERT(50 == nghttp2_session_get_local_settings(\n                      session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS));\n  CU_ASSERT(16 * 1024 == nghttp2_session_get_local_settings(\n                             session, NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE));\n\n  /* We just keep the last seen value */\n  CU_ASSERT(50 == session->pending_local_max_concurrent_stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_settings_update_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_settings_entry iv[4];\n  nghttp2_stream *stream;\n  nghttp2_frame ack_frame;\n  nghttp2_mem *mem;\n  nghttp2_option *option;\n\n  mem = nghttp2_mem_default();\n  nghttp2_frame_settings_init(&ack_frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[0].value = 16 * 1024;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream = open_recv_stream(session, 1);\n  stream->local_window_size = NGHTTP2_INITIAL_WINDOW_SIZE + 100;\n  stream->recv_window_size = 32768;\n\n  open_recv_stream(session, 3);\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(16 * 1024 + 100 == stream->local_window_size);\n\n  stream = nghttp2_session_get_stream(session, 3);\n  CU_ASSERT(16 * 1024 == stream->local_window_size);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(32768 == item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n\n  /* Without auto-window update */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, NULL, option);\n\n  nghttp2_option_del(option);\n\n  stream = open_recv_stream(session, 1);\n  stream->local_window_size = NGHTTP2_INITIAL_WINDOW_SIZE + 100;\n  stream->recv_window_size = 32768;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(32768 == stream->recv_window_size);\n  CU_ASSERT(16 * 1024 + 100 == stream->local_window_size);\n  /* Check that we can handle the case where local_window_size <\n     recv_window_size */\n  CU_ASSERT(0 == nghttp2_session_get_stream_local_window_size(session, 1));\n\n  nghttp2_session_del(session);\n\n  /* Check overflow case */\n  iv[0].value = 128 * 1024;\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  stream = open_recv_stream(session, 1);\n  stream->local_window_size = NGHTTP2_MAX_WINDOW_SIZE;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FLOW_CONTROL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_frame_settings_free(&ack_frame.settings, mem);\n}\n\nvoid test_nghttp2_submit_settings_multiple_times(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_settings_entry iv[4];\n  nghttp2_frame frame;\n  nghttp2_inflight_settings *inflight_settings;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  /* first SETTINGS */\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 100;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;\n  iv[1].value = 0;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 2));\n\n  inflight_settings = session->inflight_settings_head;\n\n  CU_ASSERT(NULL != inflight_settings);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            inflight_settings->iv[0].settings_id);\n  CU_ASSERT(100 == inflight_settings->iv[0].value);\n  CU_ASSERT(2 == inflight_settings->niv);\n  CU_ASSERT(NULL == inflight_settings->next);\n\n  CU_ASSERT(100 == session->pending_local_max_concurrent_stream);\n  CU_ASSERT(0 == session->pending_enable_push);\n\n  /* second SETTINGS */\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 99;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n\n  inflight_settings = session->inflight_settings_head->next;\n\n  CU_ASSERT(NULL != inflight_settings);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            inflight_settings->iv[0].settings_id);\n  CU_ASSERT(99 == inflight_settings->iv[0].value);\n  CU_ASSERT(1 == inflight_settings->niv);\n  CU_ASSERT(NULL == inflight_settings->next);\n\n  CU_ASSERT(99 == session->pending_local_max_concurrent_stream);\n  CU_ASSERT(0 == session->pending_enable_push);\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n\n  /* receive SETTINGS ACK */\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  inflight_settings = session->inflight_settings_head;\n\n  /* first inflight SETTINGS was removed */\n  CU_ASSERT(NULL != inflight_settings);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            inflight_settings->iv[0].settings_id);\n  CU_ASSERT(99 == inflight_settings->iv[0].value);\n  CU_ASSERT(1 == inflight_settings->niv);\n  CU_ASSERT(NULL == inflight_settings->next);\n\n  CU_ASSERT(100 == session->local_settings.max_concurrent_streams);\n\n  /* receive SETTINGS ACK again */\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  CU_ASSERT(NULL == session->inflight_settings_head);\n  CU_ASSERT(99 == session->local_settings.max_concurrent_streams);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_push_promise(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  open_recv_stream(session, 1);\n  CU_ASSERT(2 == nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 1,\n                                             reqnv, ARRLEN(reqnv), &ud));\n\n  stream = nghttp2_session_get_stream(session, 2);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == stream->state);\n  CU_ASSERT(&ud == nghttp2_session_get_stream_user_data(session, 2));\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_PUSH_PROMISE == ud.sent_frame_type);\n\n  stream = nghttp2_session_get_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == stream->state);\n  CU_ASSERT(&ud == nghttp2_session_get_stream_user_data(session, 2));\n\n  /* submit PUSH_PROMISE while associated stream is not opened */\n  CU_ASSERT(NGHTTP2_ERR_STREAM_CLOSED ==\n            nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 3, reqnv,\n                                        ARRLEN(reqnv), NULL));\n\n  /* Stream ID <= 0 is error */\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 0, reqnv,\n                                        ARRLEN(reqnv), NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_window_update(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  stream = open_recv_stream(session, 2);\n  stream->recv_window_size = 4096;\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 1024));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1024 == item->frame.window_update.window_size_increment);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(3072 == stream->recv_window_size);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 4096));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4096 == item->frame.window_update.window_size_increment);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == stream->recv_window_size);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 4096));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4096 == item->frame.window_update.window_size_increment);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == stream->recv_window_size);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 0));\n  /* It is ok if stream is closed or does not exist at the call\n     time */\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 4, 4096));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_window_update_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = open_recv_stream(session, 2);\n  stream->recv_window_size = 4096;\n\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2,\n                                              stream->recv_window_size + 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1 == stream->local_window_size);\n  CU_ASSERT(0 == stream->recv_window_size);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4097 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Let's decrement local window size */\n  stream->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2,\n                                              -stream->local_window_size / 2));\n  CU_ASSERT(32768 == stream->local_window_size);\n  CU_ASSERT(-28672 == stream->recv_window_size);\n  CU_ASSERT(32768 == stream->recv_reduction);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 16384));\n  CU_ASSERT(49152 == stream->local_window_size);\n  CU_ASSERT(-12288 == stream->recv_window_size);\n  CU_ASSERT(16384 == stream->recv_reduction);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  CU_ASSERT(NGHTTP2_ERR_FLOW_CONTROL ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2,\n                                         NGHTTP2_MAX_WINDOW_SIZE));\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Check connection-level flow control */\n  session->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                              session->recv_window_size + 1));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1 ==\n            session->local_window_size);\n  CU_ASSERT(0 == session->recv_window_size);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4097 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Go decrement part */\n  session->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                              -session->local_window_size / 2));\n  CU_ASSERT(32768 == session->local_window_size);\n  CU_ASSERT(-28672 == session->recv_window_size);\n  CU_ASSERT(32768 == session->recv_reduction);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, 16384));\n  CU_ASSERT(49152 == session->local_window_size);\n  CU_ASSERT(-12288 == session->recv_window_size);\n  CU_ASSERT(16384 == session->recv_reduction);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  CU_ASSERT(NGHTTP2_ERR_FLOW_CONTROL ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                         NGHTTP2_MAX_WINDOW_SIZE));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_shutdown_notice(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  CU_ASSERT(0 == nghttp2_submit_shutdown_notice(session));\n\n  ud.frame_send_cb_called = 0;\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_GOAWAY == ud.sent_frame_type);\n  CU_ASSERT((1u << 31) - 1 == session->local_last_stream_id);\n\n  /* After another GOAWAY, nghttp2_submit_shutdown_notice() is\n     noop. */\n  CU_ASSERT(0 == nghttp2_session_terminate_session(session, NGHTTP2_NO_ERROR));\n\n  ud.frame_send_cb_called = 0;\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_GOAWAY == ud.sent_frame_type);\n  CU_ASSERT(0 == session->local_last_stream_id);\n\n  CU_ASSERT(0 == nghttp2_submit_shutdown_notice(session));\n\n  ud.frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(0 == ud.frame_not_send_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Using nghttp2_submit_shutdown_notice() with client side session\n     is error */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_STATE ==\n            nghttp2_submit_shutdown_notice(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_invalid_nv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv empty_name_nv[] = {MAKE_NV(\"Version\", \"HTTP/1.1\"),\n                                MAKE_NV(\"\", \"empty name\")};\n\n  /* Now invalid header name/value pair in HTTP/1.1 is accepted in\n     nghttp2 */\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, NULL));\n\n  /* nghttp2_submit_response */\n  CU_ASSERT(0 == nghttp2_submit_response(session, 2, empty_name_nv,\n                                         ARRLEN(empty_name_nv), NULL));\n\n  /* nghttp2_submit_push_promise */\n  open_recv_stream(session, 1);\n\n  CU_ASSERT(0 < nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 1,\n                                            empty_name_nv,\n                                            ARRLEN(empty_name_nv), NULL));\n\n  nghttp2_session_del(session);\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n\n  /* nghttp2_submit_request */\n  CU_ASSERT(0 < nghttp2_submit_request(session, NULL, empty_name_nv,\n                                       ARRLEN(empty_name_nv), NULL, NULL));\n\n  /* nghttp2_submit_headers */\n  CU_ASSERT(0 < nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, -1, NULL,\n                                       empty_name_nv, ARRLEN(empty_name_nv),\n                                       NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_extension(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  accumulator acc;\n  nghttp2_mem *mem;\n  const char data[] = \"Hello World!\";\n  size_t len;\n  int32_t stream_id;\n  int rv;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.pack_extension_callback = pack_extension_callback;\n  callbacks.send_callback = accumulator_send_callback;\n\n  nghttp2_buf_init2(&ud.scratchbuf, 4096, mem);\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  ud.scratchbuf.last = nghttp2_cpymem(ud.scratchbuf.last, data, sizeof(data));\n  ud.acc = &acc;\n\n  rv = nghttp2_submit_extension(session, 211, 0x01, 3, &ud.scratchbuf);\n\n  CU_ASSERT(0 == rv);\n\n  acc.length = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + sizeof(data) == acc.length);\n\n  len = nghttp2_get_uint32(acc.buf) >> 8;\n\n  CU_ASSERT(sizeof(data) == len);\n  CU_ASSERT(211 == acc.buf[3]);\n  CU_ASSERT(0x01 == acc.buf[4]);\n\n  stream_id = (int32_t)nghttp2_get_uint32(acc.buf + 5);\n\n  CU_ASSERT(3 == stream_id);\n  CU_ASSERT(0 == memcmp(data, &acc.buf[NGHTTP2_FRAME_HDLEN], sizeof(data)));\n\n  nghttp2_session_del(session);\n\n  /* submitting standard HTTP/2 frame is error */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_extension(session, NGHTTP2_GOAWAY, NGHTTP2_FLAG_NONE, 0,\n                                NULL);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  nghttp2_session_del(session);\n  nghttp2_buf_free(&ud.scratchbuf, mem);\n}\n\nvoid test_nghttp2_submit_altsvc(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  int rv;\n  ssize_t len;\n  const uint8_t *data;\n  nghttp2_frame_hd hd;\n  size_t origin_len;\n  const uint8_t origin[] = \"nghttp2.org\";\n  const uint8_t field_value[] = \"h2=\\\":443\\\"\";\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 0, origin,\n                             sizeof(origin) - 1, field_value,\n                             sizeof(field_value) - 1);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n\n  len = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(len == NGHTTP2_FRAME_HDLEN + 2 + sizeof(origin) - 1 +\n                       sizeof(field_value) - 1);\n\n  nghttp2_frame_unpack_frame_hd(&hd, data);\n\n  CU_ASSERT(2 + sizeof(origin) - 1 + sizeof(field_value) - 1 == hd.length);\n  CU_ASSERT(NGHTTP2_ALTSVC == hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n\n  origin_len = nghttp2_get_uint16(data + NGHTTP2_FRAME_HDLEN);\n\n  CU_ASSERT(sizeof(origin) - 1 == origin_len);\n  CU_ASSERT(0 ==\n            memcmp(origin, data + NGHTTP2_FRAME_HDLEN + 2, sizeof(origin) - 1));\n  CU_ASSERT(0 == memcmp(field_value,\n                        data + NGHTTP2_FRAME_HDLEN + 2 + sizeof(origin) - 1,\n                        hd.length - (sizeof(origin) - 1) - 2));\n\n  /* submitting empty origin with stream_id == 0 is error */\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 0, NULL, 0,\n                             field_value, sizeof(field_value) - 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* submitting non-empty origin with stream_id != 0 is error */\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 1, origin,\n                             sizeof(origin) - 1, field_value,\n                             sizeof(field_value) - 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  nghttp2_session_del(session);\n\n  /* submitting from client side session is error */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 0, origin,\n                             sizeof(origin) - 1, field_value,\n                             sizeof(field_value) - 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_STATE == rv);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_origin(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  int rv;\n  ssize_t len;\n  const uint8_t *data;\n  static const uint8_t nghttp2[] = \"https://nghttp2.org\";\n  static const uint8_t examples[] = \"https://examples.com\";\n  static const nghttp2_origin_entry ov[] = {\n      {\n          (uint8_t *)nghttp2,\n          sizeof(nghttp2) - 1,\n      },\n      {\n          (uint8_t *)examples,\n          sizeof(examples) - 1,\n      },\n  };\n  nghttp2_frame frame;\n  nghttp2_ext_origin origin;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  frame.ext.payload = &origin;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_origin(session, NGHTTP2_FLAG_NONE, ov, 2);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n  len = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(len > 0);\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_frame_unpack_frame_hd(&frame.hd, data);\n  rv = nghttp2_frame_unpack_origin_payload(\n      &frame.ext, data + NGHTTP2_FRAME_HDLEN, (size_t)len - NGHTTP2_FRAME_HDLEN,\n      mem);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_ORIGIN == frame.hd.type);\n  CU_ASSERT(2 == origin.nov);\n  CU_ASSERT(0 == memcmp(nghttp2, origin.ov[0].origin, sizeof(nghttp2) - 1));\n  CU_ASSERT(sizeof(nghttp2) - 1 == origin.ov[0].origin_len);\n  CU_ASSERT(0 == memcmp(examples, origin.ov[1].origin, sizeof(examples) - 1));\n  CU_ASSERT(sizeof(examples) - 1 == origin.ov[1].origin_len);\n\n  nghttp2_frame_origin_free(&frame.ext, mem);\n\n  nghttp2_session_del(session);\n\n  /* Submitting ORIGIN frame from client session is error */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  rv = nghttp2_submit_origin(session, NGHTTP2_FLAG_NONE, ov, 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_STATE == rv);\n\n  nghttp2_session_del(session);\n\n  /* Submitting empty ORIGIN frame */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_origin(session, NGHTTP2_FLAG_NONE, NULL, 0);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n  len = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(len == NGHTTP2_FRAME_HDLEN);\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_frame_unpack_frame_hd(&frame.hd, data);\n\n  CU_ASSERT(NGHTTP2_ORIGIN == frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_open_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 245, 0);\n\n  stream = nghttp2_session_open_stream(session, 1, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(0 == session->num_outgoing_streams);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(245 == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_SHUT_NONE == stream->shut_flags);\n\n  stream = nghttp2_session_open_stream(session, 2, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec_default,\n                                       NGHTTP2_STREAM_OPENING, NULL);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_outgoing_streams);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(NGHTTP2_SHUT_NONE == stream->shut_flags);\n\n  stream = nghttp2_session_open_stream(session, 4, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec_default,\n                                       NGHTTP2_STREAM_RESERVED, NULL);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_outgoing_streams);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(NGHTTP2_SHUT_RD == stream->shut_flags);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 17, 1);\n\n  stream = nghttp2_session_open_stream(session, 3, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n  CU_ASSERT(17 == stream->weight);\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  /* Dependency to idle stream */\n  nghttp2_priority_spec_init(&pri_spec, 1000000007, 240, 1);\n\n  stream = nghttp2_session_open_stream(session, 5, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n  CU_ASSERT(240 == stream->weight);\n  CU_ASSERT(1000000007 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 1000000007);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n\n  /* Dependency to closed stream which is not in dependency tree */\n  session->last_recv_stream_id = 7;\n\n  nghttp2_priority_spec_init(&pri_spec, 7, 10, 0);\n\n  stream = nghttp2_session_open_stream(session, 9, NGHTTP2_FLAG_NONE, &pri_spec,\n                                       NGHTTP2_STREAM_OPENED, NULL);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = nghttp2_session_open_stream(session, 4, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec_default,\n                                       NGHTTP2_STREAM_RESERVED, NULL);\n  CU_ASSERT(0 == session->num_incoming_streams);\n  CU_ASSERT(0 == session->num_outgoing_streams);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(NGHTTP2_SHUT_WR == stream->shut_flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_open_stream_with_idle_stream_dep(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Dependency to idle stream */\n  nghttp2_priority_spec_init(&pri_spec, 101, 245, 0);\n\n  stream = nghttp2_session_open_stream(session, 1, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n\n  CU_ASSERT(245 == stream->weight);\n  CU_ASSERT(101 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 101);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_priority_spec_init(&pri_spec, 211, 1, 0);\n\n  /* stream 101 was already created as idle. */\n  stream = nghttp2_session_open_stream(session, 101, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n\n  CU_ASSERT(1 == stream->weight);\n  CU_ASSERT(211 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 211);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_get_next_ob_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 2;\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n  CU_ASSERT(NGHTTP2_PING ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, NULL, 0, NULL, NULL));\n  CU_ASSERT(NGHTTP2_PING ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Incoming stream does not affect the number of outgoing max\n     concurrent streams. */\n  open_recv_stream(session, 2);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, NGHTTP2_MAX_WEIGHT, 0);\n\n  CU_ASSERT(3 ==\n            nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL));\n  CU_ASSERT(NGHTTP2_HEADERS ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(5 ==\n            nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  session->remote_settings.max_concurrent_streams = 3;\n\n  CU_ASSERT(NGHTTP2_HEADERS ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  nghttp2_session_del(session);\n\n  /* Check that push reply HEADERS are queued into ob_ss_pq */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 0;\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 2,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(1 == nghttp2_outbound_queue_size(&session->ob_syn));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_pop_next_ob_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 1;\n\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 254, 0);\n\n  nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL);\n\n  item = nghttp2_session_pop_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_PING == item->frame.hd.type);\n  nghttp2_outbound_item_free(item, mem);\n  mem->free(item, NULL);\n\n  item = nghttp2_session_pop_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  nghttp2_outbound_item_free(item, mem);\n  mem->free(item, NULL);\n\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n\n  /* Incoming stream does not affect the number of outgoing max\n     concurrent streams. */\n  open_recv_stream(session, 4);\n  /* In-flight outgoing stream */\n  open_sent_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, NGHTTP2_MAX_WEIGHT, 0);\n\n  nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL);\n\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n\n  session->remote_settings.max_concurrent_streams = 2;\n\n  item = nghttp2_session_pop_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  nghttp2_outbound_item_free(item, mem);\n  mem->free(item, NULL);\n\n  nghttp2_session_del(session);\n\n  /* Check that push reply HEADERS are queued into ob_ss_pq */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 0;\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 2,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n  CU_ASSERT(1 == nghttp2_outbound_queue_size(&session->ob_syn));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_reply_fail(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = fail_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = 4 * 1024;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, NULL, 0, &data_prd));\n  CU_ASSERT(NGHTTP2_ERR_CALLBACK_FAILURE == nghttp2_session_send(session));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_max_concurrent_streams(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  open_recv_stream(session, 1);\n\n  /* Check un-ACKed SETTINGS_MAX_CONCURRENT_STREAMS */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  session->pending_local_max_concurrent_stream = 1;\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_REFUSED_STREAM == item->frame.rst_stream.error_code);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Check ACKed SETTINGS_MAX_CONCURRENT_STREAMS */\n  session->local_settings.max_concurrent_streams = 1;\n  frame.hd.stream_id = 5;\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stop_data_with_rst_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.send_callback = block_count_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 4;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  nghttp2_submit_response(session, 1, NULL, 0, &data_prd);\n\n  ud.block_count = 2;\n  /* Sends response HEADERS + DATA[0] */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_DATA == ud.sent_frame_type);\n  /* data for DATA[1] is read from data_prd but it is not sent */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  nghttp2_frame_rst_stream_init(&frame.rst_stream, 1, NGHTTP2_CANCEL);\n  CU_ASSERT(0 == nghttp2_session_on_rst_stream_received(session, &frame));\n  nghttp2_frame_rst_stream_free(&frame.rst_stream);\n\n  /* Big enough number to send all DATA frames potentially. */\n  ud.block_count = 100;\n  /* Nothing will be sent in the following call. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* With RST_STREAM, stream is canceled and further DATA on that\n     stream are not sent. */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_defer_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.send_callback = block_count_send_callback;\n  data_prd.read_callback = defer_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 4;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  stream = open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  session->remote_window_size = 1 << 20;\n  stream->remote_window_size = 1 << 20;\n\n  nghttp2_submit_response(session, 1, NULL, 0, &data_prd);\n\n  ud.block_count = 1;\n  /* Sends HEADERS reply */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  /* No data is read */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 4);\n\n  ud.block_count = 1;\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n  /* Sends PING */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_PING == ud.sent_frame_type);\n\n  /* Resume deferred DATA */\n  CU_ASSERT(0 == nghttp2_session_resume_data(session, 1));\n  item = stream->item;\n  item->aux_data.data.data_prd.read_callback =\n      fixed_length_data_source_read_callback;\n  ud.block_count = 1;\n  /* Reads 2 DATA chunks */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  /* Deferred again */\n  item->aux_data.data.data_prd.read_callback = defer_data_source_read_callback;\n  /* This is needed since 16KiB block is already read and waiting to be\n     sent. No read_callback invocation. */\n  ud.block_count = 1;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  /* Resume deferred DATA */\n  CU_ASSERT(0 == nghttp2_session_resume_data(session, 1));\n  item->aux_data.data.data_prd.read_callback =\n      fixed_length_data_source_read_callback;\n  ud.block_count = 1;\n  /* Reads 2 16KiB blocks */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(ud.data_source_length == 0);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flow_control(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  int32_t new_initial_window_size;\n  nghttp2_settings_entry iv[1];\n  nghttp2_frame settings_frame;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = fixed_bytes_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = 128 * 1024;\n  /* Use smaller emission count so that we can check outbound flow\n     control window calculation is correct. */\n  ud.fixed_sendlen = 2 * 1024;\n\n  /* Initial window size to 64KiB - 1*/\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  /* Change it to 64KiB for easy calculation */\n  session->remote_window_size = 64 * 1024;\n  session->remote_settings.initial_window_size = 64 * 1024;\n\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n\n  /* Sends 64KiB - 1 data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(64 * 1024 == ud.data_source_length);\n\n  /* Back 32KiB in stream window */\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   32 * 1024);\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Send nothing because of connection-level window */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(64 * 1024 == ud.data_source_length);\n\n  /* Back 32KiB in connection-level window */\n  frame.hd.stream_id = 0;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Sends another 32KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(32 * 1024 == ud.data_source_length);\n\n  stream = nghttp2_session_get_stream(session, 1);\n  /* Change initial window size to 16KiB. The window_size becomes\n     negative. */\n  new_initial_window_size = 16 * 1024;\n  stream->remote_window_size =\n      new_initial_window_size -\n      ((int32_t)session->remote_settings.initial_window_size -\n       stream->remote_window_size);\n  session->remote_settings.initial_window_size =\n      (uint32_t)new_initial_window_size;\n  CU_ASSERT(-48 * 1024 == stream->remote_window_size);\n\n  /* Back 48KiB to stream window */\n  frame.hd.stream_id = 1;\n  frame.window_update.window_size_increment = 48 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Nothing is sent because window_size is 0 */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(32 * 1024 == ud.data_source_length);\n\n  /* Back 16KiB in stream window */\n  frame.hd.stream_id = 1;\n  frame.window_update.window_size_increment = 16 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Back 24KiB in connection-level window */\n  frame.hd.stream_id = 0;\n  frame.window_update.window_size_increment = 24 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Sends another 16KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(16 * 1024 == ud.data_source_length);\n\n  /* Increase initial window size to 32KiB */\n  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[0].value = 32 * 1024;\n\n  nghttp2_frame_settings_init(&settings_frame.settings, NGHTTP2_FLAG_NONE,\n                              dup_iv(iv, 1), 1);\n  nghttp2_session_on_settings_received(session, &settings_frame, 1);\n  nghttp2_frame_settings_free(&settings_frame.settings, mem);\n\n  /* Sends another 8KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(8 * 1024 == ud.data_source_length);\n\n  /* Back 8KiB in connection-level window */\n  frame.hd.stream_id = 0;\n  frame.window_update.window_size_increment = 8 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Sends last 8KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.data_source_length);\n  CU_ASSERT(nghttp2_session_get_stream(session, 1)->shut_flags &\n            NGHTTP2_SHUT_WR);\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flow_control_data_recv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t data[64 * 1024 + 16];\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  /* Initial window size to 64KiB - 1*/\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  stream = open_sent_stream(session, 1);\n\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n\n  session->local_window_size = NGHTTP2_MAX_PAYLOADLEN;\n  stream->local_window_size = NGHTTP2_MAX_PAYLOADLEN;\n\n  /* Create DATA frame */\n  memset(data, 0, sizeof(data));\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_PAYLOADLEN, NGHTTP2_DATA,\n                        NGHTTP2_FLAG_END_STREAM, 1);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN ==\n            nghttp2_session_mem_recv(\n                session, data, NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN));\n\n  item = nghttp2_session_get_next_ob_item(session);\n  /* Since this is the last frame, stream-level WINDOW_UPDATE is not\n     issued, but connection-level is. */\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN ==\n            item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Receive DATA for closed stream. They are still subject to under\n     connection-level flow control, since this situation arises when\n     RST_STREAM is issued by the remote, but the local side keeps\n     sending DATA frames. Without calculating connection-level window,\n     the subsequent flow control gets confused. */\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN ==\n            nghttp2_session_mem_recv(\n                session, data, NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN));\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN ==\n            item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flow_control_data_with_padding_recv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t data[1024];\n  nghttp2_frame_hd hd;\n  nghttp2_stream *stream;\n  nghttp2_option *option;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_option_new(&option);\n  /* Disable auto window update so that we can check padding is\n     consumed automatically */\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  /* Initial window size to 64KiB - 1*/\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  nghttp2_option_del(option);\n\n  stream = open_sent_stream(session, 1);\n\n  /* Create DATA frame */\n  memset(data, 0, sizeof(data));\n  nghttp2_frame_hd_init(&hd, 357, NGHTTP2_DATA, NGHTTP2_FLAG_PADDED, 1);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  /* Set Pad Length field, which itself is padding */\n  data[NGHTTP2_FRAME_HDLEN] = 255;\n\n  CU_ASSERT(\n      (ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length) ==\n      nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + hd.length));\n\n  CU_ASSERT((int32_t)hd.length == session->recv_window_size);\n  CU_ASSERT((int32_t)hd.length == stream->recv_window_size);\n  CU_ASSERT(256 == session->consumed_size);\n  CU_ASSERT(256 == stream->consumed_size);\n  CU_ASSERT(357 == session->recv_window_size);\n  CU_ASSERT(357 == stream->recv_window_size);\n\n  /* Receive the same DATA frame, but in 2 parts: first 9 + 1 + 102\n     bytes which includes 1st padding byte, and remainder */\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + 103) ==\n            nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 103));\n  CU_ASSERT(258 == session->consumed_size);\n  CU_ASSERT(258 == stream->consumed_size);\n  CU_ASSERT(460 == session->recv_window_size);\n  CU_ASSERT(460 == stream->recv_window_size);\n\n  /* 357 - 103 = 254 bytes left */\n  CU_ASSERT(254 == nghttp2_session_mem_recv(session, data, 254));\n  CU_ASSERT(512 == session->consumed_size);\n  CU_ASSERT(512 == stream->consumed_size);\n  CU_ASSERT(714 == session->recv_window_size);\n  CU_ASSERT(714 == stream->recv_window_size);\n\n  /* Receive the same DATA frame, but in 2 parts: first 9 = 1 + 101\n     bytes which only includes data without padding, 2nd part is\n     padding only */\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + 102) ==\n            nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 102));\n  CU_ASSERT(513 == session->consumed_size);\n  CU_ASSERT(513 == stream->consumed_size);\n  CU_ASSERT(816 == session->recv_window_size);\n  CU_ASSERT(816 == stream->recv_window_size);\n\n  /* 357 - 102 = 255 bytes left */\n  CU_ASSERT(255 == nghttp2_session_mem_recv(session, data, 255));\n  CU_ASSERT(768 == session->consumed_size);\n  CU_ASSERT(768 == stream->consumed_size);\n  CU_ASSERT(1071 == session->recv_window_size);\n  CU_ASSERT(1071 == stream->recv_window_size);\n\n  /* Receive the same DATA frame, but in 2 parts: first 9 = 1 + 50\n     bytes which includes byte up to middle of data, 2nd part is the\n     remainder */\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + 51) ==\n            nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 51));\n  CU_ASSERT(769 == session->consumed_size);\n  CU_ASSERT(769 == stream->consumed_size);\n  CU_ASSERT(1122 == session->recv_window_size);\n  CU_ASSERT(1122 == stream->recv_window_size);\n\n  /* 357 - 51 = 306 bytes left */\n  CU_ASSERT(306 == nghttp2_session_mem_recv(session, data, 306));\n  CU_ASSERT(1024 == session->consumed_size);\n  CU_ASSERT(1024 == stream->consumed_size);\n  CU_ASSERT(1428 == session->recv_window_size);\n  CU_ASSERT(1428 == stream->recv_window_size);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_data_read_temporal_failure(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  size_t data_size = 128 * 1024;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.data_source_length = data_size;\n\n  /* Initial window size is 64KiB - 1 */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n\n  /* Sends NGHTTP2_INITIAL_WINDOW_SIZE data, assuming, it is equal to\n     or smaller than NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(data_size - NGHTTP2_INITIAL_WINDOW_SIZE == ud.data_source_length);\n\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(NGHTTP2_DATA == stream->item->frame.hd.type);\n\n  stream->item->aux_data.data.data_prd.read_callback =\n      temporal_failure_data_source_read_callback;\n\n  /* Back NGHTTP2_INITIAL_WINDOW_SIZE to both connection-level and\n     stream-wise window */\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   NGHTTP2_INITIAL_WINDOW_SIZE);\n  nghttp2_session_on_window_update_received(session, &frame);\n  frame.hd.stream_id = 0;\n  nghttp2_session_on_window_update_received(session, &frame);\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  /* Sending data will fail (soft fail) and treated as stream error */\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(data_size - NGHTTP2_INITIAL_WINDOW_SIZE == ud.data_source_length);\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_RST_STREAM == ud.sent_frame_type);\n\n  data_prd.read_callback = fail_data_source_read_callback;\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n  /* Sending data will fail (hard fail) and session tear down */\n  CU_ASSERT(NGHTTP2_ERR_CALLBACK_FAILURE == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_stream_close(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n  user_data.stream_close_cb_called = 0;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream =\n      open_sent_stream3(session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec_default,\n                        NGHTTP2_STREAM_OPENED, &user_data);\n  CU_ASSERT(stream != NULL);\n  CU_ASSERT(nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR) == 0);\n  CU_ASSERT(user_data.stream_close_cb_called == 1);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_ctrl_not_send(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n  callbacks.send_callback = null_send_callback;\n  user_data.frame_not_send_cb_called = 0;\n  user_data.not_sent_frame_type = 0;\n  user_data.not_sent_error = 0;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  stream =\n      open_recv_stream3(session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec_default,\n                        NGHTTP2_STREAM_OPENING, &user_data);\n\n  /* Check response HEADERS */\n  /* Send bogus stream ID */\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 3,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_STREAM_CLOSED == user_data.not_sent_error);\n\n  user_data.frame_not_send_cb_called = 0;\n  /* Shutdown transmission */\n  stream->shut_flags |= NGHTTP2_SHUT_WR;\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_STREAM_SHUT_WR == user_data.not_sent_error);\n\n  stream->shut_flags = NGHTTP2_SHUT_NONE;\n  user_data.frame_not_send_cb_called = 0;\n  /* Queue RST_STREAM */\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1,\n                                           NGHTTP2_INTERNAL_ERROR));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_STREAM_CLOSING == user_data.not_sent_error);\n\n  nghttp2_session_del(session);\n\n  /* Check request HEADERS */\n  user_data.frame_not_send_cb_called = 0;\n  CU_ASSERT(nghttp2_session_client_new(&session, &callbacks, &user_data) == 0);\n  /* Maximum Stream ID is reached */\n  session->next_stream_id = (1u << 31) + 1;\n  CU_ASSERT(NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1, NULL,\n                                   NULL, 0, NULL));\n\n  user_data.frame_not_send_cb_called = 0;\n  /* GOAWAY received */\n  session->goaway_flags |= NGHTTP2_GOAWAY_RECV;\n  session->next_stream_id = 9;\n\n  CU_ASSERT(0 < nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                       NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_START_STREAM_NOT_ALLOWED == user_data.not_sent_error);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_get_outbound_queue_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n  CU_ASSERT(0 == nghttp2_session_get_outbound_queue_size(session));\n\n  CU_ASSERT(0 == nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL));\n  CU_ASSERT(1 == nghttp2_session_get_outbound_queue_size(session));\n\n  CU_ASSERT(0 == nghttp2_submit_goaway(session, NGHTTP2_FLAG_NONE, 2,\n                                       NGHTTP2_NO_ERROR, NULL, 0));\n  CU_ASSERT(2 == nghttp2_session_get_outbound_queue_size(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_get_effective_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n\n  stream = open_sent_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(0 == nghttp2_session_get_effective_recv_data_length(session));\n\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(0 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  /* Check connection flow control */\n  session->recv_window_size = 100;\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, 1100);\n\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(0 == nghttp2_session_get_effective_recv_data_length(session));\n\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, -50);\n  /* Now session->recv_window_size = -50 */\n  CU_ASSERT(-50 == session->recv_window_size);\n  CU_ASSERT(50 == session->recv_reduction);\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 950 ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(0 == nghttp2_session_get_effective_recv_data_length(session));\n\n  session->recv_window_size += 50;\n\n  /* Now session->recv_window_size = 0 */\n\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 950 ==\n            nghttp2_session_get_local_window_size(session));\n\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, 100);\n  CU_ASSERT(50 == session->recv_window_size);\n  CU_ASSERT(0 == session->recv_reduction);\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1050 ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(50 == nghttp2_session_get_effective_recv_data_length(session));\n\n  /* Check stream flow control */\n  stream->recv_window_size = 100;\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 1, 1100);\n\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(0 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 1, -50);\n  /* Now stream->recv_window_size = -50 */\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 950 ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(0 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  stream->recv_window_size += 50;\n  /* Now stream->recv_window_size = 0 */\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 1, 100);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1050 ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(50 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_set_option(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_option *option;\n  nghttp2_hd_deflater *deflater;\n  int rv;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  /* Test for nghttp2_option_set_no_auto_window_update */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_peer_max_concurrent_streams */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_peer_max_concurrent_streams(option, 100);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(100 == session->remote_settings.max_concurrent_streams);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_max_reserved_remote_streams */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_max_reserved_remote_streams(option, 99);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(99 == session->max_incoming_reserved_streams);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_no_auto_ping_ack */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_ping_ack(option, 1);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_PING_ACK);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_max_deflate_dynamic_table_size */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_max_deflate_dynamic_table_size(option, 0);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  deflater = &session->hd_deflater;\n\n  rv = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(1 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == deflater->deflate_hd_table_bufsize_max);\n  CU_ASSERT(0 == deflater->ctx.hd_table_bufsize);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_data_backoff_by_high_pri_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 4;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n\n  session->remote_window_size = 1 << 20;\n\n  ud.block_count = 2;\n  /* Sends request HEADERS + DATA[0] */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  stream = nghttp2_session_get_stream(session, 1);\n  stream->remote_window_size = 1 << 20;\n\n  CU_ASSERT(NGHTTP2_DATA == ud.sent_frame_type);\n  /* data for DATA[1] is read from data_prd but it is not sent */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n  ud.block_count = 2;\n  /* Sends DATA[1] + PING, PING is interleaved in DATA sequence */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_PING == ud.sent_frame_type);\n  /* data for DATA[2] is read from data_prd but it is not sent */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN);\n\n  ud.block_count = 2;\n  /* Sends DATA[2..3] */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(stream->shut_flags & NGHTTP2_SHUT_WR);\n\n  nghttp2_session_del(session);\n}\n\nstatic void check_session_recv_data_with_padding(nghttp2_bufs *bufs,\n                                                 size_t datalen,\n                                                 nghttp2_mem *mem) {\n  nghttp2_session *session;\n  my_user_data ud;\n  nghttp2_session_callbacks callbacks;\n  uint8_t *in;\n  size_t inlen;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_data_chunk_recv_callback = on_data_chunk_recv_callback;\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  inlen = (size_t)nghttp2_bufs_remove(bufs, &in);\n\n  ud.frame_recv_cb_called = 0;\n  ud.data_chunk_len = 0;\n\n  CU_ASSERT((ssize_t)inlen == nghttp2_session_mem_recv(session, in, inlen));\n\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(datalen == ud.data_chunk_len);\n\n  mem->free(in, NULL);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_pack_data_with_padding(void) {\n  nghttp2_session *session;\n  my_user_data ud;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame *frame;\n  size_t datalen = 55;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.select_padding_callback = select_padding_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  ud.padlen = 63;\n\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n  ud.block_count = 1;\n  ud.data_source_length = datalen;\n  /* Sends HEADERS */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n\n  frame = &session->aob.item->frame;\n\n  CU_ASSERT(ud.padlen == frame->data.padlen);\n  CU_ASSERT(frame->hd.flags & NGHTTP2_FLAG_PADDED);\n\n  /* Check reception of this DATA frame */\n  check_session_recv_data_with_padding(&session->aob.framebufs, datalen, mem);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_pack_headers_with_padding(void) {\n  nghttp2_session *session, *sv_session;\n  accumulator acc;\n  my_user_data ud;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.select_padding_callback = select_padding_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  acc.length = 0;\n  ud.acc = &acc;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_session_server_new(&sv_session, &callbacks, &ud);\n\n  ud.padlen = 163;\n\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                        NULL, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(acc.length < NGHTTP2_MAX_PAYLOADLEN);\n  ud.frame_recv_cb_called = 0;\n  CU_ASSERT((ssize_t)acc.length ==\n            nghttp2_session_mem_recv(sv_session, acc.buf, acc.length));\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(sv_session));\n\n  nghttp2_session_del(sv_session);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_pack_settings_payload(void) {\n  nghttp2_settings_entry iv[2];\n  uint8_t buf[64];\n  ssize_t len;\n  nghttp2_settings_entry *resiv;\n  size_t resniv;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 1023;\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 4095;\n\n  len = nghttp2_pack_settings_payload(buf, sizeof(buf), iv, 2);\n  CU_ASSERT(2 * NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH == len);\n  CU_ASSERT(0 == nghttp2_frame_unpack_settings_payload2(&resiv, &resniv, buf,\n                                                        (size_t)len, mem));\n  CU_ASSERT(2 == resniv);\n  CU_ASSERT(NGHTTP2_SETTINGS_HEADER_TABLE_SIZE == resiv[0].settings_id);\n  CU_ASSERT(1023 == resiv[0].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE == resiv[1].settings_id);\n  CU_ASSERT(4095 == resiv[1].value);\n\n  mem->free(resiv, NULL);\n\n  len = nghttp2_pack_settings_payload(buf, 9 /* too small */, iv, 2);\n  CU_ASSERT(NGHTTP2_ERR_INSUFF_BUFSIZE == len);\n}\n\n#define check_stream_dep_sib(STREAM, DEP_PREV, DEP_NEXT, SIB_PREV, SIB_NEXT)   \\\n  do {                                                                         \\\n    CU_ASSERT(DEP_PREV == STREAM->dep_prev);                                   \\\n    CU_ASSERT(DEP_NEXT == STREAM->dep_next);                                   \\\n    CU_ASSERT(SIB_PREV == STREAM->sib_prev);                                   \\\n    CU_ASSERT(SIB_NEXT == STREAM->sib_next);                                   \\\n  } while (0)\n\n/* nghttp2_stream_dep_add() and its families functions should be\n   tested in nghttp2_stream_test.c, but it is easier to use\n   nghttp2_session_open_stream().  Therefore, we test them here. */\nvoid test_nghttp2_session_stream_dep_add(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n\n  c = open_stream_with_dep(session, 5, a);\n  b = open_stream_with_dep(session, 3, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * b--c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, c);\n  check_stream_dep_sib(c, a, d, b, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(a == session->root.dep_next);\n\n  e = open_stream_with_dep_excl(session, 9, a);\n\n  /* a\n   * |\n   * e\n   * |\n   * b--c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == e->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(e, a, b, NULL, NULL);\n  check_stream_dep_sib(b, e, NULL, NULL, c);\n  check_stream_dep_sib(c, e, d, b, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(a == session->root.dep_next);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_remove(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *f, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* Remove root */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove(a);\n\n  /* becomes:\n   * c    b\n   * |\n   * d\n   */\n\n  CU_ASSERT(0 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(b, root, NULL, c, NULL);\n  check_stream_dep_sib(c, root, d, NULL, b);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(c == session->root.dep_next);\n\n  nghttp2_session_del(session);\n\n  /* Remove right most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove(b);\n\n  /* becomes:\n   * a\n   * |\n   * c\n   * |\n   * d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, c, NULL, NULL);\n  check_stream_dep_sib(b, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(c, a, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(a == session->root.dep_next);\n\n  nghttp2_session_del(session);\n\n  /* Remove left most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n  e = open_stream_with_dep(session, 9, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * e--d\n   */\n\n  nghttp2_stream_dep_remove(c);\n\n  /* becomes:\n   * a\n   * |\n   * e--d--b\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == c->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, d, NULL);\n  check_stream_dep_sib(c, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(d, a, NULL, e, b);\n  check_stream_dep_sib(e, a, NULL, NULL, d);\n\n  nghttp2_session_del(session);\n\n  /* Remove middle stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, a);\n  e = open_stream_with_dep(session, 9, c);\n  f = open_stream_with_dep(session, 11, c);\n\n  /* a\n   * |\n   * d--c--b\n   *    |\n   *    f--e\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 3 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  nghttp2_stream_dep_remove(c);\n\n  /* becomes:\n   * a\n   * |\n   * d--f--e--b\n   */\n\n  /* c's weight 16 is distributed evenly to e and f.  Each weight of e\n     and f becomes 8. */\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 + 8 * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(0 == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, d, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, e, NULL);\n  check_stream_dep_sib(c, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(e, a, NULL, f, b);\n  check_stream_dep_sib(f, a, NULL, d, e);\n  check_stream_dep_sib(d, a, NULL, NULL, f);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_add_subtree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *f, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* dep_stream has dep_next */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  e = open_stream(session, 9);\n  f = open_stream_with_dep(session, 11, e);\n\n  /* a         e\n   * |         |\n   * c--b      f\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(e);\n  nghttp2_stream_dep_add_subtree(a, e);\n\n  /* becomes\n   * a\n   * |\n   * e--c--b\n   * |  |\n   * f  d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 3 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, c, NULL);\n  check_stream_dep_sib(c, a, d, e, b);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n  check_stream_dep_sib(e, a, f, NULL, c);\n  check_stream_dep_sib(f, e, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  /* dep_stream has dep_next and now we insert subtree */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  e = open_stream(session, 9);\n  f = open_stream_with_dep(session, 11, e);\n\n  /* a         e\n   * |         |\n   * c--b      f\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(e);\n  nghttp2_stream_dep_insert_subtree(a, e);\n\n  /* becomes\n   * a\n   * |\n   * e\n   * |\n   * f--c--b\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 3 == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(e, a, f, NULL, NULL);\n  check_stream_dep_sib(f, e, NULL, NULL, c);\n  check_stream_dep_sib(b, e, NULL, c, NULL);\n  check_stream_dep_sib(c, e, d, f, b);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_remove_subtree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* Remove left most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n\n  /* becomes\n   * a  c\n   * |  |\n   * b  d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n  check_stream_dep_sib(c, NULL, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  /* Remove right most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(b);\n\n  /* becomes\n   * a  b\n   * |\n   * c\n   * |\n   * d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, c, NULL, NULL);\n  check_stream_dep_sib(c, a, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n  check_stream_dep_sib(b, NULL, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  /* Remove middle stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  e = open_stream_with_dep(session, 9, a);\n  c = open_stream_with_dep(session, 5, a);\n  b = open_stream_with_dep(session, 3, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * b--c--e\n   *    |\n   *    d\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n\n  /* becomes\n   * a     c\n   * |     |\n   * b--e  d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, e);\n  check_stream_dep_sib(e, a, NULL, b, NULL);\n  check_stream_dep_sib(c, NULL, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *root;\n  nghttp2_outbound_item *db, *dc;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n\n  /* a     c\n   * |\n   * b\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * a\n   * |\n   * b\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n\n  check_stream_dep_sib(c, root, a, NULL, NULL);\n  check_stream_dep_sib(a, c, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream(session, 3);\n  c = open_stream(session, 5);\n\n  /*\n   * a  b   c\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * b--a\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == c->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(0 == a->sum_dep_weight);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n\n  check_stream_dep_sib(c, root, b, NULL, NULL);\n  check_stream_dep_sib(b, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, NULL, b, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a     c\n   * |     |\n   * b     d\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * d--a\n   *    |\n   *    b\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  check_stream_dep_sib(c, root, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, b, d, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a     c\n   * |     |\n   * b     d\n   */\n\n  db = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * d--a\n   *    |\n   *    b\n   */\n\n  CU_ASSERT(c->queued);\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  check_stream_dep_sib(c, root, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, b, d, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a     c\n   * |     |\n   * b     d\n   */\n\n  db = create_data_ob_item(mem);\n  dc = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n  nghttp2_stream_attach_item(c, dc);\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * d--a\n   *    |\n   *    b\n   */\n\n  CU_ASSERT(c->queued);\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!d->queued);\n\n  check_stream_dep_sib(c, root, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, b, d, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_attach_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e;\n  nghttp2_outbound_item *da, *db, *dc, *dd;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  db = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n\n  /* Attach item to c */\n  dc = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(c, dc);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n\n  /* Attach item to a */\n  da = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(a, da);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n\n  /* Detach item from a */\n  nghttp2_stream_detach_item(a);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n\n  /* Attach item to d */\n  dd = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(d, dd);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n\n  /* Detach item from c */\n  nghttp2_stream_detach_item(c);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n\n  /* Detach item from b */\n  nghttp2_stream_detach_item(b);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(!b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n\n  /* exercises insertion */\n  e = open_stream_with_dep_excl(session, 9, a);\n\n  /* a\n   * |\n   * e\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* exercises deletion */\n  nghttp2_stream_dep_remove(e);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(!b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* e's weight 16 is distributed equally among c and b, both now have\n     weight 8 each. */\n  CU_ASSERT(8 == b->weight);\n  CU_ASSERT(8 == c->weight);\n\n  /* da, db, dc have been detached */\n  nghttp2_outbound_item_free(da, mem);\n  nghttp2_outbound_item_free(db, mem);\n  nghttp2_outbound_item_free(dc, mem);\n  free(da);\n  free(db);\n  free(dc);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  da = create_data_ob_item(mem);\n  db = create_data_ob_item(mem);\n  dc = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(a, da);\n  nghttp2_stream_attach_item(b, db);\n  nghttp2_stream_attach_item(c, dc);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* Detach item from a */\n  nghttp2_stream_detach_item(a);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* da has been detached */\n  nghttp2_outbound_item_free(da, mem);\n  free(da);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_attach_item_subtree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *f;\n  nghttp2_outbound_item *da, *db, *dd, *de;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  e = open_stream_with_dep_weight(session, 9, 32, &session->root);\n  f = open_stream_with_dep(session, 11, e);\n\n  /*\n   * a        e\n   * |        |\n   * c--b     f\n   * |\n   * d\n   */\n\n  de = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(e, de);\n\n  db = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Insert subtree e under a */\n\n  nghttp2_stream_dep_remove_subtree(e);\n  nghttp2_stream_dep_insert_subtree(a, e);\n\n  /*\n   * a\n   * |\n   * e\n   * |\n   * f--c--b\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree b */\n\n  nghttp2_stream_dep_remove_subtree(b);\n\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, b));\n\n  /*\n   * a       b\n   * |\n   * e\n   * |\n   * f--c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree a, and add it to root again */\n\n  nghttp2_stream_dep_remove_subtree(a);\n\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, a));\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree c */\n\n  nghttp2_stream_dep_remove_subtree(c);\n\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, c));\n\n  /*\n   * a       b     c\n   * |             |\n   * e             d\n   * |\n   * f\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  dd = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(d, dd);\n\n  /* Add subtree c to a */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  nghttp2_stream_dep_add_subtree(a, c);\n\n  /*\n   * a       b\n   * |\n   * c--e\n   * |  |\n   * d  f\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Insert b under a */\n\n  nghttp2_stream_dep_remove_subtree(b);\n  nghttp2_stream_dep_insert_subtree(a, b);\n\n  /*\n   * a\n   * |\n   * b\n   * |\n   * c--e\n   * |  |\n   * d  f\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree b */\n\n  nghttp2_stream_dep_remove_subtree(b);\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, b));\n\n  /*\n   * b       a\n   * |\n   * e--c\n   * |  |\n   * f  d\n   */\n\n  CU_ASSERT(!a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree c, and detach item from b, and then re-add\n     subtree c under b */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  nghttp2_stream_detach_item(b);\n  nghttp2_stream_dep_add_subtree(b, c);\n\n  /*\n   * b       a\n   * |\n   * e--c\n   * |  |\n   * f  d\n   */\n\n  CU_ASSERT(!a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Attach data to a, and add subtree a under b */\n\n  da = create_data_ob_item(mem);\n  nghttp2_stream_attach_item(a, da);\n  nghttp2_stream_dep_remove_subtree(a);\n  nghttp2_stream_dep_add_subtree(b, a);\n\n  /*\n   * b\n   * |\n   * a--e--c\n   *    |  |\n   *    f  d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(3 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree c, and add under f */\n  nghttp2_stream_dep_remove_subtree(c);\n  nghttp2_stream_dep_insert_subtree(f, c);\n\n  /*\n   * b\n   * |\n   * a--e\n   *    |\n   *    f\n   *    |\n   *    c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&e->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&f->obq));\n\n  /* db has been detached */\n  nghttp2_outbound_item_free(db, mem);\n  free(db);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_get_state(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_mem *mem;\n  nghttp2_hd_deflater deflater;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_stream *stream;\n  ssize_t rv;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n  memset(&data_prd, 0, sizeof(data_prd));\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_IDLE ==\n            nghttp2_stream_get_state(nghttp2_session_get_root_stream(session)));\n\n  /* stream 1 HEADERS; without END_STREAM flag set */\n  pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 1);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(1 == stream->stream_id);\n  CU_ASSERT(NGHTTP2_STREAM_STATE_OPEN == nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* stream 3 HEADERS; with END_STREAM flag set */\n  pack_headers(&bufs, &deflater, 3,\n               NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 3);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(3 == stream->stream_id);\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE ==\n            nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Respond to stream 1 */\n  nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv), NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  /* Respond to stream 3 */\n  nghttp2_submit_response(session, 3, resnv, ARRLEN(resnv), NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 3);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_CLOSED == nghttp2_stream_get_state(stream));\n\n  /* stream 5 HEADERS; with END_STREAM flag set */\n  pack_headers(&bufs, &deflater, 5,\n               NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Push stream 2 associated to stream 5 */\n  rv = nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 5, reqnv,\n                                   ARRLEN(reqnv), NULL);\n\n  CU_ASSERT(2 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_RESERVED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  /* Send resposne to push stream 2 with END_STREAM set */\n  nghttp2_submit_response(session, 2, resnv, ARRLEN(resnv), NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  /* At server, pushed stream object is not retained after closed */\n  CU_ASSERT(NULL == stream);\n\n  /* Push stream 4 associated to stream 5 */\n  rv = nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 5, reqnv,\n                                   ARRLEN(reqnv), NULL);\n\n  CU_ASSERT(4 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 4);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_RESERVED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  /* Send response to push stream 4 without closing */\n  data_prd.read_callback = defer_data_source_read_callback;\n\n  nghttp2_submit_response(session, 4, resnv, ARRLEN(resnv), &data_prd);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 4);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE ==\n            nghttp2_stream_get_state(stream));\n\n  /* Create idle stream by PRIORITY frame */\n  nghttp2_frame_priority_init(&frame.priority, 7, &pri_spec_default);\n\n  rv = nghttp2_frame_pack_priority(&bufs, &frame.priority);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 7);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_IDLE == nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Test for client side */\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  /* Receive PUSH_PROMISE 2 associated to stream 1 */\n  pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2, reqnv,\n                    ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_RESERVED_REMOTE ==\n            nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Receive push response for stream 2 without END_STREAM set */\n  pack_headers(&bufs, &deflater, 2, NGHTTP2_FLAG_END_HEADERS, resnv,\n               ARRLEN(resnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_stream_get_something(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n\n  CU_ASSERT(nghttp2_session_get_root_stream(session) ==\n            nghttp2_stream_get_parent(a));\n  CU_ASSERT(NULL == nghttp2_stream_get_previous_sibling(a));\n  CU_ASSERT(NULL == nghttp2_stream_get_next_sibling(a));\n  CU_ASSERT(NULL == nghttp2_stream_get_first_child(a));\n\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep_weight(session, 5, 11, a);\n\n  CU_ASSERT(a == nghttp2_stream_get_parent(c));\n  CU_ASSERT(a == nghttp2_stream_get_parent(b));\n\n  CU_ASSERT(c == nghttp2_stream_get_first_child(a));\n\n  CU_ASSERT(b == nghttp2_stream_get_next_sibling(c));\n  CU_ASSERT(c == nghttp2_stream_get_previous_sibling(b));\n\n  CU_ASSERT(27 == nghttp2_stream_get_sum_dependency_weight(a));\n\n  CU_ASSERT(11 == nghttp2_stream_get_weight(c));\n  CU_ASSERT(5 == nghttp2_stream_get_stream_id(c));\n  CU_ASSERT(0 == nghttp2_stream_get_stream_id(&session->root));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_find_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  open_recv_stream(session, 1);\n\n  stream = nghttp2_session_find_stream(session, 1);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(1 == stream->stream_id);\n\n  stream = nghttp2_session_find_stream(session, 0);\n\n  CU_ASSERT(&session->root == stream);\n  CU_ASSERT(0 == stream->stream_id);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_keep_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const size_t max_concurrent_streams = 5;\n  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,\n                               (uint32_t)max_concurrent_streams};\n  size_t i;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  for (i = 0; i < max_concurrent_streams; ++i) {\n    open_recv_stream(session, (int32_t)i * 2 + 1);\n  }\n\n  CU_ASSERT(0 == session->num_closed_streams);\n\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(1 == session->closed_stream_tail->stream_id);\n  CU_ASSERT(session->closed_stream_tail == session->closed_stream_head);\n\n  nghttp2_session_close_stream(session, 5, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(2 == session->num_closed_streams);\n  CU_ASSERT(5 == session->closed_stream_tail->stream_id);\n  CU_ASSERT(1 == session->closed_stream_head->stream_id);\n  CU_ASSERT(session->closed_stream_head ==\n            session->closed_stream_tail->closed_prev);\n  CU_ASSERT(NULL == session->closed_stream_tail->closed_next);\n  CU_ASSERT(session->closed_stream_tail ==\n            session->closed_stream_head->closed_next);\n  CU_ASSERT(NULL == session->closed_stream_head->closed_prev);\n\n  open_recv_stream(session, 11);\n  nghttp2_session_adjust_closed_stream(session);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(5 == session->closed_stream_tail->stream_id);\n  CU_ASSERT(session->closed_stream_tail == session->closed_stream_head);\n  CU_ASSERT(NULL == session->closed_stream_head->closed_prev);\n  CU_ASSERT(NULL == session->closed_stream_head->closed_next);\n\n  open_recv_stream(session, 13);\n  nghttp2_session_adjust_closed_stream(session);\n\n  CU_ASSERT(0 == session->num_closed_streams);\n  CU_ASSERT(NULL == session->closed_stream_tail);\n  CU_ASSERT(NULL == session->closed_stream_head);\n\n  nghttp2_session_close_stream(session, 3, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(3 == session->closed_stream_head->stream_id);\n\n  /* server initiated stream is not counted to max concurrent limit */\n  open_sent_stream(session, 2);\n  nghttp2_session_adjust_closed_stream(session);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(3 == session->closed_stream_head->stream_id);\n\n  nghttp2_session_close_stream(session, 2, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(3 == session->closed_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_keep_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const size_t max_concurrent_streams = 1;\n  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,\n                               (uint32_t)max_concurrent_streams};\n  int i;\n  int32_t stream_id;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  /* We at least allow NGHTTP2_MIN_IDLE_STREAM idle streams even if\n     max concurrent streams is very low. */\n  for (i = 0; i < NGHTTP2_MIN_IDLE_STREAMS; ++i) {\n    open_recv_stream2(session, i * 2 + 1, NGHTTP2_STREAM_IDLE);\n    nghttp2_session_adjust_idle_stream(session);\n  }\n\n  CU_ASSERT(NGHTTP2_MIN_IDLE_STREAMS == session->num_idle_streams);\n\n  stream_id = (NGHTTP2_MIN_IDLE_STREAMS - 1) * 2 + 1;\n  CU_ASSERT(1 == session->idle_stream_head->stream_id);\n  CU_ASSERT(stream_id == session->idle_stream_tail->stream_id);\n\n  stream_id += 2;\n\n  open_recv_stream2(session, stream_id, NGHTTP2_STREAM_IDLE);\n  nghttp2_session_adjust_idle_stream(session);\n\n  CU_ASSERT(NGHTTP2_MIN_IDLE_STREAMS == session->num_idle_streams);\n  CU_ASSERT(3 == session->idle_stream_head->stream_id);\n  CU_ASSERT(stream_id == session->idle_stream_tail->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_detach_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  int i;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  for (i = 1; i <= 3; ++i) {\n    nghttp2_session_open_stream(session, i, NGHTTP2_STREAM_FLAG_NONE,\n                                &pri_spec_default, NGHTTP2_STREAM_IDLE, NULL);\n  }\n\n  CU_ASSERT(3 == session->num_idle_streams);\n\n  /* Detach middle stream */\n  stream = nghttp2_session_get_stream_raw(session, 2);\n\n  CU_ASSERT(session->idle_stream_head == stream->closed_prev);\n  CU_ASSERT(session->idle_stream_tail == stream->closed_next);\n  CU_ASSERT(stream == session->idle_stream_head->closed_next);\n  CU_ASSERT(stream == session->idle_stream_tail->closed_prev);\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(2 == session->num_idle_streams);\n\n  CU_ASSERT(NULL == stream->closed_prev);\n  CU_ASSERT(NULL == stream->closed_next);\n\n  CU_ASSERT(session->idle_stream_head ==\n            session->idle_stream_tail->closed_prev);\n  CU_ASSERT(session->idle_stream_tail ==\n            session->idle_stream_head->closed_next);\n\n  /* Detach head stream */\n  stream = session->idle_stream_head;\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(1 == session->num_idle_streams);\n\n  CU_ASSERT(session->idle_stream_head == session->idle_stream_tail);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_prev);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_next);\n\n  /* Detach last stream */\n\n  stream = session->idle_stream_head;\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(0 == session->num_idle_streams);\n\n  CU_ASSERT(NULL == session->idle_stream_head);\n  CU_ASSERT(NULL == session->idle_stream_tail);\n\n  for (i = 4; i <= 5; ++i) {\n    nghttp2_session_open_stream(session, i, NGHTTP2_STREAM_FLAG_NONE,\n                                &pri_spec_default, NGHTTP2_STREAM_IDLE, NULL);\n  }\n\n  CU_ASSERT(2 == session->num_idle_streams);\n\n  /* Detach tail stream */\n\n  stream = session->idle_stream_tail;\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(1 == session->num_idle_streams);\n\n  CU_ASSERT(session->idle_stream_head == session->idle_stream_tail);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_prev);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_next);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_large_dep_tree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  size_t i;\n  nghttp2_stream *dep_stream = NULL;\n  nghttp2_stream *stream;\n  int32_t stream_id;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream_id = 1;\n  for (i = 0; i < 250; ++i, stream_id += 2) {\n    dep_stream = open_stream_with_dep(session, stream_id, dep_stream);\n  }\n\n  stream_id = 1;\n  for (i = 0; i < 250; ++i, stream_id += 2) {\n    stream = nghttp2_session_get_stream(session, stream_id);\n    CU_ASSERT(nghttp2_stream_dep_find_ancestor(stream, &session->root));\n    CU_ASSERT(nghttp2_stream_in_dep_tree(stream));\n  }\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_graceful_shutdown(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 301);\n  open_sent_stream(session, 302);\n  open_recv_stream(session, 309);\n  open_recv_stream(session, 311);\n  open_recv_stream(session, 319);\n\n  CU_ASSERT(0 == nghttp2_submit_shutdown_notice(session));\n\n  ud.frame_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT((1u << 31) - 1 == session->local_last_stream_id);\n\n  CU_ASSERT(0 == nghttp2_submit_goaway(session, NGHTTP2_FLAG_NONE, 311,\n                                       NGHTTP2_NO_ERROR, NULL, 0));\n\n  ud.frame_send_cb_called = 0;\n  ud.stream_close_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(311 == session->local_last_stream_id);\n  CU_ASSERT(1 == ud.stream_close_cb_called);\n\n  CU_ASSERT(0 ==\n            nghttp2_session_terminate_session2(session, 301, NGHTTP2_NO_ERROR));\n\n  ud.frame_send_cb_called = 0;\n  ud.stream_close_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(301 == session->local_last_stream_id);\n  CU_ASSERT(2 == ud.stream_close_cb_called);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 301));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 302));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 309));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 311));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 319));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_header_temporal_failure(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_hd_deflater deflater;\n  nghttp2_nv nv[] = {MAKE_NV(\"alpha\", \"bravo\"), MAKE_NV(\"charlie\", \"delta\")};\n  nghttp2_nv *nva;\n  size_t hdpos;\n  ssize_t rv;\n  nghttp2_frame frame;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.on_header_callback = temporal_failure_on_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  frame_pack_bufs_init(&bufs);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nghttp2_nv_array_copy(&nva, reqnv, ARRLEN(reqnv), mem);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_STREAM, 1,\n                             NGHTTP2_HCAT_REQUEST, NULL, nva, ARRLEN(reqnv));\n  nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* We are going to create CONTINUATION.  First serialize header\n     block, and then frame header. */\n  hdpos = nghttp2_bufs_len(&bufs);\n\n  buf = &bufs.head->buf;\n  buf->last += NGHTTP2_FRAME_HDLEN;\n\n  nghttp2_hd_deflate_hd_bufs(&deflater, &bufs, &nv[1], 1);\n\n  nghttp2_frame_hd_init(&hd,\n                        nghttp2_bufs_len(&bufs) - hdpos - NGHTTP2_FRAME_HDLEN,\n                        NGHTTP2_CONTINUATION, NGHTTP2_FLAG_END_HEADERS, 1);\n\n  nghttp2_frame_pack_frame_hd(&buf->pos[hdpos], &hd);\n\n  ud.header_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.header_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n\n  /* Make sure no header decompression error occurred */\n  CU_ASSERT(NGHTTP2_GOAWAY_NONE == session->goaway_flags);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Check for PUSH_PROMISE */\n  nghttp2_hd_deflate_init(&deflater, mem);\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  open_sent_stream(session, 1);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  ud.header_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.header_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(2 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INTERNAL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_recv_client_magic(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  ssize_t rv;\n  nghttp2_frame ping_frame;\n  uint8_t buf[16];\n\n  /* enable global nghttp2_enable_strict_preface here */\n  nghttp2_enable_strict_preface = 1;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* Check success case */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  rv = nghttp2_session_mem_recv(session, (const uint8_t *)NGHTTP2_CLIENT_MAGIC,\n                                NGHTTP2_CLIENT_MAGIC_LEN);\n\n  CU_ASSERT(rv == NGHTTP2_CLIENT_MAGIC_LEN);\n  CU_ASSERT(NGHTTP2_IB_READ_FIRST_SETTINGS == session->iframe.state);\n\n  /* Receiving PING is error because we want SETTINGS. */\n  nghttp2_frame_ping_init(&ping_frame.ping, NGHTTP2_FLAG_NONE, NULL);\n\n  nghttp2_frame_pack_frame_hd(buf, &ping_frame.ping.hd);\n\n  rv = nghttp2_session_mem_recv(session, buf, NGHTTP2_FRAME_HDLEN);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(NGHTTP2_IB_IGN_ALL == session->iframe.state);\n  CU_ASSERT(0 == session->iframe.payloadleft);\n\n  nghttp2_frame_ping_free(&ping_frame.ping);\n\n  nghttp2_session_del(session);\n\n  /* Check bad case */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Feed magic with one byte less */\n  rv = nghttp2_session_mem_recv(session, (const uint8_t *)NGHTTP2_CLIENT_MAGIC,\n                                NGHTTP2_CLIENT_MAGIC_LEN - 1);\n\n  CU_ASSERT(rv == NGHTTP2_CLIENT_MAGIC_LEN - 1);\n  CU_ASSERT(NGHTTP2_IB_READ_CLIENT_MAGIC == session->iframe.state);\n  CU_ASSERT(1 == session->iframe.payloadleft);\n\n  rv = nghttp2_session_mem_recv(session, (const uint8_t *)\"\\0\", 1);\n\n  CU_ASSERT(NGHTTP2_ERR_BAD_CLIENT_MAGIC == rv);\n\n  nghttp2_session_del(session);\n\n  /* disable global nghttp2_enable_strict_preface here */\n  nghttp2_enable_strict_preface = 0;\n}\n\nvoid test_nghttp2_session_delete_data_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a;\n  nghttp2_data_provider prd;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_recv_stream(session, 1);\n  open_recv_stream_with_dep(session, 3, a);\n\n  /* We don't care about these members, since we won't send data */\n  prd.source.ptr = NULL;\n  prd.read_callback = fail_data_source_read_callback;\n\n  CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, 1, &prd));\n  CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, 3, &prd));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_open_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_stream *opened_stream;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 3, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  stream = nghttp2_session_get_stream_raw(session, 1);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(NULL == stream->closed_prev);\n  CU_ASSERT(NULL == stream->closed_next);\n  CU_ASSERT(1 == session->num_idle_streams);\n  CU_ASSERT(session->idle_stream_head == stream);\n  CU_ASSERT(session->idle_stream_tail == stream);\n\n  opened_stream = open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  CU_ASSERT(stream == opened_stream);\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n  CU_ASSERT(0 == session->num_idle_streams);\n  CU_ASSERT(NULL == session->idle_stream_head);\n  CU_ASSERT(NULL == session->idle_stream_tail);\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_cancel_reserved_remote(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  stream = open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 2, NGHTTP2_CANCEL);\n\n  CU_ASSERT(NGHTTP2_STREAM_CLOSING == stream->state);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nvlen = ARRLEN(resnv);\n  nghttp2_nv_array_copy(&nva, resnv, nvlen, mem);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_PUSH_RESPONSE, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  /* stream is not dangling, so assign NULL */\n  stream = NULL;\n\n  /* No RST_STREAM or GOAWAY is generated since stream should be in\n     NGHTTP2_STREAM_CLOSING and push response should be ignored. */\n  CU_ASSERT(0 == nghttp2_outbound_queue_size(&session->ob_reg));\n\n  /* Check that we can receive push response HEADERS while RST_STREAM\n     is just queued. */\n  open_recv_stream2(session, 4, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 2, NGHTTP2_CANCEL);\n\n  nghttp2_bufs_reset(&bufs);\n\n  frame.hd.stream_id = 4;\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(1 == nghttp2_outbound_queue_size(&session->ob_reg));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_reset_pending_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  int32_t stream_id;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  stream_id = nghttp2_submit_request(session, NULL, NULL, 0, NULL, NULL);\n  CU_ASSERT(stream_id >= 1);\n\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, stream_id,\n                            NGHTTP2_CANCEL);\n\n  session->remote_settings.max_concurrent_streams = 0;\n\n  /* RST_STREAM cancels pending HEADERS and is not actually sent. */\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  /* See HEADERS is not sent.  on_stream_close is called just like\n     transmission failure. */\n  session->remote_settings.max_concurrent_streams = 1;\n\n  ud.frame_not_send_cb_called = 0;\n  ud.stream_close_error_code = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_CANCEL == ud.stream_close_error_code);\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_data_callback(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  accumulator acc;\n  nghttp2_frame_hd hd;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.send_data_callback = send_data_callback;\n\n  data_prd.read_callback = no_copy_data_source_read_callback;\n\n  acc.length = 0;\n  ud.acc = &acc;\n\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  open_sent_stream(session, 1);\n\n  nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT((NGHTTP2_FRAME_HDLEN + NGHTTP2_DATA_PAYLOADLEN) * 2 == acc.length);\n\n  nghttp2_frame_unpack_frame_hd(&hd, acc.buf);\n\n  CU_ASSERT(16384 == hd.length);\n  CU_ASSERT(NGHTTP2_DATA == hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n\n  nghttp2_frame_unpack_frame_hd(&hd, acc.buf + NGHTTP2_FRAME_HDLEN + hd.length);\n\n  CU_ASSERT(16384 == hd.length);\n  CU_ASSERT(NGHTTP2_DATA == hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == hd.flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_begin_headers_temporal_failure(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_hd_deflater deflater;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback =\n      temporal_failure_on_begin_headers_callback;\n  callbacks.on_header_callback = on_header_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INTERNAL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_bufs_reset(&bufs);\n  /* check for PUSH_PROMISE */\n  nghttp2_hd_deflate_init(&deflater, mem);\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  open_sent_stream(session, 1);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(2 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INTERNAL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_defer_then_close(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider prd;\n  int rv;\n  const uint8_t *datap;\n  ssize_t datalen;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  prd.read_callback = defer_data_source_read_callback;\n\n  rv = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), &prd, NULL);\n  CU_ASSERT(rv > 0);\n\n  /* This sends HEADERS */\n  datalen = nghttp2_session_mem_send(session, &datap);\n\n  CU_ASSERT(datalen > 0);\n\n  /* This makes DATA item deferred */\n  datalen = nghttp2_session_mem_send(session, &datap);\n\n  CU_ASSERT(datalen == 0);\n\n  nghttp2_frame_rst_stream_init(&frame.rst_stream, 1, NGHTTP2_CANCEL);\n\n  /* Assertion failure; GH-264 */\n  rv = nghttp2_session_on_rst_stream_received(session, &frame);\n\n  CU_ASSERT(rv == 0);\n\n  nghttp2_session_del(session);\n}\n\nstatic int submit_response_on_stream_close(nghttp2_session *session,\n                                           int32_t stream_id,\n                                           uint32_t error_code,\n                                           void *user_data) {\n  nghttp2_data_provider data_prd;\n  (void)error_code;\n  (void)user_data;\n\n  data_prd.read_callback = temporal_failure_data_source_read_callback;\n\n  // Attempt to submit response or data to the stream being closed\n  switch (stream_id) {\n  case 1:\n    CU_ASSERT(0 == nghttp2_submit_response(session, stream_id, resnv,\n                                           ARRLEN(resnv), &data_prd));\n    break;\n  case 3:\n    CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, stream_id,\n                                       &data_prd));\n    break;\n  }\n\n  return 0;\n}\n\nvoid test_nghttp2_session_detach_item_from_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_stream_close_callback = submit_response_on_stream_close;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  open_recv_stream(session, 1);\n  open_recv_stream(session, 3);\n\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n  nghttp2_session_close_stream(session, 3, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flooding(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_frame frame;\n  nghttp2_mem *mem;\n  size_t i;\n\n  mem = nghttp2_mem_default();\n\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* PING ACK */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_NONE, NULL);\n  nghttp2_frame_pack_ping(&bufs, &frame.ping);\n  nghttp2_frame_ping_free(&frame.ping);\n\n  buf = &bufs.head->buf;\n\n  for (i = 0; i < NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM; ++i) {\n    CU_ASSERT(\n        (ssize_t)nghttp2_buf_len(buf) ==\n        nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n  }\n\n  CU_ASSERT(NGHTTP2_ERR_FLOODED ==\n            nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n\n  nghttp2_session_del(session);\n\n  /* SETTINGS ACK */\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, NULL, 0);\n  nghttp2_frame_pack_settings(&bufs, &frame.settings);\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n\n  for (i = 0; i < NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM; ++i) {\n    CU_ASSERT(\n        (ssize_t)nghttp2_buf_len(buf) ==\n        nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n  }\n\n  CU_ASSERT(NGHTTP2_ERR_FLOODED ==\n            nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_change_stream_priority(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream1, *stream2, *stream3, *stream5;\n  nghttp2_priority_spec pri_spec;\n  int rv;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream1 = open_recv_stream(session, 1);\n  stream3 = open_recv_stream_with_dep_weight(session, 3, 199, stream1);\n  stream2 = open_sent_stream_with_dep_weight(session, 2, 101, stream3);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 256, 0);\n\n  rv = nghttp2_session_change_stream_priority(session, 2, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  CU_ASSERT(stream1 == stream2->dep_prev);\n  CU_ASSERT(256 == stream2->weight);\n\n  /* Cannot change stream which does not exist */\n  rv = nghttp2_session_change_stream_priority(session, 5, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to depend on itself */\n  rv = nghttp2_session_change_stream_priority(session, 1, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to change priority of root stream (0) */\n  rv = nghttp2_session_change_stream_priority(session, 0, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* Depends on the non-existing idle stream.  This creates that idle\n     stream. */\n  nghttp2_priority_spec_init(&pri_spec, 5, 9, 1);\n\n  rv = nghttp2_session_change_stream_priority(session, 2, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream5 = nghttp2_session_get_stream_raw(session, 5);\n\n  CU_ASSERT(NULL != stream5);\n  CU_ASSERT(&session->root == stream5->dep_prev);\n  CU_ASSERT(stream5 == stream2->dep_prev);\n  CU_ASSERT(9 == stream2->weight);\n\n  nghttp2_session_del(session);\n\n  /* Check that this works in client session too */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  stream1 = open_sent_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 5, 9, 1);\n\n  rv = nghttp2_session_change_stream_priority(session, 1, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream5 = nghttp2_session_get_stream_raw(session, 5);\n\n  CU_ASSERT(NULL != stream5);\n  CU_ASSERT(&session->root == stream5->dep_prev);\n  CU_ASSERT(stream5 == stream1->dep_prev);\n  CU_ASSERT(9 == stream1->weight);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_create_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream2, *stream4, *stream8, *stream10;\n  nghttp2_priority_spec pri_spec;\n  int rv;\n  int i;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream2 = open_sent_stream(session, 2);\n\n  nghttp2_priority_spec_init(&pri_spec, 2, 111, 1);\n\n  rv = nghttp2_session_create_idle_stream(session, 4, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream4 = nghttp2_session_get_stream_raw(session, 4);\n\n  CU_ASSERT(4 == stream4->stream_id);\n  CU_ASSERT(111 == stream4->weight);\n  CU_ASSERT(stream2 == stream4->dep_prev);\n  CU_ASSERT(stream4 == stream2->dep_next);\n\n  /* If pri_spec->stream_id does not exist, and it is idle stream, it\n     is created too */\n  nghttp2_priority_spec_init(&pri_spec, 10, 109, 0);\n\n  rv = nghttp2_session_create_idle_stream(session, 8, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream8 = nghttp2_session_get_stream_raw(session, 8);\n  stream10 = nghttp2_session_get_stream_raw(session, 10);\n\n  CU_ASSERT(8 == stream8->stream_id);\n  CU_ASSERT(109 == stream8->weight);\n  CU_ASSERT(10 == stream10->stream_id);\n  CU_ASSERT(16 == stream10->weight);\n  CU_ASSERT(stream10 == stream8->dep_prev);\n  CU_ASSERT(&session->root == stream10->dep_prev);\n\n  /* It is an error to attempt to create already existing idle\n     stream */\n  rv = nghttp2_session_create_idle_stream(session, 4, &pri_spec);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to depend on itself */\n  pri_spec.stream_id = 6;\n\n  rv = nghttp2_session_create_idle_stream(session, 6, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to create root stream (0) as idle stream */\n  rv = nghttp2_session_create_idle_stream(session, 0, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to create non-idle stream */\n  session->last_sent_stream_id = 20;\n  pri_spec.stream_id = 2;\n\n  rv = nghttp2_session_create_idle_stream(session, 18, &pri_spec);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  nghttp2_session_del(session);\n\n  /* Check that this works in client session too */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 4, 99, 1);\n\n  rv = nghttp2_session_create_idle_stream(session, 2, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream4 = nghttp2_session_get_stream_raw(session, 4);\n  stream2 = nghttp2_session_get_stream_raw(session, 2);\n\n  CU_ASSERT(NULL != stream4);\n  CU_ASSERT(NULL != stream2);\n  CU_ASSERT(&session->root == stream4->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream4->weight);\n  CU_ASSERT(stream4 == stream2->dep_prev);\n  CU_ASSERT(99 == stream2->weight);\n\n  nghttp2_session_del(session);\n\n  /* Check that idle stream is reduced when nghttp2_session_send() is\n     called. */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = 30;\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n  for (i = 0; i < 100; ++i) {\n    rv = nghttp2_session_create_idle_stream(session, i * 2 + 1, &pri_spec);\n\n    CU_ASSERT(0 == rv);\n\n    nghttp2_priority_spec_init(&pri_spec, i * 2 + 1, 16, 0);\n  }\n\n  CU_ASSERT(100 == session->num_idle_streams);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(30 == session->num_idle_streams);\n  CU_ASSERT(141 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n\n  /* Check that idle stream is reduced when nghttp2_session_mem_recv() is\n     called. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = 30;\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n  for (i = 0; i < 100; ++i) {\n    rv = nghttp2_session_create_idle_stream(session, i * 2 + 1, &pri_spec);\n\n    CU_ASSERT(0 == rv);\n\n    nghttp2_priority_spec_init(&pri_spec, i * 2 + 1, 16, 0);\n  }\n\n  CU_ASSERT(100 == session->num_idle_streams);\n  CU_ASSERT(0 == nghttp2_session_mem_recv(session, NULL, 0));\n  CU_ASSERT(30 == session->num_idle_streams);\n  CU_ASSERT(141 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_repeated_priority_change(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_priority_spec pri_spec;\n  int32_t stream_id, last_stream_id;\n  int32_t max_streams = 20;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = (uint32_t)max_streams;\n\n  /* 1 -> 0 */\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  last_stream_id = max_streams * 2 + 1;\n\n  for (stream_id = 3; stream_id < last_stream_id; stream_id += 2) {\n    /* 1 -> stream_id */\n    nghttp2_priority_spec_init(&pri_spec, stream_id, 16, 0);\n    nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n    CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n    nghttp2_frame_priority_free(&frame.priority);\n  }\n\n  CU_ASSERT(20 == session->num_idle_streams);\n  CU_ASSERT(1 == session->idle_stream_head->stream_id);\n\n  /* 1 -> last_stream_id */\n  nghttp2_priority_spec_init(&pri_spec, last_stream_id, 16, 0);\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  CU_ASSERT(20 == session->num_idle_streams);\n  CU_ASSERT(3 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_repeated_priority_submission(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_priority_spec pri_spec;\n  int32_t stream_id, last_stream_id;\n  uint32_t max_streams = NGHTTP2_MIN_IDLE_STREAMS;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = max_streams;\n\n  /* 1 -> 0 */\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n\n  last_stream_id = (int32_t)(max_streams * 2 + 1);\n\n  for (stream_id = 3; stream_id < last_stream_id; stream_id += 2) {\n    /* 1 -> stream_id */\n    nghttp2_priority_spec_init(&pri_spec, stream_id, 16, 0);\n\n    CU_ASSERT(\n        0 == nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n  }\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(max_streams == session->num_idle_streams);\n  CU_ASSERT(1 == session->idle_stream_head->stream_id);\n\n  /* 1 -> last_stream_id */\n  nghttp2_priority_spec_init(&pri_spec, last_stream_id, 16, 0);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(max_streams == session->num_idle_streams);\n  CU_ASSERT(3 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_set_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = open_sent_stream(session, 1);\n  stream->recv_window_size = 4096;\n\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 65536));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1 ==\n            stream->local_window_size);\n  CU_ASSERT(4096 == stream->recv_window_size);\n  CU_ASSERT(65536 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Go decrement part */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 32768));\n  CU_ASSERT(32768 == stream->local_window_size);\n  CU_ASSERT(-28672 == stream->recv_window_size);\n  CU_ASSERT(32768 == stream->recv_reduction);\n  CU_ASSERT(65536 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 49152));\n  CU_ASSERT(49152 == stream->local_window_size);\n  CU_ASSERT(-12288 == stream->recv_window_size);\n  CU_ASSERT(16384 == stream->recv_reduction);\n  CU_ASSERT(65536 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Increase local window again */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 65537));\n  CU_ASSERT(65537 == stream->local_window_size);\n  CU_ASSERT(4096 == stream->recv_window_size);\n  CU_ASSERT(0 == stream->recv_reduction);\n  CU_ASSERT(65537 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Check connection-level flow control */\n  session->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 65536));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1 ==\n            session->local_window_size);\n  CU_ASSERT(4096 == session->recv_window_size);\n  CU_ASSERT(65536 - 4096 == nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Go decrement part */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 32768));\n  CU_ASSERT(32768 == session->local_window_size);\n  CU_ASSERT(-28672 == session->recv_window_size);\n  CU_ASSERT(32768 == session->recv_reduction);\n  CU_ASSERT(65536 - 4096 == nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 49152));\n  CU_ASSERT(49152 == session->local_window_size);\n  CU_ASSERT(-12288 == session->recv_window_size);\n  CU_ASSERT(16384 == session->recv_reduction);\n  CU_ASSERT(65536 - 4096 == nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Increase local window again */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 65537));\n  CU_ASSERT(65537 == session->local_window_size);\n  CU_ASSERT(4096 == session->recv_window_size);\n  CU_ASSERT(0 == session->recv_reduction);\n  CU_ASSERT(65537 - 4096 == nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n\n  /* Make sure that nghttp2_session_set_local_window_size submits\n     WINDOW_UPDATE if necessary to increase stream-level window. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = open_sent_stream(session, 1);\n  stream->recv_window_size = NGHTTP2_INITIAL_WINDOW_SIZE;\n\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 0));\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == nghttp2_session_get_stream_local_window_size(session, 1));\n  /* This should submit WINDOW_UPDATE frame because stream-level\n     receiving window is now full. */\n  CU_ASSERT(0 ==\n            nghttp2_session_set_local_window_size(session, NGHTTP2_FLAG_NONE, 1,\n                                                  NGHTTP2_INITIAL_WINDOW_SIZE));\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n\n  /* Make sure that nghttp2_session_set_local_window_size submits\n     WINDOW_UPDATE if necessary to increase connection-level\n     window. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  session->recv_window_size = NGHTTP2_INITIAL_WINDOW_SIZE;\n\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 0));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(0 == nghttp2_session_get_local_window_size(session));\n  /* This should submit WINDOW_UPDATE frame because connection-level\n     receiving window is now full. */\n  CU_ASSERT(0 ==\n            nghttp2_session_set_local_window_size(session, NGHTTP2_FLAG_NONE, 0,\n                                                  NGHTTP2_INITIAL_WINDOW_SIZE));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_cancel_from_before_frame_send(void) {\n  int rv;\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_settings_entry iv;\n  nghttp2_data_provider data_prd;\n  int32_t stream_id;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.before_frame_send_callback = cancel_before_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  iv.settings_id = 0;\n  iv.value = 1000000009;\n\n  rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n  ud.before_frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(1 == ud.before_frame_send_cb_called);\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  data_prd.source.ptr = NULL;\n  data_prd.read_callback = temporal_failure_data_source_read_callback;\n\n  stream_id = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                     &data_prd, NULL);\n\n  CU_ASSERT(stream_id > 0);\n\n  ud.frame_send_cb_called = 0;\n  ud.before_frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(1 == ud.before_frame_send_cb_called);\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  stream_id = nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 1, reqnv,\n                                          ARRLEN(reqnv), NULL);\n\n  CU_ASSERT(stream_id > 0);\n\n  ud.frame_send_cb_called = 0;\n  ud.before_frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(1 == ud.before_frame_send_cb_called);\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n}\n\nstatic void\nprepare_session_removed_closed_stream(nghttp2_session *session,\n                                      nghttp2_hd_deflater *deflater) {\n  int rv;\n  nghttp2_settings_entry iv;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  ssize_t nread;\n  int i;\n  nghttp2_stream *stream;\n  nghttp2_frame_hd hd;\n\n  mem = nghttp2_mem_default();\n\n  frame_pack_bufs_init(&bufs);\n\n  iv.settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv.value = 2;\n\n  rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  for (i = 1; i <= 3; i += 2) {\n    rv = pack_headers(&bufs, deflater, i,\n                      NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n                      ARRLEN(reqnv), mem);\n\n    CU_ASSERT(0 == rv);\n\n    nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                     nghttp2_bufs_len(&bufs));\n\n    CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n    nghttp2_bufs_reset(&bufs);\n  }\n\n  nghttp2_session_close_stream(session, 3, NGHTTP2_NO_ERROR);\n\n  rv = pack_headers(&bufs, deflater, 5,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n                    ARRLEN(reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  /* Receiving stream 5 will erase stream 3 from closed stream list */\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  stream = nghttp2_session_get_stream_raw(session, 3);\n\n  CU_ASSERT(NULL == stream);\n\n  /* Since the current max concurrent streams is\n     NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS, receiving frame on stream\n     3 is ignored. */\n  nghttp2_bufs_reset(&bufs);\n  rv = pack_headers(&bufs, deflater, 3,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    trailernv, ARRLEN(trailernv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 3);\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Now server receives SETTINGS ACK */\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_SETTINGS, NGHTTP2_FLAG_ACK, 0);\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_removed_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  int rv;\n  nghttp2_hd_deflater deflater;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  ssize_t nread;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Now local max concurrent streams is still unlimited, pending max\n     concurrent streams is now 2. */\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  prepare_session_removed_closed_stream(session, &deflater);\n\n  /* Now current max concurrent streams is 2.  Receiving frame on\n     stream 3 is ignored because we have no stream object for stream\n     3. */\n  nghttp2_bufs_reset(&bufs);\n  rv = pack_headers(&bufs, &deflater, 3,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    trailernv, ARRLEN(trailernv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL == item);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_hd_deflate_init(&deflater, mem);\n  /* Same setup, and then receive DATA instead of HEADERS */\n\n  prepare_session_removed_closed_stream(session, &deflater);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 3);\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL == item);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nstatic ssize_t pause_once_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = user_data;\n  if (ud->data_source_read_cb_paused == 0) {\n    ++ud->data_source_read_cb_paused;\n    return NGHTTP2_ERR_PAUSE;\n  }\n\n  return fixed_length_data_source_read_callback(session, stream_id, buf, len,\n                                                data_flags, source, user_data);\n}\n\nvoid test_nghttp2_session_pause_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  data_prd.read_callback = pause_once_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_read_cb_paused = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(NULL == session->aob.item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_DATA == ud.sent_frame_type);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_no_closed_streams(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_option *option;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_closed_streams(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, NULL, option);\n\n  open_recv_stream(session, 1);\n\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(0 == session->num_closed_streams);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_set_stream_user_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  int32_t stream_id;\n  int user_data1, user_data2;\n  int rv;\n  const uint8_t *datap;\n  ssize_t datalen;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  stream_id = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL,\n                                     &user_data1);\n\n  rv = nghttp2_session_set_stream_user_data(session, stream_id, &user_data2);\n\n  CU_ASSERT(0 == rv);\n\n  datalen = nghttp2_session_mem_send(session, &datap);\n\n  CU_ASSERT(datalen > 0);\n\n  CU_ASSERT(&user_data2 ==\n            nghttp2_session_get_stream_user_data(session, stream_id));\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_session_set_stream_user_data(session, 2, NULL));\n\n  nghttp2_session_del(session);\n}\n\nstatic void check_nghttp2_http_recv_headers_fail(\n    nghttp2_session *session, nghttp2_hd_deflater *deflater, int32_t stream_id,\n    int stream_state, const nghttp2_nv *nva, size_t nvlen) {\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_outbound_item *item;\n  nghttp2_bufs bufs;\n  my_user_data *ud;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  ud = session->user_data;\n\n  if (stream_state != -1) {\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      open_sent_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    } else {\n      open_recv_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    }\n  }\n\n  rv = pack_headers(&bufs, deflater, stream_id, NGHTTP2_FLAG_END_HEADERS, nva,\n                    nvlen, mem);\n  CU_ASSERT(0 == rv);\n\n  ud->invalid_frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == ud->invalid_frame_recv_cb_called);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_free(&bufs);\n}\n\nstatic void check_nghttp2_http_recv_headers_ok(\n    nghttp2_session *session, nghttp2_hd_deflater *deflater, int32_t stream_id,\n    int stream_state, const nghttp2_nv *nva, size_t nvlen) {\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_bufs bufs;\n  my_user_data *ud;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  ud = session->user_data;\n\n  if (stream_state != -1) {\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      open_sent_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    } else {\n      open_recv_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    }\n  }\n\n  rv = pack_headers(&bufs, deflater, stream_id, NGHTTP2_FLAG_END_HEADERS, nva,\n                    nvlen, mem);\n  CU_ASSERT(0 == rv);\n\n  ud->frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(1 == ud->frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_mandatory_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  my_user_data ud;\n  /* test case for response */\n  const nghttp2_nv nostatus_resnv[] = {MAKE_NV(\"server\", \"foo\")};\n  const nghttp2_nv dupstatus_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                        MAKE_NV(\":status\", \"200\")};\n  const nghttp2_nv badpseudo_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                        MAKE_NV(\":scheme\", \"https\")};\n  const nghttp2_nv latepseudo_resnv[] = {MAKE_NV(\"server\", \"foo\"),\n                                         MAKE_NV(\":status\", \"200\")};\n  const nghttp2_nv badstatus_resnv[] = {MAKE_NV(\":status\", \"2000\")};\n  const nghttp2_nv badcl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                    MAKE_NV(\"content-length\", \"-1\")};\n  const nghttp2_nv dupcl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                    MAKE_NV(\"content-length\", \"0\"),\n                                    MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv badhd_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                    MAKE_NV(\"connection\", \"close\")};\n  const nghttp2_nv cl1xx_resnv[] = {MAKE_NV(\":status\", \"100\"),\n                                    MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv cl204_resnv[] = {MAKE_NV(\":status\", \"204\"),\n                                    MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv clnonzero204_resnv[] = {MAKE_NV(\":status\", \"204\"),\n                                           MAKE_NV(\"content-length\", \"100\")};\n  const nghttp2_nv status101_resnv[] = {MAKE_NV(\":status\", \"101\")};\n\n  /* test case for request */\n  const nghttp2_nv nopath_reqnv[] = {MAKE_NV(\":scheme\", \"https\"),\n                                     MAKE_NV(\":method\", \"GET\"),\n                                     MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv earlyconnect_reqnv[] = {\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":path\", \"/\"), MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv lateconnect_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv duppath_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv badcl_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"POST\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\"content-length\", \"-1\")};\n  const nghttp2_nv dupcl_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"),        MAKE_NV(\":method\", \"POST\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\"content-length\", \"0\"),     MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv badhd_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\"connection\", \"close\")};\n  const nghttp2_nv badauthority_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\":authority\", \"\\x0d\\x0alocalhost\"), MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv badhdbtw_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\"foo\", \"\\x0d\\x0a\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv asteriskget1_reqnv[] = {\n      MAKE_NV(\":path\", \"*\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":method\", \"GET\")};\n  const nghttp2_nv asteriskget2_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":method\", \"GET\"), MAKE_NV(\":path\", \"*\")};\n  const nghttp2_nv asteriskoptions1_reqnv[] = {\n      MAKE_NV(\":path\", \"*\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":method\", \"OPTIONS\")};\n  const nghttp2_nv asteriskoptions2_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":method\", \"OPTIONS\"), MAKE_NV(\":path\", \"*\")};\n  const nghttp2_nv connectproto_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv connectprotoget_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"GET\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv connectprotonopath_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"CONNECT\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv connectprotonoauth_reqnv[] = {\n      MAKE_NV(\":scheme\", \"http\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\"host\", \"localhost\"),\n      MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv regularconnect_reqnv[] = {\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":authority\", \"localhost\")};\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* response header lacks :status */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 1,\n                                       NGHTTP2_STREAM_OPENING, nostatus_resnv,\n                                       ARRLEN(nostatus_resnv));\n\n  /* response header has 2 :status */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 3,\n                                       NGHTTP2_STREAM_OPENING, dupstatus_resnv,\n                                       ARRLEN(dupstatus_resnv));\n\n  /* response header has bad pseudo header :scheme */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 5,\n                                       NGHTTP2_STREAM_OPENING, badpseudo_resnv,\n                                       ARRLEN(badpseudo_resnv));\n\n  /* response header has :status after regular header field */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 7,\n                                       NGHTTP2_STREAM_OPENING, latepseudo_resnv,\n                                       ARRLEN(latepseudo_resnv));\n\n  /* response header has bad status code */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 9,\n                                       NGHTTP2_STREAM_OPENING, badstatus_resnv,\n                                       ARRLEN(badstatus_resnv));\n\n  /* response header has bad content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 11,\n                                       NGHTTP2_STREAM_OPENING, badcl_resnv,\n                                       ARRLEN(badcl_resnv));\n\n  /* response header has multiple content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 13,\n                                       NGHTTP2_STREAM_OPENING, dupcl_resnv,\n                                       ARRLEN(dupcl_resnv));\n\n  /* response header has disallowed header field */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 15,\n                                       NGHTTP2_STREAM_OPENING, badhd_resnv,\n                                       ARRLEN(badhd_resnv));\n\n  /* response header has content-length with 100 status code */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 17,\n                                       NGHTTP2_STREAM_OPENING, cl1xx_resnv,\n                                       ARRLEN(cl1xx_resnv));\n\n  /* response header has 0 content-length with 204 status code */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 19,\n                                     NGHTTP2_STREAM_OPENING, cl204_resnv,\n                                     ARRLEN(cl204_resnv));\n\n  /* response header has nonzero content-length with 204 status\n     code */\n  check_nghttp2_http_recv_headers_fail(\n      session, &deflater, 21, NGHTTP2_STREAM_OPENING, clnonzero204_resnv,\n      ARRLEN(clnonzero204_resnv));\n\n  /* status code 101 should not be used in HTTP/2 because it is used\n     for HTTP Upgrade which HTTP/2 removes. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 23,\n                                       NGHTTP2_STREAM_OPENING, status101_resnv,\n                                       ARRLEN(status101_resnv));\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  /* check server side */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* request header has no :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 1, -1, nopath_reqnv,\n                                       ARRLEN(nopath_reqnv));\n\n  /* request header has CONNECT method, but followed by :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 3, -1,\n                                       earlyconnect_reqnv,\n                                       ARRLEN(earlyconnect_reqnv));\n\n  /* request header has CONNECT method following :path */\n  check_nghttp2_http_recv_headers_fail(\n      session, &deflater, 5, -1, lateconnect_reqnv, ARRLEN(lateconnect_reqnv));\n\n  /* request header has multiple :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 7, -1, duppath_reqnv,\n                                       ARRLEN(duppath_reqnv));\n\n  /* request header has bad content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 9, -1, badcl_reqnv,\n                                       ARRLEN(badcl_reqnv));\n\n  /* request header has multiple content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 11, -1, dupcl_reqnv,\n                                       ARRLEN(dupcl_reqnv));\n\n  /* request header has disallowed header field */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 13, -1, badhd_reqnv,\n                                       ARRLEN(badhd_reqnv));\n\n  /* request header has :authority header field containing illegal\n     characters */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 15, -1,\n                                       badauthority_reqnv,\n                                       ARRLEN(badauthority_reqnv));\n\n  /* request header has regular header field containing illegal\n     character before all mandatory header fields are seen. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 17, -1,\n                                       badhdbtw_reqnv, ARRLEN(badhdbtw_reqnv));\n\n  /* request header has \"*\" in :path header field while method is GET.\n     :path is received before :method */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 19, -1,\n                                       asteriskget1_reqnv,\n                                       ARRLEN(asteriskget1_reqnv));\n\n  /* request header has \"*\" in :path header field while method is GET.\n     :method is received before :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 21, -1,\n                                       asteriskget2_reqnv,\n                                       ARRLEN(asteriskget2_reqnv));\n\n  /* OPTIONS method can include \"*\" in :path header field.  :path is\n     received before :method. */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 23, -1,\n                                     asteriskoptions1_reqnv,\n                                     ARRLEN(asteriskoptions1_reqnv));\n\n  /* OPTIONS method can include \"*\" in :path header field.  :method is\n     received before :path. */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 25, -1,\n                                     asteriskoptions2_reqnv,\n                                     ARRLEN(asteriskoptions2_reqnv));\n\n  /* :protocol is not allowed unless it is enabled by the local\n     endpoint. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 27, -1,\n                                       connectproto_reqnv,\n                                       ARRLEN(connectproto_reqnv));\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  /* enable SETTINGS_CONNECT_PROTOCOL */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  session->pending_enable_connect_protocol = 1;\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* :protocol is allowed if SETTINGS_CONNECT_PROTOCOL is enabled by\n     the local endpoint. */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 1, -1,\n                                     connectproto_reqnv,\n                                     ARRLEN(connectproto_reqnv));\n\n  /* :protocol is only allowed with CONNECT method. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 3, -1,\n                                       connectprotoget_reqnv,\n                                       ARRLEN(connectprotoget_reqnv));\n\n  /* CONNECT method with :protocol requires :path. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 5, -1,\n                                       connectprotonopath_reqnv,\n                                       ARRLEN(connectprotonopath_reqnv));\n\n  /* CONNECT method with :protocol requires :authority. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 7, -1,\n                                       connectprotonoauth_reqnv,\n                                       ARRLEN(connectprotonoauth_reqnv));\n\n  /* regular CONNECT method should succeed with\n     SETTINGS_CONNECT_PROTOCOL */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 9, -1,\n                                     regularconnect_reqnv,\n                                     ARRLEN(regularconnect_reqnv));\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_http_content_length(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  nghttp2_stream *stream;\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                 MAKE_NV(\"te\", \"trailers\"),\n                                 MAKE_NV(\"content-length\", \"9000000000\")};\n  const nghttp2_nv cl_reqnv[] = {\n      MAKE_NV(\":path\", \"/\"),        MAKE_NV(\":method\", \"PUT\"),\n      MAKE_NV(\":scheme\", \"https\"),  MAKE_NV(\"te\", \"trailers\"),\n      MAKE_NV(\"host\", \"localhost\"), MAKE_NV(\"content-length\", \"9000000000\")};\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(9000000000LL == stream->content_length);\n  CU_ASSERT(200 == stream->status_code);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* check server side */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, cl_reqnv,\n                    ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(9000000000LL == stream->content_length);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_content_length_mismatch(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv cl_reqnv[] = {\n      MAKE_NV(\":path\", \"/\"), MAKE_NV(\":method\", \"PUT\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\"content-length\", \"20\")};\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                 MAKE_NV(\"content-length\", \"20\")};\n  nghttp2_outbound_item *item;\n  nghttp2_frame_hd hd;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* header says content-length: 20, but HEADERS has END_STREAM flag set */\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    cl_reqnv, ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 0 byte */\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS, cl_reqnv,\n                    ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 3);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 21 bytes */\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, cl_reqnv,\n                    ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 21, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 5);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN + 21;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  /* Check for client */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* header says content-length: 20, but HEADERS has END_STREAM flag set */\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    cl_resnv, ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* After sending RST_STREAM, stream must be closed */\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 0 byte */\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 3);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 3));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* After sending RST_STREAM, stream must be closed */\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 3));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 21 bytes */\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 21, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 5);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN + 21;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 5));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* After sending RST_STREAM, stream must be closed */\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 5));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_bufs_free(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_http_non_final_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv nonfinal_resnv[] = {\n      MAKE_NV(\":status\", \"100\"),\n  };\n  nghttp2_outbound_item *item;\n  nghttp2_frame_hd hd;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* non-final HEADERS with END_STREAM is illegal */\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by non-empty DATA is illegal */\n  open_sent_stream2(session, 3, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 10, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 3);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN + 10;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by empty DATA (without END_STREAM) is\n     ok */\n  open_sent_stream2(session, 5, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 5);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by empty DATA (with END_STREAM) is\n     illegal */\n  open_sent_stream2(session, 7, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 7, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 7);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by final HEADERS is OK */\n  open_sent_stream2(session, 9, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 9, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 9, NGHTTP2_FLAG_END_HEADERS, resnv,\n                    ARRLEN(resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_trailer_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv trailer_reqnv[] = {\n      MAKE_NV(\"foo\", \"bar\"),\n  };\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* good trailer header */\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    trailer_reqnv, ARRLEN(trailer_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* trailer header without END_STREAM is illegal */\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS,\n                    trailer_reqnv, ARRLEN(trailer_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* trailer header including pseudo header field is illegal */\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_ignore_regular_header(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  my_user_data ud;\n  const nghttp2_nv bad_reqnv[] = {\n      MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\"foo\", \"\\x0zzz\"),\n      MAKE_NV(\"bar\", \"buzz\"),\n  };\n  const nghttp2_nv bad_ansnv[] = {\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":path\", \"/\"), MAKE_NV(\":method\", \"GET\"), MAKE_NV(\"bar\", \"buzz\")};\n  size_t proclen;\n  size_t i;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_header_callback = pause_on_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    bad_reqnv, ARRLEN(bad_reqnv), mem);\n\n  CU_ASSERT_FATAL(0 == rv);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  proclen = 0;\n\n  for (i = 0; i < 4; ++i) {\n    rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                  nghttp2_buf_len(&bufs.head->buf) - proclen);\n    CU_ASSERT_FATAL(rv > 0);\n    proclen += (size_t)rv;\n    CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[i], &ud.nv));\n  }\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                nghttp2_buf_len(&bufs.head->buf) - proclen);\n  CU_ASSERT_FATAL(rv > 0);\n  /* Without on_invalid_frame_recv_callback, bad header causes stream\n     reset */\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  proclen += (size_t)rv;\n\n  CU_ASSERT(nghttp2_buf_len(&bufs.head->buf) == proclen);\n\n  nghttp2_session_del(session);\n\n  /* use on_invalid_header_callback */\n  callbacks.on_invalid_header_callback = pause_on_invalid_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  proclen = 0;\n\n  ud.invalid_header_cb_called = 0;\n\n  for (i = 0; i < 4; ++i) {\n    rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                  nghttp2_buf_len(&bufs.head->buf) - proclen);\n    CU_ASSERT_FATAL(rv > 0);\n    proclen += (size_t)rv;\n    CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[i], &ud.nv));\n  }\n\n  CU_ASSERT(0 == ud.invalid_header_cb_called);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                nghttp2_buf_len(&bufs.head->buf) - proclen);\n\n  CU_ASSERT_FATAL(rv > 0);\n  CU_ASSERT(1 == ud.invalid_header_cb_called);\n  CU_ASSERT(nghttp2_nv_equal(&bad_reqnv[4], &ud.nv));\n\n  proclen += (size_t)rv;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                nghttp2_buf_len(&bufs.head->buf) - proclen);\n\n  CU_ASSERT(rv > 0);\n  CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[4], &ud.nv));\n\n  nghttp2_session_del(session);\n\n  /* make sure that we can reset stream from\n     on_invalid_header_callback */\n  callbacks.on_header_callback = on_header_callback;\n  callbacks.on_invalid_header_callback = reset_on_invalid_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT(rv == (ssize_t)nghttp2_buf_len(&bufs.head->buf));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_ignore_content_length(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"304\"),\n                                 MAKE_NV(\"content-length\", \"20\")};\n  const nghttp2_nv conn_reqnv[] = {MAKE_NV(\":authority\", \"localhost\"),\n                                   MAKE_NV(\":method\", \"CONNECT\"),\n                                   MAKE_NV(\"content-length\", \"999999\")};\n  const nghttp2_nv conn_cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                      MAKE_NV(\"content-length\", \"0\")};\n  nghttp2_stream *stream;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* If status 304, content-length must be ignored */\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    cl_resnv, ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Content-Length in 200 response to CONNECT is ignored */\n  stream = open_sent_stream2(session, 3, NGHTTP2_STREAM_OPENING);\n  stream->http_flags |= NGHTTP2_HTTP_FLAG_METH_CONNECT;\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS,\n                    conn_cl_resnv, ARRLEN(conn_cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(-1 == stream->content_length);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* If request method is CONNECT, content-length must be ignored */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, conn_reqnv,\n                    ARRLEN(conn_reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(-1 == stream->content_length);\n  CU_ASSERT((stream->http_flags & NGHTTP2_HTTP_FLAG_METH_CONNECT) > 0);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_record_request_method(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const nghttp2_nv conn_reqnv[] = {MAKE_NV(\":method\", \"CONNECT\"),\n                                   MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv conn_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                   MAKE_NV(\"content-length\", \"9999\")};\n  nghttp2_stream *stream;\n  ssize_t rv;\n  nghttp2_bufs bufs;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, conn_reqnv,\n                                        ARRLEN(conn_reqnv), NULL, NULL));\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_HTTP_FLAG_METH_CONNECT == stream->http_flags);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, conn_resnv,\n                    ARRLEN(conn_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT((NGHTTP2_HTTP_FLAG_METH_CONNECT & stream->http_flags) > 0);\n  CU_ASSERT(-1 == stream->content_length);\n\n  /* content-length is ignored in 200 response to a CONNECT request */\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL == item);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_push_promise(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  nghttp2_stream *stream;\n  const nghttp2_nv bad_reqnv[] = {MAKE_NV(\":method\", \"GET\")};\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  /* good PUSH_PROMISE case */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NULL != stream);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 2, NGHTTP2_FLAG_END_HEADERS, resnv,\n                    ARRLEN(resnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  CU_ASSERT(200 == stream->status_code);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* PUSH_PROMISE lacks mandatory header */\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 4,\n                         bad_reqnv, ARRLEN(bad_reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(4 == item->frame.hd.stream_id);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_head_method_upgrade_workaround(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                 MAKE_NV(\"content-length\", \"1000000007\")};\n  nghttp2_bufs bufs;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_stream *stream;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nghttp2_session_upgrade(session, NULL, 0, NULL);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(-1 == stream->content_length);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_SESSION_TEST_H\n#define NGHTTP2_SESSION_TEST_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\nvoid test_nghttp2_session_recv(void);\nvoid test_nghttp2_session_recv_invalid_stream_id(void);\nvoid test_nghttp2_session_recv_invalid_frame(void);\nvoid test_nghttp2_session_recv_eof(void);\nvoid test_nghttp2_session_recv_data(void);\nvoid test_nghttp2_session_recv_data_no_auto_flow_control(void);\nvoid test_nghttp2_session_recv_continuation(void);\nvoid test_nghttp2_session_recv_headers_with_priority(void);\nvoid test_nghttp2_session_recv_headers_with_padding(void);\nvoid test_nghttp2_session_recv_headers_early_response(void);\nvoid test_nghttp2_session_recv_headers_for_closed_stream(void);\nvoid test_nghttp2_session_server_recv_push_response(void);\nvoid test_nghttp2_session_recv_premature_headers(void);\nvoid test_nghttp2_session_recv_unknown_frame(void);\nvoid test_nghttp2_session_recv_unexpected_continuation(void);\nvoid test_nghttp2_session_recv_settings_header_table_size(void);\nvoid test_nghttp2_session_recv_too_large_frame_length(void);\nvoid test_nghttp2_session_recv_extension(void);\nvoid test_nghttp2_session_recv_altsvc(void);\nvoid test_nghttp2_session_recv_origin(void);\nvoid test_nghttp2_session_continue(void);\nvoid test_nghttp2_session_add_frame(void);\nvoid test_nghttp2_session_on_request_headers_received(void);\nvoid test_nghttp2_session_on_response_headers_received(void);\nvoid test_nghttp2_session_on_headers_received(void);\nvoid test_nghttp2_session_on_push_response_headers_received(void);\nvoid test_nghttp2_session_on_priority_received(void);\nvoid test_nghttp2_session_on_rst_stream_received(void);\nvoid test_nghttp2_session_on_settings_received(void);\nvoid test_nghttp2_session_on_push_promise_received(void);\nvoid test_nghttp2_session_on_ping_received(void);\nvoid test_nghttp2_session_on_goaway_received(void);\nvoid test_nghttp2_session_on_window_update_received(void);\nvoid test_nghttp2_session_on_data_received(void);\nvoid test_nghttp2_session_on_data_received_fail_fast(void);\nvoid test_nghttp2_session_on_altsvc_received(void);\nvoid test_nghttp2_session_send_headers_start_stream(void);\nvoid test_nghttp2_session_send_headers_reply(void);\nvoid test_nghttp2_session_send_headers_frame_size_error(void);\nvoid test_nghttp2_session_send_headers_push_reply(void);\nvoid test_nghttp2_session_send_rst_stream(void);\nvoid test_nghttp2_session_send_push_promise(void);\nvoid test_nghttp2_session_is_my_stream_id(void);\nvoid test_nghttp2_session_upgrade2(void);\nvoid test_nghttp2_session_reprioritize_stream(void);\nvoid test_nghttp2_session_reprioritize_stream_with_idle_stream_dep(void);\nvoid test_nghttp2_submit_data(void);\nvoid test_nghttp2_submit_data_read_length_too_large(void);\nvoid test_nghttp2_submit_data_read_length_smallest(void);\nvoid test_nghttp2_submit_data_twice(void);\nvoid test_nghttp2_submit_request_with_data(void);\nvoid test_nghttp2_submit_request_without_data(void);\nvoid test_nghttp2_submit_response_with_data(void);\nvoid test_nghttp2_submit_response_without_data(void);\nvoid test_nghttp2_submit_response_push_response(void);\nvoid test_nghttp2_submit_trailer(void);\nvoid test_nghttp2_submit_headers_start_stream(void);\nvoid test_nghttp2_submit_headers_reply(void);\nvoid test_nghttp2_submit_headers_push_reply(void);\nvoid test_nghttp2_submit_headers(void);\nvoid test_nghttp2_submit_headers_continuation(void);\nvoid test_nghttp2_submit_headers_continuation_extra_large(void);\nvoid test_nghttp2_submit_priority(void);\nvoid test_nghttp2_submit_settings(void);\nvoid test_nghttp2_submit_settings_update_local_window_size(void);\nvoid test_nghttp2_submit_settings_multiple_times(void);\nvoid test_nghttp2_submit_push_promise(void);\nvoid test_nghttp2_submit_window_update(void);\nvoid test_nghttp2_submit_window_update_local_window_size(void);\nvoid test_nghttp2_submit_shutdown_notice(void);\nvoid test_nghttp2_submit_invalid_nv(void);\nvoid test_nghttp2_submit_extension(void);\nvoid test_nghttp2_submit_altsvc(void);\nvoid test_nghttp2_submit_origin(void);\nvoid test_nghttp2_session_open_stream(void);\nvoid test_nghttp2_session_open_stream_with_idle_stream_dep(void);\nvoid test_nghttp2_session_get_next_ob_item(void);\nvoid test_nghttp2_session_pop_next_ob_item(void);\nvoid test_nghttp2_session_reply_fail(void);\nvoid test_nghttp2_session_max_concurrent_streams(void);\nvoid test_nghttp2_session_stop_data_with_rst_stream(void);\nvoid test_nghttp2_session_defer_data(void);\nvoid test_nghttp2_session_flow_control(void);\nvoid test_nghttp2_session_flow_control_data_recv(void);\nvoid test_nghttp2_session_flow_control_data_with_padding_recv(void);\nvoid test_nghttp2_session_data_read_temporal_failure(void);\nvoid test_nghttp2_session_on_stream_close(void);\nvoid test_nghttp2_session_on_ctrl_not_send(void);\nvoid test_nghttp2_session_get_outbound_queue_size(void);\nvoid test_nghttp2_session_get_effective_local_window_size(void);\nvoid test_nghttp2_session_set_option(void);\nvoid test_nghttp2_session_data_backoff_by_high_pri_frame(void);\nvoid test_nghttp2_session_pack_data_with_padding(void);\nvoid test_nghttp2_session_pack_headers_with_padding(void);\nvoid test_nghttp2_pack_settings_payload(void);\nvoid test_nghttp2_session_stream_dep_add(void);\nvoid test_nghttp2_session_stream_dep_remove(void);\nvoid test_nghttp2_session_stream_dep_add_subtree(void);\nvoid test_nghttp2_session_stream_dep_remove_subtree(void);\nvoid test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us(void);\nvoid test_nghttp2_session_stream_attach_item(void);\nvoid test_nghttp2_session_stream_attach_item_subtree(void);\nvoid test_nghttp2_session_stream_get_state(void);\nvoid test_nghttp2_session_stream_get_something(void);\nvoid test_nghttp2_session_find_stream(void);\nvoid test_nghttp2_session_keep_closed_stream(void);\nvoid test_nghttp2_session_keep_idle_stream(void);\nvoid test_nghttp2_session_detach_idle_stream(void);\nvoid test_nghttp2_session_large_dep_tree(void);\nvoid test_nghttp2_session_graceful_shutdown(void);\nvoid test_nghttp2_session_on_header_temporal_failure(void);\nvoid test_nghttp2_session_recv_client_magic(void);\nvoid test_nghttp2_session_delete_data_item(void);\nvoid test_nghttp2_session_open_idle_stream(void);\nvoid test_nghttp2_session_cancel_reserved_remote(void);\nvoid test_nghttp2_session_reset_pending_headers(void);\nvoid test_nghttp2_session_send_data_callback(void);\nvoid test_nghttp2_session_on_begin_headers_temporal_failure(void);\nvoid test_nghttp2_session_defer_then_close(void);\nvoid test_nghttp2_session_detach_item_from_closed_stream(void);\nvoid test_nghttp2_session_flooding(void);\nvoid test_nghttp2_session_change_stream_priority(void);\nvoid test_nghttp2_session_create_idle_stream(void);\nvoid test_nghttp2_session_repeated_priority_change(void);\nvoid test_nghttp2_session_repeated_priority_submission(void);\nvoid test_nghttp2_session_set_local_window_size(void);\nvoid test_nghttp2_session_cancel_from_before_frame_send(void);\nvoid test_nghttp2_session_removed_closed_stream(void);\nvoid test_nghttp2_session_pause_data(void);\nvoid test_nghttp2_session_no_closed_streams(void);\nvoid test_nghttp2_session_set_stream_user_data(void);\nvoid test_nghttp2_http_mandatory_headers(void);\nvoid test_nghttp2_http_content_length(void);\nvoid test_nghttp2_http_content_length_mismatch(void);\nvoid test_nghttp2_http_non_final_response(void);\nvoid test_nghttp2_http_trailer_headers(void);\nvoid test_nghttp2_http_ignore_regular_header(void);\nvoid test_nghttp2_http_ignore_content_length(void);\nvoid test_nghttp2_http_record_request_method(void);\nvoid test_nghttp2_http_push_promise(void);\nvoid test_nghttp2_http_head_method_upgrade_workaround(void);\n\n#endif /* NGHTTP2_SESSION_TEST_H */\n"], "fixing_code": ["# Generated documents\nset(APIDOCS\n  macros.rst\n  enums.rst\n  types.rst\n  nghttp2_check_header_name.rst\n  nghttp2_check_header_value.rst\n  nghttp2_hd_deflate_bound.rst\n  nghttp2_hd_deflate_change_table_size.rst\n  nghttp2_hd_deflate_del.rst\n  nghttp2_hd_deflate_get_dynamic_table_size.rst\n  nghttp2_hd_deflate_get_max_dynamic_table_size.rst\n  nghttp2_hd_deflate_get_num_table_entries.rst\n  nghttp2_hd_deflate_get_table_entry.rst\n  nghttp2_hd_deflate_hd.rst\n  nghttp2_hd_deflate_hd_vec.rst\n  nghttp2_hd_deflate_new.rst\n  nghttp2_hd_deflate_new2.rst\n  nghttp2_hd_inflate_change_table_size.rst\n  nghttp2_hd_inflate_del.rst\n  nghttp2_hd_inflate_end_headers.rst\n  nghttp2_hd_inflate_get_dynamic_table_size.rst\n  nghttp2_hd_inflate_get_max_dynamic_table_size.rst\n  nghttp2_hd_inflate_get_num_table_entries.rst\n  nghttp2_hd_inflate_get_table_entry.rst\n  nghttp2_hd_inflate_hd.rst\n  nghttp2_hd_inflate_hd2.rst\n  nghttp2_hd_inflate_new.rst\n  nghttp2_hd_inflate_new2.rst\n  nghttp2_http2_strerror.rst\n  nghttp2_is_fatal.rst\n  nghttp2_nv_compare_name.rst\n  nghttp2_option_del.rst\n  nghttp2_option_new.rst\n  nghttp2_option_set_builtin_recv_extension_type.rst\n  nghttp2_option_set_max_deflate_dynamic_table_size.rst\n  nghttp2_option_set_max_reserved_remote_streams.rst\n  nghttp2_option_set_max_send_header_block_length.rst\n  nghttp2_option_set_no_auto_ping_ack.rst\n  nghttp2_option_set_no_auto_window_update.rst\n  nghttp2_option_set_no_http_messaging.rst\n  nghttp2_option_set_no_recv_client_magic.rst\n  nghttp2_option_set_peer_max_concurrent_streams.rst\n  nghttp2_option_set_user_recv_extension_type.rst\n  nghttp2_option_set_max_settings.rst\n  nghttp2_pack_settings_payload.rst\n  nghttp2_priority_spec_check_default.rst\n  nghttp2_priority_spec_default_init.rst\n  nghttp2_priority_spec_init.rst\n  nghttp2_rcbuf_decref.rst\n  nghttp2_rcbuf_get_buf.rst\n  nghttp2_rcbuf_incref.rst\n  nghttp2_rcbuf_is_static.rst\n  nghttp2_select_next_protocol.rst\n  nghttp2_session_callbacks_del.rst\n  nghttp2_session_callbacks_new.rst\n  nghttp2_session_callbacks_set_before_frame_send_callback.rst\n  nghttp2_session_callbacks_set_data_source_read_length_callback.rst\n  nghttp2_session_callbacks_set_error_callback.rst\n  nghttp2_session_callbacks_set_on_begin_frame_callback.rst\n  nghttp2_session_callbacks_set_on_begin_headers_callback.rst\n  nghttp2_session_callbacks_set_on_data_chunk_recv_callback.rst\n  nghttp2_session_callbacks_set_on_extension_chunk_recv_callback.rst\n  nghttp2_session_callbacks_set_on_frame_not_send_callback.rst\n  nghttp2_session_callbacks_set_on_frame_recv_callback.rst\n  nghttp2_session_callbacks_set_on_frame_send_callback.rst\n  nghttp2_session_callbacks_set_on_header_callback.rst\n  nghttp2_session_callbacks_set_on_header_callback2.rst\n  nghttp2_session_callbacks_set_on_invalid_frame_recv_callback.rst\n  nghttp2_session_callbacks_set_on_invalid_header_callback.rst\n  nghttp2_session_callbacks_set_on_invalid_header_callback2.rst\n  nghttp2_session_callbacks_set_on_stream_close_callback.rst\n  nghttp2_session_callbacks_set_pack_extension_callback.rst\n  nghttp2_session_callbacks_set_recv_callback.rst\n  nghttp2_session_callbacks_set_select_padding_callback.rst\n  nghttp2_session_callbacks_set_send_callback.rst\n  nghttp2_session_callbacks_set_send_data_callback.rst\n  nghttp2_session_callbacks_set_unpack_extension_callback.rst\n  nghttp2_session_change_stream_priority.rst\n  nghttp2_session_check_request_allowed.rst\n  nghttp2_session_check_server_session.rst\n  nghttp2_session_client_new.rst\n  nghttp2_session_client_new2.rst\n  nghttp2_session_client_new3.rst\n  nghttp2_session_consume.rst\n  nghttp2_session_consume_connection.rst\n  nghttp2_session_consume_stream.rst\n  nghttp2_session_create_idle_stream.rst\n  nghttp2_session_del.rst\n  nghttp2_session_find_stream.rst\n  nghttp2_session_get_effective_local_window_size.rst\n  nghttp2_session_get_effective_recv_data_length.rst\n  nghttp2_session_get_hd_deflate_dynamic_table_size.rst\n  nghttp2_session_get_hd_inflate_dynamic_table_size.rst\n  nghttp2_session_get_last_proc_stream_id.rst\n  nghttp2_session_get_local_settings.rst\n  nghttp2_session_get_local_window_size.rst\n  nghttp2_session_get_next_stream_id.rst\n  nghttp2_session_get_outbound_queue_size.rst\n  nghttp2_session_get_remote_settings.rst\n  nghttp2_session_get_remote_window_size.rst\n  nghttp2_session_get_root_stream.rst\n  nghttp2_session_get_stream_effective_local_window_size.rst\n  nghttp2_session_get_stream_effective_recv_data_length.rst\n  nghttp2_session_get_stream_local_close.rst\n  nghttp2_session_get_stream_local_window_size.rst\n  nghttp2_session_get_stream_remote_close.rst\n  nghttp2_session_get_stream_remote_window_size.rst\n  nghttp2_session_get_stream_user_data.rst\n  nghttp2_session_mem_recv.rst\n  nghttp2_session_mem_send.rst\n  nghttp2_session_recv.rst\n  nghttp2_session_resume_data.rst\n  nghttp2_session_send.rst\n  nghttp2_session_server_new.rst\n  nghttp2_session_server_new2.rst\n  nghttp2_session_server_new3.rst\n  nghttp2_session_set_local_window_size.rst\n  nghttp2_session_set_next_stream_id.rst\n  nghttp2_session_set_stream_user_data.rst\n  nghttp2_session_terminate_session.rst\n  nghttp2_session_terminate_session2.rst\n  nghttp2_session_upgrade.rst\n  nghttp2_session_upgrade2.rst\n  nghttp2_session_want_read.rst\n  nghttp2_session_want_write.rst\n  nghttp2_set_debug_vprintf_callback.rst\n  nghttp2_stream_get_first_child.rst\n  nghttp2_stream_get_next_sibling.rst\n  nghttp2_stream_get_parent.rst\n  nghttp2_stream_get_previous_sibling.rst\n  nghttp2_stream_get_state.rst\n  nghttp2_stream_get_sum_dependency_weight.rst\n  nghttp2_stream_get_weight.rst\n  nghttp2_strerror.rst\n  nghttp2_submit_altsvc.rst\n  nghttp2_submit_data.rst\n  nghttp2_submit_extension.rst\n  nghttp2_submit_goaway.rst\n  nghttp2_submit_headers.rst\n  nghttp2_submit_ping.rst\n  nghttp2_submit_priority.rst\n  nghttp2_submit_push_promise.rst\n  nghttp2_submit_request.rst\n  nghttp2_submit_response.rst\n  nghttp2_submit_rst_stream.rst\n  nghttp2_submit_settings.rst\n  nghttp2_submit_shutdown_notice.rst\n  nghttp2_submit_trailer.rst\n  nghttp2_submit_window_update.rst\n  nghttp2_version.rst\n)\n\nset(MAN_PAGES\n  nghttp.1\n  nghttpd.1\n  nghttpx.1\n  h2load.1\n)\n\n# Other .rst files from the source tree that need to be copied\n# XXX move them to sources/ and create .in files?\nset(RST_FILES\n  README.rst\n  programmers-guide.rst\n  nghttp.1.rst\n  nghttpd.1.rst\n  nghttpx.1.rst\n  h2load.1.rst\n)\n\n# XXX unused for now\nset(EXTRA_DIST\n  mkapiref.py\n  ${RST_FILES}\n  ${APIDOCS}\n  sources/index.rst\n  sources/tutorial-client.rst\n  sources/tutorial-server.rst\n  sources/tutorial-hpack.rst\n  sources/nghttpx-howto.rst\n  sources/h2load-howto.rst\n  sources/libnghttp2_asio.rst\n  sources/python-apiref.rst\n  sources/building-android-binary.rst\n  sources/contribute.rst\n  _exts/sphinxcontrib/LICENSE.rubydomain\n  _exts/sphinxcontrib/__init__.py\n  _exts/sphinxcontrib/rubydomain.py\n  _themes/sphinx_rtd_theme/__init__.py\n  _themes/sphinx_rtd_theme/breadcrumbs.html\n  _themes/sphinx_rtd_theme/footer.html\n  _themes/sphinx_rtd_theme/layout.html\n  _themes/sphinx_rtd_theme/layout_old.html\n  _themes/sphinx_rtd_theme/search.html\n  _themes/sphinx_rtd_theme/searchbox.html\n  _themes/sphinx_rtd_theme/static/css/badge_only.css\n  _themes/sphinx_rtd_theme/static/css/theme.css\n  _themes/sphinx_rtd_theme/static/fonts/FontAwesome.otf\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.svg\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf\n  _themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff\n  _themes/sphinx_rtd_theme/static/js/theme.js\n  _themes/sphinx_rtd_theme/theme.conf\n  _themes/sphinx_rtd_theme/versions.html\n  ${MAN_PAGES}\n  bash_completion/nghttp\n  bash_completion/nghttpd\n  bash_completion/nghttpx\n  bash_completion/h2load\n)\n\n# Based on Makefile for Sphinx documentation\n\n# You can set these variables from the command line.\nset(SPHINXOPTS)\nset(SPHINXBUILD sphinx-build)\nset(PAPER)\nset(BUILDDIR    manual)\n\n# Internal variables.\nset(PAPEROPT_a4     -D latex_paper_size=a4)\nset(PAPEROPT_letter -D latex_paper_size=letter)\nset(ALLSPHINXOPTS   -d ${BUILDDIR}/doctrees ${PAPEROPT_${PAPER}} ${SPHINXOPTS} .)\n\n# \"Please use `make <target>' where <target> is one of\"\n# \"  html       to make standalone HTML files\"\n# \"  dirhtml    to make HTML files named index.html in directories\"\n# \"  singlehtml to make a single large HTML file\"\n# \"  pickle     to make pickle files\"\n# \"  json       to make JSON files\"\n# \"  htmlhelp   to make HTML files and a HTML help project\"\n# \"  qthelp     to make HTML files and a qthelp project\"\n# \"  devhelp    to make HTML files and a Devhelp project\"\n# \"  epub       to make an epub\"\n# \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n# \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n# \"  text       to make text files\"\n# \"  man        to make manual pages\"\n# \"  changes    to make an overview of all changed/added/deprecated items\"\n# \"  linkcheck  to check all external links for integrity\"\n# \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n\n\n# Copy files for out-of-tree builds\nif(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)\n  set(RST_BUILD_FILES)\n  foreach(rstfile IN LISTS RST_FILES)\n    set(outfile \"${CMAKE_CURRENT_BINARY_DIR}/${rstfile}\")\n    add_custom_command(OUTPUT \"${outfile}\"\n      COMMAND ${CMAKE_COMMAND} -E copy\n              \"${CMAKE_CURRENT_SOURCE_DIR}/${rstfile}\" \"${outfile}\"\n      DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/${rstfile}\"\n    )\n    list(APPEND RST_BUILD_FILES \"${outfile}\")\n  endforeach()\nelse()\n  set(RST_BUILD_FILES \"${RST_FILES}\")\nendif()\n\nset(apiref_SOURCES\n  ${CMAKE_BINARY_DIR}/lib/includes/nghttp2/nghttp2ver.h\n  ${CMAKE_SOURCE_DIR}/lib/includes/nghttp2/nghttp2.h\n)\n# Generates apiref.rst and other files\nadd_custom_command(\n  OUTPUT\n    apiref.rst\n    ${APIDOCS}\n  COMMAND\n    \"${PYTHON_EXECUTABLE}\" \"${CMAKE_CURRENT_SOURCE_DIR}/mkapiref.py\"\n    apiref.rst macros.rst enums.rst types.rst .\n    ${apiref_SOURCES}\n  DEPENDS\n    ${RST_BUILD_FILES}\n    ${apiref_SOURCES}\n)\n\n\n\nset_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES \"${BUILDDIR}\")\n\n# Invokes sphinx-build and prints the given messages when completed\nfunction(sphinxbuild builder)\n  set(echo_commands)\n  foreach(message IN LISTS ARGN)\n    list(APPEND echo_commands COMMAND ${CMAKE_COMMAND} -E echo \"${message}\")\n  endforeach()\n  add_custom_target(${builder}\n    COMMAND \"${SPHINXBUILD}\" -b ${builder} ${ALLSPHINXOPTS} \"${BUILDDIR}/${builder}\"\n    COMMAND ${CMAKE_COMMAND} -E echo\n    ${echo_commands}\n    VERBATIM\n    DEPENDS apiref.rst\n  )\nendfunction()\n\nforeach(builder html dirhtml singlehtml)\n  sphinxbuild(${builder}\n    \"Build finished. The HTML pages are in ${BUILDDIR}/${builder}.\")\nendforeach()\nsphinxbuild(pickle  \"Build finished; now you can process the pickle files.\")\nsphinxbuild(json    \"Build finished; now you can process the JSON files.\")\nsphinxbuild(htmlhelp\n  \"Build finished; now you can run HTML Help Workshop with the\"\n  \".hhp project file in ${BUILDDIR}/htmlhelp.\"\n)\nsphinxbuild(qthelp\n  \"Build finished; now you can run \\\"qcollectiongenerator\\\" with the\"\n  \".qhcp project file in ${BUILDDIR}/qthelp, like this:\"\n  \"# qcollectiongenerator ${BUILDDIR}/qthelp/nghttp2.qhcp\"\n  \"To view the help file:\"\n  \"# assistant -collectionFile ${BUILDDIR}/qthelp/nghttp2.qhc\"\n)\nsphinxbuild(devhelp\n  \"Build finished.\"\n  \"To view the help file:\"\n  \"# mkdir -p ~/.local/share/devhelp/nghttp2\"\n  \"# ln -s ${BUILDDIR}/devhelp ~/.local/share/devhelp/nghttp2\"\n  \"# devhelp\"\n)\nsphinxbuild(epub    \"Build finished. The epub file is in ${BUILDDIR}/epub.\")\nsphinxbuild(latex\n  \"Build finished; the LaTeX files are in ${BUILDDIR}/latex.\"\n  \"Run `make' in that directory to run these through (pdf)latex\"\n  \"(use `make latexpdf' here to do that automatically).\"\n)\n\n# Invoke the Makefile generated by sphinx\nadd_custom_target(latexpdf\n  COMMAND ${CMAKE_COMMAND} -E echo \"Running LaTeX files through pdflatex...\"\n  COMMAND make -C \"${BUILDDIR}/latex\" all-pdf\n  COMMAND ${CMAKE_COMMAND} -E echo \"pdflatex finished; the PDF files are in ${BUILDDIR}/latex.\"\n  DEPENDS latex\n)\n\nsphinxbuild(text    \"Build finished. The text files are in ${BUILDDIR}/text.\")\nsphinxbuild(man     \"Build finished. The manual pages are in ${BUILDDIR}/man.\")\nsphinxbuild(changes \"The overview file is in ${BUILDDIR}/changes.\")\nsphinxbuild(linkcheck\n  \"Link check complete; look for any errors in the above output\"\n  \"or in ${BUILDDIR}/linkcheck/output.txt.\"\n)\nsphinxbuild(doctest\n  \"Testing of doctests in the sources finished, look at the\"\n  \"results in ${BUILDDIR}/doctest/output.txt.\"\n)\n\nforeach(_man_page IN LISTS MAN_PAGES)\n  install(FILES ${_man_page}\n    DESTINATION \"${CMAKE_INSTALL_MANDIR}/man1\"\n  )\nendforeach()\n", "# nghttp2 - HTTP/2 C Library\n\n# Copyright (c) 2012 Tatsuhiro Tsujikawa\n\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nman_MANS = nghttp.1 nghttpd.1 nghttpx.1 h2load.1\n\nAPIDOCS= \\\n\tmacros.rst \\\n\tenums.rst \\\n\ttypes.rst \\\n\tnghttp2_check_authority.rst \\\n\tnghttp2_check_header_name.rst \\\n\tnghttp2_check_header_value.rst \\\n\tnghttp2_hd_deflate_bound.rst \\\n\tnghttp2_hd_deflate_change_table_size.rst \\\n\tnghttp2_hd_deflate_del.rst \\\n\tnghttp2_hd_deflate_get_dynamic_table_size.rst \\\n\tnghttp2_hd_deflate_get_max_dynamic_table_size.rst \\\n\tnghttp2_hd_deflate_get_num_table_entries.rst \\\n\tnghttp2_hd_deflate_get_table_entry.rst \\\n\tnghttp2_hd_deflate_hd.rst \\\n\tnghttp2_hd_deflate_hd_vec.rst \\\n\tnghttp2_hd_deflate_new.rst \\\n\tnghttp2_hd_deflate_new2.rst \\\n\tnghttp2_hd_inflate_change_table_size.rst \\\n\tnghttp2_hd_inflate_del.rst \\\n\tnghttp2_hd_inflate_end_headers.rst \\\n\tnghttp2_hd_inflate_get_dynamic_table_size.rst \\\n\tnghttp2_hd_inflate_get_max_dynamic_table_size.rst \\\n\tnghttp2_hd_inflate_get_num_table_entries.rst \\\n\tnghttp2_hd_inflate_get_table_entry.rst \\\n\tnghttp2_hd_inflate_hd.rst \\\n\tnghttp2_hd_inflate_hd2.rst \\\n\tnghttp2_hd_inflate_new.rst \\\n\tnghttp2_hd_inflate_new2.rst \\\n\tnghttp2_http2_strerror.rst \\\n\tnghttp2_is_fatal.rst \\\n\tnghttp2_nv_compare_name.rst \\\n\tnghttp2_option_del.rst \\\n\tnghttp2_option_new.rst \\\n\tnghttp2_option_set_builtin_recv_extension_type.rst \\\n\tnghttp2_option_set_max_deflate_dynamic_table_size.rst \\\n\tnghttp2_option_set_max_reserved_remote_streams.rst \\\n\tnghttp2_option_set_max_send_header_block_length.rst \\\n\tnghttp2_option_set_no_auto_ping_ack.rst \\\n\tnghttp2_option_set_no_auto_window_update.rst \\\n\tnghttp2_option_set_no_closed_streams.rst \\\n\tnghttp2_option_set_no_http_messaging.rst \\\n\tnghttp2_option_set_no_recv_client_magic.rst \\\n\tnghttp2_option_set_peer_max_concurrent_streams.rst \\\n\tnghttp2_option_set_user_recv_extension_type.rst \\\n\tnghttp2_option_set_max_outbound_ack.rst \\\n\tnghttp2_option_set_max_settings.rst \\\n\tnghttp2_pack_settings_payload.rst \\\n\tnghttp2_priority_spec_check_default.rst \\\n\tnghttp2_priority_spec_default_init.rst \\\n\tnghttp2_priority_spec_init.rst \\\n\tnghttp2_rcbuf_decref.rst \\\n\tnghttp2_rcbuf_get_buf.rst \\\n\tnghttp2_rcbuf_incref.rst \\\n\tnghttp2_rcbuf_is_static.rst \\\n\tnghttp2_select_next_protocol.rst \\\n\tnghttp2_session_callbacks_del.rst \\\n\tnghttp2_session_callbacks_new.rst \\\n\tnghttp2_session_callbacks_set_before_frame_send_callback.rst \\\n\tnghttp2_session_callbacks_set_data_source_read_length_callback.rst \\\n\tnghttp2_session_callbacks_set_error_callback.rst \\\n\tnghttp2_session_callbacks_set_error_callback2.rst \\\n\tnghttp2_session_callbacks_set_on_begin_frame_callback.rst \\\n\tnghttp2_session_callbacks_set_on_begin_headers_callback.rst \\\n\tnghttp2_session_callbacks_set_on_data_chunk_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_extension_chunk_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_frame_not_send_callback.rst \\\n\tnghttp2_session_callbacks_set_on_frame_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_frame_send_callback.rst \\\n\tnghttp2_session_callbacks_set_on_header_callback.rst \\\n\tnghttp2_session_callbacks_set_on_header_callback2.rst \\\n\tnghttp2_session_callbacks_set_on_invalid_frame_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_on_invalid_header_callback.rst \\\n\tnghttp2_session_callbacks_set_on_invalid_header_callback2.rst \\\n\tnghttp2_session_callbacks_set_on_stream_close_callback.rst \\\n\tnghttp2_session_callbacks_set_pack_extension_callback.rst \\\n\tnghttp2_session_callbacks_set_recv_callback.rst \\\n\tnghttp2_session_callbacks_set_select_padding_callback.rst \\\n\tnghttp2_session_callbacks_set_send_callback.rst \\\n\tnghttp2_session_callbacks_set_send_data_callback.rst \\\n\tnghttp2_session_callbacks_set_unpack_extension_callback.rst \\\n\tnghttp2_session_change_stream_priority.rst \\\n\tnghttp2_session_check_request_allowed.rst \\\n\tnghttp2_session_check_server_session.rst \\\n\tnghttp2_session_client_new.rst \\\n\tnghttp2_session_client_new2.rst \\\n\tnghttp2_session_client_new3.rst \\\n\tnghttp2_session_consume.rst \\\n\tnghttp2_session_consume_connection.rst \\\n\tnghttp2_session_consume_stream.rst \\\n\tnghttp2_session_create_idle_stream.rst \\\n\tnghttp2_session_del.rst \\\n\tnghttp2_session_find_stream.rst \\\n\tnghttp2_session_get_effective_local_window_size.rst \\\n\tnghttp2_session_get_effective_recv_data_length.rst \\\n\tnghttp2_session_get_hd_deflate_dynamic_table_size.rst \\\n\tnghttp2_session_get_hd_inflate_dynamic_table_size.rst \\\n\tnghttp2_session_get_last_proc_stream_id.rst \\\n\tnghttp2_session_get_local_settings.rst \\\n\tnghttp2_session_get_local_window_size.rst \\\n\tnghttp2_session_get_next_stream_id.rst \\\n\tnghttp2_session_get_outbound_queue_size.rst \\\n\tnghttp2_session_get_remote_settings.rst \\\n\tnghttp2_session_get_remote_window_size.rst \\\n\tnghttp2_session_get_root_stream.rst \\\n\tnghttp2_session_get_stream_effective_local_window_size.rst \\\n\tnghttp2_session_get_stream_effective_recv_data_length.rst \\\n\tnghttp2_session_get_stream_local_close.rst \\\n\tnghttp2_session_get_stream_local_window_size.rst \\\n\tnghttp2_session_get_stream_remote_close.rst \\\n\tnghttp2_session_get_stream_remote_window_size.rst \\\n\tnghttp2_session_get_stream_user_data.rst \\\n\tnghttp2_session_mem_recv.rst \\\n\tnghttp2_session_mem_send.rst \\\n\tnghttp2_session_recv.rst \\\n\tnghttp2_session_resume_data.rst \\\n\tnghttp2_session_send.rst \\\n\tnghttp2_session_server_new.rst \\\n\tnghttp2_session_server_new2.rst \\\n\tnghttp2_session_server_new3.rst \\\n\tnghttp2_session_set_local_window_size.rst \\\n\tnghttp2_session_set_next_stream_id.rst \\\n\tnghttp2_session_set_stream_user_data.rst \\\n\tnghttp2_session_set_user_data.rst \\\n\tnghttp2_session_terminate_session.rst \\\n\tnghttp2_session_terminate_session2.rst \\\n\tnghttp2_session_upgrade.rst \\\n\tnghttp2_session_upgrade2.rst \\\n\tnghttp2_session_want_read.rst \\\n\tnghttp2_session_want_write.rst \\\n\tnghttp2_set_debug_vprintf_callback.rst \\\n\tnghttp2_stream_get_first_child.rst \\\n\tnghttp2_stream_get_next_sibling.rst \\\n\tnghttp2_stream_get_parent.rst \\\n\tnghttp2_stream_get_previous_sibling.rst \\\n\tnghttp2_stream_get_state.rst \\\n\tnghttp2_stream_get_sum_dependency_weight.rst \\\n\tnghttp2_stream_get_weight.rst \\\n\tnghttp2_strerror.rst \\\n\tnghttp2_submit_altsvc.rst \\\n\tnghttp2_submit_data.rst \\\n\tnghttp2_submit_extension.rst \\\n\tnghttp2_submit_goaway.rst \\\n\tnghttp2_submit_headers.rst \\\n\tnghttp2_submit_origin.rst \\\n\tnghttp2_submit_ping.rst \\\n\tnghttp2_submit_priority.rst \\\n\tnghttp2_submit_push_promise.rst \\\n\tnghttp2_submit_request.rst \\\n\tnghttp2_submit_response.rst \\\n\tnghttp2_submit_rst_stream.rst \\\n\tnghttp2_submit_settings.rst \\\n\tnghttp2_submit_shutdown_notice.rst \\\n\tnghttp2_submit_trailer.rst \\\n\tnghttp2_submit_window_update.rst \\\n\tnghttp2_version.rst\n\nRST_FILES = \\\n\tREADME.rst \\\n\tprogrammers-guide.rst \\\n\tnghttp.1.rst \\\n\tnghttpd.1.rst \\\n\tnghttpx.1.rst \\\n\th2load.1.rst\n\nEXTRA_DIST = \\\n\tCMakeLists.txt \\\n\tmkapiref.py \\\n\t$(RST_FILES) \\\n\t$(APIDOCS) \\\n\tsources/index.rst \\\n\tsources/tutorial-client.rst \\\n\tsources/tutorial-server.rst \\\n\tsources/tutorial-hpack.rst \\\n\tsources/nghttpx-howto.rst \\\n\tsources/h2load-howto.rst \\\n\tsources/libnghttp2_asio.rst \\\n\tsources/python-apiref.rst \\\n\tsources/building-android-binary.rst \\\n\tsources/contribute.rst \\\n\t_exts/sphinxcontrib/LICENSE.rubydomain \\\n\t_exts/sphinxcontrib/__init__.py \\\n\t_exts/sphinxcontrib/rubydomain.py \\\n\t_themes/sphinx_rtd_theme/__init__.py \\\n\t_themes/sphinx_rtd_theme/breadcrumbs.html \\\n\t_themes/sphinx_rtd_theme/footer.html \\\n\t_themes/sphinx_rtd_theme/layout.html \\\n\t_themes/sphinx_rtd_theme/layout_old.html \\\n\t_themes/sphinx_rtd_theme/search.html \\\n\t_themes/sphinx_rtd_theme/searchbox.html \\\n\t_themes/sphinx_rtd_theme/static/css/badge_only.css \\\n\t_themes/sphinx_rtd_theme/static/css/theme.css \\\n\t_themes/sphinx_rtd_theme/static/fonts/FontAwesome.otf \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.svg \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf \\\n\t_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff \\\n\t_themes/sphinx_rtd_theme/static/js/theme.js \\\n\t_themes/sphinx_rtd_theme/theme.conf \\\n\t_themes/sphinx_rtd_theme/versions.html \\\n\t$(man_MANS) \\\n\tbash_completion/nghttp \\\n\tbash_completion/nghttpd \\\n\tbash_completion/nghttpx \\\n\tbash_completion/h2load\n\n# Makefile for Sphinx documentation\n#\n\n# You can set these variables from the command line.\nSPHINXOPTS    =\nSPHINXBUILD   = sphinx-build\nPAPER         =\nBUILDDIR      = manual\n\n# Internal variables.\nPAPEROPT_a4     = -D latex_paper_size=a4\nPAPEROPT_letter = -D latex_paper_size=letter\nALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .\n\n.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest\n\nhelp:\n\t@echo \"Please use \\`make <target>' where <target> is one of\"\n\t@echo \"  html       to make standalone HTML files\"\n\t@echo \"  dirhtml    to make HTML files named index.html in directories\"\n\t@echo \"  singlehtml to make a single large HTML file\"\n\t@echo \"  pickle     to make pickle files\"\n\t@echo \"  json       to make JSON files\"\n\t@echo \"  htmlhelp   to make HTML files and a HTML help project\"\n\t@echo \"  qthelp     to make HTML files and a qthelp project\"\n\t@echo \"  devhelp    to make HTML files and a Devhelp project\"\n\t@echo \"  epub       to make an epub\"\n\t@echo \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n\t@echo \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n\t@echo \"  text       to make text files\"\n\t@echo \"  man        to make manual pages\"\n\t@echo \"  changes    to make an overview of all changed/added/deprecated items\"\n\t@echo \"  linkcheck  to check all external links for integrity\"\n\t@echo \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n\napiref.rst: \\\n\t$(top_builddir)/lib/includes/nghttp2/nghttp2ver.h \\\n\t$(top_srcdir)/lib/includes/nghttp2/nghttp2.h\n\tfor i in $(RST_FILES); do [ -e $(builddir)/$$i ] || cp $(srcdir)/$$i $(builddir); done\n\t$(PYTHON) $(top_srcdir)/doc/mkapiref.py \\\n\tapiref.rst macros.rst enums.rst types.rst . $^\n\n$(APIDOCS): apiref.rst\n\nclean-local:\n\tif [ $(srcdir) != $(builddir) ]; then for i in $(RST_FILES); do rm -f $(builddir)/$$i; done fi\n\t-rm -f apiref.rst\n\t-rm -f $(APIDOCS)\n\t-rm -rf $(BUILDDIR)/*\n\nhtml-local: apiref.rst\n\t$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/html.\"\n\ndirhtml:\n\t$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/dirhtml.\"\n\nsinglehtml:\n\t$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml\n\t@echo\n\t@echo \"Build finished. The HTML page is in $(BUILDDIR)/singlehtml.\"\n\npickle:\n\t$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle\n\t@echo\n\t@echo \"Build finished; now you can process the pickle files.\"\n\njson:\n\t$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json\n\t@echo\n\t@echo \"Build finished; now you can process the JSON files.\"\n\nhtmlhelp:\n\t$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp\n\t@echo\n\t@echo \"Build finished; now you can run HTML Help Workshop with the\" \\\n\t      \".hhp project file in $(BUILDDIR)/htmlhelp.\"\n\nqthelp:\n\t$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp\n\t@echo\n\t@echo \"Build finished; now you can run \"qcollectiongenerator\" with the\" \\\n\t      \".qhcp project file in $(BUILDDIR)/qthelp, like this:\"\n\t@echo \"# qcollectiongenerator $(BUILDDIR)/qthelp/nghttp2.qhcp\"\n\t@echo \"To view the help file:\"\n\t@echo \"# assistant -collectionFile $(BUILDDIR)/qthelp/nghttp2.qhc\"\n\ndevhelp:\n\t$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp\n\t@echo\n\t@echo \"Build finished.\"\n\t@echo \"To view the help file:\"\n\t@echo \"# mkdir -p $$HOME/.local/share/devhelp/nghttp2\"\n\t@echo \"# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/nghttp2\"\n\t@echo \"# devhelp\"\n\nepub:\n\t$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub\n\t@echo\n\t@echo \"Build finished. The epub file is in $(BUILDDIR)/epub.\"\n\nlatex:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo\n\t@echo \"Build finished; the LaTeX files are in $(BUILDDIR)/latex.\"\n\t@echo \"Run \\`make' in that directory to run these through (pdf)latex\" \\\n\t      \"(use \\`make latexpdf' here to do that automatically).\"\n\nlatexpdf:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo \"Running LaTeX files through pdflatex...\"\n\t$(MAKE) -C $(BUILDDIR)/latex all-pdf\n\t@echo \"pdflatex finished; the PDF files are in $(BUILDDIR)/latex.\"\n\ntext:\n\t$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text\n\t@echo\n\t@echo \"Build finished. The text files are in $(BUILDDIR)/text.\"\n\nman: apiref.rst\n\t$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man\n\t@echo\n\t@echo \"Build finished. The manual pages are in $(BUILDDIR)/man.\"\n\nchanges:\n\t$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes\n\t@echo\n\t@echo \"The overview file is in $(BUILDDIR)/changes.\"\n\nlinkcheck:\n\t$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck\n\t@echo\n\t@echo \"Link check complete; look for any errors in the above output \" \\\n\t      \"or in $(BUILDDIR)/linkcheck/output.txt.\"\n\ndoctest:\n\t$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest\n\t@echo \"Testing of doctests in the sources finished, look at the \" \\\n\t      \"results in $(BUILDDIR)/doctest/output.txt.\"\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2013, 2014 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_H\n#define NGHTTP2_H\n\n/* Define WIN32 when build target is Win32 API (borrowed from\n   libcurl) */\n#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n#  define WIN32\n#endif\n\n/* Compatibility for non-Clang compilers */\n#ifndef __has_declspec_attribute\n#  define __has_declspec_attribute(x) 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdlib.h>\n#if defined(_MSC_VER) && (_MSC_VER < 1800)\n/* MSVC < 2013 does not have inttypes.h because it is not C99\n   compliant.  See compiler macros and version number in\n   https://sourceforge.net/p/predef/wiki/Compilers/ */\n#  include <stdint.h>\n#else /* !defined(_MSC_VER) || (_MSC_VER >= 1800) */\n#  include <inttypes.h>\n#endif /* !defined(_MSC_VER) || (_MSC_VER >= 1800) */\n#include <sys/types.h>\n#include <stdarg.h>\n\n#include <nghttp2/nghttp2ver.h>\n\n#ifdef NGHTTP2_STATICLIB\n#  define NGHTTP2_EXTERN\n#elif defined(WIN32) || (__has_declspec_attribute(dllexport) &&                \\\n                         __has_declspec_attribute(dllimport))\n#  ifdef BUILDING_NGHTTP2\n#    define NGHTTP2_EXTERN __declspec(dllexport)\n#  else /* !BUILDING_NGHTTP2 */\n#    define NGHTTP2_EXTERN __declspec(dllimport)\n#  endif /* !BUILDING_NGHTTP2 */\n#else    /* !defined(WIN32) */\n#  ifdef BUILDING_NGHTTP2\n#    define NGHTTP2_EXTERN __attribute__((visibility(\"default\")))\n#  else /* !BUILDING_NGHTTP2 */\n#    define NGHTTP2_EXTERN\n#  endif /* !BUILDING_NGHTTP2 */\n#endif   /* !defined(WIN32) */\n\n/**\n * @macro\n *\n * The protocol version identification string of this library\n * supports.  This identifier is used if HTTP/2 is used over TLS.\n */\n#define NGHTTP2_PROTO_VERSION_ID \"h2\"\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_PROTO_VERSION_ID`.\n */\n#define NGHTTP2_PROTO_VERSION_ID_LEN 2\n\n/**\n * @macro\n *\n * The serialized form of ALPN protocol identifier this library\n * supports.  Notice that first byte is the length of following\n * protocol identifier.  This is the same wire format of `TLS ALPN\n * extension <https://tools.ietf.org/html/rfc7301>`_.  This is useful\n * to process incoming ALPN tokens in wire format.\n */\n#define NGHTTP2_PROTO_ALPN \"\\x2h2\"\n\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_PROTO_ALPN`.\n */\n#define NGHTTP2_PROTO_ALPN_LEN (sizeof(NGHTTP2_PROTO_ALPN) - 1)\n\n/**\n * @macro\n *\n * The protocol version identification string of this library\n * supports.  This identifier is used if HTTP/2 is used over cleartext\n * TCP.\n */\n#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID \"h2c\"\n\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_CLEARTEXT_PROTO_VERSION_ID`.\n */\n#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID_LEN 3\n\nstruct nghttp2_session;\n/**\n * @struct\n *\n * The primary structure to hold the resources needed for a HTTP/2\n * session.  The details of this structure are intentionally hidden\n * from the public API.\n */\ntypedef struct nghttp2_session nghttp2_session;\n\n/**\n * @macro\n *\n * The age of :type:`nghttp2_info`\n */\n#define NGHTTP2_VERSION_AGE 1\n\n/**\n * @struct\n *\n * This struct is what `nghttp2_version()` returns.  It holds\n * information about the particular nghttp2 version.\n */\ntypedef struct {\n  /**\n   * Age of this struct.  This instance of nghttp2 sets it to\n   * :macro:`NGHTTP2_VERSION_AGE` but a future version may bump it and\n   * add more struct fields at the bottom\n   */\n  int age;\n  /**\n   * the :macro:`NGHTTP2_VERSION_NUM` number (since age ==1)\n   */\n  int version_num;\n  /**\n   * points to the :macro:`NGHTTP2_VERSION` string (since age ==1)\n   */\n  const char *version_str;\n  /**\n   * points to the :macro:`NGHTTP2_PROTO_VERSION_ID` string this\n   * instance implements (since age ==1)\n   */\n  const char *proto_str;\n  /* -------- the above fields all exist when age == 1 */\n} nghttp2_info;\n\n/**\n * @macro\n *\n * The default weight of stream dependency.\n */\n#define NGHTTP2_DEFAULT_WEIGHT 16\n\n/**\n * @macro\n *\n * The maximum weight of stream dependency.\n */\n#define NGHTTP2_MAX_WEIGHT 256\n\n/**\n * @macro\n *\n * The minimum weight of stream dependency.\n */\n#define NGHTTP2_MIN_WEIGHT 1\n\n/**\n * @macro\n *\n * The maximum window size\n */\n#define NGHTTP2_MAX_WINDOW_SIZE ((int32_t)((1U << 31) - 1))\n\n/**\n * @macro\n *\n * The initial window size for stream level flow control.\n */\n#define NGHTTP2_INITIAL_WINDOW_SIZE ((1 << 16) - 1)\n/**\n * @macro\n *\n * The initial window size for connection level flow control.\n */\n#define NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ((1 << 16) - 1)\n\n/**\n * @macro\n *\n * The default header table size.\n */\n#define NGHTTP2_DEFAULT_HEADER_TABLE_SIZE (1 << 12)\n\n/**\n * @macro\n *\n * The client magic string, which is the first 24 bytes byte string of\n * client connection preface.\n */\n#define NGHTTP2_CLIENT_MAGIC \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\"\n\n/**\n * @macro\n *\n * The length of :macro:`NGHTTP2_CLIENT_MAGIC`.\n */\n#define NGHTTP2_CLIENT_MAGIC_LEN 24\n\n/**\n * @macro\n *\n * The default max number of settings per SETTINGS frame\n */\n#define NGHTTP2_DEFAULT_MAX_SETTINGS 32\n\n/**\n * @enum\n *\n * Error codes used in this library.  The code range is [-999, -500],\n * inclusive. The following values are defined:\n */\ntypedef enum {\n  /**\n   * Invalid argument passed.\n   */\n  NGHTTP2_ERR_INVALID_ARGUMENT = -501,\n  /**\n   * Out of buffer space.\n   */\n  NGHTTP2_ERR_BUFFER_ERROR = -502,\n  /**\n   * The specified protocol version is not supported.\n   */\n  NGHTTP2_ERR_UNSUPPORTED_VERSION = -503,\n  /**\n   * Used as a return value from :type:`nghttp2_send_callback`,\n   * :type:`nghttp2_recv_callback` and\n   * :type:`nghttp2_send_data_callback` to indicate that the operation\n   * would block.\n   */\n  NGHTTP2_ERR_WOULDBLOCK = -504,\n  /**\n   * General protocol error\n   */\n  NGHTTP2_ERR_PROTO = -505,\n  /**\n   * The frame is invalid.\n   */\n  NGHTTP2_ERR_INVALID_FRAME = -506,\n  /**\n   * The peer performed a shutdown on the connection.\n   */\n  NGHTTP2_ERR_EOF = -507,\n  /**\n   * Used as a return value from\n   * :func:`nghttp2_data_source_read_callback` to indicate that data\n   * transfer is postponed.  See\n   * :func:`nghttp2_data_source_read_callback` for details.\n   */\n  NGHTTP2_ERR_DEFERRED = -508,\n  /**\n   * Stream ID has reached the maximum value.  Therefore no stream ID\n   * is available.\n   */\n  NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE = -509,\n  /**\n   * The stream is already closed; or the stream ID is invalid.\n   */\n  NGHTTP2_ERR_STREAM_CLOSED = -510,\n  /**\n   * RST_STREAM has been added to the outbound queue.  The stream is\n   * in closing state.\n   */\n  NGHTTP2_ERR_STREAM_CLOSING = -511,\n  /**\n   * The transmission is not allowed for this stream (e.g., a frame\n   * with END_STREAM flag set has already sent).\n   */\n  NGHTTP2_ERR_STREAM_SHUT_WR = -512,\n  /**\n   * The stream ID is invalid.\n   */\n  NGHTTP2_ERR_INVALID_STREAM_ID = -513,\n  /**\n   * The state of the stream is not valid (e.g., DATA cannot be sent\n   * to the stream if response HEADERS has not been sent).\n   */\n  NGHTTP2_ERR_INVALID_STREAM_STATE = -514,\n  /**\n   * Another DATA frame has already been deferred.\n   */\n  NGHTTP2_ERR_DEFERRED_DATA_EXIST = -515,\n  /**\n   * Starting new stream is not allowed (e.g., GOAWAY has been sent\n   * and/or received).\n   */\n  NGHTTP2_ERR_START_STREAM_NOT_ALLOWED = -516,\n  /**\n   * GOAWAY has already been sent.\n   */\n  NGHTTP2_ERR_GOAWAY_ALREADY_SENT = -517,\n  /**\n   * The received frame contains the invalid header block (e.g., There\n   * are duplicate header names; or the header names are not encoded\n   * in US-ASCII character set and not lower cased; or the header name\n   * is zero-length string; or the header value contains multiple\n   * in-sequence NUL bytes).\n   */\n  NGHTTP2_ERR_INVALID_HEADER_BLOCK = -518,\n  /**\n   * Indicates that the context is not suitable to perform the\n   * requested operation.\n   */\n  NGHTTP2_ERR_INVALID_STATE = -519,\n  /**\n   * The user callback function failed due to the temporal error.\n   */\n  NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE = -521,\n  /**\n   * The length of the frame is invalid, either too large or too small.\n   */\n  NGHTTP2_ERR_FRAME_SIZE_ERROR = -522,\n  /**\n   * Header block inflate/deflate error.\n   */\n  NGHTTP2_ERR_HEADER_COMP = -523,\n  /**\n   * Flow control error\n   */\n  NGHTTP2_ERR_FLOW_CONTROL = -524,\n  /**\n   * Insufficient buffer size given to function.\n   */\n  NGHTTP2_ERR_INSUFF_BUFSIZE = -525,\n  /**\n   * Callback was paused by the application\n   */\n  NGHTTP2_ERR_PAUSE = -526,\n  /**\n   * There are too many in-flight SETTING frame and no more\n   * transmission of SETTINGS is allowed.\n   */\n  NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS = -527,\n  /**\n   * The server push is disabled.\n   */\n  NGHTTP2_ERR_PUSH_DISABLED = -528,\n  /**\n   * DATA or HEADERS frame for a given stream has been already\n   * submitted and has not been fully processed yet.  Application\n   * should wait for the transmission of the previously submitted\n   * frame before submitting another.\n   */\n  NGHTTP2_ERR_DATA_EXIST = -529,\n  /**\n   * The current session is closing due to a connection error or\n   * `nghttp2_session_terminate_session()` is called.\n   */\n  NGHTTP2_ERR_SESSION_CLOSING = -530,\n  /**\n   * Invalid HTTP header field was received and stream is going to be\n   * closed.\n   */\n  NGHTTP2_ERR_HTTP_HEADER = -531,\n  /**\n   * Violation in HTTP messaging rule.\n   */\n  NGHTTP2_ERR_HTTP_MESSAGING = -532,\n  /**\n   * Stream was refused.\n   */\n  NGHTTP2_ERR_REFUSED_STREAM = -533,\n  /**\n   * Unexpected internal error, but recovered.\n   */\n  NGHTTP2_ERR_INTERNAL = -534,\n  /**\n   * Indicates that a processing was canceled.\n   */\n  NGHTTP2_ERR_CANCEL = -535,\n  /**\n   * When a local endpoint expects to receive SETTINGS frame, it\n   * receives an other type of frame.\n   */\n  NGHTTP2_ERR_SETTINGS_EXPECTED = -536,\n  /**\n   * When a local endpoint receives too many settings entries\n   * in a single SETTINGS frame.\n   */\n  NGHTTP2_ERR_TOO_MANY_SETTINGS = -537,\n  /**\n   * The errors < :enum:`NGHTTP2_ERR_FATAL` mean that the library is\n   * under unexpected condition and processing was terminated (e.g.,\n   * out of memory).  If application receives this error code, it must\n   * stop using that :type:`nghttp2_session` object and only allowed\n   * operation for that object is deallocate it using\n   * `nghttp2_session_del()`.\n   */\n  NGHTTP2_ERR_FATAL = -900,\n  /**\n   * Out of memory.  This is a fatal error.\n   */\n  NGHTTP2_ERR_NOMEM = -901,\n  /**\n   * The user callback function failed.  This is a fatal error.\n   */\n  NGHTTP2_ERR_CALLBACK_FAILURE = -902,\n  /**\n   * Invalid client magic (see :macro:`NGHTTP2_CLIENT_MAGIC`) was\n   * received and further processing is not possible.\n   */\n  NGHTTP2_ERR_BAD_CLIENT_MAGIC = -903,\n  /**\n   * Possible flooding by peer was detected in this HTTP/2 session.\n   * Flooding is measured by how many PING and SETTINGS frames with\n   * ACK flag set are queued for transmission.  These frames are\n   * response for the peer initiated frames, and peer can cause memory\n   * exhaustion on server side to send these frames forever and does\n   * not read network.\n   */\n  NGHTTP2_ERR_FLOODED = -904\n} nghttp2_error;\n\n/**\n * @struct\n *\n * The object representing single contiguous buffer.\n */\ntypedef struct {\n  /**\n   * The pointer to the buffer.\n   */\n  uint8_t *base;\n  /**\n   * The length of the buffer.\n   */\n  size_t len;\n} nghttp2_vec;\n\nstruct nghttp2_rcbuf;\n\n/**\n * @struct\n *\n * The object representing reference counted buffer.  The details of\n * this structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_rcbuf nghttp2_rcbuf;\n\n/**\n * @function\n *\n * Increments the reference count of |rcbuf| by 1.\n */\nNGHTTP2_EXTERN void nghttp2_rcbuf_incref(nghttp2_rcbuf *rcbuf);\n\n/**\n * @function\n *\n * Decrements the reference count of |rcbuf| by 1.  If the reference\n * count becomes zero, the object pointed by |rcbuf| will be freed.\n * In this case, application must not use |rcbuf| again.\n */\nNGHTTP2_EXTERN void nghttp2_rcbuf_decref(nghttp2_rcbuf *rcbuf);\n\n/**\n * @function\n *\n * Returns the underlying buffer managed by |rcbuf|.\n */\nNGHTTP2_EXTERN nghttp2_vec nghttp2_rcbuf_get_buf(nghttp2_rcbuf *rcbuf);\n\n/**\n * @function\n *\n * Returns nonzero if the underlying buffer is statically allocated,\n * and 0 otherwise. This can be useful for language bindings that wish\n * to avoid creating duplicate strings for these buffers.\n */\nNGHTTP2_EXTERN int nghttp2_rcbuf_is_static(const nghttp2_rcbuf *rcbuf);\n\n/**\n * @enum\n *\n * The flags for header field name/value pair.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_NV_FLAG_NONE = 0,\n  /**\n   * Indicates that this name/value pair must not be indexed (\"Literal\n   * Header Field never Indexed\" representation must be used in HPACK\n   * encoding).  Other implementation calls this bit as \"sensitive\".\n   */\n  NGHTTP2_NV_FLAG_NO_INDEX = 0x01,\n  /**\n   * This flag is set solely by application.  If this flag is set, the\n   * library does not make a copy of header field name.  This could\n   * improve performance.\n   */\n  NGHTTP2_NV_FLAG_NO_COPY_NAME = 0x02,\n  /**\n   * This flag is set solely by application.  If this flag is set, the\n   * library does not make a copy of header field value.  This could\n   * improve performance.\n   */\n  NGHTTP2_NV_FLAG_NO_COPY_VALUE = 0x04\n} nghttp2_nv_flag;\n\n/**\n * @struct\n *\n * The name/value pair, which mainly used to represent header fields.\n */\ntypedef struct {\n  /**\n   * The |name| byte string.  If this struct is presented from library\n   * (e.g., :type:`nghttp2_on_frame_recv_callback`), |name| is\n   * guaranteed to be NULL-terminated.  For some callbacks\n   * (:type:`nghttp2_before_frame_send_callback`,\n   * :type:`nghttp2_on_frame_send_callback`, and\n   * :type:`nghttp2_on_frame_not_send_callback`), it may not be\n   * NULL-terminated if header field is passed from application with\n   * the flag :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`).  When application\n   * is constructing this struct, |name| is not required to be\n   * NULL-terminated.\n   */\n  uint8_t *name;\n  /**\n   * The |value| byte string.  If this struct is presented from\n   * library (e.g., :type:`nghttp2_on_frame_recv_callback`), |value|\n   * is guaranteed to be NULL-terminated.  For some callbacks\n   * (:type:`nghttp2_before_frame_send_callback`,\n   * :type:`nghttp2_on_frame_send_callback`, and\n   * :type:`nghttp2_on_frame_not_send_callback`), it may not be\n   * NULL-terminated if header field is passed from application with\n   * the flag :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE`).  When\n   * application is constructing this struct, |value| is not required\n   * to be NULL-terminated.\n   */\n  uint8_t *value;\n  /**\n   * The length of the |name|, excluding terminating NULL.\n   */\n  size_t namelen;\n  /**\n   * The length of the |value|, excluding terminating NULL.\n   */\n  size_t valuelen;\n  /**\n   * Bitwise OR of one or more of :type:`nghttp2_nv_flag`.\n   */\n  uint8_t flags;\n} nghttp2_nv;\n\n/**\n * @enum\n *\n * The frame types in HTTP/2 specification.\n */\ntypedef enum {\n  /**\n   * The DATA frame.\n   */\n  NGHTTP2_DATA = 0,\n  /**\n   * The HEADERS frame.\n   */\n  NGHTTP2_HEADERS = 0x01,\n  /**\n   * The PRIORITY frame.\n   */\n  NGHTTP2_PRIORITY = 0x02,\n  /**\n   * The RST_STREAM frame.\n   */\n  NGHTTP2_RST_STREAM = 0x03,\n  /**\n   * The SETTINGS frame.\n   */\n  NGHTTP2_SETTINGS = 0x04,\n  /**\n   * The PUSH_PROMISE frame.\n   */\n  NGHTTP2_PUSH_PROMISE = 0x05,\n  /**\n   * The PING frame.\n   */\n  NGHTTP2_PING = 0x06,\n  /**\n   * The GOAWAY frame.\n   */\n  NGHTTP2_GOAWAY = 0x07,\n  /**\n   * The WINDOW_UPDATE frame.\n   */\n  NGHTTP2_WINDOW_UPDATE = 0x08,\n  /**\n   * The CONTINUATION frame.  This frame type won't be passed to any\n   * callbacks because the library processes this frame type and its\n   * preceding HEADERS/PUSH_PROMISE as a single frame.\n   */\n  NGHTTP2_CONTINUATION = 0x09,\n  /**\n   * The ALTSVC frame, which is defined in `RFC 7383\n   * <https://tools.ietf.org/html/rfc7838#section-4>`_.\n   */\n  NGHTTP2_ALTSVC = 0x0a,\n  /**\n   * The ORIGIN frame, which is defined by `RFC 8336\n   * <https://tools.ietf.org/html/rfc8336>`_.\n   */\n  NGHTTP2_ORIGIN = 0x0c\n} nghttp2_frame_type;\n\n/**\n * @enum\n *\n * The flags for HTTP/2 frames.  This enum defines all flags for all\n * frames.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_FLAG_NONE = 0,\n  /**\n   * The END_STREAM flag.\n   */\n  NGHTTP2_FLAG_END_STREAM = 0x01,\n  /**\n   * The END_HEADERS flag.\n   */\n  NGHTTP2_FLAG_END_HEADERS = 0x04,\n  /**\n   * The ACK flag.\n   */\n  NGHTTP2_FLAG_ACK = 0x01,\n  /**\n   * The PADDED flag.\n   */\n  NGHTTP2_FLAG_PADDED = 0x08,\n  /**\n   * The PRIORITY flag.\n   */\n  NGHTTP2_FLAG_PRIORITY = 0x20\n} nghttp2_flag;\n\n/**\n * @enum\n * The SETTINGS ID.\n */\ntypedef enum {\n  /**\n   * SETTINGS_HEADER_TABLE_SIZE\n   */\n  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE = 0x01,\n  /**\n   * SETTINGS_ENABLE_PUSH\n   */\n  NGHTTP2_SETTINGS_ENABLE_PUSH = 0x02,\n  /**\n   * SETTINGS_MAX_CONCURRENT_STREAMS\n   */\n  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = 0x03,\n  /**\n   * SETTINGS_INITIAL_WINDOW_SIZE\n   */\n  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE = 0x04,\n  /**\n   * SETTINGS_MAX_FRAME_SIZE\n   */\n  NGHTTP2_SETTINGS_MAX_FRAME_SIZE = 0x05,\n  /**\n   * SETTINGS_MAX_HEADER_LIST_SIZE\n   */\n  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = 0x06,\n  /**\n   * SETTINGS_ENABLE_CONNECT_PROTOCOL\n   * (`RFC 8441 <https://tools.ietf.org/html/rfc8441>`_)\n   */\n  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL = 0x08\n} nghttp2_settings_id;\n/* Note: If we add SETTINGS, update the capacity of\n   NGHTTP2_INBOUND_NUM_IV as well */\n\n/**\n * @macro\n *\n * .. warning::\n *\n *   Deprecated.  The initial max concurrent streams is 0xffffffffu.\n *\n * Default maximum number of incoming concurrent streams.  Use\n * `nghttp2_submit_settings()` with\n * :enum:`NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS` to change the\n * maximum number of incoming concurrent streams.\n *\n * .. note::\n *\n *   The maximum number of outgoing concurrent streams is 100 by\n *   default.\n */\n#define NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS ((1U << 31) - 1)\n\n/**\n * @enum\n * The status codes for the RST_STREAM and GOAWAY frames.\n */\ntypedef enum {\n  /**\n   * No errors.\n   */\n  NGHTTP2_NO_ERROR = 0x00,\n  /**\n   * PROTOCOL_ERROR\n   */\n  NGHTTP2_PROTOCOL_ERROR = 0x01,\n  /**\n   * INTERNAL_ERROR\n   */\n  NGHTTP2_INTERNAL_ERROR = 0x02,\n  /**\n   * FLOW_CONTROL_ERROR\n   */\n  NGHTTP2_FLOW_CONTROL_ERROR = 0x03,\n  /**\n   * SETTINGS_TIMEOUT\n   */\n  NGHTTP2_SETTINGS_TIMEOUT = 0x04,\n  /**\n   * STREAM_CLOSED\n   */\n  NGHTTP2_STREAM_CLOSED = 0x05,\n  /**\n   * FRAME_SIZE_ERROR\n   */\n  NGHTTP2_FRAME_SIZE_ERROR = 0x06,\n  /**\n   * REFUSED_STREAM\n   */\n  NGHTTP2_REFUSED_STREAM = 0x07,\n  /**\n   * CANCEL\n   */\n  NGHTTP2_CANCEL = 0x08,\n  /**\n   * COMPRESSION_ERROR\n   */\n  NGHTTP2_COMPRESSION_ERROR = 0x09,\n  /**\n   * CONNECT_ERROR\n   */\n  NGHTTP2_CONNECT_ERROR = 0x0a,\n  /**\n   * ENHANCE_YOUR_CALM\n   */\n  NGHTTP2_ENHANCE_YOUR_CALM = 0x0b,\n  /**\n   * INADEQUATE_SECURITY\n   */\n  NGHTTP2_INADEQUATE_SECURITY = 0x0c,\n  /**\n   * HTTP_1_1_REQUIRED\n   */\n  NGHTTP2_HTTP_1_1_REQUIRED = 0x0d\n} nghttp2_error_code;\n\n/**\n * @struct\n * The frame header.\n */\ntypedef struct {\n  /**\n   * The length field of this frame, excluding frame header.\n   */\n  size_t length;\n  /**\n   * The stream identifier (aka, stream ID)\n   */\n  int32_t stream_id;\n  /**\n   * The type of this frame.  See `nghttp2_frame_type`.\n   */\n  uint8_t type;\n  /**\n   * The flags.\n   */\n  uint8_t flags;\n  /**\n   * Reserved bit in frame header.  Currently, this is always set to 0\n   * and application should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_frame_hd;\n\n/**\n * @union\n *\n * This union represents the some kind of data source passed to\n * :type:`nghttp2_data_source_read_callback`.\n */\ntypedef union {\n  /**\n   * The integer field, suitable for a file descriptor.\n   */\n  int fd;\n  /**\n   * The pointer to an arbitrary object.\n   */\n  void *ptr;\n} nghttp2_data_source;\n\n/**\n * @enum\n *\n * The flags used to set in |data_flags| output parameter in\n * :type:`nghttp2_data_source_read_callback`.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_DATA_FLAG_NONE = 0,\n  /**\n   * Indicates EOF was sensed.\n   */\n  NGHTTP2_DATA_FLAG_EOF = 0x01,\n  /**\n   * Indicates that END_STREAM flag must not be set even if\n   * NGHTTP2_DATA_FLAG_EOF is set.  Usually this flag is used to send\n   * trailer fields with `nghttp2_submit_request()` or\n   * `nghttp2_submit_response()`.\n   */\n  NGHTTP2_DATA_FLAG_NO_END_STREAM = 0x02,\n  /**\n   * Indicates that application will send complete DATA frame in\n   * :type:`nghttp2_send_data_callback`.\n   */\n  NGHTTP2_DATA_FLAG_NO_COPY = 0x04\n} nghttp2_data_flag;\n\n/**\n * @functypedef\n *\n * Callback function invoked when the library wants to read data from\n * the |source|.  The read data is sent in the stream |stream_id|.\n * The implementation of this function must read at most |length|\n * bytes of data from |source| (or possibly other places) and store\n * them in |buf| and return number of data stored in |buf|.  If EOF is\n * reached, set :enum:`NGHTTP2_DATA_FLAG_EOF` flag in |*data_flags|.\n *\n * Sometime it is desirable to avoid copying data into |buf| and let\n * application to send data directly.  To achieve this, set\n * :enum:`NGHTTP2_DATA_FLAG_NO_COPY` to |*data_flags| (and possibly\n * other flags, just like when we do copy), and return the number of\n * bytes to send without copying data into |buf|.  The library, seeing\n * :enum:`NGHTTP2_DATA_FLAG_NO_COPY`, will invoke\n * :type:`nghttp2_send_data_callback`.  The application must send\n * complete DATA frame in that callback.\n *\n * If this callback is set by `nghttp2_submit_request()`,\n * `nghttp2_submit_response()` or `nghttp2_submit_headers()` and\n * `nghttp2_submit_data()` with flag parameter\n * :enum:`NGHTTP2_FLAG_END_STREAM` set, and\n * :enum:`NGHTTP2_DATA_FLAG_EOF` flag is set to |*data_flags|, DATA\n * frame will have END_STREAM flag set.  Usually, this is expected\n * behaviour and all are fine.  One exception is send trailer fields.\n * You cannot send trailer fields after sending frame with END_STREAM\n * set.  To avoid this problem, one can set\n * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM` along with\n * :enum:`NGHTTP2_DATA_FLAG_EOF` to signal the library not to set\n * END_STREAM in DATA frame.  Then application can use\n * `nghttp2_submit_trailer()` to send trailer fields.\n * `nghttp2_submit_trailer()` can be called inside this callback.\n *\n * If the application wants to postpone DATA frames (e.g.,\n * asynchronous I/O, or reading data blocks for long time), it is\n * achieved by returning :enum:`NGHTTP2_ERR_DEFERRED` without reading\n * any data in this invocation.  The library removes DATA frame from\n * the outgoing queue temporarily.  To move back deferred DATA frame\n * to outgoing queue, call `nghttp2_session_resume_data()`.\n *\n * By default, |length| is limited to 16KiB at maximum.  If peer\n * allows larger frames, application can enlarge transmission buffer\n * size.  See :type:`nghttp2_data_source_read_length_callback` for\n * more details.\n *\n * If the application just wants to return from\n * `nghttp2_session_send()` or `nghttp2_session_mem_send()` without\n * sending anything, return :enum:`NGHTTP2_ERR_PAUSE`.\n *\n * In case of error, there are 2 choices. Returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close the stream\n * by issuing RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  If a\n * different error code is desirable, use\n * `nghttp2_submit_rst_stream()` with a desired error code and then\n * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Returning\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session\n * failure.\n */\ntypedef ssize_t (*nghttp2_data_source_read_callback)(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t length,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data);\n\n/**\n * @struct\n *\n * This struct represents the data source and the way to read a chunk\n * of data from it.\n */\ntypedef struct {\n  /**\n   * The data source.\n   */\n  nghttp2_data_source source;\n  /**\n   * The callback function to read a chunk of data from the |source|.\n   */\n  nghttp2_data_source_read_callback read_callback;\n} nghttp2_data_provider;\n\n/**\n * @struct\n *\n * The DATA frame.  The received data is delivered via\n * :type:`nghttp2_on_data_chunk_recv_callback`.\n */\ntypedef struct {\n  nghttp2_frame_hd hd;\n  /**\n   * The length of the padding in this frame.  This includes PAD_HIGH\n   * and PAD_LOW.\n   */\n  size_t padlen;\n} nghttp2_data;\n\n/**\n * @enum\n *\n * The category of HEADERS, which indicates the role of the frame.  In\n * HTTP/2 spec, request, response, push response and other arbitrary\n * headers (e.g., trailer fields) are all called just HEADERS.  To\n * give the application the role of incoming HEADERS frame, we define\n * several categories.\n */\ntypedef enum {\n  /**\n   * The HEADERS frame is opening new stream, which is analogous to\n   * SYN_STREAM in SPDY.\n   */\n  NGHTTP2_HCAT_REQUEST = 0,\n  /**\n   * The HEADERS frame is the first response headers, which is\n   * analogous to SYN_REPLY in SPDY.\n   */\n  NGHTTP2_HCAT_RESPONSE = 1,\n  /**\n   * The HEADERS frame is the first headers sent against reserved\n   * stream.\n   */\n  NGHTTP2_HCAT_PUSH_RESPONSE = 2,\n  /**\n   * The HEADERS frame which does not apply for the above categories,\n   * which is analogous to HEADERS in SPDY.  If non-final response\n   * (e.g., status 1xx) is used, final response HEADERS frame will be\n   * categorized here.\n   */\n  NGHTTP2_HCAT_HEADERS = 3\n} nghttp2_headers_category;\n\n/**\n * @struct\n *\n * The structure to specify stream dependency.\n */\ntypedef struct {\n  /**\n   * The stream ID of the stream to depend on.  Specifying 0 makes\n   * stream not depend any other stream.\n   */\n  int32_t stream_id;\n  /**\n   * The weight of this dependency.\n   */\n  int32_t weight;\n  /**\n   * nonzero means exclusive dependency\n   */\n  uint8_t exclusive;\n} nghttp2_priority_spec;\n\n/**\n * @struct\n *\n * The HEADERS frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The length of the padding in this frame.  This includes PAD_HIGH\n   * and PAD_LOW.\n   */\n  size_t padlen;\n  /**\n   * The priority specification\n   */\n  nghttp2_priority_spec pri_spec;\n  /**\n   * The name/value pairs.\n   */\n  nghttp2_nv *nva;\n  /**\n   * The number of name/value pairs in |nva|.\n   */\n  size_t nvlen;\n  /**\n   * The category of this HEADERS frame.\n   */\n  nghttp2_headers_category cat;\n} nghttp2_headers;\n\n/**\n * @struct\n *\n * The PRIORITY frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The priority specification.\n   */\n  nghttp2_priority_spec pri_spec;\n} nghttp2_priority;\n\n/**\n * @struct\n *\n * The RST_STREAM frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The error code.  See :type:`nghttp2_error_code`.\n   */\n  uint32_t error_code;\n} nghttp2_rst_stream;\n\n/**\n * @struct\n *\n * The SETTINGS ID/Value pair.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The SETTINGS ID.  See :type:`nghttp2_settings_id`.\n   */\n  int32_t settings_id;\n  /**\n   * The value of this entry.\n   */\n  uint32_t value;\n} nghttp2_settings_entry;\n\n/**\n * @struct\n *\n * The SETTINGS frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The number of SETTINGS ID/Value pairs in |iv|.\n   */\n  size_t niv;\n  /**\n   * The pointer to the array of SETTINGS ID/Value pair.\n   */\n  nghttp2_settings_entry *iv;\n} nghttp2_settings;\n\n/**\n * @struct\n *\n * The PUSH_PROMISE frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The length of the padding in this frame.  This includes PAD_HIGH\n   * and PAD_LOW.\n   */\n  size_t padlen;\n  /**\n   * The name/value pairs.\n   */\n  nghttp2_nv *nva;\n  /**\n   * The number of name/value pairs in |nva|.\n   */\n  size_t nvlen;\n  /**\n   * The promised stream ID\n   */\n  int32_t promised_stream_id;\n  /**\n   * Reserved bit.  Currently this is always set to 0 and application\n   * should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_push_promise;\n\n/**\n * @struct\n *\n * The PING frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The opaque data\n   */\n  uint8_t opaque_data[8];\n} nghttp2_ping;\n\n/**\n * @struct\n *\n * The GOAWAY frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The last stream stream ID.\n   */\n  int32_t last_stream_id;\n  /**\n   * The error code.  See :type:`nghttp2_error_code`.\n   */\n  uint32_t error_code;\n  /**\n   * The additional debug data\n   */\n  uint8_t *opaque_data;\n  /**\n   * The length of |opaque_data| member.\n   */\n  size_t opaque_data_len;\n  /**\n   * Reserved bit.  Currently this is always set to 0 and application\n   * should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_goaway;\n\n/**\n * @struct\n *\n * The WINDOW_UPDATE frame.  It has the following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The window size increment.\n   */\n  int32_t window_size_increment;\n  /**\n   * Reserved bit.  Currently this is always set to 0 and application\n   * should not expect something useful in here.\n   */\n  uint8_t reserved;\n} nghttp2_window_update;\n\n/**\n * @struct\n *\n * The extension frame.  It has following members:\n */\ntypedef struct {\n  /**\n   * The frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The pointer to extension payload.  The exact pointer type is\n   * determined by hd.type.\n   *\n   * Currently, no extension is supported.  This is a place holder for\n   * the future extensions.\n   */\n  void *payload;\n} nghttp2_extension;\n\n/**\n * @union\n *\n * This union includes all frames to pass them to various function\n * calls as nghttp2_frame type.  The CONTINUATION frame is omitted\n * from here because the library deals with it internally.\n */\ntypedef union {\n  /**\n   * The frame header, which is convenient to inspect frame header.\n   */\n  nghttp2_frame_hd hd;\n  /**\n   * The DATA frame.\n   */\n  nghttp2_data data;\n  /**\n   * The HEADERS frame.\n   */\n  nghttp2_headers headers;\n  /**\n   * The PRIORITY frame.\n   */\n  nghttp2_priority priority;\n  /**\n   * The RST_STREAM frame.\n   */\n  nghttp2_rst_stream rst_stream;\n  /**\n   * The SETTINGS frame.\n   */\n  nghttp2_settings settings;\n  /**\n   * The PUSH_PROMISE frame.\n   */\n  nghttp2_push_promise push_promise;\n  /**\n   * The PING frame.\n   */\n  nghttp2_ping ping;\n  /**\n   * The GOAWAY frame.\n   */\n  nghttp2_goaway goaway;\n  /**\n   * The WINDOW_UPDATE frame.\n   */\n  nghttp2_window_update window_update;\n  /**\n   * The extension frame.\n   */\n  nghttp2_extension ext;\n} nghttp2_frame;\n\n/**\n * @functypedef\n *\n * Callback function invoked when |session| wants to send data to the\n * remote peer.  The implementation of this function must send at most\n * |length| bytes of data stored in |data|.  The |flags| is currently\n * not used and always 0. It must return the number of bytes sent if\n * it succeeds.  If it cannot send any single byte without blocking,\n * it must return :enum:`NGHTTP2_ERR_WOULDBLOCK`.  For other errors,\n * it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * This callback is required if the application uses\n * `nghttp2_session_send()` to send data to the remote endpoint.  If\n * the application uses solely `nghttp2_session_mem_send()` instead,\n * this callback function is unnecessary.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_send_callback()`.\n *\n * .. note::\n *\n *   The |length| may be very small.  If that is the case, and\n *   application disables Nagle algorithm (``TCP_NODELAY``), then just\n *   writing |data| to the network stack leads to very small packet,\n *   and it is very inefficient.  An application should be responsible\n *   to buffer up small chunks of data as necessary to avoid this\n *   situation.\n */\ntypedef ssize_t (*nghttp2_send_callback)(nghttp2_session *session,\n                                         const uint8_t *data, size_t length,\n                                         int flags, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when :enum:`NGHTTP2_DATA_FLAG_NO_COPY` is\n * used in :type:`nghttp2_data_source_read_callback` to send complete\n * DATA frame.\n *\n * The |frame| is a DATA frame to send.  The |framehd| is the\n * serialized frame header (9 bytes). The |length| is the length of\n * application data to send (this does not include padding).  The\n * |source| is the same pointer passed to\n * :type:`nghttp2_data_source_read_callback`.\n *\n * The application first must send frame header |framehd| of length 9\n * bytes.  If ``frame->data.padlen > 0``, send 1 byte of value\n * ``frame->data.padlen - 1``.  Then send exactly |length| bytes of\n * application data.  Finally, if ``frame->data.padlen > 1``, send\n * ``frame->data.padlen - 1`` bytes of zero as padding.\n *\n * The application has to send complete DATA frame in this callback.\n * If all data were written successfully, return 0.\n *\n * If it cannot send any data at all, just return\n * :enum:`NGHTTP2_ERR_WOULDBLOCK`; the library will call this callback\n * with the same parameters later (It is recommended to send complete\n * DATA frame at once in this function to deal with error; if partial\n * frame data has already sent, it is impossible to send another data\n * in that state, and all we can do is tear down connection).  When\n * data is fully processed, but application wants to make\n * `nghttp2_session_mem_send()` or `nghttp2_session_send()` return\n * immediately without processing next frames, return\n * :enum:`NGHTTP2_ERR_PAUSE`.  If application decided to reset this\n * stream, return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`, then\n * the library will send RST_STREAM with INTERNAL_ERROR as error code.\n * The application can also return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, which will result in\n * connection closure.  Returning any other value is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.\n */\ntypedef int (*nghttp2_send_data_callback)(nghttp2_session *session,\n                                          nghttp2_frame *frame,\n                                          const uint8_t *framehd, size_t length,\n                                          nghttp2_data_source *source,\n                                          void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when |session| wants to receive data from\n * the remote peer.  The implementation of this function must read at\n * most |length| bytes of data and store it in |buf|.  The |flags| is\n * currently not used and always 0.  It must return the number of\n * bytes written in |buf| if it succeeds.  If it cannot read any\n * single byte without blocking, it must return\n * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  If it gets EOF before it reads any\n * single byte, it must return :enum:`NGHTTP2_ERR_EOF`.  For other\n * errors, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n * Returning 0 is treated as :enum:`NGHTTP2_ERR_WOULDBLOCK`.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * This callback is required if the application uses\n * `nghttp2_session_recv()` to receive data from the remote endpoint.\n * If the application uses solely `nghttp2_session_mem_recv()`\n * instead, this callback function is unnecessary.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_recv_callback()`.\n */\ntypedef ssize_t (*nghttp2_recv_callback)(nghttp2_session *session, uint8_t *buf,\n                                         size_t length, int flags,\n                                         void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when a frame is received.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``\n * member of their data structure are always ``NULL`` and 0\n * respectively.  The header name/value pairs are emitted via\n * :type:`nghttp2_on_header_callback`.\n *\n * For HEADERS, PUSH_PROMISE and DATA frames, this callback may be\n * called after stream is closed (see\n * :type:`nghttp2_on_stream_close_callback`).  The application should\n * check that stream is still alive using its own stream management or\n * :func:`nghttp2_session_get_stream_user_data()`.\n *\n * Only HEADERS and DATA frame can signal the end of incoming data.\n * If ``frame->hd.flags & NGHTTP2_FLAG_END_STREAM`` is nonzero, the\n * |frame| is the last frame from the remote peer in this stream.\n *\n * This callback won't be called for CONTINUATION frames.\n * HEADERS/PUSH_PROMISE + CONTINUATIONs are treated as single frame.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero value is returned, it is treated as fatal error and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_frame_recv_callback()`.\n */\ntypedef int (*nghttp2_on_frame_recv_callback)(nghttp2_session *session,\n                                              const nghttp2_frame *frame,\n                                              void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when an invalid non-DATA frame is\n * received.  The error is indicated by the |lib_error_code|, which is\n * one of the values defined in :type:`nghttp2_error`.  When this\n * callback function is invoked, the library automatically submits\n * either RST_STREAM or GOAWAY frame.  The |user_data| pointer is the\n * third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``\n * member of their data structure are always ``NULL`` and 0\n * respectively.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_invalid_frame_recv_callback()`.\n */\ntypedef int (*nghttp2_on_invalid_frame_recv_callback)(\n    nghttp2_session *session, const nghttp2_frame *frame, int lib_error_code,\n    void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a chunk of data in DATA frame is\n * received.  The |stream_id| is the stream ID this DATA frame belongs\n * to.  The |flags| is the flags of DATA frame which this data chunk\n * is contained.  ``(flags & NGHTTP2_FLAG_END_STREAM) != 0`` does not\n * necessarily mean this chunk of data is the last one in the stream.\n * You should use :type:`nghttp2_on_frame_recv_callback` to know all\n * data frames are received.  The |user_data| pointer is the third\n * argument passed in to the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * If the application uses `nghttp2_session_mem_recv()`, it can return\n * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`\n * return without processing further input bytes.  The memory by\n * pointed by the |data| is retained until\n * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.\n * The application must retain the input bytes which was used to\n * produce the |data| parameter, because it may refer to the memory\n * region included in the input bytes.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error, and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_data_chunk_recv_callback()`.\n */\ntypedef int (*nghttp2_on_data_chunk_recv_callback)(nghttp2_session *session,\n                                                   uint8_t flags,\n                                                   int32_t stream_id,\n                                                   const uint8_t *data,\n                                                   size_t len, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked just before the non-DATA frame |frame| is\n * sent.  The |user_data| pointer is the third argument passed in to\n * the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * The implementation of this function must return 0 if it succeeds.\n * It can also return :enum:`NGHTTP2_ERR_CANCEL` to cancel the\n * transmission of the given frame.\n *\n * If there is a fatal error while executing this callback, the\n * implementation should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`,\n * which makes `nghttp2_session_send()` and\n * `nghttp2_session_mem_send()` functions immediately return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * If the other value is returned, it is treated as if\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.  But the\n * implementation should not rely on this since the library may define\n * new return value to extend its capability.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_before_frame_send_callback()`.\n */\ntypedef int (*nghttp2_before_frame_send_callback)(nghttp2_session *session,\n                                                  const nghttp2_frame *frame,\n                                                  void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked after the frame |frame| is sent.  The\n * |user_data| pointer is the third argument passed in to the call to\n * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_frame_send_callback()`.\n */\ntypedef int (*nghttp2_on_frame_send_callback)(nghttp2_session *session,\n                                              const nghttp2_frame *frame,\n                                              void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked after the non-DATA frame |frame| is not\n * sent because of the error.  The error is indicated by the\n * |lib_error_code|, which is one of the values defined in\n * :type:`nghttp2_error`.  The |user_data| pointer is the third\n * argument passed in to the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * `nghttp2_session_get_stream_user_data()` can be used to get\n * associated data.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_frame_not_send_callback()`.\n */\ntypedef int (*nghttp2_on_frame_not_send_callback)(nghttp2_session *session,\n                                                  const nghttp2_frame *frame,\n                                                  int lib_error_code,\n                                                  void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the stream |stream_id| is closed.\n * The reason of closure is indicated by the |error_code|.  The\n * |error_code| is usually one of :enum:`nghttp2_error_code`, but that\n * is not guaranteed.  The stream_user_data, which was specified in\n * `nghttp2_submit_request()` or `nghttp2_submit_headers()`, is still\n * available in this function.  The |user_data| pointer is the third\n * argument passed in to the call to `nghttp2_session_client_new()` or\n * `nghttp2_session_server_new()`.\n *\n * This function is also called for a stream in reserved state.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero is returned, it is treated as fatal error and\n * `nghttp2_session_recv()`, `nghttp2_session_mem_recv()`,\n * `nghttp2_session_send()`, and `nghttp2_session_mem_send()`\n * functions immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_stream_close_callback()`.\n */\ntypedef int (*nghttp2_on_stream_close_callback)(nghttp2_session *session,\n                                                int32_t stream_id,\n                                                uint32_t error_code,\n                                                void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the reception of header block in\n * HEADERS or PUSH_PROMISE is started.  Each header name/value pair\n * will be emitted by :type:`nghttp2_on_header_callback`.\n *\n * The ``frame->hd.flags`` may not have\n * :enum:`NGHTTP2_FLAG_END_HEADERS` flag set, which indicates that one\n * or more CONTINUATION frames are involved.  But the application does\n * not need to care about that because the header name/value pairs are\n * emitted transparently regardless of CONTINUATION frames.\n *\n * The server applications probably create an object to store\n * information about new stream if ``frame->hd.type ==\n * NGHTTP2_HEADERS`` and ``frame->headers.cat ==\n * NGHTTP2_HCAT_REQUEST``.  If |session| is configured as server side,\n * ``frame->headers.cat`` is either ``NGHTTP2_HCAT_REQUEST``\n * containing request headers or ``NGHTTP2_HCAT_HEADERS`` containing\n * trailer fields and never get PUSH_PROMISE in this callback.\n *\n * For the client applications, ``frame->hd.type`` is either\n * ``NGHTTP2_HEADERS`` or ``NGHTTP2_PUSH_PROMISE``.  In case of\n * ``NGHTTP2_HEADERS``, ``frame->headers.cat ==\n * NGHTTP2_HCAT_RESPONSE`` means that it is the first response\n * headers, but it may be non-final response which is indicated by 1xx\n * status code.  In this case, there may be zero or more HEADERS frame\n * with ``frame->headers.cat == NGHTTP2_HCAT_HEADERS`` which has\n * non-final response code and finally client gets exactly one HEADERS\n * frame with ``frame->headers.cat == NGHTTP2_HCAT_HEADERS``\n * containing final response headers (non-1xx status code).  The\n * trailer fields also has ``frame->headers.cat ==\n * NGHTTP2_HCAT_HEADERS`` which does not contain any status code.\n *\n * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close\n * the stream (promised stream if frame is PUSH_PROMISE) by issuing\n * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,\n * :type:`nghttp2_on_header_callback` and\n * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a\n * different error code is desirable, use\n * `nghttp2_submit_rst_stream()` with a desired error code and then\n * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use\n * ``frame->push_promise.promised_stream_id`` as stream_id parameter\n * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.\n *\n * The implementation of this function must return 0 if it succeeds.\n * It can return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` to\n * reset the stream (promised stream if frame is PUSH_PROMISE).  For\n * critical errors, it must return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the other value is\n * returned, it is treated as if :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n * is returned.  If :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,\n * `nghttp2_session_mem_recv()` function will immediately return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_begin_headers_callback()`.\n */\ntypedef int (*nghttp2_on_begin_headers_callback)(nghttp2_session *session,\n                                                 const nghttp2_frame *frame,\n                                                 void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a header name/value pair is received\n * for the |frame|.  The |name| of length |namelen| is header name.\n * The |value| of length |valuelen| is header value.  The |flags| is\n * bitwise OR of one or more of :type:`nghttp2_nv_flag`.\n *\n * If :enum:`NGHTTP2_NV_FLAG_NO_INDEX` is set in |flags|, the receiver\n * must not index this name/value pair when forwarding it to the next\n * hop.  More specifically, \"Literal Header Field never Indexed\"\n * representation must be used in HPACK encoding.\n *\n * When this callback is invoked, ``frame->hd.type`` is either\n * :enum:`NGHTTP2_HEADERS` or :enum:`NGHTTP2_PUSH_PROMISE`.  After all\n * header name/value pairs are processed with this callback, and no\n * error has been detected, :type:`nghttp2_on_frame_recv_callback`\n * will be invoked.  If there is an error in decompression,\n * :type:`nghttp2_on_frame_recv_callback` for the |frame| will not be\n * invoked.\n *\n * Both |name| and |value| are guaranteed to be NULL-terminated.  The\n * |namelen| and |valuelen| do not include terminal NULL.  If\n * `nghttp2_option_set_no_http_messaging()` is used with nonzero\n * value, NULL character may be included in |name| or |value| before\n * terminating NULL.\n *\n * Please note that unless `nghttp2_option_set_no_http_messaging()` is\n * used, nghttp2 library does perform validation against the |name|\n * and the |value| using `nghttp2_check_header_name()` and\n * `nghttp2_check_header_value()`.  In addition to this, nghttp2\n * performs validation based on HTTP Messaging rule, which is briefly\n * explained in :ref:`http-messaging` section.\n *\n * If the application uses `nghttp2_session_mem_recv()`, it can return\n * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`\n * return without processing further input bytes.  The memory pointed\n * by |frame|, |name| and |value| parameters are retained until\n * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.\n * The application must retain the input bytes which was used to\n * produce these parameters, because it may refer to the memory region\n * included in the input bytes.\n *\n * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close\n * the stream (promised stream if frame is PUSH_PROMISE) by issuing\n * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,\n * :type:`nghttp2_on_header_callback` and\n * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a\n * different error code is desirable, use\n * `nghttp2_submit_rst_stream()` with a desired error code and then\n * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use\n * ``frame->push_promise.promised_stream_id`` as stream_id parameter\n * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.\n *\n * The implementation of this function must return 0 if it succeeds.\n * It may return :enum:`NGHTTP2_ERR_PAUSE` or\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  For other critical\n * failures, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If\n * the other nonzero value is returned, it is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_header_callback()`.\n *\n * .. warning::\n *\n *   Application should properly limit the total buffer size to store\n *   incoming header fields.  Without it, peer may send large number\n *   of header fields or large header fields to cause out of memory in\n *   local endpoint.  Due to how HPACK works, peer can do this\n *   effectively without using much memory on their own.\n */\ntypedef int (*nghttp2_on_header_callback)(nghttp2_session *session,\n                                          const nghttp2_frame *frame,\n                                          const uint8_t *name, size_t namelen,\n                                          const uint8_t *value, size_t valuelen,\n                                          uint8_t flags, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a header name/value pair is received\n * for the |frame|.  The |name| is header name.  The |value| is header\n * value.  The |flags| is bitwise OR of one or more of\n * :type:`nghttp2_nv_flag`.\n *\n * This callback behaves like :type:`nghttp2_on_header_callback`,\n * except that |name| and |value| are stored in reference counted\n * buffer.  If application wishes to keep these references without\n * copying them, use `nghttp2_rcbuf_incref()` to increment their\n * reference count.  It is the application's responsibility to call\n * `nghttp2_rcbuf_decref()` if they called `nghttp2_rcbuf_incref()` so\n * as not to leak memory.  If the |session| is created by\n * `nghttp2_session_server_new3()` or `nghttp2_session_client_new3()`,\n * the function to free memory is the one belongs to the mem\n * parameter.  As long as this free function alives, |name| and\n * |value| can live after |session| was destroyed.\n */\ntypedef int (*nghttp2_on_header_callback2)(nghttp2_session *session,\n                                           const nghttp2_frame *frame,\n                                           nghttp2_rcbuf *name,\n                                           nghttp2_rcbuf *value, uint8_t flags,\n                                           void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a invalid header name/value pair is\n * received for the |frame|.\n *\n * The parameter and behaviour are similar to\n * :type:`nghttp2_on_header_callback`.  The difference is that this\n * callback is only invoked when a invalid header name/value pair is\n * received which is treated as stream error if this callback is not\n * set.  Only invalid regular header field are passed to this\n * callback.  In other words, invalid pseudo header field is not\n * passed to this callback.  Also header fields which includes upper\n * cased latter are also treated as error without passing them to this\n * callback.\n *\n * This callback is only considered if HTTP messaging validation is\n * turned on (which is on by default, see\n * `nghttp2_option_set_no_http_messaging()`).\n *\n * With this callback, application inspects the incoming invalid\n * field, and it also can reset stream from this callback by returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  By default, the\n * error code is :enum:`NGHTTP2_PROTOCOL_ERROR`.  To change the error\n * code, call `nghttp2_submit_rst_stream()` with the error code of\n * choice in addition to returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.\n *\n * If 0 is returned, the header field is ignored, and the stream is\n * not reset.\n */\ntypedef int (*nghttp2_on_invalid_header_callback)(\n    nghttp2_session *session, const nghttp2_frame *frame, const uint8_t *name,\n    size_t namelen, const uint8_t *value, size_t valuelen, uint8_t flags,\n    void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a invalid header name/value pair is\n * received for the |frame|.\n *\n * The parameter and behaviour are similar to\n * :type:`nghttp2_on_header_callback2`.  The difference is that this\n * callback is only invoked when a invalid header name/value pair is\n * received which is silently ignored if this callback is not set.\n * Only invalid regular header field are passed to this callback.  In\n * other words, invalid pseudo header field is not passed to this\n * callback.  Also header fields which includes upper cased latter are\n * also treated as error without passing them to this callback.\n *\n * This callback is only considered if HTTP messaging validation is\n * turned on (which is on by default, see\n * `nghttp2_option_set_no_http_messaging()`).\n *\n * With this callback, application inspects the incoming invalid\n * field, and it also can reset stream from this callback by returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  By default, the\n * error code is :enum:`NGHTTP2_INTERNAL_ERROR`.  To change the error\n * code, call `nghttp2_submit_rst_stream()` with the error code of\n * choice in addition to returning\n * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.\n */\ntypedef int (*nghttp2_on_invalid_header_callback2)(\n    nghttp2_session *session, const nghttp2_frame *frame, nghttp2_rcbuf *name,\n    nghttp2_rcbuf *value, uint8_t flags, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the library asks application how\n * many padding bytes are required for the transmission of the\n * |frame|.  The application must choose the total length of payload\n * including padded bytes in range [frame->hd.length, max_payloadlen],\n * inclusive.  Choosing number not in this range will be treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Returning\n * ``frame->hd.length`` means no padding is added.  Returning\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will make\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_select_padding_callback()`.\n */\ntypedef ssize_t (*nghttp2_select_padding_callback)(nghttp2_session *session,\n                                                   const nghttp2_frame *frame,\n                                                   size_t max_payloadlen,\n                                                   void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library wants to get max length of\n * data to send data to the remote peer.  The implementation of this\n * function should return a value in the following range.  [1,\n * min(|session_remote_window_size|, |stream_remote_window_size|,\n * |remote_max_frame_size|)].  If a value greater than this range is\n * returned than the max allow value will be used.  Returning a value\n * smaller than this range is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The |frame_type| is provided\n * for future extensibility and identifies the type of frame (see\n * :type:`nghttp2_frame_type`) for which to get the length for.\n * Currently supported frame types are: :enum:`NGHTTP2_DATA`.\n *\n * This callback can be used to control the length in bytes for which\n * :type:`nghttp2_data_source_read_callback` is allowed to send to the\n * remote endpoint.  This callback is optional.  Returning\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session\n * failure.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_data_source_read_length_callback()`.\n */\ntypedef ssize_t (*nghttp2_data_source_read_length_callback)(\n    nghttp2_session *session, uint8_t frame_type, int32_t stream_id,\n    int32_t session_remote_window_size, int32_t stream_remote_window_size,\n    uint32_t remote_max_frame_size, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when a frame header is received.  The\n * |hd| points to received frame header.\n *\n * Unlike :type:`nghttp2_on_frame_recv_callback`, this callback will\n * also be called when frame header of CONTINUATION frame is received.\n *\n * If both :type:`nghttp2_on_begin_frame_callback` and\n * :type:`nghttp2_on_begin_headers_callback` are set and HEADERS or\n * PUSH_PROMISE is received, :type:`nghttp2_on_begin_frame_callback`\n * will be called first.\n *\n * The implementation of this function must return 0 if it succeeds.\n * If nonzero value is returned, it is treated as fatal error and\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n *\n * To set this callback to :type:`nghttp2_session_callbacks`, use\n * `nghttp2_session_callbacks_set_on_begin_frame_callback()`.\n */\ntypedef int (*nghttp2_on_begin_frame_callback)(nghttp2_session *session,\n                                               const nghttp2_frame_hd *hd,\n                                               void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when chunk of extension frame payload is\n * received.  The |hd| points to frame header.  The received\n * chunk is |data| of length |len|.\n *\n * The implementation of this function must return 0 if it succeeds.\n *\n * To abort processing this extension frame, return\n * :enum:`NGHTTP2_ERR_CANCEL`.\n *\n * If fatal error occurred, application should return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the\n * other values are returned, currently they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n */\ntypedef int (*nghttp2_on_extension_chunk_recv_callback)(\n    nghttp2_session *session, const nghttp2_frame_hd *hd, const uint8_t *data,\n    size_t len, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library asks the application to\n * unpack extension payload from its wire format.  The extension\n * payload has been passed to the application using\n * :type:`nghttp2_on_extension_chunk_recv_callback`.  The frame header\n * is already unpacked by the library and provided as |hd|.\n *\n * To receive extension frames, the application must tell desired\n * extension frame type to the library using\n * `nghttp2_option_set_user_recv_extension_type()`.\n *\n * The implementation of this function may store the pointer to the\n * created object as a result of unpacking in |*payload|, and returns\n * 0.  The pointer stored in |*payload| is opaque to the library, and\n * the library does not own its pointer.  |*payload| is initialized as\n * ``NULL``.  The |*payload| is available as ``frame->ext.payload`` in\n * :type:`nghttp2_on_frame_recv_callback`.  Therefore if application\n * can free that memory inside :type:`nghttp2_on_frame_recv_callback`\n * callback.  Of course, application has a liberty not ot use\n * |*payload|, and do its own mechanism to process extension frames.\n *\n * To abort processing this extension frame, return\n * :enum:`NGHTTP2_ERR_CANCEL`.\n *\n * If fatal error occurred, application should return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the\n * other values are returned, currently they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n */\ntypedef int (*nghttp2_unpack_extension_callback)(nghttp2_session *session,\n                                                 void **payload,\n                                                 const nghttp2_frame_hd *hd,\n                                                 void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library asks the application to pack\n * extension payload in its wire format.  The frame header will be\n * packed by library.  Application must pack payload only.\n * ``frame->ext.payload`` is the object passed to\n * `nghttp2_submit_extension()` as payload parameter.  Application\n * must pack extension payload to the |buf| of its capacity |len|\n * bytes.  The |len| is at least 16KiB.\n *\n * The implementation of this function should return the number of\n * bytes written into |buf| when it succeeds.\n *\n * To abort processing this extension frame, return\n * :enum:`NGHTTP2_ERR_CANCEL`, and\n * :type:`nghttp2_on_frame_not_send_callback` will be invoked.\n *\n * If fatal error occurred, application should return\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions\n * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the\n * other values are returned, currently they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the return value is\n * strictly larger than |len|, it is treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.\n */\ntypedef ssize_t (*nghttp2_pack_extension_callback)(nghttp2_session *session,\n                                                   uint8_t *buf, size_t len,\n                                                   const nghttp2_frame *frame,\n                                                   void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library provides the error message\n * intended for human consumption.  This callback is solely for\n * debugging purpose.  The |msg| is typically NULL-terminated string\n * of length |len|.  |len| does not include the sentinel NULL\n * character.\n *\n * This function is deprecated.  The new application should use\n * :type:`nghttp2_error_callback2`.\n *\n * The format of error message may change between nghttp2 library\n * versions.  The application should not depend on the particular\n * format.\n *\n * Normally, application should return 0 from this callback.  If fatal\n * error occurred while doing something in this callback, application\n * should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * library will return immediately with return value\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Currently, if nonzero value\n * is returned from this callback, they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, but application should not\n * rely on this details.\n */\ntypedef int (*nghttp2_error_callback)(nghttp2_session *session, const char *msg,\n                                      size_t len, void *user_data);\n\n/**\n * @functypedef\n *\n * Callback function invoked when library provides the error code, and\n * message.  This callback is solely for debugging purpose.\n * |lib_error_code| is one of error code defined in\n * :enum:`nghttp2_error`.  The |msg| is typically NULL-terminated\n * string of length |len|, and intended for human consumption.  |len|\n * does not include the sentinel NULL character.\n *\n * The format of error message may change between nghttp2 library\n * versions.  The application should not depend on the particular\n * format.\n *\n * Normally, application should return 0 from this callback.  If fatal\n * error occurred while doing something in this callback, application\n * should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,\n * library will return immediately with return value\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Currently, if nonzero value\n * is returned from this callback, they are treated as\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, but application should not\n * rely on this details.\n */\ntypedef int (*nghttp2_error_callback2)(nghttp2_session *session,\n                                       int lib_error_code, const char *msg,\n                                       size_t len, void *user_data);\n\nstruct nghttp2_session_callbacks;\n\n/**\n * @struct\n *\n * Callback functions for :type:`nghttp2_session`.  The details of\n * this structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_session_callbacks nghttp2_session_callbacks;\n\n/**\n * @function\n *\n * Initializes |*callbacks_ptr| with NULL values.\n *\n * The initialized object can be used when initializing multiple\n * :type:`nghttp2_session` objects.\n *\n * When the application finished using this object, it can use\n * `nghttp2_session_callbacks_del()` to free its memory.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_callbacks_new(nghttp2_session_callbacks **callbacks_ptr);\n\n/**\n * @function\n *\n * Frees any resources allocated for |callbacks|.  If |callbacks| is\n * ``NULL``, this function does nothing.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_del(nghttp2_session_callbacks *callbacks);\n\n/**\n * @function\n *\n * Sets callback function invoked when a session wants to send data to\n * the remote peer.  This callback is not necessary if the application\n * uses solely `nghttp2_session_mem_send()` to serialize data to\n * transmit.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_send_callback(\n    nghttp2_session_callbacks *cbs, nghttp2_send_callback send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the a session wants to receive\n * data from the remote peer.  This callback is not necessary if the\n * application uses solely `nghttp2_session_mem_recv()` to process\n * received data.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_recv_callback(\n    nghttp2_session_callbacks *cbs, nghttp2_recv_callback recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when a frame is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_frame_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_frame_recv_callback on_frame_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked by `nghttp2_session_recv()` and\n * `nghttp2_session_mem_recv()` when an invalid non-DATA frame is\n * received.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_set_on_invalid_frame_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_invalid_frame_recv_callback on_invalid_frame_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a chunk of data in DATA frame\n * is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_data_chunk_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_data_chunk_recv_callback on_data_chunk_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked before a non-DATA frame is sent.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_before_frame_send_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_before_frame_send_callback before_frame_send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked after a frame is sent.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_frame_send_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_frame_send_callback on_frame_send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a non-DATA frame is not sent\n * because of an error.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_frame_not_send_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_frame_not_send_callback on_frame_not_send_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the stream is closed.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_stream_close_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_stream_close_callback on_stream_close_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the reception of header block\n * in HEADERS or PUSH_PROMISE is started.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_begin_headers_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_begin_headers_callback on_begin_headers_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a header name/value pair is\n * received.  If both\n * `nghttp2_session_callbacks_set_on_header_callback()` and\n * `nghttp2_session_callbacks_set_on_header_callback2()` are used to\n * set callbacks, the latter has the precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_header_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_header_callback on_header_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a header name/value pair is\n * received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_header_callback2(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_header_callback2 on_header_callback2);\n\n/**\n * @function\n *\n * Sets callback function invoked when a invalid header name/value\n * pair is received.  If both\n * `nghttp2_session_callbacks_set_on_invalid_header_callback()` and\n * `nghttp2_session_callbacks_set_on_invalid_header_callback2()` are\n * used to set callbacks, the latter takes the precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_invalid_header_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_invalid_header_callback on_invalid_header_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a invalid header name/value\n * pair is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_invalid_header_callback2(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_invalid_header_callback2 on_invalid_header_callback2);\n\n/**\n * @function\n *\n * Sets callback function invoked when the library asks application\n * how many padding bytes are required for the transmission of the\n * given frame.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_select_padding_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_select_padding_callback select_padding_callback);\n\n/**\n * @function\n *\n * Sets callback function determine the length allowed in\n * :type:`nghttp2_data_source_read_callback`.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_set_data_source_read_length_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_data_source_read_length_callback data_source_read_length_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when a frame header is received.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_on_begin_frame_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_begin_frame_callback on_begin_frame_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when\n * :enum:`NGHTTP2_DATA_FLAG_NO_COPY` is used in\n * :type:`nghttp2_data_source_read_callback` to avoid data copy.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_send_data_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_send_data_callback send_data_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the library asks the\n * application to pack extension frame payload in wire format.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_pack_extension_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_pack_extension_callback pack_extension_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when the library asks the\n * application to unpack extension frame payload from wire format.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_unpack_extension_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_unpack_extension_callback unpack_extension_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when chunk of extension frame\n * payload is received.\n */\nNGHTTP2_EXTERN void\nnghttp2_session_callbacks_set_on_extension_chunk_recv_callback(\n    nghttp2_session_callbacks *cbs,\n    nghttp2_on_extension_chunk_recv_callback on_extension_chunk_recv_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when library tells error message to\n * the application.\n *\n * This function is deprecated.  The new application should use\n * `nghttp2_session_callbacks_set_error_callback2()`.\n *\n * If both :type:`nghttp2_error_callback` and\n * :type:`nghttp2_error_callback2` are set, the latter takes\n * precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_error_callback(\n    nghttp2_session_callbacks *cbs, nghttp2_error_callback error_callback);\n\n/**\n * @function\n *\n * Sets callback function invoked when library tells error code, and\n * message to the application.\n *\n * If both :type:`nghttp2_error_callback` and\n * :type:`nghttp2_error_callback2` are set, the latter takes\n * precedence.\n */\nNGHTTP2_EXTERN void nghttp2_session_callbacks_set_error_callback2(\n    nghttp2_session_callbacks *cbs, nghttp2_error_callback2 error_callback2);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace malloc().  The |mem_user_data|\n * is the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void *(*nghttp2_malloc)(size_t size, void *mem_user_data);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace free().  The |mem_user_data| is\n * the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void (*nghttp2_free)(void *ptr, void *mem_user_data);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace calloc().  The |mem_user_data|\n * is the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void *(*nghttp2_calloc)(size_t nmemb, size_t size, void *mem_user_data);\n\n/**\n * @functypedef\n *\n * Custom memory allocator to replace realloc().  The |mem_user_data|\n * is the mem_user_data member of :type:`nghttp2_mem` structure.\n */\ntypedef void *(*nghttp2_realloc)(void *ptr, size_t size, void *mem_user_data);\n\n/**\n * @struct\n *\n * Custom memory allocator functions and user defined pointer.  The\n * |mem_user_data| member is passed to each allocator function.  This\n * can be used, for example, to achieve per-session memory pool.\n *\n * In the following example code, ``my_malloc``, ``my_free``,\n * ``my_calloc`` and ``my_realloc`` are the replacement of the\n * standard allocators ``malloc``, ``free``, ``calloc`` and\n * ``realloc`` respectively::\n *\n *     void *my_malloc_cb(size_t size, void *mem_user_data) {\n *       return my_malloc(size);\n *     }\n *\n *     void my_free_cb(void *ptr, void *mem_user_data) { my_free(ptr); }\n *\n *     void *my_calloc_cb(size_t nmemb, size_t size, void *mem_user_data) {\n *       return my_calloc(nmemb, size);\n *     }\n *\n *     void *my_realloc_cb(void *ptr, size_t size, void *mem_user_data) {\n *       return my_realloc(ptr, size);\n *     }\n *\n *     void session_new() {\n *       nghttp2_session *session;\n *       nghttp2_session_callbacks *callbacks;\n *       nghttp2_mem mem = {NULL, my_malloc_cb, my_free_cb, my_calloc_cb,\n *                          my_realloc_cb};\n *\n *       ...\n *\n *       nghttp2_session_client_new3(&session, callbacks, NULL, NULL, &mem);\n *\n *       ...\n *     }\n */\ntypedef struct {\n  /**\n   * An arbitrary user supplied data.  This is passed to each\n   * allocator function.\n   */\n  void *mem_user_data;\n  /**\n   * Custom allocator function to replace malloc().\n   */\n  nghttp2_malloc malloc;\n  /**\n   * Custom allocator function to replace free().\n   */\n  nghttp2_free free;\n  /**\n   * Custom allocator function to replace calloc().\n   */\n  nghttp2_calloc calloc;\n  /**\n   * Custom allocator function to replace realloc().\n   */\n  nghttp2_realloc realloc;\n} nghttp2_mem;\n\nstruct nghttp2_option;\n\n/**\n * @struct\n *\n * Configuration options for :type:`nghttp2_session`.  The details of\n * this structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_option nghttp2_option;\n\n/**\n * @function\n *\n * Initializes |*option_ptr| with default values.\n *\n * When the application finished using this object, it can use\n * `nghttp2_option_del()` to free its memory.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_option_new(nghttp2_option **option_ptr);\n\n/**\n * @function\n *\n * Frees any resources allocated for |option|.  If |option| is\n * ``NULL``, this function does nothing.\n */\nNGHTTP2_EXTERN void nghttp2_option_del(nghttp2_option *option);\n\n/**\n * @function\n *\n * This option prevents the library from sending WINDOW_UPDATE for a\n * connection automatically.  If this option is set to nonzero, the\n * library won't send WINDOW_UPDATE for DATA until application calls\n * `nghttp2_session_consume()` to indicate the consumed amount of\n * data.  Don't use `nghttp2_submit_window_update()` for this purpose.\n * By default, this option is set to zero.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_no_auto_window_update(nghttp2_option *option, int val);\n\n/**\n * @function\n *\n * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of\n * remote endpoint as if it is received in SETTINGS frame.  Without\n * specifying this option, the maximum number of outgoing concurrent\n * streams is initially limited to 100 to avoid issues when the local\n * endpoint submits lots of requests before receiving initial SETTINGS\n * frame from the remote endpoint, since sending them at once to the\n * remote endpoint could lead to rejection of some of the requests.\n * This value will be overwritten when the local endpoint receives\n * initial SETTINGS frame from the remote endpoint, either to the\n * value advertised in SETTINGS_MAX_CONCURRENT_STREAMS or to the\n * default value (unlimited) if none was advertised.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_peer_max_concurrent_streams(nghttp2_option *option,\n                                               uint32_t val);\n\n/**\n * @function\n *\n * By default, nghttp2 library, if configured as server, requires\n * first 24 bytes of client magic byte string (MAGIC).  In most cases,\n * this will simplify the implementation of server.  But sometimes\n * server may want to detect the application protocol based on first\n * few bytes on clear text communication.\n *\n * If this option is used with nonzero |val|, nghttp2 library does not\n * handle MAGIC.  It still checks following SETTINGS frame.  This\n * means that applications should deal with MAGIC by themselves.\n *\n * If this option is not used or used with zero value, if MAGIC does\n * not match :macro:`NGHTTP2_CLIENT_MAGIC`, `nghttp2_session_recv()`\n * and `nghttp2_session_mem_recv()` will return error\n * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`, which is fatal error.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_no_recv_client_magic(nghttp2_option *option, int val);\n\n/**\n * @function\n *\n * By default, nghttp2 library enforces subset of HTTP Messaging rules\n * described in `HTTP/2 specification, section 8\n * <https://tools.ietf.org/html/rfc7540#section-8>`_.  See\n * :ref:`http-messaging` section for details.  For those applications\n * who use nghttp2 library as non-HTTP use, give nonzero to |val| to\n * disable this enforcement.  Please note that disabling this feature\n * does not change the fundamental client and server model of HTTP.\n * That is, even if the validation is disabled, only client can send\n * requests.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_no_http_messaging(nghttp2_option *option,\n                                                         int val);\n\n/**\n * @function\n *\n * RFC 7540 does not enforce any limit on the number of incoming\n * reserved streams (in RFC 7540 terms, streams in reserved (remote)\n * state).  This only affects client side, since only server can push\n * streams.  Malicious server can push arbitrary number of streams,\n * and make client's memory exhausted.  This option can set the\n * maximum number of such incoming streams to avoid possible memory\n * exhaustion.  If this option is set, and pushed streams are\n * automatically closed on reception, without calling user provided\n * callback, if they exceed the given limit.  The default value is\n * 200.  If session is configured as server side, this option has no\n * effect.  Server can control the number of streams to push.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_max_reserved_remote_streams(nghttp2_option *option,\n                                               uint32_t val);\n\n/**\n * @function\n *\n * Sets extension frame type the application is willing to handle with\n * user defined callbacks (see\n * :type:`nghttp2_on_extension_chunk_recv_callback` and\n * :type:`nghttp2_unpack_extension_callback`).  The |type| is\n * extension frame type, and must be strictly greater than 0x9.\n * Otherwise, this function does nothing.  The application can call\n * this function multiple times to set more than one frame type to\n * receive.  The application does not have to call this function if it\n * just sends extension frames.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_user_recv_extension_type(nghttp2_option *option,\n                                            uint8_t type);\n\n/**\n * @function\n *\n * Sets extension frame type the application is willing to receive\n * using builtin handler.  The |type| is the extension frame type to\n * receive, and must be strictly greater than 0x9.  Otherwise, this\n * function does nothing.  The application can call this function\n * multiple times to set more than one frame type to receive.  The\n * application does not have to call this function if it just sends\n * extension frames.\n *\n * If same frame type is passed to both\n * `nghttp2_option_set_builtin_recv_extension_type()` and\n * `nghttp2_option_set_user_recv_extension_type()`, the latter takes\n * precedence.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_builtin_recv_extension_type(nghttp2_option *option,\n                                               uint8_t type);\n\n/**\n * @function\n *\n * This option prevents the library from sending PING frame with ACK\n * flag set automatically when PING frame without ACK flag set is\n * received.  If this option is set to nonzero, the library won't send\n * PING frame with ACK flag set in the response for incoming PING\n * frame.  The application can send PING frame with ACK flag set using\n * `nghttp2_submit_ping()` with :enum:`NGHTTP2_FLAG_ACK` as flags\n * parameter.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_no_auto_ping_ack(nghttp2_option *option,\n                                                        int val);\n\n/**\n * @function\n *\n * This option sets the maximum length of header block (a set of\n * header fields per one HEADERS frame) to send.  The length of a\n * given set of header fields is calculated using\n * `nghttp2_hd_deflate_bound()`.  The default value is 64KiB.  If\n * application attempts to send header fields larger than this limit,\n * the transmission of the frame fails with error code\n * :enum:`NGHTTP2_ERR_FRAME_SIZE_ERROR`.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_max_send_header_block_length(nghttp2_option *option,\n                                                size_t val);\n\n/**\n * @function\n *\n * This option sets the maximum dynamic table size for deflating\n * header fields.  The default value is 4KiB.  In HTTP/2, receiver of\n * deflated header block can specify maximum dynamic table size.  The\n * actual maximum size is the minimum of the size receiver specified\n * and this option value.\n */\nNGHTTP2_EXTERN void\nnghttp2_option_set_max_deflate_dynamic_table_size(nghttp2_option *option,\n                                                  size_t val);\n\n/**\n * @function\n *\n * This option prevents the library from retaining closed streams to\n * maintain the priority tree.  If this option is set to nonzero,\n * applications can discard closed stream completely to save memory.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_no_closed_streams(nghttp2_option *option,\n                                                         int val);\n\n/**\n * @function\n *\n * This function sets the maximum number of outgoing SETTINGS ACK and\n * PING ACK frames retained in :type:`nghttp2_session` object.  If\n * more than those frames are retained, the peer is considered to be\n * misbehaving and session will be closed.  The default value is 1000.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_max_outbound_ack(nghttp2_option *option,\n                                                        size_t val);\n\n/**\n * @function\n *\n * This function sets the maximum number of SETTINGS entries per\n * SETTINGS frame that will be accepted. If more than those entries\n * are received, the peer is considered to be misbehaving and session\n * will be closed. The default value is 32.\n */\nNGHTTP2_EXTERN void nghttp2_option_set_max_settings(nghttp2_option *option,\n                                                    size_t val);\n\n/**\n * @function\n *\n * Initializes |*session_ptr| for client use.  The all members of\n * |callbacks| are copied to |*session_ptr|.  Therefore |*session_ptr|\n * does not store |callbacks|.  The |user_data| is an arbitrary user\n * supplied data, which will be passed to the callback functions.\n *\n * The :type:`nghttp2_send_callback` must be specified.  If the\n * application code uses `nghttp2_session_recv()`, the\n * :type:`nghttp2_recv_callback` must be specified.  The other members\n * of |callbacks| can be ``NULL``.\n *\n * If this function fails, |*session_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_client_new(nghttp2_session **session_ptr,\n                           const nghttp2_session_callbacks *callbacks,\n                           void *user_data);\n\n/**\n * @function\n *\n * Initializes |*session_ptr| for server use.  The all members of\n * |callbacks| are copied to |*session_ptr|. Therefore |*session_ptr|\n * does not store |callbacks|.  The |user_data| is an arbitrary user\n * supplied data, which will be passed to the callback functions.\n *\n * The :type:`nghttp2_send_callback` must be specified.  If the\n * application code uses `nghttp2_session_recv()`, the\n * :type:`nghttp2_recv_callback` must be specified.  The other members\n * of |callbacks| can be ``NULL``.\n *\n * If this function fails, |*session_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_server_new(nghttp2_session **session_ptr,\n                           const nghttp2_session_callbacks *callbacks,\n                           void *user_data);\n\n/**\n * @function\n *\n * Like `nghttp2_session_client_new()`, but with additional options\n * specified in the |option|.\n *\n * The |option| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_client_new()`.\n *\n * This function does not take ownership |option|.  The application is\n * responsible for freeing |option| if it finishes using the object.\n *\n * The library code does not refer to |option| after this function\n * returns.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_client_new2(nghttp2_session **session_ptr,\n                            const nghttp2_session_callbacks *callbacks,\n                            void *user_data, const nghttp2_option *option);\n\n/**\n * @function\n *\n * Like `nghttp2_session_server_new()`, but with additional options\n * specified in the |option|.\n *\n * The |option| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_server_new()`.\n *\n * This function does not take ownership |option|.  The application is\n * responsible for freeing |option| if it finishes using the object.\n *\n * The library code does not refer to |option| after this function\n * returns.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_server_new2(nghttp2_session **session_ptr,\n                            const nghttp2_session_callbacks *callbacks,\n                            void *user_data, const nghttp2_option *option);\n\n/**\n * @function\n *\n * Like `nghttp2_session_client_new2()`, but with additional custom\n * memory allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_client_new2()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_client_new3(\n    nghttp2_session **session_ptr, const nghttp2_session_callbacks *callbacks,\n    void *user_data, const nghttp2_option *option, nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Like `nghttp2_session_server_new2()`, but with additional custom\n * memory allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_session_server_new2()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_server_new3(\n    nghttp2_session **session_ptr, const nghttp2_session_callbacks *callbacks,\n    void *user_data, const nghttp2_option *option, nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Frees any resources allocated for |session|.  If |session| is\n * ``NULL``, this function does nothing.\n */\nNGHTTP2_EXTERN void nghttp2_session_del(nghttp2_session *session);\n\n/**\n * @function\n *\n * Sends pending frames to the remote peer.\n *\n * This function retrieves the highest prioritized frame from the\n * outbound queue and sends it to the remote peer.  It does this as\n * many as possible until the user callback\n * :type:`nghttp2_send_callback` returns\n * :enum:`NGHTTP2_ERR_WOULDBLOCK` or the outbound queue becomes empty.\n * This function calls several callback functions which are passed\n * when initializing the |session|.  Here is the simple time chart\n * which tells when each callback is invoked:\n *\n * 1. Get the next frame to send from outbound queue.\n *\n * 2. Prepare transmission of the frame.\n *\n * 3. If the control frame cannot be sent because some preconditions\n *    are not met (e.g., request HEADERS cannot be sent after GOAWAY),\n *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort\n *    the following steps.\n *\n * 4. If the frame is HEADERS, PUSH_PROMISE or DATA,\n *    :type:`nghttp2_select_padding_callback` is invoked.\n *\n * 5. If the frame is request HEADERS, the stream is opened here.\n *\n * 6. :type:`nghttp2_before_frame_send_callback` is invoked.\n *\n * 7. If :enum:`NGHTTP2_ERR_CANCEL` is returned from\n *    :type:`nghttp2_before_frame_send_callback`, the current frame\n *    transmission is canceled, and\n *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort\n *    the following steps.\n *\n * 8. :type:`nghttp2_send_callback` is invoked one or more times to\n *    send the frame.\n *\n * 9. :type:`nghttp2_on_frame_send_callback` is invoked.\n *\n * 10. If the transmission of the frame triggers closure of the\n *     stream, the stream is closed and\n *     :type:`nghttp2_on_stream_close_callback` is invoked.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n *     The callback function failed.\n */\nNGHTTP2_EXTERN int nghttp2_session_send(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the serialized data to send.\n *\n * This function behaves like `nghttp2_session_send()` except that it\n * does not use :type:`nghttp2_send_callback` to transmit data.\n * Instead, it assigns the pointer to the serialized data to the\n * |*data_ptr| and returns its length.  The other callbacks are called\n * in the same way as they are in `nghttp2_session_send()`.\n *\n * If no data is available to send, this function returns 0.\n *\n * This function may not return all serialized data in one invocation.\n * To get all data, call this function repeatedly until it returns 0\n * or one of negative error codes.\n *\n * The assigned |*data_ptr| is valid until the next call of\n * `nghttp2_session_mem_send()` or `nghttp2_session_send()`.\n *\n * The caller must send all data before sending the next chunk of\n * data.\n *\n * This function returns the length of the data pointed by the\n * |*data_ptr| if it succeeds, or one of the following negative error\n * codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n *\n * .. note::\n *\n *   This function may produce very small byte string.  If that is the\n *   case, and application disables Nagle algorithm (``TCP_NODELAY``),\n *   then writing this small chunk leads to very small packet, and it\n *   is very inefficient.  An application should be responsible to\n *   buffer up small chunks of data as necessary to avoid this\n *   situation.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_session_mem_send(nghttp2_session *session,\n                                                const uint8_t **data_ptr);\n\n/**\n * @function\n *\n * Receives frames from the remote peer.\n *\n * This function receives as many frames as possible until the user\n * callback :type:`nghttp2_recv_callback` returns\n * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  This function calls several\n * callback functions which are passed when initializing the\n * |session|.  Here is the simple time chart which tells when each\n * callback is invoked:\n *\n * 1. :type:`nghttp2_recv_callback` is invoked one or more times to\n *    receive frame header.\n *\n * 2. When frame header is received,\n *    :type:`nghttp2_on_begin_frame_callback` is invoked.\n *\n * 3. If the frame is DATA frame:\n *\n *    1. :type:`nghttp2_recv_callback` is invoked to receive DATA\n *       payload. For each chunk of data,\n *       :type:`nghttp2_on_data_chunk_recv_callback` is invoked.\n *\n *    2. If one DATA frame is completely received,\n *       :type:`nghttp2_on_frame_recv_callback` is invoked.  If the\n *       reception of the frame triggers the closure of the stream,\n *       :type:`nghttp2_on_stream_close_callback` is invoked.\n *\n * 4. If the frame is the control frame:\n *\n *    1. :type:`nghttp2_recv_callback` is invoked one or more times to\n *       receive whole frame.\n *\n *    2. If the received frame is valid, then following actions are\n *       taken.  If the frame is either HEADERS or PUSH_PROMISE,\n *       :type:`nghttp2_on_begin_headers_callback` is invoked.  Then\n *       :type:`nghttp2_on_header_callback` is invoked for each header\n *       name/value pair.  For invalid header field,\n *       :type:`nghttp2_on_invalid_header_callback` is called.  After\n *       all name/value pairs are emitted successfully,\n *       :type:`nghttp2_on_frame_recv_callback` is invoked.  For other\n *       frames, :type:`nghttp2_on_frame_recv_callback` is invoked.\n *       If the reception of the frame triggers the closure of the\n *       stream, :type:`nghttp2_on_stream_close_callback` is invoked.\n *\n *    3. If the received frame is unpacked but is interpreted as\n *       invalid, :type:`nghttp2_on_invalid_frame_recv_callback` is\n *       invoked.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_EOF`\n *     The remote peer did shutdown on the connection.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n *     The callback function failed.\n * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`\n *     Invalid client magic was detected.  This error only returns\n *     when |session| was configured as server and\n *     `nghttp2_option_set_no_recv_client_magic()` is not used with\n *     nonzero value.\n * :enum:`NGHTTP2_ERR_FLOODED`\n *     Flooding was detected in this HTTP/2 session, and it must be\n *     closed.  This is most likely caused by misbehaviour of peer.\n */\nNGHTTP2_EXTERN int nghttp2_session_recv(nghttp2_session *session);\n\n/**\n * @function\n *\n * Processes data |in| as an input from the remote endpoint.  The\n * |inlen| indicates the number of bytes in the |in|.\n *\n * This function behaves like `nghttp2_session_recv()` except that it\n * does not use :type:`nghttp2_recv_callback` to receive data; the\n * |in| is the only data for the invocation of this function.  If all\n * bytes are processed, this function returns.  The other callbacks\n * are called in the same way as they are in `nghttp2_session_recv()`.\n *\n * In the current implementation, this function always tries to\n * processes all input data unless either an error occurs or\n * :enum:`NGHTTP2_ERR_PAUSE` is returned from\n * :type:`nghttp2_on_header_callback` or\n * :type:`nghttp2_on_data_chunk_recv_callback`.  If\n * :enum:`NGHTTP2_ERR_PAUSE` is used, the return value includes the\n * number of bytes which was used to produce the data or frame for the\n * callback.\n *\n * This function returns the number of processed bytes, or one of the\n * following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`\n *     The callback function failed.\n * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`\n *     Invalid client magic was detected.  This error only returns\n *     when |session| was configured as server and\n *     `nghttp2_option_set_no_recv_client_magic()` is not used with\n *     nonzero value.\n * :enum:`NGHTTP2_ERR_FLOODED`\n *     Flooding was detected in this HTTP/2 session, and it must be\n *     closed.  This is most likely caused by misbehaviour of peer.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_session_mem_recv(nghttp2_session *session,\n                                                const uint8_t *in,\n                                                size_t inlen);\n\n/**\n * @function\n *\n * Puts back previously deferred DATA frame in the stream |stream_id|\n * to the outbound queue.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The stream does not exist; or no deferred data exist.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_resume_data(nghttp2_session *session,\n                                               int32_t stream_id);\n\n/**\n * @function\n *\n * Returns nonzero value if |session| wants to receive data from the\n * remote peer.\n *\n * If both `nghttp2_session_want_read()` and\n * `nghttp2_session_want_write()` return 0, the application should\n * drop the connection.\n */\nNGHTTP2_EXTERN int nghttp2_session_want_read(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns nonzero value if |session| wants to send data to the remote\n * peer.\n *\n * If both `nghttp2_session_want_read()` and\n * `nghttp2_session_want_write()` return 0, the application should\n * drop the connection.\n */\nNGHTTP2_EXTERN int nghttp2_session_want_write(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns stream_user_data for the stream |stream_id|.  The\n * stream_user_data is provided by `nghttp2_submit_request()`,\n * `nghttp2_submit_headers()` or\n * `nghttp2_session_set_stream_user_data()`.  Unless it is set using\n * `nghttp2_session_set_stream_user_data()`, if the stream is\n * initiated by the remote endpoint, stream_user_data is always\n * ``NULL``.  If the stream does not exist, this function returns\n * ``NULL``.\n */\nNGHTTP2_EXTERN void *\nnghttp2_session_get_stream_user_data(nghttp2_session *session,\n                                     int32_t stream_id);\n\n/**\n * @function\n *\n * Sets the |stream_user_data| to the stream denoted by the\n * |stream_id|.  If a stream user data is already set to the stream,\n * it is replaced with the |stream_user_data|.  It is valid to specify\n * ``NULL`` in the |stream_user_data|, which nullifies the associated\n * data pointer.\n *\n * It is valid to set the |stream_user_data| to the stream reserved by\n * PUSH_PROMISE frame.\n *\n * This function returns 0 if it succeeds, or one of following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The stream does not exist\n */\nNGHTTP2_EXTERN int\nnghttp2_session_set_stream_user_data(nghttp2_session *session,\n                                     int32_t stream_id, void *stream_user_data);\n\n/**\n * @function\n *\n * Sets |user_data| to |session|, overwriting the existing user data\n * specified in `nghttp2_session_client_new()`, or\n * `nghttp2_session_server_new()`.\n */\nNGHTTP2_EXTERN void nghttp2_session_set_user_data(nghttp2_session *session,\n                                                  void *user_data);\n\n/**\n * @function\n *\n * Returns the number of frames in the outbound queue.  This does not\n * include the deferred DATA frames.\n */\nNGHTTP2_EXTERN size_t\nnghttp2_session_get_outbound_queue_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the number of DATA payload in bytes received without\n * WINDOW_UPDATE transmission for the stream |stream_id|.  The local\n * (receive) window size can be adjusted by\n * `nghttp2_submit_window_update()`.  This function takes into account\n * that and returns effective data length.  In particular, if the\n * local window size is reduced by submitting negative\n * window_size_increment with `nghttp2_submit_window_update()`, this\n * function returns the number of bytes less than actually received.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_effective_recv_data_length(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the local (receive) window size for the stream |stream_id|.\n * The local window size can be adjusted by\n * `nghttp2_submit_window_update()`.  This function takes into account\n * that and returns effective window size.\n *\n * This function does not take into account the amount of received\n * data from the remote endpoint.  Use\n * `nghttp2_session_get_stream_local_window_size()` to know the amount\n * of data the remote endpoint can send without receiving stream level\n * WINDOW_UPDATE frame.  Note that each stream is still subject to the\n * connection level flow control.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_effective_local_window_size(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the amount of flow-controlled payload (e.g., DATA) that the\n * remote endpoint can send without receiving stream level\n * WINDOW_UPDATE frame.  It is also subject to the connection level\n * flow control.  So the actual amount of data to send is\n * min(`nghttp2_session_get_stream_local_window_size()`,\n * `nghttp2_session_get_local_window_size()`).\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_local_window_size(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the number of DATA payload in bytes received without\n * WINDOW_UPDATE transmission for a connection.  The local (receive)\n * window size can be adjusted by `nghttp2_submit_window_update()`.\n * This function takes into account that and returns effective data\n * length.  In particular, if the local window size is reduced by\n * submitting negative window_size_increment with\n * `nghttp2_submit_window_update()`, this function returns the number\n * of bytes less than actually received.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_effective_recv_data_length(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the local (receive) window size for a connection.  The\n * local window size can be adjusted by\n * `nghttp2_submit_window_update()`.  This function takes into account\n * that and returns effective window size.\n *\n * This function does not take into account the amount of received\n * data from the remote endpoint.  Use\n * `nghttp2_session_get_local_window_size()` to know the amount of\n * data the remote endpoint can send without receiving\n * connection-level WINDOW_UPDATE frame.  Note that each stream is\n * still subject to the stream level flow control.\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_effective_local_window_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the amount of flow-controlled payload (e.g., DATA) that the\n * remote endpoint can send without receiving connection level\n * WINDOW_UPDATE frame.  Note that each stream is still subject to the\n * stream level flow control (see\n * `nghttp2_session_get_stream_local_window_size()`).\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_local_window_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the remote window size for a given stream |stream_id|.\n *\n * This is the amount of flow-controlled payload (e.g., DATA) that the\n * local endpoint can send without stream level WINDOW_UPDATE.  There\n * is also connection level flow control, so the effective size of\n * payload that the local endpoint can actually send is\n * min(`nghttp2_session_get_stream_remote_window_size()`,\n * `nghttp2_session_get_remote_window_size()`).\n *\n * This function returns -1 if it fails.\n */\nNGHTTP2_EXTERN int32_t nghttp2_session_get_stream_remote_window_size(\n    nghttp2_session *session, int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the remote window size for a connection.\n *\n * This function always succeeds.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_remote_window_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns 1 if local peer half closed the given stream |stream_id|.\n * Returns 0 if it did not.  Returns -1 if no such stream exists.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_get_stream_local_close(nghttp2_session *session,\n                                       int32_t stream_id);\n\n/**\n * @function\n *\n * Returns 1 if remote peer half closed the given stream |stream_id|.\n * Returns 0 if it did not.  Returns -1 if no such stream exists.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_get_stream_remote_close(nghttp2_session *session,\n                                        int32_t stream_id);\n\n/**\n * @function\n *\n * Returns the current dynamic table size of HPACK inflater, including\n * the overhead 32 bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN size_t\nnghttp2_session_get_hd_inflate_dynamic_table_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the current dynamic table size of HPACK deflater including\n * the overhead 32 bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN size_t\nnghttp2_session_get_hd_deflate_dynamic_table_size(nghttp2_session *session);\n\n/**\n * @function\n *\n * Signals the session so that the connection should be terminated.\n *\n * The last stream ID is the minimum value between the stream ID of a\n * stream for which :type:`nghttp2_on_frame_recv_callback` was called\n * most recently and the last stream ID we have sent to the peer\n * previously.\n *\n * The |error_code| is the error code of this GOAWAY frame.  The\n * pre-defined error code is one of :enum:`nghttp2_error_code`.\n *\n * After the transmission, both `nghttp2_session_want_read()` and\n * `nghttp2_session_want_write()` return 0.\n *\n * This function should be called when the connection should be\n * terminated after sending GOAWAY.  If the remaining streams should\n * be processed after GOAWAY, use `nghttp2_submit_goaway()` instead.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_session_terminate_session(nghttp2_session *session,\n                                                     uint32_t error_code);\n\n/**\n * @function\n *\n * Signals the session so that the connection should be terminated.\n *\n * This function behaves like `nghttp2_session_terminate_session()`,\n * but the last stream ID can be specified by the application for fine\n * grained control of stream.  The HTTP/2 specification does not allow\n * last_stream_id to be increased.  So the actual value sent as\n * last_stream_id is the minimum value between the given\n * |last_stream_id| and the last_stream_id we have previously sent to\n * the peer.\n *\n * The |last_stream_id| is peer's stream ID or 0.  So if |session| is\n * initialized as client, |last_stream_id| must be even or 0.  If\n * |session| is initialized as server, |last_stream_id| must be odd or\n * 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |last_stream_id| is invalid.\n */\nNGHTTP2_EXTERN int nghttp2_session_terminate_session2(nghttp2_session *session,\n                                                      int32_t last_stream_id,\n                                                      uint32_t error_code);\n\n/**\n * @function\n *\n * Signals to the client that the server started graceful shutdown\n * procedure.\n *\n * This function is only usable for server.  If this function is\n * called with client side session, this function returns\n * :enum:`NGHTTP2_ERR_INVALID_STATE`.\n *\n * To gracefully shutdown HTTP/2 session, server should call this\n * function to send GOAWAY with last_stream_id (1u << 31) - 1.  And\n * after some delay (e.g., 1 RTT), send another GOAWAY with the stream\n * ID that the server has some processing using\n * `nghttp2_submit_goaway()`.  See also\n * `nghttp2_session_get_last_proc_stream_id()`.\n *\n * Unlike `nghttp2_submit_goaway()`, this function just sends GOAWAY\n * and does nothing more.  This is a mere indication to the client\n * that session shutdown is imminent.  The application should call\n * `nghttp2_submit_goaway()` with appropriate last_stream_id after\n * this call.\n *\n * If one or more GOAWAY frame have been already sent by either\n * `nghttp2_submit_goaway()` or `nghttp2_session_terminate_session()`,\n * this function has no effect.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The |session| is initialized as client.\n */\nNGHTTP2_EXTERN int nghttp2_submit_shutdown_notice(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the value of SETTINGS |id| notified by a remote endpoint.\n * The |id| must be one of values defined in\n * :enum:`nghttp2_settings_id`.\n */\nNGHTTP2_EXTERN uint32_t nghttp2_session_get_remote_settings(\n    nghttp2_session *session, nghttp2_settings_id id);\n\n/**\n * @function\n *\n * Returns the value of SETTINGS |id| of local endpoint acknowledged\n * by the remote endpoint.  The |id| must be one of the values defined\n * in :enum:`nghttp2_settings_id`.\n */\nNGHTTP2_EXTERN uint32_t nghttp2_session_get_local_settings(\n    nghttp2_session *session, nghttp2_settings_id id);\n\n/**\n * @function\n *\n * Tells the |session| that next stream ID is |next_stream_id|.  The\n * |next_stream_id| must be equal or greater than the value returned\n * by `nghttp2_session_get_next_stream_id()`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |next_stream_id| is strictly less than the value\n *     `nghttp2_session_get_next_stream_id()` returns; or\n *     |next_stream_id| is invalid (e.g., even integer for client, or\n *     odd integer for server).\n */\nNGHTTP2_EXTERN int nghttp2_session_set_next_stream_id(nghttp2_session *session,\n                                                      int32_t next_stream_id);\n\n/**\n * @function\n *\n * Returns the next outgoing stream ID.  Notice that return type is\n * uint32_t.  If we run out of stream ID for this session, this\n * function returns 1 << 31.\n */\nNGHTTP2_EXTERN uint32_t\nnghttp2_session_get_next_stream_id(nghttp2_session *session);\n\n/**\n * @function\n *\n * Tells the |session| that |size| bytes for a stream denoted by\n * |stream_id| were consumed by application and are ready to\n * WINDOW_UPDATE.  The consumed bytes are counted towards both\n * connection and stream level WINDOW_UPDATE (see\n * `nghttp2_session_consume_connection()` and\n * `nghttp2_session_consume_stream()` to update consumption\n * independently).  This function is intended to be used without\n * automatic window update (see\n * `nghttp2_option_set_no_auto_window_update()`).\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     Automatic WINDOW_UPDATE is not disabled.\n */\nNGHTTP2_EXTERN int nghttp2_session_consume(nghttp2_session *session,\n                                           int32_t stream_id, size_t size);\n\n/**\n * @function\n *\n * Like `nghttp2_session_consume()`, but this only tells library that\n * |size| bytes were consumed only for connection level.  Note that\n * HTTP/2 maintains connection and stream level flow control windows\n * independently.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     Automatic WINDOW_UPDATE is not disabled.\n */\nNGHTTP2_EXTERN int nghttp2_session_consume_connection(nghttp2_session *session,\n                                                      size_t size);\n\n/**\n * @function\n *\n * Like `nghttp2_session_consume()`, but this only tells library that\n * |size| bytes were consumed only for stream denoted by |stream_id|.\n * Note that HTTP/2 maintains connection and stream level flow control\n * windows independently.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     Automatic WINDOW_UPDATE is not disabled.\n */\nNGHTTP2_EXTERN int nghttp2_session_consume_stream(nghttp2_session *session,\n                                                  int32_t stream_id,\n                                                  size_t size);\n\n/**\n * @function\n *\n * Changes priority of existing stream denoted by |stream_id|.  The\n * new priority specification is |pri_spec|.\n *\n * The priority is changed silently and instantly, and no PRIORITY\n * frame will be sent to notify the peer of this change.  This\n * function may be useful for server to change the priority of pushed\n * stream.\n *\n * If |session| is initialized as server, and ``pri_spec->stream_id``\n * points to the idle stream, the idle stream is created if it does\n * not exist.  The created idle stream will depend on root stream\n * (stream 0) with weight 16.\n *\n * Otherwise, if stream denoted by ``pri_spec->stream_id`` is not\n * found, we use default priority instead of given |pri_spec|.  That\n * is make stream depend on root stream with weight 16.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     Attempted to depend on itself; or no stream exist for the given\n *     |stream_id|; or |stream_id| is 0\n */\nNGHTTP2_EXTERN int\nnghttp2_session_change_stream_priority(nghttp2_session *session,\n                                       int32_t stream_id,\n                                       const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Creates idle stream with the given |stream_id|, and priority\n * |pri_spec|.\n *\n * The stream creation is done without sending PRIORITY frame, which\n * means that peer does not know about the existence of this idle\n * stream in the local endpoint.\n *\n * RFC 7540 does not disallow the use of creation of idle stream with\n * odd or even stream ID regardless of client or server.  So this\n * function can create odd or even stream ID regardless of client or\n * server.  But probably it is a bit safer to use the stream ID the\n * local endpoint can initiate (in other words, use odd stream ID for\n * client, and even stream ID for server), to avoid potential\n * collision from peer's instruction.  Also we can use\n * `nghttp2_session_set_next_stream_id()` to avoid to open created\n * idle streams accidentally if we follow this recommendation.\n *\n * If |session| is initialized as server, and ``pri_spec->stream_id``\n * points to the idle stream, the idle stream is created if it does\n * not exist.  The created idle stream will depend on root stream\n * (stream 0) with weight 16.\n *\n * Otherwise, if stream denoted by ``pri_spec->stream_id`` is not\n * found, we use default priority instead of given |pri_spec|.  That\n * is make stream depend on root stream with weight 16.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     Attempted to depend on itself; or stream denoted by |stream_id|\n *     already exists; or |stream_id| cannot be used to create idle\n *     stream (in other words, local endpoint has already opened\n *     stream ID greater than or equal to the given stream ID; or\n *     |stream_id| is 0\n */\nNGHTTP2_EXTERN int\nnghttp2_session_create_idle_stream(nghttp2_session *session, int32_t stream_id,\n                                   const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Performs post-process of HTTP Upgrade request.  This function can\n * be called from both client and server, but the behavior is very\n * different in each other.\n *\n * .. warning::\n *\n *   This function is deprecated in favor of\n *   `nghttp2_session_upgrade2()`, because this function lacks the\n *   parameter to tell the library the request method used in the\n *   original HTTP request.  This information is required for client\n *   to validate actual response body length against content-length\n *   header field (see `nghttp2_option_set_no_http_messaging()`).  If\n *   HEAD is used in request, the length of response body must be 0\n *   regardless of value included in content-length header field.\n *\n * If called from client side, the |settings_payload| must be the\n * value sent in ``HTTP2-Settings`` header field and must be decoded\n * by base64url decoder.  The |settings_payloadlen| is the length of\n * |settings_payload|.  The |settings_payload| is unpacked and its\n * setting values will be submitted using `nghttp2_submit_settings()`.\n * This means that the client application code does not need to submit\n * SETTINGS by itself.  The stream with stream ID=1 is opened and the\n * |stream_user_data| is used for its stream_user_data.  The opened\n * stream becomes half-closed (local) state.\n *\n * If called from server side, the |settings_payload| must be the\n * value received in ``HTTP2-Settings`` header field and must be\n * decoded by base64url decoder.  The |settings_payloadlen| is the\n * length of |settings_payload|.  It is treated as if the SETTINGS\n * frame with that payload is received.  Thus, callback functions for\n * the reception of SETTINGS frame will be invoked.  The stream with\n * stream ID=1 is opened.  The |stream_user_data| is ignored.  The\n * opened stream becomes half-closed (remote).\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |settings_payload| is badly formed.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The stream ID 1 is already used or closed; or is not available.\n */\nNGHTTP2_EXTERN int nghttp2_session_upgrade(nghttp2_session *session,\n                                           const uint8_t *settings_payload,\n                                           size_t settings_payloadlen,\n                                           void *stream_user_data);\n\n/**\n * @function\n *\n * Performs post-process of HTTP Upgrade request.  This function can\n * be called from both client and server, but the behavior is very\n * different in each other.\n *\n * If called from client side, the |settings_payload| must be the\n * value sent in ``HTTP2-Settings`` header field and must be decoded\n * by base64url decoder.  The |settings_payloadlen| is the length of\n * |settings_payload|.  The |settings_payload| is unpacked and its\n * setting values will be submitted using `nghttp2_submit_settings()`.\n * This means that the client application code does not need to submit\n * SETTINGS by itself.  The stream with stream ID=1 is opened and the\n * |stream_user_data| is used for its stream_user_data.  The opened\n * stream becomes half-closed (local) state.\n *\n * If called from server side, the |settings_payload| must be the\n * value received in ``HTTP2-Settings`` header field and must be\n * decoded by base64url decoder.  The |settings_payloadlen| is the\n * length of |settings_payload|.  It is treated as if the SETTINGS\n * frame with that payload is received.  Thus, callback functions for\n * the reception of SETTINGS frame will be invoked.  The stream with\n * stream ID=1 is opened.  The |stream_user_data| is ignored.  The\n * opened stream becomes half-closed (remote).\n *\n * If the request method is HEAD, pass nonzero value to\n * |head_request|.  Otherwise, pass 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |settings_payload| is badly formed.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The stream ID 1 is already used or closed; or is not available.\n */\nNGHTTP2_EXTERN int nghttp2_session_upgrade2(nghttp2_session *session,\n                                            const uint8_t *settings_payload,\n                                            size_t settings_payloadlen,\n                                            int head_request,\n                                            void *stream_user_data);\n\n/**\n * @function\n *\n * Serializes the SETTINGS values |iv| in the |buf|.  The size of the\n * |buf| is specified by |buflen|.  The number of entries in the |iv|\n * array is given by |niv|.  The required space in |buf| for the |niv|\n * entries is ``6*niv`` bytes and if the given buffer is too small, an\n * error is returned.  This function is used mainly for creating a\n * SETTINGS payload to be sent with the ``HTTP2-Settings`` header\n * field in an HTTP Upgrade request.  The data written in |buf| is NOT\n * base64url encoded and the application is responsible for encoding.\n *\n * This function returns the number of bytes written in |buf|, or one\n * of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |iv| contains duplicate settings ID or invalid value.\n *\n * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`\n *     The provided |buflen| size is too small to hold the output.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_pack_settings_payload(\n    uint8_t *buf, size_t buflen, const nghttp2_settings_entry *iv, size_t niv);\n\n/**\n * @function\n *\n * Returns string describing the |lib_error_code|.  The\n * |lib_error_code| must be one of the :enum:`nghttp2_error`.\n */\nNGHTTP2_EXTERN const char *nghttp2_strerror(int lib_error_code);\n\n/**\n * @function\n *\n * Returns string representation of HTTP/2 error code |error_code|\n * (e.g., ``PROTOCOL_ERROR`` is returned if ``error_code ==\n * NGHTTP2_PROTOCOL_ERROR``).  If string representation is unknown for\n * given |error_code|, this function returns string ``unknown``.\n */\nNGHTTP2_EXTERN const char *nghttp2_http2_strerror(uint32_t error_code);\n\n/**\n * @function\n *\n * Initializes |pri_spec| with the |stream_id| of the stream to depend\n * on with |weight| and its exclusive flag.  If |exclusive| is\n * nonzero, exclusive flag is set.\n *\n * The |weight| must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.\n */\nNGHTTP2_EXTERN void nghttp2_priority_spec_init(nghttp2_priority_spec *pri_spec,\n                                               int32_t stream_id,\n                                               int32_t weight, int exclusive);\n\n/**\n * @function\n *\n * Initializes |pri_spec| with the default values.  The default values\n * are: stream_id = 0, weight = :macro:`NGHTTP2_DEFAULT_WEIGHT` and\n * exclusive = 0.\n */\nNGHTTP2_EXTERN void\nnghttp2_priority_spec_default_init(nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Returns nonzero if the |pri_spec| is filled with default values.\n */\nNGHTTP2_EXTERN int\nnghttp2_priority_spec_check_default(const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Submits HEADERS frame and optionally one or more DATA frames.\n *\n * The |pri_spec| is priority specification of this request.  ``NULL``\n * means the default priority (see\n * `nghttp2_priority_spec_default_init()`).  To specify the priority,\n * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,\n * this function will copy its data members.\n *\n * The ``pri_spec->weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec->weight`` is\n * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes\n * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than\n * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * HTTP/2 specification has requirement about header fields in the\n * request HEADERS.  See the specification for more details.\n *\n * If |data_prd| is not ``NULL``, it provides data which will be sent\n * in subsequent DATA frames.  In this case, a method that allows\n * request message bodies\n * (https://tools.ietf.org/html/rfc7231#section-4) must be specified\n * with ``:method`` key in |nva| (e.g. ``POST``).  This function does\n * not take ownership of the |data_prd|.  The function copies the\n * members of the |data_prd|.  If |data_prd| is ``NULL``, HEADERS have\n * END_STREAM set.  The |stream_user_data| is data associated to the\n * stream opened by this request and can be an arbitrary pointer,\n * which can be retrieved later by\n * `nghttp2_session_get_stream_user_data()`.\n *\n * This function returns assigned stream ID if it succeeds, or one of\n * the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`\n *     No stream ID is available because maximum stream ID was\n *     reached.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     Trying to depend on itself (new stream ID equals\n *     ``pri_spec->stream_id``).\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The |session| is server session.\n *\n * .. warning::\n *\n *   This function returns assigned stream ID if it succeeds.  But\n *   that stream is not created yet.  The application must not submit\n *   frame to that stream ID before\n *   :type:`nghttp2_before_frame_send_callback` is called for this\n *   frame.  This means `nghttp2_session_get_stream_user_data()` does\n *   not work before the callback.  But\n *   `nghttp2_session_set_stream_user_data()` handles this situation\n *   specially, and it can set data to a stream during this period.\n *\n */\nNGHTTP2_EXTERN int32_t nghttp2_submit_request(\n    nghttp2_session *session, const nghttp2_priority_spec *pri_spec,\n    const nghttp2_nv *nva, size_t nvlen, const nghttp2_data_provider *data_prd,\n    void *stream_user_data);\n\n/**\n * @function\n *\n * Submits response HEADERS frame and optionally one or more DATA\n * frames against the stream |stream_id|.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * HTTP/2 specification has requirement about header fields in the\n * response HEADERS.  See the specification for more details.\n *\n * If |data_prd| is not ``NULL``, it provides data which will be sent\n * in subsequent DATA frames.  This function does not take ownership\n * of the |data_prd|.  The function copies the members of the\n * |data_prd|.  If |data_prd| is ``NULL``, HEADERS will have\n * END_STREAM flag set.\n *\n * This method can be used as normal HTTP response and push response.\n * When pushing a resource using this function, the |session| must be\n * configured using `nghttp2_session_server_new()` or its variants and\n * the target stream denoted by the |stream_id| must be reserved using\n * `nghttp2_submit_push_promise()`.\n *\n * To send non-final response headers (e.g., HTTP status 101), don't\n * use this function because this function half-closes the outbound\n * stream.  Instead, use `nghttp2_submit_headers()` for this purpose.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_DATA_EXIST`\n *     DATA or HEADERS has been already submitted and not fully\n *     processed yet.  Normally, this does not happen, but when\n *     application wrongly calls `nghttp2_submit_response()` twice,\n *     this may happen.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The |session| is client session.\n *\n * .. warning::\n *\n *   Calling this function twice for the same stream ID may lead to\n *   program crash.  It is generally considered to a programming error\n *   to commit response twice.\n */\nNGHTTP2_EXTERN int\nnghttp2_submit_response(nghttp2_session *session, int32_t stream_id,\n                        const nghttp2_nv *nva, size_t nvlen,\n                        const nghttp2_data_provider *data_prd);\n\n/**\n * @function\n *\n * Submits trailer fields HEADERS against the stream |stream_id|.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application must not include pseudo-header\n * fields (headers whose names starts with \":\") in |nva|.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * For server, trailer fields must follow response HEADERS or response\n * DATA without END_STREAM flat set.  The library does not enforce\n * this requirement, and applications should do this for themselves.\n * If `nghttp2_submit_trailer()` is called before any response HEADERS\n * submission (usually by `nghttp2_submit_response()`), the content of\n * |nva| will be sent as response headers, which will result in error.\n *\n * This function has the same effect with `nghttp2_submit_headers()`,\n * with flags = :enum:`NGHTTP2_FLAG_END_STREAM` and both pri_spec and\n * stream_user_data to NULL.\n *\n * To submit trailer fields after `nghttp2_submit_response()` is\n * called, the application has to specify\n * :type:`nghttp2_data_provider` to `nghttp2_submit_response()`.\n * Inside of :type:`nghttp2_data_source_read_callback`, when setting\n * :enum:`NGHTTP2_DATA_FLAG_EOF`, also set\n * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM`.  After that, the\n * application can send trailer fields using\n * `nghttp2_submit_trailer()`.  `nghttp2_submit_trailer()` can be used\n * inside :type:`nghttp2_data_source_read_callback`.\n *\n * This function returns 0 if it succeeds and |stream_id| is -1.\n * Otherwise, this function returns 0 if it succeeds, or one of the\n * following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n */\nNGHTTP2_EXTERN int nghttp2_submit_trailer(nghttp2_session *session,\n                                          int32_t stream_id,\n                                          const nghttp2_nv *nva, size_t nvlen);\n\n/**\n * @function\n *\n * Submits HEADERS frame. The |flags| is bitwise OR of the\n * following values:\n *\n * * :enum:`NGHTTP2_FLAG_END_STREAM`\n *\n * If |flags| includes :enum:`NGHTTP2_FLAG_END_STREAM`, this frame has\n * END_STREAM flag set.\n *\n * The library handles the CONTINUATION frame internally and it\n * correctly sets END_HEADERS to the last sequence of the PUSH_PROMISE\n * or CONTINUATION frame.\n *\n * If the |stream_id| is -1, this frame is assumed as request (i.e.,\n * request HEADERS frame which opens new stream).  In this case, the\n * assigned stream ID will be returned.  Otherwise, specify stream ID\n * in |stream_id|.\n *\n * The |pri_spec| is priority specification of this request.  ``NULL``\n * means the default priority (see\n * `nghttp2_priority_spec_default_init()`).  To specify the priority,\n * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,\n * this function will copy its data members.\n *\n * The ``pri_spec->weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec->weight`` is\n * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes\n * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than\n * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * The |stream_user_data| is a pointer to an arbitrary data which is\n * associated to the stream this frame will open.  Therefore it is\n * only used if this frame opens streams, in other words, it changes\n * stream state from idle or reserved to open.\n *\n * This function is low-level in a sense that the application code can\n * specify flags directly.  For usual HTTP request,\n * `nghttp2_submit_request()` is useful.  Likewise, for HTTP response,\n * prefer `nghttp2_submit_response()`.\n *\n * This function returns newly assigned stream ID if it succeeds and\n * |stream_id| is -1.  Otherwise, this function returns 0 if it\n * succeeds, or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`\n *     No stream ID is available because maximum stream ID was\n *     reached.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0; or trying to depend on itself (stream ID\n *     equals ``pri_spec->stream_id``).\n * :enum:`NGHTTP2_ERR_DATA_EXIST`\n *     DATA or HEADERS has been already submitted and not fully\n *     processed yet.  This happens if stream denoted by |stream_id|\n *     is in reserved state.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     The |stream_id| is -1, and |session| is server session.\n *\n * .. warning::\n *\n *   This function returns assigned stream ID if it succeeds and\n *   |stream_id| is -1.  But that stream is not opened yet.  The\n *   application must not submit frame to that stream ID before\n *   :type:`nghttp2_before_frame_send_callback` is called for this\n *   frame.\n *\n */\nNGHTTP2_EXTERN int32_t nghttp2_submit_headers(\n    nghttp2_session *session, uint8_t flags, int32_t stream_id,\n    const nghttp2_priority_spec *pri_spec, const nghttp2_nv *nva, size_t nvlen,\n    void *stream_user_data);\n\n/**\n * @function\n *\n * Submits one or more DATA frames to the stream |stream_id|.  The\n * data to be sent are provided by |data_prd|.  If |flags| contains\n * :enum:`NGHTTP2_FLAG_END_STREAM`, the last DATA frame has END_STREAM\n * flag set.\n *\n * This function does not take ownership of the |data_prd|.  The\n * function copies the members of the |data_prd|.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_DATA_EXIST`\n *     DATA or HEADERS has been already submitted and not fully\n *     processed yet.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n * :enum:`NGHTTP2_ERR_STREAM_CLOSED`\n *     The stream was already closed; or the |stream_id| is invalid.\n *\n * .. note::\n *\n *   Currently, only one DATA or HEADERS is allowed for a stream at a\n *   time.  Submitting these frames more than once before first DATA\n *   or HEADERS is finished results in :enum:`NGHTTP2_ERR_DATA_EXIST`\n *   error code.  The earliest callback which tells that previous\n *   frame is done is :type:`nghttp2_on_frame_send_callback`.  In side\n *   that callback, new data can be submitted using\n *   `nghttp2_submit_data()`.  Of course, all data except for last one\n *   must not have :enum:`NGHTTP2_FLAG_END_STREAM` flag set in\n *   |flags|.  This sounds a bit complicated, and we recommend to use\n *   `nghttp2_submit_request()` and `nghttp2_submit_response()` to\n *   avoid this cascading issue.  The experience shows that for HTTP\n *   use, these two functions are enough to implement both client and\n *   server.\n */\nNGHTTP2_EXTERN int nghttp2_submit_data(nghttp2_session *session, uint8_t flags,\n                                       int32_t stream_id,\n                                       const nghttp2_data_provider *data_prd);\n\n/**\n * @function\n *\n * Submits PRIORITY frame to change the priority of stream |stream_id|\n * to the priority specification |pri_spec|.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |pri_spec| is priority specification of this request.  ``NULL``\n * is not allowed for this function. To specify the priority, use\n * `nghttp2_priority_spec_init()`.  This function will copy its data\n * members.\n *\n * The ``pri_spec->weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,\n * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec->weight`` is\n * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes\n * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than\n * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0; or the |pri_spec| is NULL; or trying to\n *     depend on itself.\n */\nNGHTTP2_EXTERN int\nnghttp2_submit_priority(nghttp2_session *session, uint8_t flags,\n                        int32_t stream_id,\n                        const nghttp2_priority_spec *pri_spec);\n\n/**\n * @function\n *\n * Submits RST_STREAM frame to cancel/reject the stream |stream_id|\n * with the error code |error_code|.\n *\n * The pre-defined error code is one of :enum:`nghttp2_error_code`.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0.\n */\nNGHTTP2_EXTERN int nghttp2_submit_rst_stream(nghttp2_session *session,\n                                             uint8_t flags, int32_t stream_id,\n                                             uint32_t error_code);\n\n/**\n * @function\n *\n * Stores local settings and submits SETTINGS frame.  The |iv| is the\n * pointer to the array of :type:`nghttp2_settings_entry`.  The |niv|\n * indicates the number of :type:`nghttp2_settings_entry`.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * This function does not take ownership of the |iv|.  This function\n * copies all the elements in the |iv|.\n *\n * While updating individual stream's local window size, if the window\n * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,\n * RST_STREAM is issued against such a stream.\n *\n * SETTINGS with :enum:`NGHTTP2_FLAG_ACK` is automatically submitted\n * by the library and application could not send it at its will.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |iv| contains invalid value (e.g., initial window size\n *     strictly greater than (1 << 31) - 1.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_submit_settings(nghttp2_session *session,\n                                           uint8_t flags,\n                                           const nghttp2_settings_entry *iv,\n                                           size_t niv);\n\n/**\n * @function\n *\n * Submits PUSH_PROMISE frame.\n *\n * The |flags| is currently ignored.  The library handles the\n * CONTINUATION frame internally and it correctly sets END_HEADERS to\n * the last sequence of the PUSH_PROMISE or CONTINUATION frame.\n *\n * The |stream_id| must be client initiated stream ID.\n *\n * The |nva| is an array of name/value pair :type:`nghttp2_nv` with\n * |nvlen| elements.  The application is responsible to include\n * required pseudo-header fields (header field whose name starts with\n * \":\") in |nva| and must place pseudo-headers before regular header\n * fields.\n *\n * This function creates copies of all name/value pairs in |nva|.  It\n * also lower-cases all names in |nva|.  The order of elements in\n * |nva| is preserved.  For header fields with\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name\n * and value are not copied respectively.  With\n * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to\n * pass header field name in lowercase.  The application should\n * maintain the references to them until\n * :type:`nghttp2_on_frame_send_callback` or\n * :type:`nghttp2_on_frame_not_send_callback` is called.\n *\n * The |promised_stream_user_data| is a pointer to an arbitrary data\n * which is associated to the promised stream this frame will open and\n * make it in reserved state.  It is available using\n * `nghttp2_session_get_stream_user_data()`.  The application can\n * access it in :type:`nghttp2_before_frame_send_callback` and\n * :type:`nghttp2_on_frame_send_callback` of this frame.\n *\n * The client side is not allowed to use this function.\n *\n * To submit response headers and data, use\n * `nghttp2_submit_response()`.\n *\n * This function returns assigned promised stream ID if it succeeds,\n * or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_PROTO`\n *     This function was invoked when |session| is initialized as\n *     client.\n * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`\n *     No stream ID is available because maximum stream ID was\n *     reached.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is 0; The |stream_id| does not designate stream\n *     that peer initiated.\n * :enum:`NGHTTP2_ERR_STREAM_CLOSED`\n *     The stream was already closed; or the |stream_id| is invalid.\n *\n * .. warning::\n *\n *   This function returns assigned promised stream ID if it succeeds.\n *   As of 1.16.0, stream object for pushed resource is created when\n *   this function succeeds.  In that case, the application can submit\n *   push response for the promised frame.\n *\n *   In 1.15.0 or prior versions, pushed stream is not opened yet when\n *   this function succeeds.  The application must not submit frame to\n *   that stream ID before :type:`nghttp2_before_frame_send_callback`\n *   is called for this frame.\n *\n */\nNGHTTP2_EXTERN int32_t nghttp2_submit_push_promise(\n    nghttp2_session *session, uint8_t flags, int32_t stream_id,\n    const nghttp2_nv *nva, size_t nvlen, void *promised_stream_user_data);\n\n/**\n * @function\n *\n * Submits PING frame.  You don't have to send PING back when you\n * received PING frame.  The library automatically submits PING frame\n * in this case.\n *\n * The |flags| is bitwise OR of 0 or more of the following value.\n *\n * * :enum:`NGHTTP2_FLAG_ACK`\n *\n * Unless `nghttp2_option_set_no_auto_ping_ack()` is used, the |flags|\n * should be :enum:`NGHTTP2_FLAG_NONE`.\n *\n * If the |opaque_data| is non ``NULL``, then it should point to the 8\n * bytes array of memory to specify opaque data to send with PING\n * frame.  If the |opaque_data| is ``NULL``, zero-cleared 8 bytes will\n * be sent as opaque data.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_submit_ping(nghttp2_session *session, uint8_t flags,\n                                       const uint8_t *opaque_data);\n\n/**\n * @function\n *\n * Submits GOAWAY frame with the last stream ID |last_stream_id| and\n * the error code |error_code|.\n *\n * The pre-defined error code is one of :enum:`nghttp2_error_code`.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |last_stream_id| is peer's stream ID or 0.  So if |session| is\n * initialized as client, |last_stream_id| must be even or 0.  If\n * |session| is initialized as server, |last_stream_id| must be odd or\n * 0.\n *\n * The HTTP/2 specification says last_stream_id must not be increased\n * from the value previously sent.  So the actual value sent as\n * last_stream_id is the minimum value between the given\n * |last_stream_id| and the last_stream_id previously sent to the\n * peer.\n *\n * If the |opaque_data| is not ``NULL`` and |opaque_data_len| is not\n * zero, those data will be sent as additional debug data.  The\n * library makes a copy of the memory region pointed by |opaque_data|\n * with the length |opaque_data_len|, so the caller does not need to\n * keep this memory after the return of this function.  If the\n * |opaque_data_len| is 0, the |opaque_data| could be ``NULL``.\n *\n * After successful transmission of GOAWAY, following things happen.\n * All incoming streams having strictly more than |last_stream_id| are\n * closed.  All incoming HEADERS which starts new stream are simply\n * ignored.  After all active streams are handled, both\n * `nghttp2_session_want_read()` and `nghttp2_session_want_write()`\n * return 0 and the application can close session.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |opaque_data_len| is too large; the |last_stream_id| is\n *     invalid.\n */\nNGHTTP2_EXTERN int nghttp2_submit_goaway(nghttp2_session *session,\n                                         uint8_t flags, int32_t last_stream_id,\n                                         uint32_t error_code,\n                                         const uint8_t *opaque_data,\n                                         size_t opaque_data_len);\n\n/**\n * @function\n *\n * Returns the last stream ID of a stream for which\n * :type:`nghttp2_on_frame_recv_callback` was invoked most recently.\n * The returned value can be used as last_stream_id parameter for\n * `nghttp2_submit_goaway()` and\n * `nghttp2_session_terminate_session2()`.\n *\n * This function always succeeds.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_session_get_last_proc_stream_id(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns nonzero if new request can be sent from local endpoint.\n *\n * This function return 0 if request is not allowed for this session.\n * There are several reasons why request is not allowed.  Some of the\n * reasons are: session is server; stream ID has been spent; GOAWAY\n * has been sent or received.\n *\n * The application can call `nghttp2_submit_request()` without\n * consulting this function.  In that case, `nghttp2_submit_request()`\n * may return error.  Or, request is failed to sent, and\n * :type:`nghttp2_on_stream_close_callback` is called.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_check_request_allowed(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns nonzero if |session| is initialized as server side session.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_check_server_session(nghttp2_session *session);\n\n/**\n * @function\n *\n * Submits WINDOW_UPDATE frame.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |stream_id| is the stream ID to send this WINDOW_UPDATE.  To\n * send connection level WINDOW_UPDATE, specify 0 to |stream_id|.\n *\n * If the |window_size_increment| is positive, the WINDOW_UPDATE with\n * that value as window_size_increment is queued.  If the\n * |window_size_increment| is larger than the received bytes from the\n * remote endpoint, the local window size is increased by that\n * difference.  If the sole purpose is to increase the local window\n * size, consider to use `nghttp2_session_set_local_window_size()`.\n *\n * If the |window_size_increment| is negative, the local window size\n * is decreased by -|window_size_increment|.  If automatic\n * WINDOW_UPDATE is enabled\n * (`nghttp2_option_set_no_auto_window_update()`), and the library\n * decided that the WINDOW_UPDATE should be submitted, then\n * WINDOW_UPDATE is queued with the current received bytes count.  If\n * the sole purpose is to decrease the local window size, consider to\n * use `nghttp2_session_set_local_window_size()`.\n *\n * If the |window_size_increment| is 0, the function does nothing and\n * returns 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_FLOW_CONTROL`\n *     The local window size overflow or gets negative.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_submit_window_update(nghttp2_session *session,\n                                                uint8_t flags,\n                                                int32_t stream_id,\n                                                int32_t window_size_increment);\n\n/**\n * @function\n *\n * Set local window size (local endpoints's window size) to the given\n * |window_size| for the given stream denoted by |stream_id|.  To\n * change connection level window size, specify 0 to |stream_id|.  To\n * increase window size, this function may submit WINDOW_UPDATE frame\n * to transmission queue.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * This sounds similar to `nghttp2_submit_window_update()`, but there\n * are 2 differences.  The first difference is that this function\n * takes the absolute value of window size to set, rather than the\n * delta.  To change the window size, this may be easier to use since\n * the application just declares the intended window size, rather than\n * calculating delta.  The second difference is that\n * `nghttp2_submit_window_update()` affects the received bytes count\n * which has not acked yet.  By the specification of\n * `nghttp2_submit_window_update()`, to strictly increase the local\n * window size, we have to submit delta including all received bytes\n * count, which might not be desirable in some cases.  On the other\n * hand, this function does not affect the received bytes count.  It\n * just sets the local window size to the given value.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The |stream_id| is negative.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_session_set_local_window_size(nghttp2_session *session, uint8_t flags,\n                                      int32_t stream_id, int32_t window_size);\n\n/**\n * @function\n *\n * Submits extension frame.\n *\n * Application can pass arbitrary frame flags and stream ID in |flags|\n * and |stream_id| respectively.  The |payload| is opaque pointer, and\n * it can be accessible though ``frame->ext.payload`` in\n * :type:`nghttp2_pack_extension_callback`.  The library will not own\n * passed |payload| pointer.\n *\n * The application must set :type:`nghttp2_pack_extension_callback`\n * using `nghttp2_session_callbacks_set_pack_extension_callback()`.\n *\n * The application should retain the memory pointed by |payload| until\n * the transmission of extension frame is done (which is indicated by\n * :type:`nghttp2_on_frame_send_callback`), or transmission fails\n * (which is indicated by :type:`nghttp2_on_frame_not_send_callback`).\n * If application does not touch this memory region after packing it\n * into a wire format, application can free it inside\n * :type:`nghttp2_pack_extension_callback`.\n *\n * The standard HTTP/2 frame cannot be sent with this function, so\n * |type| must be strictly grater than 0x9.  Otherwise, this function\n * will fail with error code :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     If :type:`nghttp2_pack_extension_callback` is not set.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     If  |type| specifies  standard  HTTP/2 frame  type.  The  frame\n *     types  in the  rage [0x0,  0x9], both  inclusive, are  standard\n *     HTTP/2 frame type, and cannot be sent using this function.\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory\n */\nNGHTTP2_EXTERN int nghttp2_submit_extension(nghttp2_session *session,\n                                            uint8_t type, uint8_t flags,\n                                            int32_t stream_id, void *payload);\n\n/**\n * @struct\n *\n * The payload of ALTSVC frame.  ALTSVC frame is a non-critical\n * extension to HTTP/2.  If this frame is received, and\n * `nghttp2_option_set_user_recv_extension_type()` is not set, and\n * `nghttp2_option_set_builtin_recv_extension_type()` is set for\n * :enum:`NGHTTP2_ALTSVC`, ``nghttp2_extension.payload`` will point to\n * this struct.\n *\n * It has the following members:\n */\ntypedef struct {\n  /**\n   * The pointer to origin which this alternative service is\n   * associated with.  This is not necessarily NULL-terminated.\n   */\n  uint8_t *origin;\n  /**\n   * The length of the |origin|.\n   */\n  size_t origin_len;\n  /**\n   * The pointer to Alt-Svc field value contained in ALTSVC frame.\n   * This is not necessarily NULL-terminated.\n   */\n  uint8_t *field_value;\n  /**\n   * The length of the |field_value|.\n   */\n  size_t field_value_len;\n} nghttp2_ext_altsvc;\n\n/**\n * @function\n *\n * Submits ALTSVC frame.\n *\n * ALTSVC frame is a non-critical extension to HTTP/2, and defined in\n * `RFC 7383 <https://tools.ietf.org/html/rfc7838#section-4>`_.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |origin| points to the origin this alternative service is\n * associated with.  The |origin_len| is the length of the origin.  If\n * |stream_id| is 0, the origin must be specified.  If |stream_id| is\n * not zero, the origin must be empty (in other words, |origin_len|\n * must be 0).\n *\n * The ALTSVC frame is only usable from server side.  If this function\n * is invoked with client side session, this function returns\n * :enum:`NGHTTP2_ERR_INVALID_STATE`.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The function is called from client side session\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     The sum of |origin_len| and |field_value_len| is larger than\n *     16382; or |origin_len| is 0 while |stream_id| is 0; or\n *     |origin_len| is not 0 while |stream_id| is not 0.\n */\nNGHTTP2_EXTERN int nghttp2_submit_altsvc(nghttp2_session *session,\n                                         uint8_t flags, int32_t stream_id,\n                                         const uint8_t *origin,\n                                         size_t origin_len,\n                                         const uint8_t *field_value,\n                                         size_t field_value_len);\n\n/**\n * @struct\n *\n * The single entry of an origin.\n */\ntypedef struct {\n  /**\n   * The pointer to origin.  No validation is made against this field\n   * by the library.  This is not necessarily NULL-terminated.\n   */\n  uint8_t *origin;\n  /**\n   * The length of the |origin|.\n   */\n  size_t origin_len;\n} nghttp2_origin_entry;\n\n/**\n * @struct\n *\n * The payload of ORIGIN frame.  ORIGIN frame is a non-critical\n * extension to HTTP/2 and defined by `RFC 8336\n * <https://tools.ietf.org/html/rfc8336>`_.\n *\n * If this frame is received, and\n * `nghttp2_option_set_user_recv_extension_type()` is not set, and\n * `nghttp2_option_set_builtin_recv_extension_type()` is set for\n * :enum:`NGHTTP2_ORIGIN`, ``nghttp2_extension.payload`` will point to\n * this struct.\n *\n * It has the following members:\n */\ntypedef struct {\n  /**\n   * The number of origins contained in |ov|.\n   */\n  size_t nov;\n  /**\n   * The pointer to the array of origins contained in ORIGIN frame.\n   */\n  nghttp2_origin_entry *ov;\n} nghttp2_ext_origin;\n\n/**\n * @function\n *\n * Submits ORIGIN frame.\n *\n * ORIGIN frame is a non-critical extension to HTTP/2 and defined by\n * `RFC 8336 <https://tools.ietf.org/html/rfc8336>`_.\n *\n * The |flags| is currently ignored and should be\n * :enum:`NGHTTP2_FLAG_NONE`.\n *\n * The |ov| points to the array of origins.  The |nov| specifies the\n * number of origins included in |ov|.  This function creates copies\n * of all elements in |ov|.\n *\n * The ORIGIN frame is only usable by a server.  If this function is\n * invoked with client side session, this function returns\n * :enum:`NGHTTP2_ERR_INVALID_STATE`.\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The function is called from client side session.\n * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`\n *     There are too many origins, or an origin is too large to fit\n *     into a default frame payload.\n */\nNGHTTP2_EXTERN int nghttp2_submit_origin(nghttp2_session *session,\n                                         uint8_t flags,\n                                         const nghttp2_origin_entry *ov,\n                                         size_t nov);\n\n/**\n * @function\n *\n * Compares ``lhs->name`` of length ``lhs->namelen`` bytes and\n * ``rhs->name`` of length ``rhs->namelen`` bytes.  Returns negative\n * integer if ``lhs->name`` is found to be less than ``rhs->name``; or\n * returns positive integer if ``lhs->name`` is found to be greater\n * than ``rhs->name``; or returns 0 otherwise.\n */\nNGHTTP2_EXTERN int nghttp2_nv_compare_name(const nghttp2_nv *lhs,\n                                           const nghttp2_nv *rhs);\n\n/**\n * @function\n *\n * A helper function for dealing with NPN in client side or ALPN in\n * server side.  The |in| contains peer's protocol list in preferable\n * order.  The format of |in| is length-prefixed and not\n * null-terminated.  For example, ``h2`` and\n * ``http/1.1`` stored in |in| like this::\n *\n *     in[0] = 2\n *     in[1..2] = \"h2\"\n *     in[3] = 8\n *     in[4..11] = \"http/1.1\"\n *     inlen = 12\n *\n * The selection algorithm is as follows:\n *\n * 1. If peer's list contains HTTP/2 protocol the library supports,\n *    it is selected and returns 1. The following step is not taken.\n *\n * 2. If peer's list contains ``http/1.1``, this function selects\n *    ``http/1.1`` and returns 0.  The following step is not taken.\n *\n * 3. This function selects nothing and returns -1 (So called\n *    non-overlap case).  In this case, |out| and |outlen| are left\n *    untouched.\n *\n * Selecting ``h2`` means that ``h2`` is written into |*out| and its\n * length (which is 2) is assigned to |*outlen|.\n *\n * For ALPN, refer to https://tools.ietf.org/html/rfc7301\n *\n * See http://technotes.googlecode.com/git/nextprotoneg.html for more\n * details about NPN.\n *\n * For NPN, to use this method you should do something like::\n *\n *     static int select_next_proto_cb(SSL* ssl,\n *                                     unsigned char **out,\n *                                     unsigned char *outlen,\n *                                     const unsigned char *in,\n *                                     unsigned int inlen,\n *                                     void *arg)\n *     {\n *         int rv;\n *         rv = nghttp2_select_next_protocol(out, outlen, in, inlen);\n *         if (rv == -1) {\n *             return SSL_TLSEXT_ERR_NOACK;\n *         }\n *         if (rv == 1) {\n *             ((MyType*)arg)->http2_selected = 1;\n *         }\n *         return SSL_TLSEXT_ERR_OK;\n *     }\n *     ...\n *     SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb, my_obj);\n *\n */\nNGHTTP2_EXTERN int nghttp2_select_next_protocol(unsigned char **out,\n                                                unsigned char *outlen,\n                                                const unsigned char *in,\n                                                unsigned int inlen);\n\n/**\n * @function\n *\n * Returns a pointer to a nghttp2_info struct with version information\n * about the run-time library in use.  The |least_version| argument\n * can be set to a 24 bit numerical value for the least accepted\n * version number and if the condition is not met, this function will\n * return a ``NULL``.  Pass in 0 to skip the version checking.\n */\nNGHTTP2_EXTERN nghttp2_info *nghttp2_version(int least_version);\n\n/**\n * @function\n *\n * Returns nonzero if the :type:`nghttp2_error` library error code\n * |lib_error| is fatal.\n */\nNGHTTP2_EXTERN int nghttp2_is_fatal(int lib_error_code);\n\n/**\n * @function\n *\n * Returns nonzero if HTTP header field name |name| of length |len| is\n * valid according to http://tools.ietf.org/html/rfc7230#section-3.2\n *\n * Because this is a header field name in HTTP2, the upper cased alphabet\n * is treated as error.\n */\nNGHTTP2_EXTERN int nghttp2_check_header_name(const uint8_t *name, size_t len);\n\n/**\n * @function\n *\n * Returns nonzero if HTTP header field value |value| of length |len|\n * is valid according to\n * http://tools.ietf.org/html/rfc7230#section-3.2\n */\nNGHTTP2_EXTERN int nghttp2_check_header_value(const uint8_t *value, size_t len);\n\n/**\n * @function\n *\n * Returns nonzero if the |value| which is supposed to the value of\n * :authority or host header field is valid according to\n * https://tools.ietf.org/html/rfc3986#section-3.2\n *\n * |value| is valid if it merely consists of the allowed characters.\n * In particular, it does not check whether |value| follows the syntax\n * of authority.\n */\nNGHTTP2_EXTERN int nghttp2_check_authority(const uint8_t *value, size_t len);\n\n/* HPACK API */\n\nstruct nghttp2_hd_deflater;\n\n/**\n * @struct\n *\n * HPACK deflater object.\n */\ntypedef struct nghttp2_hd_deflater nghttp2_hd_deflater;\n\n/**\n * @function\n *\n * Initializes |*deflater_ptr| for deflating name/values pairs.\n *\n * The |max_deflate_dynamic_table_size| is the upper bound of header\n * table size the deflater will use.\n *\n * If this function fails, |*deflater_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_deflate_new(nghttp2_hd_deflater **deflater_ptr,\n                       size_t max_deflate_dynamic_table_size);\n\n/**\n * @function\n *\n * Like `nghttp2_hd_deflate_new()`, but with additional custom memory\n * allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_hd_deflate_new()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_deflate_new2(nghttp2_hd_deflater **deflater_ptr,\n                        size_t max_deflate_dynamic_table_size,\n                        nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Deallocates any resources allocated for |deflater|.\n */\nNGHTTP2_EXTERN void nghttp2_hd_deflate_del(nghttp2_hd_deflater *deflater);\n\n/**\n * @function\n *\n * Changes header table size of the |deflater| to\n * |settings_max_dynamic_table_size| bytes.  This may trigger eviction\n * in the dynamic table.\n *\n * The |settings_max_dynamic_table_size| should be the value received\n * in SETTINGS_HEADER_TABLE_SIZE.\n *\n * The deflater never uses more memory than\n * ``max_deflate_dynamic_table_size`` bytes specified in\n * `nghttp2_hd_deflate_new()`.  Therefore, if\n * |settings_max_dynamic_table_size| >\n * ``max_deflate_dynamic_table_size``, resulting maximum table size\n * becomes ``max_deflate_dynamic_table_size``.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_deflate_change_table_size(nghttp2_hd_deflater *deflater,\n                                     size_t settings_max_dynamic_table_size);\n\n/**\n * @function\n *\n * Deflates the |nva|, which has the |nvlen| name/value pairs, into\n * the |buf| of length |buflen|.\n *\n * If |buf| is not large enough to store the deflated header block,\n * this function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The\n * caller should use `nghttp2_hd_deflate_bound()` to know the upper\n * bound of buffer size required to deflate given header name/value\n * pairs.\n *\n * Once this function fails, subsequent call of this function always\n * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.\n *\n * After this function returns, it is safe to delete the |nva|.\n *\n * This function returns the number of bytes written to |buf| if it\n * succeeds, or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Deflation process has failed.\n * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`\n *     The provided |buflen| size is too small to hold the output.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_deflate_hd(nghttp2_hd_deflater *deflater,\n                                             uint8_t *buf, size_t buflen,\n                                             const nghttp2_nv *nva,\n                                             size_t nvlen);\n\n/**\n * @function\n *\n * Deflates the |nva|, which has the |nvlen| name/value pairs, into\n * the |veclen| size of buf vector |vec|.  The each size of buffer\n * must be set in len field of :type:`nghttp2_vec`.  If and only if\n * one chunk is filled up completely, next chunk will be used.  If\n * |vec| is not large enough to store the deflated header block, this\n * function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The caller\n * should use `nghttp2_hd_deflate_bound()` to know the upper bound of\n * buffer size required to deflate given header name/value pairs.\n *\n * Once this function fails, subsequent call of this function always\n * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.\n *\n * After this function returns, it is safe to delete the |nva|.\n *\n * This function returns the number of bytes written to |vec| if it\n * succeeds, or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Deflation process has failed.\n * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`\n *     The provided |buflen| size is too small to hold the output.\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_deflate_hd_vec(nghttp2_hd_deflater *deflater,\n                                                 const nghttp2_vec *vec,\n                                                 size_t veclen,\n                                                 const nghttp2_nv *nva,\n                                                 size_t nvlen);\n\n/**\n * @function\n *\n * Returns an upper bound on the compressed size after deflation of\n * |nva| of length |nvlen|.\n */\nNGHTTP2_EXTERN size_t nghttp2_hd_deflate_bound(nghttp2_hd_deflater *deflater,\n                                               const nghttp2_nv *nva,\n                                               size_t nvlen);\n\n/**\n * @function\n *\n * Returns the number of entries that header table of |deflater|\n * contains.  This is the sum of the number of static table and\n * dynamic table, so the return value is at least 61.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_deflate_get_num_table_entries(nghttp2_hd_deflater *deflater);\n\n/**\n * @function\n *\n * Returns the table entry denoted by |idx| from header table of\n * |deflater|.  The |idx| is 1-based, and idx=1 returns first entry of\n * static table.  idx=62 returns first entry of dynamic table if it\n * exists.  Specifying idx=0 is error, and this function returns NULL.\n * If |idx| is strictly greater than the number of entries the tables\n * contain, this function returns NULL.\n */\nNGHTTP2_EXTERN\nconst nghttp2_nv *\nnghttp2_hd_deflate_get_table_entry(nghttp2_hd_deflater *deflater, size_t idx);\n\n/**\n * @function\n *\n * Returns the used dynamic table size, including the overhead 32\n * bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_deflate_get_dynamic_table_size(nghttp2_hd_deflater *deflater);\n\n/**\n * @function\n *\n * Returns the maximum dynamic table size.\n */\nNGHTTP2_EXTERN\nsize_t\nnghttp2_hd_deflate_get_max_dynamic_table_size(nghttp2_hd_deflater *deflater);\n\nstruct nghttp2_hd_inflater;\n\n/**\n * @struct\n *\n * HPACK inflater object.\n */\ntypedef struct nghttp2_hd_inflater nghttp2_hd_inflater;\n\n/**\n * @function\n *\n * Initializes |*inflater_ptr| for inflating name/values pairs.\n *\n * If this function fails, |*inflater_ptr| is left untouched.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n */\nNGHTTP2_EXTERN int nghttp2_hd_inflate_new(nghttp2_hd_inflater **inflater_ptr);\n\n/**\n * @function\n *\n * Like `nghttp2_hd_inflate_new()`, but with additional custom memory\n * allocator specified in the |mem|.\n *\n * The |mem| can be ``NULL`` and the call is equivalent to\n * `nghttp2_hd_inflate_new()`.\n *\n * This function does not take ownership |mem|.  The application is\n * responsible for freeing |mem|.\n *\n * The library code does not refer to |mem| pointer after this\n * function returns, so the application can safely free it.\n */\nNGHTTP2_EXTERN int nghttp2_hd_inflate_new2(nghttp2_hd_inflater **inflater_ptr,\n                                           nghttp2_mem *mem);\n\n/**\n * @function\n *\n * Deallocates any resources allocated for |inflater|.\n */\nNGHTTP2_EXTERN void nghttp2_hd_inflate_del(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Changes header table size in the |inflater|.  This may trigger\n * eviction in the dynamic table.\n *\n * The |settings_max_dynamic_table_size| should be the value\n * transmitted in SETTINGS_HEADER_TABLE_SIZE.\n *\n * This function must not be called while header block is being\n * inflated.  In other words, this function must be called after\n * initialization of |inflater|, but before calling\n * `nghttp2_hd_inflate_hd2()`, or after\n * `nghttp2_hd_inflate_end_headers()`.  Otherwise,\n * `NGHTTP2_ERR_INVALID_STATE` was returned.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_INVALID_STATE`\n *     The function is called while header block is being inflated.\n *     Probably, application missed to call\n *     `nghttp2_hd_inflate_end_headers()`.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_inflate_change_table_size(nghttp2_hd_inflater *inflater,\n                                     size_t settings_max_dynamic_table_size);\n\n/**\n * @enum\n *\n * The flags for header inflation.\n */\ntypedef enum {\n  /**\n   * No flag set.\n   */\n  NGHTTP2_HD_INFLATE_NONE = 0,\n  /**\n   * Indicates all headers were inflated.\n   */\n  NGHTTP2_HD_INFLATE_FINAL = 0x01,\n  /**\n   * Indicates a header was emitted.\n   */\n  NGHTTP2_HD_INFLATE_EMIT = 0x02\n} nghttp2_hd_inflate_flag;\n\n/**\n * @function\n *\n * .. warning::\n *\n *   Deprecated.  Use `nghttp2_hd_inflate_hd2()` instead.\n *\n * Inflates name/value block stored in |in| with length |inlen|.  This\n * function performs decompression.  For each successful emission of\n * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in\n * |*inflate_flags| and name/value pair is assigned to the |nv_out|\n * and the function returns.  The caller must not free the members of\n * |nv_out|.\n *\n * The |nv_out| may include pointers to the memory region in the |in|.\n * The caller must retain the |in| while the |nv_out| is used.\n *\n * The application should call this function repeatedly until the\n * ``(*inflate_flags) & NGHTTP2_HD_INFLATE_FINAL`` is nonzero and\n * return value is non-negative.  This means the all input values are\n * processed successfully.  Then the application must call\n * `nghttp2_hd_inflate_end_headers()` to prepare for the next header\n * block input.\n *\n * The caller can feed complete compressed header block.  It also can\n * feed it in several chunks.  The caller must set |in_final| to\n * nonzero if the given input is the last block of the compressed\n * header.\n *\n * This function returns the number of bytes processed if it succeeds,\n * or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Inflation process has failed.\n * :enum:`NGHTTP2_ERR_BUFFER_ERROR`\n *     The header field name or value is too large.\n *\n * Example follows::\n *\n *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,\n *                              uint8_t *in, size_t inlen, int final)\n *     {\n *         ssize_t rv;\n *\n *         for(;;) {\n *             nghttp2_nv nv;\n *             int inflate_flags = 0;\n *\n *             rv = nghttp2_hd_inflate_hd(hd_inflater, &nv, &inflate_flags,\n *                                        in, inlen, final);\n *\n *             if(rv < 0) {\n *                 fprintf(stderr, \"inflate failed with error code %zd\", rv);\n *                 return -1;\n *             }\n *\n *             in += rv;\n *             inlen -= rv;\n *\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_EMIT) {\n *                 fwrite(nv.name, nv.namelen, 1, stderr);\n *                 fprintf(stderr, \": \");\n *                 fwrite(nv.value, nv.valuelen, 1, stderr);\n *                 fprintf(stderr, \"\\n\");\n *             }\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\n *                 nghttp2_hd_inflate_end_headers(hd_inflater);\n *                 break;\n *             }\n *             if((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 &&\n *                inlen == 0) {\n *                break;\n *             }\n *         }\n *\n *         return 0;\n *     }\n *\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_inflate_hd(nghttp2_hd_inflater *inflater,\n                                             nghttp2_nv *nv_out,\n                                             int *inflate_flags, uint8_t *in,\n                                             size_t inlen, int in_final);\n\n/**\n * @function\n *\n * Inflates name/value block stored in |in| with length |inlen|.  This\n * function performs decompression.  For each successful emission of\n * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in\n * |*inflate_flags| and name/value pair is assigned to the |nv_out|\n * and the function returns.  The caller must not free the members of\n * |nv_out|.\n *\n * The |nv_out| may include pointers to the memory region in the |in|.\n * The caller must retain the |in| while the |nv_out| is used.\n *\n * The application should call this function repeatedly until the\n * ``(*inflate_flags) & NGHTTP2_HD_INFLATE_FINAL`` is nonzero and\n * return value is non-negative.  If that happens, all given input\n * data (|inlen| bytes) are processed successfully.  Then the\n * application must call `nghttp2_hd_inflate_end_headers()` to prepare\n * for the next header block input.\n *\n * In other words, if |in_final| is nonzero, and this function returns\n * |inlen|, you can assert that :enum:`NGHTTP2_HD_INFLATE_FINAL` is\n * set in |*inflate_flags|.\n *\n * The caller can feed complete compressed header block.  It also can\n * feed it in several chunks.  The caller must set |in_final| to\n * nonzero if the given input is the last block of the compressed\n * header.\n *\n * This function returns the number of bytes processed if it succeeds,\n * or one of the following negative error codes:\n *\n * :enum:`NGHTTP2_ERR_NOMEM`\n *     Out of memory.\n * :enum:`NGHTTP2_ERR_HEADER_COMP`\n *     Inflation process has failed.\n * :enum:`NGHTTP2_ERR_BUFFER_ERROR`\n *     The header field name or value is too large.\n *\n * Example follows::\n *\n *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,\n *                              uint8_t *in, size_t inlen, int final)\n *     {\n *         ssize_t rv;\n *\n *         for(;;) {\n *             nghttp2_nv nv;\n *             int inflate_flags = 0;\n *\n *             rv = nghttp2_hd_inflate_hd2(hd_inflater, &nv, &inflate_flags,\n *                                         in, inlen, final);\n *\n *             if(rv < 0) {\n *                 fprintf(stderr, \"inflate failed with error code %zd\", rv);\n *                 return -1;\n *             }\n *\n *             in += rv;\n *             inlen -= rv;\n *\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_EMIT) {\n *                 fwrite(nv.name, nv.namelen, 1, stderr);\n *                 fprintf(stderr, \": \");\n *                 fwrite(nv.value, nv.valuelen, 1, stderr);\n *                 fprintf(stderr, \"\\n\");\n *             }\n *             if(inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\n *                 nghttp2_hd_inflate_end_headers(hd_inflater);\n *                 break;\n *             }\n *             if((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 &&\n *                inlen == 0) {\n *                break;\n *             }\n *         }\n *\n *         return 0;\n *     }\n *\n */\nNGHTTP2_EXTERN ssize_t nghttp2_hd_inflate_hd2(nghttp2_hd_inflater *inflater,\n                                              nghttp2_nv *nv_out,\n                                              int *inflate_flags,\n                                              const uint8_t *in, size_t inlen,\n                                              int in_final);\n\n/**\n * @function\n *\n * Signals the end of decompression for one header block.\n *\n * This function returns 0 if it succeeds. Currently this function\n * always succeeds.\n */\nNGHTTP2_EXTERN int\nnghttp2_hd_inflate_end_headers(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Returns the number of entries that header table of |inflater|\n * contains.  This is the sum of the number of static table and\n * dynamic table, so the return value is at least 61.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_inflate_get_num_table_entries(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Returns the table entry denoted by |idx| from header table of\n * |inflater|.  The |idx| is 1-based, and idx=1 returns first entry of\n * static table.  idx=62 returns first entry of dynamic table if it\n * exists.  Specifying idx=0 is error, and this function returns NULL.\n * If |idx| is strictly greater than the number of entries the tables\n * contain, this function returns NULL.\n */\nNGHTTP2_EXTERN\nconst nghttp2_nv *\nnghttp2_hd_inflate_get_table_entry(nghttp2_hd_inflater *inflater, size_t idx);\n\n/**\n * @function\n *\n * Returns the used dynamic table size, including the overhead 32\n * bytes per entry described in RFC 7541.\n */\nNGHTTP2_EXTERN\nsize_t nghttp2_hd_inflate_get_dynamic_table_size(nghttp2_hd_inflater *inflater);\n\n/**\n * @function\n *\n * Returns the maximum dynamic table size.\n */\nNGHTTP2_EXTERN\nsize_t\nnghttp2_hd_inflate_get_max_dynamic_table_size(nghttp2_hd_inflater *inflater);\n\nstruct nghttp2_stream;\n\n/**\n * @struct\n *\n * The structure to represent HTTP/2 stream.  The details of this\n * structure are intentionally hidden from the public API.\n */\ntypedef struct nghttp2_stream nghttp2_stream;\n\n/**\n * @function\n *\n * Returns pointer to :type:`nghttp2_stream` object denoted by\n * |stream_id|.  If stream was not found, returns NULL.\n *\n * Returns imaginary root stream (see\n * `nghttp2_session_get_root_stream()`) if 0 is given in |stream_id|.\n *\n * Unless |stream_id| == 0, the returned pointer is valid until next\n * call of `nghttp2_session_send()`, `nghttp2_session_mem_send()`,\n * `nghttp2_session_recv()`, and `nghttp2_session_mem_recv()`.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_session_find_stream(nghttp2_session *session, int32_t stream_id);\n\n/**\n * @enum\n *\n * State of stream as described in RFC 7540.\n */\ntypedef enum {\n  /**\n   * idle state.\n   */\n  NGHTTP2_STREAM_STATE_IDLE = 1,\n  /**\n   * open state.\n   */\n  NGHTTP2_STREAM_STATE_OPEN,\n  /**\n   * reserved (local) state.\n   */\n  NGHTTP2_STREAM_STATE_RESERVED_LOCAL,\n  /**\n   * reserved (remote) state.\n   */\n  NGHTTP2_STREAM_STATE_RESERVED_REMOTE,\n  /**\n   * half closed (local) state.\n   */\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL,\n  /**\n   * half closed (remote) state.\n   */\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE,\n  /**\n   * closed state.\n   */\n  NGHTTP2_STREAM_STATE_CLOSED\n} nghttp2_stream_proto_state;\n\n/**\n * @function\n *\n * Returns state of |stream|.  The root stream retrieved by\n * `nghttp2_session_get_root_stream()` will have stream state\n * :enum:`NGHTTP2_STREAM_STATE_IDLE`.\n */\nNGHTTP2_EXTERN nghttp2_stream_proto_state\nnghttp2_stream_get_state(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns root of dependency tree, which is imaginary stream with\n * stream ID 0.  The returned pointer is valid until |session| is\n * freed by `nghttp2_session_del()`.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_session_get_root_stream(nghttp2_session *session);\n\n/**\n * @function\n *\n * Returns the parent stream of |stream| in dependency tree.  Returns\n * NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_parent(nghttp2_stream *stream);\n\nNGHTTP2_EXTERN int32_t nghttp2_stream_get_stream_id(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the next sibling stream of |stream| in dependency tree.\n * Returns NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_next_sibling(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the previous sibling stream of |stream| in dependency tree.\n * Returns NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_previous_sibling(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the first child stream of |stream| in dependency tree.\n * Returns NULL if there is no such stream.\n */\nNGHTTP2_EXTERN nghttp2_stream *\nnghttp2_stream_get_first_child(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns dependency weight to the parent stream of |stream|.\n */\nNGHTTP2_EXTERN int32_t nghttp2_stream_get_weight(nghttp2_stream *stream);\n\n/**\n * @function\n *\n * Returns the sum of the weight for |stream|'s children.\n */\nNGHTTP2_EXTERN int32_t\nnghttp2_stream_get_sum_dependency_weight(nghttp2_stream *stream);\n\n/**\n * @functypedef\n *\n * Callback function invoked when the library outputs debug logging.\n * The function is called with arguments suitable for ``vfprintf(3)``\n *\n * The debug output is only enabled if the library is built with\n * ``DEBUGBUILD`` macro defined.\n */\ntypedef void (*nghttp2_debug_vprintf_callback)(const char *format,\n                                               va_list args);\n\n/**\n * @function\n *\n * Sets a debug output callback called by the library when built with\n * ``DEBUGBUILD`` macro defined.  If this option is not used, debug\n * log is written into standard error output.\n *\n * For builds without ``DEBUGBUILD`` macro defined, this function is\n * noop.\n *\n * Note that building with ``DEBUGBUILD`` may cause significant\n * performance penalty to libnghttp2 because of extra processing.  It\n * should be used for debugging purpose only.\n *\n * .. Warning::\n *\n *   Building with ``DEBUGBUILD`` may cause significant performance\n *   penalty to libnghttp2 because of extra processing.  It should be\n *   used for debugging purpose only.  We write this two times because\n *   this is important.\n */\nNGHTTP2_EXTERN void nghttp2_set_debug_vprintf_callback(\n    nghttp2_debug_vprintf_callback debug_vprintf_callback);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NGHTTP2_H */\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_helper.h\"\n\n#include <assert.h>\n#include <string.h>\n\n#include \"nghttp2_net.h\"\n\nvoid nghttp2_put_uint16be(uint8_t *buf, uint16_t n) {\n  uint16_t x = htons(n);\n  memcpy(buf, &x, sizeof(uint16_t));\n}\n\nvoid nghttp2_put_uint32be(uint8_t *buf, uint32_t n) {\n  uint32_t x = htonl(n);\n  memcpy(buf, &x, sizeof(uint32_t));\n}\n\nuint16_t nghttp2_get_uint16(const uint8_t *data) {\n  uint16_t n;\n  memcpy(&n, data, sizeof(uint16_t));\n  return ntohs(n);\n}\n\nuint32_t nghttp2_get_uint32(const uint8_t *data) {\n  uint32_t n;\n  memcpy(&n, data, sizeof(uint32_t));\n  return ntohl(n);\n}\n\n/* Generated by gendowncasetbl.py */\nstatic const uint8_t DOWNCASE_TBL[] = {\n    0 /* NUL  */,   1 /* SOH  */,   2 /* STX  */,   3 /* ETX  */,\n    4 /* EOT  */,   5 /* ENQ  */,   6 /* ACK  */,   7 /* BEL  */,\n    8 /* BS   */,   9 /* HT   */,   10 /* LF   */,  11 /* VT   */,\n    12 /* FF   */,  13 /* CR   */,  14 /* SO   */,  15 /* SI   */,\n    16 /* DLE  */,  17 /* DC1  */,  18 /* DC2  */,  19 /* DC3  */,\n    20 /* DC4  */,  21 /* NAK  */,  22 /* SYN  */,  23 /* ETB  */,\n    24 /* CAN  */,  25 /* EM   */,  26 /* SUB  */,  27 /* ESC  */,\n    28 /* FS   */,  29 /* GS   */,  30 /* RS   */,  31 /* US   */,\n    32 /* SPC  */,  33 /* !    */,  34 /* \"    */,  35 /* #    */,\n    36 /* $    */,  37 /* %    */,  38 /* &    */,  39 /* '    */,\n    40 /* (    */,  41 /* )    */,  42 /* *    */,  43 /* +    */,\n    44 /* ,    */,  45 /* -    */,  46 /* .    */,  47 /* /    */,\n    48 /* 0    */,  49 /* 1    */,  50 /* 2    */,  51 /* 3    */,\n    52 /* 4    */,  53 /* 5    */,  54 /* 6    */,  55 /* 7    */,\n    56 /* 8    */,  57 /* 9    */,  58 /* :    */,  59 /* ;    */,\n    60 /* <    */,  61 /* =    */,  62 /* >    */,  63 /* ?    */,\n    64 /* @    */,  97 /* A    */,  98 /* B    */,  99 /* C    */,\n    100 /* D    */, 101 /* E    */, 102 /* F    */, 103 /* G    */,\n    104 /* H    */, 105 /* I    */, 106 /* J    */, 107 /* K    */,\n    108 /* L    */, 109 /* M    */, 110 /* N    */, 111 /* O    */,\n    112 /* P    */, 113 /* Q    */, 114 /* R    */, 115 /* S    */,\n    116 /* T    */, 117 /* U    */, 118 /* V    */, 119 /* W    */,\n    120 /* X    */, 121 /* Y    */, 122 /* Z    */, 91 /* [    */,\n    92 /* \\    */,  93 /* ]    */,  94 /* ^    */,  95 /* _    */,\n    96 /* `    */,  97 /* a    */,  98 /* b    */,  99 /* c    */,\n    100 /* d    */, 101 /* e    */, 102 /* f    */, 103 /* g    */,\n    104 /* h    */, 105 /* i    */, 106 /* j    */, 107 /* k    */,\n    108 /* l    */, 109 /* m    */, 110 /* n    */, 111 /* o    */,\n    112 /* p    */, 113 /* q    */, 114 /* r    */, 115 /* s    */,\n    116 /* t    */, 117 /* u    */, 118 /* v    */, 119 /* w    */,\n    120 /* x    */, 121 /* y    */, 122 /* z    */, 123 /* {    */,\n    124 /* |    */, 125 /* }    */, 126 /* ~    */, 127 /* DEL  */,\n    128 /* 0x80 */, 129 /* 0x81 */, 130 /* 0x82 */, 131 /* 0x83 */,\n    132 /* 0x84 */, 133 /* 0x85 */, 134 /* 0x86 */, 135 /* 0x87 */,\n    136 /* 0x88 */, 137 /* 0x89 */, 138 /* 0x8a */, 139 /* 0x8b */,\n    140 /* 0x8c */, 141 /* 0x8d */, 142 /* 0x8e */, 143 /* 0x8f */,\n    144 /* 0x90 */, 145 /* 0x91 */, 146 /* 0x92 */, 147 /* 0x93 */,\n    148 /* 0x94 */, 149 /* 0x95 */, 150 /* 0x96 */, 151 /* 0x97 */,\n    152 /* 0x98 */, 153 /* 0x99 */, 154 /* 0x9a */, 155 /* 0x9b */,\n    156 /* 0x9c */, 157 /* 0x9d */, 158 /* 0x9e */, 159 /* 0x9f */,\n    160 /* 0xa0 */, 161 /* 0xa1 */, 162 /* 0xa2 */, 163 /* 0xa3 */,\n    164 /* 0xa4 */, 165 /* 0xa5 */, 166 /* 0xa6 */, 167 /* 0xa7 */,\n    168 /* 0xa8 */, 169 /* 0xa9 */, 170 /* 0xaa */, 171 /* 0xab */,\n    172 /* 0xac */, 173 /* 0xad */, 174 /* 0xae */, 175 /* 0xaf */,\n    176 /* 0xb0 */, 177 /* 0xb1 */, 178 /* 0xb2 */, 179 /* 0xb3 */,\n    180 /* 0xb4 */, 181 /* 0xb5 */, 182 /* 0xb6 */, 183 /* 0xb7 */,\n    184 /* 0xb8 */, 185 /* 0xb9 */, 186 /* 0xba */, 187 /* 0xbb */,\n    188 /* 0xbc */, 189 /* 0xbd */, 190 /* 0xbe */, 191 /* 0xbf */,\n    192 /* 0xc0 */, 193 /* 0xc1 */, 194 /* 0xc2 */, 195 /* 0xc3 */,\n    196 /* 0xc4 */, 197 /* 0xc5 */, 198 /* 0xc6 */, 199 /* 0xc7 */,\n    200 /* 0xc8 */, 201 /* 0xc9 */, 202 /* 0xca */, 203 /* 0xcb */,\n    204 /* 0xcc */, 205 /* 0xcd */, 206 /* 0xce */, 207 /* 0xcf */,\n    208 /* 0xd0 */, 209 /* 0xd1 */, 210 /* 0xd2 */, 211 /* 0xd3 */,\n    212 /* 0xd4 */, 213 /* 0xd5 */, 214 /* 0xd6 */, 215 /* 0xd7 */,\n    216 /* 0xd8 */, 217 /* 0xd9 */, 218 /* 0xda */, 219 /* 0xdb */,\n    220 /* 0xdc */, 221 /* 0xdd */, 222 /* 0xde */, 223 /* 0xdf */,\n    224 /* 0xe0 */, 225 /* 0xe1 */, 226 /* 0xe2 */, 227 /* 0xe3 */,\n    228 /* 0xe4 */, 229 /* 0xe5 */, 230 /* 0xe6 */, 231 /* 0xe7 */,\n    232 /* 0xe8 */, 233 /* 0xe9 */, 234 /* 0xea */, 235 /* 0xeb */,\n    236 /* 0xec */, 237 /* 0xed */, 238 /* 0xee */, 239 /* 0xef */,\n    240 /* 0xf0 */, 241 /* 0xf1 */, 242 /* 0xf2 */, 243 /* 0xf3 */,\n    244 /* 0xf4 */, 245 /* 0xf5 */, 246 /* 0xf6 */, 247 /* 0xf7 */,\n    248 /* 0xf8 */, 249 /* 0xf9 */, 250 /* 0xfa */, 251 /* 0xfb */,\n    252 /* 0xfc */, 253 /* 0xfd */, 254 /* 0xfe */, 255 /* 0xff */,\n};\n\nvoid nghttp2_downcase(uint8_t *s, size_t len) {\n  size_t i;\n  for (i = 0; i < len; ++i) {\n    s[i] = DOWNCASE_TBL[s[i]];\n  }\n}\n\n/*\n *   local_window_size\n *   ^  *\n *   |  *    recv_window_size\n *   |  *  * ^\n *   |  *  * |\n *  0+++++++++\n *   |  *  *   \\\n *   |  *  *   | This rage is hidden in flow control.  But it must be\n *   v  *  *   / kept in order to restore it when window size is enlarged.\n *   recv_reduction\n *   (+ for negative direction)\n *\n *   recv_window_size could be negative if we decrease\n *   local_window_size more than recv_window_size:\n *\n *   local_window_size\n *   ^  *\n *   |  *\n *   |  *\n *   0++++++++\n *   |  *    ^ recv_window_size (negative)\n *   |  *    |\n *   v  *  *\n *   recv_reduction\n */\nint nghttp2_adjust_local_window_size(int32_t *local_window_size_ptr,\n                                     int32_t *recv_window_size_ptr,\n                                     int32_t *recv_reduction_ptr,\n                                     int32_t *delta_ptr) {\n  if (*delta_ptr > 0) {\n    int32_t recv_reduction_delta;\n    int32_t delta;\n    int32_t new_recv_window_size =\n        nghttp2_max(0, *recv_window_size_ptr) - *delta_ptr;\n\n    if (new_recv_window_size >= 0) {\n      *recv_window_size_ptr = new_recv_window_size;\n      return 0;\n    }\n\n    delta = -new_recv_window_size;\n\n    /* The delta size is strictly more than received bytes. Increase\n       local_window_size by that difference |delta|. */\n    if (*local_window_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - delta) {\n      return NGHTTP2_ERR_FLOW_CONTROL;\n    }\n    *local_window_size_ptr += delta;\n    /* If there is recv_reduction due to earlier window_size\n       reduction, we have to adjust it too. */\n    recv_reduction_delta = nghttp2_min(*recv_reduction_ptr, delta);\n    *recv_reduction_ptr -= recv_reduction_delta;\n    if (*recv_window_size_ptr < 0) {\n      *recv_window_size_ptr += recv_reduction_delta;\n    } else {\n      /* If *recv_window_size_ptr > 0, then those bytes are going to\n         be returned to the remote peer (by WINDOW_UPDATE with the\n         adjusted *delta_ptr), so it is effectively 0 now.  We set to\n         *recv_reduction_delta, because caller does not take into\n         account it in *delta_ptr. */\n      *recv_window_size_ptr = recv_reduction_delta;\n    }\n    /* recv_reduction_delta must be paid from *delta_ptr, since it was\n       added in window size reduction (see below). */\n    *delta_ptr -= recv_reduction_delta;\n\n    return 0;\n  }\n\n  if (*local_window_size_ptr + *delta_ptr < 0 ||\n      *recv_window_size_ptr < INT32_MIN - *delta_ptr ||\n      *recv_reduction_ptr > INT32_MAX + *delta_ptr) {\n    return NGHTTP2_ERR_FLOW_CONTROL;\n  }\n  /* Decreasing local window size. Note that we achieve this without\n     noticing to the remote peer. To do this, we cut\n     recv_window_size by -delta. This means that we don't send\n     WINDOW_UPDATE for -delta bytes. */\n  *local_window_size_ptr += *delta_ptr;\n  *recv_window_size_ptr += *delta_ptr;\n  *recv_reduction_ptr -= *delta_ptr;\n  *delta_ptr = 0;\n\n  return 0;\n}\n\nint nghttp2_increase_local_window_size(int32_t *local_window_size_ptr,\n                                       int32_t *recv_window_size_ptr,\n                                       int32_t *recv_reduction_ptr,\n                                       int32_t *delta_ptr) {\n  int32_t recv_reduction_delta;\n  int32_t delta;\n\n  delta = *delta_ptr;\n\n  assert(delta >= 0);\n\n  /* The delta size is strictly more than received bytes. Increase\n     local_window_size by that difference |delta|. */\n  if (*local_window_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - delta) {\n    return NGHTTP2_ERR_FLOW_CONTROL;\n  }\n\n  *local_window_size_ptr += delta;\n  /* If there is recv_reduction due to earlier window_size\n     reduction, we have to adjust it too. */\n  recv_reduction_delta = nghttp2_min(*recv_reduction_ptr, delta);\n  *recv_reduction_ptr -= recv_reduction_delta;\n\n  *recv_window_size_ptr += recv_reduction_delta;\n\n  /* recv_reduction_delta must be paid from *delta_ptr, since it was\n     added in window size reduction (see below). */\n  *delta_ptr -= recv_reduction_delta;\n\n  return 0;\n}\n\nint nghttp2_should_send_window_update(int32_t local_window_size,\n                                      int32_t recv_window_size) {\n  return recv_window_size > 0 && recv_window_size >= local_window_size / 2;\n}\n\nconst char *nghttp2_strerror(int error_code) {\n  switch (error_code) {\n  case 0:\n    return \"Success\";\n  case NGHTTP2_ERR_INVALID_ARGUMENT:\n    return \"Invalid argument\";\n  case NGHTTP2_ERR_BUFFER_ERROR:\n    return \"Out of buffer space\";\n  case NGHTTP2_ERR_UNSUPPORTED_VERSION:\n    return \"Unsupported SPDY version\";\n  case NGHTTP2_ERR_WOULDBLOCK:\n    return \"Operation would block\";\n  case NGHTTP2_ERR_PROTO:\n    return \"Protocol error\";\n  case NGHTTP2_ERR_INVALID_FRAME:\n    return \"Invalid frame octets\";\n  case NGHTTP2_ERR_EOF:\n    return \"EOF\";\n  case NGHTTP2_ERR_DEFERRED:\n    return \"Data transfer deferred\";\n  case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n    return \"No more Stream ID available\";\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return \"Stream was already closed or invalid\";\n  case NGHTTP2_ERR_STREAM_CLOSING:\n    return \"Stream is closing\";\n  case NGHTTP2_ERR_STREAM_SHUT_WR:\n    return \"The transmission is not allowed for this stream\";\n  case NGHTTP2_ERR_INVALID_STREAM_ID:\n    return \"Stream ID is invalid\";\n  case NGHTTP2_ERR_INVALID_STREAM_STATE:\n    return \"Invalid stream state\";\n  case NGHTTP2_ERR_DEFERRED_DATA_EXIST:\n    return \"Another DATA frame has already been deferred\";\n  case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED:\n    return \"request HEADERS is not allowed\";\n  case NGHTTP2_ERR_GOAWAY_ALREADY_SENT:\n    return \"GOAWAY has already been sent\";\n  case NGHTTP2_ERR_INVALID_HEADER_BLOCK:\n    return \"Invalid header block\";\n  case NGHTTP2_ERR_INVALID_STATE:\n    return \"Invalid state\";\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return \"The user callback function failed due to the temporal error\";\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return \"The length of the frame is invalid\";\n  case NGHTTP2_ERR_HEADER_COMP:\n    return \"Header compression/decompression error\";\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return \"Flow control error\";\n  case NGHTTP2_ERR_INSUFF_BUFSIZE:\n    return \"Insufficient buffer size given to function\";\n  case NGHTTP2_ERR_PAUSE:\n    return \"Callback was paused by the application\";\n  case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS:\n    return \"Too many inflight SETTINGS\";\n  case NGHTTP2_ERR_PUSH_DISABLED:\n    return \"Server push is disabled by peer\";\n  case NGHTTP2_ERR_DATA_EXIST:\n    return \"DATA or HEADERS frame has already been submitted for the stream\";\n  case NGHTTP2_ERR_SESSION_CLOSING:\n    return \"The current session is closing\";\n  case NGHTTP2_ERR_HTTP_HEADER:\n    return \"Invalid HTTP header field was received\";\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return \"Violation in HTTP messaging rule\";\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return \"Stream was refused\";\n  case NGHTTP2_ERR_INTERNAL:\n    return \"Internal error\";\n  case NGHTTP2_ERR_CANCEL:\n    return \"Cancel\";\n  case NGHTTP2_ERR_SETTINGS_EXPECTED:\n    return \"When a local endpoint expects to receive SETTINGS frame, it \"\n           \"receives an other type of frame\";\n  case NGHTTP2_ERR_NOMEM:\n    return \"Out of memory\";\n  case NGHTTP2_ERR_CALLBACK_FAILURE:\n    return \"The user callback function failed\";\n  case NGHTTP2_ERR_BAD_CLIENT_MAGIC:\n    return \"Received bad client magic byte string\";\n  case NGHTTP2_ERR_FLOODED:\n    return \"Flooding was detected in this HTTP/2 session, and it must be \"\n           \"closed\";\n  case NGHTTP2_ERR_TOO_MANY_SETTINGS:\n    return \"SETTINGS frame contained more than the maximum allowed entries\";\n  default:\n    return \"Unknown error code\";\n  }\n}\n\n/* Generated by gennmchartbl.py */\nstatic const int VALID_HD_NAME_CHARS[] = {\n    0 /* NUL  */, 0 /* SOH  */, 0 /* STX  */, 0 /* ETX  */,\n    0 /* EOT  */, 0 /* ENQ  */, 0 /* ACK  */, 0 /* BEL  */,\n    0 /* BS   */, 0 /* HT   */, 0 /* LF   */, 0 /* VT   */,\n    0 /* FF   */, 0 /* CR   */, 0 /* SO   */, 0 /* SI   */,\n    0 /* DLE  */, 0 /* DC1  */, 0 /* DC2  */, 0 /* DC3  */,\n    0 /* DC4  */, 0 /* NAK  */, 0 /* SYN  */, 0 /* ETB  */,\n    0 /* CAN  */, 0 /* EM   */, 0 /* SUB  */, 0 /* ESC  */,\n    0 /* FS   */, 0 /* GS   */, 0 /* RS   */, 0 /* US   */,\n    0 /* SPC  */, 1 /* !    */, 0 /* \"    */, 1 /* #    */,\n    1 /* $    */, 1 /* %    */, 1 /* &    */, 1 /* '    */,\n    0 /* (    */, 0 /* )    */, 1 /* *    */, 1 /* +    */,\n    0 /* ,    */, 1 /* -    */, 1 /* .    */, 0 /* /    */,\n    1 /* 0    */, 1 /* 1    */, 1 /* 2    */, 1 /* 3    */,\n    1 /* 4    */, 1 /* 5    */, 1 /* 6    */, 1 /* 7    */,\n    1 /* 8    */, 1 /* 9    */, 0 /* :    */, 0 /* ;    */,\n    0 /* <    */, 0 /* =    */, 0 /* >    */, 0 /* ?    */,\n    0 /* @    */, 0 /* A    */, 0 /* B    */, 0 /* C    */,\n    0 /* D    */, 0 /* E    */, 0 /* F    */, 0 /* G    */,\n    0 /* H    */, 0 /* I    */, 0 /* J    */, 0 /* K    */,\n    0 /* L    */, 0 /* M    */, 0 /* N    */, 0 /* O    */,\n    0 /* P    */, 0 /* Q    */, 0 /* R    */, 0 /* S    */,\n    0 /* T    */, 0 /* U    */, 0 /* V    */, 0 /* W    */,\n    0 /* X    */, 0 /* Y    */, 0 /* Z    */, 0 /* [    */,\n    0 /* \\    */, 0 /* ]    */, 1 /* ^    */, 1 /* _    */,\n    1 /* `    */, 1 /* a    */, 1 /* b    */, 1 /* c    */,\n    1 /* d    */, 1 /* e    */, 1 /* f    */, 1 /* g    */,\n    1 /* h    */, 1 /* i    */, 1 /* j    */, 1 /* k    */,\n    1 /* l    */, 1 /* m    */, 1 /* n    */, 1 /* o    */,\n    1 /* p    */, 1 /* q    */, 1 /* r    */, 1 /* s    */,\n    1 /* t    */, 1 /* u    */, 1 /* v    */, 1 /* w    */,\n    1 /* x    */, 1 /* y    */, 1 /* z    */, 0 /* {    */,\n    1 /* |    */, 0 /* }    */, 1 /* ~    */, 0 /* DEL  */,\n    0 /* 0x80 */, 0 /* 0x81 */, 0 /* 0x82 */, 0 /* 0x83 */,\n    0 /* 0x84 */, 0 /* 0x85 */, 0 /* 0x86 */, 0 /* 0x87 */,\n    0 /* 0x88 */, 0 /* 0x89 */, 0 /* 0x8a */, 0 /* 0x8b */,\n    0 /* 0x8c */, 0 /* 0x8d */, 0 /* 0x8e */, 0 /* 0x8f */,\n    0 /* 0x90 */, 0 /* 0x91 */, 0 /* 0x92 */, 0 /* 0x93 */,\n    0 /* 0x94 */, 0 /* 0x95 */, 0 /* 0x96 */, 0 /* 0x97 */,\n    0 /* 0x98 */, 0 /* 0x99 */, 0 /* 0x9a */, 0 /* 0x9b */,\n    0 /* 0x9c */, 0 /* 0x9d */, 0 /* 0x9e */, 0 /* 0x9f */,\n    0 /* 0xa0 */, 0 /* 0xa1 */, 0 /* 0xa2 */, 0 /* 0xa3 */,\n    0 /* 0xa4 */, 0 /* 0xa5 */, 0 /* 0xa6 */, 0 /* 0xa7 */,\n    0 /* 0xa8 */, 0 /* 0xa9 */, 0 /* 0xaa */, 0 /* 0xab */,\n    0 /* 0xac */, 0 /* 0xad */, 0 /* 0xae */, 0 /* 0xaf */,\n    0 /* 0xb0 */, 0 /* 0xb1 */, 0 /* 0xb2 */, 0 /* 0xb3 */,\n    0 /* 0xb4 */, 0 /* 0xb5 */, 0 /* 0xb6 */, 0 /* 0xb7 */,\n    0 /* 0xb8 */, 0 /* 0xb9 */, 0 /* 0xba */, 0 /* 0xbb */,\n    0 /* 0xbc */, 0 /* 0xbd */, 0 /* 0xbe */, 0 /* 0xbf */,\n    0 /* 0xc0 */, 0 /* 0xc1 */, 0 /* 0xc2 */, 0 /* 0xc3 */,\n    0 /* 0xc4 */, 0 /* 0xc5 */, 0 /* 0xc6 */, 0 /* 0xc7 */,\n    0 /* 0xc8 */, 0 /* 0xc9 */, 0 /* 0xca */, 0 /* 0xcb */,\n    0 /* 0xcc */, 0 /* 0xcd */, 0 /* 0xce */, 0 /* 0xcf */,\n    0 /* 0xd0 */, 0 /* 0xd1 */, 0 /* 0xd2 */, 0 /* 0xd3 */,\n    0 /* 0xd4 */, 0 /* 0xd5 */, 0 /* 0xd6 */, 0 /* 0xd7 */,\n    0 /* 0xd8 */, 0 /* 0xd9 */, 0 /* 0xda */, 0 /* 0xdb */,\n    0 /* 0xdc */, 0 /* 0xdd */, 0 /* 0xde */, 0 /* 0xdf */,\n    0 /* 0xe0 */, 0 /* 0xe1 */, 0 /* 0xe2 */, 0 /* 0xe3 */,\n    0 /* 0xe4 */, 0 /* 0xe5 */, 0 /* 0xe6 */, 0 /* 0xe7 */,\n    0 /* 0xe8 */, 0 /* 0xe9 */, 0 /* 0xea */, 0 /* 0xeb */,\n    0 /* 0xec */, 0 /* 0xed */, 0 /* 0xee */, 0 /* 0xef */,\n    0 /* 0xf0 */, 0 /* 0xf1 */, 0 /* 0xf2 */, 0 /* 0xf3 */,\n    0 /* 0xf4 */, 0 /* 0xf5 */, 0 /* 0xf6 */, 0 /* 0xf7 */,\n    0 /* 0xf8 */, 0 /* 0xf9 */, 0 /* 0xfa */, 0 /* 0xfb */,\n    0 /* 0xfc */, 0 /* 0xfd */, 0 /* 0xfe */, 0 /* 0xff */\n};\n\nint nghttp2_check_header_name(const uint8_t *name, size_t len) {\n  const uint8_t *last;\n  if (len == 0) {\n    return 0;\n  }\n  if (*name == ':') {\n    if (len == 1) {\n      return 0;\n    }\n    ++name;\n    --len;\n  }\n  for (last = name + len; name != last; ++name) {\n    if (!VALID_HD_NAME_CHARS[*name]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n/* Generated by genvchartbl.py */\nstatic const int VALID_HD_VALUE_CHARS[] = {\n    0 /* NUL  */, 0 /* SOH  */, 0 /* STX  */, 0 /* ETX  */,\n    0 /* EOT  */, 0 /* ENQ  */, 0 /* ACK  */, 0 /* BEL  */,\n    0 /* BS   */, 1 /* HT   */, 0 /* LF   */, 0 /* VT   */,\n    0 /* FF   */, 0 /* CR   */, 0 /* SO   */, 0 /* SI   */,\n    0 /* DLE  */, 0 /* DC1  */, 0 /* DC2  */, 0 /* DC3  */,\n    0 /* DC4  */, 0 /* NAK  */, 0 /* SYN  */, 0 /* ETB  */,\n    0 /* CAN  */, 0 /* EM   */, 0 /* SUB  */, 0 /* ESC  */,\n    0 /* FS   */, 0 /* GS   */, 0 /* RS   */, 0 /* US   */,\n    1 /* SPC  */, 1 /* !    */, 1 /* \"    */, 1 /* #    */,\n    1 /* $    */, 1 /* %    */, 1 /* &    */, 1 /* '    */,\n    1 /* (    */, 1 /* )    */, 1 /* *    */, 1 /* +    */,\n    1 /* ,    */, 1 /* -    */, 1 /* .    */, 1 /* /    */,\n    1 /* 0    */, 1 /* 1    */, 1 /* 2    */, 1 /* 3    */,\n    1 /* 4    */, 1 /* 5    */, 1 /* 6    */, 1 /* 7    */,\n    1 /* 8    */, 1 /* 9    */, 1 /* :    */, 1 /* ;    */,\n    1 /* <    */, 1 /* =    */, 1 /* >    */, 1 /* ?    */,\n    1 /* @    */, 1 /* A    */, 1 /* B    */, 1 /* C    */,\n    1 /* D    */, 1 /* E    */, 1 /* F    */, 1 /* G    */,\n    1 /* H    */, 1 /* I    */, 1 /* J    */, 1 /* K    */,\n    1 /* L    */, 1 /* M    */, 1 /* N    */, 1 /* O    */,\n    1 /* P    */, 1 /* Q    */, 1 /* R    */, 1 /* S    */,\n    1 /* T    */, 1 /* U    */, 1 /* V    */, 1 /* W    */,\n    1 /* X    */, 1 /* Y    */, 1 /* Z    */, 1 /* [    */,\n    1 /* \\    */, 1 /* ]    */, 1 /* ^    */, 1 /* _    */,\n    1 /* `    */, 1 /* a    */, 1 /* b    */, 1 /* c    */,\n    1 /* d    */, 1 /* e    */, 1 /* f    */, 1 /* g    */,\n    1 /* h    */, 1 /* i    */, 1 /* j    */, 1 /* k    */,\n    1 /* l    */, 1 /* m    */, 1 /* n    */, 1 /* o    */,\n    1 /* p    */, 1 /* q    */, 1 /* r    */, 1 /* s    */,\n    1 /* t    */, 1 /* u    */, 1 /* v    */, 1 /* w    */,\n    1 /* x    */, 1 /* y    */, 1 /* z    */, 1 /* {    */,\n    1 /* |    */, 1 /* }    */, 1 /* ~    */, 0 /* DEL  */,\n    1 /* 0x80 */, 1 /* 0x81 */, 1 /* 0x82 */, 1 /* 0x83 */,\n    1 /* 0x84 */, 1 /* 0x85 */, 1 /* 0x86 */, 1 /* 0x87 */,\n    1 /* 0x88 */, 1 /* 0x89 */, 1 /* 0x8a */, 1 /* 0x8b */,\n    1 /* 0x8c */, 1 /* 0x8d */, 1 /* 0x8e */, 1 /* 0x8f */,\n    1 /* 0x90 */, 1 /* 0x91 */, 1 /* 0x92 */, 1 /* 0x93 */,\n    1 /* 0x94 */, 1 /* 0x95 */, 1 /* 0x96 */, 1 /* 0x97 */,\n    1 /* 0x98 */, 1 /* 0x99 */, 1 /* 0x9a */, 1 /* 0x9b */,\n    1 /* 0x9c */, 1 /* 0x9d */, 1 /* 0x9e */, 1 /* 0x9f */,\n    1 /* 0xa0 */, 1 /* 0xa1 */, 1 /* 0xa2 */, 1 /* 0xa3 */,\n    1 /* 0xa4 */, 1 /* 0xa5 */, 1 /* 0xa6 */, 1 /* 0xa7 */,\n    1 /* 0xa8 */, 1 /* 0xa9 */, 1 /* 0xaa */, 1 /* 0xab */,\n    1 /* 0xac */, 1 /* 0xad */, 1 /* 0xae */, 1 /* 0xaf */,\n    1 /* 0xb0 */, 1 /* 0xb1 */, 1 /* 0xb2 */, 1 /* 0xb3 */,\n    1 /* 0xb4 */, 1 /* 0xb5 */, 1 /* 0xb6 */, 1 /* 0xb7 */,\n    1 /* 0xb8 */, 1 /* 0xb9 */, 1 /* 0xba */, 1 /* 0xbb */,\n    1 /* 0xbc */, 1 /* 0xbd */, 1 /* 0xbe */, 1 /* 0xbf */,\n    1 /* 0xc0 */, 1 /* 0xc1 */, 1 /* 0xc2 */, 1 /* 0xc3 */,\n    1 /* 0xc4 */, 1 /* 0xc5 */, 1 /* 0xc6 */, 1 /* 0xc7 */,\n    1 /* 0xc8 */, 1 /* 0xc9 */, 1 /* 0xca */, 1 /* 0xcb */,\n    1 /* 0xcc */, 1 /* 0xcd */, 1 /* 0xce */, 1 /* 0xcf */,\n    1 /* 0xd0 */, 1 /* 0xd1 */, 1 /* 0xd2 */, 1 /* 0xd3 */,\n    1 /* 0xd4 */, 1 /* 0xd5 */, 1 /* 0xd6 */, 1 /* 0xd7 */,\n    1 /* 0xd8 */, 1 /* 0xd9 */, 1 /* 0xda */, 1 /* 0xdb */,\n    1 /* 0xdc */, 1 /* 0xdd */, 1 /* 0xde */, 1 /* 0xdf */,\n    1 /* 0xe0 */, 1 /* 0xe1 */, 1 /* 0xe2 */, 1 /* 0xe3 */,\n    1 /* 0xe4 */, 1 /* 0xe5 */, 1 /* 0xe6 */, 1 /* 0xe7 */,\n    1 /* 0xe8 */, 1 /* 0xe9 */, 1 /* 0xea */, 1 /* 0xeb */,\n    1 /* 0xec */, 1 /* 0xed */, 1 /* 0xee */, 1 /* 0xef */,\n    1 /* 0xf0 */, 1 /* 0xf1 */, 1 /* 0xf2 */, 1 /* 0xf3 */,\n    1 /* 0xf4 */, 1 /* 0xf5 */, 1 /* 0xf6 */, 1 /* 0xf7 */,\n    1 /* 0xf8 */, 1 /* 0xf9 */, 1 /* 0xfa */, 1 /* 0xfb */,\n    1 /* 0xfc */, 1 /* 0xfd */, 1 /* 0xfe */, 1 /* 0xff */\n};\n\nint nghttp2_check_header_value(const uint8_t *value, size_t len) {\n  const uint8_t *last;\n  for (last = value + len; value != last; ++value) {\n    if (!VALID_HD_VALUE_CHARS[*value]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n/* Generated by genauthroitychartbl.py */\nstatic char VALID_AUTHORITY_CHARS[] = {\n    0 /* NUL  */, 0 /* SOH  */, 0 /* STX  */, 0 /* ETX  */,\n    0 /* EOT  */, 0 /* ENQ  */, 0 /* ACK  */, 0 /* BEL  */,\n    0 /* BS   */, 0 /* HT   */, 0 /* LF   */, 0 /* VT   */,\n    0 /* FF   */, 0 /* CR   */, 0 /* SO   */, 0 /* SI   */,\n    0 /* DLE  */, 0 /* DC1  */, 0 /* DC2  */, 0 /* DC3  */,\n    0 /* DC4  */, 0 /* NAK  */, 0 /* SYN  */, 0 /* ETB  */,\n    0 /* CAN  */, 0 /* EM   */, 0 /* SUB  */, 0 /* ESC  */,\n    0 /* FS   */, 0 /* GS   */, 0 /* RS   */, 0 /* US   */,\n    0 /* SPC  */, 1 /* !    */, 0 /* \"    */, 0 /* #    */,\n    1 /* $    */, 1 /* %    */, 1 /* &    */, 1 /* '    */,\n    1 /* (    */, 1 /* )    */, 1 /* *    */, 1 /* +    */,\n    1 /* ,    */, 1 /* -    */, 1 /* .    */, 0 /* /    */,\n    1 /* 0    */, 1 /* 1    */, 1 /* 2    */, 1 /* 3    */,\n    1 /* 4    */, 1 /* 5    */, 1 /* 6    */, 1 /* 7    */,\n    1 /* 8    */, 1 /* 9    */, 1 /* :    */, 1 /* ;    */,\n    0 /* <    */, 1 /* =    */, 0 /* >    */, 0 /* ?    */,\n    1 /* @    */, 1 /* A    */, 1 /* B    */, 1 /* C    */,\n    1 /* D    */, 1 /* E    */, 1 /* F    */, 1 /* G    */,\n    1 /* H    */, 1 /* I    */, 1 /* J    */, 1 /* K    */,\n    1 /* L    */, 1 /* M    */, 1 /* N    */, 1 /* O    */,\n    1 /* P    */, 1 /* Q    */, 1 /* R    */, 1 /* S    */,\n    1 /* T    */, 1 /* U    */, 1 /* V    */, 1 /* W    */,\n    1 /* X    */, 1 /* Y    */, 1 /* Z    */, 1 /* [    */,\n    0 /* \\    */, 1 /* ]    */, 0 /* ^    */, 1 /* _    */,\n    0 /* `    */, 1 /* a    */, 1 /* b    */, 1 /* c    */,\n    1 /* d    */, 1 /* e    */, 1 /* f    */, 1 /* g    */,\n    1 /* h    */, 1 /* i    */, 1 /* j    */, 1 /* k    */,\n    1 /* l    */, 1 /* m    */, 1 /* n    */, 1 /* o    */,\n    1 /* p    */, 1 /* q    */, 1 /* r    */, 1 /* s    */,\n    1 /* t    */, 1 /* u    */, 1 /* v    */, 1 /* w    */,\n    1 /* x    */, 1 /* y    */, 1 /* z    */, 0 /* {    */,\n    0 /* |    */, 0 /* }    */, 1 /* ~    */, 0 /* DEL  */,\n    0 /* 0x80 */, 0 /* 0x81 */, 0 /* 0x82 */, 0 /* 0x83 */,\n    0 /* 0x84 */, 0 /* 0x85 */, 0 /* 0x86 */, 0 /* 0x87 */,\n    0 /* 0x88 */, 0 /* 0x89 */, 0 /* 0x8a */, 0 /* 0x8b */,\n    0 /* 0x8c */, 0 /* 0x8d */, 0 /* 0x8e */, 0 /* 0x8f */,\n    0 /* 0x90 */, 0 /* 0x91 */, 0 /* 0x92 */, 0 /* 0x93 */,\n    0 /* 0x94 */, 0 /* 0x95 */, 0 /* 0x96 */, 0 /* 0x97 */,\n    0 /* 0x98 */, 0 /* 0x99 */, 0 /* 0x9a */, 0 /* 0x9b */,\n    0 /* 0x9c */, 0 /* 0x9d */, 0 /* 0x9e */, 0 /* 0x9f */,\n    0 /* 0xa0 */, 0 /* 0xa1 */, 0 /* 0xa2 */, 0 /* 0xa3 */,\n    0 /* 0xa4 */, 0 /* 0xa5 */, 0 /* 0xa6 */, 0 /* 0xa7 */,\n    0 /* 0xa8 */, 0 /* 0xa9 */, 0 /* 0xaa */, 0 /* 0xab */,\n    0 /* 0xac */, 0 /* 0xad */, 0 /* 0xae */, 0 /* 0xaf */,\n    0 /* 0xb0 */, 0 /* 0xb1 */, 0 /* 0xb2 */, 0 /* 0xb3 */,\n    0 /* 0xb4 */, 0 /* 0xb5 */, 0 /* 0xb6 */, 0 /* 0xb7 */,\n    0 /* 0xb8 */, 0 /* 0xb9 */, 0 /* 0xba */, 0 /* 0xbb */,\n    0 /* 0xbc */, 0 /* 0xbd */, 0 /* 0xbe */, 0 /* 0xbf */,\n    0 /* 0xc0 */, 0 /* 0xc1 */, 0 /* 0xc2 */, 0 /* 0xc3 */,\n    0 /* 0xc4 */, 0 /* 0xc5 */, 0 /* 0xc6 */, 0 /* 0xc7 */,\n    0 /* 0xc8 */, 0 /* 0xc9 */, 0 /* 0xca */, 0 /* 0xcb */,\n    0 /* 0xcc */, 0 /* 0xcd */, 0 /* 0xce */, 0 /* 0xcf */,\n    0 /* 0xd0 */, 0 /* 0xd1 */, 0 /* 0xd2 */, 0 /* 0xd3 */,\n    0 /* 0xd4 */, 0 /* 0xd5 */, 0 /* 0xd6 */, 0 /* 0xd7 */,\n    0 /* 0xd8 */, 0 /* 0xd9 */, 0 /* 0xda */, 0 /* 0xdb */,\n    0 /* 0xdc */, 0 /* 0xdd */, 0 /* 0xde */, 0 /* 0xdf */,\n    0 /* 0xe0 */, 0 /* 0xe1 */, 0 /* 0xe2 */, 0 /* 0xe3 */,\n    0 /* 0xe4 */, 0 /* 0xe5 */, 0 /* 0xe6 */, 0 /* 0xe7 */,\n    0 /* 0xe8 */, 0 /* 0xe9 */, 0 /* 0xea */, 0 /* 0xeb */,\n    0 /* 0xec */, 0 /* 0xed */, 0 /* 0xee */, 0 /* 0xef */,\n    0 /* 0xf0 */, 0 /* 0xf1 */, 0 /* 0xf2 */, 0 /* 0xf3 */,\n    0 /* 0xf4 */, 0 /* 0xf5 */, 0 /* 0xf6 */, 0 /* 0xf7 */,\n    0 /* 0xf8 */, 0 /* 0xf9 */, 0 /* 0xfa */, 0 /* 0xfb */,\n    0 /* 0xfc */, 0 /* 0xfd */, 0 /* 0xfe */, 0 /* 0xff */\n};\n\nint nghttp2_check_authority(const uint8_t *value, size_t len) {\n  const uint8_t *last;\n  for (last = value + len; value != last; ++value) {\n    if (!VALID_AUTHORITY_CHARS[*value]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nuint8_t *nghttp2_cpymem(uint8_t *dest, const void *src, size_t len) {\n  if (len == 0) {\n    return dest;\n  }\n\n  memcpy(dest, src, len);\n\n  return dest + len;\n}\n\nconst char *nghttp2_http2_strerror(uint32_t error_code) {\n  switch (error_code) {\n  case NGHTTP2_NO_ERROR:\n    return \"NO_ERROR\";\n  case NGHTTP2_PROTOCOL_ERROR:\n    return \"PROTOCOL_ERROR\";\n  case NGHTTP2_INTERNAL_ERROR:\n    return \"INTERNAL_ERROR\";\n  case NGHTTP2_FLOW_CONTROL_ERROR:\n    return \"FLOW_CONTROL_ERROR\";\n  case NGHTTP2_SETTINGS_TIMEOUT:\n    return \"SETTINGS_TIMEOUT\";\n  case NGHTTP2_STREAM_CLOSED:\n    return \"STREAM_CLOSED\";\n  case NGHTTP2_FRAME_SIZE_ERROR:\n    return \"FRAME_SIZE_ERROR\";\n  case NGHTTP2_REFUSED_STREAM:\n    return \"REFUSED_STREAM\";\n  case NGHTTP2_CANCEL:\n    return \"CANCEL\";\n  case NGHTTP2_COMPRESSION_ERROR:\n    return \"COMPRESSION_ERROR\";\n  case NGHTTP2_CONNECT_ERROR:\n    return \"CONNECT_ERROR\";\n  case NGHTTP2_ENHANCE_YOUR_CALM:\n    return \"ENHANCE_YOUR_CALM\";\n  case NGHTTP2_INADEQUATE_SECURITY:\n    return \"INADEQUATE_SECURITY\";\n  case NGHTTP2_HTTP_1_1_REQUIRED:\n    return \"HTTP_1_1_REQUIRED\";\n  default:\n    return \"unknown\";\n  }\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2014 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_option.h\"\n\n#include \"nghttp2_session.h\"\n\nint nghttp2_option_new(nghttp2_option **option_ptr) {\n  *option_ptr = calloc(1, sizeof(nghttp2_option));\n\n  if (*option_ptr == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  return 0;\n}\n\nvoid nghttp2_option_del(nghttp2_option *option) { free(option); }\n\nvoid nghttp2_option_set_no_auto_window_update(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE;\n  option->no_auto_window_update = val;\n}\n\nvoid nghttp2_option_set_peer_max_concurrent_streams(nghttp2_option *option,\n                                                    uint32_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS;\n  option->peer_max_concurrent_streams = val;\n}\n\nvoid nghttp2_option_set_no_recv_client_magic(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC;\n  option->no_recv_client_magic = val;\n}\n\nvoid nghttp2_option_set_no_http_messaging(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_HTTP_MESSAGING;\n  option->no_http_messaging = val;\n}\n\nvoid nghttp2_option_set_max_reserved_remote_streams(nghttp2_option *option,\n                                                    uint32_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS;\n  option->max_reserved_remote_streams = val;\n}\n\nstatic void set_ext_type(uint8_t *ext_types, uint8_t type) {\n  ext_types[type / 8] = (uint8_t)(ext_types[type / 8] | (1 << (type & 0x7)));\n}\n\nvoid nghttp2_option_set_user_recv_extension_type(nghttp2_option *option,\n                                                 uint8_t type) {\n  if (type < 10) {\n    return;\n  }\n\n  option->opt_set_mask |= NGHTTP2_OPT_USER_RECV_EXT_TYPES;\n  set_ext_type(option->user_recv_ext_types, type);\n}\n\nvoid nghttp2_option_set_builtin_recv_extension_type(nghttp2_option *option,\n                                                    uint8_t type) {\n  switch (type) {\n  case NGHTTP2_ALTSVC:\n    option->opt_set_mask |= NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES;\n    option->builtin_recv_ext_types |= NGHTTP2_TYPEMASK_ALTSVC;\n    return;\n  case NGHTTP2_ORIGIN:\n    option->opt_set_mask |= NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES;\n    option->builtin_recv_ext_types |= NGHTTP2_TYPEMASK_ORIGIN;\n    return;\n  default:\n    return;\n  }\n}\n\nvoid nghttp2_option_set_no_auto_ping_ack(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_AUTO_PING_ACK;\n  option->no_auto_ping_ack = val;\n}\n\nvoid nghttp2_option_set_max_send_header_block_length(nghttp2_option *option,\n                                                     size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH;\n  option->max_send_header_block_length = val;\n}\n\nvoid nghttp2_option_set_max_deflate_dynamic_table_size(nghttp2_option *option,\n                                                       size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE;\n  option->max_deflate_dynamic_table_size = val;\n}\n\nvoid nghttp2_option_set_no_closed_streams(nghttp2_option *option, int val) {\n  option->opt_set_mask |= NGHTTP2_OPT_NO_CLOSED_STREAMS;\n  option->no_closed_streams = val;\n}\n\nvoid nghttp2_option_set_max_outbound_ack(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_OUTBOUND_ACK;\n  option->max_outbound_ack = val;\n}\n\nvoid nghttp2_option_set_max_settings(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_SETTINGS;\n  option->max_settings = val;\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2014 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_OPTION_H\n#define NGHTTP2_OPTION_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <nghttp2/nghttp2.h>\n\n/**\n * Configuration options\n */\ntypedef enum {\n  /**\n   * This option prevents the library from sending WINDOW_UPDATE for a\n   * connection automatically.  If this option is set to nonzero, the\n   * library won't send WINDOW_UPDATE for DATA until application calls\n   * nghttp2_session_consume() to indicate the amount of consumed\n   * DATA.  By default, this option is set to zero.\n   */\n  NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE = 1,\n  /**\n   * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of\n   * remote endpoint as if it is received in SETTINGS frame. Without\n   * specifying this option, before the local endpoint receives\n   * SETTINGS_MAX_CONCURRENT_STREAMS in SETTINGS frame from remote\n   * endpoint, SETTINGS_MAX_CONCURRENT_STREAMS is unlimited. This may\n   * cause problem if local endpoint submits lots of requests\n   * initially and sending them at once to the remote peer may lead to\n   * the rejection of some requests. Specifying this option to the\n   * sensible value, say 100, may avoid this kind of issue. This value\n   * will be overwritten if the local endpoint receives\n   * SETTINGS_MAX_CONCURRENT_STREAMS from the remote endpoint.\n   */\n  NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS = 1 << 1,\n  NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC = 1 << 2,\n  NGHTTP2_OPT_NO_HTTP_MESSAGING = 1 << 3,\n  NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS = 1 << 4,\n  NGHTTP2_OPT_USER_RECV_EXT_TYPES = 1 << 5,\n  NGHTTP2_OPT_NO_AUTO_PING_ACK = 1 << 6,\n  NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES = 1 << 7,\n  NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH = 1 << 8,\n  NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE = 1 << 9,\n  NGHTTP2_OPT_NO_CLOSED_STREAMS = 1 << 10,\n  NGHTTP2_OPT_MAX_OUTBOUND_ACK = 1 << 11,\n  NGHTTP2_OPT_MAX_SETTINGS = 1 << 12,\n} nghttp2_option_flag;\n\n/**\n * Struct to store option values for nghttp2_session.\n */\nstruct nghttp2_option {\n  /**\n   * NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH\n   */\n  size_t max_send_header_block_length;\n  /**\n   * NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE\n   */\n  size_t max_deflate_dynamic_table_size;\n  /**\n   * NGHTTP2_OPT_MAX_OUTBOUND_ACK\n   */\n  size_t max_outbound_ack;\n  /**\n   * NGHTTP2_OPT_MAX_SETTINGS\n   */\n  size_t max_settings;\n  /**\n   * Bitwise OR of nghttp2_option_flag to determine that which fields\n   * are specified.\n   */\n  uint32_t opt_set_mask;\n  /**\n   * NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS\n   */\n  uint32_t peer_max_concurrent_streams;\n  /**\n   * NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS\n   */\n  uint32_t max_reserved_remote_streams;\n  /**\n   * NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES\n   */\n  uint32_t builtin_recv_ext_types;\n  /**\n   * NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE\n   */\n  int no_auto_window_update;\n  /**\n   * NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC\n   */\n  int no_recv_client_magic;\n  /**\n   * NGHTTP2_OPT_NO_HTTP_MESSAGING\n   */\n  int no_http_messaging;\n  /**\n   * NGHTTP2_OPT_NO_AUTO_PING_ACK\n   */\n  int no_auto_ping_ack;\n  /**\n   * NGHTTP2_OPT_NO_CLOSED_STREAMS\n   */\n  int no_closed_streams;\n  /**\n   * NGHTTP2_OPT_USER_RECV_EXT_TYPES\n   */\n  uint8_t user_recv_ext_types[32];\n};\n\n#endif /* NGHTTP2_OPTION_H */\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_session.h\"\n\n#include <string.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdarg.h>\n\n#include \"nghttp2_helper.h\"\n#include \"nghttp2_net.h\"\n#include \"nghttp2_priority_spec.h\"\n#include \"nghttp2_option.h\"\n#include \"nghttp2_http.h\"\n#include \"nghttp2_pq.h\"\n#include \"nghttp2_debug.h\"\n\n/*\n * Returns non-zero if the number of outgoing opened streams is larger\n * than or equal to\n * remote_settings.max_concurrent_streams.\n */\nstatic int\nsession_is_outgoing_concurrent_streams_max(nghttp2_session *session) {\n  return session->remote_settings.max_concurrent_streams <=\n         session->num_outgoing_streams;\n}\n\n/*\n * Returns non-zero if the number of incoming opened streams is larger\n * than or equal to\n * local_settings.max_concurrent_streams.\n */\nstatic int\nsession_is_incoming_concurrent_streams_max(nghttp2_session *session) {\n  return session->local_settings.max_concurrent_streams <=\n         session->num_incoming_streams;\n}\n\n/*\n * Returns non-zero if the number of incoming opened streams is larger\n * than or equal to\n * session->pending_local_max_concurrent_stream.\n */\nstatic int\nsession_is_incoming_concurrent_streams_pending_max(nghttp2_session *session) {\n  return session->pending_local_max_concurrent_stream <=\n         session->num_incoming_streams;\n}\n\n/*\n * Returns non-zero if |lib_error| is non-fatal error.\n */\nstatic int is_non_fatal(int lib_error_code) {\n  return lib_error_code < 0 && lib_error_code > NGHTTP2_ERR_FATAL;\n}\n\nint nghttp2_is_fatal(int lib_error_code) {\n  return lib_error_code < NGHTTP2_ERR_FATAL;\n}\n\nstatic int session_enforce_http_messaging(nghttp2_session *session) {\n  return (session->opt_flags & NGHTTP2_OPTMASK_NO_HTTP_MESSAGING) == 0;\n}\n\n/*\n * Returns nonzero if |frame| is trailer headers.\n */\nstatic int session_trailer_headers(nghttp2_session *session,\n                                   nghttp2_stream *stream,\n                                   nghttp2_frame *frame) {\n  if (!stream || frame->hd.type != NGHTTP2_HEADERS) {\n    return 0;\n  }\n  if (session->server) {\n    return frame->headers.cat == NGHTTP2_HCAT_HEADERS;\n  }\n\n  return frame->headers.cat == NGHTTP2_HCAT_HEADERS &&\n         (stream->http_flags & NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE) == 0;\n}\n\n/* Returns nonzero if the |stream| is in reserved(remote) state */\nstatic int state_reserved_remote(nghttp2_session *session,\n                                 nghttp2_stream *stream) {\n  return stream->state == NGHTTP2_STREAM_RESERVED &&\n         !nghttp2_session_is_my_stream_id(session, stream->stream_id);\n}\n\n/* Returns nonzero if the |stream| is in reserved(local) state */\nstatic int state_reserved_local(nghttp2_session *session,\n                                nghttp2_stream *stream) {\n  return stream->state == NGHTTP2_STREAM_RESERVED &&\n         nghttp2_session_is_my_stream_id(session, stream->stream_id);\n}\n\n/*\n * Checks whether received stream_id is valid.  This function returns\n * 1 if it succeeds, or 0.\n */\nstatic int session_is_new_peer_stream_id(nghttp2_session *session,\n                                         int32_t stream_id) {\n  return stream_id != 0 &&\n         !nghttp2_session_is_my_stream_id(session, stream_id) &&\n         session->last_recv_stream_id < stream_id;\n}\n\nstatic int session_detect_idle_stream(nghttp2_session *session,\n                                      int32_t stream_id) {\n  /* Assume that stream object with stream_id does not exist */\n  if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n    if (session->last_sent_stream_id < stream_id) {\n      return 1;\n    }\n    return 0;\n  }\n  if (session_is_new_peer_stream_id(session, stream_id)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic int check_ext_type_set(const uint8_t *ext_types, uint8_t type) {\n  return (ext_types[type / 8] & (1 << (type & 0x7))) > 0;\n}\n\nstatic int session_call_error_callback(nghttp2_session *session,\n                                       int lib_error_code, const char *fmt,\n                                       ...) {\n  size_t bufsize;\n  va_list ap;\n  char *buf;\n  int rv;\n  nghttp2_mem *mem;\n\n  if (!session->callbacks.error_callback &&\n      !session->callbacks.error_callback2) {\n    return 0;\n  }\n\n  mem = &session->mem;\n\n  va_start(ap, fmt);\n  rv = vsnprintf(NULL, 0, fmt, ap);\n  va_end(ap);\n\n  if (rv < 0) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  bufsize = (size_t)(rv + 1);\n\n  buf = nghttp2_mem_malloc(mem, bufsize);\n  if (buf == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  va_start(ap, fmt);\n  rv = vsnprintf(buf, bufsize, fmt, ap);\n  va_end(ap);\n\n  if (rv < 0) {\n    nghttp2_mem_free(mem, buf);\n    /* vsnprintf may return error because of various things we can\n       imagine, but typically we don't want to drop session just for\n       debug callback. */\n    DEBUGF(\"error_callback: vsnprintf failed. The template was %s\\n\", fmt);\n    return 0;\n  }\n\n  if (session->callbacks.error_callback2) {\n    rv = session->callbacks.error_callback2(session, lib_error_code, buf,\n                                            (size_t)rv, session->user_data);\n  } else {\n    rv = session->callbacks.error_callback(session, buf, (size_t)rv,\n                                           session->user_data);\n  }\n\n  nghttp2_mem_free(mem, buf);\n\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  return 0;\n}\n\nstatic int session_terminate_session(nghttp2_session *session,\n                                     int32_t last_stream_id,\n                                     uint32_t error_code, const char *reason) {\n  int rv;\n  const uint8_t *debug_data;\n  size_t debug_datalen;\n\n  if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND) {\n    return 0;\n  }\n\n  /* Ignore all incoming frames because we are going to tear down the\n     session. */\n  session->iframe.state = NGHTTP2_IB_IGN_ALL;\n\n  if (reason == NULL) {\n    debug_data = NULL;\n    debug_datalen = 0;\n  } else {\n    debug_data = (const uint8_t *)reason;\n    debug_datalen = strlen(reason);\n  }\n\n  rv = nghttp2_session_add_goaway(session, last_stream_id, error_code,\n                                  debug_data, debug_datalen,\n                                  NGHTTP2_GOAWAY_AUX_TERM_ON_SEND);\n\n  if (rv != 0) {\n    return rv;\n  }\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_TERM_ON_SEND;\n\n  return 0;\n}\n\nint nghttp2_session_terminate_session(nghttp2_session *session,\n                                      uint32_t error_code) {\n  return session_terminate_session(session, session->last_proc_stream_id,\n                                   error_code, NULL);\n}\n\nint nghttp2_session_terminate_session2(nghttp2_session *session,\n                                       int32_t last_stream_id,\n                                       uint32_t error_code) {\n  return session_terminate_session(session, last_stream_id, error_code, NULL);\n}\n\nint nghttp2_session_terminate_session_with_reason(nghttp2_session *session,\n                                                  uint32_t error_code,\n                                                  const char *reason) {\n  return session_terminate_session(session, session->last_proc_stream_id,\n                                   error_code, reason);\n}\n\nint nghttp2_session_is_my_stream_id(nghttp2_session *session,\n                                    int32_t stream_id) {\n  int rem;\n  if (stream_id == 0) {\n    return 0;\n  }\n  rem = stream_id & 0x1;\n  if (session->server) {\n    return rem == 0;\n  }\n  return rem == 1;\n}\n\nnghttp2_stream *nghttp2_session_get_stream(nghttp2_session *session,\n                                           int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = (nghttp2_stream *)nghttp2_map_find(&session->streams, stream_id);\n\n  if (stream == NULL || (stream->flags & NGHTTP2_STREAM_FLAG_CLOSED) ||\n      stream->state == NGHTTP2_STREAM_IDLE) {\n    return NULL;\n  }\n\n  return stream;\n}\n\nnghttp2_stream *nghttp2_session_get_stream_raw(nghttp2_session *session,\n                                               int32_t stream_id) {\n  return (nghttp2_stream *)nghttp2_map_find(&session->streams, stream_id);\n}\n\nstatic void session_inbound_frame_reset(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_mem *mem = &session->mem;\n  /* A bit risky code, since if this function is called from\n     nghttp2_session_new(), we rely on the fact that\n     iframe->frame.hd.type is 0, so that no free is performed. */\n  switch (iframe->frame.hd.type) {\n  case NGHTTP2_DATA:\n    break;\n  case NGHTTP2_HEADERS:\n    nghttp2_frame_headers_free(&iframe->frame.headers, mem);\n    break;\n  case NGHTTP2_PRIORITY:\n    nghttp2_frame_priority_free(&iframe->frame.priority);\n    break;\n  case NGHTTP2_RST_STREAM:\n    nghttp2_frame_rst_stream_free(&iframe->frame.rst_stream);\n    break;\n  case NGHTTP2_SETTINGS:\n    nghttp2_frame_settings_free(&iframe->frame.settings, mem);\n\n    nghttp2_mem_free(mem, iframe->iv);\n\n    iframe->iv = NULL;\n    iframe->niv = 0;\n    iframe->max_niv = 0;\n\n    break;\n  case NGHTTP2_PUSH_PROMISE:\n    nghttp2_frame_push_promise_free(&iframe->frame.push_promise, mem);\n    break;\n  case NGHTTP2_PING:\n    nghttp2_frame_ping_free(&iframe->frame.ping);\n    break;\n  case NGHTTP2_GOAWAY:\n    nghttp2_frame_goaway_free(&iframe->frame.goaway, mem);\n    break;\n  case NGHTTP2_WINDOW_UPDATE:\n    nghttp2_frame_window_update_free(&iframe->frame.window_update);\n    break;\n  default:\n    /* extension frame */\n    if (check_ext_type_set(session->user_recv_ext_types,\n                           iframe->frame.hd.type)) {\n      nghttp2_frame_extension_free(&iframe->frame.ext);\n    } else {\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_ALTSVC:\n        if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC) == 0) {\n          break;\n        }\n        nghttp2_frame_altsvc_free(&iframe->frame.ext, mem);\n        break;\n      case NGHTTP2_ORIGIN:\n        if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN) == 0) {\n          break;\n        }\n        nghttp2_frame_origin_free(&iframe->frame.ext, mem);\n        break;\n      }\n    }\n\n    break;\n  }\n\n  memset(&iframe->frame, 0, sizeof(nghttp2_frame));\n  memset(&iframe->ext_frame_payload, 0, sizeof(nghttp2_ext_frame_payload));\n\n  iframe->state = NGHTTP2_IB_READ_HEAD;\n\n  nghttp2_buf_wrap_init(&iframe->sbuf, iframe->raw_sbuf,\n                        sizeof(iframe->raw_sbuf));\n  iframe->sbuf.mark += NGHTTP2_FRAME_HDLEN;\n\n  nghttp2_buf_free(&iframe->lbuf, mem);\n  nghttp2_buf_wrap_init(&iframe->lbuf, NULL, 0);\n\n  iframe->raw_lbuf = NULL;\n\n  iframe->payloadleft = 0;\n  iframe->padlen = 0;\n}\n\nstatic void init_settings(nghttp2_settings_storage *settings) {\n  settings->header_table_size = NGHTTP2_HD_DEFAULT_MAX_BUFFER_SIZE;\n  settings->enable_push = 1;\n  settings->max_concurrent_streams = NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  settings->initial_window_size = NGHTTP2_INITIAL_WINDOW_SIZE;\n  settings->max_frame_size = NGHTTP2_MAX_FRAME_SIZE_MIN;\n  settings->max_header_list_size = UINT32_MAX;\n}\n\nstatic void active_outbound_item_reset(nghttp2_active_outbound_item *aob,\n                                       nghttp2_mem *mem) {\n  DEBUGF(\"send: reset nghttp2_active_outbound_item\\n\");\n  DEBUGF(\"send: aob->item = %p\\n\", aob->item);\n  nghttp2_outbound_item_free(aob->item, mem);\n  nghttp2_mem_free(mem, aob->item);\n  aob->item = NULL;\n  nghttp2_bufs_reset(&aob->framebufs);\n  aob->state = NGHTTP2_OB_POP_ITEM;\n}\n\nint nghttp2_enable_strict_preface = 1;\n\nstatic int session_new(nghttp2_session **session_ptr,\n                       const nghttp2_session_callbacks *callbacks,\n                       void *user_data, int server,\n                       const nghttp2_option *option, nghttp2_mem *mem) {\n  int rv;\n  size_t nbuffer;\n  size_t max_deflate_dynamic_table_size =\n      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;\n\n  if (mem == NULL) {\n    mem = nghttp2_mem_default();\n  }\n\n  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));\n  if (*session_ptr == NULL) {\n    rv = NGHTTP2_ERR_NOMEM;\n    goto fail_session;\n  }\n\n  (*session_ptr)->mem = *mem;\n  mem = &(*session_ptr)->mem;\n\n  /* next_stream_id is initialized in either\n     nghttp2_session_client_new2 or nghttp2_session_server_new2 */\n\n  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,\n                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,\n                      mem);\n\n  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n  (*session_ptr)->recv_window_size = 0;\n  (*session_ptr)->consumed_size = 0;\n  (*session_ptr)->recv_reduction = 0;\n  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n\n  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;\n  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;\n  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;\n\n  (*session_ptr)->pending_local_max_concurrent_stream =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  (*session_ptr)->pending_enable_push = 1;\n\n  if (server) {\n    (*session_ptr)->server = 1;\n  }\n\n  init_settings(&(*session_ptr)->remote_settings);\n  init_settings(&(*session_ptr)->local_settings);\n\n  (*session_ptr)->max_incoming_reserved_streams =\n      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;\n\n  /* Limit max outgoing concurrent streams to sensible value */\n  (*session_ptr)->remote_settings.max_concurrent_streams = 100;\n\n  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;\n\n  if (option) {\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n        option->no_auto_window_update) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {\n\n      (*session_ptr)->remote_settings.max_concurrent_streams =\n          option->peer_max_concurrent_streams;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {\n\n      (*session_ptr)->max_incoming_reserved_streams =\n          option->max_reserved_remote_streams;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&\n        option->no_recv_client_magic) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&\n        option->no_http_messaging) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {\n      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,\n             sizeof((*session_ptr)->user_recv_ext_types));\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {\n      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&\n        option->no_auto_ping_ack) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {\n      (*session_ptr)->max_send_header_block_length =\n          option->max_send_header_block_length;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {\n      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&\n        option->no_closed_streams) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&\n        option->max_settings) {\n      (*session_ptr)->max_settings = option->max_settings;\n    }\n  }\n\n  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,\n                                max_deflate_dynamic_table_size, mem);\n  if (rv != 0) {\n    goto fail_hd_deflater;\n  }\n  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);\n  if (rv != 0) {\n    goto fail_hd_inflater;\n  }\n  rv = nghttp2_map_init(&(*session_ptr)->streams, mem);\n  if (rv != 0) {\n    goto fail_map;\n  }\n\n  nbuffer = ((*session_ptr)->max_send_header_block_length +\n             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /\n            NGHTTP2_FRAMEBUF_CHUNKLEN;\n\n  if (nbuffer == 0) {\n    nbuffer = 1;\n  }\n\n  /* 1 for Pad Field. */\n  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,\n                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,\n                          NGHTTP2_FRAME_HDLEN + 1, mem);\n  if (rv != 0) {\n    goto fail_aob_framebuf;\n  }\n\n  active_outbound_item_reset(&(*session_ptr)->aob, mem);\n\n  (*session_ptr)->callbacks = *callbacks;\n  (*session_ptr)->user_data = user_data;\n\n  session_inbound_frame_reset(*session_ptr);\n\n  if (nghttp2_enable_strict_preface) {\n    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;\n\n    if (server && ((*session_ptr)->opt_flags &\n                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {\n      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;\n      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;\n    } else {\n      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n    }\n\n    if (!server) {\n      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;\n      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,\n                       NGHTTP2_CLIENT_MAGIC_LEN);\n    }\n  }\n\n  return 0;\n\nfail_aob_framebuf:\n  nghttp2_map_free(&(*session_ptr)->streams);\nfail_map:\n  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);\nfail_hd_inflater:\n  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);\nfail_hd_deflater:\n  nghttp2_mem_free(mem, *session_ptr);\nfail_session:\n  return rv;\n}\n\nint nghttp2_session_client_new(nghttp2_session **session_ptr,\n                               const nghttp2_session_callbacks *callbacks,\n                               void *user_data) {\n  return nghttp2_session_client_new3(session_ptr, callbacks, user_data, NULL,\n                                     NULL);\n}\n\nint nghttp2_session_client_new2(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option) {\n  return nghttp2_session_client_new3(session_ptr, callbacks, user_data, option,\n                                     NULL);\n}\n\nint nghttp2_session_client_new3(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option,\n                                nghttp2_mem *mem) {\n  int rv;\n  nghttp2_session *session;\n\n  rv = session_new(&session, callbacks, user_data, 0, option, mem);\n\n  if (rv != 0) {\n    return rv;\n  }\n  /* IDs for use in client */\n  session->next_stream_id = 1;\n\n  *session_ptr = session;\n\n  return 0;\n}\n\nint nghttp2_session_server_new(nghttp2_session **session_ptr,\n                               const nghttp2_session_callbacks *callbacks,\n                               void *user_data) {\n  return nghttp2_session_server_new3(session_ptr, callbacks, user_data, NULL,\n                                     NULL);\n}\n\nint nghttp2_session_server_new2(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option) {\n  return nghttp2_session_server_new3(session_ptr, callbacks, user_data, option,\n                                     NULL);\n}\n\nint nghttp2_session_server_new3(nghttp2_session **session_ptr,\n                                const nghttp2_session_callbacks *callbacks,\n                                void *user_data, const nghttp2_option *option,\n                                nghttp2_mem *mem) {\n  int rv;\n  nghttp2_session *session;\n\n  rv = session_new(&session, callbacks, user_data, 1, option, mem);\n\n  if (rv != 0) {\n    return rv;\n  }\n  /* IDs for use in client */\n  session->next_stream_id = 2;\n\n  *session_ptr = session;\n\n  return 0;\n}\n\nstatic int free_streams(nghttp2_map_entry *entry, void *ptr) {\n  nghttp2_session *session;\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  session = (nghttp2_session *)ptr;\n  mem = &session->mem;\n  stream = (nghttp2_stream *)entry;\n  item = stream->item;\n\n  if (item && !item->queued && item != session->aob.item) {\n    nghttp2_outbound_item_free(item, mem);\n    nghttp2_mem_free(mem, item);\n  }\n\n  nghttp2_stream_free(stream);\n  nghttp2_mem_free(mem, stream);\n\n  return 0;\n}\n\nstatic void ob_q_free(nghttp2_outbound_queue *q, nghttp2_mem *mem) {\n  nghttp2_outbound_item *item, *next;\n  for (item = q->head; item;) {\n    next = item->qnext;\n    nghttp2_outbound_item_free(item, mem);\n    nghttp2_mem_free(mem, item);\n    item = next;\n  }\n}\n\nstatic int inflight_settings_new(nghttp2_inflight_settings **settings_ptr,\n                                 const nghttp2_settings_entry *iv, size_t niv,\n                                 nghttp2_mem *mem) {\n  *settings_ptr = nghttp2_mem_malloc(mem, sizeof(nghttp2_inflight_settings));\n  if (!*settings_ptr) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  if (niv > 0) {\n    (*settings_ptr)->iv = nghttp2_frame_iv_copy(iv, niv, mem);\n    if (!(*settings_ptr)->iv) {\n      nghttp2_mem_free(mem, *settings_ptr);\n      return NGHTTP2_ERR_NOMEM;\n    }\n  } else {\n    (*settings_ptr)->iv = NULL;\n  }\n\n  (*settings_ptr)->niv = niv;\n  (*settings_ptr)->next = NULL;\n\n  return 0;\n}\n\nstatic void inflight_settings_del(nghttp2_inflight_settings *settings,\n                                  nghttp2_mem *mem) {\n  if (!settings) {\n    return;\n  }\n\n  nghttp2_mem_free(mem, settings->iv);\n  nghttp2_mem_free(mem, settings);\n}\n\nvoid nghttp2_session_del(nghttp2_session *session) {\n  nghttp2_mem *mem;\n  nghttp2_inflight_settings *settings;\n\n  if (session == NULL) {\n    return;\n  }\n\n  mem = &session->mem;\n\n  for (settings = session->inflight_settings_head; settings;) {\n    nghttp2_inflight_settings *next = settings->next;\n    inflight_settings_del(settings, mem);\n    settings = next;\n  }\n\n  nghttp2_stream_free(&session->root);\n\n  /* Have to free streams first, so that we can check\n     stream->item->queued */\n  nghttp2_map_each_free(&session->streams, free_streams, session);\n  nghttp2_map_free(&session->streams);\n\n  ob_q_free(&session->ob_urgent, mem);\n  ob_q_free(&session->ob_reg, mem);\n  ob_q_free(&session->ob_syn, mem);\n\n  active_outbound_item_reset(&session->aob, mem);\n  session_inbound_frame_reset(session);\n  nghttp2_hd_deflate_free(&session->hd_deflater);\n  nghttp2_hd_inflate_free(&session->hd_inflater);\n  nghttp2_bufs_free(&session->aob.framebufs);\n  nghttp2_mem_free(mem, session);\n}\n\nint nghttp2_session_reprioritize_stream(\n    nghttp2_session *session, nghttp2_stream *stream,\n    const nghttp2_priority_spec *pri_spec_in) {\n  int rv;\n  nghttp2_stream *dep_stream = NULL;\n  nghttp2_priority_spec pri_spec_default;\n  const nghttp2_priority_spec *pri_spec = pri_spec_in;\n\n  assert(pri_spec->stream_id != stream->stream_id);\n\n  if (!nghttp2_stream_in_dep_tree(stream)) {\n    return 0;\n  }\n\n  if (pri_spec->stream_id != 0) {\n    dep_stream = nghttp2_session_get_stream_raw(session, pri_spec->stream_id);\n\n    if (!dep_stream &&\n        session_detect_idle_stream(session, pri_spec->stream_id)) {\n\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n\n      dep_stream = nghttp2_session_open_stream(\n          session, pri_spec->stream_id, NGHTTP2_FLAG_NONE, &pri_spec_default,\n          NGHTTP2_STREAM_IDLE, NULL);\n\n      if (dep_stream == NULL) {\n        return NGHTTP2_ERR_NOMEM;\n      }\n    } else if (!dep_stream || !nghttp2_stream_in_dep_tree(dep_stream)) {\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n      pri_spec = &pri_spec_default;\n    }\n  }\n\n  if (pri_spec->stream_id == 0) {\n    dep_stream = &session->root;\n  } else if (nghttp2_stream_dep_find_ancestor(dep_stream, stream)) {\n    DEBUGF(\"stream: cycle detected, dep_stream(%p)=%d stream(%p)=%d\\n\",\n           dep_stream, dep_stream->stream_id, stream, stream->stream_id);\n\n    nghttp2_stream_dep_remove_subtree(dep_stream);\n    rv = nghttp2_stream_dep_add_subtree(stream->dep_prev, dep_stream);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  assert(dep_stream);\n\n  if (dep_stream == stream->dep_prev && !pri_spec->exclusive) {\n    /* This is minor optimization when just weight is changed. */\n    nghttp2_stream_change_weight(stream, pri_spec->weight);\n\n    return 0;\n  }\n\n  nghttp2_stream_dep_remove_subtree(stream);\n\n  /* We have to update weight after removing stream from tree */\n  stream->weight = pri_spec->weight;\n\n  if (pri_spec->exclusive) {\n    rv = nghttp2_stream_dep_insert_subtree(dep_stream, stream);\n  } else {\n    rv = nghttp2_stream_dep_add_subtree(dep_stream, stream);\n  }\n\n  if (rv != 0) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_add_item(nghttp2_session *session,\n                             nghttp2_outbound_item *item) {\n  /* TODO Return error if stream is not found for the frame requiring\n     stream presence. */\n  int rv = 0;\n  nghttp2_stream *stream;\n  nghttp2_frame *frame;\n\n  frame = &item->frame;\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n  switch (frame->hd.type) {\n  case NGHTTP2_DATA:\n    if (!stream) {\n      return NGHTTP2_ERR_STREAM_CLOSED;\n    }\n\n    if (stream->item) {\n      return NGHTTP2_ERR_DATA_EXIST;\n    }\n\n    rv = nghttp2_stream_attach_item(stream, item);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    return 0;\n  case NGHTTP2_HEADERS:\n    /* We push request HEADERS and push response HEADERS to\n       dedicated queue because their transmission is affected by\n       SETTINGS_MAX_CONCURRENT_STREAMS */\n    /* TODO If 2 HEADERS are submitted for reserved stream, then\n       both of them are queued into ob_syn, which is not\n       desirable. */\n    if (frame->headers.cat == NGHTTP2_HCAT_REQUEST ||\n        (stream && stream->state == NGHTTP2_STREAM_RESERVED)) {\n      nghttp2_outbound_queue_push(&session->ob_syn, item);\n      item->queued = 1;\n      return 0;\n      ;\n    }\n\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  case NGHTTP2_SETTINGS:\n  case NGHTTP2_PING:\n    nghttp2_outbound_queue_push(&session->ob_urgent, item);\n    item->queued = 1;\n    return 0;\n  case NGHTTP2_RST_STREAM:\n    if (stream) {\n      stream->state = NGHTTP2_STREAM_CLOSING;\n    }\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  case NGHTTP2_PUSH_PROMISE: {\n    nghttp2_headers_aux_data *aux_data;\n    nghttp2_priority_spec pri_spec;\n\n    aux_data = &item->aux_data.headers;\n\n    if (!stream) {\n      return NGHTTP2_ERR_STREAM_CLOSED;\n    }\n\n    nghttp2_priority_spec_init(&pri_spec, stream->stream_id,\n                               NGHTTP2_DEFAULT_WEIGHT, 0);\n\n    if (!nghttp2_session_open_stream(\n            session, frame->push_promise.promised_stream_id,\n            NGHTTP2_STREAM_FLAG_NONE, &pri_spec, NGHTTP2_STREAM_RESERVED,\n            aux_data->stream_user_data)) {\n      return NGHTTP2_ERR_NOMEM;\n    }\n\n    /* We don't have to call nghttp2_session_adjust_closed_stream()\n       here, since stream->stream_id is local stream_id, and it does\n       not affect closed stream count. */\n\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n\n    return 0;\n  }\n  case NGHTTP2_WINDOW_UPDATE:\n    if (stream) {\n      stream->window_update_queued = 1;\n    } else if (frame->hd.stream_id == 0) {\n      session->window_update_queued = 1;\n    }\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  default:\n    nghttp2_outbound_queue_push(&session->ob_reg, item);\n    item->queued = 1;\n    return 0;\n  }\n}\n\nint nghttp2_session_add_rst_stream(nghttp2_session *session, int32_t stream_id,\n                                   uint32_t error_code) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream && stream->state == NGHTTP2_STREAM_CLOSING) {\n    return 0;\n  }\n\n  /* Cancel pending request HEADERS in ob_syn if this RST_STREAM\n     refers to that stream. */\n  if (!session->server && nghttp2_session_is_my_stream_id(session, stream_id) &&\n      nghttp2_outbound_queue_top(&session->ob_syn)) {\n    nghttp2_headers_aux_data *aux_data;\n    nghttp2_frame *headers_frame;\n\n    headers_frame = &nghttp2_outbound_queue_top(&session->ob_syn)->frame;\n    assert(headers_frame->hd.type == NGHTTP2_HEADERS);\n\n    if (headers_frame->hd.stream_id <= stream_id &&\n        (uint32_t)stream_id < session->next_stream_id) {\n\n      for (item = session->ob_syn.head; item; item = item->qnext) {\n        aux_data = &item->aux_data.headers;\n\n        if (item->frame.hd.stream_id < stream_id) {\n          continue;\n        }\n\n        /* stream_id in ob_syn queue must be strictly increasing.  If\n           we found larger ID, then we can break here. */\n        if (item->frame.hd.stream_id > stream_id || aux_data->canceled) {\n          break;\n        }\n\n        aux_data->error_code = error_code;\n        aux_data->canceled = 1;\n\n        return 0;\n      }\n    }\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_rst_stream_init(&frame->rst_stream, stream_id, error_code);\n  rv = nghttp2_session_add_item(session, item);\n  if (rv != 0) {\n    nghttp2_frame_rst_stream_free(&frame->rst_stream);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n  return 0;\n}\n\nnghttp2_stream *nghttp2_session_open_stream(nghttp2_session *session,\n                                            int32_t stream_id, uint8_t flags,\n                                            nghttp2_priority_spec *pri_spec_in,\n                                            nghttp2_stream_state initial_state,\n                                            void *stream_user_data) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_stream *dep_stream = NULL;\n  int stream_alloc = 0;\n  nghttp2_priority_spec pri_spec_default;\n  nghttp2_priority_spec *pri_spec = pri_spec_in;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n\n  if (stream) {\n    assert(stream->state == NGHTTP2_STREAM_IDLE);\n    assert(nghttp2_stream_in_dep_tree(stream));\n    nghttp2_session_detach_idle_stream(session, stream);\n    rv = nghttp2_stream_dep_remove(stream);\n    if (rv != 0) {\n      return NULL;\n    }\n  } else {\n    stream = nghttp2_mem_malloc(mem, sizeof(nghttp2_stream));\n    if (stream == NULL) {\n      return NULL;\n    }\n\n    stream_alloc = 1;\n  }\n\n  if (pri_spec->stream_id != 0) {\n    dep_stream = nghttp2_session_get_stream_raw(session, pri_spec->stream_id);\n\n    if (!dep_stream &&\n        session_detect_idle_stream(session, pri_spec->stream_id)) {\n      /* Depends on idle stream, which does not exist in memory.\n         Assign default priority for it. */\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n\n      dep_stream = nghttp2_session_open_stream(\n          session, pri_spec->stream_id, NGHTTP2_FLAG_NONE, &pri_spec_default,\n          NGHTTP2_STREAM_IDLE, NULL);\n\n      if (dep_stream == NULL) {\n        if (stream_alloc) {\n          nghttp2_mem_free(mem, stream);\n        }\n\n        return NULL;\n      }\n    } else if (!dep_stream || !nghttp2_stream_in_dep_tree(dep_stream)) {\n      /* If dep_stream is not part of dependency tree, stream will get\n         default priority.  This handles the case when\n         pri_spec->stream_id == stream_id.  This happens because we\n         don't check pri_spec->stream_id against new stream ID in\n         nghttp2_submit_request.  This also handles the case when idle\n         stream created by PRIORITY frame was opened.  Somehow we\n         first remove the idle stream from dependency tree.  This is\n         done to simplify code base, but ideally we should retain old\n         dependency.  But I'm not sure this adds values. */\n      nghttp2_priority_spec_default_init(&pri_spec_default);\n      pri_spec = &pri_spec_default;\n    }\n  }\n\n  if (initial_state == NGHTTP2_STREAM_RESERVED) {\n    flags |= NGHTTP2_STREAM_FLAG_PUSH;\n  }\n\n  if (stream_alloc) {\n    nghttp2_stream_init(stream, stream_id, flags, initial_state,\n                        pri_spec->weight,\n                        (int32_t)session->remote_settings.initial_window_size,\n                        (int32_t)session->local_settings.initial_window_size,\n                        stream_user_data, mem);\n\n    rv = nghttp2_map_insert(&session->streams, &stream->map_entry);\n    if (rv != 0) {\n      nghttp2_stream_free(stream);\n      nghttp2_mem_free(mem, stream);\n      return NULL;\n    }\n  } else {\n    stream->flags = flags;\n    stream->state = initial_state;\n    stream->weight = pri_spec->weight;\n    stream->stream_user_data = stream_user_data;\n  }\n\n  switch (initial_state) {\n  case NGHTTP2_STREAM_RESERVED:\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      /* reserved (local) */\n      nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    } else {\n      /* reserved (remote) */\n      nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n      ++session->num_incoming_reserved_streams;\n    }\n    /* Reserved stream does not count in the concurrent streams\n       limit. That is one of the DOS vector. */\n    break;\n  case NGHTTP2_STREAM_IDLE:\n    /* Idle stream does not count toward the concurrent streams limit.\n       This is used as anchor node in dependency tree. */\n    nghttp2_session_keep_idle_stream(session, stream);\n    break;\n  default:\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      ++session->num_outgoing_streams;\n    } else {\n      ++session->num_incoming_streams;\n    }\n  }\n\n  if (pri_spec->stream_id == 0) {\n    dep_stream = &session->root;\n  }\n\n  assert(dep_stream);\n\n  if (pri_spec->exclusive) {\n    rv = nghttp2_stream_dep_insert(dep_stream, stream);\n    if (rv != 0) {\n      return NULL;\n    }\n  } else {\n    nghttp2_stream_dep_add(dep_stream, stream);\n  }\n\n  return stream;\n}\n\nint nghttp2_session_close_stream(nghttp2_session *session, int32_t stream_id,\n                                 uint32_t error_code) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n  int is_my_stream_id;\n\n  mem = &session->mem;\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  DEBUGF(\"stream: stream(%p)=%d close\\n\", stream, stream->stream_id);\n\n  if (stream->item) {\n    nghttp2_outbound_item *item;\n\n    item = stream->item;\n\n    rv = nghttp2_stream_detach_item(stream);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    /* If item is queued, it will be deleted when it is popped\n       (nghttp2_session_prep_frame() will fail).  If session->aob.item\n       points to this item, let active_outbound_item_reset()\n       free the item. */\n    if (!item->queued && item != session->aob.item) {\n      nghttp2_outbound_item_free(item, mem);\n      nghttp2_mem_free(mem, item);\n    }\n  }\n\n  /* We call on_stream_close_callback even if stream->state is\n     NGHTTP2_STREAM_INITIAL. This will happen while sending request\n     HEADERS, a local endpoint receives RST_STREAM for that stream. It\n     may be PROTOCOL_ERROR, but without notifying stream closure will\n     hang the stream in a local endpoint.\n  */\n\n  if (session->callbacks.on_stream_close_callback) {\n    if (session->callbacks.on_stream_close_callback(\n            session, stream_id, error_code, session->user_data) != 0) {\n\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n\n  is_my_stream_id = nghttp2_session_is_my_stream_id(session, stream_id);\n\n  /* pushed streams which is not opened yet is not counted toward max\n     concurrent limits */\n  if ((stream->flags & NGHTTP2_STREAM_FLAG_PUSH)) {\n    if (!is_my_stream_id) {\n      --session->num_incoming_reserved_streams;\n    }\n  } else {\n    if (is_my_stream_id) {\n      --session->num_outgoing_streams;\n    } else {\n      --session->num_incoming_streams;\n    }\n  }\n\n  /* Closes both directions just in case they are not closed yet */\n  stream->flags |= NGHTTP2_STREAM_FLAG_CLOSED;\n\n  if ((session->opt_flags & NGHTTP2_OPTMASK_NO_CLOSED_STREAMS) == 0 &&\n      session->server && !is_my_stream_id &&\n      nghttp2_stream_in_dep_tree(stream)) {\n    /* On server side, retain stream at most MAX_CONCURRENT_STREAMS\n       combined with the current active incoming streams to make\n       dependency tree work better. */\n    nghttp2_session_keep_closed_stream(session, stream);\n  } else {\n    rv = nghttp2_session_destroy_stream(session, stream);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  return 0;\n}\n\nint nghttp2_session_destroy_stream(nghttp2_session *session,\n                                   nghttp2_stream *stream) {\n  nghttp2_mem *mem;\n  int rv;\n\n  DEBUGF(\"stream: destroy closed stream(%p)=%d\\n\", stream, stream->stream_id);\n\n  mem = &session->mem;\n\n  if (nghttp2_stream_in_dep_tree(stream)) {\n    rv = nghttp2_stream_dep_remove(stream);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  nghttp2_map_remove(&session->streams, stream->stream_id);\n  nghttp2_stream_free(stream);\n  nghttp2_mem_free(mem, stream);\n\n  return 0;\n}\n\nvoid nghttp2_session_keep_closed_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream) {\n  DEBUGF(\"stream: keep closed stream(%p)=%d, state=%d\\n\", stream,\n         stream->stream_id, stream->state);\n\n  if (session->closed_stream_tail) {\n    session->closed_stream_tail->closed_next = stream;\n    stream->closed_prev = session->closed_stream_tail;\n  } else {\n    session->closed_stream_head = stream;\n  }\n  session->closed_stream_tail = stream;\n\n  ++session->num_closed_streams;\n}\n\nvoid nghttp2_session_keep_idle_stream(nghttp2_session *session,\n                                      nghttp2_stream *stream) {\n  DEBUGF(\"stream: keep idle stream(%p)=%d, state=%d\\n\", stream,\n         stream->stream_id, stream->state);\n\n  if (session->idle_stream_tail) {\n    session->idle_stream_tail->closed_next = stream;\n    stream->closed_prev = session->idle_stream_tail;\n  } else {\n    session->idle_stream_head = stream;\n  }\n  session->idle_stream_tail = stream;\n\n  ++session->num_idle_streams;\n}\n\nvoid nghttp2_session_detach_idle_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream) {\n  nghttp2_stream *prev_stream, *next_stream;\n\n  DEBUGF(\"stream: detach idle stream(%p)=%d, state=%d\\n\", stream,\n         stream->stream_id, stream->state);\n\n  prev_stream = stream->closed_prev;\n  next_stream = stream->closed_next;\n\n  if (prev_stream) {\n    prev_stream->closed_next = next_stream;\n  } else {\n    session->idle_stream_head = next_stream;\n  }\n\n  if (next_stream) {\n    next_stream->closed_prev = prev_stream;\n  } else {\n    session->idle_stream_tail = prev_stream;\n  }\n\n  stream->closed_prev = NULL;\n  stream->closed_next = NULL;\n\n  --session->num_idle_streams;\n}\n\nint nghttp2_session_adjust_closed_stream(nghttp2_session *session) {\n  size_t num_stream_max;\n  int rv;\n\n  if (session->local_settings.max_concurrent_streams ==\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS) {\n    num_stream_max = session->pending_local_max_concurrent_stream;\n  } else {\n    num_stream_max = session->local_settings.max_concurrent_streams;\n  }\n\n  DEBUGF(\"stream: adjusting kept closed streams num_closed_streams=%zu, \"\n         \"num_incoming_streams=%zu, max_concurrent_streams=%zu\\n\",\n         session->num_closed_streams, session->num_incoming_streams,\n         num_stream_max);\n\n  while (session->num_closed_streams > 0 &&\n         session->num_closed_streams + session->num_incoming_streams >\n             num_stream_max) {\n    nghttp2_stream *head_stream;\n    nghttp2_stream *next;\n\n    head_stream = session->closed_stream_head;\n\n    assert(head_stream);\n\n    next = head_stream->closed_next;\n\n    rv = nghttp2_session_destroy_stream(session, head_stream);\n    if (rv != 0) {\n      return rv;\n    }\n\n    /* head_stream is now freed */\n\n    session->closed_stream_head = next;\n\n    if (session->closed_stream_head) {\n      session->closed_stream_head->closed_prev = NULL;\n    } else {\n      session->closed_stream_tail = NULL;\n    }\n\n    --session->num_closed_streams;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_adjust_idle_stream(nghttp2_session *session) {\n  size_t max;\n  int rv;\n\n  /* Make minimum number of idle streams 16, and maximum 100, which\n     are arbitrary chosen numbers. */\n  max = nghttp2_min(\n      100, nghttp2_max(\n               16, nghttp2_min(session->local_settings.max_concurrent_streams,\n                               session->pending_local_max_concurrent_stream)));\n\n  DEBUGF(\"stream: adjusting kept idle streams num_idle_streams=%zu, max=%zu\\n\",\n         session->num_idle_streams, max);\n\n  while (session->num_idle_streams > max) {\n    nghttp2_stream *head;\n    nghttp2_stream *next;\n\n    head = session->idle_stream_head;\n    assert(head);\n\n    next = head->closed_next;\n\n    rv = nghttp2_session_destroy_stream(session, head);\n    if (rv != 0) {\n      return rv;\n    }\n\n    /* head is now destroyed */\n\n    session->idle_stream_head = next;\n\n    if (session->idle_stream_head) {\n      session->idle_stream_head->closed_prev = NULL;\n    } else {\n      session->idle_stream_tail = NULL;\n    }\n\n    --session->num_idle_streams;\n  }\n\n  return 0;\n}\n\n/*\n * Closes stream with stream ID |stream_id| if both transmission and\n * reception of the stream were disallowed. The |error_code| indicates\n * the reason of the closure.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *   The stream is not found.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *   The callback function failed.\n */\nint nghttp2_session_close_stream_if_shut_rdwr(nghttp2_session *session,\n                                              nghttp2_stream *stream) {\n  if ((stream->shut_flags & NGHTTP2_SHUT_RDWR) == NGHTTP2_SHUT_RDWR) {\n    return nghttp2_session_close_stream(session, stream->stream_id,\n                                        NGHTTP2_NO_ERROR);\n  }\n  return 0;\n}\n\n/*\n * Returns nonzero if local endpoint allows reception of new stream\n * from remote.\n */\nstatic int session_allow_incoming_new_stream(nghttp2_session *session) {\n  return (session->goaway_flags &\n          (NGHTTP2_GOAWAY_TERM_ON_SEND | NGHTTP2_GOAWAY_SENT)) == 0;\n}\n\n/*\n * This function returns nonzero if session is closing.\n */\nstatic int session_is_closing(nghttp2_session *session) {\n  return (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND) != 0 ||\n         (nghttp2_session_want_read(session) == 0 &&\n          nghttp2_session_want_write(session) == 0);\n}\n\n/*\n * Check that we can send a frame to the |stream|. This function\n * returns 0 if we can send a frame to the |frame|, or one of the\n * following negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *   The stream is already closed.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *   The stream is half-closed for transmission.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_for_stream_send(nghttp2_session *session,\n                                             nghttp2_stream *stream) {\n  if (stream == NULL) {\n    return NGHTTP2_ERR_STREAM_CLOSED;\n  }\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n  if (stream->shut_flags & NGHTTP2_SHUT_WR) {\n    return NGHTTP2_ERR_STREAM_SHUT_WR;\n  }\n  return 0;\n}\n\nint nghttp2_session_check_request_allowed(nghttp2_session *session) {\n  return !session->server && session->next_stream_id <= INT32_MAX &&\n         (session->goaway_flags & NGHTTP2_GOAWAY_RECV) == 0 &&\n         !session_is_closing(session);\n}\n\n/*\n * This function checks request HEADERS frame, which opens stream, can\n * be sent at this time.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_START_STREAM_NOT_ALLOWED\n *     New stream cannot be created because of GOAWAY: session is\n *     going down or received last_stream_id is strictly less than\n *     frame->hd.stream_id.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     request HEADERS was canceled by RST_STREAM while it is in queue.\n */\nstatic int session_predicate_request_headers_send(nghttp2_session *session,\n                                                  nghttp2_outbound_item *item) {\n  if (item->aux_data.headers.canceled) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  /* If we are terminating session (NGHTTP2_GOAWAY_TERM_ON_SEND),\n     GOAWAY was received from peer, or session is about to close, new\n     request is not allowed. */\n  if ((session->goaway_flags & NGHTTP2_GOAWAY_RECV) ||\n      session_is_closing(session)) {\n    return NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n  }\n  return 0;\n}\n\n/*\n * This function checks HEADERS, which is the first frame from the\n * server, with the |stream| can be sent at this time.  The |stream|\n * can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_INVALID_STREAM_ID\n *     The stream ID is invalid.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *     This session is closing.\n * NGHTTP2_ERR_PROTO\n *     Client side attempted to send response.\n */\nstatic int session_predicate_response_headers_send(nghttp2_session *session,\n                                                   nghttp2_stream *stream) {\n  int rv;\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n  if (!session->server) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n    return NGHTTP2_ERR_INVALID_STREAM_ID;\n  }\n  switch (stream->state) {\n  case NGHTTP2_STREAM_OPENING:\n    return 0;\n  case NGHTTP2_STREAM_CLOSING:\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  default:\n    return NGHTTP2_ERR_INVALID_STREAM_STATE;\n  }\n}\n\n/*\n * This function checks HEADERS for reserved stream can be sent. The\n * |stream| must be reserved state and the |session| is server side.\n * The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *   The stream is already closed.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *   The stream is half-closed for transmission.\n * NGHTTP2_ERR_PROTO\n *   The stream is not reserved state\n * NGHTTP2_ERR_STREAM_CLOSED\n *   RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n * NGHTTP2_ERR_START_STREAM_NOT_ALLOWED\n *   New stream cannot be created because GOAWAY is already sent or\n *   received.\n * NGHTTP2_ERR_PROTO\n *   Client side attempted to send push response.\n */\nstatic int\nsession_predicate_push_response_headers_send(nghttp2_session *session,\n                                             nghttp2_stream *stream) {\n  int rv;\n  /* TODO Should disallow HEADERS if GOAWAY has already been issued? */\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n  if (!session->server) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (stream->state != NGHTTP2_STREAM_RESERVED) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (session->goaway_flags & NGHTTP2_GOAWAY_RECV) {\n    return NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n  }\n  return 0;\n}\n\n/*\n * This function checks HEADERS, which is neither stream-opening nor\n * first response header, with the |stream| can be sent at this time.\n * The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_headers_send(nghttp2_session *session,\n                                          nghttp2_stream *stream) {\n  int rv;\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n\n  switch (stream->state) {\n  case NGHTTP2_STREAM_OPENED:\n    return 0;\n  case NGHTTP2_STREAM_CLOSING:\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  default:\n    if (nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n      return 0;\n    }\n    return NGHTTP2_ERR_INVALID_STREAM_STATE;\n  }\n}\n\n/*\n * This function checks PUSH_PROMISE frame |frame| with the |stream|\n * can be sent at this time.  The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_START_STREAM_NOT_ALLOWED\n *     New stream cannot be created because GOAWAY is already sent or\n *     received.\n * NGHTTP2_ERR_PROTO\n *     The client side attempts to send PUSH_PROMISE, or the server\n *     sends PUSH_PROMISE for the stream not initiated by the client.\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_PUSH_DISABLED\n *     The remote peer disabled reception of PUSH_PROMISE.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_push_promise_send(nghttp2_session *session,\n                                               nghttp2_stream *stream) {\n  int rv;\n\n  if (!session->server) {\n    return NGHTTP2_ERR_PROTO;\n  }\n\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n\n  assert(stream);\n\n  if (session->remote_settings.enable_push == 0) {\n    return NGHTTP2_ERR_PUSH_DISABLED;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  if (session->goaway_flags & NGHTTP2_GOAWAY_RECV) {\n    return NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n  }\n  return 0;\n}\n\n/*\n * This function checks WINDOW_UPDATE with the stream ID |stream_id|\n * can be sent at this time. Note that END_STREAM flag of the previous\n * frame does not affect the transmission of the WINDOW_UPDATE frame.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int session_predicate_window_update_send(nghttp2_session *session,\n                                                int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n\n  if (stream_id == 0) {\n    /* Connection-level window update */\n    return 0;\n  }\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_STREAM_CLOSED;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  if (state_reserved_local(session, stream)) {\n    return NGHTTP2_ERR_INVALID_STREAM_STATE;\n  }\n  return 0;\n}\n\nstatic int session_predicate_altsvc_send(nghttp2_session *session,\n                                         int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n\n  if (stream_id == 0) {\n    return 0;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_STREAM_CLOSED;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n\n  return 0;\n}\n\nstatic int session_predicate_origin_send(nghttp2_session *session) {\n  if (session_is_closing(session)) {\n    return NGHTTP2_ERR_SESSION_CLOSING;\n  }\n  return 0;\n}\n\n/* Take into account settings max frame size and both connection-level\n   flow control here */\nstatic ssize_t\nnghttp2_session_enforce_flow_control_limits(nghttp2_session *session,\n                                            nghttp2_stream *stream,\n                                            ssize_t requested_window_size) {\n  DEBUGF(\"send: remote windowsize connection=%d, remote maxframsize=%u, \"\n         \"stream(id %d)=%d\\n\",\n         session->remote_window_size, session->remote_settings.max_frame_size,\n         stream->stream_id, stream->remote_window_size);\n\n  return nghttp2_min(nghttp2_min(nghttp2_min(requested_window_size,\n                                             stream->remote_window_size),\n                                 session->remote_window_size),\n                     (int32_t)session->remote_settings.max_frame_size);\n}\n\n/*\n * Returns the maximum length of next data read. If the\n * connection-level and/or stream-wise flow control are enabled, the\n * return value takes into account those current window sizes. The remote\n * settings for max frame size is also taken into account.\n */\nstatic size_t nghttp2_session_next_data_read(nghttp2_session *session,\n                                             nghttp2_stream *stream) {\n  ssize_t window_size;\n\n  window_size = nghttp2_session_enforce_flow_control_limits(\n      session, stream, NGHTTP2_DATA_PAYLOADLEN);\n\n  DEBUGF(\"send: available window=%zd\\n\", window_size);\n\n  return window_size > 0 ? (size_t)window_size : 0;\n}\n\n/*\n * This function checks DATA with the |stream| can be sent at this\n * time.  The |stream| can be NULL.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_STREAM_CLOSED\n *     The stream is already closed or does not exist.\n * NGHTTP2_ERR_STREAM_SHUT_WR\n *     The transmission is not allowed for this stream (e.g., a frame\n *     with END_STREAM flag set has already sent)\n * NGHTTP2_ERR_STREAM_CLOSING\n *     RST_STREAM was queued for this stream.\n * NGHTTP2_ERR_INVALID_STREAM_STATE\n *     The state of the stream is not valid.\n * NGHTTP2_ERR_SESSION_CLOSING\n *   This session is closing.\n */\nstatic int nghttp2_session_predicate_data_send(nghttp2_session *session,\n                                               nghttp2_stream *stream) {\n  int rv;\n  rv = session_predicate_for_stream_send(session, stream);\n  if (rv != 0) {\n    return rv;\n  }\n  assert(stream);\n  if (nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n    /* Request body data */\n    /* If stream->state is NGHTTP2_STREAM_CLOSING, RST_STREAM was\n       queued but not yet sent. In this case, we won't send DATA\n       frames. */\n    if (stream->state == NGHTTP2_STREAM_CLOSING) {\n      return NGHTTP2_ERR_STREAM_CLOSING;\n    }\n    if (stream->state == NGHTTP2_STREAM_RESERVED) {\n      return NGHTTP2_ERR_INVALID_STREAM_STATE;\n    }\n    return 0;\n  }\n  /* Response body data */\n  if (stream->state == NGHTTP2_STREAM_OPENED) {\n    return 0;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_STREAM_CLOSING;\n  }\n  return NGHTTP2_ERR_INVALID_STREAM_STATE;\n}\n\nstatic ssize_t session_call_select_padding(nghttp2_session *session,\n                                           const nghttp2_frame *frame,\n                                           size_t max_payloadlen) {\n  ssize_t rv;\n\n  if (frame->hd.length >= max_payloadlen) {\n    return (ssize_t)frame->hd.length;\n  }\n\n  if (session->callbacks.select_padding_callback) {\n    size_t max_paddedlen;\n\n    max_paddedlen =\n        nghttp2_min(frame->hd.length + NGHTTP2_MAX_PADLEN, max_payloadlen);\n\n    rv = session->callbacks.select_padding_callback(\n        session, frame, max_paddedlen, session->user_data);\n    if (rv < (ssize_t)frame->hd.length || rv > (ssize_t)max_paddedlen) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    return rv;\n  }\n  return (ssize_t)frame->hd.length;\n}\n\n/* Add padding to HEADERS or PUSH_PROMISE. We use\n   frame->headers.padlen in this function to use the fact that\n   frame->push_promise has also padlen in the same position. */\nstatic int session_headers_add_pad(nghttp2_session *session,\n                                   nghttp2_frame *frame) {\n  int rv;\n  ssize_t padded_payloadlen;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  size_t padlen;\n  size_t max_payloadlen;\n\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  max_payloadlen = nghttp2_min(NGHTTP2_MAX_PAYLOADLEN,\n                               frame->hd.length + NGHTTP2_MAX_PADLEN);\n\n  padded_payloadlen =\n      session_call_select_padding(session, frame, max_payloadlen);\n\n  if (nghttp2_is_fatal((int)padded_payloadlen)) {\n    return (int)padded_payloadlen;\n  }\n\n  padlen = (size_t)padded_payloadlen - frame->hd.length;\n\n  DEBUGF(\"send: padding selected: payloadlen=%zd, padlen=%zu\\n\",\n         padded_payloadlen, padlen);\n\n  rv = nghttp2_frame_add_pad(framebufs, &frame->hd, padlen, 0);\n\n  if (rv != 0) {\n    return rv;\n  }\n\n  frame->headers.padlen = padlen;\n\n  return 0;\n}\n\nstatic size_t session_estimate_headers_payload(nghttp2_session *session,\n                                               const nghttp2_nv *nva,\n                                               size_t nvlen,\n                                               size_t additional) {\n  return nghttp2_hd_deflate_bound(&session->hd_deflater, nva, nvlen) +\n         additional;\n}\n\nstatic int session_pack_extension(nghttp2_session *session, nghttp2_bufs *bufs,\n                                  nghttp2_frame *frame) {\n  ssize_t rv;\n  nghttp2_buf *buf;\n  size_t buflen;\n  size_t framelen;\n\n  assert(session->callbacks.pack_extension_callback);\n\n  buf = &bufs->head->buf;\n  buflen = nghttp2_min(nghttp2_buf_avail(buf), NGHTTP2_MAX_PAYLOADLEN);\n\n  rv = session->callbacks.pack_extension_callback(session, buf->last, buflen,\n                                                  frame, session->user_data);\n  if (rv == NGHTTP2_ERR_CANCEL) {\n    return (int)rv;\n  }\n\n  if (rv < 0 || (size_t)rv > buflen) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  framelen = (size_t)rv;\n\n  frame->hd.length = framelen;\n\n  assert(buf->pos == buf->last);\n  buf->last += framelen;\n  buf->pos -= NGHTTP2_FRAME_HDLEN;\n\n  nghttp2_frame_pack_frame_hd(buf->pos, &frame->hd);\n\n  return 0;\n}\n\n/*\n * This function serializes frame for transmission.\n *\n * This function returns 0 if it succeeds, or one of negative error\n * codes, including both fatal and non-fatal ones.\n */\nstatic int session_prep_frame(nghttp2_session *session,\n                              nghttp2_outbound_item *item) {\n  int rv;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  frame = &item->frame;\n\n  switch (frame->hd.type) {\n  case NGHTTP2_DATA: {\n    size_t next_readmax;\n    nghttp2_stream *stream;\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n    if (stream) {\n      assert(stream->item == item);\n    }\n\n    rv = nghttp2_session_predicate_data_send(session, stream);\n    if (rv != 0) {\n      // If stream was already closed, nghttp2_session_get_stream()\n      // returns NULL, but item is still attached to the stream.\n      // Search stream including closed again.\n      stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n      if (stream) {\n        int rv2;\n\n        rv2 = nghttp2_stream_detach_item(stream);\n\n        if (nghttp2_is_fatal(rv2)) {\n          return rv2;\n        }\n      }\n\n      return rv;\n    }\n    /* Assuming stream is not NULL */\n    assert(stream);\n    next_readmax = nghttp2_session_next_data_read(session, stream);\n\n    if (next_readmax == 0) {\n\n      /* This must be true since we only pop DATA frame item from\n         queue when session->remote_window_size > 0 */\n      assert(session->remote_window_size > 0);\n\n      rv = nghttp2_stream_defer_item(stream,\n                                     NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session->aob.item = NULL;\n      active_outbound_item_reset(&session->aob, mem);\n      return NGHTTP2_ERR_DEFERRED;\n    }\n\n    rv = nghttp2_session_pack_data(session, &session->aob.framebufs,\n                                   next_readmax, frame, &item->aux_data.data,\n                                   stream);\n    if (rv == NGHTTP2_ERR_PAUSE) {\n      return rv;\n    }\n    if (rv == NGHTTP2_ERR_DEFERRED) {\n      rv = nghttp2_stream_defer_item(stream, NGHTTP2_STREAM_FLAG_DEFERRED_USER);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session->aob.item = NULL;\n      active_outbound_item_reset(&session->aob, mem);\n      return NGHTTP2_ERR_DEFERRED;\n    }\n    if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n      rv = nghttp2_stream_detach_item(stream);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      rv = nghttp2_session_add_rst_stream(session, frame->hd.stream_id,\n                                          NGHTTP2_INTERNAL_ERROR);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n    if (rv != 0) {\n      int rv2;\n\n      rv2 = nghttp2_stream_detach_item(stream);\n\n      if (nghttp2_is_fatal(rv2)) {\n        return rv2;\n      }\n\n      return rv;\n    }\n    return 0;\n  }\n  case NGHTTP2_HEADERS: {\n    nghttp2_headers_aux_data *aux_data;\n    size_t estimated_payloadlen;\n\n    aux_data = &item->aux_data.headers;\n\n    if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n      /* initial HEADERS, which opens stream */\n      nghttp2_stream *stream;\n\n      stream = nghttp2_session_open_stream(\n          session, frame->hd.stream_id, NGHTTP2_STREAM_FLAG_NONE,\n          &frame->headers.pri_spec, NGHTTP2_STREAM_INITIAL,\n          aux_data->stream_user_data);\n\n      if (stream == NULL) {\n        return NGHTTP2_ERR_NOMEM;\n      }\n\n      /* We don't call nghttp2_session_adjust_closed_stream() here,\n         since we don't keep closed stream in client side */\n\n      rv = session_predicate_request_headers_send(session, item);\n      if (rv != 0) {\n        return rv;\n      }\n\n      if (session_enforce_http_messaging(session)) {\n        nghttp2_http_record_request_method(stream, frame);\n      }\n    } else {\n      nghttp2_stream *stream;\n\n      stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n      if (stream && stream->state == NGHTTP2_STREAM_RESERVED) {\n        rv = session_predicate_push_response_headers_send(session, stream);\n        if (rv == 0) {\n          frame->headers.cat = NGHTTP2_HCAT_PUSH_RESPONSE;\n\n          if (aux_data->stream_user_data) {\n            stream->stream_user_data = aux_data->stream_user_data;\n          }\n        }\n      } else if (session_predicate_response_headers_send(session, stream) ==\n                 0) {\n        frame->headers.cat = NGHTTP2_HCAT_RESPONSE;\n        rv = 0;\n      } else {\n        frame->headers.cat = NGHTTP2_HCAT_HEADERS;\n\n        rv = session_predicate_headers_send(session, stream);\n      }\n\n      if (rv != 0) {\n        return rv;\n      }\n    }\n\n    estimated_payloadlen = session_estimate_headers_payload(\n        session, frame->headers.nva, frame->headers.nvlen,\n        NGHTTP2_PRIORITY_SPECLEN);\n\n    if (estimated_payloadlen > session->max_send_header_block_length) {\n      return NGHTTP2_ERR_FRAME_SIZE_ERROR;\n    }\n\n    rv = nghttp2_frame_pack_headers(&session->aob.framebufs, &frame->headers,\n                                    &session->hd_deflater);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    DEBUGF(\"send: before padding, HEADERS serialized in %zd bytes\\n\",\n           nghttp2_bufs_len(&session->aob.framebufs));\n\n    rv = session_headers_add_pad(session, frame);\n\n    if (rv != 0) {\n      return rv;\n    }\n\n    DEBUGF(\"send: HEADERS finally serialized in %zd bytes\\n\",\n           nghttp2_bufs_len(&session->aob.framebufs));\n\n    if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n      assert(session->last_sent_stream_id < frame->hd.stream_id);\n      session->last_sent_stream_id = frame->hd.stream_id;\n    }\n\n    return 0;\n  }\n  case NGHTTP2_PRIORITY: {\n    if (session_is_closing(session)) {\n      return NGHTTP2_ERR_SESSION_CLOSING;\n    }\n    /* PRIORITY frame can be sent at any time and to any stream\n       ID. */\n    nghttp2_frame_pack_priority(&session->aob.framebufs, &frame->priority);\n\n    /* Peer can send PRIORITY frame against idle stream to create\n       \"anchor\" in dependency tree.  Only client can do this in\n       nghttp2.  In nghttp2, only server retains non-active (closed\n       or idle) streams in memory, so we don't open stream here. */\n    return 0;\n  }\n  case NGHTTP2_RST_STREAM:\n    if (session_is_closing(session)) {\n      return NGHTTP2_ERR_SESSION_CLOSING;\n    }\n    nghttp2_frame_pack_rst_stream(&session->aob.framebufs, &frame->rst_stream);\n    return 0;\n  case NGHTTP2_SETTINGS: {\n    if (frame->hd.flags & NGHTTP2_FLAG_ACK) {\n      assert(session->obq_flood_counter_ > 0);\n      --session->obq_flood_counter_;\n      /* When session is about to close, don't send SETTINGS ACK.\n         We are required to send SETTINGS without ACK though; for\n         example, we have to send SETTINGS as a part of connection\n         preface. */\n      if (session_is_closing(session)) {\n        return NGHTTP2_ERR_SESSION_CLOSING;\n      }\n    }\n\n    rv = nghttp2_frame_pack_settings(&session->aob.framebufs, &frame->settings);\n    if (rv != 0) {\n      return rv;\n    }\n    return 0;\n  }\n  case NGHTTP2_PUSH_PROMISE: {\n    nghttp2_stream *stream;\n    size_t estimated_payloadlen;\n\n    /* stream could be NULL if associated stream was already\n       closed. */\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n    /* predicate should fail if stream is NULL. */\n    rv = session_predicate_push_promise_send(session, stream);\n    if (rv != 0) {\n      return rv;\n    }\n\n    assert(stream);\n\n    estimated_payloadlen = session_estimate_headers_payload(\n        session, frame->push_promise.nva, frame->push_promise.nvlen, 0);\n\n    if (estimated_payloadlen > session->max_send_header_block_length) {\n      return NGHTTP2_ERR_FRAME_SIZE_ERROR;\n    }\n\n    rv = nghttp2_frame_pack_push_promise(\n        &session->aob.framebufs, &frame->push_promise, &session->hd_deflater);\n    if (rv != 0) {\n      return rv;\n    }\n    rv = session_headers_add_pad(session, frame);\n    if (rv != 0) {\n      return rv;\n    }\n\n    assert(session->last_sent_stream_id + 2 <=\n           frame->push_promise.promised_stream_id);\n    session->last_sent_stream_id = frame->push_promise.promised_stream_id;\n\n    return 0;\n  }\n  case NGHTTP2_PING:\n    if (frame->hd.flags & NGHTTP2_FLAG_ACK) {\n      assert(session->obq_flood_counter_ > 0);\n      --session->obq_flood_counter_;\n    }\n    /* PING frame is allowed to be sent unless termination GOAWAY is\n       sent */\n    if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND) {\n      return NGHTTP2_ERR_SESSION_CLOSING;\n    }\n    nghttp2_frame_pack_ping(&session->aob.framebufs, &frame->ping);\n    return 0;\n  case NGHTTP2_GOAWAY:\n    rv = nghttp2_frame_pack_goaway(&session->aob.framebufs, &frame->goaway);\n    if (rv != 0) {\n      return rv;\n    }\n    session->local_last_stream_id = frame->goaway.last_stream_id;\n\n    return 0;\n  case NGHTTP2_WINDOW_UPDATE:\n    rv = session_predicate_window_update_send(session, frame->hd.stream_id);\n    if (rv != 0) {\n      return rv;\n    }\n    nghttp2_frame_pack_window_update(&session->aob.framebufs,\n                                     &frame->window_update);\n    return 0;\n  case NGHTTP2_CONTINUATION:\n    /* We never handle CONTINUATION here. */\n    assert(0);\n    return 0;\n  default: {\n    nghttp2_ext_aux_data *aux_data;\n\n    /* extension frame */\n\n    aux_data = &item->aux_data.ext;\n\n    if (aux_data->builtin == 0) {\n      if (session_is_closing(session)) {\n        return NGHTTP2_ERR_SESSION_CLOSING;\n      }\n\n      return session_pack_extension(session, &session->aob.framebufs, frame);\n    }\n\n    switch (frame->hd.type) {\n    case NGHTTP2_ALTSVC:\n      rv = session_predicate_altsvc_send(session, frame->hd.stream_id);\n      if (rv != 0) {\n        return rv;\n      }\n\n      nghttp2_frame_pack_altsvc(&session->aob.framebufs, &frame->ext);\n\n      return 0;\n    case NGHTTP2_ORIGIN:\n      rv = session_predicate_origin_send(session);\n      if (rv != 0) {\n        return rv;\n      }\n\n      rv = nghttp2_frame_pack_origin(&session->aob.framebufs, &frame->ext);\n      if (rv != 0) {\n        return rv;\n      }\n\n      return 0;\n    default:\n      /* Unreachable here */\n      assert(0);\n      return 0;\n    }\n  }\n  }\n}\n\nnghttp2_outbound_item *\nnghttp2_session_get_next_ob_item(nghttp2_session *session) {\n  if (nghttp2_outbound_queue_top(&session->ob_urgent)) {\n    return nghttp2_outbound_queue_top(&session->ob_urgent);\n  }\n\n  if (nghttp2_outbound_queue_top(&session->ob_reg)) {\n    return nghttp2_outbound_queue_top(&session->ob_reg);\n  }\n\n  if (!session_is_outgoing_concurrent_streams_max(session)) {\n    if (nghttp2_outbound_queue_top(&session->ob_syn)) {\n      return nghttp2_outbound_queue_top(&session->ob_syn);\n    }\n  }\n\n  if (session->remote_window_size > 0) {\n    return nghttp2_stream_next_outbound_item(&session->root);\n  }\n\n  return NULL;\n}\n\nnghttp2_outbound_item *\nnghttp2_session_pop_next_ob_item(nghttp2_session *session) {\n  nghttp2_outbound_item *item;\n\n  item = nghttp2_outbound_queue_top(&session->ob_urgent);\n  if (item) {\n    nghttp2_outbound_queue_pop(&session->ob_urgent);\n    item->queued = 0;\n    return item;\n  }\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n  if (item) {\n    nghttp2_outbound_queue_pop(&session->ob_reg);\n    item->queued = 0;\n    return item;\n  }\n\n  if (!session_is_outgoing_concurrent_streams_max(session)) {\n    item = nghttp2_outbound_queue_top(&session->ob_syn);\n    if (item) {\n      nghttp2_outbound_queue_pop(&session->ob_syn);\n      item->queued = 0;\n      return item;\n    }\n  }\n\n  if (session->remote_window_size > 0) {\n    return nghttp2_stream_next_outbound_item(&session->root);\n  }\n\n  return NULL;\n}\n\nstatic int session_call_before_frame_send(nghttp2_session *session,\n                                          nghttp2_frame *frame) {\n  int rv;\n  if (session->callbacks.before_frame_send_callback) {\n    rv = session->callbacks.before_frame_send_callback(session, frame,\n                                                       session->user_data);\n    if (rv == NGHTTP2_ERR_CANCEL) {\n      return rv;\n    }\n\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_call_on_frame_send(nghttp2_session *session,\n                                      nghttp2_frame *frame) {\n  int rv;\n  if (session->callbacks.on_frame_send_callback) {\n    rv = session->callbacks.on_frame_send_callback(session, frame,\n                                                   session->user_data);\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int find_stream_on_goaway_func(nghttp2_map_entry *entry, void *ptr) {\n  nghttp2_close_stream_on_goaway_arg *arg;\n  nghttp2_stream *stream;\n\n  arg = (nghttp2_close_stream_on_goaway_arg *)ptr;\n  stream = (nghttp2_stream *)entry;\n\n  if (nghttp2_session_is_my_stream_id(arg->session, stream->stream_id)) {\n    if (arg->incoming) {\n      return 0;\n    }\n  } else if (!arg->incoming) {\n    return 0;\n  }\n\n  if (stream->state != NGHTTP2_STREAM_IDLE &&\n      (stream->flags & NGHTTP2_STREAM_FLAG_CLOSED) == 0 &&\n      stream->stream_id > arg->last_stream_id) {\n    /* We are collecting streams to close because we cannot call\n       nghttp2_session_close_stream() inside nghttp2_map_each().\n       Reuse closed_next member.. bad choice? */\n    assert(stream->closed_next == NULL);\n    assert(stream->closed_prev == NULL);\n\n    if (arg->head) {\n      stream->closed_next = arg->head;\n      arg->head = stream;\n    } else {\n      arg->head = stream;\n    }\n  }\n\n  return 0;\n}\n\n/* Closes non-idle and non-closed streams whose stream ID >\n   last_stream_id.  If incoming is nonzero, we are going to close\n   incoming streams.  Otherwise, close outgoing streams. */\nstatic int session_close_stream_on_goaway(nghttp2_session *session,\n                                          int32_t last_stream_id,\n                                          int incoming) {\n  int rv;\n  nghttp2_stream *stream, *next_stream;\n  nghttp2_close_stream_on_goaway_arg arg = {session, NULL, last_stream_id,\n                                            incoming};\n\n  rv = nghttp2_map_each(&session->streams, find_stream_on_goaway_func, &arg);\n  assert(rv == 0);\n\n  stream = arg.head;\n  while (stream) {\n    next_stream = stream->closed_next;\n    stream->closed_next = NULL;\n    rv = nghttp2_session_close_stream(session, stream->stream_id,\n                                      NGHTTP2_REFUSED_STREAM);\n\n    /* stream may be deleted here */\n\n    stream = next_stream;\n\n    if (nghttp2_is_fatal(rv)) {\n      /* Clean up closed_next member just in case */\n      while (stream) {\n        next_stream = stream->closed_next;\n        stream->closed_next = NULL;\n        stream = next_stream;\n      }\n      return rv;\n    }\n  }\n\n  return 0;\n}\n\nstatic void reschedule_stream(nghttp2_stream *stream) {\n  stream->last_writelen = stream->item->frame.hd.length;\n\n  nghttp2_stream_reschedule(stream);\n}\n\nstatic int session_update_stream_consumed_size(nghttp2_session *session,\n                                               nghttp2_stream *stream,\n                                               size_t delta_size);\n\nstatic int session_update_connection_consumed_size(nghttp2_session *session,\n                                                   size_t delta_size);\n\n/*\n * Called after a frame is sent.  This function runs\n * on_frame_send_callback and handles stream closure upon END_STREAM\n * or RST_STREAM.  This function does not reset session->aob.  It is a\n * responsibility of session_after_frame_sent2.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nstatic int session_after_frame_sent1(nghttp2_session *session) {\n  int rv;\n  nghttp2_active_outbound_item *aob = &session->aob;\n  nghttp2_outbound_item *item = aob->item;\n  nghttp2_bufs *framebufs = &aob->framebufs;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n\n  frame = &item->frame;\n\n  if (frame->hd.type == NGHTTP2_DATA) {\n    nghttp2_data_aux_data *aux_data;\n\n    aux_data = &item->aux_data.data;\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    /* We update flow control window after a frame was completely\n       sent. This is possible because we choose payload length not to\n       exceed the window */\n    session->remote_window_size -= (int32_t)frame->hd.length;\n    if (stream) {\n      stream->remote_window_size -= (int32_t)frame->hd.length;\n    }\n\n    if (stream && aux_data->eof) {\n      rv = nghttp2_stream_detach_item(stream);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      /* Call on_frame_send_callback after\n         nghttp2_stream_detach_item(), so that application can issue\n         nghttp2_submit_data() in the callback. */\n      if (session->callbacks.on_frame_send_callback) {\n        rv = session_call_on_frame_send(session, frame);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      }\n\n      if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n        int stream_closed;\n\n        stream_closed =\n            (stream->shut_flags & NGHTTP2_SHUT_RDWR) == NGHTTP2_SHUT_RDWR;\n\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n\n        rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        /* stream may be NULL if it was closed */\n        if (stream_closed) {\n          stream = NULL;\n        }\n      }\n      return 0;\n    }\n\n    if (session->callbacks.on_frame_send_callback) {\n      rv = session_call_on_frame_send(session, frame);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    return 0;\n  }\n\n  /* non-DATA frame */\n\n  if (frame->hd.type == NGHTTP2_HEADERS ||\n      frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n    if (nghttp2_bufs_next_present(framebufs)) {\n      DEBUGF(\"send: CONTINUATION exists, just return\\n\");\n      return 0;\n    }\n  }\n  rv = session_call_on_frame_send(session, frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  switch (frame->hd.type) {\n  case NGHTTP2_HEADERS: {\n    nghttp2_headers_aux_data *aux_data;\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n      return 0;\n    }\n\n    switch (frame->headers.cat) {\n    case NGHTTP2_HCAT_REQUEST: {\n      stream->state = NGHTTP2_STREAM_OPENING;\n      if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n      }\n      rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      /* We assume aux_data is a pointer to nghttp2_headers_aux_data */\n      aux_data = &item->aux_data.headers;\n      if (aux_data->data_prd.read_callback) {\n        /* nghttp2_submit_data() makes a copy of aux_data->data_prd */\n        rv = nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM,\n                                 frame->hd.stream_id, &aux_data->data_prd);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        /* TODO nghttp2_submit_data() may fail if stream has already\n           DATA frame item.  We might have to handle it here. */\n      }\n      return 0;\n    }\n    case NGHTTP2_HCAT_PUSH_RESPONSE:\n      stream->flags = (uint8_t)(stream->flags & ~NGHTTP2_STREAM_FLAG_PUSH);\n      ++session->num_outgoing_streams;\n    /* Fall through */\n    case NGHTTP2_HCAT_RESPONSE:\n      stream->state = NGHTTP2_STREAM_OPENED;\n    /* Fall through */\n    case NGHTTP2_HCAT_HEADERS:\n      if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n      }\n      rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      /* We assume aux_data is a pointer to nghttp2_headers_aux_data */\n      aux_data = &item->aux_data.headers;\n      if (aux_data->data_prd.read_callback) {\n        rv = nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM,\n                                 frame->hd.stream_id, &aux_data->data_prd);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        /* TODO nghttp2_submit_data() may fail if stream has already\n           DATA frame item.  We might have to handle it here. */\n      }\n      return 0;\n    default:\n      /* Unreachable */\n      assert(0);\n      return 0;\n    }\n  }\n  case NGHTTP2_PRIORITY:\n    if (session->server) {\n      return 0;\n      ;\n    }\n\n    stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n\n    if (!stream) {\n      if (!session_detect_idle_stream(session, frame->hd.stream_id)) {\n        return 0;\n      }\n\n      stream = nghttp2_session_open_stream(\n          session, frame->hd.stream_id, NGHTTP2_FLAG_NONE,\n          &frame->priority.pri_spec, NGHTTP2_STREAM_IDLE, NULL);\n      if (!stream) {\n        return NGHTTP2_ERR_NOMEM;\n      }\n    } else {\n      rv = nghttp2_session_reprioritize_stream(session, stream,\n                                               &frame->priority.pri_spec);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    rv = nghttp2_session_adjust_idle_stream(session);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n\n    return 0;\n  case NGHTTP2_RST_STREAM:\n    rv = nghttp2_session_close_stream(session, frame->hd.stream_id,\n                                      frame->rst_stream.error_code);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n    return 0;\n  case NGHTTP2_GOAWAY: {\n    nghttp2_goaway_aux_data *aux_data;\n\n    aux_data = &item->aux_data.goaway;\n\n    if ((aux_data->flags & NGHTTP2_GOAWAY_AUX_SHUTDOWN_NOTICE) == 0) {\n\n      if (aux_data->flags & NGHTTP2_GOAWAY_AUX_TERM_ON_SEND) {\n        session->goaway_flags |= NGHTTP2_GOAWAY_TERM_SENT;\n      }\n\n      session->goaway_flags |= NGHTTP2_GOAWAY_SENT;\n\n      rv = session_close_stream_on_goaway(session, frame->goaway.last_stream_id,\n                                          1);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    return 0;\n  }\n  case NGHTTP2_WINDOW_UPDATE:\n    if (frame->hd.stream_id == 0) {\n      session->window_update_queued = 0;\n      if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n        rv = session_update_connection_consumed_size(session, 0);\n      } else {\n        rv = nghttp2_session_update_recv_connection_window_size(session, 0);\n      }\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      return 0;\n    }\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n      return 0;\n    }\n\n    stream->window_update_queued = 0;\n\n    /* We don't have to send WINDOW_UPDATE if END_STREAM from peer\n       is seen. */\n    if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n      return 0;\n    }\n\n    if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n      rv = session_update_stream_consumed_size(session, stream, 0);\n    } else {\n      rv =\n          nghttp2_session_update_recv_stream_window_size(session, stream, 0, 1);\n    }\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n\n    return 0;\n  default:\n    return 0;\n  }\n}\n\n/*\n * Called after a frame is sent and session_after_frame_sent1.  This\n * function is responsible to reset session->aob.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nstatic int session_after_frame_sent2(nghttp2_session *session) {\n  int rv;\n  nghttp2_active_outbound_item *aob = &session->aob;\n  nghttp2_outbound_item *item = aob->item;\n  nghttp2_bufs *framebufs = &aob->framebufs;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n  nghttp2_stream *stream;\n  nghttp2_data_aux_data *aux_data;\n\n  mem = &session->mem;\n  frame = &item->frame;\n\n  if (frame->hd.type != NGHTTP2_DATA) {\n\n    if (frame->hd.type == NGHTTP2_HEADERS ||\n        frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n\n      if (nghttp2_bufs_next_present(framebufs)) {\n        framebufs->cur = framebufs->cur->next;\n\n        DEBUGF(\"send: next CONTINUATION frame, %zu bytes\\n\",\n               nghttp2_buf_len(&framebufs->cur->buf));\n\n        return 0;\n      }\n    }\n\n    active_outbound_item_reset(&session->aob, mem);\n\n    return 0;\n  }\n\n  /* DATA frame */\n\n  aux_data = &item->aux_data.data;\n\n  /* On EOF, we have already detached data.  Please note that\n     application may issue nghttp2_submit_data() in\n     on_frame_send_callback (call from session_after_frame_sent1),\n     which attach data to stream.  We don't want to detach it. */\n  if (aux_data->eof) {\n    active_outbound_item_reset(aob, mem);\n\n    return 0;\n  }\n\n  /* Reset no_copy here because next write may not use this. */\n  aux_data->no_copy = 0;\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n  /* If session is closed or RST_STREAM was queued, we won't send\n     further data. */\n  if (nghttp2_session_predicate_data_send(session, stream) != 0) {\n    if (stream) {\n      rv = nghttp2_stream_detach_item(stream);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n    }\n\n    active_outbound_item_reset(aob, mem);\n\n    return 0;\n  }\n\n  aob->item = NULL;\n  active_outbound_item_reset(&session->aob, mem);\n\n  return 0;\n}\n\nstatic int session_call_send_data(nghttp2_session *session,\n                                  nghttp2_outbound_item *item,\n                                  nghttp2_bufs *framebufs) {\n  int rv;\n  nghttp2_buf *buf;\n  size_t length;\n  nghttp2_frame *frame;\n  nghttp2_data_aux_data *aux_data;\n\n  buf = &framebufs->cur->buf;\n  frame = &item->frame;\n  length = frame->hd.length - frame->data.padlen;\n  aux_data = &item->aux_data.data;\n\n  rv = session->callbacks.send_data_callback(session, frame, buf->pos, length,\n                                             &aux_data->data_prd.source,\n                                             session->user_data);\n\n  switch (rv) {\n  case 0:\n  case NGHTTP2_ERR_WOULDBLOCK:\n  case NGHTTP2_ERR_PAUSE:\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return rv;\n  default:\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n}\n\nstatic ssize_t nghttp2_session_mem_send_internal(nghttp2_session *session,\n                                                 const uint8_t **data_ptr,\n                                                 int fast_cb) {\n  int rv;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  /* We may have idle streams more than we expect (e.g.,\n     nghttp2_session_change_stream_priority() or\n     nghttp2_session_create_idle_stream()).  Adjust them here. */\n  rv = nghttp2_session_adjust_idle_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  for (;;) {\n    switch (aob->state) {\n    case NGHTTP2_OB_POP_ITEM: {\n      nghttp2_outbound_item *item;\n\n      item = nghttp2_session_pop_next_ob_item(session);\n      if (item == NULL) {\n        return 0;\n      }\n\n      rv = session_prep_frame(session, item);\n      if (rv == NGHTTP2_ERR_PAUSE) {\n        return 0;\n      }\n      if (rv == NGHTTP2_ERR_DEFERRED) {\n        DEBUGF(\"send: frame transmission deferred\\n\");\n        break;\n      }\n      if (rv < 0) {\n        int32_t opened_stream_id = 0;\n        uint32_t error_code = NGHTTP2_INTERNAL_ERROR;\n\n        DEBUGF(\"send: frame preparation failed with %s\\n\",\n               nghttp2_strerror(rv));\n        /* TODO If the error comes from compressor, the connection\n           must be closed. */\n        if (item->frame.hd.type != NGHTTP2_DATA &&\n            session->callbacks.on_frame_not_send_callback && is_non_fatal(rv)) {\n          nghttp2_frame *frame = &item->frame;\n          /* The library is responsible for the transmission of\n             WINDOW_UPDATE frame, so we don't call error callback for\n             it. */\n          if (frame->hd.type != NGHTTP2_WINDOW_UPDATE &&\n              session->callbacks.on_frame_not_send_callback(\n                  session, frame, rv, session->user_data) != 0) {\n\n            nghttp2_outbound_item_free(item, mem);\n            nghttp2_mem_free(mem, item);\n\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n          }\n        }\n        /* We have to close stream opened by failed request HEADERS\n           or PUSH_PROMISE. */\n        switch (item->frame.hd.type) {\n        case NGHTTP2_HEADERS:\n          if (item->frame.headers.cat == NGHTTP2_HCAT_REQUEST) {\n            opened_stream_id = item->frame.hd.stream_id;\n            if (item->aux_data.headers.canceled) {\n              error_code = item->aux_data.headers.error_code;\n            } else {\n              /* Set error_code to REFUSED_STREAM so that application\n                 can send request again. */\n              error_code = NGHTTP2_REFUSED_STREAM;\n            }\n          }\n          break;\n        case NGHTTP2_PUSH_PROMISE:\n          opened_stream_id = item->frame.push_promise.promised_stream_id;\n          break;\n        }\n        if (opened_stream_id) {\n          /* careful not to override rv */\n          int rv2;\n          rv2 = nghttp2_session_close_stream(session, opened_stream_id,\n                                             error_code);\n\n          if (nghttp2_is_fatal(rv2)) {\n            return rv2;\n          }\n        }\n\n        nghttp2_outbound_item_free(item, mem);\n        nghttp2_mem_free(mem, item);\n        active_outbound_item_reset(aob, mem);\n\n        if (rv == NGHTTP2_ERR_HEADER_COMP) {\n          /* If header compression error occurred, should terminiate\n             connection. */\n          rv = nghttp2_session_terminate_session(session,\n                                                 NGHTTP2_INTERNAL_ERROR);\n        }\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        break;\n      }\n\n      aob->item = item;\n\n      nghttp2_bufs_rewind(framebufs);\n\n      if (item->frame.hd.type != NGHTTP2_DATA) {\n        nghttp2_frame *frame;\n\n        frame = &item->frame;\n\n        DEBUGF(\"send: next frame: payloadlen=%zu, type=%u, flags=0x%02x, \"\n               \"stream_id=%d\\n\",\n               frame->hd.length, frame->hd.type, frame->hd.flags,\n               frame->hd.stream_id);\n\n        rv = session_call_before_frame_send(session, frame);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (rv == NGHTTP2_ERR_CANCEL) {\n          int32_t opened_stream_id = 0;\n          uint32_t error_code = NGHTTP2_INTERNAL_ERROR;\n\n          if (session->callbacks.on_frame_not_send_callback) {\n            if (session->callbacks.on_frame_not_send_callback(\n                    session, frame, rv, session->user_data) != 0) {\n              return NGHTTP2_ERR_CALLBACK_FAILURE;\n            }\n          }\n\n          /* We have to close stream opened by canceled request\n             HEADERS or PUSH_PROMISE. */\n          switch (item->frame.hd.type) {\n          case NGHTTP2_HEADERS:\n            if (item->frame.headers.cat == NGHTTP2_HCAT_REQUEST) {\n              opened_stream_id = item->frame.hd.stream_id;\n              /* We don't have to check\n                 item->aux_data.headers.canceled since it has already\n                 been checked. */\n              /* Set error_code to REFUSED_STREAM so that application\n                 can send request again. */\n              error_code = NGHTTP2_REFUSED_STREAM;\n            }\n            break;\n          case NGHTTP2_PUSH_PROMISE:\n            opened_stream_id = item->frame.push_promise.promised_stream_id;\n            break;\n          }\n          if (opened_stream_id) {\n            /* careful not to override rv */\n            int rv2;\n            rv2 = nghttp2_session_close_stream(session, opened_stream_id,\n                                               error_code);\n\n            if (nghttp2_is_fatal(rv2)) {\n              return rv2;\n            }\n          }\n\n          active_outbound_item_reset(aob, mem);\n\n          break;\n        }\n      } else {\n        DEBUGF(\"send: next frame: DATA\\n\");\n\n        if (item->aux_data.data.no_copy) {\n          aob->state = NGHTTP2_OB_SEND_NO_COPY;\n          break;\n        }\n      }\n\n      DEBUGF(\"send: start transmitting frame type=%u, length=%zd\\n\",\n             framebufs->cur->buf.pos[3],\n             framebufs->cur->buf.last - framebufs->cur->buf.pos);\n\n      aob->state = NGHTTP2_OB_SEND_DATA;\n\n      break;\n    }\n    case NGHTTP2_OB_SEND_DATA: {\n      size_t datalen;\n      nghttp2_buf *buf;\n\n      buf = &framebufs->cur->buf;\n\n      if (buf->pos == buf->last) {\n        DEBUGF(\"send: end transmission of a frame\\n\");\n\n        /* Frame has completely sent */\n        if (fast_cb) {\n          rv = session_after_frame_sent2(session);\n        } else {\n          rv = session_after_frame_sent1(session);\n          if (rv < 0) {\n            /* FATAL */\n            assert(nghttp2_is_fatal(rv));\n            return rv;\n          }\n          rv = session_after_frame_sent2(session);\n        }\n        if (rv < 0) {\n          /* FATAL */\n          assert(nghttp2_is_fatal(rv));\n          return rv;\n        }\n        /* We have already adjusted the next state */\n        break;\n      }\n\n      *data_ptr = buf->pos;\n      datalen = nghttp2_buf_len(buf);\n\n      /* We increment the offset here. If send_callback does not send\n         everything, we will adjust it. */\n      buf->pos += datalen;\n\n      return (ssize_t)datalen;\n    }\n    case NGHTTP2_OB_SEND_NO_COPY: {\n      nghttp2_stream *stream;\n      nghttp2_frame *frame;\n      int pause;\n\n      DEBUGF(\"send: no copy DATA\\n\");\n\n      frame = &aob->item->frame;\n\n      stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n      if (stream == NULL) {\n        DEBUGF(\"send: no copy DATA cancelled because stream was closed\\n\");\n\n        active_outbound_item_reset(aob, mem);\n\n        break;\n      }\n\n      rv = session_call_send_data(session, aob->item, framebufs);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n        rv = nghttp2_stream_detach_item(stream);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = nghttp2_session_add_rst_stream(session, frame->hd.stream_id,\n                                            NGHTTP2_INTERNAL_ERROR);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        active_outbound_item_reset(aob, mem);\n\n        break;\n      }\n\n      if (rv == NGHTTP2_ERR_WOULDBLOCK) {\n        return 0;\n      }\n\n      pause = (rv == NGHTTP2_ERR_PAUSE);\n\n      rv = session_after_frame_sent1(session);\n      if (rv < 0) {\n        assert(nghttp2_is_fatal(rv));\n        return rv;\n      }\n      rv = session_after_frame_sent2(session);\n      if (rv < 0) {\n        assert(nghttp2_is_fatal(rv));\n        return rv;\n      }\n\n      /* We have already adjusted the next state */\n\n      if (pause) {\n        return 0;\n      }\n\n      break;\n    }\n    case NGHTTP2_OB_SEND_CLIENT_MAGIC: {\n      size_t datalen;\n      nghttp2_buf *buf;\n\n      buf = &framebufs->cur->buf;\n\n      if (buf->pos == buf->last) {\n        DEBUGF(\"send: end transmission of client magic\\n\");\n        active_outbound_item_reset(aob, mem);\n        break;\n      }\n\n      *data_ptr = buf->pos;\n      datalen = nghttp2_buf_len(buf);\n\n      buf->pos += datalen;\n\n      return (ssize_t)datalen;\n    }\n    }\n  }\n}\n\nssize_t nghttp2_session_mem_send(nghttp2_session *session,\n                                 const uint8_t **data_ptr) {\n  int rv;\n  ssize_t len;\n\n  *data_ptr = NULL;\n\n  len = nghttp2_session_mem_send_internal(session, data_ptr, 1);\n  if (len <= 0) {\n    return len;\n  }\n\n  if (session->aob.item) {\n    /* We have to call session_after_frame_sent1 here to handle stream\n       closure upon transmission of frames.  Otherwise, END_STREAM may\n       be reached to client before we call nghttp2_session_mem_send\n       again and we may get exceeding number of incoming streams. */\n    rv = session_after_frame_sent1(session);\n    if (rv < 0) {\n      assert(nghttp2_is_fatal(rv));\n      return (ssize_t)rv;\n    }\n  }\n\n  return len;\n}\n\nint nghttp2_session_send(nghttp2_session *session) {\n  const uint8_t *data = NULL;\n  ssize_t datalen;\n  ssize_t sentlen;\n  nghttp2_bufs *framebufs;\n\n  framebufs = &session->aob.framebufs;\n\n  for (;;) {\n    datalen = nghttp2_session_mem_send_internal(session, &data, 0);\n    if (datalen <= 0) {\n      return (int)datalen;\n    }\n    sentlen = session->callbacks.send_callback(session, data, (size_t)datalen,\n                                               0, session->user_data);\n    if (sentlen < 0) {\n      if (sentlen == NGHTTP2_ERR_WOULDBLOCK) {\n        /* Transmission canceled. Rewind the offset */\n        framebufs->cur->buf.pos -= datalen;\n\n        return 0;\n      }\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    /* Rewind the offset to the amount of unsent bytes */\n    framebufs->cur->buf.pos -= datalen - sentlen;\n  }\n}\n\nstatic ssize_t session_recv(nghttp2_session *session, uint8_t *buf,\n                            size_t len) {\n  ssize_t rv;\n  rv = session->callbacks.recv_callback(session, buf, len, 0,\n                                        session->user_data);\n  if (rv > 0) {\n    if ((size_t)rv > len) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  } else if (rv < 0 && rv != NGHTTP2_ERR_WOULDBLOCK && rv != NGHTTP2_ERR_EOF) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n  return rv;\n}\n\nstatic int session_call_on_begin_frame(nghttp2_session *session,\n                                       const nghttp2_frame_hd *hd) {\n  int rv;\n\n  if (session->callbacks.on_begin_frame_callback) {\n\n    rv = session->callbacks.on_begin_frame_callback(session, hd,\n                                                    session->user_data);\n\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n\n  return 0;\n}\n\nstatic int session_call_on_frame_received(nghttp2_session *session,\n                                          nghttp2_frame *frame) {\n  int rv;\n  if (session->callbacks.on_frame_recv_callback) {\n    rv = session->callbacks.on_frame_recv_callback(session, frame,\n                                                   session->user_data);\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_call_on_begin_headers(nghttp2_session *session,\n                                         nghttp2_frame *frame) {\n  int rv;\n  DEBUGF(\"recv: call on_begin_headers callback stream_id=%d\\n\",\n         frame->hd.stream_id);\n  if (session->callbacks.on_begin_headers_callback) {\n    rv = session->callbacks.on_begin_headers_callback(session, frame,\n                                                      session->user_data);\n    if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n      return rv;\n    }\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_call_on_header(nghttp2_session *session,\n                                  const nghttp2_frame *frame,\n                                  const nghttp2_hd_nv *nv) {\n  int rv = 0;\n  if (session->callbacks.on_header_callback2) {\n    rv = session->callbacks.on_header_callback2(\n        session, frame, nv->name, nv->value, nv->flags, session->user_data);\n  } else if (session->callbacks.on_header_callback) {\n    rv = session->callbacks.on_header_callback(\n        session, frame, nv->name->base, nv->name->len, nv->value->base,\n        nv->value->len, nv->flags, session->user_data);\n  }\n\n  if (rv == NGHTTP2_ERR_PAUSE || rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n    return rv;\n  }\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  return 0;\n}\n\nstatic int session_call_on_invalid_header(nghttp2_session *session,\n                                          const nghttp2_frame *frame,\n                                          const nghttp2_hd_nv *nv) {\n  int rv;\n  if (session->callbacks.on_invalid_header_callback2) {\n    rv = session->callbacks.on_invalid_header_callback2(\n        session, frame, nv->name, nv->value, nv->flags, session->user_data);\n  } else if (session->callbacks.on_invalid_header_callback) {\n    rv = session->callbacks.on_invalid_header_callback(\n        session, frame, nv->name->base, nv->name->len, nv->value->base,\n        nv->value->len, nv->flags, session->user_data);\n  } else {\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  }\n\n  if (rv == NGHTTP2_ERR_PAUSE || rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n    return rv;\n  }\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  return 0;\n}\n\nstatic int\nsession_call_on_extension_chunk_recv_callback(nghttp2_session *session,\n                                              const uint8_t *data, size_t len) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  if (session->callbacks.on_extension_chunk_recv_callback) {\n    rv = session->callbacks.on_extension_chunk_recv_callback(\n        session, &frame->hd, data, len, session->user_data);\n    if (rv == NGHTTP2_ERR_CANCEL) {\n      return rv;\n    }\n    if (rv != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n\n  return 0;\n}\n\nstatic int session_call_unpack_extension_callback(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  void *payload = NULL;\n\n  rv = session->callbacks.unpack_extension_callback(\n      session, &payload, &frame->hd, session->user_data);\n  if (rv == NGHTTP2_ERR_CANCEL) {\n    return rv;\n  }\n  if (rv != 0) {\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  frame->ext.payload = payload;\n\n  return 0;\n}\n\n/*\n * Handles frame size error.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *   Out of memory.\n */\nstatic int session_handle_frame_size_error(nghttp2_session *session) {\n  /* TODO Currently no callback is called for this error, because we\n     call this callback before reading any payload */\n  return nghttp2_session_terminate_session(session, NGHTTP2_FRAME_SIZE_ERROR);\n}\n\nstatic uint32_t get_error_code_from_lib_error_code(int lib_error_code) {\n  switch (lib_error_code) {\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return NGHTTP2_STREAM_CLOSED;\n  case NGHTTP2_ERR_HEADER_COMP:\n    return NGHTTP2_COMPRESSION_ERROR;\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return NGHTTP2_FRAME_SIZE_ERROR;\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return NGHTTP2_FLOW_CONTROL_ERROR;\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return NGHTTP2_REFUSED_STREAM;\n  case NGHTTP2_ERR_PROTO:\n  case NGHTTP2_ERR_HTTP_HEADER:\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return NGHTTP2_PROTOCOL_ERROR;\n  default:\n    return NGHTTP2_INTERNAL_ERROR;\n  }\n}\n\n/*\n * Calls on_invalid_frame_recv_callback if it is set to |session|.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *   User defined callback function fails.\n */\nstatic int session_call_on_invalid_frame_recv_callback(nghttp2_session *session,\n                                                       nghttp2_frame *frame,\n                                                       int lib_error_code) {\n  if (session->callbacks.on_invalid_frame_recv_callback) {\n    if (session->callbacks.on_invalid_frame_recv_callback(\n            session, frame, lib_error_code, session->user_data) != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_handle_invalid_stream2(nghttp2_session *session,\n                                          int32_t stream_id,\n                                          nghttp2_frame *frame,\n                                          int lib_error_code) {\n  int rv;\n  rv = nghttp2_session_add_rst_stream(\n      session, stream_id, get_error_code_from_lib_error_code(lib_error_code));\n  if (rv != 0) {\n    return rv;\n  }\n  if (session->callbacks.on_invalid_frame_recv_callback) {\n    if (session->callbacks.on_invalid_frame_recv_callback(\n            session, frame, lib_error_code, session->user_data) != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return 0;\n}\n\nstatic int session_handle_invalid_stream(nghttp2_session *session,\n                                         nghttp2_frame *frame,\n                                         int lib_error_code) {\n  return session_handle_invalid_stream2(session, frame->hd.stream_id, frame,\n                                        lib_error_code);\n}\n\nstatic int session_inflate_handle_invalid_stream(nghttp2_session *session,\n                                                 nghttp2_frame *frame,\n                                                 int lib_error_code) {\n  int rv;\n  rv = session_handle_invalid_stream(session, frame, lib_error_code);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n}\n\n/*\n * Handles invalid frame which causes connection error.\n */\nstatic int session_handle_invalid_connection(nghttp2_session *session,\n                                             nghttp2_frame *frame,\n                                             int lib_error_code,\n                                             const char *reason) {\n  if (session->callbacks.on_invalid_frame_recv_callback) {\n    if (session->callbacks.on_invalid_frame_recv_callback(\n            session, frame, lib_error_code, session->user_data) != 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n  return nghttp2_session_terminate_session_with_reason(\n      session, get_error_code_from_lib_error_code(lib_error_code), reason);\n}\n\nstatic int session_inflate_handle_invalid_connection(nghttp2_session *session,\n                                                     nghttp2_frame *frame,\n                                                     int lib_error_code,\n                                                     const char *reason) {\n  int rv;\n  rv =\n      session_handle_invalid_connection(session, frame, lib_error_code, reason);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n}\n\n/*\n * Inflates header block in the memory pointed by |in| with |inlen|\n * bytes. If this function returns NGHTTP2_ERR_PAUSE, the caller must\n * call this function again, until it returns 0 or one of negative\n * error code.  If |call_header_cb| is zero, the on_header_callback\n * are not invoked and the function never return NGHTTP2_ERR_PAUSE. If\n * the given |in| is the last chunk of header block, the |final| must\n * be nonzero. If header block is successfully processed (which is\n * indicated by the return value 0, NGHTTP2_ERR_PAUSE or\n * NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE), the number of processed\n * input bytes is assigned to the |*readlen_ptr|.\n *\n * This function return 0 if it succeeds, or one of the negative error\n * codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n * NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE\n *     The callback returns this error code, indicating that this\n *     stream should be RST_STREAMed.\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_PAUSE\n *     The callback function returned NGHTTP2_ERR_PAUSE\n * NGHTTP2_ERR_HEADER_COMP\n *     Header decompression failed\n */\nstatic int inflate_header_block(nghttp2_session *session, nghttp2_frame *frame,\n                                size_t *readlen_ptr, uint8_t *in, size_t inlen,\n                                int final, int call_header_cb) {\n  ssize_t proclen;\n  int rv;\n  int inflate_flags;\n  nghttp2_hd_nv nv;\n  nghttp2_stream *stream;\n  nghttp2_stream *subject_stream;\n  int trailer = 0;\n\n  *readlen_ptr = 0;\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n\n  if (frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n    subject_stream = nghttp2_session_get_stream(\n        session, frame->push_promise.promised_stream_id);\n  } else {\n    subject_stream = stream;\n    trailer = session_trailer_headers(session, stream, frame);\n  }\n\n  DEBUGF(\"recv: decoding header block %zu bytes\\n\", inlen);\n  for (;;) {\n    inflate_flags = 0;\n    proclen = nghttp2_hd_inflate_hd_nv(&session->hd_inflater, &nv,\n                                       &inflate_flags, in, inlen, final);\n    if (nghttp2_is_fatal((int)proclen)) {\n      return (int)proclen;\n    }\n    if (proclen < 0) {\n      if (session->iframe.state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n        if (subject_stream && subject_stream->state != NGHTTP2_STREAM_CLOSING) {\n          /* Adding RST_STREAM here is very important. It prevents\n             from invoking subsequent callbacks for the same stream\n             ID. */\n          rv = nghttp2_session_add_rst_stream(\n              session, subject_stream->stream_id, NGHTTP2_COMPRESSION_ERROR);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n      }\n      rv =\n          nghttp2_session_terminate_session(session, NGHTTP2_COMPRESSION_ERROR);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      return NGHTTP2_ERR_HEADER_COMP;\n    }\n    in += proclen;\n    inlen -= (size_t)proclen;\n    *readlen_ptr += (size_t)proclen;\n\n    DEBUGF(\"recv: proclen=%zd\\n\", proclen);\n\n    if (call_header_cb && (inflate_flags & NGHTTP2_HD_INFLATE_EMIT)) {\n      rv = 0;\n      if (subject_stream) {\n        if (session_enforce_http_messaging(session)) {\n          rv = nghttp2_http_on_header(session, subject_stream, frame, &nv,\n                                      trailer);\n\n          if (rv == NGHTTP2_ERR_IGN_HTTP_HEADER) {\n            /* Don't overwrite rv here */\n            int rv2;\n\n            rv2 = session_call_on_invalid_header(session, frame, &nv);\n            if (rv2 == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n              rv = NGHTTP2_ERR_HTTP_HEADER;\n            } else {\n              if (rv2 != 0) {\n                return rv2;\n              }\n\n              /* header is ignored */\n              DEBUGF(\"recv: HTTP ignored: type=%u, id=%d, header %.*s: %.*s\\n\",\n                     frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                     nv.name->base, (int)nv.value->len, nv.value->base);\n\n              rv2 = session_call_error_callback(\n                  session, NGHTTP2_ERR_HTTP_HEADER,\n                  \"Ignoring received invalid HTTP header field: frame type: \"\n                  \"%u, stream: %d, name: [%.*s], value: [%.*s]\",\n                  frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                  nv.name->base, (int)nv.value->len, nv.value->base);\n\n              if (nghttp2_is_fatal(rv2)) {\n                return rv2;\n              }\n            }\n          }\n\n          if (rv == NGHTTP2_ERR_HTTP_HEADER) {\n            DEBUGF(\"recv: HTTP error: type=%u, id=%d, header %.*s: %.*s\\n\",\n                   frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                   nv.name->base, (int)nv.value->len, nv.value->base);\n\n            rv = session_call_error_callback(\n                session, NGHTTP2_ERR_HTTP_HEADER,\n                \"Invalid HTTP header field was received: frame type: \"\n                \"%u, stream: %d, name: [%.*s], value: [%.*s]\",\n                frame->hd.type, frame->hd.stream_id, (int)nv.name->len,\n                nv.name->base, (int)nv.value->len, nv.value->base);\n\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n\n            rv = session_handle_invalid_stream2(session,\n                                                subject_stream->stream_id,\n                                                frame, NGHTTP2_ERR_HTTP_HEADER);\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n          }\n        }\n        if (rv == 0) {\n          rv = session_call_on_header(session, frame, &nv);\n          /* This handles NGHTTP2_ERR_PAUSE and\n             NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE as well */\n          if (rv != 0) {\n            return rv;\n          }\n        }\n      }\n    }\n    if (inflate_flags & NGHTTP2_HD_INFLATE_FINAL) {\n      nghttp2_hd_inflate_end_headers(&session->hd_inflater);\n      break;\n    }\n    if ((inflate_flags & NGHTTP2_HD_INFLATE_EMIT) == 0 && inlen == 0) {\n      break;\n    }\n  }\n  return 0;\n}\n\n/*\n * Call this function when HEADERS frame was completely received.\n *\n * This function returns 0 if it succeeds, or one of negative error\n * codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nstatic int session_end_stream_headers_received(nghttp2_session *session,\n                                               nghttp2_frame *frame,\n                                               nghttp2_stream *stream) {\n  int rv;\n  if ((frame->hd.flags & NGHTTP2_FLAG_END_STREAM) == 0) {\n    return 0;\n  }\n\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nstatic int session_after_header_block_received(nghttp2_session *session) {\n  int rv = 0;\n  nghttp2_frame *frame = &session->iframe.frame;\n  nghttp2_stream *stream;\n\n  /* We don't call on_frame_recv_callback if stream has been closed\n     already or being closed. */\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream || stream->state == NGHTTP2_STREAM_CLOSING) {\n    return 0;\n  }\n\n  if (session_enforce_http_messaging(session)) {\n    if (frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n      nghttp2_stream *subject_stream;\n\n      subject_stream = nghttp2_session_get_stream(\n          session, frame->push_promise.promised_stream_id);\n      if (subject_stream) {\n        rv = nghttp2_http_on_request_headers(subject_stream, frame);\n      }\n    } else {\n      assert(frame->hd.type == NGHTTP2_HEADERS);\n      switch (frame->headers.cat) {\n      case NGHTTP2_HCAT_REQUEST:\n        rv = nghttp2_http_on_request_headers(stream, frame);\n        break;\n      case NGHTTP2_HCAT_RESPONSE:\n      case NGHTTP2_HCAT_PUSH_RESPONSE:\n        rv = nghttp2_http_on_response_headers(stream);\n        break;\n      case NGHTTP2_HCAT_HEADERS:\n        if (stream->http_flags & NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE) {\n          assert(!session->server);\n          rv = nghttp2_http_on_response_headers(stream);\n        } else {\n          rv = nghttp2_http_on_trailer_headers(stream, frame);\n        }\n        break;\n      default:\n        assert(0);\n      }\n      if (rv == 0 && (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)) {\n        rv = nghttp2_http_on_remote_end_stream(stream);\n      }\n    }\n    if (rv != 0) {\n      int32_t stream_id;\n\n      if (frame->hd.type == NGHTTP2_PUSH_PROMISE) {\n        stream_id = frame->push_promise.promised_stream_id;\n      } else {\n        stream_id = frame->hd.stream_id;\n      }\n\n      rv = session_handle_invalid_stream2(session, stream_id, frame,\n                                          NGHTTP2_ERR_HTTP_MESSAGING);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (frame->hd.type == NGHTTP2_HEADERS &&\n          (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)) {\n        nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n        /* Don't call nghttp2_session_close_stream_if_shut_rdwr\n           because RST_STREAM has been submitted. */\n      }\n      return 0;\n    }\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (frame->hd.type != NGHTTP2_HEADERS) {\n    return 0;\n  }\n\n  return session_end_stream_headers_received(session, frame, stream);\n}\n\nint nghttp2_session_on_request_headers_received(nghttp2_session *session,\n                                                nghttp2_frame *frame) {\n  int rv = 0;\n  nghttp2_stream *stream;\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"request HEADERS: stream_id == 0\");\n  }\n\n  /* If client receives idle stream from server, it is invalid\n     regardless stream ID is even or odd.  This is because client is\n     not expected to receive request from server. */\n  if (!session->server) {\n    if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n      return session_inflate_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_PROTO,\n          \"request HEADERS: client received request\");\n    }\n\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  assert(session->server);\n\n  if (!session_is_new_peer_stream_id(session, frame->hd.stream_id)) {\n    if (frame->hd.stream_id == 0 ||\n        nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n      return session_inflate_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_PROTO,\n          \"request HEADERS: invalid stream_id\");\n    }\n\n    /* RFC 7540 says if an endpoint receives a HEADERS with invalid\n     * stream ID (e.g, numerically smaller than previous), it MUST\n     * issue connection error with error code PROTOCOL_ERROR.  It is a\n     * bit hard to detect this, since we cannot remember all streams\n     * we observed so far.\n     *\n     * You might imagine this is really easy.  But no.  HTTP/2 is\n     * asynchronous protocol, and usually client and server do not\n     * share the complete picture of open/closed stream status.  For\n     * example, after server sends RST_STREAM for a stream, client may\n     * send trailer HEADERS for that stream.  If naive server detects\n     * that, and issued connection error, then it is a bug of server\n     * implementation since client is not wrong if it did not get\n     * RST_STREAM when it issued trailer HEADERS.\n     *\n     * At the moment, we are very conservative here.  We only use\n     * connection error if stream ID refers idle stream, or we are\n     * sure that stream is half-closed(remote) or closed.  Otherwise\n     * we just ignore HEADERS for now.\n     */\n    stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n    if (stream && (stream->shut_flags & NGHTTP2_SHUT_RD)) {\n      return session_inflate_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_STREAM_CLOSED, \"HEADERS: stream closed\");\n    }\n\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n  session->last_recv_stream_id = frame->hd.stream_id;\n\n  if (session_is_incoming_concurrent_streams_max(session)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"request HEADERS: max concurrent streams exceeded\");\n  }\n\n  if (!session_allow_incoming_new_stream(session)) {\n    /* We just ignore stream after GOAWAY was sent */\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (frame->headers.pri_spec.stream_id == frame->hd.stream_id) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"request HEADERS: depend on itself\");\n  }\n\n  if (session_is_incoming_concurrent_streams_pending_max(session)) {\n    return session_inflate_handle_invalid_stream(session, frame,\n                                                 NGHTTP2_ERR_REFUSED_STREAM);\n  }\n\n  stream = nghttp2_session_open_stream(\n      session, frame->hd.stream_id, NGHTTP2_STREAM_FLAG_NONE,\n      &frame->headers.pri_spec, NGHTTP2_STREAM_OPENING, NULL);\n  if (!stream) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  rv = nghttp2_session_adjust_closed_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  session->last_proc_stream_id = session->last_recv_stream_id;\n\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_on_response_headers_received(nghttp2_session *session,\n                                                 nghttp2_frame *frame,\n                                                 nghttp2_stream *stream) {\n  int rv;\n  /* This function is only called if stream->state ==\n     NGHTTP2_STREAM_OPENING and stream_id is local side initiated. */\n  assert(stream->state == NGHTTP2_STREAM_OPENING &&\n         nghttp2_session_is_my_stream_id(session, frame->hd.stream_id));\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"response HEADERS: stream_id == 0\");\n  }\n  if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n    /* half closed (remote): from the spec:\n\n       If an endpoint receives additional frames for a stream that is\n       in this state it MUST respond with a stream error (Section\n       5.4.2) of type STREAM_CLOSED.\n\n       We go further, and make it connection error.\n    */\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_STREAM_CLOSED, \"HEADERS: stream closed\");\n  }\n  stream->state = NGHTTP2_STREAM_OPENED;\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_on_push_response_headers_received(nghttp2_session *session,\n                                                      nghttp2_frame *frame,\n                                                      nghttp2_stream *stream) {\n  int rv = 0;\n  assert(stream->state == NGHTTP2_STREAM_RESERVED);\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"push response HEADERS: stream_id == 0\");\n  }\n\n  if (session->server) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"HEADERS: no HEADERS allowed from client in reserved state\");\n  }\n\n  if (session_is_incoming_concurrent_streams_max(session)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"push response HEADERS: max concurrent streams exceeded\");\n  }\n\n  if (!session_allow_incoming_new_stream(session)) {\n    /* We don't accept new stream after GOAWAY was sent. */\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (session_is_incoming_concurrent_streams_pending_max(session)) {\n    return session_inflate_handle_invalid_stream(session, frame,\n                                                 NGHTTP2_ERR_REFUSED_STREAM);\n  }\n\n  nghttp2_stream_promise_fulfilled(stream);\n  if (!nghttp2_session_is_my_stream_id(session, stream->stream_id)) {\n    --session->num_incoming_reserved_streams;\n  }\n  ++session->num_incoming_streams;\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_on_headers_received(nghttp2_session *session,\n                                        nghttp2_frame *frame,\n                                        nghttp2_stream *stream) {\n  int rv = 0;\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"HEADERS: stream_id == 0\");\n  }\n  if ((stream->shut_flags & NGHTTP2_SHUT_RD)) {\n    /* half closed (remote): from the spec:\n\n       If an endpoint receives additional frames for a stream that is\n       in this state it MUST respond with a stream error (Section\n       5.4.2) of type STREAM_CLOSED.\n\n       we go further, and make it connection error.\n    */\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_STREAM_CLOSED, \"HEADERS: stream closed\");\n  }\n  if (nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n    if (stream->state == NGHTTP2_STREAM_OPENED) {\n      rv = session_call_on_begin_headers(session, frame);\n      if (rv != 0) {\n        return rv;\n      }\n      return 0;\n    }\n\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n  /* If this is remote peer initiated stream, it is OK unless it\n     has sent END_STREAM frame already. But if stream is in\n     NGHTTP2_STREAM_CLOSING, we discard the frame. This is a race\n     condition. */\n  if (stream->state != NGHTTP2_STREAM_CLOSING) {\n    rv = session_call_on_begin_headers(session, frame);\n    if (rv != 0) {\n      return rv;\n    }\n    return 0;\n  }\n  return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n}\n\nstatic int session_process_headers_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  nghttp2_stream *stream;\n\n  rv = nghttp2_frame_unpack_headers_payload(&frame->headers, iframe->sbuf.pos);\n\n  if (rv != 0) {\n    return nghttp2_session_terminate_session_with_reason(\n        session, NGHTTP2_PROTOCOL_ERROR, \"HEADERS: could not unpack\");\n  }\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream) {\n    frame->headers.cat = NGHTTP2_HCAT_REQUEST;\n    return nghttp2_session_on_request_headers_received(session, frame);\n  }\n\n  if (stream->state == NGHTTP2_STREAM_RESERVED) {\n    frame->headers.cat = NGHTTP2_HCAT_PUSH_RESPONSE;\n    return nghttp2_session_on_push_response_headers_received(session, frame,\n                                                             stream);\n  }\n\n  if (stream->state == NGHTTP2_STREAM_OPENING &&\n      nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n    frame->headers.cat = NGHTTP2_HCAT_RESPONSE;\n    return nghttp2_session_on_response_headers_received(session, frame, stream);\n  }\n\n  frame->headers.cat = NGHTTP2_HCAT_HEADERS;\n  return nghttp2_session_on_headers_received(session, frame, stream);\n}\n\nint nghttp2_session_on_priority_received(nghttp2_session *session,\n                                         nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (frame->hd.stream_id == 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"PRIORITY: stream_id == 0\");\n  }\n\n  if (frame->priority.pri_spec.stream_id == frame->hd.stream_id) {\n    return nghttp2_session_terminate_session_with_reason(\n        session, NGHTTP2_PROTOCOL_ERROR, \"depend on itself\");\n  }\n\n  if (!session->server) {\n    /* Re-prioritization works only in server */\n    return session_call_on_frame_received(session, frame);\n  }\n\n  stream = nghttp2_session_get_stream_raw(session, frame->hd.stream_id);\n\n  if (!stream) {\n    /* PRIORITY against idle stream can create anchor node in\n       dependency tree. */\n    if (!session_detect_idle_stream(session, frame->hd.stream_id)) {\n      return 0;\n    }\n\n    stream = nghttp2_session_open_stream(\n        session, frame->hd.stream_id, NGHTTP2_STREAM_FLAG_NONE,\n        &frame->priority.pri_spec, NGHTTP2_STREAM_IDLE, NULL);\n\n    if (stream == NULL) {\n      return NGHTTP2_ERR_NOMEM;\n    }\n\n    rv = nghttp2_session_adjust_idle_stream(session);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  } else {\n    rv = nghttp2_session_reprioritize_stream(session, stream,\n                                             &frame->priority.pri_spec);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n\n    rv = nghttp2_session_adjust_idle_stream(session);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_priority_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_priority_payload(&frame->priority, iframe->sbuf.pos);\n\n  return nghttp2_session_on_priority_received(session, frame);\n}\n\nint nghttp2_session_on_rst_stream_received(nghttp2_session *session,\n                                           nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n  if (frame->hd.stream_id == 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"RST_STREAM: stream_id == 0\");\n  }\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"RST_STREAM: stream in idle\");\n  }\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (stream) {\n    /* We may use stream->shut_flags for strict error checking. */\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  rv = nghttp2_session_close_stream(session, frame->hd.stream_id,\n                                    frame->rst_stream.error_code);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return 0;\n}\n\nstatic int session_process_rst_stream_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_rst_stream_payload(&frame->rst_stream, iframe->sbuf.pos);\n\n  return nghttp2_session_on_rst_stream_received(session, frame);\n}\n\nstatic int update_remote_initial_window_size_func(nghttp2_map_entry *entry,\n                                                  void *ptr) {\n  int rv;\n  nghttp2_update_window_size_arg *arg;\n  nghttp2_stream *stream;\n\n  arg = (nghttp2_update_window_size_arg *)ptr;\n  stream = (nghttp2_stream *)entry;\n\n  rv = nghttp2_stream_update_remote_initial_window_size(\n      stream, arg->new_window_size, arg->old_window_size);\n  if (rv != 0) {\n    return nghttp2_session_add_rst_stream(arg->session, stream->stream_id,\n                                          NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n\n  /* If window size gets positive, push deferred DATA frame to\n     outbound queue. */\n  if (stream->remote_window_size > 0 &&\n      nghttp2_stream_check_deferred_by_flow_control(stream)) {\n\n    rv = nghttp2_stream_resume_deferred_item(\n        stream, NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n  return 0;\n}\n\n/*\n * Updates the remote initial window size of all active streams.  If\n * error occurs, all streams may not be updated.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nstatic int\nsession_update_remote_initial_window_size(nghttp2_session *session,\n                                          int32_t new_initial_window_size) {\n  nghttp2_update_window_size_arg arg;\n\n  arg.session = session;\n  arg.new_window_size = new_initial_window_size;\n  arg.old_window_size = (int32_t)session->remote_settings.initial_window_size;\n\n  return nghttp2_map_each(&session->streams,\n                          update_remote_initial_window_size_func, &arg);\n}\n\nstatic int update_local_initial_window_size_func(nghttp2_map_entry *entry,\n                                                 void *ptr) {\n  int rv;\n  nghttp2_update_window_size_arg *arg;\n  nghttp2_stream *stream;\n  arg = (nghttp2_update_window_size_arg *)ptr;\n  stream = (nghttp2_stream *)entry;\n  rv = nghttp2_stream_update_local_initial_window_size(\n      stream, arg->new_window_size, arg->old_window_size);\n  if (rv != 0) {\n    return nghttp2_session_add_rst_stream(arg->session, stream->stream_id,\n                                          NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n  if (!(arg->session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) &&\n      stream->window_update_queued == 0 &&\n      nghttp2_should_send_window_update(stream->local_window_size,\n                                        stream->recv_window_size)) {\n\n    rv = nghttp2_session_add_window_update(arg->session, NGHTTP2_FLAG_NONE,\n                                           stream->stream_id,\n                                           stream->recv_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n\n    stream->recv_window_size = 0;\n  }\n  return 0;\n}\n\n/*\n * Updates the local initial window size of all active streams.  If\n * error occurs, all streams may not be updated.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nstatic int\nsession_update_local_initial_window_size(nghttp2_session *session,\n                                         int32_t new_initial_window_size,\n                                         int32_t old_initial_window_size) {\n  nghttp2_update_window_size_arg arg;\n  arg.session = session;\n  arg.new_window_size = new_initial_window_size;\n  arg.old_window_size = old_initial_window_size;\n  return nghttp2_map_each(&session->streams,\n                          update_local_initial_window_size_func, &arg);\n}\n\n/*\n * Apply SETTINGS values |iv| having |niv| elements to the local\n * settings.  We assumes that all values in |iv| is correct, since we\n * validated them in nghttp2_session_add_settings() already.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_HEADER_COMP\n *     The header table size is out of range\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_update_local_settings(nghttp2_session *session,\n                                          nghttp2_settings_entry *iv,\n                                          size_t niv) {\n  int rv;\n  size_t i;\n  int32_t new_initial_window_size = -1;\n  uint32_t header_table_size = 0;\n  uint32_t min_header_table_size = UINT32_MAX;\n  uint8_t header_table_size_seen = 0;\n  /* For NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE, use the value last\n     seen.  For NGHTTP2_SETTINGS_HEADER_TABLE_SIZE, use both minimum\n     value and last seen value. */\n  for (i = 0; i < niv; ++i) {\n    switch (iv[i].settings_id) {\n    case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n      header_table_size_seen = 1;\n      header_table_size = iv[i].value;\n      min_header_table_size = nghttp2_min(min_header_table_size, iv[i].value);\n      break;\n    case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n      new_initial_window_size = (int32_t)iv[i].value;\n      break;\n    }\n  }\n  if (header_table_size_seen) {\n    if (min_header_table_size < header_table_size) {\n      rv = nghttp2_hd_inflate_change_table_size(&session->hd_inflater,\n                                                min_header_table_size);\n      if (rv != 0) {\n        return rv;\n      }\n    }\n\n    rv = nghttp2_hd_inflate_change_table_size(&session->hd_inflater,\n                                              header_table_size);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n  if (new_initial_window_size != -1) {\n    rv = session_update_local_initial_window_size(\n        session, new_initial_window_size,\n        (int32_t)session->local_settings.initial_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n\n  for (i = 0; i < niv; ++i) {\n    switch (iv[i].settings_id) {\n    case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n      session->local_settings.header_table_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_PUSH:\n      session->local_settings.enable_push = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n      session->local_settings.max_concurrent_streams = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n      session->local_settings.initial_window_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n      session->local_settings.max_frame_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n      session->local_settings.max_header_list_size = iv[i].value;\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n      session->local_settings.enable_connect_protocol = iv[i].value;\n      break;\n    }\n  }\n\n  return 0;\n}\n\nint nghttp2_session_on_settings_received(nghttp2_session *session,\n                                         nghttp2_frame *frame, int noack) {\n  int rv;\n  size_t i;\n  nghttp2_mem *mem;\n  nghttp2_inflight_settings *settings;\n\n  mem = &session->mem;\n\n  if (frame->hd.stream_id != 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"SETTINGS: stream_id != 0\");\n  }\n  if (frame->hd.flags & NGHTTP2_FLAG_ACK) {\n    if (frame->settings.niv != 0) {\n      return session_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_FRAME_SIZE_ERROR,\n          \"SETTINGS: ACK and payload != 0\");\n    }\n\n    settings = session->inflight_settings_head;\n\n    if (!settings) {\n      return session_handle_invalid_connection(\n          session, frame, NGHTTP2_ERR_PROTO, \"SETTINGS: unexpected ACK\");\n    }\n\n    rv = nghttp2_session_update_local_settings(session, settings->iv,\n                                               settings->niv);\n\n    session->inflight_settings_head = settings->next;\n\n    inflight_settings_del(settings, mem);\n\n    if (rv != 0) {\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n      return session_handle_invalid_connection(session, frame, rv, NULL);\n    }\n    return session_call_on_frame_received(session, frame);\n  }\n\n  if (!session->remote_settings_received) {\n    session->remote_settings.max_concurrent_streams =\n        NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n    session->remote_settings_received = 1;\n  }\n\n  for (i = 0; i < frame->settings.niv; ++i) {\n    nghttp2_settings_entry *entry = &frame->settings.iv[i];\n\n    switch (entry->settings_id) {\n    case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n\n      rv = nghttp2_hd_deflate_change_table_size(&session->hd_deflater,\n                                                entry->value);\n      if (rv != 0) {\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        } else {\n          return session_handle_invalid_connection(\n              session, frame, NGHTTP2_ERR_HEADER_COMP, NULL);\n        }\n      }\n\n      session->remote_settings.header_table_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_PUSH:\n\n      if (entry->value != 0 && entry->value != 1) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: invalid SETTINGS_ENBLE_PUSH\");\n      }\n\n      if (!session->server && entry->value != 0) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: server attempted to enable push\");\n      }\n\n      session->remote_settings.enable_push = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n\n      session->remote_settings.max_concurrent_streams = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n\n      /* Update the initial window size of the all active streams */\n      /* Check that initial_window_size < (1u << 31) */\n      if (entry->value > NGHTTP2_MAX_WINDOW_SIZE) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_FLOW_CONTROL,\n            \"SETTINGS: too large SETTINGS_INITIAL_WINDOW_SIZE\");\n      }\n\n      rv = session_update_remote_initial_window_size(session,\n                                                     (int32_t)entry->value);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (rv != 0) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_FLOW_CONTROL, NULL);\n      }\n\n      session->remote_settings.initial_window_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n\n      if (entry->value < NGHTTP2_MAX_FRAME_SIZE_MIN ||\n          entry->value > NGHTTP2_MAX_FRAME_SIZE_MAX) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: invalid SETTINGS_MAX_FRAME_SIZE\");\n      }\n\n      session->remote_settings.max_frame_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n\n      session->remote_settings.max_header_list_size = entry->value;\n\n      break;\n    case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n\n      if (entry->value != 0 && entry->value != 1) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: invalid SETTINGS_ENABLE_CONNECT_PROTOCOL\");\n      }\n\n      if (!session->server &&\n          session->remote_settings.enable_connect_protocol &&\n          entry->value == 0) {\n        return session_handle_invalid_connection(\n            session, frame, NGHTTP2_ERR_PROTO,\n            \"SETTINGS: server attempted to disable \"\n            \"SETTINGS_ENABLE_CONNECT_PROTOCOL\");\n      }\n\n      session->remote_settings.enable_connect_protocol = entry->value;\n\n      break;\n    }\n  }\n\n  if (!noack && !session_is_closing(session)) {\n    rv = nghttp2_session_add_settings(session, NGHTTP2_FLAG_ACK, NULL, 0);\n\n    if (rv != 0) {\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      return session_handle_invalid_connection(session, frame,\n                                               NGHTTP2_ERR_INTERNAL, NULL);\n    }\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_settings_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  size_t i;\n  nghttp2_settings_entry min_header_size_entry;\n\n  if (iframe->max_niv) {\n    min_header_size_entry = iframe->iv[iframe->max_niv - 1];\n\n    if (min_header_size_entry.value < UINT32_MAX) {\n      /* If we have less value, then we must have\n         SETTINGS_HEADER_TABLE_SIZE in i < iframe->niv */\n      for (i = 0; i < iframe->niv; ++i) {\n        if (iframe->iv[i].settings_id == NGHTTP2_SETTINGS_HEADER_TABLE_SIZE) {\n          break;\n        }\n      }\n\n      assert(i < iframe->niv);\n\n      if (min_header_size_entry.value != iframe->iv[i].value) {\n        iframe->iv[iframe->niv++] = iframe->iv[i];\n        iframe->iv[i] = min_header_size_entry;\n      }\n    }\n  }\n\n  nghttp2_frame_unpack_settings_payload(&frame->settings, iframe->iv,\n                                        iframe->niv);\n\n  iframe->iv = NULL;\n  iframe->niv = 0;\n  iframe->max_niv = 0;\n\n  return nghttp2_session_on_settings_received(session, frame, 0 /* ACK */);\n}\n\nint nghttp2_session_on_push_promise_received(nghttp2_session *session,\n                                             nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_stream *promised_stream;\n  nghttp2_priority_spec pri_spec;\n\n  if (frame->hd.stream_id == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: stream_id == 0\");\n  }\n  if (session->server || session->local_settings.enable_push == 0) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: push disabled\");\n  }\n\n  if (!nghttp2_session_is_my_stream_id(session, frame->hd.stream_id)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: invalid stream_id\");\n  }\n\n  if (!session_allow_incoming_new_stream(session)) {\n    /* We just discard PUSH_PROMISE after GOAWAY was sent */\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (!session_is_new_peer_stream_id(session,\n                                     frame->push_promise.promised_stream_id)) {\n    /* The spec says if an endpoint receives a PUSH_PROMISE with\n       illegal stream ID is subject to a connection error of type\n       PROTOCOL_ERROR. */\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"PUSH_PROMISE: invalid promised_stream_id\");\n  }\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"PUSH_PROMISE: stream in idle\");\n  }\n\n  session->last_recv_stream_id = frame->push_promise.promised_stream_id;\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream || stream->state == NGHTTP2_STREAM_CLOSING ||\n      !session->pending_enable_push ||\n      session->num_incoming_reserved_streams >=\n          session->max_incoming_reserved_streams) {\n    /* Currently, client does not retain closed stream, so we don't\n       check NGHTTP2_SHUT_RD condition here. */\n\n    rv = nghttp2_session_add_rst_stream(\n        session, frame->push_promise.promised_stream_id, NGHTTP2_CANCEL);\n    if (rv != 0) {\n      return rv;\n    }\n    return NGHTTP2_ERR_IGN_HEADER_BLOCK;\n  }\n\n  if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n    return session_inflate_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_STREAM_CLOSED,\n        \"PUSH_PROMISE: stream closed\");\n  }\n\n  nghttp2_priority_spec_init(&pri_spec, stream->stream_id,\n                             NGHTTP2_DEFAULT_WEIGHT, 0);\n\n  promised_stream = nghttp2_session_open_stream(\n      session, frame->push_promise.promised_stream_id, NGHTTP2_STREAM_FLAG_NONE,\n      &pri_spec, NGHTTP2_STREAM_RESERVED, NULL);\n\n  if (!promised_stream) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't call nghttp2_session_adjust_closed_stream(), since we\n     don't keep closed stream in client side */\n\n  session->last_proc_stream_id = session->last_recv_stream_id;\n  rv = session_call_on_begin_headers(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  return 0;\n}\n\nstatic int session_process_push_promise_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  rv = nghttp2_frame_unpack_push_promise_payload(&frame->push_promise,\n                                                 iframe->sbuf.pos);\n\n  if (rv != 0) {\n    return nghttp2_session_terminate_session_with_reason(\n        session, NGHTTP2_PROTOCOL_ERROR, \"PUSH_PROMISE: could not unpack\");\n  }\n\n  return nghttp2_session_on_push_promise_received(session, frame);\n}\n\nint nghttp2_session_on_ping_received(nghttp2_session *session,\n                                     nghttp2_frame *frame) {\n  int rv = 0;\n  if (frame->hd.stream_id != 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"PING: stream_id != 0\");\n  }\n  if ((session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_PING_ACK) == 0 &&\n      (frame->hd.flags & NGHTTP2_FLAG_ACK) == 0 &&\n      !session_is_closing(session)) {\n    /* Peer sent ping, so ping it back */\n    rv = nghttp2_session_add_ping(session, NGHTTP2_FLAG_ACK,\n                                  frame->ping.opaque_data);\n    if (rv != 0) {\n      return rv;\n    }\n  }\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_ping_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_ping_payload(&frame->ping, iframe->sbuf.pos);\n\n  return nghttp2_session_on_ping_received(session, frame);\n}\n\nint nghttp2_session_on_goaway_received(nghttp2_session *session,\n                                       nghttp2_frame *frame) {\n  int rv;\n\n  if (frame->hd.stream_id != 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"GOAWAY: stream_id != 0\");\n  }\n  /* Spec says Endpoints MUST NOT increase the value they send in the\n     last stream identifier. */\n  if ((frame->goaway.last_stream_id > 0 &&\n       !nghttp2_session_is_my_stream_id(session,\n                                        frame->goaway.last_stream_id)) ||\n      session->remote_last_stream_id < frame->goaway.last_stream_id) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"GOAWAY: invalid last_stream_id\");\n  }\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_RECV;\n\n  session->remote_last_stream_id = frame->goaway.last_stream_id;\n\n  rv = session_call_on_frame_received(session, frame);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return session_close_stream_on_goaway(session, frame->goaway.last_stream_id,\n                                        0);\n}\n\nstatic int session_process_goaway_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_goaway_payload(&frame->goaway, iframe->sbuf.pos,\n                                      iframe->lbuf.pos,\n                                      nghttp2_buf_len(&iframe->lbuf));\n\n  nghttp2_buf_wrap_init(&iframe->lbuf, NULL, 0);\n\n  return nghttp2_session_on_goaway_received(session, frame);\n}\n\nstatic int\nsession_on_connection_window_update_received(nghttp2_session *session,\n                                             nghttp2_frame *frame) {\n  /* Handle connection-level flow control */\n  if (frame->window_update.window_size_increment == 0) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"WINDOW_UPDATE: window_size_increment == 0\");\n  }\n\n  if (NGHTTP2_MAX_WINDOW_SIZE - frame->window_update.window_size_increment <\n      session->remote_window_size) {\n    return session_handle_invalid_connection(session, frame,\n                                             NGHTTP2_ERR_FLOW_CONTROL, NULL);\n  }\n  session->remote_window_size += frame->window_update.window_size_increment;\n\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_on_stream_window_update_received(nghttp2_session *session,\n                                                    nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"WINDOW_UPDATE to idle stream\");\n  }\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream) {\n    return 0;\n  }\n  if (state_reserved_remote(session, stream)) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO, \"WINDOW_UPADATE to reserved stream\");\n  }\n  if (frame->window_update.window_size_increment == 0) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"WINDOW_UPDATE: window_size_increment == 0\");\n  }\n  if (NGHTTP2_MAX_WINDOW_SIZE - frame->window_update.window_size_increment <\n      stream->remote_window_size) {\n    return session_handle_invalid_stream(session, frame,\n                                         NGHTTP2_ERR_FLOW_CONTROL);\n  }\n  stream->remote_window_size += frame->window_update.window_size_increment;\n\n  if (stream->remote_window_size > 0 &&\n      nghttp2_stream_check_deferred_by_flow_control(stream)) {\n\n    rv = nghttp2_stream_resume_deferred_item(\n        stream, NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL);\n\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n  return session_call_on_frame_received(session, frame);\n}\n\nint nghttp2_session_on_window_update_received(nghttp2_session *session,\n                                              nghttp2_frame *frame) {\n  if (frame->hd.stream_id == 0) {\n    return session_on_connection_window_update_received(session, frame);\n  } else {\n    return session_on_stream_window_update_received(session, frame);\n  }\n}\n\nstatic int session_process_window_update_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_window_update_payload(&frame->window_update,\n                                             iframe->sbuf.pos);\n\n  return nghttp2_session_on_window_update_received(session, frame);\n}\n\nint nghttp2_session_on_altsvc_received(nghttp2_session *session,\n                                       nghttp2_frame *frame) {\n  nghttp2_ext_altsvc *altsvc;\n  nghttp2_stream *stream;\n\n  altsvc = frame->ext.payload;\n\n  /* session->server case has been excluded */\n\n  if (frame->hd.stream_id == 0) {\n    if (altsvc->origin_len == 0) {\n      return session_call_on_invalid_frame_recv_callback(session, frame,\n                                                         NGHTTP2_ERR_PROTO);\n    }\n  } else {\n    if (altsvc->origin_len > 0) {\n      return session_call_on_invalid_frame_recv_callback(session, frame,\n                                                         NGHTTP2_ERR_PROTO);\n    }\n\n    stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n      return 0;\n    }\n\n    if (stream->state == NGHTTP2_STREAM_CLOSING) {\n      return 0;\n    }\n  }\n\n  if (altsvc->field_value_len == 0) {\n    return session_call_on_invalid_frame_recv_callback(session, frame,\n                                                       NGHTTP2_ERR_PROTO);\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nint nghttp2_session_on_origin_received(nghttp2_session *session,\n                                       nghttp2_frame *frame) {\n  return session_call_on_frame_received(session, frame);\n}\n\nstatic int session_process_altsvc_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  nghttp2_frame_unpack_altsvc_payload(\n      &frame->ext, nghttp2_get_uint16(iframe->sbuf.pos), iframe->lbuf.pos,\n      nghttp2_buf_len(&iframe->lbuf));\n\n  /* nghttp2_frame_unpack_altsvc_payload steals buffer from\n     iframe->lbuf */\n  nghttp2_buf_wrap_init(&iframe->lbuf, NULL, 0);\n\n  return nghttp2_session_on_altsvc_received(session, frame);\n}\n\nstatic int session_process_origin_frame(nghttp2_session *session) {\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n  nghttp2_mem *mem = &session->mem;\n  int rv;\n\n  rv = nghttp2_frame_unpack_origin_payload(&frame->ext, iframe->lbuf.pos,\n                                           nghttp2_buf_len(&iframe->lbuf), mem);\n  if (rv != 0) {\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n    /* Ignore ORIGIN frame which cannot be parsed. */\n    return 0;\n  }\n\n  return nghttp2_session_on_origin_received(session, frame);\n}\n\nstatic int session_process_extension_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  nghttp2_frame *frame = &iframe->frame;\n\n  rv = session_call_unpack_extension_callback(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  /* This handles the case where rv == NGHTTP2_ERR_CANCEL as well */\n  if (rv != 0) {\n    return 0;\n  }\n\n  return session_call_on_frame_received(session, frame);\n}\n\nint nghttp2_session_on_data_received(nghttp2_session *session,\n                                     nghttp2_frame *frame) {\n  int rv = 0;\n  nghttp2_stream *stream;\n\n  /* We don't call on_frame_recv_callback if stream has been closed\n     already or being closed. */\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (!stream || stream->state == NGHTTP2_STREAM_CLOSING) {\n    /* This should be treated as stream error, but it results in lots\n       of RST_STREAM. So just ignore frame against nonexistent stream\n       for now. */\n    return 0;\n  }\n\n  if (session_enforce_http_messaging(session) &&\n      (frame->hd.flags & NGHTTP2_FLAG_END_STREAM)) {\n    if (nghttp2_http_on_remote_end_stream(stream) != 0) {\n      rv = nghttp2_session_add_rst_stream(session, stream->stream_id,\n                                          NGHTTP2_PROTOCOL_ERROR);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n      /* Don't call nghttp2_session_close_stream_if_shut_rdwr because\n         RST_STREAM has been submitted. */\n      return 0;\n    }\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    rv = nghttp2_session_close_stream_if_shut_rdwr(session, stream);\n    if (nghttp2_is_fatal(rv)) {\n      return rv;\n    }\n  }\n  return 0;\n}\n\n/* For errors, this function only returns FATAL error. */\nstatic int session_process_data_frame(nghttp2_session *session) {\n  int rv;\n  nghttp2_frame *public_data_frame = &session->iframe.frame;\n  rv = nghttp2_session_on_data_received(session, public_data_frame);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return 0;\n}\n\n/*\n * Now we have SETTINGS synchronization, flow control error can be\n * detected strictly. If DATA frame is received with length > 0 and\n * current received window size + delta length is strictly larger than\n * local window size, it is subject to FLOW_CONTROL_ERROR, so return\n * -1. Note that local_window_size is calculated after SETTINGS ACK is\n * received from peer, so peer must honor this limit. If the resulting\n * recv_window_size is strictly larger than NGHTTP2_MAX_WINDOW_SIZE,\n * return -1 too.\n */\nstatic int adjust_recv_window_size(int32_t *recv_window_size_ptr, size_t delta,\n                                   int32_t local_window_size) {\n  if (*recv_window_size_ptr > local_window_size - (int32_t)delta ||\n      *recv_window_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - (int32_t)delta) {\n    return -1;\n  }\n  *recv_window_size_ptr += (int32_t)delta;\n  return 0;\n}\n\nint nghttp2_session_update_recv_stream_window_size(nghttp2_session *session,\n                                                   nghttp2_stream *stream,\n                                                   size_t delta_size,\n                                                   int send_window_update) {\n  int rv;\n  rv = adjust_recv_window_size(&stream->recv_window_size, delta_size,\n                               stream->local_window_size);\n  if (rv != 0) {\n    return nghttp2_session_add_rst_stream(session, stream->stream_id,\n                                          NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n  /* We don't have to send WINDOW_UPDATE if the data received is the\n     last chunk in the incoming stream. */\n  /* We have to use local_settings here because it is the constraint\n     the remote endpoint should honor. */\n  if (send_window_update &&\n      !(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) &&\n      stream->window_update_queued == 0 &&\n      nghttp2_should_send_window_update(stream->local_window_size,\n                                        stream->recv_window_size)) {\n    rv = nghttp2_session_add_window_update(session, NGHTTP2_FLAG_NONE,\n                                           stream->stream_id,\n                                           stream->recv_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n\n    stream->recv_window_size = 0;\n  }\n  return 0;\n}\n\nint nghttp2_session_update_recv_connection_window_size(nghttp2_session *session,\n                                                       size_t delta_size) {\n  int rv;\n  rv = adjust_recv_window_size(&session->recv_window_size, delta_size,\n                               session->local_window_size);\n  if (rv != 0) {\n    return nghttp2_session_terminate_session(session,\n                                             NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) &&\n      session->window_update_queued == 0 &&\n      nghttp2_should_send_window_update(session->local_window_size,\n                                        session->recv_window_size)) {\n    /* Use stream ID 0 to update connection-level flow control\n       window */\n    rv = nghttp2_session_add_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                           session->recv_window_size);\n    if (rv != 0) {\n      return rv;\n    }\n\n    session->recv_window_size = 0;\n  }\n  return 0;\n}\n\nstatic int session_update_consumed_size(nghttp2_session *session,\n                                        int32_t *consumed_size_ptr,\n                                        int32_t *recv_window_size_ptr,\n                                        uint8_t window_update_queued,\n                                        int32_t stream_id, size_t delta_size,\n                                        int32_t local_window_size) {\n  int32_t recv_size;\n  int rv;\n\n  if ((size_t)*consumed_size_ptr > NGHTTP2_MAX_WINDOW_SIZE - delta_size) {\n    return nghttp2_session_terminate_session(session,\n                                             NGHTTP2_FLOW_CONTROL_ERROR);\n  }\n\n  *consumed_size_ptr += (int32_t)delta_size;\n\n  if (window_update_queued == 0) {\n    /* recv_window_size may be smaller than consumed_size, because it\n       may be decreased by negative value with\n       nghttp2_submit_window_update(). */\n    recv_size = nghttp2_min(*consumed_size_ptr, *recv_window_size_ptr);\n\n    if (nghttp2_should_send_window_update(local_window_size, recv_size)) {\n      rv = nghttp2_session_add_window_update(session, NGHTTP2_FLAG_NONE,\n                                             stream_id, recv_size);\n\n      if (rv != 0) {\n        return rv;\n      }\n\n      *recv_window_size_ptr -= recv_size;\n      *consumed_size_ptr -= recv_size;\n    }\n  }\n\n  return 0;\n}\n\nstatic int session_update_stream_consumed_size(nghttp2_session *session,\n                                               nghttp2_stream *stream,\n                                               size_t delta_size) {\n  return session_update_consumed_size(\n      session, &stream->consumed_size, &stream->recv_window_size,\n      stream->window_update_queued, stream->stream_id, delta_size,\n      stream->local_window_size);\n}\n\nstatic int session_update_connection_consumed_size(nghttp2_session *session,\n                                                   size_t delta_size) {\n  return session_update_consumed_size(\n      session, &session->consumed_size, &session->recv_window_size,\n      session->window_update_queued, 0, delta_size, session->local_window_size);\n}\n\n/*\n * Checks that we can receive the DATA frame for stream, which is\n * indicated by |session->iframe.frame.hd.stream_id|. If it is a\n * connection error situation, GOAWAY frame will be issued by this\n * function.\n *\n * If the DATA frame is allowed, returns 0.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_IGN_PAYLOAD\n *   The reception of DATA frame is connection error; or should be\n *   ignored.\n * NGHTTP2_ERR_NOMEM\n *   Out of memory.\n */\nstatic int session_on_data_received_fail_fast(nghttp2_session *session) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_inbound_frame *iframe;\n  int32_t stream_id;\n  const char *failure_reason;\n  uint32_t error_code = NGHTTP2_PROTOCOL_ERROR;\n\n  iframe = &session->iframe;\n  stream_id = iframe->frame.hd.stream_id;\n\n  if (stream_id == 0) {\n    /* The spec says that if a DATA frame is received whose stream ID\n       is 0, the recipient MUST respond with a connection error of\n       type PROTOCOL_ERROR. */\n    failure_reason = \"DATA: stream_id == 0\";\n    goto fail;\n  }\n\n  if (session_detect_idle_stream(session, stream_id)) {\n    failure_reason = \"DATA: stream in idle\";\n    error_code = NGHTTP2_PROTOCOL_ERROR;\n    goto fail;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (!stream) {\n    stream = nghttp2_session_get_stream_raw(session, stream_id);\n    if (stream && (stream->shut_flags & NGHTTP2_SHUT_RD)) {\n      failure_reason = \"DATA: stream closed\";\n      error_code = NGHTTP2_STREAM_CLOSED;\n      goto fail;\n    }\n\n    return NGHTTP2_ERR_IGN_PAYLOAD;\n  }\n  if (stream->shut_flags & NGHTTP2_SHUT_RD) {\n    failure_reason = \"DATA: stream in half-closed(remote)\";\n    error_code = NGHTTP2_STREAM_CLOSED;\n    goto fail;\n  }\n\n  if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n    if (stream->state == NGHTTP2_STREAM_CLOSING) {\n      return NGHTTP2_ERR_IGN_PAYLOAD;\n    }\n    if (stream->state != NGHTTP2_STREAM_OPENED) {\n      failure_reason = \"DATA: stream not opened\";\n      goto fail;\n    }\n    return 0;\n  }\n  if (stream->state == NGHTTP2_STREAM_RESERVED) {\n    failure_reason = \"DATA: stream in reserved\";\n    goto fail;\n  }\n  if (stream->state == NGHTTP2_STREAM_CLOSING) {\n    return NGHTTP2_ERR_IGN_PAYLOAD;\n  }\n  return 0;\nfail:\n  rv = nghttp2_session_terminate_session_with_reason(session, error_code,\n                                                     failure_reason);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n  return NGHTTP2_ERR_IGN_PAYLOAD;\n}\n\nstatic size_t inbound_frame_payload_readlen(nghttp2_inbound_frame *iframe,\n                                            const uint8_t *in,\n                                            const uint8_t *last) {\n  return nghttp2_min((size_t)(last - in), iframe->payloadleft);\n}\n\n/*\n * Resets iframe->sbuf and advance its mark pointer by |left| bytes.\n */\nstatic void inbound_frame_set_mark(nghttp2_inbound_frame *iframe, size_t left) {\n  nghttp2_buf_reset(&iframe->sbuf);\n  iframe->sbuf.mark += left;\n}\n\nstatic size_t inbound_frame_buf_read(nghttp2_inbound_frame *iframe,\n                                     const uint8_t *in, const uint8_t *last) {\n  size_t readlen;\n\n  readlen =\n      nghttp2_min((size_t)(last - in), nghttp2_buf_mark_avail(&iframe->sbuf));\n\n  iframe->sbuf.last = nghttp2_cpymem(iframe->sbuf.last, in, readlen);\n\n  return readlen;\n}\n\n/*\n * Unpacks SETTINGS entry in iframe->sbuf.\n */\nstatic void inbound_frame_set_settings_entry(nghttp2_inbound_frame *iframe) {\n  nghttp2_settings_entry iv;\n  nghttp2_settings_entry *min_header_table_size_entry;\n  size_t i;\n\n  nghttp2_frame_unpack_settings_entry(&iv, iframe->sbuf.pos);\n\n  switch (iv.settings_id) {\n  case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n  case NGHTTP2_SETTINGS_ENABLE_PUSH:\n  case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n  case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n  case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n  case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n  case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n    break;\n  default:\n    DEBUGF(\"recv: unknown settings id=0x%02x\\n\", iv.settings_id);\n\n    iframe->iv[iframe->niv++] = iv;\n\n    return;\n  }\n\n  for (i = 0; i < iframe->niv; ++i) {\n    if (iframe->iv[i].settings_id == iv.settings_id) {\n      iframe->iv[i] = iv;\n      break;\n    }\n  }\n\n  if (i == iframe->niv) {\n    iframe->iv[iframe->niv++] = iv;\n  }\n\n  if (iv.settings_id == NGHTTP2_SETTINGS_HEADER_TABLE_SIZE) {\n    /* Keep track of minimum value of SETTINGS_HEADER_TABLE_SIZE */\n    min_header_table_size_entry = &iframe->iv[iframe->max_niv - 1];\n\n    if (iv.value < min_header_table_size_entry->value) {\n      min_header_table_size_entry->value = iv.value;\n    }\n  }\n}\n\n/*\n * Checks PADDED flags and set iframe->sbuf to read them accordingly.\n * If padding is set, this function returns 1.  If no padding is set,\n * this function returns 0.  On error, returns -1.\n */\nstatic int inbound_frame_handle_pad(nghttp2_inbound_frame *iframe,\n                                    nghttp2_frame_hd *hd) {\n  if (hd->flags & NGHTTP2_FLAG_PADDED) {\n    if (hd->length < 1) {\n      return -1;\n    }\n    inbound_frame_set_mark(iframe, 1);\n    return 1;\n  }\n  DEBUGF(\"recv: no padding in payload\\n\");\n  return 0;\n}\n\n/*\n * Computes number of padding based on flags. This function returns\n * the calculated length if it succeeds, or -1.\n */\nstatic ssize_t inbound_frame_compute_pad(nghttp2_inbound_frame *iframe) {\n  size_t padlen;\n\n  /* 1 for Pad Length field */\n  padlen = (size_t)(iframe->sbuf.pos[0] + 1);\n\n  DEBUGF(\"recv: padlen=%zu\\n\", padlen);\n\n  /* We cannot use iframe->frame.hd.length because of CONTINUATION */\n  if (padlen - 1 > iframe->payloadleft) {\n    return -1;\n  }\n\n  iframe->padlen = padlen;\n\n  return (ssize_t)padlen;\n}\n\n/*\n * This function returns the effective payload length in the data of\n * length |readlen| when the remaning payload is |payloadleft|. The\n * |payloadleft| does not include |readlen|. If padding was started\n * strictly before this data chunk, this function returns -1.\n */\nstatic ssize_t inbound_frame_effective_readlen(nghttp2_inbound_frame *iframe,\n                                               size_t payloadleft,\n                                               size_t readlen) {\n  size_t trail_padlen =\n      nghttp2_frame_trail_padlen(&iframe->frame, iframe->padlen);\n\n  if (trail_padlen > payloadleft) {\n    size_t padlen;\n    padlen = trail_padlen - payloadleft;\n    if (readlen < padlen) {\n      return -1;\n    }\n    return (ssize_t)(readlen - padlen);\n  }\n  return (ssize_t)(readlen);\n}\n\nssize_t nghttp2_session_mem_recv(nghttp2_session *session, const uint8_t *in,\n                                 size_t inlen) {\n  const uint8_t *first = in, *last = in + inlen;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  size_t readlen;\n  ssize_t padlen;\n  int rv;\n  int busy = 0;\n  nghttp2_frame_hd cont_hd;\n  nghttp2_stream *stream;\n  size_t pri_fieldlen;\n  nghttp2_mem *mem;\n\n  DEBUGF(\"recv: connection recv_window_size=%d, local_window=%d\\n\",\n         session->recv_window_size, session->local_window_size);\n\n  mem = &session->mem;\n\n  /* We may have idle streams more than we expect (e.g.,\n     nghttp2_session_change_stream_priority() or\n     nghttp2_session_create_idle_stream()).  Adjust them here. */\n  rv = nghttp2_session_adjust_idle_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (!nghttp2_session_want_read(session)) {\n    return (ssize_t)inlen;\n  }\n\n  for (;;) {\n    switch (iframe->state) {\n    case NGHTTP2_IB_READ_CLIENT_MAGIC:\n      readlen = nghttp2_min(inlen, iframe->payloadleft);\n\n      if (memcmp(&NGHTTP2_CLIENT_MAGIC[NGHTTP2_CLIENT_MAGIC_LEN -\n                                       iframe->payloadleft],\n                 in, readlen) != 0) {\n        return NGHTTP2_ERR_BAD_CLIENT_MAGIC;\n      }\n\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      if (iframe->payloadleft == 0) {\n        session_inbound_frame_reset(session);\n        iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n      }\n\n      break;\n    case NGHTTP2_IB_READ_FIRST_SETTINGS:\n      DEBUGF(\"recv: [IB_READ_FIRST_SETTINGS]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      if (iframe->sbuf.pos[3] != NGHTTP2_SETTINGS ||\n          (iframe->sbuf.pos[4] & NGHTTP2_FLAG_ACK)) {\n        rv = session_call_error_callback(\n            session, NGHTTP2_ERR_SETTINGS_EXPECTED,\n            \"Remote peer returned unexpected data while we expected \"\n            \"SETTINGS frame.  Perhaps, peer does not support HTTP/2 \"\n            \"properly.\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"SETTINGS expected\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      }\n\n      iframe->state = NGHTTP2_IB_READ_HEAD;\n\n    /* Fall through */\n    case NGHTTP2_IB_READ_HEAD: {\n      int on_begin_frame_called = 0;\n\n      DEBUGF(\"recv: [IB_READ_HEAD]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      nghttp2_frame_unpack_frame_hd(&iframe->frame.hd, iframe->sbuf.pos);\n      iframe->payloadleft = iframe->frame.hd.length;\n\n      DEBUGF(\"recv: payloadlen=%zu, type=%u, flags=0x%02x, stream_id=%d\\n\",\n             iframe->frame.hd.length, iframe->frame.hd.type,\n             iframe->frame.hd.flags, iframe->frame.hd.stream_id);\n\n      if (iframe->frame.hd.length > session->local_settings.max_frame_size) {\n        DEBUGF(\"recv: length is too large %zu > %u\\n\", iframe->frame.hd.length,\n               session->local_settings.max_frame_size);\n\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_FRAME_SIZE_ERROR, \"too large frame size\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_DATA: {\n        DEBUGF(\"recv: DATA\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_PADDED);\n        /* Check stream is open. If it is not open or closing,\n           ignore payload. */\n        busy = 1;\n\n        rv = session_on_data_received_fail_fast(session);\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n        if (rv == NGHTTP2_ERR_IGN_PAYLOAD) {\n          DEBUGF(\"recv: DATA not allowed stream_id=%d\\n\",\n                 iframe->frame.hd.stream_id);\n          iframe->state = NGHTTP2_IB_IGN_DATA;\n          break;\n        }\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"DATA: insufficient padding space\");\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (ssize_t)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_PAD_DATA;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_DATA;\n        break;\n      }\n      case NGHTTP2_HEADERS:\n\n        DEBUGF(\"recv: HEADERS\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS |\n             NGHTTP2_FLAG_PADDED | NGHTTP2_FLAG_PRIORITY);\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"HEADERS: insufficient padding space\");\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (ssize_t)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n          break;\n        }\n\n        pri_fieldlen = nghttp2_frame_priority_len(iframe->frame.hd.flags);\n\n        if (pri_fieldlen > 0) {\n          if (iframe->payloadleft < pri_fieldlen) {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n            break;\n          }\n\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n          inbound_frame_set_mark(iframe, pri_fieldlen);\n\n          break;\n        }\n\n        /* Call on_begin_frame_callback here because\n           session_process_headers_frame() may call\n           on_begin_headers_callback */\n        rv = session_call_on_begin_frame(session, &iframe->frame.hd);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        on_begin_frame_called = 1;\n\n        rv = session_process_headers_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.hd.stream_id, NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PRIORITY:\n        DEBUGF(\"recv: PRIORITY\\n\");\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft != NGHTTP2_PRIORITY_SPECLEN) {\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, NGHTTP2_PRIORITY_SPECLEN);\n\n        break;\n      case NGHTTP2_RST_STREAM:\n      case NGHTTP2_WINDOW_UPDATE:\n#ifdef DEBUGBUILD\n        switch (iframe->frame.hd.type) {\n        case NGHTTP2_RST_STREAM:\n          DEBUGF(\"recv: RST_STREAM\\n\");\n          break;\n        case NGHTTP2_WINDOW_UPDATE:\n          DEBUGF(\"recv: WINDOW_UPDATE\\n\");\n          break;\n        }\n#endif /* DEBUGBUILD */\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft != 4) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, 4);\n\n        break;\n      case NGHTTP2_SETTINGS:\n        DEBUGF(\"recv: SETTINGS\\n\");\n\n        iframe->frame.hd.flags &= NGHTTP2_FLAG_ACK;\n\n        if ((iframe->frame.hd.length % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) ||\n            ((iframe->frame.hd.flags & NGHTTP2_FLAG_ACK) &&\n             iframe->payloadleft > 0)) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_SETTINGS;\n\n        if (iframe->payloadleft) {\n          nghttp2_settings_entry *min_header_table_size_entry;\n\n          /* We allocate iv with additional one entry, to store the\n             minimum header table size. */\n          iframe->max_niv =\n              iframe->frame.hd.length / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH + 1;\n\n          if (iframe->max_niv - 1 > session->max_settings) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_ENHANCE_YOUR_CALM,\n                \"SETTINGS: too many setting entries\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (ssize_t)inlen;\n          }\n\n          iframe->iv = nghttp2_mem_malloc(mem, sizeof(nghttp2_settings_entry) *\n                                                   iframe->max_niv);\n\n          if (!iframe->iv) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          min_header_table_size_entry = &iframe->iv[iframe->max_niv - 1];\n          min_header_table_size_entry->settings_id =\n              NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n          min_header_table_size_entry->value = UINT32_MAX;\n\n          inbound_frame_set_mark(iframe, NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH);\n          break;\n        }\n\n        busy = 1;\n\n        inbound_frame_set_mark(iframe, 0);\n\n        break;\n      case NGHTTP2_PUSH_PROMISE:\n        DEBUGF(\"recv: PUSH_PROMISE\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED);\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"PUSH_PROMISE: insufficient padding space\");\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (ssize_t)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n          break;\n        }\n\n        if (iframe->payloadleft < 4) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, 4);\n\n        break;\n      case NGHTTP2_PING:\n        DEBUGF(\"recv: PING\\n\");\n\n        iframe->frame.hd.flags &= NGHTTP2_FLAG_ACK;\n\n        if (iframe->payloadleft != 8) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n        inbound_frame_set_mark(iframe, 8);\n\n        break;\n      case NGHTTP2_GOAWAY:\n        DEBUGF(\"recv: GOAWAY\\n\");\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft < 8) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n        inbound_frame_set_mark(iframe, 8);\n\n        break;\n      case NGHTTP2_CONTINUATION:\n        DEBUGF(\"recv: unexpected CONTINUATION\\n\");\n\n        /* Receiving CONTINUATION in this state are subject to\n           connection error of type PROTOCOL_ERROR */\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"CONTINUATION: unexpected\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      default:\n        DEBUGF(\"recv: extension frame\\n\");\n\n        if (check_ext_type_set(session->user_recv_ext_types,\n                               iframe->frame.hd.type)) {\n          if (!session->callbacks.unpack_extension_callback) {\n            /* Silently ignore unknown frame type. */\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n            break;\n          }\n\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_READ_EXTENSION_PAYLOAD;\n\n          break;\n        } else {\n          switch (iframe->frame.hd.type) {\n          case NGHTTP2_ALTSVC:\n            if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC) ==\n                0) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: ALTSVC\\n\");\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n            iframe->frame.ext.payload = &iframe->ext_frame_payload.altsvc;\n\n            if (session->server) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            if (iframe->payloadleft < 2) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, 2);\n\n            break;\n          case NGHTTP2_ORIGIN:\n            if (!(session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: ORIGIN\\n\");\n\n            iframe->frame.ext.payload = &iframe->ext_frame_payload.origin;\n\n            if (session->server || iframe->frame.hd.stream_id ||\n                (iframe->frame.hd.flags & 0xf0)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n            if (iframe->payloadleft) {\n              iframe->raw_lbuf = nghttp2_mem_malloc(mem, iframe->payloadleft);\n\n              if (iframe->raw_lbuf == NULL) {\n                return NGHTTP2_ERR_NOMEM;\n              }\n\n              nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf,\n                                    iframe->payloadleft);\n            } else {\n              busy = 1;\n            }\n\n            iframe->state = NGHTTP2_IB_READ_ORIGIN_PAYLOAD;\n\n            break;\n          default:\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n            break;\n          }\n        }\n      }\n\n      if (!on_begin_frame_called) {\n        switch (iframe->state) {\n        case NGHTTP2_IB_IGN_HEADER_BLOCK:\n        case NGHTTP2_IB_IGN_PAYLOAD:\n        case NGHTTP2_IB_FRAME_SIZE_ERROR:\n        case NGHTTP2_IB_IGN_DATA:\n        case NGHTTP2_IB_IGN_ALL:\n          break;\n        default:\n          rv = session_call_on_begin_frame(session, &iframe->frame.hd);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n      }\n\n      break;\n    }\n    case NGHTTP2_IB_READ_NBYTE:\n      DEBUGF(\"recv: [IB_READ_NBYTE]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n      iframe->payloadleft -= readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu, left=%zd\\n\", readlen,\n             iframe->payloadleft, nghttp2_buf_mark_avail(&iframe->sbuf));\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_HEADERS:\n        if (iframe->padlen == 0 &&\n            (iframe->frame.hd.flags & NGHTTP2_FLAG_PADDED)) {\n          pri_fieldlen = nghttp2_frame_priority_len(iframe->frame.hd.flags);\n          padlen = inbound_frame_compute_pad(iframe);\n          if (padlen < 0 ||\n              (size_t)padlen + pri_fieldlen > 1 + iframe->payloadleft) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_PROTOCOL_ERROR, \"HEADERS: invalid padding\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (ssize_t)inlen;\n          }\n          iframe->frame.headers.padlen = (size_t)padlen;\n\n          if (pri_fieldlen > 0) {\n            if (iframe->payloadleft < pri_fieldlen) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, pri_fieldlen);\n            break;\n          } else {\n            /* Truncate buffers used for padding spec */\n            inbound_frame_set_mark(iframe, 0);\n          }\n        }\n\n        rv = session_process_headers_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.hd.stream_id, NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PRIORITY:\n        rv = session_process_priority_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_RST_STREAM:\n        rv = session_process_rst_stream_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_PUSH_PROMISE:\n        if (iframe->padlen == 0 &&\n            (iframe->frame.hd.flags & NGHTTP2_FLAG_PADDED)) {\n          padlen = inbound_frame_compute_pad(iframe);\n          if (padlen < 0 || (size_t)padlen + 4 /* promised stream id */\n                                > 1 + iframe->payloadleft) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_PROTOCOL_ERROR,\n                \"PUSH_PROMISE: invalid padding\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (ssize_t)inlen;\n          }\n\n          iframe->frame.push_promise.padlen = (size_t)padlen;\n\n          if (iframe->payloadleft < 4) {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n            break;\n          }\n\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n          inbound_frame_set_mark(iframe, 4);\n\n          break;\n        }\n\n        rv = session_process_push_promise_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.push_promise.promised_stream_id,\n              NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PING:\n        rv = session_process_ping_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_GOAWAY: {\n        size_t debuglen;\n\n        /* 8 is Last-stream-ID + Error Code */\n        debuglen = iframe->frame.hd.length - 8;\n\n        if (debuglen > 0) {\n          iframe->raw_lbuf = nghttp2_mem_malloc(mem, debuglen);\n\n          if (iframe->raw_lbuf == NULL) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf, debuglen);\n        }\n\n        busy = 1;\n\n        iframe->state = NGHTTP2_IB_READ_GOAWAY_DEBUG;\n\n        break;\n      }\n      case NGHTTP2_WINDOW_UPDATE:\n        rv = session_process_window_update_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_ALTSVC: {\n        size_t origin_len;\n\n        origin_len = nghttp2_get_uint16(iframe->sbuf.pos);\n\n        DEBUGF(\"recv: origin_len=%zu\\n\", origin_len);\n\n        if (origin_len > iframe->payloadleft) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        if (iframe->frame.hd.length > 2) {\n          iframe->raw_lbuf =\n              nghttp2_mem_malloc(mem, iframe->frame.hd.length - 2);\n\n          if (iframe->raw_lbuf == NULL) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf,\n                                iframe->frame.hd.length);\n        }\n\n        busy = 1;\n\n        iframe->state = NGHTTP2_IB_READ_ALTSVC_PAYLOAD;\n\n        break;\n      }\n      default:\n        /* This is unknown frame */\n        session_inbound_frame_reset(session);\n\n        break;\n      }\n      break;\n    case NGHTTP2_IB_READ_HEADER_BLOCK:\n    case NGHTTP2_IB_IGN_HEADER_BLOCK: {\n      ssize_t data_readlen;\n      size_t trail_padlen;\n      int final;\n#ifdef DEBUGBUILD\n      if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n        DEBUGF(\"recv: [IB_READ_HEADER_BLOCK]\\n\");\n      } else {\n        DEBUGF(\"recv: [IB_IGN_HEADER_BLOCK]\\n\");\n      }\n#endif /* DEBUGBUILD */\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft - readlen);\n\n      data_readlen = inbound_frame_effective_readlen(\n          iframe, iframe->payloadleft - readlen, readlen);\n\n      if (data_readlen == -1) {\n        /* everything is padding */\n        data_readlen = 0;\n      }\n\n      trail_padlen = nghttp2_frame_trail_padlen(&iframe->frame, iframe->padlen);\n\n      final = (iframe->frame.hd.flags & NGHTTP2_FLAG_END_HEADERS) &&\n              iframe->payloadleft - (size_t)data_readlen == trail_padlen;\n\n      if (data_readlen > 0 || (data_readlen == 0 && final)) {\n        size_t hd_proclen = 0;\n\n        DEBUGF(\"recv: block final=%d\\n\", final);\n\n        rv =\n            inflate_header_block(session, &iframe->frame, &hd_proclen,\n                                 (uint8_t *)in, (size_t)data_readlen, final,\n                                 iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_PAUSE) {\n          in += hd_proclen;\n          iframe->payloadleft -= hd_proclen;\n\n          return in - first;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          /* The application says no more headers. We decompress the\n             rest of the header block but not invoke on_header_callback\n             and on_frame_recv_callback. */\n          in += hd_proclen;\n          iframe->payloadleft -= hd_proclen;\n\n          /* Use promised stream ID for PUSH_PROMISE */\n          rv = nghttp2_session_add_rst_stream(\n              session,\n              iframe->frame.hd.type == NGHTTP2_PUSH_PROMISE\n                  ? iframe->frame.push_promise.promised_stream_id\n                  : iframe->frame.hd.stream_id,\n              NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          busy = 1;\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        in += readlen;\n        iframe->payloadleft -= readlen;\n\n        if (rv == NGHTTP2_ERR_HEADER_COMP) {\n          /* GOAWAY is already issued */\n          if (iframe->payloadleft == 0) {\n            session_inbound_frame_reset(session);\n          } else {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n          }\n          break;\n        }\n      } else {\n        in += readlen;\n        iframe->payloadleft -= readlen;\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      if ((iframe->frame.hd.flags & NGHTTP2_FLAG_END_HEADERS) == 0) {\n\n        inbound_frame_set_mark(iframe, NGHTTP2_FRAME_HDLEN);\n\n        iframe->padlen = 0;\n\n        if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_EXPECT_CONTINUATION;\n        } else {\n          iframe->state = NGHTTP2_IB_IGN_CONTINUATION;\n        }\n      } else {\n        if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n          rv = session_after_header_block_received(session);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n        session_inbound_frame_reset(session);\n      }\n      break;\n    }\n    case NGHTTP2_IB_IGN_PAYLOAD:\n      DEBUGF(\"recv: [IB_IGN_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_HEADERS:\n      case NGHTTP2_PUSH_PROMISE:\n      case NGHTTP2_CONTINUATION:\n        /* Mark inflater bad so that we won't perform further decoding */\n        session->hd_inflater.ctx.bad = 1;\n        break;\n      default:\n        break;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_FRAME_SIZE_ERROR:\n      DEBUGF(\"recv: [IB_FRAME_SIZE_ERROR]\\n\");\n\n      rv = session_handle_frame_size_error(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      assert(iframe->state == NGHTTP2_IB_IGN_ALL);\n\n      return (ssize_t)inlen;\n    case NGHTTP2_IB_READ_SETTINGS:\n      DEBUGF(\"recv: [IB_READ_SETTINGS]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        break;\n      }\n\n      if (readlen > 0) {\n        inbound_frame_set_settings_entry(iframe);\n      }\n      if (iframe->payloadleft) {\n        inbound_frame_set_mark(iframe, NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH);\n        break;\n      }\n\n      rv = session_process_settings_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_GOAWAY_DEBUG:\n      DEBUGF(\"recv: [IB_READ_GOAWAY_DEBUG]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_goaway_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_EXPECT_CONTINUATION:\n    case NGHTTP2_IB_IGN_CONTINUATION:\n#ifdef DEBUGBUILD\n      if (iframe->state == NGHTTP2_IB_EXPECT_CONTINUATION) {\n        fprintf(stderr, \"recv: [IB_EXPECT_CONTINUATION]\\n\");\n      } else {\n        fprintf(stderr, \"recv: [IB_IGN_CONTINUATION]\\n\");\n      }\n#endif /* DEBUGBUILD */\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      nghttp2_frame_unpack_frame_hd(&cont_hd, iframe->sbuf.pos);\n      iframe->payloadleft = cont_hd.length;\n\n      DEBUGF(\"recv: payloadlen=%zu, type=%u, flags=0x%02x, stream_id=%d\\n\",\n             cont_hd.length, cont_hd.type, cont_hd.flags, cont_hd.stream_id);\n\n      if (cont_hd.type != NGHTTP2_CONTINUATION ||\n          cont_hd.stream_id != iframe->frame.hd.stream_id) {\n        DEBUGF(\"recv: expected stream_id=%d, type=%d, but got stream_id=%d, \"\n               \"type=%u\\n\",\n               iframe->frame.hd.stream_id, NGHTTP2_CONTINUATION,\n               cont_hd.stream_id, cont_hd.type);\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR,\n            \"unexpected non-CONTINUATION frame or stream_id is invalid\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (ssize_t)inlen;\n      }\n\n      /* CONTINUATION won't bear NGHTTP2_PADDED flag */\n\n      iframe->frame.hd.flags = (uint8_t)(\n          iframe->frame.hd.flags | (cont_hd.flags & NGHTTP2_FLAG_END_HEADERS));\n      iframe->frame.hd.length += cont_hd.length;\n\n      busy = 1;\n\n      if (iframe->state == NGHTTP2_IB_EXPECT_CONTINUATION) {\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        rv = session_call_on_begin_frame(session, &cont_hd);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      } else {\n        iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n      }\n\n      break;\n    case NGHTTP2_IB_READ_PAD_DATA:\n      DEBUGF(\"recv: [IB_READ_PAD_DATA]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n      iframe->payloadleft -= readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu, left=%zu\\n\", readlen,\n             iframe->payloadleft, nghttp2_buf_mark_avail(&iframe->sbuf));\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return in - first;\n      }\n\n      /* Pad Length field is subject to flow control */\n      rv = nghttp2_session_update_recv_connection_window_size(session, readlen);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      /* Pad Length field is consumed immediately */\n      rv =\n          nghttp2_session_consume(session, iframe->frame.hd.stream_id, readlen);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      stream = nghttp2_session_get_stream(session, iframe->frame.hd.stream_id);\n      if (stream) {\n        rv = nghttp2_session_update_recv_stream_window_size(\n            session, stream, readlen,\n            iframe->payloadleft ||\n                (iframe->frame.hd.flags & NGHTTP2_FLAG_END_STREAM) == 0);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      }\n\n      busy = 1;\n\n      padlen = inbound_frame_compute_pad(iframe);\n      if (padlen < 0) {\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"DATA: invalid padding\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        return (ssize_t)inlen;\n      }\n\n      iframe->frame.data.padlen = (size_t)padlen;\n\n      iframe->state = NGHTTP2_IB_READ_DATA;\n\n      break;\n    case NGHTTP2_IB_READ_DATA:\n      stream = nghttp2_session_get_stream(session, iframe->frame.hd.stream_id);\n\n      if (!stream) {\n        busy = 1;\n        iframe->state = NGHTTP2_IB_IGN_DATA;\n        break;\n      }\n\n      DEBUGF(\"recv: [IB_READ_DATA]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        ssize_t data_readlen;\n\n        rv = nghttp2_session_update_recv_connection_window_size(session,\n                                                                readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        rv = nghttp2_session_update_recv_stream_window_size(\n            session, stream, readlen,\n            iframe->payloadleft ||\n                (iframe->frame.hd.flags & NGHTTP2_FLAG_END_STREAM) == 0);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        data_readlen = inbound_frame_effective_readlen(\n            iframe, iframe->payloadleft, readlen);\n\n        if (data_readlen == -1) {\n          /* everything is padding */\n          data_readlen = 0;\n        }\n\n        padlen = (ssize_t)readlen - data_readlen;\n\n        if (padlen > 0) {\n          /* Padding is considered as \"consumed\" immediately */\n          rv = nghttp2_session_consume(session, iframe->frame.hd.stream_id,\n                                       (size_t)padlen);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (ssize_t)inlen;\n          }\n        }\n\n        DEBUGF(\"recv: data_readlen=%zd\\n\", data_readlen);\n\n        if (data_readlen > 0) {\n          if (session_enforce_http_messaging(session)) {\n            if (nghttp2_http_on_data_chunk(stream, (size_t)data_readlen) != 0) {\n              if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n                /* Consume all data for connection immediately here */\n                rv = session_update_connection_consumed_size(\n                    session, (size_t)data_readlen);\n\n                if (nghttp2_is_fatal(rv)) {\n                  return rv;\n                }\n\n                if (iframe->state == NGHTTP2_IB_IGN_DATA) {\n                  return (ssize_t)inlen;\n                }\n              }\n\n              rv = nghttp2_session_add_rst_stream(\n                  session, iframe->frame.hd.stream_id, NGHTTP2_PROTOCOL_ERROR);\n              if (nghttp2_is_fatal(rv)) {\n                return rv;\n              }\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_DATA;\n              break;\n            }\n          }\n          if (session->callbacks.on_data_chunk_recv_callback) {\n            rv = session->callbacks.on_data_chunk_recv_callback(\n                session, iframe->frame.hd.flags, iframe->frame.hd.stream_id,\n                in - readlen, (size_t)data_readlen, session->user_data);\n            if (rv == NGHTTP2_ERR_PAUSE) {\n              return in - first;\n            }\n\n            if (nghttp2_is_fatal(rv)) {\n              return NGHTTP2_ERR_CALLBACK_FAILURE;\n            }\n          }\n        }\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      rv = session_process_data_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_IGN_DATA:\n      DEBUGF(\"recv: [IB_IGN_DATA]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        /* Update connection-level flow control window for ignored\n           DATA frame too */\n        rv = nghttp2_session_update_recv_connection_window_size(session,\n                                                                readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (ssize_t)inlen;\n        }\n\n        if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n\n          /* Ignored DATA is considered as \"consumed\" immediately. */\n          rv = session_update_connection_consumed_size(session, readlen);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (ssize_t)inlen;\n          }\n        }\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_IGN_ALL:\n      return (ssize_t)inlen;\n    case NGHTTP2_IB_READ_EXTENSION_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_EXTENSION_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        rv = session_call_on_extension_chunk_recv_callback(\n            session, in - readlen, readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (rv != 0) {\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n          break;\n        }\n      }\n\n      if (iframe->payloadleft > 0) {\n        break;\n      }\n\n      rv = session_process_extension_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_ALTSVC_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_ALTSVC_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_altsvc_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_ORIGIN_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_ORIGIN_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_origin_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (ssize_t)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    }\n\n    if (!busy && in == last) {\n      break;\n    }\n\n    busy = 0;\n  }\n\n  assert(in == last);\n\n  return in - first;\n}\n\nint nghttp2_session_recv(nghttp2_session *session) {\n  uint8_t buf[NGHTTP2_INBOUND_BUFFER_LENGTH];\n  while (1) {\n    ssize_t readlen;\n    readlen = session_recv(session, buf, sizeof(buf));\n    if (readlen > 0) {\n      ssize_t proclen = nghttp2_session_mem_recv(session, buf, (size_t)readlen);\n      if (proclen < 0) {\n        return (int)proclen;\n      }\n      assert(proclen == readlen);\n    } else if (readlen == 0 || readlen == NGHTTP2_ERR_WOULDBLOCK) {\n      return 0;\n    } else if (readlen == NGHTTP2_ERR_EOF) {\n      return NGHTTP2_ERR_EOF;\n    } else if (readlen < 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n  }\n}\n\n/*\n * Returns the number of active streams, which includes streams in\n * reserved state.\n */\nstatic size_t session_get_num_active_streams(nghttp2_session *session) {\n  return nghttp2_map_size(&session->streams) - session->num_closed_streams -\n         session->num_idle_streams;\n}\n\nint nghttp2_session_want_read(nghttp2_session *session) {\n  size_t num_active_streams;\n\n  /* If this flag is set, we don't want to read. The application\n     should drop the connection. */\n  if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_SENT) {\n    return 0;\n  }\n\n  num_active_streams = session_get_num_active_streams(session);\n\n  /* Unless termination GOAWAY is sent or received, we always want to\n     read incoming frames. */\n\n  if (num_active_streams > 0) {\n    return 1;\n  }\n\n  /* If there is no active streams and GOAWAY has been sent or\n     received, we are done with this session. */\n  return (session->goaway_flags &\n          (NGHTTP2_GOAWAY_SENT | NGHTTP2_GOAWAY_RECV)) == 0;\n}\n\nint nghttp2_session_want_write(nghttp2_session *session) {\n  /* If these flag is set, we don't want to write any data. The\n     application should drop the connection. */\n  if (session->goaway_flags & NGHTTP2_GOAWAY_TERM_SENT) {\n    return 0;\n  }\n\n  /*\n   * Unless termination GOAWAY is sent or received, we want to write\n   * frames if there is pending ones. If pending frame is request/push\n   * response HEADERS and concurrent stream limit is reached, we don't\n   * want to write them.\n   */\n  return session->aob.item || nghttp2_outbound_queue_top(&session->ob_urgent) ||\n         nghttp2_outbound_queue_top(&session->ob_reg) ||\n         (!nghttp2_pq_empty(&session->root.obq) &&\n          session->remote_window_size > 0) ||\n         (nghttp2_outbound_queue_top(&session->ob_syn) &&\n          !session_is_outgoing_concurrent_streams_max(session));\n}\n\nint nghttp2_session_add_ping(nghttp2_session *session, uint8_t flags,\n                             const uint8_t *opaque_data) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if ((flags & NGHTTP2_FLAG_ACK) &&\n      session->obq_flood_counter_ >= session->max_outbound_ack) {\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_ping_init(&frame->ping, flags, opaque_data);\n\n  rv = nghttp2_session_add_item(session, item);\n\n  if (rv != 0) {\n    nghttp2_frame_ping_free(&frame->ping);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n\n  if (flags & NGHTTP2_FLAG_ACK) {\n    ++session->obq_flood_counter_;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_add_goaway(nghttp2_session *session, int32_t last_stream_id,\n                               uint32_t error_code, const uint8_t *opaque_data,\n                               size_t opaque_data_len, uint8_t aux_flags) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  uint8_t *opaque_data_copy = NULL;\n  nghttp2_goaway_aux_data *aux_data;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if (nghttp2_session_is_my_stream_id(session, last_stream_id)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (opaque_data_len) {\n    if (opaque_data_len + 8 > NGHTTP2_MAX_PAYLOADLEN) {\n      return NGHTTP2_ERR_INVALID_ARGUMENT;\n    }\n    opaque_data_copy = nghttp2_mem_malloc(mem, opaque_data_len);\n    if (opaque_data_copy == NULL) {\n      return NGHTTP2_ERR_NOMEM;\n    }\n    memcpy(opaque_data_copy, opaque_data, opaque_data_len);\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    nghttp2_mem_free(mem, opaque_data_copy);\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  /* last_stream_id must not be increased from the value previously\n     sent */\n  last_stream_id = nghttp2_min(last_stream_id, session->local_last_stream_id);\n\n  nghttp2_frame_goaway_init(&frame->goaway, last_stream_id, error_code,\n                            opaque_data_copy, opaque_data_len);\n\n  aux_data = &item->aux_data.goaway;\n  aux_data->flags = aux_flags;\n\n  rv = nghttp2_session_add_item(session, item);\n  if (rv != 0) {\n    nghttp2_frame_goaway_free(&frame->goaway, mem);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n  return 0;\n}\n\nint nghttp2_session_add_window_update(nghttp2_session *session, uint8_t flags,\n                                      int32_t stream_id,\n                                      int32_t window_size_increment) {\n  int rv;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_window_update_init(&frame->window_update, flags, stream_id,\n                                   window_size_increment);\n\n  rv = nghttp2_session_add_item(session, item);\n\n  if (rv != 0) {\n    nghttp2_frame_window_update_free(&frame->window_update);\n    nghttp2_mem_free(mem, item);\n    return rv;\n  }\n  return 0;\n}\n\nstatic void\nsession_append_inflight_settings(nghttp2_session *session,\n                                 nghttp2_inflight_settings *settings) {\n  nghttp2_inflight_settings **i;\n\n  for (i = &session->inflight_settings_head; *i; i = &(*i)->next)\n    ;\n\n  *i = settings;\n}\n\nint nghttp2_session_add_settings(nghttp2_session *session, uint8_t flags,\n                                 const nghttp2_settings_entry *iv, size_t niv) {\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_settings_entry *iv_copy;\n  size_t i;\n  int rv;\n  nghttp2_mem *mem;\n  nghttp2_inflight_settings *inflight_settings = NULL;\n\n  mem = &session->mem;\n\n  if (flags & NGHTTP2_FLAG_ACK) {\n    if (niv != 0) {\n      return NGHTTP2_ERR_INVALID_ARGUMENT;\n    }\n\n    if (session->obq_flood_counter_ >= session->max_outbound_ack) {\n      return NGHTTP2_ERR_FLOODED;\n    }\n  }\n\n  if (!nghttp2_iv_check(iv, niv)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  item = nghttp2_mem_malloc(mem, sizeof(nghttp2_outbound_item));\n  if (item == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  if (niv > 0) {\n    iv_copy = nghttp2_frame_iv_copy(iv, niv, mem);\n    if (iv_copy == NULL) {\n      nghttp2_mem_free(mem, item);\n      return NGHTTP2_ERR_NOMEM;\n    }\n  } else {\n    iv_copy = NULL;\n  }\n\n  if ((flags & NGHTTP2_FLAG_ACK) == 0) {\n    rv = inflight_settings_new(&inflight_settings, iv, niv, mem);\n    if (rv != 0) {\n      assert(nghttp2_is_fatal(rv));\n      nghttp2_mem_free(mem, iv_copy);\n      nghttp2_mem_free(mem, item);\n      return rv;\n    }\n  }\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_settings_init(&frame->settings, flags, iv_copy, niv);\n  rv = nghttp2_session_add_item(session, item);\n  if (rv != 0) {\n    /* The only expected error is fatal one */\n    assert(nghttp2_is_fatal(rv));\n\n    inflight_settings_del(inflight_settings, mem);\n\n    nghttp2_frame_settings_free(&frame->settings, mem);\n    nghttp2_mem_free(mem, item);\n\n    return rv;\n  }\n\n  if (flags & NGHTTP2_FLAG_ACK) {\n    ++session->obq_flood_counter_;\n  } else {\n    session_append_inflight_settings(session, inflight_settings);\n  }\n\n  /* Extract NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS and ENABLE_PUSH\n     here.  We use it to refuse the incoming stream and PUSH_PROMISE\n     with RST_STREAM. */\n\n  for (i = niv; i > 0; --i) {\n    if (iv[i - 1].settings_id == NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS) {\n      session->pending_local_max_concurrent_stream = iv[i - 1].value;\n      break;\n    }\n  }\n\n  for (i = niv; i > 0; --i) {\n    if (iv[i - 1].settings_id == NGHTTP2_SETTINGS_ENABLE_PUSH) {\n      session->pending_enable_push = (uint8_t)iv[i - 1].value;\n      break;\n    }\n  }\n\n  for (i = niv; i > 0; --i) {\n    if (iv[i - 1].settings_id == NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL) {\n      session->pending_enable_connect_protocol = (uint8_t)iv[i - 1].value;\n      break;\n    }\n  }\n\n  return 0;\n}\n\nint nghttp2_session_pack_data(nghttp2_session *session, nghttp2_bufs *bufs,\n                              size_t datamax, nghttp2_frame *frame,\n                              nghttp2_data_aux_data *aux_data,\n                              nghttp2_stream *stream) {\n  int rv;\n  uint32_t data_flags;\n  ssize_t payloadlen;\n  ssize_t padded_payloadlen;\n  nghttp2_buf *buf;\n  size_t max_payloadlen;\n\n  assert(bufs->head == bufs->cur);\n\n  buf = &bufs->cur->buf;\n\n  if (session->callbacks.read_length_callback) {\n\n    payloadlen = session->callbacks.read_length_callback(\n        session, frame->hd.type, stream->stream_id, session->remote_window_size,\n        stream->remote_window_size, session->remote_settings.max_frame_size,\n        session->user_data);\n\n    DEBUGF(\"send: read_length_callback=%zd\\n\", payloadlen);\n\n    payloadlen = nghttp2_session_enforce_flow_control_limits(session, stream,\n                                                             payloadlen);\n\n    DEBUGF(\"send: read_length_callback after flow control=%zd\\n\", payloadlen);\n\n    if (payloadlen <= 0) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n\n    if ((size_t)payloadlen > nghttp2_buf_avail(buf)) {\n      /* Resize the current buffer(s).  The reason why we do +1 for\n         buffer size is for possible padding field. */\n      rv = nghttp2_bufs_realloc(&session->aob.framebufs,\n                                (size_t)(NGHTTP2_FRAME_HDLEN + 1 + payloadlen));\n\n      if (rv != 0) {\n        DEBUGF(\"send: realloc buffer failed rv=%d\", rv);\n        /* If reallocation failed, old buffers are still in tact.  So\n           use safe limit. */\n        payloadlen = (ssize_t)datamax;\n\n        DEBUGF(\"send: use safe limit payloadlen=%zd\", payloadlen);\n      } else {\n        assert(&session->aob.framebufs == bufs);\n\n        buf = &bufs->cur->buf;\n      }\n    }\n    datamax = (size_t)payloadlen;\n  }\n\n  /* Current max DATA length is less then buffer chunk size */\n  assert(nghttp2_buf_avail(buf) >= datamax);\n\n  data_flags = NGHTTP2_DATA_FLAG_NONE;\n  payloadlen = aux_data->data_prd.read_callback(\n      session, frame->hd.stream_id, buf->pos, datamax, &data_flags,\n      &aux_data->data_prd.source, session->user_data);\n\n  if (payloadlen == NGHTTP2_ERR_DEFERRED ||\n      payloadlen == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ||\n      payloadlen == NGHTTP2_ERR_PAUSE) {\n    DEBUGF(\"send: DATA postponed due to %s\\n\",\n           nghttp2_strerror((int)payloadlen));\n\n    return (int)payloadlen;\n  }\n\n  if (payloadlen < 0 || datamax < (size_t)payloadlen) {\n    /* This is the error code when callback is failed. */\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n  }\n\n  buf->last = buf->pos + payloadlen;\n  buf->pos -= NGHTTP2_FRAME_HDLEN;\n\n  /* Clear flags, because this may contain previous flags of previous\n     DATA */\n  frame->hd.flags = NGHTTP2_FLAG_NONE;\n\n  if (data_flags & NGHTTP2_DATA_FLAG_EOF) {\n    aux_data->eof = 1;\n    /* If NGHTTP2_DATA_FLAG_NO_END_STREAM is set, don't set\n       NGHTTP2_FLAG_END_STREAM */\n    if ((aux_data->flags & NGHTTP2_FLAG_END_STREAM) &&\n        (data_flags & NGHTTP2_DATA_FLAG_NO_END_STREAM) == 0) {\n      frame->hd.flags |= NGHTTP2_FLAG_END_STREAM;\n    }\n  }\n\n  if (data_flags & NGHTTP2_DATA_FLAG_NO_COPY) {\n    if (session->callbacks.send_data_callback == NULL) {\n      DEBUGF(\"NGHTTP2_DATA_FLAG_NO_COPY requires send_data_callback set\\n\");\n\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    aux_data->no_copy = 1;\n  }\n\n  frame->hd.length = (size_t)payloadlen;\n  frame->data.padlen = 0;\n\n  max_payloadlen = nghttp2_min(datamax, frame->hd.length + NGHTTP2_MAX_PADLEN);\n\n  padded_payloadlen =\n      session_call_select_padding(session, frame, max_payloadlen);\n\n  if (nghttp2_is_fatal((int)padded_payloadlen)) {\n    return (int)padded_payloadlen;\n  }\n\n  frame->data.padlen = (size_t)(padded_payloadlen - payloadlen);\n\n  nghttp2_frame_pack_frame_hd(buf->pos, &frame->hd);\n\n  rv = nghttp2_frame_add_pad(bufs, &frame->hd, frame->data.padlen,\n                             aux_data->no_copy);\n  if (rv != 0) {\n    return rv;\n  }\n\n  reschedule_stream(stream);\n\n  if (frame->hd.length == 0 && (data_flags & NGHTTP2_DATA_FLAG_EOF) &&\n      (data_flags & NGHTTP2_DATA_FLAG_NO_END_STREAM)) {\n    /* DATA payload length is 0, and DATA frame does not bear\n       END_STREAM.  In this case, there is no point to send 0 length\n       DATA frame. */\n    return NGHTTP2_ERR_CANCEL;\n  }\n\n  return 0;\n}\n\nvoid *nghttp2_session_get_stream_user_data(nghttp2_session *session,\n                                           int32_t stream_id) {\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream) {\n    return stream->stream_user_data;\n  } else {\n    return NULL;\n  }\n}\n\nint nghttp2_session_set_stream_user_data(nghttp2_session *session,\n                                         int32_t stream_id,\n                                         void *stream_user_data) {\n  nghttp2_stream *stream;\n  nghttp2_frame *frame;\n  nghttp2_outbound_item *item;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream) {\n    stream->stream_user_data = stream_user_data;\n    return 0;\n  }\n\n  if (session->server || !nghttp2_session_is_my_stream_id(session, stream_id) ||\n      !nghttp2_outbound_queue_top(&session->ob_syn)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  frame = &nghttp2_outbound_queue_top(&session->ob_syn)->frame;\n  assert(frame->hd.type == NGHTTP2_HEADERS);\n\n  if (frame->hd.stream_id > stream_id ||\n      (uint32_t)stream_id >= session->next_stream_id) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  for (item = session->ob_syn.head; item; item = item->qnext) {\n    if (item->frame.hd.stream_id < stream_id) {\n      continue;\n    }\n\n    if (item->frame.hd.stream_id > stream_id) {\n      break;\n    }\n\n    item->aux_data.headers.stream_user_data = stream_user_data;\n    return 0;\n  }\n\n  return NGHTTP2_ERR_INVALID_ARGUMENT;\n}\n\nint nghttp2_session_resume_data(nghttp2_session *session, int32_t stream_id) {\n  int rv;\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL || !nghttp2_stream_check_deferred_item(stream)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  rv = nghttp2_stream_resume_deferred_item(stream,\n                                           NGHTTP2_STREAM_FLAG_DEFERRED_USER);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nsize_t nghttp2_session_get_outbound_queue_size(nghttp2_session *session) {\n  return nghttp2_outbound_queue_size(&session->ob_urgent) +\n         nghttp2_outbound_queue_size(&session->ob_reg) +\n         nghttp2_outbound_queue_size(&session->ob_syn);\n  /* TODO account for item attached to stream */\n}\n\nint32_t\nnghttp2_session_get_stream_effective_recv_data_length(nghttp2_session *session,\n                                                      int32_t stream_id) {\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n  return stream->recv_window_size < 0 ? 0 : stream->recv_window_size;\n}\n\nint32_t\nnghttp2_session_get_stream_effective_local_window_size(nghttp2_session *session,\n                                                       int32_t stream_id) {\n  nghttp2_stream *stream;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n  return stream->local_window_size;\n}\n\nint32_t nghttp2_session_get_stream_local_window_size(nghttp2_session *session,\n                                                     int32_t stream_id) {\n  nghttp2_stream *stream;\n  int32_t size;\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n\n  size = stream->local_window_size - stream->recv_window_size;\n\n  /* size could be negative if local endpoint reduced\n     SETTINGS_INITIAL_WINDOW_SIZE */\n  if (size < 0) {\n    return 0;\n  }\n\n  return size;\n}\n\nint32_t\nnghttp2_session_get_effective_recv_data_length(nghttp2_session *session) {\n  return session->recv_window_size < 0 ? 0 : session->recv_window_size;\n}\n\nint32_t\nnghttp2_session_get_effective_local_window_size(nghttp2_session *session) {\n  return session->local_window_size;\n}\n\nint32_t nghttp2_session_get_local_window_size(nghttp2_session *session) {\n  return session->local_window_size - session->recv_window_size;\n}\n\nint32_t nghttp2_session_get_stream_remote_window_size(nghttp2_session *session,\n                                                      int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n  if (stream == NULL) {\n    return -1;\n  }\n\n  /* stream->remote_window_size can be negative when\n     SETTINGS_INITIAL_WINDOW_SIZE is changed. */\n  return nghttp2_max(0, stream->remote_window_size);\n}\n\nint32_t nghttp2_session_get_remote_window_size(nghttp2_session *session) {\n  return session->remote_window_size;\n}\n\nuint32_t nghttp2_session_get_remote_settings(nghttp2_session *session,\n                                             nghttp2_settings_id id) {\n  switch (id) {\n  case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n    return session->remote_settings.header_table_size;\n  case NGHTTP2_SETTINGS_ENABLE_PUSH:\n    return session->remote_settings.enable_push;\n  case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n    return session->remote_settings.max_concurrent_streams;\n  case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n    return session->remote_settings.initial_window_size;\n  case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n    return session->remote_settings.max_frame_size;\n  case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n    return session->remote_settings.max_header_list_size;\n  case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n    return session->remote_settings.enable_connect_protocol;\n  }\n\n  assert(0);\n  abort(); /* if NDEBUG is set */\n}\n\nuint32_t nghttp2_session_get_local_settings(nghttp2_session *session,\n                                            nghttp2_settings_id id) {\n  switch (id) {\n  case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n    return session->local_settings.header_table_size;\n  case NGHTTP2_SETTINGS_ENABLE_PUSH:\n    return session->local_settings.enable_push;\n  case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n    return session->local_settings.max_concurrent_streams;\n  case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n    return session->local_settings.initial_window_size;\n  case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n    return session->local_settings.max_frame_size;\n  case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n    return session->local_settings.max_header_list_size;\n  case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n    return session->local_settings.enable_connect_protocol;\n  }\n\n  assert(0);\n  abort(); /* if NDEBUG is set */\n}\n\nstatic int nghttp2_session_upgrade_internal(nghttp2_session *session,\n                                            const uint8_t *settings_payload,\n                                            size_t settings_payloadlen,\n                                            void *stream_user_data) {\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n  nghttp2_settings_entry *iv;\n  size_t niv;\n  int rv;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if ((!session->server && session->next_stream_id != 1) ||\n      (session->server && session->last_recv_stream_id >= 1)) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n  /* SETTINGS frame contains too many settings */\n  if (settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH\n        > session->max_settings) {\n    return NGHTTP2_ERR_TOO_MANY_SETTINGS;\n  }\n  rv = nghttp2_frame_unpack_settings_payload2(&iv, &niv, settings_payload,\n                                              settings_payloadlen, mem);\n  if (rv != 0) {\n    return rv;\n  }\n\n  if (session->server) {\n    nghttp2_frame_hd_init(&frame.hd, settings_payloadlen, NGHTTP2_SETTINGS,\n                          NGHTTP2_FLAG_NONE, 0);\n    frame.settings.iv = iv;\n    frame.settings.niv = niv;\n    rv = nghttp2_session_on_settings_received(session, &frame, 1 /* No ACK */);\n  } else {\n    rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, niv);\n  }\n  nghttp2_mem_free(mem, iv);\n  if (rv != 0) {\n    return rv;\n  }\n\n  nghttp2_priority_spec_default_init(&pri_spec);\n\n  stream = nghttp2_session_open_stream(\n      session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec, NGHTTP2_STREAM_OPENING,\n      session->server ? NULL : stream_user_data);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't call nghttp2_session_adjust_closed_stream(), since this\n     should be the first stream open. */\n\n  if (session->server) {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    session->last_recv_stream_id = 1;\n    session->last_proc_stream_id = 1;\n  } else {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n    session->last_sent_stream_id = 1;\n    session->next_stream_id += 2;\n  }\n  return 0;\n}\n\nint nghttp2_session_upgrade(nghttp2_session *session,\n                            const uint8_t *settings_payload,\n                            size_t settings_payloadlen,\n                            void *stream_user_data) {\n  int rv;\n  nghttp2_stream *stream;\n\n  rv = nghttp2_session_upgrade_internal(session, settings_payload,\n                                        settings_payloadlen, stream_user_data);\n  if (rv != 0) {\n    return rv;\n  }\n\n  stream = nghttp2_session_get_stream(session, 1);\n  assert(stream);\n\n  /* We have no information about request header fields when Upgrade\n     was happened.  So we don't know the request method here.  If\n     request method is HEAD, we have a trouble because we may have\n     nonzero content-length header field in response headers, and we\n     will going to check it against the actual DATA frames, but we may\n     get mismatch because HEAD response body must be empty.  Because\n     of this reason, nghttp2_session_upgrade() was deprecated in favor\n     of nghttp2_session_upgrade2(), which has |head_request| parameter\n     to indicate that request method is HEAD or not. */\n  stream->http_flags |= NGHTTP2_HTTP_FLAG_METH_UPGRADE_WORKAROUND;\n  return 0;\n}\n\nint nghttp2_session_upgrade2(nghttp2_session *session,\n                             const uint8_t *settings_payload,\n                             size_t settings_payloadlen, int head_request,\n                             void *stream_user_data) {\n  int rv;\n  nghttp2_stream *stream;\n\n  rv = nghttp2_session_upgrade_internal(session, settings_payload,\n                                        settings_payloadlen, stream_user_data);\n  if (rv != 0) {\n    return rv;\n  }\n\n  stream = nghttp2_session_get_stream(session, 1);\n  assert(stream);\n\n  if (head_request) {\n    stream->http_flags |= NGHTTP2_HTTP_FLAG_METH_HEAD;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_get_stream_local_close(nghttp2_session *session,\n                                           int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return -1;\n  }\n\n  return (stream->shut_flags & NGHTTP2_SHUT_WR) != 0;\n}\n\nint nghttp2_session_get_stream_remote_close(nghttp2_session *session,\n                                            int32_t stream_id) {\n  nghttp2_stream *stream;\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return -1;\n  }\n\n  return (stream->shut_flags & NGHTTP2_SHUT_RD) != 0;\n}\n\nint nghttp2_session_consume(nghttp2_session *session, int32_t stream_id,\n                            size_t size) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (stream_id == 0) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE)) {\n    return NGHTTP2_ERR_INVALID_STATE;\n  }\n\n  rv = session_update_connection_consumed_size(session, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return 0;\n  }\n\n  rv = session_update_stream_consumed_size(session, stream, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_consume_connection(nghttp2_session *session, size_t size) {\n  int rv;\n\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE)) {\n    return NGHTTP2_ERR_INVALID_STATE;\n  }\n\n  rv = session_update_connection_consumed_size(session, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_consume_stream(nghttp2_session *session, int32_t stream_id,\n                                   size_t size) {\n  int rv;\n  nghttp2_stream *stream;\n\n  if (stream_id == 0) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (!(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE)) {\n    return NGHTTP2_ERR_INVALID_STATE;\n  }\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  if (!stream) {\n    return 0;\n  }\n\n  rv = session_update_stream_consumed_size(session, stream, size);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return 0;\n}\n\nint nghttp2_session_set_next_stream_id(nghttp2_session *session,\n                                       int32_t next_stream_id) {\n  if (next_stream_id <= 0 ||\n      session->next_stream_id > (uint32_t)next_stream_id) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  if (session->server) {\n    if (next_stream_id % 2) {\n      return NGHTTP2_ERR_INVALID_ARGUMENT;\n    }\n  } else if (next_stream_id % 2 == 0) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  session->next_stream_id = (uint32_t)next_stream_id;\n  return 0;\n}\n\nuint32_t nghttp2_session_get_next_stream_id(nghttp2_session *session) {\n  return session->next_stream_id;\n}\n\nint32_t nghttp2_session_get_last_proc_stream_id(nghttp2_session *session) {\n  return session->last_proc_stream_id;\n}\n\nnghttp2_stream *nghttp2_session_find_stream(nghttp2_session *session,\n                                            int32_t stream_id) {\n  if (stream_id == 0) {\n    return &session->root;\n  }\n\n  return nghttp2_session_get_stream_raw(session, stream_id);\n}\n\nnghttp2_stream *nghttp2_session_get_root_stream(nghttp2_session *session) {\n  return &session->root;\n}\n\nint nghttp2_session_check_server_session(nghttp2_session *session) {\n  return session->server;\n}\n\nint nghttp2_session_change_stream_priority(\n    nghttp2_session *session, int32_t stream_id,\n    const nghttp2_priority_spec *pri_spec) {\n  int rv;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec_copy;\n\n  if (stream_id == 0 || stream_id == pri_spec->stream_id) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n  if (!stream) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  pri_spec_copy = *pri_spec;\n  nghttp2_priority_spec_normalize_weight(&pri_spec_copy);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec_copy);\n\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  /* We don't intentionally call nghttp2_session_adjust_idle_stream()\n     so that idle stream created by this function, and existing ones\n     are kept for application.  We will adjust number of idle stream\n     in nghttp2_session_mem_send or nghttp2_session_mem_recv is\n     called. */\n  return 0;\n}\n\nint nghttp2_session_create_idle_stream(nghttp2_session *session,\n                                       int32_t stream_id,\n                                       const nghttp2_priority_spec *pri_spec) {\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec_copy;\n\n  if (stream_id == 0 || stream_id == pri_spec->stream_id ||\n      !session_detect_idle_stream(session, stream_id)) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n  if (stream) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n\n  pri_spec_copy = *pri_spec;\n  nghttp2_priority_spec_normalize_weight(&pri_spec_copy);\n\n  stream =\n      nghttp2_session_open_stream(session, stream_id, NGHTTP2_STREAM_FLAG_NONE,\n                                  &pri_spec_copy, NGHTTP2_STREAM_IDLE, NULL);\n  if (!stream) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't intentionally call nghttp2_session_adjust_idle_stream()\n     so that idle stream created by this function, and existing ones\n     are kept for application.  We will adjust number of idle stream\n     in nghttp2_session_mem_send or nghttp2_session_mem_recv is\n     called. */\n  return 0;\n}\n\nsize_t\nnghttp2_session_get_hd_inflate_dynamic_table_size(nghttp2_session *session) {\n  return nghttp2_hd_inflate_get_dynamic_table_size(&session->hd_inflater);\n}\n\nsize_t\nnghttp2_session_get_hd_deflate_dynamic_table_size(nghttp2_session *session) {\n  return nghttp2_hd_deflate_get_dynamic_table_size(&session->hd_deflater);\n}\n\nvoid nghttp2_session_set_user_data(nghttp2_session *session, void *user_data) {\n  session->user_data = user_data;\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_SESSION_H\n#define NGHTTP2_SESSION_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <nghttp2/nghttp2.h>\n#include \"nghttp2_map.h\"\n#include \"nghttp2_frame.h\"\n#include \"nghttp2_hd.h\"\n#include \"nghttp2_stream.h\"\n#include \"nghttp2_outbound_item.h\"\n#include \"nghttp2_int.h\"\n#include \"nghttp2_buf.h\"\n#include \"nghttp2_callbacks.h\"\n#include \"nghttp2_mem.h\"\n\n/* The global variable for tests where we want to disable strict\n   preface handling. */\nextern int nghttp2_enable_strict_preface;\n\n/*\n * Option flags.\n */\ntypedef enum {\n  NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE = 1 << 0,\n  NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC = 1 << 1,\n  NGHTTP2_OPTMASK_NO_HTTP_MESSAGING = 1 << 2,\n  NGHTTP2_OPTMASK_NO_AUTO_PING_ACK = 1 << 3,\n  NGHTTP2_OPTMASK_NO_CLOSED_STREAMS = 1 << 4\n} nghttp2_optmask;\n\n/*\n * bitmask for built-in type to enable the default handling for that\n * type of the frame.\n */\ntypedef enum {\n  NGHTTP2_TYPEMASK_NONE = 0,\n  NGHTTP2_TYPEMASK_ALTSVC = 1 << 0,\n  NGHTTP2_TYPEMASK_ORIGIN = 1 << 1\n} nghttp2_typemask;\n\ntypedef enum {\n  NGHTTP2_OB_POP_ITEM,\n  NGHTTP2_OB_SEND_DATA,\n  NGHTTP2_OB_SEND_NO_COPY,\n  NGHTTP2_OB_SEND_CLIENT_MAGIC\n} nghttp2_outbound_state;\n\ntypedef struct {\n  nghttp2_outbound_item *item;\n  nghttp2_bufs framebufs;\n  nghttp2_outbound_state state;\n} nghttp2_active_outbound_item;\n\n/* Buffer length for inbound raw byte stream used in\n   nghttp2_session_recv(). */\n#define NGHTTP2_INBOUND_BUFFER_LENGTH 16384\n\n/* The default maximum number of incoming reserved streams */\n#define NGHTTP2_MAX_INCOMING_RESERVED_STREAMS 200\n\n/* Even if we have less SETTINGS_MAX_CONCURRENT_STREAMS than this\n   number, we keep NGHTTP2_MIN_IDLE_STREAMS streams in idle state */\n#define NGHTTP2_MIN_IDLE_STREAMS 16\n\n/* The maximum number of items in outbound queue, which is considered\n   as flooding caused by peer.  All frames are not considered here.\n   We only consider PING + ACK and SETTINGS + ACK.  This is because\n   they both are response to the frame initiated by peer and peer can\n   send as many of them as they want.  If peer does not read network,\n   response frames are stacked up, which leads to memory exhaustion.\n   The value selected here is arbitrary, but safe value and if we have\n   these frames in this number, it is considered suspicious. */\n#define NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM 1000\n\n/* The default value of maximum number of concurrent streams. */\n#define NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS 0xffffffffu\n\n/* Internal state when receiving incoming frame */\ntypedef enum {\n  /* Receiving frame header */\n  NGHTTP2_IB_READ_CLIENT_MAGIC,\n  NGHTTP2_IB_READ_FIRST_SETTINGS,\n  NGHTTP2_IB_READ_HEAD,\n  NGHTTP2_IB_READ_NBYTE,\n  NGHTTP2_IB_READ_HEADER_BLOCK,\n  NGHTTP2_IB_IGN_HEADER_BLOCK,\n  NGHTTP2_IB_IGN_PAYLOAD,\n  NGHTTP2_IB_FRAME_SIZE_ERROR,\n  NGHTTP2_IB_READ_SETTINGS,\n  NGHTTP2_IB_READ_GOAWAY_DEBUG,\n  NGHTTP2_IB_EXPECT_CONTINUATION,\n  NGHTTP2_IB_IGN_CONTINUATION,\n  NGHTTP2_IB_READ_PAD_DATA,\n  NGHTTP2_IB_READ_DATA,\n  NGHTTP2_IB_IGN_DATA,\n  NGHTTP2_IB_IGN_ALL,\n  NGHTTP2_IB_READ_ALTSVC_PAYLOAD,\n  NGHTTP2_IB_READ_ORIGIN_PAYLOAD,\n  NGHTTP2_IB_READ_EXTENSION_PAYLOAD\n} nghttp2_inbound_state;\n\ntypedef struct {\n  nghttp2_frame frame;\n  /* Storage for extension frame payload.  frame->ext.payload points\n     to this structure to avoid frequent memory allocation. */\n  nghttp2_ext_frame_payload ext_frame_payload;\n  /* The received SETTINGS entry.  For the standard settings entries,\n     we only keep the last seen value.  For\n     SETTINGS_HEADER_TABLE_SIZE, we also keep minimum value in the\n     last index. */\n  nghttp2_settings_entry *iv;\n  /* buffer pointers to small buffer, raw_sbuf */\n  nghttp2_buf sbuf;\n  /* buffer pointers to large buffer, raw_lbuf */\n  nghttp2_buf lbuf;\n  /* Large buffer, malloced on demand */\n  uint8_t *raw_lbuf;\n  /* The number of entry filled in |iv| */\n  size_t niv;\n  /* The number of entries |iv| can store. */\n  size_t max_niv;\n  /* How many bytes we still need to receive for current frame */\n  size_t payloadleft;\n  /* padding length for the current frame */\n  size_t padlen;\n  nghttp2_inbound_state state;\n  /* Small buffer.  Currently the largest contiguous chunk to buffer\n     is frame header.  We buffer part of payload, but they are smaller\n     than frame header. */\n  uint8_t raw_sbuf[NGHTTP2_FRAME_HDLEN];\n} nghttp2_inbound_frame;\n\ntypedef struct {\n  uint32_t header_table_size;\n  uint32_t enable_push;\n  uint32_t max_concurrent_streams;\n  uint32_t initial_window_size;\n  uint32_t max_frame_size;\n  uint32_t max_header_list_size;\n  uint32_t enable_connect_protocol;\n} nghttp2_settings_storage;\n\ntypedef enum {\n  NGHTTP2_GOAWAY_NONE = 0,\n  /* Flag means that connection should be terminated after sending GOAWAY. */\n  NGHTTP2_GOAWAY_TERM_ON_SEND = 0x1,\n  /* Flag means GOAWAY to terminate session has been sent */\n  NGHTTP2_GOAWAY_TERM_SENT = 0x2,\n  /* Flag means GOAWAY was sent */\n  NGHTTP2_GOAWAY_SENT = 0x4,\n  /* Flag means GOAWAY was received */\n  NGHTTP2_GOAWAY_RECV = 0x8\n} nghttp2_goaway_flag;\n\n/* nghttp2_inflight_settings stores the SETTINGS entries which local\n   endpoint has sent to the remote endpoint, and has not received ACK\n   yet. */\nstruct nghttp2_inflight_settings {\n  struct nghttp2_inflight_settings *next;\n  nghttp2_settings_entry *iv;\n  size_t niv;\n};\n\ntypedef struct nghttp2_inflight_settings nghttp2_inflight_settings;\n\nstruct nghttp2_session {\n  nghttp2_map /* <nghttp2_stream*> */ streams;\n  /* root of dependency tree*/\n  nghttp2_stream root;\n  /* Queue for outbound urgent frames (PING and SETTINGS) */\n  nghttp2_outbound_queue ob_urgent;\n  /* Queue for non-DATA frames */\n  nghttp2_outbound_queue ob_reg;\n  /* Queue for outbound stream-creating HEADERS (request or push\n     response) frame, which are subject to\n     SETTINGS_MAX_CONCURRENT_STREAMS limit. */\n  nghttp2_outbound_queue ob_syn;\n  nghttp2_active_outbound_item aob;\n  nghttp2_inbound_frame iframe;\n  nghttp2_hd_deflater hd_deflater;\n  nghttp2_hd_inflater hd_inflater;\n  nghttp2_session_callbacks callbacks;\n  /* Memory allocator */\n  nghttp2_mem mem;\n  void *user_data;\n  /* Points to the latest incoming closed stream.  NULL if there is no\n     closed stream.  Only used when session is initialized as\n     server. */\n  nghttp2_stream *closed_stream_head;\n  /* Points to the oldest incoming closed stream.  NULL if there is no\n     closed stream.  Only used when session is initialized as\n     server. */\n  nghttp2_stream *closed_stream_tail;\n  /* Points to the latest idle stream.  NULL if there is no idle\n     stream.  Only used when session is initialized as server .*/\n  nghttp2_stream *idle_stream_head;\n  /* Points to the oldest idle stream.  NULL if there is no idle\n     stream.  Only used when session is initialized as erver. */\n  nghttp2_stream *idle_stream_tail;\n  /* Queue of In-flight SETTINGS values.  SETTINGS bearing ACK is not\n     considered as in-flight. */\n  nghttp2_inflight_settings *inflight_settings_head;\n  /* The number of outgoing streams. This will be capped by\n     remote_settings.max_concurrent_streams. */\n  size_t num_outgoing_streams;\n  /* The number of incoming streams. This will be capped by\n     local_settings.max_concurrent_streams. */\n  size_t num_incoming_streams;\n  /* The number of incoming reserved streams.  This is the number of\n     streams in reserved (remote) state.  RFC 7540 does not limit this\n     number.  nghttp2 offers\n     nghttp2_option_set_max_reserved_remote_streams() to achieve this.\n     If it is used, num_incoming_streams is capped by\n     max_incoming_reserved_streams.  Client application should\n     consider to set this because without that server can send\n     arbitrary number of PUSH_PROMISE, and exhaust client's memory. */\n  size_t num_incoming_reserved_streams;\n  /* The maximum number of incoming reserved streams (reserved\n     (remote) state).  RST_STREAM will be sent for the pushed stream\n     which exceeds this limit. */\n  size_t max_incoming_reserved_streams;\n  /* The number of closed streams still kept in |streams| hash.  The\n     closed streams can be accessed through single linked list\n     |closed_stream_head|.  The current implementation only keeps\n     incoming streams and session is initialized as server. */\n  size_t num_closed_streams;\n  /* The number of idle streams kept in |streams| hash.  The idle\n     streams can be accessed through doubly linked list\n     |idle_stream_head|.  The current implementation only keeps idle\n     streams if session is initialized as server. */\n  size_t num_idle_streams;\n  /* The number of bytes allocated for nvbuf */\n  size_t nvbuflen;\n  /* Counter for detecting flooding in outbound queue.  If it exceeds\n     max_outbound_ack, session will be closed. */\n  size_t obq_flood_counter_;\n  /* The maximum number of outgoing SETTINGS ACK and PING ACK in\n     outbound queue. */\n  size_t max_outbound_ack;\n  /* The maximum length of header block to send.  Calculated by the\n     same way as nghttp2_hd_deflate_bound() does. */\n  size_t max_send_header_block_length;\n  /* The maximum number of settings accepted per SETTINGS frame. */\n  size_t max_settings;\n  /* Next Stream ID. Made unsigned int to detect >= (1 << 31). */\n  uint32_t next_stream_id;\n  /* The last stream ID this session initiated.  For client session,\n     this is the last stream ID it has sent.  For server session, it\n     is the last promised stream ID sent in PUSH_PROMISE. */\n  int32_t last_sent_stream_id;\n  /* The largest stream ID received so far */\n  int32_t last_recv_stream_id;\n  /* The largest stream ID which has been processed in some way. This\n     value will be used as last-stream-id when sending GOAWAY\n     frame. */\n  int32_t last_proc_stream_id;\n  /* Counter of unique ID of PING. Wraps when it exceeds\n     NGHTTP2_MAX_UNIQUE_ID */\n  uint32_t next_unique_id;\n  /* This is the last-stream-ID we have sent in GOAWAY */\n  int32_t local_last_stream_id;\n  /* This is the value in GOAWAY frame received from remote endpoint. */\n  int32_t remote_last_stream_id;\n  /* Current sender window size. This value is computed against the\n     current initial window size of remote endpoint. */\n  int32_t remote_window_size;\n  /* Keep track of the number of bytes received without\n     WINDOW_UPDATE. This could be negative after submitting negative\n     value to WINDOW_UPDATE. */\n  int32_t recv_window_size;\n  /* The number of bytes consumed by the application and now is\n     subject to WINDOW_UPDATE.  This is only used when auto\n     WINDOW_UPDATE is turned off. */\n  int32_t consumed_size;\n  /* The amount of recv_window_size cut using submitting negative\n     value to WINDOW_UPDATE */\n  int32_t recv_reduction;\n  /* window size for local flow control. It is initially set to\n     NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE and could be\n     increased/decreased by submitting WINDOW_UPDATE. See\n     nghttp2_submit_window_update(). */\n  int32_t local_window_size;\n  /* This flag is used to indicate that the local endpoint received initial\n     SETTINGS frame from the remote endpoint. */\n  uint8_t remote_settings_received;\n  /* Settings value received from the remote endpoint. */\n  nghttp2_settings_storage remote_settings;\n  /* Settings value of the local endpoint. */\n  nghttp2_settings_storage local_settings;\n  /* Option flags. This is bitwise-OR of 0 or more of nghttp2_optmask. */\n  uint32_t opt_flags;\n  /* Unacked local SETTINGS_MAX_CONCURRENT_STREAMS value. We use this\n     to refuse the incoming stream if it exceeds this value. */\n  uint32_t pending_local_max_concurrent_stream;\n  /* The bitwise OR of zero or more of nghttp2_typemask to indicate\n     that the default handling of extension frame is enabled. */\n  uint32_t builtin_recv_ext_types;\n  /* Unacked local ENABLE_PUSH value.  We use this to refuse\n     PUSH_PROMISE before SETTINGS ACK is received. */\n  uint8_t pending_enable_push;\n  /* Unacked local ENABLE_CONNECT_PROTOCOL value.  We use this to\n     accept :protocol header field before SETTINGS_ACK is received. */\n  uint8_t pending_enable_connect_protocol;\n  /* Nonzero if the session is server side. */\n  uint8_t server;\n  /* Flags indicating GOAWAY is sent and/or received. The flags are\n     composed by bitwise OR-ing nghttp2_goaway_flag. */\n  uint8_t goaway_flags;\n  /* This flag is used to reduce excessive queuing of WINDOW_UPDATE to\n     this session.  The nonzero does not necessarily mean\n     WINDOW_UPDATE is not queued. */\n  uint8_t window_update_queued;\n  /* Bitfield of extension frame types that application is willing to\n     receive.  To designate the bit of given frame type i, use\n     user_recv_ext_types[i / 8] & (1 << (i & 0x7)).  First 10 frame\n     types are standard frame types and not used in this bitfield.  If\n     bit is set, it indicates that incoming frame with that type is\n     passed to user defined callbacks, otherwise they are ignored. */\n  uint8_t user_recv_ext_types[32];\n};\n\n/* Struct used when updating initial window size of each active\n   stream. */\ntypedef struct {\n  nghttp2_session *session;\n  int32_t new_window_size, old_window_size;\n} nghttp2_update_window_size_arg;\n\ntypedef struct {\n  nghttp2_session *session;\n  /* linked list of streams to close */\n  nghttp2_stream *head;\n  int32_t last_stream_id;\n  /* nonzero if GOAWAY is sent to peer, which means we are going to\n     close incoming streams.  zero if GOAWAY is received from peer and\n     we are going to close outgoing streams. */\n  int incoming;\n} nghttp2_close_stream_on_goaway_arg;\n\n/* TODO stream timeout etc */\n\n/*\n * Returns nonzero value if |stream_id| is initiated by local\n * endpoint.\n */\nint nghttp2_session_is_my_stream_id(nghttp2_session *session,\n                                    int32_t stream_id);\n\n/*\n * Adds |item| to the outbound queue in |session|.  When this function\n * succeeds, it takes ownership of |item|. So caller must not free it\n * on success.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_STREAM_CLOSED\n *     Stream already closed (DATA and PUSH_PROMISE frame only)\n */\nint nghttp2_session_add_item(nghttp2_session *session,\n                             nghttp2_outbound_item *item);\n\n/*\n * Adds RST_STREAM frame for the stream |stream_id| with the error\n * code |error_code|. This is a convenient function built on top of\n * nghttp2_session_add_frame() to add RST_STREAM easily.\n *\n * This function simply returns 0 without adding RST_STREAM frame if\n * given stream is in NGHTTP2_STREAM_CLOSING state, because multiple\n * RST_STREAM for a stream is redundant.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_add_rst_stream(nghttp2_session *session, int32_t stream_id,\n                                   uint32_t error_code);\n\n/*\n * Adds PING frame. This is a convenient functin built on top of\n * nghttp2_session_add_frame() to add PING easily.\n *\n * If the |opaque_data| is not NULL, it must point to 8 bytes memory\n * region of data. The data pointed by |opaque_data| is copied. It can\n * be NULL. In this case, 8 bytes NULL is used.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue; this only happens\n *     if NGHTTP2_FLAG_ACK is set in |flags|\n */\nint nghttp2_session_add_ping(nghttp2_session *session, uint8_t flags,\n                             const uint8_t *opaque_data);\n\n/*\n * Adds GOAWAY frame with the last-stream-ID |last_stream_id| and the\n * error code |error_code|. This is a convenient function built on top\n * of nghttp2_session_add_frame() to add GOAWAY easily.  The\n * |aux_flags| are bitwise-OR of one or more of\n * nghttp2_goaway_aux_flag.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The |opaque_data_len| is too large.\n */\nint nghttp2_session_add_goaway(nghttp2_session *session, int32_t last_stream_id,\n                               uint32_t error_code, const uint8_t *opaque_data,\n                               size_t opaque_data_len, uint8_t aux_flags);\n\n/*\n * Adds WINDOW_UPDATE frame with stream ID |stream_id| and\n * window-size-increment |window_size_increment|. This is a convenient\n * function built on top of nghttp2_session_add_frame() to add\n * WINDOW_UPDATE easily.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_add_window_update(nghttp2_session *session, uint8_t flags,\n                                      int32_t stream_id,\n                                      int32_t window_size_increment);\n\n/*\n * Adds SETTINGS frame.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue; this only happens\n *     if NGHTTP2_FLAG_ACK is set in |flags|\n */\nint nghttp2_session_add_settings(nghttp2_session *session, uint8_t flags,\n                                 const nghttp2_settings_entry *iv, size_t niv);\n\n/*\n * Creates new stream in |session| with stream ID |stream_id|,\n * priority |pri_spec| and flags |flags|.  The |flags| is bitwise OR\n * of nghttp2_stream_flag.  Since this function is called when initial\n * HEADERS is sent or received, these flags are taken from it.  The\n * state of stream is set to |initial_state|. The |stream_user_data|\n * is a pointer to the arbitrary user supplied data to be associated\n * to this stream.\n *\n * If |initial_state| is NGHTTP2_STREAM_RESERVED, this function sets\n * NGHTTP2_STREAM_FLAG_PUSH flag set.\n *\n * This function returns a pointer to created new stream object, or\n * NULL.\n *\n * This function adjusts neither the number of closed streams or idle\n * streams.  The caller should manually call\n * nghttp2_session_adjust_closed_stream() or\n * nghttp2_session_adjust_idle_stream() respectively.\n */\nnghttp2_stream *nghttp2_session_open_stream(nghttp2_session *session,\n                                            int32_t stream_id, uint8_t flags,\n                                            nghttp2_priority_spec *pri_spec,\n                                            nghttp2_stream_state initial_state,\n                                            void *stream_user_data);\n\n/*\n * Closes stream whose stream ID is |stream_id|. The reason of closure\n * is indicated by the |error_code|. When closing the stream,\n * on_stream_close_callback will be called.\n *\n * If the session is initialized as server and |stream| is incoming\n * stream, stream is just marked closed and this function calls\n * nghttp2_session_keep_closed_stream() with |stream|.  Otherwise,\n * |stream| will be deleted from memory.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The specified stream does not exist.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_close_stream(nghttp2_session *session, int32_t stream_id,\n                                 uint32_t error_code);\n\n/*\n * Deletes |stream| from memory.  After this function returns, stream\n * cannot be accessed.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_destroy_stream(nghttp2_session *session,\n                                   nghttp2_stream *stream);\n\n/*\n * Tries to keep incoming closed stream |stream|.  Due to the\n * limitation of maximum number of streams in memory, |stream| is not\n * closed and just deleted from memory (see\n * nghttp2_session_destroy_stream).\n */\nvoid nghttp2_session_keep_closed_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream);\n\n/*\n * Appends |stream| to linked list |session->idle_stream_head|.  We\n * apply fixed limit for list size.  To fit into that limit, one or\n * more oldest streams are removed from list as necessary.\n */\nvoid nghttp2_session_keep_idle_stream(nghttp2_session *session,\n                                      nghttp2_stream *stream);\n\n/*\n * Detaches |stream| from idle streams linked list.\n */\nvoid nghttp2_session_detach_idle_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream);\n\n/*\n * Deletes closed stream to ensure that number of incoming streams\n * including active and closed is in the maximum number of allowed\n * stream.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_adjust_closed_stream(nghttp2_session *session);\n\n/*\n * Deletes idle stream to ensure that number of idle streams is in\n * certain limit.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_adjust_idle_stream(nghttp2_session *session);\n\n/*\n * If further receptions and transmissions over the stream |stream_id|\n * are disallowed, close the stream with error code NGHTTP2_NO_ERROR.\n *\n * This function returns 0 if it\n * succeeds, or one of the following negative error codes:\n *\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The specified stream does not exist.\n */\nint nghttp2_session_close_stream_if_shut_rdwr(nghttp2_session *session,\n                                              nghttp2_stream *stream);\n\nint nghttp2_session_on_request_headers_received(nghttp2_session *session,\n                                                nghttp2_frame *frame);\n\nint nghttp2_session_on_response_headers_received(nghttp2_session *session,\n                                                 nghttp2_frame *frame,\n                                                 nghttp2_stream *stream);\n\nint nghttp2_session_on_push_response_headers_received(nghttp2_session *session,\n                                                      nghttp2_frame *frame,\n                                                      nghttp2_stream *stream);\n\n/*\n * Called when HEADERS is received, assuming |frame| is properly\n * initialized.  This function does first validate received frame and\n * then open stream and call callback functions.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_IGN_HEADER_BLOCK\n *     Frame was rejected and header block must be decoded but\n *     result must be ignored.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_headers_received(nghttp2_session *session,\n                                        nghttp2_frame *frame,\n                                        nghttp2_stream *stream);\n\n/*\n * Called when PRIORITY is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_priority_received(nghttp2_session *session,\n                                         nghttp2_frame *frame);\n\n/*\n * Called when RST_STREAM is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_rst_stream_received(nghttp2_session *session,\n                                           nghttp2_frame *frame);\n\n/*\n * Called when SETTINGS is received, assuming |frame| is properly\n * initialized. If |noack| is non-zero, SETTINGS with ACK will not be\n * submitted. If |frame| has NGHTTP2_FLAG_ACK flag set, no SETTINGS\n * with ACK will not be submitted regardless of |noack|.\n *\n * This function returns 0 if it succeeds, or one the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue, and this is most\n *     likely caused by misbehaviour of peer.\n */\nint nghttp2_session_on_settings_received(nghttp2_session *session,\n                                         nghttp2_frame *frame, int noack);\n\n/*\n * Called when PUSH_PROMISE is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_IGN_HEADER_BLOCK\n *     Frame was rejected and header block must be decoded but\n *     result must be ignored.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed\n */\nint nghttp2_session_on_push_promise_received(nghttp2_session *session,\n                                             nghttp2_frame *frame);\n\n/*\n * Called when PING is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n * NGHTTP2_ERR_FLOODED\n *     There are too many items in outbound queue, and this is most\n *     likely caused by misbehaviour of peer.\n */\nint nghttp2_session_on_ping_received(nghttp2_session *session,\n                                     nghttp2_frame *frame);\n\n/*\n * Called when GOAWAY is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_goaway_received(nghttp2_session *session,\n                                       nghttp2_frame *frame);\n\n/*\n * Called when WINDOW_UPDATE is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_window_update_received(nghttp2_session *session,\n                                              nghttp2_frame *frame);\n\n/*\n * Called when ALTSVC is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_altsvc_received(nghttp2_session *session,\n                                       nghttp2_frame *frame);\n\n/*\n * Called when ORIGIN is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_origin_received(nghttp2_session *session,\n                                       nghttp2_frame *frame);\n\n/*\n * Called when DATA is received, assuming |frame| is properly\n * initialized.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The callback function failed.\n */\nint nghttp2_session_on_data_received(nghttp2_session *session,\n                                     nghttp2_frame *frame);\n\n/*\n * Returns nghttp2_stream* object whose stream ID is |stream_id|.  It\n * could be NULL if such stream does not exist.  This function returns\n * NULL if stream is marked as closed.\n */\nnghttp2_stream *nghttp2_session_get_stream(nghttp2_session *session,\n                                           int32_t stream_id);\n\n/*\n * This function behaves like nghttp2_session_get_stream(), but it\n * returns stream object even if it is marked as closed or in\n * NGHTTP2_STREAM_IDLE state.\n */\nnghttp2_stream *nghttp2_session_get_stream_raw(nghttp2_session *session,\n                                               int32_t stream_id);\n\n/*\n * Packs DATA frame |frame| in wire frame format and stores it in\n * |bufs|.  Payload will be read using |aux_data->data_prd|.  The\n * length of payload is at most |datamax| bytes.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_DEFERRED\n *     The DATA frame is postponed.\n * NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE\n *     The read_callback failed (stream error).\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_CALLBACK_FAILURE\n *     The read_callback failed (session error).\n */\nint nghttp2_session_pack_data(nghttp2_session *session, nghttp2_bufs *bufs,\n                              size_t datamax, nghttp2_frame *frame,\n                              nghttp2_data_aux_data *aux_data,\n                              nghttp2_stream *stream);\n\n/*\n * Pops and returns next item to send.  If there is no such item,\n * returns NULL.  This function takes into account max concurrent\n * streams.  That means if session->ob_syn has item and max concurrent\n * streams is reached, the even if other queues contain items, then\n * this function returns NULL.\n */\nnghttp2_outbound_item *\nnghttp2_session_pop_next_ob_item(nghttp2_session *session);\n\n/*\n * Returns next item to send.  If there is no such item, this function\n * returns NULL.  This function takes into account max concurrent\n * streams.  That means if session->ob_syn has item and max concurrent\n * streams is reached, the even if other queues contain items, then\n * this function returns NULL.\n */\nnghttp2_outbound_item *\nnghttp2_session_get_next_ob_item(nghttp2_session *session);\n\n/*\n * Updates local settings with the |iv|. The number of elements in the\n * array pointed by the |iv| is given by the |niv|.  This function\n * assumes that the all settings_id member in |iv| are in range 1 to\n * NGHTTP2_SETTINGS_MAX, inclusive.\n *\n * While updating individual stream's local window size, if the window\n * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,\n * RST_STREAM is issued against such a stream.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_update_local_settings(nghttp2_session *session,\n                                          nghttp2_settings_entry *iv,\n                                          size_t niv);\n\n/*\n * Re-prioritize |stream|. The new priority specification is\n * |pri_spec|.  Caller must ensure that stream->hd.stream_id !=\n * pri_spec->stream_id.\n *\n * This function does not adjust the number of idle streams.  The\n * caller should call nghttp2_session_adjust_idle_stream() later.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory\n */\nint nghttp2_session_reprioritize_stream(nghttp2_session *session,\n                                        nghttp2_stream *stream,\n                                        const nghttp2_priority_spec *pri_spec);\n\n/*\n * Terminates current |session| with the |error_code|.  The |reason|\n * is NULL-terminated debug string.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n * NGHTTP2_ERR_INVALID_ARGUMENT\n *     The |reason| is too long.\n */\nint nghttp2_session_terminate_session_with_reason(nghttp2_session *session,\n                                                  uint32_t error_code,\n                                                  const char *reason);\n\n/*\n * Accumulates received bytes |delta_size| for connection-level flow\n * control and decides whether to send WINDOW_UPDATE to the\n * connection.  If NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE is set,\n * WINDOW_UPDATE will not be sent.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_update_recv_connection_window_size(nghttp2_session *session,\n                                                       size_t delta_size);\n\n/*\n * Accumulates received bytes |delta_size| for stream-level flow\n * control and decides whether to send WINDOW_UPDATE to that stream.\n * If NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE is set, WINDOW_UPDATE will not\n * be sent.\n *\n * This function returns 0 if it succeeds, or one of the following\n * negative error codes:\n *\n * NGHTTP2_ERR_NOMEM\n *     Out of memory.\n */\nint nghttp2_session_update_recv_stream_window_size(nghttp2_session *session,\n                                                   nghttp2_stream *stream,\n                                                   size_t delta_size,\n                                                   int send_window_update);\n\n#endif /* NGHTTP2_SESSION_H */\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <string.h>\n#include <CUnit/Basic.h>\n/* include test cases' include files here */\n#include \"nghttp2_pq_test.h\"\n#include \"nghttp2_map_test.h\"\n#include \"nghttp2_queue_test.h\"\n#include \"nghttp2_session_test.h\"\n#include \"nghttp2_frame_test.h\"\n#include \"nghttp2_stream_test.h\"\n#include \"nghttp2_hd_test.h\"\n#include \"nghttp2_npn_test.h\"\n#include \"nghttp2_helper_test.h\"\n#include \"nghttp2_buf_test.h\"\n\nextern int nghttp2_enable_strict_preface;\n\nstatic int init_suite1(void) { return 0; }\n\nstatic int clean_suite1(void) { return 0; }\n\nint main() {\n  CU_pSuite pSuite = NULL;\n  unsigned int num_tests_failed;\n\n  nghttp2_enable_strict_preface = 0;\n\n  /* initialize the CUnit test registry */\n  if (CUE_SUCCESS != CU_initialize_registry())\n    return (int)CU_get_error();\n\n  /* add a suite to the registry */\n  pSuite = CU_add_suite(\"libnghttp2_TestSuite\", init_suite1, clean_suite1);\n  if (NULL == pSuite) {\n    CU_cleanup_registry();\n    return (int)CU_get_error();\n  }\n\n  /* add the tests to the suite */\n  if (!CU_add_test(pSuite, \"pq\", test_nghttp2_pq) ||\n      !CU_add_test(pSuite, \"pq_update\", test_nghttp2_pq_update) ||\n      !CU_add_test(pSuite, \"pq_remove\", test_nghttp2_pq_remove) ||\n      !CU_add_test(pSuite, \"map\", test_nghttp2_map) ||\n      !CU_add_test(pSuite, \"map_functional\", test_nghttp2_map_functional) ||\n      !CU_add_test(pSuite, \"map_each_free\", test_nghttp2_map_each_free) ||\n      !CU_add_test(pSuite, \"queue\", test_nghttp2_queue) ||\n      !CU_add_test(pSuite, \"npn\", test_nghttp2_npn) ||\n      !CU_add_test(pSuite, \"session_recv\", test_nghttp2_session_recv) ||\n      !CU_add_test(pSuite, \"session_recv_invalid_stream_id\",\n                   test_nghttp2_session_recv_invalid_stream_id) ||\n      !CU_add_test(pSuite, \"session_recv_invalid_frame\",\n                   test_nghttp2_session_recv_invalid_frame) ||\n      !CU_add_test(pSuite, \"session_recv_eof\", test_nghttp2_session_recv_eof) ||\n      !CU_add_test(pSuite, \"session_recv_data\",\n                   test_nghttp2_session_recv_data) ||\n      !CU_add_test(pSuite, \"session_recv_data_no_auto_flow_control\",\n                   test_nghttp2_session_recv_data_no_auto_flow_control) ||\n      !CU_add_test(pSuite, \"session_recv_continuation\",\n                   test_nghttp2_session_recv_continuation) ||\n      !CU_add_test(pSuite, \"session_recv_headers_with_priority\",\n                   test_nghttp2_session_recv_headers_with_priority) ||\n      !CU_add_test(pSuite, \"session_recv_headers_with_padding\",\n                   test_nghttp2_session_recv_headers_with_padding) ||\n      !CU_add_test(pSuite, \"session_recv_headers_early_response\",\n                   test_nghttp2_session_recv_headers_early_response) ||\n      !CU_add_test(pSuite, \"session_recv_headers_for_closed_stream\",\n                   test_nghttp2_session_recv_headers_for_closed_stream) ||\n      !CU_add_test(pSuite, \"session_server_recv_push_response\",\n                   test_nghttp2_session_server_recv_push_response) ||\n      !CU_add_test(pSuite, \"session_recv_premature_headers\",\n                   test_nghttp2_session_recv_premature_headers) ||\n      !CU_add_test(pSuite, \"session_recv_unknown_frame\",\n                   test_nghttp2_session_recv_unknown_frame) ||\n      !CU_add_test(pSuite, \"session_recv_unexpected_continuation\",\n                   test_nghttp2_session_recv_unexpected_continuation) ||\n      !CU_add_test(pSuite, \"session_recv_settings_header_table_size\",\n                   test_nghttp2_session_recv_settings_header_table_size) ||\n      !CU_add_test(pSuite, \"session_recv_too_large_frame_length\",\n                   test_nghttp2_session_recv_too_large_frame_length) ||\n      !CU_add_test(pSuite, \"session_recv_extension\",\n                   test_nghttp2_session_recv_extension) ||\n      !CU_add_test(pSuite, \"session_recv_altsvc\",\n                   test_nghttp2_session_recv_altsvc) ||\n      !CU_add_test(pSuite, \"session_recv_origin\",\n                   test_nghttp2_session_recv_origin) ||\n      !CU_add_test(pSuite, \"session_continue\", test_nghttp2_session_continue) ||\n      !CU_add_test(pSuite, \"session_add_frame\",\n                   test_nghttp2_session_add_frame) ||\n      !CU_add_test(pSuite, \"session_on_request_headers_received\",\n                   test_nghttp2_session_on_request_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_response_headers_received\",\n                   test_nghttp2_session_on_response_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_headers_received\",\n                   test_nghttp2_session_on_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_push_response_headers_received\",\n                   test_nghttp2_session_on_push_response_headers_received) ||\n      !CU_add_test(pSuite, \"session_on_priority_received\",\n                   test_nghttp2_session_on_priority_received) ||\n      !CU_add_test(pSuite, \"session_on_rst_stream_received\",\n                   test_nghttp2_session_on_rst_stream_received) ||\n      !CU_add_test(pSuite, \"session_on_settings_received\",\n                   test_nghttp2_session_on_settings_received) ||\n      !CU_add_test(pSuite, \"session_on_push_promise_received\",\n                   test_nghttp2_session_on_push_promise_received) ||\n      !CU_add_test(pSuite, \"session_on_ping_received\",\n                   test_nghttp2_session_on_ping_received) ||\n      !CU_add_test(pSuite, \"session_on_goaway_received\",\n                   test_nghttp2_session_on_goaway_received) ||\n      !CU_add_test(pSuite, \"session_on_window_update_received\",\n                   test_nghttp2_session_on_window_update_received) ||\n      !CU_add_test(pSuite, \"session_on_data_received\",\n                   test_nghttp2_session_on_data_received) ||\n      !CU_add_test(pSuite, \"session_on_data_received_fail_fast\",\n                   test_nghttp2_session_on_data_received_fail_fast) ||\n      !CU_add_test(pSuite, \"session_on_altsvc_received\",\n                   test_nghttp2_session_on_altsvc_received) ||\n      !CU_add_test(pSuite, \"session_send_headers_start_stream\",\n                   test_nghttp2_session_send_headers_start_stream) ||\n      !CU_add_test(pSuite, \"session_send_headers_reply\",\n                   test_nghttp2_session_send_headers_reply) ||\n      !CU_add_test(pSuite, \"session_send_headers_frame_size_error\",\n                   test_nghttp2_session_send_headers_frame_size_error) ||\n      !CU_add_test(pSuite, \"session_send_headers_push_reply\",\n                   test_nghttp2_session_send_headers_push_reply) ||\n      !CU_add_test(pSuite, \"session_send_rst_stream\",\n                   test_nghttp2_session_send_rst_stream) ||\n      !CU_add_test(pSuite, \"session_send_push_promise\",\n                   test_nghttp2_session_send_push_promise) ||\n      !CU_add_test(pSuite, \"session_is_my_stream_id\",\n                   test_nghttp2_session_is_my_stream_id) ||\n      !CU_add_test(pSuite, \"session_upgrade2\", test_nghttp2_session_upgrade2) ||\n      !CU_add_test(pSuite, \"session_reprioritize_stream\",\n                   test_nghttp2_session_reprioritize_stream) ||\n      !CU_add_test(\n          pSuite, \"session_reprioritize_stream_with_idle_stream_dep\",\n          test_nghttp2_session_reprioritize_stream_with_idle_stream_dep) ||\n      !CU_add_test(pSuite, \"submit_data\", test_nghttp2_submit_data) ||\n      !CU_add_test(pSuite, \"submit_data_read_length_too_large\",\n                   test_nghttp2_submit_data_read_length_too_large) ||\n      !CU_add_test(pSuite, \"submit_data_read_length_smallest\",\n                   test_nghttp2_submit_data_read_length_smallest) ||\n      !CU_add_test(pSuite, \"submit_data_twice\",\n                   test_nghttp2_submit_data_twice) ||\n      !CU_add_test(pSuite, \"submit_request_with_data\",\n                   test_nghttp2_submit_request_with_data) ||\n      !CU_add_test(pSuite, \"submit_request_without_data\",\n                   test_nghttp2_submit_request_without_data) ||\n      !CU_add_test(pSuite, \"submit_response_with_data\",\n                   test_nghttp2_submit_response_with_data) ||\n      !CU_add_test(pSuite, \"submit_response_without_data\",\n                   test_nghttp2_submit_response_without_data) ||\n      !CU_add_test(pSuite, \"Submit_response_push_response\",\n                   test_nghttp2_submit_response_push_response) ||\n      !CU_add_test(pSuite, \"submit_trailer\", test_nghttp2_submit_trailer) ||\n      !CU_add_test(pSuite, \"submit_headers_start_stream\",\n                   test_nghttp2_submit_headers_start_stream) ||\n      !CU_add_test(pSuite, \"submit_headers_reply\",\n                   test_nghttp2_submit_headers_reply) ||\n      !CU_add_test(pSuite, \"submit_headers_push_reply\",\n                   test_nghttp2_submit_headers_push_reply) ||\n      !CU_add_test(pSuite, \"submit_headers\", test_nghttp2_submit_headers) ||\n      !CU_add_test(pSuite, \"submit_headers_continuation\",\n                   test_nghttp2_submit_headers_continuation) ||\n      !CU_add_test(pSuite, \"submit_headers_continuation_extra_large\",\n                   test_nghttp2_submit_headers_continuation_extra_large) ||\n      !CU_add_test(pSuite, \"submit_priority\", test_nghttp2_submit_priority) ||\n      !CU_add_test(pSuite, \"session_submit_settings\",\n                   test_nghttp2_submit_settings) ||\n      !CU_add_test(pSuite, \"session_submit_settings_update_local_window_size\",\n                   test_nghttp2_submit_settings_update_local_window_size) ||\n      !CU_add_test(pSuite, \"session_submit_settings_multiple_times\",\n                   test_nghttp2_submit_settings_multiple_times) ||\n      !CU_add_test(pSuite, \"session_submit_push_promise\",\n                   test_nghttp2_submit_push_promise) ||\n      !CU_add_test(pSuite, \"submit_window_update\",\n                   test_nghttp2_submit_window_update) ||\n      !CU_add_test(pSuite, \"submit_window_update_local_window_size\",\n                   test_nghttp2_submit_window_update_local_window_size) ||\n      !CU_add_test(pSuite, \"submit_shutdown_notice\",\n                   test_nghttp2_submit_shutdown_notice) ||\n      !CU_add_test(pSuite, \"submit_invalid_nv\",\n                   test_nghttp2_submit_invalid_nv) ||\n      !CU_add_test(pSuite, \"submit_extension\", test_nghttp2_submit_extension) ||\n      !CU_add_test(pSuite, \"submit_altsvc\", test_nghttp2_submit_altsvc) ||\n      !CU_add_test(pSuite, \"submit_origin\", test_nghttp2_submit_origin) ||\n      !CU_add_test(pSuite, \"session_open_stream\",\n                   test_nghttp2_session_open_stream) ||\n      !CU_add_test(pSuite, \"session_open_stream_with_idle_stream_dep\",\n                   test_nghttp2_session_open_stream_with_idle_stream_dep) ||\n      !CU_add_test(pSuite, \"session_get_next_ob_item\",\n                   test_nghttp2_session_get_next_ob_item) ||\n      !CU_add_test(pSuite, \"session_pop_next_ob_item\",\n                   test_nghttp2_session_pop_next_ob_item) ||\n      !CU_add_test(pSuite, \"session_reply_fail\",\n                   test_nghttp2_session_reply_fail) ||\n      !CU_add_test(pSuite, \"session_max_concurrent_streams\",\n                   test_nghttp2_session_max_concurrent_streams) ||\n      !CU_add_test(pSuite, \"session_stop_data_with_rst_stream\",\n                   test_nghttp2_session_stop_data_with_rst_stream) ||\n      !CU_add_test(pSuite, \"session_defer_data\",\n                   test_nghttp2_session_defer_data) ||\n      !CU_add_test(pSuite, \"session_flow_control\",\n                   test_nghttp2_session_flow_control) ||\n      !CU_add_test(pSuite, \"session_flow_control_data_recv\",\n                   test_nghttp2_session_flow_control_data_recv) ||\n      !CU_add_test(pSuite, \"session_flow_control_data_with_padding_recv\",\n                   test_nghttp2_session_flow_control_data_with_padding_recv) ||\n      !CU_add_test(pSuite, \"session_data_read_temporal_failure\",\n                   test_nghttp2_session_data_read_temporal_failure) ||\n      !CU_add_test(pSuite, \"session_on_stream_close\",\n                   test_nghttp2_session_on_stream_close) ||\n      !CU_add_test(pSuite, \"session_on_ctrl_not_send\",\n                   test_nghttp2_session_on_ctrl_not_send) ||\n      !CU_add_test(pSuite, \"session_get_outbound_queue_size\",\n                   test_nghttp2_session_get_outbound_queue_size) ||\n      !CU_add_test(pSuite, \"session_get_effective_local_window_size\",\n                   test_nghttp2_session_get_effective_local_window_size) ||\n      !CU_add_test(pSuite, \"session_set_option\",\n                   test_nghttp2_session_set_option) ||\n      !CU_add_test(pSuite, \"session_data_backoff_by_high_pri_frame\",\n                   test_nghttp2_session_data_backoff_by_high_pri_frame) ||\n      !CU_add_test(pSuite, \"session_pack_data_with_padding\",\n                   test_nghttp2_session_pack_data_with_padding) ||\n      !CU_add_test(pSuite, \"session_pack_headers_with_padding\",\n                   test_nghttp2_session_pack_headers_with_padding) ||\n      !CU_add_test(pSuite, \"pack_settings_payload\",\n                   test_nghttp2_pack_settings_payload) ||\n      !CU_add_test(pSuite, \"session_stream_dep_add\",\n                   test_nghttp2_session_stream_dep_add) ||\n      !CU_add_test(pSuite, \"session_stream_dep_remove\",\n                   test_nghttp2_session_stream_dep_remove) ||\n      !CU_add_test(pSuite, \"session_stream_dep_add_subtree\",\n                   test_nghttp2_session_stream_dep_add_subtree) ||\n      !CU_add_test(pSuite, \"session_stream_dep_remove_subtree\",\n                   test_nghttp2_session_stream_dep_remove_subtree) ||\n      !CU_add_test(\n          pSuite, \"session_stream_dep_all_your_stream_are_belong_to_us\",\n          test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us) ||\n      !CU_add_test(pSuite, \"session_stream_attach_item\",\n                   test_nghttp2_session_stream_attach_item) ||\n      !CU_add_test(pSuite, \"session_stream_attach_item_subtree\",\n                   test_nghttp2_session_stream_attach_item_subtree) ||\n      !CU_add_test(pSuite, \"session_stream_get_state\",\n                   test_nghttp2_session_stream_get_state) ||\n      !CU_add_test(pSuite, \"session_stream_get_something\",\n                   test_nghttp2_session_stream_get_something) ||\n      !CU_add_test(pSuite, \"session_find_stream\",\n                   test_nghttp2_session_find_stream) ||\n      !CU_add_test(pSuite, \"session_keep_closed_stream\",\n                   test_nghttp2_session_keep_closed_stream) ||\n      !CU_add_test(pSuite, \"session_keep_idle_stream\",\n                   test_nghttp2_session_keep_idle_stream) ||\n      !CU_add_test(pSuite, \"session_detach_idle_stream\",\n                   test_nghttp2_session_detach_idle_stream) ||\n      !CU_add_test(pSuite, \"session_large_dep_tree\",\n                   test_nghttp2_session_large_dep_tree) ||\n      !CU_add_test(pSuite, \"session_graceful_shutdown\",\n                   test_nghttp2_session_graceful_shutdown) ||\n      !CU_add_test(pSuite, \"session_on_header_temporal_failure\",\n                   test_nghttp2_session_on_header_temporal_failure) ||\n      !CU_add_test(pSuite, \"session_recv_client_magic\",\n                   test_nghttp2_session_recv_client_magic) ||\n      !CU_add_test(pSuite, \"session_delete_data_item\",\n                   test_nghttp2_session_delete_data_item) ||\n      !CU_add_test(pSuite, \"session_open_idle_stream\",\n                   test_nghttp2_session_open_idle_stream) ||\n      !CU_add_test(pSuite, \"session_cancel_reserved_remote\",\n                   test_nghttp2_session_cancel_reserved_remote) ||\n      !CU_add_test(pSuite, \"session_reset_pending_headers\",\n                   test_nghttp2_session_reset_pending_headers) ||\n      !CU_add_test(pSuite, \"session_send_data_callback\",\n                   test_nghttp2_session_send_data_callback) ||\n      !CU_add_test(pSuite, \"session_on_begin_headers_temporal_failure\",\n                   test_nghttp2_session_on_begin_headers_temporal_failure) ||\n      !CU_add_test(pSuite, \"session_defer_then_close\",\n                   test_nghttp2_session_defer_then_close) ||\n      !CU_add_test(pSuite, \"session_detach_item_from_closed_stream\",\n                   test_nghttp2_session_detach_item_from_closed_stream) ||\n      !CU_add_test(pSuite, \"session_flooding\", test_nghttp2_session_flooding) ||\n      !CU_add_test(pSuite, \"session_change_stream_priority\",\n                   test_nghttp2_session_change_stream_priority) ||\n      !CU_add_test(pSuite, \"session_create_idle_stream\",\n                   test_nghttp2_session_create_idle_stream) ||\n      !CU_add_test(pSuite, \"session_repeated_priority_change\",\n                   test_nghttp2_session_repeated_priority_change) ||\n      !CU_add_test(pSuite, \"session_repeated_priority_submission\",\n                   test_nghttp2_session_repeated_priority_submission) ||\n      !CU_add_test(pSuite, \"session_set_local_window_size\",\n                   test_nghttp2_session_set_local_window_size) ||\n      !CU_add_test(pSuite, \"session_cancel_from_before_frame_send\",\n                   test_nghttp2_session_cancel_from_before_frame_send) ||\n      !CU_add_test(pSuite, \"session_too_many_settings\",\n                   test_nghttp2_session_too_many_settings) ||\n      !CU_add_test(pSuite, \"session_removed_closed_stream\",\n                   test_nghttp2_session_removed_closed_stream) ||\n      !CU_add_test(pSuite, \"session_pause_data\",\n                   test_nghttp2_session_pause_data) ||\n      !CU_add_test(pSuite, \"session_no_closed_streams\",\n                   test_nghttp2_session_no_closed_streams) ||\n      !CU_add_test(pSuite, \"session_set_stream_user_data\",\n                   test_nghttp2_session_set_stream_user_data) ||\n      !CU_add_test(pSuite, \"http_mandatory_headers\",\n                   test_nghttp2_http_mandatory_headers) ||\n      !CU_add_test(pSuite, \"http_content_length\",\n                   test_nghttp2_http_content_length) ||\n      !CU_add_test(pSuite, \"http_content_length_mismatch\",\n                   test_nghttp2_http_content_length_mismatch) ||\n      !CU_add_test(pSuite, \"http_non_final_response\",\n                   test_nghttp2_http_non_final_response) ||\n      !CU_add_test(pSuite, \"http_trailer_headers\",\n                   test_nghttp2_http_trailer_headers) ||\n      !CU_add_test(pSuite, \"http_ignore_regular_header\",\n                   test_nghttp2_http_ignore_regular_header) ||\n      !CU_add_test(pSuite, \"http_ignore_content_length\",\n                   test_nghttp2_http_ignore_content_length) ||\n      !CU_add_test(pSuite, \"http_record_request_method\",\n                   test_nghttp2_http_record_request_method) ||\n      !CU_add_test(pSuite, \"http_push_promise\",\n                   test_nghttp2_http_push_promise) ||\n      !CU_add_test(pSuite, \"http_head_method_upgrade_workaround\",\n                   test_nghttp2_http_head_method_upgrade_workaround) ||\n      !CU_add_test(pSuite, \"frame_pack_headers\",\n                   test_nghttp2_frame_pack_headers) ||\n      !CU_add_test(pSuite, \"frame_pack_headers_frame_too_large\",\n                   test_nghttp2_frame_pack_headers_frame_too_large) ||\n      !CU_add_test(pSuite, \"frame_pack_priority\",\n                   test_nghttp2_frame_pack_priority) ||\n      !CU_add_test(pSuite, \"frame_pack_rst_stream\",\n                   test_nghttp2_frame_pack_rst_stream) ||\n      !CU_add_test(pSuite, \"frame_pack_settings\",\n                   test_nghttp2_frame_pack_settings) ||\n      !CU_add_test(pSuite, \"frame_pack_push_promise\",\n                   test_nghttp2_frame_pack_push_promise) ||\n      !CU_add_test(pSuite, \"frame_pack_ping\", test_nghttp2_frame_pack_ping) ||\n      !CU_add_test(pSuite, \"frame_pack_goaway\",\n                   test_nghttp2_frame_pack_goaway) ||\n      !CU_add_test(pSuite, \"frame_pack_window_update\",\n                   test_nghttp2_frame_pack_window_update) ||\n      !CU_add_test(pSuite, \"frame_pack_altsvc\",\n                   test_nghttp2_frame_pack_altsvc) ||\n      !CU_add_test(pSuite, \"frame_pack_origin\",\n                   test_nghttp2_frame_pack_origin) ||\n      !CU_add_test(pSuite, \"nv_array_copy\", test_nghttp2_nv_array_copy) ||\n      !CU_add_test(pSuite, \"iv_check\", test_nghttp2_iv_check) ||\n      !CU_add_test(pSuite, \"hd_deflate\", test_nghttp2_hd_deflate) ||\n      !CU_add_test(pSuite, \"hd_deflate_same_indexed_repr\",\n                   test_nghttp2_hd_deflate_same_indexed_repr) ||\n      !CU_add_test(pSuite, \"hd_inflate_indexed\",\n                   test_nghttp2_hd_inflate_indexed) ||\n      !CU_add_test(pSuite, \"hd_inflate_indname_noinc\",\n                   test_nghttp2_hd_inflate_indname_noinc) ||\n      !CU_add_test(pSuite, \"hd_inflate_indname_inc\",\n                   test_nghttp2_hd_inflate_indname_inc) ||\n      !CU_add_test(pSuite, \"hd_inflate_indname_inc_eviction\",\n                   test_nghttp2_hd_inflate_indname_inc_eviction) ||\n      !CU_add_test(pSuite, \"hd_inflate_newname_noinc\",\n                   test_nghttp2_hd_inflate_newname_noinc) ||\n      !CU_add_test(pSuite, \"hd_inflate_newname_inc\",\n                   test_nghttp2_hd_inflate_newname_inc) ||\n      !CU_add_test(pSuite, \"hd_inflate_clearall_inc\",\n                   test_nghttp2_hd_inflate_clearall_inc) ||\n      !CU_add_test(pSuite, \"hd_inflate_zero_length_huffman\",\n                   test_nghttp2_hd_inflate_zero_length_huffman) ||\n      !CU_add_test(pSuite, \"hd_inflate_expect_table_size_update\",\n                   test_nghttp2_hd_inflate_expect_table_size_update) ||\n      !CU_add_test(pSuite, \"hd_inflate_unexpected_table_size_update\",\n                   test_nghttp2_hd_inflate_unexpected_table_size_update) ||\n      !CU_add_test(pSuite, \"hd_ringbuf_reserve\",\n                   test_nghttp2_hd_ringbuf_reserve) ||\n      !CU_add_test(pSuite, \"hd_change_table_size\",\n                   test_nghttp2_hd_change_table_size) ||\n      !CU_add_test(pSuite, \"hd_deflate_inflate\",\n                   test_nghttp2_hd_deflate_inflate) ||\n      !CU_add_test(pSuite, \"hd_no_index\", test_nghttp2_hd_no_index) ||\n      !CU_add_test(pSuite, \"hd_deflate_bound\", test_nghttp2_hd_deflate_bound) ||\n      !CU_add_test(pSuite, \"hd_public_api\", test_nghttp2_hd_public_api) ||\n      !CU_add_test(pSuite, \"hd_deflate_hd_vec\",\n                   test_nghttp2_hd_deflate_hd_vec) ||\n      !CU_add_test(pSuite, \"hd_decode_length\", test_nghttp2_hd_decode_length) ||\n      !CU_add_test(pSuite, \"hd_huff_encode\", test_nghttp2_hd_huff_encode) ||\n      !CU_add_test(pSuite, \"hd_huff_decode\", test_nghttp2_hd_huff_decode) ||\n      !CU_add_test(pSuite, \"adjust_local_window_size\",\n                   test_nghttp2_adjust_local_window_size) ||\n      !CU_add_test(pSuite, \"check_header_name\",\n                   test_nghttp2_check_header_name) ||\n      !CU_add_test(pSuite, \"check_header_value\",\n                   test_nghttp2_check_header_value) ||\n      !CU_add_test(pSuite, \"bufs_add\", test_nghttp2_bufs_add) ||\n      !CU_add_test(pSuite, \"bufs_add_stack_buffer_overflow_bug\",\n                   test_nghttp2_bufs_add_stack_buffer_overflow_bug) ||\n      !CU_add_test(pSuite, \"bufs_addb\", test_nghttp2_bufs_addb) ||\n      !CU_add_test(pSuite, \"bufs_orb\", test_nghttp2_bufs_orb) ||\n      !CU_add_test(pSuite, \"bufs_remove\", test_nghttp2_bufs_remove) ||\n      !CU_add_test(pSuite, \"bufs_reset\", test_nghttp2_bufs_reset) ||\n      !CU_add_test(pSuite, \"bufs_advance\", test_nghttp2_bufs_advance) ||\n      !CU_add_test(pSuite, \"bufs_next_present\",\n                   test_nghttp2_bufs_next_present) ||\n      !CU_add_test(pSuite, \"bufs_realloc\", test_nghttp2_bufs_realloc)) {\n    CU_cleanup_registry();\n    return (int)CU_get_error();\n  }\n\n  /* Run all tests using the CUnit Basic interface */\n  CU_basic_set_mode(CU_BRM_VERBOSE);\n  CU_basic_run_tests();\n  num_tests_failed = CU_get_number_of_tests_failed();\n  CU_cleanup_registry();\n  if (CU_get_error() == CUE_SUCCESS) {\n    return (int)num_tests_failed;\n  } else {\n    printf(\"CUnit Error: %s\\n\", CU_get_error_msg());\n    return (int)CU_get_error();\n  }\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2013 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"nghttp2_session_test.h\"\n\n#include <stdio.h>\n#include <assert.h>\n\n#include <CUnit/CUnit.h>\n\n#include \"nghttp2_session.h\"\n#include \"nghttp2_stream.h\"\n#include \"nghttp2_net.h\"\n#include \"nghttp2_helper.h\"\n#include \"nghttp2_test_helper.h\"\n#include \"nghttp2_priority_spec.h\"\n\ntypedef struct {\n  uint8_t buf[65535];\n  size_t length;\n} accumulator;\n\ntypedef struct {\n  uint8_t data[8192];\n  uint8_t *datamark;\n  uint8_t *datalimit;\n  size_t feedseq[8192];\n  size_t seqidx;\n} scripted_data_feed;\n\ntypedef struct {\n  accumulator *acc;\n  scripted_data_feed *df;\n  int frame_recv_cb_called, invalid_frame_recv_cb_called;\n  uint8_t recv_frame_type;\n  nghttp2_frame_hd recv_frame_hd;\n  int frame_send_cb_called;\n  uint8_t sent_frame_type;\n  int before_frame_send_cb_called;\n  int frame_not_send_cb_called;\n  uint8_t not_sent_frame_type;\n  int not_sent_error;\n  int stream_close_cb_called;\n  uint32_t stream_close_error_code;\n  size_t data_source_length;\n  int32_t stream_id;\n  size_t block_count;\n  int data_chunk_recv_cb_called;\n  const nghttp2_frame *frame;\n  size_t fixed_sendlen;\n  int header_cb_called;\n  int invalid_header_cb_called;\n  int begin_headers_cb_called;\n  nghttp2_nv nv;\n  size_t data_chunk_len;\n  size_t padlen;\n  int begin_frame_cb_called;\n  nghttp2_buf scratchbuf;\n  size_t data_source_read_cb_paused;\n} my_user_data;\n\nstatic const nghttp2_nv reqnv[] = {\n    MAKE_NV(\":method\", \"GET\"),\n    MAKE_NV(\":path\", \"/\"),\n    MAKE_NV(\":scheme\", \"https\"),\n    MAKE_NV(\":authority\", \"localhost\"),\n};\n\nstatic const nghttp2_nv resnv[] = {\n    MAKE_NV(\":status\", \"200\"),\n};\n\nstatic const nghttp2_nv trailernv[] = {\n    // from http://tools.ietf.org/html/rfc6249#section-7\n    MAKE_NV(\"digest\", \"SHA-256=\"\n                      \"MWVkMWQxYTRiMzk5MDQ0MzI3NGU5NDEyZTk5OWY1ZGFmNzgyZTJlODYz\"\n                      \"YjRjYzFhOTlmNTQwYzI2M2QwM2U2MQ==\"),\n};\n\nstatic void scripted_data_feed_init2(scripted_data_feed *df,\n                                     nghttp2_bufs *bufs) {\n  nghttp2_buf_chain *ci;\n  nghttp2_buf *buf;\n  uint8_t *ptr;\n  size_t len;\n\n  memset(df, 0, sizeof(scripted_data_feed));\n  ptr = df->data;\n  len = 0;\n\n  for (ci = bufs->head; ci; ci = ci->next) {\n    buf = &ci->buf;\n    ptr = nghttp2_cpymem(ptr, buf->pos, nghttp2_buf_len(buf));\n    len += nghttp2_buf_len(buf);\n  }\n\n  df->datamark = df->data;\n  df->datalimit = df->data + len;\n  df->feedseq[0] = len;\n}\n\nstatic ssize_t null_send_callback(nghttp2_session *session, const uint8_t *data,\n                                  size_t len, int flags, void *user_data) {\n  (void)session;\n  (void)data;\n  (void)flags;\n  (void)user_data;\n\n  return (ssize_t)len;\n}\n\nstatic ssize_t fail_send_callback(nghttp2_session *session, const uint8_t *data,\n                                  size_t len, int flags, void *user_data) {\n  (void)session;\n  (void)data;\n  (void)len;\n  (void)flags;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nstatic ssize_t fixed_bytes_send_callback(nghttp2_session *session,\n                                         const uint8_t *data, size_t len,\n                                         int flags, void *user_data) {\n  size_t fixed_sendlen = ((my_user_data *)user_data)->fixed_sendlen;\n  (void)session;\n  (void)data;\n  (void)flags;\n\n  return (ssize_t)(fixed_sendlen < len ? fixed_sendlen : len);\n}\n\nstatic ssize_t scripted_recv_callback(nghttp2_session *session, uint8_t *data,\n                                      size_t len, int flags, void *user_data) {\n  scripted_data_feed *df = ((my_user_data *)user_data)->df;\n  size_t wlen = df->feedseq[df->seqidx] > len ? len : df->feedseq[df->seqidx];\n  (void)session;\n  (void)flags;\n\n  memcpy(data, df->datamark, wlen);\n  df->datamark += wlen;\n  df->feedseq[df->seqidx] -= wlen;\n  if (df->feedseq[df->seqidx] == 0) {\n    ++df->seqidx;\n  }\n  return (ssize_t)wlen;\n}\n\nstatic ssize_t eof_recv_callback(nghttp2_session *session, uint8_t *data,\n                                 size_t len, int flags, void *user_data) {\n  (void)session;\n  (void)data;\n  (void)len;\n  (void)flags;\n  (void)user_data;\n\n  return NGHTTP2_ERR_EOF;\n}\n\nstatic ssize_t accumulator_send_callback(nghttp2_session *session,\n                                         const uint8_t *buf, size_t len,\n                                         int flags, void *user_data) {\n  accumulator *acc = ((my_user_data *)user_data)->acc;\n  (void)session;\n  (void)flags;\n\n  assert(acc->length + len < sizeof(acc->buf));\n  memcpy(acc->buf + acc->length, buf, len);\n  acc->length += len;\n  return (ssize_t)len;\n}\n\nstatic int on_begin_frame_callback(nghttp2_session *session,\n                                   const nghttp2_frame_hd *hd,\n                                   void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)hd;\n\n  ++ud->begin_frame_cb_called;\n  return 0;\n}\n\nstatic int on_frame_recv_callback(nghttp2_session *session,\n                                  const nghttp2_frame *frame, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  ++ud->frame_recv_cb_called;\n  ud->recv_frame_type = frame->hd.type;\n  ud->recv_frame_hd = frame->hd;\n\n  return 0;\n}\n\nstatic int on_invalid_frame_recv_callback(nghttp2_session *session,\n                                          const nghttp2_frame *frame,\n                                          int lib_error_code, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)frame;\n  (void)lib_error_code;\n\n  ++ud->invalid_frame_recv_cb_called;\n  return 0;\n}\n\nstatic int on_frame_send_callback(nghttp2_session *session,\n                                  const nghttp2_frame *frame, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  ++ud->frame_send_cb_called;\n  ud->sent_frame_type = frame->hd.type;\n  return 0;\n}\n\nstatic int on_frame_not_send_callback(nghttp2_session *session,\n                                      const nghttp2_frame *frame, int lib_error,\n                                      void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  ++ud->frame_not_send_cb_called;\n  ud->not_sent_frame_type = frame->hd.type;\n  ud->not_sent_error = lib_error;\n  return 0;\n}\n\nstatic int cancel_before_frame_send_callback(nghttp2_session *session,\n                                             const nghttp2_frame *frame,\n                                             void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)frame;\n\n  ++ud->before_frame_send_cb_called;\n  return NGHTTP2_ERR_CANCEL;\n}\n\nstatic int on_data_chunk_recv_callback(nghttp2_session *session, uint8_t flags,\n                                       int32_t stream_id, const uint8_t *data,\n                                       size_t len, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n  (void)stream_id;\n  (void)data;\n\n  ++ud->data_chunk_recv_cb_called;\n  ud->data_chunk_len = len;\n  return 0;\n}\n\nstatic int pause_on_data_chunk_recv_callback(nghttp2_session *session,\n                                             uint8_t flags, int32_t stream_id,\n                                             const uint8_t *data, size_t len,\n                                             void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n  (void)stream_id;\n  (void)data;\n  (void)len;\n\n  ++ud->data_chunk_recv_cb_called;\n  return NGHTTP2_ERR_PAUSE;\n}\n\nstatic ssize_t select_padding_callback(nghttp2_session *session,\n                                       const nghttp2_frame *frame,\n                                       size_t max_payloadlen, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n\n  return (ssize_t)nghttp2_min(max_payloadlen, frame->hd.length + ud->padlen);\n}\n\nstatic ssize_t too_large_data_source_length_callback(\n    nghttp2_session *session, uint8_t frame_type, int32_t stream_id,\n    int32_t session_remote_window_size, int32_t stream_remote_window_size,\n    uint32_t remote_max_frame_size, void *user_data) {\n  (void)session;\n  (void)frame_type;\n  (void)stream_id;\n  (void)session_remote_window_size;\n  (void)stream_remote_window_size;\n  (void)remote_max_frame_size;\n  (void)user_data;\n\n  return NGHTTP2_MAX_FRAME_SIZE_MAX + 1;\n}\n\nstatic ssize_t smallest_length_data_source_length_callback(\n    nghttp2_session *session, uint8_t frame_type, int32_t stream_id,\n    int32_t session_remote_window_size, int32_t stream_remote_window_size,\n    uint32_t remote_max_frame_size, void *user_data) {\n  (void)session;\n  (void)frame_type;\n  (void)stream_id;\n  (void)session_remote_window_size;\n  (void)stream_remote_window_size;\n  (void)remote_max_frame_size;\n  (void)user_data;\n\n  return 1;\n}\n\nstatic ssize_t fixed_length_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  size_t wlen;\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)source;\n\n  if (len < ud->data_source_length) {\n    wlen = len;\n  } else {\n    wlen = ud->data_source_length;\n  }\n  ud->data_source_length -= wlen;\n  if (ud->data_source_length == 0) {\n    *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n  }\n  return (ssize_t)wlen;\n}\n\nstatic ssize_t temporal_failure_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)data_flags;\n  (void)source;\n  (void)user_data;\n\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic ssize_t fail_data_source_read_callback(nghttp2_session *session,\n                                              int32_t stream_id, uint8_t *buf,\n                                              size_t len, uint32_t *data_flags,\n                                              nghttp2_data_source *source,\n                                              void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)data_flags;\n  (void)source;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nstatic ssize_t no_end_stream_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)source;\n  (void)user_data;\n\n  *data_flags |= NGHTTP2_DATA_FLAG_EOF | NGHTTP2_DATA_FLAG_NO_END_STREAM;\n  return 0;\n}\n\nstatic ssize_t no_copy_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  size_t wlen;\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)source;\n\n  if (len < ud->data_source_length) {\n    wlen = len;\n  } else {\n    wlen = ud->data_source_length;\n  }\n\n  ud->data_source_length -= wlen;\n\n  *data_flags |= NGHTTP2_DATA_FLAG_NO_COPY;\n\n  if (ud->data_source_length == 0) {\n    *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n  }\n  return (ssize_t)wlen;\n}\n\nstatic int send_data_callback(nghttp2_session *session, nghttp2_frame *frame,\n                              const uint8_t *framehd, size_t length,\n                              nghttp2_data_source *source, void *user_data) {\n  accumulator *acc = ((my_user_data *)user_data)->acc;\n  (void)session;\n  (void)source;\n\n  memcpy(acc->buf + acc->length, framehd, NGHTTP2_FRAME_HDLEN);\n  acc->length += NGHTTP2_FRAME_HDLEN;\n\n  if (frame->data.padlen) {\n    *(acc->buf + acc->length++) = (uint8_t)(frame->data.padlen - 1);\n  }\n\n  acc->length += length;\n\n  if (frame->data.padlen) {\n    acc->length += frame->data.padlen - 1;\n  }\n\n  return 0;\n}\n\nstatic ssize_t block_count_send_callback(nghttp2_session *session,\n                                         const uint8_t *data, size_t len,\n                                         int flags, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)data;\n  (void)flags;\n\n  if (ud->block_count == 0) {\n    return NGHTTP2_ERR_WOULDBLOCK;\n  }\n\n  --ud->block_count;\n  return (ssize_t)len;\n}\n\nstatic int on_header_callback(nghttp2_session *session,\n                              const nghttp2_frame *frame, const uint8_t *name,\n                              size_t namelen, const uint8_t *value,\n                              size_t valuelen, uint8_t flags, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n\n  ++ud->header_cb_called;\n  ud->nv.name = (uint8_t *)name;\n  ud->nv.namelen = namelen;\n  ud->nv.value = (uint8_t *)value;\n  ud->nv.valuelen = valuelen;\n\n  ud->frame = frame;\n  return 0;\n}\n\nstatic int pause_on_header_callback(nghttp2_session *session,\n                                    const nghttp2_frame *frame,\n                                    const uint8_t *name, size_t namelen,\n                                    const uint8_t *value, size_t valuelen,\n                                    uint8_t flags, void *user_data) {\n  on_header_callback(session, frame, name, namelen, value, valuelen, flags,\n                     user_data);\n  return NGHTTP2_ERR_PAUSE;\n}\n\nstatic int temporal_failure_on_header_callback(\n    nghttp2_session *session, const nghttp2_frame *frame, const uint8_t *name,\n    size_t namelen, const uint8_t *value, size_t valuelen, uint8_t flags,\n    void *user_data) {\n  on_header_callback(session, frame, name, namelen, value, valuelen, flags,\n                     user_data);\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic int on_invalid_header_callback(nghttp2_session *session,\n                                      const nghttp2_frame *frame,\n                                      const uint8_t *name, size_t namelen,\n                                      const uint8_t *value, size_t valuelen,\n                                      uint8_t flags, void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)flags;\n\n  ++ud->invalid_header_cb_called;\n  ud->nv.name = (uint8_t *)name;\n  ud->nv.namelen = namelen;\n  ud->nv.value = (uint8_t *)value;\n  ud->nv.valuelen = valuelen;\n\n  ud->frame = frame;\n  return 0;\n}\n\nstatic int pause_on_invalid_header_callback(nghttp2_session *session,\n                                            const nghttp2_frame *frame,\n                                            const uint8_t *name, size_t namelen,\n                                            const uint8_t *value,\n                                            size_t valuelen, uint8_t flags,\n                                            void *user_data) {\n  on_invalid_header_callback(session, frame, name, namelen, value, valuelen,\n                             flags, user_data);\n  return NGHTTP2_ERR_PAUSE;\n}\n\nstatic int reset_on_invalid_header_callback(nghttp2_session *session,\n                                            const nghttp2_frame *frame,\n                                            const uint8_t *name, size_t namelen,\n                                            const uint8_t *value,\n                                            size_t valuelen, uint8_t flags,\n                                            void *user_data) {\n  on_invalid_header_callback(session, frame, name, namelen, value, valuelen,\n                             flags, user_data);\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic int on_begin_headers_callback(nghttp2_session *session,\n                                     const nghttp2_frame *frame,\n                                     void *user_data) {\n  my_user_data *ud = (my_user_data *)user_data;\n  (void)session;\n  (void)frame;\n\n  ++ud->begin_headers_cb_called;\n  return 0;\n}\n\nstatic int temporal_failure_on_begin_headers_callback(\n    nghttp2_session *session, const nghttp2_frame *frame, void *user_data) {\n  on_begin_headers_callback(session, frame, user_data);\n  return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n}\n\nstatic ssize_t defer_data_source_read_callback(nghttp2_session *session,\n                                               int32_t stream_id, uint8_t *buf,\n                                               size_t len, uint32_t *data_flags,\n                                               nghttp2_data_source *source,\n                                               void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)len;\n  (void)data_flags;\n  (void)source;\n  (void)user_data;\n\n  return NGHTTP2_ERR_DEFERRED;\n}\n\nstatic int on_stream_close_callback(nghttp2_session *session, int32_t stream_id,\n                                    nghttp2_error_code error_code,\n                                    void *user_data) {\n  my_user_data *my_data = (my_user_data *)user_data;\n  (void)session;\n  (void)stream_id;\n  (void)error_code;\n\n  ++my_data->stream_close_cb_called;\n  my_data->stream_close_error_code = error_code;\n\n  return 0;\n}\n\nstatic ssize_t pack_extension_callback(nghttp2_session *session, uint8_t *buf,\n                                       size_t len, const nghttp2_frame *frame,\n                                       void *user_data) {\n  nghttp2_buf *p = frame->ext.payload;\n  (void)session;\n  (void)len;\n  (void)user_data;\n\n  memcpy(buf, p->pos, nghttp2_buf_len(p));\n\n  return (ssize_t)nghttp2_buf_len(p);\n}\n\nstatic int on_extension_chunk_recv_callback(nghttp2_session *session,\n                                            const nghttp2_frame_hd *hd,\n                                            const uint8_t *data, size_t len,\n                                            void *user_data) {\n  my_user_data *my_data = (my_user_data *)user_data;\n  nghttp2_buf *buf = &my_data->scratchbuf;\n  (void)session;\n  (void)hd;\n\n  buf->last = nghttp2_cpymem(buf->last, data, len);\n\n  return 0;\n}\n\nstatic int cancel_on_extension_chunk_recv_callback(nghttp2_session *session,\n                                                   const nghttp2_frame_hd *hd,\n                                                   const uint8_t *data,\n                                                   size_t len,\n                                                   void *user_data) {\n  (void)session;\n  (void)hd;\n  (void)data;\n  (void)len;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CANCEL;\n}\n\nstatic int unpack_extension_callback(nghttp2_session *session, void **payload,\n                                     const nghttp2_frame_hd *hd,\n                                     void *user_data) {\n  my_user_data *my_data = (my_user_data *)user_data;\n  nghttp2_buf *buf = &my_data->scratchbuf;\n  (void)session;\n  (void)hd;\n\n  *payload = buf;\n\n  return 0;\n}\n\nstatic int cancel_unpack_extension_callback(nghttp2_session *session,\n                                            void **payload,\n                                            const nghttp2_frame_hd *hd,\n                                            void *user_data) {\n  (void)session;\n  (void)payload;\n  (void)hd;\n  (void)user_data;\n\n  return NGHTTP2_ERR_CANCEL;\n}\n\nstatic nghttp2_settings_entry *dup_iv(const nghttp2_settings_entry *iv,\n                                      size_t niv) {\n  return nghttp2_frame_iv_copy(iv, niv, nghttp2_mem_default());\n}\n\nstatic nghttp2_priority_spec pri_spec_default = {0, NGHTTP2_DEFAULT_WEIGHT, 0};\n\nvoid test_nghttp2_session_recv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  scripted_data_feed df;\n  my_user_data user_data;\n  nghttp2_bufs bufs;\n  size_t framelen;\n  nghttp2_frame frame;\n  size_t i;\n  nghttp2_outbound_item *item;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_hd_deflater deflater;\n  int rv;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.recv_callback = scripted_recv_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_begin_frame_callback = on_begin_frame_callback;\n\n  user_data.df = &df;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  scripted_data_feed_init2(&df, &bufs);\n\n  framelen = nghttp2_bufs_len(&bufs);\n\n  /* Send 1 byte per each read */\n  for (i = 0; i < framelen; ++i) {\n    df.feedseq[i] = 1;\n  }\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  user_data.frame_recv_cb_called = 0;\n  user_data.begin_frame_cb_called = 0;\n\n  while (df.seqidx < framelen) {\n    CU_ASSERT(0 == nghttp2_session_recv(session));\n  }\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(1 == user_data.begin_frame_cb_called);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Receive PRIORITY */\n  nghttp2_frame_priority_init(&frame.priority, 5, &pri_spec_default);\n\n  rv = nghttp2_frame_pack_priority(&bufs, &frame.priority);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  scripted_data_feed_init2(&df, &bufs);\n\n  user_data.frame_recv_cb_called = 0;\n  user_data.begin_frame_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(1 == user_data.begin_frame_cb_called);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Some tests for frame too large */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  /* Receive PING with too large payload */\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_NONE, NULL);\n\n  rv = nghttp2_frame_pack_ping(&bufs, &frame.ping);\n\n  CU_ASSERT(0 == rv);\n\n  /* Add extra 16 bytes */\n  nghttp2_bufs_seek_last_present(&bufs);\n  assert(nghttp2_buf_len(&bufs.cur->buf) >= 16);\n\n  bufs.cur->buf.last += 16;\n  nghttp2_put_uint32be(\n      bufs.cur->buf.pos,\n      (uint32_t)(((frame.hd.length + 16) << 8) + bufs.cur->buf.pos[3]));\n\n  nghttp2_frame_ping_free(&frame.ping);\n\n  scripted_data_feed_init2(&df, &bufs);\n  user_data.frame_recv_cb_called = 0;\n  user_data.begin_frame_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(0 == user_data.frame_recv_cb_called);\n  CU_ASSERT(0 == user_data.begin_frame_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FRAME_SIZE_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_invalid_stream_id(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  scripted_data_feed df;\n  my_user_data user_data;\n  nghttp2_bufs bufs;\n  nghttp2_frame frame;\n  nghttp2_hd_deflater deflater;\n  int rv;\n  nghttp2_mem *mem;\n  nghttp2_nv *nva;\n  size_t nvlen;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.recv_callback = scripted_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  user_data.df = &df;\n  user_data.invalid_frame_recv_cb_called = 0;\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  scripted_data_feed_init2(&df, &bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_invalid_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  scripted_data_feed df;\n  my_user_data user_data;\n  nghttp2_bufs bufs;\n  nghttp2_frame frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_hd_deflater deflater;\n  int rv;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.recv_callback = scripted_recv_callback;\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  user_data.df = &df;\n  user_data.frame_send_cb_called = 0;\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  nghttp2_hd_deflate_init(&deflater, mem);\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  scripted_data_feed_init2(&df, &bufs);\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == user_data.frame_send_cb_called);\n\n  /* Receive exactly same bytes of HEADERS is treated as error, because it has\n   * pseudo headers and without END_STREAM flag set */\n  scripted_data_feed_init2(&df, &bufs);\n\n  CU_ASSERT(0 == nghttp2_session_recv(session));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_RST_STREAM == user_data.sent_frame_type);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_eof(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.recv_callback = eof_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  CU_ASSERT(NGHTTP2_ERR_EOF == nghttp2_session_recv(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  uint8_t data[8092];\n  ssize_t rv;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n  nghttp2_frame_hd hd;\n  int i;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_data_chunk_recv_callback = on_data_chunk_recv_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  /* Create DATA frame with length 4KiB */\n  memset(data, 0, sizeof(data));\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  /* stream 1 is not opened, so it must be responded with connection\n     error.  This is not mandated by the spec */\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  /* Create stream 1 with CLOSING state. DATA is ignored. */\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_CLOSING);\n\n  /* Set initial window size 16383 to check stream flow control,\n     isolating it from the connection flow control */\n  stream->local_window_size = 16383;\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NULL == item);\n\n  /* This is normal case. DATA is acceptable. */\n  stream->state = NGHTTP2_STREAM_OPENED;\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(1 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  /* Now we got data more than initial-window-size / 2, WINDOW_UPDATE\n     must be queued */\n  CU_ASSERT(1 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Set initial window size to 1MiB, so that we can check connection\n     flow control individually */\n  stream->local_window_size = 1 << 20;\n  /* Connection flow control takes into account DATA which is received\n     in the error condition. We have received 4096 * 4 bytes of\n     DATA. Additional 4 DATA frames, connection flow control will kick\n     in. */\n  for (i = 0; i < 5; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Reception of DATA with stream ID = 0 causes connection error */\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 0;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  ud.data_chunk_recv_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n\n  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_session_del(session);\n\n  /* Check window_update_queued flag in both session and stream */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  stream = open_recv_stream(session, 1);\n\n  /* Send 32767 bytes of DATA.  In our current flow control algorithm,\n     it triggers first WINDOW_UPDATE of window_size_increment\n     32767. */\n  for (i = 0; i < 7; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n\n  hd.length = 4095;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4095);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4095 == rv);\n\n  /* Now 2 WINDOW_UPDATEs for session and stream should be queued. */\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(1 == stream->window_update_queued);\n  CU_ASSERT(1 == session->window_update_queued);\n\n  /* Then send 32768 bytes of DATA.  Since we have not sent queued\n     WINDOW_UDPATE frame, recv_window_size should not be decreased */\n  hd.length = 4096;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  for (i = 0; i < 8; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n\n  /* WINDOW_UPDATE is blocked for session and stream, so\n     recv_window_size must not be decreased. */\n  CU_ASSERT(32768 == stream->recv_window_size);\n  CU_ASSERT(32768 == session->recv_window_size);\n  CU_ASSERT(1 == stream->window_update_queued);\n  CU_ASSERT(1 == session->window_update_queued);\n\n  ud.frame_send_cb_called = 0;\n\n  /* This sends queued WINDOW_UPDATES.  And then check\n     recv_window_size, and queue WINDOW_UPDATEs for both session and\n     stream, and send them at once. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(4 == ud.frame_send_cb_called);\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(0 == stream->window_update_queued);\n  CU_ASSERT(0 == session->window_update_queued);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_data_no_auto_flow_control(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_option *option;\n  nghttp2_frame_hd hd;\n  size_t padlen;\n  uint8_t data[8192];\n  ssize_t rv;\n  size_t sendlen;\n  nghttp2_stream *stream;\n  size_t i;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  /* Create DATA frame with length 4KiB + 11 bytes padding*/\n  padlen = 11;\n  memset(data, 0, sizeof(data));\n  hd.length = 4096 + 1 + padlen;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_PADDED;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  data[NGHTTP2_FRAME_HDLEN] = (uint8_t)padlen;\n\n  /* First create stream 1, then close it.  Check that data is\n     consumed for connection in this situation */\n  open_recv_stream(session, 1);\n\n  /* Receive first 100 bytes */\n  sendlen = 100;\n  rv = nghttp2_session_mem_recv(session, data, sendlen);\n  CU_ASSERT((ssize_t)sendlen == rv);\n\n  /* We consumed pad length field (1 byte) */\n  CU_ASSERT(1 == session->consumed_size);\n\n  /* close stream here */\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1, NGHTTP2_NO_ERROR);\n  nghttp2_session_send(session);\n\n  /* stream 1 has been closed, and we disabled auto flow-control, so\n     data must be immediately consumed for connection. */\n  rv = nghttp2_session_mem_recv(session, data + sendlen,\n                                NGHTTP2_FRAME_HDLEN + hd.length - sendlen);\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length - sendlen) == rv);\n\n  /* We already consumed pad length field (1 byte), so do +1 here */\n  CU_ASSERT((int32_t)(NGHTTP2_FRAME_HDLEN + hd.length - sendlen + 1) ==\n            session->consumed_size);\n\n  nghttp2_session_del(session);\n\n  /* Reuse DATA created previously. */\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  /* Now we are expecting final response header, which means receiving\n     DATA for that stream is illegal. */\n  stream = open_recv_stream(session, 1);\n  stream->http_flags |= NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE;\n\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + hd.length);\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length) == rv);\n\n  /* Whole payload must be consumed now because HTTP messaging rule\n     was not honored. */\n  CU_ASSERT((int32_t)hd.length == session->consumed_size);\n\n  nghttp2_session_del(session);\n\n  /* Check window_update_queued flag in both session and stream */\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  stream = open_recv_stream(session, 1);\n\n  hd.length = 4096;\n  hd.type = NGHTTP2_DATA;\n  hd.flags = NGHTTP2_FLAG_NONE;\n  hd.stream_id = 1;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  /* Receive up to 65535 bytes of DATA */\n  for (i = 0; i < 15; ++i) {\n    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);\n    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);\n  }\n\n  hd.length = 4095;\n  nghttp2_frame_pack_frame_hd(data, &hd);\n\n  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4095);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4095 == rv);\n\n  CU_ASSERT(65535 == session->recv_window_size);\n  CU_ASSERT(65535 == stream->recv_window_size);\n\n  /* The first call of nghttp2_session_consume_connection() will queue\n     WINDOW_UPDATE.  Next call does not. */\n  nghttp2_session_consume_connection(session, 32767);\n  nghttp2_session_consume_connection(session, 32768);\n\n  CU_ASSERT(32768 == session->recv_window_size);\n  CU_ASSERT(65535 == stream->recv_window_size);\n  CU_ASSERT(1 == session->window_update_queued);\n  CU_ASSERT(0 == stream->window_update_queued);\n\n  ud.frame_send_cb_called = 0;\n\n  /* This will send WINDOW_UPDATE, and check whether we should send\n     WINDOW_UPDATE, and queue and send it at once. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(65535 == stream->recv_window_size);\n  CU_ASSERT(0 == session->window_update_queued);\n  CU_ASSERT(0 == stream->window_update_queued);\n  CU_ASSERT(2 == ud.frame_send_cb_called);\n\n  /* Do the same for stream */\n  nghttp2_session_consume_stream(session, 1, 32767);\n  nghttp2_session_consume_stream(session, 1, 32768);\n\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(32768 == stream->recv_window_size);\n  CU_ASSERT(0 == session->window_update_queued);\n  CU_ASSERT(1 == stream->window_update_queued);\n\n  ud.frame_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == session->window_update_queued);\n  CU_ASSERT(0 == stream->window_update_queued);\n  CU_ASSERT(2 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_recv_continuation(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  uint8_t data[1024];\n  size_t datalen;\n  nghttp2_frame_hd cont_hd;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_header_callback = on_header_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_begin_frame_callback = on_begin_frame_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* Make 1 HEADERS and insert CONTINUATION header */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_NONE, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  /* make sure that all data is in the first buf */\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* HEADERS's payload is 1 byte */\n  memcpy(data, buf->pos, NGHTTP2_FRAME_HDLEN + 1);\n  datalen = NGHTTP2_FRAME_HDLEN + 1;\n  buf->pos += NGHTTP2_FRAME_HDLEN + 1;\n\n  nghttp2_put_uint32be(data, (uint32_t)((1 << 8) + data[3]));\n\n  /* First CONTINUATION, 2 bytes */\n  nghttp2_frame_hd_init(&cont_hd, 2, NGHTTP2_CONTINUATION, NGHTTP2_FLAG_NONE,\n                        1);\n\n  nghttp2_frame_pack_frame_hd(data + datalen, &cont_hd);\n  datalen += NGHTTP2_FRAME_HDLEN;\n\n  memcpy(data + datalen, buf->pos, cont_hd.length);\n  datalen += cont_hd.length;\n  buf->pos += cont_hd.length;\n\n  /* Second CONTINUATION, rest of the bytes */\n  nghttp2_frame_hd_init(&cont_hd, nghttp2_buf_len(buf), NGHTTP2_CONTINUATION,\n                        NGHTTP2_FLAG_END_HEADERS, 1);\n\n  nghttp2_frame_pack_frame_hd(data + datalen, &cont_hd);\n  datalen += NGHTTP2_FRAME_HDLEN;\n\n  memcpy(data + datalen, buf->pos, cont_hd.length);\n  datalen += cont_hd.length;\n  buf->pos += cont_hd.length;\n\n  CU_ASSERT(0 == nghttp2_buf_len(buf));\n\n  ud.header_cb_called = 0;\n  ud.begin_frame_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n  CU_ASSERT((ssize_t)datalen == rv);\n  CU_ASSERT(4 == ud.header_cb_called);\n  CU_ASSERT(3 == ud.begin_frame_cb_called);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* HEADERS with padding followed by CONTINUATION */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_NONE, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n\n  nghttp2_bufs_reset(&bufs);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* make sure that all data is in the first buf */\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  /* HEADERS payload is 3 byte (1 for padding field, 1 for padding) */\n  memcpy(data, buf->pos, NGHTTP2_FRAME_HDLEN);\n  nghttp2_put_uint32be(data, (uint32_t)((3 << 8) + data[3]));\n  data[4] |= NGHTTP2_FLAG_PADDED;\n  /* padding field */\n  data[NGHTTP2_FRAME_HDLEN] = 1;\n  data[NGHTTP2_FRAME_HDLEN + 1] = buf->pos[NGHTTP2_FRAME_HDLEN];\n  /* padding */\n  data[NGHTTP2_FRAME_HDLEN + 2] = 0;\n  datalen = NGHTTP2_FRAME_HDLEN + 3;\n  buf->pos += NGHTTP2_FRAME_HDLEN + 1;\n\n  /* CONTINUATION, rest of the bytes */\n  nghttp2_frame_hd_init(&cont_hd, nghttp2_buf_len(buf), NGHTTP2_CONTINUATION,\n                        NGHTTP2_FLAG_END_HEADERS, 1);\n  nghttp2_frame_pack_frame_hd(data + datalen, &cont_hd);\n  datalen += NGHTTP2_FRAME_HDLEN;\n\n  memcpy(data + datalen, buf->pos, cont_hd.length);\n  datalen += cont_hd.length;\n  buf->pos += cont_hd.length;\n\n  CU_ASSERT(0 == nghttp2_buf_len(buf));\n\n  ud.header_cb_called = 0;\n  ud.begin_frame_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n\n  CU_ASSERT((ssize_t)datalen == rv);\n  CU_ASSERT(4 == ud.header_cb_called);\n  CU_ASSERT(2 == ud.begin_frame_cb_called);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Expecting CONTINUATION, but get the other frame */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* HEADERS without END_HEADERS flag */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_NONE, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  nghttp2_bufs_reset(&bufs);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* make sure that all data is in the first buf */\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  memcpy(data, buf->pos, nghttp2_buf_len(buf));\n  datalen = nghttp2_buf_len(buf);\n\n  /* Followed by PRIORITY */\n  nghttp2_priority_spec_default_init(&pri_spec);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n  nghttp2_bufs_reset(&bufs);\n\n  rv = nghttp2_frame_pack_priority(&bufs, &frame.priority);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  memcpy(data + datalen, buf->pos, nghttp2_buf_len(buf));\n  datalen += nghttp2_buf_len(buf);\n\n  ud.begin_headers_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n  CU_ASSERT((ssize_t)datalen == rv);\n\n  CU_ASSERT(1 == ud.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_GOAWAY ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_headers_with_priority(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  nghttp2_outbound_item *item;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_recv_stream(session, 1);\n\n  /* With NGHTTP2_FLAG_PRIORITY without exclusive flag set */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 99, 0);\n\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             3, NGHTTP2_HCAT_HEADERS, &pri_spec, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 3);\n\n  CU_ASSERT(99 == stream->weight);\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* With NGHTTP2_FLAG_PRIORITY, but cut last 1 byte to make it\n     invalid. */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 99, 0);\n\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             5, NGHTTP2_HCAT_HEADERS, &pri_spec, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > NGHTTP2_FRAME_HDLEN + 5);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  /* Make payload shorter than required length to store priority\n     group */\n  nghttp2_put_uint32be(buf->pos, (uint32_t)((4 << 8) + buf->pos[3]));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 5);\n\n  CU_ASSERT(NULL == stream);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FRAME_SIZE_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Check dep_stream_id == stream_id */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 0, 0);\n\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             1, NGHTTP2_HCAT_HEADERS, &pri_spec, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL == stream);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_headers_with_padding(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  ssize_t rv;\n\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n\n  /* HEADERS: Wrong padding length */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  nghttp2_session_send(session);\n\n  nghttp2_frame_hd_init(&hd, 10, NGHTTP2_HEADERS,\n                        NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY |\n                            NGHTTP2_FLAG_PADDED,\n                        1);\n  buf = &bufs.head->buf;\n  nghttp2_frame_pack_frame_hd(buf->last, &hd);\n  buf->last += NGHTTP2_FRAME_HDLEN;\n  /* padding is 6 bytes */\n  *buf->last++ = 5;\n  /* priority field */\n  nghttp2_put_uint32be(buf->last, 3);\n  buf->last += sizeof(uint32_t);\n  *buf->last++ = 1;\n  /* rest is garbage */\n  memset(buf->last, 0, 4);\n  buf->last += 4;\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_session_del(session);\n\n  /* PUSH_PROMISE: Wrong padding length */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_session_send(session);\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_hd_init(&hd, 9, NGHTTP2_PUSH_PROMISE,\n                        NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED, 1);\n  buf = &bufs.head->buf;\n  nghttp2_frame_pack_frame_hd(buf->last, &hd);\n  buf->last += NGHTTP2_FRAME_HDLEN;\n  /* padding is 6 bytes */\n  *buf->last++ = 5;\n  /* promised stream ID field */\n  nghttp2_put_uint32be(buf->last, 2);\n  buf->last += sizeof(uint32_t);\n  /* rest is garbage */\n  memset(buf->last, 0, 4);\n  buf->last += 4;\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nstatic int response_on_begin_frame_callback(nghttp2_session *session,\n                                            const nghttp2_frame_hd *hd,\n                                            void *user_data) {\n  int rv;\n  (void)user_data;\n\n  if (hd->type != NGHTTP2_HEADERS) {\n    return 0;\n  }\n\n  rv = nghttp2_submit_response(session, hd->stream_id, resnv, ARRLEN(resnv),\n                               NULL);\n\n  CU_ASSERT(0 == rv);\n\n  return 0;\n}\n\nvoid test_nghttp2_session_recv_headers_early_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  ssize_t rv;\n  nghttp2_stream *stream;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_begin_frame_callback = response_on_begin_frame_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                             1, NGHTTP2_HCAT_REQUEST, NULL, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n\n  /* Only receive 9 bytes headers, and invoke\n     on_begin_frame_callback */\n  rv = nghttp2_session_mem_recv(session, buf->pos, 9);\n\n  CU_ASSERT(9 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  rv =\n      nghttp2_session_mem_recv(session, buf->pos + 9, nghttp2_buf_len(buf) - 9);\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) - 9 == rv);\n\n  stream = nghttp2_session_get_stream_raw(session, 1);\n\n  CU_ASSERT(stream->flags & NGHTTP2_STREAM_FLAG_CLOSED);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_recv_headers_for_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n  const uint8_t *data;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_header_callback = on_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* Make sure that on_header callback never be invoked for closed\n     stream */\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, NGHTTP2_FRAME_HDLEN);\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL != stream);\n\n  rv = nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1,\n                                 NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(rv > 0);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL == stream);\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos + NGHTTP2_FRAME_HDLEN,\n                                nghttp2_buf_len(buf) - NGHTTP2_FRAME_HDLEN);\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) - NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_server_recv_push_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_mem *mem;\n  nghttp2_frame frame;\n  nghttp2_hd_deflater deflater;\n  nghttp2_nv *nva;\n  size_t nvlen;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nvlen = ARRLEN(resnv);\n  nghttp2_nv_array_copy(&nva, resnv, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, &pri_spec_default, nva,\n                             nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n\n  ud.invalid_frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_premature_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_hd_deflater deflater;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n  uint32_t payloadlen;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  /* Intentionally feed payload cutting last 1 byte off */\n  payloadlen = nghttp2_get_uint32(buf->pos) >> 8;\n  nghttp2_put_uint32be(buf->pos, ((payloadlen - 1) << 8) + buf->pos[3]);\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf) - 1);\n\n  CU_ASSERT((ssize_t)(nghttp2_buf_len(buf) - 1) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_COMPRESSION_ERROR == item->frame.rst_stream.error_code);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Test for PUSH_PROMISE */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_sent_stream3(session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec_default,\n                    NGHTTP2_STREAM_OPENING, NULL);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  buf = &bufs.head->buf;\n  payloadlen = nghttp2_get_uint32(buf->pos) >> 8;\n  /* Intentionally feed payload cutting last 1 byte off */\n  nghttp2_put_uint32be(buf->pos, ((payloadlen - 1) << 8) + buf->pos[3]);\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf) - 1);\n\n  CU_ASSERT((ssize_t)(nghttp2_buf_len(buf) - 1) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_COMPRESSION_ERROR == item->frame.rst_stream.error_code);\n  CU_ASSERT(2 == item->frame.hd.stream_id);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_recv_unknown_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  uint8_t data[16384];\n  size_t datalen;\n  nghttp2_frame_hd hd;\n  ssize_t rv;\n\n  nghttp2_frame_hd_init(&hd, 16000, 99, NGHTTP2_FLAG_NONE, 0);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  datalen = NGHTTP2_FRAME_HDLEN + hd.length;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  ud.frame_recv_cb_called = 0;\n\n  /* Unknown frame must be ignored */\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n\n  CU_ASSERT(rv == (ssize_t)datalen);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_unexpected_continuation(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  uint8_t data[16384];\n  size_t datalen;\n  nghttp2_frame_hd hd;\n  ssize_t rv;\n  nghttp2_outbound_item *item;\n\n  nghttp2_frame_hd_init(&hd, 16000, NGHTTP2_CONTINUATION,\n                        NGHTTP2_FLAG_END_HEADERS, 1);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  datalen = NGHTTP2_FRAME_HDLEN + hd.length;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  ud.frame_recv_cb_called = 0;\n\n  /* unexpected CONTINUATION must be treated as connection error */\n  rv = nghttp2_session_mem_recv(session, data, datalen);\n\n  CU_ASSERT(rv == (ssize_t)datalen);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_settings_header_table_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_settings_entry iv[3];\n  nghttp2_nv nv = MAKE_NV(\":authority\", \"example.org\");\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3000;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16384;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 2),\n                              2);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(3000 == session->remote_settings.header_table_size);\n  CU_ASSERT(16384 == session->remote_settings.initial_window_size);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* 2 SETTINGS_HEADER_TABLE_SIZE */\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3001;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16383;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[2].value = 3001;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 3),\n                              3);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)(nghttp2_buf_len(buf)) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(3001 == session->remote_settings.header_table_size);\n  CU_ASSERT(16383 == session->remote_settings.initial_window_size);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* 2 SETTINGS_HEADER_TABLE_SIZE; first entry clears dynamic header\n     table. */\n\n  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);\n  nghttp2_session_send(session);\n\n  CU_ASSERT(0 < session->hd_deflater.ctx.hd_table.len);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 0;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16382;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[2].value = 4096;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 3),\n                              3);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(4096 == session->remote_settings.header_table_size);\n  CU_ASSERT(16382 == session->remote_settings.initial_window_size);\n  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* 2 SETTINGS_HEADER_TABLE_SIZE; second entry clears dynamic header\n     table. */\n\n  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);\n  nghttp2_session_send(session);\n\n  CU_ASSERT(0 < session->hd_deflater.ctx.hd_table.len);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3000;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16381;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[2].value = 0;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 3),\n                              3);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  CU_ASSERT(0 == session->remote_settings.header_table_size);\n  CU_ASSERT(16381 == session->remote_settings.initial_window_size);\n  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_too_large_frame_length(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t buf[NGHTTP2_FRAME_HDLEN];\n  nghttp2_outbound_item *item;\n  nghttp2_frame_hd hd;\n\n  /* Initial max frame size is NGHTTP2_MAX_FRAME_SIZE_MIN */\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_FRAME_SIZE_MIN + 1, NGHTTP2_HEADERS,\n                        NGHTTP2_FLAG_NONE, 1);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_frame_pack_frame_hd(buf, &hd);\n\n  CU_ASSERT(sizeof(buf) == nghttp2_session_mem_recv(session, buf, sizeof(buf)));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_recv_extension(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_buf buf;\n  nghttp2_frame_hd hd;\n  nghttp2_mem *mem;\n  const char data[] = \"Hello World!\";\n  ssize_t rv;\n  nghttp2_option *option;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.on_extension_chunk_recv_callback = on_extension_chunk_recv_callback;\n  callbacks.unpack_extension_callback = unpack_extension_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_user_recv_extension_type(option, 111);\n\n  nghttp2_buf_init2(&ud.scratchbuf, 4096, mem);\n  nghttp2_buf_init2(&buf, 4096, mem);\n\n  nghttp2_frame_hd_init(&hd, sizeof(data), 111, 0xab, 1000000007);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  buf.last = nghttp2_cpymem(buf.last, data, sizeof(data));\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&ud.recv_frame_hd, 0, 0, 0, 0);\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + hd.length == (size_t)rv);\n  CU_ASSERT(111 == ud.recv_frame_hd.type);\n  CU_ASSERT(0xab == ud.recv_frame_hd.flags);\n  CU_ASSERT(1000000007 == ud.recv_frame_hd.stream_id);\n  CU_ASSERT(0 == memcmp(data, ud.scratchbuf.pos, sizeof(data)));\n\n  nghttp2_session_del(session);\n\n  /* cancel in on_extension_chunk_recv_callback */\n  nghttp2_buf_reset(&ud.scratchbuf);\n\n  callbacks.on_extension_chunk_recv_callback =\n      cancel_on_extension_chunk_recv_callback;\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + hd.length == (size_t)rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* cancel in unpack_extension_callback */\n  nghttp2_buf_reset(&ud.scratchbuf);\n\n  callbacks.on_extension_chunk_recv_callback = on_extension_chunk_recv_callback;\n  callbacks.unpack_extension_callback = cancel_unpack_extension_callback;\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + hd.length == (size_t)rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  nghttp2_buf_free(&buf, mem);\n  nghttp2_buf_free(&ud.scratchbuf, mem);\n\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_recv_altsvc(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_buf buf;\n  nghttp2_frame_hd hd;\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_option *option;\n  static const uint8_t origin[] = \"nghttp2.org\";\n  static const uint8_t field_value[] = \"h2=\\\":443\\\"\";\n\n  mem = nghttp2_mem_default();\n\n  nghttp2_buf_init2(&buf, NGHTTP2_FRAME_HDLEN + NGHTTP2_MAX_FRAME_SIZE_MIN,\n                    mem);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 + sizeof(field_value) - 1,\n                        NGHTTP2_ALTSVC, NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ALTSVC == ud.recv_frame_hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == ud.recv_frame_hd.flags);\n  CU_ASSERT(0 == ud.recv_frame_hd.stream_id);\n\n  nghttp2_session_del(session);\n\n  /* size of origin is larger than frame length */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 - 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1 - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* zero-length value */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n\n  ud.invalid_frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* non-empty origin to a stream other than 0 */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 + sizeof(field_value) - 1,\n                        NGHTTP2_ALTSVC, NGHTTP2_FLAG_NONE, 1);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.invalid_frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* empty origin to stream 0 */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(field_value) - 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, 0);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.invalid_frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.invalid_frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* send large frame (16KiB) */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_FRAME_SIZE_MIN, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  memset(buf.last, 0, nghttp2_buf_avail(&buf));\n  buf.last += nghttp2_buf_avail(&buf);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ALTSVC == ud.recv_frame_hd.type);\n  CU_ASSERT(NGHTTP2_MAX_FRAME_SIZE_MIN == ud.recv_frame_hd.length);\n\n  nghttp2_session_del(session);\n\n  /* send too large frame */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  session->local_settings.max_frame_size = NGHTTP2_MAX_FRAME_SIZE_MIN - 1;\n\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_FRAME_SIZE_MIN + 1, NGHTTP2_ALTSVC,\n                        NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  memset(buf.last, 0, nghttp2_buf_avail(&buf));\n  buf.last += nghttp2_buf_avail(&buf);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* received by server */\n  nghttp2_buf_reset(&buf);\n\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_hd_init(&hd, 2 + sizeof(origin) - 1 + sizeof(field_value) - 1,\n                        NGHTTP2_ALTSVC, NGHTTP2_FLAG_NONE, 0);\n  nghttp2_frame_pack_frame_hd(buf.last, &hd);\n  buf.last += NGHTTP2_FRAME_HDLEN;\n  nghttp2_put_uint16be(buf.last, sizeof(origin) - 1);\n  buf.last += 2;\n  buf.last = nghttp2_cpymem(buf.last, origin, sizeof(origin) - 1);\n  buf.last = nghttp2_cpymem(buf.last, field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf.pos, nghttp2_buf_len(&buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&buf) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  nghttp2_buf_free(&buf, mem);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_recv_origin(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  nghttp2_option *option;\n  nghttp2_extension frame;\n  nghttp2_ext_origin origin;\n  nghttp2_origin_entry ov;\n  static const uint8_t nghttp2[] = \"https://nghttp2.org\";\n\n  frame_pack_bufs_init(&bufs);\n\n  frame.payload = &origin;\n\n  ov.origin = (uint8_t *)nghttp2;\n  ov.origin_len = sizeof(nghttp2) - 1;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ORIGIN);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ORIGIN == ud.recv_frame_hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == ud.recv_frame_hd.flags);\n  CU_ASSERT(0 == ud.recv_frame_hd.stream_id);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* The length of origin is larger than payload length. */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_put_uint16be(bufs.head->buf.pos + NGHTTP2_FRAME_HDLEN,\n                       (uint16_t)sizeof(nghttp2));\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* A frame should be ignored if it is sent to a stream other than\n     stream 0. */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  frame.hd.stream_id = 1;\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* A frame should be ignored if the reserved flag is set */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  frame.hd.flags = 0xf0;\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* A frame should be ignored if it is received by a server. */\n  nghttp2_session_server_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, &ov, 1);\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_reset(&bufs);\n\n  /* Receiving empty ORIGIN frame */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  nghttp2_frame_origin_init(&frame, NULL, 0);\n  rv = nghttp2_frame_pack_origin(&bufs, &frame);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_ORIGIN == ud.recv_frame_hd.type);\n\n  nghttp2_session_del(session);\n\n  nghttp2_option_del(option);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_continue(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  const nghttp2_nv nv1[] = {MAKE_NV(\":method\", \"GET\"), MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv nv2[] = {MAKE_NV(\"user-agent\", \"nghttp2/1.0.0\"),\n                            MAKE_NV(\"alpha\", \"bravo\")};\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  size_t framelen1, framelen2;\n  ssize_t rv;\n  uint8_t buffer[4096];\n  nghttp2_buf databuf;\n  nghttp2_frame frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  const nghttp2_frame *recv_frame;\n  nghttp2_frame_hd data_hd;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n  nghttp2_buf_wrap_init(&databuf, buffer, sizeof(buffer));\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_data_chunk_recv_callback = pause_on_data_chunk_recv_callback;\n  callbacks.on_header_callback = pause_on_header_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  /* disable strict HTTP layering checks */\n  session->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* Make 2 HEADERS frames */\n  nvlen = ARRLEN(nv1);\n  nghttp2_nv_array_copy(&nva, nv1, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  framelen1 = nghttp2_buf_len(buf);\n  databuf.last = nghttp2_cpymem(databuf.last, buf->pos, nghttp2_buf_len(buf));\n\n  nvlen = ARRLEN(nv2);\n  nghttp2_nv_array_copy(&nva, nv2, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  nghttp2_bufs_reset(&bufs);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  framelen2 = nghttp2_buf_len(buf);\n  databuf.last = nghttp2_cpymem(databuf.last, buf->pos, nghttp2_buf_len(buf));\n\n  /* Receive 1st HEADERS and pause */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  recv_frame = user_data.frame;\n  CU_ASSERT(NGHTTP2_HEADERS == recv_frame->hd.type);\n  CU_ASSERT(framelen1 - NGHTTP2_FRAME_HDLEN == recv_frame->hd.length);\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv1[0], &user_data.nv));\n\n  /* get 2nd header field */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv1[1], &user_data.nv));\n\n  /* will call end_headers_callback and receive 2nd HEADERS and pause */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  recv_frame = user_data.frame;\n  CU_ASSERT(NGHTTP2_HEADERS == recv_frame->hd.type);\n  CU_ASSERT(framelen2 - NGHTTP2_FRAME_HDLEN == recv_frame->hd.length);\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv2[0], &user_data.nv));\n\n  /* get 2nd header field */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.header_cb_called);\n\n  CU_ASSERT(nghttp2_nv_equal(&nv2[1], &user_data.nv));\n\n  /* No input data, frame_recv_callback is called */\n  user_data.begin_headers_cb_called = 0;\n  user_data.header_cb_called = 0;\n  user_data.frame_recv_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(rv >= 0);\n  databuf.pos += rv;\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.header_cb_called);\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  /* Receive DATA */\n  nghttp2_frame_hd_init(&data_hd, 16, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 1);\n\n  nghttp2_buf_reset(&databuf);\n  nghttp2_frame_pack_frame_hd(databuf.pos, &data_hd);\n\n  /* Intentionally specify larger buffer size to see pause is kicked\n     in. */\n  databuf.last = databuf.end;\n\n  user_data.frame_recv_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n\n  CU_ASSERT(16 + NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(0 == user_data.frame_recv_cb_called);\n\n  /* Next nghttp2_session_mem_recv invokes on_frame_recv_callback and\n     pause again in on_data_chunk_recv_callback since we pass same\n     DATA frame. */\n  user_data.frame_recv_cb_called = 0;\n  rv =\n      nghttp2_session_mem_recv(session, databuf.pos, nghttp2_buf_len(&databuf));\n  CU_ASSERT(16 + NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  /* And finally call on_frame_recv_callback with 0 size input */\n  user_data.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, NULL, 0);\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_add_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  my_user_data user_data;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n\n  acc.length = 0;\n  user_data.acc = &acc;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &user_data));\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nvlen = ARRLEN(reqnv);\n  nghttp2_nv_array_copy(&nva, reqnv, nvlen, mem);\n\n  nghttp2_frame_headers_init(\n      &frame->headers, NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n      (int32_t)session->next_stream_id, NGHTTP2_HCAT_REQUEST, NULL, nva, nvlen);\n\n  session->next_stream_id += 2;\n\n  CU_ASSERT(0 == nghttp2_session_add_item(session, item));\n  CU_ASSERT(NULL != nghttp2_outbound_queue_top(&session->ob_syn));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_HEADERS == acc.buf[3]);\n  CU_ASSERT((NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY) == acc.buf[4]);\n  /* check stream id */\n  CU_ASSERT(1 == nghttp2_get_uint32(&acc.buf[5]));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_request_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  int32_t stream_id = 1;\n  nghttp2_nv malformed_nva[] = {MAKE_NV(\":path\", \"\\x01\")};\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 255, 0);\n\n  nghttp2_frame_headers_init(\n      &frame.headers, NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n      stream_id, NGHTTP2_HCAT_REQUEST, &pri_spec, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  stream = nghttp2_session_get_stream(session, stream_id);\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n  CU_ASSERT(255 == stream->weight);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* More than un-ACKed max concurrent streams leads REFUSED_STREAM */\n  session->pending_local_max_concurrent_stream = 1;\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             3, NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  session->local_settings.max_concurrent_streams =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n\n  /* Stream ID less than or equal to the previouly received request\n     HEADERS is just ignored due to race condition */\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             3, NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* Stream ID is our side and it is idle stream ID, then treat it as\n     connection error */\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             2, NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  /* Check malformed headers. The library accept it. */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  nvlen = ARRLEN(malformed_nva);\n  nghttp2_nv_array_copy(&nva, malformed_nva, nvlen, mem);\n  nghttp2_frame_headers_init(&frame.headers,\n                             NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PRIORITY,\n                             1, NGHTTP2_HCAT_HEADERS, NULL, nva, nvlen);\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  /* Check client side */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  /* Receiving peer's idle stream ID is subject to connection error */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  /* Receiving our's idle stream ID is subject to connection error */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  session->next_stream_id = 5;\n  session->last_sent_stream_id = 3;\n\n  /* Stream ID which is not idle and not in stream map is just\n     ignored */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  /* Stream ID which is equal to local_last_stream_id is ok. */\n  session->local_last_stream_id = 3;\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  CU_ASSERT(0 == nghttp2_session_on_request_headers_received(session, &frame));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* If GOAWAY has been sent, new stream is ignored */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 5,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_SENT;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == (session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  /* HEADERS to closed stream */\n  stream = open_recv_stream(session, 1);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_response_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_response_headers_received(session, &frame,\n                                                              stream));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENED);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  /* stream closed */\n  frame.hd.flags |= NGHTTP2_FLAG_END_STREAM;\n\n  CU_ASSERT(0 == nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(2 == user_data.begin_headers_cb_called);\n\n  /* Check to see when NGHTTP2_STREAM_CLOSING, incoming HEADERS is\n     discarded. */\n  stream = open_sent_stream2(session, 3, NGHTTP2_STREAM_CLOSING);\n  frame.hd.stream_id = 3;\n  frame.hd.flags = NGHTTP2_FLAG_END_HEADERS;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_headers_received(session, &frame, stream));\n  /* See no counters are updated */\n  CU_ASSERT(2 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n\n  /* Server initiated stream */\n  stream = open_recv_stream(session, 2);\n\n  frame.hd.flags = NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM;\n  frame.hd.stream_id = 2;\n\n  CU_ASSERT(0 == nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(3 == user_data.begin_headers_cb_called);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n\n  /* Further reception of HEADERS is subject to stream error */\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_headers_received(session, &frame, stream));\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_push_response_headers_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  /* nghttp2_session_on_push_response_headers_received assumes\n     stream's state is NGHTTP2_STREAM_RESERVED and session->server is\n     0. */\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(0 == nghttp2_session_on_push_response_headers_received(\n                     session, &frame, stream));\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(0 == (stream->flags & NGHTTP2_STREAM_FLAG_PUSH));\n\n  /* If un-ACKed max concurrent streams limit is exceeded,\n     RST_STREAMed */\n  session->pending_local_max_concurrent_stream = 1;\n  stream = open_recv_stream2(session, 4, NGHTTP2_STREAM_RESERVED);\n  frame.hd.stream_id = 4;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_response_headers_received(session, &frame,\n                                                              stream));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_REFUSED_STREAM == item->frame.rst_stream.error_code);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == session->num_incoming_streams);\n\n  /* If ACKed max concurrent streams limit is exceeded, GOAWAY is\n     issued */\n  session->local_settings.max_concurrent_streams = 1;\n\n  stream = open_recv_stream2(session, 6, NGHTTP2_STREAM_RESERVED);\n  frame.hd.stream_id = 6;\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_response_headers_received(session, &frame,\n                                                              stream));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_priority_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream, *dep_stream;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_outbound_item *item;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  stream = open_recv_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 2, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  /* depend on stream 0 */\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  CU_ASSERT(2 == stream->weight);\n\n  stream = open_sent_stream(session, 2);\n  dep_stream = open_recv_stream(session, 3);\n\n  frame.hd.stream_id = 2;\n\n  /* using dependency stream */\n  nghttp2_priority_spec_init(&frame.priority.pri_spec, 3, 1, 0);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n  CU_ASSERT(dep_stream == stream->dep_prev);\n\n  /* PRIORITY against idle stream */\n\n  frame.hd.stream_id = 100;\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  stream = nghttp2_session_get_stream_raw(session, frame.hd.stream_id);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(dep_stream == stream->dep_prev);\n\n  nghttp2_frame_priority_free(&frame.priority);\n  nghttp2_session_del(session);\n\n  /* Check dep_stream_id == stream_id case */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  open_recv_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 0, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_priority_free(&frame.priority);\n  nghttp2_session_del(session);\n\n  /* Check again dep_stream_id == stream_id, and stream_id is idle */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 16, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_priority_free(&frame.priority);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_rst_stream_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  open_recv_stream(session, 1);\n\n  nghttp2_frame_rst_stream_init(&frame.rst_stream, 1, NGHTTP2_PROTOCOL_ERROR);\n\n  CU_ASSERT(0 == nghttp2_session_on_rst_stream_received(session, &frame));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_frame_rst_stream_free(&frame.rst_stream);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_settings_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_stream *stream1, *stream2;\n  nghttp2_frame frame;\n  const size_t niv = 5;\n  nghttp2_settings_entry iv[255];\n  nghttp2_outbound_item *item;\n  nghttp2_nv nv = MAKE_NV(\":authority\", \"example.org\");\n  nghttp2_mem *mem;\n  nghttp2_option *option;\n\n  mem = nghttp2_mem_default();\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 50;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[1].value = 1000000009;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[2].value = 64 * 1024;\n\n  iv[3].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[3].value = 1024;\n\n  iv[4].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;\n  iv[4].value = 0;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  session->remote_settings.initial_window_size = 16 * 1024;\n\n  stream1 = open_sent_stream(session, 1);\n  stream2 = open_recv_stream(session, 2);\n\n  /* Set window size for each streams and will see how settings\n     updates these values */\n  stream1->remote_window_size = 16 * 1024;\n  stream2->remote_window_size = -48 * 1024;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE,\n                              dup_iv(iv, niv), niv);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  CU_ASSERT(1000000009 == session->remote_settings.max_concurrent_streams);\n  CU_ASSERT(64 * 1024 == session->remote_settings.initial_window_size);\n  CU_ASSERT(1024 == session->remote_settings.header_table_size);\n  CU_ASSERT(0 == session->remote_settings.enable_push);\n\n  CU_ASSERT(64 * 1024 == stream1->remote_window_size);\n  CU_ASSERT(0 == stream2->remote_window_size);\n\n  frame.settings.iv[2].value = 16 * 1024;\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  CU_ASSERT(16 * 1024 == stream1->remote_window_size);\n  CU_ASSERT(-48 * 1024 == stream2->remote_window_size);\n\n  CU_ASSERT(16 * 1024 == nghttp2_session_get_stream_remote_window_size(\n                             session, stream1->stream_id));\n  CU_ASSERT(0 == nghttp2_session_get_stream_remote_window_size(\n                     session, stream2->stream_id));\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  nghttp2_session_del(session);\n\n  /* Check ACK with niv > 0 */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, dup_iv(iv, 1),\n                              1);\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check ACK against no inflight SETTINGS */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check that 2 SETTINGS_HEADER_TABLE_SIZE 0 and 4096 are included\n     and header table size is once cleared to 0. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(session->hd_deflater.ctx.hd_table.len > 0);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 0;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[1].value = 2048;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 2),\n                              2);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);\n  CU_ASSERT(2048 == session->hd_deflater.ctx.hd_table_bufsize_max);\n  CU_ASSERT(2048 == session->remote_settings.header_table_size);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check that remote SETTINGS_MAX_CONCURRENT_STREAMS is set to a value set by\n     nghttp2_option_set_peer_max_concurrent_streams() and reset to the default\n     value (unlimited) after receiving initial SETTINGS frame from the peer. */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_peer_max_concurrent_streams(option, 1000);\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n  CU_ASSERT(1000 == session->remote_settings.max_concurrent_streams);\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, NULL, 0);\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==\n            session->remote_settings.max_concurrent_streams);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Check too large SETTINGS_MAX_FRAME_SIZE */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_FRAME_SIZE;\n  iv[0].value = NGHTTP2_MAX_FRAME_SIZE_MAX + 1;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),\n                              1);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item != NULL);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n  nghttp2_session_del(session);\n\n  /* Check the case where stream window size overflows */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream1 = open_recv_stream(session, 1);\n\n  /* This will increment window size by 1 */\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   1);\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[0].value = NGHTTP2_MAX_WINDOW_SIZE;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),\n                              1);\n\n  /* Now window size gets NGHTTP2_MAX_WINDOW_SIZE + 1, which is\n     unacceptable situation in protocol spec. */\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_STREAM_CLOSING == stream1->state);\n\n  nghttp2_session_del(session);\n\n  /* It is invalid that peer disables ENABLE_CONNECT_PROTOCOL once it\n     has been enabled. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  session->remote_settings.enable_connect_protocol = 1;\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL;\n  iv[0].value = 0;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),\n                              1);\n\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_push_promise_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream, *promised_stream;\n  nghttp2_outbound_item *item;\n  nghttp2_nv malformed_nva[] = {MAKE_NV(\":path\", \"\\x01\")};\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_mem *mem;\n  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_ENABLE_PUSH, 0};\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_begin_headers_callback = on_begin_headers_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  promised_stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == promised_stream->state);\n  CU_ASSERT(2 == session->last_recv_stream_id);\n\n  /* Attempt to PUSH_PROMISE against half close (remote) */\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  frame.push_promise.promised_stream_id = 4;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 4));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_STREAM_CLOSED == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(4 == session->last_recv_stream_id);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  /* Attempt to PUSH_PROMISE against stream in closing state */\n  stream->state = NGHTTP2_STREAM_CLOSING;\n  frame.push_promise.promised_stream_id = 6;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 6));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(6 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_CANCEL == item->frame.rst_stream.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Attempt to PUSH_PROMISE against idle stream */\n  frame.hd.stream_id = 3;\n  frame.push_promise.promised_stream_id = 8;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 8));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  /* Same ID twice */\n  frame.hd.stream_id = 1;\n  frame.push_promise.promised_stream_id = 2;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 2));\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 8));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* After GOAWAY, PUSH_PROMISE will be discarded */\n  frame.push_promise.promised_stream_id = 10;\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 10));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  /* Attempt to PUSH_PROMISE against reserved (remote) stream */\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  2, 4, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* Disable PUSH */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_sent_stream(session, 1);\n\n  session->local_settings.enable_push = 0;\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, NULL, 0);\n\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == user_data.begin_headers_cb_called);\n  CU_ASSERT(1 == user_data.invalid_frame_recv_cb_called);\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* Check malformed headers. We accept malformed headers */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_sent_stream(session, 1);\n\n  nvlen = ARRLEN(malformed_nva);\n  nghttp2_nv_array_copy(&nva, malformed_nva, nvlen, mem);\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, nva, nvlen);\n  user_data.begin_headers_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.begin_headers_cb_called);\n  CU_ASSERT(0 == user_data.invalid_frame_recv_cb_called);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* If local_settings.enable_push = 0 is pending, but not acked from\n     peer, incoming PUSH_PROMISE is rejected */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  open_sent_stream(session, 1);\n\n  /* Submit settings with ENABLE_PUSH = 0 (thus disabling push) */\n  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 2, NULL, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(0 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n\n  /* Check max_incoming_reserved_streams */\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  session->max_incoming_reserved_streams = 1;\n\n  open_sent_stream(session, 1);\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  nghttp2_frame_push_promise_init(&frame.push_promise, NGHTTP2_FLAG_END_HEADERS,\n                                  1, 4, NULL, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_push_promise_received(session, &frame));\n\n  CU_ASSERT(1 == session->num_incoming_reserved_streams);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_CANCEL == item->frame.rst_stream.error_code);\n\n  nghttp2_frame_push_promise_free(&frame.push_promise, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_ping_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_outbound_item *top;\n  const uint8_t opaque_data[] = \"01234567\";\n  nghttp2_option *option;\n\n  user_data.frame_recv_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_ACK, opaque_data);\n\n  CU_ASSERT(0 == nghttp2_session_on_ping_received(session, &frame));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n\n  /* Since this ping frame has ACK flag set, no further action is\n     performed. */\n  CU_ASSERT(NULL == nghttp2_outbound_queue_top(&session->ob_urgent));\n\n  /* Clear the flag, and receive it again */\n  frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n  CU_ASSERT(0 == nghttp2_session_on_ping_received(session, &frame));\n  CU_ASSERT(2 == user_data.frame_recv_cb_called);\n  top = nghttp2_outbound_queue_top(&session->ob_urgent);\n  CU_ASSERT(NGHTTP2_PING == top->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_ACK == top->frame.hd.flags);\n  CU_ASSERT(memcmp(opaque_data, top->frame.ping.opaque_data, 8) == 0);\n\n  nghttp2_frame_ping_free(&frame.ping);\n  nghttp2_session_del(session);\n\n  /* Use nghttp2_option_set_no_auto_ping_ack() */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_ping_ack(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, &user_data, option);\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_NONE, NULL);\n\n  user_data.frame_recv_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_ping_received(session, &frame));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(NULL == nghttp2_outbound_queue_top(&session->ob_urgent));\n\n  nghttp2_frame_ping_free(&frame.ping);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_on_goaway_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  int i;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  user_data.frame_recv_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  for (i = 1; i <= 7; ++i) {\n    if (nghttp2_session_is_my_stream_id(session, i)) {\n      open_sent_stream(session, i);\n    } else {\n      open_recv_stream(session, i);\n    }\n  }\n\n  nghttp2_frame_goaway_init(&frame.goaway, 3, NGHTTP2_PROTOCOL_ERROR, NULL, 0);\n\n  user_data.stream_close_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_on_goaway_received(session, &frame));\n\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(3 == session->remote_last_stream_id);\n  /* on_stream_close should be callsed for 2 times (stream 5 and 7) */\n  CU_ASSERT(2 == user_data.stream_close_cb_called);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 1));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 2));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 3));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 4));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 5));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 6));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 7));\n\n  nghttp2_frame_goaway_free(&frame.goaway, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_window_update_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *data_item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n  user_data.frame_recv_cb_called = 0;\n  user_data.invalid_frame_recv_cb_called = 0;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream(session, 1);\n\n  data_item = create_data_ob_item(mem);\n\n  CU_ASSERT(0 == nghttp2_stream_attach_item(stream, data_item));\n\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   16 * 1024);\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(1 == user_data.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 16 * 1024 ==\n            stream->remote_window_size);\n\n  CU_ASSERT(0 == nghttp2_stream_defer_item(\n                     stream, NGHTTP2_STREAM_FLAG_DEFERRED_FLOW_CONTROL));\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(2 == user_data.frame_recv_cb_called);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 16 * 1024 * 2 ==\n            stream->remote_window_size);\n  CU_ASSERT(0 == (stream->flags & NGHTTP2_STREAM_FLAG_DEFERRED_ALL));\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  /* Receiving WINDOW_UPDATE on reserved (remote) stream is a\n     connection error */\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 2,\n                                   4096);\n\n  CU_ASSERT(!(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND);\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  nghttp2_session_del(session);\n\n  /* Receiving WINDOW_UPDATE on reserved (local) stream is allowed */\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n\n  stream = open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 2,\n                                   4096);\n\n  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));\n  CU_ASSERT(!(session->goaway_flags & NGHTTP2_GOAWAY_TERM_ON_SEND));\n\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 4096 == stream->remote_window_size);\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_data_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_outbound_item *top;\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream = open_recv_stream(session, 2);\n\n  nghttp2_frame_hd_init(&frame.hd, 4096, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 2);\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  CU_ASSERT(0 == stream->shut_flags);\n\n  frame.hd.flags = NGHTTP2_FLAG_END_STREAM;\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  CU_ASSERT(NGHTTP2_SHUT_RD == stream->shut_flags);\n\n  /* If NGHTTP2_STREAM_CLOSING state, DATA frame is discarded. */\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_CLOSING);\n\n  frame.hd.flags = NGHTTP2_FLAG_NONE;\n  frame.hd.stream_id = 1;\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  CU_ASSERT(NULL == nghttp2_outbound_queue_top(&session->ob_reg));\n\n  /* Check INVALID_STREAM case: DATA frame with stream ID which does\n     not exist. */\n\n  frame.hd.stream_id = 3;\n\n  CU_ASSERT(0 == nghttp2_session_on_data_received(session, &frame));\n  top = nghttp2_outbound_queue_top(&session->ob_reg);\n  /* DATA against nonexistent stream is just ignored for now. */\n  CU_ASSERT(top == NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_data_received_fail_fast(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t buf[9];\n  nghttp2_stream *stream;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 1);\n  nghttp2_frame_pack_frame_hd(buf, &hd);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* DATA to closed (remote) */\n  stream = open_recv_stream(session, 1);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n\n  CU_ASSERT((ssize_t)sizeof(buf) ==\n            nghttp2_session_mem_recv(session, buf, sizeof(buf)));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* DATA to closed stream with explicit closed (remote) */\n  stream = open_recv_stream(session, 1);\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT((ssize_t)sizeof(buf) ==\n            nghttp2_session_mem_recv(session, buf, sizeof(buf)));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL != item);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_altsvc_received(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_option *option;\n  uint8_t origin[] = \"nghttp2.org\";\n  uint8_t field_value[] = \"h2=\\\":443\\\"\";\n  int rv;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_builtin_recv_extension_type(option, NGHTTP2_ALTSVC);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  /* We just pass the strings without making a copy.  This is OK,\n     since we never call nghttp2_frame_altsvc_free(). */\n  nghttp2_frame_altsvc_init(&frame.ext, 0, origin, sizeof(origin) - 1,\n                            field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Receiving empty origin with stream ID == 0 */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  nghttp2_frame_altsvc_init(&frame.ext, 0, origin, 0, field_value,\n                            sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Receiving non-empty origin with stream ID != 0 */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_altsvc_init(&frame.ext, 1, origin, sizeof(origin) - 1,\n                            field_value, sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Receiving empty origin with stream ID != 0; this is OK */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  open_sent_stream(session, 1);\n\n  nghttp2_frame_altsvc_init(&frame.ext, 1, origin, 0, field_value,\n                            sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Stream does not exist; ALTSVC will be ignored. */\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  frame.ext.payload = &session->iframe.ext_frame_payload;\n\n  nghttp2_frame_altsvc_init(&frame.ext, 1, origin, 0, field_value,\n                            sizeof(field_value) - 1);\n\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_on_altsvc_received(session, &frame);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  nghttp2_session_del(session);\n\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_send_headers_start_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS,\n                             (int32_t)session->next_stream_id,\n                             NGHTTP2_HCAT_REQUEST, NULL, NULL, 0);\n  session->next_stream_id += 2;\n\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_headers_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, NULL));\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS, 1,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_headers_frame_size_error(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  size_t vallen = NGHTTP2_HD_MAX_NV;\n  nghttp2_nv nv[28];\n  size_t nnv = ARRLEN(nv);\n  size_t i;\n  my_user_data ud;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  for (i = 0; i < nnv; ++i) {\n    nv[i].name = (uint8_t *)\"header\";\n    nv[i].namelen = strlen((const char *)nv[i].name);\n    nv[i].value = mem->malloc(vallen + 1, NULL);\n    memset(nv[i].value, '0' + (int)i, vallen);\n    nv[i].value[vallen] = '\\0';\n    nv[i].valuelen = vallen;\n    nv[i].flags = NGHTTP2_NV_FLAG_NONE;\n  }\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nvlen = nnv;\n  nghttp2_nv_array_copy(&nva, nv, nvlen, mem);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS,\n                             (int32_t)session->next_stream_id,\n                             NGHTTP2_HCAT_REQUEST, NULL, nva, nvlen);\n\n  session->next_stream_id += 2;\n\n  nghttp2_session_add_item(session, item);\n\n  ud.frame_not_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_FRAME_SIZE_ERROR == ud.not_sent_error);\n\n  for (i = 0; i < nnv; ++i) {\n    mem->free(nv[i].value, NULL);\n  }\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_headers_push_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, NULL));\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_headers_init(&frame->headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == session->num_outgoing_streams);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == session->num_outgoing_streams);\n  stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(0 == (stream->flags & NGHTTP2_STREAM_FLAG_PUSH));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_rst_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  open_sent_stream(session, 1);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_rst_stream_init(&frame->rst_stream, 1, NGHTTP2_PROTOCOL_ERROR);\n  nghttp2_session_add_item(session, item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_push_promise(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_stream *stream;\n  nghttp2_settings_entry iv;\n  my_user_data ud;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  open_recv_stream(session, 1);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_push_promise_init(&frame->push_promise,\n                                  NGHTTP2_FLAG_END_HEADERS, 1,\n                                  (int32_t)session->next_stream_id, NULL, 0);\n\n  session->next_stream_id += 2;\n\n  nghttp2_session_add_item(session, item);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == stream->state);\n\n  /* Received ENABLE_PUSH = 0 */\n  iv.settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;\n  iv.value = 0;\n  frame = mem->malloc(sizeof(nghttp2_frame), NULL);\n  nghttp2_frame_settings_init(&frame->settings, NGHTTP2_FLAG_NONE,\n                              dup_iv(&iv, 1), 1);\n  nghttp2_session_on_settings_received(session, frame, 1);\n  nghttp2_frame_settings_free(&frame->settings, mem);\n  mem->free(frame, NULL);\n\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_push_promise_init(&frame->push_promise,\n                                  NGHTTP2_FLAG_END_HEADERS, 1, -1, NULL, 0);\n  nghttp2_session_add_item(session, item);\n\n  ud.frame_not_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_PUSH_PROMISE == ud.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_PUSH_DISABLED == ud.not_sent_error);\n\n  nghttp2_session_del(session);\n\n  /* PUSH_PROMISE from client is error */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  open_sent_stream(session, 1);\n  item = mem->malloc(sizeof(nghttp2_outbound_item), NULL);\n\n  nghttp2_outbound_item_init(item);\n\n  frame = &item->frame;\n\n  nghttp2_frame_push_promise_init(&frame->push_promise,\n                                  NGHTTP2_FLAG_END_HEADERS, 1, -1, NULL, 0);\n  nghttp2_session_add_item(session, item);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 3));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_is_my_stream_id(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 0));\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 1));\n  CU_ASSERT(1 == nghttp2_session_is_my_stream_id(session, 2));\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 0));\n  CU_ASSERT(1 == nghttp2_session_is_my_stream_id(session, 1));\n  CU_ASSERT(0 == nghttp2_session_is_my_stream_id(session, 2));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_upgrade2(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t settings_payload[128];\n  size_t settings_payloadlen;\n  nghttp2_settings_entry iv[16];\n  nghttp2_stream *stream;\n  nghttp2_outbound_item *item;\n  ssize_t rv;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 1;\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 4095;\n  settings_payloadlen = (size_t)nghttp2_pack_settings_payload(\n      settings_payload, sizeof(settings_payload), iv, 2);\n\n  /* Check client side */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, &callbacks));\n  CU_ASSERT(1 == session->last_sent_stream_id);\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(stream != NULL);\n  CU_ASSERT(&callbacks == stream->stream_user_data);\n  CU_ASSERT(NGHTTP2_SHUT_WR == stream->shut_flags);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);\n  CU_ASSERT(2 == item->frame.settings.niv);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            item->frame.settings.iv[0].settings_id);\n  CU_ASSERT(1 == item->frame.settings.iv[0].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE ==\n            item->frame.settings.iv[1].settings_id);\n  CU_ASSERT(4095 == item->frame.settings.iv[1].value);\n\n  /* Call nghttp2_session_upgrade2() again is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_session_upgrade2(session, settings_payload,\n                                     settings_payloadlen, 0, &callbacks));\n  nghttp2_session_del(session);\n\n  /* Make sure that response from server can be received */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, &callbacks));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, resnv,\n                    ARRLEN(resnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  buf = &bufs.head->buf;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT(rv == (ssize_t)nghttp2_buf_len(buf));\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Check server side */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, &callbacks));\n  CU_ASSERT(1 == session->last_recv_stream_id);\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(stream != NULL);\n  CU_ASSERT(NULL == stream->stream_user_data);\n  CU_ASSERT(NGHTTP2_SHUT_RD == stream->shut_flags);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(1 == session->remote_settings.max_concurrent_streams);\n  CU_ASSERT(4095 == session->remote_settings.initial_window_size);\n  /* Call nghttp2_session_upgrade2() again is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_session_upgrade2(session, settings_payload,\n                                     settings_payloadlen, 0, &callbacks));\n  nghttp2_session_del(session);\n\n  /* Empty SETTINGS is OK */\n  settings_payloadlen = (size_t)nghttp2_pack_settings_payload(\n      settings_payload, sizeof(settings_payload), NULL, 0);\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  CU_ASSERT(0 == nghttp2_session_upgrade2(session, settings_payload,\n                                          settings_payloadlen, 0, NULL));\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_reprioritize_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_stream *dep_stream;\n  nghttp2_priority_spec pri_spec;\n  int rv;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream = open_recv_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 10, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(10 == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n\n  /* If depenency to idle stream which is not in depdenency tree yet */\n\n  nghttp2_priority_spec_init(&pri_spec, 3, 99, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(99 == stream->weight);\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  dep_stream = nghttp2_session_get_stream_raw(session, 3);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == dep_stream->weight);\n\n  dep_stream = open_recv_stream(session, 3);\n\n  /* Change weight */\n  pri_spec.weight = 128;\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(128 == stream->weight);\n  CU_ASSERT(dep_stream == stream->dep_prev);\n\n  /* Change weight again to test short-path case */\n  pri_spec.weight = 100;\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(100 == stream->weight);\n  CU_ASSERT(dep_stream == stream->dep_prev);\n  CU_ASSERT(100 == dep_stream->sum_dep_weight);\n\n  /* Test circular dependency; stream 1 is first removed and becomes\n     root.  Then stream 3 depends on it. */\n  nghttp2_priority_spec_init(&pri_spec, 1, 1, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, dep_stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(1 == dep_stream->weight);\n  CU_ASSERT(stream == dep_stream->dep_prev);\n\n  /* Making priority to closed stream will result in default\n     priority */\n  session->last_recv_stream_id = 9;\n\n  nghttp2_priority_spec_init(&pri_spec, 5, 5, 0);\n\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* circular dependency; in case of stream which is not a direct\n     descendant of root.  Use exclusive dependency. */\n  stream = open_recv_stream(session, 1);\n  stream = open_recv_stream_with_dep(session, 3, stream);\n  stream = open_recv_stream_with_dep(session, 5, stream);\n  stream = open_recv_stream_with_dep(session, 7, stream);\n  open_recv_stream_with_dep(session, 9, stream);\n\n  nghttp2_priority_spec_init(&pri_spec, 7, 1, 1);\n\n  stream = nghttp2_session_get_stream(session, 3);\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(7 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 7);\n\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 9);\n\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 5);\n\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* circular dependency; in case of stream which is not a direct\n     descendant of root.  Without exclusive dependency. */\n  stream = open_recv_stream(session, 1);\n  stream = open_recv_stream_with_dep(session, 3, stream);\n  stream = open_recv_stream_with_dep(session, 5, stream);\n  stream = open_recv_stream_with_dep(session, 7, stream);\n  open_recv_stream_with_dep(session, 9, stream);\n\n  nghttp2_priority_spec_init(&pri_spec, 7, 1, 0);\n\n  stream = nghttp2_session_get_stream(session, 3);\n  rv = nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(7 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 7);\n\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 9);\n\n  CU_ASSERT(7 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream(session, 5);\n\n  CU_ASSERT(3 == stream->dep_prev->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_reprioritize_stream_with_idle_stream_dep(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream = open_recv_stream(session, 1);\n\n  session->pending_local_max_concurrent_stream = 1;\n\n  nghttp2_priority_spec_init(&pri_spec, 101, 10, 0);\n\n  nghttp2_session_reprioritize_stream(session, stream, &pri_spec);\n\n  /* idle stream is not counteed to max concurrent streams */\n\n  CU_ASSERT(10 == stream->weight);\n  CU_ASSERT(101 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 101);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_frame *frame;\n  nghttp2_frame_hd hd;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_buf *buf;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  frame = &aob->item->frame;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_data_read_length_too_large(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_frame *frame;\n  nghttp2_frame_hd hd;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_buf *buf;\n  size_t payloadlen;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.read_length_callback = too_large_data_source_length_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  frame = &aob->item->frame;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  CU_ASSERT(16384 == hd.length)\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n\n  /* Check that buffers are expanded */\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  ud.data_source_length = NGHTTP2_MAX_FRAME_SIZE_MAX;\n\n  session->remote_settings.max_frame_size = NGHTTP2_MAX_FRAME_SIZE_MAX;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  aob = &session->aob;\n\n  frame = &aob->item->frame;\n\n  framebufs = &aob->framebufs;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  payloadlen = nghttp2_min(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE,\n                           NGHTTP2_INITIAL_WINDOW_SIZE);\n\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 1 + payloadlen ==\n            (size_t)nghttp2_buf_cap(buf));\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  CU_ASSERT(payloadlen == hd.length);\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_data_read_length_smallest(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_frame *frame;\n  nghttp2_frame_hd hd;\n  nghttp2_active_outbound_item *aob;\n  nghttp2_bufs *framebufs;\n  nghttp2_buf *buf;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.read_length_callback = smallest_length_data_source_length_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  aob = &session->aob;\n  framebufs = &aob->framebufs;\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.block_count = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  frame = &aob->item->frame;\n\n  buf = &framebufs->head->buf;\n  nghttp2_frame_unpack_frame_hd(&hd, buf->pos);\n\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == frame->hd.flags);\n  CU_ASSERT(1 == hd.length)\n  /* aux_data.data.flags has these flags */\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == aob->item->aux_data.data.flags);\n\n  nghttp2_session_del(session);\n}\n\nstatic ssize_t submit_data_twice_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  (void)session;\n  (void)stream_id;\n  (void)buf;\n  (void)source;\n  (void)user_data;\n\n  *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n  return (ssize_t)nghttp2_min(len, 16);\n}\n\nstatic int submit_data_twice_on_frame_send_callback(nghttp2_session *session,\n                                                    const nghttp2_frame *frame,\n                                                    void *user_data) {\n  static int called = 0;\n  int rv;\n  nghttp2_data_provider data_prd;\n  (void)user_data;\n\n  if (called == 0) {\n    called = 1;\n\n    data_prd.read_callback = submit_data_twice_data_source_read_callback;\n\n    rv = nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM,\n                             frame->hd.stream_id, &data_prd);\n    CU_ASSERT(0 == rv);\n  }\n\n  return 0;\n}\n\nvoid test_nghttp2_submit_data_twice(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  accumulator acc;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.on_frame_send_callback = submit_data_twice_on_frame_send_callback;\n\n  data_prd.read_callback = submit_data_twice_data_source_read_callback;\n\n  acc.length = 0;\n  ud.acc = &acc;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  open_sent_stream(session, 1);\n\n  CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, 1, &data_prd));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* We should have sent 2 DATA frame with 16 bytes payload each */\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN * 2 + 16 * 2 == acc.length);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_request_with_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = 64 * 1024 - 1;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                        &data_prd, NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.data_source_length);\n\n  nghttp2_session_del(session);\n\n  /* nghttp2_submit_request() with server session is error */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(NGHTTP2_ERR_PROTO == nghttp2_submit_request(session, NULL, reqnv,\n                                                        ARRLEN(reqnv), NULL,\n                                                        NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_request_without_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  nghttp2_data_provider data_prd = {{-1}, NULL};\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  nghttp2_priority_spec pri_spec;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                        &data_prd, NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(item->frame.hd.flags & NGHTTP2_FLAG_END_STREAM);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(reqnv) == out.nvlen);\n  assert_nv_equal(reqnv, out.nva, out.nvlen, mem);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nva_out_reset(&out, mem);\n\n  nghttp2_bufs_free(&bufs);\n  nghttp2_hd_inflate_free(&inflater);\n\n  /* Try to depend on itself is error */\n  nghttp2_priority_spec_init(&pri_spec, (int32_t)session->next_stream_id, 16,\n                             0);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_request(session, &pri_spec, reqnv, ARRLEN(reqnv),\n                                   NULL, NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_response_with_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = 64 * 1024 - 1;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv),\n                                         &data_prd));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(resnv) == item->frame.headers.nvlen);\n  assert_nv_equal(resnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.data_source_length);\n\n  nghttp2_session_del(session);\n\n  /* Various error cases */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  /* Calling nghttp2_submit_response() with client session is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv), NULL));\n\n  /* Stream ID <= 0 is error */\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_response(session, 0, resnv, ARRLEN(resnv), NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_response_without_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  nghttp2_data_provider data_prd = {{-1}, NULL};\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv),\n                                         &data_prd));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(resnv) == item->frame.headers.nvlen);\n  assert_nv_equal(resnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT(item->frame.hd.flags & NGHTTP2_FLAG_END_STREAM);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(resnv) == out.nvlen);\n  assert_nv_equal(resnv, out.nva, out.nvlen, mem);\n\n  nva_out_reset(&out, mem);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_hd_inflate_free(&inflater);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_response_push_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  session->goaway_flags |= NGHTTP2_GOAWAY_RECV;\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_response(session, 2, resnv, ARRLEN(resnv), NULL));\n\n  ud.frame_not_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_trailer(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  accumulator acc;\n  nghttp2_data_provider data_prd;\n  nghttp2_outbound_item *item;\n  my_user_data ud;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  data_prd.read_callback = no_end_stream_data_source_read_callback;\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv),\n                                         &data_prd));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_trailer(session, 1, trailernv, ARRLEN(trailernv)));\n\n  session->callbacks.send_callback = accumulator_send_callback;\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_HCAT_HEADERS == item->frame.headers.cat);\n  CU_ASSERT(item->frame.hd.flags & NGHTTP2_FLAG_END_STREAM);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(trailernv) == out.nvlen);\n  assert_nv_equal(trailernv, out.nva, out.nvlen, mem);\n\n  nva_out_reset(&out, mem);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_hd_inflate_free(&inflater);\n  nghttp2_session_del(session);\n\n  /* Specifying stream ID <= 0 is error */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  open_recv_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_trailer(session, 0, trailernv, ARRLEN(trailernv)));\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_trailer(session, -1, trailernv, ARRLEN(trailernv)));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_start_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n  CU_ASSERT(1 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                        NULL, reqnv, ARRLEN(reqnv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT((NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM) ==\n            item->frame.hd.flags);\n  CU_ASSERT(0 == (item->frame.hd.flags & NGHTTP2_FLAG_PRIORITY));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, resnv, ARRLEN(resnv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(resnv) == item->frame.headers.nvlen);\n  assert_nv_equal(resnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  /* The transimission will be canceled because the stream 1 is not\n     open. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  stream = open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, resnv, ARRLEN(resnv), NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  CU_ASSERT(stream->shut_flags & NGHTTP2_SHUT_WR);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_push_reply(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_stream *stream;\n  int foo;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  stream = open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 2, NULL,\n                                        resnv, ARRLEN(resnv), &foo));\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(&foo == stream->stream_user_data);\n\n  nghttp2_session_del(session);\n\n  /* Sending HEADERS from client against stream in reserved state is\n     error */\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 2, NULL,\n                                        reqnv, ARRLEN(reqnv), NULL));\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n  accumulator acc;\n  nghttp2_frame frame;\n  nghttp2_hd_inflater inflater;\n  nva_out out;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  nghttp2_priority_spec pri_spec;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  nva_out_init(&out);\n  acc.length = 0;\n  ud.acc = &acc;\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n\n  nghttp2_hd_inflate_init(&inflater, mem);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, reqnv, ARRLEN(reqnv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(ARRLEN(reqnv) == item->frame.headers.nvlen);\n  assert_nv_equal(reqnv, item->frame.headers.nva, item->frame.headers.nvlen,\n                  mem);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n  /* The transimission will be canceled because the stream 1 is not\n     open. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  stream = open_sent_stream(session, 1);\n\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, reqnv, ARRLEN(reqnv), NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  CU_ASSERT(stream->shut_flags & NGHTTP2_SHUT_WR);\n\n  CU_ASSERT(0 == unpack_frame(&frame, acc.buf, acc.length));\n\n  nghttp2_bufs_add(&bufs, acc.buf, acc.length);\n  inflate_hd(&inflater, &out, &bufs, NGHTTP2_FRAME_HDLEN, mem);\n\n  CU_ASSERT(ARRLEN(reqnv) == out.nvlen);\n  assert_nv_equal(reqnv, out.nva, out.nvlen, mem);\n\n  nva_out_reset(&out, mem);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_hd_inflate_free(&inflater);\n\n  /* Try to depend on itself */\n  nghttp2_priority_spec_init(&pri_spec, 3, 16, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 3, &pri_spec,\n                                   reqnv, ARRLEN(reqnv), NULL));\n\n  session->next_stream_id = 5;\n  nghttp2_priority_spec_init(&pri_spec, 5, 16, 0);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, -1, &pri_spec,\n                                   reqnv, ARRLEN(reqnv), NULL));\n\n  nghttp2_session_del(session);\n\n  /* Error cases with invalid stream ID */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Sending nghttp2_submit_headers() with stream_id == 1 and server\n     session is error */\n  CU_ASSERT(NGHTTP2_ERR_PROTO ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, -1, NULL, reqnv,\n                                   ARRLEN(reqnv), NULL));\n\n  /* Sending stream ID <= 0 is error */\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, 0, NULL, resnv,\n                                   ARRLEN(resnv), NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_continuation(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv nv[] = {\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n      MAKE_NV(\"h1\", \"\"),\n  };\n  nghttp2_outbound_item *item;\n  uint8_t data[4096];\n  size_t i;\n  my_user_data ud;\n\n  memset(data, '0', sizeof(data));\n  for (i = 0; i < ARRLEN(nv); ++i) {\n    nv[i].valuelen = sizeof(data);\n    nv[i].value = data;\n  }\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, &ud));\n  CU_ASSERT(1 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                        NULL, nv, ARRLEN(nv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n  CU_ASSERT(0 == (item->frame.hd.flags & NGHTTP2_FLAG_PRIORITY));\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_headers_continuation_extra_large(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv nv[] = {\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n      MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"), MAKE_NV(\"h1\", \"\"),\n  };\n  nghttp2_outbound_item *item;\n  uint8_t data[16384];\n  size_t i;\n  my_user_data ud;\n  nghttp2_option *opt;\n\n  memset(data, '0', sizeof(data));\n  for (i = 0; i < ARRLEN(nv); ++i) {\n    nv[i].valuelen = sizeof(data);\n    nv[i].value = data;\n  }\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  /* The default size of max send header block length is too small to\n     send these header fields.  Expand it. */\n  nghttp2_option_new(&opt);\n  nghttp2_option_set_max_send_header_block_length(opt, 102400);\n\n  CU_ASSERT(0 == nghttp2_session_client_new2(&session, &callbacks, &ud, opt));\n  CU_ASSERT(1 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                        NULL, nv, ARRLEN(nv), NULL));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  CU_ASSERT((NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS) ==\n            item->frame.hd.flags);\n  CU_ASSERT(0 == (item->frame.hd.flags & NGHTTP2_FLAG_PRIORITY));\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(opt);\n}\n\nvoid test_nghttp2_submit_priority(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  my_user_data ud;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  stream = open_sent_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 3, 0);\n\n  /* depends on stream 0 */\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(3 == stream->weight);\n\n  /* submit against idle stream */\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 3, &pri_spec));\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_settings(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_frame *frame;\n  nghttp2_settings_entry iv[7];\n  nghttp2_frame ack_frame;\n  const int32_t UNKNOWN_ID = 1000000007;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 5;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16 * 1024;\n\n  iv[2].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[2].value = 50;\n\n  iv[3].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[3].value = 111;\n\n  iv[4].settings_id = UNKNOWN_ID;\n  iv[4].value = 999;\n\n  iv[5].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[5].value = 1023;\n\n  iv[6].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[6].value = (uint32_t)NGHTTP2_MAX_WINDOW_SIZE + 1;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 7));\n\n  /* Make sure that local settings are not changed */\n  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==\n            session->local_settings.max_concurrent_streams);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            session->local_settings.initial_window_size);\n\n  /* Now sends without 6th one */\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 6));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);\n\n  frame = &item->frame;\n  CU_ASSERT(6 == frame->settings.niv);\n  CU_ASSERT(5 == frame->settings.iv[0].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            frame->settings.iv[0].settings_id);\n\n  CU_ASSERT(16 * 1024 == frame->settings.iv[1].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE ==\n            frame->settings.iv[1].settings_id);\n\n  CU_ASSERT(UNKNOWN_ID == frame->settings.iv[4].settings_id);\n  CU_ASSERT(999 == frame->settings.iv[4].value);\n\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  CU_ASSERT(50 == session->pending_local_max_concurrent_stream);\n\n  /* before receiving SETTINGS ACK, local settings have still default\n     values */\n  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==\n            nghttp2_session_get_local_settings(\n                session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_local_settings(\n                session, NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE));\n\n  nghttp2_frame_settings_init(&ack_frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n  nghttp2_frame_settings_free(&ack_frame.settings, mem);\n\n  CU_ASSERT(16 * 1024 == session->local_settings.initial_window_size);\n  CU_ASSERT(1023 == session->hd_inflater.ctx.hd_table_bufsize_max);\n  CU_ASSERT(111 == session->hd_inflater.min_hd_table_bufsize_max);\n  CU_ASSERT(50 == session->local_settings.max_concurrent_streams);\n\n  CU_ASSERT(50 == nghttp2_session_get_local_settings(\n                      session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS));\n  CU_ASSERT(16 * 1024 == nghttp2_session_get_local_settings(\n                             session, NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE));\n\n  /* We just keep the last seen value */\n  CU_ASSERT(50 == session->pending_local_max_concurrent_stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_settings_update_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_settings_entry iv[4];\n  nghttp2_stream *stream;\n  nghttp2_frame ack_frame;\n  nghttp2_mem *mem;\n  nghttp2_option *option;\n\n  mem = nghttp2_mem_default();\n  nghttp2_frame_settings_init(&ack_frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[0].value = 16 * 1024;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream = open_recv_stream(session, 1);\n  stream->local_window_size = NGHTTP2_INITIAL_WINDOW_SIZE + 100;\n  stream->recv_window_size = 32768;\n\n  open_recv_stream(session, 3);\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(16 * 1024 + 100 == stream->local_window_size);\n\n  stream = nghttp2_session_get_stream(session, 3);\n  CU_ASSERT(16 * 1024 == stream->local_window_size);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(32768 == item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n\n  /* Without auto-window update */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, NULL, option);\n\n  nghttp2_option_del(option);\n\n  stream = open_recv_stream(session, 1);\n  stream->local_window_size = NGHTTP2_INITIAL_WINDOW_SIZE + 100;\n  stream->recv_window_size = 32768;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(32768 == stream->recv_window_size);\n  CU_ASSERT(16 * 1024 + 100 == stream->local_window_size);\n  /* Check that we can handle the case where local_window_size <\n     recv_window_size */\n  CU_ASSERT(0 == nghttp2_session_get_stream_local_window_size(session, 1));\n\n  nghttp2_session_del(session);\n\n  /* Check overflow case */\n  iv[0].value = 128 * 1024;\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  stream = open_recv_stream(session, 1);\n  stream->local_window_size = NGHTTP2_MAX_WINDOW_SIZE;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &ack_frame, 0));\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_FLOW_CONTROL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_frame_settings_free(&ack_frame.settings, mem);\n}\n\nvoid test_nghttp2_submit_settings_multiple_times(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_settings_entry iv[4];\n  nghttp2_frame frame;\n  nghttp2_inflight_settings *inflight_settings;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  /* first SETTINGS */\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 100;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;\n  iv[1].value = 0;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 2));\n\n  inflight_settings = session->inflight_settings_head;\n\n  CU_ASSERT(NULL != inflight_settings);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            inflight_settings->iv[0].settings_id);\n  CU_ASSERT(100 == inflight_settings->iv[0].value);\n  CU_ASSERT(2 == inflight_settings->niv);\n  CU_ASSERT(NULL == inflight_settings->next);\n\n  CU_ASSERT(100 == session->pending_local_max_concurrent_stream);\n  CU_ASSERT(0 == session->pending_enable_push);\n\n  /* second SETTINGS */\n  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv[0].value = 99;\n\n  CU_ASSERT(0 == nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, 1));\n\n  inflight_settings = session->inflight_settings_head->next;\n\n  CU_ASSERT(NULL != inflight_settings);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            inflight_settings->iv[0].settings_id);\n  CU_ASSERT(99 == inflight_settings->iv[0].value);\n  CU_ASSERT(1 == inflight_settings->niv);\n  CU_ASSERT(NULL == inflight_settings->next);\n\n  CU_ASSERT(99 == session->pending_local_max_concurrent_stream);\n  CU_ASSERT(0 == session->pending_enable_push);\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);\n\n  /* receive SETTINGS ACK */\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  inflight_settings = session->inflight_settings_head;\n\n  /* first inflight SETTINGS was removed */\n  CU_ASSERT(NULL != inflight_settings);\n  CU_ASSERT(NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS ==\n            inflight_settings->iv[0].settings_id);\n  CU_ASSERT(99 == inflight_settings->iv[0].value);\n  CU_ASSERT(1 == inflight_settings->niv);\n  CU_ASSERT(NULL == inflight_settings->next);\n\n  CU_ASSERT(100 == session->local_settings.max_concurrent_streams);\n\n  /* receive SETTINGS ACK again */\n  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));\n\n  CU_ASSERT(NULL == session->inflight_settings_head);\n  CU_ASSERT(99 == session->local_settings.max_concurrent_streams);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_push_promise(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  open_recv_stream(session, 1);\n  CU_ASSERT(2 == nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 1,\n                                             reqnv, ARRLEN(reqnv), &ud));\n\n  stream = nghttp2_session_get_stream(session, 2);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == stream->state);\n  CU_ASSERT(&ud == nghttp2_session_get_stream_user_data(session, 2));\n\n  ud.frame_send_cb_called = 0;\n  ud.sent_frame_type = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_PUSH_PROMISE == ud.sent_frame_type);\n\n  stream = nghttp2_session_get_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_RESERVED == stream->state);\n  CU_ASSERT(&ud == nghttp2_session_get_stream_user_data(session, 2));\n\n  /* submit PUSH_PROMISE while associated stream is not opened */\n  CU_ASSERT(NGHTTP2_ERR_STREAM_CLOSED ==\n            nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 3, reqnv,\n                                        ARRLEN(reqnv), NULL));\n\n  /* Stream ID <= 0 is error */\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 0, reqnv,\n                                        ARRLEN(reqnv), NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_window_update(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  stream = open_recv_stream(session, 2);\n  stream->recv_window_size = 4096;\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 1024));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1024 == item->frame.window_update.window_size_increment);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(3072 == stream->recv_window_size);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 4096));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4096 == item->frame.window_update.window_size_increment);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == stream->recv_window_size);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 4096));\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4096 == item->frame.window_update.window_size_increment);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == stream->recv_window_size);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 0));\n  /* It is ok if stream is closed or does not exist at the call\n     time */\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 4, 4096));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_window_update_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = open_recv_stream(session, 2);\n  stream->recv_window_size = 4096;\n\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2,\n                                              stream->recv_window_size + 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1 == stream->local_window_size);\n  CU_ASSERT(0 == stream->recv_window_size);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4097 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Let's decrement local window size */\n  stream->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2,\n                                              -stream->local_window_size / 2));\n  CU_ASSERT(32768 == stream->local_window_size);\n  CU_ASSERT(-28672 == stream->recv_window_size);\n  CU_ASSERT(32768 == stream->recv_reduction);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2, 16384));\n  CU_ASSERT(49152 == stream->local_window_size);\n  CU_ASSERT(-12288 == stream->recv_window_size);\n  CU_ASSERT(16384 == stream->recv_reduction);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  CU_ASSERT(NGHTTP2_ERR_FLOW_CONTROL ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 2,\n                                         NGHTTP2_MAX_WINDOW_SIZE));\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Check connection-level flow control */\n  session->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                              session->recv_window_size + 1));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1 ==\n            session->local_window_size);\n  CU_ASSERT(0 == session->recv_window_size);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(4097 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Go decrement part */\n  session->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                              -session->local_window_size / 2));\n  CU_ASSERT(32768 == session->local_window_size);\n  CU_ASSERT(-28672 == session->recv_window_size);\n  CU_ASSERT(32768 == session->recv_reduction);\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, 16384));\n  CU_ASSERT(49152 == session->local_window_size);\n  CU_ASSERT(-12288 == session->recv_window_size);\n  CU_ASSERT(16384 == session->recv_reduction);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  CU_ASSERT(NGHTTP2_ERR_FLOW_CONTROL ==\n            nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0,\n                                         NGHTTP2_MAX_WINDOW_SIZE));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_shutdown_notice(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  CU_ASSERT(0 == nghttp2_submit_shutdown_notice(session));\n\n  ud.frame_send_cb_called = 0;\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_GOAWAY == ud.sent_frame_type);\n  CU_ASSERT((1u << 31) - 1 == session->local_last_stream_id);\n\n  /* After another GOAWAY, nghttp2_submit_shutdown_notice() is\n     noop. */\n  CU_ASSERT(0 == nghttp2_session_terminate_session(session, NGHTTP2_NO_ERROR));\n\n  ud.frame_send_cb_called = 0;\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_GOAWAY == ud.sent_frame_type);\n  CU_ASSERT(0 == session->local_last_stream_id);\n\n  CU_ASSERT(0 == nghttp2_submit_shutdown_notice(session));\n\n  ud.frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  nghttp2_session_send(session);\n\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(0 == ud.frame_not_send_cb_called);\n\n  nghttp2_session_del(session);\n\n  /* Using nghttp2_submit_shutdown_notice() with client side session\n     is error */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_STATE ==\n            nghttp2_submit_shutdown_notice(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_invalid_nv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_nv empty_name_nv[] = {MAKE_NV(\"Version\", \"HTTP/1.1\"),\n                                MAKE_NV(\"\", \"empty name\")};\n\n  /* Now invalid header name/value pair in HTTP/1.1 is accepted in\n     nghttp2 */\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, NULL));\n\n  /* nghttp2_submit_response */\n  CU_ASSERT(0 == nghttp2_submit_response(session, 2, empty_name_nv,\n                                         ARRLEN(empty_name_nv), NULL));\n\n  /* nghttp2_submit_push_promise */\n  open_recv_stream(session, 1);\n\n  CU_ASSERT(0 < nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 1,\n                                            empty_name_nv,\n                                            ARRLEN(empty_name_nv), NULL));\n\n  nghttp2_session_del(session);\n\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n\n  /* nghttp2_submit_request */\n  CU_ASSERT(0 < nghttp2_submit_request(session, NULL, empty_name_nv,\n                                       ARRLEN(empty_name_nv), NULL, NULL));\n\n  /* nghttp2_submit_headers */\n  CU_ASSERT(0 < nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, -1, NULL,\n                                       empty_name_nv, ARRLEN(empty_name_nv),\n                                       NULL));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_extension(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  accumulator acc;\n  nghttp2_mem *mem;\n  const char data[] = \"Hello World!\";\n  size_t len;\n  int32_t stream_id;\n  int rv;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  callbacks.pack_extension_callback = pack_extension_callback;\n  callbacks.send_callback = accumulator_send_callback;\n\n  nghttp2_buf_init2(&ud.scratchbuf, 4096, mem);\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  ud.scratchbuf.last = nghttp2_cpymem(ud.scratchbuf.last, data, sizeof(data));\n  ud.acc = &acc;\n\n  rv = nghttp2_submit_extension(session, 211, 0x01, 3, &ud.scratchbuf);\n\n  CU_ASSERT(0 == rv);\n\n  acc.length = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN + sizeof(data) == acc.length);\n\n  len = nghttp2_get_uint32(acc.buf) >> 8;\n\n  CU_ASSERT(sizeof(data) == len);\n  CU_ASSERT(211 == acc.buf[3]);\n  CU_ASSERT(0x01 == acc.buf[4]);\n\n  stream_id = (int32_t)nghttp2_get_uint32(acc.buf + 5);\n\n  CU_ASSERT(3 == stream_id);\n  CU_ASSERT(0 == memcmp(data, &acc.buf[NGHTTP2_FRAME_HDLEN], sizeof(data)));\n\n  nghttp2_session_del(session);\n\n  /* submitting standard HTTP/2 frame is error */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_extension(session, NGHTTP2_GOAWAY, NGHTTP2_FLAG_NONE, 0,\n                                NULL);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  nghttp2_session_del(session);\n  nghttp2_buf_free(&ud.scratchbuf, mem);\n}\n\nvoid test_nghttp2_submit_altsvc(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  int rv;\n  ssize_t len;\n  const uint8_t *data;\n  nghttp2_frame_hd hd;\n  size_t origin_len;\n  const uint8_t origin[] = \"nghttp2.org\";\n  const uint8_t field_value[] = \"h2=\\\":443\\\"\";\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 0, origin,\n                             sizeof(origin) - 1, field_value,\n                             sizeof(field_value) - 1);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n\n  len = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(len == NGHTTP2_FRAME_HDLEN + 2 + sizeof(origin) - 1 +\n                       sizeof(field_value) - 1);\n\n  nghttp2_frame_unpack_frame_hd(&hd, data);\n\n  CU_ASSERT(2 + sizeof(origin) - 1 + sizeof(field_value) - 1 == hd.length);\n  CU_ASSERT(NGHTTP2_ALTSVC == hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n\n  origin_len = nghttp2_get_uint16(data + NGHTTP2_FRAME_HDLEN);\n\n  CU_ASSERT(sizeof(origin) - 1 == origin_len);\n  CU_ASSERT(0 ==\n            memcmp(origin, data + NGHTTP2_FRAME_HDLEN + 2, sizeof(origin) - 1));\n  CU_ASSERT(0 == memcmp(field_value,\n                        data + NGHTTP2_FRAME_HDLEN + 2 + sizeof(origin) - 1,\n                        hd.length - (sizeof(origin) - 1) - 2));\n\n  /* submitting empty origin with stream_id == 0 is error */\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 0, NULL, 0,\n                             field_value, sizeof(field_value) - 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* submitting non-empty origin with stream_id != 0 is error */\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 1, origin,\n                             sizeof(origin) - 1, field_value,\n                             sizeof(field_value) - 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  nghttp2_session_del(session);\n\n  /* submitting from client side session is error */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  rv = nghttp2_submit_altsvc(session, NGHTTP2_FLAG_NONE, 0, origin,\n                             sizeof(origin) - 1, field_value,\n                             sizeof(field_value) - 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_STATE == rv);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_submit_origin(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  int rv;\n  ssize_t len;\n  const uint8_t *data;\n  static const uint8_t nghttp2[] = \"https://nghttp2.org\";\n  static const uint8_t examples[] = \"https://examples.com\";\n  static const nghttp2_origin_entry ov[] = {\n      {\n          (uint8_t *)nghttp2,\n          sizeof(nghttp2) - 1,\n      },\n      {\n          (uint8_t *)examples,\n          sizeof(examples) - 1,\n      },\n  };\n  nghttp2_frame frame;\n  nghttp2_ext_origin origin;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  frame.ext.payload = &origin;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_origin(session, NGHTTP2_FLAG_NONE, ov, 2);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n  len = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(len > 0);\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_frame_unpack_frame_hd(&frame.hd, data);\n  rv = nghttp2_frame_unpack_origin_payload(\n      &frame.ext, data + NGHTTP2_FRAME_HDLEN, (size_t)len - NGHTTP2_FRAME_HDLEN,\n      mem);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_ORIGIN == frame.hd.type);\n  CU_ASSERT(2 == origin.nov);\n  CU_ASSERT(0 == memcmp(nghttp2, origin.ov[0].origin, sizeof(nghttp2) - 1));\n  CU_ASSERT(sizeof(nghttp2) - 1 == origin.ov[0].origin_len);\n  CU_ASSERT(0 == memcmp(examples, origin.ov[1].origin, sizeof(examples) - 1));\n  CU_ASSERT(sizeof(examples) - 1 == origin.ov[1].origin_len);\n\n  nghttp2_frame_origin_free(&frame.ext, mem);\n\n  nghttp2_session_del(session);\n\n  /* Submitting ORIGIN frame from client session is error */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  rv = nghttp2_submit_origin(session, NGHTTP2_FLAG_NONE, ov, 1);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_STATE == rv);\n\n  nghttp2_session_del(session);\n\n  /* Submitting empty ORIGIN frame */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_submit_origin(session, NGHTTP2_FLAG_NONE, NULL, 0);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n  len = nghttp2_session_mem_send(session, &data);\n\n  CU_ASSERT(len == NGHTTP2_FRAME_HDLEN);\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n\n  nghttp2_frame_unpack_frame_hd(&frame.hd, data);\n\n  CU_ASSERT(NGHTTP2_ORIGIN == frame.hd.type);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_open_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 245, 0);\n\n  stream = nghttp2_session_open_stream(session, 1, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(0 == session->num_outgoing_streams);\n  CU_ASSERT(NGHTTP2_STREAM_OPENED == stream->state);\n  CU_ASSERT(245 == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_SHUT_NONE == stream->shut_flags);\n\n  stream = nghttp2_session_open_stream(session, 2, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec_default,\n                                       NGHTTP2_STREAM_OPENING, NULL);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_outgoing_streams);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(NGHTTP2_SHUT_NONE == stream->shut_flags);\n\n  stream = nghttp2_session_open_stream(session, 4, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec_default,\n                                       NGHTTP2_STREAM_RESERVED, NULL);\n  CU_ASSERT(1 == session->num_incoming_streams);\n  CU_ASSERT(1 == session->num_outgoing_streams);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(NGHTTP2_SHUT_RD == stream->shut_flags);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 17, 1);\n\n  stream = nghttp2_session_open_stream(session, 3, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n  CU_ASSERT(17 == stream->weight);\n  CU_ASSERT(1 == stream->dep_prev->stream_id);\n\n  /* Dependency to idle stream */\n  nghttp2_priority_spec_init(&pri_spec, 1000000007, 240, 1);\n\n  stream = nghttp2_session_open_stream(session, 5, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n  CU_ASSERT(240 == stream->weight);\n  CU_ASSERT(1000000007 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 1000000007);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n\n  /* Dependency to closed stream which is not in dependency tree */\n  session->last_recv_stream_id = 7;\n\n  nghttp2_priority_spec_init(&pri_spec, 7, 10, 0);\n\n  stream = nghttp2_session_open_stream(session, 9, NGHTTP2_FLAG_NONE, &pri_spec,\n                                       NGHTTP2_STREAM_OPENED, NULL);\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(&session->root == stream->dep_prev);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = nghttp2_session_open_stream(session, 4, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec_default,\n                                       NGHTTP2_STREAM_RESERVED, NULL);\n  CU_ASSERT(0 == session->num_incoming_streams);\n  CU_ASSERT(0 == session->num_outgoing_streams);\n  CU_ASSERT(&session->root == stream->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n  CU_ASSERT(NGHTTP2_SHUT_WR == stream->shut_flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_open_stream_with_idle_stream_dep(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Dependency to idle stream */\n  nghttp2_priority_spec_init(&pri_spec, 101, 245, 0);\n\n  stream = nghttp2_session_open_stream(session, 1, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n\n  CU_ASSERT(245 == stream->weight);\n  CU_ASSERT(101 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 101);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_priority_spec_init(&pri_spec, 211, 1, 0);\n\n  /* stream 101 was already created as idle. */\n  stream = nghttp2_session_open_stream(session, 101, NGHTTP2_STREAM_FLAG_NONE,\n                                       &pri_spec, NGHTTP2_STREAM_OPENED, NULL);\n\n  CU_ASSERT(1 == stream->weight);\n  CU_ASSERT(211 == stream->dep_prev->stream_id);\n\n  stream = nghttp2_session_get_stream_raw(session, 211);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream->weight);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_get_next_ob_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_priority_spec pri_spec;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 2;\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n  CU_ASSERT(NGHTTP2_PING ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, NULL, 0, NULL, NULL));\n  CU_ASSERT(NGHTTP2_PING ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Incoming stream does not affect the number of outgoing max\n     concurrent streams. */\n  open_recv_stream(session, 2);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, NGHTTP2_MAX_WEIGHT, 0);\n\n  CU_ASSERT(3 ==\n            nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL));\n  CU_ASSERT(NGHTTP2_HEADERS ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(5 ==\n            nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  session->remote_settings.max_concurrent_streams = 3;\n\n  CU_ASSERT(NGHTTP2_HEADERS ==\n            nghttp2_session_get_next_ob_item(session)->frame.hd.type);\n\n  nghttp2_session_del(session);\n\n  /* Check that push reply HEADERS are queued into ob_ss_pq */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 0;\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 2,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(1 == nghttp2_outbound_queue_size(&session->ob_syn));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_pop_next_ob_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 1;\n\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 254, 0);\n\n  nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL);\n\n  item = nghttp2_session_pop_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_PING == item->frame.hd.type);\n  nghttp2_outbound_item_free(item, mem);\n  mem->free(item, NULL);\n\n  item = nghttp2_session_pop_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  nghttp2_outbound_item_free(item, mem);\n  mem->free(item, NULL);\n\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n\n  /* Incoming stream does not affect the number of outgoing max\n     concurrent streams. */\n  open_recv_stream(session, 4);\n  /* In-flight outgoing stream */\n  open_sent_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, NGHTTP2_MAX_WEIGHT, 0);\n\n  nghttp2_submit_request(session, &pri_spec, NULL, 0, NULL, NULL);\n\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n\n  session->remote_settings.max_concurrent_streams = 2;\n\n  item = nghttp2_session_pop_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_HEADERS == item->frame.hd.type);\n  nghttp2_outbound_item_free(item, mem);\n  mem->free(item, NULL);\n\n  nghttp2_session_del(session);\n\n  /* Check that push reply HEADERS are queued into ob_ss_pq */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  session->remote_settings.max_concurrent_streams = 0;\n  open_sent_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 2,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(NULL == nghttp2_session_pop_next_ob_item(session));\n  CU_ASSERT(1 == nghttp2_outbound_queue_size(&session->ob_syn));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_reply_fail(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = fail_send_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n  ud.data_source_length = 4 * 1024;\n  CU_ASSERT(0 == nghttp2_session_server_new(&session, &callbacks, &ud));\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  CU_ASSERT(0 == nghttp2_submit_response(session, 1, NULL, 0, &data_prd));\n  CU_ASSERT(NGHTTP2_ERR_CALLBACK_FAILURE == nghttp2_session_send(session));\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_max_concurrent_streams(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  open_recv_stream(session, 1);\n\n  /* Check un-ACKed SETTINGS_MAX_CONCURRENT_STREAMS */\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 3,\n                             NGHTTP2_HCAT_HEADERS, NULL, NULL, 0);\n  session->pending_local_max_concurrent_stream = 1;\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_REFUSED_STREAM == item->frame.rst_stream.error_code);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Check ACKed SETTINGS_MAX_CONCURRENT_STREAMS */\n  session->local_settings.max_concurrent_streams = 1;\n  frame.hd.stream_id = 5;\n\n  CU_ASSERT(NGHTTP2_ERR_IGN_HEADER_BLOCK ==\n            nghttp2_session_on_request_headers_received(session, &frame));\n\n  item = nghttp2_outbound_queue_top(&session->ob_reg);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stop_data_with_rst_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.send_callback = block_count_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 4;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n  nghttp2_submit_response(session, 1, NULL, 0, &data_prd);\n\n  ud.block_count = 2;\n  /* Sends response HEADERS + DATA[0] */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_DATA == ud.sent_frame_type);\n  /* data for DATA[1] is read from data_prd but it is not sent */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  nghttp2_frame_rst_stream_init(&frame.rst_stream, 1, NGHTTP2_CANCEL);\n  CU_ASSERT(0 == nghttp2_session_on_rst_stream_received(session, &frame));\n  nghttp2_frame_rst_stream_free(&frame.rst_stream);\n\n  /* Big enough number to send all DATA frames potentially. */\n  ud.block_count = 100;\n  /* Nothing will be sent in the following call. */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* With RST_STREAM, stream is canceled and further DATA on that\n     stream are not sent. */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_defer_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.send_callback = block_count_send_callback;\n  data_prd.read_callback = defer_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 4;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  stream = open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  session->remote_window_size = 1 << 20;\n  stream->remote_window_size = 1 << 20;\n\n  nghttp2_submit_response(session, 1, NULL, 0, &data_prd);\n\n  ud.block_count = 1;\n  /* Sends HEADERS reply */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n  /* No data is read */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 4);\n\n  ud.block_count = 1;\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n  /* Sends PING */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_PING == ud.sent_frame_type);\n\n  /* Resume deferred DATA */\n  CU_ASSERT(0 == nghttp2_session_resume_data(session, 1));\n  item = stream->item;\n  item->aux_data.data.data_prd.read_callback =\n      fixed_length_data_source_read_callback;\n  ud.block_count = 1;\n  /* Reads 2 DATA chunks */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  /* Deferred again */\n  item->aux_data.data.data_prd.read_callback = defer_data_source_read_callback;\n  /* This is needed since 16KiB block is already read and waiting to be\n     sent. No read_callback invocation. */\n  ud.block_count = 1;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  /* Resume deferred DATA */\n  CU_ASSERT(0 == nghttp2_session_resume_data(session, 1));\n  item->aux_data.data.data_prd.read_callback =\n      fixed_length_data_source_read_callback;\n  ud.block_count = 1;\n  /* Reads 2 16KiB blocks */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(ud.data_source_length == 0);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flow_control(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  int32_t new_initial_window_size;\n  nghttp2_settings_entry iv[1];\n  nghttp2_frame settings_frame;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = fixed_bytes_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = 128 * 1024;\n  /* Use smaller emission count so that we can check outbound flow\n     control window calculation is correct. */\n  ud.fixed_sendlen = 2 * 1024;\n\n  /* Initial window size to 64KiB - 1*/\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  /* Change it to 64KiB for easy calculation */\n  session->remote_window_size = 64 * 1024;\n  session->remote_settings.initial_window_size = 64 * 1024;\n\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n\n  /* Sends 64KiB - 1 data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(64 * 1024 == ud.data_source_length);\n\n  /* Back 32KiB in stream window */\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   32 * 1024);\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Send nothing because of connection-level window */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(64 * 1024 == ud.data_source_length);\n\n  /* Back 32KiB in connection-level window */\n  frame.hd.stream_id = 0;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Sends another 32KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(32 * 1024 == ud.data_source_length);\n\n  stream = nghttp2_session_get_stream(session, 1);\n  /* Change initial window size to 16KiB. The window_size becomes\n     negative. */\n  new_initial_window_size = 16 * 1024;\n  stream->remote_window_size =\n      new_initial_window_size -\n      ((int32_t)session->remote_settings.initial_window_size -\n       stream->remote_window_size);\n  session->remote_settings.initial_window_size =\n      (uint32_t)new_initial_window_size;\n  CU_ASSERT(-48 * 1024 == stream->remote_window_size);\n\n  /* Back 48KiB to stream window */\n  frame.hd.stream_id = 1;\n  frame.window_update.window_size_increment = 48 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Nothing is sent because window_size is 0 */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(32 * 1024 == ud.data_source_length);\n\n  /* Back 16KiB in stream window */\n  frame.hd.stream_id = 1;\n  frame.window_update.window_size_increment = 16 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Back 24KiB in connection-level window */\n  frame.hd.stream_id = 0;\n  frame.window_update.window_size_increment = 24 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Sends another 16KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(16 * 1024 == ud.data_source_length);\n\n  /* Increase initial window size to 32KiB */\n  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[0].value = 32 * 1024;\n\n  nghttp2_frame_settings_init(&settings_frame.settings, NGHTTP2_FLAG_NONE,\n                              dup_iv(iv, 1), 1);\n  nghttp2_session_on_settings_received(session, &settings_frame, 1);\n  nghttp2_frame_settings_free(&settings_frame.settings, mem);\n\n  /* Sends another 8KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(8 * 1024 == ud.data_source_length);\n\n  /* Back 8KiB in connection-level window */\n  frame.hd.stream_id = 0;\n  frame.window_update.window_size_increment = 8 * 1024;\n  nghttp2_session_on_window_update_received(session, &frame);\n\n  /* Sends last 8KiB data */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.data_source_length);\n  CU_ASSERT(nghttp2_session_get_stream(session, 1)->shut_flags &\n            NGHTTP2_SHUT_WR);\n\n  nghttp2_frame_window_update_free(&frame.window_update);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flow_control_data_recv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t data[64 * 1024 + 16];\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  /* Initial window size to 64KiB - 1*/\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  stream = open_sent_stream(session, 1);\n\n  nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n\n  session->local_window_size = NGHTTP2_MAX_PAYLOADLEN;\n  stream->local_window_size = NGHTTP2_MAX_PAYLOADLEN;\n\n  /* Create DATA frame */\n  memset(data, 0, sizeof(data));\n  nghttp2_frame_hd_init(&hd, NGHTTP2_MAX_PAYLOADLEN, NGHTTP2_DATA,\n                        NGHTTP2_FLAG_END_STREAM, 1);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN ==\n            nghttp2_session_mem_recv(\n                session, data, NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN));\n\n  item = nghttp2_session_get_next_ob_item(session);\n  /* Since this is the last frame, stream-level WINDOW_UPDATE is not\n     issued, but connection-level is. */\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN ==\n            item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Receive DATA for closed stream. They are still subject to under\n     connection-level flow control, since this situation arises when\n     RST_STREAM is issued by the remote, but the local side keeps\n     sending DATA frames. Without calculating connection-level window,\n     the subsequent flow control gets confused. */\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN ==\n            nghttp2_session_mem_recv(\n                session, data, NGHTTP2_MAX_PAYLOADLEN + NGHTTP2_FRAME_HDLEN));\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_MAX_PAYLOADLEN ==\n            item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flow_control_data_with_padding_recv(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  uint8_t data[1024];\n  nghttp2_frame_hd hd;\n  nghttp2_stream *stream;\n  nghttp2_option *option;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_option_new(&option);\n  /* Disable auto window update so that we can check padding is\n     consumed automatically */\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  /* Initial window size to 64KiB - 1*/\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  nghttp2_option_del(option);\n\n  stream = open_sent_stream(session, 1);\n\n  /* Create DATA frame */\n  memset(data, 0, sizeof(data));\n  nghttp2_frame_hd_init(&hd, 357, NGHTTP2_DATA, NGHTTP2_FLAG_PADDED, 1);\n\n  nghttp2_frame_pack_frame_hd(data, &hd);\n  /* Set Pad Length field, which itself is padding */\n  data[NGHTTP2_FRAME_HDLEN] = 255;\n\n  CU_ASSERT(\n      (ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length) ==\n      nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + hd.length));\n\n  CU_ASSERT((int32_t)hd.length == session->recv_window_size);\n  CU_ASSERT((int32_t)hd.length == stream->recv_window_size);\n  CU_ASSERT(256 == session->consumed_size);\n  CU_ASSERT(256 == stream->consumed_size);\n  CU_ASSERT(357 == session->recv_window_size);\n  CU_ASSERT(357 == stream->recv_window_size);\n\n  /* Receive the same DATA frame, but in 2 parts: first 9 + 1 + 102\n     bytes which includes 1st padding byte, and remainder */\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + 103) ==\n            nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 103));\n  CU_ASSERT(258 == session->consumed_size);\n  CU_ASSERT(258 == stream->consumed_size);\n  CU_ASSERT(460 == session->recv_window_size);\n  CU_ASSERT(460 == stream->recv_window_size);\n\n  /* 357 - 103 = 254 bytes left */\n  CU_ASSERT(254 == nghttp2_session_mem_recv(session, data, 254));\n  CU_ASSERT(512 == session->consumed_size);\n  CU_ASSERT(512 == stream->consumed_size);\n  CU_ASSERT(714 == session->recv_window_size);\n  CU_ASSERT(714 == stream->recv_window_size);\n\n  /* Receive the same DATA frame, but in 2 parts: first 9 = 1 + 101\n     bytes which only includes data without padding, 2nd part is\n     padding only */\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + 102) ==\n            nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 102));\n  CU_ASSERT(513 == session->consumed_size);\n  CU_ASSERT(513 == stream->consumed_size);\n  CU_ASSERT(816 == session->recv_window_size);\n  CU_ASSERT(816 == stream->recv_window_size);\n\n  /* 357 - 102 = 255 bytes left */\n  CU_ASSERT(255 == nghttp2_session_mem_recv(session, data, 255));\n  CU_ASSERT(768 == session->consumed_size);\n  CU_ASSERT(768 == stream->consumed_size);\n  CU_ASSERT(1071 == session->recv_window_size);\n  CU_ASSERT(1071 == stream->recv_window_size);\n\n  /* Receive the same DATA frame, but in 2 parts: first 9 = 1 + 50\n     bytes which includes byte up to middle of data, 2nd part is the\n     remainder */\n  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + 51) ==\n            nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 51));\n  CU_ASSERT(769 == session->consumed_size);\n  CU_ASSERT(769 == stream->consumed_size);\n  CU_ASSERT(1122 == session->recv_window_size);\n  CU_ASSERT(1122 == stream->recv_window_size);\n\n  /* 357 - 51 = 306 bytes left */\n  CU_ASSERT(306 == nghttp2_session_mem_recv(session, data, 306));\n  CU_ASSERT(1024 == session->consumed_size);\n  CU_ASSERT(1024 == stream->consumed_size);\n  CU_ASSERT(1428 == session->recv_window_size);\n  CU_ASSERT(1428 == stream->recv_window_size);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_data_read_temporal_failure(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n  nghttp2_stream *stream;\n  size_t data_size = 128 * 1024;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.data_source_length = data_size;\n\n  /* Initial window size is 64KiB - 1 */\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n\n  /* Sends NGHTTP2_INITIAL_WINDOW_SIZE data, assuming, it is equal to\n     or smaller than NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(data_size - NGHTTP2_INITIAL_WINDOW_SIZE == ud.data_source_length);\n\n  stream = nghttp2_session_get_stream(session, 1);\n  CU_ASSERT(NGHTTP2_DATA == stream->item->frame.hd.type);\n\n  stream->item->aux_data.data.data_prd.read_callback =\n      temporal_failure_data_source_read_callback;\n\n  /* Back NGHTTP2_INITIAL_WINDOW_SIZE to both connection-level and\n     stream-wise window */\n  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,\n                                   NGHTTP2_INITIAL_WINDOW_SIZE);\n  nghttp2_session_on_window_update_received(session, &frame);\n  frame.hd.stream_id = 0;\n  nghttp2_session_on_window_update_received(session, &frame);\n  nghttp2_frame_window_update_free(&frame.window_update);\n\n  /* Sending data will fail (soft fail) and treated as stream error */\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(data_size - NGHTTP2_INITIAL_WINDOW_SIZE == ud.data_source_length);\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_RST_STREAM == ud.sent_frame_type);\n\n  data_prd.read_callback = fail_data_source_read_callback;\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n  /* Sending data will fail (hard fail) and session tear down */\n  CU_ASSERT(NGHTTP2_ERR_CALLBACK_FAILURE == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_stream_close(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n  user_data.stream_close_cb_called = 0;\n\n  nghttp2_session_client_new(&session, &callbacks, &user_data);\n  stream =\n      open_sent_stream3(session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec_default,\n                        NGHTTP2_STREAM_OPENED, &user_data);\n  CU_ASSERT(stream != NULL);\n  CU_ASSERT(nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR) == 0);\n  CU_ASSERT(user_data.stream_close_cb_called == 1);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_ctrl_not_send(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data user_data;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n  callbacks.send_callback = null_send_callback;\n  user_data.frame_not_send_cb_called = 0;\n  user_data.not_sent_frame_type = 0;\n  user_data.not_sent_error = 0;\n\n  nghttp2_session_server_new(&session, &callbacks, &user_data);\n  stream =\n      open_recv_stream3(session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec_default,\n                        NGHTTP2_STREAM_OPENING, &user_data);\n\n  /* Check response HEADERS */\n  /* Send bogus stream ID */\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 3,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_STREAM_CLOSED == user_data.not_sent_error);\n\n  user_data.frame_not_send_cb_called = 0;\n  /* Shutdown transmission */\n  stream->shut_flags |= NGHTTP2_SHUT_WR;\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_STREAM_SHUT_WR == user_data.not_sent_error);\n\n  stream->shut_flags = NGHTTP2_SHUT_NONE;\n  user_data.frame_not_send_cb_called = 0;\n  /* Queue RST_STREAM */\n  CU_ASSERT(0 == nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, 1,\n                                        NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1,\n                                           NGHTTP2_INTERNAL_ERROR));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_STREAM_CLOSING == user_data.not_sent_error);\n\n  nghttp2_session_del(session);\n\n  /* Check request HEADERS */\n  user_data.frame_not_send_cb_called = 0;\n  CU_ASSERT(nghttp2_session_client_new(&session, &callbacks, &user_data) == 0);\n  /* Maximum Stream ID is reached */\n  session->next_stream_id = (1u << 31) + 1;\n  CU_ASSERT(NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE ==\n            nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1, NULL,\n                                   NULL, 0, NULL));\n\n  user_data.frame_not_send_cb_called = 0;\n  /* GOAWAY received */\n  session->goaway_flags |= NGHTTP2_GOAWAY_RECV;\n  session->next_stream_id = 9;\n\n  CU_ASSERT(0 < nghttp2_submit_headers(session, NGHTTP2_FLAG_END_STREAM, -1,\n                                       NULL, NULL, 0, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == user_data.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == user_data.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_ERR_START_STREAM_NOT_ALLOWED == user_data.not_sent_error);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_get_outbound_queue_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n  CU_ASSERT(0 == nghttp2_session_get_outbound_queue_size(session));\n\n  CU_ASSERT(0 == nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL));\n  CU_ASSERT(1 == nghttp2_session_get_outbound_queue_size(session));\n\n  CU_ASSERT(0 == nghttp2_submit_goaway(session, NGHTTP2_FLAG_NONE, 2,\n                                       NGHTTP2_NO_ERROR, NULL, 0));\n  CU_ASSERT(2 == nghttp2_session_get_outbound_queue_size(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_get_effective_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  CU_ASSERT(0 == nghttp2_session_client_new(&session, &callbacks, NULL));\n\n  stream = open_sent_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(0 == nghttp2_session_get_effective_recv_data_length(session));\n\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(0 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  /* Check connection flow control */\n  session->recv_window_size = 100;\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, 1100);\n\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(0 == nghttp2_session_get_effective_recv_data_length(session));\n\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, -50);\n  /* Now session->recv_window_size = -50 */\n  CU_ASSERT(-50 == session->recv_window_size);\n  CU_ASSERT(50 == session->recv_reduction);\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 950 ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(0 == nghttp2_session_get_effective_recv_data_length(session));\n\n  session->recv_window_size += 50;\n\n  /* Now session->recv_window_size = 0 */\n\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 950 ==\n            nghttp2_session_get_local_window_size(session));\n\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 0, 100);\n  CU_ASSERT(50 == session->recv_window_size);\n  CU_ASSERT(0 == session->recv_reduction);\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1050 ==\n            nghttp2_session_get_effective_local_window_size(session));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(50 == nghttp2_session_get_effective_recv_data_length(session));\n\n  /* Check stream flow control */\n  stream->recv_window_size = 100;\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 1, 1100);\n\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(0 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 1, -50);\n  /* Now stream->recv_window_size = -50 */\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 950 ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(0 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  stream->recv_window_size += 50;\n  /* Now stream->recv_window_size = 0 */\n  nghttp2_submit_window_update(session, NGHTTP2_FLAG_NONE, 1, 100);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1050 ==\n            nghttp2_session_get_stream_effective_local_window_size(session, 1));\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE + 1000 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(50 ==\n            nghttp2_session_get_stream_effective_recv_data_length(session, 1));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_set_option(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_option *option;\n  nghttp2_hd_deflater *deflater;\n  int rv;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  /* Test for nghttp2_option_set_no_auto_window_update */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_window_update(option, 1);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_peer_max_concurrent_streams */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_peer_max_concurrent_streams(option, 100);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(100 == session->remote_settings.max_concurrent_streams);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_max_reserved_remote_streams */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_max_reserved_remote_streams(option, 99);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(99 == session->max_incoming_reserved_streams);\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_no_auto_ping_ack */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_auto_ping_ack(option, 1);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  CU_ASSERT(session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_PING_ACK);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n\n  /* Test for nghttp2_option_set_max_deflate_dynamic_table_size */\n  nghttp2_option_new(&option);\n  nghttp2_option_set_max_deflate_dynamic_table_size(option, 0);\n\n  nghttp2_session_client_new2(&session, &callbacks, NULL, option);\n\n  deflater = &session->hd_deflater;\n\n  rv = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(1 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == deflater->deflate_hd_table_bufsize_max);\n  CU_ASSERT(0 == deflater->ctx.hd_table_bufsize);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_data_backoff_by_high_pri_frame(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_data_provider data_prd;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 4;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n\n  session->remote_window_size = 1 << 20;\n\n  ud.block_count = 2;\n  /* Sends request HEADERS + DATA[0] */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  stream = nghttp2_session_get_stream(session, 1);\n  stream->remote_window_size = 1 << 20;\n\n  CU_ASSERT(NGHTTP2_DATA == ud.sent_frame_type);\n  /* data for DATA[1] is read from data_prd but it is not sent */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN * 2);\n\n  nghttp2_submit_ping(session, NGHTTP2_FLAG_NONE, NULL);\n  ud.block_count = 2;\n  /* Sends DATA[1] + PING, PING is interleaved in DATA sequence */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_PING == ud.sent_frame_type);\n  /* data for DATA[2] is read from data_prd but it is not sent */\n  CU_ASSERT(ud.data_source_length == NGHTTP2_DATA_PAYLOADLEN);\n\n  ud.block_count = 2;\n  /* Sends DATA[2..3] */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(stream->shut_flags & NGHTTP2_SHUT_WR);\n\n  nghttp2_session_del(session);\n}\n\nstatic void check_session_recv_data_with_padding(nghttp2_bufs *bufs,\n                                                 size_t datalen,\n                                                 nghttp2_mem *mem) {\n  nghttp2_session *session;\n  my_user_data ud;\n  nghttp2_session_callbacks callbacks;\n  uint8_t *in;\n  size_t inlen;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_data_chunk_recv_callback = on_data_chunk_recv_callback;\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  inlen = (size_t)nghttp2_bufs_remove(bufs, &in);\n\n  ud.frame_recv_cb_called = 0;\n  ud.data_chunk_len = 0;\n\n  CU_ASSERT((ssize_t)inlen == nghttp2_session_mem_recv(session, in, inlen));\n\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(datalen == ud.data_chunk_len);\n\n  mem->free(in, NULL);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_pack_data_with_padding(void) {\n  nghttp2_session *session;\n  my_user_data ud;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame *frame;\n  size_t datalen = 55;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = block_count_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.select_padding_callback = select_padding_callback;\n\n  data_prd.read_callback = fixed_length_data_source_read_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  ud.padlen = 63;\n\n  nghttp2_submit_request(session, NULL, NULL, 0, &data_prd, NULL);\n  ud.block_count = 1;\n  ud.data_source_length = datalen;\n  /* Sends HEADERS */\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(NGHTTP2_HEADERS == ud.sent_frame_type);\n\n  frame = &session->aob.item->frame;\n\n  CU_ASSERT(ud.padlen == frame->data.padlen);\n  CU_ASSERT(frame->hd.flags & NGHTTP2_FLAG_PADDED);\n\n  /* Check reception of this DATA frame */\n  check_session_recv_data_with_padding(&session->aob.framebufs, datalen, mem);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_pack_headers_with_padding(void) {\n  nghttp2_session *session, *sv_session;\n  accumulator acc;\n  my_user_data ud;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.select_padding_callback = select_padding_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n\n  acc.length = 0;\n  ud.acc = &acc;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n  nghttp2_session_server_new(&sv_session, &callbacks, &ud);\n\n  ud.padlen = 163;\n\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                        NULL, NULL));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(acc.length < NGHTTP2_MAX_PAYLOADLEN);\n  ud.frame_recv_cb_called = 0;\n  CU_ASSERT((ssize_t)acc.length ==\n            nghttp2_session_mem_recv(sv_session, acc.buf, acc.length));\n  CU_ASSERT(1 == ud.frame_recv_cb_called);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(sv_session));\n\n  nghttp2_session_del(sv_session);\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_pack_settings_payload(void) {\n  nghttp2_settings_entry iv[2];\n  uint8_t buf[64];\n  ssize_t len;\n  nghttp2_settings_entry *resiv;\n  size_t resniv;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 1023;\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 4095;\n\n  len = nghttp2_pack_settings_payload(buf, sizeof(buf), iv, 2);\n  CU_ASSERT(2 * NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH == len);\n  CU_ASSERT(0 == nghttp2_frame_unpack_settings_payload2(&resiv, &resniv, buf,\n                                                        (size_t)len, mem));\n  CU_ASSERT(2 == resniv);\n  CU_ASSERT(NGHTTP2_SETTINGS_HEADER_TABLE_SIZE == resiv[0].settings_id);\n  CU_ASSERT(1023 == resiv[0].value);\n  CU_ASSERT(NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE == resiv[1].settings_id);\n  CU_ASSERT(4095 == resiv[1].value);\n\n  mem->free(resiv, NULL);\n\n  len = nghttp2_pack_settings_payload(buf, 9 /* too small */, iv, 2);\n  CU_ASSERT(NGHTTP2_ERR_INSUFF_BUFSIZE == len);\n}\n\n#define check_stream_dep_sib(STREAM, DEP_PREV, DEP_NEXT, SIB_PREV, SIB_NEXT)   \\\n  do {                                                                         \\\n    CU_ASSERT(DEP_PREV == STREAM->dep_prev);                                   \\\n    CU_ASSERT(DEP_NEXT == STREAM->dep_next);                                   \\\n    CU_ASSERT(SIB_PREV == STREAM->sib_prev);                                   \\\n    CU_ASSERT(SIB_NEXT == STREAM->sib_next);                                   \\\n  } while (0)\n\n/* nghttp2_stream_dep_add() and its families functions should be\n   tested in nghttp2_stream_test.c, but it is easier to use\n   nghttp2_session_open_stream().  Therefore, we test them here. */\nvoid test_nghttp2_session_stream_dep_add(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n\n  c = open_stream_with_dep(session, 5, a);\n  b = open_stream_with_dep(session, 3, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * b--c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, c);\n  check_stream_dep_sib(c, a, d, b, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(a == session->root.dep_next);\n\n  e = open_stream_with_dep_excl(session, 9, a);\n\n  /* a\n   * |\n   * e\n   * |\n   * b--c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == e->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(e, a, b, NULL, NULL);\n  check_stream_dep_sib(b, e, NULL, NULL, c);\n  check_stream_dep_sib(c, e, d, b, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(a == session->root.dep_next);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_remove(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *f, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* Remove root */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove(a);\n\n  /* becomes:\n   * c    b\n   * |\n   * d\n   */\n\n  CU_ASSERT(0 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(b, root, NULL, c, NULL);\n  check_stream_dep_sib(c, root, d, NULL, b);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(c == session->root.dep_next);\n\n  nghttp2_session_del(session);\n\n  /* Remove right most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove(b);\n\n  /* becomes:\n   * a\n   * |\n   * c\n   * |\n   * d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, c, NULL, NULL);\n  check_stream_dep_sib(b, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(c, a, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  CU_ASSERT(a == session->root.dep_next);\n\n  nghttp2_session_del(session);\n\n  /* Remove left most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n  e = open_stream_with_dep(session, 9, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * e--d\n   */\n\n  nghttp2_stream_dep_remove(c);\n\n  /* becomes:\n   * a\n   * |\n   * e--d--b\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == c->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, d, NULL);\n  check_stream_dep_sib(c, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(d, a, NULL, e, b);\n  check_stream_dep_sib(e, a, NULL, NULL, d);\n\n  nghttp2_session_del(session);\n\n  /* Remove middle stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, a);\n  e = open_stream_with_dep(session, 9, c);\n  f = open_stream_with_dep(session, 11, c);\n\n  /* a\n   * |\n   * d--c--b\n   *    |\n   *    f--e\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 3 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  nghttp2_stream_dep_remove(c);\n\n  /* becomes:\n   * a\n   * |\n   * d--f--e--b\n   */\n\n  /* c's weight 16 is distributed evenly to e and f.  Each weight of e\n     and f becomes 8. */\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 + 8 * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(0 == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, d, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, e, NULL);\n  check_stream_dep_sib(c, NULL, NULL, NULL, NULL);\n  check_stream_dep_sib(e, a, NULL, f, b);\n  check_stream_dep_sib(f, a, NULL, d, e);\n  check_stream_dep_sib(d, a, NULL, NULL, f);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_add_subtree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *f, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* dep_stream has dep_next */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  e = open_stream(session, 9);\n  f = open_stream_with_dep(session, 11, e);\n\n  /* a         e\n   * |         |\n   * c--b      f\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(e);\n  nghttp2_stream_dep_add_subtree(a, e);\n\n  /* becomes\n   * a\n   * |\n   * e--c--b\n   * |  |\n   * f  d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 3 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, c, NULL);\n  check_stream_dep_sib(c, a, d, e, b);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n  check_stream_dep_sib(e, a, f, NULL, c);\n  check_stream_dep_sib(f, e, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  /* dep_stream has dep_next and now we insert subtree */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  e = open_stream(session, 9);\n  f = open_stream_with_dep(session, 11, e);\n\n  /* a         e\n   * |         |\n   * c--b      f\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(e);\n  nghttp2_stream_dep_insert_subtree(a, e);\n\n  /* becomes\n   * a\n   * |\n   * e\n   * |\n   * f--c--b\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 3 == e->sum_dep_weight);\n  CU_ASSERT(0 == f->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, e, NULL, NULL);\n  check_stream_dep_sib(e, a, f, NULL, NULL);\n  check_stream_dep_sib(f, e, NULL, NULL, c);\n  check_stream_dep_sib(b, e, NULL, c, NULL);\n  check_stream_dep_sib(c, e, d, f, b);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_remove_subtree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *root;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* Remove left most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n\n  /* becomes\n   * a  c\n   * |  |\n   * b  d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n  check_stream_dep_sib(c, NULL, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  /* Remove right most stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  nghttp2_stream_dep_remove_subtree(b);\n\n  /* becomes\n   * a  b\n   * |\n   * c\n   * |\n   * d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, c, NULL, NULL);\n  check_stream_dep_sib(c, a, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n  check_stream_dep_sib(b, NULL, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  /* Remove middle stream */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  e = open_stream_with_dep(session, 9, a);\n  c = open_stream_with_dep(session, 5, a);\n  b = open_stream_with_dep(session, 3, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * b--c--e\n   *    |\n   *    d\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n\n  /* becomes\n   * a     c\n   * |     |\n   * b--e  d\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(0 == e->sum_dep_weight);\n\n  check_stream_dep_sib(a, root, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, e);\n  check_stream_dep_sib(e, a, NULL, b, NULL);\n  check_stream_dep_sib(c, NULL, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *root;\n  nghttp2_outbound_item *db, *dc;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n\n  /* a     c\n   * |\n   * b\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * a\n   * |\n   * b\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == c->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n\n  check_stream_dep_sib(c, root, a, NULL, NULL);\n  check_stream_dep_sib(a, c, b, NULL, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream(session, 3);\n  c = open_stream(session, 5);\n\n  /*\n   * a  b   c\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * b--a\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == c->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n  CU_ASSERT(0 == a->sum_dep_weight);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n\n  check_stream_dep_sib(c, root, b, NULL, NULL);\n  check_stream_dep_sib(b, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, NULL, b, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a     c\n   * |     |\n   * b     d\n   */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * d--a\n   *    |\n   *    b\n   */\n\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT * 2 == c->sum_dep_weight);\n  CU_ASSERT(0 == d->sum_dep_weight);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == a->sum_dep_weight);\n  CU_ASSERT(0 == b->sum_dep_weight);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  check_stream_dep_sib(c, root, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, b, d, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a     c\n   * |     |\n   * b     d\n   */\n\n  db = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * d--a\n   *    |\n   *    b\n   */\n\n  CU_ASSERT(c->queued);\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  check_stream_dep_sib(c, root, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, b, d, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  root = &session->root;\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n\n  c = open_stream(session, 5);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a     c\n   * |     |\n   * b     d\n   */\n\n  db = create_data_ob_item(mem);\n  dc = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n  nghttp2_stream_attach_item(c, dc);\n\n  nghttp2_stream_dep_remove_subtree(c);\n  CU_ASSERT(0 == nghttp2_stream_dep_insert_subtree(&session->root, c));\n\n  /*\n   * c\n   * |\n   * d--a\n   *    |\n   *    b\n   */\n\n  CU_ASSERT(c->queued);\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!d->queued);\n\n  check_stream_dep_sib(c, root, d, NULL, NULL);\n  check_stream_dep_sib(d, c, NULL, NULL, a);\n  check_stream_dep_sib(a, c, b, d, NULL);\n  check_stream_dep_sib(b, a, NULL, NULL, NULL);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_attach_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e;\n  nghttp2_outbound_item *da, *db, *dc, *dd;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  db = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n\n  /* Attach item to c */\n  dc = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(c, dc);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n\n  /* Attach item to a */\n  da = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(a, da);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n\n  /* Detach item from a */\n  nghttp2_stream_detach_item(a);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n\n  /* Attach item to d */\n  dd = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(d, dd);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n\n  /* Detach item from c */\n  nghttp2_stream_detach_item(c);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n\n  /* Detach item from b */\n  nghttp2_stream_detach_item(b);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(!b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n\n  /* exercises insertion */\n  e = open_stream_with_dep_excl(session, 9, a);\n\n  /* a\n   * |\n   * e\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* exercises deletion */\n  nghttp2_stream_dep_remove(e);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(!b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* e's weight 16 is distributed equally among c and b, both now have\n     weight 8 each. */\n  CU_ASSERT(8 == b->weight);\n  CU_ASSERT(8 == c->weight);\n\n  /* da, db, dc have been detached */\n  nghttp2_outbound_item_free(da, mem);\n  nghttp2_outbound_item_free(db, mem);\n  nghttp2_outbound_item_free(dc, mem);\n  free(da);\n  free(db);\n  free(dc);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  /* a\n   * |\n   * c--b\n   * |\n   * d\n   */\n\n  da = create_data_ob_item(mem);\n  db = create_data_ob_item(mem);\n  dc = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(a, da);\n  nghttp2_stream_attach_item(b, db);\n  nghttp2_stream_attach_item(c, dc);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* Detach item from a */\n  nghttp2_stream_detach_item(a);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(!d->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n\n  /* da has been detached */\n  nghttp2_outbound_item_free(da, mem);\n  free(da);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_attach_item_subtree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c, *d, *e, *f;\n  nghttp2_outbound_item *da, *db, *dd, *de;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep(session, 5, a);\n  d = open_stream_with_dep(session, 7, c);\n\n  e = open_stream_with_dep_weight(session, 9, 32, &session->root);\n  f = open_stream_with_dep(session, 11, e);\n\n  /*\n   * a        e\n   * |        |\n   * c--b     f\n   * |\n   * d\n   */\n\n  de = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(e, de);\n\n  db = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(b, db);\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Insert subtree e under a */\n\n  nghttp2_stream_dep_remove_subtree(e);\n  nghttp2_stream_dep_insert_subtree(a, e);\n\n  /*\n   * a\n   * |\n   * e\n   * |\n   * f--c--b\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree b */\n\n  nghttp2_stream_dep_remove_subtree(b);\n\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, b));\n\n  /*\n   * a       b\n   * |\n   * e\n   * |\n   * f--c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree a, and add it to root again */\n\n  nghttp2_stream_dep_remove_subtree(a);\n\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, a));\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree c */\n\n  nghttp2_stream_dep_remove_subtree(c);\n\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, c));\n\n  /*\n   * a       b     c\n   * |             |\n   * e             d\n   * |\n   * f\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(!c->queued);\n  CU_ASSERT(!d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(nghttp2_pq_empty(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  dd = create_data_ob_item(mem);\n\n  nghttp2_stream_attach_item(d, dd);\n\n  /* Add subtree c to a */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  nghttp2_stream_dep_add_subtree(a, c);\n\n  /*\n   * a       b\n   * |\n   * c--e\n   * |  |\n   * d  f\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(2 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(nghttp2_pq_empty(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Insert b under a */\n\n  nghttp2_stream_dep_remove_subtree(b);\n  nghttp2_stream_dep_insert_subtree(a, b);\n\n  /*\n   * a\n   * |\n   * b\n   * |\n   * c--e\n   * |  |\n   * d  f\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(1 == nghttp2_pq_size(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree b */\n\n  nghttp2_stream_dep_remove_subtree(b);\n  CU_ASSERT(0 == nghttp2_stream_dep_add_subtree(&session->root, b));\n\n  /*\n   * b       a\n   * |\n   * e--c\n   * |  |\n   * f  d\n   */\n\n  CU_ASSERT(!a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree c, and detach item from b, and then re-add\n     subtree c under b */\n\n  nghttp2_stream_dep_remove_subtree(c);\n  nghttp2_stream_detach_item(b);\n  nghttp2_stream_dep_add_subtree(b, c);\n\n  /*\n   * b       a\n   * |\n   * e--c\n   * |  |\n   * f  d\n   */\n\n  CU_ASSERT(!a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Attach data to a, and add subtree a under b */\n\n  da = create_data_ob_item(mem);\n  nghttp2_stream_attach_item(a, da);\n  nghttp2_stream_dep_remove_subtree(a);\n  nghttp2_stream_dep_add_subtree(b, a);\n\n  /*\n   * b\n   * |\n   * a--e--c\n   *    |  |\n   *    f  d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(!f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(3 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(nghttp2_pq_empty(&e->obq));\n  CU_ASSERT(nghttp2_pq_empty(&f->obq));\n\n  /* Remove subtree c, and add under f */\n  nghttp2_stream_dep_remove_subtree(c);\n  nghttp2_stream_dep_insert_subtree(f, c);\n\n  /*\n   * b\n   * |\n   * a--e\n   *    |\n   *    f\n   *    |\n   *    c\n   *    |\n   *    d\n   */\n\n  CU_ASSERT(a->queued);\n  CU_ASSERT(b->queued);\n  CU_ASSERT(c->queued);\n  CU_ASSERT(d->queued);\n  CU_ASSERT(e->queued);\n  CU_ASSERT(f->queued);\n\n  CU_ASSERT(nghttp2_pq_empty(&a->obq));\n  CU_ASSERT(2 == nghttp2_pq_size(&b->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&c->obq));\n  CU_ASSERT(nghttp2_pq_empty(&d->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&e->obq));\n  CU_ASSERT(1 == nghttp2_pq_size(&f->obq));\n\n  /* db has been detached */\n  nghttp2_outbound_item_free(db, mem);\n  free(db);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_stream_get_state(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_mem *mem;\n  nghttp2_hd_deflater deflater;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_stream *stream;\n  ssize_t rv;\n  nghttp2_data_provider data_prd;\n  nghttp2_frame frame;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n  memset(&data_prd, 0, sizeof(data_prd));\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_IDLE ==\n            nghttp2_stream_get_state(nghttp2_session_get_root_stream(session)));\n\n  /* stream 1 HEADERS; without END_STREAM flag set */\n  pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 1);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(1 == stream->stream_id);\n  CU_ASSERT(NGHTTP2_STREAM_STATE_OPEN == nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* stream 3 HEADERS; with END_STREAM flag set */\n  pack_headers(&bufs, &deflater, 3,\n               NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 3);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(3 == stream->stream_id);\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE ==\n            nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Respond to stream 1 */\n  nghttp2_submit_response(session, 1, resnv, ARRLEN(resnv), NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  /* Respond to stream 3 */\n  nghttp2_submit_response(session, 3, resnv, ARRLEN(resnv), NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 3);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_CLOSED == nghttp2_stream_get_state(stream));\n\n  /* stream 5 HEADERS; with END_STREAM flag set */\n  pack_headers(&bufs, &deflater, 5,\n               NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n               ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Push stream 2 associated to stream 5 */\n  rv = nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 5, reqnv,\n                                   ARRLEN(reqnv), NULL);\n\n  CU_ASSERT(2 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_RESERVED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  /* Send resposne to push stream 2 with END_STREAM set */\n  nghttp2_submit_response(session, 2, resnv, ARRLEN(resnv), NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  /* At server, pushed stream object is not retained after closed */\n  CU_ASSERT(NULL == stream);\n\n  /* Push stream 4 associated to stream 5 */\n  rv = nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 5, reqnv,\n                                   ARRLEN(reqnv), NULL);\n\n  CU_ASSERT(4 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 4);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_RESERVED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  /* Send response to push stream 4 without closing */\n  data_prd.read_callback = defer_data_source_read_callback;\n\n  nghttp2_submit_response(session, 4, resnv, ARRLEN(resnv), &data_prd);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  stream = nghttp2_session_find_stream(session, 4);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE ==\n            nghttp2_stream_get_state(stream));\n\n  /* Create idle stream by PRIORITY frame */\n  nghttp2_frame_priority_init(&frame.priority, 7, &pri_spec_default);\n\n  rv = nghttp2_frame_pack_priority(&bufs, &frame.priority);\n\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 7);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_IDLE == nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* Test for client side */\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  /* Receive PUSH_PROMISE 2 associated to stream 1 */\n  pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2, reqnv,\n                    ARRLEN(reqnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_RESERVED_REMOTE ==\n            nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Receive push response for stream 2 without END_STREAM set */\n  pack_headers(&bufs, &deflater, 2, NGHTTP2_FLAG_END_HEADERS, resnv,\n               ARRLEN(resnv), mem);\n\n  buf = &bufs.head->buf;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL ==\n            nghttp2_stream_get_state(stream));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_stream_get_something(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a, *b, *c;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_stream(session, 1);\n\n  CU_ASSERT(nghttp2_session_get_root_stream(session) ==\n            nghttp2_stream_get_parent(a));\n  CU_ASSERT(NULL == nghttp2_stream_get_previous_sibling(a));\n  CU_ASSERT(NULL == nghttp2_stream_get_next_sibling(a));\n  CU_ASSERT(NULL == nghttp2_stream_get_first_child(a));\n\n  b = open_stream_with_dep(session, 3, a);\n  c = open_stream_with_dep_weight(session, 5, 11, a);\n\n  CU_ASSERT(a == nghttp2_stream_get_parent(c));\n  CU_ASSERT(a == nghttp2_stream_get_parent(b));\n\n  CU_ASSERT(c == nghttp2_stream_get_first_child(a));\n\n  CU_ASSERT(b == nghttp2_stream_get_next_sibling(c));\n  CU_ASSERT(c == nghttp2_stream_get_previous_sibling(b));\n\n  CU_ASSERT(27 == nghttp2_stream_get_sum_dependency_weight(a));\n\n  CU_ASSERT(11 == nghttp2_stream_get_weight(c));\n  CU_ASSERT(5 == nghttp2_stream_get_stream_id(c));\n  CU_ASSERT(0 == nghttp2_stream_get_stream_id(&session->root));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_find_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  open_recv_stream(session, 1);\n\n  stream = nghttp2_session_find_stream(session, 1);\n\n  CU_ASSERT(NULL != stream);\n  CU_ASSERT(1 == stream->stream_id);\n\n  stream = nghttp2_session_find_stream(session, 0);\n\n  CU_ASSERT(&session->root == stream);\n  CU_ASSERT(0 == stream->stream_id);\n\n  stream = nghttp2_session_find_stream(session, 2);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_keep_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const size_t max_concurrent_streams = 5;\n  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,\n                               (uint32_t)max_concurrent_streams};\n  size_t i;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  for (i = 0; i < max_concurrent_streams; ++i) {\n    open_recv_stream(session, (int32_t)i * 2 + 1);\n  }\n\n  CU_ASSERT(0 == session->num_closed_streams);\n\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(1 == session->closed_stream_tail->stream_id);\n  CU_ASSERT(session->closed_stream_tail == session->closed_stream_head);\n\n  nghttp2_session_close_stream(session, 5, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(2 == session->num_closed_streams);\n  CU_ASSERT(5 == session->closed_stream_tail->stream_id);\n  CU_ASSERT(1 == session->closed_stream_head->stream_id);\n  CU_ASSERT(session->closed_stream_head ==\n            session->closed_stream_tail->closed_prev);\n  CU_ASSERT(NULL == session->closed_stream_tail->closed_next);\n  CU_ASSERT(session->closed_stream_tail ==\n            session->closed_stream_head->closed_next);\n  CU_ASSERT(NULL == session->closed_stream_head->closed_prev);\n\n  open_recv_stream(session, 11);\n  nghttp2_session_adjust_closed_stream(session);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(5 == session->closed_stream_tail->stream_id);\n  CU_ASSERT(session->closed_stream_tail == session->closed_stream_head);\n  CU_ASSERT(NULL == session->closed_stream_head->closed_prev);\n  CU_ASSERT(NULL == session->closed_stream_head->closed_next);\n\n  open_recv_stream(session, 13);\n  nghttp2_session_adjust_closed_stream(session);\n\n  CU_ASSERT(0 == session->num_closed_streams);\n  CU_ASSERT(NULL == session->closed_stream_tail);\n  CU_ASSERT(NULL == session->closed_stream_head);\n\n  nghttp2_session_close_stream(session, 3, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(3 == session->closed_stream_head->stream_id);\n\n  /* server initiated stream is not counted to max concurrent limit */\n  open_sent_stream(session, 2);\n  nghttp2_session_adjust_closed_stream(session);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(3 == session->closed_stream_head->stream_id);\n\n  nghttp2_session_close_stream(session, 2, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(1 == session->num_closed_streams);\n  CU_ASSERT(3 == session->closed_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_keep_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const size_t max_concurrent_streams = 1;\n  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,\n                               (uint32_t)max_concurrent_streams};\n  int i;\n  int32_t stream_id;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  /* We at least allow NGHTTP2_MIN_IDLE_STREAM idle streams even if\n     max concurrent streams is very low. */\n  for (i = 0; i < NGHTTP2_MIN_IDLE_STREAMS; ++i) {\n    open_recv_stream2(session, i * 2 + 1, NGHTTP2_STREAM_IDLE);\n    nghttp2_session_adjust_idle_stream(session);\n  }\n\n  CU_ASSERT(NGHTTP2_MIN_IDLE_STREAMS == session->num_idle_streams);\n\n  stream_id = (NGHTTP2_MIN_IDLE_STREAMS - 1) * 2 + 1;\n  CU_ASSERT(1 == session->idle_stream_head->stream_id);\n  CU_ASSERT(stream_id == session->idle_stream_tail->stream_id);\n\n  stream_id += 2;\n\n  open_recv_stream2(session, stream_id, NGHTTP2_STREAM_IDLE);\n  nghttp2_session_adjust_idle_stream(session);\n\n  CU_ASSERT(NGHTTP2_MIN_IDLE_STREAMS == session->num_idle_streams);\n  CU_ASSERT(3 == session->idle_stream_head->stream_id);\n  CU_ASSERT(stream_id == session->idle_stream_tail->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_detach_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  int i;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  for (i = 1; i <= 3; ++i) {\n    nghttp2_session_open_stream(session, i, NGHTTP2_STREAM_FLAG_NONE,\n                                &pri_spec_default, NGHTTP2_STREAM_IDLE, NULL);\n  }\n\n  CU_ASSERT(3 == session->num_idle_streams);\n\n  /* Detach middle stream */\n  stream = nghttp2_session_get_stream_raw(session, 2);\n\n  CU_ASSERT(session->idle_stream_head == stream->closed_prev);\n  CU_ASSERT(session->idle_stream_tail == stream->closed_next);\n  CU_ASSERT(stream == session->idle_stream_head->closed_next);\n  CU_ASSERT(stream == session->idle_stream_tail->closed_prev);\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(2 == session->num_idle_streams);\n\n  CU_ASSERT(NULL == stream->closed_prev);\n  CU_ASSERT(NULL == stream->closed_next);\n\n  CU_ASSERT(session->idle_stream_head ==\n            session->idle_stream_tail->closed_prev);\n  CU_ASSERT(session->idle_stream_tail ==\n            session->idle_stream_head->closed_next);\n\n  /* Detach head stream */\n  stream = session->idle_stream_head;\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(1 == session->num_idle_streams);\n\n  CU_ASSERT(session->idle_stream_head == session->idle_stream_tail);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_prev);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_next);\n\n  /* Detach last stream */\n\n  stream = session->idle_stream_head;\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(0 == session->num_idle_streams);\n\n  CU_ASSERT(NULL == session->idle_stream_head);\n  CU_ASSERT(NULL == session->idle_stream_tail);\n\n  for (i = 4; i <= 5; ++i) {\n    nghttp2_session_open_stream(session, i, NGHTTP2_STREAM_FLAG_NONE,\n                                &pri_spec_default, NGHTTP2_STREAM_IDLE, NULL);\n  }\n\n  CU_ASSERT(2 == session->num_idle_streams);\n\n  /* Detach tail stream */\n\n  stream = session->idle_stream_tail;\n\n  nghttp2_session_detach_idle_stream(session, stream);\n\n  CU_ASSERT(1 == session->num_idle_streams);\n\n  CU_ASSERT(session->idle_stream_head == session->idle_stream_tail);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_prev);\n  CU_ASSERT(NULL == session->idle_stream_head->closed_next);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_large_dep_tree(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  size_t i;\n  nghttp2_stream *dep_stream = NULL;\n  nghttp2_stream *stream;\n  int32_t stream_id;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream_id = 1;\n  for (i = 0; i < 250; ++i, stream_id += 2) {\n    dep_stream = open_stream_with_dep(session, stream_id, dep_stream);\n  }\n\n  stream_id = 1;\n  for (i = 0; i < 250; ++i, stream_id += 2) {\n    stream = nghttp2_session_get_stream(session, stream_id);\n    CU_ASSERT(nghttp2_stream_dep_find_ancestor(stream, &session->root));\n    CU_ASSERT(nghttp2_stream_in_dep_tree(stream));\n  }\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_graceful_shutdown(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 301);\n  open_sent_stream(session, 302);\n  open_recv_stream(session, 309);\n  open_recv_stream(session, 311);\n  open_recv_stream(session, 319);\n\n  CU_ASSERT(0 == nghttp2_submit_shutdown_notice(session));\n\n  ud.frame_send_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT((1u << 31) - 1 == session->local_last_stream_id);\n\n  CU_ASSERT(0 == nghttp2_submit_goaway(session, NGHTTP2_FLAG_NONE, 311,\n                                       NGHTTP2_NO_ERROR, NULL, 0));\n\n  ud.frame_send_cb_called = 0;\n  ud.stream_close_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(311 == session->local_last_stream_id);\n  CU_ASSERT(1 == ud.stream_close_cb_called);\n\n  CU_ASSERT(0 ==\n            nghttp2_session_terminate_session2(session, 301, NGHTTP2_NO_ERROR));\n\n  ud.frame_send_cb_called = 0;\n  ud.stream_close_cb_called = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(301 == session->local_last_stream_id);\n  CU_ASSERT(2 == ud.stream_close_cb_called);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 301));\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 302));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 309));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 311));\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 319));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_header_temporal_failure(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_hd_deflater deflater;\n  nghttp2_nv nv[] = {MAKE_NV(\"alpha\", \"bravo\"), MAKE_NV(\"charlie\", \"delta\")};\n  nghttp2_nv *nva;\n  size_t hdpos;\n  ssize_t rv;\n  nghttp2_frame frame;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n  nghttp2_mem *mem;\n\n  mem = nghttp2_mem_default();\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.on_header_callback = temporal_failure_on_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  frame_pack_bufs_init(&bufs);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nghttp2_nv_array_copy(&nva, reqnv, ARRLEN(reqnv), mem);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_STREAM, 1,\n                             NGHTTP2_HCAT_REQUEST, NULL, nva, ARRLEN(reqnv));\n  nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  /* We are going to create CONTINUATION.  First serialize header\n     block, and then frame header. */\n  hdpos = nghttp2_bufs_len(&bufs);\n\n  buf = &bufs.head->buf;\n  buf->last += NGHTTP2_FRAME_HDLEN;\n\n  nghttp2_hd_deflate_hd_bufs(&deflater, &bufs, &nv[1], 1);\n\n  nghttp2_frame_hd_init(&hd,\n                        nghttp2_bufs_len(&bufs) - hdpos - NGHTTP2_FRAME_HDLEN,\n                        NGHTTP2_CONTINUATION, NGHTTP2_FLAG_END_HEADERS, 1);\n\n  nghttp2_frame_pack_frame_hd(&buf->pos[hdpos], &hd);\n\n  ud.header_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.header_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n\n  /* Make sure no header decompression error occurred */\n  CU_ASSERT(NGHTTP2_GOAWAY_NONE == session->goaway_flags);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Check for PUSH_PROMISE */\n  nghttp2_hd_deflate_init(&deflater, mem);\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  open_sent_stream(session, 1);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  ud.header_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(1 == ud.header_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(2 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INTERNAL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_recv_client_magic(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  ssize_t rv;\n  nghttp2_frame ping_frame;\n  uint8_t buf[16];\n\n  /* enable global nghttp2_enable_strict_preface here */\n  nghttp2_enable_strict_preface = 1;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* Check success case */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  rv = nghttp2_session_mem_recv(session, (const uint8_t *)NGHTTP2_CLIENT_MAGIC,\n                                NGHTTP2_CLIENT_MAGIC_LEN);\n\n  CU_ASSERT(rv == NGHTTP2_CLIENT_MAGIC_LEN);\n  CU_ASSERT(NGHTTP2_IB_READ_FIRST_SETTINGS == session->iframe.state);\n\n  /* Receiving PING is error because we want SETTINGS. */\n  nghttp2_frame_ping_init(&ping_frame.ping, NGHTTP2_FLAG_NONE, NULL);\n\n  nghttp2_frame_pack_frame_hd(buf, &ping_frame.ping.hd);\n\n  rv = nghttp2_session_mem_recv(session, buf, NGHTTP2_FRAME_HDLEN);\n  CU_ASSERT(NGHTTP2_FRAME_HDLEN == rv);\n  CU_ASSERT(NGHTTP2_IB_IGN_ALL == session->iframe.state);\n  CU_ASSERT(0 == session->iframe.payloadleft);\n\n  nghttp2_frame_ping_free(&ping_frame.ping);\n\n  nghttp2_session_del(session);\n\n  /* Check bad case */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Feed magic with one byte less */\n  rv = nghttp2_session_mem_recv(session, (const uint8_t *)NGHTTP2_CLIENT_MAGIC,\n                                NGHTTP2_CLIENT_MAGIC_LEN - 1);\n\n  CU_ASSERT(rv == NGHTTP2_CLIENT_MAGIC_LEN - 1);\n  CU_ASSERT(NGHTTP2_IB_READ_CLIENT_MAGIC == session->iframe.state);\n  CU_ASSERT(1 == session->iframe.payloadleft);\n\n  rv = nghttp2_session_mem_recv(session, (const uint8_t *)\"\\0\", 1);\n\n  CU_ASSERT(NGHTTP2_ERR_BAD_CLIENT_MAGIC == rv);\n\n  nghttp2_session_del(session);\n\n  /* disable global nghttp2_enable_strict_preface here */\n  nghttp2_enable_strict_preface = 0;\n}\n\nvoid test_nghttp2_session_delete_data_item(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *a;\n  nghttp2_data_provider prd;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  a = open_recv_stream(session, 1);\n  open_recv_stream_with_dep(session, 3, a);\n\n  /* We don't care about these members, since we won't send data */\n  prd.source.ptr = NULL;\n  prd.read_callback = fail_data_source_read_callback;\n\n  CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, 1, &prd));\n  CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, 3, &prd));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_open_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_stream *opened_stream;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 3, 0);\n\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  stream = nghttp2_session_get_stream_raw(session, 1);\n\n  CU_ASSERT(NGHTTP2_STREAM_IDLE == stream->state);\n  CU_ASSERT(NULL == stream->closed_prev);\n  CU_ASSERT(NULL == stream->closed_next);\n  CU_ASSERT(1 == session->num_idle_streams);\n  CU_ASSERT(session->idle_stream_head == stream);\n  CU_ASSERT(session->idle_stream_tail == stream);\n\n  opened_stream = open_recv_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  CU_ASSERT(stream == opened_stream);\n  CU_ASSERT(NGHTTP2_STREAM_OPENING == stream->state);\n  CU_ASSERT(0 == session->num_idle_streams);\n  CU_ASSERT(NULL == session->idle_stream_head);\n  CU_ASSERT(NULL == session->idle_stream_tail);\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_cancel_reserved_remote(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n  nghttp2_nv *nva;\n  size_t nvlen;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  stream = open_recv_stream2(session, 2, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 2, NGHTTP2_CANCEL);\n\n  CU_ASSERT(NGHTTP2_STREAM_CLOSING == stream->state);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nvlen = ARRLEN(resnv);\n  nghttp2_nv_array_copy(&nva, resnv, nvlen, mem);\n\n  nghttp2_frame_headers_init(&frame.headers, NGHTTP2_FLAG_END_HEADERS, 2,\n                             NGHTTP2_HCAT_PUSH_RESPONSE, NULL, nva, nvlen);\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  /* stream is not dangling, so assign NULL */\n  stream = NULL;\n\n  /* No RST_STREAM or GOAWAY is generated since stream should be in\n     NGHTTP2_STREAM_CLOSING and push response should be ignored. */\n  CU_ASSERT(0 == nghttp2_outbound_queue_size(&session->ob_reg));\n\n  /* Check that we can receive push response HEADERS while RST_STREAM\n     is just queued. */\n  open_recv_stream2(session, 4, NGHTTP2_STREAM_RESERVED);\n\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 2, NGHTTP2_CANCEL);\n\n  nghttp2_bufs_reset(&bufs);\n\n  frame.hd.stream_id = 4;\n  rv = nghttp2_frame_pack_headers(&bufs, &frame.headers, &deflater);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(1 == nghttp2_outbound_queue_size(&session->ob_reg));\n\n  nghttp2_frame_headers_free(&frame.headers, mem);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_reset_pending_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream;\n  int32_t stream_id;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n  callbacks.on_stream_close_callback = on_stream_close_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  stream_id = nghttp2_submit_request(session, NULL, NULL, 0, NULL, NULL);\n  CU_ASSERT(stream_id >= 1);\n\n  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, stream_id,\n                            NGHTTP2_CANCEL);\n\n  session->remote_settings.max_concurrent_streams = 0;\n\n  /* RST_STREAM cancels pending HEADERS and is not actually sent. */\n  ud.frame_send_cb_called = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  /* See HEADERS is not sent.  on_stream_close is called just like\n     transmission failure. */\n  session->remote_settings.max_concurrent_streams = 1;\n\n  ud.frame_not_send_cb_called = 0;\n  ud.stream_close_error_code = 0;\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n  CU_ASSERT(NGHTTP2_HEADERS == ud.not_sent_frame_type);\n  CU_ASSERT(NGHTTP2_CANCEL == ud.stream_close_error_code);\n\n  stream = nghttp2_session_get_stream(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_send_data_callback(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n  accumulator acc;\n  nghttp2_frame_hd hd;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = accumulator_send_callback;\n  callbacks.send_data_callback = send_data_callback;\n\n  data_prd.read_callback = no_copy_data_source_read_callback;\n\n  acc.length = 0;\n  ud.acc = &acc;\n\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN * 2;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  open_sent_stream(session, 1);\n\n  nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  CU_ASSERT((NGHTTP2_FRAME_HDLEN + NGHTTP2_DATA_PAYLOADLEN) * 2 == acc.length);\n\n  nghttp2_frame_unpack_frame_hd(&hd, acc.buf);\n\n  CU_ASSERT(16384 == hd.length);\n  CU_ASSERT(NGHTTP2_DATA == hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_NONE == hd.flags);\n\n  nghttp2_frame_unpack_frame_hd(&hd, acc.buf + NGHTTP2_FRAME_HDLEN + hd.length);\n\n  CU_ASSERT(16384 == hd.length);\n  CU_ASSERT(NGHTTP2_DATA == hd.type);\n  CU_ASSERT(NGHTTP2_FLAG_END_STREAM == hd.flags);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_on_begin_headers_temporal_failure(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_hd_deflater deflater;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_begin_headers_callback =\n      temporal_failure_on_begin_headers_callback;\n  callbacks.on_header_callback = on_header_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INTERNAL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_bufs_reset(&bufs);\n  /* check for PUSH_PROMISE */\n  nghttp2_hd_deflate_init(&deflater, mem);\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  open_sent_stream(session, 1);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  ud.header_cb_called = 0;\n  ud.frame_recv_cb_called = 0;\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_bufs_len(&bufs));\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == rv);\n  CU_ASSERT(0 == ud.header_cb_called);\n  CU_ASSERT(0 == ud.frame_recv_cb_called);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(2 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INTERNAL_ERROR == item->frame.rst_stream.error_code);\n\n  nghttp2_session_del(session);\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_defer_then_close(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider prd;\n  int rv;\n  const uint8_t *datap;\n  ssize_t datalen;\n  nghttp2_frame frame;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  prd.read_callback = defer_data_source_read_callback;\n\n  rv = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), &prd, NULL);\n  CU_ASSERT(rv > 0);\n\n  /* This sends HEADERS */\n  datalen = nghttp2_session_mem_send(session, &datap);\n\n  CU_ASSERT(datalen > 0);\n\n  /* This makes DATA item deferred */\n  datalen = nghttp2_session_mem_send(session, &datap);\n\n  CU_ASSERT(datalen == 0);\n\n  nghttp2_frame_rst_stream_init(&frame.rst_stream, 1, NGHTTP2_CANCEL);\n\n  /* Assertion failure; GH-264 */\n  rv = nghttp2_session_on_rst_stream_received(session, &frame);\n\n  CU_ASSERT(rv == 0);\n\n  nghttp2_session_del(session);\n}\n\nstatic int submit_response_on_stream_close(nghttp2_session *session,\n                                           int32_t stream_id,\n                                           uint32_t error_code,\n                                           void *user_data) {\n  nghttp2_data_provider data_prd;\n  (void)error_code;\n  (void)user_data;\n\n  data_prd.read_callback = temporal_failure_data_source_read_callback;\n\n  // Attempt to submit response or data to the stream being closed\n  switch (stream_id) {\n  case 1:\n    CU_ASSERT(0 == nghttp2_submit_response(session, stream_id, resnv,\n                                           ARRLEN(resnv), &data_prd));\n    break;\n  case 3:\n    CU_ASSERT(0 == nghttp2_submit_data(session, NGHTTP2_FLAG_NONE, stream_id,\n                                       &data_prd));\n    break;\n  }\n\n  return 0;\n}\n\nvoid test_nghttp2_session_detach_item_from_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_stream_close_callback = submit_response_on_stream_close;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  open_recv_stream(session, 1);\n  open_recv_stream(session, 3);\n\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n  nghttp2_session_close_stream(session, 3, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_flooding(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  nghttp2_frame frame;\n  nghttp2_mem *mem;\n  size_t i;\n\n  mem = nghttp2_mem_default();\n\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  /* PING ACK */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_frame_ping_init(&frame.ping, NGHTTP2_FLAG_NONE, NULL);\n  nghttp2_frame_pack_ping(&bufs, &frame.ping);\n  nghttp2_frame_ping_free(&frame.ping);\n\n  buf = &bufs.head->buf;\n\n  for (i = 0; i < NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM; ++i) {\n    CU_ASSERT(\n        (ssize_t)nghttp2_buf_len(buf) ==\n        nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n  }\n\n  CU_ASSERT(NGHTTP2_ERR_FLOODED ==\n            nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n\n  nghttp2_session_del(session);\n\n  /* SETTINGS ACK */\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, NULL, 0);\n  nghttp2_frame_pack_settings(&bufs, &frame.settings);\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n\n  for (i = 0; i < NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM; ++i) {\n    CU_ASSERT(\n        (ssize_t)nghttp2_buf_len(buf) ==\n        nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n  }\n\n  CU_ASSERT(NGHTTP2_ERR_FLOODED ==\n            nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf)));\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_change_stream_priority(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream1, *stream2, *stream3, *stream5;\n  nghttp2_priority_spec pri_spec;\n  int rv;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream1 = open_recv_stream(session, 1);\n  stream3 = open_recv_stream_with_dep_weight(session, 3, 199, stream1);\n  stream2 = open_sent_stream_with_dep_weight(session, 2, 101, stream3);\n\n  nghttp2_priority_spec_init(&pri_spec, 1, 256, 0);\n\n  rv = nghttp2_session_change_stream_priority(session, 2, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  CU_ASSERT(stream1 == stream2->dep_prev);\n  CU_ASSERT(256 == stream2->weight);\n\n  /* Cannot change stream which does not exist */\n  rv = nghttp2_session_change_stream_priority(session, 5, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to depend on itself */\n  rv = nghttp2_session_change_stream_priority(session, 1, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to change priority of root stream (0) */\n  rv = nghttp2_session_change_stream_priority(session, 0, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* Depends on the non-existing idle stream.  This creates that idle\n     stream. */\n  nghttp2_priority_spec_init(&pri_spec, 5, 9, 1);\n\n  rv = nghttp2_session_change_stream_priority(session, 2, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream5 = nghttp2_session_get_stream_raw(session, 5);\n\n  CU_ASSERT(NULL != stream5);\n  CU_ASSERT(&session->root == stream5->dep_prev);\n  CU_ASSERT(stream5 == stream2->dep_prev);\n  CU_ASSERT(9 == stream2->weight);\n\n  nghttp2_session_del(session);\n\n  /* Check that this works in client session too */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  stream1 = open_sent_stream(session, 1);\n\n  nghttp2_priority_spec_init(&pri_spec, 5, 9, 1);\n\n  rv = nghttp2_session_change_stream_priority(session, 1, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream5 = nghttp2_session_get_stream_raw(session, 5);\n\n  CU_ASSERT(NULL != stream5);\n  CU_ASSERT(&session->root == stream5->dep_prev);\n  CU_ASSERT(stream5 == stream1->dep_prev);\n  CU_ASSERT(9 == stream1->weight);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_create_idle_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_stream *stream2, *stream4, *stream8, *stream10;\n  nghttp2_priority_spec pri_spec;\n  int rv;\n  int i;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  stream2 = open_sent_stream(session, 2);\n\n  nghttp2_priority_spec_init(&pri_spec, 2, 111, 1);\n\n  rv = nghttp2_session_create_idle_stream(session, 4, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream4 = nghttp2_session_get_stream_raw(session, 4);\n\n  CU_ASSERT(4 == stream4->stream_id);\n  CU_ASSERT(111 == stream4->weight);\n  CU_ASSERT(stream2 == stream4->dep_prev);\n  CU_ASSERT(stream4 == stream2->dep_next);\n\n  /* If pri_spec->stream_id does not exist, and it is idle stream, it\n     is created too */\n  nghttp2_priority_spec_init(&pri_spec, 10, 109, 0);\n\n  rv = nghttp2_session_create_idle_stream(session, 8, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream8 = nghttp2_session_get_stream_raw(session, 8);\n  stream10 = nghttp2_session_get_stream_raw(session, 10);\n\n  CU_ASSERT(8 == stream8->stream_id);\n  CU_ASSERT(109 == stream8->weight);\n  CU_ASSERT(10 == stream10->stream_id);\n  CU_ASSERT(16 == stream10->weight);\n  CU_ASSERT(stream10 == stream8->dep_prev);\n  CU_ASSERT(&session->root == stream10->dep_prev);\n\n  /* It is an error to attempt to create already existing idle\n     stream */\n  rv = nghttp2_session_create_idle_stream(session, 4, &pri_spec);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to depend on itself */\n  pri_spec.stream_id = 6;\n\n  rv = nghttp2_session_create_idle_stream(session, 6, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to create root stream (0) as idle stream */\n  rv = nghttp2_session_create_idle_stream(session, 0, &pri_spec);\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  /* It is an error to create non-idle stream */\n  session->last_sent_stream_id = 20;\n  pri_spec.stream_id = 2;\n\n  rv = nghttp2_session_create_idle_stream(session, 18, &pri_spec);\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT == rv);\n\n  nghttp2_session_del(session);\n\n  /* Check that this works in client session too */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_priority_spec_init(&pri_spec, 4, 99, 1);\n\n  rv = nghttp2_session_create_idle_stream(session, 2, &pri_spec);\n\n  CU_ASSERT(0 == rv);\n\n  stream4 = nghttp2_session_get_stream_raw(session, 4);\n  stream2 = nghttp2_session_get_stream_raw(session, 2);\n\n  CU_ASSERT(NULL != stream4);\n  CU_ASSERT(NULL != stream2);\n  CU_ASSERT(&session->root == stream4->dep_prev);\n  CU_ASSERT(NGHTTP2_DEFAULT_WEIGHT == stream4->weight);\n  CU_ASSERT(stream4 == stream2->dep_prev);\n  CU_ASSERT(99 == stream2->weight);\n\n  nghttp2_session_del(session);\n\n  /* Check that idle stream is reduced when nghttp2_session_send() is\n     called. */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = 30;\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n  for (i = 0; i < 100; ++i) {\n    rv = nghttp2_session_create_idle_stream(session, i * 2 + 1, &pri_spec);\n\n    CU_ASSERT(0 == rv);\n\n    nghttp2_priority_spec_init(&pri_spec, i * 2 + 1, 16, 0);\n  }\n\n  CU_ASSERT(100 == session->num_idle_streams);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(30 == session->num_idle_streams);\n  CU_ASSERT(141 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n\n  /* Check that idle stream is reduced when nghttp2_session_mem_recv() is\n     called. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = 30;\n\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n  for (i = 0; i < 100; ++i) {\n    rv = nghttp2_session_create_idle_stream(session, i * 2 + 1, &pri_spec);\n\n    CU_ASSERT(0 == rv);\n\n    nghttp2_priority_spec_init(&pri_spec, i * 2 + 1, 16, 0);\n  }\n\n  CU_ASSERT(100 == session->num_idle_streams);\n  CU_ASSERT(0 == nghttp2_session_mem_recv(session, NULL, 0));\n  CU_ASSERT(30 == session->num_idle_streams);\n  CU_ASSERT(141 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_repeated_priority_change(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_priority_spec pri_spec;\n  int32_t stream_id, last_stream_id;\n  int32_t max_streams = 20;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = (uint32_t)max_streams;\n\n  /* 1 -> 0 */\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  last_stream_id = max_streams * 2 + 1;\n\n  for (stream_id = 3; stream_id < last_stream_id; stream_id += 2) {\n    /* 1 -> stream_id */\n    nghttp2_priority_spec_init(&pri_spec, stream_id, 16, 0);\n    nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n    CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n    nghttp2_frame_priority_free(&frame.priority);\n  }\n\n  CU_ASSERT(20 == session->num_idle_streams);\n  CU_ASSERT(1 == session->idle_stream_head->stream_id);\n\n  /* 1 -> last_stream_id */\n  nghttp2_priority_spec_init(&pri_spec, last_stream_id, 16, 0);\n  nghttp2_frame_priority_init(&frame.priority, 1, &pri_spec);\n\n  CU_ASSERT(0 == nghttp2_session_on_priority_received(session, &frame));\n\n  nghttp2_frame_priority_free(&frame.priority);\n\n  CU_ASSERT(20 == session->num_idle_streams);\n  CU_ASSERT(3 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_repeated_priority_submission(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_priority_spec pri_spec;\n  int32_t stream_id, last_stream_id;\n  uint32_t max_streams = NGHTTP2_MIN_IDLE_STREAMS;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  session->local_settings.max_concurrent_streams = max_streams;\n\n  /* 1 -> 0 */\n  nghttp2_priority_spec_init(&pri_spec, 0, 16, 0);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n\n  last_stream_id = (int32_t)(max_streams * 2 + 1);\n\n  for (stream_id = 3; stream_id < last_stream_id; stream_id += 2) {\n    /* 1 -> stream_id */\n    nghttp2_priority_spec_init(&pri_spec, stream_id, 16, 0);\n\n    CU_ASSERT(\n        0 == nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n  }\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(max_streams == session->num_idle_streams);\n  CU_ASSERT(1 == session->idle_stream_head->stream_id);\n\n  /* 1 -> last_stream_id */\n  nghttp2_priority_spec_init(&pri_spec, last_stream_id, 16, 0);\n\n  CU_ASSERT(0 ==\n            nghttp2_submit_priority(session, NGHTTP2_FLAG_NONE, 1, &pri_spec));\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(max_streams == session->num_idle_streams);\n  CU_ASSERT(3 == session->idle_stream_head->stream_id);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_set_local_window_size(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_outbound_item *item;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = open_sent_stream(session, 1);\n  stream->recv_window_size = 4096;\n\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 65536));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1 ==\n            stream->local_window_size);\n  CU_ASSERT(4096 == stream->recv_window_size);\n  CU_ASSERT(65536 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Go decrement part */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 32768));\n  CU_ASSERT(32768 == stream->local_window_size);\n  CU_ASSERT(-28672 == stream->recv_window_size);\n  CU_ASSERT(32768 == stream->recv_reduction);\n  CU_ASSERT(65536 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 49152));\n  CU_ASSERT(49152 == stream->local_window_size);\n  CU_ASSERT(-12288 == stream->recv_window_size);\n  CU_ASSERT(16384 == stream->recv_reduction);\n  CU_ASSERT(65536 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Increase local window again */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 65537));\n  CU_ASSERT(65537 == stream->local_window_size);\n  CU_ASSERT(4096 == stream->recv_window_size);\n  CU_ASSERT(0 == stream->recv_reduction);\n  CU_ASSERT(65537 - 4096 ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Check connection-level flow control */\n  session->recv_window_size = 4096;\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 65536));\n  CU_ASSERT(NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE + 1 ==\n            session->local_window_size);\n  CU_ASSERT(4096 == session->recv_window_size);\n  CU_ASSERT(65536 - 4096 == nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.window_update.hd.stream_id);\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  /* Go decrement part */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 32768));\n  CU_ASSERT(32768 == session->local_window_size);\n  CU_ASSERT(-28672 == session->recv_window_size);\n  CU_ASSERT(32768 == session->recv_reduction);\n  CU_ASSERT(65536 - 4096 == nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(item == NULL);\n\n  /* Increase local window size */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 49152));\n  CU_ASSERT(49152 == session->local_window_size);\n  CU_ASSERT(-12288 == session->recv_window_size);\n  CU_ASSERT(16384 == session->recv_reduction);\n  CU_ASSERT(65536 - 4096 == nghttp2_session_get_local_window_size(session));\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Increase local window again */\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 65537));\n  CU_ASSERT(65537 == session->local_window_size);\n  CU_ASSERT(4096 == session->recv_window_size);\n  CU_ASSERT(0 == session->recv_reduction);\n  CU_ASSERT(65537 - 4096 == nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(1 == item->frame.window_update.window_size_increment);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_session_del(session);\n\n  /* Make sure that nghttp2_session_set_local_window_size submits\n     WINDOW_UPDATE if necessary to increase stream-level window. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  stream = open_sent_stream(session, 1);\n  stream->recv_window_size = NGHTTP2_INITIAL_WINDOW_SIZE;\n\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 1, 0));\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(0 == nghttp2_session_get_stream_local_window_size(session, 1));\n  /* This should submit WINDOW_UPDATE frame because stream-level\n     receiving window is now full. */\n  CU_ASSERT(0 ==\n            nghttp2_session_set_local_window_size(session, NGHTTP2_FLAG_NONE, 1,\n                                                  NGHTTP2_INITIAL_WINDOW_SIZE));\n  CU_ASSERT(0 == stream->recv_window_size);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_stream_local_window_size(session, 1));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n\n  /* Make sure that nghttp2_session_set_local_window_size submits\n     WINDOW_UPDATE if necessary to increase connection-level\n     window. */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n  session->recv_window_size = NGHTTP2_INITIAL_WINDOW_SIZE;\n\n  CU_ASSERT(0 == nghttp2_session_set_local_window_size(\n                     session, NGHTTP2_FLAG_NONE, 0, 0));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(0 == nghttp2_session_get_local_window_size(session));\n  /* This should submit WINDOW_UPDATE frame because connection-level\n     receiving window is now full. */\n  CU_ASSERT(0 ==\n            nghttp2_session_set_local_window_size(session, NGHTTP2_FLAG_NONE, 0,\n                                                  NGHTTP2_INITIAL_WINDOW_SIZE));\n  CU_ASSERT(0 == session->recv_window_size);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            nghttp2_session_get_local_window_size(session));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);\n  CU_ASSERT(0 == item->frame.hd.stream_id);\n  CU_ASSERT(NGHTTP2_INITIAL_WINDOW_SIZE ==\n            item->frame.window_update.window_size_increment);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_cancel_from_before_frame_send(void) {\n  int rv;\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  my_user_data ud;\n  nghttp2_settings_entry iv;\n  nghttp2_data_provider data_prd;\n  int32_t stream_id;\n  nghttp2_stream *stream;\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.before_frame_send_callback = cancel_before_frame_send_callback;\n  callbacks.on_frame_not_send_callback = on_frame_not_send_callback;\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  iv.settings_id = 0;\n  iv.value = 1000000009;\n\n  rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  CU_ASSERT(0 == rv);\n\n  ud.frame_send_cb_called = 0;\n  ud.before_frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(1 == ud.before_frame_send_cb_called);\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  data_prd.source.ptr = NULL;\n  data_prd.read_callback = temporal_failure_data_source_read_callback;\n\n  stream_id = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv),\n                                     &data_prd, NULL);\n\n  CU_ASSERT(stream_id > 0);\n\n  ud.frame_send_cb_called = 0;\n  ud.before_frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(1 == ud.before_frame_send_cb_called);\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  stream_id = nghttp2_submit_push_promise(session, NGHTTP2_FLAG_NONE, 1, reqnv,\n                                          ARRLEN(reqnv), NULL);\n\n  CU_ASSERT(stream_id > 0);\n\n  ud.frame_send_cb_called = 0;\n  ud.before_frame_send_cb_called = 0;\n  ud.frame_not_send_cb_called = 0;\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(1 == ud.before_frame_send_cb_called);\n  CU_ASSERT(1 == ud.frame_not_send_cb_called);\n\n  stream = nghttp2_session_get_stream_raw(session, stream_id);\n\n  CU_ASSERT(NULL == stream);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_too_many_settings(void) {\n  nghttp2_session *session;\n  nghttp2_option *option;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_frame frame;\n  nghttp2_bufs bufs;\n  nghttp2_buf *buf;\n  ssize_t rv;\n  my_user_data ud;\n  nghttp2_settings_entry iv[3];\n  nghttp2_mem *mem;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_max_settings(option, 1);\n\n  nghttp2_session_client_new2(&session, &callbacks, &ud, option);\n\n  CU_ASSERT(1 == session->max_settings);\n\n  nghttp2_option_del(option);\n\n  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n  iv[0].value = 3000;\n\n  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n  iv[1].value = 16384;\n\n  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 2),\n                              2);\n\n  rv = nghttp2_frame_pack_settings(&bufs, &frame.settings);\n\n  CU_ASSERT(0 == rv);\n  CU_ASSERT(nghttp2_bufs_len(&bufs) > 0);\n\n  nghttp2_frame_settings_free(&frame.settings, mem);\n\n  buf = &bufs.head->buf;\n  assert(nghttp2_bufs_len(&bufs) == nghttp2_buf_len(buf));\n\n  ud.frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, buf->pos, nghttp2_buf_len(buf));\n  CU_ASSERT((ssize_t)nghttp2_buf_len(buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);\n\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_bufs_free(&bufs);\n  nghttp2_session_del(session);\n}\n\nstatic void\nprepare_session_removed_closed_stream(nghttp2_session *session,\n                                      nghttp2_hd_deflater *deflater) {\n  int rv;\n  nghttp2_settings_entry iv;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  ssize_t nread;\n  int i;\n  nghttp2_stream *stream;\n  nghttp2_frame_hd hd;\n\n  mem = nghttp2_mem_default();\n\n  frame_pack_bufs_init(&bufs);\n\n  iv.settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n  iv.value = 2;\n\n  rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_send(session);\n\n  CU_ASSERT(0 == rv);\n\n  for (i = 1; i <= 3; i += 2) {\n    rv = pack_headers(&bufs, deflater, i,\n                      NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n                      ARRLEN(reqnv), mem);\n\n    CU_ASSERT(0 == rv);\n\n    nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                     nghttp2_bufs_len(&bufs));\n\n    CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n    nghttp2_bufs_reset(&bufs);\n  }\n\n  nghttp2_session_close_stream(session, 3, NGHTTP2_NO_ERROR);\n\n  rv = pack_headers(&bufs, deflater, 5,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM, reqnv,\n                    ARRLEN(reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  /* Receiving stream 5 will erase stream 3 from closed stream list */\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  stream = nghttp2_session_get_stream_raw(session, 3);\n\n  CU_ASSERT(NULL == stream);\n\n  /* Since the current max concurrent streams is\n     NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS, receiving frame on stream\n     3 is ignored. */\n  nghttp2_bufs_reset(&bufs);\n  rv = pack_headers(&bufs, deflater, 3,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    trailernv, ARRLEN(trailernv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 3);\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  /* Now server receives SETTINGS ACK */\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_SETTINGS, NGHTTP2_FLAG_ACK, 0);\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_session_removed_closed_stream(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  int rv;\n  nghttp2_hd_deflater deflater;\n  nghttp2_bufs bufs;\n  nghttp2_mem *mem;\n  ssize_t nread;\n  nghttp2_frame_hd hd;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(callbacks));\n\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  /* Now local max concurrent streams is still unlimited, pending max\n     concurrent streams is now 2. */\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  prepare_session_removed_closed_stream(session, &deflater);\n\n  /* Now current max concurrent streams is 2.  Receiving frame on\n     stream 3 is ignored because we have no stream object for stream\n     3. */\n  nghttp2_bufs_reset(&bufs);\n  rv = pack_headers(&bufs, &deflater, 3,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    trailernv, ARRLEN(trailernv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL == item);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n  nghttp2_hd_deflate_init(&deflater, mem);\n  /* Same setup, and then receive DATA instead of HEADERS */\n\n  prepare_session_removed_closed_stream(session, &deflater);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 3);\n  nghttp2_bufs_reset(&bufs);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  nread = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                   nghttp2_bufs_len(&bufs));\n\n  CU_ASSERT((ssize_t)nghttp2_bufs_len(&bufs) == nread);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL == item);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nstatic ssize_t pause_once_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = user_data;\n  if (ud->data_source_read_cb_paused == 0) {\n    ++ud->data_source_read_cb_paused;\n    return NGHTTP2_ERR_PAUSE;\n  }\n\n  return fixed_length_data_source_read_callback(session, stream_id, buf, len,\n                                                data_flags, source, user_data);\n}\n\nvoid test_nghttp2_session_pause_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_data_provider data_prd;\n  my_user_data ud;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_send_callback = on_frame_send_callback;\n\n  data_prd.read_callback = pause_once_data_source_read_callback;\n  ud.data_source_length = NGHTTP2_DATA_PAYLOADLEN;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  open_recv_stream(session, 1);\n\n  CU_ASSERT(\n      0 == nghttp2_submit_data(session, NGHTTP2_FLAG_END_STREAM, 1, &data_prd));\n\n  ud.frame_send_cb_called = 0;\n  ud.data_source_read_cb_paused = 0;\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(0 == ud.frame_send_cb_called);\n  CU_ASSERT(NULL == session->aob.item);\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  CU_ASSERT(1 == ud.frame_send_cb_called);\n  CU_ASSERT(NGHTTP2_DATA == ud.sent_frame_type);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_session_no_closed_streams(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_option *option;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_option_new(&option);\n  nghttp2_option_set_no_closed_streams(option, 1);\n\n  nghttp2_session_server_new2(&session, &callbacks, NULL, option);\n\n  open_recv_stream(session, 1);\n\n  nghttp2_session_close_stream(session, 1, NGHTTP2_NO_ERROR);\n\n  CU_ASSERT(0 == session->num_closed_streams);\n\n  nghttp2_session_del(session);\n  nghttp2_option_del(option);\n}\n\nvoid test_nghttp2_session_set_stream_user_data(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  int32_t stream_id;\n  int user_data1, user_data2;\n  int rv;\n  const uint8_t *datap;\n  ssize_t datalen;\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  stream_id = nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL,\n                                     &user_data1);\n\n  rv = nghttp2_session_set_stream_user_data(session, stream_id, &user_data2);\n\n  CU_ASSERT(0 == rv);\n\n  datalen = nghttp2_session_mem_send(session, &datap);\n\n  CU_ASSERT(datalen > 0);\n\n  CU_ASSERT(&user_data2 ==\n            nghttp2_session_get_stream_user_data(session, stream_id));\n\n  CU_ASSERT(NGHTTP2_ERR_INVALID_ARGUMENT ==\n            nghttp2_session_set_stream_user_data(session, 2, NULL));\n\n  nghttp2_session_del(session);\n}\n\nstatic void check_nghttp2_http_recv_headers_fail(\n    nghttp2_session *session, nghttp2_hd_deflater *deflater, int32_t stream_id,\n    int stream_state, const nghttp2_nv *nva, size_t nvlen) {\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_outbound_item *item;\n  nghttp2_bufs bufs;\n  my_user_data *ud;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  ud = session->user_data;\n\n  if (stream_state != -1) {\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      open_sent_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    } else {\n      open_recv_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    }\n  }\n\n  rv = pack_headers(&bufs, deflater, stream_id, NGHTTP2_FLAG_END_HEADERS, nva,\n                    nvlen, mem);\n  CU_ASSERT(0 == rv);\n\n  ud->invalid_frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == ud->invalid_frame_recv_cb_called);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_free(&bufs);\n}\n\nstatic void check_nghttp2_http_recv_headers_ok(\n    nghttp2_session *session, nghttp2_hd_deflater *deflater, int32_t stream_id,\n    int stream_state, const nghttp2_nv *nva, size_t nvlen) {\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_bufs bufs;\n  my_user_data *ud;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  ud = session->user_data;\n\n  if (stream_state != -1) {\n    if (nghttp2_session_is_my_stream_id(session, stream_id)) {\n      open_sent_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    } else {\n      open_recv_stream2(session, stream_id, (nghttp2_stream_state)stream_state);\n    }\n  }\n\n  rv = pack_headers(&bufs, deflater, stream_id, NGHTTP2_FLAG_END_HEADERS, nva,\n                    nvlen, mem);\n  CU_ASSERT(0 == rv);\n\n  ud->frame_recv_cb_called = 0;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(1 == ud->frame_recv_cb_called);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_mandatory_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  my_user_data ud;\n  /* test case for response */\n  const nghttp2_nv nostatus_resnv[] = {MAKE_NV(\"server\", \"foo\")};\n  const nghttp2_nv dupstatus_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                        MAKE_NV(\":status\", \"200\")};\n  const nghttp2_nv badpseudo_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                        MAKE_NV(\":scheme\", \"https\")};\n  const nghttp2_nv latepseudo_resnv[] = {MAKE_NV(\"server\", \"foo\"),\n                                         MAKE_NV(\":status\", \"200\")};\n  const nghttp2_nv badstatus_resnv[] = {MAKE_NV(\":status\", \"2000\")};\n  const nghttp2_nv badcl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                    MAKE_NV(\"content-length\", \"-1\")};\n  const nghttp2_nv dupcl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                    MAKE_NV(\"content-length\", \"0\"),\n                                    MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv badhd_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                    MAKE_NV(\"connection\", \"close\")};\n  const nghttp2_nv cl1xx_resnv[] = {MAKE_NV(\":status\", \"100\"),\n                                    MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv cl204_resnv[] = {MAKE_NV(\":status\", \"204\"),\n                                    MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv clnonzero204_resnv[] = {MAKE_NV(\":status\", \"204\"),\n                                           MAKE_NV(\"content-length\", \"100\")};\n  const nghttp2_nv status101_resnv[] = {MAKE_NV(\":status\", \"101\")};\n\n  /* test case for request */\n  const nghttp2_nv nopath_reqnv[] = {MAKE_NV(\":scheme\", \"https\"),\n                                     MAKE_NV(\":method\", \"GET\"),\n                                     MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv earlyconnect_reqnv[] = {\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":path\", \"/\"), MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv lateconnect_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv duppath_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv badcl_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"POST\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\"content-length\", \"-1\")};\n  const nghttp2_nv dupcl_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"),        MAKE_NV(\":method\", \"POST\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\"content-length\", \"0\"),     MAKE_NV(\"content-length\", \"0\")};\n  const nghttp2_nv badhd_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\"connection\", \"close\")};\n  const nghttp2_nv badauthority_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\":authority\", \"\\x0d\\x0alocalhost\"), MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv badhdbtw_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\"foo\", \"\\x0d\\x0a\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":path\", \"/\")};\n  const nghttp2_nv asteriskget1_reqnv[] = {\n      MAKE_NV(\":path\", \"*\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":method\", \"GET\")};\n  const nghttp2_nv asteriskget2_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":method\", \"GET\"), MAKE_NV(\":path\", \"*\")};\n  const nghttp2_nv asteriskoptions1_reqnv[] = {\n      MAKE_NV(\":path\", \"*\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":method\", \"OPTIONS\")};\n  const nghttp2_nv asteriskoptions2_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":method\", \"OPTIONS\"), MAKE_NV(\":path\", \"*\")};\n  const nghttp2_nv connectproto_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv connectprotoget_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"GET\"), MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv connectprotonopath_reqnv[] = {\n      MAKE_NV(\":scheme\", \"https\"), MAKE_NV(\":method\", \"CONNECT\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv connectprotonoauth_reqnv[] = {\n      MAKE_NV(\":scheme\", \"http\"), MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\"host\", \"localhost\"),\n      MAKE_NV(\":protocol\", \"websocket\")};\n  const nghttp2_nv regularconnect_reqnv[] = {\n      MAKE_NV(\":method\", \"CONNECT\"), MAKE_NV(\":authority\", \"localhost\")};\n\n  mem = nghttp2_mem_default();\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_frame_recv_callback = on_frame_recv_callback;\n  callbacks.on_invalid_frame_recv_callback = on_invalid_frame_recv_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* response header lacks :status */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 1,\n                                       NGHTTP2_STREAM_OPENING, nostatus_resnv,\n                                       ARRLEN(nostatus_resnv));\n\n  /* response header has 2 :status */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 3,\n                                       NGHTTP2_STREAM_OPENING, dupstatus_resnv,\n                                       ARRLEN(dupstatus_resnv));\n\n  /* response header has bad pseudo header :scheme */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 5,\n                                       NGHTTP2_STREAM_OPENING, badpseudo_resnv,\n                                       ARRLEN(badpseudo_resnv));\n\n  /* response header has :status after regular header field */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 7,\n                                       NGHTTP2_STREAM_OPENING, latepseudo_resnv,\n                                       ARRLEN(latepseudo_resnv));\n\n  /* response header has bad status code */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 9,\n                                       NGHTTP2_STREAM_OPENING, badstatus_resnv,\n                                       ARRLEN(badstatus_resnv));\n\n  /* response header has bad content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 11,\n                                       NGHTTP2_STREAM_OPENING, badcl_resnv,\n                                       ARRLEN(badcl_resnv));\n\n  /* response header has multiple content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 13,\n                                       NGHTTP2_STREAM_OPENING, dupcl_resnv,\n                                       ARRLEN(dupcl_resnv));\n\n  /* response header has disallowed header field */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 15,\n                                       NGHTTP2_STREAM_OPENING, badhd_resnv,\n                                       ARRLEN(badhd_resnv));\n\n  /* response header has content-length with 100 status code */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 17,\n                                       NGHTTP2_STREAM_OPENING, cl1xx_resnv,\n                                       ARRLEN(cl1xx_resnv));\n\n  /* response header has 0 content-length with 204 status code */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 19,\n                                     NGHTTP2_STREAM_OPENING, cl204_resnv,\n                                     ARRLEN(cl204_resnv));\n\n  /* response header has nonzero content-length with 204 status\n     code */\n  check_nghttp2_http_recv_headers_fail(\n      session, &deflater, 21, NGHTTP2_STREAM_OPENING, clnonzero204_resnv,\n      ARRLEN(clnonzero204_resnv));\n\n  /* status code 101 should not be used in HTTP/2 because it is used\n     for HTTP Upgrade which HTTP/2 removes. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 23,\n                                       NGHTTP2_STREAM_OPENING, status101_resnv,\n                                       ARRLEN(status101_resnv));\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  /* check server side */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* request header has no :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 1, -1, nopath_reqnv,\n                                       ARRLEN(nopath_reqnv));\n\n  /* request header has CONNECT method, but followed by :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 3, -1,\n                                       earlyconnect_reqnv,\n                                       ARRLEN(earlyconnect_reqnv));\n\n  /* request header has CONNECT method following :path */\n  check_nghttp2_http_recv_headers_fail(\n      session, &deflater, 5, -1, lateconnect_reqnv, ARRLEN(lateconnect_reqnv));\n\n  /* request header has multiple :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 7, -1, duppath_reqnv,\n                                       ARRLEN(duppath_reqnv));\n\n  /* request header has bad content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 9, -1, badcl_reqnv,\n                                       ARRLEN(badcl_reqnv));\n\n  /* request header has multiple content-length */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 11, -1, dupcl_reqnv,\n                                       ARRLEN(dupcl_reqnv));\n\n  /* request header has disallowed header field */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 13, -1, badhd_reqnv,\n                                       ARRLEN(badhd_reqnv));\n\n  /* request header has :authority header field containing illegal\n     characters */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 15, -1,\n                                       badauthority_reqnv,\n                                       ARRLEN(badauthority_reqnv));\n\n  /* request header has regular header field containing illegal\n     character before all mandatory header fields are seen. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 17, -1,\n                                       badhdbtw_reqnv, ARRLEN(badhdbtw_reqnv));\n\n  /* request header has \"*\" in :path header field while method is GET.\n     :path is received before :method */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 19, -1,\n                                       asteriskget1_reqnv,\n                                       ARRLEN(asteriskget1_reqnv));\n\n  /* request header has \"*\" in :path header field while method is GET.\n     :method is received before :path */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 21, -1,\n                                       asteriskget2_reqnv,\n                                       ARRLEN(asteriskget2_reqnv));\n\n  /* OPTIONS method can include \"*\" in :path header field.  :path is\n     received before :method. */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 23, -1,\n                                     asteriskoptions1_reqnv,\n                                     ARRLEN(asteriskoptions1_reqnv));\n\n  /* OPTIONS method can include \"*\" in :path header field.  :method is\n     received before :path. */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 25, -1,\n                                     asteriskoptions2_reqnv,\n                                     ARRLEN(asteriskoptions2_reqnv));\n\n  /* :protocol is not allowed unless it is enabled by the local\n     endpoint. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 27, -1,\n                                       connectproto_reqnv,\n                                       ARRLEN(connectproto_reqnv));\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  /* enable SETTINGS_CONNECT_PROTOCOL */\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  session->pending_enable_connect_protocol = 1;\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* :protocol is allowed if SETTINGS_CONNECT_PROTOCOL is enabled by\n     the local endpoint. */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 1, -1,\n                                     connectproto_reqnv,\n                                     ARRLEN(connectproto_reqnv));\n\n  /* :protocol is only allowed with CONNECT method. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 3, -1,\n                                       connectprotoget_reqnv,\n                                       ARRLEN(connectprotoget_reqnv));\n\n  /* CONNECT method with :protocol requires :path. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 5, -1,\n                                       connectprotonopath_reqnv,\n                                       ARRLEN(connectprotonopath_reqnv));\n\n  /* CONNECT method with :protocol requires :authority. */\n  check_nghttp2_http_recv_headers_fail(session, &deflater, 7, -1,\n                                       connectprotonoauth_reqnv,\n                                       ARRLEN(connectprotonoauth_reqnv));\n\n  /* regular CONNECT method should succeed with\n     SETTINGS_CONNECT_PROTOCOL */\n  check_nghttp2_http_recv_headers_ok(session, &deflater, 9, -1,\n                                     regularconnect_reqnv,\n                                     ARRLEN(regularconnect_reqnv));\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_http_content_length(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  nghttp2_stream *stream;\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                 MAKE_NV(\"te\", \"trailers\"),\n                                 MAKE_NV(\"content-length\", \"9000000000\")};\n  const nghttp2_nv cl_reqnv[] = {\n      MAKE_NV(\":path\", \"/\"),        MAKE_NV(\":method\", \"PUT\"),\n      MAKE_NV(\":scheme\", \"https\"),  MAKE_NV(\"te\", \"trailers\"),\n      MAKE_NV(\"host\", \"localhost\"), MAKE_NV(\"content-length\", \"9000000000\")};\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(9000000000LL == stream->content_length);\n  CU_ASSERT(200 == stream->status_code);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* check server side */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, cl_reqnv,\n                    ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(9000000000LL == stream->content_length);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_content_length_mismatch(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv cl_reqnv[] = {\n      MAKE_NV(\":path\", \"/\"), MAKE_NV(\":method\", \"PUT\"),\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\"content-length\", \"20\")};\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                 MAKE_NV(\"content-length\", \"20\")};\n  nghttp2_outbound_item *item;\n  nghttp2_frame_hd hd;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* header says content-length: 20, but HEADERS has END_STREAM flag set */\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    cl_reqnv, ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 0 byte */\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS, cl_reqnv,\n                    ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 3);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 21 bytes */\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, cl_reqnv,\n                    ARRLEN(cl_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 21, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 5);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN + 21;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  /* Check for client */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* header says content-length: 20, but HEADERS has END_STREAM flag set */\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    cl_resnv, ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 1));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* After sending RST_STREAM, stream must be closed */\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 1));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 0 byte */\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 3);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 3));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* After sending RST_STREAM, stream must be closed */\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 3));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* header says content-length: 20, but DATA has 21 bytes */\n  nghttp2_submit_request(session, NULL, reqnv, ARRLEN(reqnv), NULL, NULL);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 21, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 5);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN + 21;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(NULL != nghttp2_session_get_stream(session, 5));\n  CU_ASSERT(0 == nghttp2_session_send(session));\n  /* After sending RST_STREAM, stream must be closed */\n  CU_ASSERT(NULL == nghttp2_session_get_stream(session, 5));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_bufs_free(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n}\n\nvoid test_nghttp2_http_non_final_response(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv nonfinal_resnv[] = {\n      MAKE_NV(\":status\", \"100\"),\n  };\n  nghttp2_outbound_item *item;\n  nghttp2_frame_hd hd;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* non-final HEADERS with END_STREAM is illegal */\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by non-empty DATA is illegal */\n  open_sent_stream2(session, 3, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 10, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 3);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN + 10;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by empty DATA (without END_STREAM) is\n     ok */\n  open_sent_stream2(session, 5, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_NONE, 5);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by empty DATA (with END_STREAM) is\n     illegal */\n  open_sent_stream2(session, 7, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 7, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  nghttp2_frame_hd_init(&hd, 0, NGHTTP2_DATA, NGHTTP2_FLAG_END_STREAM, 7);\n  nghttp2_frame_pack_frame_hd(bufs.head->buf.last, &hd);\n  bufs.head->buf.last += NGHTTP2_FRAME_HDLEN;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* non-final HEADERS followed by final HEADERS is OK */\n  open_sent_stream2(session, 9, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 9, NGHTTP2_FLAG_END_HEADERS,\n                    nonfinal_resnv, ARRLEN(nonfinal_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 9, NGHTTP2_FLAG_END_HEADERS, resnv,\n                    ARRLEN(resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_trailer_headers(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv trailer_reqnv[] = {\n      MAKE_NV(\"foo\", \"bar\"),\n  };\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* good trailer header */\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    trailer_reqnv, ARRLEN(trailer_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* trailer header without END_STREAM is illegal */\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS,\n                    trailer_reqnv, ARRLEN(trailer_reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* trailer header including pseudo header field is illegal */\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 5, NGHTTP2_FLAG_END_HEADERS, reqnv,\n                    ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  nghttp2_session_del(session);\n\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_ignore_regular_header(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  my_user_data ud;\n  const nghttp2_nv bad_reqnv[] = {\n      MAKE_NV(\":authority\", \"localhost\"),\n      MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":path\", \"/\"),\n      MAKE_NV(\":method\", \"GET\"),\n      MAKE_NV(\"foo\", \"\\x0zzz\"),\n      MAKE_NV(\"bar\", \"buzz\"),\n  };\n  const nghttp2_nv bad_ansnv[] = {\n      MAKE_NV(\":authority\", \"localhost\"), MAKE_NV(\":scheme\", \"https\"),\n      MAKE_NV(\":path\", \"/\"), MAKE_NV(\":method\", \"GET\"), MAKE_NV(\"bar\", \"buzz\")};\n  size_t proclen;\n  size_t i;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n  callbacks.on_header_callback = pause_on_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    bad_reqnv, ARRLEN(bad_reqnv), mem);\n\n  CU_ASSERT_FATAL(0 == rv);\n\n  nghttp2_hd_deflate_free(&deflater);\n\n  proclen = 0;\n\n  for (i = 0; i < 4; ++i) {\n    rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                  nghttp2_buf_len(&bufs.head->buf) - proclen);\n    CU_ASSERT_FATAL(rv > 0);\n    proclen += (size_t)rv;\n    CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[i], &ud.nv));\n  }\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                nghttp2_buf_len(&bufs.head->buf) - proclen);\n  CU_ASSERT_FATAL(rv > 0);\n  /* Without on_invalid_frame_recv_callback, bad header causes stream\n     reset */\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n\n  proclen += (size_t)rv;\n\n  CU_ASSERT(nghttp2_buf_len(&bufs.head->buf) == proclen);\n\n  nghttp2_session_del(session);\n\n  /* use on_invalid_header_callback */\n  callbacks.on_invalid_header_callback = pause_on_invalid_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  proclen = 0;\n\n  ud.invalid_header_cb_called = 0;\n\n  for (i = 0; i < 4; ++i) {\n    rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                  nghttp2_buf_len(&bufs.head->buf) - proclen);\n    CU_ASSERT_FATAL(rv > 0);\n    proclen += (size_t)rv;\n    CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[i], &ud.nv));\n  }\n\n  CU_ASSERT(0 == ud.invalid_header_cb_called);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                nghttp2_buf_len(&bufs.head->buf) - proclen);\n\n  CU_ASSERT_FATAL(rv > 0);\n  CU_ASSERT(1 == ud.invalid_header_cb_called);\n  CU_ASSERT(nghttp2_nv_equal(&bad_reqnv[4], &ud.nv));\n\n  proclen += (size_t)rv;\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,\n                                nghttp2_buf_len(&bufs.head->buf) - proclen);\n\n  CU_ASSERT(rv > 0);\n  CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[4], &ud.nv));\n\n  nghttp2_session_del(session);\n\n  /* make sure that we can reset stream from\n     on_invalid_header_callback */\n  callbacks.on_header_callback = on_header_callback;\n  callbacks.on_invalid_header_callback = reset_on_invalid_header_callback;\n\n  nghttp2_session_server_new(&session, &callbacks, &ud);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT(rv == (ssize_t)nghttp2_buf_len(&bufs.head->buf));\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(1 == item->frame.hd.stream_id);\n\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_ignore_content_length(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"304\"),\n                                 MAKE_NV(\"content-length\", \"20\")};\n  const nghttp2_nv conn_reqnv[] = {MAKE_NV(\":authority\", \"localhost\"),\n                                   MAKE_NV(\":method\", \"CONNECT\"),\n                                   MAKE_NV(\"content-length\", \"999999\")};\n  const nghttp2_nv conn_cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                      MAKE_NV(\"content-length\", \"0\")};\n  nghttp2_stream *stream;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  /* If status 304, content-length must be ignored */\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_headers(&bufs, &deflater, 1,\n                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,\n                    cl_resnv, ARRLEN(cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* Content-Length in 200 response to CONNECT is ignored */\n  stream = open_sent_stream2(session, 3, NGHTTP2_STREAM_OPENING);\n  stream->http_flags |= NGHTTP2_HTTP_FLAG_METH_CONNECT;\n\n  rv = pack_headers(&bufs, &deflater, 3, NGHTTP2_FLAG_END_HEADERS,\n                    conn_cl_resnv, ARRLEN(conn_cl_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n  CU_ASSERT(-1 == stream->content_length);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n\n  /* If request method is CONNECT, content-length must be ignored */\n  nghttp2_session_server_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, conn_reqnv,\n                    ARRLEN(conn_reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(-1 == stream->content_length);\n  CU_ASSERT((stream->http_flags & NGHTTP2_HTTP_FLAG_METH_CONNECT) > 0);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_record_request_method(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const nghttp2_nv conn_reqnv[] = {MAKE_NV(\":method\", \"CONNECT\"),\n                                   MAKE_NV(\":authority\", \"localhost\")};\n  const nghttp2_nv conn_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                   MAKE_NV(\"content-length\", \"9999\")};\n  nghttp2_stream *stream;\n  ssize_t rv;\n  nghttp2_bufs bufs;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  CU_ASSERT(1 == nghttp2_submit_request(session, NULL, conn_reqnv,\n                                        ARRLEN(conn_reqnv), NULL, NULL));\n\n  CU_ASSERT(0 == nghttp2_session_send(session));\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(NGHTTP2_HTTP_FLAG_METH_CONNECT == stream->http_flags);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, conn_resnv,\n                    ARRLEN(conn_resnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT((NGHTTP2_HTTP_FLAG_METH_CONNECT & stream->http_flags) > 0);\n  CU_ASSERT(-1 == stream->content_length);\n\n  /* content-length is ignored in 200 response to a CONNECT request */\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NULL == item);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_push_promise(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  nghttp2_bufs bufs;\n  ssize_t rv;\n  nghttp2_stream *stream;\n  const nghttp2_nv bad_reqnv[] = {MAKE_NV(\":method\", \"GET\")};\n  nghttp2_outbound_item *item;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  /* good PUSH_PROMISE case */\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  open_sent_stream2(session, 1, NGHTTP2_STREAM_OPENING);\n\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 2,\n                         reqnv, ARRLEN(reqnv), mem);\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  stream = nghttp2_session_get_stream(session, 2);\n  CU_ASSERT(NULL != stream);\n\n  nghttp2_bufs_reset(&bufs);\n\n  rv = pack_headers(&bufs, &deflater, 2, NGHTTP2_FLAG_END_HEADERS, resnv,\n                    ARRLEN(resnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));\n\n  CU_ASSERT(200 == stream->status_code);\n\n  nghttp2_bufs_reset(&bufs);\n\n  /* PUSH_PROMISE lacks mandatory header */\n  rv = pack_push_promise(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, 4,\n                         bad_reqnv, ARRLEN(bad_reqnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  item = nghttp2_session_get_next_ob_item(session);\n\n  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);\n  CU_ASSERT(4 == item->frame.hd.stream_id);\n\n  nghttp2_bufs_reset(&bufs);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n\nvoid test_nghttp2_http_head_method_upgrade_workaround(void) {\n  nghttp2_session *session;\n  nghttp2_session_callbacks callbacks;\n  const nghttp2_nv cl_resnv[] = {MAKE_NV(\":status\", \"200\"),\n                                 MAKE_NV(\"content-length\", \"1000000007\")};\n  nghttp2_bufs bufs;\n  nghttp2_hd_deflater deflater;\n  nghttp2_mem *mem;\n  ssize_t rv;\n  nghttp2_stream *stream;\n\n  mem = nghttp2_mem_default();\n  frame_pack_bufs_init(&bufs);\n\n  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));\n  callbacks.send_callback = null_send_callback;\n\n  nghttp2_session_client_new(&session, &callbacks, NULL);\n\n  nghttp2_hd_deflate_init(&deflater, mem);\n\n  nghttp2_session_upgrade(session, NULL, 0, NULL);\n\n  rv = pack_headers(&bufs, &deflater, 1, NGHTTP2_FLAG_END_HEADERS, cl_resnv,\n                    ARRLEN(cl_resnv), mem);\n\n  CU_ASSERT(0 == rv);\n\n  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,\n                                nghttp2_buf_len(&bufs.head->buf));\n\n  CU_ASSERT((ssize_t)nghttp2_buf_len(&bufs.head->buf) == rv);\n\n  stream = nghttp2_session_get_stream(session, 1);\n\n  CU_ASSERT(-1 == stream->content_length);\n\n  nghttp2_hd_deflate_free(&deflater);\n  nghttp2_session_del(session);\n  nghttp2_bufs_free(&bufs);\n}\n", "/*\n * nghttp2 - HTTP/2 C Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#ifndef NGHTTP2_SESSION_TEST_H\n#define NGHTTP2_SESSION_TEST_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\nvoid test_nghttp2_session_recv(void);\nvoid test_nghttp2_session_recv_invalid_stream_id(void);\nvoid test_nghttp2_session_recv_invalid_frame(void);\nvoid test_nghttp2_session_recv_eof(void);\nvoid test_nghttp2_session_recv_data(void);\nvoid test_nghttp2_session_recv_data_no_auto_flow_control(void);\nvoid test_nghttp2_session_recv_continuation(void);\nvoid test_nghttp2_session_recv_headers_with_priority(void);\nvoid test_nghttp2_session_recv_headers_with_padding(void);\nvoid test_nghttp2_session_recv_headers_early_response(void);\nvoid test_nghttp2_session_recv_headers_for_closed_stream(void);\nvoid test_nghttp2_session_server_recv_push_response(void);\nvoid test_nghttp2_session_recv_premature_headers(void);\nvoid test_nghttp2_session_recv_unknown_frame(void);\nvoid test_nghttp2_session_recv_unexpected_continuation(void);\nvoid test_nghttp2_session_recv_settings_header_table_size(void);\nvoid test_nghttp2_session_recv_too_large_frame_length(void);\nvoid test_nghttp2_session_recv_extension(void);\nvoid test_nghttp2_session_recv_altsvc(void);\nvoid test_nghttp2_session_recv_origin(void);\nvoid test_nghttp2_session_continue(void);\nvoid test_nghttp2_session_add_frame(void);\nvoid test_nghttp2_session_on_request_headers_received(void);\nvoid test_nghttp2_session_on_response_headers_received(void);\nvoid test_nghttp2_session_on_headers_received(void);\nvoid test_nghttp2_session_on_push_response_headers_received(void);\nvoid test_nghttp2_session_on_priority_received(void);\nvoid test_nghttp2_session_on_rst_stream_received(void);\nvoid test_nghttp2_session_on_settings_received(void);\nvoid test_nghttp2_session_on_push_promise_received(void);\nvoid test_nghttp2_session_on_ping_received(void);\nvoid test_nghttp2_session_on_goaway_received(void);\nvoid test_nghttp2_session_on_window_update_received(void);\nvoid test_nghttp2_session_on_data_received(void);\nvoid test_nghttp2_session_on_data_received_fail_fast(void);\nvoid test_nghttp2_session_on_altsvc_received(void);\nvoid test_nghttp2_session_send_headers_start_stream(void);\nvoid test_nghttp2_session_send_headers_reply(void);\nvoid test_nghttp2_session_send_headers_frame_size_error(void);\nvoid test_nghttp2_session_send_headers_push_reply(void);\nvoid test_nghttp2_session_send_rst_stream(void);\nvoid test_nghttp2_session_send_push_promise(void);\nvoid test_nghttp2_session_is_my_stream_id(void);\nvoid test_nghttp2_session_upgrade2(void);\nvoid test_nghttp2_session_reprioritize_stream(void);\nvoid test_nghttp2_session_reprioritize_stream_with_idle_stream_dep(void);\nvoid test_nghttp2_submit_data(void);\nvoid test_nghttp2_submit_data_read_length_too_large(void);\nvoid test_nghttp2_submit_data_read_length_smallest(void);\nvoid test_nghttp2_submit_data_twice(void);\nvoid test_nghttp2_submit_request_with_data(void);\nvoid test_nghttp2_submit_request_without_data(void);\nvoid test_nghttp2_submit_response_with_data(void);\nvoid test_nghttp2_submit_response_without_data(void);\nvoid test_nghttp2_submit_response_push_response(void);\nvoid test_nghttp2_submit_trailer(void);\nvoid test_nghttp2_submit_headers_start_stream(void);\nvoid test_nghttp2_submit_headers_reply(void);\nvoid test_nghttp2_submit_headers_push_reply(void);\nvoid test_nghttp2_submit_headers(void);\nvoid test_nghttp2_submit_headers_continuation(void);\nvoid test_nghttp2_submit_headers_continuation_extra_large(void);\nvoid test_nghttp2_submit_priority(void);\nvoid test_nghttp2_submit_settings(void);\nvoid test_nghttp2_submit_settings_update_local_window_size(void);\nvoid test_nghttp2_submit_settings_multiple_times(void);\nvoid test_nghttp2_submit_push_promise(void);\nvoid test_nghttp2_submit_window_update(void);\nvoid test_nghttp2_submit_window_update_local_window_size(void);\nvoid test_nghttp2_submit_shutdown_notice(void);\nvoid test_nghttp2_submit_invalid_nv(void);\nvoid test_nghttp2_submit_extension(void);\nvoid test_nghttp2_submit_altsvc(void);\nvoid test_nghttp2_submit_origin(void);\nvoid test_nghttp2_session_open_stream(void);\nvoid test_nghttp2_session_open_stream_with_idle_stream_dep(void);\nvoid test_nghttp2_session_get_next_ob_item(void);\nvoid test_nghttp2_session_pop_next_ob_item(void);\nvoid test_nghttp2_session_reply_fail(void);\nvoid test_nghttp2_session_max_concurrent_streams(void);\nvoid test_nghttp2_session_stop_data_with_rst_stream(void);\nvoid test_nghttp2_session_defer_data(void);\nvoid test_nghttp2_session_flow_control(void);\nvoid test_nghttp2_session_flow_control_data_recv(void);\nvoid test_nghttp2_session_flow_control_data_with_padding_recv(void);\nvoid test_nghttp2_session_data_read_temporal_failure(void);\nvoid test_nghttp2_session_on_stream_close(void);\nvoid test_nghttp2_session_on_ctrl_not_send(void);\nvoid test_nghttp2_session_get_outbound_queue_size(void);\nvoid test_nghttp2_session_get_effective_local_window_size(void);\nvoid test_nghttp2_session_set_option(void);\nvoid test_nghttp2_session_data_backoff_by_high_pri_frame(void);\nvoid test_nghttp2_session_pack_data_with_padding(void);\nvoid test_nghttp2_session_pack_headers_with_padding(void);\nvoid test_nghttp2_pack_settings_payload(void);\nvoid test_nghttp2_session_stream_dep_add(void);\nvoid test_nghttp2_session_stream_dep_remove(void);\nvoid test_nghttp2_session_stream_dep_add_subtree(void);\nvoid test_nghttp2_session_stream_dep_remove_subtree(void);\nvoid test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us(void);\nvoid test_nghttp2_session_stream_attach_item(void);\nvoid test_nghttp2_session_stream_attach_item_subtree(void);\nvoid test_nghttp2_session_stream_get_state(void);\nvoid test_nghttp2_session_stream_get_something(void);\nvoid test_nghttp2_session_find_stream(void);\nvoid test_nghttp2_session_keep_closed_stream(void);\nvoid test_nghttp2_session_keep_idle_stream(void);\nvoid test_nghttp2_session_detach_idle_stream(void);\nvoid test_nghttp2_session_large_dep_tree(void);\nvoid test_nghttp2_session_graceful_shutdown(void);\nvoid test_nghttp2_session_on_header_temporal_failure(void);\nvoid test_nghttp2_session_recv_client_magic(void);\nvoid test_nghttp2_session_delete_data_item(void);\nvoid test_nghttp2_session_open_idle_stream(void);\nvoid test_nghttp2_session_cancel_reserved_remote(void);\nvoid test_nghttp2_session_reset_pending_headers(void);\nvoid test_nghttp2_session_send_data_callback(void);\nvoid test_nghttp2_session_on_begin_headers_temporal_failure(void);\nvoid test_nghttp2_session_defer_then_close(void);\nvoid test_nghttp2_session_detach_item_from_closed_stream(void);\nvoid test_nghttp2_session_flooding(void);\nvoid test_nghttp2_session_change_stream_priority(void);\nvoid test_nghttp2_session_create_idle_stream(void);\nvoid test_nghttp2_session_repeated_priority_change(void);\nvoid test_nghttp2_session_repeated_priority_submission(void);\nvoid test_nghttp2_session_set_local_window_size(void);\nvoid test_nghttp2_session_cancel_from_before_frame_send(void);\nvoid test_nghttp2_session_too_many_settings(void);\nvoid test_nghttp2_session_removed_closed_stream(void);\nvoid test_nghttp2_session_pause_data(void);\nvoid test_nghttp2_session_no_closed_streams(void);\nvoid test_nghttp2_session_set_stream_user_data(void);\nvoid test_nghttp2_http_mandatory_headers(void);\nvoid test_nghttp2_http_content_length(void);\nvoid test_nghttp2_http_content_length_mismatch(void);\nvoid test_nghttp2_http_non_final_response(void);\nvoid test_nghttp2_http_trailer_headers(void);\nvoid test_nghttp2_http_ignore_regular_header(void);\nvoid test_nghttp2_http_ignore_content_length(void);\nvoid test_nghttp2_http_record_request_method(void);\nvoid test_nghttp2_http_push_promise(void);\nvoid test_nghttp2_http_head_method_upgrade_workaround(void);\n\n#endif /* NGHTTP2_SESSION_TEST_H */\n"], "filenames": ["doc/CMakeLists.txt", "doc/Makefile.am", "lib/includes/nghttp2/nghttp2.h", "lib/nghttp2_helper.c", "lib/nghttp2_option.c", "lib/nghttp2_option.h", "lib/nghttp2_session.c", "lib/nghttp2_session.h", "tests/main.c", "tests/nghttp2_session_test.c", "tests/nghttp2_session_test.h"], "buggy_code_start_loc": [44, 71, 231, 336, 123, 69, 460, 269, 319, 10613, 158], "buggy_code_end_loc": [44, 71, 2660, 336, 123, 87, 7427, 269, 319, 10613, 158], "fixing_code_start_loc": [45, 72, 232, 337, 124, 70, 461, 270, 320, 10614, 159], "fixing_code_end_loc": [46, 73, 2684, 339, 129, 93, 7449, 272, 322, 10675, 160], "type": "CWE-707", "message": "In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection.", "other": {"cve": {"id": "CVE-2020-11080", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-03T23:15:11.073", "lastModified": "2022-08-29T20:41:12.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection."}, {"lang": "es", "value": "En nghttp2 versiones anteriores a 1.41.0, la carga \u00fatil de la trama HTTP/2 SETTINGS demasiado grande causa una denegaci\u00f3n de servicio. El ataque de prueba de concepto involucra a un cliente malicioso que construye una trama SETTINGS con una longitud de 14,400 bytes (2400 entradas de configuraciones individuales) una y otra vez. El ataque causa que la CPU se aumente al 100%. nghttp2 versi\u00f3n v1.41.0 corrige esta vulnerabilidad. Existe una soluci\u00f3n alternativa a esta vulnerabilidad. Implemente la funci\u00f3n nghttp2_on_frame_recv_callback callback, y si la trama es recibida es la trama SETTINGS y el n\u00famero de entradas de configuraci\u00f3n es grande (por ejemplo, mayor a 32), luego desconecte la conexi\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-707"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nghttp2:nghttp2:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.41.0", "matchCriteriaId": "6B8F12EE-F729-4A29-A21C-254E2E13B649"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_extensibility_workbench:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "EABAFD73-150F-4DFE-B721-29EB4475D979"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_extensibility_workbench:14.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "DE57039D-E2EE-4014-A7B1-D7380D26098E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:blockchain_platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.1.2", "matchCriteriaId": "D0DBC938-A782-433F-8BF1-CA250C332AA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_communications_broker:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "E11C65C3-1B17-4362-A99C-59583081A24D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_communications_broker:3.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "348EEE70-E114-4720-AAAF-E77DE5C9A2D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:graalvm:19.3.2:*:*:*:enterprise:*:*:*", "matchCriteriaId": "909B4029-1D4F-4D60-AC6D-98C7E9FF1B15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:graalvm:20.1.0:*:*:*:enterprise:*:*:*", "matchCriteriaId": "B501426C-7FB5-4C0D-83E4-0279746EFBE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.3.0", "versionEndIncluding": "7.3.30", "matchCriteriaId": "2D2F1144-F032-4687-8F76-1A4E45BCD8F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.4.0", "versionEndIncluding": "7.4.29", "matchCriteriaId": "BD5F19DF-F8E7-48B4-BBFA-22A0118584CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.5.0", "versionEndIncluding": "7.5.19", "matchCriteriaId": "FD7FA925-B9AC-4819-AAC1-C3478D80E3E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.6.0", "versionEndIncluding": "7.6.15", "matchCriteriaId": "DF828AB6-ED4E-4AA9-9E8D-58E715DBDB1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndIncluding": "8.0.21", "matchCriteriaId": "7A885799-F19A-41B5-B015-B318ED959755"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:-:*:*:*", "versionStartIncluding": "10.0.0", "versionEndIncluding": "10.12.0", "matchCriteriaId": "25A3180B-21AF-4010-9DAB-41ADFD2D8031"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:lts:*:*:*", "versionStartIncluding": "10.13.0", "versionEndExcluding": "10.21.0", "matchCriteriaId": "E9E9BD86-6374-45B3-8727-AACED7C8F3B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:-:*:*:*", "versionStartIncluding": "12.0.0", "versionEndIncluding": "12.12.0", "matchCriteriaId": "564ED5C8-50D7-413A-B88E-E62B6C07336A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:lts:*:*:*", "versionStartIncluding": "12.13.0", "versionEndExcluding": "12.18.0", "matchCriteriaId": "319C5BC0-7893-4FEC-8051-C8067F5007D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:-:*:*:*", "versionStartIncluding": "14.0.0", "versionEndIncluding": "14.4.0", "matchCriteriaId": "7AB132F1-11B6-4B70-8819-4ADD7B6C814E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00024.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nghttp2/nghttp2/commit/f8da73bd042f810f34d19f9eae02b46d870af394", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nghttp2/nghttp2/security/advisories/GHSA-q5wr-xfw9-q7xr", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/10/msg00011.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4OOYAMJVLLCLXDTHW3V5UXNULZBBK4O6/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AAC2AA36OTRHKSVM5OV7TTVB3CZIGEFL/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4696", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "security-advisories@github.com", "tags": ["Not Applicable", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090"}}