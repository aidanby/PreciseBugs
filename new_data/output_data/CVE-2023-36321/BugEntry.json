{"buggy_code": ["/*\n * SPDX license identifier: MPL-2.0\n *\n * Copyright (C) 2011-2015, BMW AG\n *\n * This file is part of GENIVI Project DLT - Diagnostic Log and Trace.\n *\n * This Source Code Form is subject to the terms of the\n * Mozilla Public License (MPL), v. 2.0.\n * If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * For further information see http://www.genivi.org/.\n */\n\n/*!\n * \\author\n * Alexander Wenzel <alexander.aw.wenzel@bmw.de>\n * Markus Klein <Markus.Klein@esk.fraunhofer.de>\n * Mikko Rapeli <mikko.rapeli@bmw.de>\n *\n * \\copyright Copyright \u00a9 2011-2015 BMW AG. \\n\n * License MPL-2.0: Mozilla Public License version 2.0 http://mozilla.org/MPL/2.0/.\n *\n * \\file dlt_common.c\n */\n\n#include <stdio.h>\n#include <stdlib.h>   /* for malloc(), free() */\n#include <string.h>   /* for strlen(), memcmp(), memmove() */\n#include <time.h>     /* for localtime_r(), strftime() */\n#include <limits.h>   /* for NAME_MAX */\n#include <inttypes.h> /* for PRI formatting macro */\n#include <stdarg.h>\n#include <err.h>\n\n#include <errno.h>\n#include <sys/stat.h> /* for mkdir() */\n#include <sys/wait.h>\n\n#include \"dlt_user_shared.h\"\n#include \"dlt_common.h\"\n#include \"dlt_common_cfg.h\"\n\n#include \"dlt_version.h\"\n\n#if defined (__WIN32__) || defined (_MSC_VER)\n#   include <winsock2.h> /* for socket(), connect(), send(), and recv() */\n#else\n#   include <sys/socket.h> /* for socket(), connect(), send(), and recv() */\n#   include <syslog.h>\n#   include <time.h> /* for clock_gettime() */\n#endif\n\n#if defined (_MSC_VER)\n#   include <io.h>\n#else\n#   include <unistd.h>  /* for read(), close() */\n#   include <fcntl.h>\n#   include <sys/time.h> /* for gettimeofday() */\n#endif\n\n#if defined (__MSDOS__) || defined (_MSC_VER)\n#   pragma warning(disable : 4996) /* Switch off C4996 warnings */\n#   include <windows.h>\n#   include <winbase.h>\n#endif\n\nconst char dltSerialHeader[DLT_ID_SIZE] = { 'D', 'L', 'S', 1 };\nchar dltSerialHeaderChar[DLT_ID_SIZE] = { 'D', 'L', 'S', 1 };\n\n#if defined DLT_DAEMON_USE_FIFO_IPC || defined DLT_LIB_USE_FIFO_IPC\nchar dltFifoBaseDir[DLT_PATH_MAX] = \"/tmp\";\n#endif\n\n#ifdef DLT_SHM_ENABLE\nchar dltShmName[NAME_MAX + 1] = \"/dlt-shm\";\n#endif\n\n/* internal logging parameters */\nstatic int logging_level = LOG_INFO;\nstatic char logging_filename[NAME_MAX + 1] = \"\";\nstatic bool print_with_attributes = false;\nint logging_mode = DLT_LOG_TO_STDERR;\nFILE *logging_handle = NULL;\n\nchar *message_type[] = { \"log\", \"app_trace\", \"nw_trace\", \"control\", \"\", \"\", \"\", \"\" };\nchar *log_info[] = { \"\", \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"verbose\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nchar *trace_type[] = { \"\", \"variable\", \"func_in\", \"func_out\", \"state\", \"vfb\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nchar *nw_trace_type[] = { \"\", \"ipc\", \"can\", \"flexray\", \"most\", \"vfb\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nchar *control_type[] = { \"\", \"request\", \"response\", \"time\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nstatic char *service_id_name[] =\n{ \"\", \"set_log_level\", \"set_trace_status\", \"get_log_info\", \"get_default_log_level\", \"store_config\",\n  \"reset_to_factory_default\",\n  \"set_com_interface_status\", \"set_com_interface_max_bandwidth\", \"set_verbose_mode\",\n  \"set_message_filtering\", \"set_timing_packets\",\n  \"get_local_time\", \"use_ecu_id\", \"use_session_id\", \"use_timestamp\", \"use_extended_header\",\n  \"set_default_log_level\", \"set_default_trace_status\",\n  \"get_software_version\", \"message_buffer_overflow\" };\nstatic char *return_type[] =\n{ \"ok\", \"not_supported\", \"error\", \"perm_denied\", \"warning\", \"\", \"\", \"\", \"no_matching_context_id\" };\n\n/* internal function definitions */\nint dlt_buffer_get(DltBuffer *buf, unsigned char *data, int max_size, int delete);\nint dlt_buffer_reset(DltBuffer *buf);\nint dlt_buffer_increase_size(DltBuffer *buf);\nint dlt_buffer_minimize_size(DltBuffer *buf);\nvoid dlt_buffer_write_block(DltBuffer *buf, int *write, const unsigned char *data, unsigned int size);\nvoid dlt_buffer_read_block(DltBuffer *buf, int *read, unsigned char *data, unsigned int size);\n\nvoid dlt_print_hex(uint8_t *ptr, int size)\n{\n    int num;\n\n    if (ptr == NULL)\n        return;\n\n    for (num = 0; num < size; num++) {\n        if (num > 0)\n            dlt_user_printf(\" \");\n\n        dlt_user_printf(\"%.2x\", ((uint8_t *)ptr)[num]);\n    }\n}\n\nstatic DltReturnValue dlt_print_hex_string_delim(char *text, int textlength, uint8_t *ptr, int size, char delim)\n{\n    int num;\n\n    if ((ptr == NULL) || (text == NULL) || (textlength <= 0) || (size < 0) || (delim == '\\0'))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Length 3: AB_ , A is first digit of hex number, B is second digit of hex number, _ is space */\n    if (textlength < (size * 3)) {\n        dlt_vlog(LOG_WARNING,\n                 \"String does not fit hex data (available=%d, required=%d) !\\n\",\n                 textlength, size * 3);\n        return DLT_RETURN_ERROR;\n    }\n\n    for (num = 0; num < size; num++) {\n        if (num > 0) {\n            snprintf(text, 2, \"%c\", delim);\n            text++;\n        }\n\n        snprintf(text, 3, \"%.2x\", ((uint8_t *)ptr)[num]);\n        text += 2; /* 2 chars */\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_print_hex_string(char *text, int textlength, uint8_t *ptr, int size)\n{\n    return dlt_print_hex_string_delim(text, textlength, ptr, size, ' ');\n}\n\nDltReturnValue dlt_print_mixed_string(char *text, int textlength, uint8_t *ptr, int size, int html)\n{\n    int required_size = 0;\n    int lines, rest, i;\n\n    if ((ptr == NULL) || (text == NULL) || (textlength <= 0) || (size < 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Check maximum required size and do a length check */\n    if (html == 0)\n        required_size =\n            (DLT_COMMON_HEX_LINELEN + (2 * DLT_COMMON_HEX_CHARS + (DLT_COMMON_HEX_CHARS - 1)) + DLT_COMMON_CHARLEN +\n             DLT_COMMON_HEX_CHARS + DLT_COMMON_CHARLEN) *\n            ((size / DLT_COMMON_HEX_CHARS) + 1);\n    /* Example: (8 chars line number + (2*16 chars + 15 spaces) + space + 16 ascii chars + CR) *\n     * ((size/16) lines + extra line for the rest) */\n    else\n        required_size =\n            (DLT_COMMON_HEX_LINELEN + (2 * DLT_COMMON_HEX_CHARS + (DLT_COMMON_HEX_CHARS - 1)) + DLT_COMMON_CHARLEN +\n             DLT_COMMON_HEX_CHARS + 4 * DLT_COMMON_CHARLEN) *\n            ((size / DLT_COMMON_HEX_CHARS) + 1);\n\n    /* Example: (8 chars line number + (2*16 chars + 15 spaces) + space + 16 ascii chars + 4 [HTML CR: <BR>]) *\n     * ((size/16) lines + extra line for the rest) */\n\n    if (textlength < required_size) {\n        dlt_vlog(LOG_WARNING,\n                 \"String does not fit mixed data (available=%d, required=%d) !\\n\",\n                 textlength, required_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* print full lines */\n    for (lines = 0; lines < (size / DLT_COMMON_HEX_CHARS); lines++) {\n        int ret = 0;\n        /* Line number */\n        ret = snprintf(text, DLT_COMMON_HEX_LINELEN + 1, \"%.6x: \", (uint32_t)lines * DLT_COMMON_HEX_CHARS);\n\n        if ((ret < 0) || (ret >= (DLT_COMMON_HEX_LINELEN + 1)))\n            dlt_log(LOG_WARNING, \"line was truncated\\n\");\n\n        text += DLT_COMMON_HEX_LINELEN; /* 'XXXXXX: ' */\n\n        /* Hex-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_hex_string(text, textlength,\n                (uint8_t *)(ptr + (lines * DLT_COMMON_HEX_CHARS)),\n                DLT_COMMON_HEX_CHARS) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n        text += ((2 * DLT_COMMON_HEX_CHARS) + (DLT_COMMON_HEX_CHARS - 1)); /* 32 characters + 15 spaces */\n\n        snprintf(text, 2, \" \");\n        text += DLT_COMMON_CHARLEN;\n\n        /* Char-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_char_string(&text, textlength,\n                (uint8_t *)(ptr + (lines * DLT_COMMON_HEX_CHARS)),\n                DLT_COMMON_HEX_CHARS) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n\n        if (html == 0) {\n            snprintf(text, 2, \"\\n\");\n            text += DLT_COMMON_CHARLEN;\n        }\n        else {\n            snprintf(text, 5, \"<BR>\");\n            text += (4 * DLT_COMMON_CHARLEN);\n        }\n    }\n\n    /* print partial line */\n    rest = size % DLT_COMMON_HEX_CHARS;\n\n    if (rest > 0) {\n        /* Line number */\n        int ret = 0;\n        ret = snprintf(text, 9, \"%.6x: \", (uint32_t)(size / DLT_COMMON_HEX_CHARS) * DLT_COMMON_HEX_CHARS);\n\n        if ((ret < 0) || (ret >= 9))\n            dlt_log(LOG_WARNING, \"line number was truncated\");\n\n        text += DLT_COMMON_HEX_LINELEN; /* 'XXXXXX: ' */\n\n        /* Hex-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_hex_string(text,\n                             textlength,\n                             (uint8_t *)(ptr + ((size / DLT_COMMON_HEX_CHARS) * DLT_COMMON_HEX_CHARS)),\n                             rest) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n        text += 2 * rest + (rest - 1);\n\n        for (i = 0; i < (DLT_COMMON_HEX_CHARS - rest); i++) {\n            snprintf(text, 4, \" xx\");\n            text += (3 * DLT_COMMON_CHARLEN);\n        }\n\n        snprintf(text, 2, \" \");\n        text += DLT_COMMON_CHARLEN;\n\n        /* Char-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_char_string(&text, textlength,\n                              (uint8_t *)(ptr + ((size / DLT_COMMON_HEX_CHARS) * DLT_COMMON_HEX_CHARS)),\n                              rest) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_print_char_string(char **text, int textlength, uint8_t *ptr, int size)\n{\n    int num;\n\n    if ((text == NULL) || (ptr == NULL) || (*text == NULL) || (textlength <= 0) || (size < 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (textlength < size) {\n        dlt_vlog(LOG_WARNING,\n                 \"String does not fit character data (available=%d, required=%d) !\\n\",\n                 textlength, size);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    for (num = 0; num < size; num++) {\n        if ((((char *)ptr)[num] < DLT_COMMON_ASCII_CHAR_SPACE) || (((char *)ptr)[num] > DLT_COMMON_ASCII_CHAR_TILDE)) {\n            snprintf(*text, 2, \".\");\n        }\n        else {\n            /* replace < with . */\n            if (((char *)ptr)[num] != DLT_COMMON_ASCII_CHAR_LT)\n                snprintf(*text, 2, \"%c\", ((char *)ptr)[num]);\n            else\n                snprintf(*text, 2, \".\");\n        }\n\n        (*text)++;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nsize_t dlt_strnlen_s(const char* str, size_t maxsize)\n{\n    if (str == NULL)\n        return 0;\n\n    for (size_t i = 0; i < maxsize; ++i) {\n        if (str[i] == '\\0')\n            return i;\n    }\n    return maxsize;\n}\n\nvoid dlt_print_id(char *text, const char *id)\n{\n    /* check nullpointer */\n    if ((text == NULL) || (id == NULL))\n        return;\n\n    /* Initialize text */\n    memset(text, '-', DLT_ID_SIZE);\n\n    text[DLT_ID_SIZE] = 0;\n\n    size_t len = dlt_strnlen_s(id, DLT_ID_SIZE);\n\n    memcpy(text, id, len);\n}\n\nvoid dlt_set_id(char *id, const char *text)\n{\n    /* check nullpointer */\n    if ((id == NULL) || (text == NULL))\n        return;\n\n    id[0] = 0;\n    id[1] = 0;\n    id[2] = 0;\n    id[3] = 0;\n\n    if (text[0] != 0)\n        id[0] = text[0];\n    else\n        return;\n\n    if (text[1] != 0)\n        id[1] = text[1];\n    else\n        return;\n\n    if (text[2] != 0)\n        id[2] = text[2];\n    else\n        return;\n\n    if (text[3] != 0)\n        id[3] = text[3];\n    else\n        return;\n}\n\nvoid dlt_clean_string(char *text, int length)\n{\n    int num;\n\n    if (text == NULL)\n        return;\n\n    for (num = 0; num < length; num++)\n        if ((text[num] == '\\r') || (text[num] == '\\n'))\n            text[num] = ' ';\n}\n\nDltReturnValue dlt_filter_init(DltFilter *filter, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (filter == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    filter->counter = 0;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_filter_free(DltFilter *filter, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (filter == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    char str1[DLT_COMMON_BUFFER_LENGTH + 1];\n    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"r\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    #define FORMAT_STRING_(x) \"%\" #x \"s\"\n    #define FORMAT_STRING(x) FORMAT_STRING_(x)\n\n    /* Reset filters */\n    filter->counter = 0;\n\n    while (!feof(handle)) {\n        str1[0] = 0;\n\n        if (fscanf(handle, FORMAT_STRING(DLT_COMMON_BUFFER_LENGTH), str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(apid, \"\");\n        else\n            dlt_set_id(apid, str1);\n\n        str1[0] = 0;\n\n        if (fscanf(handle, FORMAT_STRING(DLT_COMMON_BUFFER_LENGTH), str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\\r\\n\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(ctid, \"\");\n        else\n            dlt_set_id(ctid, str1);\n\n        if (filter->counter < DLT_FILTER_MAX)\n            dlt_filter_add(filter, apid, ctid, 0, 0, INT32_MAX, verbose);\n        else\n            dlt_vlog(LOG_WARNING,\n                     \"Maximum number (%d) of allowed filters reached, ignoring rest of filters!\\n\",\n                     DLT_FILTER_MAX);\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_filter_save(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    int num;\n    char buf[DLT_COMMON_BUFFER_LENGTH];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"w\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    for (num = 0; num < filter->counter; num++) {\n        if (filter->apid[num][0] == 0) {\n            fprintf(handle, \"---- \");\n        }\n        else {\n            dlt_print_id(buf, filter->apid[num]);\n            fprintf(handle, \"%s \", buf);\n        }\n\n        if (filter->ctid[num][0] == 0) {\n            fprintf(handle, \"---- \");\n        }\n        else {\n            dlt_print_id(buf, filter->ctid[num]);\n            fprintf(handle, \"%s \", buf);\n        }\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_filter_find(DltFilter *filter, const char *apid, const char *ctid, const int log_level,\n                    const int32_t payload_min, const int32_t payload_max, int verbose)\n{\n    int num;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((filter == NULL) || (apid == NULL))\n        return -1;\n\n    for (num = 0; num < filter->counter; num++)\n        if (memcmp(filter->apid[num], apid, DLT_ID_SIZE) == 0) {\n            /* apid matches, now check for ctid */\n            if (ctid == NULL) {\n                /* check if empty ctid matches */\n                /*if (memcmp(filter->ctid[num],\"\",DLT_ID_SIZE)==0)//coverity complains here about Out-of-bounds access. */\n                char empty_ctid[DLT_ID_SIZE] = \"\";\n\n                if (memcmp(filter->ctid[num], empty_ctid, DLT_ID_SIZE) == 0)\n                    if ((filter->log_level[num] == log_level) || (filter->log_level[num] == 0))\n                        if (filter->payload_min[num] <= payload_min)\n                            if (filter->payload_max[num] >= payload_max)\n                                return num;\n            }\n            else if (memcmp(filter->ctid[num], ctid, DLT_ID_SIZE) == 0)\n            {\n                if ((filter->log_level[num] == log_level) || (filter->log_level[num] == 0))\n                    if (filter->payload_min[num] <= payload_min)\n                        if (filter->payload_max[num] >= payload_max)\n                            return num;\n            }\n        }\n\n    return -1; /* Not found */\n}\n\nDltReturnValue dlt_filter_add(DltFilter *filter, const char *apid, const char *ctid, const int log_level,\n                              const int32_t payload_min, const int32_t payload_max, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((filter == NULL) || (apid == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (filter->counter >= DLT_FILTER_MAX) {\n        dlt_vlog(LOG_WARNING,\n                 \"Maximum number (%d) of allowed filters reached, ignoring filter!\\n\",\n                 DLT_FILTER_MAX);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* add each filter (apid, ctid, log_level, payload_min, payload_max) only once to filter array */\n    if (dlt_filter_find(filter, apid, ctid, log_level, payload_min, payload_max, verbose) < 0) {\n        /* filter not found, so add it to filter array */\n        dlt_set_id(filter->apid[filter->counter], apid);\n        dlt_set_id(filter->ctid[filter->counter], (ctid ? ctid : \"\"));\n        filter->log_level[filter->counter] = log_level;\n        filter->payload_min[filter->counter] = payload_min;\n        filter->payload_max[filter->counter] = payload_max;\n\n        filter->counter++;\n\n        return DLT_RETURN_OK;\n    }\n\n    return DLT_RETURN_ERROR;\n}\n\nDltReturnValue dlt_filter_delete(DltFilter *filter, const char *apid, const char *ctid, const int log_level,\n                                 const int32_t payload_min, const int32_t payload_max, int verbose)\n{\n    int j, k;\n    int found = 0;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((filter == NULL) || (apid == NULL) || (ctid == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (filter->counter > 0) {\n        /* Get first occurence of apid and ctid in filter array */\n        for (j = 0; j < filter->counter; j++)\n            if ((memcmp(filter->apid[j], apid, DLT_ID_SIZE) == 0) &&\n                (memcmp(filter->ctid[j], ctid, DLT_ID_SIZE) == 0) &&\n                ((filter->log_level[j] == log_level) || (filter->log_level[j] == 0)) &&\n                (filter->payload_min[j] == payload_min) &&\n                (filter->payload_max[j] == payload_max)\n                ) {\n                found = 1;\n                break;\n            }\n\n        if (found) {\n            /* j is index */\n            /* Copy from j+1 til end to j til end-1 */\n\n            dlt_set_id(filter->apid[j], \"\");\n            dlt_set_id(filter->ctid[j], \"\");\n            filter->log_level[j] = 0;\n            filter->payload_min[j] = 0;\n            filter->payload_max[j] = INT32_MAX;\n\n            for (k = j; k < (filter->counter - 1); k++) {\n                dlt_set_id(filter->apid[k], filter->apid[k + 1]);\n                dlt_set_id(filter->ctid[k], filter->ctid[k + 1]);\n                filter->log_level[k] = filter->log_level[k + 1];\n                filter->payload_min[k] = filter->payload_min[k + 1];\n                filter->payload_max[k] = filter->payload_max[k + 1];\n            }\n\n            filter->counter--;\n            return DLT_RETURN_OK;\n        }\n    }\n\n    return DLT_RETURN_ERROR;\n}\n\nDltReturnValue dlt_message_init(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* initalise structure parameters */\n    msg->headersize = 0;\n    msg->datasize = 0;\n\n    msg->databuffer = NULL;\n    msg->databuffersize = 0;\n\n    msg->storageheader = NULL;\n    msg->standardheader = NULL;\n    msg->extendedheader = NULL;\n\n    msg->found_serialheader = 0;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_free(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* delete databuffer if exists */\n    if (msg->databuffer) {\n        free(msg->databuffer);\n        msg->databuffer = NULL;\n        msg->databuffersize = 0;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_header(DltMessage *msg, char *text, size_t textlength, int verbose)\n{\n    return dlt_message_header_flags(msg, text, textlength, DLT_HEADER_SHOW_ALL, verbose);\n}\n\nDltReturnValue dlt_message_header_flags(DltMessage *msg, char *text, size_t textlength, int flags, int verbose)\n{\n    struct tm timeinfo;\n    char buffer [DLT_COMMON_BUFFER_LENGTH];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (text == NULL) || (textlength <= 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) && (msg->extendedheader == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((flags < DLT_HEADER_SHOW_NONE) || (flags > DLT_HEADER_SHOW_ALL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    text[0] = 0;\n\n    if ((flags & DLT_HEADER_SHOW_TIME) == DLT_HEADER_SHOW_TIME) {\n        /* print received time */\n        time_t tt = msg->storageheader->seconds;\n        tzset();\n        localtime_r(&tt, &timeinfo);\n        strftime (buffer, sizeof(buffer), \"%Y/%m/%d %H:%M:%S\", &timeinfo);\n        snprintf(text, textlength, \"%s.%.6d \", buffer, msg->storageheader->microseconds);\n    }\n\n    if ((flags & DLT_HEADER_SHOW_TMSTP) == DLT_HEADER_SHOW_TMSTP) {\n        /* print timestamp if available */\n        if (DLT_IS_HTYP_WTMS(msg->standardheader->htyp))\n            snprintf(text + strlen(text), textlength - strlen(text), \"%10u \", msg->headerextra.tmsp);\n        else\n            snprintf(text + strlen(text), textlength - strlen(text), \"---------- \");\n    }\n\n    if ((flags & DLT_HEADER_SHOW_MSGCNT) == DLT_HEADER_SHOW_MSGCNT)\n        /* print message counter */\n        snprintf(text + strlen(text), textlength - strlen(text), \"%.3d \", msg->standardheader->mcnt);\n\n    if ((flags & DLT_HEADER_SHOW_ECUID) == DLT_HEADER_SHOW_ECUID) {\n        /* print ecu id, use header extra if available, else storage header value */\n        if (DLT_IS_HTYP_WEID(msg->standardheader->htyp))\n            dlt_print_id(text + strlen(text), msg->headerextra.ecu);\n        else\n            dlt_print_id(text + strlen(text), msg->storageheader->ecu);\n    }\n\n    /* print app id and context id if extended header available, else '----' */ #\n\n    if ((flags & DLT_HEADER_SHOW_APID) == DLT_HEADER_SHOW_APID) {\n        snprintf(text + strlen(text), textlength - strlen(text), \" \");\n\n        if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) && (msg->extendedheader->apid[0] != 0))\n            dlt_print_id(text + strlen(text), msg->extendedheader->apid);\n        else\n            snprintf(text + strlen(text), textlength - strlen(text), \"----\");\n\n        snprintf(text + strlen(text), textlength - strlen(text), \" \");\n    }\n\n    if ((flags & DLT_HEADER_SHOW_CTID) == DLT_HEADER_SHOW_CTID) {\n        if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) && (msg->extendedheader->ctid[0] != 0))\n            dlt_print_id(text + strlen(text), msg->extendedheader->ctid);\n        else\n            snprintf(text + strlen(text), textlength - strlen(text), \"----\");\n\n        snprintf(text + strlen(text), textlength - strlen(text), \" \");\n    }\n\n    /* print info about message type and length */\n    if (DLT_IS_HTYP_UEH(msg->standardheader->htyp)) {\n        if ((flags & DLT_HEADER_SHOW_MSGTYPE) == DLT_HEADER_SHOW_MSGTYPE) {\n            snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                     message_type[DLT_GET_MSIN_MSTP(msg->extendedheader->msin)]);\n            snprintf(text + strlen(text), textlength - strlen(text), \" \");\n        }\n\n        if ((flags & DLT_HEADER_SHOW_MSGSUBTYPE) == DLT_HEADER_SHOW_MSGSUBTYPE) {\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_LOG)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         log_info[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_APP_TRACE)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         trace_type[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_NW_TRACE)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         nw_trace_type[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_CONTROL)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         control_type[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            snprintf(text + strlen(text), textlength - strlen(text), \" \");\n        }\n\n        if ((flags & DLT_HEADER_SHOW_VNVSTATUS) == DLT_HEADER_SHOW_VNVSTATUS) {\n            /* print verbose status pf message */\n            if (DLT_IS_MSIN_VERB(msg->extendedheader->msin))\n                snprintf(text + strlen(text), textlength - strlen(text), \"V\");\n            else\n                snprintf(text + strlen(text), textlength - strlen(text), \"N\");\n\n            snprintf(text + strlen(text), textlength - strlen(text), \" \");\n        }\n\n        if ((flags & DLT_HEADER_SHOW_NOARG) == DLT_HEADER_SHOW_NOARG)\n            /* print number of arguments */\n            snprintf(text + strlen(text), textlength - strlen(text), \"%d\", msg->extendedheader->noar);\n    }\n    else {\n        if ((flags & DLT_HEADER_SHOW_MSGTYPE) == DLT_HEADER_SHOW_MSGTYPE)\n            snprintf(text + strlen(text), textlength - strlen(text), \"--- \");\n\n        if ((flags & DLT_HEADER_SHOW_MSGSUBTYPE) == DLT_HEADER_SHOW_MSGSUBTYPE)\n            snprintf(text + strlen(text), textlength - strlen(text), \"--- \");\n\n        if ((flags & DLT_HEADER_SHOW_VNVSTATUS) == DLT_HEADER_SHOW_VNVSTATUS)\n            snprintf(text + strlen(text), textlength - strlen(text), \"N \");\n\n        if ((flags & DLT_HEADER_SHOW_NOARG) == DLT_HEADER_SHOW_NOARG)\n            snprintf(text + strlen(text), textlength - strlen(text), \"-\");\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_payload(DltMessage *msg, char *text, size_t textlength, int type, int verbose)\n{\n    uint32_t id = 0, id_tmp = 0;\n    uint8_t retval = 0;\n\n    uint8_t *ptr;\n    int32_t datalength;\n\n    /* Pointer to ptr and datalength */\n    uint8_t **pptr;\n    int32_t *pdatalength;\n\n    int ret = 0;\n\n    int num;\n    uint32_t type_info = 0, type_info_tmp = 0;\n    int text_offset = 0;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (msg->databuffer == NULL) || (text == NULL) ||\n        (type < DLT_OUTPUT_HEX) || (type > DLT_OUTPUT_ASCII_LIMITED))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (textlength <= 0) {\n        dlt_log(LOG_WARNING, \"String does not fit binary data!\\n\");\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    /* start with empty string */\n    text[0] = 0;\n\n    /* print payload only as hex */\n    if (type == DLT_OUTPUT_HEX)\n        return dlt_print_hex_string(text, (int)textlength, msg->databuffer, (int)msg->datasize);\n\n    /* print payload as mixed */\n    if (type == DLT_OUTPUT_MIXED_FOR_PLAIN)\n        return dlt_print_mixed_string(text, (int)textlength, msg->databuffer, (int)msg->datasize, 0);\n\n    if (type == DLT_OUTPUT_MIXED_FOR_HTML)\n        return dlt_print_mixed_string(text, (int)textlength, msg->databuffer, (int)msg->datasize, 1);\n\n    ptr = msg->databuffer;\n    datalength = (int32_t)msg->datasize;\n\n    /* Pointer to ptr and datalength */\n    pptr = &ptr;\n    pdatalength = &datalength;\n\n    /* non-verbose mode */\n\n    /* print payload as hex */\n    if (DLT_MSG_IS_NONVERBOSE(msg)) {\n\n        DLT_MSG_READ_VALUE(id_tmp, ptr, datalength, uint32_t);\n        id = DLT_ENDIAN_GET_32(msg->standardheader->htyp, id_tmp);\n\n        if (textlength < (((unsigned int)datalength * 3) + 20)) {\n            dlt_vlog(LOG_WARNING,\n                     \"String does not fit binary data (available=%d, required=%d) !\\n\",\n                     (int) textlength, (datalength * 3) + 20);\n            return DLT_RETURN_ERROR;\n        }\n\n        /* process message id / service id */\n        if (DLT_MSG_IS_CONTROL(msg)) {\n            if ((id > 0) && (id < DLT_SERVICE_ID_LAST_ENTRY))\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         service_id_name[id]); /* service id */\n            else if (!(DLT_MSG_IS_CONTROL_TIME(msg)))\n                snprintf(text + strlen(text), textlength - strlen(text), \"service(%u)\", id); /* service id */\n\n            if (datalength > 0)\n                snprintf(text + strlen(text), textlength - strlen(text), \", \");\n        }\n        else {\n            snprintf(text + strlen(text), textlength - strlen(text), \"%u, \", id); /* message id */\n        }\n\n        /* process return value */\n        if (DLT_MSG_IS_CONTROL_RESPONSE(msg)) {\n            if (datalength > 0) {\n                DLT_MSG_READ_VALUE(retval, ptr, datalength, uint8_t); /* No endian conversion necessary */\n\n                if ((retval < DLT_SERVICE_RESPONSE_LAST) || (retval == 8))\n                    snprintf(text + strlen(text), textlength - strlen(text), \"%s\", return_type[retval]);\n                else\n                    snprintf(text + strlen(text), textlength - strlen(text), \"%.2x\", retval);\n\n                if (datalength >= 1)\n                    snprintf(text + strlen(text), textlength - strlen(text), \", \");\n            }\n        }\n\n        if (type == DLT_OUTPUT_ASCII_LIMITED) {\n            ret = dlt_print_hex_string(text + strlen(text),\n                                       (int)(textlength - strlen(\n                                                 text)),\n                                       ptr,\n                                       (datalength >\n                                        DLT_COMMON_ASCII_LIMIT_MAX_CHARS ? DLT_COMMON_ASCII_LIMIT_MAX_CHARS : datalength));\n\n            if ((datalength > DLT_COMMON_ASCII_LIMIT_MAX_CHARS) &&\n                ((textlength - strlen(text)) > 4))\n                snprintf(text + strlen(text), textlength - strlen(text), \" ...\");\n        }\n        else {\n            ret = dlt_print_hex_string(text + strlen(text), (int)(textlength - strlen(text)), ptr, datalength);\n        }\n\n        return ret;\n    }\n\n    /* At this point, it is ensured that a extended header is available */\n\n    /* verbose mode */\n    type_info = 0;\n    type_info_tmp = 0;\n\n    for (num = 0; num < (int)(msg->extendedheader->noar); num++) {\n        if (num != 0) {\n            text_offset = (int)strlen(text);\n            snprintf(text + text_offset, textlength - (size_t)text_offset, \" \");\n        }\n\n        /* first read the type info of the argument */\n        DLT_MSG_READ_VALUE(type_info_tmp, ptr, datalength, uint32_t);\n        type_info = DLT_ENDIAN_GET_32(msg->standardheader->htyp, type_info_tmp);\n\n        /* print out argument */\n        text_offset = (int)strlen(text);\n\n        if (dlt_message_argument_print(msg, type_info, pptr, pdatalength,\n                                       (text + text_offset), (textlength - (size_t)text_offset), -1,\n                                       0) == DLT_RETURN_ERROR)\n            return DLT_RETURN_ERROR;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_filter_check(DltMessage *msg, DltFilter *filter, int verbose)\n{\n    /* check the filters if message is used */\n    int num;\n    DltReturnValue found = DLT_RETURN_OK;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (filter == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((filter->counter == 0) || (!(DLT_IS_HTYP_UEH(msg->standardheader->htyp))))\n        /* no filter is set, or no extended header is available, so do as filter is matching */\n        return DLT_RETURN_TRUE;\n\n    for (num = 0; num < filter->counter; num++)\n        /* check each filter if it matches */\n        if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) &&\n            ((filter->apid[num][0] == 0) || (memcmp(filter->apid[num], msg->extendedheader->apid, DLT_ID_SIZE) == 0)) &&\n            ((filter->ctid[num][0] == 0) || (memcmp(filter->ctid[num], msg->extendedheader->ctid, DLT_ID_SIZE) == 0)) &&\n            ((filter->log_level[num] == 0) ||\n             (filter->log_level[num] == DLT_GET_MSIN_MTIN(msg->extendedheader->msin))) &&\n            ((filter->payload_min[num] == 0) || (filter->payload_min[num] <= msg->datasize)) &&\n            ((filter->payload_max[num] == 0) || (filter->payload_max[num] >= msg->datasize))) {\n            found = DLT_RETURN_TRUE;\n            break;\n        }\n\n    return found;\n}\n\nint dlt_message_read(DltMessage *msg, uint8_t *buffer, unsigned int length, int resync, int verbose)\n{\n    uint32_t extra_size = 0;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (buffer == NULL) || (length <= 0))\n        return DLT_MESSAGE_ERROR_UNKNOWN;\n\n    /* initialize resync_offset */\n    msg->resync_offset = 0;\n\n    /* check if message contains serial header, smaller than standard header */\n    if (length < sizeof(dltSerialHeader))\n        /* dlt_log(LOG_ERR, \"Length smaller than serial header!\\n\"); */\n        return DLT_MESSAGE_ERROR_SIZE;\n\n    if (memcmp(buffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {\n        /* serial header found */\n        msg->found_serialheader = 1;\n        buffer += sizeof(dltSerialHeader);\n        length -= (unsigned int)sizeof(dltSerialHeader);\n    }\n    else {\n        /* serial header not found */\n        msg->found_serialheader = 0;\n\n        if (resync) {\n            /* resync if necessary */\n            msg->resync_offset = 0;\n\n            do {\n                if (memcmp(buffer + msg->resync_offset, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {\n                    /* serial header found */\n                    msg->found_serialheader = 1;\n                    buffer += sizeof(dltSerialHeader);\n                    length -= (unsigned int)sizeof(dltSerialHeader);\n                    break;\n                }\n\n                msg->resync_offset++;\n            } while ((sizeof(dltSerialHeader) + (size_t)msg->resync_offset) <= length);\n\n            /* Set new start offset */\n            if (msg->resync_offset > 0) {\n                /* Resyncing connection */\n                buffer += msg->resync_offset;\n                length -= (unsigned int)msg->resync_offset;\n            }\n        }\n    }\n\n    /* check that standard header fits buffer */\n    if (length < sizeof(DltStandardHeader))\n        /* dlt_log(LOG_ERR, \"Length smaller than standard header!\\n\"); */\n        return DLT_MESSAGE_ERROR_SIZE;\n\n    memcpy(msg->headerbuffer + sizeof(DltStorageHeader), buffer, sizeof(DltStandardHeader));\n\n    /* set ptrs to structures */\n    msg->storageheader = (DltStorageHeader *)msg->headerbuffer;\n    msg->standardheader = (DltStandardHeader *)(msg->headerbuffer + sizeof(DltStorageHeader));\n\n    /* calculate complete size of headers */\n    extra_size = (uint32_t) (DLT_STANDARD_HEADER_EXTRA_SIZE(msg->standardheader->htyp) +\n        (DLT_IS_HTYP_UEH(msg->standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));\n    msg->headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) + extra_size);\n    msg->datasize = (uint32_t) DLT_BETOH_16(msg->standardheader->len) - msg->headersize + (uint32_t) sizeof(DltStorageHeader);\n\n    /* calculate complete size of payload */\n    int32_t temp_datasize;\n    temp_datasize = DLT_BETOH_16(msg->standardheader->len) - (int32_t) msg->headersize + (int32_t) sizeof(DltStorageHeader);\n\n    /* check data size */\n    if (temp_datasize < 0) {\n        dlt_vlog(LOG_WARNING,\n                 \"Plausibility check failed. Complete message size too short (%d)!\\n\",\n                 temp_datasize);\n        return DLT_MESSAGE_ERROR_CONTENT;\n    }\n    else {\n        msg->datasize = (uint32_t) temp_datasize;\n    }\n\n    /* check if verbose mode is on*/\n    if (verbose) {\n        dlt_vlog(LOG_DEBUG, \"BufferLength=%u, HeaderSize=%u, DataSize=%u\\n\",\n                 length, msg->headersize, msg->datasize);\n    }\n\n    /* load standard header extra parameters and Extended header if used */\n    if (extra_size > 0) {\n        if (length < (msg->headersize - sizeof(DltStorageHeader)))\n            return DLT_MESSAGE_ERROR_SIZE;\n\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n               buffer + sizeof(DltStandardHeader), (size_t)extra_size);\n\n        /* set extended header ptr and get standard header extra parameters */\n        if (DLT_IS_HTYP_UEH(msg->standardheader->htyp))\n            msg->extendedheader =\n                (DltExtendedHeader *)(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n                                      DLT_STANDARD_HEADER_EXTRA_SIZE(msg->standardheader->htyp));\n        else\n            msg->extendedheader = NULL;\n\n        dlt_message_get_extraparameters(msg, verbose);\n    }\n\n    /* check if payload fits length */\n    if (length < (msg->headersize - sizeof(DltStorageHeader) + msg->datasize))\n        /* dlt_log(LOG_ERR,\"length does not fit!\\n\"); */\n        return DLT_MESSAGE_ERROR_SIZE;\n\n    /* free last used memory for buffer */\n    if (msg->databuffer) {\n        if (msg->datasize > msg->databuffersize) {\n            free(msg->databuffer);\n            msg->databuffer = (uint8_t *)malloc(msg->datasize);\n            msg->databuffersize = msg->datasize;\n        }\n    }\n    else {\n        /* get new memory for buffer */\n        msg->databuffer = (uint8_t *)malloc(msg->datasize);\n        msg->databuffersize = msg->datasize;\n    }\n\n    if (msg->databuffer == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"Cannot allocate memory for payload buffer of size %u!\\n\",\n                 msg->datasize);\n        return DLT_MESSAGE_ERROR_UNKNOWN;\n    }\n\n    /* load payload data from buffer */\n    memcpy(msg->databuffer, buffer + (msg->headersize - sizeof(DltStorageHeader)), msg->datasize);\n\n    return DLT_MESSAGE_ERROR_OK;\n}\n\nDltReturnValue dlt_message_get_extraparameters(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (DLT_IS_HTYP_WEID(msg->standardheader->htyp))\n        memcpy(msg->headerextra.ecu,\n               msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n               DLT_ID_SIZE);\n\n    if (DLT_IS_HTYP_WSID(msg->standardheader->htyp)) {\n        memcpy(&(msg->headerextra.seid), msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0), DLT_SIZE_WSID);\n        msg->headerextra.seid = DLT_BETOH_32(msg->headerextra.seid);\n    }\n\n    if (DLT_IS_HTYP_WTMS(msg->standardheader->htyp)) {\n        memcpy(&(msg->headerextra.tmsp), msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0)\n               + (DLT_IS_HTYP_WSID(msg->standardheader->htyp) ? DLT_SIZE_WSID : 0), DLT_SIZE_WTMS);\n        msg->headerextra.tmsp = DLT_BETOH_32(msg->headerextra.tmsp);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_set_extraparameters(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (DLT_IS_HTYP_WEID(msg->standardheader->htyp))\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n               msg->headerextra.ecu,\n               DLT_ID_SIZE);\n\n    if (DLT_IS_HTYP_WSID(msg->standardheader->htyp)) {\n        msg->headerextra.seid = DLT_HTOBE_32(msg->headerextra.seid);\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0),\n               &(msg->headerextra.seid),\n               DLT_SIZE_WSID);\n    }\n\n    if (DLT_IS_HTYP_WTMS(msg->standardheader->htyp)) {\n        msg->headerextra.tmsp = DLT_HTOBE_32(msg->headerextra.tmsp);\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0)\n               + (DLT_IS_HTYP_WSID(msg->standardheader->htyp) ? DLT_SIZE_WSID : 0),\n               &(msg->headerextra.tmsp),\n               DLT_SIZE_WTMS);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_init(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* initalise structure parameters */\n    file->handle = NULL;\n    file->counter = 0;\n    file->counter_total = 0;\n    file->index = NULL;\n\n    file->filter = NULL;\n    file->filter_counter = 0;\n    file->file_position = 0;\n\n    file->position = 0;\n\n    file->error_messages = 0;\n\n    return dlt_message_init(&(file->msg), verbose);\n}\n\nDltReturnValue dlt_file_set_filter(DltFile *file, DltFilter *filter, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* set filter */\n    file->filter = filter;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_header(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Loop until storage header is found */\n    while (1) {\n        /* load header from file */\n        if (fread(file->msg.headerbuffer,\n                  sizeof(DltStorageHeader) + sizeof(DltStandardHeader), 1,\n                  file->handle) != 1) {\n            if (!feof(file->handle))\n                dlt_log(LOG_WARNING, \"Cannot read header from file!\\n\");\n            else\n                dlt_log(LOG_DEBUG, \"Reached end of file\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n\n        /* set ptrs to structures */\n        file->msg.storageheader = (DltStorageHeader *)file->msg.headerbuffer;\n        file->msg.standardheader = (DltStandardHeader *)(file->msg.headerbuffer +\n                                                         sizeof(DltStorageHeader));\n\n        /* check id of storage header */\n        if (dlt_check_storageheader(file->msg.storageheader) != DLT_RETURN_TRUE) {\n            /* Shift the position back to the place where it stared to read + 1 */\n            if (fseek(file->handle,\n                      (long) (1 - (sizeof(DltStorageHeader) + sizeof(DltStandardHeader))),\n                      SEEK_CUR) < 0) {\n                dlt_log(LOG_WARNING, \"DLT storage header pattern not found!\\n\");\n                return DLT_RETURN_ERROR;\n            }\n        }\n        else {\n            /* storage header is found */\n            break;\n        }\n    }\n\n    /* calculate complete size of headers */\n    file->msg.headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n        DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp) +\n        (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));\n\n    /* calculate complete size of payload */\n    int32_t temp_datasize;\n    temp_datasize = DLT_BETOH_16(file->msg.standardheader->len) + (int32_t) sizeof(DltStorageHeader) - (int32_t) file->msg.headersize;\n\n    /* check data size */\n    if (temp_datasize < 0) {\n        dlt_vlog(LOG_WARNING,\n                 \"Plausibility check failed. Complete message size too short! (%d)\\n\",\n                 temp_datasize);\n        return DLT_RETURN_ERROR;\n    } else {\n        file->msg.datasize = (uint32_t) temp_datasize;\n    }\n\n    /* check if verbose mode is on */\n    if (verbose) {\n        dlt_vlog(LOG_DEBUG, \"HeaderSize=%u, DataSize=%u\\n\",\n                 file->msg.headersize, file->msg.datasize);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_header_raw(DltFile *file, int resync, int verbose)\n{\n    char dltSerialHeaderBuffer[DLT_ID_SIZE];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if serial header exists, ignore if found */\n    if (fread(dltSerialHeaderBuffer, sizeof(dltSerialHeaderBuffer), 1, file->handle) != 1) {\n        /* cannot read serial header, not enough data available in file */\n        if (!feof(file->handle))\n            dlt_log(LOG_WARNING, \"Cannot read header from file!\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    if (memcmp(dltSerialHeaderBuffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {\n        /* serial header found */\n        /* nothing to do continue reading */\n\n    }\n    else {\n        /* serial header not found */\n        if (resync) {\n            /* increase error counter */\n            file->error_messages++;\n\n            /* resync to serial header */\n            do {\n                memmove(dltSerialHeaderBuffer, dltSerialHeaderBuffer + 1, sizeof(dltSerialHeader) - 1);\n\n                if (fread(dltSerialHeaderBuffer + 3, 1, 1, file->handle) != 1)\n                    /* cannot read any data, perhaps end of file reached */\n                    return DLT_RETURN_ERROR;\n\n                if (memcmp(dltSerialHeaderBuffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0)\n                    /* serial header synchronised */\n                    break;\n            } while (1);\n        }\n        else\n        /* go back to last file position */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n        {\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    /* load header from file */\n    if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader), sizeof(DltStandardHeader), 1, file->handle) != 1) {\n        if (!feof(file->handle))\n            dlt_log(LOG_WARNING, \"Cannot read header from file!\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    /* set ptrs to structures */\n    file->msg.storageheader = (DltStorageHeader *)file->msg.headerbuffer; /* this points now to a empty storage header (filled with '0') */\n    file->msg.standardheader = (DltStandardHeader *)(file->msg.headerbuffer + sizeof(DltStorageHeader));\n\n    /* Skip storage header field, fill this field with '0' */\n    memset(file->msg.storageheader, 0, sizeof(DltStorageHeader));\n\n    /* Set storage header */\n    dlt_set_storageheader(file->msg.storageheader, DLT_COMMON_DUMMY_ECUID);\n\n    /* no check for storage header id*/\n\n    /* calculate complete size of headers */\n    file->msg.headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n        DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp) +\n        (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));\n\n    /* calculate complete size of payload */\n    int32_t temp_datasize;\n    temp_datasize = DLT_BETOH_16(file->msg.standardheader->len) + (int32_t) sizeof(DltStorageHeader) - (int32_t) file->msg.headersize;\n\n    /* check data size */\n    if (temp_datasize < 0) {\n        dlt_vlog(LOG_WARNING,\n                 \"Plausibility check failed. Complete message size too short! (%d)\\n\",\n                 temp_datasize);\n        return DLT_RETURN_ERROR;\n    }\n    else {\n        file->msg.datasize = (uint32_t) temp_datasize;\n    }\n\n    /* check if verbose mode is on */\n    if (verbose) {\n        dlt_vlog(LOG_DEBUG, \"HeaderSize=%u, DataSize=%u\\n\",\n                 file->msg.headersize, file->msg.datasize);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_header_extended(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* load standard header extra parameters if used */\n    if (DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp)) {\n        if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n                  DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp),\n                  1, file->handle) != 1) {\n            dlt_log(LOG_WARNING, \"Cannot read standard header extra parameters from file!\\n\");\n            return DLT_RETURN_ERROR;\n        }\n\n        dlt_message_get_extraparameters(&(file->msg), verbose);\n    }\n\n    /* load Extended header if used */\n    if (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) == 0)\n        /* there is nothing to be loaded */\n        return DLT_RETURN_OK;\n\n    if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n              DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp),\n              (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0),\n              1, file->handle) != 1) {\n        dlt_log(LOG_WARNING, \"Cannot read extended header from file!\\n\");\n        return DLT_RETURN_ERROR;\n    }\n\n    /* set extended header ptr */\n    if (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp))\n        file->msg.extendedheader =\n            (DltExtendedHeader *)(file->msg.headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n                                  DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp));\n    else\n        file->msg.extendedheader = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_data(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* free last used memory for buffer */\n    if (file->msg.databuffer && (file->msg.databuffersize < file->msg.datasize)) {\n        free(file->msg.databuffer);\n        file->msg.databuffer = NULL;\n    }\n\n    if (file->msg.databuffer == NULL) {\n        /* get new memory for buffer */\n        file->msg.databuffer = (uint8_t *)malloc(file->msg.datasize);\n        file->msg.databuffersize = file->msg.datasize;\n    }\n\n    if (file->msg.databuffer == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"Cannot allocate memory for payload buffer of size %u!\\n\",\n                 file->msg.datasize);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* load payload data from file */\n    if (fread(file->msg.databuffer, file->msg.datasize, 1, file->handle) != 1) {\n        if (file->msg.datasize != 0) {\n            dlt_vlog(LOG_WARNING,\n                     \"Cannot read payload data from file of size %u!\\n\",\n                     file->msg.datasize);\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_open(DltFile *file, const char *filename, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((file == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* reset counters */\n    file->counter = 0;\n    file->counter_total = 0;\n    file->position = 0;\n    file->file_position = 0;\n    file->file_length = 0;\n    file->error_messages = 0;\n\n    if (file->handle)\n        fclose(file->handle);\n\n    /* open dlt file */\n    file->handle = fopen(filename, \"rb\");\n\n    if (file->handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"File %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    if (0 != fseek(file->handle, 0, SEEK_END)) {\n        dlt_vlog(LOG_WARNING, \"dlt_file_open: Seek failed to 0,SEEK_END\");\n        return DLT_RETURN_ERROR;\n    }\n\n    file->file_length = ftell(file->handle);\n\n    if (0 != fseek(file->handle, 0, SEEK_SET)) {\n        dlt_vlog(LOG_WARNING, \"dlt_file_open: Seek failed to 0,SEEK_SET\");\n        return DLT_RETURN_ERROR;\n    }\n\n    if (verbose)\n        /* print file length */\n        dlt_vlog(LOG_DEBUG, \"File is %\" PRIu64 \"bytes long\\n\", file->file_length);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read(DltFile *file, int verbose)\n{\n    long *ptr;\n    int found = DLT_RETURN_OK;\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (verbose)\n        dlt_vlog(LOG_DEBUG, \"%s: Message %d:\\n\", __func__, file->counter_total);\n\n    /* allocate new memory for index if number of messages exceeds a multiple of DLT_COMMON_INDEX_ALLOC (e.g.: 1000) */\n    if (file->counter % DLT_COMMON_INDEX_ALLOC == 0) {\n        ptr = (long *)malloc(((file->counter / DLT_COMMON_INDEX_ALLOC) + 1) * DLT_COMMON_INDEX_ALLOC * sizeof(long));\n\n        if (ptr == NULL)\n            return DLT_RETURN_ERROR;\n\n        if (file->index) {\n            memcpy(ptr, file->index, (size_t)(file->counter) * sizeof(long));\n            free(file->index);\n        }\n\n        file->index = ptr;\n    }\n\n    /* set to end of last succesful read message, because of conflicting calls to dlt_file_read and dlt_file_message */\n    if (0 != fseek(file->handle, file->file_position, SEEK_SET)) {\n        dlt_vlog(LOG_WARNING, \"Seek failed to file_position %\" PRIu64 \"\\n\",\n                 file->file_position);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* get file position at start of DLT message */\n    if (verbose)\n        dlt_vlog(LOG_INFO, \"Position in file: %\" PRIu64 \"\\n\", file->file_position);\n\n    /* read header */\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        fseek(file->handle, file->file_position, SEEK_SET);\n        return DLT_RETURN_ERROR;\n    }\n\n    if (file->filter) {\n        /* read the extended header if filter is enabled and extended header exists */\n        if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) {\n            /* go back to last position in file */\n            if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n                dlt_vlog(LOG_WARNING, \"Seek to last file pos failed!\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n\n        /* check the filters if message is used */\n        if (dlt_message_filter_check(&(file->msg), file->filter, verbose) == DLT_RETURN_TRUE) {\n            /* filter matched, consequently store current message */\n            /* store index pointer to message position in DLT file */\n            file->index[file->counter] = file->file_position;\n            file->counter++;\n            file->position = file->counter - 1;\n\n            found = DLT_RETURN_TRUE;\n        }\n\n        /* skip payload data */\n        if (fseek(file->handle, file->msg.datasize, SEEK_CUR) != 0) {\n            /* go back to last position in file */\n            dlt_vlog(LOG_WARNING,\n                     \"Seek failed to skip payload data of size %u!\\n\",\n                     file->msg.datasize);\n\n            if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n                dlt_log(LOG_WARNING, \"Seek back also failed!\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n    }\n    else {\n        /* filter is disabled */\n        /* skip additional header parameters and payload data */\n        if (fseek(file->handle,\n                  (long) (file->msg.headersize - sizeof(DltStorageHeader) - sizeof(DltStandardHeader) + file->msg.datasize),\n                  SEEK_CUR)) {\n\n            dlt_vlog(LOG_WARNING,\n                     \"Seek failed to skip extra header and payload data from file of size %u!\\n\",\n                     file->msg.headersize - (int32_t)sizeof(DltStorageHeader) -\n                     (int32_t)sizeof(DltStandardHeader) + file->msg.datasize);\n\n            /* go back to last position in file */\n            if (fseek(file->handle, file->file_position, SEEK_SET))\n                dlt_log(LOG_WARNING, \"Seek back also failed!\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n\n        /* store index pointer to message position in DLT file */\n        file->index[file->counter] = file->file_position;\n        file->counter++;\n        file->position = file->counter - 1;\n\n        found = DLT_RETURN_TRUE;\n    }\n\n    /* increase total message counter */\n    file->counter_total++;\n\n    /* store position to next message */\n    file->file_position = ftell(file->handle);\n\n    return found;\n}\n\nDltReturnValue dlt_file_read_raw(DltFile *file, int resync, int verbose)\n{\n    int found = DLT_RETURN_OK;\n    long *ptr;\n\n    if (verbose)\n        dlt_vlog(LOG_DEBUG, \"%s: Message %d:\\n\", __func__, file->counter_total);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* allocate new memory for index if number of messages exceeds a multiple of DLT_COMMON_INDEX_ALLOC (e.g.: 1000) */\n    if (file->counter % DLT_COMMON_INDEX_ALLOC == 0) {\n        ptr = (long *)malloc(((file->counter / DLT_COMMON_INDEX_ALLOC) + 1) * DLT_COMMON_INDEX_ALLOC * sizeof(long));\n\n        if (ptr == NULL)\n            return DLT_RETURN_ERROR;\n\n        if (file->index) {\n            memcpy(ptr, file->index, (size_t)(file->counter) * sizeof(long));\n            free(file->index);\n        }\n\n        file->index = ptr;\n    }\n\n    /* set to end of last successful read message, because of conflicting calls to dlt_file_read and dlt_file_message */\n    if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n        return DLT_RETURN_ERROR;\n\n    /* get file position at start of DLT message */\n    if (verbose)\n        dlt_vlog(LOG_DEBUG, \"Position in file: %\" PRIu64 \"\\n\", file->file_position);\n\n    /* read header */\n    if (dlt_file_read_header_raw(file, resync, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n            dlt_log(LOG_WARNING, \"dlt_file_read_raw, fseek failed 1\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    /* read the extended header if filter is enabled and extended header exists */\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n            dlt_log(LOG_WARNING, \"dlt_file_read_raw, fseek failed 2\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n            dlt_log(LOG_WARNING, \"dlt_file_read_raw, fseek failed 3\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    /* store index pointer to message position in DLT file */\n    file->index[file->counter] = file->file_position;\n    file->counter++;\n    file->position = file->counter - 1;\n\n    found = DLT_RETURN_TRUE;\n\n    /* increase total message counter */\n    file->counter_total++;\n\n    /* store position to next message */\n    file->file_position = ftell(file->handle);\n\n    return found;\n}\n\nDltReturnValue dlt_file_close(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (file->handle)\n        fclose(file->handle);\n\n    file->handle = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_message(DltFile *file, int index, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if message is in range */\n    if (index >= file->counter) {\n        dlt_vlog(LOG_WARNING, \"Message %d out of range!\\r\\n\", index);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    /* seek to position in file */\n    if (fseek(file->handle, file->index[index], SEEK_SET) != 0) {\n        dlt_vlog(LOG_WARNING, \"Seek to message %d to position %ld failed!\\r\\n\",\n                 index, file->index[index]);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* read all header and payload */\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    /* set current position in file */\n    file->position = index;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_free(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* delete index lost if exists */\n    if (file->index)\n        free(file->index);\n\n    file->index = NULL;\n\n    /* close file */\n    if (file->handle)\n        fclose(file->handle);\n\n    file->handle = NULL;\n\n    return dlt_message_free(&(file->msg), verbose);\n}\n\nvoid dlt_log_set_level(int level)\n{\n    if ((level < 0) || (level > LOG_DEBUG)) {\n        if (logging_level < LOG_WARNING)\n            logging_level = LOG_WARNING;\n\n        dlt_vlog(LOG_WARNING, \"Wrong parameter for level: %d\\n\", level);\n    }\n    else {\n        logging_level = level;\n    }\n}\n\nvoid dlt_log_set_filename(const char *filename)\n{\n    /* check nullpointer */\n    if (filename == NULL) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: filename is NULL\\n\");\n        return;\n    }\n\n    strncpy(logging_filename, filename, NAME_MAX);\n    logging_filename[NAME_MAX] = 0;\n}\n\n#if defined DLT_DAEMON_USE_FIFO_IPC || defined DLT_LIB_USE_FIFO_IPC\nvoid dlt_log_set_fifo_basedir(const char *pipe_dir)\n{\n    strncpy(dltFifoBaseDir, pipe_dir, DLT_PATH_MAX);\n    dltFifoBaseDir[DLT_PATH_MAX - 1] = 0;\n}\n#endif\n\n#ifdef DLT_SHM_ENABLE\nvoid dlt_log_set_shm_name(const char *env_shm_name)\n{\n    strncpy(dltShmName, env_shm_name, NAME_MAX);\n    dltShmName[NAME_MAX] = 0;\n}\n#endif\n\nvoid dlt_print_with_attributes(bool state)\n{\n    print_with_attributes = state;\n}\n\nDltReturnValue dlt_log_init(int mode)\n{\n    if ((mode < DLT_LOG_TO_CONSOLE) || (mode > DLT_LOG_DROPPED)) {\n        dlt_user_printf(\"Wrong parameter for mode: %d\\n\", mode);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    logging_mode = mode;\n\n    if (logging_mode == DLT_LOG_TO_FILE) {\n        /* internal logging to file */\n        logging_handle = fopen(logging_filename, \"a\");\n\n        if (logging_handle == NULL) {\n            dlt_user_printf(\"Internal log file %s cannot be opened!\\n\", logging_filename);\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    return DLT_RETURN_OK;\n}\n\nvoid dlt_log_free(void)\n{\n    if (logging_mode == DLT_LOG_TO_FILE && logging_handle)\n        fclose(logging_handle);\n}\n\nint dlt_user_printf(const char *format, ...)\n{\n    va_list args;\n    va_start(args, format);\n\n    int ret = 0;\n\n    switch (logging_mode) {\n    case DLT_LOG_TO_CONSOLE:\n    case DLT_LOG_TO_SYSLOG:\n    case DLT_LOG_TO_FILE:\n    case DLT_LOG_DROPPED:\n    default:\n        ret = vfprintf(stdout, format, args);\n        break;\n    case DLT_LOG_TO_STDERR:\n        ret = vfprintf(stderr, format, args);\n        break;\n    }\n\n    va_end(args);\n\n    return ret;\n}\n\nDltReturnValue dlt_log(int prio, char *s)\n{\n    static const char asSeverity[LOG_DEBUG +\n                                 2][11] =\n    { \"EMERGENCY\", \"ALERT    \", \"CRITICAL \", \"ERROR    \", \"WARNING  \", \"NOTICE   \", \"INFO     \", \"DEBUG    \",\n      \"         \" };\n    static const char sFormatString[] = \"[%5u.%06u]~DLT~%5d~%s~%s\";\n    struct timespec sTimeSpec;\n\n    if (s == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (logging_level < prio)\n        return DLT_RETURN_OK;\n\n    if ((prio < 0) || (prio > LOG_DEBUG))\n        prio = LOG_DEBUG + 1;\n\n    clock_gettime(CLOCK_MONOTONIC, &sTimeSpec);\n\n    switch (logging_mode) {\n    case DLT_LOG_TO_CONSOLE:\n        /* log to stdout */\n        fprintf(stdout, sFormatString,\n                (unsigned int)sTimeSpec.tv_sec,\n                (unsigned int)(sTimeSpec.tv_nsec / 1000),\n                getpid(),\n                asSeverity[prio],\n                s);\n        fflush(stdout);\n        break;\n    case DLT_LOG_TO_STDERR:\n        /* log to stderr */\n        fprintf(stderr, sFormatString,\n                (unsigned int)sTimeSpec.tv_sec,\n                (unsigned int)(sTimeSpec.tv_nsec / 1000),\n                getpid(),\n                asSeverity[prio],\n                s);\n        break;\n    case DLT_LOG_TO_SYSLOG:\n        /* log to syslog */\n#if !defined (__WIN32__) && !defined(_MSC_VER)\n        openlog(\"DLT\", LOG_PID, LOG_DAEMON);\n        syslog(prio,\n               sFormatString,\n               (unsigned int)sTimeSpec.tv_sec,\n               (unsigned int)(sTimeSpec.tv_nsec / 1000),\n               getpid(),\n               asSeverity[prio],\n               s);\n        closelog();\n#endif\n        break;\n    case DLT_LOG_TO_FILE:\n\n        /* log to file */\n        if (logging_handle) {\n            fprintf(logging_handle, sFormatString, (unsigned int)sTimeSpec.tv_sec,\n                    (unsigned int)(sTimeSpec.tv_nsec / 1000), getpid(), asSeverity[prio], s);\n            fflush(logging_handle);\n        }\n\n        break;\n    case DLT_LOG_DROPPED:\n    default:\n        break;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_vlog(int prio, const char *format, ...)\n{\n    char outputString[2048] = { 0 }; /* TODO: what is a reasonable string length here? */\n\n    va_list args;\n\n    if (format == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (logging_level < prio)\n        return DLT_RETURN_OK;\n\n    va_start(args, format);\n    vsnprintf(outputString, 2047, format, args);\n    va_end(args);\n\n    dlt_log(prio, outputString);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_vnlog(int prio, size_t size, const char *format, ...)\n{\n    char *outputString = NULL;\n\n    va_list args;\n\n    if (format == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((logging_level < prio) || (size == 0))\n        return DLT_RETURN_OK;\n\n    if ((outputString = (char *)calloc(size + 1, sizeof(char))) == NULL)\n        return DLT_RETURN_ERROR;\n\n    va_start(args, format);\n    vsnprintf(outputString, size, format, args);\n    va_end(args);\n\n    dlt_log(prio, outputString);\n\n    free(outputString);\n    outputString = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_init(DltReceiver *receiver, int fd, DltReceiverType type, int buffersize)\n{\n    if (NULL == receiver)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    receiver->fd = fd;\n    receiver->type = type;\n\n    /** Reuse the receiver buffer if it exists and the buffer size\n      * is not changed. If not, free the old one and allocate a new buffer.\n      */\n    if ((NULL != receiver->buffer) && ( buffersize != receiver->buffersize)) {\n       free(receiver->buffer);\n       receiver->buffer = NULL;\n    }\n\n    if (NULL == receiver->buffer) {\n        receiver->lastBytesRcvd = 0;\n        receiver->bytesRcvd = 0;\n        receiver->totalBytesRcvd = 0;\n        receiver->buf = NULL;\n        receiver->backup_buf = NULL;\n        receiver->buffer = (char *)calloc(1, (size_t)buffersize);\n        receiver->buffersize = (uint32_t)buffersize;\n    }\n\n    if (NULL == receiver->buffer) {\n        dlt_log(LOG_ERR, \"allocate memory for receiver buffer failed.\\n\");\n        return DLT_RETURN_ERROR;\n    }\n    else {\n        receiver->buf = receiver->buffer;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_init_global_buffer(DltReceiver *receiver, int fd, DltReceiverType type, char **buffer)\n{\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (*buffer == NULL) {\n        /* allocating the buffer once and using it for all application receivers\n         * by keeping allocated buffer in app_recv_buffer global handle\n         */\n        *buffer = (char *)malloc(DLT_RECEIVE_BUFSIZE);\n\n        if (*buffer == NULL)\n            return DLT_RETURN_ERROR;\n    }\n\n    receiver->lastBytesRcvd = 0;\n    receiver->bytesRcvd = 0;\n    receiver->totalBytesRcvd = 0;\n    receiver->buffersize = DLT_RECEIVE_BUFSIZE;\n    receiver->fd = fd;\n    receiver->type = type;\n    receiver->buffer = *buffer;\n    receiver->backup_buf = NULL;\n    receiver->buf = receiver->buffer;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_free(DltReceiver *receiver)\n{\n\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (receiver->buffer)\n        free(receiver->buffer);\n\n    if (receiver->backup_buf)\n        free(receiver->backup_buf);\n\n    receiver->buffer = NULL;\n    receiver->buf = NULL;\n    receiver->backup_buf = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_free_global_buffer(DltReceiver *receiver)\n{\n\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (receiver->backup_buf)\n        free(receiver->backup_buf);\n\n    receiver->buffer = NULL;\n    receiver->buf = NULL;\n    receiver->backup_buf = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_receiver_receive(DltReceiver *receiver)\n{\n    socklen_t addrlen;\n\n    if (receiver == NULL)\n        return -1;\n\n    if (receiver->buffer == NULL)\n        return -1;\n\n    receiver->buf = (char *)receiver->buffer;\n    receiver->lastBytesRcvd = receiver->bytesRcvd;\n\n    if ((receiver->lastBytesRcvd) && (receiver->backup_buf != NULL)) {\n        memcpy(receiver->buf, receiver->backup_buf, (size_t)receiver->lastBytesRcvd);\n        free(receiver->backup_buf);\n        receiver->backup_buf = NULL;\n    }\n\n    if (receiver->type == DLT_RECEIVE_SOCKET)\n        /* wait for data from socket */\n        receiver->bytesRcvd = recv(receiver->fd,\n                                   receiver->buf + receiver->lastBytesRcvd,\n                                   receiver->buffersize - (uint32_t) receiver->lastBytesRcvd,\n                                   0);\n    else if (receiver->type == DLT_RECEIVE_FD)\n        /* wait for data from fd */\n        receiver->bytesRcvd = read(receiver->fd,\n                                   receiver->buf + receiver->lastBytesRcvd,\n                                   receiver->buffersize - (uint32_t) receiver->lastBytesRcvd);\n\n    else { /* receiver->type == DLT_RECEIVE_UDP_SOCKET */\n        /* wait for data from UDP socket */\n        addrlen = sizeof(receiver->addr);\n        receiver->bytesRcvd = recvfrom(receiver->fd,\n                                       receiver->buf + receiver->lastBytesRcvd,\n                                       receiver->buffersize - receiver->lastBytesRcvd,\n                                       0,\n                                       (struct sockaddr *)&(receiver->addr),\n                                       &addrlen);\n    }\n\n    if (receiver->bytesRcvd <= 0) {\n        receiver->bytesRcvd = 0;\n        return receiver->bytesRcvd;\n    } /* if */\n\n    receiver->totalBytesRcvd += receiver->bytesRcvd;\n    receiver->bytesRcvd += receiver->lastBytesRcvd;\n\n    return receiver->bytesRcvd;\n}\n\nDltReturnValue dlt_receiver_remove(DltReceiver *receiver, int size)\n{\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (receiver->buf == NULL)\n        return DLT_RETURN_ERROR;\n\n    if ((size > receiver->bytesRcvd) || (size <= 0)) {\n        receiver->buf = receiver->buf + receiver->bytesRcvd;\n        receiver->bytesRcvd = 0;\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    receiver->bytesRcvd = receiver->bytesRcvd - size;\n    receiver->buf = receiver->buf + size;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_move_to_begin(DltReceiver *receiver)\n{\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((receiver->buffer == NULL) || (receiver->buf == NULL))\n        return DLT_RETURN_ERROR;\n\n    if ((receiver->buffer != receiver->buf) && (receiver->bytesRcvd != 0)) {\n        receiver->backup_buf = calloc((size_t)(receiver->bytesRcvd + 1), sizeof(char));\n\n        if (receiver->backup_buf == NULL)\n            dlt_vlog(LOG_WARNING,\n                     \"Can't allocate memory for backup buf, there will be atleast\"\n                     \"one corrupted message for fd[%d] \\n\", receiver->fd);\n        else\n            memcpy(receiver->backup_buf, receiver->buf, (size_t)receiver->bytesRcvd);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_receiver_check_and_get(DltReceiver *receiver,\n                               void *dest,\n                               unsigned int to_get,\n                               unsigned int flags)\n{\n    size_t min_size = (size_t)to_get;\n    uint8_t *src = NULL;\n\n    if (flags & DLT_RCV_SKIP_HEADER)\n        min_size += sizeof(DltUserHeader);\n\n    if (!receiver ||\n        (receiver->bytesRcvd < (int32_t) min_size) ||\n        !receiver->buf ||\n        !dest)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    src = (uint8_t *)receiver->buf;\n\n    if (flags & DLT_RCV_SKIP_HEADER)\n        src += sizeof(DltUserHeader);\n\n    memcpy(dest, src, to_get);\n\n    if (flags & DLT_RCV_REMOVE) {\n        if (dlt_receiver_remove(receiver, (int)min_size) != DLT_RETURN_OK) {\n            dlt_log(LOG_WARNING, \"Can't remove bytes from receiver\\n\");\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    return to_get;\n}\n\nDltReturnValue dlt_set_storageheader(DltStorageHeader *storageheader, const char *ecu)\n{\n\n#if !defined(_MSC_VER)\n    struct timeval tv;\n#endif\n\n    if ((storageheader == NULL) || (ecu == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* get time of day */\n#if defined(_MSC_VER)\n    time(&(storageheader->seconds));\n#else\n    gettimeofday(&tv, NULL);\n#endif\n\n    /* prepare storage header */\n    storageheader->pattern[0] = 'D';\n    storageheader->pattern[1] = 'L';\n    storageheader->pattern[2] = 'T';\n    storageheader->pattern[3] = 0x01;\n\n    dlt_set_id(storageheader->ecu, ecu);\n\n    /* Set current time */\n#if defined(_MSC_VER)\n    storageheader->microseconds = 0;\n#else\n    storageheader->seconds = (uint32_t) tv.tv_sec; /* value is long */\n    storageheader->microseconds = (int32_t) tv.tv_usec; /* value is long */\n#endif\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_check_rcv_data_size(int received, int required)\n{\n    int _ret = DLT_RETURN_OK;\n    if (received < required) {\n        dlt_vlog(LOG_WARNING, \"%s: Received data not complete\\n\", __func__);\n        _ret = DLT_RETURN_ERROR;\n    }\n\n    return _ret;\n}\n\nDltReturnValue dlt_check_storageheader(DltStorageHeader *storageheader)\n{\n    if (storageheader == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    return ((storageheader->pattern[0] == 'D') &&\n            (storageheader->pattern[1] == 'L') &&\n            (storageheader->pattern[2] == 'T') &&\n            (storageheader->pattern[3] == 1))\n           ? DLT_RETURN_TRUE : DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_buffer_init_static_server(DltBuffer *buf, const unsigned char *ptr, uint32_t size)\n{\n    if ((buf == NULL) || (ptr == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    DltBufferHead *head;\n\n    /* Init parameters */\n    buf->shm = (unsigned char *)ptr;\n    buf->min_size = size;\n    buf->max_size = size;\n    buf->step_size = 0;\n\n    /* Init pointers */\n    head = (DltBufferHead *)buf->shm;\n    head->read = 0;\n    head->write = 0;\n    head->count = 0;\n    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));\n    buf->size = (unsigned int) buf->min_size - (unsigned int) sizeof(DltBufferHead);\n\n    /* clear memory */\n    memset(buf->mem, 0, buf->size);\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size %u, Start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_init_static_client(DltBuffer *buf, const unsigned char *ptr, uint32_t size)\n{\n    if ((buf == NULL) || (ptr == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Init parameters */\n    buf->shm = (unsigned char *)ptr;\n    buf->min_size = size;\n    buf->max_size = size;\n    buf->step_size = 0;\n\n    /* Init pointers */\n    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));\n    buf->size = (uint32_t)(buf->min_size - sizeof(DltBufferHead));\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size %u, Start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_init_dynamic(DltBuffer *buf, uint32_t min_size, uint32_t max_size, uint32_t step_size)\n{\n    /*Do not DLT_SEM_LOCK inside here! */\n    DltBufferHead *head;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* catch 0 logical errors */\n    if ((min_size == 0) || (max_size == 0) || (step_size == 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (min_size > max_size)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (step_size > max_size)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Init parameters */\n    buf->min_size = min_size;\n    buf->max_size = max_size;\n    buf->step_size = step_size;\n\n    /* allocat memory */\n    buf->shm = malloc(buf->min_size);\n\n    if (buf->shm == NULL) {\n        dlt_vlog(LOG_EMERG,\n                 \"%s: Buffer: Cannot allocate %u bytes\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* Init pointers */\n    head = (DltBufferHead *)buf->shm;\n    head->read = 0;\n    head->write = 0;\n    head->count = 0;\n    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));\n\n    if (buf->min_size < (uint32_t)sizeof(DltBufferHead)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: min_size is too small [%u]\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    buf->size = (uint32_t) (buf->min_size - sizeof(DltBufferHead));\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size %u, Start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    /* clear memory */\n    memset(buf->mem, 0, (size_t)buf->size);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_free_static(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->mem == NULL) {\n        /* buffer not initialized */\n        dlt_vlog(LOG_WARNING, \"%s: Buffer: Buffer not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_buffer_free_dynamic(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->shm == NULL) {\n        /* buffer not initialized */\n        dlt_vlog(LOG_WARNING, \"%s: Buffer: Buffer not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    free(buf->shm);\n    buf->shm = NULL;\n    buf->mem = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nvoid dlt_buffer_write_block(DltBuffer *buf, int *write, const unsigned char *data, unsigned int size)\n{\n    /* catch null pointer */\n    if ((buf != NULL) && (write != NULL) && (data != NULL)) {\n\tif (size <= buf->size){\n            if (( (unsigned int) (*write ) + size) <= buf->size) {\n                /* write one block */\n                memcpy(buf->mem + *write, data, size);\n                *write += (int) size;\n            }\n            else {\n                /* when (*write) = buf->size, write only the second block\n                * and update write position correspondingly.\n                */\n                if((unsigned int) (*write) <= buf->size) {\n                    /* write two blocks */\n                    memcpy(buf->mem + *write, data, buf->size - (unsigned int) (*write));\n                    memcpy(buf->mem, data + buf->size - *write, size - buf->size + (unsigned int) (*write));\n                    *write += (int) (size - buf->size);\n                }\n            }\n\t}\n\telse {\n\t    dlt_vlog(LOG_WARNING, \"%s: Write error: ring buffer to small\\n\", __func__);\n\t}\n    }\n    else {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n    }\n}\n\nvoid dlt_buffer_read_block(DltBuffer *buf, int *read, unsigned char *data, unsigned int size)\n{\n    /* catch nullpointer */\n    if ((buf != NULL) && (read != NULL) && (data != NULL)) {\n        if (((unsigned int)(*read) + size) <= buf->size) {\n            /* read one block */\n            memcpy(data, buf->mem + *read, size);\n            *read += (int)size;\n        }\n        else {\n            /* when (*read) = buf->size, read only the second block\n            * and update read position correspondingly.\n            */\n            if ((unsigned int)(*read) <= buf->size) {\n                /* read two blocks */\n                memcpy(data, buf->mem + *read, buf->size - (unsigned int)(*read));\n                memcpy(data + buf->size - *read, buf->mem, size - buf->size + (unsigned int)(*read));\n                *read += (int) (size - buf->size);\n            }\n        }\n    }\n    else {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n    }\n}\n\nint dlt_buffer_check_size(DltBuffer *buf, int needed)\n{\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((buf->size + sizeof(DltBufferHead) + (size_t) needed) > buf->max_size)\n        return DLT_RETURN_ERROR;\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_buffer_increase_size(DltBuffer *buf)\n{\n    DltBufferHead *head, *new_head;\n    unsigned char *new_ptr;\n\n    /* catch null pointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    /* check size */\n    if (buf->step_size == 0)\n        /* cannot increase size */\n        return DLT_RETURN_ERROR;\n\n    /* check size */\n    if ((buf->size + sizeof(DltBufferHead) + buf->step_size) > buf->max_size)\n        /* max size reached, do not increase */\n        return DLT_RETURN_ERROR;\n\n    /* allocate new buffer */\n    new_ptr = malloc(buf->size + sizeof(DltBufferHead) + buf->step_size);\n\n    if (new_ptr == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"%s: Buffer: Cannot increase size because allocate %u bytes failed\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* copy data */\n    head = (DltBufferHead *)buf->shm;\n    new_head = (DltBufferHead *)new_ptr;\n\n    if (head->read < head->write) {\n        memcpy(new_ptr + sizeof(DltBufferHead), buf->mem + head->read, (size_t)(head->write - head->read));\n        new_head->read = 0;\n        new_head->write = head->write - head->read;\n        new_head->count = head->count;\n    }\n    else {\n        memcpy(new_ptr + sizeof(DltBufferHead), buf->mem + head->read, buf->size - (uint32_t)(head->read));\n        memcpy(new_ptr + sizeof(DltBufferHead) + buf->size - head->read, buf->mem, (size_t)head->write);\n        new_head->read = 0;\n        new_head->write = (int)(buf->size) + head->write - head->read;\n        new_head->count = head->count;\n    }\n\n    /* free old data */\n    free(buf->shm);\n\n    /* update data */\n    buf->shm = new_ptr;\n    buf->mem = new_ptr + sizeof(DltBufferHead);\n    buf->size += buf->step_size;\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size increased to %u bytes with start address %lX\\n\",\n             __func__,\n             buf->size + (int32_t)sizeof(DltBufferHead),\n             (unsigned long)buf->mem);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nint dlt_buffer_minimize_size(DltBuffer *buf)\n{\n    unsigned char *new_ptr;\n\n    /* catch null pointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    if ((buf->size + sizeof(DltBufferHead)) == buf->min_size)\n        /* already minimized */\n        return DLT_RETURN_OK;\n\n    /* allocate new buffer */\n    new_ptr = malloc(buf->min_size);\n\n    if (new_ptr == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"%s: Buffer: Cannot set to min size of %u bytes\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* free old data */\n    free(buf->shm);\n\n    /* update data */\n    buf->shm = new_ptr;\n    buf->mem = new_ptr + sizeof(DltBufferHead);\n    buf->size = (uint32_t)(buf->min_size - sizeof(DltBufferHead));\n\n    /* reset pointers and counters */\n    ((int *)(buf->shm))[0] = 0;  /* pointer to write memory */\n    ((int *)(buf->shm))[1] = 0;  /* pointer to read memory */\n    ((int *)(buf->shm))[2] = 0;  /* number of packets */\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Buffer minimized to Size %u bytes with start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    /* clear memory */\n    memset(buf->mem, 0, buf->size);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nint dlt_buffer_reset(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    dlt_vlog(LOG_WARNING,\n             \"%s: Buffer: Buffer reset triggered. Size: %u, Start address: %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    /* reset pointers and counters */\n    ((int *)(buf->shm))[0] = 0;  /* pointer to write memory */\n    ((int *)(buf->shm))[1] = 0;  /* pointer to read memory */\n    ((int *)(buf->shm))[2] = 0;  /* number of packets */\n\n    /* clear memory */\n    memset(buf->mem, 0, buf->size);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_push(DltBuffer *buf, const unsigned char *data, unsigned int size)\n{\n    return dlt_buffer_push3(buf, data, size, 0, 0, 0, 0);\n}\n\nint dlt_buffer_push3(DltBuffer *buf,\n                     const unsigned char *data1,\n                     unsigned int size1,\n                     const unsigned char *data2,\n                     unsigned int size2,\n                     const unsigned char *data3,\n                     unsigned int size3)\n{\n    int free_size;\n    int write, read, count;\n    DltBufferBlockHead head;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->shm == NULL) {\n        /* buffer not initialised */\n        dlt_vlog(LOG_ERR, \"%s: Buffer: Buffer not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* get current write pointer */\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    /* check pointers */\n    if (((unsigned int)read > buf->size) || ((unsigned int)write > buf->size)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Pointer out of range. Read: %d, Write: %d, Size: %u\\n\",\n                 __func__, read, write, buf->size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* calculate free size */\n    if (read > write)\n        free_size = read - write;\n    else if (count && (write == read))\n        free_size = 0;\n    else\n        free_size = (int)buf->size - write + read;\n\n    /* check size */\n    while (free_size < (int) (sizeof(DltBufferBlockHead) + size1 + size2 + size3)) {\n        /* try to increase size if possible */\n        if (dlt_buffer_increase_size(buf))\n            /* increase size is not possible */\n            /*dlt_log(LOG_ERR, \"Buffer: Buffer is full\\n\"); */\n            return DLT_RETURN_ERROR; /* ERROR */\n\n        /* update pointers */\n        write = ((int *)(buf->shm))[0];\n        read = ((int *)(buf->shm))[1];\n\n\t    /* update free size */\n        if (read > write)\n            free_size = read - write;\n        else if (count && (write == read))\n            free_size = 0;\n        else\n            free_size = buf->size - write + read;\n    }\n\n    /* set header */\n    strncpy(head.head, DLT_BUFFER_HEAD, 4);\n    head.head[3] = 0;\n    head.status = 2;\n    head.size = (int)(size1 + size2 + size3);\n\n    /* write data */\n    dlt_buffer_write_block(buf, &write, (unsigned char *)&head, sizeof(DltBufferBlockHead));\n\n    if (size1)\n        dlt_buffer_write_block(buf, &write, data1, size1);\n\n    if (size2)\n        dlt_buffer_write_block(buf, &write, data2, size2);\n\n    if (size3)\n        dlt_buffer_write_block(buf, &write, data3, size3);\n\n    /* update global shm pointers */\n    ((int *)(buf->shm))[0] = write; /* set new write pointer */\n    ((int *)(buf->shm))[2] += 1; /* increase counter */\n\n    return DLT_RETURN_OK; /* OK */\n\n}\n\nint dlt_buffer_get(DltBuffer *buf, unsigned char *data, int max_size, int delete)\n{\n    int used_size;\n    int write, read, count;\n    char head_compare[] = DLT_BUFFER_HEAD;\n    DltBufferBlockHead head;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->shm == NULL) {\n        /* shm not initialised */\n        dlt_vlog(LOG_ERR, \"%s: Buffer: SHM not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* get current write pointer */\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    /* check pointers */\n    if (((unsigned int)read > buf->size) || ((unsigned int)write > buf->size) || (count < 0)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Pointer out of range. Read: %d, Write: %d, Count: %d, Size: %u\\n\",\n                 __func__, read, write, count, buf->size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* check if data is in there */\n    if (count == 0) {\n        if (write != read) {\n            dlt_vlog(LOG_ERR,\n                     \"%s: Buffer: SHM should be empty, but is not. Read: %d, Write: %d\\n\",\n                     __func__, read, write);\n            dlt_buffer_reset(buf);\n        }\n\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* calculate used size */\n    if (write > read)\n        used_size = write - read;\n    else\n        used_size = (int)buf->size - read + write;\n\n    /* first check size */\n    if (used_size < (int)(sizeof(DltBufferBlockHead))) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Used size is smaller than buffer block header size. Used size: %d\\n\",\n                 __func__, used_size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* read header */\n    dlt_buffer_read_block(buf, &read, (unsigned char *)&head, sizeof(DltBufferBlockHead));\n\n    /* check header */\n    if (memcmp((unsigned char *)(head.head), head_compare, sizeof(head_compare)) != 0) {\n        dlt_vlog(LOG_ERR, \"%s: Buffer: Header head check failed\\n\", __func__);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    if (head.status != 2) {\n        dlt_vlog(LOG_ERR, \"%s: Buffer: Header status check failed\\n\", __func__);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* second check size */\n    if (used_size < ((int)sizeof(DltBufferBlockHead) + head.size)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Used size is smaller than buffer block header size And read header size. Used size: %d\\n\",\n                 __func__, used_size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* third check size */\n    if (max_size && (head.size > max_size))\n        dlt_vlog(LOG_WARNING,\n                 \"%s: Buffer: Max size is smaller than read header size. Max size: %d\\n\",\n                 __func__, max_size);\n\n    /* nothing to do but data does not fit provided buffer */\n\n    if ((data != NULL) && max_size) {\n        /* read data */\n        dlt_buffer_read_block(buf, &read, data, (unsigned int)head.size);\n\n        if (delete)\n            /* update buffer pointers */\n            ((int *)(buf->shm))[1] = read; /* set new read pointer */\n\n    }\n    else if (delete)\n    {\n        if ((unsigned int)(read + head.size) <= buf->size)\n            ((int *)(buf->shm))[1] = read + head.size;  /* set new read pointer */\n        else\n            ((int *)(buf->shm))[1] = read + head.size - (int)buf->size;  /* set new read pointer */\n\n    }\n\n    if (delete) {\n        ((int *)(buf->shm))[2] -= 1; /* decrease counter */\n\n        if (((int *)(buf->shm))[2] == 0)\n            /* try to minimize size */\n            dlt_buffer_minimize_size(buf);\n    }\n\n    return head.size; /* OK */\n}\n\nint dlt_buffer_pull(DltBuffer *buf, unsigned char *data, int max_size)\n{\n    return dlt_buffer_get(buf, data, max_size, 1);\n}\n\nint dlt_buffer_copy(DltBuffer *buf, unsigned char *data, int max_size)\n{\n    return dlt_buffer_get(buf, data, max_size, 0);\n}\n\nint dlt_buffer_remove(DltBuffer *buf)\n{\n    return dlt_buffer_get(buf, 0, 0, 1);\n}\n\nvoid dlt_buffer_info(DltBuffer *buf)\n{\n    /* check nullpointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return;\n    }\n\n    dlt_vlog(LOG_DEBUG,\n             \"Buffer: Available size: %u, Buffer: Buffer full start address: %lX, Buffer: Buffer start address: %lX\\n\",\n             buf->size, (unsigned long)buf->shm, (unsigned long)buf->mem);\n}\n\nvoid dlt_buffer_status(DltBuffer *buf)\n{\n    int write, read, count;\n\n    /* check nullpointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return;\n    }\n\n    /* check if buffer available */\n    if (buf->shm == NULL)\n        return;\n\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    dlt_vlog(LOG_DEBUG,\n             \"Buffer: Write: %d, Read: %d, Count: %d\\n\",\n             write, read, count);\n}\n\nuint32_t dlt_buffer_get_total_size(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    return buf->max_size;\n}\n\nint dlt_buffer_get_used_size(DltBuffer *buf)\n{\n    int write, read, count;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if buffer available */\n    if (buf->shm == NULL)\n        return DLT_RETURN_OK;\n\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    if (count == 0)\n        return DLT_RETURN_OK;\n\n    if (write > read)\n        return write - read;\n\n    return (int)buf->size - read + write;\n}\n\nint dlt_buffer_get_message_count(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if buffer available */\n    if (buf->shm == NULL)\n        return DLT_RETURN_OK;\n\n    return ((int *)(buf->shm))[2];\n}\n\n#if !defined (__WIN32__)\n\nDltReturnValue dlt_setup_serial(int fd, speed_t speed)\n{\n#   if !defined (__WIN32__) && !defined(_MSC_VER)\n    struct termios config;\n\n    if (isatty(fd) == 0)\n        return DLT_RETURN_ERROR;\n\n    if (tcgetattr(fd, &config) < 0)\n        return DLT_RETURN_ERROR;\n\n    /* Input flags - Turn off input processing\n     * convert break to null byte, no CR to NL translation,\n     * no NL to CR translation, don't mark parity errors or breaks\n     * no input parity check, don't strip high bit off,\n     * no XON/XOFF software flow control\n     */\n    config.c_iflag &= ~(IGNBRK | BRKINT | ICRNL |\n                        INLCR | PARMRK | INPCK | ISTRIP | IXON);\n\n    /* Output flags - Turn off output processing\n     * no CR to NL translation, no NL to CR-NL translation,\n     * no NL to CR translation, no column 0 CR suppression,\n     * no Ctrl-D suppression, no fill characters, no case mapping,\n     * no local output processing\n     *\n     * config.c_oflag &= ~(OCRNL | ONLCR | ONLRET |\n     *                     ONOCR | ONOEOT| OFILL | OLCUC | OPOST);\n     */\n    config.c_oflag = 0;\n\n    /* No line processing:\n     * echo off, echo newline off, canonical mode off,\n     * extended input processing off, signal chars off\n     */\n    config.c_lflag &= ~(ECHO | ECHONL | ICANON | IEXTEN | ISIG);\n\n    /* Turn off character processing\n     * clear current char size mask, no parity checking,\n     * no output processing, force 8 bit input\n     */\n    config.c_cflag &= ~(CSIZE | PARENB);\n    config.c_cflag |= CS8;\n\n    /* One input byte is enough to return from read()\n     * Inter-character timer off\n     */\n    config.c_cc[VMIN] = 1;\n    config.c_cc[VTIME] = 0;\n\n    /* Communication speed (simple version, using the predefined\n     * constants)\n     */\n    if ((cfsetispeed(&config, speed) < 0) || (cfsetospeed(&config, speed) < 0))\n        return DLT_RETURN_ERROR;\n\n    /* Finally, apply the configuration\n     */\n    if (tcsetattr(fd, TCSAFLUSH, &config) < 0)\n        return DLT_RETURN_ERROR;\n\n    return DLT_RETURN_OK;\n#   else\n    return DLT_RETURN_ERROR;\n#   endif\n}\n\nspeed_t dlt_convert_serial_speed(int baudrate)\n{\n#   if !defined (__WIN32__) && !defined(_MSC_VER) && !defined(__CYGWIN__)\n    speed_t ret;\n\n    switch (baudrate) {\n    case  50:\n    {\n        ret = B50;\n        break;\n    }\n    case  75:\n    {\n        ret = B75;\n        break;\n    }\n    case  110:\n    {\n        ret = B110;\n        break;\n    }\n    case  134:\n    {\n        ret = B134;\n        break;\n    }\n    case  150:\n    {\n        ret = B150;\n        break;\n    }\n    case  200:\n    {\n        ret = B200;\n        break;\n    }\n    case  300:\n    {\n        ret = B300;\n        break;\n    }\n    case  600:\n    {\n        ret = B600;\n        break;\n    }\n    case  1200:\n    {\n        ret = B1200;\n        break;\n    }\n    case  1800:\n    {\n        ret = B1800;\n        break;\n    }\n    case  2400:\n    {\n        ret = B2400;\n        break;\n    }\n    case  4800:\n    {\n        ret = B4800;\n        break;\n    }\n    case  9600:\n    {\n        ret = B9600;\n        break;\n    }\n    case  19200:\n    {\n        ret = B19200;\n        break;\n    }\n    case  38400:\n    {\n        ret = B38400;\n        break;\n    }\n    case  57600:\n    {\n        ret = B57600;\n        break;\n    }\n    case  115200:\n    {\n        ret = B115200;\n        break;\n    }\n#      ifdef __linux__\n    case 230400:\n    {\n        ret = B230400;\n        break;\n    }\n    case 460800:\n    {\n        ret = B460800;\n        break;\n    }\n    case  500000:\n    {\n        ret = B500000;\n        break;\n    }\n    case  576000:\n    {\n        ret = B576000;\n        break;\n    }\n    case  921600:\n    {\n        ret = B921600;\n        break;\n    }\n    case  1000000:\n    {\n        ret = B1000000;\n        break;\n    }\n    case  1152000:\n    {\n        ret = B1152000;\n        break;\n    }\n    case  1500000:\n    {\n        ret = B1500000;\n        break;\n    }\n    case  2000000:\n    {\n        ret = B2000000;\n        break;\n    }\n    case  2500000:\n    {\n        ret = B2500000;\n        break;\n    }\n    case  3000000:\n    {\n        ret = B3000000;\n        break;\n    }\n    case  3500000:\n    {\n        ret = B3500000;\n        break;\n    }\n    case  4000000:\n    {\n        ret = B4000000;\n        break;\n    }\n#      endif /* __linux__ */\n    default:\n    {\n        ret = B115200;\n        break;\n    }\n    }\n\n    return ret;\n#   else\n    return 0;\n#   endif\n}\n\n#endif\n\nvoid dlt_get_version(char *buf, size_t size)\n{\n    if ((buf == NULL) && (size > 0)) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: Null pointer\\n\");\n        return;\n    }\n\n/* Clang does not like these macros, because they are not reproducable */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdate-time\"\n    snprintf(buf,\n             size,\n             \"DLT Package Version: %s %s, Package Revision: %s, build on %s %s\\n%s %s %s %s\\n\",\n             _DLT_PACKAGE_VERSION,\n             _DLT_PACKAGE_VERSION_STATE,\n             _DLT_PACKAGE_REVISION,\n             __DATE__,\n             __TIME__,\n             _DLT_SYSTEMD_ENABLE,\n             _DLT_SYSTEMD_WATCHDOG_ENABLE,\n             _DLT_TEST_ENABLE,\n             _DLT_SHM_ENABLE);\n#pragma GCC diagnostic pop\n}\n\nvoid dlt_get_major_version(char *buf, size_t size)\n{\n    if ((buf == NULL) && (size > 0)) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: Null pointer\\n\");\n        return;\n    }\n\n    snprintf(buf, size, \"%s\", _DLT_PACKAGE_MAJOR_VERSION);\n}\n\nvoid dlt_get_minor_version(char *buf, size_t size)\n{\n    if ((buf == NULL) && (size > 0)) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: Null pointer\\n\");\n        return;\n    }\n\n    snprintf(buf, size, \"%s\", _DLT_PACKAGE_MINOR_VERSION);\n}\n\n\nuint32_t dlt_uptime(void)\n{\n\n#if defined (__WIN32__) || defined(_MSC_VER)\n\n    return (uint32_t)(GetTickCount() * 10); /* GetTickCount() return DWORD */\n\n#else\n    struct timespec ts;\n\n    if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0)\n        return (uint32_t)ts.tv_sec * 10000 + (uint32_t)ts.tv_nsec / 100000; /* in 0.1 ms = 100 us */\n    else\n        return 0;\n\n#endif\n\n}\n\nDltReturnValue dlt_message_print_header(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_hex(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_HEX, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_ascii(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_ASCII, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_mixed_plain(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \\n\", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_MIXED_FOR_PLAIN, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_mixed_html(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \\n\", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_MIXED_FOR_HTML, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_argument_print(DltMessage *msg,\n                                          uint32_t type_info,\n                                          uint8_t **ptr,\n                                          int32_t *datalength,\n                                          char *text,\n                                          size_t textlength,\n                                          int byteLength,\n                                          int __attribute__((unused)) verbose)\n{\n    /* check null pointers */\n    if ((msg == NULL) || (ptr == NULL) || (datalength == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    uint16_t length = 0, length2 = 0, length3 = 0;\n\n    uint8_t value8u = 0;\n    uint16_t value16u = 0, value16u_tmp = 0;\n    uint32_t value32u = 0, value32u_tmp = 0;\n    uint64_t value64u = 0, value64u_tmp = 0;\n\n    int8_t value8i = 0;\n    int16_t value16i = 0, value16i_tmp = 0;\n    int32_t value32i = 0, value32i_tmp = 0;\n    int64_t value64i = 0, value64i_tmp = 0;\n\n    float32_t value32f = 0, value32f_tmp = 0;\n    int32_t value32f_tmp_int32i = 0, value32f_tmp_int32i_swaped = 0;\n    float64_t value64f = 0, value64f_tmp = 0;\n    int64_t value64f_tmp_int64i = 0, value64f_tmp_int64i_swaped = 0;\n\n    uint32_t quantisation_tmp = 0;\n\n    // pointer to the value string\n    char* value_text = text;\n    // pointer to the \"unit\" attribute string, if there is one (only for *INT and FLOAT*)\n    const uint8_t* unit_text_src = NULL;\n    // length of the \"unit\" attribute string, if there is one (only for *INT and FLOAT*)\n    size_t unit_text_len = 0;\n\n    /* apparently this makes no sense but needs to be done to prevent compiler warning.\n     * This variable is only written by DLT_MSG_READ_VALUE macro in if (type_info & DLT_TYPE_INFO_FIXP)\n     * case but never read anywhere */\n    quantisation_tmp += quantisation_tmp;\n\n    if ((type_info & DLT_TYPE_INFO_STRG) &&\n        (((type_info & DLT_TYPE_INFO_SCOD) == DLT_SCOD_ASCII) || ((type_info & DLT_TYPE_INFO_SCOD) == DLT_SCOD_UTF8))) {\n        /* string type or utf8-encoded string type */\n        if (byteLength < 0) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n        }\n        else {\n            length = (uint16_t)byteLength;\n        }\n\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n        }\n\n        DLT_MSG_READ_STRING(value_text, *ptr, *datalength, textlength, length);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n    }\n    else if (type_info & DLT_TYPE_INFO_BOOL)\n    {\n        /* Boolean type */\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-2;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n        }\n\n        value8u = 0;\n        DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n\n        snprintf(value_text, textlength, \"%d\", value8u);\n    }\n    else if ((type_info & DLT_TYPE_INFO_UINT) && (DLT_SCOD_BIN == (type_info & DLT_TYPE_INFO_SCOD)))\n    {\n        if (DLT_TYLE_8BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            char binary[10] = { '\\0' }; /* e.g.: \"0b1100 0010\" */\n            int i;\n\n            for (i = (1 << 7); i > 0; i >>= 1) {\n                if ((1 << 3) == i)\n                    strcat(binary, \" \");\n\n                strcat(binary, (i == (value8u & i)) ? \"1\" : \"0\");\n            }\n\n            snprintf(value_text, textlength, \"0b%s\", binary);\n        }\n\n        if (DLT_TYLE_16BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value16u, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            char binary[20] = { '\\0' }; /* e.g.: \"0b1100 0010 0011 0110\" */\n            int i;\n\n            for (i = (1 << 15); i > 0; i >>= 1) {\n                if (((1 << 3) == i) || ((1 << 7) == i) || ((1 << 11) == i))\n                    strcat(binary, \" \");\n\n                strcat(binary, (i == (value16u & i)) ? \"1\" : \"0\");\n            }\n\n            snprintf(value_text, textlength, \"0b%s\", binary);\n        }\n    }\n    else if ((type_info & DLT_TYPE_INFO_UINT) && (DLT_SCOD_HEX == (type_info & DLT_TYPE_INFO_SCOD)))\n    {\n        if (DLT_TYLE_8BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%02x\", value8u);\n        }\n\n        if (DLT_TYLE_16BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value16u, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%04x\", value16u);\n        }\n\n        if (DLT_TYLE_32BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%08x\", value32u);\n        }\n\n        if (DLT_TYLE_64BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            *ptr += 4;\n            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%08x\", value32u);\n            *ptr -= 8;\n            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text + strlen(value_text), textlength - strlen(value_text), \"%08x\", value32u);\n            *ptr += 4;\n        }\n    }\n    else if ((type_info & DLT_TYPE_INFO_SINT) || (type_info & DLT_TYPE_INFO_UINT))\n    {\n        /* signed or unsigned argument received */\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length3 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for the \":\", and -1 for nul\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n\n            if ((*datalength) < length3)\n                return DLT_RETURN_ERROR;\n\n            // We want to add the \"unit\" attribute only after the value, so remember its pointer and length here.\n            unit_text_src = *ptr;\n            unit_text_len = length3;\n\n            *ptr += length3;\n            *datalength -= length3;\n        }\n\n        if (type_info & DLT_TYPE_INFO_FIXP) {\n            DLT_MSG_READ_VALUE(quantisation_tmp, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            switch (type_info & DLT_TYPE_INFO_TYLE) {\n            case DLT_TYLE_8BIT:\n            case DLT_TYLE_16BIT:\n            case DLT_TYLE_32BIT:\n            {\n                if ((*datalength) < 4)\n                    return DLT_RETURN_ERROR;\n\n                *ptr += 4;\n                *datalength -= 4;\n                break;\n            }\n            case DLT_TYLE_64BIT:\n            {\n                if ((*datalength) < 8)\n                    return DLT_RETURN_ERROR;\n\n                *ptr += 8;\n                *datalength -= 8;\n                break;\n            }\n            case DLT_TYLE_128BIT:\n            {\n                if ((*datalength) < 16)\n                    return DLT_RETURN_ERROR;\n\n                *ptr += 16;\n                *datalength -= 16;\n                break;\n            }\n            default:\n            {\n                return DLT_RETURN_ERROR;\n            }\n            }\n        }\n\n        switch (type_info & DLT_TYPE_INFO_TYLE) {\n        case DLT_TYLE_8BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value8i = 0;\n                DLT_MSG_READ_VALUE(value8i, *ptr, *datalength, int8_t);  /* No endian conversion necessary */\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                snprintf(value_text, textlength, \"%d\", value8i);\n            }\n            else {\n                value8u = 0;\n                DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t);  /* No endian conversion necessary */\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                snprintf(value_text, textlength, \"%d\", value8u);\n            }\n\n            break;\n        }\n        case DLT_TYLE_16BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value16i = 0;\n                value16i_tmp = 0;\n                DLT_MSG_READ_VALUE(value16i_tmp, *ptr, *datalength, int16_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value16i = (int16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16i_tmp);\n                snprintf(value_text, textlength, \"%hd\", value16i);\n            }\n            else {\n                value16u = 0;\n                value16u_tmp = 0;\n                DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value16u = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n                snprintf(value_text, textlength, \"%hu\", value16u);\n            }\n\n            break;\n        }\n        case DLT_TYLE_32BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value32i = 0;\n                value32i_tmp = 0;\n                DLT_MSG_READ_VALUE(value32i_tmp, *ptr, *datalength, int32_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value32i = (int32_t) DLT_ENDIAN_GET_32(msg->standardheader->htyp, (uint32_t)value32i_tmp);\n                snprintf(value_text, textlength, \"%d\", value32i);\n            }\n            else {\n                value32u = 0;\n                value32u_tmp = 0;\n                DLT_MSG_READ_VALUE(value32u_tmp, *ptr, *datalength, uint32_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value32u = DLT_ENDIAN_GET_32(msg->standardheader->htyp, value32u_tmp);\n                snprintf(value_text, textlength, \"%u\", value32u);\n            }\n\n            break;\n        }\n        case DLT_TYLE_64BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value64i = 0;\n                value64i_tmp = 0;\n                DLT_MSG_READ_VALUE(value64i_tmp, *ptr, *datalength, int64_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value64i = (int64_t) DLT_ENDIAN_GET_64(msg->standardheader->htyp, (uint64_t)value64i_tmp);\n    #if defined (__WIN32__) && !defined(_MSC_VER)\n                snprintf(value_text, textlength, \"%I64d\", value64i);\n    #else\n                snprintf(value_text, textlength, \"%\" PRId64, value64i);\n    #endif\n            }\n            else {\n                value64u = 0;\n                value64u_tmp = 0;\n                DLT_MSG_READ_VALUE(value64u_tmp, *ptr, *datalength, uint64_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value64u = DLT_ENDIAN_GET_64(msg->standardheader->htyp, value64u_tmp);\n    #if defined (__WIN32__) && !defined(_MSC_VER)\n                snprintf(value_text, textlength, \"%I64u\", value64u);\n    #else\n                snprintf(value_text, textlength, \"%\" PRIu64, value64u);\n    #endif\n            }\n\n            break;\n        }\n        case DLT_TYLE_128BIT:\n        {\n            if (*datalength >= 16)\n                dlt_print_hex_string(value_text, (int) textlength, *ptr, 16);\n\n            if ((*datalength) < 16)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 16;\n            *datalength -= 16;\n            break;\n        }\n        default:\n        {\n            return DLT_RETURN_ERROR;\n        }\n        }\n    }\n    else if (type_info & DLT_TYPE_INFO_FLOA)\n    {\n        /* float data argument */\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length3 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n\n            if ((*datalength) < length3)\n                return DLT_RETURN_ERROR;\n\n            // We want to add the \"unit\" attribute only after the value, so remember its pointer and length here.\n            unit_text_src = *ptr;\n            unit_text_len = length3;\n\n            *ptr += length3;\n            *datalength -= length3;\n        }\n\n        switch (type_info & DLT_TYPE_INFO_TYLE) {\n        case DLT_TYLE_8BIT:\n        {\n            if (*datalength >= 1)\n                dlt_print_hex_string(value_text, (int) textlength, *ptr, 1);\n\n            if ((*datalength) < 1)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 1;\n            *datalength -= 1;\n            break;\n        }\n        case DLT_TYLE_16BIT:\n        {\n            if (*datalength >= 2)\n                dlt_print_hex_string(value_text, (int) textlength, *ptr, 2);\n\n            if ((*datalength) < 2)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 2;\n            *datalength -= 2;\n            break;\n        }\n        case DLT_TYLE_32BIT:\n        {\n            if (sizeof(float32_t) == 4) {\n                value32f = 0;\n                value32f_tmp = 0;\n                value32f_tmp_int32i = 0;\n                value32f_tmp_int32i_swaped = 0;\n                DLT_MSG_READ_VALUE(value32f_tmp, *ptr, *datalength, float32_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                memcpy(&value32f_tmp_int32i, &value32f_tmp, sizeof(float32_t));\n                value32f_tmp_int32i_swaped =\n                    (int32_t) DLT_ENDIAN_GET_32(msg->standardheader->htyp, (uint32_t)value32f_tmp_int32i);\n                memcpy(&value32f, &value32f_tmp_int32i_swaped, sizeof(float32_t));\n                snprintf(value_text, textlength, \"%g\", value32f);\n            }\n            else {\n                dlt_log(LOG_ERR, \"Invalid size of float32_t\\n\");\n                return DLT_RETURN_ERROR;\n            }\n\n            break;\n        }\n        case DLT_TYLE_64BIT:\n        {\n            if (sizeof(float64_t) == 8) {\n                value64f = 0;\n                value64f_tmp = 0;\n                value64f_tmp_int64i = 0;\n                value64f_tmp_int64i_swaped = 0;\n                DLT_MSG_READ_VALUE(value64f_tmp, *ptr, *datalength, float64_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                memcpy(&value64f_tmp_int64i, &value64f_tmp, sizeof(float64_t));\n                value64f_tmp_int64i_swaped =\n                    (int64_t) DLT_ENDIAN_GET_64(msg->standardheader->htyp, (uint64_t)value64f_tmp_int64i);\n                memcpy(&value64f, &value64f_tmp_int64i_swaped, sizeof(float64_t));\n#ifdef __arm__\n                snprintf(value_text, textlength, \"ILLEGAL\");\n#else\n                snprintf(value_text, textlength, \"%g\", value64f);\n#endif\n            }\n            else {\n                dlt_log(LOG_ERR, \"Invalid size of float64_t\\n\");\n                return DLT_RETURN_ERROR;\n            }\n\n            break;\n        }\n        case DLT_TYLE_128BIT:\n        {\n            if (*datalength >= 16)\n                dlt_print_hex_string(value_text, textlength, *ptr, 16);\n\n            if ((*datalength) < 16)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 16;\n            *datalength -= 16;\n            break;\n        }\n        default:\n        {\n            return DLT_RETURN_ERROR;\n        }\n        }\n    }\n    else if (type_info & DLT_TYPE_INFO_RAWD)\n    {\n        /* raw data argument */\n        DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n\n        length = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n        }\n\n        if ((*datalength) < length)\n            return DLT_RETURN_ERROR;\n\n        if (dlt_print_hex_string_delim(value_text, (int) textlength, *ptr, length, '\\'') < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n        *ptr += length;\n        *datalength -= length;\n    }\n    else if (type_info & DLT_TYPE_INFO_TRAI)\n    {\n        /* trace info argument */\n        DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n\n        length = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n        DLT_MSG_READ_STRING(value_text, *ptr, *datalength, textlength, length);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n    }\n    else {\n        return DLT_RETURN_ERROR;\n    }\n\n    if (*datalength < 0) {\n        dlt_log(LOG_ERR, \"Payload of DLT message corrupted\\n\");\n        return DLT_RETURN_ERROR;\n    }\n\n    // Now write \"unit\" attribute, but only if it has more than only a nul-termination char.\n    if (print_with_attributes) {\n        if (unit_text_len > 1) {\n            // 'value_text' still points to the +start+ of the value text\n            size_t currLen = strlen(value_text);\n\n            char* unitText = value_text + currLen;\n            textlength -= currLen;\n            snprintf(unitText, textlength, \":%s\", unit_text_src);\n        }\n    }\n\n    return DLT_RETURN_OK;\n}\n\nvoid dlt_check_envvar()\n{\n    char *env_log_filename = getenv(\"DLT_LOG_FILENAME\");\n\n    if (env_log_filename != NULL)\n        dlt_log_set_filename(env_log_filename);\n\n    char *env_log_level_str = getenv(\"DLT_LOG_LEVEL\");\n\n    if (env_log_level_str != NULL) {\n        int level = 0;\n\n        if (sscanf(env_log_level_str, \"%d\", &level))\n            dlt_log_set_level(level);\n    }\n\n    char *env_log_mode = getenv(\"DLT_LOG_MODE\");\n\n    if (env_log_mode != NULL) {\n        int mode = 0;\n\n        if (sscanf(env_log_mode, \"%d\", &mode))\n            dlt_log_init(mode);\n    }\n\n#if defined DLT_DAEMON_USE_FIFO_IPC || defined DLT_LIB_USE_FIFO_IPC\n    char *env_pipe_dir = getenv(\"DLT_PIPE_DIR\");\n\n    if (env_pipe_dir != NULL)\n        dlt_log_set_fifo_basedir(env_pipe_dir);\n    else\n        dlt_log_set_fifo_basedir(DLT_USER_IPC_PATH);\n\n#endif\n\n#ifdef DLT_SHM_ENABLE\n    char *env_shm_name = getenv(\"DLT_SHM_NAME\");\n\n    if (env_shm_name != NULL)\n        dlt_log_set_shm_name(env_shm_name);\n\n#endif\n}\n\nint dlt_set_loginfo_parse_service_id(char *resp_text,\n                                     uint32_t *service_id,\n                                     uint8_t *service_opt)\n{\n    int ret = -1;\n    char get_log_info_tag[GET_LOG_INFO_LENGTH];\n    char service_opt_str[SERVICE_OPT_LENGTH];\n\n    if ((resp_text == NULL) || (service_id == NULL) || (service_opt == NULL))\n        return DLT_RETURN_ERROR;\n\n    /* ascii type, syntax is 'get_log_info, ..' */\n    /* check target id */\n    strncpy(get_log_info_tag, \"get_log_info\", strlen(\"get_log_info\") + 1);\n    ret = memcmp((void *)resp_text, (void *)get_log_info_tag, sizeof(get_log_info_tag) - 1);\n\n    if (ret == 0) {\n        *service_id = DLT_SERVICE_ID_GET_LOG_INFO;\n        /* reading the response mode from the resp_text. eg. option 7*/\n        service_opt_str[0] = *(resp_text + GET_LOG_INFO_LENGTH + 1);\n        service_opt_str[1] = *(resp_text + GET_LOG_INFO_LENGTH + 2);\n        service_opt_str[2] = 0;\n        *service_opt = (uint8_t) atoi(service_opt_str);\n    }\n\n    return ret;\n}\n\nint16_t dlt_getloginfo_conv_ascii_to_uint16_t(char *rp, int *rp_count)\n{\n    char num_work[5] = { 0 };\n    char *endptr;\n\n    if ((rp == NULL) || (rp_count == NULL))\n        return -1;\n\n    /* ------------------------------------------------------\n     *  from: [89 13 ] -> to: ['+0x'1389\\0] -> to num\n     *  ------------------------------------------------------ */\n    num_work[0] = *(rp + *rp_count + 3);\n    num_work[1] = *(rp + *rp_count + 4);\n    num_work[2] = *(rp + *rp_count + 0);\n    num_work[3] = *(rp + *rp_count + 1);\n    num_work[4] = 0;\n    *rp_count += 6;\n\n    return (uint16_t)strtol(num_work, &endptr, 16);\n}\n\nint16_t dlt_getloginfo_conv_ascii_to_int16_t(char *rp, int *rp_count)\n{\n    char num_work[3] = { 0 };\n    char *endptr;\n\n    if ((rp == NULL) || (rp_count == NULL))\n        return -1;\n\n    /* ------------------------------------------------------\n     *  from: [89 ] -> to: ['0x'89\\0] -> to num\n     *  ------------------------------------------------------ */\n    num_work[0] = *(rp + *rp_count + 0);\n    num_work[1] = *(rp + *rp_count + 1);\n    num_work[2] = 0;\n    *rp_count += 3;\n\n    return (signed char)strtol(num_work, &endptr, 16);\n}\n\nvoid dlt_getloginfo_conv_ascii_to_string(char *rp, int *rp_count, char *wp, int len)\n{\n    if ((rp == NULL ) || (rp_count == NULL ) || (wp == NULL ))\n        return;\n    /* ------------------------------------------------------\n     *  from: [72 65 6d 6f ] -> to: [0x72,0x65,0x6d,0x6f,0x00]\n     *  ------------------------------------------------------ */\n\n    int count = dlt_getloginfo_conv_ascii_to_id(rp, rp_count, wp, len);\n    *(wp + count) = '\\0';\n\n    return;\n}\n\nint dlt_getloginfo_conv_ascii_to_id(char *rp, int *rp_count, char *wp, int len)\n{\n    char number16[3] = { 0 };\n    char *endptr;\n    int count;\n\n    if ((rp == NULL) || (rp_count == NULL) || (wp == NULL))\n        return 0;\n\n    /* ------------------------------------------------------\n     *  from: [72 65 6d 6f ] -> to: [0x72,0x65,0x6d,0x6f]\n     *  ------------------------------------------------------ */\n    for (count = 0; count < len; count++) {\n        number16[0] = *(rp + *rp_count + 0);\n        number16[1] = *(rp + *rp_count + 1);\n        *(wp + count) = (char) strtol(number16, &endptr, 16);\n        *rp_count += 3;\n    }\n\n    return count;\n}\n\nvoid dlt_hex_ascii_to_binary(const char *ptr, uint8_t *binary, int *size)\n{\n    char ch = *ptr;\n    int pos = 0;\n    binary[pos] = 0;\n    int first = 1;\n    int found;\n\n    for (;;) {\n        if (ch == 0) {\n            *size = pos;\n            return;\n        }\n\n        found = 0;\n\n        if ((ch >= '0') && (ch <= '9')) {\n            binary[pos] = (uint8_t) ((binary[pos] << 4) + (ch - '0'));\n            found = 1;\n        }\n        else if ((ch >= 'A') && (ch <= 'F'))\n        {\n            binary[pos] = (uint8_t) ((binary[pos] << 4) + (ch - 'A' + 10));\n            found = 1;\n        }\n        else if ((ch >= 'a') && (ch <= 'f'))\n        {\n            binary[pos] = (uint8_t) ((binary[pos] << 4) + (ch - 'a' + 10));\n            found = 1;\n        }\n\n        if (found) {\n            if (first) {\n                first = 0;\n            }\n            else {\n                first = 1;\n                pos++;\n\n                if (pos >= *size)\n                    return;\n\n                binary[pos] = 0;\n            }\n        }\n\n        ch = *(++ptr);\n    }\n}\n\nDltReturnValue dlt_file_quick_parsing(DltFile *file, const char *filename,\n                                      int type, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n    int ret = DLT_RETURN_OK;\n    char text[DLT_CONVERT_TEXTBUFSIZE] = { 0 };\n\n    if ((file == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *output = fopen(filename, \"w+\");\n\n    if (output == NULL) {\n        dlt_vlog(LOG_ERR, \"Cannot open output file %s for parsing\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    while (ret >= DLT_RETURN_OK && file->file_position < file->file_length) {\n        /* get file position at start of DLT message */\n        if (verbose)\n            dlt_vlog(LOG_DEBUG, \"Position in file: %\" PRIu64 \"\\n\", file->file_position);\n\n        /* read all header and payload */\n        ret = dlt_file_read_header(file, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        ret = dlt_file_read_header_extended(file, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        ret = dlt_file_read_data(file, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        if (file->filter) {\n            /* check the filters if message is used */\n            ret = dlt_message_filter_check(&(file->msg), file->filter, verbose);\n\n            if (ret != DLT_RETURN_TRUE)\n                continue;\n        }\n\n        ret = dlt_message_header(&(file->msg), text,\n                                 DLT_CONVERT_TEXTBUFSIZE, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        fprintf(output, \"%s\", text);\n\n        ret = dlt_message_payload(&(file->msg), text,\n                                  DLT_CONVERT_TEXTBUFSIZE, type, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        fprintf(output, \"[%s]\\n\", text);\n\n        /* store index pointer to message position in DLT file */\n        file->counter++;\n        file->position = file->counter_total - 1;\n        /* increase total message counter */\n        file->counter_total++;\n        /* store position to next message */\n        file->file_position = ftell(file->handle);\n    } /* while() */\n\n    fclose(output);\n    return ret;\n}\n\n\nint dlt_execute_command(char *filename, char *command, ...)\n{\n    va_list val;\n    int argc;\n    char **args = NULL;\n    int ret = 0;\n\n    if (command == NULL)\n        return -1;\n\n    /* Determine number of variadic arguments */\n    va_start(val, command);\n\n    for (argc = 2; va_arg(val, char *) != NULL; argc++);\n\n    va_end(val);\n\n    /* Allocate args, put references to command */\n    args = (char **) malloc( (uint32_t) argc * sizeof(char*));\n    args[0] = command;\n\n    va_start(val, command);\n\n    for (int i = 0; args[i] != NULL; i++)\n        args[i + 1] = va_arg(val, char *);\n\n    va_end(val);\n\n    /* Run command in child process */\n    pid_t pid = fork();\n\n    if (pid == 0) { /* child process */\n\n        /* Redirect output if required */\n        if (filename != NULL) {\n            int fd = open(filename, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n            if (fd < 0)\n                err(-1, \"%s failed on open()\", __func__);\n\n            if (dup2(fd, STDOUT_FILENO) == -1) {\n                close(fd);\n                err(-1, \"%s failed on dup2()\", __func__);\n            }\n\n            close(fd);\n        }\n\n        /* Run command */\n        execvp(command, (char **)args);\n    }\n    else if (pid == -1) /* error in fork */\n    {\n        ret = -1;\n    }\n    else { /* parent */\n        wait(&ret);\n    }\n\n    free(args);\n    return ret;\n}\n"], "fixing_code": ["/*\n * SPDX license identifier: MPL-2.0\n *\n * Copyright (C) 2011-2015, BMW AG\n *\n * This file is part of GENIVI Project DLT - Diagnostic Log and Trace.\n *\n * This Source Code Form is subject to the terms of the\n * Mozilla Public License (MPL), v. 2.0.\n * If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * For further information see http://www.genivi.org/.\n */\n\n/*!\n * \\author\n * Alexander Wenzel <alexander.aw.wenzel@bmw.de>\n * Markus Klein <Markus.Klein@esk.fraunhofer.de>\n * Mikko Rapeli <mikko.rapeli@bmw.de>\n *\n * \\copyright Copyright \u00a9 2011-2015 BMW AG. \\n\n * License MPL-2.0: Mozilla Public License version 2.0 http://mozilla.org/MPL/2.0/.\n *\n * \\file dlt_common.c\n */\n\n#include <stdio.h>\n#include <stdlib.h>   /* for malloc(), free() */\n#include <string.h>   /* for strlen(), memcmp(), memmove() */\n#include <time.h>     /* for localtime_r(), strftime() */\n#include <limits.h>   /* for NAME_MAX */\n#include <inttypes.h> /* for PRI formatting macro */\n#include <stdarg.h>\n#include <err.h>\n\n#include <errno.h>\n#include <sys/stat.h> /* for mkdir() */\n#include <sys/wait.h>\n\n#include \"dlt_user_shared.h\"\n#include \"dlt_common.h\"\n#include \"dlt_common_cfg.h\"\n\n#include \"dlt_version.h\"\n\n#if defined (__WIN32__) || defined (_MSC_VER)\n#   include <winsock2.h> /* for socket(), connect(), send(), and recv() */\n#else\n#   include <sys/socket.h> /* for socket(), connect(), send(), and recv() */\n#   include <syslog.h>\n#   include <time.h> /* for clock_gettime() */\n#endif\n\n#if defined (_MSC_VER)\n#   include <io.h>\n#else\n#   include <unistd.h>  /* for read(), close() */\n#   include <fcntl.h>\n#   include <sys/time.h> /* for gettimeofday() */\n#endif\n\n#if defined (__MSDOS__) || defined (_MSC_VER)\n#   pragma warning(disable : 4996) /* Switch off C4996 warnings */\n#   include <windows.h>\n#   include <winbase.h>\n#endif\n\nconst char dltSerialHeader[DLT_ID_SIZE] = { 'D', 'L', 'S', 1 };\nchar dltSerialHeaderChar[DLT_ID_SIZE] = { 'D', 'L', 'S', 1 };\n\n#if defined DLT_DAEMON_USE_FIFO_IPC || defined DLT_LIB_USE_FIFO_IPC\nchar dltFifoBaseDir[DLT_PATH_MAX] = \"/tmp\";\n#endif\n\n#ifdef DLT_SHM_ENABLE\nchar dltShmName[NAME_MAX + 1] = \"/dlt-shm\";\n#endif\n\n/* internal logging parameters */\nstatic int logging_level = LOG_INFO;\nstatic char logging_filename[NAME_MAX + 1] = \"\";\nstatic bool print_with_attributes = false;\nint logging_mode = DLT_LOG_TO_STDERR;\nFILE *logging_handle = NULL;\n\nchar *message_type[] = { \"log\", \"app_trace\", \"nw_trace\", \"control\", \"\", \"\", \"\", \"\" };\nchar *log_info[] = { \"\", \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"verbose\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nchar *trace_type[] = { \"\", \"variable\", \"func_in\", \"func_out\", \"state\", \"vfb\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nchar *nw_trace_type[] = { \"\", \"ipc\", \"can\", \"flexray\", \"most\", \"vfb\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nchar *control_type[] = { \"\", \"request\", \"response\", \"time\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\nstatic char *service_id_name[] =\n{ \"\", \"set_log_level\", \"set_trace_status\", \"get_log_info\", \"get_default_log_level\", \"store_config\",\n  \"reset_to_factory_default\",\n  \"set_com_interface_status\", \"set_com_interface_max_bandwidth\", \"set_verbose_mode\",\n  \"set_message_filtering\", \"set_timing_packets\",\n  \"get_local_time\", \"use_ecu_id\", \"use_session_id\", \"use_timestamp\", \"use_extended_header\",\n  \"set_default_log_level\", \"set_default_trace_status\",\n  \"get_software_version\", \"message_buffer_overflow\" };\nstatic char *return_type[] =\n{ \"ok\", \"not_supported\", \"error\", \"perm_denied\", \"warning\", \"\", \"\", \"\", \"no_matching_context_id\" };\n\n/* internal function definitions */\nint dlt_buffer_get(DltBuffer *buf, unsigned char *data, int max_size, int delete);\nint dlt_buffer_reset(DltBuffer *buf);\nint dlt_buffer_increase_size(DltBuffer *buf);\nint dlt_buffer_minimize_size(DltBuffer *buf);\nvoid dlt_buffer_write_block(DltBuffer *buf, int *write, const unsigned char *data, unsigned int size);\nvoid dlt_buffer_read_block(DltBuffer *buf, int *read, unsigned char *data, unsigned int size);\n\nvoid dlt_print_hex(uint8_t *ptr, int size)\n{\n    int num;\n\n    if (ptr == NULL)\n        return;\n\n    for (num = 0; num < size; num++) {\n        if (num > 0)\n            dlt_user_printf(\" \");\n\n        dlt_user_printf(\"%.2x\", ((uint8_t *)ptr)[num]);\n    }\n}\n\nstatic DltReturnValue dlt_print_hex_string_delim(char *text, int textlength, uint8_t *ptr, int size, char delim)\n{\n    int num;\n\n    if ((ptr == NULL) || (text == NULL) || (textlength <= 0) || (size < 0) || (delim == '\\0'))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Length 3: AB_ , A is first digit of hex number, B is second digit of hex number, _ is space */\n    if (textlength < (size * 3)) {\n        dlt_vlog(LOG_WARNING,\n                 \"String does not fit hex data (available=%d, required=%d) !\\n\",\n                 textlength, size * 3);\n        return DLT_RETURN_ERROR;\n    }\n\n    for (num = 0; num < size; num++) {\n        if (num > 0) {\n            snprintf(text, 2, \"%c\", delim);\n            text++;\n        }\n\n        snprintf(text, 3, \"%.2x\", ((uint8_t *)ptr)[num]);\n        text += 2; /* 2 chars */\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_print_hex_string(char *text, int textlength, uint8_t *ptr, int size)\n{\n    return dlt_print_hex_string_delim(text, textlength, ptr, size, ' ');\n}\n\nDltReturnValue dlt_print_mixed_string(char *text, int textlength, uint8_t *ptr, int size, int html)\n{\n    int required_size = 0;\n    int lines, rest, i;\n\n    if ((ptr == NULL) || (text == NULL) || (textlength <= 0) || (size < 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Check maximum required size and do a length check */\n    if (html == 0)\n        required_size =\n            (DLT_COMMON_HEX_LINELEN + (2 * DLT_COMMON_HEX_CHARS + (DLT_COMMON_HEX_CHARS - 1)) + DLT_COMMON_CHARLEN +\n             DLT_COMMON_HEX_CHARS + DLT_COMMON_CHARLEN) *\n            ((size / DLT_COMMON_HEX_CHARS) + 1);\n    /* Example: (8 chars line number + (2*16 chars + 15 spaces) + space + 16 ascii chars + CR) *\n     * ((size/16) lines + extra line for the rest) */\n    else\n        required_size =\n            (DLT_COMMON_HEX_LINELEN + (2 * DLT_COMMON_HEX_CHARS + (DLT_COMMON_HEX_CHARS - 1)) + DLT_COMMON_CHARLEN +\n             DLT_COMMON_HEX_CHARS + 4 * DLT_COMMON_CHARLEN) *\n            ((size / DLT_COMMON_HEX_CHARS) + 1);\n\n    /* Example: (8 chars line number + (2*16 chars + 15 spaces) + space + 16 ascii chars + 4 [HTML CR: <BR>]) *\n     * ((size/16) lines + extra line for the rest) */\n\n    if (textlength < required_size) {\n        dlt_vlog(LOG_WARNING,\n                 \"String does not fit mixed data (available=%d, required=%d) !\\n\",\n                 textlength, required_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* print full lines */\n    for (lines = 0; lines < (size / DLT_COMMON_HEX_CHARS); lines++) {\n        int ret = 0;\n        /* Line number */\n        ret = snprintf(text, DLT_COMMON_HEX_LINELEN + 1, \"%.6x: \", (uint32_t)lines * DLT_COMMON_HEX_CHARS);\n\n        if ((ret < 0) || (ret >= (DLT_COMMON_HEX_LINELEN + 1)))\n            dlt_log(LOG_WARNING, \"line was truncated\\n\");\n\n        text += DLT_COMMON_HEX_LINELEN; /* 'XXXXXX: ' */\n\n        /* Hex-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_hex_string(text, textlength,\n                (uint8_t *)(ptr + (lines * DLT_COMMON_HEX_CHARS)),\n                DLT_COMMON_HEX_CHARS) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n        text += ((2 * DLT_COMMON_HEX_CHARS) + (DLT_COMMON_HEX_CHARS - 1)); /* 32 characters + 15 spaces */\n\n        snprintf(text, 2, \" \");\n        text += DLT_COMMON_CHARLEN;\n\n        /* Char-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_char_string(&text, textlength,\n                (uint8_t *)(ptr + (lines * DLT_COMMON_HEX_CHARS)),\n                DLT_COMMON_HEX_CHARS) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n\n        if (html == 0) {\n            snprintf(text, 2, \"\\n\");\n            text += DLT_COMMON_CHARLEN;\n        }\n        else {\n            snprintf(text, 5, \"<BR>\");\n            text += (4 * DLT_COMMON_CHARLEN);\n        }\n    }\n\n    /* print partial line */\n    rest = size % DLT_COMMON_HEX_CHARS;\n\n    if (rest > 0) {\n        /* Line number */\n        int ret = 0;\n        ret = snprintf(text, 9, \"%.6x: \", (uint32_t)(size / DLT_COMMON_HEX_CHARS) * DLT_COMMON_HEX_CHARS);\n\n        if ((ret < 0) || (ret >= 9))\n            dlt_log(LOG_WARNING, \"line number was truncated\");\n\n        text += DLT_COMMON_HEX_LINELEN; /* 'XXXXXX: ' */\n\n        /* Hex-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_hex_string(text,\n                             textlength,\n                             (uint8_t *)(ptr + ((size / DLT_COMMON_HEX_CHARS) * DLT_COMMON_HEX_CHARS)),\n                             rest) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n        text += 2 * rest + (rest - 1);\n\n        for (i = 0; i < (DLT_COMMON_HEX_CHARS - rest); i++) {\n            snprintf(text, 4, \" xx\");\n            text += (3 * DLT_COMMON_CHARLEN);\n        }\n\n        snprintf(text, 2, \" \");\n        text += DLT_COMMON_CHARLEN;\n\n        /* Char-Output */\n        /* It is not required to decrement textlength, as it was already checked, that\n         * there is enough space for the complete output */\n        if (dlt_print_char_string(&text, textlength,\n                              (uint8_t *)(ptr + ((size / DLT_COMMON_HEX_CHARS) * DLT_COMMON_HEX_CHARS)),\n                              rest) < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_print_char_string(char **text, int textlength, uint8_t *ptr, int size)\n{\n    int num;\n\n    if ((text == NULL) || (ptr == NULL) || (*text == NULL) || (textlength <= 0) || (size < 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (textlength < size) {\n        dlt_vlog(LOG_WARNING,\n                 \"String does not fit character data (available=%d, required=%d) !\\n\",\n                 textlength, size);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    for (num = 0; num < size; num++) {\n        if ((((char *)ptr)[num] < DLT_COMMON_ASCII_CHAR_SPACE) || (((char *)ptr)[num] > DLT_COMMON_ASCII_CHAR_TILDE)) {\n            snprintf(*text, 2, \".\");\n        }\n        else {\n            /* replace < with . */\n            if (((char *)ptr)[num] != DLT_COMMON_ASCII_CHAR_LT)\n                snprintf(*text, 2, \"%c\", ((char *)ptr)[num]);\n            else\n                snprintf(*text, 2, \".\");\n        }\n\n        (*text)++;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nsize_t dlt_strnlen_s(const char* str, size_t maxsize)\n{\n    if (str == NULL)\n        return 0;\n\n    for (size_t i = 0; i < maxsize; ++i) {\n        if (str[i] == '\\0')\n            return i;\n    }\n    return maxsize;\n}\n\nvoid dlt_print_id(char *text, const char *id)\n{\n    /* check nullpointer */\n    if ((text == NULL) || (id == NULL))\n        return;\n\n    /* Initialize text */\n    memset(text, '-', DLT_ID_SIZE);\n\n    text[DLT_ID_SIZE] = 0;\n\n    size_t len = dlt_strnlen_s(id, DLT_ID_SIZE);\n\n    memcpy(text, id, len);\n}\n\nvoid dlt_set_id(char *id, const char *text)\n{\n    /* check nullpointer */\n    if ((id == NULL) || (text == NULL))\n        return;\n\n    id[0] = 0;\n    id[1] = 0;\n    id[2] = 0;\n    id[3] = 0;\n\n    if (text[0] != 0)\n        id[0] = text[0];\n    else\n        return;\n\n    if (text[1] != 0)\n        id[1] = text[1];\n    else\n        return;\n\n    if (text[2] != 0)\n        id[2] = text[2];\n    else\n        return;\n\n    if (text[3] != 0)\n        id[3] = text[3];\n    else\n        return;\n}\n\nvoid dlt_clean_string(char *text, int length)\n{\n    int num;\n\n    if (text == NULL)\n        return;\n\n    for (num = 0; num < length; num++)\n        if ((text[num] == '\\r') || (text[num] == '\\n'))\n            text[num] = ' ';\n}\n\nDltReturnValue dlt_filter_init(DltFilter *filter, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (filter == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    filter->counter = 0;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_filter_free(DltFilter *filter, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (filter == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    char str1[DLT_COMMON_BUFFER_LENGTH + 1];\n    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"r\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    #define FORMAT_STRING_(x) \"%\" #x \"s\"\n    #define FORMAT_STRING(x) FORMAT_STRING_(x)\n\n    /* Reset filters */\n    filter->counter = 0;\n\n    while (!feof(handle)) {\n        str1[0] = 0;\n\n        if (fscanf(handle, FORMAT_STRING(DLT_COMMON_BUFFER_LENGTH), str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(apid, \"\");\n        else\n            dlt_set_id(apid, str1);\n\n        str1[0] = 0;\n\n        if (fscanf(handle, FORMAT_STRING(DLT_COMMON_BUFFER_LENGTH), str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\\r\\n\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(ctid, \"\");\n        else\n            dlt_set_id(ctid, str1);\n\n        if (filter->counter < DLT_FILTER_MAX)\n            dlt_filter_add(filter, apid, ctid, 0, 0, INT32_MAX, verbose);\n        else\n            dlt_vlog(LOG_WARNING,\n                     \"Maximum number (%d) of allowed filters reached, ignoring rest of filters!\\n\",\n                     DLT_FILTER_MAX);\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_filter_save(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    int num;\n    char buf[DLT_COMMON_BUFFER_LENGTH];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"w\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    for (num = 0; num < filter->counter; num++) {\n        if (filter->apid[num][0] == 0) {\n            fprintf(handle, \"---- \");\n        }\n        else {\n            dlt_print_id(buf, filter->apid[num]);\n            fprintf(handle, \"%s \", buf);\n        }\n\n        if (filter->ctid[num][0] == 0) {\n            fprintf(handle, \"---- \");\n        }\n        else {\n            dlt_print_id(buf, filter->ctid[num]);\n            fprintf(handle, \"%s \", buf);\n        }\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_filter_find(DltFilter *filter, const char *apid, const char *ctid, const int log_level,\n                    const int32_t payload_min, const int32_t payload_max, int verbose)\n{\n    int num;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((filter == NULL) || (apid == NULL))\n        return -1;\n\n    for (num = 0; num < filter->counter; num++)\n        if (memcmp(filter->apid[num], apid, DLT_ID_SIZE) == 0) {\n            /* apid matches, now check for ctid */\n            if (ctid == NULL) {\n                /* check if empty ctid matches */\n                /*if (memcmp(filter->ctid[num],\"\",DLT_ID_SIZE)==0)//coverity complains here about Out-of-bounds access. */\n                char empty_ctid[DLT_ID_SIZE] = \"\";\n\n                if (memcmp(filter->ctid[num], empty_ctid, DLT_ID_SIZE) == 0)\n                    if ((filter->log_level[num] == log_level) || (filter->log_level[num] == 0))\n                        if (filter->payload_min[num] <= payload_min)\n                            if (filter->payload_max[num] >= payload_max)\n                                return num;\n            }\n            else if (memcmp(filter->ctid[num], ctid, DLT_ID_SIZE) == 0)\n            {\n                if ((filter->log_level[num] == log_level) || (filter->log_level[num] == 0))\n                    if (filter->payload_min[num] <= payload_min)\n                        if (filter->payload_max[num] >= payload_max)\n                            return num;\n            }\n        }\n\n    return -1; /* Not found */\n}\n\nDltReturnValue dlt_filter_add(DltFilter *filter, const char *apid, const char *ctid, const int log_level,\n                              const int32_t payload_min, const int32_t payload_max, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((filter == NULL) || (apid == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (filter->counter >= DLT_FILTER_MAX) {\n        dlt_vlog(LOG_WARNING,\n                 \"Maximum number (%d) of allowed filters reached, ignoring filter!\\n\",\n                 DLT_FILTER_MAX);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* add each filter (apid, ctid, log_level, payload_min, payload_max) only once to filter array */\n    if (dlt_filter_find(filter, apid, ctid, log_level, payload_min, payload_max, verbose) < 0) {\n        /* filter not found, so add it to filter array */\n        dlt_set_id(filter->apid[filter->counter], apid);\n        dlt_set_id(filter->ctid[filter->counter], (ctid ? ctid : \"\"));\n        filter->log_level[filter->counter] = log_level;\n        filter->payload_min[filter->counter] = payload_min;\n        filter->payload_max[filter->counter] = payload_max;\n\n        filter->counter++;\n\n        return DLT_RETURN_OK;\n    }\n\n    return DLT_RETURN_ERROR;\n}\n\nDltReturnValue dlt_filter_delete(DltFilter *filter, const char *apid, const char *ctid, const int log_level,\n                                 const int32_t payload_min, const int32_t payload_max, int verbose)\n{\n    int j, k;\n    int found = 0;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((filter == NULL) || (apid == NULL) || (ctid == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (filter->counter > 0) {\n        /* Get first occurence of apid and ctid in filter array */\n        for (j = 0; j < filter->counter; j++)\n            if ((memcmp(filter->apid[j], apid, DLT_ID_SIZE) == 0) &&\n                (memcmp(filter->ctid[j], ctid, DLT_ID_SIZE) == 0) &&\n                ((filter->log_level[j] == log_level) || (filter->log_level[j] == 0)) &&\n                (filter->payload_min[j] == payload_min) &&\n                (filter->payload_max[j] == payload_max)\n                ) {\n                found = 1;\n                break;\n            }\n\n        if (found) {\n            /* j is index */\n            /* Copy from j+1 til end to j til end-1 */\n\n            dlt_set_id(filter->apid[j], \"\");\n            dlt_set_id(filter->ctid[j], \"\");\n            filter->log_level[j] = 0;\n            filter->payload_min[j] = 0;\n            filter->payload_max[j] = INT32_MAX;\n\n            for (k = j; k < (filter->counter - 1); k++) {\n                dlt_set_id(filter->apid[k], filter->apid[k + 1]);\n                dlt_set_id(filter->ctid[k], filter->ctid[k + 1]);\n                filter->log_level[k] = filter->log_level[k + 1];\n                filter->payload_min[k] = filter->payload_min[k + 1];\n                filter->payload_max[k] = filter->payload_max[k + 1];\n            }\n\n            filter->counter--;\n            return DLT_RETURN_OK;\n        }\n    }\n\n    return DLT_RETURN_ERROR;\n}\n\nDltReturnValue dlt_message_init(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* initalise structure parameters */\n    msg->headersize = 0;\n    msg->datasize = 0;\n\n    msg->databuffer = NULL;\n    msg->databuffersize = 0;\n\n    msg->storageheader = NULL;\n    msg->standardheader = NULL;\n    msg->extendedheader = NULL;\n\n    msg->found_serialheader = 0;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_free(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* delete databuffer if exists */\n    if (msg->databuffer) {\n        free(msg->databuffer);\n        msg->databuffer = NULL;\n        msg->databuffersize = 0;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_header(DltMessage *msg, char *text, size_t textlength, int verbose)\n{\n    return dlt_message_header_flags(msg, text, textlength, DLT_HEADER_SHOW_ALL, verbose);\n}\n\nDltReturnValue dlt_message_header_flags(DltMessage *msg, char *text, size_t textlength, int flags, int verbose)\n{\n    struct tm timeinfo;\n    char buffer [DLT_COMMON_BUFFER_LENGTH];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (text == NULL) || (textlength <= 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) && (msg->extendedheader == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((flags < DLT_HEADER_SHOW_NONE) || (flags > DLT_HEADER_SHOW_ALL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    text[0] = 0;\n\n    if ((flags & DLT_HEADER_SHOW_TIME) == DLT_HEADER_SHOW_TIME) {\n        /* print received time */\n        time_t tt = msg->storageheader->seconds;\n        tzset();\n        localtime_r(&tt, &timeinfo);\n        strftime (buffer, sizeof(buffer), \"%Y/%m/%d %H:%M:%S\", &timeinfo);\n        snprintf(text, textlength, \"%s.%.6d \", buffer, msg->storageheader->microseconds);\n    }\n\n    if ((flags & DLT_HEADER_SHOW_TMSTP) == DLT_HEADER_SHOW_TMSTP) {\n        /* print timestamp if available */\n        if (DLT_IS_HTYP_WTMS(msg->standardheader->htyp))\n            snprintf(text + strlen(text), textlength - strlen(text), \"%10u \", msg->headerextra.tmsp);\n        else\n            snprintf(text + strlen(text), textlength - strlen(text), \"---------- \");\n    }\n\n    if ((flags & DLT_HEADER_SHOW_MSGCNT) == DLT_HEADER_SHOW_MSGCNT)\n        /* print message counter */\n        snprintf(text + strlen(text), textlength - strlen(text), \"%.3d \", msg->standardheader->mcnt);\n\n    if ((flags & DLT_HEADER_SHOW_ECUID) == DLT_HEADER_SHOW_ECUID) {\n        /* print ecu id, use header extra if available, else storage header value */\n        if (DLT_IS_HTYP_WEID(msg->standardheader->htyp))\n            dlt_print_id(text + strlen(text), msg->headerextra.ecu);\n        else\n            dlt_print_id(text + strlen(text), msg->storageheader->ecu);\n    }\n\n    /* print app id and context id if extended header available, else '----' */ #\n\n    if ((flags & DLT_HEADER_SHOW_APID) == DLT_HEADER_SHOW_APID) {\n        snprintf(text + strlen(text), textlength - strlen(text), \" \");\n\n        if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) && (msg->extendedheader->apid[0] != 0))\n            dlt_print_id(text + strlen(text), msg->extendedheader->apid);\n        else\n            snprintf(text + strlen(text), textlength - strlen(text), \"----\");\n\n        snprintf(text + strlen(text), textlength - strlen(text), \" \");\n    }\n\n    if ((flags & DLT_HEADER_SHOW_CTID) == DLT_HEADER_SHOW_CTID) {\n        if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) && (msg->extendedheader->ctid[0] != 0))\n            dlt_print_id(text + strlen(text), msg->extendedheader->ctid);\n        else\n            snprintf(text + strlen(text), textlength - strlen(text), \"----\");\n\n        snprintf(text + strlen(text), textlength - strlen(text), \" \");\n    }\n\n    /* print info about message type and length */\n    if (DLT_IS_HTYP_UEH(msg->standardheader->htyp)) {\n        if ((flags & DLT_HEADER_SHOW_MSGTYPE) == DLT_HEADER_SHOW_MSGTYPE) {\n            snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                     message_type[DLT_GET_MSIN_MSTP(msg->extendedheader->msin)]);\n            snprintf(text + strlen(text), textlength - strlen(text), \" \");\n        }\n\n        if ((flags & DLT_HEADER_SHOW_MSGSUBTYPE) == DLT_HEADER_SHOW_MSGSUBTYPE) {\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_LOG)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         log_info[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_APP_TRACE)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         trace_type[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_NW_TRACE)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         nw_trace_type[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            if ((DLT_GET_MSIN_MSTP(msg->extendedheader->msin)) == DLT_TYPE_CONTROL)\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         control_type[DLT_GET_MSIN_MTIN(msg->extendedheader->msin)]);\n\n            snprintf(text + strlen(text), textlength - strlen(text), \" \");\n        }\n\n        if ((flags & DLT_HEADER_SHOW_VNVSTATUS) == DLT_HEADER_SHOW_VNVSTATUS) {\n            /* print verbose status pf message */\n            if (DLT_IS_MSIN_VERB(msg->extendedheader->msin))\n                snprintf(text + strlen(text), textlength - strlen(text), \"V\");\n            else\n                snprintf(text + strlen(text), textlength - strlen(text), \"N\");\n\n            snprintf(text + strlen(text), textlength - strlen(text), \" \");\n        }\n\n        if ((flags & DLT_HEADER_SHOW_NOARG) == DLT_HEADER_SHOW_NOARG)\n            /* print number of arguments */\n            snprintf(text + strlen(text), textlength - strlen(text), \"%d\", msg->extendedheader->noar);\n    }\n    else {\n        if ((flags & DLT_HEADER_SHOW_MSGTYPE) == DLT_HEADER_SHOW_MSGTYPE)\n            snprintf(text + strlen(text), textlength - strlen(text), \"--- \");\n\n        if ((flags & DLT_HEADER_SHOW_MSGSUBTYPE) == DLT_HEADER_SHOW_MSGSUBTYPE)\n            snprintf(text + strlen(text), textlength - strlen(text), \"--- \");\n\n        if ((flags & DLT_HEADER_SHOW_VNVSTATUS) == DLT_HEADER_SHOW_VNVSTATUS)\n            snprintf(text + strlen(text), textlength - strlen(text), \"N \");\n\n        if ((flags & DLT_HEADER_SHOW_NOARG) == DLT_HEADER_SHOW_NOARG)\n            snprintf(text + strlen(text), textlength - strlen(text), \"-\");\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_payload(DltMessage *msg, char *text, size_t textlength, int type, int verbose)\n{\n    uint32_t id = 0, id_tmp = 0;\n    uint8_t retval = 0;\n\n    uint8_t *ptr;\n    int32_t datalength;\n\n    /* Pointer to ptr and datalength */\n    uint8_t **pptr;\n    int32_t *pdatalength;\n\n    int ret = 0;\n\n    int num;\n    uint32_t type_info = 0, type_info_tmp = 0;\n    int text_offset = 0;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (msg->databuffer == NULL) || (text == NULL) ||\n        (type < DLT_OUTPUT_HEX) || (type > DLT_OUTPUT_ASCII_LIMITED))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (textlength <= 0) {\n        dlt_log(LOG_WARNING, \"String does not fit binary data!\\n\");\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    /* start with empty string */\n    text[0] = 0;\n\n    /* print payload only as hex */\n    if (type == DLT_OUTPUT_HEX)\n        return dlt_print_hex_string(text, (int)textlength, msg->databuffer, (int)msg->datasize);\n\n    /* print payload as mixed */\n    if (type == DLT_OUTPUT_MIXED_FOR_PLAIN)\n        return dlt_print_mixed_string(text, (int)textlength, msg->databuffer, (int)msg->datasize, 0);\n\n    if (type == DLT_OUTPUT_MIXED_FOR_HTML)\n        return dlt_print_mixed_string(text, (int)textlength, msg->databuffer, (int)msg->datasize, 1);\n\n    ptr = msg->databuffer;\n    datalength = (int32_t)msg->datasize;\n\n    /* Pointer to ptr and datalength */\n    pptr = &ptr;\n    pdatalength = &datalength;\n\n    /* non-verbose mode */\n\n    /* print payload as hex */\n    if (DLT_MSG_IS_NONVERBOSE(msg)) {\n\n        DLT_MSG_READ_VALUE(id_tmp, ptr, datalength, uint32_t);\n        id = DLT_ENDIAN_GET_32(msg->standardheader->htyp, id_tmp);\n\n        if (textlength < (((unsigned int)datalength * 3) + 20)) {\n            dlt_vlog(LOG_WARNING,\n                     \"String does not fit binary data (available=%d, required=%d) !\\n\",\n                     (int) textlength, (datalength * 3) + 20);\n            return DLT_RETURN_ERROR;\n        }\n\n        /* process message id / service id */\n        if (DLT_MSG_IS_CONTROL(msg)) {\n            if ((id > 0) && (id < DLT_SERVICE_ID_LAST_ENTRY))\n                snprintf(text + strlen(text), textlength - strlen(text), \"%s\",\n                         service_id_name[id]); /* service id */\n            else if (!(DLT_MSG_IS_CONTROL_TIME(msg)))\n                snprintf(text + strlen(text), textlength - strlen(text), \"service(%u)\", id); /* service id */\n\n            if (datalength > 0)\n                snprintf(text + strlen(text), textlength - strlen(text), \", \");\n        }\n        else {\n            snprintf(text + strlen(text), textlength - strlen(text), \"%u, \", id); /* message id */\n        }\n\n        /* process return value */\n        if (DLT_MSG_IS_CONTROL_RESPONSE(msg)) {\n            if (datalength > 0) {\n                DLT_MSG_READ_VALUE(retval, ptr, datalength, uint8_t); /* No endian conversion necessary */\n\n                if ((retval < DLT_SERVICE_RESPONSE_LAST) || (retval == 8))\n                    snprintf(text + strlen(text), textlength - strlen(text), \"%s\", return_type[retval]);\n                else\n                    snprintf(text + strlen(text), textlength - strlen(text), \"%.2x\", retval);\n\n                if (datalength >= 1)\n                    snprintf(text + strlen(text), textlength - strlen(text), \", \");\n            }\n        }\n\n        if (type == DLT_OUTPUT_ASCII_LIMITED) {\n            ret = dlt_print_hex_string(text + strlen(text),\n                                       (int)(textlength - strlen(\n                                                 text)),\n                                       ptr,\n                                       (datalength >\n                                        DLT_COMMON_ASCII_LIMIT_MAX_CHARS ? DLT_COMMON_ASCII_LIMIT_MAX_CHARS : datalength));\n\n            if ((datalength > DLT_COMMON_ASCII_LIMIT_MAX_CHARS) &&\n                ((textlength - strlen(text)) > 4))\n                snprintf(text + strlen(text), textlength - strlen(text), \" ...\");\n        }\n        else {\n            ret = dlt_print_hex_string(text + strlen(text), (int)(textlength - strlen(text)), ptr, datalength);\n        }\n\n        return ret;\n    }\n\n    /* At this point, it is ensured that a extended header is available */\n\n    /* verbose mode */\n    type_info = 0;\n    type_info_tmp = 0;\n\n    for (num = 0; num < (int)(msg->extendedheader->noar); num++) {\n        if (num != 0) {\n            text_offset = (int)strlen(text);\n            snprintf(text + text_offset, textlength - (size_t)text_offset, \" \");\n        }\n\n        /* first read the type info of the argument */\n        DLT_MSG_READ_VALUE(type_info_tmp, ptr, datalength, uint32_t);\n        type_info = DLT_ENDIAN_GET_32(msg->standardheader->htyp, type_info_tmp);\n\n        /* print out argument */\n        text_offset = (int)strlen(text);\n\n        if (dlt_message_argument_print(msg, type_info, pptr, pdatalength,\n                                       (text + text_offset), (textlength - (size_t)text_offset), -1,\n                                       0) == DLT_RETURN_ERROR)\n            return DLT_RETURN_ERROR;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_filter_check(DltMessage *msg, DltFilter *filter, int verbose)\n{\n    /* check the filters if message is used */\n    int num;\n    DltReturnValue found = DLT_RETURN_OK;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (filter == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((filter->counter == 0) || (!(DLT_IS_HTYP_UEH(msg->standardheader->htyp))))\n        /* no filter is set, or no extended header is available, so do as filter is matching */\n        return DLT_RETURN_TRUE;\n\n    for (num = 0; num < filter->counter; num++)\n        /* check each filter if it matches */\n        if ((DLT_IS_HTYP_UEH(msg->standardheader->htyp)) &&\n            ((filter->apid[num][0] == 0) || (memcmp(filter->apid[num], msg->extendedheader->apid, DLT_ID_SIZE) == 0)) &&\n            ((filter->ctid[num][0] == 0) || (memcmp(filter->ctid[num], msg->extendedheader->ctid, DLT_ID_SIZE) == 0)) &&\n            ((filter->log_level[num] == 0) ||\n             (filter->log_level[num] == DLT_GET_MSIN_MTIN(msg->extendedheader->msin))) &&\n            ((filter->payload_min[num] == 0) || (filter->payload_min[num] <= msg->datasize)) &&\n            ((filter->payload_max[num] == 0) || (filter->payload_max[num] >= msg->datasize))) {\n            found = DLT_RETURN_TRUE;\n            break;\n        }\n\n    return found;\n}\n\nint dlt_message_read(DltMessage *msg, uint8_t *buffer, unsigned int length, int resync, int verbose)\n{\n    uint32_t extra_size = 0;\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((msg == NULL) || (buffer == NULL) || (length <= 0))\n        return DLT_MESSAGE_ERROR_UNKNOWN;\n\n    /* initialize resync_offset */\n    msg->resync_offset = 0;\n\n    /* check if message contains serial header, smaller than standard header */\n    if (length < sizeof(dltSerialHeader))\n        /* dlt_log(LOG_ERR, \"Length smaller than serial header!\\n\"); */\n        return DLT_MESSAGE_ERROR_SIZE;\n\n    if (memcmp(buffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {\n        /* serial header found */\n        msg->found_serialheader = 1;\n        buffer += sizeof(dltSerialHeader);\n        length -= (unsigned int)sizeof(dltSerialHeader);\n    }\n    else {\n        /* serial header not found */\n        msg->found_serialheader = 0;\n\n        if (resync) {\n            /* resync if necessary */\n            msg->resync_offset = 0;\n\n            do {\n                if (memcmp(buffer + msg->resync_offset, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {\n                    /* serial header found */\n                    msg->found_serialheader = 1;\n                    buffer += sizeof(dltSerialHeader);\n                    length -= (unsigned int)sizeof(dltSerialHeader);\n                    break;\n                }\n\n                msg->resync_offset++;\n            } while ((sizeof(dltSerialHeader) + (size_t)msg->resync_offset) <= length);\n\n            /* Set new start offset */\n            if (msg->resync_offset > 0) {\n                /* Resyncing connection */\n                buffer += msg->resync_offset;\n                length -= (unsigned int)msg->resync_offset;\n            }\n        }\n    }\n\n    /* check that standard header fits buffer */\n    if (length < sizeof(DltStandardHeader))\n        /* dlt_log(LOG_ERR, \"Length smaller than standard header!\\n\"); */\n        return DLT_MESSAGE_ERROR_SIZE;\n\n    memcpy(msg->headerbuffer + sizeof(DltStorageHeader), buffer, sizeof(DltStandardHeader));\n\n    /* set ptrs to structures */\n    msg->storageheader = (DltStorageHeader *)msg->headerbuffer;\n    msg->standardheader = (DltStandardHeader *)(msg->headerbuffer + sizeof(DltStorageHeader));\n\n    /* calculate complete size of headers */\n    extra_size = (uint32_t) (DLT_STANDARD_HEADER_EXTRA_SIZE(msg->standardheader->htyp) +\n        (DLT_IS_HTYP_UEH(msg->standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));\n    msg->headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) + extra_size);\n    msg->datasize = (uint32_t) DLT_BETOH_16(msg->standardheader->len) - msg->headersize + (uint32_t) sizeof(DltStorageHeader);\n\n    /* calculate complete size of payload */\n    int32_t temp_datasize;\n    temp_datasize = DLT_BETOH_16(msg->standardheader->len) - (int32_t) msg->headersize + (int32_t) sizeof(DltStorageHeader);\n\n    /* check data size */\n    if (temp_datasize < 0) {\n        dlt_vlog(LOG_WARNING,\n                 \"Plausibility check failed. Complete message size too short (%d)!\\n\",\n                 temp_datasize);\n        return DLT_MESSAGE_ERROR_CONTENT;\n    }\n    else {\n        msg->datasize = (uint32_t) temp_datasize;\n    }\n\n    /* check if verbose mode is on*/\n    if (verbose) {\n        dlt_vlog(LOG_DEBUG, \"BufferLength=%u, HeaderSize=%u, DataSize=%u\\n\",\n                 length, msg->headersize, msg->datasize);\n    }\n\n    /* load standard header extra parameters and Extended header if used */\n    if (extra_size > 0) {\n        if (length < (msg->headersize - sizeof(DltStorageHeader)))\n            return DLT_MESSAGE_ERROR_SIZE;\n\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n               buffer + sizeof(DltStandardHeader), (size_t)extra_size);\n\n        /* set extended header ptr and get standard header extra parameters */\n        if (DLT_IS_HTYP_UEH(msg->standardheader->htyp))\n            msg->extendedheader =\n                (DltExtendedHeader *)(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n                                      DLT_STANDARD_HEADER_EXTRA_SIZE(msg->standardheader->htyp));\n        else\n            msg->extendedheader = NULL;\n\n        dlt_message_get_extraparameters(msg, verbose);\n    }\n\n    /* check if payload fits length */\n    if (length < (msg->headersize - sizeof(DltStorageHeader) + msg->datasize))\n        /* dlt_log(LOG_ERR,\"length does not fit!\\n\"); */\n        return DLT_MESSAGE_ERROR_SIZE;\n\n    /* free last used memory for buffer */\n    if (msg->databuffer) {\n        if (msg->datasize > msg->databuffersize) {\n            free(msg->databuffer);\n            msg->databuffer = (uint8_t *)malloc(msg->datasize);\n            msg->databuffersize = msg->datasize;\n        }\n    }\n    else {\n        /* get new memory for buffer */\n        msg->databuffer = (uint8_t *)malloc(msg->datasize);\n        msg->databuffersize = msg->datasize;\n    }\n\n    if (msg->databuffer == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"Cannot allocate memory for payload buffer of size %u!\\n\",\n                 msg->datasize);\n        return DLT_MESSAGE_ERROR_UNKNOWN;\n    }\n\n    /* load payload data from buffer */\n    memcpy(msg->databuffer, buffer + (msg->headersize - sizeof(DltStorageHeader)), msg->datasize);\n\n    return DLT_MESSAGE_ERROR_OK;\n}\n\nDltReturnValue dlt_message_get_extraparameters(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (DLT_IS_HTYP_WEID(msg->standardheader->htyp))\n        memcpy(msg->headerextra.ecu,\n               msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n               DLT_ID_SIZE);\n\n    if (DLT_IS_HTYP_WSID(msg->standardheader->htyp)) {\n        memcpy(&(msg->headerextra.seid), msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0), DLT_SIZE_WSID);\n        msg->headerextra.seid = DLT_BETOH_32(msg->headerextra.seid);\n    }\n\n    if (DLT_IS_HTYP_WTMS(msg->standardheader->htyp)) {\n        memcpy(&(msg->headerextra.tmsp), msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0)\n               + (DLT_IS_HTYP_WSID(msg->standardheader->htyp) ? DLT_SIZE_WSID : 0), DLT_SIZE_WTMS);\n        msg->headerextra.tmsp = DLT_BETOH_32(msg->headerextra.tmsp);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_set_extraparameters(DltMessage *msg, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (msg == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (DLT_IS_HTYP_WEID(msg->standardheader->htyp))\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n               msg->headerextra.ecu,\n               DLT_ID_SIZE);\n\n    if (DLT_IS_HTYP_WSID(msg->standardheader->htyp)) {\n        msg->headerextra.seid = DLT_HTOBE_32(msg->headerextra.seid);\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0),\n               &(msg->headerextra.seid),\n               DLT_SIZE_WSID);\n    }\n\n    if (DLT_IS_HTYP_WTMS(msg->standardheader->htyp)) {\n        msg->headerextra.tmsp = DLT_HTOBE_32(msg->headerextra.tmsp);\n        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader)\n               + (DLT_IS_HTYP_WEID(msg->standardheader->htyp) ? DLT_SIZE_WEID : 0)\n               + (DLT_IS_HTYP_WSID(msg->standardheader->htyp) ? DLT_SIZE_WSID : 0),\n               &(msg->headerextra.tmsp),\n               DLT_SIZE_WTMS);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_init(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* initalise structure parameters */\n    file->handle = NULL;\n    file->counter = 0;\n    file->counter_total = 0;\n    file->index = NULL;\n\n    file->filter = NULL;\n    file->filter_counter = 0;\n    file->file_position = 0;\n\n    file->position = 0;\n\n    file->error_messages = 0;\n\n    return dlt_message_init(&(file->msg), verbose);\n}\n\nDltReturnValue dlt_file_set_filter(DltFile *file, DltFilter *filter, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* set filter */\n    file->filter = filter;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_header(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Loop until storage header is found */\n    while (1) {\n        /* load header from file */\n        if (fread(file->msg.headerbuffer,\n                  sizeof(DltStorageHeader) + sizeof(DltStandardHeader), 1,\n                  file->handle) != 1) {\n            if (!feof(file->handle))\n                dlt_log(LOG_WARNING, \"Cannot read header from file!\\n\");\n            else\n                dlt_log(LOG_DEBUG, \"Reached end of file\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n\n        /* set ptrs to structures */\n        file->msg.storageheader = (DltStorageHeader *)file->msg.headerbuffer;\n        file->msg.standardheader = (DltStandardHeader *)(file->msg.headerbuffer +\n                                                         sizeof(DltStorageHeader));\n\n        /* check id of storage header */\n        if (dlt_check_storageheader(file->msg.storageheader) != DLT_RETURN_TRUE) {\n            /* Shift the position back to the place where it stared to read + 1 */\n            if (fseek(file->handle,\n                      (long) (1 - (sizeof(DltStorageHeader) + sizeof(DltStandardHeader))),\n                      SEEK_CUR) < 0) {\n                dlt_log(LOG_WARNING, \"DLT storage header pattern not found!\\n\");\n                return DLT_RETURN_ERROR;\n            }\n        }\n        else {\n            /* storage header is found */\n            break;\n        }\n    }\n\n    /* calculate complete size of headers */\n    file->msg.headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n        DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp) +\n        (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));\n\n    /* calculate complete size of payload */\n    int32_t temp_datasize;\n    temp_datasize = DLT_BETOH_16(file->msg.standardheader->len) + (int32_t) sizeof(DltStorageHeader) - (int32_t) file->msg.headersize;\n\n    /* check data size */\n    if (temp_datasize < 0) {\n        dlt_vlog(LOG_WARNING,\n                 \"Plausibility check failed. Complete message size too short! (%d)\\n\",\n                 temp_datasize);\n        return DLT_RETURN_ERROR;\n    } else {\n        file->msg.datasize = (uint32_t) temp_datasize;\n    }\n\n    /* check if verbose mode is on */\n    if (verbose) {\n        dlt_vlog(LOG_DEBUG, \"HeaderSize=%u, DataSize=%u\\n\",\n                 file->msg.headersize, file->msg.datasize);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_header_raw(DltFile *file, int resync, int verbose)\n{\n    char dltSerialHeaderBuffer[DLT_ID_SIZE];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if serial header exists, ignore if found */\n    if (fread(dltSerialHeaderBuffer, sizeof(dltSerialHeaderBuffer), 1, file->handle) != 1) {\n        /* cannot read serial header, not enough data available in file */\n        if (!feof(file->handle))\n            dlt_log(LOG_WARNING, \"Cannot read header from file!\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    if (memcmp(dltSerialHeaderBuffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {\n        /* serial header found */\n        /* nothing to do continue reading */\n\n    }\n    else {\n        /* serial header not found */\n        if (resync) {\n            /* increase error counter */\n            file->error_messages++;\n\n            /* resync to serial header */\n            do {\n                memmove(dltSerialHeaderBuffer, dltSerialHeaderBuffer + 1, sizeof(dltSerialHeader) - 1);\n\n                if (fread(dltSerialHeaderBuffer + 3, 1, 1, file->handle) != 1)\n                    /* cannot read any data, perhaps end of file reached */\n                    return DLT_RETURN_ERROR;\n\n                if (memcmp(dltSerialHeaderBuffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0)\n                    /* serial header synchronised */\n                    break;\n            } while (1);\n        }\n        else\n        /* go back to last file position */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n        {\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    /* load header from file */\n    if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader), sizeof(DltStandardHeader), 1, file->handle) != 1) {\n        if (!feof(file->handle))\n            dlt_log(LOG_WARNING, \"Cannot read header from file!\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    /* set ptrs to structures */\n    file->msg.storageheader = (DltStorageHeader *)file->msg.headerbuffer; /* this points now to a empty storage header (filled with '0') */\n    file->msg.standardheader = (DltStandardHeader *)(file->msg.headerbuffer + sizeof(DltStorageHeader));\n\n    /* Skip storage header field, fill this field with '0' */\n    memset(file->msg.storageheader, 0, sizeof(DltStorageHeader));\n\n    /* Set storage header */\n    dlt_set_storageheader(file->msg.storageheader, DLT_COMMON_DUMMY_ECUID);\n\n    /* no check for storage header id*/\n\n    /* calculate complete size of headers */\n    file->msg.headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n        DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp) +\n        (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));\n\n    /* calculate complete size of payload */\n    int32_t temp_datasize;\n    temp_datasize = DLT_BETOH_16(file->msg.standardheader->len) + (int32_t) sizeof(DltStorageHeader) - (int32_t) file->msg.headersize;\n\n    /* check data size */\n    if (temp_datasize < 0) {\n        dlt_vlog(LOG_WARNING,\n                 \"Plausibility check failed. Complete message size too short! (%d)\\n\",\n                 temp_datasize);\n        return DLT_RETURN_ERROR;\n    }\n    else {\n        file->msg.datasize = (uint32_t) temp_datasize;\n    }\n\n    /* check if verbose mode is on */\n    if (verbose) {\n        dlt_vlog(LOG_DEBUG, \"HeaderSize=%u, DataSize=%u\\n\",\n                 file->msg.headersize, file->msg.datasize);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_header_extended(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* load standard header extra parameters if used */\n    if (DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp)) {\n        if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),\n                  DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp),\n                  1, file->handle) != 1) {\n            dlt_log(LOG_WARNING, \"Cannot read standard header extra parameters from file!\\n\");\n            return DLT_RETURN_ERROR;\n        }\n\n        dlt_message_get_extraparameters(&(file->msg), verbose);\n    }\n\n    /* load Extended header if used */\n    if (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) == 0)\n        /* there is nothing to be loaded */\n        return DLT_RETURN_OK;\n\n    if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n              DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp),\n              (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0),\n              1, file->handle) != 1) {\n        dlt_log(LOG_WARNING, \"Cannot read extended header from file!\\n\");\n        return DLT_RETURN_ERROR;\n    }\n\n    /* set extended header ptr */\n    if (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp))\n        file->msg.extendedheader =\n            (DltExtendedHeader *)(file->msg.headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +\n                                  DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp));\n    else\n        file->msg.extendedheader = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read_data(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* free last used memory for buffer */\n    if (file->msg.databuffer && (file->msg.databuffersize < file->msg.datasize)) {\n        free(file->msg.databuffer);\n        file->msg.databuffer = NULL;\n    }\n\n    if (file->msg.databuffer == NULL) {\n        /* get new memory for buffer */\n        file->msg.databuffer = (uint8_t *)malloc(file->msg.datasize);\n        file->msg.databuffersize = file->msg.datasize;\n    }\n\n    if (file->msg.databuffer == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"Cannot allocate memory for payload buffer of size %u!\\n\",\n                 file->msg.datasize);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* load payload data from file */\n    if (fread(file->msg.databuffer, file->msg.datasize, 1, file->handle) != 1) {\n        if (file->msg.datasize != 0) {\n            dlt_vlog(LOG_WARNING,\n                     \"Cannot read payload data from file of size %u!\\n\",\n                     file->msg.datasize);\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_open(DltFile *file, const char *filename, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if ((file == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* reset counters */\n    file->counter = 0;\n    file->counter_total = 0;\n    file->position = 0;\n    file->file_position = 0;\n    file->file_length = 0;\n    file->error_messages = 0;\n\n    if (file->handle)\n        fclose(file->handle);\n\n    /* open dlt file */\n    file->handle = fopen(filename, \"rb\");\n\n    if (file->handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"File %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    if (0 != fseek(file->handle, 0, SEEK_END)) {\n        dlt_vlog(LOG_WARNING, \"dlt_file_open: Seek failed to 0,SEEK_END\");\n        return DLT_RETURN_ERROR;\n    }\n\n    file->file_length = ftell(file->handle);\n\n    if (0 != fseek(file->handle, 0, SEEK_SET)) {\n        dlt_vlog(LOG_WARNING, \"dlt_file_open: Seek failed to 0,SEEK_SET\");\n        return DLT_RETURN_ERROR;\n    }\n\n    if (verbose)\n        /* print file length */\n        dlt_vlog(LOG_DEBUG, \"File is %\" PRIu64 \"bytes long\\n\", file->file_length);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_read(DltFile *file, int verbose)\n{\n    long *ptr;\n    int found = DLT_RETURN_OK;\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (verbose)\n        dlt_vlog(LOG_DEBUG, \"%s: Message %d:\\n\", __func__, file->counter_total);\n\n    /* allocate new memory for index if number of messages exceeds a multiple of DLT_COMMON_INDEX_ALLOC (e.g.: 1000) */\n    if (file->counter % DLT_COMMON_INDEX_ALLOC == 0) {\n        ptr = (long *)malloc(((file->counter / DLT_COMMON_INDEX_ALLOC) + 1) * DLT_COMMON_INDEX_ALLOC * sizeof(long));\n\n        if (ptr == NULL)\n            return DLT_RETURN_ERROR;\n\n        if (file->index) {\n            memcpy(ptr, file->index, (size_t)(file->counter) * sizeof(long));\n            free(file->index);\n        }\n\n        file->index = ptr;\n    }\n\n    /* set to end of last succesful read message, because of conflicting calls to dlt_file_read and dlt_file_message */\n    if (0 != fseek(file->handle, file->file_position, SEEK_SET)) {\n        dlt_vlog(LOG_WARNING, \"Seek failed to file_position %\" PRIu64 \"\\n\",\n                 file->file_position);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* get file position at start of DLT message */\n    if (verbose)\n        dlt_vlog(LOG_INFO, \"Position in file: %\" PRIu64 \"\\n\", file->file_position);\n\n    /* read header */\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        fseek(file->handle, file->file_position, SEEK_SET);\n        return DLT_RETURN_ERROR;\n    }\n\n    if (file->filter) {\n        /* read the extended header if filter is enabled and extended header exists */\n        if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) {\n            /* go back to last position in file */\n            if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n                dlt_vlog(LOG_WARNING, \"Seek to last file pos failed!\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n\n        /* check the filters if message is used */\n        if (dlt_message_filter_check(&(file->msg), file->filter, verbose) == DLT_RETURN_TRUE) {\n            /* filter matched, consequently store current message */\n            /* store index pointer to message position in DLT file */\n            file->index[file->counter] = file->file_position;\n            file->counter++;\n            file->position = file->counter - 1;\n\n            found = DLT_RETURN_TRUE;\n        }\n\n        /* skip payload data */\n        if (fseek(file->handle, file->msg.datasize, SEEK_CUR) != 0) {\n            /* go back to last position in file */\n            dlt_vlog(LOG_WARNING,\n                     \"Seek failed to skip payload data of size %u!\\n\",\n                     file->msg.datasize);\n\n            if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n                dlt_log(LOG_WARNING, \"Seek back also failed!\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n    }\n    else {\n        /* filter is disabled */\n        /* skip additional header parameters and payload data */\n        if (fseek(file->handle,\n                  (long) (file->msg.headersize - sizeof(DltStorageHeader) - sizeof(DltStandardHeader) + file->msg.datasize),\n                  SEEK_CUR)) {\n\n            dlt_vlog(LOG_WARNING,\n                     \"Seek failed to skip extra header and payload data from file of size %u!\\n\",\n                     file->msg.headersize - (int32_t)sizeof(DltStorageHeader) -\n                     (int32_t)sizeof(DltStandardHeader) + file->msg.datasize);\n\n            /* go back to last position in file */\n            if (fseek(file->handle, file->file_position, SEEK_SET))\n                dlt_log(LOG_WARNING, \"Seek back also failed!\\n\");\n\n            return DLT_RETURN_ERROR;\n        }\n\n        /* store index pointer to message position in DLT file */\n        file->index[file->counter] = file->file_position;\n        file->counter++;\n        file->position = file->counter - 1;\n\n        found = DLT_RETURN_TRUE;\n    }\n\n    /* increase total message counter */\n    file->counter_total++;\n\n    /* store position to next message */\n    file->file_position = ftell(file->handle);\n\n    return found;\n}\n\nDltReturnValue dlt_file_read_raw(DltFile *file, int resync, int verbose)\n{\n    int found = DLT_RETURN_OK;\n    long *ptr;\n\n    if (verbose)\n        dlt_vlog(LOG_DEBUG, \"%s: Message %d:\\n\", __func__, file->counter_total);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* allocate new memory for index if number of messages exceeds a multiple of DLT_COMMON_INDEX_ALLOC (e.g.: 1000) */\n    if (file->counter % DLT_COMMON_INDEX_ALLOC == 0) {\n        ptr = (long *)malloc(((file->counter / DLT_COMMON_INDEX_ALLOC) + 1) * DLT_COMMON_INDEX_ALLOC * sizeof(long));\n\n        if (ptr == NULL)\n            return DLT_RETURN_ERROR;\n\n        if (file->index) {\n            memcpy(ptr, file->index, (size_t)(file->counter) * sizeof(long));\n            free(file->index);\n        }\n\n        file->index = ptr;\n    }\n\n    /* set to end of last successful read message, because of conflicting calls to dlt_file_read and dlt_file_message */\n    if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n        return DLT_RETURN_ERROR;\n\n    /* get file position at start of DLT message */\n    if (verbose)\n        dlt_vlog(LOG_DEBUG, \"Position in file: %\" PRIu64 \"\\n\", file->file_position);\n\n    /* read header */\n    if (dlt_file_read_header_raw(file, resync, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n            dlt_log(LOG_WARNING, \"dlt_file_read_raw, fseek failed 1\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    /* read the extended header if filter is enabled and extended header exists */\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n            dlt_log(LOG_WARNING, \"dlt_file_read_raw, fseek failed 2\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK) {\n        /* go back to last position in file */\n        if (0 != fseek(file->handle, file->file_position, SEEK_SET))\n            dlt_log(LOG_WARNING, \"dlt_file_read_raw, fseek failed 3\\n\");\n\n        return DLT_RETURN_ERROR;\n    }\n\n    /* store index pointer to message position in DLT file */\n    file->index[file->counter] = file->file_position;\n    file->counter++;\n    file->position = file->counter - 1;\n\n    found = DLT_RETURN_TRUE;\n\n    /* increase total message counter */\n    file->counter_total++;\n\n    /* store position to next message */\n    file->file_position = ftell(file->handle);\n\n    return found;\n}\n\nDltReturnValue dlt_file_close(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (file->handle)\n        fclose(file->handle);\n\n    file->handle = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_message(DltFile *file, int index, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if message is in range */\n    if (index < 0 || index >= file->counter) {\n        dlt_vlog(LOG_WARNING, \"Message %d out of range!\\r\\n\", index);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    /* seek to position in file */\n    if (fseek(file->handle, file->index[index], SEEK_SET) != 0) {\n        dlt_vlog(LOG_WARNING, \"Seek to message %d to position %ld failed!\\r\\n\",\n                 index, file->index[index]);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* read all header and payload */\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    /* set current position in file */\n    file->position = index;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_file_free(DltFile *file, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* delete index lost if exists */\n    if (file->index)\n        free(file->index);\n\n    file->index = NULL;\n\n    /* close file */\n    if (file->handle)\n        fclose(file->handle);\n\n    file->handle = NULL;\n\n    return dlt_message_free(&(file->msg), verbose);\n}\n\nvoid dlt_log_set_level(int level)\n{\n    if ((level < 0) || (level > LOG_DEBUG)) {\n        if (logging_level < LOG_WARNING)\n            logging_level = LOG_WARNING;\n\n        dlt_vlog(LOG_WARNING, \"Wrong parameter for level: %d\\n\", level);\n    }\n    else {\n        logging_level = level;\n    }\n}\n\nvoid dlt_log_set_filename(const char *filename)\n{\n    /* check nullpointer */\n    if (filename == NULL) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: filename is NULL\\n\");\n        return;\n    }\n\n    strncpy(logging_filename, filename, NAME_MAX);\n    logging_filename[NAME_MAX] = 0;\n}\n\n#if defined DLT_DAEMON_USE_FIFO_IPC || defined DLT_LIB_USE_FIFO_IPC\nvoid dlt_log_set_fifo_basedir(const char *pipe_dir)\n{\n    strncpy(dltFifoBaseDir, pipe_dir, DLT_PATH_MAX);\n    dltFifoBaseDir[DLT_PATH_MAX - 1] = 0;\n}\n#endif\n\n#ifdef DLT_SHM_ENABLE\nvoid dlt_log_set_shm_name(const char *env_shm_name)\n{\n    strncpy(dltShmName, env_shm_name, NAME_MAX);\n    dltShmName[NAME_MAX] = 0;\n}\n#endif\n\nvoid dlt_print_with_attributes(bool state)\n{\n    print_with_attributes = state;\n}\n\nDltReturnValue dlt_log_init(int mode)\n{\n    if ((mode < DLT_LOG_TO_CONSOLE) || (mode > DLT_LOG_DROPPED)) {\n        dlt_user_printf(\"Wrong parameter for mode: %d\\n\", mode);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    logging_mode = mode;\n\n    if (logging_mode == DLT_LOG_TO_FILE) {\n        /* internal logging to file */\n        logging_handle = fopen(logging_filename, \"a\");\n\n        if (logging_handle == NULL) {\n            dlt_user_printf(\"Internal log file %s cannot be opened!\\n\", logging_filename);\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    return DLT_RETURN_OK;\n}\n\nvoid dlt_log_free(void)\n{\n    if (logging_mode == DLT_LOG_TO_FILE && logging_handle)\n        fclose(logging_handle);\n}\n\nint dlt_user_printf(const char *format, ...)\n{\n    va_list args;\n    va_start(args, format);\n\n    int ret = 0;\n\n    switch (logging_mode) {\n    case DLT_LOG_TO_CONSOLE:\n    case DLT_LOG_TO_SYSLOG:\n    case DLT_LOG_TO_FILE:\n    case DLT_LOG_DROPPED:\n    default:\n        ret = vfprintf(stdout, format, args);\n        break;\n    case DLT_LOG_TO_STDERR:\n        ret = vfprintf(stderr, format, args);\n        break;\n    }\n\n    va_end(args);\n\n    return ret;\n}\n\nDltReturnValue dlt_log(int prio, char *s)\n{\n    static const char asSeverity[LOG_DEBUG +\n                                 2][11] =\n    { \"EMERGENCY\", \"ALERT    \", \"CRITICAL \", \"ERROR    \", \"WARNING  \", \"NOTICE   \", \"INFO     \", \"DEBUG    \",\n      \"         \" };\n    static const char sFormatString[] = \"[%5u.%06u]~DLT~%5d~%s~%s\";\n    struct timespec sTimeSpec;\n\n    if (s == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (logging_level < prio)\n        return DLT_RETURN_OK;\n\n    if ((prio < 0) || (prio > LOG_DEBUG))\n        prio = LOG_DEBUG + 1;\n\n    clock_gettime(CLOCK_MONOTONIC, &sTimeSpec);\n\n    switch (logging_mode) {\n    case DLT_LOG_TO_CONSOLE:\n        /* log to stdout */\n        fprintf(stdout, sFormatString,\n                (unsigned int)sTimeSpec.tv_sec,\n                (unsigned int)(sTimeSpec.tv_nsec / 1000),\n                getpid(),\n                asSeverity[prio],\n                s);\n        fflush(stdout);\n        break;\n    case DLT_LOG_TO_STDERR:\n        /* log to stderr */\n        fprintf(stderr, sFormatString,\n                (unsigned int)sTimeSpec.tv_sec,\n                (unsigned int)(sTimeSpec.tv_nsec / 1000),\n                getpid(),\n                asSeverity[prio],\n                s);\n        break;\n    case DLT_LOG_TO_SYSLOG:\n        /* log to syslog */\n#if !defined (__WIN32__) && !defined(_MSC_VER)\n        openlog(\"DLT\", LOG_PID, LOG_DAEMON);\n        syslog(prio,\n               sFormatString,\n               (unsigned int)sTimeSpec.tv_sec,\n               (unsigned int)(sTimeSpec.tv_nsec / 1000),\n               getpid(),\n               asSeverity[prio],\n               s);\n        closelog();\n#endif\n        break;\n    case DLT_LOG_TO_FILE:\n\n        /* log to file */\n        if (logging_handle) {\n            fprintf(logging_handle, sFormatString, (unsigned int)sTimeSpec.tv_sec,\n                    (unsigned int)(sTimeSpec.tv_nsec / 1000), getpid(), asSeverity[prio], s);\n            fflush(logging_handle);\n        }\n\n        break;\n    case DLT_LOG_DROPPED:\n    default:\n        break;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_vlog(int prio, const char *format, ...)\n{\n    char outputString[2048] = { 0 }; /* TODO: what is a reasonable string length here? */\n\n    va_list args;\n\n    if (format == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (logging_level < prio)\n        return DLT_RETURN_OK;\n\n    va_start(args, format);\n    vsnprintf(outputString, 2047, format, args);\n    va_end(args);\n\n    dlt_log(prio, outputString);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_vnlog(int prio, size_t size, const char *format, ...)\n{\n    char *outputString = NULL;\n\n    va_list args;\n\n    if (format == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((logging_level < prio) || (size == 0))\n        return DLT_RETURN_OK;\n\n    if ((outputString = (char *)calloc(size + 1, sizeof(char))) == NULL)\n        return DLT_RETURN_ERROR;\n\n    va_start(args, format);\n    vsnprintf(outputString, size, format, args);\n    va_end(args);\n\n    dlt_log(prio, outputString);\n\n    free(outputString);\n    outputString = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_init(DltReceiver *receiver, int fd, DltReceiverType type, int buffersize)\n{\n    if (NULL == receiver)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    receiver->fd = fd;\n    receiver->type = type;\n\n    /** Reuse the receiver buffer if it exists and the buffer size\n      * is not changed. If not, free the old one and allocate a new buffer.\n      */\n    if ((NULL != receiver->buffer) && ( buffersize != receiver->buffersize)) {\n       free(receiver->buffer);\n       receiver->buffer = NULL;\n    }\n\n    if (NULL == receiver->buffer) {\n        receiver->lastBytesRcvd = 0;\n        receiver->bytesRcvd = 0;\n        receiver->totalBytesRcvd = 0;\n        receiver->buf = NULL;\n        receiver->backup_buf = NULL;\n        receiver->buffer = (char *)calloc(1, (size_t)buffersize);\n        receiver->buffersize = (uint32_t)buffersize;\n    }\n\n    if (NULL == receiver->buffer) {\n        dlt_log(LOG_ERR, \"allocate memory for receiver buffer failed.\\n\");\n        return DLT_RETURN_ERROR;\n    }\n    else {\n        receiver->buf = receiver->buffer;\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_init_global_buffer(DltReceiver *receiver, int fd, DltReceiverType type, char **buffer)\n{\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (*buffer == NULL) {\n        /* allocating the buffer once and using it for all application receivers\n         * by keeping allocated buffer in app_recv_buffer global handle\n         */\n        *buffer = (char *)malloc(DLT_RECEIVE_BUFSIZE);\n\n        if (*buffer == NULL)\n            return DLT_RETURN_ERROR;\n    }\n\n    receiver->lastBytesRcvd = 0;\n    receiver->bytesRcvd = 0;\n    receiver->totalBytesRcvd = 0;\n    receiver->buffersize = DLT_RECEIVE_BUFSIZE;\n    receiver->fd = fd;\n    receiver->type = type;\n    receiver->buffer = *buffer;\n    receiver->backup_buf = NULL;\n    receiver->buf = receiver->buffer;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_free(DltReceiver *receiver)\n{\n\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (receiver->buffer)\n        free(receiver->buffer);\n\n    if (receiver->backup_buf)\n        free(receiver->backup_buf);\n\n    receiver->buffer = NULL;\n    receiver->buf = NULL;\n    receiver->backup_buf = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_free_global_buffer(DltReceiver *receiver)\n{\n\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (receiver->backup_buf)\n        free(receiver->backup_buf);\n\n    receiver->buffer = NULL;\n    receiver->buf = NULL;\n    receiver->backup_buf = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_receiver_receive(DltReceiver *receiver)\n{\n    socklen_t addrlen;\n\n    if (receiver == NULL)\n        return -1;\n\n    if (receiver->buffer == NULL)\n        return -1;\n\n    receiver->buf = (char *)receiver->buffer;\n    receiver->lastBytesRcvd = receiver->bytesRcvd;\n\n    if ((receiver->lastBytesRcvd) && (receiver->backup_buf != NULL)) {\n        memcpy(receiver->buf, receiver->backup_buf, (size_t)receiver->lastBytesRcvd);\n        free(receiver->backup_buf);\n        receiver->backup_buf = NULL;\n    }\n\n    if (receiver->type == DLT_RECEIVE_SOCKET)\n        /* wait for data from socket */\n        receiver->bytesRcvd = recv(receiver->fd,\n                                   receiver->buf + receiver->lastBytesRcvd,\n                                   receiver->buffersize - (uint32_t) receiver->lastBytesRcvd,\n                                   0);\n    else if (receiver->type == DLT_RECEIVE_FD)\n        /* wait for data from fd */\n        receiver->bytesRcvd = read(receiver->fd,\n                                   receiver->buf + receiver->lastBytesRcvd,\n                                   receiver->buffersize - (uint32_t) receiver->lastBytesRcvd);\n\n    else { /* receiver->type == DLT_RECEIVE_UDP_SOCKET */\n        /* wait for data from UDP socket */\n        addrlen = sizeof(receiver->addr);\n        receiver->bytesRcvd = recvfrom(receiver->fd,\n                                       receiver->buf + receiver->lastBytesRcvd,\n                                       receiver->buffersize - receiver->lastBytesRcvd,\n                                       0,\n                                       (struct sockaddr *)&(receiver->addr),\n                                       &addrlen);\n    }\n\n    if (receiver->bytesRcvd <= 0) {\n        receiver->bytesRcvd = 0;\n        return receiver->bytesRcvd;\n    } /* if */\n\n    receiver->totalBytesRcvd += receiver->bytesRcvd;\n    receiver->bytesRcvd += receiver->lastBytesRcvd;\n\n    return receiver->bytesRcvd;\n}\n\nDltReturnValue dlt_receiver_remove(DltReceiver *receiver, int size)\n{\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (receiver->buf == NULL)\n        return DLT_RETURN_ERROR;\n\n    if ((size > receiver->bytesRcvd) || (size <= 0)) {\n        receiver->buf = receiver->buf + receiver->bytesRcvd;\n        receiver->bytesRcvd = 0;\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    receiver->bytesRcvd = receiver->bytesRcvd - size;\n    receiver->buf = receiver->buf + size;\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_receiver_move_to_begin(DltReceiver *receiver)\n{\n    if (receiver == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((receiver->buffer == NULL) || (receiver->buf == NULL))\n        return DLT_RETURN_ERROR;\n\n    if ((receiver->buffer != receiver->buf) && (receiver->bytesRcvd != 0)) {\n        receiver->backup_buf = calloc((size_t)(receiver->bytesRcvd + 1), sizeof(char));\n\n        if (receiver->backup_buf == NULL)\n            dlt_vlog(LOG_WARNING,\n                     \"Can't allocate memory for backup buf, there will be atleast\"\n                     \"one corrupted message for fd[%d] \\n\", receiver->fd);\n        else\n            memcpy(receiver->backup_buf, receiver->buf, (size_t)receiver->bytesRcvd);\n    }\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_receiver_check_and_get(DltReceiver *receiver,\n                               void *dest,\n                               unsigned int to_get,\n                               unsigned int flags)\n{\n    size_t min_size = (size_t)to_get;\n    uint8_t *src = NULL;\n\n    if (flags & DLT_RCV_SKIP_HEADER)\n        min_size += sizeof(DltUserHeader);\n\n    if (!receiver ||\n        (receiver->bytesRcvd < (int32_t) min_size) ||\n        !receiver->buf ||\n        !dest)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    src = (uint8_t *)receiver->buf;\n\n    if (flags & DLT_RCV_SKIP_HEADER)\n        src += sizeof(DltUserHeader);\n\n    memcpy(dest, src, to_get);\n\n    if (flags & DLT_RCV_REMOVE) {\n        if (dlt_receiver_remove(receiver, (int)min_size) != DLT_RETURN_OK) {\n            dlt_log(LOG_WARNING, \"Can't remove bytes from receiver\\n\");\n            return DLT_RETURN_ERROR;\n        }\n    }\n\n    return to_get;\n}\n\nDltReturnValue dlt_set_storageheader(DltStorageHeader *storageheader, const char *ecu)\n{\n\n#if !defined(_MSC_VER)\n    struct timeval tv;\n#endif\n\n    if ((storageheader == NULL) || (ecu == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* get time of day */\n#if defined(_MSC_VER)\n    time(&(storageheader->seconds));\n#else\n    gettimeofday(&tv, NULL);\n#endif\n\n    /* prepare storage header */\n    storageheader->pattern[0] = 'D';\n    storageheader->pattern[1] = 'L';\n    storageheader->pattern[2] = 'T';\n    storageheader->pattern[3] = 0x01;\n\n    dlt_set_id(storageheader->ecu, ecu);\n\n    /* Set current time */\n#if defined(_MSC_VER)\n    storageheader->microseconds = 0;\n#else\n    storageheader->seconds = (uint32_t) tv.tv_sec; /* value is long */\n    storageheader->microseconds = (int32_t) tv.tv_usec; /* value is long */\n#endif\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_check_rcv_data_size(int received, int required)\n{\n    int _ret = DLT_RETURN_OK;\n    if (received < required) {\n        dlt_vlog(LOG_WARNING, \"%s: Received data not complete\\n\", __func__);\n        _ret = DLT_RETURN_ERROR;\n    }\n\n    return _ret;\n}\n\nDltReturnValue dlt_check_storageheader(DltStorageHeader *storageheader)\n{\n    if (storageheader == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    return ((storageheader->pattern[0] == 'D') &&\n            (storageheader->pattern[1] == 'L') &&\n            (storageheader->pattern[2] == 'T') &&\n            (storageheader->pattern[3] == 1))\n           ? DLT_RETURN_TRUE : DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_buffer_init_static_server(DltBuffer *buf, const unsigned char *ptr, uint32_t size)\n{\n    if ((buf == NULL) || (ptr == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    DltBufferHead *head;\n\n    /* Init parameters */\n    buf->shm = (unsigned char *)ptr;\n    buf->min_size = size;\n    buf->max_size = size;\n    buf->step_size = 0;\n\n    /* Init pointers */\n    head = (DltBufferHead *)buf->shm;\n    head->read = 0;\n    head->write = 0;\n    head->count = 0;\n    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));\n    buf->size = (unsigned int) buf->min_size - (unsigned int) sizeof(DltBufferHead);\n\n    /* clear memory */\n    memset(buf->mem, 0, buf->size);\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size %u, Start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_init_static_client(DltBuffer *buf, const unsigned char *ptr, uint32_t size)\n{\n    if ((buf == NULL) || (ptr == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Init parameters */\n    buf->shm = (unsigned char *)ptr;\n    buf->min_size = size;\n    buf->max_size = size;\n    buf->step_size = 0;\n\n    /* Init pointers */\n    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));\n    buf->size = (uint32_t)(buf->min_size - sizeof(DltBufferHead));\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size %u, Start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_init_dynamic(DltBuffer *buf, uint32_t min_size, uint32_t max_size, uint32_t step_size)\n{\n    /*Do not DLT_SEM_LOCK inside here! */\n    DltBufferHead *head;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* catch 0 logical errors */\n    if ((min_size == 0) || (max_size == 0) || (step_size == 0))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (min_size > max_size)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (step_size > max_size)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* Init parameters */\n    buf->min_size = min_size;\n    buf->max_size = max_size;\n    buf->step_size = step_size;\n\n    /* allocat memory */\n    buf->shm = malloc(buf->min_size);\n\n    if (buf->shm == NULL) {\n        dlt_vlog(LOG_EMERG,\n                 \"%s: Buffer: Cannot allocate %u bytes\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* Init pointers */\n    head = (DltBufferHead *)buf->shm;\n    head->read = 0;\n    head->write = 0;\n    head->count = 0;\n    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));\n\n    if (buf->min_size < (uint32_t)sizeof(DltBufferHead)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: min_size is too small [%u]\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    buf->size = (uint32_t) (buf->min_size - sizeof(DltBufferHead));\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size %u, Start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    /* clear memory */\n    memset(buf->mem, 0, (size_t)buf->size);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_free_static(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->mem == NULL) {\n        /* buffer not initialized */\n        dlt_vlog(LOG_WARNING, \"%s: Buffer: Buffer not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_buffer_free_dynamic(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->shm == NULL) {\n        /* buffer not initialized */\n        dlt_vlog(LOG_WARNING, \"%s: Buffer: Buffer not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    free(buf->shm);\n    buf->shm = NULL;\n    buf->mem = NULL;\n\n    return DLT_RETURN_OK;\n}\n\nvoid dlt_buffer_write_block(DltBuffer *buf, int *write, const unsigned char *data, unsigned int size)\n{\n    /* catch null pointer */\n    if ((buf != NULL) && (write != NULL) && (data != NULL)) {\n\tif (size <= buf->size){\n            if (( (unsigned int) (*write ) + size) <= buf->size) {\n                /* write one block */\n                memcpy(buf->mem + *write, data, size);\n                *write += (int) size;\n            }\n            else {\n                /* when (*write) = buf->size, write only the second block\n                * and update write position correspondingly.\n                */\n                if((unsigned int) (*write) <= buf->size) {\n                    /* write two blocks */\n                    memcpy(buf->mem + *write, data, buf->size - (unsigned int) (*write));\n                    memcpy(buf->mem, data + buf->size - *write, size - buf->size + (unsigned int) (*write));\n                    *write += (int) (size - buf->size);\n                }\n            }\n\t}\n\telse {\n\t    dlt_vlog(LOG_WARNING, \"%s: Write error: ring buffer to small\\n\", __func__);\n\t}\n    }\n    else {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n    }\n}\n\nvoid dlt_buffer_read_block(DltBuffer *buf, int *read, unsigned char *data, unsigned int size)\n{\n    /* catch nullpointer */\n    if ((buf != NULL) && (read != NULL) && (data != NULL)) {\n        if (((unsigned int)(*read) + size) <= buf->size) {\n            /* read one block */\n            memcpy(data, buf->mem + *read, size);\n            *read += (int)size;\n        }\n        else {\n            /* when (*read) = buf->size, read only the second block\n            * and update read position correspondingly.\n            */\n            if ((unsigned int)(*read) <= buf->size) {\n                /* read two blocks */\n                memcpy(data, buf->mem + *read, buf->size - (unsigned int)(*read));\n                memcpy(data + buf->size - *read, buf->mem, size - buf->size + (unsigned int)(*read));\n                *read += (int) (size - buf->size);\n            }\n        }\n    }\n    else {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n    }\n}\n\nint dlt_buffer_check_size(DltBuffer *buf, int needed)\n{\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if ((buf->size + sizeof(DltBufferHead) + (size_t) needed) > buf->max_size)\n        return DLT_RETURN_ERROR;\n\n    return DLT_RETURN_OK;\n}\n\nint dlt_buffer_increase_size(DltBuffer *buf)\n{\n    DltBufferHead *head, *new_head;\n    unsigned char *new_ptr;\n\n    /* catch null pointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    /* check size */\n    if (buf->step_size == 0)\n        /* cannot increase size */\n        return DLT_RETURN_ERROR;\n\n    /* check size */\n    if ((buf->size + sizeof(DltBufferHead) + buf->step_size) > buf->max_size)\n        /* max size reached, do not increase */\n        return DLT_RETURN_ERROR;\n\n    /* allocate new buffer */\n    new_ptr = malloc(buf->size + sizeof(DltBufferHead) + buf->step_size);\n\n    if (new_ptr == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"%s: Buffer: Cannot increase size because allocate %u bytes failed\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* copy data */\n    head = (DltBufferHead *)buf->shm;\n    new_head = (DltBufferHead *)new_ptr;\n\n    if (head->read < head->write) {\n        memcpy(new_ptr + sizeof(DltBufferHead), buf->mem + head->read, (size_t)(head->write - head->read));\n        new_head->read = 0;\n        new_head->write = head->write - head->read;\n        new_head->count = head->count;\n    }\n    else {\n        memcpy(new_ptr + sizeof(DltBufferHead), buf->mem + head->read, buf->size - (uint32_t)(head->read));\n        memcpy(new_ptr + sizeof(DltBufferHead) + buf->size - head->read, buf->mem, (size_t)head->write);\n        new_head->read = 0;\n        new_head->write = (int)(buf->size) + head->write - head->read;\n        new_head->count = head->count;\n    }\n\n    /* free old data */\n    free(buf->shm);\n\n    /* update data */\n    buf->shm = new_ptr;\n    buf->mem = new_ptr + sizeof(DltBufferHead);\n    buf->size += buf->step_size;\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Size increased to %u bytes with start address %lX\\n\",\n             __func__,\n             buf->size + (int32_t)sizeof(DltBufferHead),\n             (unsigned long)buf->mem);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nint dlt_buffer_minimize_size(DltBuffer *buf)\n{\n    unsigned char *new_ptr;\n\n    /* catch null pointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    if ((buf->size + sizeof(DltBufferHead)) == buf->min_size)\n        /* already minimized */\n        return DLT_RETURN_OK;\n\n    /* allocate new buffer */\n    new_ptr = malloc(buf->min_size);\n\n    if (new_ptr == NULL) {\n        dlt_vlog(LOG_WARNING,\n                 \"%s: Buffer: Cannot set to min size of %u bytes\\n\",\n                 __func__, buf->min_size);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* free old data */\n    free(buf->shm);\n\n    /* update data */\n    buf->shm = new_ptr;\n    buf->mem = new_ptr + sizeof(DltBufferHead);\n    buf->size = (uint32_t)(buf->min_size - sizeof(DltBufferHead));\n\n    /* reset pointers and counters */\n    ((int *)(buf->shm))[0] = 0;  /* pointer to write memory */\n    ((int *)(buf->shm))[1] = 0;  /* pointer to read memory */\n    ((int *)(buf->shm))[2] = 0;  /* number of packets */\n\n    dlt_vlog(LOG_DEBUG,\n             \"%s: Buffer: Buffer minimized to Size %u bytes with start address %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    /* clear memory */\n    memset(buf->mem, 0, buf->size);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nint dlt_buffer_reset(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n\n    dlt_vlog(LOG_WARNING,\n             \"%s: Buffer: Buffer reset triggered. Size: %u, Start address: %lX\\n\",\n             __func__, buf->size, (unsigned long)buf->mem);\n\n    /* reset pointers and counters */\n    ((int *)(buf->shm))[0] = 0;  /* pointer to write memory */\n    ((int *)(buf->shm))[1] = 0;  /* pointer to read memory */\n    ((int *)(buf->shm))[2] = 0;  /* number of packets */\n\n    /* clear memory */\n    memset(buf->mem, 0, buf->size);\n\n    return DLT_RETURN_OK; /* OK */\n}\n\nDltReturnValue dlt_buffer_push(DltBuffer *buf, const unsigned char *data, unsigned int size)\n{\n    return dlt_buffer_push3(buf, data, size, 0, 0, 0, 0);\n}\n\nint dlt_buffer_push3(DltBuffer *buf,\n                     const unsigned char *data1,\n                     unsigned int size1,\n                     const unsigned char *data2,\n                     unsigned int size2,\n                     const unsigned char *data3,\n                     unsigned int size3)\n{\n    int free_size;\n    int write, read, count;\n    DltBufferBlockHead head;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->shm == NULL) {\n        /* buffer not initialised */\n        dlt_vlog(LOG_ERR, \"%s: Buffer: Buffer not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* get current write pointer */\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    /* check pointers */\n    if (((unsigned int)read > buf->size) || ((unsigned int)write > buf->size)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Pointer out of range. Read: %d, Write: %d, Size: %u\\n\",\n                 __func__, read, write, buf->size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* calculate free size */\n    if (read > write)\n        free_size = read - write;\n    else if (count && (write == read))\n        free_size = 0;\n    else\n        free_size = (int)buf->size - write + read;\n\n    /* check size */\n    while (free_size < (int) (sizeof(DltBufferBlockHead) + size1 + size2 + size3)) {\n        /* try to increase size if possible */\n        if (dlt_buffer_increase_size(buf))\n            /* increase size is not possible */\n            /*dlt_log(LOG_ERR, \"Buffer: Buffer is full\\n\"); */\n            return DLT_RETURN_ERROR; /* ERROR */\n\n        /* update pointers */\n        write = ((int *)(buf->shm))[0];\n        read = ((int *)(buf->shm))[1];\n\n\t    /* update free size */\n        if (read > write)\n            free_size = read - write;\n        else if (count && (write == read))\n            free_size = 0;\n        else\n            free_size = buf->size - write + read;\n    }\n\n    /* set header */\n    strncpy(head.head, DLT_BUFFER_HEAD, 4);\n    head.head[3] = 0;\n    head.status = 2;\n    head.size = (int)(size1 + size2 + size3);\n\n    /* write data */\n    dlt_buffer_write_block(buf, &write, (unsigned char *)&head, sizeof(DltBufferBlockHead));\n\n    if (size1)\n        dlt_buffer_write_block(buf, &write, data1, size1);\n\n    if (size2)\n        dlt_buffer_write_block(buf, &write, data2, size2);\n\n    if (size3)\n        dlt_buffer_write_block(buf, &write, data3, size3);\n\n    /* update global shm pointers */\n    ((int *)(buf->shm))[0] = write; /* set new write pointer */\n    ((int *)(buf->shm))[2] += 1; /* increase counter */\n\n    return DLT_RETURN_OK; /* OK */\n\n}\n\nint dlt_buffer_get(DltBuffer *buf, unsigned char *data, int max_size, int delete)\n{\n    int used_size;\n    int write, read, count;\n    char head_compare[] = DLT_BUFFER_HEAD;\n    DltBufferBlockHead head;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (buf->shm == NULL) {\n        /* shm not initialised */\n        dlt_vlog(LOG_ERR, \"%s: Buffer: SHM not initialized\\n\", __func__);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* get current write pointer */\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    /* check pointers */\n    if (((unsigned int)read > buf->size) || ((unsigned int)write > buf->size) || (count < 0)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Pointer out of range. Read: %d, Write: %d, Count: %d, Size: %u\\n\",\n                 __func__, read, write, count, buf->size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* check if data is in there */\n    if (count == 0) {\n        if (write != read) {\n            dlt_vlog(LOG_ERR,\n                     \"%s: Buffer: SHM should be empty, but is not. Read: %d, Write: %d\\n\",\n                     __func__, read, write);\n            dlt_buffer_reset(buf);\n        }\n\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* calculate used size */\n    if (write > read)\n        used_size = write - read;\n    else\n        used_size = (int)buf->size - read + write;\n\n    /* first check size */\n    if (used_size < (int)(sizeof(DltBufferBlockHead))) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Used size is smaller than buffer block header size. Used size: %d\\n\",\n                 __func__, used_size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* read header */\n    dlt_buffer_read_block(buf, &read, (unsigned char *)&head, sizeof(DltBufferBlockHead));\n\n    /* check header */\n    if (memcmp((unsigned char *)(head.head), head_compare, sizeof(head_compare)) != 0) {\n        dlt_vlog(LOG_ERR, \"%s: Buffer: Header head check failed\\n\", __func__);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    if (head.status != 2) {\n        dlt_vlog(LOG_ERR, \"%s: Buffer: Header status check failed\\n\", __func__);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* second check size */\n    if (used_size < ((int)sizeof(DltBufferBlockHead) + head.size)) {\n        dlt_vlog(LOG_ERR,\n                 \"%s: Buffer: Used size is smaller than buffer block header size And read header size. Used size: %d\\n\",\n                 __func__, used_size);\n        dlt_buffer_reset(buf);\n        return DLT_RETURN_ERROR; /* ERROR */\n    }\n\n    /* third check size */\n    if (max_size && (head.size > max_size))\n        dlt_vlog(LOG_WARNING,\n                 \"%s: Buffer: Max size is smaller than read header size. Max size: %d\\n\",\n                 __func__, max_size);\n\n    /* nothing to do but data does not fit provided buffer */\n\n    if ((data != NULL) && max_size) {\n        /* read data */\n        dlt_buffer_read_block(buf, &read, data, (unsigned int)head.size);\n\n        if (delete)\n            /* update buffer pointers */\n            ((int *)(buf->shm))[1] = read; /* set new read pointer */\n\n    }\n    else if (delete)\n    {\n        if ((unsigned int)(read + head.size) <= buf->size)\n            ((int *)(buf->shm))[1] = read + head.size;  /* set new read pointer */\n        else\n            ((int *)(buf->shm))[1] = read + head.size - (int)buf->size;  /* set new read pointer */\n\n    }\n\n    if (delete) {\n        ((int *)(buf->shm))[2] -= 1; /* decrease counter */\n\n        if (((int *)(buf->shm))[2] == 0)\n            /* try to minimize size */\n            dlt_buffer_minimize_size(buf);\n    }\n\n    return head.size; /* OK */\n}\n\nint dlt_buffer_pull(DltBuffer *buf, unsigned char *data, int max_size)\n{\n    return dlt_buffer_get(buf, data, max_size, 1);\n}\n\nint dlt_buffer_copy(DltBuffer *buf, unsigned char *data, int max_size)\n{\n    return dlt_buffer_get(buf, data, max_size, 0);\n}\n\nint dlt_buffer_remove(DltBuffer *buf)\n{\n    return dlt_buffer_get(buf, 0, 0, 1);\n}\n\nvoid dlt_buffer_info(DltBuffer *buf)\n{\n    /* check nullpointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return;\n    }\n\n    dlt_vlog(LOG_DEBUG,\n             \"Buffer: Available size: %u, Buffer: Buffer full start address: %lX, Buffer: Buffer start address: %lX\\n\",\n             buf->size, (unsigned long)buf->shm, (unsigned long)buf->mem);\n}\n\nvoid dlt_buffer_status(DltBuffer *buf)\n{\n    int write, read, count;\n\n    /* check nullpointer */\n    if (buf == NULL) {\n        dlt_vlog(LOG_WARNING, \"%s: Wrong parameter: Null pointer\\n\", __func__);\n        return;\n    }\n\n    /* check if buffer available */\n    if (buf->shm == NULL)\n        return;\n\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    dlt_vlog(LOG_DEBUG,\n             \"Buffer: Write: %d, Read: %d, Count: %d\\n\",\n             write, read, count);\n}\n\nuint32_t dlt_buffer_get_total_size(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    return buf->max_size;\n}\n\nint dlt_buffer_get_used_size(DltBuffer *buf)\n{\n    int write, read, count;\n\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if buffer available */\n    if (buf->shm == NULL)\n        return DLT_RETURN_OK;\n\n    write = ((int *)(buf->shm))[0];\n    read = ((int *)(buf->shm))[1];\n    count = ((int *)(buf->shm))[2];\n\n    if (count == 0)\n        return DLT_RETURN_OK;\n\n    if (write > read)\n        return write - read;\n\n    return (int)buf->size - read + write;\n}\n\nint dlt_buffer_get_message_count(DltBuffer *buf)\n{\n    /* catch null pointer */\n    if (buf == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    /* check if buffer available */\n    if (buf->shm == NULL)\n        return DLT_RETURN_OK;\n\n    return ((int *)(buf->shm))[2];\n}\n\n#if !defined (__WIN32__)\n\nDltReturnValue dlt_setup_serial(int fd, speed_t speed)\n{\n#   if !defined (__WIN32__) && !defined(_MSC_VER)\n    struct termios config;\n\n    if (isatty(fd) == 0)\n        return DLT_RETURN_ERROR;\n\n    if (tcgetattr(fd, &config) < 0)\n        return DLT_RETURN_ERROR;\n\n    /* Input flags - Turn off input processing\n     * convert break to null byte, no CR to NL translation,\n     * no NL to CR translation, don't mark parity errors or breaks\n     * no input parity check, don't strip high bit off,\n     * no XON/XOFF software flow control\n     */\n    config.c_iflag &= ~(IGNBRK | BRKINT | ICRNL |\n                        INLCR | PARMRK | INPCK | ISTRIP | IXON);\n\n    /* Output flags - Turn off output processing\n     * no CR to NL translation, no NL to CR-NL translation,\n     * no NL to CR translation, no column 0 CR suppression,\n     * no Ctrl-D suppression, no fill characters, no case mapping,\n     * no local output processing\n     *\n     * config.c_oflag &= ~(OCRNL | ONLCR | ONLRET |\n     *                     ONOCR | ONOEOT| OFILL | OLCUC | OPOST);\n     */\n    config.c_oflag = 0;\n\n    /* No line processing:\n     * echo off, echo newline off, canonical mode off,\n     * extended input processing off, signal chars off\n     */\n    config.c_lflag &= ~(ECHO | ECHONL | ICANON | IEXTEN | ISIG);\n\n    /* Turn off character processing\n     * clear current char size mask, no parity checking,\n     * no output processing, force 8 bit input\n     */\n    config.c_cflag &= ~(CSIZE | PARENB);\n    config.c_cflag |= CS8;\n\n    /* One input byte is enough to return from read()\n     * Inter-character timer off\n     */\n    config.c_cc[VMIN] = 1;\n    config.c_cc[VTIME] = 0;\n\n    /* Communication speed (simple version, using the predefined\n     * constants)\n     */\n    if ((cfsetispeed(&config, speed) < 0) || (cfsetospeed(&config, speed) < 0))\n        return DLT_RETURN_ERROR;\n\n    /* Finally, apply the configuration\n     */\n    if (tcsetattr(fd, TCSAFLUSH, &config) < 0)\n        return DLT_RETURN_ERROR;\n\n    return DLT_RETURN_OK;\n#   else\n    return DLT_RETURN_ERROR;\n#   endif\n}\n\nspeed_t dlt_convert_serial_speed(int baudrate)\n{\n#   if !defined (__WIN32__) && !defined(_MSC_VER) && !defined(__CYGWIN__)\n    speed_t ret;\n\n    switch (baudrate) {\n    case  50:\n    {\n        ret = B50;\n        break;\n    }\n    case  75:\n    {\n        ret = B75;\n        break;\n    }\n    case  110:\n    {\n        ret = B110;\n        break;\n    }\n    case  134:\n    {\n        ret = B134;\n        break;\n    }\n    case  150:\n    {\n        ret = B150;\n        break;\n    }\n    case  200:\n    {\n        ret = B200;\n        break;\n    }\n    case  300:\n    {\n        ret = B300;\n        break;\n    }\n    case  600:\n    {\n        ret = B600;\n        break;\n    }\n    case  1200:\n    {\n        ret = B1200;\n        break;\n    }\n    case  1800:\n    {\n        ret = B1800;\n        break;\n    }\n    case  2400:\n    {\n        ret = B2400;\n        break;\n    }\n    case  4800:\n    {\n        ret = B4800;\n        break;\n    }\n    case  9600:\n    {\n        ret = B9600;\n        break;\n    }\n    case  19200:\n    {\n        ret = B19200;\n        break;\n    }\n    case  38400:\n    {\n        ret = B38400;\n        break;\n    }\n    case  57600:\n    {\n        ret = B57600;\n        break;\n    }\n    case  115200:\n    {\n        ret = B115200;\n        break;\n    }\n#      ifdef __linux__\n    case 230400:\n    {\n        ret = B230400;\n        break;\n    }\n    case 460800:\n    {\n        ret = B460800;\n        break;\n    }\n    case  500000:\n    {\n        ret = B500000;\n        break;\n    }\n    case  576000:\n    {\n        ret = B576000;\n        break;\n    }\n    case  921600:\n    {\n        ret = B921600;\n        break;\n    }\n    case  1000000:\n    {\n        ret = B1000000;\n        break;\n    }\n    case  1152000:\n    {\n        ret = B1152000;\n        break;\n    }\n    case  1500000:\n    {\n        ret = B1500000;\n        break;\n    }\n    case  2000000:\n    {\n        ret = B2000000;\n        break;\n    }\n    case  2500000:\n    {\n        ret = B2500000;\n        break;\n    }\n    case  3000000:\n    {\n        ret = B3000000;\n        break;\n    }\n    case  3500000:\n    {\n        ret = B3500000;\n        break;\n    }\n    case  4000000:\n    {\n        ret = B4000000;\n        break;\n    }\n#      endif /* __linux__ */\n    default:\n    {\n        ret = B115200;\n        break;\n    }\n    }\n\n    return ret;\n#   else\n    return 0;\n#   endif\n}\n\n#endif\n\nvoid dlt_get_version(char *buf, size_t size)\n{\n    if ((buf == NULL) && (size > 0)) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: Null pointer\\n\");\n        return;\n    }\n\n/* Clang does not like these macros, because they are not reproducable */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdate-time\"\n    snprintf(buf,\n             size,\n             \"DLT Package Version: %s %s, Package Revision: %s, build on %s %s\\n%s %s %s %s\\n\",\n             _DLT_PACKAGE_VERSION,\n             _DLT_PACKAGE_VERSION_STATE,\n             _DLT_PACKAGE_REVISION,\n             __DATE__,\n             __TIME__,\n             _DLT_SYSTEMD_ENABLE,\n             _DLT_SYSTEMD_WATCHDOG_ENABLE,\n             _DLT_TEST_ENABLE,\n             _DLT_SHM_ENABLE);\n#pragma GCC diagnostic pop\n}\n\nvoid dlt_get_major_version(char *buf, size_t size)\n{\n    if ((buf == NULL) && (size > 0)) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: Null pointer\\n\");\n        return;\n    }\n\n    snprintf(buf, size, \"%s\", _DLT_PACKAGE_MAJOR_VERSION);\n}\n\nvoid dlt_get_minor_version(char *buf, size_t size)\n{\n    if ((buf == NULL) && (size > 0)) {\n        dlt_log(LOG_WARNING, \"Wrong parameter: Null pointer\\n\");\n        return;\n    }\n\n    snprintf(buf, size, \"%s\", _DLT_PACKAGE_MINOR_VERSION);\n}\n\n\nuint32_t dlt_uptime(void)\n{\n\n#if defined (__WIN32__) || defined(_MSC_VER)\n\n    return (uint32_t)(GetTickCount() * 10); /* GetTickCount() return DWORD */\n\n#else\n    struct timespec ts;\n\n    if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0)\n        return (uint32_t)ts.tv_sec * 10000 + (uint32_t)ts.tv_nsec / 100000; /* in 0.1 ms = 100 us */\n    else\n        return 0;\n\n#endif\n\n}\n\nDltReturnValue dlt_message_print_header(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_hex(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_HEX, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_ascii(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_ASCII, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_mixed_plain(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \\n\", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_MIXED_FOR_PLAIN, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_print_mixed_html(DltMessage *message, char *text, uint32_t size, int verbose)\n{\n    if ((message == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    if (dlt_message_header(message, text, size, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    dlt_user_printf(\"%s \\n\", text);\n\n    if (dlt_message_payload(message, text, size, DLT_OUTPUT_MIXED_FOR_HTML, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n\n    dlt_user_printf(\"[%s]\\n\", text);\n\n    return DLT_RETURN_OK;\n}\n\nDltReturnValue dlt_message_argument_print(DltMessage *msg,\n                                          uint32_t type_info,\n                                          uint8_t **ptr,\n                                          int32_t *datalength,\n                                          char *text,\n                                          size_t textlength,\n                                          int byteLength,\n                                          int __attribute__((unused)) verbose)\n{\n    /* check null pointers */\n    if ((msg == NULL) || (ptr == NULL) || (datalength == NULL) || (text == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    uint16_t length = 0, length2 = 0, length3 = 0;\n\n    uint8_t value8u = 0;\n    uint16_t value16u = 0, value16u_tmp = 0;\n    uint32_t value32u = 0, value32u_tmp = 0;\n    uint64_t value64u = 0, value64u_tmp = 0;\n\n    int8_t value8i = 0;\n    int16_t value16i = 0, value16i_tmp = 0;\n    int32_t value32i = 0, value32i_tmp = 0;\n    int64_t value64i = 0, value64i_tmp = 0;\n\n    float32_t value32f = 0, value32f_tmp = 0;\n    int32_t value32f_tmp_int32i = 0, value32f_tmp_int32i_swaped = 0;\n    float64_t value64f = 0, value64f_tmp = 0;\n    int64_t value64f_tmp_int64i = 0, value64f_tmp_int64i_swaped = 0;\n\n    uint32_t quantisation_tmp = 0;\n\n    // pointer to the value string\n    char* value_text = text;\n    // pointer to the \"unit\" attribute string, if there is one (only for *INT and FLOAT*)\n    const uint8_t* unit_text_src = NULL;\n    // length of the \"unit\" attribute string, if there is one (only for *INT and FLOAT*)\n    size_t unit_text_len = 0;\n\n    /* apparently this makes no sense but needs to be done to prevent compiler warning.\n     * This variable is only written by DLT_MSG_READ_VALUE macro in if (type_info & DLT_TYPE_INFO_FIXP)\n     * case but never read anywhere */\n    quantisation_tmp += quantisation_tmp;\n\n    if ((type_info & DLT_TYPE_INFO_STRG) &&\n        (((type_info & DLT_TYPE_INFO_SCOD) == DLT_SCOD_ASCII) || ((type_info & DLT_TYPE_INFO_SCOD) == DLT_SCOD_UTF8))) {\n        /* string type or utf8-encoded string type */\n        if (byteLength < 0) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n        }\n        else {\n            length = (uint16_t)byteLength;\n        }\n\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n        }\n\n        DLT_MSG_READ_STRING(value_text, *ptr, *datalength, textlength, length);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n    }\n    else if (type_info & DLT_TYPE_INFO_BOOL)\n    {\n        /* Boolean type */\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-2;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n        }\n\n        value8u = 0;\n        DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n\n        snprintf(value_text, textlength, \"%d\", value8u);\n    }\n    else if ((type_info & DLT_TYPE_INFO_UINT) && (DLT_SCOD_BIN == (type_info & DLT_TYPE_INFO_SCOD)))\n    {\n        if (DLT_TYLE_8BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            char binary[10] = { '\\0' }; /* e.g.: \"0b1100 0010\" */\n            int i;\n\n            for (i = (1 << 7); i > 0; i >>= 1) {\n                if ((1 << 3) == i)\n                    strcat(binary, \" \");\n\n                strcat(binary, (i == (value8u & i)) ? \"1\" : \"0\");\n            }\n\n            snprintf(value_text, textlength, \"0b%s\", binary);\n        }\n\n        if (DLT_TYLE_16BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value16u, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            char binary[20] = { '\\0' }; /* e.g.: \"0b1100 0010 0011 0110\" */\n            int i;\n\n            for (i = (1 << 15); i > 0; i >>= 1) {\n                if (((1 << 3) == i) || ((1 << 7) == i) || ((1 << 11) == i))\n                    strcat(binary, \" \");\n\n                strcat(binary, (i == (value16u & i)) ? \"1\" : \"0\");\n            }\n\n            snprintf(value_text, textlength, \"0b%s\", binary);\n        }\n    }\n    else if ((type_info & DLT_TYPE_INFO_UINT) && (DLT_SCOD_HEX == (type_info & DLT_TYPE_INFO_SCOD)))\n    {\n        if (DLT_TYLE_8BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%02x\", value8u);\n        }\n\n        if (DLT_TYLE_16BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value16u, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%04x\", value16u);\n        }\n\n        if (DLT_TYLE_32BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%08x\", value32u);\n        }\n\n        if (DLT_TYLE_64BIT == (type_info & DLT_TYPE_INFO_TYLE)) {\n            *ptr += 4;\n            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text, textlength, \"0x%08x\", value32u);\n            *ptr -= 8;\n            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            snprintf(value_text + strlen(value_text), textlength - strlen(value_text), \"%08x\", value32u);\n            *ptr += 4;\n        }\n    }\n    else if ((type_info & DLT_TYPE_INFO_SINT) || (type_info & DLT_TYPE_INFO_UINT))\n    {\n        /* signed or unsigned argument received */\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length3 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for the \":\", and -1 for nul\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n\n            if ((*datalength) < length3)\n                return DLT_RETURN_ERROR;\n\n            // We want to add the \"unit\" attribute only after the value, so remember its pointer and length here.\n            unit_text_src = *ptr;\n            unit_text_len = length3;\n\n            *ptr += length3;\n            *datalength -= length3;\n        }\n\n        if (type_info & DLT_TYPE_INFO_FIXP) {\n            DLT_MSG_READ_VALUE(quantisation_tmp, *ptr, *datalength, uint32_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            switch (type_info & DLT_TYPE_INFO_TYLE) {\n            case DLT_TYLE_8BIT:\n            case DLT_TYLE_16BIT:\n            case DLT_TYLE_32BIT:\n            {\n                if ((*datalength) < 4)\n                    return DLT_RETURN_ERROR;\n\n                *ptr += 4;\n                *datalength -= 4;\n                break;\n            }\n            case DLT_TYLE_64BIT:\n            {\n                if ((*datalength) < 8)\n                    return DLT_RETURN_ERROR;\n\n                *ptr += 8;\n                *datalength -= 8;\n                break;\n            }\n            case DLT_TYLE_128BIT:\n            {\n                if ((*datalength) < 16)\n                    return DLT_RETURN_ERROR;\n\n                *ptr += 16;\n                *datalength -= 16;\n                break;\n            }\n            default:\n            {\n                return DLT_RETURN_ERROR;\n            }\n            }\n        }\n\n        switch (type_info & DLT_TYPE_INFO_TYLE) {\n        case DLT_TYLE_8BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value8i = 0;\n                DLT_MSG_READ_VALUE(value8i, *ptr, *datalength, int8_t);  /* No endian conversion necessary */\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                snprintf(value_text, textlength, \"%d\", value8i);\n            }\n            else {\n                value8u = 0;\n                DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t);  /* No endian conversion necessary */\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                snprintf(value_text, textlength, \"%d\", value8u);\n            }\n\n            break;\n        }\n        case DLT_TYLE_16BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value16i = 0;\n                value16i_tmp = 0;\n                DLT_MSG_READ_VALUE(value16i_tmp, *ptr, *datalength, int16_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value16i = (int16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16i_tmp);\n                snprintf(value_text, textlength, \"%hd\", value16i);\n            }\n            else {\n                value16u = 0;\n                value16u_tmp = 0;\n                DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value16u = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n                snprintf(value_text, textlength, \"%hu\", value16u);\n            }\n\n            break;\n        }\n        case DLT_TYLE_32BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value32i = 0;\n                value32i_tmp = 0;\n                DLT_MSG_READ_VALUE(value32i_tmp, *ptr, *datalength, int32_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value32i = (int32_t) DLT_ENDIAN_GET_32(msg->standardheader->htyp, (uint32_t)value32i_tmp);\n                snprintf(value_text, textlength, \"%d\", value32i);\n            }\n            else {\n                value32u = 0;\n                value32u_tmp = 0;\n                DLT_MSG_READ_VALUE(value32u_tmp, *ptr, *datalength, uint32_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value32u = DLT_ENDIAN_GET_32(msg->standardheader->htyp, value32u_tmp);\n                snprintf(value_text, textlength, \"%u\", value32u);\n            }\n\n            break;\n        }\n        case DLT_TYLE_64BIT:\n        {\n            if (type_info & DLT_TYPE_INFO_SINT) {\n                value64i = 0;\n                value64i_tmp = 0;\n                DLT_MSG_READ_VALUE(value64i_tmp, *ptr, *datalength, int64_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value64i = (int64_t) DLT_ENDIAN_GET_64(msg->standardheader->htyp, (uint64_t)value64i_tmp);\n    #if defined (__WIN32__) && !defined(_MSC_VER)\n                snprintf(value_text, textlength, \"%I64d\", value64i);\n    #else\n                snprintf(value_text, textlength, \"%\" PRId64, value64i);\n    #endif\n            }\n            else {\n                value64u = 0;\n                value64u_tmp = 0;\n                DLT_MSG_READ_VALUE(value64u_tmp, *ptr, *datalength, uint64_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                value64u = DLT_ENDIAN_GET_64(msg->standardheader->htyp, value64u_tmp);\n    #if defined (__WIN32__) && !defined(_MSC_VER)\n                snprintf(value_text, textlength, \"%I64u\", value64u);\n    #else\n                snprintf(value_text, textlength, \"%\" PRIu64, value64u);\n    #endif\n            }\n\n            break;\n        }\n        case DLT_TYLE_128BIT:\n        {\n            if (*datalength >= 16)\n                dlt_print_hex_string(value_text, (int) textlength, *ptr, 16);\n\n            if ((*datalength) < 16)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 16;\n            *datalength -= 16;\n            break;\n        }\n        default:\n        {\n            return DLT_RETURN_ERROR;\n        }\n        }\n    }\n    else if (type_info & DLT_TYPE_INFO_FLOA)\n    {\n        /* float data argument */\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length3 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n\n            if ((*datalength) < length3)\n                return DLT_RETURN_ERROR;\n\n            // We want to add the \"unit\" attribute only after the value, so remember its pointer and length here.\n            unit_text_src = *ptr;\n            unit_text_len = length3;\n\n            *ptr += length3;\n            *datalength -= length3;\n        }\n\n        switch (type_info & DLT_TYPE_INFO_TYLE) {\n        case DLT_TYLE_8BIT:\n        {\n            if (*datalength >= 1)\n                dlt_print_hex_string(value_text, (int) textlength, *ptr, 1);\n\n            if ((*datalength) < 1)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 1;\n            *datalength -= 1;\n            break;\n        }\n        case DLT_TYLE_16BIT:\n        {\n            if (*datalength >= 2)\n                dlt_print_hex_string(value_text, (int) textlength, *ptr, 2);\n\n            if ((*datalength) < 2)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 2;\n            *datalength -= 2;\n            break;\n        }\n        case DLT_TYLE_32BIT:\n        {\n            if (sizeof(float32_t) == 4) {\n                value32f = 0;\n                value32f_tmp = 0;\n                value32f_tmp_int32i = 0;\n                value32f_tmp_int32i_swaped = 0;\n                DLT_MSG_READ_VALUE(value32f_tmp, *ptr, *datalength, float32_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                memcpy(&value32f_tmp_int32i, &value32f_tmp, sizeof(float32_t));\n                value32f_tmp_int32i_swaped =\n                    (int32_t) DLT_ENDIAN_GET_32(msg->standardheader->htyp, (uint32_t)value32f_tmp_int32i);\n                memcpy(&value32f, &value32f_tmp_int32i_swaped, sizeof(float32_t));\n                snprintf(value_text, textlength, \"%g\", value32f);\n            }\n            else {\n                dlt_log(LOG_ERR, \"Invalid size of float32_t\\n\");\n                return DLT_RETURN_ERROR;\n            }\n\n            break;\n        }\n        case DLT_TYLE_64BIT:\n        {\n            if (sizeof(float64_t) == 8) {\n                value64f = 0;\n                value64f_tmp = 0;\n                value64f_tmp_int64i = 0;\n                value64f_tmp_int64i_swaped = 0;\n                DLT_MSG_READ_VALUE(value64f_tmp, *ptr, *datalength, float64_t);\n\n                if ((*datalength) < 0)\n                    return DLT_RETURN_ERROR;\n\n                memcpy(&value64f_tmp_int64i, &value64f_tmp, sizeof(float64_t));\n                value64f_tmp_int64i_swaped =\n                    (int64_t) DLT_ENDIAN_GET_64(msg->standardheader->htyp, (uint64_t)value64f_tmp_int64i);\n                memcpy(&value64f, &value64f_tmp_int64i_swaped, sizeof(float64_t));\n#ifdef __arm__\n                snprintf(value_text, textlength, \"ILLEGAL\");\n#else\n                snprintf(value_text, textlength, \"%g\", value64f);\n#endif\n            }\n            else {\n                dlt_log(LOG_ERR, \"Invalid size of float64_t\\n\");\n                return DLT_RETURN_ERROR;\n            }\n\n            break;\n        }\n        case DLT_TYLE_128BIT:\n        {\n            if (*datalength >= 16)\n                dlt_print_hex_string(value_text, textlength, *ptr, 16);\n\n            if ((*datalength) < 16)\n                return DLT_RETURN_ERROR;\n\n            *ptr += 16;\n            *datalength -= 16;\n            break;\n        }\n        default:\n        {\n            return DLT_RETURN_ERROR;\n        }\n        }\n    }\n    else if (type_info & DLT_TYPE_INFO_RAWD)\n    {\n        /* raw data argument */\n        DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n\n        length = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n        if (type_info & DLT_TYPE_INFO_VARI) {\n            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n            if ((*datalength) < 0)\n                return DLT_RETURN_ERROR;\n\n            length2 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n            if ((*datalength) < length2)\n                return DLT_RETURN_ERROR;\n\n            if (print_with_attributes) {\n                // Print \"name\" attribute, if we have one with non-zero size.\n                if (length2 > 1) {\n                    snprintf(text, textlength, \"%s:\", *ptr);\n                    value_text += length2+1-1;  // +1 for \":\" and -1 for NUL\n                    textlength -= length2+1-1;\n                }\n            }\n\n            *ptr += length2;\n            *datalength -= length2;\n        }\n\n        if ((*datalength) < length)\n            return DLT_RETURN_ERROR;\n\n        if (dlt_print_hex_string_delim(value_text, (int) textlength, *ptr, length, '\\'') < DLT_RETURN_OK)\n            return DLT_RETURN_ERROR;\n        *ptr += length;\n        *datalength -= length;\n    }\n    else if (type_info & DLT_TYPE_INFO_TRAI)\n    {\n        /* trace info argument */\n        DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n\n        length = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);\n\n        DLT_MSG_READ_STRING(value_text, *ptr, *datalength, textlength, length);\n\n        if ((*datalength) < 0)\n            return DLT_RETURN_ERROR;\n    }\n    else {\n        return DLT_RETURN_ERROR;\n    }\n\n    if (*datalength < 0) {\n        dlt_log(LOG_ERR, \"Payload of DLT message corrupted\\n\");\n        return DLT_RETURN_ERROR;\n    }\n\n    // Now write \"unit\" attribute, but only if it has more than only a nul-termination char.\n    if (print_with_attributes) {\n        if (unit_text_len > 1) {\n            // 'value_text' still points to the +start+ of the value text\n            size_t currLen = strlen(value_text);\n\n            char* unitText = value_text + currLen;\n            textlength -= currLen;\n            snprintf(unitText, textlength, \":%s\", unit_text_src);\n        }\n    }\n\n    return DLT_RETURN_OK;\n}\n\nvoid dlt_check_envvar()\n{\n    char *env_log_filename = getenv(\"DLT_LOG_FILENAME\");\n\n    if (env_log_filename != NULL)\n        dlt_log_set_filename(env_log_filename);\n\n    char *env_log_level_str = getenv(\"DLT_LOG_LEVEL\");\n\n    if (env_log_level_str != NULL) {\n        int level = 0;\n\n        if (sscanf(env_log_level_str, \"%d\", &level))\n            dlt_log_set_level(level);\n    }\n\n    char *env_log_mode = getenv(\"DLT_LOG_MODE\");\n\n    if (env_log_mode != NULL) {\n        int mode = 0;\n\n        if (sscanf(env_log_mode, \"%d\", &mode))\n            dlt_log_init(mode);\n    }\n\n#if defined DLT_DAEMON_USE_FIFO_IPC || defined DLT_LIB_USE_FIFO_IPC\n    char *env_pipe_dir = getenv(\"DLT_PIPE_DIR\");\n\n    if (env_pipe_dir != NULL)\n        dlt_log_set_fifo_basedir(env_pipe_dir);\n    else\n        dlt_log_set_fifo_basedir(DLT_USER_IPC_PATH);\n\n#endif\n\n#ifdef DLT_SHM_ENABLE\n    char *env_shm_name = getenv(\"DLT_SHM_NAME\");\n\n    if (env_shm_name != NULL)\n        dlt_log_set_shm_name(env_shm_name);\n\n#endif\n}\n\nint dlt_set_loginfo_parse_service_id(char *resp_text,\n                                     uint32_t *service_id,\n                                     uint8_t *service_opt)\n{\n    int ret = -1;\n    char get_log_info_tag[GET_LOG_INFO_LENGTH];\n    char service_opt_str[SERVICE_OPT_LENGTH];\n\n    if ((resp_text == NULL) || (service_id == NULL) || (service_opt == NULL))\n        return DLT_RETURN_ERROR;\n\n    /* ascii type, syntax is 'get_log_info, ..' */\n    /* check target id */\n    strncpy(get_log_info_tag, \"get_log_info\", strlen(\"get_log_info\") + 1);\n    ret = memcmp((void *)resp_text, (void *)get_log_info_tag, sizeof(get_log_info_tag) - 1);\n\n    if (ret == 0) {\n        *service_id = DLT_SERVICE_ID_GET_LOG_INFO;\n        /* reading the response mode from the resp_text. eg. option 7*/\n        service_opt_str[0] = *(resp_text + GET_LOG_INFO_LENGTH + 1);\n        service_opt_str[1] = *(resp_text + GET_LOG_INFO_LENGTH + 2);\n        service_opt_str[2] = 0;\n        *service_opt = (uint8_t) atoi(service_opt_str);\n    }\n\n    return ret;\n}\n\nint16_t dlt_getloginfo_conv_ascii_to_uint16_t(char *rp, int *rp_count)\n{\n    char num_work[5] = { 0 };\n    char *endptr;\n\n    if ((rp == NULL) || (rp_count == NULL))\n        return -1;\n\n    /* ------------------------------------------------------\n     *  from: [89 13 ] -> to: ['+0x'1389\\0] -> to num\n     *  ------------------------------------------------------ */\n    num_work[0] = *(rp + *rp_count + 3);\n    num_work[1] = *(rp + *rp_count + 4);\n    num_work[2] = *(rp + *rp_count + 0);\n    num_work[3] = *(rp + *rp_count + 1);\n    num_work[4] = 0;\n    *rp_count += 6;\n\n    return (uint16_t)strtol(num_work, &endptr, 16);\n}\n\nint16_t dlt_getloginfo_conv_ascii_to_int16_t(char *rp, int *rp_count)\n{\n    char num_work[3] = { 0 };\n    char *endptr;\n\n    if ((rp == NULL) || (rp_count == NULL))\n        return -1;\n\n    /* ------------------------------------------------------\n     *  from: [89 ] -> to: ['0x'89\\0] -> to num\n     *  ------------------------------------------------------ */\n    num_work[0] = *(rp + *rp_count + 0);\n    num_work[1] = *(rp + *rp_count + 1);\n    num_work[2] = 0;\n    *rp_count += 3;\n\n    return (signed char)strtol(num_work, &endptr, 16);\n}\n\nvoid dlt_getloginfo_conv_ascii_to_string(char *rp, int *rp_count, char *wp, int len)\n{\n    if ((rp == NULL ) || (rp_count == NULL ) || (wp == NULL ))\n        return;\n    /* ------------------------------------------------------\n     *  from: [72 65 6d 6f ] -> to: [0x72,0x65,0x6d,0x6f,0x00]\n     *  ------------------------------------------------------ */\n\n    int count = dlt_getloginfo_conv_ascii_to_id(rp, rp_count, wp, len);\n    *(wp + count) = '\\0';\n\n    return;\n}\n\nint dlt_getloginfo_conv_ascii_to_id(char *rp, int *rp_count, char *wp, int len)\n{\n    char number16[3] = { 0 };\n    char *endptr;\n    int count;\n\n    if ((rp == NULL) || (rp_count == NULL) || (wp == NULL))\n        return 0;\n\n    /* ------------------------------------------------------\n     *  from: [72 65 6d 6f ] -> to: [0x72,0x65,0x6d,0x6f]\n     *  ------------------------------------------------------ */\n    for (count = 0; count < len; count++) {\n        number16[0] = *(rp + *rp_count + 0);\n        number16[1] = *(rp + *rp_count + 1);\n        *(wp + count) = (char) strtol(number16, &endptr, 16);\n        *rp_count += 3;\n    }\n\n    return count;\n}\n\nvoid dlt_hex_ascii_to_binary(const char *ptr, uint8_t *binary, int *size)\n{\n    char ch = *ptr;\n    int pos = 0;\n    binary[pos] = 0;\n    int first = 1;\n    int found;\n\n    for (;;) {\n        if (ch == 0) {\n            *size = pos;\n            return;\n        }\n\n        found = 0;\n\n        if ((ch >= '0') && (ch <= '9')) {\n            binary[pos] = (uint8_t) ((binary[pos] << 4) + (ch - '0'));\n            found = 1;\n        }\n        else if ((ch >= 'A') && (ch <= 'F'))\n        {\n            binary[pos] = (uint8_t) ((binary[pos] << 4) + (ch - 'A' + 10));\n            found = 1;\n        }\n        else if ((ch >= 'a') && (ch <= 'f'))\n        {\n            binary[pos] = (uint8_t) ((binary[pos] << 4) + (ch - 'a' + 10));\n            found = 1;\n        }\n\n        if (found) {\n            if (first) {\n                first = 0;\n            }\n            else {\n                first = 1;\n                pos++;\n\n                if (pos >= *size)\n                    return;\n\n                binary[pos] = 0;\n            }\n        }\n\n        ch = *(++ptr);\n    }\n}\n\nDltReturnValue dlt_file_quick_parsing(DltFile *file, const char *filename,\n                                      int type, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n    int ret = DLT_RETURN_OK;\n    char text[DLT_CONVERT_TEXTBUFSIZE] = { 0 };\n\n    if ((file == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *output = fopen(filename, \"w+\");\n\n    if (output == NULL) {\n        dlt_vlog(LOG_ERR, \"Cannot open output file %s for parsing\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    while (ret >= DLT_RETURN_OK && file->file_position < file->file_length) {\n        /* get file position at start of DLT message */\n        if (verbose)\n            dlt_vlog(LOG_DEBUG, \"Position in file: %\" PRIu64 \"\\n\", file->file_position);\n\n        /* read all header and payload */\n        ret = dlt_file_read_header(file, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        ret = dlt_file_read_header_extended(file, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        ret = dlt_file_read_data(file, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        if (file->filter) {\n            /* check the filters if message is used */\n            ret = dlt_message_filter_check(&(file->msg), file->filter, verbose);\n\n            if (ret != DLT_RETURN_TRUE)\n                continue;\n        }\n\n        ret = dlt_message_header(&(file->msg), text,\n                                 DLT_CONVERT_TEXTBUFSIZE, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        fprintf(output, \"%s\", text);\n\n        ret = dlt_message_payload(&(file->msg), text,\n                                  DLT_CONVERT_TEXTBUFSIZE, type, verbose);\n\n        if (ret < DLT_RETURN_OK)\n            break;\n\n        fprintf(output, \"[%s]\\n\", text);\n\n        /* store index pointer to message position in DLT file */\n        file->counter++;\n        file->position = file->counter_total - 1;\n        /* increase total message counter */\n        file->counter_total++;\n        /* store position to next message */\n        file->file_position = ftell(file->handle);\n    } /* while() */\n\n    fclose(output);\n    return ret;\n}\n\n\nint dlt_execute_command(char *filename, char *command, ...)\n{\n    va_list val;\n    int argc;\n    char **args = NULL;\n    int ret = 0;\n\n    if (command == NULL)\n        return -1;\n\n    /* Determine number of variadic arguments */\n    va_start(val, command);\n\n    for (argc = 2; va_arg(val, char *) != NULL; argc++);\n\n    va_end(val);\n\n    /* Allocate args, put references to command */\n    args = (char **) malloc( (uint32_t) argc * sizeof(char*));\n    args[0] = command;\n\n    va_start(val, command);\n\n    for (int i = 0; args[i] != NULL; i++)\n        args[i + 1] = va_arg(val, char *);\n\n    va_end(val);\n\n    /* Run command in child process */\n    pid_t pid = fork();\n\n    if (pid == 0) { /* child process */\n\n        /* Redirect output if required */\n        if (filename != NULL) {\n            int fd = open(filename, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n            if (fd < 0)\n                err(-1, \"%s failed on open()\", __func__);\n\n            if (dup2(fd, STDOUT_FILENO) == -1) {\n                close(fd);\n                err(-1, \"%s failed on dup2()\", __func__);\n            }\n\n            close(fd);\n        }\n\n        /* Run command */\n        execvp(command, (char **)args);\n    }\n    else if (pid == -1) /* error in fork */\n    {\n        ret = -1;\n    }\n    else { /* parent */\n        wait(&ret);\n    }\n\n    free(args);\n    return ret;\n}\n"], "filenames": ["src/shared/dlt_common.c"], "buggy_code_start_loc": [1721], "buggy_code_end_loc": [1722], "fixing_code_start_loc": [1721], "fixing_code_end_loc": [1722], "type": "CWE-120", "message": "Connected Vehicle Systems Alliance (COVESA) up to v2.18.8 was discovered to contain a buffer overflow via the component /shared/dlt_common.c.", "other": {"cve": {"id": "CVE-2023-36321", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-17T23:15:11.513", "lastModified": "2023-10-24T23:40:13.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Connected Vehicle Systems Alliance (COVESA) up to v2.18.8 was discovered to contain a buffer overflow via the component /shared/dlt_common.c."}, {"lang": "es", "value": "Se descubri\u00f3 que Connected Vehicle Systems Alliance (COVESA) hasta v2.18.8 conten\u00eda un desbordamiento de b\u00fafer a trav\u00e9s del componente /shared/dlt_common.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:covesa:dlt-daemon:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.18.8", "matchCriteriaId": "66004448-7EF2-4593-88DC-D85CB481BD06"}]}]}], "references": [{"url": "https://github.com/COVESA/dlt-daemon/issues/436", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/michael-methner/dlt-daemon/commit/8ac9a080bee25e67e49bd138d81c992ce7b6d899", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/michael-methner/dlt-daemon/commit/8ac9a080bee25e67e49bd138d81c992ce7b6d899"}}