{"buggy_code": ["/* radare - LGPL - Copyright 2009-2016 - earada, pancake */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n\n#include <dalvik/opcode.h>\n\nstatic int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {\n\tint vA, vB, vC, payload = 0, i = (int) buf[0];\n\tint size = dalvik_opcodes[i].len;\n\tchar str[1024], *strasm;\n\tut64 offset;\n\tconst char *flag_str; \n\n\top->buf_asm[0] = 0;\n\tif (buf[0] == 0x00) { /* nop */\n\t\tswitch (buf[1]) {\n\t\tcase 0x01: /* packed-switch-payload */\n\t\t\t// ushort size\n\t\t\t// int first_key\n\t\t\t// int[size] = relative offsets\n\t\t\t{\n\t\t\t\tunsigned short array_size = buf[2] | (buf[3] << 8);\n\t\t\t\tint first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\n\t\t\t\tsprintf (op->buf_asm, \"packed-switch-payload %d, %d\", array_size, first_key);\n\t\t\t\tsize = 8;\n\t\t\t\tpayload = 2 * (array_size * 2);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x02: /* sparse-switch-payload */\n\t\t\t// ushort size\n\t\t\t// int[size] keys\n\t\t\t// int[size] relative offsets\n\t\t\t{\n\t\t\t\tunsigned short array_size = buf[2] | (buf[3] << 8);\n\t\t\t\tsprintf (op->buf_asm, \"sparse-switch-payload %d\", array_size);\n\t\t\t\tsize = 4;\n\t\t\t\tpayload = 2 * (array_size*4);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* fill-array-data-payload */\n\t\t\t// element_width = 2 bytes ushort little endian\n\t\t\t// size = 4 bytes uint\n\t\t\t// ([size*element_width+1)/2)+4\n\t\t\tif (len > 7) {\n\t\t\t\tunsigned short elem_width = buf[2] | (buf[3] << 8);\n\t\t\t\tunsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\n\t\t\t\tsnprintf (op->buf_asm, sizeof (op->buf_asm),\n\t\t\t\t\t\"fill-array-data-payload %d, %d\",\n\t\t\t\t\telem_width, array_size);\n\t\t\t\tpayload = 2 * ((array_size * elem_width+1)/2);\n\t\t\t}\n\t\t\tsize = 8;\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* nop */\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrasm = NULL;\n\tif (size <= len) {\n\t\tstrncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);\n\t\tstrasm = strdup (op->buf_asm);\n\t\tsize = dalvik_opcodes[i].len;\n\t\tswitch (dalvik_opcodes[i].fmt) {\n\t\tcase fmtop: break;\n\t\tcase fmtopvAvB:\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tsprintf (str, \" v%i, v%i\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tsprintf (str, \" v%i, v%i\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAAAvBBBB: // buf[1] seems useless :/\n\t\t\tvA = (buf[3] << 8) | buf[2];\n\t\t\tvB = (buf[5] << 8) | buf[4];\n\t\t\tsprintf (str, \" v%i, v%i\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAA:\n\t\t\tvA = (int) buf[1];\n\t\t\tsprintf (str, \" v%i\", vA);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAcB:\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tsprintf (str, \" v%i, %#x\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\t{\n\t\t\t\tshort sB = (buf[3] << 8) | buf[2];\n\t\t\t\tsprintf (str, \" v%i, %#04hx\", vA, sB);\n\t\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);\n\t\t\tif (buf[0] == 0x17) { //const-wide/32\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n\t\t\t} else { //const\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBB0000:\n\t\t\tvA = (int) buf[1];\n\t\t\t// vB = 0|(buf[3]<<16)|(buf[2]<<24);\n\t\t\tvB = 0 | (buf[2] << 16) | (buf[3] << 24);\n\t\t\tif (buf[0] == 0x19) { // const-wide/high16\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBBBBBBBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\t#define llint long long int\n\t\t\tllint lB = (llint)buf[2] | ((llint)buf[3] << 8)|\n\t\t\t\t((llint)buf[4] << 16) | ((llint)buf[5] << 24)|\n\t\t\t\t((llint)buf[6] << 32) | ((llint)buf[7] << 40)|\n\t\t\t\t((llint)buf[8] << 48) | ((llint)buf[9] << 56);\n\t\t\t#undef llint\n\t\t\tsprintf (str, \" v%i:v%i, 0x%\"PFMT64x, vA, vA + 1, lB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBvCC:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) buf[2];\n\t\t\tvC = (int) buf[3];\n\t\t\tsprintf (str, \" v%i, v%i, v%i\", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBcCC:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) buf[2];\n\t\t\tvC = (int) buf[3];\n\t\t\tsprintf (str, \" v%i, v%i, %#x\", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBcCCCC:\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (buf[3] << 8) | buf[2];\n\t\t\tsprintf (str, \" v%i, v%i, %#x\", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAA:\n\t\t\tvA = (char) buf[1];\n\t\t\t//sprintf (str, \" %i\", vA*2); // vA : word -> byte\n\t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2)); // vA : word -> byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAAAA:\n\t\t\tvA = (short) (buf[3] << 8 | buf[2]);\n\t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2)); // vA : word -> byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAApBBBB: // if-*z\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[3] << 8 | buf[2]);\n\t\t\t//sprintf (str, \" v%i, %i\", vA, vB);\n\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + (vB * 2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAAAAAAAA:\n\t\t\tvA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\n\t\t\t//sprintf (str, \" %#08x\", vA*2); // vA: word -> byte\n\t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA*2)); // vA : word -> byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBpCCCC: // if-*\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (int) (buf[3] << 8 | buf[2]);\n\t\t\t//sprintf (str, \" v%i, v%i, %i\", vA, vB, vC);\n\t\t\tsnprintf (str, sizeof (str),\" v%i, v%i, 0x%08\"PFMT64x, vA, vB, a->pc + (vC * 2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAApBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\n\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + vB); // + (vB*2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinlineI:\n\t\t\tvA = (int) (buf[1] & 0x0f);\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\t*str = 0;\n\t\t\tswitch (vA) {\n\t\t\tcase 1:\n\t\t\t\tsprintf (str, \" {v%i}\", buf[4] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf (str, \" {}\");\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tsprintf (str, \", [%04x]\", vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinlineIR:\n\t\tcase fmtoptinvokeVSR:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tvC = (buf[5] << 8) | buf[4];\n\t\t\tsprintf (str, \" {v%i..v%i}, [%04x]\", vC, vC + vA - 1, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinvokeVS:\n\t\t\tvA = (int) (buf[1] & 0xf0) >> 4;\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tswitch (vA) {\n\t\t\tcase 1:\n\t\t\t\tsprintf (str, \" {v%i}\", buf[4] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf (str, \" {}\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tsprintf (str, \", [%04x]\", vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAtBBBB: // \"sput-*\"\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tif (buf[0] == 0x1a) {\n\t\t\t\toffset = R_ASM_GET_OFFSET (a, 's', vB);\n\t\t\t\tif (offset == -1) {\n\t\t\t\t\tsprintf (str, \" v%i, string+%i\", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);\n\t\t\t\t}\n\t\t\t} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);\n\t\t\t\tif (!flag_str) {\n\t\t\t\t\tsprintf (str, \" v%i, class+%i\", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, \" v%i, %s\", vA, flag_str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'f', vB);\n\t\t\t\tif (!flag_str) {\n\t\t\t\t\tsprintf (str, \" v%i, field+%i\", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, \" v%i, %s\", vA, flag_str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptopvAvBoCCCC:\n\t\t\tvA = (buf[1] & 0x0f);\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (buf[3]<<8) | buf[2];\n\t\t\toffset = R_ASM_GET_OFFSET (a, 'o', vC);\n\t\t\tif (offset == -1) {\n\t\t\t\tsprintf (str, \" v%i, v%i, [obj+%04x]\", vA, vB, vC);\n\t\t\t} else {\n\t\t\t\tsprintf (str, \" v%i, v%i, [0x%\"PFMT64x\"]\", vA, vB, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopAAtBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\toffset = R_ASM_GET_OFFSET (a, 't', vB);\n\t\t\tif (offset == -1) {\n\t\t\t\tsprintf (str, \" v%i, thing+%i\", vA, vB);\n\t\t\t} else {\n\t\t\t\tsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBtCCCC:\n\t\t\tvA = (buf[1] & 0x0f);\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (buf[3] << 8) | buf[2];\n\t\t\tif (buf[0] == 0x20 || buf[0] == 0x23) { //instance-of & new-array\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vC);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, \" v%i, v%i, %s\", vA, vB, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, \" v%i, v%i, class+%i\", vA, vB, vC);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'f', vC);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, \" v%i, v%i, %s\", vA, vB, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, \" v%i, v%i, field+%i\", vA, vB, vC);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAtBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));\n\t\t\toffset = R_ASM_GET_OFFSET (a, 's', vB);\n\t\t\tif (offset == -1) {\n\t\t\t\tsprintf (str, \" v%i, string+%i\", vA, vB);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvCCCCmBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tvC = (buf[5] << 8) | buf[4];\n\t\t\tif (buf[0] == 0x25) { // filled-new-array/range\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, \" {v%i..v%i}, class+%i\", vC, vC + vA - 1, vB);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'm', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsprintf (str, \" {v%i..v%i}, method+%i\", vC, vC + vA - 1, vB);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvXtBBBB:\n\t\t\tvA = (int) (buf[1] & 0xf0) >> 4;\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tswitch (vA) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsprintf (str, \" {v%i}\", buf[4] & 0x0f);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f); // TOODO: recheck this\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsprintf (str, \" {}\");\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tif (buf[0] == 0x24) { // filled-new-array\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, \", %s ; 0x%x\", flag_str, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, \", class+%i\", vB);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'm', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsprintf (str, \", %s ; 0x%x\", flag_str, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf (str, \", method+%i\", vB);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinvokeI: // Any opcode has this formats\n\t\tcase fmtoptinvokeIR:\n\t\tcase fmt00:\n\t\tdefault:\n\t\t\tstrcpy (op->buf_asm, \"invalid \");\n\t\t\tfree (strasm);\n\t\t\tstrasm = NULL;\n\t\t\tsize = 2;\n\t\t}\n\t\tif (strasm) {\n\t\t\tstrncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);\n\t\t\top->buf_asm[sizeof (op->buf_asm) - 1] = 0;\n\t\t} else {\n\t\t\t//op->buf_asm[0] = 0;\n\t\t\tstrcpy (op->buf_asm , \"invalid\");\n\t\t}\n\t} else if (len > 0) {\n\t\tstrcpy (op->buf_asm, \"invalid \");\n\t\top->size = len;\n\t\tsize = len;\n\t}\n\top->payload = payload;\n\tsize += payload; // XXX\n\t// align to 2\n\top->size = size;\n\tfree (strasm);\n\treturn size;\n}\n\n//TODO\nstatic int dalvik_assemble(RAsm *a, RAsmOp *op, const char *buf) {\n\tint i;\n\tchar *p = strchr (buf, ' ');\n\tif (p) {\n\t\t*p = 0;\n\t}\n\t// TODO: use a hashtable here\n\tfor (i = 0; i < 256; i++) {\n\t\tif (!strcmp (dalvik_opcodes[i].name, buf)) {\n\t\t\tr_write_ble32 (op->buf, i, a->big_endian);\n\t\t\top->size = dalvik_opcodes[i].len;\n\t\t\treturn op->size;\n\t\t}\n\t}\n\treturn 0;\n}\n\nRAsmPlugin r_asm_plugin_dalvik = {\n\t.name = \"dalvik\",\n\t.arch = \"dalvik\",\n\t.license = \"LGPL3\",\n\t.desc = \"AndroidVM Dalvik\",\n\t.bits = 32 | 64,\n\t.endian = R_SYS_ENDIAN_LITTLE,\n\t.disassemble = &dalvik_disassemble,\n\t.assemble = &dalvik_assemble,\n};\n\n#ifndef CORELIB\nstruct r_lib_struct_t radare_plugin = {\n\t.type = R_LIB_TYPE_ASM,\n\t.data = &r_asm_plugin_dalvik,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2016 - earada, pancake */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n\n#include <dalvik/opcode.h>\n\nstatic int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {\n\tint vA, vB, vC, payload = 0, i = (int) buf[0];\n\tint size = dalvik_opcodes[i].len;\n\tchar str[1024], *strasm;\n\tut64 offset;\n\tconst char *flag_str; \n\n\top->buf_asm[0] = 0;\n\tif (buf[0] == 0x00) { /* nop */\n\t\tswitch (buf[1]) {\n\t\tcase 0x01: /* packed-switch-payload */\n\t\t\t// ushort size\n\t\t\t// int first_key\n\t\t\t// int[size] = relative offsets\n\t\t\t{\n\t\t\t\tunsigned short array_size = buf[2] | (buf[3] << 8);\n\t\t\t\tint first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\n\t\t\t\tsnprintf (op->buf_asm, sizeof(op->buf_asm), \"packed-switch-payload %d, %d\", array_size, first_key);\n\t\t\t\tsize = 8;\n\t\t\t\tpayload = 2 * (array_size * 2);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x02: /* sparse-switch-payload */\n\t\t\t// ushort size\n\t\t\t// int[size] keys\n\t\t\t// int[size] relative offsets\n\t\t\t{\n\t\t\t\tunsigned short array_size = buf[2] | (buf[3] << 8);\n\t\t\t\tsnprintf (op->buf_asm, sizeof (op->buf_asm), \"sparse-switch-payload %d\", array_size);\n\t\t\t\tsize = 4;\n\t\t\t\tpayload = 2 * (array_size*4);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* fill-array-data-payload */\n\t\t\t// element_width = 2 bytes ushort little endian\n\t\t\t// size = 4 bytes uint\n\t\t\t// ([size*element_width+1)/2)+4\n\t\t\tif (len > 7) {\n\t\t\t\tunsigned short elem_width = buf[2] | (buf[3] << 8);\n\t\t\t\tunsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\n\t\t\t\tsnprintf (op->buf_asm, sizeof (op->buf_asm),\n\t\t\t\t\t\"fill-array-data-payload %d, %d\",\n\t\t\t\t\telem_width, array_size);\n\t\t\t\tpayload = 2 * ((array_size * elem_width+1)/2);\n\t\t\t}\n\t\t\tsize = 8;\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* nop */\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrasm = NULL;\n\tif (size <= len) {\n\t\tstrncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);\n\t\tstrasm = strdup (op->buf_asm);\n\t\tsize = dalvik_opcodes[i].len;\n\t\tswitch (dalvik_opcodes[i].fmt) {\n\t\tcase fmtop: break;\n\t\tcase fmtopvAvB:\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAAAvBBBB: // buf[1] seems useless :/\n\t\t\tvA = (buf[3] << 8) | buf[2];\n\t\t\tvB = (buf[5] << 8) | buf[4];\n\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAA:\n\t\t\tvA = (int) buf[1];\n\t\t\tsnprintf (str, sizeof (str), \" v%i\", vA);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAcB:\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tsnprintf (str, sizeof (str), \" v%i, %#x\", vA, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\t{\n\t\t\t\tshort sB = (buf[3] << 8) | buf[2];\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, %#04hx\", vA, sB);\n\t\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);\n\t\t\tif (buf[0] == 0x17) { //const-wide/32\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n\t\t\t} else { //const\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBB0000:\n\t\t\tvA = (int) buf[1];\n\t\t\t// vB = 0|(buf[3]<<16)|(buf[2]<<24);\n\t\t\tvB = 0 | (buf[2] << 16) | (buf[3] << 24);\n\t\t\tif (buf[0] == 0x19) { // const-wide/high16\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAcBBBBBBBBBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\t#define llint long long int\n\t\t\tllint lB = (llint)buf[2] | ((llint)buf[3] << 8)|\n\t\t\t\t((llint)buf[4] << 16) | ((llint)buf[5] << 24)|\n\t\t\t\t((llint)buf[6] << 32) | ((llint)buf[7] << 40)|\n\t\t\t\t((llint)buf[8] << 48) | ((llint)buf[9] << 56);\n\t\t\t#undef llint\n\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%\"PFMT64x, vA, vA + 1, lB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBvCC:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) buf[2];\n\t\t\tvC = (int) buf[3];\n\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, v%i\", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAvBBcCC:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) buf[2];\n\t\t\tvC = (int) buf[3];\n\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %#x\", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBcCCCC:\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (buf[3] << 8) | buf[2];\n\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %#x\", vA, vB, vC);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAA:\n\t\t\tvA = (char) buf[1];\n\t\t\t//snprintf (str, sizeof (str), \" %i\", vA*2); // vA : word -> byte\n\t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2)); // vA : word -> byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAAAA:\n\t\t\tvA = (short) (buf[3] << 8 | buf[2]);\n\t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2)); // vA : word -> byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAApBBBB: // if-*z\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[3] << 8 | buf[2]);\n\t\t\t//snprintf (str, sizeof (str), \" v%i, %i\", vA, vB);\n\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + (vB * 2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoppAAAAAAAA:\n\t\t\tvA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\n\t\t\t//snprintf (str, sizeof (str), \" %#08x\", vA*2); // vA: word -> byte\n\t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA*2)); // vA : word -> byte\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBpCCCC: // if-*\n\t\t\tvA = buf[1] & 0x0f;\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (int) (buf[3] << 8 | buf[2]);\n\t\t\t//snprintf (str, sizeof (str), \" v%i, v%i, %i\", vA, vB, vC);\n\t\t\tsnprintf (str, sizeof (str),\" v%i, v%i, 0x%08\"PFMT64x, vA, vB, a->pc + (vC * 2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAApBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));\n\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + vB); // + (vB*2));\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinlineI:\n\t\t\tvA = (int) (buf[1] & 0x0f);\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\t*str = 0;\n\t\t\tswitch (vA) {\n\t\t\tcase 1:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf (str, sizeof (str), \" {}\");\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tsnprintf (str, sizeof (str), \", [%04x]\", vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinlineIR:\n\t\tcase fmtoptinvokeVSR:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tvC = (buf[5] << 8) | buf[4];\n\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, [%04x]\", vC, vC + vA - 1, vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinvokeVS:\n\t\t\tvA = (int) (buf[1] & 0xf0) >> 4;\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tswitch (vA) {\n\t\t\tcase 1:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf (str, sizeof (str), \" {}\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tsnprintf (str, sizeof (str), \", [%04x]\", vB);\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAtBBBB: // \"sput-*\"\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tif (buf[0] == 0x1a) {\n\t\t\t\toffset = R_ASM_GET_OFFSET (a, 's', vB);\n\t\t\t\tif (offset == -1) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, string+%i\", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);\n\t\t\t\t}\n\t\t\t} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);\n\t\t\t\tif (!flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, class+%i\", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, %s\", vA, flag_str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'f', vB);\n\t\t\t\tif (!flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, field+%i\", vA, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, %s\", vA, flag_str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptopvAvBoCCCC:\n\t\t\tvA = (buf[1] & 0x0f);\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (buf[3]<<8) | buf[2];\n\t\t\toffset = R_ASM_GET_OFFSET (a, 'o', vC);\n\t\t\tif (offset == -1) {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, [obj+%04x]\", vA, vB, vC);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, [0x%\"PFMT64x\"]\", vA, vB, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopAAtBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\toffset = R_ASM_GET_OFFSET (a, 't', vB);\n\t\t\tif (offset == -1) {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, thing+%i\", vA, vB);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAvBtCCCC:\n\t\t\tvA = (buf[1] & 0x0f);\n\t\t\tvB = (buf[1] & 0xf0) >> 4;\n\t\t\tvC = (buf[3] << 8) | buf[2];\n\t\t\tif (buf[0] == 0x20 || buf[0] == 0x23) { //instance-of & new-array\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vC);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %s\", vA, vB, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, class+%i\", vA, vB, vC);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'f', vC);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %s\", vA, vB, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, field+%i\", vA, vB, vC);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvAAtBBBBBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));\n\t\t\toffset = R_ASM_GET_OFFSET (a, 's', vB);\n\t\t\tif (offset == -1) {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, string+%i\", vA, vB);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvCCCCmBBBB:\n\t\t\tvA = (int) buf[1];\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tvC = (buf[5] << 8) | buf[4];\n\t\t\tif (buf[0] == 0x25) { // filled-new-array/range\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, class+%i\", vC, vC + vA - 1, vB);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'm', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, method+%i\", vC, vC + vA - 1, vB);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtopvXtBBBB:\n\t\t\tvA = (int) (buf[1] & 0xf0) >> 4;\n\t\t\tvB = (buf[3] << 8) | buf[2];\n\t\t\tswitch (vA) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,\n\t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f); // TOODO: recheck this\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsnprintf (str, sizeof (str), \" {}\");\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tif (buf[0] == 0x24) { // filled-new-array\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \", %s ; 0x%x\", flag_str, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (str, sizeof (str), \", class+%i\", vB);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag_str = R_ASM_GET_NAME (a, 'm', vB);\n\t\t\t\tif (flag_str) {\n\t\t\t\t\tsnprintf (str, sizeof (str), \", %s ; 0x%x\", flag_str, vB);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (str, sizeof (str), \", method+%i\", vB);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tstrasm = r_str_concat (strasm, str);\n\t\t\tbreak;\n\t\tcase fmtoptinvokeI: // Any opcode has this formats\n\t\tcase fmtoptinvokeIR:\n\t\tcase fmt00:\n\t\tdefault:\n\t\t\tstrcpy (op->buf_asm, \"invalid \");\n\t\t\tfree (strasm);\n\t\t\tstrasm = NULL;\n\t\t\tsize = 2;\n\t\t}\n\t\tif (strasm) {\n\t\t\tstrncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);\n\t\t\top->buf_asm[sizeof (op->buf_asm) - 1] = 0;\n\t\t} else {\n\t\t\t//op->buf_asm[0] = 0;\n\t\t\tstrcpy (op->buf_asm , \"invalid\");\n\t\t}\n\t} else if (len > 0) {\n\t\tstrcpy (op->buf_asm, \"invalid \");\n\t\top->size = len;\n\t\tsize = len;\n\t}\n\top->payload = payload;\n\tsize += payload; // XXX\n\t// align to 2\n\top->size = size;\n\tfree (strasm);\n\treturn size;\n}\n\n//TODO\nstatic int dalvik_assemble(RAsm *a, RAsmOp *op, const char *buf) {\n\tint i;\n\tchar *p = strchr (buf, ' ');\n\tif (p) {\n\t\t*p = 0;\n\t}\n\t// TODO: use a hashtable here\n\tfor (i = 0; i < 256; i++) {\n\t\tif (!strcmp (dalvik_opcodes[i].name, buf)) {\n\t\t\tr_write_ble32 (op->buf, i, a->big_endian);\n\t\t\top->size = dalvik_opcodes[i].len;\n\t\t\treturn op->size;\n\t\t}\n\t}\n\treturn 0;\n}\n\nRAsmPlugin r_asm_plugin_dalvik = {\n\t.name = \"dalvik\",\n\t.arch = \"dalvik\",\n\t.license = \"LGPL3\",\n\t.desc = \"AndroidVM Dalvik\",\n\t.bits = 32 | 64,\n\t.endian = R_SYS_ENDIAN_LITTLE,\n\t.disassemble = &dalvik_disassemble,\n\t.assemble = &dalvik_assemble,\n};\n\n#ifndef CORELIB\nstruct r_lib_struct_t radare_plugin = {\n\t.type = R_LIB_TYPE_ASM,\n\t.data = &r_asm_plugin_dalvik,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/asm/p/asm_dalvik.c"], "buggy_code_start_loc": [29], "buggy_code_end_loc": [408], "fixing_code_start_loc": [29], "fixing_code_end_loc": [408], "type": "CWE-119", "message": "The dalvik_disassemble function in libr/asm/p/asm_dalvik.c in radare2 1.2.1 allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file.", "other": {"cve": {"id": "CVE-2017-6448", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-03T05:59:00.957", "lastModified": "2017-04-10T21:37:59.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The dalvik_disassemble function in libr/asm/p/asm_dalvik.c in radare2 1.2.1 allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file."}, {"lang": "es", "value": "La funci\u00f3n dalvik_disassemble en libr/asm/p/asm_dalvik.c en radare2 1.2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (Desbordamiento de buffer basado en pila y ca\u00edda de la aplicaci\u00f3n) o posiblemente tener otros impactos inexpec\u00edficos a trav\u00e9s de un archivo DEX manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1E2BB74D-D369-43D4-9EDB-3F0DD27091B0"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97313", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/f41e941341e44aa86edd4483c4487ec09a074257", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/radare/radare2/issues/6885", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/f41e941341e44aa86edd4483c4487ec09a074257"}}