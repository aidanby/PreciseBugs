{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_HINTING)\n\nBool IsHintTrack(GF_TrackBox *trak)\n{\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT) return GF_FALSE;\n\t//QT doesn't specify any InfoHeader on HintTracks\n\tif (trak->Media->information->InfoHeader\n\t        && (trak->Media->information->InfoHeader->type != GF_ISOM_BOX_TYPE_HMHD)\n\t        && (trak->Media->information->InfoHeader->type != GF_ISOM_BOX_TYPE_NMHD)\n\t\t)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nu32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}\n\nBool CheckHintFormat(GF_TrackBox *trak, u32 HintType)\n{\n\tif (!IsHintTrack(trak)) return GF_FALSE;\n\tif (GetHintFormat(trak) != HintType) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err AdjustHintInfo(GF_HintSampleEntryBox *entry, u32 HintSampleNumber)\n{\n\tu32 offset, count, i, size;\n\tGF_Err e;\n\n\toffset = gf_isom_hint_sample_size(entry->hint_sample) - entry->hint_sample->dataLength;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_HintPacket *pck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, i);\n\t\tif (offset && entry->hint_sample->dataLength) {\n\t\t\t//adjust any offset in this packet\n\t\t\te = gf_isom_hint_pck_offset(pck, offset, HintSampleNumber);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//adjust the max packet size for this sample entry...\n\t\tsize = gf_isom_hint_pck_length(pck);\n\t\tif (entry->MaxPacketSize < size) entry->MaxPacketSize = size;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_setup_hint_track(GF_ISOFile *movie, u32 trackNumber, GF_ISOHintFormat HintType)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_HintMediaHeaderBox *hmhd;\n\t//UDTA related ...\n\tGF_UserDataBox *udta;\n\n\n\t//what do we support\n\tswitch (HintType) {\n\tcase GF_ISOM_HINT_RTP:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return gf_isom_last_error(movie);\n\n\t//check we have a hint ...\n\tif ( !IsHintTrack(trak)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\thmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\t//make sure the subtype was not already defined\n\tif (hmhd->subType) return GF_BAD_PARAM;\n\t//store the HintTrack format for later use...\n\thmhd->subType = HintType;\n\n\n\t//hint tracks always have a tref and everything ...\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\t//do we have a hint reference on this trak ???\n\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_HINT, &dpnd);\n\tif (e) return e;\n\t//if yes, return false (existing hint track...)\n\tif (dpnd) return GF_BAD_PARAM;\n\n\t//create our dep\n\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\tif (!dpnd) return GF_OUT_OF_MEM;\n\tdpnd->reference_type = GF_ISOM_BOX_TYPE_HINT;\n\n\t//for RTP, we need to do some UDTA-related stuff...\n\tif (HintType != GF_ISOM_HINT_RTP) return GF_OK;\n\n\tif (!trak->udta) {\n\t\t//create one\n\t\tudta = (GF_UserDataBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA);\n\t\tif (!udta) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) udta, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tudta = trak->udta;\n\n\t//HNTI\n\te = udta_on_child_box((GF_Box *)udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HNTI), GF_FALSE);\n\tif (e) return e;\n\n\t/*\n\t\t//NAME\n\t\te = udta_on_child_box((GF_Box *)udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_NAME));\n\t\tif (e) return e;\n\t\t//HINF\n\t\treturn udta_on_child_box((GF_Box *)udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HINF));\n\t*/\n\treturn GF_OK;\n}\n\n//to use with internally supported protocols\nGF_EXPORT\nGF_Err gf_isom_new_hint_description(GF_ISOFile *the_file, u32 trackNumber, s32 HintTrackVersion, s32 LastCompatibleVersion, u8 Rely, u32 *HintDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_RelyHintBox *relyA;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t*HintDescriptionIndex = 0;\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GetHintFormat(trak));\n\tif (!hdesc) return GF_OUT_OF_MEM;\n\n\tif (HintTrackVersion > 0) hdesc->HintTrackVersion = HintTrackVersion;\n\tif (LastCompatibleVersion > 0) hdesc->LastCompatibleVersion = LastCompatibleVersion;\n\n\t//create a data reference - WE ONLY DEAL WITH SELF-CONTAINED HINT TRACKS\n\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, NULL, NULL, &drefIndex);\n\tif (e) return e;\n\thdesc->dataReferenceIndex = drefIndex;\n\n\t*HintDescriptionIndex = gf_list_count(stsd->child_boxes);\n\n\t//RTP needs a default timeScale... use the media one.\n\tif (CheckHintFormat(trak, GF_ISOM_HINT_RTP)) {\n\t\te = gf_isom_rtp_set_timescale(the_file, trackNumber, *HintDescriptionIndex, trak->Media->mediaHeader->timeScale);\n\t\tif (e) return e;\n\t}\n\tif (!Rely) return GF_OK;\n\n\t//we need a rely box (common to all protocols)\n\trelyA = (GF_RelyHintBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_RELY);\n\tif (!relyA) return GF_OUT_OF_MEM;\n\tif (Rely == 1) {\n\t\trelyA->preferred = 1;\n\t} else {\n\t\trelyA->required = 1;\n\t}\n\treturn GF_OK;\n}\n\n\n/*******************************************************************\n\t\t\t\t\tRTP WRITING API\n*******************************************************************/\n\n//sets the RTP TimeScale\nGF_EXPORT\nGF_Err gf_isom_rtp_set_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeScale)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_TSHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_TSHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_TIMS) {\n\t\t\tent->timeScale = TimeScale;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_TSHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_TIMS);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->timeScale = TimeScale;\n\treturn GF_OK;\n}\n\n//sets the RTP TimeOffset that the server will add to the packets\n//if not set, the server adds a random offset\nGF_EXPORT\nGF_Err gf_isom_rtp_set_time_offset(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_TimeOffHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_TimeOffHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_TSRO) {\n\t\t\tent->TimeOffset = TimeOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_TimeOffHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_TSRO);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->TimeOffset = TimeOffset;\n\n\treturn GF_OK;\n}\n\n//sets the RTP SequenceNumber Offset that the server will add to the packets\n//if not set, the server adds a random offset\nGF_EXPORT\nGF_Err gf_isom_rtp_set_time_sequence_offset(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 SequenceNumberOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_SeqOffHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_SeqOffHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_SNRO) {\n\t\t\tent->SeqOffset = SequenceNumberOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_SeqOffHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_SNRO);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->SeqOffset = SequenceNumberOffset;\n\treturn GF_OK;\n}\n\n//Starts a new sample for the hint track. A sample is just a collection of packets\n//the transmissionTime is indicated in the media timeScale of the hint track\nGF_EXPORT\nGF_Err gf_isom_begin_hint_sample(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TransmissionTime)\n{\n\tGF_TrackBox *trak;\n\tu32 descIndex, dataRefIndex;\n\tGF_HintSample *samp;\n\tGF_HintSampleEntryBox *entry;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\t//assert we're increasing the timing...\n\tif (trak->Media->information->sampleTable->TimeToSample->w_LastDTS > TransmissionTime) return GF_BAD_PARAM;\n\n\t//store the descIndex for this sample\n\tdescIndex = HintDescriptionIndex;\n\tif (!HintDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one if no packet is used\n\tif (entry->hint_sample) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//create a new sample based on the protocol type of the hint description entry\n\tsamp = gf_isom_hint_sample_new(entry->type);\n\tif (!samp) return GF_NOT_SUPPORTED;\n\n\t//OK, let's store the time of this sample\n\tsamp->TransmissionTime = TransmissionTime;\n\t//OK, set our sample in the entry...\n\tentry->hint_sample = samp;\n\treturn GF_OK;\n}\n\n//stores the hint sample in the file\n//set IsRandomAccessPoint if you want to indicate that this is a random access point\n//in the stream\nGF_EXPORT\nGF_Err gf_isom_end_hint_sample(GF_ISOFile *the_file, u32 trackNumber, u8 IsRandomAccessPoint)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tGF_Err e;\n\tGF_BitStream *bs;\n\tGF_ISOSample *samp;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\t//first of all, we need to adjust the offset for data referenced IN THIS hint sample\n\t//and get some PckSize\n\te = AdjustHintInfo(entry, trak->Media->information->sampleTable->SampleSize->sampleCount + 1);\n\tif (e) return e;\n\n\t//ok, let's write the sample\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_hint_sample_write(entry->hint_sample, bs);\n\tif (e) {\n\t\tgf_bs_del(bs);\n\t\treturn e;\n\t}\n\tsamp = gf_isom_sample_new();\n\tsamp->CTS_Offset = 0;\n\tsamp->IsRAP = IsRandomAccessPoint;\n\tsamp->DTS = entry->hint_sample->TransmissionTime;\n\t//get the sample\n\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\tgf_bs_del(bs);\n\n\t//finally add the sample\n\te = gf_isom_add_sample(the_file, trackNumber, trak->Media->information->sampleTable->currentEntryIndex, samp);\n\tgf_isom_sample_del(&samp);\n\n\t//and delete the sample in our entry ...\n\tgf_isom_hint_sample_del(entry->hint_sample);\n\tentry->hint_sample = NULL;\n\treturn e;\n}\n\n\n//adds a blank chunk of data in the sample that is skipped while streaming\nGF_EXPORT\nGF_Err gf_isom_hint_blank_data(GF_ISOFile *the_file, u32 trackNumber, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tGF_HintPacket *pck;\n\tGF_EmptyDTE *dte;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_EmptyDTE *) NewDTE(0);\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\n\n//adds a chunk of data (max 14 bytes) in the packet that is directly copied\n//while streaming\nGF_EXPORT\nGF_Err gf_isom_hint_direct_data(GF_ISOFile *the_file, u32 trackNumber, u8 *data, u32 dataLength, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tGF_HintPacket *pck;\n\tGF_ImmediateDTE *dte;\n\tGF_Err e;\n\tu32 offset = 0;\n\n\tif (!dataLength) return GF_OK;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak) || (dataLength > 14)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_ImmediateDTE *) NewDTE(1);\n\tmemcpy(dte->data, data + offset, dataLength);\n\tdte->dataLength = dataLength;\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hint_sample_data(GF_ISOFile *the_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 SampleNumber, u16 DataLength, u32 offsetInSample, u8 *extra_data, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tu16 refIndex;\n\tGF_HintPacket *pck;\n\tGF_SampleDTE *dte;\n\tGF_Err e;\n\tGF_TrackReferenceTypeBox *hint;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_SampleDTE *) NewDTE(2);\n\n\tdte->dataLength = DataLength;\n\tdte->sampleNumber = SampleNumber;\n\tdte->byteOffset = offsetInSample;\n\n\t//we're getting data from another track\n\tif (SourceTrackID != trak->Header->trackID) {\n\t\t//get (or set) the track reference index\n\t\te = Track_FindRef(trak, GF_ISOM_REF_HINT, &hint);\n\t\tif (e) return e;\n\t\te = reftype_AddRefTrack(hint, SourceTrackID, &refIndex);\n\t\tif (e) return e;\n\t\t//WARNING: IN QT, MUST BE 0-based !!!\n\t\tdte->trackRefIndex = (u8) (refIndex - 1);\n\t} else {\n\t\t//we're in the hint track\n\t\tdte->trackRefIndex = (s8) -1;\n\t\t//basic check...\n\t\tif (SampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount + 1) {\n\t\t\tDelDTE((GF_GenericDTE *)dte);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\t//are we in the current sample ??\n\t\tif (!SampleNumber || (SampleNumber == trak->Media->information->sampleTable->SampleSize->sampleCount + 1)) {\n\t\t\t//we adding some stuff in the current sample ...\n\t\t\tdte->byteOffset += entry->hint_sample->dataLength;\n\t\t\tentry->hint_sample->AdditionalData = (char*)gf_realloc(entry->hint_sample->AdditionalData, sizeof(char) * (entry->hint_sample->dataLength + DataLength));\n\t\t\tif (AtBegin) {\n\t\t\t\tif (entry->hint_sample->dataLength)\n\t\t\t\t\tmemmove(entry->hint_sample->AdditionalData + DataLength, entry->hint_sample->AdditionalData, entry->hint_sample->dataLength);\n\t\t\t\tmemcpy(entry->hint_sample->AdditionalData, extra_data, DataLength);\n\t\t\t\t/*offset existing DTE*/\n\t\t\t\tgf_isom_hint_pck_offset(pck, DataLength, SampleNumber);\n\t\t\t} else {\n\t\t\t\tmemcpy(entry->hint_sample->AdditionalData + entry->hint_sample->dataLength, extra_data, DataLength);\n\t\t\t}\n\t\t\tentry->hint_sample->dataLength += DataLength;\n\t\t\t//and set the sample number ...\n\t\t\tdte->sampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount + 1;\n\t\t}\n\t}\n\t//OK, add the entry\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hint_sample_description_data(GF_ISOFile *the_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 StreamDescriptionIndex, u16 DataLength, u32 offsetInDescription, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tu16 refIndex;\n\tGF_HintPacket *pck;\n\tGF_StreamDescDTE *dte;\n\tGF_Err e;\n\tGF_TrackReferenceTypeBox *hint;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_StreamDescDTE *) NewDTE(3);\n\tdte->byteOffset = offsetInDescription;\n\tdte->dataLength = DataLength;\n\tdte->streamDescIndex = StreamDescriptionIndex;\n\tif (SourceTrackID == trak->Header->trackID) {\n\t\tdte->trackRefIndex = (s8) -1;\n\t} else {\n\t\t//get (or set) the track reference index\n\t\te = Track_FindRef(trak, GF_ISOM_REF_HINT, &hint);\n\t\tif (e) return e;\n\t\te = reftype_AddRefTrack(hint, SourceTrackID, &refIndex);\n\t\tif (e) return e;\n\t\t//WARNING: IN QT, MUST BE 0-based !!!\n\t\tdte->trackRefIndex = (u8) (refIndex - 1);\n\t}\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\nGF_EXPORT\nGF_Err gf_isom_rtp_packet_set_flags(GF_ISOFile *the_file, u32 trackNumber,\n                                    u8 PackingBit,\n                                    u8 eXtensionBit,\n                                    u8 MarkerBit,\n                                    u8 disposable_packet,\n                                    u8 IsRepeatedPacket)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tGF_RTPPacket *pck;\n\tu32 dataRefIndex, ind;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\tind = gf_list_count(entry->hint_sample->packetTable);\n\tif (!ind) return GF_BAD_PARAM;\n\tpck = (GF_RTPPacket *)gf_list_get(entry->hint_sample->packetTable, ind-1);\n\n\tpck->P_bit = PackingBit ? 1 : 0;\n\tpck->X_bit = eXtensionBit ? 1 : 0;\n\tpck->M_bit = MarkerBit ? 1 : 0;\n\tpck->B_bit = disposable_packet ? 1 : 0;\n\tpck->R_bit = IsRepeatedPacket ? 1 : 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_rtp_packet_begin(GF_ISOFile *the_file, u32 trackNumber,\n                                s32 relativeTime,\n                                u8 PackingBit,\n                                u8 eXtensionBit,\n                                u8 MarkerBit,\n                                u8 PayloadType,\n                                u8 B_frame,\n                                u8 IsRepeatedPacket,\n                                u16 SequenceNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tGF_RTPPacket *pck;\n\tu32 dataRefIndex;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\tpck = (GF_RTPPacket *) gf_isom_hint_pck_new(entry->type);\n\n\tpck->P_bit = PackingBit ? 1 : 0;\n\tpck->X_bit = eXtensionBit ? 1 : 0;\n\tpck->M_bit = MarkerBit ? 1 : 0;\n\tpck->payloadType = PayloadType;\n\tpck->SequenceNumber = SequenceNumber;\n\tpck->B_bit = B_frame ? 1 : 0;\n\tpck->R_bit = IsRepeatedPacket ? 1 : 0;\n\tpck->relativeTransTime = relativeTime;\n\treturn gf_list_add(entry->hint_sample->packetTable, pck);\n}\n\n\n//set the time offset of this packet. This enables packets to be placed in the hint track\n//in decoding order, but have their presentation time-stamp in the transmitted\n//packet be in a different order. Typically used for MPEG video with B-frames\nGF_EXPORT\nGF_Err gf_isom_rtp_packet_set_offset(GF_ISOFile *the_file, u32 trackNumber, s32 timeOffset)\n{\n\tGF_RTPOBox *rtpo;\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tGF_RTPPacket *pck;\n\tu32 dataRefIndex, i;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\tpck = (GF_RTPPacket *)gf_list_get(entry->hint_sample->packetTable, gf_list_count(entry->hint_sample->packetTable) - 1);\n\tif (!pck) return GF_BAD_PARAM;\n\n\t//look in the TLV\n\ti=0;\n\twhile ((rtpo = (GF_RTPOBox *)gf_list_enum(pck->TLV, &i))) {\n\t\tif (rtpo->type == GF_ISOM_BOX_TYPE_RTPO) {\n\t\t\trtpo->timeOffset = timeOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//not found, add it\n\trtpo = (GF_RTPOBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_RTPO);\n\tif (!rtpo) return GF_OUT_OF_MEM;\n\trtpo->timeOffset = timeOffset;\n\n\treturn gf_list_add(pck->TLV, rtpo);\n}\n\n\nstatic void AddSDPLine(GF_List *list, char *sdp_text, Bool is_movie_sdp)\n{\n\tconst char *sdp_order;\n\tu32 i, count = gf_list_count(list);\n\tchar fc = sdp_text[0];\n\n\tsdp_order = (is_movie_sdp) ? \"vosiuepcbzkatr\" : \"micbka\";\n\tfor (i=0; i<count; i++) {\n\t\tchar *l = (char *)gf_list_get(list, i);\n\t\tchar *s1 = (char *)strchr(sdp_order, l[0]);\n\t\tchar *s2 = (char *)strchr(sdp_order, fc);\n\t\tif (s1 && s2 && (strlen(s2)>strlen(s1))) {\n\t\t\tgf_list_insert(list, sdp_text, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_list_add(list, sdp_text);\n}\n\nstatic void ReorderSDP(char *sdp_text, Bool is_movie_sdp)\n{\n\tchar *cur;\n\tGF_List *lines = gf_list_new();\n\tcur = sdp_text;\n\twhile (cur) {\n\t\tchar b;\n\t\tchar *st = strstr(cur, \"\\r\\n\");\n\t\tassert(st);\n\t\tst += 2;\n\t\tif (!st[0]) {\n\t\t\tAddSDPLine(lines, gf_strdup(cur), is_movie_sdp);\n\t\t\tbreak;\n\t\t}\n\t\tb = st[0];\n\t\tst[0] = 0;\n\t\tAddSDPLine(lines, gf_strdup(cur), is_movie_sdp);\n\t\tst[0] = b;\n\t\tcur = st;\n\t}\n\tstrcpy(sdp_text, \"\");\n\twhile (gf_list_count(lines)) {\n\t\tcur = (char *)gf_list_get(lines, 0);\n\t\tgf_list_rem(lines, 0);\n\t\tstrcat(sdp_text, cur);\n\t\tgf_free(cur);\n\t}\n\tgf_list_del(lines);\n}\n\n//add an SDP line to the SDP container at the track level (media-specific SDP info)\nGF_EXPORT\nGF_Err gf_isom_sdp_add_track_line(GF_ISOFile *the_file, u32 trackNumber, const char *text)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\tGF_SDPBox *sdp;\n\tGF_Err e;\n\tchar *buf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//currently, only RTP hinting supports SDP\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_ISOM_INVALID_FILE;\n\n\t//we should have only one HNTI in the UDTA\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\tif (!hnti->SDP) {\n\t\te = hnti_on_child_box((GF_Box*)hnti, gf_isom_box_new_parent(&hnti->child_boxes, GF_ISOM_BOX_TYPE_SDP), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tsdp = (GF_SDPBox *) hnti->SDP;\n\n\tif (!sdp->sdpText) {\n\t\tsdp->sdpText = (char *)gf_malloc(sizeof(char) * (strlen(text) + 3));\n\t\tif (!sdp->sdpText) return GF_OUT_OF_MEM;\n\n\t\tstrcpy(sdp->sdpText, text);\n\t\tstrcat(sdp->sdpText, \"\\r\\n\");\n\t\treturn GF_OK;\n\t}\n\tbuf = (char *)gf_malloc(sizeof(char) * (strlen(sdp->sdpText) + strlen(text) + 3));\n\tif (!buf) return GF_OUT_OF_MEM;\n\n\tstrcpy(buf, sdp->sdpText);\n\tstrcat(buf, text);\n\tstrcat(buf, \"\\r\\n\");\n\tgf_free(sdp->sdpText);\n\tReorderSDP(buf, GF_FALSE);\n\tsdp->sdpText = buf;\n\treturn GF_OK;\n}\n\n//remove all SDP info at the track level\nGF_EXPORT\nGF_Err gf_isom_sdp_clean_track(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//currently, only RTP hinting supports SDP\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_ISOM_INVALID_FILE;\n\n\t//we should have only one HNTI in the UDTA\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\tif (!hnti->SDP) return GF_OK;\n\t//and free the SDP\n\tgf_free(((GF_SDPBox *)hnti->SDP)->sdpText);\n\t((GF_SDPBox *)hnti->SDP)->sdpText = NULL;\n\treturn GF_OK;\n}\n\n\n//add an SDP line to the SDP container at the movie level (presentation SDP info)\n//NOTE: the \\r\\n end of line for SDP is automatically inserted\nGF_EXPORT\nGF_Err gf_isom_sdp_add_line(GF_ISOFile *movie, const char *text)\n{\n\tGF_UserDataMap *map;\n\tGF_RTPBox *rtp;\n\tGF_Err e;\n\tGF_HintTrackInfoBox *hnti;\n\tchar *buf;\n\n\tif (!movie->moov) return GF_BAD_PARAM;\n\n\t//check if we have a udta ...\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a hnti in the udta\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) {\n\t\te = udta_on_child_box((GF_Box *)movie->moov->udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HNTI), GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\t}\n\n\t//there should be one and only one hnti\n\tif (!gf_list_count(map->boxes) ) {\n\t\te = udta_on_child_box((GF_Box *)movie->moov->udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HNTI), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\telse if (gf_list_count(map->boxes) < 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\n\tif (!hnti->SDP) {\n\t\tGF_Box *a = gf_isom_box_new_ex(GF_ISOM_BOX_TYPE_RTP, GF_ISOM_BOX_TYPE_HNTI, 0, GF_FALSE);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\thnti_on_child_box((GF_Box*)hnti, a, GF_FALSE);\n\t\tif (!hnti->child_boxes) hnti->child_boxes = gf_list_new();\n\t\tgf_list_add(hnti->child_boxes, a);\n\t}\n\trtp = (GF_RTPBox *) hnti->SDP;\n\n\tif (!rtp->sdpText) {\n\t\trtp->sdpText = (char*)gf_malloc(sizeof(char) * (strlen(text) + 3));\n\t\tif (!rtp->sdpText) return GF_OUT_OF_MEM;\n\n\t\tstrcpy(rtp->sdpText, text);\n\t\tstrcat(rtp->sdpText, \"\\r\\n\");\n\t\treturn GF_OK;\n\t}\n\tbuf = (char*)gf_malloc(sizeof(char) * (strlen(rtp->sdpText) + strlen(text) + 3));\n\tif (!buf) return GF_OUT_OF_MEM;\n\t\n\tstrcpy(buf, rtp->sdpText);\n\tstrcat(buf, text);\n\tstrcat(buf, \"\\r\\n\");\n\tgf_free(rtp->sdpText);\n\tReorderSDP(buf, GF_TRUE);\n\trtp->sdpText = buf;\n\treturn GF_OK;\n}\n\n\n//remove all SDP info at the movie level\nGF_EXPORT\nGF_Err gf_isom_sdp_clean(GF_ISOFile *movie)\n{\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\n\t//check if we have a udta ...\n\tif (!movie->moov || !movie->moov->udta) return GF_OK;\n\n\t//find a hnti in the udta\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_OK;\n\n\t//there should be one and only one hnti\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\n\t//remove and destroy the entry\n\tgf_list_rem(map->boxes, 0);\n\tgf_isom_box_del((GF_Box *)hnti);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Err gf_isom_sdp_get(GF_ISOFile *movie, const char **sdp, u32 *length)\n{\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\tGF_RTPBox *rtp;\n\t*length = 0;\n\t*sdp = NULL;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//check if we have a udta ...\n\tif (!movie->moov->udta) return GF_OK;\n\n\t//find a hnti in the udta\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_OK;\n\n\t//there should be one and only one hnti\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\n\tif (!hnti->SDP) return GF_OK;\n\trtp = (GF_RTPBox *) hnti->SDP;\n\n\t*length = (u32) strlen(rtp->sdpText);\n\t*sdp = rtp->sdpText;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_sdp_track_get(GF_ISOFile *the_file, u32 trackNumber, const char **sdp, u32 *length)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\tGF_SDPBox *sdpa;\n\n\t*sdp = NULL;\n\t*length = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->udta) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_ISOM_INVALID_FILE;\n\n\t//we should have only one HNTI in the UDTA\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\tif (!hnti->SDP) return GF_OK;\n\tsdpa = (GF_SDPBox *) hnti->SDP;\n\n\t*length = (u32) strlen(sdpa->sdpText);\n\t*sdp = sdpa->sdpText;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_payt_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintInfoBox *hinf;\n\tGF_PAYTBox *payt;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HINF, NULL);\n\tif (!map) return 0;\n\tif (gf_list_count(map->boxes) != 1) return 0;\n\n\thinf = (GF_HintInfoBox *)gf_list_get(map->boxes, 0);\n\tcount = 0;\n\ti = 0;\n\twhile ((payt = (GF_PAYTBox*)gf_list_enum(hinf->child_boxes, &i))) {\n\t\tif (payt->type == GF_ISOM_BOX_TYPE_PAYT) count++;\n\t}\n\treturn count;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_payt_info(GF_ISOFile *the_file, u32 trackNumber, u32 index, u32 *payID)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintInfoBox *hinf;\n\tGF_PAYTBox *payt;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !index) return NULL;\n\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HINF, NULL);\n\tif (!map) return NULL;\n\tif (gf_list_count(map->boxes) != 1) return NULL;\n\n\thinf = (GF_HintInfoBox *)gf_list_get(map->boxes, 0);\n\tcount = 0;\n\ti = 0;\n\twhile ((payt = (GF_PAYTBox*)gf_list_enum(hinf->child_boxes, &i))) {\n\t\tif (payt->type == GF_ISOM_BOX_TYPE_PAYT) {\n\t\t\tcount++;\n\t\t\tif (count == index) {\n\t\t\t\tif (payID) *payID=payt->payloadCode;\n\t\t\t\treturn payt->payloadString;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n#endif /*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_HINTING)*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_HINTING)\n\nBool IsHintTrack(GF_TrackBox *trak)\n{\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT) return GF_FALSE;\n\t//QT doesn't specify any InfoHeader on HintTracks\n\tif (trak->Media->information->InfoHeader\n\t        && (trak->Media->information->InfoHeader->type != GF_ISOM_BOX_TYPE_HMHD)\n\t        && (trak->Media->information->InfoHeader->type != GF_ISOM_BOX_TYPE_NMHD)\n\t\t)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nu32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD))\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}\n\nBool CheckHintFormat(GF_TrackBox *trak, u32 HintType)\n{\n\tif (!IsHintTrack(trak)) return GF_FALSE;\n\tif (GetHintFormat(trak) != HintType) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err AdjustHintInfo(GF_HintSampleEntryBox *entry, u32 HintSampleNumber)\n{\n\tu32 offset, count, i, size;\n\tGF_Err e;\n\n\toffset = gf_isom_hint_sample_size(entry->hint_sample) - entry->hint_sample->dataLength;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_HintPacket *pck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, i);\n\t\tif (offset && entry->hint_sample->dataLength) {\n\t\t\t//adjust any offset in this packet\n\t\t\te = gf_isom_hint_pck_offset(pck, offset, HintSampleNumber);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//adjust the max packet size for this sample entry...\n\t\tsize = gf_isom_hint_pck_length(pck);\n\t\tif (entry->MaxPacketSize < size) entry->MaxPacketSize = size;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_setup_hint_track(GF_ISOFile *movie, u32 trackNumber, GF_ISOHintFormat HintType)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_HintMediaHeaderBox *hmhd;\n\t//UDTA related ...\n\tGF_UserDataBox *udta;\n\n\n\t//what do we support\n\tswitch (HintType) {\n\tcase GF_ISOM_HINT_RTP:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return gf_isom_last_error(movie);\n\n\t//check we have a hint ...\n\tif ( !IsHintTrack(trak)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\thmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\t//make sure the subtype was not already defined\n\tif (hmhd->subType) return GF_BAD_PARAM;\n\t//store the HintTrack format for later use...\n\thmhd->subType = HintType;\n\n\n\t//hint tracks always have a tref and everything ...\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\t//do we have a hint reference on this trak ???\n\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_HINT, &dpnd);\n\tif (e) return e;\n\t//if yes, return false (existing hint track...)\n\tif (dpnd) return GF_BAD_PARAM;\n\n\t//create our dep\n\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\tif (!dpnd) return GF_OUT_OF_MEM;\n\tdpnd->reference_type = GF_ISOM_BOX_TYPE_HINT;\n\n\t//for RTP, we need to do some UDTA-related stuff...\n\tif (HintType != GF_ISOM_HINT_RTP) return GF_OK;\n\n\tif (!trak->udta) {\n\t\t//create one\n\t\tudta = (GF_UserDataBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA);\n\t\tif (!udta) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) udta, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tudta = trak->udta;\n\n\t//HNTI\n\te = udta_on_child_box((GF_Box *)udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HNTI), GF_FALSE);\n\tif (e) return e;\n\n\t/*\n\t\t//NAME\n\t\te = udta_on_child_box((GF_Box *)udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_NAME));\n\t\tif (e) return e;\n\t\t//HINF\n\t\treturn udta_on_child_box((GF_Box *)udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HINF));\n\t*/\n\treturn GF_OK;\n}\n\n//to use with internally supported protocols\nGF_EXPORT\nGF_Err gf_isom_new_hint_description(GF_ISOFile *the_file, u32 trackNumber, s32 HintTrackVersion, s32 LastCompatibleVersion, u8 Rely, u32 *HintDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_RelyHintBox *relyA;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t*HintDescriptionIndex = 0;\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GetHintFormat(trak));\n\tif (!hdesc) return GF_OUT_OF_MEM;\n\n\tif (HintTrackVersion > 0) hdesc->HintTrackVersion = HintTrackVersion;\n\tif (LastCompatibleVersion > 0) hdesc->LastCompatibleVersion = LastCompatibleVersion;\n\n\t//create a data reference - WE ONLY DEAL WITH SELF-CONTAINED HINT TRACKS\n\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, NULL, NULL, &drefIndex);\n\tif (e) return e;\n\thdesc->dataReferenceIndex = drefIndex;\n\n\t*HintDescriptionIndex = gf_list_count(stsd->child_boxes);\n\n\t//RTP needs a default timeScale... use the media one.\n\tif (CheckHintFormat(trak, GF_ISOM_HINT_RTP)) {\n\t\te = gf_isom_rtp_set_timescale(the_file, trackNumber, *HintDescriptionIndex, trak->Media->mediaHeader->timeScale);\n\t\tif (e) return e;\n\t}\n\tif (!Rely) return GF_OK;\n\n\t//we need a rely box (common to all protocols)\n\trelyA = (GF_RelyHintBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_RELY);\n\tif (!relyA) return GF_OUT_OF_MEM;\n\tif (Rely == 1) {\n\t\trelyA->preferred = 1;\n\t} else {\n\t\trelyA->required = 1;\n\t}\n\treturn GF_OK;\n}\n\n\n/*******************************************************************\n\t\t\t\t\tRTP WRITING API\n*******************************************************************/\n\n//sets the RTP TimeScale\nGF_EXPORT\nGF_Err gf_isom_rtp_set_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeScale)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_TSHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_TSHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_TIMS) {\n\t\t\tent->timeScale = TimeScale;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_TSHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_TIMS);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->timeScale = TimeScale;\n\treturn GF_OK;\n}\n\n//sets the RTP TimeOffset that the server will add to the packets\n//if not set, the server adds a random offset\nGF_EXPORT\nGF_Err gf_isom_rtp_set_time_offset(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_TimeOffHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_TimeOffHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_TSRO) {\n\t\t\tent->TimeOffset = TimeOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_TimeOffHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_TSRO);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->TimeOffset = TimeOffset;\n\n\treturn GF_OK;\n}\n\n//sets the RTP SequenceNumber Offset that the server will add to the packets\n//if not set, the server adds a random offset\nGF_EXPORT\nGF_Err gf_isom_rtp_set_time_sequence_offset(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 SequenceNumberOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *hdesc;\n\tu32 i, count;\n\tGF_SeqOffHintEntryBox *ent;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\t//OK, create a new HintSampleDesc\n\thdesc = (GF_HintSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, HintDescriptionIndex - 1);\n\tif (!hdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(hdesc->child_boxes);\n\n\tfor (i=0; i< count; i++) {\n\t\tent = (GF_SeqOffHintEntryBox *)gf_list_get(hdesc->child_boxes, i);\n\t\tif (ent->type == GF_ISOM_BOX_TYPE_SNRO) {\n\t\t\tent->SeqOffset = SequenceNumberOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//we have to create a new entry...\n\tent = (GF_SeqOffHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_ISOM_BOX_TYPE_SNRO);\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->SeqOffset = SequenceNumberOffset;\n\treturn GF_OK;\n}\n\n//Starts a new sample for the hint track. A sample is just a collection of packets\n//the transmissionTime is indicated in the media timeScale of the hint track\nGF_EXPORT\nGF_Err gf_isom_begin_hint_sample(GF_ISOFile *the_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TransmissionTime)\n{\n\tGF_TrackBox *trak;\n\tu32 descIndex, dataRefIndex;\n\tGF_HintSample *samp;\n\tGF_HintSampleEntryBox *entry;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\t//assert we're increasing the timing...\n\tif (trak->Media->information->sampleTable->TimeToSample->w_LastDTS > TransmissionTime) return GF_BAD_PARAM;\n\n\t//store the descIndex for this sample\n\tdescIndex = HintDescriptionIndex;\n\tif (!HintDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one if no packet is used\n\tif (entry->hint_sample) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//create a new sample based on the protocol type of the hint description entry\n\tsamp = gf_isom_hint_sample_new(entry->type);\n\tif (!samp) return GF_NOT_SUPPORTED;\n\n\t//OK, let's store the time of this sample\n\tsamp->TransmissionTime = TransmissionTime;\n\t//OK, set our sample in the entry...\n\tentry->hint_sample = samp;\n\treturn GF_OK;\n}\n\n//stores the hint sample in the file\n//set IsRandomAccessPoint if you want to indicate that this is a random access point\n//in the stream\nGF_EXPORT\nGF_Err gf_isom_end_hint_sample(GF_ISOFile *the_file, u32 trackNumber, u8 IsRandomAccessPoint)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tGF_Err e;\n\tGF_BitStream *bs;\n\tGF_ISOSample *samp;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\t//first of all, we need to adjust the offset for data referenced IN THIS hint sample\n\t//and get some PckSize\n\te = AdjustHintInfo(entry, trak->Media->information->sampleTable->SampleSize->sampleCount + 1);\n\tif (e) return e;\n\n\t//ok, let's write the sample\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_hint_sample_write(entry->hint_sample, bs);\n\tif (e) {\n\t\tgf_bs_del(bs);\n\t\treturn e;\n\t}\n\tsamp = gf_isom_sample_new();\n\tsamp->CTS_Offset = 0;\n\tsamp->IsRAP = IsRandomAccessPoint;\n\tsamp->DTS = entry->hint_sample->TransmissionTime;\n\t//get the sample\n\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\tgf_bs_del(bs);\n\n\t//finally add the sample\n\te = gf_isom_add_sample(the_file, trackNumber, trak->Media->information->sampleTable->currentEntryIndex, samp);\n\tgf_isom_sample_del(&samp);\n\n\t//and delete the sample in our entry ...\n\tgf_isom_hint_sample_del(entry->hint_sample);\n\tentry->hint_sample = NULL;\n\treturn e;\n}\n\n\n//adds a blank chunk of data in the sample that is skipped while streaming\nGF_EXPORT\nGF_Err gf_isom_hint_blank_data(GF_ISOFile *the_file, u32 trackNumber, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tGF_HintPacket *pck;\n\tGF_EmptyDTE *dte;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_EmptyDTE *) NewDTE(0);\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\n\n//adds a chunk of data (max 14 bytes) in the packet that is directly copied\n//while streaming\nGF_EXPORT\nGF_Err gf_isom_hint_direct_data(GF_ISOFile *the_file, u32 trackNumber, u8 *data, u32 dataLength, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tGF_HintPacket *pck;\n\tGF_ImmediateDTE *dte;\n\tGF_Err e;\n\tu32 offset = 0;\n\n\tif (!dataLength) return GF_OK;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak) || (dataLength > 14)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_ImmediateDTE *) NewDTE(1);\n\tmemcpy(dte->data, data + offset, dataLength);\n\tdte->dataLength = dataLength;\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hint_sample_data(GF_ISOFile *the_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 SampleNumber, u16 DataLength, u32 offsetInSample, u8 *extra_data, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tu16 refIndex;\n\tGF_HintPacket *pck;\n\tGF_SampleDTE *dte;\n\tGF_Err e;\n\tGF_TrackReferenceTypeBox *hint;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_SampleDTE *) NewDTE(2);\n\n\tdte->dataLength = DataLength;\n\tdte->sampleNumber = SampleNumber;\n\tdte->byteOffset = offsetInSample;\n\n\t//we're getting data from another track\n\tif (SourceTrackID != trak->Header->trackID) {\n\t\t//get (or set) the track reference index\n\t\te = Track_FindRef(trak, GF_ISOM_REF_HINT, &hint);\n\t\tif (e) return e;\n\t\te = reftype_AddRefTrack(hint, SourceTrackID, &refIndex);\n\t\tif (e) return e;\n\t\t//WARNING: IN QT, MUST BE 0-based !!!\n\t\tdte->trackRefIndex = (u8) (refIndex - 1);\n\t} else {\n\t\t//we're in the hint track\n\t\tdte->trackRefIndex = (s8) -1;\n\t\t//basic check...\n\t\tif (SampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount + 1) {\n\t\t\tDelDTE((GF_GenericDTE *)dte);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\t//are we in the current sample ??\n\t\tif (!SampleNumber || (SampleNumber == trak->Media->information->sampleTable->SampleSize->sampleCount + 1)) {\n\t\t\t//we adding some stuff in the current sample ...\n\t\t\tdte->byteOffset += entry->hint_sample->dataLength;\n\t\t\tentry->hint_sample->AdditionalData = (char*)gf_realloc(entry->hint_sample->AdditionalData, sizeof(char) * (entry->hint_sample->dataLength + DataLength));\n\t\t\tif (AtBegin) {\n\t\t\t\tif (entry->hint_sample->dataLength)\n\t\t\t\t\tmemmove(entry->hint_sample->AdditionalData + DataLength, entry->hint_sample->AdditionalData, entry->hint_sample->dataLength);\n\t\t\t\tmemcpy(entry->hint_sample->AdditionalData, extra_data, DataLength);\n\t\t\t\t/*offset existing DTE*/\n\t\t\t\tgf_isom_hint_pck_offset(pck, DataLength, SampleNumber);\n\t\t\t} else {\n\t\t\t\tmemcpy(entry->hint_sample->AdditionalData + entry->hint_sample->dataLength, extra_data, DataLength);\n\t\t\t}\n\t\t\tentry->hint_sample->dataLength += DataLength;\n\t\t\t//and set the sample number ...\n\t\t\tdte->sampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount + 1;\n\t\t}\n\t}\n\t//OK, add the entry\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hint_sample_description_data(GF_ISOFile *the_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 StreamDescriptionIndex, u16 DataLength, u32 offsetInDescription, u8 AtBegin)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tu32 count;\n\tu16 refIndex;\n\tGF_HintPacket *pck;\n\tGF_StreamDescDTE *dte;\n\tGF_Err e;\n\tGF_TrackReferenceTypeBox *hint;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\tcount = gf_list_count(entry->hint_sample->packetTable);\n\tif (!count) return GF_BAD_PARAM;\n\tpck = (GF_HintPacket *)gf_list_get(entry->hint_sample->packetTable, count - 1);\n\n\tdte = (GF_StreamDescDTE *) NewDTE(3);\n\tdte->byteOffset = offsetInDescription;\n\tdte->dataLength = DataLength;\n\tdte->streamDescIndex = StreamDescriptionIndex;\n\tif (SourceTrackID == trak->Header->trackID) {\n\t\tdte->trackRefIndex = (s8) -1;\n\t} else {\n\t\t//get (or set) the track reference index\n\t\te = Track_FindRef(trak, GF_ISOM_REF_HINT, &hint);\n\t\tif (e) return e;\n\t\te = reftype_AddRefTrack(hint, SourceTrackID, &refIndex);\n\t\tif (e) return e;\n\t\t//WARNING: IN QT, MUST BE 0-based !!!\n\t\tdte->trackRefIndex = (u8) (refIndex - 1);\n\t}\n\treturn gf_isom_hint_pck_add_dte(pck, (GF_GenericDTE *)dte, AtBegin);\n}\n\nGF_EXPORT\nGF_Err gf_isom_rtp_packet_set_flags(GF_ISOFile *the_file, u32 trackNumber,\n                                    u8 PackingBit,\n                                    u8 eXtensionBit,\n                                    u8 MarkerBit,\n                                    u8 disposable_packet,\n                                    u8 IsRepeatedPacket)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tGF_RTPPacket *pck;\n\tu32 dataRefIndex, ind;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\tind = gf_list_count(entry->hint_sample->packetTable);\n\tif (!ind) return GF_BAD_PARAM;\n\tpck = (GF_RTPPacket *)gf_list_get(entry->hint_sample->packetTable, ind-1);\n\n\tpck->P_bit = PackingBit ? 1 : 0;\n\tpck->X_bit = eXtensionBit ? 1 : 0;\n\tpck->M_bit = MarkerBit ? 1 : 0;\n\tpck->B_bit = disposable_packet ? 1 : 0;\n\tpck->R_bit = IsRepeatedPacket ? 1 : 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_rtp_packet_begin(GF_ISOFile *the_file, u32 trackNumber,\n                                s32 relativeTime,\n                                u8 PackingBit,\n                                u8 eXtensionBit,\n                                u8 MarkerBit,\n                                u8 PayloadType,\n                                u8 B_frame,\n                                u8 IsRepeatedPacket,\n                                u16 SequenceNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tGF_RTPPacket *pck;\n\tu32 dataRefIndex;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\tpck = (GF_RTPPacket *) gf_isom_hint_pck_new(entry->type);\n\n\tpck->P_bit = PackingBit ? 1 : 0;\n\tpck->X_bit = eXtensionBit ? 1 : 0;\n\tpck->M_bit = MarkerBit ? 1 : 0;\n\tpck->payloadType = PayloadType;\n\tpck->SequenceNumber = SequenceNumber;\n\tpck->B_bit = B_frame ? 1 : 0;\n\tpck->R_bit = IsRepeatedPacket ? 1 : 0;\n\tpck->relativeTransTime = relativeTime;\n\treturn gf_list_add(entry->hint_sample->packetTable, pck);\n}\n\n\n//set the time offset of this packet. This enables packets to be placed in the hint track\n//in decoding order, but have their presentation time-stamp in the transmitted\n//packet be in a different order. Typically used for MPEG video with B-frames\nGF_EXPORT\nGF_Err gf_isom_rtp_packet_set_offset(GF_ISOFile *the_file, u32 trackNumber, s32 timeOffset)\n{\n\tGF_RTPOBox *rtpo;\n\tGF_TrackBox *trak;\n\tGF_HintSampleEntryBox *entry;\n\tGF_RTPPacket *pck;\n\tu32 dataRefIndex, i;\n\tGF_Err e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, trak->Media->information->sampleTable->currentEntryIndex, (GF_SampleEntryBox **) &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry->hint_sample) return GF_BAD_PARAM;\n\n\tpck = (GF_RTPPacket *)gf_list_get(entry->hint_sample->packetTable, gf_list_count(entry->hint_sample->packetTable) - 1);\n\tif (!pck) return GF_BAD_PARAM;\n\n\t//look in the TLV\n\ti=0;\n\twhile ((rtpo = (GF_RTPOBox *)gf_list_enum(pck->TLV, &i))) {\n\t\tif (rtpo->type == GF_ISOM_BOX_TYPE_RTPO) {\n\t\t\trtpo->timeOffset = timeOffset;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//not found, add it\n\trtpo = (GF_RTPOBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_RTPO);\n\tif (!rtpo) return GF_OUT_OF_MEM;\n\trtpo->timeOffset = timeOffset;\n\n\treturn gf_list_add(pck->TLV, rtpo);\n}\n\n\nstatic void AddSDPLine(GF_List *list, char *sdp_text, Bool is_movie_sdp)\n{\n\tconst char *sdp_order;\n\tu32 i, count = gf_list_count(list);\n\tchar fc = sdp_text[0];\n\n\tsdp_order = (is_movie_sdp) ? \"vosiuepcbzkatr\" : \"micbka\";\n\tfor (i=0; i<count; i++) {\n\t\tchar *l = (char *)gf_list_get(list, i);\n\t\tchar *s1 = (char *)strchr(sdp_order, l[0]);\n\t\tchar *s2 = (char *)strchr(sdp_order, fc);\n\t\tif (s1 && s2 && (strlen(s2)>strlen(s1))) {\n\t\t\tgf_list_insert(list, sdp_text, i);\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_list_add(list, sdp_text);\n}\n\nstatic void ReorderSDP(char *sdp_text, Bool is_movie_sdp)\n{\n\tchar *cur;\n\tGF_List *lines = gf_list_new();\n\tcur = sdp_text;\n\twhile (cur) {\n\t\tchar b;\n\t\tchar *st = strstr(cur, \"\\r\\n\");\n\t\tassert(st);\n\t\tst += 2;\n\t\tif (!st[0]) {\n\t\t\tAddSDPLine(lines, gf_strdup(cur), is_movie_sdp);\n\t\t\tbreak;\n\t\t}\n\t\tb = st[0];\n\t\tst[0] = 0;\n\t\tAddSDPLine(lines, gf_strdup(cur), is_movie_sdp);\n\t\tst[0] = b;\n\t\tcur = st;\n\t}\n\tstrcpy(sdp_text, \"\");\n\twhile (gf_list_count(lines)) {\n\t\tcur = (char *)gf_list_get(lines, 0);\n\t\tgf_list_rem(lines, 0);\n\t\tstrcat(sdp_text, cur);\n\t\tgf_free(cur);\n\t}\n\tgf_list_del(lines);\n}\n\n//add an SDP line to the SDP container at the track level (media-specific SDP info)\nGF_EXPORT\nGF_Err gf_isom_sdp_add_track_line(GF_ISOFile *the_file, u32 trackNumber, const char *text)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\tGF_SDPBox *sdp;\n\tGF_Err e;\n\tchar *buf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//currently, only RTP hinting supports SDP\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_ISOM_INVALID_FILE;\n\n\t//we should have only one HNTI in the UDTA\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\tif (!hnti->SDP) {\n\t\te = hnti_on_child_box((GF_Box*)hnti, gf_isom_box_new_parent(&hnti->child_boxes, GF_ISOM_BOX_TYPE_SDP), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tsdp = (GF_SDPBox *) hnti->SDP;\n\n\tif (!sdp->sdpText) {\n\t\tsdp->sdpText = (char *)gf_malloc(sizeof(char) * (strlen(text) + 3));\n\t\tif (!sdp->sdpText) return GF_OUT_OF_MEM;\n\n\t\tstrcpy(sdp->sdpText, text);\n\t\tstrcat(sdp->sdpText, \"\\r\\n\");\n\t\treturn GF_OK;\n\t}\n\tbuf = (char *)gf_malloc(sizeof(char) * (strlen(sdp->sdpText) + strlen(text) + 3));\n\tif (!buf) return GF_OUT_OF_MEM;\n\n\tstrcpy(buf, sdp->sdpText);\n\tstrcat(buf, text);\n\tstrcat(buf, \"\\r\\n\");\n\tgf_free(sdp->sdpText);\n\tReorderSDP(buf, GF_FALSE);\n\tsdp->sdpText = buf;\n\treturn GF_OK;\n}\n\n//remove all SDP info at the track level\nGF_EXPORT\nGF_Err gf_isom_sdp_clean_track(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//currently, only RTP hinting supports SDP\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_ISOM_INVALID_FILE;\n\n\t//we should have only one HNTI in the UDTA\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\tif (!hnti->SDP) return GF_OK;\n\t//and free the SDP\n\tgf_free(((GF_SDPBox *)hnti->SDP)->sdpText);\n\t((GF_SDPBox *)hnti->SDP)->sdpText = NULL;\n\treturn GF_OK;\n}\n\n\n//add an SDP line to the SDP container at the movie level (presentation SDP info)\n//NOTE: the \\r\\n end of line for SDP is automatically inserted\nGF_EXPORT\nGF_Err gf_isom_sdp_add_line(GF_ISOFile *movie, const char *text)\n{\n\tGF_UserDataMap *map;\n\tGF_RTPBox *rtp;\n\tGF_Err e;\n\tGF_HintTrackInfoBox *hnti;\n\tchar *buf;\n\n\tif (!movie->moov) return GF_BAD_PARAM;\n\n\t//check if we have a udta ...\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a hnti in the udta\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) {\n\t\te = udta_on_child_box((GF_Box *)movie->moov->udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HNTI), GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\t}\n\n\t//there should be one and only one hnti\n\tif (!gf_list_count(map->boxes) ) {\n\t\te = udta_on_child_box((GF_Box *)movie->moov->udta, gf_isom_box_new(GF_ISOM_BOX_TYPE_HNTI), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\telse if (gf_list_count(map->boxes) < 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\n\tif (!hnti->SDP) {\n\t\tGF_Box *a = gf_isom_box_new_ex(GF_ISOM_BOX_TYPE_RTP, GF_ISOM_BOX_TYPE_HNTI, 0, GF_FALSE);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\thnti_on_child_box((GF_Box*)hnti, a, GF_FALSE);\n\t\tif (!hnti->child_boxes) hnti->child_boxes = gf_list_new();\n\t\tgf_list_add(hnti->child_boxes, a);\n\t}\n\trtp = (GF_RTPBox *) hnti->SDP;\n\n\tif (!rtp->sdpText) {\n\t\trtp->sdpText = (char*)gf_malloc(sizeof(char) * (strlen(text) + 3));\n\t\tif (!rtp->sdpText) return GF_OUT_OF_MEM;\n\n\t\tstrcpy(rtp->sdpText, text);\n\t\tstrcat(rtp->sdpText, \"\\r\\n\");\n\t\treturn GF_OK;\n\t}\n\tbuf = (char*)gf_malloc(sizeof(char) * (strlen(rtp->sdpText) + strlen(text) + 3));\n\tif (!buf) return GF_OUT_OF_MEM;\n\t\n\tstrcpy(buf, rtp->sdpText);\n\tstrcat(buf, text);\n\tstrcat(buf, \"\\r\\n\");\n\tgf_free(rtp->sdpText);\n\tReorderSDP(buf, GF_TRUE);\n\trtp->sdpText = buf;\n\treturn GF_OK;\n}\n\n\n//remove all SDP info at the movie level\nGF_EXPORT\nGF_Err gf_isom_sdp_clean(GF_ISOFile *movie)\n{\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\n\t//check if we have a udta ...\n\tif (!movie->moov || !movie->moov->udta) return GF_OK;\n\n\t//find a hnti in the udta\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_OK;\n\n\t//there should be one and only one hnti\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\n\t//remove and destroy the entry\n\tgf_list_rem(map->boxes, 0);\n\tgf_isom_box_del((GF_Box *)hnti);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Err gf_isom_sdp_get(GF_ISOFile *movie, const char **sdp, u32 *length)\n{\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\tGF_RTPBox *rtp;\n\t*length = 0;\n\t*sdp = NULL;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//check if we have a udta ...\n\tif (!movie->moov->udta) return GF_OK;\n\n\t//find a hnti in the udta\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_OK;\n\n\t//there should be one and only one hnti\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\n\tif (!hnti->SDP) return GF_OK;\n\trtp = (GF_RTPBox *) hnti->SDP;\n\n\t*length = (u32) strlen(rtp->sdpText);\n\t*sdp = rtp->sdpText;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_sdp_track_get(GF_ISOFile *the_file, u32 trackNumber, const char **sdp, u32 *length)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintTrackInfoBox *hnti;\n\tGF_SDPBox *sdpa;\n\n\t*sdp = NULL;\n\t*length = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->udta) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);\n\tif (!map) return GF_ISOM_INVALID_FILE;\n\n\t//we should have only one HNTI in the UDTA\n\tif (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;\n\n\thnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0);\n\tif (!hnti->SDP) return GF_OK;\n\tsdpa = (GF_SDPBox *) hnti->SDP;\n\n\t*length = (u32) strlen(sdpa->sdpText);\n\t*sdp = sdpa->sdpText;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_payt_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintInfoBox *hinf;\n\tGF_PAYTBox *payt;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HINF, NULL);\n\tif (!map) return 0;\n\tif (gf_list_count(map->boxes) != 1) return 0;\n\n\thinf = (GF_HintInfoBox *)gf_list_get(map->boxes, 0);\n\tcount = 0;\n\ti = 0;\n\twhile ((payt = (GF_PAYTBox*)gf_list_enum(hinf->child_boxes, &i))) {\n\t\tif (payt->type == GF_ISOM_BOX_TYPE_PAYT) count++;\n\t}\n\treturn count;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_payt_info(GF_ISOFile *the_file, u32 trackNumber, u32 index, u32 *payID)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_HintInfoBox *hinf;\n\tGF_PAYTBox *payt;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !index) return NULL;\n\n\tif (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HINF, NULL);\n\tif (!map) return NULL;\n\tif (gf_list_count(map->boxes) != 1) return NULL;\n\n\thinf = (GF_HintInfoBox *)gf_list_get(map->boxes, 0);\n\tcount = 0;\n\ti = 0;\n\twhile ((payt = (GF_PAYTBox*)gf_list_enum(hinf->child_boxes, &i))) {\n\t\tif (payt->type == GF_ISOM_BOX_TYPE_PAYT) {\n\t\t\tcount++;\n\t\t\tif (count == index) {\n\t\t\t\tif (payID) *payID=payt->payloadCode;\n\t\t\t\treturn payt->payloadString;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n#endif /*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_HINTING)*/\n\n"], "filenames": ["src/isomedia/hint_track.c"], "buggy_code_start_loc": [46], "buggy_code_end_loc": [47], "fixing_code_start_loc": [46], "fixing_code_end_loc": [47], "type": "CWE-476", "message": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the gf_isom_get_payt_count function in hint_track.c, which allows attackers to cause a denial of service.", "other": {"cve": {"id": "CVE-2021-40576", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-13T19:15:08.407", "lastModified": "2023-05-27T04:15:17.203", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability in the gf_isom_get_payt_count function in hint_track.c, which allows attackers to cause a denial of service."}, {"lang": "es", "value": "El MP4Box binario en Gpac versi\u00f3n 1.0.1, presenta una vulnerabilidad de desreferencia de puntero null en la funci\u00f3n gf_isom_get_payt_count en el archivo hint_track.c, que permite a atacantes causar una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/ad18ece95fa064efc0995c4ab2c985f77fb166ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1904", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/ad18ece95fa064efc0995c4ab2c985f77fb166ec"}}