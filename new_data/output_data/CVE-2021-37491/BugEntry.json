{"buggy_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2017 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <wallet/wallet.h>\n\n#include <checkpoints.h>\n#include <chain.h>\n#include <wallet/coincontrol.h>\n#include <wallet/coinselection.h>\n#include <consensus/consensus.h>\n#include <consensus/validation.h>\n#include <fs.h>\n#include <wallet/init.h>\n#include <key.h>\n#include <key_io.h>\n#include <keystore.h>\n#include <validation.h>\n#include <net.h>\n#include <policy/fees.h>\n#include <policy/policy.h>\n#include <policy/rbf.h>\n#include <primitives/block.h>\n#include <primitives/transaction.h>\n#include <script/script.h>\n#include <scheduler.h>\n#include <timedata.h>\n#include <txmempool.h>\n#include <util.h>\n#include <utilmoneystr.h>\n#include <wallet/fees.h>\n\n#include <assert.h>\n#include <future>\n\n#include <boost/algorithm/string/replace.hpp>\n\nstd::vector<CWalletRef> vpwallets;\n/** Transaction fee set by the user */\nCFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\nunsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;\nbool bSpendZeroConfChange = DEFAULT_SPEND_ZEROCONF_CHANGE;\nbool fWalletRbf = DEFAULT_WALLET_RBF;\nbool g_wallet_allow_fallback_fee = true; //<! will be defined via chainparams\n\nconst uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n\n/**\n * Fees smaller than this (in satoshi) are considered zero fee (for transaction creation)\n * Override with -mintxfee\n */\nCFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE);\n/**\n * If fee estimation does not have enough data to provide estimates, use this fee instead.\n * Has no effect if not using fee estimation\n * Override with -fallbackfee\n */\nCFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);\n\nCFeeRate CWallet::m_discard_rate = CFeeRate(DEFAULT_DISCARD_FEE);\n\nconst uint256 CMerkleTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n\n/** @defgroup mapWallet\n *\n * @{\n */\n\nstd::string COutput::ToString() const\n{\n    return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n}\n\nclass CAffectedKeysVisitor : public boost::static_visitor<void> {\nprivate:\n    const CKeyStore &keystore;\n    std::vector<CKeyID> &vKeys;\n\npublic:\n    CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}\n\n    void Process(const CScript &script) {\n        txnouttype type;\n        std::vector<CTxDestination> vDest;\n        int nRequired;\n        if (ExtractDestinations(script, type, vDest, nRequired)) {\n            for (const CTxDestination &dest : vDest)\n                boost::apply_visitor(*this, dest);\n        }\n    }\n\n    void operator()(const CKeyID &keyId) {\n        if (keystore.HaveKey(keyId))\n            vKeys.push_back(keyId);\n    }\n\n    void operator()(const CScriptID &scriptId) {\n        CScript script;\n        if (keystore.GetCScript(scriptId, script))\n            Process(script);\n    }\n\n    void operator()(const WitnessV0ScriptHash& scriptID)\n    {\n        CScriptID id;\n        CRIPEMD160().Write(scriptID.begin(), 32).Finalize(id.begin());\n        CScript script;\n        if (keystore.GetCScript(id, script)) {\n            Process(script);\n        }\n    }\n\n    void operator()(const WitnessV0KeyHash& keyid)\n    {\n        CKeyID id(keyid);\n        if (keystore.HaveKey(id)) {\n            vKeys.push_back(id);\n        }\n    }\n\n    template<typename X>\n    void operator()(const X &none) {}\n};\n\nconst CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n{\n    LOCK(cs_wallet);\n    std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);\n    if (it == mapWallet.end())\n        return nullptr;\n    return &(it->second);\n}\n\nCPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal)\n{\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n\n    CKey secret;\n\n    // Create new metadata\n    int64_t nCreationTime = GetTime();\n    CKeyMetadata metadata(nCreationTime);\n\n    // use HD key derivation if HD was enabled during wallet creation\n    if (IsHDEnabled()) {\n        DeriveNewChildKey(walletdb, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n    } else {\n        secret.MakeNewKey(fCompressed);\n    }\n\n    // Compressed public keys were introduced in version 0.6.0\n    if (fCompressed) {\n        SetMinVersion(FEATURE_COMPRPUBKEY);\n    }\n\n    CPubKey pubkey = secret.GetPubKey();\n    assert(secret.VerifyPubKey(pubkey));\n\n    mapKeyMetadata[pubkey.GetID()] = metadata;\n    UpdateTimeFirstKey(nCreationTime);\n\n    if (!AddKeyPubKeyWithDB(walletdb, secret, pubkey)) {\n        throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n    }\n    return pubkey;\n}\n\nvoid CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal)\n{\n    // for now we use a fixed keypath scheme of m/0'/0'/k\n    CKey key;                      //master key seed (256bit)\n    CExtKey masterKey;             //hd master key\n    CExtKey accountKey;            //key at m/0'\n    CExtKey chainChildKey;         //key at m/0'/0' (external) or m/0'/1' (internal)\n    CExtKey childKey;              //key at m/0'/0'/<n>'\n\n    // try to get the master key\n    if (!GetKey(hdChain.masterKeyID, key))\n        throw std::runtime_error(std::string(__func__) + \": Master key not found\");\n\n    masterKey.SetMaster(key.begin(), key.size());\n\n    // derive m/0'\n    // use hardened derivation (child keys >= 0x80000000 are hardened after bip32)\n    masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);\n\n    // derive m/0'/0' (external chain) OR m/0'/1' (internal chain)\n    assert(internal ? CanSupportFeature(FEATURE_HD_SPLIT) : true);\n    accountKey.Derive(chainChildKey, BIP32_HARDENED_KEY_LIMIT+(internal ? 1 : 0));\n\n    // derive child key at next index, skip keys already known to the wallet\n    do {\n        // always derive hardened keys\n        // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range\n        // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649\n        if (internal) {\n            chainChildKey.Derive(childKey, hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n            metadata.hdKeypath = \"m/0'/1'/\" + std::to_string(hdChain.nInternalChainCounter) + \"'\";\n            hdChain.nInternalChainCounter++;\n        }\n        else {\n            chainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n            metadata.hdKeypath = \"m/0'/0'/\" + std::to_string(hdChain.nExternalChainCounter) + \"'\";\n            hdChain.nExternalChainCounter++;\n        }\n    } while (HaveKey(childKey.key.GetPubKey().GetID()));\n    secret = childKey.key;\n    metadata.hdMasterKeyID = hdChain.masterKeyID;\n    // update the chain model in the database\n    if (!walletdb.WriteHDChain(hdChain))\n        throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n}\n\nbool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const CPubKey &pubkey)\n{\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n\n    // CCryptoKeyStore has no concept of wallet databases, but calls AddCryptedKey\n    // which is overridden below.  To avoid flushes, the database handle is\n    // tunneled through to it.\n    bool needsDB = !pwalletdbEncryption;\n    if (needsDB) {\n        pwalletdbEncryption = &walletdb;\n    }\n    if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) {\n        if (needsDB) pwalletdbEncryption = nullptr;\n        return false;\n    }\n    if (needsDB) pwalletdbEncryption = nullptr;\n\n    // check if we need to remove from watch-only\n    CScript script;\n    script = GetScriptForDestination(pubkey.GetID());\n    if (HaveWatchOnly(script)) {\n        RemoveWatchOnly(script);\n    }\n    script = GetScriptForRawPubKey(pubkey);\n    if (HaveWatchOnly(script)) {\n        RemoveWatchOnly(script);\n    }\n\n    if (!IsCrypted()) {\n        return walletdb.WriteKey(pubkey,\n                                                 secret.GetPrivKey(),\n                                                 mapKeyMetadata[pubkey.GetID()]);\n    }\n    return true;\n}\n\nbool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n{\n    CWalletDB walletdb(*dbw);\n    return CWallet::AddKeyPubKeyWithDB(walletdb, secret, pubkey);\n}\n\nbool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                            const std::vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey,\n                                                        vchCryptedSecret,\n                                                        mapKeyMetadata[vchPubKey.GetID()]);\n        else\n            return CWalletDB(*dbw).WriteCryptedKey(vchPubKey,\n                                                            vchCryptedSecret,\n                                                            mapKeyMetadata[vchPubKey.GetID()]);\n    }\n}\n\nbool CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata &meta)\n{\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n    UpdateTimeFirstKey(meta.nCreateTime);\n    mapKeyMetadata[keyID] = meta;\n    return true;\n}\n\nbool CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata &meta)\n{\n    AssertLockHeld(cs_wallet); // m_script_metadata\n    UpdateTimeFirstKey(meta.nCreateTime);\n    m_script_metadata[script_id] = meta;\n    return true;\n}\n\nbool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n{\n    return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n}\n\n/**\n * Update wallet first key creation time. This should be called whenever keys\n * are added to the wallet, with the oldest key creation time.\n */\nvoid CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n{\n    AssertLockHeld(cs_wallet);\n    if (nCreateTime <= 1) {\n        // Cannot determine birthday information, so set the wallet birthday to\n        // the beginning of time.\n        nTimeFirstKey = 1;\n    } else if (!nTimeFirstKey || nCreateTime < nTimeFirstKey) {\n        nTimeFirstKey = nCreateTime;\n    }\n}\n\nbool CWallet::AddCScript(const CScript& redeemScript)\n{\n    if (!CCryptoKeyStore::AddCScript(redeemScript))\n        return false;\n    return CWalletDB(*dbw).WriteCScript(Hash160(redeemScript), redeemScript);\n}\n\nbool CWallet::LoadCScript(const CScript& redeemScript)\n{\n    /* A sanity check was added in pull #3843 to avoid adding redeemScripts\n     * that never can be redeemed. However, old wallets may still contain\n     * these. Do not add them to the wallet and warn. */\n    if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n    {\n        std::string strAddr = EncodeDestination(CScriptID(redeemScript));\n        LogPrintf(\"%s: Warning: This wallet contains a redeemScript of size %i which exceeds maximum size %i thus can never be redeemed. Do not use address %s.\\n\",\n            __func__, redeemScript.size(), MAX_SCRIPT_ELEMENT_SIZE, strAddr);\n        return true;\n    }\n\n    return CCryptoKeyStore::AddCScript(redeemScript);\n}\n\nbool CWallet::AddWatchOnly(const CScript& dest)\n{\n    if (!CCryptoKeyStore::AddWatchOnly(dest))\n        return false;\n    const CKeyMetadata& meta = m_script_metadata[CScriptID(dest)];\n    UpdateTimeFirstKey(meta.nCreateTime);\n    NotifyWatchonlyChanged(true);\n    return CWalletDB(*dbw).WriteWatchOnly(dest, meta);\n}\n\nbool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n{\n    m_script_metadata[CScriptID(dest)].nCreateTime = nCreateTime;\n    return AddWatchOnly(dest);\n}\n\nbool CWallet::RemoveWatchOnly(const CScript &dest)\n{\n    AssertLockHeld(cs_wallet);\n    if (!CCryptoKeyStore::RemoveWatchOnly(dest))\n        return false;\n    if (!HaveWatchOnly())\n        NotifyWatchonlyChanged(false);\n    if (!CWalletDB(*dbw).EraseWatchOnly(dest))\n        return false;\n\n    return true;\n}\n\nbool CWallet::LoadWatchOnly(const CScript &dest)\n{\n    return CCryptoKeyStore::AddWatchOnly(dest);\n}\n\nbool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    CCrypter crypter;\n    CKeyingMaterial _vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        for (const MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, _vMasterKey))\n                continue; // try another master key\n            if (CCryptoKeyStore::Unlock(_vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n{\n    bool fWasLocked = IsLocked();\n\n    {\n        LOCK(cs_wallet);\n        Lock();\n\n        CCrypter crypter;\n        CKeyingMaterial _vMasterKey;\n        for (MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, _vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(_vMasterKey))\n            {\n                int64_t nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = static_cast<unsigned int>(pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime))));\n\n                nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + static_cast<unsigned int>(pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime)))) / 2;\n\n                if (pMasterKey.second.nDeriveIterations < 25000)\n                    pMasterKey.second.nDeriveIterations = 25000;\n\n                LogPrintf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n\n                if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                    return false;\n                if (!crypter.Encrypt(_vMasterKey, pMasterKey.second.vchCryptedKey))\n                    return false;\n                CWalletDB(*dbw).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                if (fWasLocked)\n                    Lock();\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid CWallet::SetBestChain(const CBlockLocator& loc)\n{\n    CWalletDB walletdb(*dbw);\n    walletdb.WriteBestBlock(loc);\n}\n\nbool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n{\n    LOCK(cs_wallet); // nWalletVersion\n    if (nWalletVersion >= nVersion)\n        return true;\n\n    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n    if (fExplicit && nVersion > nWalletMaxVersion)\n            nVersion = FEATURE_LATEST;\n\n    nWalletVersion = nVersion;\n\n    if (nVersion > nWalletMaxVersion)\n        nWalletMaxVersion = nVersion;\n\n    {\n        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(*dbw);\n        if (nWalletVersion > 40000)\n            pwalletdb->WriteMinVersion(nWalletVersion);\n        if (!pwalletdbIn)\n            delete pwalletdb;\n    }\n\n    return true;\n}\n\nbool CWallet::SetMaxVersion(int nVersion)\n{\n    LOCK(cs_wallet); // nWalletVersion, nWalletMaxVersion\n    // cannot downgrade below current version\n    if (nWalletVersion > nVersion)\n        return false;\n\n    nWalletMaxVersion = nVersion;\n\n    return true;\n}\n\nstd::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n{\n    std::set<uint256> result;\n    AssertLockHeld(cs_wallet);\n\n    std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(txid);\n    if (it == mapWallet.end())\n        return result;\n    const CWalletTx& wtx = it->second;\n\n    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n\n    for (const CTxIn& txin : wtx.tx->vin)\n    {\n        if (mapTxSpends.count(txin.prevout) <= 1)\n            continue;  // No conflict if zero or one spends\n        range = mapTxSpends.equal_range(txin.prevout);\n        for (TxSpends::const_iterator _it = range.first; _it != range.second; ++_it)\n            result.insert(_it->second);\n    }\n    return result;\n}\n\nbool CWallet::HasWalletSpend(const uint256& txid) const\n{\n    AssertLockHeld(cs_wallet);\n    auto iter = mapTxSpends.lower_bound(COutPoint(txid, 0));\n    return (iter != mapTxSpends.end() && iter->first.hash == txid);\n}\n\nvoid CWallet::Flush(bool shutdown)\n{\n    dbw->Flush(shutdown);\n}\n\nvoid CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n{\n    // We want all the wallet transactions in range to have the same metadata as\n    // the oldest (smallest nOrderPos).\n    // So: find smallest nOrderPos:\n\n    int nMinOrderPos = std::numeric_limits<int>::max();\n    const CWalletTx* copyFrom = nullptr;\n    for (TxSpends::iterator it = range.first; it != range.second; ++it) {\n        const CWalletTx* wtx = &mapWallet.at(it->second);\n        if (wtx->nOrderPos < nMinOrderPos) {\n            nMinOrderPos = wtx->nOrderPos;;\n            copyFrom = wtx;\n        }\n    }\n\n    assert(copyFrom);\n\n    // Now copy data from copyFrom to rest:\n    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n    {\n        const uint256& hash = it->second;\n        CWalletTx* copyTo = &mapWallet.at(hash);\n        if (copyFrom == copyTo) continue;\n        assert(copyFrom && \"Oldest wallet transaction in range assumed to have been found.\");\n        if (!copyFrom->IsEquivalentTo(*copyTo)) continue;\n        copyTo->mapValue = copyFrom->mapValue;\n        copyTo->vOrderForm = copyFrom->vOrderForm;\n        // fTimeReceivedIsTxTime not copied on purpose\n        // nTimeReceived not copied on purpose\n        copyTo->nTimeSmart = copyFrom->nTimeSmart;\n        copyTo->fFromMe = copyFrom->fFromMe;\n        copyTo->strFromAccount = copyFrom->strFromAccount;\n        // nOrderPos not copied on purpose\n        // cached members not copied on purpose\n    }\n}\n\n/**\n * Outpoint is spent if any non-conflicted transaction\n * spends it:\n */\nbool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n{\n    const COutPoint outpoint(hash, n);\n    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n    range = mapTxSpends.equal_range(outpoint);\n\n    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n    {\n        const uint256& wtxid = it->second;\n        std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);\n        if (mit != mapWallet.end()) {\n            int depth = mit->second.GetDepthInMainChain();\n            if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))\n                return true; // Spent\n        }\n    }\n    return false;\n}\n\nvoid CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n{\n    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n\n    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n    range = mapTxSpends.equal_range(outpoint);\n    SyncMetaData(range);\n}\n\n\nvoid CWallet::AddToSpends(const uint256& wtxid)\n{\n    auto it = mapWallet.find(wtxid);\n    assert(it != mapWallet.end());\n    CWalletTx& thisTx = it->second;\n    if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n        return;\n\n    for (const CTxIn& txin : thisTx.tx->vin)\n        AddToSpends(txin.prevout, wtxid);\n}\n\nbool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n{\n    if (IsCrypted())\n        return false;\n\n    CKeyingMaterial _vMasterKey;\n\n    _vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n    GetStrongRandBytes(&_vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n\n    CMasterKey kMasterKey;\n\n    kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n    GetStrongRandBytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n\n    CCrypter crypter;\n    int64_t nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = static_cast<unsigned int>(2500000 / ((double)(GetTimeMillis() - nStartTime)));\n\n    nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + static_cast<unsigned int>(kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime)))) / 2;\n\n    if (kMasterKey.nDeriveIterations < 25000)\n        kMasterKey.nDeriveIterations = 25000;\n\n    LogPrintf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n\n    if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n        return false;\n    if (!crypter.Encrypt(_vMasterKey, kMasterKey.vchCryptedKey))\n        return false;\n\n    {\n        LOCK(cs_wallet);\n        mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n        assert(!pwalletdbEncryption);\n        pwalletdbEncryption = new CWalletDB(*dbw);\n        if (!pwalletdbEncryption->TxnBegin()) {\n            delete pwalletdbEncryption;\n            pwalletdbEncryption = nullptr;\n            return false;\n        }\n        pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n\n        if (!EncryptKeys(_vMasterKey))\n        {\n            pwalletdbEncryption->TxnAbort();\n            delete pwalletdbEncryption;\n            // We now probably have half of our keys encrypted in memory, and half not...\n            // die and let the user reload the unencrypted wallet.\n            assert(false);\n        }\n\n        // Encryption was introduced in version 0.4.0\n        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n\n        if (!pwalletdbEncryption->TxnCommit()) {\n            delete pwalletdbEncryption;\n            // We now have keys encrypted in memory, but not on disk...\n            // die to avoid confusion and let the user reload the unencrypted wallet.\n            assert(false);\n        }\n\n        delete pwalletdbEncryption;\n        pwalletdbEncryption = nullptr;\n\n        Lock();\n        Unlock(strWalletPassphrase);\n\n        // if we are using HD, replace the HD master key (seed) with a new one\n        if (IsHDEnabled()) {\n            if (!SetHDMasterKey(GenerateNewHDMasterKey())) {\n                return false;\n            }\n        }\n\n        NewKeyPool();\n        Lock();\n\n        // Need to completely rewrite the wallet file; if we don't, bdb might keep\n        // bits of the unencrypted private key in slack space in the database file.\n        dbw->Rewrite();\n\n    }\n    NotifyStatusChanged(this);\n\n    return true;\n}\n\nDBErrors CWallet::ReorderTransactions()\n{\n    LOCK(cs_wallet);\n    CWalletDB walletdb(*dbw);\n\n    // Old wallets didn't have any defined order for transactions\n    // Probably a bad idea to change the output of this\n\n    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n    typedef std::multimap<int64_t, TxPair > TxItems;\n    TxItems txByTime;\n\n    for (auto& entry : mapWallet)\n    {\n        CWalletTx* wtx = &entry.second;\n        txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, nullptr)));\n    }\n    std::list<CAccountingEntry> acentries;\n    walletdb.ListAccountCreditDebit(\"\", acentries);\n    for (CAccountingEntry& entry : acentries)\n    {\n        txByTime.insert(std::make_pair(entry.nTime, TxPair(nullptr, &entry)));\n    }\n\n    nOrderPosNext = 0;\n    std::vector<int64_t> nOrderPosOffsets;\n    for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n    {\n        CWalletTx *const pwtx = (*it).second.first;\n        CAccountingEntry *const pacentry = (*it).second.second;\n        int64_t& nOrderPos = (pwtx != nullptr) ? pwtx->nOrderPos : pacentry->nOrderPos;\n\n        if (nOrderPos == -1)\n        {\n            nOrderPos = nOrderPosNext++;\n            nOrderPosOffsets.push_back(nOrderPos);\n\n            if (pwtx)\n            {\n                if (!walletdb.WriteTx(*pwtx))\n                    return DB_LOAD_FAIL;\n            }\n            else\n                if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n        else\n        {\n            int64_t nOrderPosOff = 0;\n            for (const int64_t& nOffsetStart : nOrderPosOffsets)\n            {\n                if (nOrderPos >= nOffsetStart)\n                    ++nOrderPosOff;\n            }\n            nOrderPos += nOrderPosOff;\n            nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n\n            if (!nOrderPosOff)\n                continue;\n\n            // Since we're changing the order, write it back\n            if (pwtx)\n            {\n                if (!walletdb.WriteTx(*pwtx))\n                    return DB_LOAD_FAIL;\n            }\n            else\n                if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n    }\n    walletdb.WriteOrderPosNext(nOrderPosNext);\n\n    return DB_LOAD_OK;\n}\n\nint64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n{\n    AssertLockHeld(cs_wallet); // nOrderPosNext\n    int64_t nRet = nOrderPosNext++;\n    if (pwalletdb) {\n        pwalletdb->WriteOrderPosNext(nOrderPosNext);\n    } else {\n        CWalletDB(*dbw).WriteOrderPosNext(nOrderPosNext);\n    }\n    return nRet;\n}\n\nbool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment)\n{\n    CWalletDB walletdb(*dbw);\n    if (!walletdb.TxnBegin())\n        return false;\n\n    int64_t nNow = GetAdjustedTime();\n\n    // Debit\n    CAccountingEntry debit;\n    debit.nOrderPos = IncOrderPosNext(&walletdb);\n    debit.strAccount = strFrom;\n    debit.nCreditDebit = -nAmount;\n    debit.nTime = nNow;\n    debit.strOtherAccount = strTo;\n    debit.strComment = strComment;\n    AddAccountingEntry(debit, &walletdb);\n\n    // Credit\n    CAccountingEntry credit;\n    credit.nOrderPos = IncOrderPosNext(&walletdb);\n    credit.strAccount = strTo;\n    credit.nCreditDebit = nAmount;\n    credit.nTime = nNow;\n    credit.strOtherAccount = strFrom;\n    credit.strComment = strComment;\n    AddAccountingEntry(credit, &walletdb);\n\n    if (!walletdb.TxnCommit())\n        return false;\n\n    return true;\n}\n\nbool CWallet::GetAccountDestination(CTxDestination &dest, std::string strAccount, bool bForceNew)\n{\n    CWalletDB walletdb(*dbw);\n\n    CAccount account;\n    walletdb.ReadAccount(strAccount, account);\n\n    if (!bForceNew) {\n        if (!account.vchPubKey.IsValid())\n            bForceNew = true;\n        else {\n            // Check if the current key has been used (TODO: check other addresses with the same key)\n            CScript scriptPubKey = GetScriptForDestination(GetDestinationForKey(account.vchPubKey, m_default_address_type));\n            for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n                 it != mapWallet.end() && account.vchPubKey.IsValid();\n                 ++it)\n                for (const CTxOut& txout : (*it).second.tx->vout)\n                    if (txout.scriptPubKey == scriptPubKey) {\n                        bForceNew = true;\n                        break;\n                    }\n        }\n    }\n\n    // Generate a new key\n    if (bForceNew) {\n        if (!GetKeyFromPool(account.vchPubKey, false))\n            return false;\n\n        LearnRelatedScripts(account.vchPubKey, m_default_address_type);\n        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n        SetAddressBook(dest, strAccount, \"receive\");\n        walletdb.WriteAccount(strAccount, account);\n    } else {\n        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n    }\n\n    return true;\n}\n\nvoid CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n            item.second.MarkDirty();\n    }\n}\n\nbool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n{\n    LOCK(cs_wallet);\n\n    auto mi = mapWallet.find(originalHash);\n\n    // There is a bug if MarkReplaced is not called on an existing wallet transaction.\n    assert(mi != mapWallet.end());\n\n    CWalletTx& wtx = (*mi).second;\n\n    // Ensure for now that we're not overwriting data\n    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n\n    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n\n    CWalletDB walletdb(*dbw, \"r+\");\n\n    bool success = true;\n    if (!walletdb.WriteTx(wtx)) {\n        LogPrintf(\"%s: Updating walletdb tx %s failed\", __func__, wtx.GetHash().ToString());\n        success = false;\n    }\n\n    NotifyTransactionChanged(this, originalHash, CT_UPDATED);\n\n    return success;\n}\n\nbool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n{\n    LOCK(cs_wallet);\n\n    CWalletDB walletdb(*dbw, \"r+\", fFlushOnClose);\n\n    uint256 hash = wtxIn.GetHash();\n\n    // Inserts only if not already there, returns tx inserted or tx found\n    std::pair<std::map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(std::make_pair(hash, wtxIn));\n    CWalletTx& wtx = (*ret.first).second;\n    wtx.BindWallet(this);\n    bool fInsertedNew = ret.second;\n    if (fInsertedNew)\n    {\n        wtx.nTimeReceived = GetAdjustedTime();\n        wtx.nOrderPos = IncOrderPosNext(&walletdb);\n        wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n        wtx.nTimeSmart = ComputeTimeSmart(wtx);\n        AddToSpends(hash);\n    }\n\n    bool fUpdated = false;\n    if (!fInsertedNew)\n    {\n        // Merge\n        if (!wtxIn.hashUnset() && wtxIn.hashBlock != wtx.hashBlock)\n        {\n            wtx.hashBlock = wtxIn.hashBlock;\n            fUpdated = true;\n        }\n        // If no longer abandoned, update\n        if (wtxIn.hashBlock.IsNull() && wtx.isAbandoned())\n        {\n            wtx.hashBlock = wtxIn.hashBlock;\n            fUpdated = true;\n        }\n        if (wtxIn.nIndex != -1 && (wtxIn.nIndex != wtx.nIndex))\n        {\n            wtx.nIndex = wtxIn.nIndex;\n            fUpdated = true;\n        }\n        if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n        {\n            wtx.fFromMe = wtxIn.fFromMe;\n            fUpdated = true;\n        }\n        // If we have a witness-stripped version of this transaction, and we\n        // see a new version with a witness, then we must be upgrading a pre-segwit\n        // wallet.  Store the new version of the transaction with the witness,\n        // as the stripped-version must be invalid.\n        // TODO: Store all versions of the transaction, instead of just one.\n        if (wtxIn.tx->HasWitness() && !wtx.tx->HasWitness()) {\n            wtx.SetTx(wtxIn.tx);\n            fUpdated = true;\n        }\n    }\n\n    //// debug print\n    LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n    // Write to disk\n    if (fInsertedNew || fUpdated)\n        if (!walletdb.WriteTx(wtx))\n            return false;\n\n    // Break debit/credit balance caches:\n    wtx.MarkDirty();\n\n    // Notify UI of new or updated transaction\n    NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n\n    // notify an external script when a wallet transaction comes in or is updated\n    std::string strCmd = gArgs.GetArg(\"-walletnotify\", \"\");\n\n    if (!strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n        std::thread t(runCommand, strCmd);\n        t.detach(); // thread runs free\n    }\n\n    return true;\n}\n\nbool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    CWalletTx& wtx = mapWallet.emplace(hash, wtxIn).first->second;\n    wtx.BindWallet(this);\n    wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n    AddToSpends(hash);\n    for (const CTxIn& txin : wtx.tx->vin) {\n        auto it = mapWallet.find(txin.prevout.hash);\n        if (it != mapWallet.end()) {\n            CWalletTx& prevtx = it->second;\n            if (prevtx.nIndex == -1 && !prevtx.hashUnset()) {\n                MarkConflicted(prevtx.hashBlock, wtx.GetHash());\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Add a transaction to the wallet, or update it.  pIndex and posInBlock should\n * be set when the transaction was known to be included in a block.  When\n * pIndex == nullptr, then wallet state is not updated in AddToWallet, but\n * notifications happen and cached balances are marked dirty.\n *\n * If fUpdate is true, existing transactions will be updated.\n * TODO: One exception to this is that the abandoned state is cleared under the\n * assumption that any further notification of a transaction that was considered\n * abandoned is an indication that it is not safe to be considered abandoned.\n * Abandoned state should probably be more carefully tracked via different\n * posInBlock signals or by checking mempool presence when necessary.\n */\nbool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n{\n    const CTransaction& tx = *ptx;\n    {\n        AssertLockHeld(cs_wallet);\n\n        if (pIndex != nullptr) {\n            for (const CTxIn& txin : tx.vin) {\n                std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                while (range.first != range.second) {\n                    if (range.first->second != tx.GetHash()) {\n                        LogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), pIndex->GetBlockHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n                        MarkConflicted(pIndex->GetBlockHash(), range.first->second);\n                    }\n                    range.first++;\n                }\n            }\n        }\n\n        bool fExisted = mapWallet.count(tx.GetHash()) != 0;\n        if (fExisted && !fUpdate) return false;\n        if (fExisted || IsMine(tx) || IsFromMe(tx))\n        {\n            /* Check if any keys in the wallet keypool that were supposed to be unused\n             * have appeared in a new transaction. If so, remove those keys from the keypool.\n             * This can happen when restoring an old wallet backup that does not contain\n             * the mostly recently created transactions from newer versions of the wallet.\n             */\n\n            // loop though all outputs\n            for (const CTxOut& txout: tx.vout) {\n                // extract addresses and check if they match with an unused keypool key\n                std::vector<CKeyID> vAffected;\n                CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n                for (const CKeyID &keyid : vAffected) {\n                    std::map<CKeyID, int64_t>::const_iterator mi = m_pool_key_to_index.find(keyid);\n                    if (mi != m_pool_key_to_index.end()) {\n                        LogPrintf(\"%s: Detected a used keypool key, mark all keypool key up to this key as used\\n\", __func__);\n                        MarkReserveKeysAsUsed(mi->second);\n\n                        if (!TopUpKeyPool()) {\n                            LogPrintf(\"%s: Topping up keypool failed (locked wallet)\\n\", __func__);\n                        }\n                    }\n                }\n            }\n\n            CWalletTx wtx(this, ptx);\n\n            // Get merkle branch if transaction was found in a block\n            if (pIndex != nullptr)\n                wtx.SetMerkleBranch(pIndex, posInBlock);\n\n            return AddToWallet(wtx, false);\n        }\n    }\n    return false;\n}\n\nbool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n{\n    LOCK2(cs_main, cs_wallet);\n    const CWalletTx* wtx = GetWalletTx(hashTx);\n    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() == 0 && !wtx->InMempool();\n}\n\nbool CWallet::AbandonTransaction(const uint256& hashTx)\n{\n    LOCK2(cs_main, cs_wallet);\n\n    CWalletDB walletdb(*dbw, \"r+\");\n\n    std::set<uint256> todo;\n    std::set<uint256> done;\n\n    // Can't mark abandoned if confirmed or in mempool\n    auto it = mapWallet.find(hashTx);\n    assert(it != mapWallet.end());\n    CWalletTx& origtx = it->second;\n    if (origtx.GetDepthInMainChain() != 0 || origtx.InMempool()) {\n        return false;\n    }\n\n    todo.insert(hashTx);\n\n    while (!todo.empty()) {\n        uint256 now = *todo.begin();\n        todo.erase(now);\n        done.insert(now);\n        auto it = mapWallet.find(now);\n        assert(it != mapWallet.end());\n        CWalletTx& wtx = it->second;\n        int currentconfirm = wtx.GetDepthInMainChain();\n        // If the orig tx was not in block, none of its spends can be\n        assert(currentconfirm <= 0);\n        // if (currentconfirm < 0) {Tx and spends are already conflicted, no need to abandon}\n        if (currentconfirm == 0 && !wtx.isAbandoned()) {\n            // If the orig tx was not in block/mempool, none of its spends can be in mempool\n            assert(!wtx.InMempool());\n            wtx.nIndex = -1;\n            wtx.setAbandoned();\n            wtx.MarkDirty();\n            walletdb.WriteTx(wtx);\n            NotifyTransactionChanged(this, wtx.GetHash(), CT_UPDATED);\n            // Iterate over all its outputs, and mark transactions in the wallet that spend them abandoned too\n            TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(hashTx, 0));\n            while (iter != mapTxSpends.end() && iter->first.hash == now) {\n                if (!done.count(iter->second)) {\n                    todo.insert(iter->second);\n                }\n                iter++;\n            }\n            // If a transaction changes 'conflicted' state, that changes the balance\n            // available of the outputs it spends. So force those to be recomputed\n            for (const CTxIn& txin : wtx.tx->vin)\n            {\n                auto it = mapWallet.find(txin.prevout.hash);\n                if (it != mapWallet.end()) {\n                    it->second.MarkDirty();\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nvoid CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n{\n    LOCK2(cs_main, cs_wallet);\n\n    int conflictconfirms = 0;\n    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n    if (pindex && chainActive.Contains(pindex)) {\n        conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n    }\n    // If number of conflict confirms cannot be determined, this means\n    // that the block is still unknown or not yet part of the main chain,\n    // for example when loading the wallet during a reindex. Do nothing in that\n    // case.\n    if (conflictconfirms >= 0)\n        return;\n\n    // Do not flush the wallet here for performance reasons\n    CWalletDB walletdb(*dbw, \"r+\", false);\n\n    std::set<uint256> todo;\n    std::set<uint256> done;\n\n    todo.insert(hashTx);\n\n    while (!todo.empty()) {\n        uint256 now = *todo.begin();\n        todo.erase(now);\n        done.insert(now);\n        auto it = mapWallet.find(now);\n        assert(it != mapWallet.end());\n        CWalletTx& wtx = it->second;\n        int currentconfirm = wtx.GetDepthInMainChain();\n        if (conflictconfirms < currentconfirm) {\n            // Block is 'more conflicted' than current confirm; update.\n            // Mark transaction as conflicted with this block.\n            wtx.nIndex = -1;\n            wtx.hashBlock = hashBlock;\n            wtx.MarkDirty();\n            walletdb.WriteTx(wtx);\n            // Iterate over all its outputs, and mark transactions in the wallet that spend them conflicted too\n            TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(now, 0));\n            while (iter != mapTxSpends.end() && iter->first.hash == now) {\n                 if (!done.count(iter->second)) {\n                     todo.insert(iter->second);\n                 }\n                 iter++;\n            }\n            // If a transaction changes 'conflicted' state, that changes the balance\n            // available of the outputs it spends. So force those to be recomputed\n            for (const CTxIn& txin : wtx.tx->vin) {\n                auto it = mapWallet.find(txin.prevout.hash);\n                if (it != mapWallet.end()) {\n                    it->second.MarkDirty();\n                }\n            }\n        }\n    }\n}\n\nvoid CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pindex, int posInBlock) {\n    const CTransaction& tx = *ptx;\n\n    if (!AddToWalletIfInvolvingMe(ptx, pindex, posInBlock, true))\n        return; // Not one of ours\n\n    // If a transaction changes 'conflicted' state, that changes the balance\n    // available of the outputs it spends. So force those to be\n    // recomputed, also:\n    for (const CTxIn& txin : tx.vin) {\n        auto it = mapWallet.find(txin.prevout.hash);\n        if (it != mapWallet.end()) {\n            it->second.MarkDirty();\n        }\n    }\n}\n\nvoid CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n    LOCK2(cs_main, cs_wallet);\n    SyncTransaction(ptx);\n\n    auto it = mapWallet.find(ptx->GetHash());\n    if (it != mapWallet.end()) {\n        it->second.fInMempool = true;\n    }\n}\n\nvoid CWallet::TransactionRemovedFromMempool(const CTransactionRef &ptx) {\n    LOCK(cs_wallet);\n    auto it = mapWallet.find(ptx->GetHash());\n    if (it != mapWallet.end()) {\n        it->second.fInMempool = false;\n    }\n}\n\nvoid CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n    LOCK2(cs_main, cs_wallet);\n    // TODO: Temporarily ensure that mempool removals are notified before\n    // connected transactions.  This shouldn't matter, but the abandoned\n    // state of transactions in our wallet is currently cleared when we\n    // receive another notification and there is a race condition where\n    // notification of a connected conflict might cause an outside process\n    // to abandon a transaction and then have it inadvertently cleared by\n    // the notification that the conflicted transaction was evicted.\n\n    for (const CTransactionRef& ptx : vtxConflicted) {\n        SyncTransaction(ptx);\n        TransactionRemovedFromMempool(ptx);\n    }\n    for (size_t i = 0; i < pblock->vtx.size(); i++) {\n        SyncTransaction(pblock->vtx[i], pindex, i);\n        TransactionRemovedFromMempool(pblock->vtx[i]);\n    }\n\n    m_last_block_processed = pindex;\n}\n\nvoid CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n    LOCK2(cs_main, cs_wallet);\n\n    for (const CTransactionRef& ptx : pblock->vtx) {\n        SyncTransaction(ptx);\n    }\n}\n\n\n\nvoid CWallet::BlockUntilSyncedToCurrentChain() {\n    AssertLockNotHeld(cs_main);\n    AssertLockNotHeld(cs_wallet);\n\n    {\n        // Skip the queue-draining stuff if we know we're caught up with\n        // chainActive.Tip()...\n        // We could also take cs_wallet here, and call m_last_block_processed\n        // protected by cs_wallet instead of cs_main, but as long as we need\n        // cs_main here anyway, its easier to just call it cs_main-protected.\n        LOCK(cs_main);\n        const CBlockIndex* initialChainTip = chainActive.Tip();\n\n        if (m_last_block_processed->GetAncestor(initialChainTip->nHeight) == initialChainTip) {\n            return;\n        }\n    }\n\n    // ...otherwise put a callback in the validation interface queue and wait\n    // for the queue to drain enough to execute it (indicating we are caught up\n    // at least with the time we entered this function).\n    SyncWithValidationInterfaceQueue();\n}\n\n\nisminetype CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.tx->vout.size())\n                return IsMine(prev.tx->vout[txin.prevout.n]);\n        }\n    }\n    return ISMINE_NO;\n}\n\n// Note that this function doesn't distinguish between a 0-valued input,\n// and a not-\"is mine\" (according to the filter) input.\nCAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n{\n    {\n        LOCK(cs_wallet);\n        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.tx->vout.size())\n                if (IsMine(prev.tx->vout[txin.prevout.n]) & filter)\n                    return prev.tx->vout[txin.prevout.n].nValue;\n        }\n    }\n    return 0;\n}\n\nisminetype CWallet::IsMine(const CTxOut& txout) const\n{\n    return ::IsMine(*this, txout.scriptPubKey);\n}\n\nCAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n{\n    if (!MoneyRange(txout.nValue))\n        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n}\n\nbool CWallet::IsChange(const CTxOut& txout) const\n{\n    // TODO: fix handling of 'change' outputs. The assumption is that any\n    // payment to a script that is ours, but is not in the address book\n    // is change. That assumption is likely to break when we implement multisignature\n    // wallets that return change back into a multi-signature-protected address;\n    // a better way of identifying which outputs are 'the send' and which are\n    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n    // which output, if any, was change).\n    if (::IsMine(*this, txout.scriptPubKey))\n    {\n        CTxDestination address;\n        if (!ExtractDestination(txout.scriptPubKey, address))\n            return true;\n\n        LOCK(cs_wallet);\n        if (!mapAddressBook.count(address))\n            return true;\n    }\n    return false;\n}\n\nCAmount CWallet::GetChange(const CTxOut& txout) const\n{\n    if (!MoneyRange(txout.nValue))\n        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    return (IsChange(txout) ? txout.nValue : 0);\n}\n\nbool CWallet::IsMine(const CTransaction& tx) const\n{\n    for (const CTxOut& txout : tx.vout)\n        if (IsMine(txout))\n            return true;\n    return false;\n}\n\nbool CWallet::IsFromMe(const CTransaction& tx) const\n{\n    return (GetDebit(tx, ISMINE_ALL) > 0);\n}\n\nCAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) const\n{\n    CAmount nDebit = 0;\n    for (const CTxIn& txin : tx.vin)\n    {\n        nDebit += GetDebit(txin, filter);\n        if (!MoneyRange(nDebit))\n            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    }\n    return nDebit;\n}\n\nbool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n{\n    LOCK(cs_wallet);\n\n    for (const CTxIn& txin : tx.vin)\n    {\n        auto mi = mapWallet.find(txin.prevout.hash);\n        if (mi == mapWallet.end())\n            return false; // any unknown inputs can't be from us\n\n        const CWalletTx& prev = (*mi).second;\n\n        if (txin.prevout.n >= prev.tx->vout.size())\n            return false; // invalid input!\n\n        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n            return false;\n    }\n    return true;\n}\n\nCAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n{\n    CAmount nCredit = 0;\n    for (const CTxOut& txout : tx.vout)\n    {\n        nCredit += GetCredit(txout, filter);\n        if (!MoneyRange(nCredit))\n            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    }\n    return nCredit;\n}\n\nCAmount CWallet::GetChange(const CTransaction& tx) const\n{\n    CAmount nChange = 0;\n    for (const CTxOut& txout : tx.vout)\n    {\n        nChange += GetChange(txout);\n        if (!MoneyRange(nChange))\n            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    }\n    return nChange;\n}\n\nCPubKey CWallet::GenerateNewHDMasterKey()\n{\n    CKey key;\n    key.MakeNewKey(true);\n\n    int64_t nCreationTime = GetTime();\n    CKeyMetadata metadata(nCreationTime);\n\n    // calculate the pubkey\n    CPubKey pubkey = key.GetPubKey();\n    assert(key.VerifyPubKey(pubkey));\n\n    // set the hd keypath to \"m\" -> Master, refers the masterkeyid to itself\n    metadata.hdKeypath     = \"m\";\n    metadata.hdMasterKeyID = pubkey.GetID();\n\n    {\n        LOCK(cs_wallet);\n\n        // mem store the metadata\n        mapKeyMetadata[pubkey.GetID()] = metadata;\n\n        // write the key&metadata to the database\n        if (!AddKeyPubKey(key, pubkey))\n            throw std::runtime_error(std::string(__func__) + \": AddKeyPubKey failed\");\n    }\n\n    return pubkey;\n}\n\nbool CWallet::SetHDMasterKey(const CPubKey& pubkey)\n{\n    LOCK(cs_wallet);\n    // store the keyid (hash160) together with\n    // the child index counter in the database\n    // as a hdchain object\n    CHDChain newHdChain;\n    newHdChain.nVersion = CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n    newHdChain.masterKeyID = pubkey.GetID();\n    SetHDChain(newHdChain, false);\n\n    return true;\n}\n\nbool CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n{\n    LOCK(cs_wallet);\n    if (!memonly && !CWalletDB(*dbw).WriteHDChain(chain))\n        throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n\n    hdChain = chain;\n    return true;\n}\n\nbool CWallet::IsHDEnabled() const\n{\n    return !hdChain.masterKeyID.IsNull();\n}\n\nint64_t CWalletTx::GetTxTime() const\n{\n    int64_t n = nTimeSmart;\n    return n ? n : nTimeReceived;\n}\n\nint CWalletTx::GetRequestCount() const\n{\n    // Returns -1 if it wasn't being tracked\n    int nRequests = -1;\n    {\n        LOCK(pwallet->cs_wallet);\n        if (IsCoinBase())\n        {\n            // Generated block\n            if (!hashUnset())\n            {\n                std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                if (mi != pwallet->mapRequestCount.end())\n                    nRequests = (*mi).second;\n            }\n        }\n        else\n        {\n            // Did anyone request this transaction?\n            std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n            if (mi != pwallet->mapRequestCount.end())\n            {\n                nRequests = (*mi).second;\n\n                // How about the block it's in?\n                if (nRequests == 0 && !hashUnset())\n                {\n                    std::map<uint256, int>::const_iterator _mi = pwallet->mapRequestCount.find(hashBlock);\n                    if (_mi != pwallet->mapRequestCount.end())\n                        nRequests = (*_mi).second;\n                    else\n                        nRequests = 1; // If it's in someone else's block it must have got out\n                }\n            }\n        }\n    }\n    return nRequests;\n}\n\n// Helper for producing a max-sized low-S signature (eg 72 bytes)\nbool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout) const\n{\n    // Fill in dummy signatures for fee calculation.\n    const CScript& scriptPubKey = txout.scriptPubKey;\n    SignatureData sigdata;\n\n    if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n    {\n        return false;\n    } else {\n        UpdateInput(tx_in, sigdata);\n    }\n    return true;\n}\n\n// Helper for producing a bunch of max-sized low-S signatures (eg 72 bytes)\nbool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts) const\n{\n    // Fill in dummy signatures for fee calculation.\n    int nIn = 0;\n    for (const auto& txout : txouts)\n    {\n        if (!DummySignInput(txNew.vin[nIn], txout)) {\n            return false;\n        }\n\n        nIn++;\n    }\n    return true;\n}\n\nint64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n{\n    std::vector<CTxOut> txouts;\n    // Look up the inputs.  We should have already checked that this transaction\n    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n    // wallet, with a valid index into the vout array, and the ability to sign.\n    for (auto& input : tx.vin) {\n        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n        if (mi == wallet->mapWallet.end()) {\n            return -1;\n        }\n        assert(input.prevout.n < mi->second.tx->vout.size());\n        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n    }\n    return CalculateMaximumSignedTxSize(tx, wallet, txouts);\n}\n\n// txouts needs to be in the order of tx.vin\nint64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts)\n{\n    CMutableTransaction txNew(tx);\n    if (!wallet->DummySignTx(txNew, txouts)) {\n        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n        // implies that we can sign for every input.\n        return -1;\n    }\n    return GetVirtualTransactionSize(txNew);\n}\n\nint CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet)\n{\n    CMutableTransaction txn;\n    txn.vin.push_back(CTxIn(COutPoint()));\n    if (!wallet->DummySignInput(txn.vin[0], txout)) {\n        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n        // implies that we can sign for every input.\n        return -1;\n    }\n    return GetVirtualTransactionInputSize(txn.vin[0]);\n}\n\nvoid CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n                           std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const\n{\n    nFee = 0;\n    listReceived.clear();\n    listSent.clear();\n    strSentAccount = strFromAccount;\n\n    // Compute fee:\n    CAmount nDebit = GetDebit(filter);\n    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n    {\n        CAmount nValueOut = tx->GetValueOut();\n        nFee = nDebit - nValueOut;\n    }\n\n    // Sent/received.\n    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n    {\n        const CTxOut& txout = tx->vout[i];\n        isminetype fIsMine = pwallet->IsMine(txout);\n        // Only need to handle txouts if AT LEAST one of these is true:\n        //   1) they debit from us (sent)\n        //   2) the output is to us (received)\n        if (nDebit > 0)\n        {\n            // Don't report 'change' txouts\n            if (pwallet->IsChange(txout))\n                continue;\n        }\n        else if (!(fIsMine & filter))\n            continue;\n\n        // In either case, we need to get the destination address\n        CTxDestination address;\n\n        if (!ExtractDestination(txout.scriptPubKey, address) && !txout.scriptPubKey.IsUnspendable())\n        {\n            LogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                     this->GetHash().ToString());\n            address = CNoDestination();\n        }\n\n        COutputEntry output = {address, txout.nValue, (int)i};\n\n        // If we are debited by the transaction, add the output as a \"sent\" entry\n        if (nDebit > 0)\n            listSent.push_back(output);\n\n        // If we are receiving the output, add it as a \"received\" entry\n        if (fIsMine & filter)\n            listReceived.push_back(output);\n    }\n\n}\n\n/**\n * Scan active chain for relevant transactions after importing keys. This should\n * be called whenever new keys are added to the wallet, with the oldest key\n * creation time.\n *\n * @return Earliest timestamp that could be successfully scanned from. Timestamp\n * returned will be higher than startTime if relevant blocks could not be read.\n */\nint64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& reserver, bool update)\n{\n    // Find starting block. May be null if nCreateTime is greater than the\n    // highest blockchain timestamp, in which case there is nothing that needs\n    // to be scanned.\n    CBlockIndex* startBlock = nullptr;\n    {\n        LOCK(cs_main);\n        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n    }\n\n    if (startBlock) {\n        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n        if (failedBlock) {\n            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n        }\n    }\n    return startTime;\n}\n\n/**\n * Scan the block chain (starting in pindexStart) for transactions\n * from or to us. If fUpdate is true, found transactions that already\n * exist in the wallet will be updated.\n *\n * Returns null if scan was successful. Otherwise, if a complete rescan was not\n * possible (due to pruning or corruption), returns pointer to the most recent\n * block that could not be scanned.\n *\n * If pindexStop is not a nullptr, the scan will stop at the block-index\n * defined by pindexStop\n *\n * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n * the main chain after to the addition of any new keys you want to detect\n * transactions for.\n */\nCBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n{\n    int64_t nNow = GetTime();\n    const CChainParams& chainParams = Params();\n\n    assert(reserver.isReserved());\n    if (pindexStop) {\n        assert(pindexStop->nHeight >= pindexStart->nHeight);\n    }\n\n    CBlockIndex* pindex = pindexStart;\n    CBlockIndex* ret = nullptr;\n    {\n        fAbortRescan = false;\n        ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n        CBlockIndex* tip = nullptr;\n        double dProgressStart;\n        double dProgressTip;\n        {\n            LOCK(cs_main);\n            tip = chainActive.Tip();\n            dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n            dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n        }\n        double gvp = dProgressStart;\n        while (pindex && !fAbortRescan)\n        {\n            if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n                ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((gvp - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n            }\n            if (GetTime() >= nNow + 60) {\n                nNow = GetTime();\n                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n            }\n\n            CBlock block;\n            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n                LOCK2(cs_main, cs_wallet);\n                if (pindex && !chainActive.Contains(pindex)) {\n                    // Abort scan if current block is no longer active, to prevent\n                    // marking transactions as coming from the wrong block.\n                    ret = pindex;\n                    break;\n                }\n                for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n                    AddToWalletIfInvolvingMe(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n                }\n            } else {\n                ret = pindex;\n            }\n            if (pindex == pindexStop) {\n                break;\n            }\n            {\n                LOCK(cs_main);\n                pindex = chainActive.Next(pindex);\n                gvp = GuessVerificationProgress(chainParams.TxData(), pindex);\n                if (tip != chainActive.Tip()) {\n                    tip = chainActive.Tip();\n                    // in case the tip has changed, update progress max\n                    dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n                }\n            }\n        }\n        if (pindex && fAbortRescan) {\n            LogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n        }\n        ShowProgress(_(\"Rescanning...\"), 100); // hide progress dialog in GUI\n    }\n    return ret;\n}\n\nvoid CWallet::ReacceptWalletTransactions()\n{\n    // If transactions aren't being broadcasted, don't let them into local mempool either\n    if (!fBroadcastTransactions)\n        return;\n    LOCK2(cs_main, cs_wallet);\n    std::map<int64_t, CWalletTx*> mapSorted;\n\n    // Sort pending wallet transactions based on their initial wallet insertion order\n    for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n    {\n        const uint256& wtxid = item.first;\n        CWalletTx& wtx = item.second;\n        assert(wtx.GetHash() == wtxid);\n\n        int nDepth = wtx.GetDepthInMainChain();\n\n        if (!wtx.IsCoinBase() && (nDepth == 0 && !wtx.isAbandoned())) {\n            mapSorted.insert(std::make_pair(wtx.nOrderPos, &wtx));\n        }\n    }\n\n    // Try to add wallet transactions to memory pool\n    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted) {\n        CWalletTx& wtx = *(item.second);\n        CValidationState state;\n        wtx.AcceptToMemoryPool(maxTxFee, state);\n    }\n}\n\nbool CWalletTx::RelayWalletTransaction(CConnman* connman)\n{\n    assert(pwallet->GetBroadcastTransactions());\n    if (!IsCoinBase() && !isAbandoned() && GetDepthInMainChain() == 0)\n    {\n        CValidationState state;\n        /* GetDepthInMainChain already catches known conflicts. */\n        if (InMempool() || AcceptToMemoryPool(maxTxFee, state)) {\n            LogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n            if (connman) {\n                CInv inv(MSG_TX, GetHash());\n                connman->ForEachNode([&inv](CNode* pnode)\n                {\n                    pnode->PushInventory(inv);\n                });\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nstd::set<uint256> CWalletTx::GetConflicts() const\n{\n    std::set<uint256> result;\n    if (pwallet != nullptr)\n    {\n        uint256 myHash = GetHash();\n        result = pwallet->GetConflicts(myHash);\n        result.erase(myHash);\n    }\n    return result;\n}\n\nCAmount CWalletTx::GetDebit(const isminefilter& filter) const\n{\n    if (tx->vin.empty())\n        return 0;\n\n    CAmount debit = 0;\n    if(filter & ISMINE_SPENDABLE)\n    {\n        if (fDebitCached)\n            debit += nDebitCached;\n        else\n        {\n            nDebitCached = pwallet->GetDebit(*tx, ISMINE_SPENDABLE);\n            fDebitCached = true;\n            debit += nDebitCached;\n        }\n    }\n    if(filter & ISMINE_WATCH_ONLY)\n    {\n        if(fWatchDebitCached)\n            debit += nWatchDebitCached;\n        else\n        {\n            nWatchDebitCached = pwallet->GetDebit(*tx, ISMINE_WATCH_ONLY);\n            fWatchDebitCached = true;\n            debit += nWatchDebitCached;\n        }\n    }\n    return debit;\n}\n\nCAmount CWalletTx::GetCredit(const isminefilter& filter) const\n{\n    // Must wait until coinbase is safely deep enough in the chain before valuing it\n    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n        return 0;\n\n    CAmount credit = 0;\n    if (filter & ISMINE_SPENDABLE)\n    {\n        // GetBalance can assume transactions in mapWallet won't change\n        if (fCreditCached)\n            credit += nCreditCached;\n        else\n        {\n            nCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);\n            fCreditCached = true;\n            credit += nCreditCached;\n        }\n    }\n    if (filter & ISMINE_WATCH_ONLY)\n    {\n        if (fWatchCreditCached)\n            credit += nWatchCreditCached;\n        else\n        {\n            nWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);\n            fWatchCreditCached = true;\n            credit += nWatchCreditCached;\n        }\n    }\n    return credit;\n}\n\nCAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n{\n    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n    {\n        if (fUseCache && fImmatureCreditCached)\n            return nImmatureCreditCached;\n        nImmatureCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);\n        fImmatureCreditCached = true;\n        return nImmatureCreditCached;\n    }\n\n    return 0;\n}\n\nCAmount CWalletTx::GetAvailableCredit(bool fUseCache) const\n{\n    if (pwallet == nullptr)\n        return 0;\n\n    // Must wait until coinbase is safely deep enough in the chain before valuing it\n    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n        return 0;\n\n    if (fUseCache && fAvailableCreditCached)\n        return nAvailableCreditCached;\n\n    CAmount nCredit = 0;\n    uint256 hashTx = GetHash();\n    for (unsigned int i = 0; i < tx->vout.size(); i++)\n    {\n        if (!pwallet->IsSpent(hashTx, i))\n        {\n            const CTxOut &txout = tx->vout[i];\n            nCredit += pwallet->GetCredit(txout, ISMINE_SPENDABLE);\n            if (!MoneyRange(nCredit))\n                throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n        }\n    }\n\n    nAvailableCreditCached = nCredit;\n    fAvailableCreditCached = true;\n    return nCredit;\n}\n\nCAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n{\n    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n    {\n        if (fUseCache && fImmatureWatchCreditCached)\n            return nImmatureWatchCreditCached;\n        nImmatureWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);\n        fImmatureWatchCreditCached = true;\n        return nImmatureWatchCreditCached;\n    }\n\n    return 0;\n}\n\nCAmount CWalletTx::GetAvailableWatchOnlyCredit(const bool fUseCache) const\n{\n    if (pwallet == nullptr)\n        return 0;\n\n    // Must wait until coinbase is safely deep enough in the chain before valuing it\n    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n        return 0;\n\n    if (fUseCache && fAvailableWatchCreditCached)\n        return nAvailableWatchCreditCached;\n\n    CAmount nCredit = 0;\n    for (unsigned int i = 0; i < tx->vout.size(); i++)\n    {\n        if (!pwallet->IsSpent(GetHash(), i))\n        {\n            const CTxOut &txout = tx->vout[i];\n            nCredit += pwallet->GetCredit(txout, ISMINE_WATCH_ONLY);\n            if (!MoneyRange(nCredit))\n                throw std::runtime_error(std::string(__func__) + \": value out of range\");\n        }\n    }\n\n    nAvailableWatchCreditCached = nCredit;\n    fAvailableWatchCreditCached = true;\n    return nCredit;\n}\n\nCAmount CWalletTx::GetChange() const\n{\n    if (fChangeCached)\n        return nChangeCached;\n    nChangeCached = pwallet->GetChange(*tx);\n    fChangeCached = true;\n    return nChangeCached;\n}\n\nbool CWalletTx::InMempool() const\n{\n    return fInMempool;\n}\n\nbool CWalletTx::IsTrusted() const\n{\n    // Quick answer in most cases\n    if (!CheckFinalTx(*tx))\n        return false;\n    int nDepth = GetDepthInMainChain();\n    if (nDepth >= 1)\n        return true;\n    if (nDepth < 0)\n        return false;\n    if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx's cached debit\n        return false;\n\n    // Don't trust unconfirmed transactions from us unless they are in the mempool.\n    if (!InMempool())\n        return false;\n\n    // Trusted if all inputs are from us and are in the mempool:\n    for (const CTxIn& txin : tx->vin)\n    {\n        // Transactions not sent by us: not trusted\n        const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n        if (parent == nullptr)\n            return false;\n        const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n        if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE)\n            return false;\n    }\n    return true;\n}\n\nbool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n{\n        CMutableTransaction tx1 = *this->tx;\n        CMutableTransaction tx2 = *_tx.tx;\n        for (auto& txin : tx1.vin) txin.scriptSig = CScript();\n        for (auto& txin : tx2.vin) txin.scriptSig = CScript();\n        return CTransaction(tx1) == CTransaction(tx2);\n}\n\nstd::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman)\n{\n    std::vector<uint256> result;\n\n    LOCK(cs_wallet);\n\n    // Sort them in chronological order\n    std::multimap<unsigned int, CWalletTx*> mapSorted;\n    for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n    {\n        CWalletTx& wtx = item.second;\n        // Don't rebroadcast if newer than nTime:\n        if (wtx.nTimeReceived > nTime)\n            continue;\n        mapSorted.insert(std::make_pair(wtx.nTimeReceived, &wtx));\n    }\n    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)\n    {\n        CWalletTx& wtx = *item.second;\n        if (wtx.RelayWalletTransaction(connman))\n            result.push_back(wtx.GetHash());\n    }\n    return result;\n}\n\nvoid CWallet::ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman)\n{\n    // Do this infrequently and randomly to avoid giving away\n    // that these are our transactions.\n    if (GetTime() < nNextResend || !fBroadcastTransactions)\n        return;\n    bool fFirst = (nNextResend == 0);\n    nNextResend = GetTime() + GetRand(30 * 60);\n    if (fFirst)\n        return;\n\n    // Only do it if there's been a new block since last time\n    if (nBestBlockTime < nLastResend)\n        return;\n    nLastResend = GetTime();\n\n    // Rebroadcast unconfirmed txes older than 5 minutes before the last\n    // block was found:\n    std::vector<uint256> relayed = ResendWalletTransactionsBefore(nBestBlockTime-5*60, connman);\n    if (!relayed.empty())\n        LogPrintf(\"%s: rebroadcast %u unconfirmed transactions\\n\", __func__, relayed.size());\n}\n\n/** @} */ // end of mapWallet\n\n\n\n\n/** @defgroup Actions\n *\n * @{\n */\n\n\nCAmount CWallet::GetBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nCAmount CWallet::GetUnconfirmedBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n    return nTotal;\n}\n\nCAmount CWallet::GetImmatureBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            nTotal += pcoin->GetImmatureCredit();\n        }\n    }\n    return nTotal;\n}\n\nCAmount CWallet::GetWatchOnlyBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableWatchOnlyCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nCAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n                nTotal += pcoin->GetAvailableWatchOnlyCredit();\n        }\n    }\n    return nTotal;\n}\n\nCAmount CWallet::GetImmatureWatchOnlyBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            nTotal += pcoin->GetImmatureWatchOnlyCredit();\n        }\n    }\n    return nTotal;\n}\n\n// Calculate total balance in a different way from GetBalance. The biggest\n// difference is that GetBalance sums up all unspent TxOuts paying to the\n// wallet, while this sums up both spent and unspent TxOuts paying to the\n// wallet, and then subtracts the values of TxIns spending from the wallet. This\n// also has fewer restrictions on which unconfirmed transactions are considered\n// trusted.\nCAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const\n{\n    LOCK2(cs_main, cs_wallet);\n\n    CAmount balance = 0;\n    for (const auto& entry : mapWallet) {\n        const CWalletTx& wtx = entry.second;\n        const int depth = wtx.GetDepthInMainChain();\n        if (depth < 0 || !CheckFinalTx(*wtx.tx) || wtx.GetBlocksToMaturity() > 0) {\n            continue;\n        }\n\n        // Loop through tx outputs and add incoming payments. For outgoing txs,\n        // treat change outputs specially, as part of the amount debited.\n        CAmount debit = wtx.GetDebit(filter);\n        const bool outgoing = debit > 0;\n        for (const CTxOut& out : wtx.tx->vout) {\n            if (outgoing && IsChange(out)) {\n                debit -= out.nValue;\n            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetAccountName(out.scriptPubKey))) {\n                balance += out.nValue;\n            }\n        }\n\n        // For outgoing txs, subtract amount debited.\n        if (outgoing && (!account || *account == wtx.strFromAccount)) {\n            balance -= debit;\n        }\n    }\n\n    if (account) {\n        balance += CWalletDB(*dbw).GetAccountCreditDebit(*account);\n    }\n\n    return balance;\n}\n\nCAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n{\n    LOCK2(cs_main, cs_wallet);\n\n    CAmount balance = 0;\n    std::vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n    for (const COutput& out : vCoins) {\n        if (out.fSpendable) {\n            balance += out.tx->tx->vout[out.i].nValue;\n        }\n    }\n    return balance;\n}\n\nvoid CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t nMaximumCount, const int nMinDepth, const int nMaxDepth) const\n{\n    AssertLockHeld(cs_main);\n    AssertLockHeld(cs_wallet);\n\n    vCoins.clear();\n    CAmount nTotal = 0;\n\n    for (const auto& entry : mapWallet)\n    {\n        const uint256& wtxid = entry.first;\n        const CWalletTx* pcoin = &entry.second;\n\n        if (!CheckFinalTx(*pcoin->tx))\n            continue;\n\n        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n            continue;\n\n        int nDepth = pcoin->GetDepthInMainChain();\n        if (nDepth < 0)\n            continue;\n\n        // We should not consider coins which aren't at least in our mempool\n        // It's possible for these to be conflicted via ancestors which we may never be able to detect\n        if (nDepth == 0 && !pcoin->InMempool())\n            continue;\n\n        bool safeTx = pcoin->IsTrusted();\n\n        // We should not consider coins from transactions that are replacing\n        // other transactions.\n        //\n        // Example: There is a transaction A which is replaced by bumpfee\n        // transaction B. In this case, we want to prevent creation of\n        // a transaction B' which spends an output of B.\n        //\n        // Reason: If transaction A were initially confirmed, transactions B\n        // and B' would no longer be valid, so the user would have to create\n        // a new transaction C to replace B'. However, in the case of a\n        // one-block reorg, transactions B' and C might BOTH be accepted,\n        // when the user only wanted one of them. Specifically, there could\n        // be a 1-block reorg away from the chain where transactions A and C\n        // were accepted to another chain where B, B', and C were all\n        // accepted.\n        if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {\n            safeTx = false;\n        }\n\n        // Similarly, we should not consider coins from transactions that\n        // have been replaced. In the example above, we would want to prevent\n        // creation of a transaction A' spending an output of A, because if\n        // transaction B were initially confirmed, conflicting with A and\n        // A', we wouldn't want to the user to create a transaction D\n        // intending to replace A', but potentially resulting in a scenario\n        // where A, A', and D could all be accepted (instead of just B and\n        // D, or just A and A' like the user would want).\n        if (nDepth == 0 && pcoin->mapValue.count(\"replaced_by_txid\")) {\n            safeTx = false;\n        }\n\n        if (fOnlySafe && !safeTx) {\n            continue;\n        }\n\n        if (nDepth < nMinDepth || nDepth > nMaxDepth)\n            continue;\n\n        for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n            if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n                continue;\n\n            if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n                continue;\n\n            if (IsLockedCoin(entry.first, i))\n                continue;\n\n            if (IsSpent(wtxid, i))\n                continue;\n\n            isminetype mine = IsMine(pcoin->tx->vout[i]);\n\n            if (mine == ISMINE_NO) {\n                continue;\n            }\n\n            bool fSpendableIn = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO);\n            bool fSolvableIn = (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO;\n\n            vCoins.push_back(COutput(pcoin, i, nDepth, fSpendableIn, fSolvableIn, safeTx));\n\n            // Checks the sum amount of all UTXO's.\n            if (nMinimumSumAmount != MAX_MONEY) {\n                nTotal += pcoin->tx->vout[i].nValue;\n\n                if (nTotal >= nMinimumSumAmount) {\n                    return;\n                }\n            }\n\n            // Checks the maximum number of UTXO's.\n            if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n                return;\n            }\n        }\n    }\n}\n\nstd::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n{\n    // TODO: Add AssertLockHeld(cs_wallet) here.\n    //\n    // Because the return value from this function contains pointers to\n    // CWalletTx objects, callers to this function really should acquire the\n    // cs_wallet lock before calling it. However, the current caller doesn't\n    // acquire this lock yet. There was an attempt to add the missing lock in\n    // https://github.com/bitcoin/bitcoin/pull/10340, but that change has been\n    // postponed until after https://github.com/bitcoin/bitcoin/pull/10244 to\n    // avoid adding some extra complexity to the Qt code.\n\n    std::map<CTxDestination, std::vector<COutput>> result;\n    std::vector<COutput> availableCoins;\n\n    LOCK2(cs_main, cs_wallet);\n    AvailableCoins(availableCoins);\n\n    for (auto& coin : availableCoins) {\n        CTxDestination address;\n        if (coin.fSpendable &&\n            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n            result[address].emplace_back(std::move(coin));\n        }\n    }\n\n    std::vector<COutPoint> lockedCoins;\n    ListLockedCoins(lockedCoins);\n    for (const auto& output : lockedCoins) {\n        auto it = mapWallet.find(output.hash);\n        if (it != mapWallet.end()) {\n            int depth = it->second.GetDepthInMainChain();\n            if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n                IsMine(it->second.tx->vout[output.n]) == ISMINE_SPENDABLE) {\n                CTxDestination address;\n                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n                    result[address].emplace_back(\n                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nconst CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n{\n    const CTransaction* ptx = &tx;\n    int n = output;\n    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n        const COutPoint& prevout = ptx->vin[0].prevout;\n        auto it = mapWallet.find(prevout.hash);\n        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n            !IsMine(it->second.tx->vout[prevout.n])) {\n            break;\n        }\n        ptx = it->second.tx.get();\n        n = prevout.n;\n    }\n    return ptx->vout[n];\n}\n\nbool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibilty_filter) const\n{\n    if (!output.fSpendable)\n        return false;\n\n    if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? eligibilty_filter.conf_mine : eligibilty_filter.conf_theirs))\n        return false;\n\n    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), eligibilty_filter.max_ancestors))\n        return false;\n\n    return true;\n}\n\nbool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins,\n                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    std::vector<CInputCoin> utxo_pool;\n    if (coin_selection_params.use_bnb) {\n\n        // Get long term estimate\n        FeeCalculation feeCalc;\n        CCoinControl temp;\n        temp.m_confirm_target = 1008;\n        CFeeRate long_term_feerate = GetMinimumFeeRate(temp, ::mempool, ::feeEstimator, &feeCalc);\n\n        // Calculate cost of change\n        CAmount cost_of_change = GetDiscardRate(::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n\n        // Filter by the min conf specs and add to utxo_pool and calculate effective value\n        for (const COutput &output : vCoins)\n        {\n            if (!OutputEligibleForSpending(output, eligibilty_filter))\n                continue;\n\n            CInputCoin coin(output.tx->tx, output.i);\n            coin.effective_value = coin.txout.nValue - (output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes));\n            // Only include outputs that are positive effective value (i.e. not dust)\n            if (coin.effective_value > 0) {\n                coin.fee = output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes);\n                coin.long_term_fee = output.nInputBytes < 0 ? 0 : long_term_feerate.GetFee(output.nInputBytes);\n                utxo_pool.push_back(coin);\n            }\n        }\n        // Calculate the fees for things that aren't inputs\n        CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n        bnb_used = true;\n        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n    } else {\n        // Filter by the min conf specs and add to utxo_pool\n        for (const COutput &output : vCoins)\n        {\n            if (!OutputEligibleForSpending(output, eligibilty_filter))\n                continue;\n\n            CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n            utxo_pool.push_back(coin);\n        }\n        bnb_used = false;\n        return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n    }\n}\n\nbool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n{\n    std::vector<COutput> vCoins(vAvailableCoins);\n\n    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n    if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n    {\n        // We didn't use BnB here, so set it to false.\n        bnb_used = false;\n\n        for (const COutput& out : vCoins)\n        {\n            if (!out.fSpendable)\n                 continue;\n            nValueRet += out.tx->tx->vout[out.i].nValue;\n            setCoinsRet.insert(CInputCoin(out.tx->tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    // calculate value from preset inputs and store them\n    std::set<CInputCoin> setPresetCoins;\n    CAmount nValueFromPresetInputs = 0;\n\n    std::vector<COutPoint> vPresetInputs;\n    coin_control.ListSelected(vPresetInputs);\n    for (const COutPoint& outpoint : vPresetInputs)\n    {\n        // For now, don't use BnB if preset inputs are selected. TODO: Enable this later\n        bnb_used = false;\n\n        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n        if (it != mapWallet.end())\n        {\n            const CWalletTx* pcoin = &it->second;\n            // Clearly invalid input, fail\n            if (pcoin->tx->vout.size() <= outpoint.n)\n                return false;\n            // Just to calculate the marginal byte size\n            nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n            setPresetCoins.insert(CInputCoin(pcoin->tx, outpoint.n));\n        } else\n            return false; // TODO: Allow non-wallet inputs\n    }\n\n    // remove preset inputs from vCoins\n    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n    {\n        if (setPresetCoins.count(CInputCoin(it->tx->tx, it->i)))\n            it = vCoins.erase(it);\n        else\n            ++it;\n    }\n\n    size_t nMaxChainLength = std::min(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT), gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT));\n    bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n\n    bool res = nTargetValue <= nValueFromPresetInputs ||\n        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n\n    // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n    setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());\n\n    // add preset inputs to the total value selected\n    nValueRet += nValueFromPresetInputs;\n\n    return res;\n}\n\nbool CWallet::SignTransaction(CMutableTransaction &tx)\n{\n    AssertLockHeld(cs_wallet); // mapWallet\n\n    // sign the new tx\n    CTransaction txNewConst(tx);\n    int nIn = 0;\n    for (const auto& input : tx.vin) {\n        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n        if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {\n            return false;\n        }\n        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n        SignatureData sigdata;\n        if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n            return false;\n        }\n        UpdateTransaction(tx, nIn, sigdata);\n        nIn++;\n    }\n    return true;\n}\n\nbool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n{\n    std::vector<CRecipient> vecSend;\n\n    // Turn the txout set into a CRecipient vector.\n    for (size_t idx = 0; idx < tx.vout.size(); idx++) {\n        const CTxOut& txOut = tx.vout[idx];\n        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, setSubtractFeeFromOutputs.count(idx) == 1};\n        vecSend.push_back(recipient);\n    }\n\n    coinControl.fAllowOtherInputs = true;\n\n    for (const CTxIn& txin : tx.vin) {\n        coinControl.Select(txin.prevout);\n    }\n\n    // Acquire the locks to prevent races to the new locked unspents between the\n    // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n    LOCK2(cs_main, cs_wallet);\n\n    CReserveKey reservekey(this);\n    CTransactionRef tx_new;\n    if (!CreateTransaction(vecSend, tx_new, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n        return false;\n    }\n\n    if (nChangePosInOut != -1) {\n        tx.vout.insert(tx.vout.begin() + nChangePosInOut, tx_new->vout[nChangePosInOut]);\n        // We don't have the normal Create/Commit cycle, and don't want to risk\n        // reusing change, so just remove the key from the keypool here.\n        reservekey.KeepKey();\n    }\n\n    // Copy output sizes from new transaction; they may have had the fee\n    // subtracted from them.\n    for (unsigned int idx = 0; idx < tx.vout.size(); idx++) {\n        tx.vout[idx].nValue = tx_new->vout[idx].nValue;\n    }\n\n    // Add new txins while keeping original txin scriptSig/order.\n    for (const CTxIn& txin : tx_new->vin) {\n        if (!coinControl.IsSelected(txin.prevout)) {\n            tx.vin.push_back(txin);\n\n            if (lockUnspents) {\n                LockCoin(txin.prevout);\n            }\n        }\n    }\n\n    return true;\n}\n\nOutputType CWallet::TransactionChangeType(OutputType change_type, const std::vector<CRecipient>& vecSend)\n{\n    // If -changetype is specified, always use that change type.\n    if (change_type != OutputType::NONE) {\n        return change_type;\n    }\n\n    // if m_default_address_type is legacy, use legacy address as change (even\n    // if some of the outputs are P2WPKH or P2WSH).\n    if (m_default_address_type == OutputType::LEGACY) {\n        return OutputType::LEGACY;\n    }\n\n    // if any destination is P2WPKH or P2WSH, use P2WPKH for the change\n    // output.\n    for (const auto& recipient : vecSend) {\n        // Check if any destination contains a witness program:\n        int witnessversion = 0;\n        std::vector<unsigned char> witnessprogram;\n        if (recipient.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n            return OutputType::BECH32;\n        }\n    }\n\n    // else use m_default_address_type for change\n    return m_default_address_type;\n}\n\nbool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n                                int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n{\n    CAmount nValue = 0;\n    int nChangePosRequest = nChangePosInOut;\n    unsigned int nSubtractFeeFromAmount = 0;\n    for (const auto& recipient : vecSend)\n    {\n        if (nValue < 0 || recipient.nAmount < 0)\n        {\n            strFailReason = _(\"Transaction amounts must not be negative\");\n            return false;\n        }\n        nValue += recipient.nAmount;\n\n        if (recipient.fSubtractFeeFromAmount)\n            nSubtractFeeFromAmount++;\n    }\n    if (vecSend.empty())\n    {\n        strFailReason = _(\"Transaction must have at least one recipient\");\n        return false;\n    }\n\n    CMutableTransaction txNew;\n\n    // Discourage fee sniping.\n    //\n    // For a large miner the value of the transactions in the best block and\n    // the mempool can exceed the cost of deliberately attempting to mine two\n    // blocks to orphan the current best block. By setting nLockTime such that\n    // only the next block can include the transaction, we discourage this\n    // practice as the height restricted and limited blocksize gives miners\n    // considering fee sniping fewer options for pulling off this attack.\n    //\n    // A simple way to think about this is from the wallet's point of view we\n    // always want the blockchain to move forward. By setting nLockTime this\n    // way we're basically making the statement that we only want this\n    // transaction to appear in the next block; we don't want to potentially\n    // encourage reorgs by allowing transactions to appear at lower heights\n    // than the next block in forks of the best chain.\n    //\n    // Of course, the subsidy is high enough, and transaction volume low\n    // enough, that fee sniping isn't a problem yet, but by implementing a fix\n    // now we ensure code won't be written that makes assumptions about\n    // nLockTime that preclude a fix later.\n    txNew.nLockTime = chainActive.Height();\n\n    // Secondly occasionally randomly pick a nLockTime even further back, so\n    // that transactions that are delayed after signing for whatever reason,\n    // e.g. high-latency mix networks and some CoinJoin implementations, have\n    // better privacy.\n    if (GetRandInt(10) == 0)\n        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));\n\n    assert(txNew.nLockTime <= (unsigned int)chainActive.Height());\n    assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n    FeeCalculation feeCalc;\n    CAmount nFeeNeeded;\n    int nBytes;\n    {\n        std::set<CInputCoin> setCoins;\n        LOCK2(cs_main, cs_wallet);\n        {\n            std::vector<COutput> vAvailableCoins;\n            AvailableCoins(vAvailableCoins, true, &coin_control);\n            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n\n            // Create change script that will be used if we need change\n            // TODO: pass in scriptChange instead of reservekey so\n            // change transaction isn't always pay-to-bitcoin-address\n            CScript scriptChange;\n\n            // coin control: send change to custom address\n            if (!boost::get<CNoDestination>(&coin_control.destChange)) {\n                scriptChange = GetScriptForDestination(coin_control.destChange);\n            } else { // no coin control: send change to newly generated address\n                // Note: We use a new key here to keep it from being obvious which side is the change.\n                //  The drawback is that by not reusing a previous key, the change may be lost if a\n                //  backup is restored, if the backup doesn't have the new private key for the change.\n                //  If we reused the old key, it would be possible to add code to look for and\n                //  rediscover unknown transactions that were written with keys of ours to recover\n                //  post-backup change.\n\n                // Reserve a new key pair from key pool\n                CPubKey vchPubKey;\n                bool ret;\n                ret = reservekey.GetReservedKey(vchPubKey, true);\n                if (!ret)\n                {\n                    strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");\n                    return false;\n                }\n\n                const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n\n                LearnRelatedScripts(vchPubKey, change_type);\n                scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));\n            }\n            CTxOut change_prototype_txout(0, scriptChange);\n            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n\n            CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n\n            // Get the fee rate to use effective values in coin selection\n            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);\n\n            nFeeRet = 0;\n            bool pick_new_inputs = true;\n            CAmount nValueIn = 0;\n\n            // BnB selector is the only selector used when this is true.\n            // That should only happen on the first pass through the loop.\n            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n            // Start with no fee and loop until there is enough fee\n            while (true)\n            {\n                nChangePosInOut = nChangePosRequest;\n                txNew.vin.clear();\n                txNew.vout.clear();\n                bool fFirst = true;\n\n                CAmount nValueToSelect = nValue;\n                if (nSubtractFeeFromAmount == 0)\n                    nValueToSelect += nFeeRet;\n\n                // vouts to the payees\n                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n                for (const auto& recipient : vecSend)\n                {\n                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n\n                    if (recipient.fSubtractFeeFromAmount)\n                    {\n                        assert(nSubtractFeeFromAmount != 0);\n                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n\n                        if (fFirst) // first receiver pays the remainder not divisible by output count\n                        {\n                            fFirst = false;\n                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                        }\n                    }\n                    // Include the fee cost for outputs. Note this is only used for BnB right now\n                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n\n                    if (IsDust(txout, ::dustRelayFee))\n                    {\n                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                        {\n                            if (txout.nValue < 0)\n                                strFailReason = _(\"The transaction amount is too small to pay the fee\");\n                            else\n                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                        }\n                        else\n                            strFailReason = _(\"Transaction amount too small\");\n                        return false;\n                    }\n                    txNew.vout.push_back(txout);\n                }\n\n                // Choose coins to use\n                bool bnb_used;\n                if (pick_new_inputs) {\n                    nValueIn = 0;\n                    setCoins.clear();\n                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n                    coin_selection_params.effective_fee = nFeeRateNeeded;\n                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                    {\n                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n                        if (bnb_used) {\n                            coin_selection_params.use_bnb = false;\n                            continue;\n                        }\n                        else {\n                            strFailReason = _(\"Insufficient funds\");\n                            return false;\n                        }\n                    }\n                }\n\n                const CAmount nChange = nValueIn - nValueToSelect;\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    CTxOut newTxOut(nChange, scriptChange);\n\n                    // Never create dust outputs; if we would, just\n                    // add the dust to the fee.\n                    // The nChange when BnB is used is always going to go to fees.\n                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n                    {\n                        nChangePosInOut = -1;\n                        nFeeRet += nChange;\n                    }\n                    else\n                    {\n                        if (nChangePosInOut == -1)\n                        {\n                            // Insert change txn at random position:\n                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                        }\n                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                        {\n                            strFailReason = _(\"Change index out of range\");\n                            return false;\n                        }\n\n                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                        txNew.vout.insert(position, newTxOut);\n                    }\n                } else {\n                    nChangePosInOut = -1;\n                }\n\n                // Fill vin\n                //\n                // Note how the sequence number is set to non-maxint so that\n                // the nLockTime set above actually works.\n                //\n                // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n                // we use the highest possible value in that range (maxint-2)\n                // to avoid conflicting with other possible uses of nSequence,\n                // and in the spirit of \"smallest possible change from prior\n                // behavior.\"\n                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n                for (const auto& coin : setCoins)\n                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n                                              nSequence));\n\n                nBytes = CalculateMaximumSignedTxSize(txNew, this);\n                if (nBytes < 0) {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                }\n\n                nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n                if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {\n                    // eventually allow a fallback fee\n                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n                    return false;\n                }\n\n                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n                // because we must be at the maximum allowed fee.\n                if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))\n                {\n                    strFailReason = _(\"Transaction too large for fee policy\");\n                    return false;\n                }\n\n                if (nFeeRet >= nFeeNeeded) {\n                    // Reduce fee to only the needed amount if possible. This\n                    // prevents potential overpayment in fees if the coins\n                    // selected to meet nFeeNeeded result in a transaction that\n                    // requires less fee than the prior iteration.\n\n                    // If we have no change and a big enough excess fee, then\n                    // try to construct transaction again only without picking\n                    // new inputs. We now know we only need the smaller fee\n                    // (because of reduced tx size) and so we should add a\n                    // change output. Only try this once.\n                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n                        CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n                            pick_new_inputs = false;\n                            nFeeRet = fee_needed_with_change;\n                            continue;\n                        }\n                    }\n\n                    // If we have change output already, just increase it\n                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                        change_position->nValue += extraFeePaid;\n                        nFeeRet -= extraFeePaid;\n                    }\n                    break; // Done, enough fee included.\n                }\n                else if (!pick_new_inputs) {\n                    // This shouldn't happen, we should have had enough excess\n                    // fee to pay for the new output and still meet nFeeNeeded\n                    // Or we should have just subtracted fee from recipients and\n                    // nFeeNeeded should not have changed\n                    strFailReason = _(\"Transaction fee and change calculation failed\");\n                    return false;\n                }\n\n                // Try to reduce change to include necessary fee\n                if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                    // Only reduce change if remaining amount is still a large enough output.\n                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n                        change_position->nValue -= additionalFeeNeeded;\n                        nFeeRet += additionalFeeNeeded;\n                        break; // Done, able to increase fee from change\n                    }\n                }\n\n                // If subtracting fee from recipients, we now know what fee we\n                // need to subtract, we have no reason to reselect inputs\n                if (nSubtractFeeFromAmount > 0) {\n                    pick_new_inputs = false;\n                }\n\n                // Include more fee and try again.\n                nFeeRet = nFeeNeeded;\n                coin_selection_params.use_bnb = false;\n                continue;\n            }\n        }\n\n        if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n\n        if (sign)\n        {\n            CTransaction txNewConst(txNew);\n            int nIn = 0;\n            for (const auto& coin : setCoins)\n            {\n                const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                SignatureData sigdata;\n\n                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                } else {\n                    UpdateTransaction(txNew, nIn, sigdata);\n                }\n\n                nIn++;\n            }\n        }\n\n        // Return the constructed transaction data.\n        tx = MakeTransactionRef(std::move(txNew));\n\n        // Limit size\n        if (GetTransactionWeight(*tx) >= MAX_STANDARD_TX_WEIGHT)\n        {\n            strFailReason = _(\"Transaction too large\");\n            return false;\n        }\n    }\n\n    if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n        // Lastly, ensure this tx will pass the mempool's chain limits\n        LockPoints lp;\n        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n        CTxMemPool::setEntries setAncestors;\n        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n        std::string errString;\n        if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n            strFailReason = _(\"Transaction has too long of a mempool chain\");\n            return false;\n        }\n    }\n\n    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n              nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n              feeCalc.est.pass.start, feeCalc.est.pass.end,\n              100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),\n              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n              feeCalc.est.fail.start, feeCalc.est.fail.end,\n              100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool),\n              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n    return true;\n}\n\n/**\n * Call after CreateTransaction unless you want to abort\n */\nbool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n\n        CWalletTx wtxNew(this, std::move(tx));\n        wtxNew.mapValue = std::move(mapValue);\n        wtxNew.vOrderForm = std::move(orderForm);\n        wtxNew.strFromAccount = std::move(fromAccount);\n        wtxNew.fTimeReceivedIsTxTime = true;\n        wtxNew.fFromMe = true;\n\n        LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.tx->ToString());\n        {\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Notify that old coins are spent\n            for (const CTxIn& txin : wtxNew.tx->vin)\n            {\n                CWalletTx &coin = mapWallet.at(txin.prevout.hash);\n                coin.BindWallet(this);\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Get the inserted-CWalletTx from mapWallet so that the\n        // fInMempool flag is cached properly\n        CWalletTx& wtx = mapWallet.at(wtxNew.GetHash());\n\n        if (fBroadcastTransactions)\n        {\n            // Broadcast\n            if (!wtx.AcceptToMemoryPool(maxTxFee, state)) {\n                LogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", FormatStateMessage(state));\n                // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n            } else {\n                wtx.RelayWalletTransaction(connman);\n            }\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries) {\n    CWalletDB walletdb(*dbw);\n    return walletdb.ListAccountCreditDebit(strAccount, entries);\n}\n\nbool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)\n{\n    CWalletDB walletdb(*dbw);\n\n    return AddAccountingEntry(acentry, &walletdb);\n}\n\nbool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwalletdb)\n{\n    if (!pwalletdb->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {\n        return false;\n    }\n\n    laccentries.push_back(acentry);\n    CAccountingEntry & entry = laccentries.back();\n    wtxOrdered.insert(std::make_pair(entry.nOrderPos, TxPair(nullptr, &entry)));\n\n    return true;\n}\n\nDBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    LOCK2(cs_main, cs_wallet);\n\n    fFirstRunRet = false;\n    DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (dbw->Rewrite(\"\\x04pool\"))\n        {\n            setInternalKeyPool.clear();\n            setExternalKeyPool.clear();\n            m_pool_key_to_index.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // that requires a new key.\n        }\n    }\n\n    // This wallet is in its first run if all of these are empty\n    fFirstRunRet = mapKeys.empty() && mapCryptedKeys.empty() && mapWatchKeys.empty() && setWatchOnly.empty() && mapScripts.empty();\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n\n    uiInterface.LoadWallet(this);\n\n    return DB_LOAD_OK;\n}\n\nDBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n{\n    AssertLockHeld(cs_wallet); // mapWallet\n    DBErrors nZapSelectTxRet = CWalletDB(*dbw,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n    for (uint256 hash : vHashOut)\n        mapWallet.erase(hash);\n\n    if (nZapSelectTxRet == DB_NEED_REWRITE)\n    {\n        if (dbw->Rewrite(\"\\x04pool\"))\n        {\n            setInternalKeyPool.clear();\n            setExternalKeyPool.clear();\n            m_pool_key_to_index.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // that requires a new key.\n        }\n    }\n\n    if (nZapSelectTxRet != DB_LOAD_OK)\n        return nZapSelectTxRet;\n\n    MarkDirty();\n\n    return DB_LOAD_OK;\n\n}\n\nDBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n{\n    DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n    if (nZapWalletTxRet == DB_NEED_REWRITE)\n    {\n        if (dbw->Rewrite(\"\\x04pool\"))\n        {\n            LOCK(cs_wallet);\n            setInternalKeyPool.clear();\n            setExternalKeyPool.clear();\n            m_pool_key_to_index.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // that requires a new key.\n        }\n    }\n\n    if (nZapWalletTxRet != DB_LOAD_OK)\n        return nZapWalletTxRet;\n\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& strPurpose)\n{\n    bool fUpdated = false;\n    {\n        LOCK(cs_wallet); // mapAddressBook\n        std::map<CTxDestination, CAddressBookData>::iterator mi = mapAddressBook.find(address);\n        fUpdated = mi != mapAddressBook.end();\n        mapAddressBook[address].name = strName;\n        if (!strPurpose.empty()) /* update purpose only if requested */\n            mapAddressBook[address].purpose = strPurpose;\n    }\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n                             strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n    if (!strPurpose.empty() && !CWalletDB(*dbw).WritePurpose(EncodeDestination(address), strPurpose))\n        return false;\n    return CWalletDB(*dbw).WriteName(EncodeDestination(address), strName);\n}\n\nbool CWallet::DelAddressBook(const CTxDestination& address)\n{\n    {\n        LOCK(cs_wallet); // mapAddressBook\n\n        // Delete destdata tuples associated with address\n        std::string strAddress = EncodeDestination(address);\n        for (const std::pair<std::string, std::string> &item : mapAddressBook[address].destdata)\n        {\n            CWalletDB(*dbw).EraseDestData(strAddress, item.first);\n        }\n        mapAddressBook.erase(address);\n    }\n\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n\n    CWalletDB(*dbw).ErasePurpose(EncodeDestination(address));\n    return CWalletDB(*dbw).EraseName(EncodeDestination(address));\n}\n\nconst std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n{\n    CTxDestination address;\n    if (ExtractDestination(scriptPubKey, address) && !scriptPubKey.IsUnspendable()) {\n        auto mi = mapAddressBook.find(address);\n        if (mi != mapAddressBook.end()) {\n            return mi->second.name;\n        }\n    }\n    // A scriptPubKey that doesn't have an entry in the address book is\n    // associated with the default account (\"\").\n    const static std::string DEFAULT_ACCOUNT_NAME;\n    return DEFAULT_ACCOUNT_NAME;\n}\n\n/**\n * Mark old keypool keys as used,\n * and generate all new keys\n */\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(*dbw);\n\n        for (int64_t nIndex : setInternalKeyPool) {\n            walletdb.ErasePool(nIndex);\n        }\n        setInternalKeyPool.clear();\n\n        for (int64_t nIndex : setExternalKeyPool) {\n            walletdb.ErasePool(nIndex);\n        }\n        setExternalKeyPool.clear();\n\n        m_pool_key_to_index.clear();\n\n        if (!TopUpKeyPool()) {\n            return false;\n        }\n        LogPrintf(\"CWallet::NewKeyPool rewrote keypool\\n\");\n    }\n    return true;\n}\n\nsize_t CWallet::KeypoolCountExternalKeys()\n{\n    AssertLockHeld(cs_wallet); // setExternalKeyPool\n    return setExternalKeyPool.size();\n}\n\nvoid CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n{\n    AssertLockHeld(cs_wallet);\n    if (keypool.fInternal) {\n        setInternalKeyPool.insert(nIndex);\n    } else {\n        setExternalKeyPool.insert(nIndex);\n    }\n    m_max_keypool_index = std::max(m_max_keypool_index, nIndex);\n    m_pool_key_to_index[keypool.vchPubKey.GetID()] = nIndex;\n\n    // If no metadata exists yet, create a default with the pool key's\n    // creation time. Note that this may be overwritten by actually\n    // stored metadata for that key later, which is fine.\n    CKeyID keyid = keypool.vchPubKey.GetID();\n    if (mapKeyMetadata.count(keyid) == 0)\n        mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n}\n\nbool CWallet::TopUpKeyPool(unsigned int kpSize)\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        // Top up key pool\n        unsigned int nTargetSize;\n        if (kpSize > 0)\n            nTargetSize = kpSize;\n        else\n            nTargetSize = std::max(gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n\n        // count amount of available keys (internal, external)\n        // make sure the keypool of external and internal keys fits the user selected target (-keypool)\n        int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setExternalKeyPool.size(), (int64_t) 0);\n        int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setInternalKeyPool.size(), (int64_t) 0);\n\n        if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n        {\n            // don't create extra internal keys\n            missingInternal = 0;\n        }\n        bool internal = false;\n        CWalletDB walletdb(*dbw);\n        for (int64_t i = missingInternal + missingExternal; i--;)\n        {\n            if (i < missingInternal) {\n                internal = true;\n            }\n\n            assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n            int64_t index = ++m_max_keypool_index;\n\n            CPubKey pubkey(GenerateNewKey(walletdb, internal));\n            if (!walletdb.WritePool(index, CKeyPool(pubkey, internal))) {\n                throw std::runtime_error(std::string(__func__) + \": writing generated key failed\");\n            }\n\n            if (internal) {\n                setInternalKeyPool.insert(index);\n            } else {\n                setExternalKeyPool.insert(index);\n            }\n            m_pool_key_to_index[pubkey.GetID()] = index;\n        }\n        if (missingInternal + missingExternal > 0) {\n            LogPrintf(\"keypool added %d keys (%d internal), size=%u (%u internal)\\n\", missingInternal + missingExternal, missingInternal, setInternalKeyPool.size() + setExternalKeyPool.size(), setInternalKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        bool fReturningInternal = IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT) && fRequestedInternal;\n        std::set<int64_t>& setKeyPool = fReturningInternal ? setInternalKeyPool : setExternalKeyPool;\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(*dbw);\n\n        auto it = setKeyPool.begin();\n        nIndex = *it;\n        setKeyPool.erase(it);\n        if (!walletdb.ReadPool(nIndex, keypool)) {\n            throw std::runtime_error(std::string(__func__) + \": read failed\");\n        }\n        if (!HaveKey(keypool.vchPubKey.GetID())) {\n            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n        }\n        if (keypool.fInternal != fReturningInternal) {\n            throw std::runtime_error(std::string(__func__) + \": keypool entry misclassified\");\n        }\n\n        assert(keypool.vchPubKey.IsValid());\n        m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n        LogPrintf(\"keypool reserve %d\\n\", nIndex);\n    }\n}\n\nvoid CWallet::KeepKey(int64_t nIndex)\n{\n    // Remove from key pool\n    CWalletDB walletdb(*dbw);\n    walletdb.ErasePool(nIndex);\n    LogPrintf(\"keypool keep %d\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        if (fInternal) {\n            setInternalKeyPool.insert(nIndex);\n        } else {\n            setExternalKeyPool.insert(nIndex);\n        }\n        m_pool_key_to_index[pubkey.GetID()] = nIndex;\n    }\n    LogPrintf(\"keypool return %d\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n{\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        int64_t nIndex = 0;\n        ReserveKeyFromKeyPool(nIndex, keypool, internal);\n        if (nIndex == -1)\n        {\n            if (IsLocked()) return false;\n            CWalletDB walletdb(*dbw);\n            result = GenerateNewKey(walletdb, internal);\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nstatic int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, CWalletDB& walletdb) {\n    if (setKeyPool.empty()) {\n        return GetTime();\n    }\n\n    CKeyPool keypool;\n    int64_t nIndex = *(setKeyPool.begin());\n    if (!walletdb.ReadPool(nIndex, keypool)) {\n        throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n    }\n    assert(keypool.vchPubKey.IsValid());\n    return keypool.nTime;\n}\n\nint64_t CWallet::GetOldestKeyPoolTime()\n{\n    LOCK(cs_wallet);\n\n    CWalletDB walletdb(*dbw);\n\n    // load oldest key from keypool, get time and return\n    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, walletdb);\n    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, walletdb), oldestKey);\n    }\n\n    return oldestKey;\n}\n\nstd::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n{\n    std::map<CTxDestination, CAmount> balances;\n\n    {\n        LOCK(cs_wallet);\n        for (const auto& walletEntry : mapWallet)\n        {\n            const CWalletTx *pcoin = &walletEntry.second;\n\n            if (!pcoin->IsTrusted())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? 0 : 1))\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++)\n            {\n                CTxDestination addr;\n                if (!IsMine(pcoin->tx->vout[i]))\n                    continue;\n                if(!ExtractDestination(pcoin->tx->vout[i].scriptPubKey, addr))\n                    continue;\n\n                CAmount n = IsSpent(walletEntry.first, i) ? 0 : pcoin->tx->vout[i].nValue;\n\n                if (!balances.count(addr))\n                    balances[addr] = 0;\n                balances[addr] += n;\n            }\n        }\n    }\n\n    return balances;\n}\n\nstd::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n{\n    AssertLockHeld(cs_wallet); // mapWallet\n    std::set< std::set<CTxDestination> > groupings;\n    std::set<CTxDestination> grouping;\n\n    for (const auto& walletEntry : mapWallet)\n    {\n        const CWalletTx *pcoin = &walletEntry.second;\n\n        if (pcoin->tx->vin.size() > 0)\n        {\n            bool any_mine = false;\n            // group all input addresses with each other\n            for (CTxIn txin : pcoin->tx->vin)\n            {\n                CTxDestination address;\n                if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n                    continue;\n                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                any_mine = true;\n            }\n\n            // group change with input addresses\n            if (any_mine)\n            {\n               for (CTxOut txout : pcoin->tx->vout)\n                   if (IsChange(txout))\n                   {\n                       CTxDestination txoutAddr;\n                       if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                           continue;\n                       grouping.insert(txoutAddr);\n                   }\n            }\n            if (grouping.size() > 0)\n            {\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n        }\n\n        // group lone addrs by themselves\n        for (const auto& txout : pcoin->tx->vout)\n            if (IsMine(txout))\n            {\n                CTxDestination address;\n                if(!ExtractDestination(txout.scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n    }\n\n    std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n    std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n    for (std::set<CTxDestination> _grouping : groupings)\n    {\n        // make a set of all the groups hit by this new group\n        std::set< std::set<CTxDestination>* > hits;\n        std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n        for (CTxDestination address : _grouping)\n            if ((it = setmap.find(address)) != setmap.end())\n                hits.insert((*it).second);\n\n        // merge all hit groups into a new single group and delete old groups\n        std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n        for (std::set<CTxDestination>* hit : hits)\n        {\n            merged->insert(hit->begin(), hit->end());\n            uniqueGroupings.erase(hit);\n            delete hit;\n        }\n        uniqueGroupings.insert(merged);\n\n        // update setmap\n        for (CTxDestination element : *merged)\n            setmap[element] = merged;\n    }\n\n    std::set< std::set<CTxDestination> > ret;\n    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)\n    {\n        ret.insert(*uniqueGrouping);\n        delete uniqueGrouping;\n    }\n\n    return ret;\n}\n\nstd::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n{\n    LOCK(cs_wallet);\n    std::set<CTxDestination> result;\n    for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n    {\n        const CTxDestination& address = item.first;\n        const std::string& strName = item.second.name;\n        if (strName == strAccount)\n            result.insert(address);\n    }\n    return result;\n}\n\nbool CReserveKey::GetReservedKey(CPubKey& pubkey, bool internal)\n{\n    if (nIndex == -1)\n    {\n        CKeyPool keypool;\n        pwallet->ReserveKeyFromKeyPool(nIndex, keypool, internal);\n        if (nIndex != -1)\n            vchPubKey = keypool.vchPubKey;\n        else {\n            return false;\n        }\n        fInternal = keypool.fInternal;\n    }\n    assert(vchPubKey.IsValid());\n    pubkey = vchPubKey;\n    return true;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1) {\n        pwallet->ReturnKey(nIndex, fInternal, vchPubKey);\n    }\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n{\n    AssertLockHeld(cs_wallet);\n    bool internal = setInternalKeyPool.count(keypool_id);\n    if (!internal) assert(setExternalKeyPool.count(keypool_id));\n    std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : &setExternalKeyPool;\n    auto it = setKeyPool->begin();\n\n    CWalletDB walletdb(*dbw);\n    while (it != std::end(*setKeyPool)) {\n        const int64_t& index = *(it);\n        if (index > keypool_id) break; // set*KeyPool is ordered\n\n        CKeyPool keypool;\n        if (walletdb.ReadPool(index, keypool)) { //TODO: This should be unnecessary\n            m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n        }\n        LearnAllRelatedScripts(keypool.vchPubKey);\n        walletdb.ErasePool(index);\n        LogPrintf(\"keypool index %d removed\\n\", index);\n        it = setKeyPool->erase(it);\n    }\n}\n\nvoid CWallet::GetScriptForMining(std::shared_ptr<CReserveScript> &script)\n{\n    std::shared_ptr<CReserveKey> rKey = std::make_shared<CReserveKey>(this);\n    CPubKey pubkey;\n    if (!rKey->GetReservedKey(pubkey))\n        return;\n\n    script = rKey;\n    script->reserveScript = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n}\n\nvoid CWallet::LockCoin(const COutPoint& output)\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    setLockedCoins.insert(output);\n}\n\nvoid CWallet::UnlockCoin(const COutPoint& output)\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    setLockedCoins.erase(output);\n}\n\nvoid CWallet::UnlockAllCoins()\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    setLockedCoins.clear();\n}\n\nbool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    COutPoint outpt(hash, n);\n\n    return (setLockedCoins.count(outpt) > 0);\n}\n\nvoid CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n         it != setLockedCoins.end(); it++) {\n        COutPoint outpt = (*it);\n        vOutpts.push_back(outpt);\n    }\n}\n\n/** @} */ // end of Actions\n\nvoid CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) const {\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n    mapKeyBirth.clear();\n\n    // get birth times for keys with metadata\n    for (const auto& entry : mapKeyMetadata) {\n        if (entry.second.nCreateTime) {\n            mapKeyBirth[entry.first] = entry.second.nCreateTime;\n        }\n    }\n\n    // map in which we'll infer heights of other keys\n    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n    for (const CKeyID &keyid : GetKeys()) {\n        if (mapKeyBirth.count(keyid) == 0)\n            mapKeyFirstBlock[keyid] = pindexMax;\n    }\n\n    // if there are no such keys, we're done\n    if (mapKeyFirstBlock.empty())\n        return;\n\n    // find first block that affects those keys, if there are any left\n    std::vector<CKeyID> vAffected;\n    for (const auto& entry : mapWallet) {\n        // iterate over all wallet transactions...\n        const CWalletTx &wtx = entry.second;\n        CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n        if (pindex && chainActive.Contains(pindex)) {\n            // ... which are already in a block\n            int nHeight = pindex->nHeight;\n            for (const CTxOut &txout : wtx.tx->vout) {\n                // iterate over all their outputs\n                CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n                for (const CKeyID &keyid : vAffected) {\n                    // ... and all their affected keys\n                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                        rit->second = pindex;\n                }\n                vAffected.clear();\n            }\n        }\n    }\n\n    // Extract block timestamps for those keys\n    for (const auto& entry : mapKeyFirstBlock)\n        mapKeyBirth[entry.first] = entry.second->GetBlockTime() - TIMESTAMP_WINDOW; // block times can be 2h off\n}\n\n/**\n * Compute smart timestamp for a transaction being added to the wallet.\n *\n * Logic:\n * - If sending a transaction, assign its timestamp to the current time.\n * - If receiving a transaction outside a block, assign its timestamp to the\n *   current time.\n * - If receiving a block with a future timestamp, assign all its (not already\n *   known) transactions' timestamps to the current time.\n * - If receiving a block with a past timestamp, before the most recent known\n *   transaction (that we care about), assign all its (not already known)\n *   transactions' timestamps to the same timestamp as that most-recent-known\n *   transaction.\n * - If receiving a block with a past timestamp, but after the most recent known\n *   transaction, assign all its (not already known) transactions' timestamps to\n *   the block time.\n *\n * For more information see CWalletTx::nTimeSmart,\n * https://bitcointalk.org/?topic=54527, or\n * https://github.com/bitcoin/bitcoin/pull/1393.\n */\nunsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n{\n    unsigned int nTimeSmart = wtx.nTimeReceived;\n    if (!wtx.hashUnset()) {\n        if (const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock)) {\n            int64_t latestNow = wtx.nTimeReceived;\n            int64_t latestEntry = 0;\n\n            // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n            int64_t latestTolerated = latestNow + 300;\n            const TxItems& txOrdered = wtxOrdered;\n            for (auto it = txOrdered.rbegin(); it != txOrdered.rend(); ++it) {\n                CWalletTx* const pwtx = it->second.first;\n                if (pwtx == &wtx) {\n                    continue;\n                }\n                CAccountingEntry* const pacentry = it->second.second;\n                int64_t nSmartTime;\n                if (pwtx) {\n                    nSmartTime = pwtx->nTimeSmart;\n                    if (!nSmartTime) {\n                        nSmartTime = pwtx->nTimeReceived;\n                    }\n                } else {\n                    nSmartTime = pacentry->nTime;\n                }\n                if (nSmartTime <= latestTolerated) {\n                    latestEntry = nSmartTime;\n                    if (nSmartTime > latestNow) {\n                        latestNow = nSmartTime;\n                    }\n                    break;\n                }\n            }\n\n            int64_t blocktime = pindex->GetBlockTime();\n            nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n        } else {\n            LogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.hashBlock.ToString());\n        }\n    }\n    return nTimeSmart;\n}\n\nbool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, const std::string &value)\n{\n    if (boost::get<CNoDestination>(&dest))\n        return false;\n\n    mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n    return CWalletDB(*dbw).WriteDestData(EncodeDestination(dest), key, value);\n}\n\nbool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n{\n    if (!mapAddressBook[dest].destdata.erase(key))\n        return false;\n    return CWalletDB(*dbw).EraseDestData(EncodeDestination(dest), key);\n}\n\nbool CWallet::LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value)\n{\n    mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n    return true;\n}\n\nbool CWallet::GetDestData(const CTxDestination &dest, const std::string &key, std::string *value) const\n{\n    std::map<CTxDestination, CAddressBookData>::const_iterator i = mapAddressBook.find(dest);\n    if(i != mapAddressBook.end())\n    {\n        CAddressBookData::StringMap::const_iterator j = i->second.destdata.find(key);\n        if(j != i->second.destdata.end())\n        {\n            if(value)\n                *value = j->second;\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::vector<std::string> CWallet::GetDestValues(const std::string& prefix) const\n{\n    LOCK(cs_wallet);\n    std::vector<std::string> values;\n    for (const auto& address : mapAddressBook) {\n        for (const auto& data : address.second.destdata) {\n            if (!data.first.compare(0, prefix.size(), prefix)) {\n                values.emplace_back(data.second);\n            }\n        }\n    }\n    return values;\n}\n\nCWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path& path)\n{\n    const std::string& walletFile = name;\n\n    // needed to restore wallet transaction meta data after -zapwallettxes\n    std::vector<CWalletTx> vWtx;\n\n    if (gArgs.GetBoolArg(\"-zapwallettxes\", false)) {\n        uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n\n        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, CWalletDBWrapper::Create(path));\n        DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n        if (nZapWalletRet != DB_LOAD_OK) {\n            InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n            return nullptr;\n        }\n    }\n\n    uiInterface.InitMessage(_(\"Loading wallet...\"));\n\n    int64_t nStart = GetTimeMillis();\n    bool fFirstRun = true;\n    CWallet *walletInstance = new CWallet(name, CWalletDBWrapper::Create(path));\n    DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n    if (nLoadWalletRet != DB_LOAD_OK)\n    {\n        if (nLoadWalletRet == DB_CORRUPT) {\n            InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n            return nullptr;\n        }\n        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n        {\n            InitWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n                                         \" or address book entries might be missing or incorrect.\"),\n                walletFile));\n        }\n        else if (nLoadWalletRet == DB_TOO_NEW) {\n            InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n            return nullptr;\n        }\n        else if (nLoadWalletRet == DB_NEED_REWRITE)\n        {\n            InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n            return nullptr;\n        }\n        else {\n            InitError(strprintf(_(\"Error loading %s\"), walletFile));\n            return nullptr;\n        }\n    }\n\n    if (gArgs.GetBoolArg(\"-upgradewallet\", fFirstRun))\n    {\n        int nMaxVersion = gArgs.GetArg(\"-upgradewallet\", 0);\n        if (nMaxVersion == 0) // the -upgradewallet without argument case\n        {\n            LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n            nMaxVersion = CLIENT_VERSION;\n            walletInstance->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n        }\n        else\n            LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n        if (nMaxVersion < walletInstance->GetVersion())\n        {\n            InitError(_(\"Cannot downgrade wallet\"));\n            return nullptr;\n        }\n        walletInstance->SetMaxVersion(nMaxVersion);\n    }\n\n    if (fFirstRun)\n    {\n        // ensure this wallet.dat can only be opened by clients supporting HD with chain split and expects no default key\n        if (!gArgs.GetBoolArg(\"-usehd\", true)) {\n            InitError(strprintf(_(\"Error creating %s: You can't create non-HD wallets with this version.\"), walletFile));\n            return nullptr;\n        }\n        walletInstance->SetMinVersion(FEATURE_NO_DEFAULT_KEY);\n\n        // generate a new master key\n        CPubKey masterPubKey = walletInstance->GenerateNewHDMasterKey();\n        if (!walletInstance->SetHDMasterKey(masterPubKey))\n            throw std::runtime_error(std::string(__func__) + \": Storing master key failed\");\n\n        // Top up the keypool\n        if (!walletInstance->TopUpKeyPool()) {\n            InitError(_(\"Unable to generate initial keys\") += \"\\n\");\n            return nullptr;\n        }\n\n        walletInstance->SetBestChain(chainActive.GetLocator());\n    } else if (gArgs.IsArgSet(\"-usehd\")) {\n        bool useHD = gArgs.GetBoolArg(\"-usehd\", true);\n        if (walletInstance->IsHDEnabled() && !useHD) {\n            InitError(strprintf(_(\"Error loading %s: You can't disable HD on an already existing HD wallet\"), walletFile));\n            return nullptr;\n        }\n        if (!walletInstance->IsHDEnabled() && useHD) {\n            InitError(strprintf(_(\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"), walletFile));\n            return nullptr;\n        }\n    }\n\n    walletInstance->m_default_address_type = ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"), DEFAULT_ADDRESS_TYPE);\n    if (walletInstance->m_default_address_type == OutputType::NONE) {\n        InitError(strprintf(\"Unknown address type '%s'\", gArgs.GetArg(\"-addresstype\", \"\")));\n        return nullptr;\n    }\n\n    // If changetype is set in config file or parameter, check that it's valid.\n    // Default to OutputType::NONE if not set.\n    walletInstance->m_default_change_type = ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"), OutputType::NONE);\n    if (walletInstance->m_default_change_type == OutputType::NONE && !gArgs.GetArg(\"-changetype\", \"\").empty()) {\n        InitError(strprintf(\"Unknown change type '%s'\", gArgs.GetArg(\"-changetype\", \"\")));\n        return nullptr;\n    }\n\n    LogPrintf(\" wallet      %15dms\\n\", GetTimeMillis() - nStart);\n\n    // Try to top up keypool. No-op if the wallet is locked.\n    walletInstance->TopUpKeyPool();\n\n    LOCK(cs_main);\n\n    CBlockIndex *pindexRescan = chainActive.Genesis();\n    if (!gArgs.GetBoolArg(\"-rescan\", false))\n    {\n        CWalletDB walletdb(*walletInstance->dbw);\n        CBlockLocator locator;\n        if (walletdb.ReadBestBlock(locator))\n            pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n    }\n\n    walletInstance->m_last_block_processed = chainActive.Tip();\n    RegisterValidationInterface(walletInstance);\n\n    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n    {\n        //We can't rescan beyond non-pruned blocks, stop and throw an error\n        //this might happen if a user uses an old wallet within a pruned node\n        // or if he ran -disablewallet for a longer time, then decided to re-enable\n        if (fPruneMode)\n        {\n            CBlockIndex *block = chainActive.Tip();\n            while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n                block = block->pprev;\n\n            if (pindexRescan != block) {\n                InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n                return nullptr;\n            }\n        }\n\n        uiInterface.InitMessage(_(\"Rescanning...\"));\n        LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n\n        // No need to read and scan block if block was created before\n        // our wallet birthday (as adjusted for block time variability)\n        while (pindexRescan && walletInstance->nTimeFirstKey && (pindexRescan->GetBlockTime() < (walletInstance->nTimeFirstKey - TIMESTAMP_WINDOW))) {\n            pindexRescan = chainActive.Next(pindexRescan);\n        }\n\n        nStart = GetTimeMillis();\n        {\n            WalletRescanReserver reserver(walletInstance);\n            if (!reserver.reserve()) {\n                InitError(_(\"Failed to rescan the wallet during initialization\"));\n                return nullptr;\n            }\n            walletInstance->ScanForWalletTransactions(pindexRescan, nullptr, reserver, true);\n        }\n        LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n        walletInstance->SetBestChain(chainActive.GetLocator());\n        walletInstance->dbw->IncrementUpdateCounter();\n\n        // Restore wallet transaction metadata after -zapwallettxes=1\n        if (gArgs.GetBoolArg(\"-zapwallettxes\", false) && gArgs.GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n        {\n            CWalletDB walletdb(*walletInstance->dbw);\n\n            for (const CWalletTx& wtxOld : vWtx)\n            {\n                uint256 hash = wtxOld.GetHash();\n                std::map<uint256, CWalletTx>::iterator mi = walletInstance->mapWallet.find(hash);\n                if (mi != walletInstance->mapWallet.end())\n                {\n                    const CWalletTx* copyFrom = &wtxOld;\n                    CWalletTx* copyTo = &mi->second;\n                    copyTo->mapValue = copyFrom->mapValue;\n                    copyTo->vOrderForm = copyFrom->vOrderForm;\n                    copyTo->nTimeReceived = copyFrom->nTimeReceived;\n                    copyTo->nTimeSmart = copyFrom->nTimeSmart;\n                    copyTo->fFromMe = copyFrom->fFromMe;\n                    copyTo->strFromAccount = copyFrom->strFromAccount;\n                    copyTo->nOrderPos = copyFrom->nOrderPos;\n                    walletdb.WriteTx(*copyTo);\n                }\n            }\n        }\n    }\n    walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n\n    {\n        LOCK(walletInstance->cs_wallet);\n        LogPrintf(\"setKeyPool.size() = %u\\n\",      walletInstance->GetKeyPoolSize());\n        LogPrintf(\"mapWallet.size() = %u\\n\",       walletInstance->mapWallet.size());\n        LogPrintf(\"mapAddressBook.size() = %u\\n\",  walletInstance->mapAddressBook.size());\n    }\n\n    return walletInstance;\n}\n\nstd::atomic<bool> CWallet::fFlushScheduled(false);\n\nvoid CWallet::postInitProcess(CScheduler& scheduler)\n{\n    // Add wallet transactions that aren't already in a block to mempool\n    // Do this here as mempool requires genesis block to be loaded\n    ReacceptWalletTransactions();\n\n    // Run a thread to flush wallet periodically\n    if (!CWallet::fFlushScheduled.exchange(true)) {\n        scheduler.scheduleEvery(MaybeCompactWalletDB, 500);\n    }\n}\n\nbool CWallet::BackupWallet(const std::string& strDest)\n{\n    return dbw->Backup(strDest);\n}\n\nCKeyPool::CKeyPool()\n{\n    nTime = GetTime();\n    fInternal = false;\n}\n\nCKeyPool::CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn)\n{\n    nTime = GetTime();\n    vchPubKey = vchPubKeyIn;\n    fInternal = internalIn;\n}\n\nCWalletKey::CWalletKey(int64_t nExpires)\n{\n    nTimeCreated = (nExpires ? GetTime() : 0);\n    nTimeExpires = nExpires;\n}\n\nvoid CMerkleTx::SetMerkleBranch(const CBlockIndex* pindex, int posInBlock)\n{\n    // Update the tx's hashBlock\n    hashBlock = pindex->GetBlockHash();\n\n    // set the position of the transaction in the block\n    nIndex = posInBlock;\n}\n\nint CMerkleTx::GetDepthInMainChain(const CBlockIndex* &pindexRet) const\n{\n    if (hashUnset())\n        return 0;\n\n    AssertLockHeld(cs_main);\n\n    // Find the block it claims to be in\n    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n    if (!pindex || !chainActive.Contains(pindex))\n        return 0;\n\n    pindexRet = pindex;\n    return ((nIndex == -1) ? (-1) : 1) * (chainActive.Height() - pindex->nHeight + 1);\n}\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!IsCoinBase())\n        return 0;\n    return std::max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n}\n\n\nbool CWalletTx::AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state)\n{\n    // We must set fInMempool here - while it will be re-set to true by the\n    // entered-mempool callback, if we did not there would be a race where a\n    // user could call sendmoney in a loop and hit spurious out of funds errors\n    // because we think that the transaction they just generated's change is\n    // unavailable as we're not yet aware its in mempool.\n    bool ret = ::AcceptToMemoryPool(mempool, state, tx, nullptr /* pfMissingInputs */,\n                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nAbsurdFee);\n    fInMempool |= ret;\n    return ret;\n}\n\nstatic const std::string OUTPUT_TYPE_STRING_LEGACY = \"legacy\";\nstatic const std::string OUTPUT_TYPE_STRING_P2SH_SEGWIT = \"p2sh-segwit\";\nstatic const std::string OUTPUT_TYPE_STRING_BECH32 = \"bech32\";\n\nOutputType ParseOutputType(const std::string& type, OutputType default_type)\n{\n    if (type.empty()) {\n        return default_type;\n    } else if (type == OUTPUT_TYPE_STRING_LEGACY) {\n        return OutputType::LEGACY;\n    } else if (type == OUTPUT_TYPE_STRING_P2SH_SEGWIT) {\n        return OutputType::P2SH_SEGWIT;\n    } else if (type == OUTPUT_TYPE_STRING_BECH32) {\n        return OutputType::BECH32;\n    } else {\n        return OutputType::NONE;\n    }\n}\n\nconst std::string& FormatOutputType(OutputType type)\n{\n    switch (type) {\n    case OutputType::LEGACY: return OUTPUT_TYPE_STRING_LEGACY;\n    case OutputType::P2SH_SEGWIT: return OUTPUT_TYPE_STRING_P2SH_SEGWIT;\n    case OutputType::BECH32: return OUTPUT_TYPE_STRING_BECH32;\n    default: assert(false);\n    }\n}\n\nvoid CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n{\n    if (key.IsCompressed() && (type == OutputType::P2SH_SEGWIT || type == OutputType::BECH32)) {\n        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n        CScript witprog = GetScriptForDestination(witdest);\n        // Make sure the resulting program is solvable.\n        assert(IsSolvable(*this, witprog));\n        AddCScript(witprog);\n    }\n}\n\nvoid CWallet::LearnAllRelatedScripts(const CPubKey& key)\n{\n    // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.\n    LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n}\n\nCTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)\n{\n    switch (type) {\n    case OutputType::LEGACY: return key.GetID();\n    case OutputType::P2SH_SEGWIT:\n    case OutputType::BECH32: {\n        if (!key.IsCompressed()) return key.GetID();\n        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n        CScript witprog = GetScriptForDestination(witdest);\n        if (type == OutputType::P2SH_SEGWIT) {\n            return CScriptID(witprog);\n        } else {\n            return witdest;\n        }\n    }\n    default: assert(false);\n    }\n}\n\nstd::vector<CTxDestination> GetAllDestinationsForKey(const CPubKey& key)\n{\n    CKeyID keyid = key.GetID();\n    if (key.IsCompressed()) {\n        CTxDestination segwit = WitnessV0KeyHash(keyid);\n        CTxDestination p2sh = CScriptID(GetScriptForDestination(segwit));\n        return std::vector<CTxDestination>{std::move(keyid), std::move(p2sh), std::move(segwit)};\n    } else {\n        return std::vector<CTxDestination>{std::move(keyid)};\n    }\n}\n\nCTxDestination CWallet::AddAndGetDestinationForScript(const CScript& script, OutputType type)\n{\n    // Note that scripts over 520 bytes are not yet supported.\n    switch (type) {\n    case OutputType::LEGACY:\n        return CScriptID(script);\n    case OutputType::P2SH_SEGWIT:\n    case OutputType::BECH32: {\n        WitnessV0ScriptHash hash;\n        CSHA256().Write(script.data(), script.size()).Finalize(hash.begin());\n        CTxDestination witdest = hash;\n        CScript witprog = GetScriptForDestination(witdest);\n        // Check if the resulting program is solvable (i.e. doesn't use an uncompressed key)\n        if (!IsSolvable(*this, witprog)) return CScriptID(script);\n        // Add the redeemscript, so that P2WSH and P2SH-P2WSH outputs are recognized as ours.\n        AddCScript(witprog);\n        if (type == OutputType::BECH32) {\n            return witdest;\n        } else {\n            return CScriptID(witprog);\n        }\n    }\n    default: assert(false);\n    }\n}\n"], "fixing_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2017 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <wallet/wallet.h>\n\n#include <checkpoints.h>\n#include <chain.h>\n#include <wallet/coincontrol.h>\n#include <wallet/coinselection.h>\n#include <consensus/consensus.h>\n#include <consensus/validation.h>\n#include <fs.h>\n#include <wallet/init.h>\n#include <key.h>\n#include <key_io.h>\n#include <keystore.h>\n#include <validation.h>\n#include <net.h>\n#include <policy/fees.h>\n#include <policy/policy.h>\n#include <policy/rbf.h>\n#include <primitives/block.h>\n#include <primitives/transaction.h>\n#include <script/script.h>\n#include <scheduler.h>\n#include <timedata.h>\n#include <txmempool.h>\n#include <util.h>\n#include <utilmoneystr.h>\n#include <wallet/fees.h>\n\n#include <assert.h>\n#include <future>\n\n#include <boost/algorithm/string/replace.hpp>\n\nstd::vector<CWalletRef> vpwallets;\n/** Transaction fee set by the user */\nCFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\nunsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;\nbool bSpendZeroConfChange = DEFAULT_SPEND_ZEROCONF_CHANGE;\nbool fWalletRbf = DEFAULT_WALLET_RBF;\nbool g_wallet_allow_fallback_fee = true; //<! will be defined via chainparams\n\nconst uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n\n/**\n * Fees smaller than this (in satoshi) are considered zero fee (for transaction creation)\n * Override with -mintxfee\n */\nCFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE);\n/**\n * If fee estimation does not have enough data to provide estimates, use this fee instead.\n * Has no effect if not using fee estimation\n * Override with -fallbackfee\n */\nCFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);\n\nCFeeRate CWallet::m_discard_rate = CFeeRate(DEFAULT_DISCARD_FEE);\n\nconst uint256 CMerkleTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n\n/** @defgroup mapWallet\n *\n * @{\n */\n\nstd::string COutput::ToString() const\n{\n    return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n}\n\nclass CAffectedKeysVisitor : public boost::static_visitor<void> {\nprivate:\n    const CKeyStore &keystore;\n    std::vector<CKeyID> &vKeys;\n\npublic:\n    CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}\n\n    void Process(const CScript &script) {\n        txnouttype type;\n        std::vector<CTxDestination> vDest;\n        int nRequired;\n        if (ExtractDestinations(script, type, vDest, nRequired)) {\n            for (const CTxDestination &dest : vDest)\n                boost::apply_visitor(*this, dest);\n        }\n    }\n\n    void operator()(const CKeyID &keyId) {\n        if (keystore.HaveKey(keyId))\n            vKeys.push_back(keyId);\n    }\n\n    void operator()(const CScriptID &scriptId) {\n        CScript script;\n        if (keystore.GetCScript(scriptId, script))\n            Process(script);\n    }\n\n    void operator()(const WitnessV0ScriptHash& scriptID)\n    {\n        CScriptID id;\n        CRIPEMD160().Write(scriptID.begin(), 32).Finalize(id.begin());\n        CScript script;\n        if (keystore.GetCScript(id, script)) {\n            Process(script);\n        }\n    }\n\n    void operator()(const WitnessV0KeyHash& keyid)\n    {\n        CKeyID id(keyid);\n        if (keystore.HaveKey(id)) {\n            vKeys.push_back(id);\n        }\n    }\n\n    template<typename X>\n    void operator()(const X &none) {}\n};\n\nconst CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n{\n    LOCK(cs_wallet);\n    std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);\n    if (it == mapWallet.end())\n        return nullptr;\n    return &(it->second);\n}\n\nCPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal)\n{\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n\n    CKey secret;\n\n    // Create new metadata\n    int64_t nCreationTime = GetTime();\n    CKeyMetadata metadata(nCreationTime);\n\n    // use HD key derivation if HD was enabled during wallet creation\n    if (IsHDEnabled()) {\n        DeriveNewChildKey(walletdb, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n    } else {\n        secret.MakeNewKey(fCompressed);\n    }\n\n    // Compressed public keys were introduced in version 0.6.0\n    if (fCompressed) {\n        SetMinVersion(FEATURE_COMPRPUBKEY);\n    }\n\n    CPubKey pubkey = secret.GetPubKey();\n    assert(secret.VerifyPubKey(pubkey));\n\n    mapKeyMetadata[pubkey.GetID()] = metadata;\n    UpdateTimeFirstKey(nCreationTime);\n\n    if (!AddKeyPubKeyWithDB(walletdb, secret, pubkey)) {\n        throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n    }\n    return pubkey;\n}\n\nvoid CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal)\n{\n    // for now we use a fixed keypath scheme of m/0'/0'/k\n    CKey key;                      //master key seed (256bit)\n    CExtKey masterKey;             //hd master key\n    CExtKey accountKey;            //key at m/0'\n    CExtKey chainChildKey;         //key at m/0'/0' (external) or m/0'/1' (internal)\n    CExtKey childKey;              //key at m/0'/0'/<n>'\n\n    // try to get the master key\n    if (!GetKey(hdChain.masterKeyID, key))\n        throw std::runtime_error(std::string(__func__) + \": Master key not found\");\n\n    masterKey.SetMaster(key.begin(), key.size());\n\n    // derive m/0'\n    // use hardened derivation (child keys >= 0x80000000 are hardened after bip32)\n    masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);\n\n    // derive m/0'/0' (external chain) OR m/0'/1' (internal chain)\n    assert(internal ? CanSupportFeature(FEATURE_HD_SPLIT) : true);\n    accountKey.Derive(chainChildKey, BIP32_HARDENED_KEY_LIMIT+(internal ? 1 : 0));\n\n    // derive child key at next index, skip keys already known to the wallet\n    do {\n        // always derive hardened keys\n        // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range\n        // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649\n        if (internal) {\n            chainChildKey.Derive(childKey, hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n            metadata.hdKeypath = \"m/0'/1'/\" + std::to_string(hdChain.nInternalChainCounter) + \"'\";\n            hdChain.nInternalChainCounter++;\n        }\n        else {\n            chainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n            metadata.hdKeypath = \"m/0'/0'/\" + std::to_string(hdChain.nExternalChainCounter) + \"'\";\n            hdChain.nExternalChainCounter++;\n        }\n    } while (HaveKey(childKey.key.GetPubKey().GetID()));\n    secret = childKey.key;\n    metadata.hdMasterKeyID = hdChain.masterKeyID;\n    // update the chain model in the database\n    if (!walletdb.WriteHDChain(hdChain))\n        throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n}\n\nbool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const CPubKey &pubkey)\n{\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n\n    // CCryptoKeyStore has no concept of wallet databases, but calls AddCryptedKey\n    // which is overridden below.  To avoid flushes, the database handle is\n    // tunneled through to it.\n    bool needsDB = !pwalletdbEncryption;\n    if (needsDB) {\n        pwalletdbEncryption = &walletdb;\n    }\n    if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) {\n        if (needsDB) pwalletdbEncryption = nullptr;\n        return false;\n    }\n    if (needsDB) pwalletdbEncryption = nullptr;\n\n    // check if we need to remove from watch-only\n    CScript script;\n    script = GetScriptForDestination(pubkey.GetID());\n    if (HaveWatchOnly(script)) {\n        RemoveWatchOnly(script);\n    }\n    script = GetScriptForRawPubKey(pubkey);\n    if (HaveWatchOnly(script)) {\n        RemoveWatchOnly(script);\n    }\n\n    if (!IsCrypted()) {\n        return walletdb.WriteKey(pubkey,\n                                                 secret.GetPrivKey(),\n                                                 mapKeyMetadata[pubkey.GetID()]);\n    }\n    return true;\n}\n\nbool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n{\n    CWalletDB walletdb(*dbw);\n    return CWallet::AddKeyPubKeyWithDB(walletdb, secret, pubkey);\n}\n\nbool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                            const std::vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey,\n                                                        vchCryptedSecret,\n                                                        mapKeyMetadata[vchPubKey.GetID()]);\n        else\n            return CWalletDB(*dbw).WriteCryptedKey(vchPubKey,\n                                                            vchCryptedSecret,\n                                                            mapKeyMetadata[vchPubKey.GetID()]);\n    }\n}\n\nbool CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata &meta)\n{\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n    UpdateTimeFirstKey(meta.nCreateTime);\n    mapKeyMetadata[keyID] = meta;\n    return true;\n}\n\nbool CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata &meta)\n{\n    AssertLockHeld(cs_wallet); // m_script_metadata\n    UpdateTimeFirstKey(meta.nCreateTime);\n    m_script_metadata[script_id] = meta;\n    return true;\n}\n\nbool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n{\n    return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n}\n\n/**\n * Update wallet first key creation time. This should be called whenever keys\n * are added to the wallet, with the oldest key creation time.\n */\nvoid CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n{\n    AssertLockHeld(cs_wallet);\n    if (nCreateTime <= 1) {\n        // Cannot determine birthday information, so set the wallet birthday to\n        // the beginning of time.\n        nTimeFirstKey = 1;\n    } else if (!nTimeFirstKey || nCreateTime < nTimeFirstKey) {\n        nTimeFirstKey = nCreateTime;\n    }\n}\n\nbool CWallet::AddCScript(const CScript& redeemScript)\n{\n    if (!CCryptoKeyStore::AddCScript(redeemScript))\n        return false;\n    return CWalletDB(*dbw).WriteCScript(Hash160(redeemScript), redeemScript);\n}\n\nbool CWallet::LoadCScript(const CScript& redeemScript)\n{\n    /* A sanity check was added in pull #3843 to avoid adding redeemScripts\n     * that never can be redeemed. However, old wallets may still contain\n     * these. Do not add them to the wallet and warn. */\n    if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n    {\n        std::string strAddr = EncodeDestination(CScriptID(redeemScript));\n        LogPrintf(\"%s: Warning: This wallet contains a redeemScript of size %i which exceeds maximum size %i thus can never be redeemed. Do not use address %s.\\n\",\n            __func__, redeemScript.size(), MAX_SCRIPT_ELEMENT_SIZE, strAddr);\n        return true;\n    }\n\n    return CCryptoKeyStore::AddCScript(redeemScript);\n}\n\nbool CWallet::AddWatchOnly(const CScript& dest)\n{\n    if (!CCryptoKeyStore::AddWatchOnly(dest))\n        return false;\n    const CKeyMetadata& meta = m_script_metadata[CScriptID(dest)];\n    UpdateTimeFirstKey(meta.nCreateTime);\n    NotifyWatchonlyChanged(true);\n    return CWalletDB(*dbw).WriteWatchOnly(dest, meta);\n}\n\nbool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n{\n    m_script_metadata[CScriptID(dest)].nCreateTime = nCreateTime;\n    return AddWatchOnly(dest);\n}\n\nbool CWallet::RemoveWatchOnly(const CScript &dest)\n{\n    AssertLockHeld(cs_wallet);\n    if (!CCryptoKeyStore::RemoveWatchOnly(dest))\n        return false;\n    if (!HaveWatchOnly())\n        NotifyWatchonlyChanged(false);\n    if (!CWalletDB(*dbw).EraseWatchOnly(dest))\n        return false;\n\n    return true;\n}\n\nbool CWallet::LoadWatchOnly(const CScript &dest)\n{\n    return CCryptoKeyStore::AddWatchOnly(dest);\n}\n\nbool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    CCrypter crypter;\n    CKeyingMaterial _vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        for (const MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, _vMasterKey))\n                continue; // try another master key\n            if (CCryptoKeyStore::Unlock(_vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n{\n    bool fWasLocked = IsLocked();\n\n    {\n        LOCK(cs_wallet);\n        Lock();\n\n        CCrypter crypter;\n        CKeyingMaterial _vMasterKey;\n        for (MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, _vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(_vMasterKey))\n            {\n                int64_t nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = static_cast<unsigned int>(pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime))));\n\n                nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + static_cast<unsigned int>(pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime)))) / 2;\n\n                if (pMasterKey.second.nDeriveIterations < 25000)\n                    pMasterKey.second.nDeriveIterations = 25000;\n\n                LogPrintf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n\n                if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                    return false;\n                if (!crypter.Encrypt(_vMasterKey, pMasterKey.second.vchCryptedKey))\n                    return false;\n                CWalletDB(*dbw).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                if (fWasLocked)\n                    Lock();\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid CWallet::SetBestChain(const CBlockLocator& loc)\n{\n    CWalletDB walletdb(*dbw);\n    walletdb.WriteBestBlock(loc);\n}\n\nbool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n{\n    LOCK(cs_wallet); // nWalletVersion\n    if (nWalletVersion >= nVersion)\n        return true;\n\n    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n    if (fExplicit && nVersion > nWalletMaxVersion)\n            nVersion = FEATURE_LATEST;\n\n    nWalletVersion = nVersion;\n\n    if (nVersion > nWalletMaxVersion)\n        nWalletMaxVersion = nVersion;\n\n    {\n        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(*dbw);\n        if (nWalletVersion > 40000)\n            pwalletdb->WriteMinVersion(nWalletVersion);\n        if (!pwalletdbIn)\n            delete pwalletdb;\n    }\n\n    return true;\n}\n\nbool CWallet::SetMaxVersion(int nVersion)\n{\n    LOCK(cs_wallet); // nWalletVersion, nWalletMaxVersion\n    // cannot downgrade below current version\n    if (nWalletVersion > nVersion)\n        return false;\n\n    nWalletMaxVersion = nVersion;\n\n    return true;\n}\n\nstd::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n{\n    std::set<uint256> result;\n    AssertLockHeld(cs_wallet);\n\n    std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(txid);\n    if (it == mapWallet.end())\n        return result;\n    const CWalletTx& wtx = it->second;\n\n    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n\n    for (const CTxIn& txin : wtx.tx->vin)\n    {\n        if (mapTxSpends.count(txin.prevout) <= 1)\n            continue;  // No conflict if zero or one spends\n        range = mapTxSpends.equal_range(txin.prevout);\n        for (TxSpends::const_iterator _it = range.first; _it != range.second; ++_it)\n            result.insert(_it->second);\n    }\n    return result;\n}\n\nbool CWallet::HasWalletSpend(const uint256& txid) const\n{\n    AssertLockHeld(cs_wallet);\n    auto iter = mapTxSpends.lower_bound(COutPoint(txid, 0));\n    return (iter != mapTxSpends.end() && iter->first.hash == txid);\n}\n\nvoid CWallet::Flush(bool shutdown)\n{\n    dbw->Flush(shutdown);\n}\n\nvoid CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n{\n    // We want all the wallet transactions in range to have the same metadata as\n    // the oldest (smallest nOrderPos).\n    // So: find smallest nOrderPos:\n\n    int nMinOrderPos = std::numeric_limits<int>::max();\n    const CWalletTx* copyFrom = nullptr;\n    for (TxSpends::iterator it = range.first; it != range.second; ++it) {\n        const CWalletTx* wtx = &mapWallet.at(it->second);\n        if (wtx->nOrderPos < nMinOrderPos) {\n            nMinOrderPos = wtx->nOrderPos;;\n            copyFrom = wtx;\n        }\n    }\n\n    assert(copyFrom);\n\n    // Now copy data from copyFrom to rest:\n    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n    {\n        const uint256& hash = it->second;\n        CWalletTx* copyTo = &mapWallet.at(hash);\n        if (copyFrom == copyTo) continue;\n        assert(copyFrom && \"Oldest wallet transaction in range assumed to have been found.\");\n        if (!copyFrom->IsEquivalentTo(*copyTo)) continue;\n        copyTo->mapValue = copyFrom->mapValue;\n        copyTo->vOrderForm = copyFrom->vOrderForm;\n        // fTimeReceivedIsTxTime not copied on purpose\n        // nTimeReceived not copied on purpose\n        copyTo->nTimeSmart = copyFrom->nTimeSmart;\n        copyTo->fFromMe = copyFrom->fFromMe;\n        copyTo->strFromAccount = copyFrom->strFromAccount;\n        // nOrderPos not copied on purpose\n        // cached members not copied on purpose\n    }\n}\n\n/**\n * Outpoint is spent if any non-conflicted transaction\n * spends it:\n */\nbool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n{\n    const COutPoint outpoint(hash, n);\n    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n    range = mapTxSpends.equal_range(outpoint);\n\n    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n    {\n        const uint256& wtxid = it->second;\n        std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);\n        if (mit != mapWallet.end()) {\n            int depth = mit->second.GetDepthInMainChain();\n            if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))\n                return true; // Spent\n        }\n    }\n    return false;\n}\n\nvoid CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n{\n    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n\n    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n    range = mapTxSpends.equal_range(outpoint);\n    SyncMetaData(range);\n}\n\n\nvoid CWallet::AddToSpends(const uint256& wtxid)\n{\n    auto it = mapWallet.find(wtxid);\n    assert(it != mapWallet.end());\n    CWalletTx& thisTx = it->second;\n    if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n        return;\n\n    for (const CTxIn& txin : thisTx.tx->vin)\n        AddToSpends(txin.prevout, wtxid);\n}\n\nbool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n{\n    if (IsCrypted())\n        return false;\n\n    CKeyingMaterial _vMasterKey;\n\n    _vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n    GetStrongRandBytes(&_vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n\n    CMasterKey kMasterKey;\n\n    kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n    GetStrongRandBytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n\n    CCrypter crypter;\n    int64_t nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = static_cast<unsigned int>(2500000 / ((double)(GetTimeMillis() - nStartTime)));\n\n    nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + static_cast<unsigned int>(kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime)))) / 2;\n\n    if (kMasterKey.nDeriveIterations < 25000)\n        kMasterKey.nDeriveIterations = 25000;\n\n    LogPrintf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n\n    if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n        return false;\n    if (!crypter.Encrypt(_vMasterKey, kMasterKey.vchCryptedKey))\n        return false;\n\n    {\n        LOCK(cs_wallet);\n        mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n        assert(!pwalletdbEncryption);\n        pwalletdbEncryption = new CWalletDB(*dbw);\n        if (!pwalletdbEncryption->TxnBegin()) {\n            delete pwalletdbEncryption;\n            pwalletdbEncryption = nullptr;\n            return false;\n        }\n        pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n\n        if (!EncryptKeys(_vMasterKey))\n        {\n            pwalletdbEncryption->TxnAbort();\n            delete pwalletdbEncryption;\n            // We now probably have half of our keys encrypted in memory, and half not...\n            // die and let the user reload the unencrypted wallet.\n            assert(false);\n        }\n\n        // Encryption was introduced in version 0.4.0\n        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n\n        if (!pwalletdbEncryption->TxnCommit()) {\n            delete pwalletdbEncryption;\n            // We now have keys encrypted in memory, but not on disk...\n            // die to avoid confusion and let the user reload the unencrypted wallet.\n            assert(false);\n        }\n\n        delete pwalletdbEncryption;\n        pwalletdbEncryption = nullptr;\n\n        Lock();\n        Unlock(strWalletPassphrase);\n\n        // if we are using HD, replace the HD master key (seed) with a new one\n        if (IsHDEnabled()) {\n            if (!SetHDMasterKey(GenerateNewHDMasterKey())) {\n                return false;\n            }\n        }\n\n        NewKeyPool();\n        Lock();\n\n        // Need to completely rewrite the wallet file; if we don't, bdb might keep\n        // bits of the unencrypted private key in slack space in the database file.\n        dbw->Rewrite();\n\n    }\n    NotifyStatusChanged(this);\n\n    return true;\n}\n\nDBErrors CWallet::ReorderTransactions()\n{\n    LOCK(cs_wallet);\n    CWalletDB walletdb(*dbw);\n\n    // Old wallets didn't have any defined order for transactions\n    // Probably a bad idea to change the output of this\n\n    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n    typedef std::multimap<int64_t, TxPair > TxItems;\n    TxItems txByTime;\n\n    for (auto& entry : mapWallet)\n    {\n        CWalletTx* wtx = &entry.second;\n        txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, nullptr)));\n    }\n    std::list<CAccountingEntry> acentries;\n    walletdb.ListAccountCreditDebit(\"\", acentries);\n    for (CAccountingEntry& entry : acentries)\n    {\n        txByTime.insert(std::make_pair(entry.nTime, TxPair(nullptr, &entry)));\n    }\n\n    nOrderPosNext = 0;\n    std::vector<int64_t> nOrderPosOffsets;\n    for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n    {\n        CWalletTx *const pwtx = (*it).second.first;\n        CAccountingEntry *const pacentry = (*it).second.second;\n        int64_t& nOrderPos = (pwtx != nullptr) ? pwtx->nOrderPos : pacentry->nOrderPos;\n\n        if (nOrderPos == -1)\n        {\n            nOrderPos = nOrderPosNext++;\n            nOrderPosOffsets.push_back(nOrderPos);\n\n            if (pwtx)\n            {\n                if (!walletdb.WriteTx(*pwtx))\n                    return DB_LOAD_FAIL;\n            }\n            else\n                if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n        else\n        {\n            int64_t nOrderPosOff = 0;\n            for (const int64_t& nOffsetStart : nOrderPosOffsets)\n            {\n                if (nOrderPos >= nOffsetStart)\n                    ++nOrderPosOff;\n            }\n            nOrderPos += nOrderPosOff;\n            nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n\n            if (!nOrderPosOff)\n                continue;\n\n            // Since we're changing the order, write it back\n            if (pwtx)\n            {\n                if (!walletdb.WriteTx(*pwtx))\n                    return DB_LOAD_FAIL;\n            }\n            else\n                if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n    }\n    walletdb.WriteOrderPosNext(nOrderPosNext);\n\n    return DB_LOAD_OK;\n}\n\nint64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n{\n    AssertLockHeld(cs_wallet); // nOrderPosNext\n    int64_t nRet = nOrderPosNext++;\n    if (pwalletdb) {\n        pwalletdb->WriteOrderPosNext(nOrderPosNext);\n    } else {\n        CWalletDB(*dbw).WriteOrderPosNext(nOrderPosNext);\n    }\n    return nRet;\n}\n\nbool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment)\n{\n    CWalletDB walletdb(*dbw);\n    if (!walletdb.TxnBegin())\n        return false;\n\n    int64_t nNow = GetAdjustedTime();\n\n    // Debit\n    CAccountingEntry debit;\n    debit.nOrderPos = IncOrderPosNext(&walletdb);\n    debit.strAccount = strFrom;\n    debit.nCreditDebit = -nAmount;\n    debit.nTime = nNow;\n    debit.strOtherAccount = strTo;\n    debit.strComment = strComment;\n    AddAccountingEntry(debit, &walletdb);\n\n    // Credit\n    CAccountingEntry credit;\n    credit.nOrderPos = IncOrderPosNext(&walletdb);\n    credit.strAccount = strTo;\n    credit.nCreditDebit = nAmount;\n    credit.nTime = nNow;\n    credit.strOtherAccount = strFrom;\n    credit.strComment = strComment;\n    AddAccountingEntry(credit, &walletdb);\n\n    if (!walletdb.TxnCommit())\n        return false;\n\n    return true;\n}\n\nbool CWallet::GetAccountDestination(CTxDestination &dest, std::string strAccount, bool bForceNew)\n{\n    CWalletDB walletdb(*dbw);\n\n    CAccount account;\n    walletdb.ReadAccount(strAccount, account);\n\n    if (!bForceNew) {\n        if (!account.vchPubKey.IsValid())\n            bForceNew = true;\n        else {\n            // Check if the current key has been used (TODO: check other addresses with the same key)\n            CScript scriptPubKey = GetScriptForDestination(GetDestinationForKey(account.vchPubKey, m_default_address_type));\n            for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n                 it != mapWallet.end() && account.vchPubKey.IsValid();\n                 ++it)\n                for (const CTxOut& txout : (*it).second.tx->vout)\n                    if (txout.scriptPubKey == scriptPubKey) {\n                        bForceNew = true;\n                        break;\n                    }\n        }\n    }\n\n    // Generate a new key\n    if (bForceNew) {\n        if (!GetKeyFromPool(account.vchPubKey, false))\n            return false;\n\n        LearnRelatedScripts(account.vchPubKey, m_default_address_type);\n        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n        SetAddressBook(dest, strAccount, \"receive\");\n        walletdb.WriteAccount(strAccount, account);\n    } else {\n        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n    }\n\n    return true;\n}\n\nvoid CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n            item.second.MarkDirty();\n    }\n}\n\nbool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n{\n    LOCK(cs_wallet);\n\n    auto mi = mapWallet.find(originalHash);\n\n    // There is a bug if MarkReplaced is not called on an existing wallet transaction.\n    assert(mi != mapWallet.end());\n\n    CWalletTx& wtx = (*mi).second;\n\n    // Ensure for now that we're not overwriting data\n    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n\n    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n\n    CWalletDB walletdb(*dbw, \"r+\");\n\n    bool success = true;\n    if (!walletdb.WriteTx(wtx)) {\n        LogPrintf(\"%s: Updating walletdb tx %s failed\", __func__, wtx.GetHash().ToString());\n        success = false;\n    }\n\n    NotifyTransactionChanged(this, originalHash, CT_UPDATED);\n\n    return success;\n}\n\nbool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n{\n    LOCK(cs_wallet);\n\n    CWalletDB walletdb(*dbw, \"r+\", fFlushOnClose);\n\n    uint256 hash = wtxIn.GetHash();\n\n    // Inserts only if not already there, returns tx inserted or tx found\n    std::pair<std::map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(std::make_pair(hash, wtxIn));\n    CWalletTx& wtx = (*ret.first).second;\n    wtx.BindWallet(this);\n    bool fInsertedNew = ret.second;\n    if (fInsertedNew)\n    {\n        wtx.nTimeReceived = GetAdjustedTime();\n        wtx.nOrderPos = IncOrderPosNext(&walletdb);\n        wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n        wtx.nTimeSmart = ComputeTimeSmart(wtx);\n        AddToSpends(hash);\n    }\n\n    bool fUpdated = false;\n    if (!fInsertedNew)\n    {\n        // Merge\n        if (!wtxIn.hashUnset() && wtxIn.hashBlock != wtx.hashBlock)\n        {\n            wtx.hashBlock = wtxIn.hashBlock;\n            fUpdated = true;\n        }\n        // If no longer abandoned, update\n        if (wtxIn.hashBlock.IsNull() && wtx.isAbandoned())\n        {\n            wtx.hashBlock = wtxIn.hashBlock;\n            fUpdated = true;\n        }\n        if (wtxIn.nIndex != -1 && (wtxIn.nIndex != wtx.nIndex))\n        {\n            wtx.nIndex = wtxIn.nIndex;\n            fUpdated = true;\n        }\n        if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n        {\n            wtx.fFromMe = wtxIn.fFromMe;\n            fUpdated = true;\n        }\n        // If we have a witness-stripped version of this transaction, and we\n        // see a new version with a witness, then we must be upgrading a pre-segwit\n        // wallet.  Store the new version of the transaction with the witness,\n        // as the stripped-version must be invalid.\n        // TODO: Store all versions of the transaction, instead of just one.\n        if (wtxIn.tx->HasWitness() && !wtx.tx->HasWitness()) {\n            wtx.SetTx(wtxIn.tx);\n            fUpdated = true;\n        }\n    }\n\n    //// debug print\n    LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n    // Write to disk\n    if (fInsertedNew || fUpdated)\n        if (!walletdb.WriteTx(wtx))\n            return false;\n\n    // Break debit/credit balance caches:\n    wtx.MarkDirty();\n\n    // Notify UI of new or updated transaction\n    NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n\n    // notify an external script when a wallet transaction comes in or is updated\n    std::string strCmd = gArgs.GetArg(\"-walletnotify\", \"\");\n\n    if (!strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n        std::thread t(runCommand, strCmd);\n        t.detach(); // thread runs free\n    }\n\n    return true;\n}\n\nbool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    CWalletTx& wtx = mapWallet.emplace(hash, wtxIn).first->second;\n    wtx.BindWallet(this);\n    wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n    AddToSpends(hash);\n    for (const CTxIn& txin : wtx.tx->vin) {\n        auto it = mapWallet.find(txin.prevout.hash);\n        if (it != mapWallet.end()) {\n            CWalletTx& prevtx = it->second;\n            if (prevtx.nIndex == -1 && !prevtx.hashUnset()) {\n                MarkConflicted(prevtx.hashBlock, wtx.GetHash());\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Add a transaction to the wallet, or update it.  pIndex and posInBlock should\n * be set when the transaction was known to be included in a block.  When\n * pIndex == nullptr, then wallet state is not updated in AddToWallet, but\n * notifications happen and cached balances are marked dirty.\n *\n * If fUpdate is true, existing transactions will be updated.\n * TODO: One exception to this is that the abandoned state is cleared under the\n * assumption that any further notification of a transaction that was considered\n * abandoned is an indication that it is not safe to be considered abandoned.\n * Abandoned state should probably be more carefully tracked via different\n * posInBlock signals or by checking mempool presence when necessary.\n */\nbool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n{\n    const CTransaction& tx = *ptx;\n    {\n        AssertLockHeld(cs_wallet);\n\n        if (pIndex != nullptr) {\n            for (const CTxIn& txin : tx.vin) {\n                std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                while (range.first != range.second) {\n                    if (range.first->second != tx.GetHash()) {\n                        LogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), pIndex->GetBlockHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n                        MarkConflicted(pIndex->GetBlockHash(), range.first->second);\n                    }\n                    range.first++;\n                }\n            }\n        }\n\n        bool fExisted = mapWallet.count(tx.GetHash()) != 0;\n        if (fExisted && !fUpdate) return false;\n        if (fExisted || IsMine(tx) || IsFromMe(tx))\n        {\n            /* Check if any keys in the wallet keypool that were supposed to be unused\n             * have appeared in a new transaction. If so, remove those keys from the keypool.\n             * This can happen when restoring an old wallet backup that does not contain\n             * the mostly recently created transactions from newer versions of the wallet.\n             */\n\n            // loop though all outputs\n            for (const CTxOut& txout: tx.vout) {\n                // extract addresses and check if they match with an unused keypool key\n                std::vector<CKeyID> vAffected;\n                CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n                for (const CKeyID &keyid : vAffected) {\n                    std::map<CKeyID, int64_t>::const_iterator mi = m_pool_key_to_index.find(keyid);\n                    if (mi != m_pool_key_to_index.end()) {\n                        LogPrintf(\"%s: Detected a used keypool key, mark all keypool key up to this key as used\\n\", __func__);\n                        MarkReserveKeysAsUsed(mi->second);\n\n                        if (!TopUpKeyPool()) {\n                            LogPrintf(\"%s: Topping up keypool failed (locked wallet)\\n\", __func__);\n                        }\n                    }\n                }\n            }\n\n            CWalletTx wtx(this, ptx);\n\n            // Get merkle branch if transaction was found in a block\n            if (pIndex != nullptr)\n                wtx.SetMerkleBranch(pIndex, posInBlock);\n\n            return AddToWallet(wtx, false);\n        }\n    }\n    return false;\n}\n\nbool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n{\n    LOCK2(cs_main, cs_wallet);\n    const CWalletTx* wtx = GetWalletTx(hashTx);\n    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() == 0 && !wtx->InMempool();\n}\n\nbool CWallet::AbandonTransaction(const uint256& hashTx)\n{\n    LOCK2(cs_main, cs_wallet);\n\n    CWalletDB walletdb(*dbw, \"r+\");\n\n    std::set<uint256> todo;\n    std::set<uint256> done;\n\n    // Can't mark abandoned if confirmed or in mempool\n    auto it = mapWallet.find(hashTx);\n    assert(it != mapWallet.end());\n    CWalletTx& origtx = it->second;\n    if (origtx.GetDepthInMainChain() != 0 || origtx.InMempool()) {\n        return false;\n    }\n\n    todo.insert(hashTx);\n\n    while (!todo.empty()) {\n        uint256 now = *todo.begin();\n        todo.erase(now);\n        done.insert(now);\n        auto it = mapWallet.find(now);\n        assert(it != mapWallet.end());\n        CWalletTx& wtx = it->second;\n        int currentconfirm = wtx.GetDepthInMainChain();\n        // If the orig tx was not in block, none of its spends can be\n        assert(currentconfirm <= 0);\n        // if (currentconfirm < 0) {Tx and spends are already conflicted, no need to abandon}\n        if (currentconfirm == 0 && !wtx.isAbandoned()) {\n            // If the orig tx was not in block/mempool, none of its spends can be in mempool\n            assert(!wtx.InMempool());\n            wtx.nIndex = -1;\n            wtx.setAbandoned();\n            wtx.MarkDirty();\n            walletdb.WriteTx(wtx);\n            NotifyTransactionChanged(this, wtx.GetHash(), CT_UPDATED);\n            // Iterate over all its outputs, and mark transactions in the wallet that spend them abandoned too\n            TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(hashTx, 0));\n            while (iter != mapTxSpends.end() && iter->first.hash == now) {\n                if (!done.count(iter->second)) {\n                    todo.insert(iter->second);\n                }\n                iter++;\n            }\n            // If a transaction changes 'conflicted' state, that changes the balance\n            // available of the outputs it spends. So force those to be recomputed\n            for (const CTxIn& txin : wtx.tx->vin)\n            {\n                auto it = mapWallet.find(txin.prevout.hash);\n                if (it != mapWallet.end()) {\n                    it->second.MarkDirty();\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nvoid CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n{\n    LOCK2(cs_main, cs_wallet);\n\n    int conflictconfirms = 0;\n    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n    if (pindex && chainActive.Contains(pindex)) {\n        conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n    }\n    // If number of conflict confirms cannot be determined, this means\n    // that the block is still unknown or not yet part of the main chain,\n    // for example when loading the wallet during a reindex. Do nothing in that\n    // case.\n    if (conflictconfirms >= 0)\n        return;\n\n    // Do not flush the wallet here for performance reasons\n    CWalletDB walletdb(*dbw, \"r+\", false);\n\n    std::set<uint256> todo;\n    std::set<uint256> done;\n\n    todo.insert(hashTx);\n\n    while (!todo.empty()) {\n        uint256 now = *todo.begin();\n        todo.erase(now);\n        done.insert(now);\n        auto it = mapWallet.find(now);\n        assert(it != mapWallet.end());\n        CWalletTx& wtx = it->second;\n        int currentconfirm = wtx.GetDepthInMainChain();\n        if (conflictconfirms < currentconfirm) {\n            // Block is 'more conflicted' than current confirm; update.\n            // Mark transaction as conflicted with this block.\n            wtx.nIndex = -1;\n            wtx.hashBlock = hashBlock;\n            wtx.MarkDirty();\n            walletdb.WriteTx(wtx);\n            // Iterate over all its outputs, and mark transactions in the wallet that spend them conflicted too\n            TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(now, 0));\n            while (iter != mapTxSpends.end() && iter->first.hash == now) {\n                 if (!done.count(iter->second)) {\n                     todo.insert(iter->second);\n                 }\n                 iter++;\n            }\n            // If a transaction changes 'conflicted' state, that changes the balance\n            // available of the outputs it spends. So force those to be recomputed\n            for (const CTxIn& txin : wtx.tx->vin) {\n                auto it = mapWallet.find(txin.prevout.hash);\n                if (it != mapWallet.end()) {\n                    it->second.MarkDirty();\n                }\n            }\n        }\n    }\n}\n\nvoid CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pindex, int posInBlock) {\n    const CTransaction& tx = *ptx;\n\n    if (!AddToWalletIfInvolvingMe(ptx, pindex, posInBlock, true))\n        return; // Not one of ours\n\n    // If a transaction changes 'conflicted' state, that changes the balance\n    // available of the outputs it spends. So force those to be\n    // recomputed, also:\n    for (const CTxIn& txin : tx.vin) {\n        auto it = mapWallet.find(txin.prevout.hash);\n        if (it != mapWallet.end()) {\n            it->second.MarkDirty();\n        }\n    }\n}\n\nvoid CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n    LOCK2(cs_main, cs_wallet);\n    SyncTransaction(ptx);\n\n    auto it = mapWallet.find(ptx->GetHash());\n    if (it != mapWallet.end()) {\n        it->second.fInMempool = true;\n    }\n}\n\nvoid CWallet::TransactionRemovedFromMempool(const CTransactionRef &ptx) {\n    LOCK(cs_wallet);\n    auto it = mapWallet.find(ptx->GetHash());\n    if (it != mapWallet.end()) {\n        it->second.fInMempool = false;\n    }\n}\n\nvoid CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n    LOCK2(cs_main, cs_wallet);\n    // TODO: Temporarily ensure that mempool removals are notified before\n    // connected transactions.  This shouldn't matter, but the abandoned\n    // state of transactions in our wallet is currently cleared when we\n    // receive another notification and there is a race condition where\n    // notification of a connected conflict might cause an outside process\n    // to abandon a transaction and then have it inadvertently cleared by\n    // the notification that the conflicted transaction was evicted.\n\n    for (const CTransactionRef& ptx : vtxConflicted) {\n        SyncTransaction(ptx);\n        TransactionRemovedFromMempool(ptx);\n    }\n    for (size_t i = 0; i < pblock->vtx.size(); i++) {\n        SyncTransaction(pblock->vtx[i], pindex, i);\n        TransactionRemovedFromMempool(pblock->vtx[i]);\n    }\n\n    m_last_block_processed = pindex;\n}\n\nvoid CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n    LOCK2(cs_main, cs_wallet);\n\n    for (const CTransactionRef& ptx : pblock->vtx) {\n        SyncTransaction(ptx);\n    }\n}\n\n\n\nvoid CWallet::BlockUntilSyncedToCurrentChain() {\n    AssertLockNotHeld(cs_main);\n    AssertLockNotHeld(cs_wallet);\n\n    {\n        // Skip the queue-draining stuff if we know we're caught up with\n        // chainActive.Tip()...\n        // We could also take cs_wallet here, and call m_last_block_processed\n        // protected by cs_wallet instead of cs_main, but as long as we need\n        // cs_main here anyway, its easier to just call it cs_main-protected.\n        LOCK(cs_main);\n        const CBlockIndex* initialChainTip = chainActive.Tip();\n\n        if (m_last_block_processed->GetAncestor(initialChainTip->nHeight) == initialChainTip) {\n            return;\n        }\n    }\n\n    // ...otherwise put a callback in the validation interface queue and wait\n    // for the queue to drain enough to execute it (indicating we are caught up\n    // at least with the time we entered this function).\n    SyncWithValidationInterfaceQueue();\n}\n\n\nisminetype CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.tx->vout.size())\n                return IsMine(prev.tx->vout[txin.prevout.n]);\n        }\n    }\n    return ISMINE_NO;\n}\n\n// Note that this function doesn't distinguish between a 0-valued input,\n// and a not-\"is mine\" (according to the filter) input.\nCAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n{\n    {\n        LOCK(cs_wallet);\n        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.tx->vout.size())\n                if (IsMine(prev.tx->vout[txin.prevout.n]) & filter)\n                    return prev.tx->vout[txin.prevout.n].nValue;\n        }\n    }\n    return 0;\n}\n\nisminetype CWallet::IsMine(const CTxOut& txout) const\n{\n    return ::IsMine(*this, txout.scriptPubKey);\n}\n\nCAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n{\n    if (!MoneyRange(txout.nValue))\n        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n}\n\nbool CWallet::IsChange(const CTxOut& txout) const\n{\n    // TODO: fix handling of 'change' outputs. The assumption is that any\n    // payment to a script that is ours, but is not in the address book\n    // is change. That assumption is likely to break when we implement multisignature\n    // wallets that return change back into a multi-signature-protected address;\n    // a better way of identifying which outputs are 'the send' and which are\n    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n    // which output, if any, was change).\n    if (::IsMine(*this, txout.scriptPubKey))\n    {\n        CTxDestination address;\n        if (!ExtractDestination(txout.scriptPubKey, address))\n            return true;\n\n        LOCK(cs_wallet);\n        if (!mapAddressBook.count(address))\n            return true;\n    }\n    return false;\n}\n\nCAmount CWallet::GetChange(const CTxOut& txout) const\n{\n    if (!MoneyRange(txout.nValue))\n        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    return (IsChange(txout) ? txout.nValue : 0);\n}\n\nbool CWallet::IsMine(const CTransaction& tx) const\n{\n    for (const CTxOut& txout : tx.vout)\n        if (IsMine(txout))\n            return true;\n    return false;\n}\n\nbool CWallet::IsFromMe(const CTransaction& tx) const\n{\n    return (GetDebit(tx, ISMINE_ALL) > 0);\n}\n\nCAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) const\n{\n    CAmount nDebit = 0;\n    for (const CTxIn& txin : tx.vin)\n    {\n        nDebit += GetDebit(txin, filter);\n        if (!MoneyRange(nDebit))\n            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    }\n    return nDebit;\n}\n\nbool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n{\n    LOCK(cs_wallet);\n\n    for (const CTxIn& txin : tx.vin)\n    {\n        auto mi = mapWallet.find(txin.prevout.hash);\n        if (mi == mapWallet.end())\n            return false; // any unknown inputs can't be from us\n\n        const CWalletTx& prev = (*mi).second;\n\n        if (txin.prevout.n >= prev.tx->vout.size())\n            return false; // invalid input!\n\n        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n            return false;\n    }\n    return true;\n}\n\nCAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n{\n    CAmount nCredit = 0;\n    for (const CTxOut& txout : tx.vout)\n    {\n        nCredit += GetCredit(txout, filter);\n        if (!MoneyRange(nCredit))\n            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    }\n    return nCredit;\n}\n\nCAmount CWallet::GetChange(const CTransaction& tx) const\n{\n    CAmount nChange = 0;\n    for (const CTxOut& txout : tx.vout)\n    {\n        nChange += GetChange(txout);\n        if (!MoneyRange(nChange))\n            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n    }\n    return nChange;\n}\n\nCPubKey CWallet::GenerateNewHDMasterKey()\n{\n    CKey key;\n    key.MakeNewKey(true);\n\n    int64_t nCreationTime = GetTime();\n    CKeyMetadata metadata(nCreationTime);\n\n    // calculate the pubkey\n    CPubKey pubkey = key.GetPubKey();\n    assert(key.VerifyPubKey(pubkey));\n\n    // set the hd keypath to \"m\" -> Master, refers the masterkeyid to itself\n    metadata.hdKeypath     = \"m\";\n    metadata.hdMasterKeyID = pubkey.GetID();\n\n    {\n        LOCK(cs_wallet);\n\n        // mem store the metadata\n        mapKeyMetadata[pubkey.GetID()] = metadata;\n\n        // write the key&metadata to the database\n        if (!AddKeyPubKey(key, pubkey))\n            throw std::runtime_error(std::string(__func__) + \": AddKeyPubKey failed\");\n    }\n\n    return pubkey;\n}\n\nbool CWallet::SetHDMasterKey(const CPubKey& pubkey)\n{\n    LOCK(cs_wallet);\n    // store the keyid (hash160) together with\n    // the child index counter in the database\n    // as a hdchain object\n    CHDChain newHdChain;\n    newHdChain.nVersion = CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n    newHdChain.masterKeyID = pubkey.GetID();\n    SetHDChain(newHdChain, false);\n\n    return true;\n}\n\nbool CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n{\n    LOCK(cs_wallet);\n    if (!memonly && !CWalletDB(*dbw).WriteHDChain(chain))\n        throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n\n    hdChain = chain;\n    return true;\n}\n\nbool CWallet::IsHDEnabled() const\n{\n    return !hdChain.masterKeyID.IsNull();\n}\n\nint64_t CWalletTx::GetTxTime() const\n{\n    int64_t n = nTimeSmart;\n    return n ? n : nTimeReceived;\n}\n\nint CWalletTx::GetRequestCount() const\n{\n    // Returns -1 if it wasn't being tracked\n    int nRequests = -1;\n    {\n        LOCK(pwallet->cs_wallet);\n        if (IsCoinBase())\n        {\n            // Generated block\n            if (!hashUnset())\n            {\n                std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                if (mi != pwallet->mapRequestCount.end())\n                    nRequests = (*mi).second;\n            }\n        }\n        else\n        {\n            // Did anyone request this transaction?\n            std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n            if (mi != pwallet->mapRequestCount.end())\n            {\n                nRequests = (*mi).second;\n\n                // How about the block it's in?\n                if (nRequests == 0 && !hashUnset())\n                {\n                    std::map<uint256, int>::const_iterator _mi = pwallet->mapRequestCount.find(hashBlock);\n                    if (_mi != pwallet->mapRequestCount.end())\n                        nRequests = (*_mi).second;\n                    else\n                        nRequests = 1; // If it's in someone else's block it must have got out\n                }\n            }\n        }\n    }\n    return nRequests;\n}\n\n// Helper for producing a max-sized low-S signature (eg 72 bytes)\nbool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout) const\n{\n    // Fill in dummy signatures for fee calculation.\n    const CScript& scriptPubKey = txout.scriptPubKey;\n    SignatureData sigdata;\n\n    if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n    {\n        return false;\n    } else {\n        UpdateInput(tx_in, sigdata);\n    }\n    return true;\n}\n\n// Helper for producing a bunch of max-sized low-S signatures (eg 72 bytes)\nbool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts) const\n{\n    // Fill in dummy signatures for fee calculation.\n    int nIn = 0;\n    for (const auto& txout : txouts)\n    {\n        if (!DummySignInput(txNew.vin[nIn], txout)) {\n            return false;\n        }\n\n        nIn++;\n    }\n    return true;\n}\n\nint64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n{\n    std::vector<CTxOut> txouts;\n    // Look up the inputs.  We should have already checked that this transaction\n    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n    // wallet, with a valid index into the vout array, and the ability to sign.\n    for (auto& input : tx.vin) {\n        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n        if (mi == wallet->mapWallet.end()) {\n            return -1;\n        }\n        assert(input.prevout.n < mi->second.tx->vout.size());\n        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n    }\n    return CalculateMaximumSignedTxSize(tx, wallet, txouts);\n}\n\n// txouts needs to be in the order of tx.vin\nint64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts)\n{\n    CMutableTransaction txNew(tx);\n    if (!wallet->DummySignTx(txNew, txouts)) {\n        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n        // implies that we can sign for every input.\n        return -1;\n    }\n    return GetVirtualTransactionSize(txNew);\n}\n\nint CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet)\n{\n    CMutableTransaction txn;\n    txn.vin.push_back(CTxIn(COutPoint()));\n    if (!wallet->DummySignInput(txn.vin[0], txout)) {\n        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n        // implies that we can sign for every input.\n        return -1;\n    }\n    return GetVirtualTransactionInputSize(txn.vin[0]);\n}\n\nvoid CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n                           std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const\n{\n    nFee = 0;\n    listReceived.clear();\n    listSent.clear();\n    strSentAccount = strFromAccount;\n\n    // Compute fee:\n    CAmount nDebit = GetDebit(filter);\n    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n    {\n        CAmount nValueOut = tx->GetValueOut();\n        nFee = nDebit - nValueOut;\n    }\n\n    // Sent/received.\n    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n    {\n        const CTxOut& txout = tx->vout[i];\n        isminetype fIsMine = pwallet->IsMine(txout);\n        // Only need to handle txouts if AT LEAST one of these is true:\n        //   1) they debit from us (sent)\n        //   2) the output is to us (received)\n        if (nDebit > 0)\n        {\n            // Don't report 'change' txouts\n            if (pwallet->IsChange(txout))\n                continue;\n        }\n        else if (!(fIsMine & filter))\n            continue;\n\n        // In either case, we need to get the destination address\n        CTxDestination address;\n\n        if (!ExtractDestination(txout.scriptPubKey, address) && !txout.scriptPubKey.IsUnspendable())\n        {\n            LogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                     this->GetHash().ToString());\n            address = CNoDestination();\n        }\n\n        COutputEntry output = {address, txout.nValue, (int)i};\n\n        // If we are debited by the transaction, add the output as a \"sent\" entry\n        if (nDebit > 0)\n            listSent.push_back(output);\n\n        // If we are receiving the output, add it as a \"received\" entry\n        if (fIsMine & filter)\n            listReceived.push_back(output);\n    }\n\n}\n\n/**\n * Scan active chain for relevant transactions after importing keys. This should\n * be called whenever new keys are added to the wallet, with the oldest key\n * creation time.\n *\n * @return Earliest timestamp that could be successfully scanned from. Timestamp\n * returned will be higher than startTime if relevant blocks could not be read.\n */\nint64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& reserver, bool update)\n{\n    // Find starting block. May be null if nCreateTime is greater than the\n    // highest blockchain timestamp, in which case there is nothing that needs\n    // to be scanned.\n    CBlockIndex* startBlock = nullptr;\n    {\n        LOCK(cs_main);\n        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n    }\n\n    if (startBlock) {\n        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n        if (failedBlock) {\n            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n        }\n    }\n    return startTime;\n}\n\n/**\n * Scan the block chain (starting in pindexStart) for transactions\n * from or to us. If fUpdate is true, found transactions that already\n * exist in the wallet will be updated.\n *\n * Returns null if scan was successful. Otherwise, if a complete rescan was not\n * possible (due to pruning or corruption), returns pointer to the most recent\n * block that could not be scanned.\n *\n * If pindexStop is not a nullptr, the scan will stop at the block-index\n * defined by pindexStop\n *\n * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n * the main chain after to the addition of any new keys you want to detect\n * transactions for.\n */\nCBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n{\n    int64_t nNow = GetTime();\n    const CChainParams& chainParams = Params();\n\n    assert(reserver.isReserved());\n    if (pindexStop) {\n        assert(pindexStop->nHeight >= pindexStart->nHeight);\n    }\n\n    CBlockIndex* pindex = pindexStart;\n    CBlockIndex* ret = nullptr;\n    {\n        fAbortRescan = false;\n        ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n        CBlockIndex* tip = nullptr;\n        double dProgressStart;\n        double dProgressTip;\n        {\n            LOCK(cs_main);\n            tip = chainActive.Tip();\n            dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n            dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n        }\n        double gvp = dProgressStart;\n        while (pindex && !fAbortRescan)\n        {\n            if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n                ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((gvp - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n            }\n            if (GetTime() >= nNow + 60) {\n                nNow = GetTime();\n                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n            }\n\n            CBlock block;\n            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n                LOCK2(cs_main, cs_wallet);\n                if (pindex && !chainActive.Contains(pindex)) {\n                    // Abort scan if current block is no longer active, to prevent\n                    // marking transactions as coming from the wrong block.\n                    ret = pindex;\n                    break;\n                }\n                for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n                    AddToWalletIfInvolvingMe(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n                }\n            } else {\n                ret = pindex;\n            }\n            if (pindex == pindexStop) {\n                break;\n            }\n            {\n                LOCK(cs_main);\n                pindex = chainActive.Next(pindex);\n                gvp = GuessVerificationProgress(chainParams.TxData(), pindex);\n                if (tip != chainActive.Tip()) {\n                    tip = chainActive.Tip();\n                    // in case the tip has changed, update progress max\n                    dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n                }\n            }\n        }\n        if (pindex && fAbortRescan) {\n            LogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n        }\n        ShowProgress(_(\"Rescanning...\"), 100); // hide progress dialog in GUI\n    }\n    return ret;\n}\n\nvoid CWallet::ReacceptWalletTransactions()\n{\n    // If transactions aren't being broadcasted, don't let them into local mempool either\n    if (!fBroadcastTransactions)\n        return;\n    LOCK2(cs_main, cs_wallet);\n    std::map<int64_t, CWalletTx*> mapSorted;\n\n    // Sort pending wallet transactions based on their initial wallet insertion order\n    for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n    {\n        const uint256& wtxid = item.first;\n        CWalletTx& wtx = item.second;\n        assert(wtx.GetHash() == wtxid);\n\n        int nDepth = wtx.GetDepthInMainChain();\n\n        if (!wtx.IsCoinBase() && (nDepth == 0 && !wtx.isAbandoned())) {\n            mapSorted.insert(std::make_pair(wtx.nOrderPos, &wtx));\n        }\n    }\n\n    // Try to add wallet transactions to memory pool\n    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted) {\n        CWalletTx& wtx = *(item.second);\n        CValidationState state;\n        wtx.AcceptToMemoryPool(maxTxFee, state);\n    }\n}\n\nbool CWalletTx::RelayWalletTransaction(CConnman* connman)\n{\n    assert(pwallet->GetBroadcastTransactions());\n    if (!IsCoinBase() && !isAbandoned() && GetDepthInMainChain() == 0)\n    {\n        CValidationState state;\n        /* GetDepthInMainChain already catches known conflicts. */\n        if (InMempool() || AcceptToMemoryPool(maxTxFee, state)) {\n            LogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n            if (connman) {\n                CInv inv(MSG_TX, GetHash());\n                connman->ForEachNode([&inv](CNode* pnode)\n                {\n                    pnode->PushInventory(inv);\n                });\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nstd::set<uint256> CWalletTx::GetConflicts() const\n{\n    std::set<uint256> result;\n    if (pwallet != nullptr)\n    {\n        uint256 myHash = GetHash();\n        result = pwallet->GetConflicts(myHash);\n        result.erase(myHash);\n    }\n    return result;\n}\n\nCAmount CWalletTx::GetDebit(const isminefilter& filter) const\n{\n    if (tx->vin.empty())\n        return 0;\n\n    CAmount debit = 0;\n    if(filter & ISMINE_SPENDABLE)\n    {\n        if (fDebitCached)\n            debit += nDebitCached;\n        else\n        {\n            nDebitCached = pwallet->GetDebit(*tx, ISMINE_SPENDABLE);\n            fDebitCached = true;\n            debit += nDebitCached;\n        }\n    }\n    if(filter & ISMINE_WATCH_ONLY)\n    {\n        if(fWatchDebitCached)\n            debit += nWatchDebitCached;\n        else\n        {\n            nWatchDebitCached = pwallet->GetDebit(*tx, ISMINE_WATCH_ONLY);\n            fWatchDebitCached = true;\n            debit += nWatchDebitCached;\n        }\n    }\n    return debit;\n}\n\nCAmount CWalletTx::GetCredit(const isminefilter& filter) const\n{\n    // Must wait until coinbase is safely deep enough in the chain before valuing it\n    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n        return 0;\n\n    CAmount credit = 0;\n    if (filter & ISMINE_SPENDABLE)\n    {\n        // GetBalance can assume transactions in mapWallet won't change\n        if (fCreditCached)\n            credit += nCreditCached;\n        else\n        {\n            nCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);\n            fCreditCached = true;\n            credit += nCreditCached;\n        }\n    }\n    if (filter & ISMINE_WATCH_ONLY)\n    {\n        if (fWatchCreditCached)\n            credit += nWatchCreditCached;\n        else\n        {\n            nWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);\n            fWatchCreditCached = true;\n            credit += nWatchCreditCached;\n        }\n    }\n    return credit;\n}\n\nCAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n{\n    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n    {\n        if (fUseCache && fImmatureCreditCached)\n            return nImmatureCreditCached;\n        nImmatureCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);\n        fImmatureCreditCached = true;\n        return nImmatureCreditCached;\n    }\n\n    return 0;\n}\n\nCAmount CWalletTx::GetAvailableCredit(bool fUseCache) const\n{\n    if (pwallet == nullptr)\n        return 0;\n\n    // Must wait until coinbase is safely deep enough in the chain before valuing it\n    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n        return 0;\n\n    if (fUseCache && fAvailableCreditCached)\n        return nAvailableCreditCached;\n\n    CAmount nCredit = 0;\n    uint256 hashTx = GetHash();\n    for (unsigned int i = 0; i < tx->vout.size(); i++)\n    {\n        if (!pwallet->IsSpent(hashTx, i))\n        {\n            const CTxOut &txout = tx->vout[i];\n            nCredit += pwallet->GetCredit(txout, ISMINE_SPENDABLE);\n            if (!MoneyRange(nCredit))\n                throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n        }\n    }\n\n    nAvailableCreditCached = nCredit;\n    fAvailableCreditCached = true;\n    return nCredit;\n}\n\nCAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n{\n    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n    {\n        if (fUseCache && fImmatureWatchCreditCached)\n            return nImmatureWatchCreditCached;\n        nImmatureWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);\n        fImmatureWatchCreditCached = true;\n        return nImmatureWatchCreditCached;\n    }\n\n    return 0;\n}\n\nCAmount CWalletTx::GetAvailableWatchOnlyCredit(const bool fUseCache) const\n{\n    if (pwallet == nullptr)\n        return 0;\n\n    // Must wait until coinbase is safely deep enough in the chain before valuing it\n    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n        return 0;\n\n    if (fUseCache && fAvailableWatchCreditCached)\n        return nAvailableWatchCreditCached;\n\n    CAmount nCredit = 0;\n    for (unsigned int i = 0; i < tx->vout.size(); i++)\n    {\n        if (!pwallet->IsSpent(GetHash(), i))\n        {\n            const CTxOut &txout = tx->vout[i];\n            nCredit += pwallet->GetCredit(txout, ISMINE_WATCH_ONLY);\n            if (!MoneyRange(nCredit))\n                throw std::runtime_error(std::string(__func__) + \": value out of range\");\n        }\n    }\n\n    nAvailableWatchCreditCached = nCredit;\n    fAvailableWatchCreditCached = true;\n    return nCredit;\n}\n\nCAmount CWalletTx::GetChange() const\n{\n    if (fChangeCached)\n        return nChangeCached;\n    nChangeCached = pwallet->GetChange(*tx);\n    fChangeCached = true;\n    return nChangeCached;\n}\n\nbool CWalletTx::InMempool() const\n{\n    return fInMempool;\n}\n\nbool CWalletTx::IsTrusted() const\n{\n    // Quick answer in most cases\n    if (!CheckFinalTx(*tx))\n        return false;\n    int nDepth = GetDepthInMainChain();\n    if (nDepth >= 1)\n        return true;\n    if (nDepth < 0)\n        return false;\n    if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx's cached debit\n        return false;\n\n    // Don't trust unconfirmed transactions from us unless they are in the mempool.\n    if (!InMempool())\n        return false;\n\n    // Trusted if all inputs are from us and are in the mempool:\n    for (const CTxIn& txin : tx->vin)\n    {\n        // Transactions not sent by us: not trusted\n        const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n        if (parent == nullptr)\n            return false;\n        const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n        if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE)\n            return false;\n    }\n    return true;\n}\n\nbool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n{\n        CMutableTransaction tx1 = *this->tx;\n        CMutableTransaction tx2 = *_tx.tx;\n        for (auto& txin : tx1.vin) txin.scriptSig = CScript();\n        for (auto& txin : tx2.vin) txin.scriptSig = CScript();\n        return CTransaction(tx1) == CTransaction(tx2);\n}\n\nstd::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman)\n{\n    std::vector<uint256> result;\n\n    LOCK(cs_wallet);\n\n    // Sort them in chronological order\n    std::multimap<unsigned int, CWalletTx*> mapSorted;\n    for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n    {\n        CWalletTx& wtx = item.second;\n        // Don't rebroadcast if newer than nTime:\n        if (wtx.nTimeReceived > nTime)\n            continue;\n        mapSorted.insert(std::make_pair(wtx.nTimeReceived, &wtx));\n    }\n    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)\n    {\n        CWalletTx& wtx = *item.second;\n        if (wtx.RelayWalletTransaction(connman))\n            result.push_back(wtx.GetHash());\n    }\n    return result;\n}\n\nvoid CWallet::ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman)\n{\n    // Do this infrequently and randomly to avoid giving away\n    // that these are our transactions.\n    if (GetTime() < nNextResend || !fBroadcastTransactions)\n        return;\n    bool fFirst = (nNextResend == 0);\n    nNextResend = GetTime() + GetRand(30 * 60);\n    if (fFirst)\n        return;\n\n    // Only do it if there's been a new block since last time\n    if (nBestBlockTime < nLastResend)\n        return;\n    nLastResend = GetTime();\n\n    // Rebroadcast unconfirmed txes older than 5 minutes before the last\n    // block was found:\n    std::vector<uint256> relayed = ResendWalletTransactionsBefore(nBestBlockTime-5*60, connman);\n    if (!relayed.empty())\n        LogPrintf(\"%s: rebroadcast %u unconfirmed transactions\\n\", __func__, relayed.size());\n}\n\n/** @} */ // end of mapWallet\n\n\n\n\n/** @defgroup Actions\n *\n * @{\n */\n\n\nCAmount CWallet::GetBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nCAmount CWallet::GetUnconfirmedBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n    return nTotal;\n}\n\nCAmount CWallet::GetImmatureBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            nTotal += pcoin->GetImmatureCredit();\n        }\n    }\n    return nTotal;\n}\n\nCAmount CWallet::GetWatchOnlyBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableWatchOnlyCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nCAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n                nTotal += pcoin->GetAvailableWatchOnlyCredit();\n        }\n    }\n    return nTotal;\n}\n\nCAmount CWallet::GetImmatureWatchOnlyBalance() const\n{\n    CAmount nTotal = 0;\n    {\n        LOCK2(cs_main, cs_wallet);\n        for (const auto& entry : mapWallet)\n        {\n            const CWalletTx* pcoin = &entry.second;\n            nTotal += pcoin->GetImmatureWatchOnlyCredit();\n        }\n    }\n    return nTotal;\n}\n\n// Calculate total balance in a different way from GetBalance. The biggest\n// difference is that GetBalance sums up all unspent TxOuts paying to the\n// wallet, while this sums up both spent and unspent TxOuts paying to the\n// wallet, and then subtracts the values of TxIns spending from the wallet. This\n// also has fewer restrictions on which unconfirmed transactions are considered\n// trusted.\nCAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const\n{\n    LOCK2(cs_main, cs_wallet);\n\n    CAmount balance = 0;\n    for (const auto& entry : mapWallet) {\n        const CWalletTx& wtx = entry.second;\n        const int depth = wtx.GetDepthInMainChain();\n        if (depth < 0 || !CheckFinalTx(*wtx.tx) || wtx.GetBlocksToMaturity() > 0) {\n            continue;\n        }\n\n        // Loop through tx outputs and add incoming payments. For outgoing txs,\n        // treat change outputs specially, as part of the amount debited.\n        CAmount debit = wtx.GetDebit(filter);\n        const bool outgoing = debit > 0;\n        for (const CTxOut& out : wtx.tx->vout) {\n            if (outgoing && IsChange(out)) {\n                debit -= out.nValue;\n            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetAccountName(out.scriptPubKey))) {\n                balance += out.nValue;\n            }\n        }\n\n        // For outgoing txs, subtract amount debited.\n        if (outgoing && (!account || *account == wtx.strFromAccount)) {\n            balance -= debit;\n        }\n    }\n\n    if (account) {\n        balance += CWalletDB(*dbw).GetAccountCreditDebit(*account);\n    }\n\n    return balance;\n}\n\nCAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n{\n    LOCK2(cs_main, cs_wallet);\n\n    CAmount balance = 0;\n    std::vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n    for (const COutput& out : vCoins) {\n        if (out.fSpendable) {\n            balance += out.tx->tx->vout[out.i].nValue;\n        }\n    }\n    return balance;\n}\n\nvoid CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t nMaximumCount, const int nMinDepth, const int nMaxDepth) const\n{\n    AssertLockHeld(cs_main);\n    AssertLockHeld(cs_wallet);\n\n    vCoins.clear();\n    CAmount nTotal = 0;\n\n    for (const auto& entry : mapWallet)\n    {\n        const uint256& wtxid = entry.first;\n        const CWalletTx* pcoin = &entry.second;\n\n        if (!CheckFinalTx(*pcoin->tx))\n            continue;\n\n        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n            continue;\n\n        int nDepth = pcoin->GetDepthInMainChain();\n        if (nDepth < 0)\n            continue;\n\n        // We should not consider coins which aren't at least in our mempool\n        // It's possible for these to be conflicted via ancestors which we may never be able to detect\n        if (nDepth == 0 && !pcoin->InMempool())\n            continue;\n\n        bool safeTx = pcoin->IsTrusted();\n\n        // We should not consider coins from transactions that are replacing\n        // other transactions.\n        //\n        // Example: There is a transaction A which is replaced by bumpfee\n        // transaction B. In this case, we want to prevent creation of\n        // a transaction B' which spends an output of B.\n        //\n        // Reason: If transaction A were initially confirmed, transactions B\n        // and B' would no longer be valid, so the user would have to create\n        // a new transaction C to replace B'. However, in the case of a\n        // one-block reorg, transactions B' and C might BOTH be accepted,\n        // when the user only wanted one of them. Specifically, there could\n        // be a 1-block reorg away from the chain where transactions A and C\n        // were accepted to another chain where B, B', and C were all\n        // accepted.\n        if (nDepth == 0 && pcoin->mapValue.count(\"replaces_txid\")) {\n            safeTx = false;\n        }\n\n        // Similarly, we should not consider coins from transactions that\n        // have been replaced. In the example above, we would want to prevent\n        // creation of a transaction A' spending an output of A, because if\n        // transaction B were initially confirmed, conflicting with A and\n        // A', we wouldn't want to the user to create a transaction D\n        // intending to replace A', but potentially resulting in a scenario\n        // where A, A', and D could all be accepted (instead of just B and\n        // D, or just A and A' like the user would want).\n        if (nDepth == 0 && pcoin->mapValue.count(\"replaced_by_txid\")) {\n            safeTx = false;\n        }\n\n        if (fOnlySafe && !safeTx) {\n            continue;\n        }\n\n        if (nDepth < nMinDepth || nDepth > nMaxDepth)\n            continue;\n\n        for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n            if (pcoin->tx->vout[i].nValue < nMinimumAmount || pcoin->tx->vout[i].nValue > nMaximumAmount)\n                continue;\n\n            if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n                continue;\n\n            if (IsLockedCoin(entry.first, i))\n                continue;\n\n            if (IsSpent(wtxid, i))\n                continue;\n\n            isminetype mine = IsMine(pcoin->tx->vout[i]);\n\n            if (mine == ISMINE_NO) {\n                continue;\n            }\n\n            bool fSpendableIn = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO);\n            bool fSolvableIn = (mine & (ISMINE_SPENDABLE | ISMINE_WATCH_SOLVABLE)) != ISMINE_NO;\n\n            vCoins.push_back(COutput(pcoin, i, nDepth, fSpendableIn, fSolvableIn, safeTx));\n\n            // Checks the sum amount of all UTXO's.\n            if (nMinimumSumAmount != MAX_MONEY) {\n                nTotal += pcoin->tx->vout[i].nValue;\n\n                if (nTotal >= nMinimumSumAmount) {\n                    return;\n                }\n            }\n\n            // Checks the maximum number of UTXO's.\n            if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n                return;\n            }\n        }\n    }\n}\n\nstd::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n{\n    // TODO: Add AssertLockHeld(cs_wallet) here.\n    //\n    // Because the return value from this function contains pointers to\n    // CWalletTx objects, callers to this function really should acquire the\n    // cs_wallet lock before calling it. However, the current caller doesn't\n    // acquire this lock yet. There was an attempt to add the missing lock in\n    // https://github.com/bitcoin/bitcoin/pull/10340, but that change has been\n    // postponed until after https://github.com/bitcoin/bitcoin/pull/10244 to\n    // avoid adding some extra complexity to the Qt code.\n\n    std::map<CTxDestination, std::vector<COutput>> result;\n    std::vector<COutput> availableCoins;\n\n    LOCK2(cs_main, cs_wallet);\n    AvailableCoins(availableCoins);\n\n    for (auto& coin : availableCoins) {\n        CTxDestination address;\n        if (coin.fSpendable &&\n            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n            result[address].emplace_back(std::move(coin));\n        }\n    }\n\n    std::vector<COutPoint> lockedCoins;\n    ListLockedCoins(lockedCoins);\n    for (const auto& output : lockedCoins) {\n        auto it = mapWallet.find(output.hash);\n        if (it != mapWallet.end()) {\n            int depth = it->second.GetDepthInMainChain();\n            if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n                IsMine(it->second.tx->vout[output.n]) == ISMINE_SPENDABLE) {\n                CTxDestination address;\n                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n                    result[address].emplace_back(\n                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nconst CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n{\n    const CTransaction* ptx = &tx;\n    int n = output;\n    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n        const COutPoint& prevout = ptx->vin[0].prevout;\n        auto it = mapWallet.find(prevout.hash);\n        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n            !IsMine(it->second.tx->vout[prevout.n])) {\n            break;\n        }\n        ptx = it->second.tx.get();\n        n = prevout.n;\n    }\n    return ptx->vout[n];\n}\n\nbool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibilty_filter) const\n{\n    if (!output.fSpendable)\n        return false;\n\n    if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? eligibilty_filter.conf_mine : eligibilty_filter.conf_theirs))\n        return false;\n\n    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), eligibilty_filter.max_ancestors))\n        return false;\n\n    return true;\n}\n\nbool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins,\n                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    std::vector<CInputCoin> utxo_pool;\n    if (coin_selection_params.use_bnb) {\n\n        // Get long term estimate\n        FeeCalculation feeCalc;\n        CCoinControl temp;\n        temp.m_confirm_target = 1008;\n        CFeeRate long_term_feerate = GetMinimumFeeRate(temp, ::mempool, ::feeEstimator, &feeCalc);\n\n        // Calculate cost of change\n        CAmount cost_of_change = GetDiscardRate(::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n\n        // Filter by the min conf specs and add to utxo_pool and calculate effective value\n        for (const COutput &output : vCoins)\n        {\n            if (!OutputEligibleForSpending(output, eligibilty_filter))\n                continue;\n\n            CInputCoin coin(output.tx->tx, output.i);\n            coin.effective_value = coin.txout.nValue - (output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes));\n            // Only include outputs that are positive effective value (i.e. not dust)\n            if (coin.effective_value > 0) {\n                coin.fee = output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes);\n                coin.long_term_fee = output.nInputBytes < 0 ? 0 : long_term_feerate.GetFee(output.nInputBytes);\n                utxo_pool.push_back(coin);\n            }\n        }\n        // Calculate the fees for things that aren't inputs\n        CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n        bnb_used = true;\n        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n    } else {\n        // Filter by the min conf specs and add to utxo_pool\n        for (const COutput &output : vCoins)\n        {\n            if (!OutputEligibleForSpending(output, eligibilty_filter))\n                continue;\n\n            CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n            utxo_pool.push_back(coin);\n        }\n        bnb_used = false;\n        return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n    }\n}\n\nbool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n{\n    std::vector<COutput> vCoins(vAvailableCoins);\n\n    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n    if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n    {\n        // We didn't use BnB here, so set it to false.\n        bnb_used = false;\n\n        for (const COutput& out : vCoins)\n        {\n            if (!out.fSpendable)\n                 continue;\n            nValueRet += out.tx->tx->vout[out.i].nValue;\n            setCoinsRet.insert(CInputCoin(out.tx->tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    // calculate value from preset inputs and store them\n    std::set<CInputCoin> setPresetCoins;\n    CAmount nValueFromPresetInputs = 0;\n\n    std::vector<COutPoint> vPresetInputs;\n    coin_control.ListSelected(vPresetInputs);\n    for (const COutPoint& outpoint : vPresetInputs)\n    {\n        // For now, don't use BnB if preset inputs are selected. TODO: Enable this later\n        bnb_used = false;\n\n        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n        if (it != mapWallet.end())\n        {\n            const CWalletTx* pcoin = &it->second;\n            // Clearly invalid input, fail\n            if (pcoin->tx->vout.size() <= outpoint.n)\n                return false;\n            // Just to calculate the marginal byte size\n            nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n            setPresetCoins.insert(CInputCoin(pcoin->tx, outpoint.n));\n        } else\n            return false; // TODO: Allow non-wallet inputs\n    }\n\n    // remove preset inputs from vCoins\n    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n    {\n        if (setPresetCoins.count(CInputCoin(it->tx->tx, it->i)))\n            it = vCoins.erase(it);\n        else\n            ++it;\n    }\n\n    size_t nMaxChainLength = std::min(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT), gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT));\n    bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n\n    bool res = nTargetValue <= nValueFromPresetInputs ||\n        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n\n    // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n    setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());\n\n    // add preset inputs to the total value selected\n    nValueRet += nValueFromPresetInputs;\n\n    return res;\n}\n\nbool CWallet::SignTransaction(CMutableTransaction &tx)\n{\n    AssertLockHeld(cs_wallet); // mapWallet\n\n    // sign the new tx\n    CTransaction txNewConst(tx);\n    int nIn = 0;\n    for (const auto& input : tx.vin) {\n        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n        if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {\n            return false;\n        }\n        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n        SignatureData sigdata;\n        if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n            return false;\n        }\n        UpdateTransaction(tx, nIn, sigdata);\n        nIn++;\n    }\n    return true;\n}\n\nbool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n{\n    std::vector<CRecipient> vecSend;\n\n    // Turn the txout set into a CRecipient vector.\n    for (size_t idx = 0; idx < tx.vout.size(); idx++) {\n        const CTxOut& txOut = tx.vout[idx];\n        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, setSubtractFeeFromOutputs.count(idx) == 1};\n        vecSend.push_back(recipient);\n    }\n\n    coinControl.fAllowOtherInputs = true;\n\n    for (const CTxIn& txin : tx.vin) {\n        coinControl.Select(txin.prevout);\n    }\n\n    // Acquire the locks to prevent races to the new locked unspents between the\n    // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n    LOCK2(cs_main, cs_wallet);\n\n    CReserveKey reservekey(this);\n    CTransactionRef tx_new;\n    if (!CreateTransaction(vecSend, tx_new, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n        return false;\n    }\n\n    if (nChangePosInOut != -1) {\n        tx.vout.insert(tx.vout.begin() + nChangePosInOut, tx_new->vout[nChangePosInOut]);\n        // We don't have the normal Create/Commit cycle, and don't want to risk\n        // reusing change, so just remove the key from the keypool here.\n        reservekey.KeepKey();\n    }\n\n    // Copy output sizes from new transaction; they may have had the fee\n    // subtracted from them.\n    for (unsigned int idx = 0; idx < tx.vout.size(); idx++) {\n        tx.vout[idx].nValue = tx_new->vout[idx].nValue;\n    }\n\n    // Add new txins while keeping original txin scriptSig/order.\n    for (const CTxIn& txin : tx_new->vin) {\n        if (!coinControl.IsSelected(txin.prevout)) {\n            tx.vin.push_back(txin);\n\n            if (lockUnspents) {\n                LockCoin(txin.prevout);\n            }\n        }\n    }\n\n    return true;\n}\n\nOutputType CWallet::TransactionChangeType(OutputType change_type, const std::vector<CRecipient>& vecSend)\n{\n    // If -changetype is specified, always use that change type.\n    if (change_type != OutputType::NONE) {\n        return change_type;\n    }\n\n    // if m_default_address_type is legacy, use legacy address as change (even\n    // if some of the outputs are P2WPKH or P2WSH).\n    if (m_default_address_type == OutputType::LEGACY) {\n        return OutputType::LEGACY;\n    }\n\n    // if any destination is P2WPKH or P2WSH, use P2WPKH for the change\n    // output.\n    for (const auto& recipient : vecSend) {\n        // Check if any destination contains a witness program:\n        int witnessversion = 0;\n        std::vector<unsigned char> witnessprogram;\n        if (recipient.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n            return OutputType::BECH32;\n        }\n    }\n\n    // else use m_default_address_type for change\n    return m_default_address_type;\n}\n\nbool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n                                int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n{\n    CAmount nValue = 0;\n    int nChangePosRequest = nChangePosInOut;\n    unsigned int nSubtractFeeFromAmount = 0;\n    for (const auto& recipient : vecSend)\n    {\n        if (nValue < 0 || recipient.nAmount < 0)\n        {\n            strFailReason = _(\"Transaction amounts must not be negative\");\n            return false;\n        }\n        nValue += recipient.nAmount;\n\n        if (recipient.fSubtractFeeFromAmount)\n            nSubtractFeeFromAmount++;\n    }\n    if (vecSend.empty())\n    {\n        strFailReason = _(\"Transaction must have at least one recipient\");\n        return false;\n    }\n\n    CMutableTransaction txNew;\n\n    // Discourage fee sniping.\n    //\n    // For a large miner the value of the transactions in the best block and\n    // the mempool can exceed the cost of deliberately attempting to mine two\n    // blocks to orphan the current best block. By setting nLockTime such that\n    // only the next block can include the transaction, we discourage this\n    // practice as the height restricted and limited blocksize gives miners\n    // considering fee sniping fewer options for pulling off this attack.\n    //\n    // A simple way to think about this is from the wallet's point of view we\n    // always want the blockchain to move forward. By setting nLockTime this\n    // way we're basically making the statement that we only want this\n    // transaction to appear in the next block; we don't want to potentially\n    // encourage reorgs by allowing transactions to appear at lower heights\n    // than the next block in forks of the best chain.\n    //\n    // Of course, the subsidy is high enough, and transaction volume low\n    // enough, that fee sniping isn't a problem yet, but by implementing a fix\n    // now we ensure code won't be written that makes assumptions about\n    // nLockTime that preclude a fix later.\n    txNew.nLockTime = chainActive.Height();\n\n    // Secondly occasionally randomly pick a nLockTime even further back, so\n    // that transactions that are delayed after signing for whatever reason,\n    // e.g. high-latency mix networks and some CoinJoin implementations, have\n    // better privacy.\n    if (GetRandInt(10) == 0)\n        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));\n\n    assert(txNew.nLockTime <= (unsigned int)chainActive.Height());\n    assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n    FeeCalculation feeCalc;\n    CAmount nFeeNeeded;\n    int nBytes;\n    {\n        std::set<CInputCoin> setCoins;\n        LOCK2(cs_main, cs_wallet);\n        {\n            std::vector<COutput> vAvailableCoins;\n            AvailableCoins(vAvailableCoins, true, &coin_control);\n            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n\n            // Create change script that will be used if we need change\n            // TODO: pass in scriptChange instead of reservekey so\n            // change transaction isn't always pay-to-bitcoin-address\n            CScript scriptChange;\n\n            // coin control: send change to custom address\n            if (!boost::get<CNoDestination>(&coin_control.destChange)) {\n                scriptChange = GetScriptForDestination(coin_control.destChange);\n            } else { // no coin control: send change to newly generated address\n                // Note: We use a new key here to keep it from being obvious which side is the change.\n                //  The drawback is that by not reusing a previous key, the change may be lost if a\n                //  backup is restored, if the backup doesn't have the new private key for the change.\n                //  If we reused the old key, it would be possible to add code to look for and\n                //  rediscover unknown transactions that were written with keys of ours to recover\n                //  post-backup change.\n\n                // Reserve a new key pair from key pool\n                CPubKey vchPubKey;\n                bool ret;\n                ret = reservekey.GetReservedKey(vchPubKey, true);\n                if (!ret)\n                {\n                    strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");\n                    return false;\n                }\n\n                const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n\n                LearnRelatedScripts(vchPubKey, change_type);\n                scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));\n            }\n            CTxOut change_prototype_txout(0, scriptChange);\n            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n\n            CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n\n            // Get the fee rate to use effective values in coin selection\n            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);\n\n            nFeeRet = 0;\n            bool pick_new_inputs = true;\n            CAmount nValueIn = 0;\n\n            // BnB selector is the only selector used when this is true.\n            // That should only happen on the first pass through the loop.\n            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n            // Start with no fee and loop until there is enough fee\n            while (true)\n            {\n                nChangePosInOut = nChangePosRequest;\n                txNew.vin.clear();\n                txNew.vout.clear();\n                bool fFirst = true;\n\n                CAmount nValueToSelect = nValue;\n                if (nSubtractFeeFromAmount == 0)\n                    nValueToSelect += nFeeRet;\n\n                // vouts to the payees\n                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n                for (const auto& recipient : vecSend)\n                {\n                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n\n                    if (recipient.fSubtractFeeFromAmount)\n                    {\n                        assert(nSubtractFeeFromAmount != 0);\n                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n\n                        if (fFirst) // first receiver pays the remainder not divisible by output count\n                        {\n                            fFirst = false;\n                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                        }\n                    }\n                    // Include the fee cost for outputs. Note this is only used for BnB right now\n                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n\n                    if (IsDust(txout, ::dustRelayFee))\n                    {\n                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                        {\n                            if (txout.nValue < 0)\n                                strFailReason = _(\"The transaction amount is too small to pay the fee\");\n                            else\n                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                        }\n                        else\n                            strFailReason = _(\"Transaction amount too small\");\n                        return false;\n                    }\n                    txNew.vout.push_back(txout);\n                }\n\n                // Choose coins to use\n                bool bnb_used;\n                if (pick_new_inputs) {\n                    nValueIn = 0;\n                    setCoins.clear();\n                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n                    coin_selection_params.effective_fee = nFeeRateNeeded;\n                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                    {\n                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n                        if (bnb_used) {\n                            coin_selection_params.use_bnb = false;\n                            continue;\n                        }\n                        else {\n                            strFailReason = _(\"Insufficient funds\");\n                            return false;\n                        }\n                    }\n                }\n\n                const CAmount nChange = nValueIn - nValueToSelect;\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    CTxOut newTxOut(nChange, scriptChange);\n\n                    // Never create dust outputs; if we would, just\n                    // add the dust to the fee.\n                    // The nChange when BnB is used is always going to go to fees.\n                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n                    {\n                        nChangePosInOut = -1;\n                        nFeeRet += nChange;\n                    }\n                    else\n                    {\n                        if (nChangePosInOut == -1)\n                        {\n                            // Insert change txn at random position:\n                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                        }\n                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                        {\n                            strFailReason = _(\"Change index out of range\");\n                            return false;\n                        }\n\n                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                        txNew.vout.insert(position, newTxOut);\n                    }\n                } else {\n                    nChangePosInOut = -1;\n                }\n\n                // Dummy fill vin for maximum size estimation\n                //\n                for (const auto& coin : setCoins) {\n                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n                }\n\n                nBytes = CalculateMaximumSignedTxSize(txNew, this);\n                if (nBytes < 0) {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                }\n\n                nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n                if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {\n                    // eventually allow a fallback fee\n                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n                    return false;\n                }\n\n                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n                // because we must be at the maximum allowed fee.\n                if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))\n                {\n                    strFailReason = _(\"Transaction too large for fee policy\");\n                    return false;\n                }\n\n                if (nFeeRet >= nFeeNeeded) {\n                    // Reduce fee to only the needed amount if possible. This\n                    // prevents potential overpayment in fees if the coins\n                    // selected to meet nFeeNeeded result in a transaction that\n                    // requires less fee than the prior iteration.\n\n                    // If we have no change and a big enough excess fee, then\n                    // try to construct transaction again only without picking\n                    // new inputs. We now know we only need the smaller fee\n                    // (because of reduced tx size) and so we should add a\n                    // change output. Only try this once.\n                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n                        CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n                            pick_new_inputs = false;\n                            nFeeRet = fee_needed_with_change;\n                            continue;\n                        }\n                    }\n\n                    // If we have change output already, just increase it\n                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                        change_position->nValue += extraFeePaid;\n                        nFeeRet -= extraFeePaid;\n                    }\n                    break; // Done, enough fee included.\n                }\n                else if (!pick_new_inputs) {\n                    // This shouldn't happen, we should have had enough excess\n                    // fee to pay for the new output and still meet nFeeNeeded\n                    // Or we should have just subtracted fee from recipients and\n                    // nFeeNeeded should not have changed\n                    strFailReason = _(\"Transaction fee and change calculation failed\");\n                    return false;\n                }\n\n                // Try to reduce change to include necessary fee\n                if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                    // Only reduce change if remaining amount is still a large enough output.\n                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n                        change_position->nValue -= additionalFeeNeeded;\n                        nFeeRet += additionalFeeNeeded;\n                        break; // Done, able to increase fee from change\n                    }\n                }\n\n                // If subtracting fee from recipients, we now know what fee we\n                // need to subtract, we have no reason to reselect inputs\n                if (nSubtractFeeFromAmount > 0) {\n                    pick_new_inputs = false;\n                }\n\n                // Include more fee and try again.\n                nFeeRet = nFeeNeeded;\n                coin_selection_params.use_bnb = false;\n                continue;\n            }\n        }\n\n        if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n\n        // Shuffle selected coins and fill in final vin\n        txNew.vin.clear();\n        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n\n        // Note how the sequence number is set to non-maxint so that\n        // the nLockTime set above actually works.\n        //\n        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n        // we use the highest possible value in that range (maxint-2)\n        // to avoid conflicting with other possible uses of nSequence,\n        // and in the spirit of \"smallest possible change from prior\n        // behavior.\"\n        const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n        for (const auto& coin : selected_coins) {\n            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n        }\n\n        if (sign)\n        {\n            CTransaction txNewConst(txNew);\n            int nIn = 0;\n            for (const auto& coin : selected_coins)\n            {\n                const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                SignatureData sigdata;\n\n                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                } else {\n                    UpdateTransaction(txNew, nIn, sigdata);\n                }\n\n                nIn++;\n            }\n        }\n\n        // Return the constructed transaction data.\n        tx = MakeTransactionRef(std::move(txNew));\n\n        // Limit size\n        if (GetTransactionWeight(*tx) >= MAX_STANDARD_TX_WEIGHT)\n        {\n            strFailReason = _(\"Transaction too large\");\n            return false;\n        }\n    }\n\n    if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n        // Lastly, ensure this tx will pass the mempool's chain limits\n        LockPoints lp;\n        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n        CTxMemPool::setEntries setAncestors;\n        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n        std::string errString;\n        if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n            strFailReason = _(\"Transaction has too long of a mempool chain\");\n            return false;\n        }\n    }\n\n    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n              nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n              feeCalc.est.pass.start, feeCalc.est.pass.end,\n              100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),\n              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n              feeCalc.est.fail.start, feeCalc.est.fail.end,\n              100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool),\n              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n    return true;\n}\n\n/**\n * Call after CreateTransaction unless you want to abort\n */\nbool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n\n        CWalletTx wtxNew(this, std::move(tx));\n        wtxNew.mapValue = std::move(mapValue);\n        wtxNew.vOrderForm = std::move(orderForm);\n        wtxNew.strFromAccount = std::move(fromAccount);\n        wtxNew.fTimeReceivedIsTxTime = true;\n        wtxNew.fFromMe = true;\n\n        LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.tx->ToString());\n        {\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Notify that old coins are spent\n            for (const CTxIn& txin : wtxNew.tx->vin)\n            {\n                CWalletTx &coin = mapWallet.at(txin.prevout.hash);\n                coin.BindWallet(this);\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Get the inserted-CWalletTx from mapWallet so that the\n        // fInMempool flag is cached properly\n        CWalletTx& wtx = mapWallet.at(wtxNew.GetHash());\n\n        if (fBroadcastTransactions)\n        {\n            // Broadcast\n            if (!wtx.AcceptToMemoryPool(maxTxFee, state)) {\n                LogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", FormatStateMessage(state));\n                // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n            } else {\n                wtx.RelayWalletTransaction(connman);\n            }\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries) {\n    CWalletDB walletdb(*dbw);\n    return walletdb.ListAccountCreditDebit(strAccount, entries);\n}\n\nbool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)\n{\n    CWalletDB walletdb(*dbw);\n\n    return AddAccountingEntry(acentry, &walletdb);\n}\n\nbool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwalletdb)\n{\n    if (!pwalletdb->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {\n        return false;\n    }\n\n    laccentries.push_back(acentry);\n    CAccountingEntry & entry = laccentries.back();\n    wtxOrdered.insert(std::make_pair(entry.nOrderPos, TxPair(nullptr, &entry)));\n\n    return true;\n}\n\nDBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    LOCK2(cs_main, cs_wallet);\n\n    fFirstRunRet = false;\n    DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (dbw->Rewrite(\"\\x04pool\"))\n        {\n            setInternalKeyPool.clear();\n            setExternalKeyPool.clear();\n            m_pool_key_to_index.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // that requires a new key.\n        }\n    }\n\n    // This wallet is in its first run if all of these are empty\n    fFirstRunRet = mapKeys.empty() && mapCryptedKeys.empty() && mapWatchKeys.empty() && setWatchOnly.empty() && mapScripts.empty();\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n\n    uiInterface.LoadWallet(this);\n\n    return DB_LOAD_OK;\n}\n\nDBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n{\n    AssertLockHeld(cs_wallet); // mapWallet\n    DBErrors nZapSelectTxRet = CWalletDB(*dbw,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n    for (uint256 hash : vHashOut)\n        mapWallet.erase(hash);\n\n    if (nZapSelectTxRet == DB_NEED_REWRITE)\n    {\n        if (dbw->Rewrite(\"\\x04pool\"))\n        {\n            setInternalKeyPool.clear();\n            setExternalKeyPool.clear();\n            m_pool_key_to_index.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // that requires a new key.\n        }\n    }\n\n    if (nZapSelectTxRet != DB_LOAD_OK)\n        return nZapSelectTxRet;\n\n    MarkDirty();\n\n    return DB_LOAD_OK;\n\n}\n\nDBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n{\n    DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n    if (nZapWalletTxRet == DB_NEED_REWRITE)\n    {\n        if (dbw->Rewrite(\"\\x04pool\"))\n        {\n            LOCK(cs_wallet);\n            setInternalKeyPool.clear();\n            setExternalKeyPool.clear();\n            m_pool_key_to_index.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // that requires a new key.\n        }\n    }\n\n    if (nZapWalletTxRet != DB_LOAD_OK)\n        return nZapWalletTxRet;\n\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& strPurpose)\n{\n    bool fUpdated = false;\n    {\n        LOCK(cs_wallet); // mapAddressBook\n        std::map<CTxDestination, CAddressBookData>::iterator mi = mapAddressBook.find(address);\n        fUpdated = mi != mapAddressBook.end();\n        mapAddressBook[address].name = strName;\n        if (!strPurpose.empty()) /* update purpose only if requested */\n            mapAddressBook[address].purpose = strPurpose;\n    }\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n                             strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n    if (!strPurpose.empty() && !CWalletDB(*dbw).WritePurpose(EncodeDestination(address), strPurpose))\n        return false;\n    return CWalletDB(*dbw).WriteName(EncodeDestination(address), strName);\n}\n\nbool CWallet::DelAddressBook(const CTxDestination& address)\n{\n    {\n        LOCK(cs_wallet); // mapAddressBook\n\n        // Delete destdata tuples associated with address\n        std::string strAddress = EncodeDestination(address);\n        for (const std::pair<std::string, std::string> &item : mapAddressBook[address].destdata)\n        {\n            CWalletDB(*dbw).EraseDestData(strAddress, item.first);\n        }\n        mapAddressBook.erase(address);\n    }\n\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n\n    CWalletDB(*dbw).ErasePurpose(EncodeDestination(address));\n    return CWalletDB(*dbw).EraseName(EncodeDestination(address));\n}\n\nconst std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n{\n    CTxDestination address;\n    if (ExtractDestination(scriptPubKey, address) && !scriptPubKey.IsUnspendable()) {\n        auto mi = mapAddressBook.find(address);\n        if (mi != mapAddressBook.end()) {\n            return mi->second.name;\n        }\n    }\n    // A scriptPubKey that doesn't have an entry in the address book is\n    // associated with the default account (\"\").\n    const static std::string DEFAULT_ACCOUNT_NAME;\n    return DEFAULT_ACCOUNT_NAME;\n}\n\n/**\n * Mark old keypool keys as used,\n * and generate all new keys\n */\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(*dbw);\n\n        for (int64_t nIndex : setInternalKeyPool) {\n            walletdb.ErasePool(nIndex);\n        }\n        setInternalKeyPool.clear();\n\n        for (int64_t nIndex : setExternalKeyPool) {\n            walletdb.ErasePool(nIndex);\n        }\n        setExternalKeyPool.clear();\n\n        m_pool_key_to_index.clear();\n\n        if (!TopUpKeyPool()) {\n            return false;\n        }\n        LogPrintf(\"CWallet::NewKeyPool rewrote keypool\\n\");\n    }\n    return true;\n}\n\nsize_t CWallet::KeypoolCountExternalKeys()\n{\n    AssertLockHeld(cs_wallet); // setExternalKeyPool\n    return setExternalKeyPool.size();\n}\n\nvoid CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n{\n    AssertLockHeld(cs_wallet);\n    if (keypool.fInternal) {\n        setInternalKeyPool.insert(nIndex);\n    } else {\n        setExternalKeyPool.insert(nIndex);\n    }\n    m_max_keypool_index = std::max(m_max_keypool_index, nIndex);\n    m_pool_key_to_index[keypool.vchPubKey.GetID()] = nIndex;\n\n    // If no metadata exists yet, create a default with the pool key's\n    // creation time. Note that this may be overwritten by actually\n    // stored metadata for that key later, which is fine.\n    CKeyID keyid = keypool.vchPubKey.GetID();\n    if (mapKeyMetadata.count(keyid) == 0)\n        mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n}\n\nbool CWallet::TopUpKeyPool(unsigned int kpSize)\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        // Top up key pool\n        unsigned int nTargetSize;\n        if (kpSize > 0)\n            nTargetSize = kpSize;\n        else\n            nTargetSize = std::max(gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n\n        // count amount of available keys (internal, external)\n        // make sure the keypool of external and internal keys fits the user selected target (-keypool)\n        int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setExternalKeyPool.size(), (int64_t) 0);\n        int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setInternalKeyPool.size(), (int64_t) 0);\n\n        if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n        {\n            // don't create extra internal keys\n            missingInternal = 0;\n        }\n        bool internal = false;\n        CWalletDB walletdb(*dbw);\n        for (int64_t i = missingInternal + missingExternal; i--;)\n        {\n            if (i < missingInternal) {\n                internal = true;\n            }\n\n            assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n            int64_t index = ++m_max_keypool_index;\n\n            CPubKey pubkey(GenerateNewKey(walletdb, internal));\n            if (!walletdb.WritePool(index, CKeyPool(pubkey, internal))) {\n                throw std::runtime_error(std::string(__func__) + \": writing generated key failed\");\n            }\n\n            if (internal) {\n                setInternalKeyPool.insert(index);\n            } else {\n                setExternalKeyPool.insert(index);\n            }\n            m_pool_key_to_index[pubkey.GetID()] = index;\n        }\n        if (missingInternal + missingExternal > 0) {\n            LogPrintf(\"keypool added %d keys (%d internal), size=%u (%u internal)\\n\", missingInternal + missingExternal, missingInternal, setInternalKeyPool.size() + setExternalKeyPool.size(), setInternalKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        bool fReturningInternal = IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT) && fRequestedInternal;\n        std::set<int64_t>& setKeyPool = fReturningInternal ? setInternalKeyPool : setExternalKeyPool;\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(*dbw);\n\n        auto it = setKeyPool.begin();\n        nIndex = *it;\n        setKeyPool.erase(it);\n        if (!walletdb.ReadPool(nIndex, keypool)) {\n            throw std::runtime_error(std::string(__func__) + \": read failed\");\n        }\n        if (!HaveKey(keypool.vchPubKey.GetID())) {\n            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n        }\n        if (keypool.fInternal != fReturningInternal) {\n            throw std::runtime_error(std::string(__func__) + \": keypool entry misclassified\");\n        }\n\n        assert(keypool.vchPubKey.IsValid());\n        m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n        LogPrintf(\"keypool reserve %d\\n\", nIndex);\n    }\n}\n\nvoid CWallet::KeepKey(int64_t nIndex)\n{\n    // Remove from key pool\n    CWalletDB walletdb(*dbw);\n    walletdb.ErasePool(nIndex);\n    LogPrintf(\"keypool keep %d\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        if (fInternal) {\n            setInternalKeyPool.insert(nIndex);\n        } else {\n            setExternalKeyPool.insert(nIndex);\n        }\n        m_pool_key_to_index[pubkey.GetID()] = nIndex;\n    }\n    LogPrintf(\"keypool return %d\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n{\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        int64_t nIndex = 0;\n        ReserveKeyFromKeyPool(nIndex, keypool, internal);\n        if (nIndex == -1)\n        {\n            if (IsLocked()) return false;\n            CWalletDB walletdb(*dbw);\n            result = GenerateNewKey(walletdb, internal);\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nstatic int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, CWalletDB& walletdb) {\n    if (setKeyPool.empty()) {\n        return GetTime();\n    }\n\n    CKeyPool keypool;\n    int64_t nIndex = *(setKeyPool.begin());\n    if (!walletdb.ReadPool(nIndex, keypool)) {\n        throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n    }\n    assert(keypool.vchPubKey.IsValid());\n    return keypool.nTime;\n}\n\nint64_t CWallet::GetOldestKeyPoolTime()\n{\n    LOCK(cs_wallet);\n\n    CWalletDB walletdb(*dbw);\n\n    // load oldest key from keypool, get time and return\n    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, walletdb);\n    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, walletdb), oldestKey);\n    }\n\n    return oldestKey;\n}\n\nstd::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n{\n    std::map<CTxDestination, CAmount> balances;\n\n    {\n        LOCK(cs_wallet);\n        for (const auto& walletEntry : mapWallet)\n        {\n            const CWalletTx *pcoin = &walletEntry.second;\n\n            if (!pcoin->IsTrusted())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? 0 : 1))\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++)\n            {\n                CTxDestination addr;\n                if (!IsMine(pcoin->tx->vout[i]))\n                    continue;\n                if(!ExtractDestination(pcoin->tx->vout[i].scriptPubKey, addr))\n                    continue;\n\n                CAmount n = IsSpent(walletEntry.first, i) ? 0 : pcoin->tx->vout[i].nValue;\n\n                if (!balances.count(addr))\n                    balances[addr] = 0;\n                balances[addr] += n;\n            }\n        }\n    }\n\n    return balances;\n}\n\nstd::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n{\n    AssertLockHeld(cs_wallet); // mapWallet\n    std::set< std::set<CTxDestination> > groupings;\n    std::set<CTxDestination> grouping;\n\n    for (const auto& walletEntry : mapWallet)\n    {\n        const CWalletTx *pcoin = &walletEntry.second;\n\n        if (pcoin->tx->vin.size() > 0)\n        {\n            bool any_mine = false;\n            // group all input addresses with each other\n            for (CTxIn txin : pcoin->tx->vin)\n            {\n                CTxDestination address;\n                if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n                    continue;\n                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                any_mine = true;\n            }\n\n            // group change with input addresses\n            if (any_mine)\n            {\n               for (CTxOut txout : pcoin->tx->vout)\n                   if (IsChange(txout))\n                   {\n                       CTxDestination txoutAddr;\n                       if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                           continue;\n                       grouping.insert(txoutAddr);\n                   }\n            }\n            if (grouping.size() > 0)\n            {\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n        }\n\n        // group lone addrs by themselves\n        for (const auto& txout : pcoin->tx->vout)\n            if (IsMine(txout))\n            {\n                CTxDestination address;\n                if(!ExtractDestination(txout.scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n    }\n\n    std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n    std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n    for (std::set<CTxDestination> _grouping : groupings)\n    {\n        // make a set of all the groups hit by this new group\n        std::set< std::set<CTxDestination>* > hits;\n        std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n        for (CTxDestination address : _grouping)\n            if ((it = setmap.find(address)) != setmap.end())\n                hits.insert((*it).second);\n\n        // merge all hit groups into a new single group and delete old groups\n        std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n        for (std::set<CTxDestination>* hit : hits)\n        {\n            merged->insert(hit->begin(), hit->end());\n            uniqueGroupings.erase(hit);\n            delete hit;\n        }\n        uniqueGroupings.insert(merged);\n\n        // update setmap\n        for (CTxDestination element : *merged)\n            setmap[element] = merged;\n    }\n\n    std::set< std::set<CTxDestination> > ret;\n    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)\n    {\n        ret.insert(*uniqueGrouping);\n        delete uniqueGrouping;\n    }\n\n    return ret;\n}\n\nstd::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n{\n    LOCK(cs_wallet);\n    std::set<CTxDestination> result;\n    for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n    {\n        const CTxDestination& address = item.first;\n        const std::string& strName = item.second.name;\n        if (strName == strAccount)\n            result.insert(address);\n    }\n    return result;\n}\n\nbool CReserveKey::GetReservedKey(CPubKey& pubkey, bool internal)\n{\n    if (nIndex == -1)\n    {\n        CKeyPool keypool;\n        pwallet->ReserveKeyFromKeyPool(nIndex, keypool, internal);\n        if (nIndex != -1)\n            vchPubKey = keypool.vchPubKey;\n        else {\n            return false;\n        }\n        fInternal = keypool.fInternal;\n    }\n    assert(vchPubKey.IsValid());\n    pubkey = vchPubKey;\n    return true;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1) {\n        pwallet->ReturnKey(nIndex, fInternal, vchPubKey);\n    }\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n{\n    AssertLockHeld(cs_wallet);\n    bool internal = setInternalKeyPool.count(keypool_id);\n    if (!internal) assert(setExternalKeyPool.count(keypool_id));\n    std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : &setExternalKeyPool;\n    auto it = setKeyPool->begin();\n\n    CWalletDB walletdb(*dbw);\n    while (it != std::end(*setKeyPool)) {\n        const int64_t& index = *(it);\n        if (index > keypool_id) break; // set*KeyPool is ordered\n\n        CKeyPool keypool;\n        if (walletdb.ReadPool(index, keypool)) { //TODO: This should be unnecessary\n            m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n        }\n        LearnAllRelatedScripts(keypool.vchPubKey);\n        walletdb.ErasePool(index);\n        LogPrintf(\"keypool index %d removed\\n\", index);\n        it = setKeyPool->erase(it);\n    }\n}\n\nvoid CWallet::GetScriptForMining(std::shared_ptr<CReserveScript> &script)\n{\n    std::shared_ptr<CReserveKey> rKey = std::make_shared<CReserveKey>(this);\n    CPubKey pubkey;\n    if (!rKey->GetReservedKey(pubkey))\n        return;\n\n    script = rKey;\n    script->reserveScript = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n}\n\nvoid CWallet::LockCoin(const COutPoint& output)\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    setLockedCoins.insert(output);\n}\n\nvoid CWallet::UnlockCoin(const COutPoint& output)\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    setLockedCoins.erase(output);\n}\n\nvoid CWallet::UnlockAllCoins()\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    setLockedCoins.clear();\n}\n\nbool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    COutPoint outpt(hash, n);\n\n    return (setLockedCoins.count(outpt) > 0);\n}\n\nvoid CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n{\n    AssertLockHeld(cs_wallet); // setLockedCoins\n    for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n         it != setLockedCoins.end(); it++) {\n        COutPoint outpt = (*it);\n        vOutpts.push_back(outpt);\n    }\n}\n\n/** @} */ // end of Actions\n\nvoid CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) const {\n    AssertLockHeld(cs_wallet); // mapKeyMetadata\n    mapKeyBirth.clear();\n\n    // get birth times for keys with metadata\n    for (const auto& entry : mapKeyMetadata) {\n        if (entry.second.nCreateTime) {\n            mapKeyBirth[entry.first] = entry.second.nCreateTime;\n        }\n    }\n\n    // map in which we'll infer heights of other keys\n    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n    for (const CKeyID &keyid : GetKeys()) {\n        if (mapKeyBirth.count(keyid) == 0)\n            mapKeyFirstBlock[keyid] = pindexMax;\n    }\n\n    // if there are no such keys, we're done\n    if (mapKeyFirstBlock.empty())\n        return;\n\n    // find first block that affects those keys, if there are any left\n    std::vector<CKeyID> vAffected;\n    for (const auto& entry : mapWallet) {\n        // iterate over all wallet transactions...\n        const CWalletTx &wtx = entry.second;\n        CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n        if (pindex && chainActive.Contains(pindex)) {\n            // ... which are already in a block\n            int nHeight = pindex->nHeight;\n            for (const CTxOut &txout : wtx.tx->vout) {\n                // iterate over all their outputs\n                CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n                for (const CKeyID &keyid : vAffected) {\n                    // ... and all their affected keys\n                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                        rit->second = pindex;\n                }\n                vAffected.clear();\n            }\n        }\n    }\n\n    // Extract block timestamps for those keys\n    for (const auto& entry : mapKeyFirstBlock)\n        mapKeyBirth[entry.first] = entry.second->GetBlockTime() - TIMESTAMP_WINDOW; // block times can be 2h off\n}\n\n/**\n * Compute smart timestamp for a transaction being added to the wallet.\n *\n * Logic:\n * - If sending a transaction, assign its timestamp to the current time.\n * - If receiving a transaction outside a block, assign its timestamp to the\n *   current time.\n * - If receiving a block with a future timestamp, assign all its (not already\n *   known) transactions' timestamps to the current time.\n * - If receiving a block with a past timestamp, before the most recent known\n *   transaction (that we care about), assign all its (not already known)\n *   transactions' timestamps to the same timestamp as that most-recent-known\n *   transaction.\n * - If receiving a block with a past timestamp, but after the most recent known\n *   transaction, assign all its (not already known) transactions' timestamps to\n *   the block time.\n *\n * For more information see CWalletTx::nTimeSmart,\n * https://bitcointalk.org/?topic=54527, or\n * https://github.com/bitcoin/bitcoin/pull/1393.\n */\nunsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n{\n    unsigned int nTimeSmart = wtx.nTimeReceived;\n    if (!wtx.hashUnset()) {\n        if (const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock)) {\n            int64_t latestNow = wtx.nTimeReceived;\n            int64_t latestEntry = 0;\n\n            // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n            int64_t latestTolerated = latestNow + 300;\n            const TxItems& txOrdered = wtxOrdered;\n            for (auto it = txOrdered.rbegin(); it != txOrdered.rend(); ++it) {\n                CWalletTx* const pwtx = it->second.first;\n                if (pwtx == &wtx) {\n                    continue;\n                }\n                CAccountingEntry* const pacentry = it->second.second;\n                int64_t nSmartTime;\n                if (pwtx) {\n                    nSmartTime = pwtx->nTimeSmart;\n                    if (!nSmartTime) {\n                        nSmartTime = pwtx->nTimeReceived;\n                    }\n                } else {\n                    nSmartTime = pacentry->nTime;\n                }\n                if (nSmartTime <= latestTolerated) {\n                    latestEntry = nSmartTime;\n                    if (nSmartTime > latestNow) {\n                        latestNow = nSmartTime;\n                    }\n                    break;\n                }\n            }\n\n            int64_t blocktime = pindex->GetBlockTime();\n            nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n        } else {\n            LogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.hashBlock.ToString());\n        }\n    }\n    return nTimeSmart;\n}\n\nbool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, const std::string &value)\n{\n    if (boost::get<CNoDestination>(&dest))\n        return false;\n\n    mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n    return CWalletDB(*dbw).WriteDestData(EncodeDestination(dest), key, value);\n}\n\nbool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n{\n    if (!mapAddressBook[dest].destdata.erase(key))\n        return false;\n    return CWalletDB(*dbw).EraseDestData(EncodeDestination(dest), key);\n}\n\nbool CWallet::LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value)\n{\n    mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n    return true;\n}\n\nbool CWallet::GetDestData(const CTxDestination &dest, const std::string &key, std::string *value) const\n{\n    std::map<CTxDestination, CAddressBookData>::const_iterator i = mapAddressBook.find(dest);\n    if(i != mapAddressBook.end())\n    {\n        CAddressBookData::StringMap::const_iterator j = i->second.destdata.find(key);\n        if(j != i->second.destdata.end())\n        {\n            if(value)\n                *value = j->second;\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::vector<std::string> CWallet::GetDestValues(const std::string& prefix) const\n{\n    LOCK(cs_wallet);\n    std::vector<std::string> values;\n    for (const auto& address : mapAddressBook) {\n        for (const auto& data : address.second.destdata) {\n            if (!data.first.compare(0, prefix.size(), prefix)) {\n                values.emplace_back(data.second);\n            }\n        }\n    }\n    return values;\n}\n\nCWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path& path)\n{\n    const std::string& walletFile = name;\n\n    // needed to restore wallet transaction meta data after -zapwallettxes\n    std::vector<CWalletTx> vWtx;\n\n    if (gArgs.GetBoolArg(\"-zapwallettxes\", false)) {\n        uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n\n        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, CWalletDBWrapper::Create(path));\n        DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n        if (nZapWalletRet != DB_LOAD_OK) {\n            InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n            return nullptr;\n        }\n    }\n\n    uiInterface.InitMessage(_(\"Loading wallet...\"));\n\n    int64_t nStart = GetTimeMillis();\n    bool fFirstRun = true;\n    CWallet *walletInstance = new CWallet(name, CWalletDBWrapper::Create(path));\n    DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n    if (nLoadWalletRet != DB_LOAD_OK)\n    {\n        if (nLoadWalletRet == DB_CORRUPT) {\n            InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n            return nullptr;\n        }\n        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n        {\n            InitWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n                                         \" or address book entries might be missing or incorrect.\"),\n                walletFile));\n        }\n        else if (nLoadWalletRet == DB_TOO_NEW) {\n            InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n            return nullptr;\n        }\n        else if (nLoadWalletRet == DB_NEED_REWRITE)\n        {\n            InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n            return nullptr;\n        }\n        else {\n            InitError(strprintf(_(\"Error loading %s\"), walletFile));\n            return nullptr;\n        }\n    }\n\n    if (gArgs.GetBoolArg(\"-upgradewallet\", fFirstRun))\n    {\n        int nMaxVersion = gArgs.GetArg(\"-upgradewallet\", 0);\n        if (nMaxVersion == 0) // the -upgradewallet without argument case\n        {\n            LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n            nMaxVersion = CLIENT_VERSION;\n            walletInstance->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n        }\n        else\n            LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n        if (nMaxVersion < walletInstance->GetVersion())\n        {\n            InitError(_(\"Cannot downgrade wallet\"));\n            return nullptr;\n        }\n        walletInstance->SetMaxVersion(nMaxVersion);\n    }\n\n    if (fFirstRun)\n    {\n        // ensure this wallet.dat can only be opened by clients supporting HD with chain split and expects no default key\n        if (!gArgs.GetBoolArg(\"-usehd\", true)) {\n            InitError(strprintf(_(\"Error creating %s: You can't create non-HD wallets with this version.\"), walletFile));\n            return nullptr;\n        }\n        walletInstance->SetMinVersion(FEATURE_NO_DEFAULT_KEY);\n\n        // generate a new master key\n        CPubKey masterPubKey = walletInstance->GenerateNewHDMasterKey();\n        if (!walletInstance->SetHDMasterKey(masterPubKey))\n            throw std::runtime_error(std::string(__func__) + \": Storing master key failed\");\n\n        // Top up the keypool\n        if (!walletInstance->TopUpKeyPool()) {\n            InitError(_(\"Unable to generate initial keys\") += \"\\n\");\n            return nullptr;\n        }\n\n        walletInstance->SetBestChain(chainActive.GetLocator());\n    } else if (gArgs.IsArgSet(\"-usehd\")) {\n        bool useHD = gArgs.GetBoolArg(\"-usehd\", true);\n        if (walletInstance->IsHDEnabled() && !useHD) {\n            InitError(strprintf(_(\"Error loading %s: You can't disable HD on an already existing HD wallet\"), walletFile));\n            return nullptr;\n        }\n        if (!walletInstance->IsHDEnabled() && useHD) {\n            InitError(strprintf(_(\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"), walletFile));\n            return nullptr;\n        }\n    }\n\n    walletInstance->m_default_address_type = ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"), DEFAULT_ADDRESS_TYPE);\n    if (walletInstance->m_default_address_type == OutputType::NONE) {\n        InitError(strprintf(\"Unknown address type '%s'\", gArgs.GetArg(\"-addresstype\", \"\")));\n        return nullptr;\n    }\n\n    // If changetype is set in config file or parameter, check that it's valid.\n    // Default to OutputType::NONE if not set.\n    walletInstance->m_default_change_type = ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"), OutputType::NONE);\n    if (walletInstance->m_default_change_type == OutputType::NONE && !gArgs.GetArg(\"-changetype\", \"\").empty()) {\n        InitError(strprintf(\"Unknown change type '%s'\", gArgs.GetArg(\"-changetype\", \"\")));\n        return nullptr;\n    }\n\n    LogPrintf(\" wallet      %15dms\\n\", GetTimeMillis() - nStart);\n\n    // Try to top up keypool. No-op if the wallet is locked.\n    walletInstance->TopUpKeyPool();\n\n    LOCK(cs_main);\n\n    CBlockIndex *pindexRescan = chainActive.Genesis();\n    if (!gArgs.GetBoolArg(\"-rescan\", false))\n    {\n        CWalletDB walletdb(*walletInstance->dbw);\n        CBlockLocator locator;\n        if (walletdb.ReadBestBlock(locator))\n            pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n    }\n\n    walletInstance->m_last_block_processed = chainActive.Tip();\n    RegisterValidationInterface(walletInstance);\n\n    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n    {\n        //We can't rescan beyond non-pruned blocks, stop and throw an error\n        //this might happen if a user uses an old wallet within a pruned node\n        // or if he ran -disablewallet for a longer time, then decided to re-enable\n        if (fPruneMode)\n        {\n            CBlockIndex *block = chainActive.Tip();\n            while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n                block = block->pprev;\n\n            if (pindexRescan != block) {\n                InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n                return nullptr;\n            }\n        }\n\n        uiInterface.InitMessage(_(\"Rescanning...\"));\n        LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n\n        // No need to read and scan block if block was created before\n        // our wallet birthday (as adjusted for block time variability)\n        while (pindexRescan && walletInstance->nTimeFirstKey && (pindexRescan->GetBlockTime() < (walletInstance->nTimeFirstKey - TIMESTAMP_WINDOW))) {\n            pindexRescan = chainActive.Next(pindexRescan);\n        }\n\n        nStart = GetTimeMillis();\n        {\n            WalletRescanReserver reserver(walletInstance);\n            if (!reserver.reserve()) {\n                InitError(_(\"Failed to rescan the wallet during initialization\"));\n                return nullptr;\n            }\n            walletInstance->ScanForWalletTransactions(pindexRescan, nullptr, reserver, true);\n        }\n        LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n        walletInstance->SetBestChain(chainActive.GetLocator());\n        walletInstance->dbw->IncrementUpdateCounter();\n\n        // Restore wallet transaction metadata after -zapwallettxes=1\n        if (gArgs.GetBoolArg(\"-zapwallettxes\", false) && gArgs.GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n        {\n            CWalletDB walletdb(*walletInstance->dbw);\n\n            for (const CWalletTx& wtxOld : vWtx)\n            {\n                uint256 hash = wtxOld.GetHash();\n                std::map<uint256, CWalletTx>::iterator mi = walletInstance->mapWallet.find(hash);\n                if (mi != walletInstance->mapWallet.end())\n                {\n                    const CWalletTx* copyFrom = &wtxOld;\n                    CWalletTx* copyTo = &mi->second;\n                    copyTo->mapValue = copyFrom->mapValue;\n                    copyTo->vOrderForm = copyFrom->vOrderForm;\n                    copyTo->nTimeReceived = copyFrom->nTimeReceived;\n                    copyTo->nTimeSmart = copyFrom->nTimeSmart;\n                    copyTo->fFromMe = copyFrom->fFromMe;\n                    copyTo->strFromAccount = copyFrom->strFromAccount;\n                    copyTo->nOrderPos = copyFrom->nOrderPos;\n                    walletdb.WriteTx(*copyTo);\n                }\n            }\n        }\n    }\n    walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n\n    {\n        LOCK(walletInstance->cs_wallet);\n        LogPrintf(\"setKeyPool.size() = %u\\n\",      walletInstance->GetKeyPoolSize());\n        LogPrintf(\"mapWallet.size() = %u\\n\",       walletInstance->mapWallet.size());\n        LogPrintf(\"mapAddressBook.size() = %u\\n\",  walletInstance->mapAddressBook.size());\n    }\n\n    return walletInstance;\n}\n\nstd::atomic<bool> CWallet::fFlushScheduled(false);\n\nvoid CWallet::postInitProcess(CScheduler& scheduler)\n{\n    // Add wallet transactions that aren't already in a block to mempool\n    // Do this here as mempool requires genesis block to be loaded\n    ReacceptWalletTransactions();\n\n    // Run a thread to flush wallet periodically\n    if (!CWallet::fFlushScheduled.exchange(true)) {\n        scheduler.scheduleEvery(MaybeCompactWalletDB, 500);\n    }\n}\n\nbool CWallet::BackupWallet(const std::string& strDest)\n{\n    return dbw->Backup(strDest);\n}\n\nCKeyPool::CKeyPool()\n{\n    nTime = GetTime();\n    fInternal = false;\n}\n\nCKeyPool::CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn)\n{\n    nTime = GetTime();\n    vchPubKey = vchPubKeyIn;\n    fInternal = internalIn;\n}\n\nCWalletKey::CWalletKey(int64_t nExpires)\n{\n    nTimeCreated = (nExpires ? GetTime() : 0);\n    nTimeExpires = nExpires;\n}\n\nvoid CMerkleTx::SetMerkleBranch(const CBlockIndex* pindex, int posInBlock)\n{\n    // Update the tx's hashBlock\n    hashBlock = pindex->GetBlockHash();\n\n    // set the position of the transaction in the block\n    nIndex = posInBlock;\n}\n\nint CMerkleTx::GetDepthInMainChain(const CBlockIndex* &pindexRet) const\n{\n    if (hashUnset())\n        return 0;\n\n    AssertLockHeld(cs_main);\n\n    // Find the block it claims to be in\n    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n    if (!pindex || !chainActive.Contains(pindex))\n        return 0;\n\n    pindexRet = pindex;\n    return ((nIndex == -1) ? (-1) : 1) * (chainActive.Height() - pindex->nHeight + 1);\n}\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!IsCoinBase())\n        return 0;\n    return std::max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n}\n\n\nbool CWalletTx::AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state)\n{\n    // We must set fInMempool here - while it will be re-set to true by the\n    // entered-mempool callback, if we did not there would be a race where a\n    // user could call sendmoney in a loop and hit spurious out of funds errors\n    // because we think that the transaction they just generated's change is\n    // unavailable as we're not yet aware its in mempool.\n    bool ret = ::AcceptToMemoryPool(mempool, state, tx, nullptr /* pfMissingInputs */,\n                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nAbsurdFee);\n    fInMempool |= ret;\n    return ret;\n}\n\nstatic const std::string OUTPUT_TYPE_STRING_LEGACY = \"legacy\";\nstatic const std::string OUTPUT_TYPE_STRING_P2SH_SEGWIT = \"p2sh-segwit\";\nstatic const std::string OUTPUT_TYPE_STRING_BECH32 = \"bech32\";\n\nOutputType ParseOutputType(const std::string& type, OutputType default_type)\n{\n    if (type.empty()) {\n        return default_type;\n    } else if (type == OUTPUT_TYPE_STRING_LEGACY) {\n        return OutputType::LEGACY;\n    } else if (type == OUTPUT_TYPE_STRING_P2SH_SEGWIT) {\n        return OutputType::P2SH_SEGWIT;\n    } else if (type == OUTPUT_TYPE_STRING_BECH32) {\n        return OutputType::BECH32;\n    } else {\n        return OutputType::NONE;\n    }\n}\n\nconst std::string& FormatOutputType(OutputType type)\n{\n    switch (type) {\n    case OutputType::LEGACY: return OUTPUT_TYPE_STRING_LEGACY;\n    case OutputType::P2SH_SEGWIT: return OUTPUT_TYPE_STRING_P2SH_SEGWIT;\n    case OutputType::BECH32: return OUTPUT_TYPE_STRING_BECH32;\n    default: assert(false);\n    }\n}\n\nvoid CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n{\n    if (key.IsCompressed() && (type == OutputType::P2SH_SEGWIT || type == OutputType::BECH32)) {\n        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n        CScript witprog = GetScriptForDestination(witdest);\n        // Make sure the resulting program is solvable.\n        assert(IsSolvable(*this, witprog));\n        AddCScript(witprog);\n    }\n}\n\nvoid CWallet::LearnAllRelatedScripts(const CPubKey& key)\n{\n    // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.\n    LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n}\n\nCTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)\n{\n    switch (type) {\n    case OutputType::LEGACY: return key.GetID();\n    case OutputType::P2SH_SEGWIT:\n    case OutputType::BECH32: {\n        if (!key.IsCompressed()) return key.GetID();\n        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n        CScript witprog = GetScriptForDestination(witdest);\n        if (type == OutputType::P2SH_SEGWIT) {\n            return CScriptID(witprog);\n        } else {\n            return witdest;\n        }\n    }\n    default: assert(false);\n    }\n}\n\nstd::vector<CTxDestination> GetAllDestinationsForKey(const CPubKey& key)\n{\n    CKeyID keyid = key.GetID();\n    if (key.IsCompressed()) {\n        CTxDestination segwit = WitnessV0KeyHash(keyid);\n        CTxDestination p2sh = CScriptID(GetScriptForDestination(segwit));\n        return std::vector<CTxDestination>{std::move(keyid), std::move(p2sh), std::move(segwit)};\n    } else {\n        return std::vector<CTxDestination>{std::move(keyid)};\n    }\n}\n\nCTxDestination CWallet::AddAndGetDestinationForScript(const CScript& script, OutputType type)\n{\n    // Note that scripts over 520 bytes are not yet supported.\n    switch (type) {\n    case OutputType::LEGACY:\n        return CScriptID(script);\n    case OutputType::P2SH_SEGWIT:\n    case OutputType::BECH32: {\n        WitnessV0ScriptHash hash;\n        CSHA256().Write(script.data(), script.size()).Finalize(hash.begin());\n        CTxDestination witdest = hash;\n        CScript witprog = GetScriptForDestination(witdest);\n        // Check if the resulting program is solvable (i.e. doesn't use an uncompressed key)\n        if (!IsSolvable(*this, witprog)) return CScriptID(script);\n        // Add the redeemscript, so that P2WSH and P2SH-P2WSH outputs are recognized as ours.\n        AddCScript(witprog);\n        if (type == OutputType::BECH32) {\n            return witdest;\n        } else {\n            return CScriptID(witprog);\n        }\n    }\n    default: assert(false);\n    }\n}\n"], "filenames": ["src/wallet/wallet.cpp"], "buggy_code_start_loc": [2892], "buggy_code_end_loc": [3000], "fixing_code_start_loc": [2892], "fixing_code_end_loc": [3009], "type": "NVD-CWE-noinfo", "message": "An issue discovered in src/wallet/wallet.cpp in Dogecoin Project Dogecoin Core 1.14.3 and earlier allows attackers to view sensitive information via CWallet::CreateTransaction() function.", "other": {"cve": {"id": "CVE-2021-37491", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-07T14:15:08.557", "lastModified": "2023-02-15T16:49:50.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue discovered in src/wallet/wallet.cpp in Dogecoin Project Dogecoin Core 1.14.3 and earlier allows attackers to view sensitive information via CWallet::CreateTransaction() function."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dogecoin:dogecoin:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.14.3", "matchCriteriaId": "31BD7B9D-4B1F-4402-A7B2-C9121C00FDD1"}]}]}], "references": [{"url": "http://dogecoin.com", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/VPRLab/BlkVulnReport/blob/main/NDSS23_BlockScope.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description"]}, {"url": "https://github.com/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/dogecoin/dogecoin/blob/master/src/wallet/wallet.cpp#L2628-L2640", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/dogecoin/dogecoin/issues/2279", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3"}}