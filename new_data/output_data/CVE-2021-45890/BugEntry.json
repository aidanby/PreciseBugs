{"buggy_code": ["package com.nexblocks.authguard.basic;\n\nimport com.nexblocks.authguard.basic.passwords.SecurePassword;\nimport com.nexblocks.authguard.basic.passwords.SecurePasswordProvider;\nimport com.nexblocks.authguard.service.AccountsService;\nimport com.nexblocks.authguard.service.CredentialsService;\nimport com.nexblocks.authguard.service.exceptions.ServiceAuthorizationException;\nimport com.nexblocks.authguard.service.exceptions.ServiceException;\nimport com.nexblocks.authguard.service.exceptions.codes.ErrorCode;\nimport com.nexblocks.authguard.service.model.AccountBO;\nimport com.nexblocks.authguard.service.model.AuthRequestBO;\nimport com.nexblocks.authguard.service.model.CredentialsBO;\nimport com.nexblocks.authguard.service.model.EntityType;\nimport com.google.inject.Inject;\nimport io.vavr.control.Either;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Base64;\nimport java.util.Optional;\n\npublic class BasicAuthProvider {\n    private final Logger LOG = LoggerFactory.getLogger(BasicAuthProvider.class);\n\n    private final CredentialsService credentialsService;\n    private final AccountsService accountsService;\n    private final SecurePassword securePassword;\n\n    @Inject\n    public BasicAuthProvider(final CredentialsService credentialsService, final AccountsService accountsService,\n                             final SecurePasswordProvider securePasswordProvider) {\n        this.credentialsService = credentialsService;\n        this.securePassword = securePasswordProvider.get();\n        this.accountsService = accountsService;\n\n        LOG.debug(\"Initialized with password implementation {}\", this.securePassword.getClass());\n    }\n\n    public Either<Exception, AccountBO> authenticateAndGetAccount(final AuthRequestBO authRequest) {\n        return verifyCredentialsAndGetAccount(authRequest.getIdentifier(), authRequest.getPassword());\n    }\n\n    public Either<Exception, AccountBO> authenticateAndGetAccount(final String basicToken) {\n        return handleBasicAuthentication(basicToken);\n    }\n\n    public Either<Exception, AccountBO> getAccount(final AuthRequestBO request) {\n        return verifyCredentialsAndGetAccount(request.getIdentifier());\n    }\n\n    public Either<Exception, AccountBO> getAccount(final String basicToken) {\n        final String[] parts = TokensUtils.parseAuthorization(basicToken);\n\n        if (parts[0].equals(\"Basic\")) {\n            return handleBasicAuthenticationNoPassword(parts[1]);\n        } else {\n            throw new ServiceException(ErrorCode.UNSUPPORTED_SCHEME, \"Unsupported authorization scheme\");\n        }\n    }\n\n    private Either<Exception, AccountBO> handleBasicAuthentication(final String base64Credentials) {\n        final String[] decoded = new String(Base64.getDecoder().decode(base64Credentials)).split(\":\");\n\n        if (decoded.length != 2) {\n            throw new ServiceException(ErrorCode.INVALID_AUTHORIZATION_FORMAT, \"Invalid format for basic authentication\");\n        }\n\n        final String username =  decoded[0];\n        final String password = decoded[1];\n\n        return verifyCredentialsAndGetAccount(username, password);\n    }\n\n    private Either<Exception, AccountBO> handleBasicAuthenticationNoPassword(final String base64Credentials) {\n        final String[] decoded = new String(Base64.getDecoder().decode(base64Credentials)).split(\":\");\n\n        if (decoded.length != 1) {\n            return Either.left(new ServiceException(ErrorCode.INVALID_AUTHORIZATION_FORMAT, \"Invalid format for basic authentication\"));\n        }\n\n        final String username =  decoded[0];\n\n        return verifyCredentialsAndGetAccount(username);\n    }\n\n    private Either<Exception, AccountBO> verifyCredentialsAndGetAccount(final String username, final String password) {\n        final Optional<CredentialsBO> credentials = credentialsService.getByUsernameUnsafe(username);\n\n        if (credentials.isPresent()) {\n            if (securePassword.verify(password, credentials.get().getHashedPassword())) {\n                return getAccountById(credentials.get().getAccountId());\n            } else {\n                return Either.left(new ServiceAuthorizationException(ErrorCode.PASSWORDS_DO_NOT_MATCH,\n                        \"Passwords do not match\", EntityType.ACCOUNT, credentials.get().getAccountId()));\n            }\n        } else {\n            return Either.left(new ServiceAuthorizationException(ErrorCode.CREDENTIALS_DOES_NOT_EXIST,\n                    \"Identifier \" + username + \" does not exist\"));\n        }\n    }\n\n    private Either<Exception, AccountBO> verifyCredentialsAndGetAccount(final String username) {\n        final Optional<CredentialsBO> credentials = credentialsService.getByUsernameUnsafe(username);\n\n        if (credentials.isPresent()) {\n            return getAccountById(credentials.get().getAccountId());\n        } else {\n            return Either.left(new ServiceAuthorizationException(ErrorCode.CREDENTIALS_DOES_NOT_EXIST,\n                    \"Identifier \" + username + \" does not exist\"));\n        }\n    }\n\n    private Either<Exception, AccountBO> getAccountById(final String accountId) {\n        final Optional<AccountBO> account = accountsService.getById(accountId);\n\n        return account\n                .<Either<Exception, AccountBO>>map(Either::right)\n                .orElseGet(() -> Either.left(new ServiceAuthorizationException(ErrorCode.ACCOUNT_DOES_NOT_EXIST,\n                \"Account \" + accountId + \" does not exist\")));\n    }\n}\n", "package com.nexblocks.authguard.basic;\n\n\nimport com.nexblocks.authguard.basic.passwords.SecurePassword;\nimport com.nexblocks.authguard.basic.passwords.SecurePasswordProvider;\nimport com.nexblocks.authguard.service.AccountsService;\nimport com.nexblocks.authguard.service.CredentialsService;\nimport com.nexblocks.authguard.service.exceptions.ServiceAuthorizationException;\nimport com.nexblocks.authguard.service.exceptions.ServiceException;\nimport com.nexblocks.authguard.service.model.*;\nimport io.vavr.control.Either;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.jeasy.random.EasyRandom;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestInstance;\nimport org.mockito.Mockito;\n\nimport java.util.Base64;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.ArgumentMatchers.eq;\n\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass BasicAuthProviderTest {\n    private AccountsService accountsService;\n    private CredentialsService credentialsService;\n    private SecurePassword securePassword;\n\n    private BasicAuthProvider basicAuth;\n\n    private final static EasyRandom RANDOM = new EasyRandom();\n\n    @BeforeAll\n    void setup() {\n        accountsService = Mockito.mock(AccountsService.class);\n        credentialsService = Mockito.mock(CredentialsService.class);\n        securePassword = Mockito.mock(SecurePassword.class);\n\n        final SecurePasswordProvider securePasswordProvider = Mockito.mock(SecurePasswordProvider.class);\n\n        Mockito.when(securePasswordProvider.get()).thenReturn(securePassword);\n\n        basicAuth = new BasicAuthProvider(credentialsService, accountsService, securePasswordProvider);\n    }\n\n    @AfterEach\n    void resetMocks() {\n        Mockito.reset(accountsService);\n        Mockito.reset(credentialsService);\n    }\n\n    @Test\n    void authenticate() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        final AccountBO account = RANDOM.nextObject(AccountBO.class);\n        final CredentialsBO credentials = RANDOM.nextObject(CredentialsBO.class)\n                .withIdentifiers(UserIdentifierBO.builder()\n                        .identifier(username)\n                        .type(UserIdentifier.Type.USERNAME)\n                        .build());\n        final HashedPasswordBO hashedPasswordBO = HashedPasswordBO.builder()\n                .password(credentials.getHashedPassword().getPassword())\n                .salt(credentials.getHashedPassword().getSalt())\n                .build();\n\n        Mockito.when(credentialsService.getByUsernameUnsafe(username)).thenReturn(Optional.of(credentials));\n        Mockito.when(accountsService.getById(credentials.getAccountId())).thenReturn(Optional.of(account));\n        Mockito.when(securePassword.verify(eq(password), eq(hashedPasswordBO))).thenReturn(true);\n\n        final Either<Exception, AccountBO> result = basicAuth.authenticateAndGetAccount(authorization);\n\n        assertThat(result.get()).isEqualTo(account);\n    }\n\n    @Test\n    void authenticateNotFound() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        Mockito.when(credentialsService.getByUsername(username)).thenReturn(Optional.empty());\n\n        assertThat(basicAuth.authenticateAndGetAccount(authorization)).isEmpty();\n    }\n\n    @Test\n    void authenticateWrongPassword() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        final CredentialsBO credentials = RANDOM.nextObject(CredentialsBO.class)\n                .withIdentifiers(UserIdentifierBO.builder()\n                        .identifier(username)\n                        .type(UserIdentifier.Type.USERNAME)\n                        .build());\n        final HashedPasswordBO hashedPasswordBO = HashedPasswordBO.builder()\n                .password(credentials.getHashedPassword().getPassword())\n                .salt(credentials.getHashedPassword().getSalt())\n                .build();\n\n        Mockito.when(credentialsService.getByUsernameUnsafe(username)).thenReturn(Optional.of(credentials));\n        Mockito.when(securePassword.verify(eq(password), eq(hashedPasswordBO))).thenReturn(false);\n\n        final Either<Exception, AccountBO> result = basicAuth.authenticateAndGetAccount(authorization);\n\n        assertThat(result.isLeft()).isTrue();\n        assertThat(result.getLeft()).isInstanceOf(ServiceAuthorizationException.class);\n    }\n\n    @Test\n    void authenticateBadAuthorization() {\n        final String authorization = RandomStringUtils.randomAlphanumeric(20);\n        assertThatThrownBy(() -> basicAuth.authenticateAndGetAccount(authorization)).isInstanceOf(ServiceException.class);\n    }\n\n    @Test\n    void authenticateBadBasicScheme() {\n        final String authorization = \"dGhpc2RvbmVzbid0Zmx5aW5vdXJjaXR5\";\n        assertThatThrownBy(() -> basicAuth.authenticateAndGetAccount(authorization)).isInstanceOf(ServiceException.class);\n    }\n}", "package com.nexblocks.authguard.service.exceptions.codes;\n\npublic enum ErrorCode {\n    ACCOUNT_DOES_NOT_EXIST(\"AC.011\"),\n    ACCOUNT_DUPLICATE_EMAILS(\"AC.031\"),\n    ACCOUNT_DUPLICATE_PHONE_NUMBER(\"AC.032\"),\n    ACCOUNT_EMAIL_REQUIRED(\"AC.032\"),\n    ACCOUNT_PHONE_NUMBER_REQUIRED(\"AC.032\"),\n\n    APP_DOES_NOT_EXIST(\"AP.011\"),\n\n    API_KEY_DOES_NOT_EXIST(\"AK.011\"),\n\n    PERMISSION_DOES_NOT_EXIST(\"PR.011\"),\n    PERMISSION_ALREADY_EXIST(\"PR.012\"),\n\n    ROLE_DOES_NOT_EXIST(\"RL.011\"),\n    ROLE_ALREADY_EXISTS(\"RL.012\"),\n\n    CREDENTIALS_DOES_NOT_EXIST(\"CD.011\"),\n    IDENTIFIER_ALREADY_EXISTS(\"CD.012\"),\n    IDENTIFIER_DOES_NOT_EXIST(\"CD.013\"),\n\n    IDEMPOTENCY_ERROR(\"ID.0.12\"),\n\n    EXPIRED_TOKEN(\"TK.021\"),\n    INVALID_TOKEN(\"TK.022\"),\n\n    UNKNOWN_EXCHANGE(\"AT.021\"),\n    UNSUPPORTED_SCHEME(\"AT.022\"),\n    INVALID_AUTHORIZATION_FORMAT(\"AT.023\"),\n    INVALID_ADDITIONAL_INFORMATION_TYPE(\"AT.024\"),\n    TOKEN_EXPIRED_OR_DOES_NOT_EXIST(\"AT.025\"),\n    TOKEN_GENERATION_FAILED(\"AT.031\"),\n    ACCOUNT_IS_LOCKED(\"AT.032\"),\n    GENERIC_AUTH_FAILURE(\"AT.039\"),\n\n    UNSUPPORTED_JWT_ALGORITHM(\"JT.021\"),\n    ENCRYPTION_NOT_SUPPORTED(\"JT.022\"),\n\n    PASSWORDS_DO_NOT_MATCH(\"PW.021\"),\n    INVALID_PASSWORD(\"PW.022\"),\n\n    LDAP_MULTIPLE_PASSWORD_ENTRIES(\"LD.021\"),\n    LDAP_ERROR(\"LD.031\"),\n\n    MISSING_REQUEST_QUERY(\"RQ.011\"),\n    INVALID_REQUEST_QUERY(\"RQ.012\");\n\n    private final String code;\n\n    ErrorCode(final String code) {\n        this.code = code;\n    }\n\n    public String getCode() {\n        return code;\n    }\n}\n", "package com.nexblocks.authguard.service.model;\n\nimport org.immutables.value.Value;\n\n@Value.Immutable\n@BOStyle\npublic interface UserIdentifier {\n    Long getId(); // only useful for relational DBs\n    Type getType();\n    String getIdentifier();\n    boolean isActive();\n\n    enum Type {\n        USERNAME,\n        EMAIL,\n        PHONE_NUMBER\n    }\n}\n"], "fixing_code": ["package com.nexblocks.authguard.basic;\n\nimport com.nexblocks.authguard.basic.passwords.SecurePassword;\nimport com.nexblocks.authguard.basic.passwords.SecurePasswordProvider;\nimport com.nexblocks.authguard.service.AccountsService;\nimport com.nexblocks.authguard.service.CredentialsService;\nimport com.nexblocks.authguard.service.exceptions.ServiceAuthorizationException;\nimport com.nexblocks.authguard.service.exceptions.ServiceException;\nimport com.nexblocks.authguard.service.exceptions.codes.ErrorCode;\nimport com.nexblocks.authguard.service.model.*;\nimport com.google.inject.Inject;\nimport io.vavr.control.Either;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Base64;\nimport java.util.Optional;\n\npublic class BasicAuthProvider {\n    private final Logger LOG = LoggerFactory.getLogger(BasicAuthProvider.class);\n\n    private final CredentialsService credentialsService;\n    private final AccountsService accountsService;\n    private final SecurePassword securePassword;\n\n    @Inject\n    public BasicAuthProvider(final CredentialsService credentialsService, final AccountsService accountsService,\n                             final SecurePasswordProvider securePasswordProvider) {\n        this.credentialsService = credentialsService;\n        this.securePassword = securePasswordProvider.get();\n        this.accountsService = accountsService;\n\n        LOG.debug(\"Initialized with password implementation {}\", this.securePassword.getClass());\n    }\n\n    public Either<Exception, AccountBO> authenticateAndGetAccount(final AuthRequestBO authRequest) {\n        return verifyCredentialsAndGetAccount(authRequest.getIdentifier(), authRequest.getPassword());\n    }\n\n    public Either<Exception, AccountBO> authenticateAndGetAccount(final String basicToken) {\n        return handleBasicAuthentication(basicToken);\n    }\n\n    public Either<Exception, AccountBO> getAccount(final AuthRequestBO request) {\n        return verifyCredentialsAndGetAccount(request.getIdentifier());\n    }\n\n    public Either<Exception, AccountBO> getAccount(final String basicToken) {\n        final String[] parts = TokensUtils.parseAuthorization(basicToken);\n\n        if (parts[0].equals(\"Basic\")) {\n            return handleBasicAuthenticationNoPassword(parts[1]);\n        } else {\n            throw new ServiceException(ErrorCode.UNSUPPORTED_SCHEME, \"Unsupported authorization scheme\");\n        }\n    }\n\n    private Either<Exception, AccountBO> handleBasicAuthentication(final String base64Credentials) {\n        final String[] decoded = new String(Base64.getDecoder().decode(base64Credentials)).split(\":\");\n\n        if (decoded.length != 2) {\n            throw new ServiceException(ErrorCode.INVALID_AUTHORIZATION_FORMAT, \"Invalid format for basic authentication\");\n        }\n\n        final String username =  decoded[0];\n        final String password = decoded[1];\n\n        return verifyCredentialsAndGetAccount(username, password);\n    }\n\n    private Either<Exception, AccountBO> handleBasicAuthenticationNoPassword(final String base64Credentials) {\n        final String[] decoded = new String(Base64.getDecoder().decode(base64Credentials)).split(\":\");\n\n        if (decoded.length != 1) {\n            return Either.left(new ServiceException(ErrorCode.INVALID_AUTHORIZATION_FORMAT, \"Invalid format for basic authentication\"));\n        }\n\n        final String username =  decoded[0];\n\n        return verifyCredentialsAndGetAccount(username);\n    }\n\n    private Either<Exception, AccountBO> verifyCredentialsAndGetAccount(final String username, final String password) {\n        final Optional<CredentialsBO> credentials = credentialsService.getByUsernameUnsafe(username);\n\n        // TODO replace this with Either mapping\n        if (credentials.isPresent()) {\n            final Optional<Exception> validationError = checkIdentifier(credentials.get(), username);\n\n            if (validationError.isPresent()) {\n                return Either.left(validationError.get());\n            }\n\n            if (securePassword.verify(password, credentials.get().getHashedPassword())) {\n                return getAccountById(credentials.get().getAccountId());\n            } else {\n                return Either.left(new ServiceAuthorizationException(ErrorCode.PASSWORDS_DO_NOT_MATCH,\n                        \"Passwords do not match\", EntityType.ACCOUNT, credentials.get().getAccountId()));\n            }\n        } else {\n            return Either.left(new ServiceAuthorizationException(ErrorCode.CREDENTIALS_DOES_NOT_EXIST,\n                    \"Identifier \" + username + \" does not exist\"));\n        }\n    }\n\n    private Either<Exception, AccountBO> verifyCredentialsAndGetAccount(final String username) {\n        final Optional<CredentialsBO> credentials = credentialsService.getByUsernameUnsafe(username);\n\n        if (credentials.isPresent()) {\n            final Optional<Exception> validationError = checkIdentifier(credentials.get(), username);\n\n            if (validationError.isPresent()) {\n                return Either.left(validationError.get());\n            }\n\n            return getAccountById(credentials.get().getAccountId());\n        } else {\n            return Either.left(new ServiceAuthorizationException(ErrorCode.CREDENTIALS_DOES_NOT_EXIST,\n                    \"Identifier \" + username + \" does not exist\"));\n        }\n    }\n\n    private Optional<Exception> checkIdentifier(final CredentialsBO credentials,\n                                                final String identifier) {\n        final Optional<UserIdentifierBO> matchedIdentifier = credentials.getIdentifiers()\n                .stream()\n                .filter(existing -> identifier.equals(existing.getIdentifier()))\n                .findFirst();\n\n        if (matchedIdentifier.isEmpty()) {\n            return Optional.of(new IllegalStateException(\"No identifier matched but credentials were returned\"));\n        }\n\n        if (!matchedIdentifier.get().isActive()) {\n            return Optional.of(new ServiceAuthorizationException(ErrorCode.INACTIVE_IDENTIFIER,\n                    \"Identifier is not active\", EntityType.ACCOUNT, credentials.getAccountId()));\n        }\n\n        return Optional.empty();\n    }\n\n    private Either<Exception, AccountBO> getAccountById(final String accountId) {\n        final Optional<AccountBO> account = accountsService.getById(accountId);\n\n        return account\n                .<Either<Exception, AccountBO>>map(Either::right)\n                .orElseGet(() -> Either.left(new ServiceAuthorizationException(ErrorCode.ACCOUNT_DOES_NOT_EXIST,\n                \"Account \" + accountId + \" does not exist\")));\n    }\n}\n", "package com.nexblocks.authguard.basic;\n\n\nimport com.nexblocks.authguard.basic.passwords.SecurePassword;\nimport com.nexblocks.authguard.basic.passwords.SecurePasswordProvider;\nimport com.nexblocks.authguard.service.AccountsService;\nimport com.nexblocks.authguard.service.CredentialsService;\nimport com.nexblocks.authguard.service.exceptions.ServiceAuthorizationException;\nimport com.nexblocks.authguard.service.exceptions.ServiceException;\nimport com.nexblocks.authguard.service.model.*;\nimport io.vavr.control.Either;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.jeasy.random.EasyRandom;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestInstance;\nimport org.mockito.Mockito;\n\nimport java.util.Base64;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.ArgumentMatchers.eq;\n\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass BasicAuthProviderTest {\n    private AccountsService accountsService;\n    private CredentialsService credentialsService;\n    private SecurePassword securePassword;\n\n    private BasicAuthProvider basicAuth;\n\n    private final static EasyRandom RANDOM = new EasyRandom();\n\n    @BeforeAll\n    void setup() {\n        accountsService = Mockito.mock(AccountsService.class);\n        credentialsService = Mockito.mock(CredentialsService.class);\n        securePassword = Mockito.mock(SecurePassword.class);\n\n        final SecurePasswordProvider securePasswordProvider = Mockito.mock(SecurePasswordProvider.class);\n\n        Mockito.when(securePasswordProvider.get()).thenReturn(securePassword);\n\n        basicAuth = new BasicAuthProvider(credentialsService, accountsService, securePasswordProvider);\n    }\n\n    @AfterEach\n    void resetMocks() {\n        Mockito.reset(accountsService);\n        Mockito.reset(credentialsService);\n    }\n\n    @Test\n    void authenticate() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        final AccountBO account = RANDOM.nextObject(AccountBO.class);\n        final CredentialsBO credentials = RANDOM.nextObject(CredentialsBO.class)\n                .withIdentifiers(UserIdentifierBO.builder()\n                        .identifier(username)\n                        .type(UserIdentifier.Type.USERNAME)\n                        .active(true)\n                        .build());\n        final HashedPasswordBO hashedPasswordBO = HashedPasswordBO.builder()\n                .password(credentials.getHashedPassword().getPassword())\n                .salt(credentials.getHashedPassword().getSalt())\n                .build();\n\n        Mockito.when(credentialsService.getByUsernameUnsafe(username)).thenReturn(Optional.of(credentials));\n        Mockito.when(accountsService.getById(credentials.getAccountId())).thenReturn(Optional.of(account));\n        Mockito.when(securePassword.verify(eq(password), eq(hashedPasswordBO))).thenReturn(true);\n\n        final Either<Exception, AccountBO> result = basicAuth.authenticateAndGetAccount(authorization);\n\n        assertThat(result.get()).isEqualTo(account);\n    }\n\n    @Test\n    void authenticateInactiveIdentifier() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        final CredentialsBO credentials = RANDOM.nextObject(CredentialsBO.class)\n                .withIdentifiers(UserIdentifierBO.builder()\n                        .identifier(username)\n                        .type(UserIdentifier.Type.USERNAME)\n                        .active(false)\n                        .build());\n\n        Mockito.when(credentialsService.getByUsernameUnsafe(username)).thenReturn(Optional.of(credentials));\n\n        final Either<Exception, AccountBO> result = basicAuth.authenticateAndGetAccount(authorization);\n\n        assertThat(result.isLeft()).isTrue();\n        assertThat(result.getLeft()).isInstanceOf(ServiceAuthorizationException.class);\n    }\n\n    @Test\n    void authenticateNotFound() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        Mockito.when(credentialsService.getByUsername(username)).thenReturn(Optional.empty());\n\n        assertThat(basicAuth.authenticateAndGetAccount(authorization)).isEmpty();\n    }\n\n    @Test\n    void authenticateWrongPassword() {\n        final String username = \"username\";\n        final String password = \"password\";\n        final String authorization = Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n\n        final CredentialsBO credentials = RANDOM.nextObject(CredentialsBO.class)\n                .withIdentifiers(UserIdentifierBO.builder()\n                        .identifier(username)\n                        .type(UserIdentifier.Type.USERNAME)\n                        .build());\n        final HashedPasswordBO hashedPasswordBO = HashedPasswordBO.builder()\n                .password(credentials.getHashedPassword().getPassword())\n                .salt(credentials.getHashedPassword().getSalt())\n                .build();\n\n        Mockito.when(credentialsService.getByUsernameUnsafe(username)).thenReturn(Optional.of(credentials));\n        Mockito.when(securePassword.verify(eq(password), eq(hashedPasswordBO))).thenReturn(false);\n\n        final Either<Exception, AccountBO> result = basicAuth.authenticateAndGetAccount(authorization);\n\n        assertThat(result.isLeft()).isTrue();\n        assertThat(result.getLeft()).isInstanceOf(ServiceAuthorizationException.class);\n    }\n\n    @Test\n    void authenticateBadAuthorization() {\n        final String authorization = RandomStringUtils.randomAlphanumeric(20);\n        assertThatThrownBy(() -> basicAuth.authenticateAndGetAccount(authorization)).isInstanceOf(ServiceException.class);\n    }\n\n    @Test\n    void authenticateBadBasicScheme() {\n        final String authorization = \"dGhpc2RvbmVzbid0Zmx5aW5vdXJjaXR5\";\n        assertThatThrownBy(() -> basicAuth.authenticateAndGetAccount(authorization)).isInstanceOf(ServiceException.class);\n    }\n}", "package com.nexblocks.authguard.service.exceptions.codes;\n\npublic enum ErrorCode {\n    ACCOUNT_DOES_NOT_EXIST(\"AC.011\"),\n    ACCOUNT_DUPLICATE_EMAILS(\"AC.031\"),\n    ACCOUNT_DUPLICATE_PHONE_NUMBER(\"AC.032\"),\n    ACCOUNT_EMAIL_REQUIRED(\"AC.032\"),\n    ACCOUNT_PHONE_NUMBER_REQUIRED(\"AC.032\"),\n\n    APP_DOES_NOT_EXIST(\"AP.011\"),\n\n    API_KEY_DOES_NOT_EXIST(\"AK.011\"),\n\n    PERMISSION_DOES_NOT_EXIST(\"PR.011\"),\n    PERMISSION_ALREADY_EXIST(\"PR.012\"),\n\n    ROLE_DOES_NOT_EXIST(\"RL.011\"),\n    ROLE_ALREADY_EXISTS(\"RL.012\"),\n\n    CREDENTIALS_DOES_NOT_EXIST(\"CD.011\"),\n    IDENTIFIER_ALREADY_EXISTS(\"CD.012\"),\n    IDENTIFIER_DOES_NOT_EXIST(\"CD.013\"),\n\n    IDEMPOTENCY_ERROR(\"ID.0.12\"),\n\n    EXPIRED_TOKEN(\"TK.021\"),\n    INVALID_TOKEN(\"TK.022\"),\n\n    UNKNOWN_EXCHANGE(\"AT.021\"),\n    UNSUPPORTED_SCHEME(\"AT.022\"),\n    INVALID_AUTHORIZATION_FORMAT(\"AT.023\"),\n    INVALID_ADDITIONAL_INFORMATION_TYPE(\"AT.024\"),\n    TOKEN_EXPIRED_OR_DOES_NOT_EXIST(\"AT.025\"),\n    TOKEN_GENERATION_FAILED(\"AT.031\"),\n    ACCOUNT_IS_LOCKED(\"AT.032\"),\n    INACTIVE_IDENTIFIER(\"AT.033\"),\n    GENERIC_AUTH_FAILURE(\"AT.039\"),\n\n    UNSUPPORTED_JWT_ALGORITHM(\"JT.021\"),\n    ENCRYPTION_NOT_SUPPORTED(\"JT.022\"),\n\n    PASSWORDS_DO_NOT_MATCH(\"PW.021\"),\n    INVALID_PASSWORD(\"PW.022\"),\n\n    LDAP_MULTIPLE_PASSWORD_ENTRIES(\"LD.021\"),\n    LDAP_ERROR(\"LD.031\"),\n\n    MISSING_REQUEST_QUERY(\"RQ.011\"),\n    INVALID_REQUEST_QUERY(\"RQ.012\");\n\n    private final String code;\n\n    ErrorCode(final String code) {\n        this.code = code;\n    }\n\n    public String getCode() {\n        return code;\n    }\n}\n", "package com.nexblocks.authguard.service.model;\n\nimport org.immutables.value.Value;\n\n@Value.Immutable\n@BOStyle\npublic interface UserIdentifier {\n    Long getId(); // only useful for relational DBs\n    Type getType();\n    String getIdentifier();\n\n    @Value.Default\n    default boolean isActive() {\n        return true;\n    }\n\n    enum Type {\n        USERNAME,\n        EMAIL,\n        PHONE_NUMBER\n    }\n}\n"], "filenames": ["basic-auth/src/main/java/com/nexblocks/authguard/basic/BasicAuthProvider.java", "basic-auth/src/test/java/com/nexblocks/authguard/basic/BasicAuthProviderTest.java", "service-api/src/main/java/com/nexblocks/authguard/service/exceptions/codes/ErrorCode.java", "service-api/src/main/java/com/nexblocks/authguard/service/model/UserIdentifier.java"], "buggy_code_start_loc": [10, 66, 35, 11], "buggy_code_end_loc": [110, 79, 35, 12], "fixing_code_start_loc": [10, 67, 36, 11], "fixing_code_end_loc": [140, 102, 37, 16], "type": "CWE-287", "message": "basic/BasicAuthProvider.java in AuthGuard before 0.9.0 allows authentication via an inactive identifier.", "other": {"cve": {"id": "CVE-2021-45890", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-27T20:15:07.480", "lastModified": "2022-01-07T17:58:13.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "basic/BasicAuthProvider.java in AuthGuard before 0.9.0 allows authentication via an inactive identifier."}, {"lang": "es", "value": "El archivo basic/BasicAuthProvider.java en AuthGuard versiones anteriores a 0.9.0, permite una autenticaci\u00f3n por medio de un identificador inactivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:authguard_project:authguard:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "CCDA41B2-8D24-4D67-8F20-0D97D4409E90"}]}]}], "references": [{"url": "https://github.com/AuthGuard/AuthGuard/commit/9783b1143da6576028de23e15a1f198b1f937b82", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/AuthGuard/AuthGuard/compare/v0.8.0...v0.9.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/AuthGuard/AuthGuard/issues/166", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/AuthGuard/AuthGuard/pull/181", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AuthGuard/AuthGuard/commit/9783b1143da6576028de23e15a1f198b1f937b82"}}