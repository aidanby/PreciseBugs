{"buggy_code": ["#!/usr/bin/python\n# encoding: utf-8\n\n# (c) 2012, Matt Wright <matt@nobien.net>\n# (c) 2013, Alexander Saltanov <asd@mokote.com>\n# (c) 2014, Rutger Spiertz <rutger@kumina.nl>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n\nDOCUMENTATION = '''\n---\nmodule: apt_repository\nshort_description: Add and remove APT repositores\ndescription:\n    - Add or remove an APT repositories in Ubuntu and Debian.\nnotes:\n    - This module works on Debian and Ubuntu and requires C(python-apt) and C(python-pycurl) packages.\n    - This module supports Debian Squeeze (version 6) as well as its successors.\n    - This module treats Debian and Ubuntu distributions separately. So PPA could be installed only on Ubuntu machines.\noptions:\n    repo:\n        required: true\n        default: none\n        description:\n            - A source string for the repository.\n    state:\n        required: false\n        choices: [ \"absent\", \"present\" ]\n        default: \"present\"\n        description:\n            - A source string state.\n    update_cache:\n        description:\n            - Run the equivalent of C(apt-get update) if has changed.\n        required: false\n        default: \"yes\"\n        choices: [ \"yes\", \"no\" ]\nauthor: Alexander Saltanov\nversion_added: \"0.7\"\nrequirements: [ python-apt, python-pycurl ]\n'''\n\nEXAMPLES = '''\n# Add specified repository into sources list.\napt_repository: repo='deb http://archive.canonical.com/ubuntu hardy partner' state=present\n\n# Add source repository into sources list.\napt_repository: repo='deb-src http://archive.canonical.com/ubuntu hardy partner' state=present\n\n# Remove specified repository from sources list.\napt_repository: repo='deb http://archive.canonical.com/ubuntu hardy partner' state=absent\n\n# On Ubuntu target: add nginx stable repository from PPA and install its signing key.\n# On Debian target: adding PPA is not available, so it will fail immediately.\napt_repository: repo='ppa:nginx/stable'\n'''\n\nimport glob\ntry:\n  import json\nexcept ImportError:\n  import simplejson as json\nimport os\nimport re\nimport tempfile\n\ntry:\n    import apt\n    import apt_pkg\n    import aptsources.distro\n    distro = aptsources.distro.get_distro()\n    HAVE_PYTHON_APT = True\nexcept ImportError:\n    HAVE_PYTHON_APT = False\n\ntry:\n    import pycurl\n    HAVE_PYCURL = True\nexcept ImportError:\n    HAVE_PYCURL = False\n\nVALID_SOURCE_TYPES = ('deb', 'deb-src')\n\n\nclass CurlCallback:\n    def __init__(self):\n        self.contents = ''\n\n    def body_callback(self, buf):\n        self.contents = self.contents + buf\n\n\nclass InvalidSource(Exception):\n    pass\n\n\n# Simple version of aptsources.sourceslist.SourcesList.\n# No advanced logic and no backups inside.\nclass SourcesList(object):\n    def __init__(self):\n        self.files = {}  # group sources by file\n        self.default_file = self._apt_cfg_file('Dir::Etc::sourcelist')\n\n        # read sources.list if it exists\n        if os.path.isfile(self.default_file):\n            self.load(self.default_file)\n\n        # read sources.list.d\n        for file in glob.iglob('%s/*.list' % self._apt_cfg_dir('Dir::Etc::sourceparts')):\n            self.load(file)\n\n    def __iter__(self):\n        '''Simple iterator to go over all sources. Empty, non-source, and other not valid lines will be skipped.'''\n        for file, sources in self.files.items():\n            for n, valid, enabled, source, comment in sources:\n                if valid:\n                    yield file, n, enabled, source, comment\n        raise StopIteration\n\n    def _expand_path(self, filename):\n        if '/' in filename:\n            return filename\n        else:\n            return os.path.abspath(os.path.join(self._apt_cfg_dir('Dir::Etc::sourceparts'), filename))\n\n    def _suggest_filename(self, line):\n        def _cleanup_filename(s):\n            return '_'.join(re.sub('[^a-zA-Z0-9]', ' ', s).split())\n\n        # Drop options and protocols.\n        line = re.sub('\\[[^\\]]+\\]', '', line)\n        line = re.sub('\\w+://', '', line)\n\n        parts = [part for part in line.split() if part not in VALID_SOURCE_TYPES]\n        return '%s.list' % _cleanup_filename(' '.join(parts[:1]))\n\n    def _parse(self, line, raise_if_invalid_or_disabled=False):\n        valid = False\n        enabled = True\n        source = ''\n        comment = ''\n\n        line = line.strip()\n        if line.startswith('#'):\n            enabled = False\n            line = line[1:]\n\n        # Check for another \"#\" in the line and treat a part after it as a comment.\n        i = line.find('#')\n        if i > 0:\n            comment = line[i+1:].strip()\n            line = line[:i]\n\n        # Split a source into substring to make sure that it is source spec.\n        # Duplicated whitespaces in a valid source spec will be removed.\n        source = line.strip()\n        if source:\n            chunks = source.split()\n            if chunks[0] in VALID_SOURCE_TYPES:\n                valid = True\n                source = ' '.join(chunks)\n\n        if raise_if_invalid_or_disabled and (not valid or not enabled):\n            raise InvalidSource(line)\n\n        return valid, enabled, source, comment\n\n    @staticmethod\n    def _apt_cfg_file(filespec):\n        '''\n        Wrapper for `apt_pkg` module for running with Python 2.5\n        '''\n        try:\n            result = apt_pkg.config.find_file(filespec)\n        except AttributeError:\n            result = apt_pkg.Config.FindFile(filespec)\n        return result\n\n    @staticmethod\n    def _apt_cfg_dir(dirspec):\n        '''\n        Wrapper for `apt_pkg` module for running with Python 2.5\n        '''\n        try:\n            result = apt_pkg.config.find_dir(dirspec)\n        except AttributeError:\n            result = apt_pkg.Config.FindDir(dirspec)\n        return result\n\n    def load(self, file):\n        group = []\n        f = open(file, 'r')\n        for n, line in enumerate(f):\n            valid, enabled, source, comment = self._parse(line)\n            group.append((n, valid, enabled, source, comment))\n        self.files[file] = group\n\n    def save(self, module):\n        for filename, sources in self.files.items():\n            if sources:\n                d, fn = os.path.split(filename)\n                fd, tmp_path = tempfile.mkstemp(prefix=\".%s-\" % fn, dir=d)\n                os.chmod(os.path.join(fd, tmp_path), 0644)\n\n                f = os.fdopen(fd, 'w')\n                for n, valid, enabled, source, comment in sources:\n                    chunks = []\n                    if not enabled:\n                        chunks.append('# ')\n                    chunks.append(source)\n                    if comment:\n                        chunks.append(' # ')\n                        chunks.append(comment)\n                    chunks.append('\\n')\n                    line = ''.join(chunks)\n\n                    try:\n                        f.write(line)\n                    except IOError, err:\n                        module.fail_json(msg=\"Failed to write to file %s: %s\" % (tmp_path, unicode(err)))\n                module.atomic_move(tmp_path, filename)\n            else:\n                del self.files[filename]\n                if os.path.exists(filename):\n                    os.remove(filename)\n\n    def dump(self):\n        return '\\n'.join([str(i) for i in self])\n\n    def modify(self, file, n, enabled=None, source=None, comment=None):\n        '''\n        This function to be used with iterator, so we don't care of invalid sources.\n        If source, enabled, or comment is None, original value from line ``n`` will be preserved.\n        '''\n        valid, enabled_old, source_old, comment_old = self.files[file][n][1:]\n        choice = lambda new, old: old if new is None else new\n        self.files[file][n] = (n, valid, choice(enabled, enabled_old), choice(source, source_old), choice(comment, comment_old))\n\n    def _add_valid_source(self, source_new, comment_new, file):\n        # We'll try to reuse disabled source if we have it.\n        # If we have more than one entry, we will enable them all - no advanced logic, remember.\n        found = False\n        for filename, n, enabled, source, comment in self:\n            if source == source_new:\n                self.modify(filename, n, enabled=True)\n                found = True\n\n        if not found:\n            if file is None:\n                file = self.default_file\n            else:\n                file = self._expand_path(file)\n\n            if file not in self.files:\n                self.files[file] = []\n\n            files = self.files[file]\n            files.append((len(files), True, True, source_new, comment_new))\n\n    def add_source(self, line, comment='', file=None):\n        source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n\n        # Prefer separate files for new sources.\n        self._add_valid_source(source, comment, file=file or self._suggest_filename(source))\n\n    def _remove_valid_source(self, source):\n        # If we have more than one entry, we will remove them all (not comment, remove!)\n        for filename, n, enabled, src, comment in self:\n            if source == src and enabled:\n                self.files[filename].pop(n)\n\n    def remove_source(self, line):\n        source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n        self._remove_valid_source(source)\n\n\nclass UbuntuSourcesList(SourcesList):\n\n    LP_API = 'https://launchpad.net/api/1.0/~%s/+archive/%s' \n\n    def __init__(self, add_ppa_signing_keys_callback=None):\n        self.add_ppa_signing_keys_callback = add_ppa_signing_keys_callback\n        super(UbuntuSourcesList, self).__init__()\n\n    def _get_ppa_info(self, owner_name, ppa_name):\n        # we can not use urllib2 here as it does not do cert verification\n        lp_api = self.LP_API % (owner_name, ppa_name)\n        return self._get_ppa_info_curl(lp_api)\n\n    def _get_ppa_info_curl(self, lp_api):\n        callback = CurlCallback()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.SSL_VERIFYPEER, 1)\n        curl.setopt(pycurl.SSL_VERIFYHOST, 2)\n        curl.setopt(pycurl.WRITEFUNCTION, callback.body_callback)\n        curl.setopt(pycurl.URL, str(lp_api))\n        curl.setopt(pycurl.HTTPHEADER, [\"Accept: application/json\"])\n        curl.perform()\n        curl.close()\n        lp_page = callback.contents\n        return json.loads(lp_page)\n\n    def _expand_ppa(self, path):\n        ppa = path.split(':')[1]\n        ppa_owner = ppa.split('/')[0]\n        try:\n            ppa_name = ppa.split('/')[1]\n        except IndexError:\n            ppa_name = 'ppa'\n\n        line = 'deb http://ppa.launchpad.net/%s/%s/ubuntu %s main' % (ppa_owner, ppa_name, distro.codename)\n        return line, ppa_owner, ppa_name\n\n    def add_source(self, line, comment='', file=None):\n        if line.startswith('ppa:'):\n            source, ppa_owner, ppa_name = self._expand_ppa(line)\n\n            if self.add_ppa_signing_keys_callback is not None:\n                info = self._get_ppa_info(ppa_owner, ppa_name)\n                command = ['apt-key', 'adv', '--recv-keys', '--keyserver', 'hkp://keyserver.ubuntu.com:80', info['signing_key_fingerprint']]\n                self.add_ppa_signing_keys_callback(command)\n\n            file = file or self._suggest_filename('%s_%s' % (line, distro.codename))\n        else:\n            source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n            file = file or self._suggest_filename(source)\n        self._add_valid_source(source, comment, file)\n\n    def remove_source(self, line):\n        if line.startswith('ppa:'):\n            source = self._expand_ppa(line)[0]\n        else:\n            source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n        self._remove_valid_source(source)\n\n\ndef get_add_ppa_signing_key_callback(module):\n    def _run_command(command):\n        module.run_command(command, check_rc=True)\n\n    if module.check_mode:\n        return None\n    else:\n        return _run_command\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            repo=dict(required=True),\n            state=dict(choices=['present', 'absent'], default='present'),\n            update_cache = dict(aliases=['update-cache'], type='bool', default='yes'),\n        ),\n        supports_check_mode=True,\n    )\n\n    if not HAVE_PYTHON_APT:\n        module.fail_json(msg='Could not import python modules: apt_pkg. Please install python-apt package.')\n\n    if not HAVE_PYCURL:\n        module.fail_json(msg='Could not import python modules: pycurl. Please install python-pycurl package.')\n\n    repo = module.params['repo']\n    state = module.params['state']\n    update_cache = module.params['update_cache']\n    sourceslist = None\n\n    if isinstance(distro, aptsources.distro.UbuntuDistribution):\n        sourceslist = UbuntuSourcesList(add_ppa_signing_keys_callback=get_add_ppa_signing_key_callback(module))\n    elif isinstance(distro, aptsources.distro.DebianDistribution) or \\\n            isinstance(distro, aptsources.distro.Distribution):\n        sourceslist = SourcesList()\n    else:\n        module.fail_json(msg='Module apt_repository supports only Debian and Ubuntu.')\n\n    sources_before = sourceslist.dump()\n\n    try:\n        if state == 'present':\n            sourceslist.add_source(repo)\n        elif state == 'absent':\n            sourceslist.remove_source(repo)\n    except InvalidSource, err:\n        module.fail_json(msg='Invalid repository string: %s' % unicode(err))\n\n    sources_after = sourceslist.dump()\n    changed = sources_before != sources_after\n\n    if not module.check_mode and changed:\n        try:\n            sourceslist.save(module)\n            if update_cache:\n                cache = apt.Cache()\n                cache.update()\n        except OSError, err:\n            module.fail_json(msg=unicode(err))\n\n    module.exit_json(changed=changed, repo=repo, state=state)\n\n# import module snippets\nfrom ansible.module_utils.basic import *\n\nmain()\n"], "fixing_code": ["#!/usr/bin/python\n# encoding: utf-8\n\n# (c) 2012, Matt Wright <matt@nobien.net>\n# (c) 2013, Alexander Saltanov <asd@mokote.com>\n# (c) 2014, Rutger Spiertz <rutger@kumina.nl>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n\nDOCUMENTATION = '''\n---\nmodule: apt_repository\nshort_description: Add and remove APT repositores\ndescription:\n    - Add or remove an APT repositories in Ubuntu and Debian.\nnotes:\n    - This module works on Debian and Ubuntu and requires C(python-apt).\n    - This module supports Debian Squeeze (version 6) as well as its successors.\n    - This module treats Debian and Ubuntu distributions separately. So PPA could be installed only on Ubuntu machines.\noptions:\n    repo:\n        required: true\n        default: none\n        description:\n            - A source string for the repository.\n    state:\n        required: false\n        choices: [ \"absent\", \"present\" ]\n        default: \"present\"\n        description:\n            - A source string state.\n    mode:\n        required: false\n        default: 0644\n        description:\n            - The octal mode for newly created files in sources.list.d\n        version_added: \"1.6\"\n    update_cache:\n        description:\n            - Run the equivalent of C(apt-get update) when a change occurs.  Cache updates are run after making changes.\n        required: false\n        default: \"yes\"\n        choices: [ \"yes\", \"no\" ]\nauthor: Alexander Saltanov\nversion_added: \"0.7\"\nrequirements: [ python-apt ]\n'''\n\nEXAMPLES = '''\n# Add specified repository into sources list.\napt_repository: repo='deb http://archive.canonical.com/ubuntu hardy partner' state=present\n\n# Add source repository into sources list.\napt_repository: repo='deb-src http://archive.canonical.com/ubuntu hardy partner' state=present\n\n# Remove specified repository from sources list.\napt_repository: repo='deb http://archive.canonical.com/ubuntu hardy partner' state=absent\n\n# On Ubuntu target: add nginx stable repository from PPA and install its signing key.\n# On Debian target: adding PPA is not available, so it will fail immediately.\napt_repository: repo='ppa:nginx/stable'\n'''\n\nimport glob\nimport os\nimport re\nimport tempfile\n\ntry:\n    import apt\n    import apt_pkg\n    import aptsources.distro\n    distro = aptsources.distro.get_distro()\n    HAVE_PYTHON_APT = True\nexcept ImportError:\n    HAVE_PYTHON_APT = False\n\n\nVALID_SOURCE_TYPES = ('deb', 'deb-src')\n\ndef install_python_apt(module):\n\n    if not module.check_mode:\n        apt_get_path = module.get_bin_path('apt-get')\n        if apt_get_path:\n            rc, so, se = module.run_command('%s update && %s install python-apt -y -q' % (apt_get_path, apt_get_path))\n            if rc == 0:\n                global apt, apt_pkg\n                import apt\n                import apt_pkg\n\nclass InvalidSource(Exception):\n    pass\n\n\n# Simple version of aptsources.sourceslist.SourcesList.\n# No advanced logic and no backups inside.\nclass SourcesList(object):\n    def __init__(self):\n        self.files = {}  # group sources by file\n        self.default_file = self._apt_cfg_file('Dir::Etc::sourcelist')\n\n        # read sources.list if it exists\n        if os.path.isfile(self.default_file):\n            self.load(self.default_file)\n\n        # read sources.list.d\n        for file in glob.iglob('%s/*.list' % self._apt_cfg_dir('Dir::Etc::sourceparts')):\n            self.load(file)\n\n    def __iter__(self):\n        '''Simple iterator to go over all sources. Empty, non-source, and other not valid lines will be skipped.'''\n        for file, sources in self.files.items():\n            for n, valid, enabled, source, comment in sources:\n                if valid:\n                    yield file, n, enabled, source, comment\n        raise StopIteration\n\n    def _expand_path(self, filename):\n        if '/' in filename:\n            return filename\n        else:\n            return os.path.abspath(os.path.join(self._apt_cfg_dir('Dir::Etc::sourceparts'), filename))\n\n    def _suggest_filename(self, line):\n        def _cleanup_filename(s):\n            return '_'.join(re.sub('[^a-zA-Z0-9]', ' ', s).split())\n        def _strip_username_password(s):\n            if '@' in s:\n                s = s.split('@', 1)\n                s = s[-1]\n            return s\n\n        # Drop options and protocols.\n        line = re.sub('\\[[^\\]]+\\]', '', line)\n        line = re.sub('\\w+://', '', line)\n\n        # split line into valid keywords\n        parts = [part for part in line.split() if part not in VALID_SOURCE_TYPES]\n\n        # Drop usernames and passwords\n        parts[0] = _strip_username_password(parts[0])\n\n        return '%s.list' % _cleanup_filename(' '.join(parts[:1]))\n\n    def _parse(self, line, raise_if_invalid_or_disabled=False):\n        valid = False\n        enabled = True\n        source = ''\n        comment = ''\n\n        line = line.strip()\n        if line.startswith('#'):\n            enabled = False\n            line = line[1:]\n\n        # Check for another \"#\" in the line and treat a part after it as a comment.\n        i = line.find('#')\n        if i > 0:\n            comment = line[i+1:].strip()\n            line = line[:i]\n\n        # Split a source into substring to make sure that it is source spec.\n        # Duplicated whitespaces in a valid source spec will be removed.\n        source = line.strip()\n        if source:\n            chunks = source.split()\n            if chunks[0] in VALID_SOURCE_TYPES:\n                valid = True\n                source = ' '.join(chunks)\n\n        if raise_if_invalid_or_disabled and (not valid or not enabled):\n            raise InvalidSource(line)\n\n        return valid, enabled, source, comment\n\n    @staticmethod\n    def _apt_cfg_file(filespec):\n        '''\n        Wrapper for `apt_pkg` module for running with Python 2.5\n        '''\n        try:\n            result = apt_pkg.config.find_file(filespec)\n        except AttributeError:\n            result = apt_pkg.Config.FindFile(filespec)\n        return result\n\n    @staticmethod\n    def _apt_cfg_dir(dirspec):\n        '''\n        Wrapper for `apt_pkg` module for running with Python 2.5\n        '''\n        try:\n            result = apt_pkg.config.find_dir(dirspec)\n        except AttributeError:\n            result = apt_pkg.Config.FindDir(dirspec)\n        return result\n\n    def load(self, file):\n        group = []\n        f = open(file, 'r')\n        for n, line in enumerate(f):\n            valid, enabled, source, comment = self._parse(line)\n            group.append((n, valid, enabled, source, comment))\n        self.files[file] = group\n\n    def save(self, module):\n        for filename, sources in self.files.items():\n            if sources:\n                d, fn = os.path.split(filename)\n                fd, tmp_path = tempfile.mkstemp(prefix=\".%s-\" % fn, dir=d)\n\n                # allow the user to override the default mode\n                this_mode = module.params['mode']\n                module.set_mode_if_different(tmp_path, this_mode, False)\n\n                f = os.fdopen(fd, 'w')\n                for n, valid, enabled, source, comment in sources:\n                    chunks = []\n                    if not enabled:\n                        chunks.append('# ')\n                    chunks.append(source)\n                    if comment:\n                        chunks.append(' # ')\n                        chunks.append(comment)\n                    chunks.append('\\n')\n                    line = ''.join(chunks)\n\n                    try:\n                        f.write(line)\n                    except IOError, err:\n                        module.fail_json(msg=\"Failed to write to file %s: %s\" % (tmp_path, unicode(err)))\n                module.atomic_move(tmp_path, filename)\n            else:\n                del self.files[filename]\n                if os.path.exists(filename):\n                    os.remove(filename)\n\n    def dump(self):\n        return '\\n'.join([str(i) for i in self])\n\n    def modify(self, file, n, enabled=None, source=None, comment=None):\n        '''\n        This function to be used with iterator, so we don't care of invalid sources.\n        If source, enabled, or comment is None, original value from line ``n`` will be preserved.\n        '''\n        valid, enabled_old, source_old, comment_old = self.files[file][n][1:]\n        choice = lambda new, old: old if new is None else new\n        self.files[file][n] = (n, valid, choice(enabled, enabled_old), choice(source, source_old), choice(comment, comment_old))\n\n    def _add_valid_source(self, source_new, comment_new, file):\n        # We'll try to reuse disabled source if we have it.\n        # If we have more than one entry, we will enable them all - no advanced logic, remember.\n        found = False\n        for filename, n, enabled, source, comment in self:\n            if source == source_new:\n                self.modify(filename, n, enabled=True)\n                found = True\n\n        if not found:\n            if file is None:\n                file = self.default_file\n            else:\n                file = self._expand_path(file)\n\n            if file not in self.files:\n                self.files[file] = []\n\n            files = self.files[file]\n            files.append((len(files), True, True, source_new, comment_new))\n\n    def add_source(self, line, comment='', file=None):\n        source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n\n        # Prefer separate files for new sources.\n        self._add_valid_source(source, comment, file=file or self._suggest_filename(source))\n\n    def _remove_valid_source(self, source):\n        # If we have more than one entry, we will remove them all (not comment, remove!)\n        for filename, n, enabled, src, comment in self:\n            if source == src and enabled:\n                self.files[filename].pop(n)\n\n    def remove_source(self, line):\n        source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n        self._remove_valid_source(source)\n\n\nclass UbuntuSourcesList(SourcesList):\n\n    LP_API = 'https://launchpad.net/api/1.0/~%s/+archive/%s'\n\n    def __init__(self, module, add_ppa_signing_keys_callback=None):\n        self.module = module\n        self.add_ppa_signing_keys_callback = add_ppa_signing_keys_callback\n        super(UbuntuSourcesList, self).__init__()\n\n    def _get_ppa_info(self, owner_name, ppa_name):\n        lp_api = self.LP_API % (owner_name, ppa_name)\n\n        headers = dict(Accept='application/json')\n        response, info = fetch_url(self.module, lp_api, headers=headers)\n        return json.load(response)\n\n    def _expand_ppa(self, path):\n        ppa = path.split(':')[1]\n        ppa_owner = ppa.split('/')[0]\n        try:\n            ppa_name = ppa.split('/')[1]\n        except IndexError:\n            ppa_name = 'ppa'\n\n        line = 'deb http://ppa.launchpad.net/%s/%s/ubuntu %s main' % (ppa_owner, ppa_name, distro.codename)\n        return line, ppa_owner, ppa_name\n\n    def add_source(self, line, comment='', file=None):\n        if line.startswith('ppa:'):\n            source, ppa_owner, ppa_name = self._expand_ppa(line)\n\n            if self.add_ppa_signing_keys_callback is not None:\n                info = self._get_ppa_info(ppa_owner, ppa_name)\n                command = ['apt-key', 'adv', '--recv-keys', '--keyserver', 'hkp://keyserver.ubuntu.com:80', info['signing_key_fingerprint']]\n                self.add_ppa_signing_keys_callback(command)\n\n            file = file or self._suggest_filename('%s_%s' % (line, distro.codename))\n        else:\n            source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n            file = file or self._suggest_filename(source)\n        self._add_valid_source(source, comment, file)\n\n    def remove_source(self, line):\n        if line.startswith('ppa:'):\n            source = self._expand_ppa(line)[0]\n        else:\n            source = self._parse(line, raise_if_invalid_or_disabled=True)[2]\n        self._remove_valid_source(source)\n\n\ndef get_add_ppa_signing_key_callback(module):\n    def _run_command(command):\n        module.run_command(command, check_rc=True)\n\n    if module.check_mode:\n        return None\n    else:\n        return _run_command\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            repo=dict(required=True),\n            state=dict(choices=['present', 'absent'], default='present'),\n            mode=dict(required=False, default=0644),\n            update_cache = dict(aliases=['update-cache'], type='bool', default='yes'),\n            # this should not be needed, but exists as a failsafe\n            install_python_apt=dict(required=False, default=\"yes\", type='bool'),\n        ),\n        supports_check_mode=True,\n    )\n\n    params = module.params\n    if params['install_python_apt'] and not HAVE_PYTHON_APT and not module.check_mode:\n        install_python_apt(module)\n\n    repo = module.params['repo']\n    state = module.params['state']\n    update_cache = module.params['update_cache']\n    sourceslist = None\n\n    if isinstance(distro, aptsources.distro.UbuntuDistribution):\n        sourceslist = UbuntuSourcesList(module,\n                                        add_ppa_signing_keys_callback=get_add_ppa_signing_key_callback(module))\n    elif isinstance(distro, aptsources.distro.DebianDistribution) or \\\n            isinstance(distro, aptsources.distro.Distribution):\n        sourceslist = SourcesList()\n    else:\n        module.fail_json(msg='Module apt_repository supports only Debian and Ubuntu.')\n\n    sources_before = sourceslist.dump()\n\n    try:\n        if state == 'present':\n            sourceslist.add_source(repo)\n        elif state == 'absent':\n            sourceslist.remove_source(repo)\n    except InvalidSource, err:\n        module.fail_json(msg='Invalid repository string: %s' % unicode(err))\n\n    sources_after = sourceslist.dump()\n    changed = sources_before != sources_after\n\n    if not module.check_mode and changed:\n        try:\n            sourceslist.save(module)\n            if update_cache:\n                cache = apt.Cache()\n                cache.update()\n        except OSError, err:\n            module.fail_json(msg=unicode(err))\n\n    module.exit_json(changed=changed, repo=repo, state=state)\n\n# import module snippets\nfrom ansible.module_utils.basic import *\nfrom ansible.module_utils.urls import *\n\nmain()\n"], "filenames": ["library/packaging/apt_repository"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [415], "fixing_code_start_loc": [31], "fixing_code_end_loc": [421], "type": "CWE-522", "message": "Ansible before 1.5.5 constructs filenames containing user and password fields on the basis of deb lines in sources.list, which might allow local users to obtain sensitive credential information in opportunistic circumstances by leveraging existence of a file that uses the \"deb http://user:pass@server:port/\" format.", "other": {"cve": {"id": "CVE-2014-4660", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-20T03:15:10.653", "lastModified": "2020-02-25T20:13:49.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ansible before 1.5.5 constructs filenames containing user and password fields on the basis of deb lines in sources.list, which might allow local users to obtain sensitive credential information in opportunistic circumstances by leveraging existence of a file that uses the \"deb http://user:pass@server:port/\" format."}, {"lang": "es", "value": "Ansible versiones anteriores a 1.5.5, construye nombres de archivos que contienen campos de usuario y contrase\u00f1a sobre la base de l\u00edneas deb en sources.list, lo que podr\u00eda permitir a usuarios locales obtener informaci\u00f3n confidencial de credenciales en circunstancias oportunistas al aprovechar la existencia de un archivo que utiliza el formato \"deb http://user:pass@server:port/\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.5", "matchCriteriaId": "B658D27D-BE83-4627-A241-6733E17F79FA"}]}]}], "references": [{"url": "https://github.com/ansible/ansible/blob/release1.5.5/CHANGELOG.md", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/ansible/ansible/commit/c4b5e46054c74176b2446c82d4df1a2610eddc08", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2014-4660", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2014/06/26/19", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.securityfocus.com/bid/68231", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/ansible/ansible/commit/c4b5e46054c74176b2446c82d4df1a2610eddc08"}}