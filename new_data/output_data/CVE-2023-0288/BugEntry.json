{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar et al.\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic void\tunshift_special(cmdarg_T *cap);\nstatic void\tdel_from_showcmd(int);\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo_or_register(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\nstatic void\tnv_object(cmdarg_T *cap);\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\n// Declare nv_cmds[].\n#define DO_DECLARE_NVCMD\n#include \"nv_cmds.h\"\n\n// Include the lookuptable generated by create_nvcmdidx.vim.\n#include \"nv_cmdidxs.h\"\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * If currently editing a cmdline or text is locked: beep and give an error\n * message, return TRUE.\n */\n    static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tif (oap != NULL)\n\t    clearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * If text is locked, \"curbuf_lock\" or \"allbuf_lock\" is set:\n * Give an error message, possibly beep and return TRUE.\n * \"oap\" may be NULL.\n */\n    int\ncheck_text_or_curbuf_locked(oparg_T *oap)\n{\n    if (check_text_locked(oap))\n\treturn TRUE;\n    if (curbuf_locked())\n    {\n\tif (oap != NULL)\n\t    clearop(oap);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Handle the count before a normal command and set cap->count0.\n */\n    static int\nnormal_cmd_get_count(\n\tcmdarg_T\t*cap,\n\tint\t\tc,\n\tint\t\ttoplevel UNUSED,\n\tint\t\tset_prevcount UNUSED,\n\tint\t\t*ctrl_w,\n\tint\t\t*need_flushbuf UNUSED)\n{\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t// Handle a count before a command and compute ca.count0.\n\t// Note that '0' is a command and not the start of a count, but it's\n\t// part of a count after other digits.\n\twhile ((c >= '1' && c <= '9')\n\t\t|| (cap->count0 != 0 && (c == K_DEL || c == K_KDEL\n\t\t\t|| c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tcap->count0 /= 10;\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n\t    }\n\t    else if (cap->count0 > 99999999L)\n\t    {\n\t\tcap->count0 = 999999999L;\n\t    }\n\t    else\n\t    {\n\t\tcap->count0 = cap->count0 * 10 + (c - '0');\n\t    }\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(cap, &set_prevcount);\n#endif\n\t    if (*ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (*ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t}\n\n\t// If we got CTRL-W there may be a/another count\n\tif (c == Ctrl_W && !*ctrl_w && cap->oap->op_type == OP_NOP)\n\t{\n\t    *ctrl_w = TRUE;\n\t    cap->opcount = cap->count0;\t// remember first count\n\t    cap->count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\tcap->oap->prev_opcount = cap->opcount;\n\tcap->oap->prev_count0 = cap->count0;\n    }\n    else if (cap->opcount != 0)\n    {\n\t// If we're in the middle of an operator (including after entering a\n\t// yank buffer with '\"') AND we had a count before the operator, then\n\t// that count overrides the current value of ca.count0.\n\t// What this means effectively, is that commands like \"3dw\" get turned\n\t// into \"d3w\" which makes things fall into place pretty neatly.\n\t// If you give a count before AND after the operator, they are\n\t// multiplied.\n\tif (cap->count0)\n\t{\n\t    if (cap->opcount >= 999999999L / cap->count0)\n\t\tcap->count0 = 999999999L;\n\t    else\n\t\tcap->count0 *= cap->opcount;\n\t}\n\telse\n\t    cap->count0 = cap->opcount;\n    }\n\n    // Always remember the count.  It will be set to zero (on the next call,\n    // above) when there is no pending operator.\n    // When called from main(), save the count for use by the \"count\" built-in\n    // variable.\n    cap->opcount = cap->count0;\n    cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n\n#ifdef FEAT_EVAL\n    // Only set v:count when called from main() and not a stuffed command.\n    // Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount(cap->count0, cap->count1, set_prevcount);\n#endif\n\n    return c;\n}\n\n/*\n * Returns TRUE if the normal command (cap) needs a second character.\n */\n    static int\nnormal_cmd_needs_more_chars(cmdarg_T *cap, short_u cmd_flags)\n{\n    return ((cmd_flags & NV_NCH)\n\t    && (((cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && cap->oap->op_type == OP_NOP)\n\t\t|| (cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (cap->cmdchar == 'q'\n\t\t    && cap->oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t\t    && (cap->oap->op_type != OP_NOP || VIsual_active))));\n}\n\n/*\n * Get one or more additional characters for a normal command.\n * Return the updated command index (if changed).\n */\n    static int\nnormal_cmd_get_more_chars(\n\tint\t    idx_arg,\n\tcmdarg_T    *cap,\n\tint\t    *need_flushbuf UNUSED)\n{\n    int\t\tidx = idx_arg;\n    int\t\tc;\n    int\t\t*cp;\n    int\t\trepl = FALSE;\t// get character for replace mode\n    int\t\tlit = FALSE;\t// get extra character literally\n    int\t\tlangmap_active = FALSE;    // using :lmap mappings\n    int\t\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n    int\t\tsave_smd;\t// saved value of p_smd\n#endif\n\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping for nchar, but allow key codes\n    // Don't generate a CursorHold event here, most commands can't handle\n    // it, e.g., nv_replace(), nv_csearch().\n    did_cursorhold = TRUE;\n    if (cap->cmdchar == 'g')\n    {\n\t/*\n\t * For 'g' get the next character now, so that we can check for\n\t * \"gr\", \"g'\" and \"g`\".\n\t */\n\tcap->nchar = plain_vgetc();\n\tLANGMAP_ADJUST(cap->nchar, TRUE);\n\t*need_flushbuf |= add_to_showcmd(cap->nchar);\n\tif (cap->nchar == 'r' || cap->nchar == '\\'' || cap->nchar == '`'\n\t\t|| cap->nchar == Ctrl_BSL)\n\t{\n\t    cp = &cap->extra_char;\t// need to get a third character\n\t    if (cap->nchar != 'r')\n\t\tlit = TRUE;\t\t\t// get it literally\n\t    else\n\t\trepl = TRUE;\t\t// get it in replace mode\n\t}\n\telse\n\t    cp = NULL;\t\t// no third character needed\n    }\n    else\n    {\n\tif (cap->cmdchar == 'r')\t\t// get it in replace mode\n\t    repl = TRUE;\n\tcp = &cap->nchar;\n    }\n    lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n    /*\n     * Get a second or third character.\n     */\n    if (cp != NULL)\n    {\n\tif (repl)\n\t{\n\t    State = MODE_REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t// show different cursor shape\n#endif\n\t}\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t{\n\t    // Allow mappings defined with \":lmap\".\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (repl)\n\t\tState = MODE_LREPLACE;\n\t    else\n\t\tState = MODE_LANGMAP;\n\t    langmap_active = TRUE;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tsave_smd = p_smd;\n\tp_smd = FALSE;\t// Don't let the IM code show the mode here\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t    im_set_active(TRUE);\n#endif\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Disable bracketed paste and modifyOtherKeys here, we won't\n\t    // recognize the escape sequences with 'esckeys' off.\n\t    out_str(T_BD);\n\t    out_str_t_TE();\n\t}\n\n\t*cp = plain_vgetc();\n\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Re-enable bracketed paste mode and modifyOtherKeys\n\t    out_str_t_BE();\n\t    out_str_t_TI();\n\t}\n\n\tif (langmap_active)\n\t{\n\t    // Undo the decrement done above\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    State = MODE_NORMAL_BUSY;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tif (lang)\n\t{\n\t    if (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\tim_save_status(&curbuf->b_p_iminsert);\n\t    im_set_active(FALSE);\n\t}\n\tp_smd = save_smd;\n#endif\n\tState = MODE_NORMAL_BUSY;\n\t*need_flushbuf |= add_to_showcmd(*cp);\n\n\tif (!lit)\n\t{\n#ifdef FEAT_DIGRAPHS\n\t    // Typing CTRL-K gets a digraph.\n\t    if (*cp == Ctrl_K\n\t\t    && ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t|| cp == &cap->extra_char)\n\t\t    && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t    {\n\t\tc = get_digraph(FALSE);\n\t\tif (c > 0)\n\t\t{\n\t\t    *cp = c;\n\t\t    // Guessing how to update showcmd here...\n\t\t    del_from_showcmd(3);\n\t\t    *need_flushbuf |= add_to_showcmd(*cp);\n\t\t}\n\t    }\n#endif\n\n\t    // adjust chars > 127, except after \"tTfFr\" commands\n\t    LANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t    // adjust Hebrew mapped char\n\t    if (p_hkmap && lang && KeyTyped)\n\t\t*cp = hkmap(*cp);\n#endif\n\t}\n\n\t// When the next character is CTRL-\\ a following CTRL-N means the\n\t// command is aborted and we go to Normal mode.\n\tif (cp == &cap->extra_char\n\t\t&& cap->nchar == Ctrl_BSL\n\t\t&& (cap->extra_char == Ctrl_N || cap->extra_char == Ctrl_G))\n\t{\n\t    cap->cmdchar = Ctrl_BSL;\n\t    cap->nchar = cap->extra_char;\n\t    idx = find_command(cap->cmdchar);\n\t}\n\telse if ((cap->nchar == 'n' || cap->nchar == 'N') && cap->cmdchar == 'g')\n\t    cap->oap->op_type = get_op_type(*cp, NUL);\n\telse if (*cp == Ctrl_BSL)\n\t{\n\t    long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t    // There is a busy wait here when typing \"f<C-\\>\" and then\n\t    // something different from CTRL-N.  Can't be avoided.\n\t    while ((c = vpeekc()) <= 0 && towait > 0L)\n\t    {\n\t\tdo_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\ttowait -= 50L;\n\t    }\n\t    if (c > 0)\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (c != Ctrl_N && c != Ctrl_G)\n\t\t    vungetc(c);\n\t\telse\n\t\t{\n\t\t    cap->cmdchar = Ctrl_BSL;\n\t\t    cap->nchar = c;\n\t\t    idx = find_command(cap->cmdchar);\n\t\t}\n\t    }\n\t}\n\n\t// When getting a text character and the next character is a\n\t// multi-byte character, it could be a composing character.\n\t// However, don't wait for it to arrive. Also, do enable mapping,\n\t// because if it's put back with vungetc() it's too late to apply\n\t// mapping.\n\t--no_mapping;\n\twhile (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t&& (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t{\n\t    c = plain_vgetc();\n\t    if (!utf_iscomposing(c))\n\t    {\n\t\tvungetc(c);\t\t// it wasn't, put it back\n\t\tbreak;\n\t    }\n\t    else if (cap->ncharC1 == 0)\n\t\tcap->ncharC1 = c;\n\t    else\n\t\tcap->ncharC2 = c;\n\t}\n\t++no_mapping;\n    }\n    --no_mapping;\n    --allow_keys;\n\n    return idx;\n}\n\n/*\n * Returns TRUE if after processing a normal mode command, need to wait for a\n * moment when a message is displayed that will be overwritten by the mode\n * message.\n */\n    static int\nnormal_cmd_need_to_wait_for_msg(cmdarg_T *cap, pos_T *old_pos)\n{\n    // In Visual mode and with \"^O\" in Insert mode, a short message will be\n    // overwritten by the mode message.  Wait a bit, until a key is hit.\n    // In Visual mode, it's more important to keep the Visual area updated\n    // than keeping a message (e.g. from a /pat search).\n    // Only do this if the command was typed, not from a mapping.\n    // Don't wait when emsg_silent is non-zero.\n    // Also wait a bit after an error message, e.g. for \"^O:\".\n    // Don't redraw the screen, it would remove the message.\n    return (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos->lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos->col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && cap->oap->regname == 0\n\t    && !(cap->retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && cap->oap->op_type == OP_NOP);\n}\n\n/*\n * After processing a normal mode command, wait for a moment when a message is\n * displayed that will be overwritten by the mode message.\n */\n    static void\nnormal_cmd_wait_for_msg(void)\n{\n    int\tsave_State = State;\n\n    // Draw the cursor with the right shape here\n    if (restart_edit != 0)\n\tState = MODE_INSERT;\n\n    // If need to redraw, and there is a \"keep_msg\", redraw before the\n    // delay\n    if (must_redraw && keep_msg != NULL && !emsg_on_display)\n    {\n\tchar_u\t*kmsg;\n\n\tkmsg = keep_msg;\n\tkeep_msg = NULL;\n\t// Showmode() will clear keep_msg, but we want to use it anyway.\n\t// First update w_topline.\n\tsetcursor();\n\tupdate_screen(0);\n\t// now reset it, otherwise it's put in the history again\n\tkeep_msg = kmsg;\n\n\tkmsg = vim_strsave(keep_msg);\n\tif (kmsg != NULL)\n\t{\n\t    msg_attr((char *)kmsg, keep_msg_attr);\n\t    vim_free(kmsg);\n\t}\n    }\n    setcursor();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    cursor_on();\n    out_flush();\n    if (msg_scroll || emsg_on_display)\n\tui_delay(1003L, TRUE);\t// wait at least one second\n    ui_delay(3003L, FALSE);\t\t// wait up to three seconds\n    State = save_State;\n\n    msg_scroll = FALSE;\n    emsg_on_display = FALSE;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    // If we are using the clipboard, then remember what was selected in case\n    // we need to paste it somewhere while we still own the selection.\n    // Only do this when the clipboard is already owned.  Don't want to grab\n    // the selection when hitting ESC.\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    may_trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    // if i == 0: try to find an identifier\n    // if i == 1: try to find any non-white text\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(e_no_string_under_cursor));\n\t    else\n\t\temsg(_(e_no_identifier_under_cursor));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    prep_redo_num2(regname, num, cmd1, cmd2, 0L, cmd3, cmd4, cmd5);\n}\n\n/*\n * Prepare for redo of any command with extra count after \"cmd2\".\n */\n    void\nprep_redo_num2(\n    int\t    regname,\n    long    num1,\n    int\t    cmd1,\n    int\t    cmd2,\n    long    num2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n\n#ifdef FEAT_EVAL\n    // Put info about a mapping in the redo buffer, so that \".\" will use the\n    // same script context.\n    may_add_last_used_map_to_redobuff();\n#endif\n\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num1 != 0)\n\tAppendNumberToRedobuff(num1);\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (num2 != 0)\n\tAppendNumberToRedobuff(num2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n    else\n\tclear_showcmd();\n}\n\n/*\n * Routines for displaying a partly typed command\n */\n\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len = (int)STRLEN(showcmd_buf);\n\n    showcmd_is_clear = (len == 0);\n    cursor_off();\n\n    if (*p_sloc == 's')\n\twin_redr_status(curwin, FALSE);\n    else if (*p_sloc == 't')\n\tdraw_tabline();\n    else // 'showcmdloc' is \"last\" or empty\n    {\n\tif (!showcmd_is_clear)\n\t    screen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\n\t// clear the rest of an old message by outputting up to SHOWCMD_COLS\n\t// spaces\n\tscreen_puts((char_u *)\"          \" + len,\n\t\t\t\t\t\t(int)Rows - 1, sc_col + len, 0);\n    }\n\n    setcursor();\t    // put cursor back where it belongs\n}\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    // Synchronize other windows, as necessary according to\n\t    // 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t    // when 'diff' is set.\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    // When switching between windows, make sure that the relative\n\t    // vertical offset is valid for the new window.  The relative\n\t    // offset is invalid whenever another 'scrollbind' window has\n\t    // scrolled to a point that would force the current window to\n\t    // scroll past the beginning or end of its buffer.  When the\n\t    // resync is performed, some of the other 'scrollbind' windows may\n\t    // need to jump so that the current window's relative position is\n\t    // visible on-screen.\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    // check 'scrollopt' string for vertical and horizontal scroll options\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    // loop through the scrollbound windows and scroll accordingly\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'noscrollbind'\n\tif (curwin == old_curwin || !curwin->w_p_scb)\n\t    continue;\n\n\t// do the vertical scroll\n\tif (want_ver)\n\t{\n#ifdef FEAT_DIFF\n\t    if (old_curwin->w_p_diff && curwin->w_p_diff)\n\t    {\n\t\tdiff_set_topline(old_curwin, curwin);\n\t    }\n\t    else\n#endif\n\t    {\n\t\tcurwin->w_scbind_pos += topline_diff;\n\t\ttopline = curwin->w_scbind_pos;\n\t\tif (topline > curbuf->b_ml.ml_line_count)\n\t\t    topline = curbuf->b_ml.ml_line_count;\n\t\tif (topline < 1)\n\t\t    topline = 1;\n\n\t\ty = topline - curwin->w_topline;\n\t\tif (y > 0)\n\t\t    scrollup(y, FALSE);\n\t\telse\n\t\t    scrolldown(-y, FALSE);\n\t    }\n\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n\n\t// do the horizontal scroll\n\tif (want_hor)\n\t    (void)set_leftcol(tgt_leftcol);\n    }\n\n    // reset current-window\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n    }\n    else\n    {\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n\t// clear any search statistics\n\tif (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\t    clear_cmdline = TRUE;\n    }\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    // With \"gD\" go to line 1.\n    // With \"gd\" Search back for the start of the current function, then go\n    // back until a blank line.  If this fails go to line 1.\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize_str(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      // Instead of sticking at the last character of the buffer line we\n      // try to stick in the last column of the screen.\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t// Check for landing on a character that got split at the end of the\n\t// last line.  We want to advance a screenline, not end up in the same\n\t// screenline or move two screenlines.\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n    adjust_skipcol();\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n    int\t\tprev_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value() > 0)\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n\t\t&& curwin->w_skipcol == prev_skipcol\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Get the count specified after a 'z' command. Only the 'z<CR>', 'zl', 'zh',\n * 'z<Left>', and 'z<Right>' commands accept a count after 'z'.\n * Returns TRUE to process the 'z' command and FALSE to skip it.\n */\n    static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t    n = n * 10 + (nchar - '0');\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}\n\n#ifdef FEAT_SPELL\n/*\n * \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n * \"zg\": add good word to word list\n * \"zw\": add wrong word to word list\n * \"zG\": add good word to temp word list\n * \"zW\": add wrong word to temp word list\n */\n    static int\nnv_zg_zw(cmdarg_T *cap, int nchar)\n{\n    char_u\t*ptr = NULL;\n    int\t\tlen;\n    int\t\tundo = FALSE;\n\n    if (nchar == 'u')\n    {\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return OK;\n\t}\n\tundo = TRUE;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn OK;\n    if (VIsual_active && get_visual_text(cap, &ptr, &len) == FAIL)\n\treturn FAIL;\n    if (ptr == NULL)\n    {\n\tpos_T\tpos = curwin->w_cursor;\n\n\t// Find bad word under the cursor.  When 'spell' is\n\t// off this fails and find_ident_under_cursor() is\n\t// used below.\n\temsg_off++;\n\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\temsg_off--;\n\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t    ptr = ml_get_pos(&curwin->w_cursor);\n\tcurwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL\n\t\t&& (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\treturn FAIL;\n    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t    ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t    (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1, undo);\n\n    return OK;\n}\n#endif\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n    long\tsiso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar) && !nv_z_get_count(cap, &nchar))\n\t    return;\n\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    // For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n    // If line number given, set cursor.\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol((colnr_T)cap->count1 > curwin->w_leftcol\n\t\t\t       ? 0 : curwin->w_leftcol - (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zL\" - scroll window left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll window to the left if not wrapping\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol(curwin->w_leftcol + (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(e_cannot_erase_folds_with_current_foldmethod));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\tif (nv_zg_zw(cap, nchar) == FAIL)\n\t\t    return;\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    do_mousescroll_horiz(scrollbar_value);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    // Ignore 'Q' in Visual mode, just give a beep.\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND\n\t\t\t\t\t   || cap->cmdchar == K_SCRIPT_COMMAND;\n    int\tflags;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tflags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;\n\tif (is_cmdkey)\n\t    cmd_result = do_cmdkey_command(cap->cmdchar, flags);\n\telse\n\t    cmd_result = do_cmdline(NULL, getexline, NULL, flags);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tmay_trigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(UPD_CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tmay_trigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * 'K' normal-mode command. Get the command to lookup the keyword under the\n * cursor.\n */\n    static int\nnv_K_getcmd(\n\tcmdarg_T\t*cap,\n\tchar_u\t\t*kp,\n\tint\t\tkp_help,\n\tint\t\tkp_ex,\n\tchar_u\t\t**ptr_arg,\n\tint\t\tn,\n\tchar_u\t\t*buf,\n\tunsigned\tbuflen)\n{\n    char_u\t*ptr = *ptr_arg;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (kp_help)\n    {\n\t// in the help buffer\n\tSTRCPY(buf, \"he! \");\n\treturn n;\n    }\n\n    if (kp_ex)\n    {\n\t// 'keywordprog' is an ex command\n\tif (cap->count0 != 0)\n\t    vim_snprintf((char *)buf, buflen, \"%s %ld\", kp, cap->count0);\n\telse\n\t    STRCPY(buf, kp);\n\tSTRCAT(buf, \" \");\n\treturn n;\n    }\n\n    // An external command will probably use an argument starting\n    // with \"-\" as an option.  To avoid trouble we skip the \"-\".\n    while (*ptr == '-' && n > 0)\n    {\n\t++ptr;\n\t--n;\n    }\n    if (n == 0)\n    {\n\t// found dashes only\n\temsg(_(e_no_identifier_under_cursor));\n\tvim_free(buf);\n\t*ptr_arg = ptr;\n\treturn 0;\n    }\n\n    // When a count is given, turn it into a range.  Is this\n    // really what we want?\n    isman = (STRCMP(kp, \"man\") == 0);\n    isman_s = (STRCMP(kp, \"man -s\") == 0);\n    if (cap->count0 != 0 && !(isman || isman_s))\n\tsprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n    STRCAT(buf, \"! \");\n    if (cap->count0 == 0 && isman_s)\n\tSTRCAT(buf, \"man\");\n    else\n\tSTRCAT(buf, kp);\n    STRCAT(buf, \" \");\n    if (cap->count0 != 0 && (isman || isman_s))\n    {\n\tsprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\tSTRCAT(buf, \" \");\n    }\n\n    *ptr_arg = ptr;\n    return n;\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    // The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_no_identifier_under_cursor));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    // Put cursor at start of word, makes search skip the word\n\t    // under the cursor.\n\t    // Call setpcmark() first, so \"*``\" puts the cursor back where\n\t    // it was.\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    n = nv_K_getcmd(cap, kp, kp_help, kp_ex, &ptr, n, buf, buflen);\n\t    if (n == 0)\n\t\treturn;\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    // Now grab the chars in the identifier\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    // Execute the command.\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    // In virtual edit mode, there's no such thing as \"past_line\", as lines\n    // are (theoretically) infinitely long.\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    //\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t    //\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t    // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_or_curbuf_locked(cap->oap))\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, 0);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (i > 0 && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n#ifdef FEAT_SEARCH_EXTRA\n    pos_T\tprev_cursor = curwin->w_cursor;\n#endif\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (!EQUAL_POS(curwin->w_cursor, prev_cursor) && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n */\n    static void\nnv_bracket_block(cmdarg_T *cap, pos_T *old_pos)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\tprev_pos;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    if (cap->nchar == '*')\n\tcap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\tif (cap->cmdchar == '[')\n\t    findc = '{';\n\telse\n\t    findc = '}';\n\tn = 9999;\n    }\n    else\n    {\n\tfindc = cap->nchar;\n\tn = cap->count1;\n    }\n    for ( ; n > 0; --n)\n    {\n\tif ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t{\n\t    if (new_pos.lnum == 0)\t// nothing found\n\t    {\n\t\tif (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t    clearopbeep(cap->oap);\n\t    }\n\t    else\n\t\tpos = &new_pos;\t// use last one found\n\t    break;\n\t}\n\tprev_pos = new_pos;\n\tcurwin->w_cursor = *pos;\n\tnew_pos = *pos;\n    }\n    curwin->w_cursor = *old_pos;\n\n    // Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n    // brought us to the match for \"[m\" and \"]M\" when inside a method.\n    // Try finding the '{' or '}' we want to be at.\n    // Also repeat for the given count.\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\t// norm is TRUE for \"]M\" and \"[m\"\n\tint\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\tn = cap->count1;\n\t// found a match: we were inside a method\n\tif (prev_pos.lnum != 0)\n\t{\n\t    pos = &prev_pos;\n\t    curwin->w_cursor = prev_pos;\n\t    if (norm)\n\t\t--n;\n\t}\n\telse\n\t    pos = NULL;\n\twhile (n > 0)\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t{\n\t\t    // if not found anything, that's an error\n\t\t    if (pos == NULL)\n\t\t\tclearopbeep(cap->oap);\n\t\t    n = 0;\n\t\t    break;\n\t\t}\n\t\tc = gchar_cursor();\n\t\tif (c == '{' || c == '}')\n\t\t{\n\t\t    // Must have found end/start of class: use it.\n\t\t    // Or found the place to be at.\n\t\t    if ((c == findc && norm) || (n == 1 && !norm))\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t\tn = 0;\n\t\t    }\n\t\t    // if no match found at all, we started outside of the\n\t\t    // class and we're inside now.  Just go on.\n\t\t    else if (new_pos.lnum == 0)\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t    }\n\t\t    // found start/end of other method: go to match\n\t\t    else if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t      (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t   0)) == NULL)\n\t\t\tn = 0;\n\t\t    else\n\t\t\tcurwin->w_cursor = *pos;\n\t\t    break;\n\t\t}\n\t    }\n\t    --n;\n\t}\n\tcurwin->w_cursor = *old_pos;\n\tif (pos == NULL && new_pos.lnum != 0)\n\t    clearopbeep(cap->oap);\n    }\n    if (pos != NULL)\n    {\n\tsetpcmark();\n\tcurwin->w_cursor = *pos;\n\tcurwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t&& cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Replacing with a TAB is done by edit() when it is complicated because\n    // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n    // Other characters are done below to avoid problems with things like\n    // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t// Replace character(s) by a single newline.\n\t// Strange vi behaviour: Only one newline is inserted.\n\t// Delete the characters here.\n\t// Insert the newline with an insert command, takes care of\n\t// autoindent.\tThe insert command depends on being on the last\n\t// character of a line or not.\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = MODE_REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    // Replace the characters within one line.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t// Get ptr again, because u_save and/or showmatch() will have\n\t\t// released the line.  This may also happen in ins_copychar().\n\t\t// At the same time we let know that the line will be changed.\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\t// line may have been flushed, get it again\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(e_changelist_is_empty));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(e_at_start_of_changelist));\n\t    else\n\t\temsg(_(e_at_end_of_changelist));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    may_trigger_modechanged();\n\t}\n\tredraw_curbuf_later(UPD_INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    // For V and ^V, we multiply the number of lines even if there\n\t    // was only one -- webb\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    update_curswant_force();\n\t\t    curwin->w_curswant += resel_VIsual_vcol * cap->count0;\n\t\t    if (*p_sel != 'e')\n\t\t\t--curwin->w_curswant;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tupdate_curswant_force();\n\t\tcurwin->w_curswant += + resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(UPD_INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n * When \"c\" is 'o' (checking for \"mouse\") then also when mapped.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (c == 'o' || (stuff_empty() && typebuf_typed()))\n\t\t    && vim_strchr(p_slm, c) != NULL;\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    may_trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < UPD_INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * \"gv\": Reselect the previous Visual area.  If Visual already active,\n *       exchange previous and current Visual area.\n */\n    static void\nnv_gv_cmd(cmdarg_T *cap)\n{\n    pos_T\ttpos;\n    int\t\ti;\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (curbuf->b_visual.vi_start.lnum == 0\n\t    || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t    || curbuf->b_visual.vi_end.lnum == 0)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // set w_cursor to the start of the Visual area, tpos to the end\n    if (VIsual_active)\n    {\n\ti = VIsual_mode;\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\tcurbuf->b_visual_mode_eval = i;\n# endif\n\ti = curwin->w_curswant;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\tcurbuf->b_visual.vi_curswant = i;\n\n\ttpos = curbuf->b_visual.vi_end;\n\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\tcurbuf->b_visual.vi_start = VIsual;\n    }\n    else\n    {\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\ttpos = curbuf->b_visual.vi_end;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n    }\n\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Set Visual to the start and w_cursor to the end of the Visual\n    // area.  Make sure they are on an existing character.\n    check_cursor();\n    VIsual = curwin->w_cursor;\n    curwin->w_cursor = tpos;\n    check_cursor();\n    update_topline();\n\n    // When called from normal \"g\" command: start Select mode when\n    // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n    // start Select mode.\n    if (cap->arg)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else\n\tmay_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n}\n\n/*\n * \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n * \"gm\": middle of \"g0\" and \"g$\".\n */\n    static void\nnv_g_home_m_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == '^')\n\tflag = TRUE;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tint\twidth1 = curwin->w_width - curwin_col_off();\n\tint\twidth2 = width1 + curwin_col_off2();\n\tint\tvirtcol;\n\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t    - curwin->w_virtcol_first_char\n#endif\n\t    ;\n\ti = 0;\n\tif (virtcol >= (colnr_T)width1 && width2 > 0)\n\t    i = (virtcol - width1) / width2 * width2 + width1;\n    }\n    else\n\ti = curwin->w_leftcol;\n    // Go to the middle of the screen line.  When 'number' or\n    // 'relativenumber' is on and lines are wrapping the middle can be more\n    // to the left.\n    if (cap->nchar == 'm')\n\ti += (curwin->w_width - curwin_col_off()\n\t\t+ ((curwin->w_p_wrap && i > 0)\n\t\t    ? curwin_col_off2() : 0)) / 2;\n    coladvance((colnr_T)i);\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneright() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"g_\": to the last non-blank character in the line or <count> lines\n *       downward.\n */\n    static void\nnv_g_underscore_cmd(cmdarg_T *cap)\n{\n    char_u  *ptr;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\tcap->oap->op_type == OP_NOP) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    ptr = ml_get_curline();\n\n    // In Visual mode we may end up after the line.\n    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t--curwin->w_cursor.col;\n\n    // Decrease the cursor column until it's on a non-blank.\n    while (curwin->w_cursor.col > 0\n\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t--curwin->w_cursor.col;\n    curwin->w_set_curswant = TRUE;\n    adjust_for_sel(cap);\n}\n\n/*\n * \"g$\" : Like \"$\" but for screen lines.\n */\n    static void\nnv_g_dollar_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n    int\t\tcol_off = curwin_col_off();\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = TRUE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\tif (cap->count1 == 1)\n\t{\n\t    int\t\twidth1 = curwin->w_width - col_off;\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\t    int\t\tvirtcol;\n\n\t    validate_virtcol();\n\t    virtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t;\n\t    i = width1 - 1;\n\t    if (virtcol >= (colnr_T)width1)\n\t\ti += ((virtcol - width1) / width2 + 1)\n\t\t    * width2;\n\t    coladvance((colnr_T)i);\n\n\t    // Make sure we stick in this column.\n\t    update_curswant_force();\n\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t    {\n\t\t// Check for landing on a character that got split at\n\t\t// the end of the line.  We do not want to advance to\n\t\t// the next screen line.\n\t\tif (curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t\t\t\t\t> (colnr_T)i)\n\t\t    --curwin->w_cursor.col;\n\t    }\n\t}\n\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t    clearopbeep(oap);\n    }\n    else\n    {\n\tif (cap->count1 > 1)\n\t    // if it fails, let the cursor still move to the last char\n\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\tcoladvance((colnr_T)i);\n\n\t// if the character doesn't fit move one back\n\tif (curwin->w_cursor.col > 0\n\t\t&& (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t{\n\t    colnr_T vcol;\n\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t--curwin->w_cursor.col;\n\t}\n\n\t// Make sure we stick in this column.\n\tupdate_curswant_force();\n    }\n}\n\n/*\n * \"gi\": start Insert at the last position.\n */\n    static void\nnv_gi_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n\n    if (curbuf->b_last_insert.lnum != 0)\n    {\n\tcurwin->w_cursor = curbuf->b_last_insert;\n\tcheck_cursor_lnum();\n\ti = (int)STRLEN(ml_get_curline());\n\tif (curwin->w_cursor.col > (colnr_T)i)\n\t{\n\t    if (virtual_active())\n\t\tcurwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t    curwin->w_cursor.col = i;\n\t}\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize_str(ml_get_curline());\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t0, NULL) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t// If \"restart_edit\" is TRUE, the last but one command is repeated\n\t// instead of the last command (inserting text). This is used for\n\t// CTRL-O <.> in insert mode.\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo or specify register in select mode\n */\n    static void\nnv_redo_or_register(cmdarg_T *cap)\n{\n    if (VIsual_select && VIsual_active)\n    {\n\tint reg;\n\t// Get register name\n\t++no_mapping;\n\t++allow_keys;\n\treg = plain_vgetc();\n\tLANGMAP_ADJUST(reg, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\n\tif (reg == '\"')\n\t    // the unnamed register is 0\n\t    reg = 0;\n\n\tVIsual_select_reg = valid_yank_reg(reg, TRUE) ? reg : 0;\n\treturn;\n    }\n\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    // Set inclusive for the \"E\" and \"e\" command.\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    // \"cw\" and \"cW\" are a special case.\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t// Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t// changes one character, not all blanks until the start of\n\t\t// the next word.  Only do this when the 'w' flag is included\n\t\t// in 'cpoptions'.\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// This is a little strange. To match what the real Vi does,\n\t\t// we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t// that we are not on a space or a TAB.  This seems impolite\n\t\t// at first, but it's really more what we mean when we say\n\t\t// 'cw'.\n\t\t// Another strangeness: When standing on the end of a word\n\t\t// \"ce\" will change until the end of the next word, but \"cw\"\n\t\t// will change only one character! This is done by setting\n\t\t// flag.\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0 && cmdwin_type == 0\n\t\t\t\t\t\t&& !VIsual_active && no_reason)\n\t{\n\t    int\tout_redir = !stdout_isatty && !is_not_a_term_or_gui();\n\n\t    // The user may accidentally do \"vim file | grep word\" and then\n\t    // CTRL-C doesn't show anything.  With a changed buffer give the\n\t    // message on stderr.  Without any changes might as well exit.\n\t    if (anyBufIsChanged())\n\t    {\n\t\tchar *ms = _(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\");\n\n\t\tif (out_redir)\n\t\t    mch_errmsg(ms);\n\t\telse\n\t\t    msg(ms);\n\t    }\n\t    else\n\t    {\n\t\tif (out_redir)\n\t\t{\n\t\t    got_int = FALSE;\n\t\t    do_cmdline_cmd((char_u *)\"qa\");\n\t\t}\n\t\telse\n\t\t    msg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t    }\n\t}\n\n\tif (restart_edit != 0)\n\t    redraw_mode = TRUE;  // remove \"-- (insert) --\"\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n    }\n    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to\n\t// break the loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(UPD_INVERTED);\n    }\n    else if (no_reason)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (!cap->arg && popup_message_win_visible())\n\t    popup_hide_message_win();\n\telse\n#endif\n\t    vim_beep(BO_ESC);\n    }\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = MODE_INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n\tnv_object(cap);\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\tint old_visual_mode = VIsual_mode;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\tif (*ml_get_cursor() != NUL)\n\t{\n\t    if (old_visual_mode == 'V')\n\t    {\n\t\t// In linewise Visual mode insert before the beginning of the\n\t\t// next line.\n\t\t// When the last line in the buffer was deleted then create a\n\t\t// new line, otherwise there is not need to move cursor.\n\t\t// Detect this by checking if cursor moved above Visual area.\n\t\tif (curwin->w_cursor.lnum < old_pos.lnum\n\t\t\t\t&& curwin->w_cursor.lnum < old_visual.lnum)\n\t\t{\n\t\t    if (u_save_cursor() == OK)\n\t\t    {\n\t\t\tml_append(curwin->w_cursor.lnum, (char_u *)\"\", 0,\n\t\t\t\t\t\t\t\t\tFALSE);\n\t\t\tappended_lines(curwin->w_cursor.lnum++, 1L);\n\t\t    }\n\t\t}\n\t    }\n\t    // When the last char in the line was deleted then append.\n\t    // Detect this by checking if cursor moved before Visual area.\n\t    else if (curwin->w_cursor.col < old_pos.col\n\t\t\t\t&& curwin->w_cursor.col < old_visual.col)\n\t\tinc_cursor();\n\t}\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = MODE_INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n#ifdef FEAT_EVAL\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n#endif\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    if (cmdwin_type != 0)\n\t    {\n\t\temsg(_(e_cmdline_window_already_open));\n\t\treturn;\n\t    }\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n    int\t\tkeep_registers = FALSE;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n\t    keep_registers = cap->cmdchar == 'P';\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = keep_registers ? '_' : NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Test for folding\n\nsource check.vim\nsource view_util.vim\nsource screendump.vim\n\nfunc PrepIndent(arg)\n  return [a:arg] + repeat([\"\\t\".a:arg], 5)\nendfu\n\nfunc Test_address_fold()\n  new\n  call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',\n\t      \\ 'after fold 1', 'after fold 2', 'after fold 3'])\n  setl fen fdm=marker\n  \" The next commands should all copy the same part of the buffer,\n  \" regardless of the addressing type, since the part to be copied\n  \" is folded away\n  :1y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :.+y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :.,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :sil .1,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  \" use silent to make E493 go away\n  :sil .+,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :,y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :,+y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/','after fold 1'], getreg(0,1,1))\n  \" using .+3 as second address should copy the whole folded line + the next 3\n  \" lines\n  :.,+3y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/',\n\t      \\ 'after fold 1', 'after fold 2', 'after fold 3'], getreg(0,1,1))\n  :sil .,-2y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n\n  \" now test again with folding disabled\n  set nofoldenable\n  :1y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  :.y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  :.+y\n  call assert_equal(['1'], getreg(0,1,1))\n  :.,.y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  \" use silent to make E493 go away\n  :sil .1,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))\n  \" use silent to make E493 go away\n  :sil .+,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))\n  :,y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  :,+y\n  call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))\n  \" using .+3 as second address should copy the whole folded line + the next 3\n  \" lines\n  :.,+3y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3'], getreg(0,1,1))\n  :7\n  :sil .,-2y\n  call assert_equal(['4', '5', '}/*}}}*/'], getreg(0,1,1))\n\n  quit!\nendfunc\n\nfunc Test_address_offsets()\n  \" check the help for :range-closed-fold\n  enew\n  call setline(1, [\n        \\ '1 one',\n        \\ '2 two',\n        \\ '3 three',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six',\n        \\ '7 seven',\n        \\ '8 eight',\n        \\])\n  set foldmethod=manual\n  normal 4Gvjzf\n  3,4+2yank\n  call assert_equal([\n        \\ '3 three',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six',\n        \\ '7 seven',\n        \\ ], getreg(0,1,1))\n\n  enew!\n  call setline(1, [\n        \\ '1 one',\n        \\ '2 two',\n        \\ '3 three FOLDED',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six FOLDED',\n        \\ '7 seven',\n        \\ '8 eight',\n        \\])\n  normal 3Gv3jzf\n  2,4-1yank\n  call assert_equal([\n        \\ '2 two',\n        \\ '3 three FOLDED',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six FOLDED',\n        \\ ], getreg(0,1,1))\n\n  bwipe!\nendfunc\n\nfunc Test_indent_fold()\n    new\n    call setline(1, ['', 'a', '    b', '    c'])\n    setl fen fdm=indent\n    2\n    norm! >>\n    let a=map(range(1,4), 'foldclosed(v:val)')\n    call assert_equal([-1,-1,-1,-1], a)\n    bw!\nendfunc\n\nfunc Test_indent_fold2()\n    new\n    call setline(1, ['', '{{{', '}}}', '{{{', '}}}'])\n    setl fen fdm=marker\n    2\n    norm! >>\n    let a=map(range(1,5), 'v:val->foldclosed()')\n    call assert_equal([-1,-1,-1,4,4], a)\n    bw!\nendfunc\n\n\" Test for fold indent with indents greater than 'foldnestmax'\nfunc Test_indent_fold_max()\n  new\n  setlocal foldmethod=indent\n  setlocal shiftwidth=2\n  \" 'foldnestmax' default value is 20\n  call setline(1, \"\\t\\t\\t\\t\\t\\ta\")\n  call assert_equal(20, foldlevel(1))\n  setlocal foldnestmax=10\n  call assert_equal(10, foldlevel(1))\n  setlocal foldnestmax=-1\n  call assert_equal(0, foldlevel(1))\n  bw!\nendfunc\n\nfunc Test_indent_fold_tabstop()\n  call setline(1, ['0', '    1', '    1', \"\\t2\", \"\\t2\"])\n  setlocal shiftwidth=4\n  setlocal foldcolumn=1\n  setlocal foldlevel=2\n  setlocal foldmethod=indent\n  redraw\n  call assert_equal('2        2', ScreenLines(5, 10)[0])\n  vsplit\n  windo diffthis\n  botright new\n  \" This 'tabstop' value should not be used for folding in other buffers.\n  setlocal tabstop=4\n  diffoff!\n  redraw\n  call assert_equal('2        2', ScreenLines(5, 10)[0])\n\n  bwipe!\n  bwipe!\nendfunc\n\nfunc Test_manual_fold_with_filter()\n  CheckExecutable cat\n  for type in ['manual', 'marker']\n    exe 'set foldmethod=' . type\n    new\n    call setline(1, range(1, 20))\n    4,$fold\n    %foldopen\n    10,$fold\n    %foldopen\n    \" This filter command should not have an effect\n    1,8! cat\n    call feedkeys('5ggzdzMGdd', 'xt')\n    call assert_equal(['1', '2', '3', '4', '5', '6', '7', '8', '9'], getline(1, '$'))\n\n    bwipe!\n    set foldmethod&\n  endfor\nendfunc\n\nfunc Test_indent_fold_with_read()\n  new\n  set foldmethod=indent\n  call setline(1, repeat([\"\\<Tab>a\"], 4))\n  for n in range(1, 4)\n    call assert_equal(1, foldlevel(n))\n  endfor\n\n  call writefile([\"a\", \"\", \"\\<Tab>a\"], 'Xinfofile', 'D')\n  foldopen\n  2read Xinfofile\n  %foldclose\n  call assert_equal(1, foldlevel(1))\n  call assert_equal(2, foldclosedend(1))\n  call assert_equal(0, foldlevel(3))\n  call assert_equal(0, foldlevel(4))\n  call assert_equal(1, foldlevel(5))\n  call assert_equal(7, 5->foldclosedend())\n\n  bwipe!\n  set foldmethod&\nendfunc\n\nfunc Test_combining_folds_indent()\n  new\n  let one = \"\\<Tab>a\"\n  let zero = 'a'\n  call setline(1, [one, one, zero, zero, zero, one, one, one])\n  set foldmethod=indent\n  3,5d\n  %foldclose\n  call assert_equal(5, foldclosedend(1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc Test_combining_folds_marker()\n  new\n  call setline(1, ['{{{', '}}}', '', '', '', '{{{', '', '}}}'])\n  set foldmethod=marker\n  3,5d\n  %foldclose\n  call assert_equal(2, foldclosedend(1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc Test_folds_marker_in_comment()\n  new\n  call setline(1, ['\" foo', 'bar', 'baz'])\n  setl fen fdm=marker\n  setl com=sO:\\\"\\ -,mO:\\\"\\ \\ ,eO:\\\"\\\",:\\\" cms=\\\"%s\n  norm! zf2j\n  setl nofen\n  :1y\n  call assert_equal(['\" foo{{{'], getreg(0,1,1))\n  :+2y\n  call assert_equal(['baz\"}}}'], getreg(0,1,1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc s:TestFoldExpr(lnum)\n  let thisline = getline(a:lnum)\n  if thisline == 'a'\n    return 1\n  elseif thisline == 'b'\n    return 0\n  elseif thisline == 'c'\n    return '<1'\n  elseif thisline == 'd'\n    return '>1'\n  endif\n  return 0\nendfunction\n\nfunc Test_update_folds_expr_read()\n  new\n  call setline(1, ['a', 'a', 'a', 'a', 'a', 'a'])\n  set foldmethod=expr\n  set foldexpr=s:TestFoldExpr(v:lnum)\n  2\n  foldopen\n  call writefile(['b', 'b', 'a', 'a', 'd', 'a', 'a', 'c'], 'Xupfofile', 'D')\n  read Xupfofile\n  %foldclose\n  call assert_equal(2, foldclosedend(1))\n  call assert_equal(0, foldlevel(3))\n  call assert_equal(0, 4->foldlevel())\n  call assert_equal(6, foldclosedend(5))\n  call assert_equal(10, foldclosedend(7))\n  call assert_equal(14, foldclosedend(11))\n\n  bwipe!\n  set foldmethod& foldexpr&\nendfunc\n\n\" Test for what patch 8.1.0535 fixes.\nfunc Test_foldexpr_no_interrupt_addsub()\n  new\n  func! FoldFunc()\n    call setpos('.', getcurpos())\n    return '='\n  endfunc\n\n  set foldmethod=expr\n  set foldexpr=FoldFunc()\n  call setline(1, '1.2')\n\n  exe \"norm! $\\<C-A>\"\n  call assert_equal('1.3', getline(1))\n\n  bwipe!\n  delfunc FoldFunc\n  set foldmethod& foldexpr&\nendfunc\n\n\" Fold function defined in another script\nfunc Test_foldexpr_compiled()\n  new\n  let lines =<< trim END\n      vim9script\n      def FoldFunc(): number\n        return v:lnum\n      enddef\n\n      set foldmethod=expr\n      set foldexpr=s:FoldFunc()\n  END\n  call writefile(lines, 'XfoldExpr', 'D')\n  source XfoldExpr\n\n  call setline(1, ['one', 'two', 'three'])\n  redraw\n  call assert_equal(1, foldlevel(1))\n  call assert_equal(2, foldlevel(2))\n  call assert_equal(3, foldlevel(3))\n\n  bwipe!\n  set foldmethod& foldexpr&\nendfunc\n\nfunc Check_foldlevels(expected)\n  call assert_equal(a:expected, map(range(1, line('$')), 'foldlevel(v:val)'))\nendfunc\n\nfunc Test_move_folds_around_manual()\n  new\n  let input = PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\")\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  let folds=[-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14]\n  \" all folds closed\n  set foldenable foldlevel=0 fdm=indent\n  \" needs a forced redraw\n  redraw!\n  set fdm=manual\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  call assert_equal(input, getline(1, '$'))\n  7,12m0\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  10,12m0\n  call assert_equal(PrepIndent(\"a\")[1:] + PrepIndent(\"b\") + [\"a\"] +  PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal([1, 1, 1, 1, 1, -1, 7, 7, 7, 7, 7, -1, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  \" moving should not close the folds\n  %d\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  set fdm=indent\n  redraw!\n  set fdm=manual\n  call cursor(2, 1)\n  %foldopen\n  7,12m0\n  let folds=repeat([-1], 18)\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  norm! zM\n  \" folds are not corrupted and all have been closed\n  call assert_equal([-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\"])\n  set fdm=indent\n  redraw!\n  set fdm=manual\n  %foldopen\n  3m4\n  %foldclose\n  call assert_equal([\"a\", \"\\tb\", \"\\td\", \"\\tc\", \"\\te\"], getline(1, '$'))\n  call assert_equal([-1, 5, 5, 5, 5], map(range(1, line('$')), 'foldclosedend(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"])\n  set fdm=indent foldlevel=0\n  set fdm=manual\n  %foldopen\n  3m1\n  %foldclose\n  call assert_equal([\"a\", \"\\tc\", \"\\tb\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"], getline(1, '$'))\n  call assert_equal(0, foldlevel(2))\n  call assert_equal(5, foldclosedend(3))\n  call assert_equal([-1, -1, 3, 3, 3, -1, 7, 7, 7, 7], map(range(1, line('$')), 'foldclosed(v:val)'))\n  2,6m$\n  %foldclose\n  call assert_equal(5, foldclosedend(2))\n  call assert_equal(0, foldlevel(6))\n  call assert_equal(9, foldclosedend(7))\n  call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, -1], map(range(1, line('$')), 'foldclosed(v:val)'))\n\n  %d\n  \" Ensure moving around the edges still works.\n  call setline(1, PrepIndent(\"a\") + repeat([\"a\"], 3) + [\"\\ta\"])\n  set fdm=indent foldlevel=0\n  set fdm=manual\n  %foldopen\n  6m$\n  \" The first fold has been truncated to the 5'th line.\n  \" Second fold has been moved up because the moved line is now below it.\n  call Check_foldlevels([0, 1, 1, 1, 1, 0, 0, 0, 1, 0])\n\n  %delete\n  set fdm=indent foldlevel=0\n  call setline(1, [\n\t\\ \"a\",\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"a\",\n\t\\ \"a\"])\n  set fdm=manual\n  %foldopen!\n  4,5m6\n  call Check_foldlevels([0, 1, 2, 0, 0, 0, 0])\n\n  %delete\n  set fdm=indent\n  call setline(1, [\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\ta\",\n\t\\ \"a\"])\n  set fdm=manual\n  %foldopen!\n  13m7\n  call Check_foldlevels([1, 2, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 0])\n  \n  bw!\nendfunc\n\nfunc Test_move_folds_around_indent()\n  new\n  let input = PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\")\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  let folds=[-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14]\n  \" all folds closed\n  set fdm=indent\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  call assert_equal(input, getline(1, '$'))\n  7,12m0\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  10,12m0\n  call assert_equal(PrepIndent(\"a\")[1:] + PrepIndent(\"b\") + [\"a\"] +  PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal([1, 1, 1, 1, 1, -1, 7, 7, 7, 7, 7, -1, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  \" moving should not close the folds\n  %d\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  set fdm=indent\n  call cursor(2, 1)\n  %foldopen\n  7,12m0\n  let folds=repeat([-1], 18)\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  norm! zM\n  \" folds are not corrupted and all have been closed\n  call assert_equal([-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\"])\n  set fdm=indent\n  %foldopen\n  3m4\n  %foldclose\n  call assert_equal([\"a\", \"\\tb\", \"\\td\", \"\\tc\", \"\\te\"], getline(1, '$'))\n  call assert_equal([-1, 5, 5, 5, 5], map(range(1, line('$')), 'foldclosedend(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"])\n  set fdm=indent foldlevel=0\n  %foldopen\n  3m1\n  %foldclose\n  call assert_equal([\"a\", \"\\tc\", \"\\tb\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"], getline(1, '$'))\n  call assert_equal(1, foldlevel(2))\n  call assert_equal(5, foldclosedend(3))\n  call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, 7], map(range(1, line('$')), 'foldclosed(v:val)'))\n  2,6m$\n  %foldclose\n  call assert_equal(9, foldclosedend(2))\n  call assert_equal(1, foldlevel(6))\n  call assert_equal(9, foldclosedend(7))\n  call assert_equal([-1, 2, 2, 2, 2, 2, 2, 2, 2, -1], map(range(1, line('$')), 'foldclosed(v:val)'))\n  \" Ensure moving around the edges still works.\n  %d\n  call setline(1, PrepIndent(\"a\") + repeat([\"a\"], 3) + [\"\\ta\"])\n  set fdm=indent foldlevel=0\n  %foldopen\n  6m$\n  \" The first fold has been truncated to the 5'th line.\n  \" Second fold has been moved up because the moved line is now below it.\n  call Check_foldlevels([0, 1, 1, 1, 1, 0, 0, 0, 1, 1])\n  bw!\nendfunc\n\nfunc Test_folddoopen_folddoclosed()\n  new\n  call setline(1, range(1, 9))\n  set foldmethod=manual\n  1,3 fold\n  6,8 fold\n\n  \" Test without range.\n  folddoopen   s/$/o/\n  folddoclosed s/$/c/\n  call assert_equal(['1c', '2c', '3c',\n  \\                  '4o', '5o',\n  \\                  '6c', '7c', '8c',\n  \\                  '9o'], getline(1, '$'))\n\n  \" Test with range.\n  call setline(1, range(1, 9))\n  1,8 folddoopen   s/$/o/\n  4,$ folddoclosed s/$/c/\n  call assert_equal(['1',  '2', '3',\n  \\                  '4o', '5o',\n  \\                  '6c', '7c', '8c',\n  \\                  '9'], getline(1, '$'))\n\n  set foldmethod&\n  bw!\nendfunc\n\nfunc Test_fold_error()\n  new\n  call setline(1, [1, 2])\n\n  for fm in ['indent', 'expr', 'syntax', 'diff']\n    exe 'set foldmethod=' . fm\n    call assert_fails('norm zf', 'E350:')\n    call assert_fails('norm zd', 'E351:')\n    call assert_fails('norm zE', 'E352:')\n  endfor\n\n  set foldmethod=manual\n  call assert_fails('norm zd', 'E490:')\n  call assert_fails('norm zo', 'E490:')\n  call assert_fails('3fold',   'E16:')\n\n  set foldmethod=marker\n  set nomodifiable\n  call assert_fails('1,2fold', 'E21:')\n\n  set modifiable&\n  set foldmethod&\n  bw!\nendfunc\n\nfunc Test_foldtext_recursive()\n  new\n  call setline(1, ['{{{', 'some text', '}}}'])\n  setlocal foldenable foldmethod=marker foldtext=foldtextresult(v\\:foldstart)\n  \" This was crashing because of endless recursion.\n  2foldclose\n  redraw\n  call assert_equal(1, foldlevel(2))\n  call assert_equal(1, foldclosed(2))\n  call assert_equal(3, foldclosedend(2))\n  bwipe!\nendfunc\n\n\" Various fold related tests\n\n\" Basic test if a fold can be created, opened, moving to the end and closed\nfunc Test_fold_manual()\n  new\n  set fdm=manual\n\n  let content = ['1 aa', '2 bb', '3 cc']\n  call append(0, content)\n  call cursor(1, 1)\n  normal zf2j\n  call assert_equal('1 aa', getline(foldclosed('.')))\n  normal zo\n  call assert_equal(-1, foldclosed('.'))\n  normal ]z\n  call assert_equal('3 cc', getline('.'))\n  normal zc\n  call assert_equal('1 aa', getline(foldclosed('.')))\n\n  \" Create a fold inside a closed fold after setting 'foldlevel'\n  %d _\n  call setline(1, range(1, 5))\n  1,5fold\n  normal zR\n  2,4fold\n  set foldlevel=1\n  3fold\n  call assert_equal([1, 3, 3, 3, 1], map(range(1, 5), {->foldlevel(v:val)}))\n  set foldlevel&\n\n  \" Create overlapping folds (at the start and at the end)\n  normal zE\n  2,3fold\n  normal zR\n  3,4fold\n  call assert_equal([0, 2, 2, 1, 0], map(range(1, 5), {->foldlevel(v:val)}))\n  normal zE\n  3,4fold\n  normal zR\n  2,3fold\n  call assert_equal([0, 1, 2, 2, 0], map(range(1, 5), {->foldlevel(v:val)}))\n\n  \" Create a nested fold across two non-adjoining folds\n  %d _\n  call setline(1, range(1, 7))\n  1,2fold\n  normal zR\n  4,5fold\n  normal zR\n  6,7fold\n  normal zR\n  1,5fold\n  call assert_equal([2, 2, 1, 2, 2, 1, 1],\n        \\ map(range(1, 7), {->foldlevel(v:val)}))\n\n  \" A newly created nested fold should be closed\n  %d _\n  call setline(1, range(1, 6))\n  1,6fold\n  normal zR\n  3,4fold\n  normal zR\n  2,5fold\n  call assert_equal([1, 2, 3, 3, 2, 1], map(range(1, 6), {->foldlevel(v:val)}))\n  call assert_equal(2, foldclosed(4))\n  call assert_equal(5, foldclosedend(4))\n\n  \" Test zO, zC and zA on a line with no folds.\n  normal zE\n  call assert_fails('normal zO', 'E490:')\n  call assert_fails('normal zC', 'E490:')\n  call assert_fails('normal zA', 'E490:')\n\n  set fdm&\n  bw!\nendfunc\n\n\" test folding with markers.\nfunc Test_fold_marker()\n  new\n  set fdm=marker fdl=1 fdc=3\n\n  let content = ['4 dd {{{', '5 ee {{{ }}}', '6 ff }}}']\n  call append(0, content)\n  call cursor(2, 1)\n  call assert_equal(2, foldlevel('.'))\n  normal [z\n  call assert_equal(1, foldlevel('.'))\n  exe \"normal jo{{ \\<Esc>r{jj\"\n  call assert_equal(1, foldlevel('.'))\n  normal kYpj\n  call assert_equal(0, foldlevel('.'))\n\n  \" Use only closing fold marker (without and with a count)\n  set fdl&\n  %d _\n  call setline(1, ['one }}}', 'two'])\n  call assert_equal([0, 0], [foldlevel(1), foldlevel(2)])\n  %d _\n  call setline(1, ['one }}}4', 'two'])\n  call assert_equal([4, 3], [foldlevel(1), foldlevel(2)])\n\n  set fdm& fdl& fdc&\n  bw!\nendfunc\n\n\" test create fold markers with C filetype\nfunc Test_fold_create_marker_in_C()\n  bw!\n  set fdm=marker fdl=9\n  set filetype=c\n\n  let content =<< trim [CODE]\n    /*\n     * comment\n     * \n     *\n     */\n    int f(int* p) {\n        *p = 3;\n        return 0;\n    }\n  [CODE]\n\n  for c in range(len(content) - 1)\n    bw!\n    call append(0, content)\n    call cursor(c + 1, 1)\n    norm! zfG\n    call assert_equal(content[c] . (c < 4 ? '{{{' : '/*{{{*/'), getline(c + 1))\n  endfor\n\n  set fdm& fdl&\n  bw!\nendfunc\n\n\" test folding with indent\nfunc Test_fold_indent()\n  new\n  set fdm=indent sw=2\n\n  let content = ['1 aa', '2 bb', '3 cc']\n  call append(0, content)\n  call cursor(2, 1)\n  exe \"normal i  \\<Esc>jI    \"\n  call assert_equal(2, foldlevel('.'))\n  normal k\n  call assert_equal(1, foldlevel('.'))\n\n  set fdm& sw&\n  bw!\nendfunc\n\n\" test syntax folding\nfunc Test_fold_syntax()\n  CheckFeature syntax\n\n  new\n  set fdm=syntax fdl=0\n\n  syn region Hup start=\"dd\" end=\"ii\" fold contains=Fd1,Fd2,Fd3\n  syn region Fd1 start=\"ee\" end=\"ff\" fold contained\n  syn region Fd2 start=\"gg\" end=\"hh\" fold contained\n  syn region Fd3 start=\"commentstart\" end=\"commentend\" fold contained\n  let content = ['3 cc', '4 dd {{{', '5 ee {{{ }}}', '{{{{', '6 ff }}}',\n\t      \\ '6 ff }}}', '7 gg', '8 hh', '9 ii']\n  call append(0, content)\n  normal Gzk\n  call assert_equal('9 ii', getline('.'))\n  normal k\n  call assert_equal('3 cc', getline('.'))\n  exe \"normal jAcommentstart   \\<Esc>Acommentend\"\n  set fdl=1\n  normal 3j\n  call assert_equal('7 gg', getline('.'))\n  set fdl=0\n  exe \"normal zO\\<C-L>j\"\n  call assert_equal('8 hh', getline('.'))\n  syn clear Fd1 Fd2 Fd3 Hup\n\n  set fdm& fdl&\n  bw!\nendfunc\n\nfunc Flvl()\n  let l = getline(v:lnum)\n  if l =~ \"bb$\"\n    return 2\n  elseif l =~ \"gg$\"\n    return \"s1\"\n  elseif l =~ \"ii$\"\n    return \">2\"\n  elseif l =~ \"kk$\"\n    return \"0\"\n  endif\n  return \"=\"\nendfun\n\n\" test expression folding\nfunc Test_fold_expr()\n  new\n  set fdm=expr fde=Flvl()\n\n  let content = ['1 aa',\n\t      \\ '2 bb',\n\t      \\ '3 cc',\n\t      \\ '4 dd {{{commentstart  commentend',\n\t      \\ '5 ee {{{ }}}',\n\t      \\ '{{{',\n\t      \\ '6 ff }}}',\n\t      \\ '6 ff }}}',\n\t      \\ '  7 gg',\n\t      \\ '    8 hh',\n\t      \\ '9 ii',\n\t      \\ 'a jj',\n\t      \\ 'b kk']\n  call append(0, content)\n  call cursor(1, 1)\n  exe \"normal /bb$\\<CR>\"\n  call assert_equal(2, foldlevel('.'))\n  exe \"normal /hh$\\<CR>\"\n  call assert_equal(1, foldlevel('.'))\n  exe \"normal /ii$\\<CR>\"\n  call assert_equal(2, foldlevel('.'))\n  exe \"normal /kk$\\<CR>\"\n  call assert_equal(0, foldlevel('.'))\n\n  set fdm& fde&\n  bw!\nendfunc\n\n\" Bug with fdm=indent and moving folds\n\" Moving a fold a few times, messes up the folds below the moved fold.\n\" Fixed by 7.4.700\nfunc Test_fold_move()\n  new\n  set fdm=indent sw=2 fdl=0\n\n  let content = ['', '', 'Line1', '  Line2', '  Line3',\n\t      \\ 'Line4', '  Line5', '  Line6',\n\t      \\ 'Line7', '  Line8', '  Line9']\n  call append(0, content)\n  normal zM\n  call cursor(4, 1)\n  move 2\n  move 1\n  call assert_equal(7, foldclosed(7))\n  call assert_equal(8, foldclosedend(7))\n  call assert_equal(0, foldlevel(9))\n  call assert_equal(10, foldclosed(10))\n  call assert_equal(11, foldclosedend(10))\n  call assert_equal('+--  2 lines: Line2', foldtextresult(2))\n  call assert_equal('+--  2 lines: Line8', 10->foldtextresult())\n\n  set fdm& sw& fdl&\n  bw!\nendfunc\n\n\" test for patch 7.3.637\n\" Cannot catch the error caused by a foldopen when there is no fold.\nfunc Test_foldopen_exception()\n  new\n  let a = 'No error caught'\n  try\n    foldopen\n  catch\n    let a = matchstr(v:exception,'^[^ ]*')\n  endtry\n  call assert_equal('Vim(foldopen):E490:', a)\n\n  let a = 'No error caught'\n  try\n    foobar\n  catch\n    let a = matchstr(v:exception,'^[^ ]*')\n  endtry\n  call assert_match('E492:', a)\n  bw!\nendfunc\n\nfunc Test_fold_last_line_with_pagedown()\n  new\n  set fdm=manual\n\n  let expect = '+-- 11 lines: 9---'\n  let content = range(1,19)\n  call append(0, content)\n  normal dd9G\n  normal zfG\n  normal zt\n  call assert_equal('9', getline(foldclosed('.')))\n  call assert_equal('19', getline(foldclosedend('.')))\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n  call feedkeys(\"\\<C-F>\", 'xt')\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n  call feedkeys(\"\\<C-F>\", 'xt')\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n  call feedkeys(\"\\<C-B>\\<C-F>\\<C-F>\", 'xt')\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n\n  set fdm&\n  bw!\nendfunc\n\nfunc Test_folds_with_rnu()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set fdm=marker rnu foldcolumn=2',\n\t\\ 'call setline(1, [\"{{{1\", \"nline 1\", \"{{{1\", \"line 2\"])',\n\t\\ ], 'Xtest_folds_with_rnu', 'D')\n  let buf = RunVimInTerminal('-S Xtest_folds_with_rnu', {})\n\n  call VerifyScreenDump(buf, 'Test_folds_with_rnu_01', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_folds_with_rnu_02', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_folds_marker_in_comment2()\n  new\n  call setline(1, ['Lorem ipsum dolor sit', 'Lorem ipsum dolor sit', 'Lorem ipsum dolor sit'])\n  setl fen fdm=marker\n  setl commentstring=<!--%s-->\n  setl comments=s:<!--,m:\\ \\ \\ \\ ,e:-->\n  norm! zf2j\n  setl nofen\n  :1y\n  call assert_equal(['Lorem ipsum dolor sit<!--{{{-->'], getreg(0,1,1))\n  :+2y\n  call assert_equal(['Lorem ipsum dolor sit<!--}}}-->'], getreg(0,1,1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc Test_fold_delete_with_marker()\n  new\n  call setline(1, ['func Func() {{{1', 'endfunc'])\n  1,2yank\n  new\n  set fdm=marker\n  call setline(1, 'x')\n  normal! Vp\n  normal! zd\n  call assert_equal(['func Func() ', 'endfunc'], getline(1, '$'))\n\n  set fdm&\n  bwipe!\n  bwipe!\nendfunc\n\nfunc Test_fold_delete_with_marker_and_whichwrap()\n  new\n  let content1 = ['']\n  let content2 = ['folded line 1 \"{{{1', '  test', '  test2', '  test3', '', 'folded line 2 \"{{{1', '  test', '  test2', '  test3']\n  call setline(1, content1 + content2)\n  set fdm=marker ww+=l\n  normal! x\n  call assert_equal(content2, getline(1, '$'))\n  set fdm& ww&\n  bwipe!\nendfunc\n\nfunc Test_fold_delete_first_line()\n  new\n  call setline(1, [\n\t\\ '\" x {{{1',\n\t\\ '\" a',\n\t\\ '\" aa',\n\t\\ '\" x {{{1',\n\t\\ '\" b',\n\t\\ '\" bb',\n\t\\ '\" x {{{1',\n\t\\ '\" c',\n\t\\ '\" cc',\n\t\\ ])\n  set foldmethod=marker\n  1\n  normal dj\n  call assert_equal([\n\t\\ '\" x {{{1',\n\t\\ '\" c',\n\t\\ '\" cc',\n\t\\ ], getline(1,'$'))\n  bwipe!\n  set foldmethod&\nendfunc\n\n\" Add a test for deleting the outer fold of a nested fold and promoting the\n\" inner folds to one level up with already a fold at that level following the\n\" nested fold.\nfunc Test_fold_delete_recursive_fold()\n  new\n  call setline(1, range(1, 7))\n  2,3fold\n  normal zR\n  4,5fold\n  normal zR\n  1,5fold\n  normal zR\n  6,7fold\n  normal zR\n  normal 1Gzd\n  normal 1Gzj\n  call assert_equal(2, line('.'))\n  normal zj\n  call assert_equal(4, line('.'))\n  normal zj\n  call assert_equal(6, line('.'))\n  bw!\nendfunc\n\n\" Test for errors in 'foldexpr'\nfunc Test_fold_expr_error()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  \" In a window with no folds, foldlevel() should return 0\n  call assert_equal(0, foldlevel(1))\n\n  \" Return a list from the expression\n  set foldexpr=[]\n  set foldmethod=expr\n  for i in range(3)\n    call assert_equal(0, foldlevel(i))\n  endfor\n\n  \" expression error\n  set foldexpr=[{]\n  set foldmethod=expr\n  for i in range(3)\n    call assert_equal(0, foldlevel(i))\n  endfor\n\n  set foldmethod& foldexpr&\n  close!\nendfunc\n\nfunc Test_undo_fold_deletion()\n  new\n  set fdm=marker\n  let lines =<< trim END\n      \" {{{\n      \" }}}1\n      \" {{{\n  END\n  call setline(1, lines)\n  3d\n  g/\"/d\n  undo\n  redo\n  eval getline(1, '$')->assert_equal([''])\n\n  set fdm&vim\n  bwipe!\nendfunc\n\n\" this was crashing\nfunc Test_move_no_folds()\n  new\n  fold\n  setlocal fdm=expr\n  normal zj\n  bwipe!\nendfunc\n\n\" this was crashing\nfunc Test_fold_create_delete_create()\n  new\n  fold\n  fold\n  normal zd\n  fold\n  bwipe!\nendfunc\n\n\" this was crashing\nfunc Test_fold_create_delete()\n  new\n  norm zFzFzdzj\n  bwipe!\nendfunc\n\nfunc Test_fold_relative_move()\n  new\n  set fdm=indent sw=2 wrap tw=80\n\n  let longtext = repeat('x', &columns + 1)\n  let content = [ '  foo', '  ' .. longtext, '  baz',\n              \\   longtext,\n              \\   '  foo', '  ' .. longtext, '  baz'\n              \\ ]\n  call append(0, content)\n\n  normal zM\n\n  for lnum in range(1, 3)\n    call cursor(lnum, 1)\n    call assert_true(foldclosed(line('.')))\n    normal gj\n    call assert_equal(2, winline())\n  endfor\n\n  call cursor(2, 1)\n  call assert_true(foldclosed(line('.')))\n  normal 2gj\n  call assert_equal(3, winline())\n\n  for lnum in range(5, 7)\n    call cursor(lnum, 1)\n    call assert_true(foldclosed(line('.')))\n    normal gk\n    call assert_equal(3, winline())\n  endfor\n\n  call cursor(6, 1)\n  call assert_true(foldclosed(line('.')))\n  normal 2gk\n  call assert_equal(2, winline())\n\n  set fdm& sw& wrap& tw&\n  bw!\nendfunc\n\n\" Test for using multibyte characters as 'foldopen', 'foldclose' and\n\" 'foldsetp' items in 'fillchars'\nfunc s:mbyte_fillchar_tests(fo, fc, fs)\n  setlocal foldcolumn=3\n\n  normal zE\n  1,2fold\n  call assert_equal([a:fc .. '  +--  2 ', '   three  '],\n        \\ ScreenLines([1, 2], 10))\n  1,2foldopen\n  call assert_equal([a:fo .. '  one ', a:fs .. '  two '],\n        \\ ScreenLines([1, 2], 7))\n  1,2foldclose\n  redraw!\n  call assert_equal([a:fc .. '  +--  2 ', '   three  '],\n        \\  ScreenLines([1, 2], 10))\n\n  \" Two level fold\n  normal zE\n  2,3fold\n  1,4fold\n  call assert_equal([a:fc .. '  +--  4 ', '   five   '],\n        \\ ScreenLines([1, 2], 10))\n  1,4foldopen\n  call assert_equal([a:fo .. '  one    ', a:fs .. a:fc .. ' +---  2'],\n        \\ ScreenLines([1, 2], 10))\n  1,4foldopen\n  call assert_equal([a:fo .. '  one    ', a:fs .. a:fo .. ' two    ',\n        \\ a:fs .. a:fs .. ' three  '], ScreenLines([1, 3], 10))\n  2,3foldclose\n  call assert_equal([a:fo .. '  one    ', a:fs .. a:fc .. ' +---  2'],\n        \\ ScreenLines([1, 2], 10))\n  1,4foldclose\n  call assert_equal([a:fc .. '  +--  4 ', '   five   '],\n        \\ ScreenLines([1, 2], 10))\n\n  \" Three level fold\n  normal zE\n  3,4fold\n  2,5fold\n  1,6fold\n  call assert_equal([a:fc .. '  +--  6 '], ScreenLines(1, 10))\n  \" open all the folds\n  normal zR\n  call assert_equal([\n        \\ a:fo .. '  one    ',\n        \\ a:fs .. a:fo .. ' two    ',\n        \\ '2' .. a:fo .. ' three  ',\n        \\ '23 four   ',\n        \\ a:fs .. a:fs .. ' five   ',\n        \\ a:fs .. '  six    ',\n        \\ ], ScreenLines([1, 6], 10))\n  \" close the innermost fold\n  3,4foldclose\n  call assert_equal([\n        \\ a:fo .. '  one    ',\n        \\ a:fs .. a:fo .. ' two    ',\n        \\ a:fs .. a:fs .. a:fc .. '+----  ',\n        \\ a:fs .. a:fs .. ' five   ',\n        \\ a:fs .. '  six    ',\n        \\ ], ScreenLines([1, 5], 10))\n  \" close the next fold\n  2,5foldclose\n  call assert_equal([\n        \\ a:fo .. '  one    ',\n        \\ a:fs .. a:fc .. ' +---  4',\n        \\ a:fs .. '  six    ',\n        \\ ], ScreenLines([1, 3], 10))\n\n  \" set the fold column size to 2\n  setlocal fdc=2\n  normal zR\n  call assert_equal([\n        \\ a:fo .. ' one  ',\n        \\ a:fo .. ' two  ',\n        \\ a:fo .. ' three',\n        \\ '3 four ',\n        \\ '2 five ',\n        \\ a:fs .. ' six  ',\n        \\ ], ScreenLines([1, 6], 7))\n\n  \" set the fold column size to 1\n  setlocal fdc=1\n  normal zR\n  call assert_equal([\n        \\ a:fo .. 'one   ',\n        \\ a:fo .. 'two   ',\n        \\ a:fo .. 'three ',\n        \\ '3four  ',\n        \\ '2five  ',\n        \\ a:fs .. 'six   ',\n        \\ ], ScreenLines([1, 6], 7))\n\n  \" Enable number and sign columns and place some signs\n  setlocal fdc=3\n  setlocal number\n  setlocal signcolumn=auto\n  sign define S1 text=->\n  sign place 10 line=3 name=S1\n  call assert_equal([\n        \\ a:fo .. '      1 one  ',\n        \\ a:fs .. a:fo .. '     2 two  ',\n        \\ '2' .. a:fo .. ' ->  3 three',\n        \\ '23     4 four ',\n        \\ a:fs .. a:fs .. '     5 five ',\n        \\ a:fs .. '      6 six  '\n        \\ ], ScreenLines([1, 6], 14))\n\n  \" Test with 'rightleft'\n  if has('rightleft')\n    setlocal rightleft\n    let lines = ScreenLines([1, 6], winwidth(0))\n    call assert_equal('o 1      ' .. a:fo,\n          \\  strcharpart(lines[0], strchars(lines[0]) - 10, 10))\n    call assert_equal('t 2     ' .. a:fo .. a:fs,\n          \\  strcharpart(lines[1], strchars(lines[1]) - 10, 10))\n    call assert_equal('t 3  >- ' .. a:fo .. '2',\n          \\  strcharpart(lines[2], strchars(lines[2]) - 10, 10))\n    call assert_equal('f 4     32',\n          \\  strcharpart(lines[3], strchars(lines[3]) - 10, 10))\n    call assert_equal('f 5     ' .. a:fs .. a:fs,\n          \\  strcharpart(lines[4], strchars(lines[4]) - 10, 10))\n    call assert_equal('s 6      ' .. a:fs,\n          \\  strcharpart(lines[5], strchars(lines[5]) - 10, 10))\n    setlocal norightleft\n  endif\n\n  sign unplace *\n  sign undefine S1\n  setlocal number& signcolumn&\n\n  \" Add a test with more than 9 folds (and then delete some folds)\n  normal zE\n  for i in range(1, 10)\n    normal zfGzo\n  endfor\n  normal zR\n  call assert_equal([\n        \\ a:fo .. a:fo .. ' one ',\n        \\ '9> two '\n        \\ ], ScreenLines([1, 2], 7))\n  normal 1Gzd\n  call assert_equal([\n        \\ a:fo .. a:fo .. ' one ',\n        \\ '89 two '\n        \\ ], ScreenLines([1, 2], 7))\n  normal 1Gzdzdzdzdzdzdzd\n  call assert_equal([\n        \\ a:fo .. a:fo .. ' one ',\n        \\ a:fs .. a:fs .. ' two '\n        \\ ], ScreenLines([1, 2], 7))\n\n  setlocal foldcolumn& number& signcolumn&\nendfunc\n\nfunc Test_foldcolumn_multibyte_char()\n  new\n  call setline(1, ['one', 'two', 'three', 'four', 'five', 'six'])\n  setlocal foldenable foldmethod=manual\n\n  \" First test with the default setting\n  call s:mbyte_fillchar_tests('-', '+', '|')\n\n  \" Use multi-byte characters\n  set fillchars+=foldopen:\u25be,foldsep:\u2502,foldclose:\u25b8\n  call s:mbyte_fillchar_tests('\u25be', '\u25b8', '\u2502')\n\n  \" Use a mix of multi-byte and single-byte characters\n  set fillchars+=foldopen:\u00ac,foldsep:\\|,foldclose:+\n  call s:mbyte_fillchar_tests('\u00ac', '+', '|')\n  set fillchars+=foldopen:+,foldsep:\\|,foldclose:\u00ac\n  call s:mbyte_fillchar_tests('+', '\u00ac', '|')\n\n  bw!\n  set foldenable& fdc& fdm& fillchars&\nendfunc\n\n\" Test for calling foldlevel() from a fold expression\nlet g:FoldLevels = []\nfunc FoldExpr1(lnum)\n  let f = [a:lnum]\n  for i in range(1, line('$'))\n    call add(f, foldlevel(i))\n  endfor\n  call add(g:FoldLevels, f)\n  return getline(a:lnum)[0] == \"\\t\"\nendfunc\n\nfunc Test_foldexpr_foldlevel()\n  new\n  call setline(1, ['one', \"\\ttwo\", \"\\tthree\"])\n  setlocal foldmethod=expr\n  setlocal foldexpr=FoldExpr1(v:lnum)\n  setlocal foldenable\n  setlocal foldcolumn=3\n  redraw!\n  call assert_equal([[1, -1, -1, -1], [2, -1, -1, -1], [3, 0, 1, -1]],\n        \\ g:FoldLevels)\n  set foldmethod& foldexpr& foldenable& foldcolumn&\n  bw!\nendfunc\n\n\" Test for returning different values from a fold expression\nfunc FoldExpr2(lnum)\n  if a:lnum == 1 || a:lnum == 4\n    return -2\n  elseif a:lnum == 2\n    return 'a1'\n  elseif a:lnum == 3\n    return 's4'\n  endif\n  return '='\nendfunc\n\nfunc Test_foldexpr_2()\n  new\n  call setline(1, ['one', 'two', 'three', 'four'])\n  setlocal foldexpr=FoldExpr2(v:lnum)\n  setlocal foldmethod=expr\n  call assert_equal([0, 1, 1, 0], [foldlevel(1), foldlevel(2), foldlevel(3),\n        \\ foldlevel(4)])\n  bw!\nendfunc\n\n\" Test for the 'foldclose' option\nfunc Test_foldclose_opt()\n  CheckScreendump\n\n  let lines =<< trim END\n    set foldmethod=manual foldclose=all foldopen=all\n    call setline(1, ['one', 'two', 'three', 'four'])\n    2,3fold\n    func XsaveFoldLevels()\n      redraw!\n      call writefile([json_encode([foldclosed(1), foldclosed(2), foldclosed(3),\n        \\ foldclosed(4)])], 'Xoutput', 'a')\n    endfunc\n  END\n  call writefile(lines, 'Xscript', 'D')\n  let rows = 10\n  let buf = RunVimInTerminal('-S Xscript', {'rows': rows})\n  call term_wait(buf)\n  call term_sendkeys(buf, \":set noruler\\n\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"2G\")\n  call WaitForAssert({-> assert_equal('two', term_getline(buf, 2))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"4G\")\n  call WaitForAssert({-> assert_equal('four', term_getline(buf, 3))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"3G\")\n  call WaitForAssert({-> assert_equal('three', term_getline(buf, 3))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"1G\")\n  call WaitForAssert({-> assert_equal('four', term_getline(buf, 3))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"2G\")\n  call WaitForAssert({-> assert_equal('two', term_getline(buf, 2))})\n  call term_sendkeys(buf, \"k\")\n  call WaitForAssert({-> assert_equal('four', term_getline(buf, 3))})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['[-1,2,2,-1]', '[-1,-1,-1,-1]', '[-1,2,2,-1]',\n        \\ '[-1,-1,-1,-1]', '[-1,2,2,-1]'], readfile('Xoutput'))\n  call delete('Xoutput')\nendfunc\n\n\" Test for foldtextresult()\nfunc Test_foldtextresult()\n  new\n  call assert_equal('', foldtextresult(-1))\n  call assert_equal('', foldtextresult(0))\n  call assert_equal('', foldtextresult(1))\n  call setline(1, ['one', 'two', 'three', 'four'])\n  2,3fold\n  call assert_equal('', foldtextresult(1))\n  call assert_equal('+--  2 lines: two', foldtextresult(2))\n  setlocal foldtext=\n  call assert_equal('+--  2 lines folded ', foldtextresult(2))\n\n  \" Fold text for a C comment fold\n  %d _\n  setlocal foldtext&\n  call setline(1, ['', '/*', ' * Comment', ' */', ''])\n  2,4fold\n  call assert_equal('+--  3 lines: Comment', foldtextresult(2))\n\n  bw!\nendfunc\n\n\" Test for merging two recursive folds when an intermediate line with no fold\n\" is removed\nfunc Test_fold_merge_recursive()\n  new\n  call setline(1, ['  one', '    two', 'xxxx', '    three',\n        \\ '      four', \"\\tfive\"])\n  setlocal foldmethod=indent shiftwidth=2\n  3d_\n  %foldclose\n  call assert_equal([1, 5], [foldclosed(5), foldclosedend(1)])\n  bw!\nendfunc\n\n\" Test for moving a line which is the start of a fold from a recursive fold to\n\" outside. The fold length should reduce.\nfunc Test_fold_move_foldlevel()\n  new\n  call setline(1, ['a{{{', 'b{{{', 'c{{{', 'd}}}', 'e}}}', 'f}}}', 'g'])\n  setlocal foldmethod=marker\n  normal zR\n  call assert_equal([3, 2, 1], [foldlevel(4), foldlevel(5), foldlevel(6)])\n  3move 7\n  call assert_equal([2, 1, 0], [foldlevel(3), foldlevel(4), foldlevel(5)])\n  call assert_equal(1, foldlevel(7))\n\n  \" Move a line from outside a fold to inside the fold.\n  %d _\n  call setline(1, ['a', 'b{{{', 'c}}}'])\n  normal zR\n  1move 2\n  call assert_equal([1, 1, 1], [foldlevel(1), foldlevel(2), foldlevel(3)])\n\n  \" Move the start of one fold to inside another fold\n  %d _\n  call setline(1, ['a', 'b{{{', 'c}}}', 'd{{{', 'e}}}'])\n  normal zR\n  call assert_equal([0, 1, 1, 1, 1], [foldlevel(1), foldlevel(2),\n        \\ foldlevel(3), foldlevel(4), foldlevel(5)])\n  1,2move 4\n  call assert_equal([0, 1, 1, 2, 2], [foldlevel(1), foldlevel(2),\n        \\ foldlevel(3), foldlevel(4), foldlevel(5)])\n\n  bw!\nendfunc\n\n\" Test for using zj and zk to move downwards and upwards to the start and end\n\" of the next fold.\n\" Test for using [z and ]z in a closed fold to jump to the beginning and end\n\" of the fold.\nfunc Test_fold_jump()\n  new\n  call setline(1, [\"\\t1\", \"\\t2\", \"\\t\\t3\", \"\\t\\t4\", \"\\t\\t\\t5\", \"\\t\\t\\t6\", \"\\t\\t7\", \"\\t\\t8\", \"\\t9\", \"\\t10\"])\n  setlocal foldmethod=indent\n  normal zR\n  normal zj\n  call assert_equal(3, line('.'))\n  normal zj\n  call assert_equal(5, line('.'))\n  call assert_beeps('normal zj')\n  call assert_equal(5, line('.'))\n  call assert_beeps('normal 9Gzj')\n  call assert_equal(9, line('.'))\n  normal Gzk\n  call assert_equal(8, line('.'))\n  normal zk\n  call assert_equal(6, line('.'))\n  call assert_beeps('normal zk')\n  call assert_equal(6, line('.'))\n  call assert_beeps('normal 2Gzk')\n  call assert_equal(2, line('.'))\n\n  \" Using [z or ]z in a closed fold should not move the cursor\n  %d _\n  call setline(1, [\"1\", \"\\t2\", \"\\t3\", \"\\t4\", \"\\t5\", \"\\t6\", \"7\"])\n  normal zR4Gzc\n  call assert_equal(4, line('.'))\n  call assert_beeps('normal [z')\n  call assert_equal(4, line('.'))\n  call assert_beeps('normal ]z')\n  call assert_equal(4, line('.'))\n  bw!\nendfunc\n\n\" Test for using a script-local function for 'foldexpr'\nfunc Test_foldexpr_scriptlocal_func()\n  func! s:FoldFunc()\n    let g:FoldLnum = v:lnum\n  endfunc\n  new | only\n  call setline(1, 'abc')\n  let g:FoldLnum = 0\n  set foldmethod=expr foldexpr=s:FoldFunc()\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldFunc()', &foldexpr)\n  call assert_equal(1, g:FoldLnum)\n  set foldmethod& foldexpr=\n  bw!\n  new | only\n  call setline(1, 'abc')\n  let g:FoldLnum = 0\n  set foldmethod=expr foldexpr=<SID>FoldFunc()\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldFunc()', &foldexpr)\n  call assert_equal(1, g:FoldLnum)\n  set foldmethod& foldexpr=\n  delfunc s:FoldFunc\n  bw!\nendfunc\n\n\" Test for using a script-local function for 'foldtext'\nfunc Test_foldtext_scriptlocal_func()\n  func! s:FoldText()\n    let g:FoldTextArgs = [v:foldstart, v:foldend]\n    return foldtext()\n  endfunc\n  new | only\n  call setline(1, range(50))\n  let g:FoldTextArgs = []\n  set foldmethod=manual\n  set foldtext=s:FoldText()\n  norm! 4Gzf4j\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldText()', &foldtext)\n  call assert_equal([4, 8], g:FoldTextArgs)\n  set foldtext&\n  bw!\n  new | only\n  call setline(1, range(50))\n  let g:FoldTextArgs = []\n  set foldmethod=manual\n  set foldtext=<SID>FoldText()\n  norm! 8Gzf4j\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldText()', &foldtext)\n  call assert_equal([8, 12], g:FoldTextArgs)\n  set foldtext&\n  bw!\n  delfunc s:FoldText\nendfunc\n\n\" Make sure a fold containing a nested fold is split correctly when using\n\" foldmethod=indent\nfunc Test_fold_split()\n  new\n  let lines =<< trim END\n    line 1\n      line 2\n      line 3\n        line 4\n        line 5\n  END\n  call setline(1, lines)\n  setlocal sw=2\n  setlocal foldmethod=indent foldenable\n  call assert_equal([0, 1, 1, 2, 2], range(1, 5)->map('foldlevel(v:val)'))\n  call append(2, 'line 2.5')\n  call assert_equal([0, 1, 0, 1, 2, 2], range(1, 6)->map('foldlevel(v:val)'))\n  3d\n  call assert_equal([0, 1, 1, 2, 2], range(1, 5)->map('foldlevel(v:val)'))\n  bw!\nendfunc\n\n\" Make sure that when you append under a blank line that is under a fold with\n\" the same indent level as your appended line, the fold expands across the\n\" blank line\nfunc Test_indent_append_under_blank_line()\n  new\n  let lines =<< trim END\n    line 1\n      line 2\n      line 3\n  END\n  call setline(1, lines)\n  setlocal sw=2\n  setlocal foldmethod=indent foldenable\n  call assert_equal([0, 1, 1], range(1, 3)->map('foldlevel(v:val)'))\n  call append(3, '')\n  call append(4, '  line 5')\n  call assert_equal([0, 1, 1, 1, 1], range(1, 5)->map('foldlevel(v:val)'))\n  bw!\nendfunc\n\n\" Make sure that when you delete 1 line of a fold whose length is 2 lines, the\n\" fold can't be closed since its length (1) is now less than foldminlines.\nfunc Test_indent_one_line_fold_close()\n  let lines =<< trim END\n    line 1\n      line 2\n      line 3\n  END\n\n  new\n  setlocal sw=2 foldmethod=indent\n  call setline(1, lines)\n  \" open all folds, delete line, then close all folds\n  normal zR\n  3delete\n  normal zM\n  call assert_equal(-1, foldclosed(2)) \" the fold should not be closed\n\n  \" Now do the same, but delete line 2 this time; this covers different code.\n  \" (Combining this code with the above code doesn't expose both bugs.)\n  1,$delete\n  call setline(1, lines)\n  normal zR\n  2delete\n  normal zM\n  call assert_equal(-1, foldclosed(2))\n  bw!\nendfunc\n\n\" Make sure that when appending [an indented line then a blank line] right\n\" before a single indented line, the resulting extended fold can be closed\nfunc Test_indent_append_blank_small_fold_close()\n  new\n  setlocal sw=2 foldmethod=indent\n  \" at first, the fold at the second line can't be closed since it's smaller\n  \" than foldminlines\n  let lines =<< trim END\n    line 1\n      line 4\n  END\n  call setline(1, lines)\n  call append(1, ['  line 2', ''])\n  \" close all folds\n  normal zM\n  call assert_notequal(-1, foldclosed(2)) \" the fold should be closed now\n  bw!\nendfunc\n\nfunc Test_sort_closed_fold()\n  CheckExecutable sort\n\n  call setline(1, [\n        \\ 'Section 1',\n        \\ '   how',\n        \\ '   now',\n        \\ '   brown',\n        \\ '   cow',\n        \\ 'Section 2',\n        \\ '   how',\n        \\ '   now',\n        \\ '   brown',\n        \\ '   cow',\n        \\])\n  setlocal foldmethod=indent sw=3\n  normal 2G\n\n  \" The \"!!\" expands to \".,.+3\" and must only sort four lines\n  call feedkeys(\"!!sort\\<CR>\", 'xt')\n  call assert_equal([\n        \\ 'Section 1',\n        \\ '   brown',\n        \\ '   cow',\n        \\ '   how',\n        \\ '   now',\n        \\ 'Section 2',\n        \\ '   how',\n        \\ '   now',\n        \\ '   brown',\n        \\ '   cow',\n        \\ ], getline(1, 10))\n\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar et al.\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic void\tunshift_special(cmdarg_T *cap);\nstatic void\tdel_from_showcmd(int);\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo_or_register(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\nstatic void\tnv_object(cmdarg_T *cap);\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\n// Declare nv_cmds[].\n#define DO_DECLARE_NVCMD\n#include \"nv_cmds.h\"\n\n// Include the lookuptable generated by create_nvcmdidx.vim.\n#include \"nv_cmdidxs.h\"\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * If currently editing a cmdline or text is locked: beep and give an error\n * message, return TRUE.\n */\n    static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tif (oap != NULL)\n\t    clearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * If text is locked, \"curbuf_lock\" or \"allbuf_lock\" is set:\n * Give an error message, possibly beep and return TRUE.\n * \"oap\" may be NULL.\n */\n    int\ncheck_text_or_curbuf_locked(oparg_T *oap)\n{\n    if (check_text_locked(oap))\n\treturn TRUE;\n    if (curbuf_locked())\n    {\n\tif (oap != NULL)\n\t    clearop(oap);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Handle the count before a normal command and set cap->count0.\n */\n    static int\nnormal_cmd_get_count(\n\tcmdarg_T\t*cap,\n\tint\t\tc,\n\tint\t\ttoplevel UNUSED,\n\tint\t\tset_prevcount UNUSED,\n\tint\t\t*ctrl_w,\n\tint\t\t*need_flushbuf UNUSED)\n{\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t// Handle a count before a command and compute ca.count0.\n\t// Note that '0' is a command and not the start of a count, but it's\n\t// part of a count after other digits.\n\twhile ((c >= '1' && c <= '9')\n\t\t|| (cap->count0 != 0 && (c == K_DEL || c == K_KDEL\n\t\t\t|| c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tcap->count0 /= 10;\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n\t    }\n\t    else if (cap->count0 > 99999999L)\n\t    {\n\t\tcap->count0 = 999999999L;\n\t    }\n\t    else\n\t    {\n\t\tcap->count0 = cap->count0 * 10 + (c - '0');\n\t    }\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(cap, &set_prevcount);\n#endif\n\t    if (*ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (*ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t}\n\n\t// If we got CTRL-W there may be a/another count\n\tif (c == Ctrl_W && !*ctrl_w && cap->oap->op_type == OP_NOP)\n\t{\n\t    *ctrl_w = TRUE;\n\t    cap->opcount = cap->count0;\t// remember first count\n\t    cap->count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\tcap->oap->prev_opcount = cap->opcount;\n\tcap->oap->prev_count0 = cap->count0;\n    }\n    else if (cap->opcount != 0)\n    {\n\t// If we're in the middle of an operator (including after entering a\n\t// yank buffer with '\"') AND we had a count before the operator, then\n\t// that count overrides the current value of ca.count0.\n\t// What this means effectively, is that commands like \"3dw\" get turned\n\t// into \"d3w\" which makes things fall into place pretty neatly.\n\t// If you give a count before AND after the operator, they are\n\t// multiplied.\n\tif (cap->count0)\n\t{\n\t    if (cap->opcount >= 999999999L / cap->count0)\n\t\tcap->count0 = 999999999L;\n\t    else\n\t\tcap->count0 *= cap->opcount;\n\t}\n\telse\n\t    cap->count0 = cap->opcount;\n    }\n\n    // Always remember the count.  It will be set to zero (on the next call,\n    // above) when there is no pending operator.\n    // When called from main(), save the count for use by the \"count\" built-in\n    // variable.\n    cap->opcount = cap->count0;\n    cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n\n#ifdef FEAT_EVAL\n    // Only set v:count when called from main() and not a stuffed command.\n    // Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount(cap->count0, cap->count1, set_prevcount);\n#endif\n\n    return c;\n}\n\n/*\n * Returns TRUE if the normal command (cap) needs a second character.\n */\n    static int\nnormal_cmd_needs_more_chars(cmdarg_T *cap, short_u cmd_flags)\n{\n    return ((cmd_flags & NV_NCH)\n\t    && (((cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && cap->oap->op_type == OP_NOP)\n\t\t|| (cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (cap->cmdchar == 'q'\n\t\t    && cap->oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t\t    && (cap->oap->op_type != OP_NOP || VIsual_active))));\n}\n\n/*\n * Get one or more additional characters for a normal command.\n * Return the updated command index (if changed).\n */\n    static int\nnormal_cmd_get_more_chars(\n\tint\t    idx_arg,\n\tcmdarg_T    *cap,\n\tint\t    *need_flushbuf UNUSED)\n{\n    int\t\tidx = idx_arg;\n    int\t\tc;\n    int\t\t*cp;\n    int\t\trepl = FALSE;\t// get character for replace mode\n    int\t\tlit = FALSE;\t// get extra character literally\n    int\t\tlangmap_active = FALSE;    // using :lmap mappings\n    int\t\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n    int\t\tsave_smd;\t// saved value of p_smd\n#endif\n\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping for nchar, but allow key codes\n    // Don't generate a CursorHold event here, most commands can't handle\n    // it, e.g., nv_replace(), nv_csearch().\n    did_cursorhold = TRUE;\n    if (cap->cmdchar == 'g')\n    {\n\t/*\n\t * For 'g' get the next character now, so that we can check for\n\t * \"gr\", \"g'\" and \"g`\".\n\t */\n\tcap->nchar = plain_vgetc();\n\tLANGMAP_ADJUST(cap->nchar, TRUE);\n\t*need_flushbuf |= add_to_showcmd(cap->nchar);\n\tif (cap->nchar == 'r' || cap->nchar == '\\'' || cap->nchar == '`'\n\t\t|| cap->nchar == Ctrl_BSL)\n\t{\n\t    cp = &cap->extra_char;\t// need to get a third character\n\t    if (cap->nchar != 'r')\n\t\tlit = TRUE;\t\t\t// get it literally\n\t    else\n\t\trepl = TRUE;\t\t// get it in replace mode\n\t}\n\telse\n\t    cp = NULL;\t\t// no third character needed\n    }\n    else\n    {\n\tif (cap->cmdchar == 'r')\t\t// get it in replace mode\n\t    repl = TRUE;\n\tcp = &cap->nchar;\n    }\n    lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n    /*\n     * Get a second or third character.\n     */\n    if (cp != NULL)\n    {\n\tif (repl)\n\t{\n\t    State = MODE_REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t// show different cursor shape\n#endif\n\t}\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t{\n\t    // Allow mappings defined with \":lmap\".\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (repl)\n\t\tState = MODE_LREPLACE;\n\t    else\n\t\tState = MODE_LANGMAP;\n\t    langmap_active = TRUE;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tsave_smd = p_smd;\n\tp_smd = FALSE;\t// Don't let the IM code show the mode here\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t    im_set_active(TRUE);\n#endif\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Disable bracketed paste and modifyOtherKeys here, we won't\n\t    // recognize the escape sequences with 'esckeys' off.\n\t    out_str(T_BD);\n\t    out_str_t_TE();\n\t}\n\n\t*cp = plain_vgetc();\n\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Re-enable bracketed paste mode and modifyOtherKeys\n\t    out_str_t_BE();\n\t    out_str_t_TI();\n\t}\n\n\tif (langmap_active)\n\t{\n\t    // Undo the decrement done above\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    State = MODE_NORMAL_BUSY;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tif (lang)\n\t{\n\t    if (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\tim_save_status(&curbuf->b_p_iminsert);\n\t    im_set_active(FALSE);\n\t}\n\tp_smd = save_smd;\n#endif\n\tState = MODE_NORMAL_BUSY;\n\t*need_flushbuf |= add_to_showcmd(*cp);\n\n\tif (!lit)\n\t{\n#ifdef FEAT_DIGRAPHS\n\t    // Typing CTRL-K gets a digraph.\n\t    if (*cp == Ctrl_K\n\t\t    && ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t|| cp == &cap->extra_char)\n\t\t    && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t    {\n\t\tc = get_digraph(FALSE);\n\t\tif (c > 0)\n\t\t{\n\t\t    *cp = c;\n\t\t    // Guessing how to update showcmd here...\n\t\t    del_from_showcmd(3);\n\t\t    *need_flushbuf |= add_to_showcmd(*cp);\n\t\t}\n\t    }\n#endif\n\n\t    // adjust chars > 127, except after \"tTfFr\" commands\n\t    LANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t    // adjust Hebrew mapped char\n\t    if (p_hkmap && lang && KeyTyped)\n\t\t*cp = hkmap(*cp);\n#endif\n\t}\n\n\t// When the next character is CTRL-\\ a following CTRL-N means the\n\t// command is aborted and we go to Normal mode.\n\tif (cp == &cap->extra_char\n\t\t&& cap->nchar == Ctrl_BSL\n\t\t&& (cap->extra_char == Ctrl_N || cap->extra_char == Ctrl_G))\n\t{\n\t    cap->cmdchar = Ctrl_BSL;\n\t    cap->nchar = cap->extra_char;\n\t    idx = find_command(cap->cmdchar);\n\t}\n\telse if ((cap->nchar == 'n' || cap->nchar == 'N') && cap->cmdchar == 'g')\n\t    cap->oap->op_type = get_op_type(*cp, NUL);\n\telse if (*cp == Ctrl_BSL)\n\t{\n\t    long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t    // There is a busy wait here when typing \"f<C-\\>\" and then\n\t    // something different from CTRL-N.  Can't be avoided.\n\t    while ((c = vpeekc()) <= 0 && towait > 0L)\n\t    {\n\t\tdo_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\ttowait -= 50L;\n\t    }\n\t    if (c > 0)\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (c != Ctrl_N && c != Ctrl_G)\n\t\t    vungetc(c);\n\t\telse\n\t\t{\n\t\t    cap->cmdchar = Ctrl_BSL;\n\t\t    cap->nchar = c;\n\t\t    idx = find_command(cap->cmdchar);\n\t\t}\n\t    }\n\t}\n\n\t// When getting a text character and the next character is a\n\t// multi-byte character, it could be a composing character.\n\t// However, don't wait for it to arrive. Also, do enable mapping,\n\t// because if it's put back with vungetc() it's too late to apply\n\t// mapping.\n\t--no_mapping;\n\twhile (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t&& (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t{\n\t    c = plain_vgetc();\n\t    if (!utf_iscomposing(c))\n\t    {\n\t\tvungetc(c);\t\t// it wasn't, put it back\n\t\tbreak;\n\t    }\n\t    else if (cap->ncharC1 == 0)\n\t\tcap->ncharC1 = c;\n\t    else\n\t\tcap->ncharC2 = c;\n\t}\n\t++no_mapping;\n    }\n    --no_mapping;\n    --allow_keys;\n\n    return idx;\n}\n\n/*\n * Returns TRUE if after processing a normal mode command, need to wait for a\n * moment when a message is displayed that will be overwritten by the mode\n * message.\n */\n    static int\nnormal_cmd_need_to_wait_for_msg(cmdarg_T *cap, pos_T *old_pos)\n{\n    // In Visual mode and with \"^O\" in Insert mode, a short message will be\n    // overwritten by the mode message.  Wait a bit, until a key is hit.\n    // In Visual mode, it's more important to keep the Visual area updated\n    // than keeping a message (e.g. from a /pat search).\n    // Only do this if the command was typed, not from a mapping.\n    // Don't wait when emsg_silent is non-zero.\n    // Also wait a bit after an error message, e.g. for \"^O:\".\n    // Don't redraw the screen, it would remove the message.\n    return (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos->lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos->col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && cap->oap->regname == 0\n\t    && !(cap->retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && cap->oap->op_type == OP_NOP);\n}\n\n/*\n * After processing a normal mode command, wait for a moment when a message is\n * displayed that will be overwritten by the mode message.\n */\n    static void\nnormal_cmd_wait_for_msg(void)\n{\n    int\tsave_State = State;\n\n    // Draw the cursor with the right shape here\n    if (restart_edit != 0)\n\tState = MODE_INSERT;\n\n    // If need to redraw, and there is a \"keep_msg\", redraw before the\n    // delay\n    if (must_redraw && keep_msg != NULL && !emsg_on_display)\n    {\n\tchar_u\t*kmsg;\n\n\tkmsg = keep_msg;\n\tkeep_msg = NULL;\n\t// Showmode() will clear keep_msg, but we want to use it anyway.\n\t// First update w_topline.\n\tsetcursor();\n\tupdate_screen(0);\n\t// now reset it, otherwise it's put in the history again\n\tkeep_msg = kmsg;\n\n\tkmsg = vim_strsave(keep_msg);\n\tif (kmsg != NULL)\n\t{\n\t    msg_attr((char *)kmsg, keep_msg_attr);\n\t    vim_free(kmsg);\n\t}\n    }\n    setcursor();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    cursor_on();\n    out_flush();\n    if (msg_scroll || emsg_on_display)\n\tui_delay(1003L, TRUE);\t// wait at least one second\n    ui_delay(3003L, FALSE);\t\t// wait up to three seconds\n    State = save_State;\n\n    msg_scroll = FALSE;\n    emsg_on_display = FALSE;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    // If we are using the clipboard, then remember what was selected in case\n    // we need to paste it somewhere while we still own the selection.\n    // Only do this when the clipboard is already owned.  Don't want to grab\n    // the selection when hitting ESC.\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    may_trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    // if i == 0: try to find an identifier\n    // if i == 1: try to find any non-white text\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(e_no_string_under_cursor));\n\t    else\n\t\temsg(_(e_no_identifier_under_cursor));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    prep_redo_num2(regname, num, cmd1, cmd2, 0L, cmd3, cmd4, cmd5);\n}\n\n/*\n * Prepare for redo of any command with extra count after \"cmd2\".\n */\n    void\nprep_redo_num2(\n    int\t    regname,\n    long    num1,\n    int\t    cmd1,\n    int\t    cmd2,\n    long    num2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n\n#ifdef FEAT_EVAL\n    // Put info about a mapping in the redo buffer, so that \".\" will use the\n    // same script context.\n    may_add_last_used_map_to_redobuff();\n#endif\n\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num1 != 0)\n\tAppendNumberToRedobuff(num1);\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (num2 != 0)\n\tAppendNumberToRedobuff(num2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n    else\n\tclear_showcmd();\n}\n\n/*\n * Routines for displaying a partly typed command\n */\n\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len = (int)STRLEN(showcmd_buf);\n\n    showcmd_is_clear = (len == 0);\n    cursor_off();\n\n    if (*p_sloc == 's')\n\twin_redr_status(curwin, FALSE);\n    else if (*p_sloc == 't')\n\tdraw_tabline();\n    else // 'showcmdloc' is \"last\" or empty\n    {\n\tif (!showcmd_is_clear)\n\t    screen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\n\t// clear the rest of an old message by outputting up to SHOWCMD_COLS\n\t// spaces\n\tscreen_puts((char_u *)\"          \" + len,\n\t\t\t\t\t\t(int)Rows - 1, sc_col + len, 0);\n    }\n\n    setcursor();\t    // put cursor back where it belongs\n}\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    // Synchronize other windows, as necessary according to\n\t    // 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t    // when 'diff' is set.\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    // When switching between windows, make sure that the relative\n\t    // vertical offset is valid for the new window.  The relative\n\t    // offset is invalid whenever another 'scrollbind' window has\n\t    // scrolled to a point that would force the current window to\n\t    // scroll past the beginning or end of its buffer.  When the\n\t    // resync is performed, some of the other 'scrollbind' windows may\n\t    // need to jump so that the current window's relative position is\n\t    // visible on-screen.\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    // check 'scrollopt' string for vertical and horizontal scroll options\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    // loop through the scrollbound windows and scroll accordingly\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'noscrollbind'\n\tif (curwin == old_curwin || !curwin->w_p_scb)\n\t    continue;\n\n\t// do the vertical scroll\n\tif (want_ver)\n\t{\n#ifdef FEAT_DIFF\n\t    if (old_curwin->w_p_diff && curwin->w_p_diff)\n\t    {\n\t\tdiff_set_topline(old_curwin, curwin);\n\t    }\n\t    else\n#endif\n\t    {\n\t\tcurwin->w_scbind_pos += topline_diff;\n\t\ttopline = curwin->w_scbind_pos;\n\t\tif (topline > curbuf->b_ml.ml_line_count)\n\t\t    topline = curbuf->b_ml.ml_line_count;\n\t\tif (topline < 1)\n\t\t    topline = 1;\n\n\t\ty = topline - curwin->w_topline;\n\t\tif (y > 0)\n\t\t    scrollup(y, FALSE);\n\t\telse\n\t\t    scrolldown(-y, FALSE);\n\t    }\n\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n\n\t// do the horizontal scroll\n\tif (want_hor)\n\t    (void)set_leftcol(tgt_leftcol);\n    }\n\n    // reset current-window\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n    }\n    else\n    {\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n\t// clear any search statistics\n\tif (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\t    clear_cmdline = TRUE;\n    }\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    // With \"gD\" go to line 1.\n    // With \"gd\" Search back for the start of the current function, then go\n    // back until a blank line.  If this fails go to line 1.\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize_str(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      // Instead of sticking at the last character of the buffer line we\n      // try to stick in the last column of the screen.\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t// Check for landing on a character that got split at the end of the\n\t// last line.  We want to advance a screenline, not end up in the same\n\t// screenline or move two screenlines.\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n    adjust_skipcol();\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n    int\t\tprev_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value() > 0)\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n\t\t&& curwin->w_skipcol == prev_skipcol\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Get the count specified after a 'z' command. Only the 'z<CR>', 'zl', 'zh',\n * 'z<Left>', and 'z<Right>' commands accept a count after 'z'.\n * Returns TRUE to process the 'z' command and FALSE to skip it.\n */\n    static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t    n = n * 10 + (nchar - '0');\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}\n\n#ifdef FEAT_SPELL\n/*\n * \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n * \"zg\": add good word to word list\n * \"zw\": add wrong word to word list\n * \"zG\": add good word to temp word list\n * \"zW\": add wrong word to temp word list\n */\n    static int\nnv_zg_zw(cmdarg_T *cap, int nchar)\n{\n    char_u\t*ptr = NULL;\n    int\t\tlen;\n    int\t\tundo = FALSE;\n\n    if (nchar == 'u')\n    {\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return OK;\n\t}\n\tundo = TRUE;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn OK;\n    if (VIsual_active && get_visual_text(cap, &ptr, &len) == FAIL)\n\treturn FAIL;\n    if (ptr == NULL)\n    {\n\tpos_T\tpos = curwin->w_cursor;\n\n\t// Find bad word under the cursor.  When 'spell' is\n\t// off this fails and find_ident_under_cursor() is\n\t// used below.\n\temsg_off++;\n\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\temsg_off--;\n\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t    ptr = ml_get_pos(&curwin->w_cursor);\n\tcurwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL\n\t\t&& (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\treturn FAIL;\n    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t    ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t    (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1, undo);\n\n    return OK;\n}\n#endif\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n    long\tsiso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar) && !nv_z_get_count(cap, &nchar))\n\t    return;\n\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    // For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n    // If line number given, set cursor.\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol((colnr_T)cap->count1 > curwin->w_leftcol\n\t\t\t       ? 0 : curwin->w_leftcol - (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zL\" - scroll window left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll window to the left if not wrapping\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol(curwin->w_leftcol + (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(e_cannot_erase_folds_with_current_foldmethod));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\tif (nv_zg_zw(cap, nchar) == FAIL)\n\t\t    return;\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    do_mousescroll_horiz(scrollbar_value);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    // Ignore 'Q' in Visual mode, just give a beep.\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND\n\t\t\t\t\t   || cap->cmdchar == K_SCRIPT_COMMAND;\n    int\tflags;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tflags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;\n\tif (is_cmdkey)\n\t    cmd_result = do_cmdkey_command(cap->cmdchar, flags);\n\telse\n\t    cmd_result = do_cmdline(NULL, getexline, NULL, flags);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tmay_trigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(UPD_CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tmay_trigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * 'K' normal-mode command. Get the command to lookup the keyword under the\n * cursor.\n */\n    static int\nnv_K_getcmd(\n\tcmdarg_T\t*cap,\n\tchar_u\t\t*kp,\n\tint\t\tkp_help,\n\tint\t\tkp_ex,\n\tchar_u\t\t**ptr_arg,\n\tint\t\tn,\n\tchar_u\t\t*buf,\n\tunsigned\tbuflen)\n{\n    char_u\t*ptr = *ptr_arg;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (kp_help)\n    {\n\t// in the help buffer\n\tSTRCPY(buf, \"he! \");\n\treturn n;\n    }\n\n    if (kp_ex)\n    {\n\t// 'keywordprog' is an ex command\n\tif (cap->count0 != 0)\n\t    vim_snprintf((char *)buf, buflen, \"%s %ld\", kp, cap->count0);\n\telse\n\t    STRCPY(buf, kp);\n\tSTRCAT(buf, \" \");\n\treturn n;\n    }\n\n    // An external command will probably use an argument starting\n    // with \"-\" as an option.  To avoid trouble we skip the \"-\".\n    while (*ptr == '-' && n > 0)\n    {\n\t++ptr;\n\t--n;\n    }\n    if (n == 0)\n    {\n\t// found dashes only\n\temsg(_(e_no_identifier_under_cursor));\n\tvim_free(buf);\n\t*ptr_arg = ptr;\n\treturn 0;\n    }\n\n    // When a count is given, turn it into a range.  Is this\n    // really what we want?\n    isman = (STRCMP(kp, \"man\") == 0);\n    isman_s = (STRCMP(kp, \"man -s\") == 0);\n    if (cap->count0 != 0 && !(isman || isman_s))\n\tsprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n    STRCAT(buf, \"! \");\n    if (cap->count0 == 0 && isman_s)\n\tSTRCAT(buf, \"man\");\n    else\n\tSTRCAT(buf, kp);\n    STRCAT(buf, \" \");\n    if (cap->count0 != 0 && (isman || isman_s))\n    {\n\tsprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\tSTRCAT(buf, \" \");\n    }\n\n    *ptr_arg = ptr;\n    return n;\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    // The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_no_identifier_under_cursor));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    // Put cursor at start of word, makes search skip the word\n\t    // under the cursor.\n\t    // Call setpcmark() first, so \"*``\" puts the cursor back where\n\t    // it was.\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    n = nv_K_getcmd(cap, kp, kp_help, kp_ex, &ptr, n, buf, buflen);\n\t    if (n == 0)\n\t\treturn;\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    // Now grab the chars in the identifier\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    // Execute the command.\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    if (curwin->w_cursor.lnum > curwin->w_topline)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    // In virtual edit mode, there's no such thing as \"past_line\", as lines\n    // are (theoretically) infinitely long.\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    //\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t    //\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t    // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_or_curbuf_locked(cap->oap))\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, 0);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (i > 0 && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n#ifdef FEAT_SEARCH_EXTRA\n    pos_T\tprev_cursor = curwin->w_cursor;\n#endif\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (!EQUAL_POS(curwin->w_cursor, prev_cursor) && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n */\n    static void\nnv_bracket_block(cmdarg_T *cap, pos_T *old_pos)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\tprev_pos;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    if (cap->nchar == '*')\n\tcap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\tif (cap->cmdchar == '[')\n\t    findc = '{';\n\telse\n\t    findc = '}';\n\tn = 9999;\n    }\n    else\n    {\n\tfindc = cap->nchar;\n\tn = cap->count1;\n    }\n    for ( ; n > 0; --n)\n    {\n\tif ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t{\n\t    if (new_pos.lnum == 0)\t// nothing found\n\t    {\n\t\tif (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t    clearopbeep(cap->oap);\n\t    }\n\t    else\n\t\tpos = &new_pos;\t// use last one found\n\t    break;\n\t}\n\tprev_pos = new_pos;\n\tcurwin->w_cursor = *pos;\n\tnew_pos = *pos;\n    }\n    curwin->w_cursor = *old_pos;\n\n    // Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n    // brought us to the match for \"[m\" and \"]M\" when inside a method.\n    // Try finding the '{' or '}' we want to be at.\n    // Also repeat for the given count.\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\t// norm is TRUE for \"]M\" and \"[m\"\n\tint\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\tn = cap->count1;\n\t// found a match: we were inside a method\n\tif (prev_pos.lnum != 0)\n\t{\n\t    pos = &prev_pos;\n\t    curwin->w_cursor = prev_pos;\n\t    if (norm)\n\t\t--n;\n\t}\n\telse\n\t    pos = NULL;\n\twhile (n > 0)\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t{\n\t\t    // if not found anything, that's an error\n\t\t    if (pos == NULL)\n\t\t\tclearopbeep(cap->oap);\n\t\t    n = 0;\n\t\t    break;\n\t\t}\n\t\tc = gchar_cursor();\n\t\tif (c == '{' || c == '}')\n\t\t{\n\t\t    // Must have found end/start of class: use it.\n\t\t    // Or found the place to be at.\n\t\t    if ((c == findc && norm) || (n == 1 && !norm))\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t\tn = 0;\n\t\t    }\n\t\t    // if no match found at all, we started outside of the\n\t\t    // class and we're inside now.  Just go on.\n\t\t    else if (new_pos.lnum == 0)\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t    }\n\t\t    // found start/end of other method: go to match\n\t\t    else if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t      (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t   0)) == NULL)\n\t\t\tn = 0;\n\t\t    else\n\t\t\tcurwin->w_cursor = *pos;\n\t\t    break;\n\t\t}\n\t    }\n\t    --n;\n\t}\n\tcurwin->w_cursor = *old_pos;\n\tif (pos == NULL && new_pos.lnum != 0)\n\t    clearopbeep(cap->oap);\n    }\n    if (pos != NULL)\n    {\n\tsetpcmark();\n\tcurwin->w_cursor = *pos;\n\tcurwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t&& cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Replacing with a TAB is done by edit() when it is complicated because\n    // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n    // Other characters are done below to avoid problems with things like\n    // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t// Replace character(s) by a single newline.\n\t// Strange vi behaviour: Only one newline is inserted.\n\t// Delete the characters here.\n\t// Insert the newline with an insert command, takes care of\n\t// autoindent.\tThe insert command depends on being on the last\n\t// character of a line or not.\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = MODE_REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    // Replace the characters within one line.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t// Get ptr again, because u_save and/or showmatch() will have\n\t\t// released the line.  This may also happen in ins_copychar().\n\t\t// At the same time we let know that the line will be changed.\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\t// line may have been flushed, get it again\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(e_changelist_is_empty));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(e_at_start_of_changelist));\n\t    else\n\t\temsg(_(e_at_end_of_changelist));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    may_trigger_modechanged();\n\t}\n\tredraw_curbuf_later(UPD_INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    // For V and ^V, we multiply the number of lines even if there\n\t    // was only one -- webb\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    update_curswant_force();\n\t\t    curwin->w_curswant += resel_VIsual_vcol * cap->count0;\n\t\t    if (*p_sel != 'e')\n\t\t\t--curwin->w_curswant;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tupdate_curswant_force();\n\t\tcurwin->w_curswant += + resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(UPD_INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n * When \"c\" is 'o' (checking for \"mouse\") then also when mapped.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (c == 'o' || (stuff_empty() && typebuf_typed()))\n\t\t    && vim_strchr(p_slm, c) != NULL;\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    may_trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < UPD_INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * \"gv\": Reselect the previous Visual area.  If Visual already active,\n *       exchange previous and current Visual area.\n */\n    static void\nnv_gv_cmd(cmdarg_T *cap)\n{\n    pos_T\ttpos;\n    int\t\ti;\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (curbuf->b_visual.vi_start.lnum == 0\n\t    || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t    || curbuf->b_visual.vi_end.lnum == 0)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // set w_cursor to the start of the Visual area, tpos to the end\n    if (VIsual_active)\n    {\n\ti = VIsual_mode;\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\tcurbuf->b_visual_mode_eval = i;\n# endif\n\ti = curwin->w_curswant;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\tcurbuf->b_visual.vi_curswant = i;\n\n\ttpos = curbuf->b_visual.vi_end;\n\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\tcurbuf->b_visual.vi_start = VIsual;\n    }\n    else\n    {\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\ttpos = curbuf->b_visual.vi_end;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n    }\n\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Set Visual to the start and w_cursor to the end of the Visual\n    // area.  Make sure they are on an existing character.\n    check_cursor();\n    VIsual = curwin->w_cursor;\n    curwin->w_cursor = tpos;\n    check_cursor();\n    update_topline();\n\n    // When called from normal \"g\" command: start Select mode when\n    // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n    // start Select mode.\n    if (cap->arg)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else\n\tmay_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n}\n\n/*\n * \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n * \"gm\": middle of \"g0\" and \"g$\".\n */\n    static void\nnv_g_home_m_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == '^')\n\tflag = TRUE;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tint\twidth1 = curwin->w_width - curwin_col_off();\n\tint\twidth2 = width1 + curwin_col_off2();\n\tint\tvirtcol;\n\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t    - curwin->w_virtcol_first_char\n#endif\n\t    ;\n\ti = 0;\n\tif (virtcol >= (colnr_T)width1 && width2 > 0)\n\t    i = (virtcol - width1) / width2 * width2 + width1;\n    }\n    else\n\ti = curwin->w_leftcol;\n    // Go to the middle of the screen line.  When 'number' or\n    // 'relativenumber' is on and lines are wrapping the middle can be more\n    // to the left.\n    if (cap->nchar == 'm')\n\ti += (curwin->w_width - curwin_col_off()\n\t\t+ ((curwin->w_p_wrap && i > 0)\n\t\t    ? curwin_col_off2() : 0)) / 2;\n    coladvance((colnr_T)i);\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneright() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"g_\": to the last non-blank character in the line or <count> lines\n *       downward.\n */\n    static void\nnv_g_underscore_cmd(cmdarg_T *cap)\n{\n    char_u  *ptr;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\tcap->oap->op_type == OP_NOP) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    ptr = ml_get_curline();\n\n    // In Visual mode we may end up after the line.\n    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t--curwin->w_cursor.col;\n\n    // Decrease the cursor column until it's on a non-blank.\n    while (curwin->w_cursor.col > 0\n\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t--curwin->w_cursor.col;\n    curwin->w_set_curswant = TRUE;\n    adjust_for_sel(cap);\n}\n\n/*\n * \"g$\" : Like \"$\" but for screen lines.\n */\n    static void\nnv_g_dollar_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n    int\t\tcol_off = curwin_col_off();\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = TRUE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\tif (cap->count1 == 1)\n\t{\n\t    int\t\twidth1 = curwin->w_width - col_off;\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\t    int\t\tvirtcol;\n\n\t    validate_virtcol();\n\t    virtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t;\n\t    i = width1 - 1;\n\t    if (virtcol >= (colnr_T)width1)\n\t\ti += ((virtcol - width1) / width2 + 1)\n\t\t    * width2;\n\t    coladvance((colnr_T)i);\n\n\t    // Make sure we stick in this column.\n\t    update_curswant_force();\n\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t    {\n\t\t// Check for landing on a character that got split at\n\t\t// the end of the line.  We do not want to advance to\n\t\t// the next screen line.\n\t\tif (curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t\t\t\t\t> (colnr_T)i)\n\t\t    --curwin->w_cursor.col;\n\t    }\n\t}\n\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t    clearopbeep(oap);\n    }\n    else\n    {\n\tif (cap->count1 > 1)\n\t    // if it fails, let the cursor still move to the last char\n\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\tcoladvance((colnr_T)i);\n\n\t// if the character doesn't fit move one back\n\tif (curwin->w_cursor.col > 0\n\t\t&& (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t{\n\t    colnr_T vcol;\n\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t--curwin->w_cursor.col;\n\t}\n\n\t// Make sure we stick in this column.\n\tupdate_curswant_force();\n    }\n}\n\n/*\n * \"gi\": start Insert at the last position.\n */\n    static void\nnv_gi_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n\n    if (curbuf->b_last_insert.lnum != 0)\n    {\n\tcurwin->w_cursor = curbuf->b_last_insert;\n\tcheck_cursor_lnum();\n\ti = (int)STRLEN(ml_get_curline());\n\tif (curwin->w_cursor.col > (colnr_T)i)\n\t{\n\t    if (virtual_active())\n\t\tcurwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t    curwin->w_cursor.col = i;\n\t}\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize_str(ml_get_curline());\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t0, NULL) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t// If \"restart_edit\" is TRUE, the last but one command is repeated\n\t// instead of the last command (inserting text). This is used for\n\t// CTRL-O <.> in insert mode.\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo or specify register in select mode\n */\n    static void\nnv_redo_or_register(cmdarg_T *cap)\n{\n    if (VIsual_select && VIsual_active)\n    {\n\tint reg;\n\t// Get register name\n\t++no_mapping;\n\t++allow_keys;\n\treg = plain_vgetc();\n\tLANGMAP_ADJUST(reg, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\n\tif (reg == '\"')\n\t    // the unnamed register is 0\n\t    reg = 0;\n\n\tVIsual_select_reg = valid_yank_reg(reg, TRUE) ? reg : 0;\n\treturn;\n    }\n\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    // Set inclusive for the \"E\" and \"e\" command.\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    // \"cw\" and \"cW\" are a special case.\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t// Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t// changes one character, not all blanks until the start of\n\t\t// the next word.  Only do this when the 'w' flag is included\n\t\t// in 'cpoptions'.\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// This is a little strange. To match what the real Vi does,\n\t\t// we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t// that we are not on a space or a TAB.  This seems impolite\n\t\t// at first, but it's really more what we mean when we say\n\t\t// 'cw'.\n\t\t// Another strangeness: When standing on the end of a word\n\t\t// \"ce\" will change until the end of the next word, but \"cw\"\n\t\t// will change only one character! This is done by setting\n\t\t// flag.\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0 && cmdwin_type == 0\n\t\t\t\t\t\t&& !VIsual_active && no_reason)\n\t{\n\t    int\tout_redir = !stdout_isatty && !is_not_a_term_or_gui();\n\n\t    // The user may accidentally do \"vim file | grep word\" and then\n\t    // CTRL-C doesn't show anything.  With a changed buffer give the\n\t    // message on stderr.  Without any changes might as well exit.\n\t    if (anyBufIsChanged())\n\t    {\n\t\tchar *ms = _(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\");\n\n\t\tif (out_redir)\n\t\t    mch_errmsg(ms);\n\t\telse\n\t\t    msg(ms);\n\t    }\n\t    else\n\t    {\n\t\tif (out_redir)\n\t\t{\n\t\t    got_int = FALSE;\n\t\t    do_cmdline_cmd((char_u *)\"qa\");\n\t\t}\n\t\telse\n\t\t    msg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t    }\n\t}\n\n\tif (restart_edit != 0)\n\t    redraw_mode = TRUE;  // remove \"-- (insert) --\"\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n    }\n    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to\n\t// break the loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(UPD_INVERTED);\n    }\n    else if (no_reason)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (!cap->arg && popup_message_win_visible())\n\t    popup_hide_message_win();\n\telse\n#endif\n\t    vim_beep(BO_ESC);\n    }\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = MODE_INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n\tnv_object(cap);\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\tint old_visual_mode = VIsual_mode;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\tif (*ml_get_cursor() != NUL)\n\t{\n\t    if (old_visual_mode == 'V')\n\t    {\n\t\t// In linewise Visual mode insert before the beginning of the\n\t\t// next line.\n\t\t// When the last line in the buffer was deleted then create a\n\t\t// new line, otherwise there is not need to move cursor.\n\t\t// Detect this by checking if cursor moved above Visual area.\n\t\tif (curwin->w_cursor.lnum < old_pos.lnum\n\t\t\t\t&& curwin->w_cursor.lnum < old_visual.lnum)\n\t\t{\n\t\t    if (u_save_cursor() == OK)\n\t\t    {\n\t\t\tml_append(curwin->w_cursor.lnum, (char_u *)\"\", 0,\n\t\t\t\t\t\t\t\t\tFALSE);\n\t\t\tappended_lines(curwin->w_cursor.lnum++, 1L);\n\t\t    }\n\t\t}\n\t    }\n\t    // When the last char in the line was deleted then append.\n\t    // Detect this by checking if cursor moved before Visual area.\n\t    else if (curwin->w_cursor.col < old_pos.col\n\t\t\t\t&& curwin->w_cursor.col < old_visual.col)\n\t\tinc_cursor();\n\t}\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = MODE_INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n#ifdef FEAT_EVAL\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n#endif\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    if (cmdwin_type != 0)\n\t    {\n\t\temsg(_(e_cmdline_window_already_open));\n\t\treturn;\n\t    }\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n    int\t\tkeep_registers = FALSE;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n\t    keep_registers = cap->cmdchar == 'P';\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = keep_registers ? '_' : NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Test for folding\n\nsource check.vim\nsource view_util.vim\nsource screendump.vim\n\nfunc PrepIndent(arg)\n  return [a:arg] + repeat([\"\\t\".a:arg], 5)\nendfu\n\nfunc Test_address_fold()\n  new\n  call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',\n\t      \\ 'after fold 1', 'after fold 2', 'after fold 3'])\n  setl fen fdm=marker\n  \" The next commands should all copy the same part of the buffer,\n  \" regardless of the addressing type, since the part to be copied\n  \" is folded away\n  :1y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :.+y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :.,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :sil .1,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  \" use silent to make E493 go away\n  :sil .+,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :,y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n  :,+y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/','after fold 1'], getreg(0,1,1))\n  \" using .+3 as second address should copy the whole folded line + the next 3\n  \" lines\n  :.,+3y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/',\n\t      \\ 'after fold 1', 'after fold 2', 'after fold 3'], getreg(0,1,1))\n  :sil .,-2y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))\n\n  \" now test again with folding disabled\n  set nofoldenable\n  :1y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  :.y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  :.+y\n  call assert_equal(['1'], getreg(0,1,1))\n  :.,.y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  \" use silent to make E493 go away\n  :sil .1,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))\n  \" use silent to make E493 go away\n  :sil .+,.y\n  call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))\n  :,y\n  call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))\n  :,+y\n  call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))\n  \" using .+3 as second address should copy the whole folded line + the next 3\n  \" lines\n  :.,+3y\n  call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3'], getreg(0,1,1))\n  :7\n  :sil .,-2y\n  call assert_equal(['4', '5', '}/*}}}*/'], getreg(0,1,1))\n\n  quit!\nendfunc\n\nfunc Test_address_offsets()\n  \" check the help for :range-closed-fold\n  enew\n  call setline(1, [\n        \\ '1 one',\n        \\ '2 two',\n        \\ '3 three',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six',\n        \\ '7 seven',\n        \\ '8 eight',\n        \\])\n  set foldmethod=manual\n  normal 4Gvjzf\n  3,4+2yank\n  call assert_equal([\n        \\ '3 three',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six',\n        \\ '7 seven',\n        \\ ], getreg(0,1,1))\n\n  enew!\n  call setline(1, [\n        \\ '1 one',\n        \\ '2 two',\n        \\ '3 three FOLDED',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six FOLDED',\n        \\ '7 seven',\n        \\ '8 eight',\n        \\])\n  normal 3Gv3jzf\n  2,4-1yank\n  call assert_equal([\n        \\ '2 two',\n        \\ '3 three FOLDED',\n        \\ '4 four FOLDED',\n        \\ '5 five FOLDED',\n        \\ '6 six FOLDED',\n        \\ ], getreg(0,1,1))\n\n  bwipe!\nendfunc\n\nfunc Test_indent_fold()\n    new\n    call setline(1, ['', 'a', '    b', '    c'])\n    setl fen fdm=indent\n    2\n    norm! >>\n    let a=map(range(1,4), 'foldclosed(v:val)')\n    call assert_equal([-1,-1,-1,-1], a)\n    bw!\nendfunc\n\nfunc Test_indent_fold2()\n    new\n    call setline(1, ['', '{{{', '}}}', '{{{', '}}}'])\n    setl fen fdm=marker\n    2\n    norm! >>\n    let a=map(range(1,5), 'v:val->foldclosed()')\n    call assert_equal([-1,-1,-1,4,4], a)\n    bw!\nendfunc\n\n\" Test for fold indent with indents greater than 'foldnestmax'\nfunc Test_indent_fold_max()\n  new\n  setlocal foldmethod=indent\n  setlocal shiftwidth=2\n  \" 'foldnestmax' default value is 20\n  call setline(1, \"\\t\\t\\t\\t\\t\\ta\")\n  call assert_equal(20, foldlevel(1))\n  setlocal foldnestmax=10\n  call assert_equal(10, foldlevel(1))\n  setlocal foldnestmax=-1\n  call assert_equal(0, foldlevel(1))\n  bw!\nendfunc\n\nfunc Test_indent_fold_tabstop()\n  call setline(1, ['0', '    1', '    1', \"\\t2\", \"\\t2\"])\n  setlocal shiftwidth=4\n  setlocal foldcolumn=1\n  setlocal foldlevel=2\n  setlocal foldmethod=indent\n  redraw\n  call assert_equal('2        2', ScreenLines(5, 10)[0])\n  vsplit\n  windo diffthis\n  botright new\n  \" This 'tabstop' value should not be used for folding in other buffers.\n  setlocal tabstop=4\n  diffoff!\n  redraw\n  call assert_equal('2        2', ScreenLines(5, 10)[0])\n\n  bwipe!\n  bwipe!\nendfunc\n\nfunc Test_manual_fold_with_filter()\n  CheckExecutable cat\n  for type in ['manual', 'marker']\n    exe 'set foldmethod=' . type\n    new\n    call setline(1, range(1, 20))\n    4,$fold\n    %foldopen\n    10,$fold\n    %foldopen\n    \" This filter command should not have an effect\n    1,8! cat\n    call feedkeys('5ggzdzMGdd', 'xt')\n    call assert_equal(['1', '2', '3', '4', '5', '6', '7', '8', '9'], getline(1, '$'))\n\n    bwipe!\n    set foldmethod&\n  endfor\nendfunc\n\nfunc Test_indent_fold_with_read()\n  new\n  set foldmethod=indent\n  call setline(1, repeat([\"\\<Tab>a\"], 4))\n  for n in range(1, 4)\n    call assert_equal(1, foldlevel(n))\n  endfor\n\n  call writefile([\"a\", \"\", \"\\<Tab>a\"], 'Xinfofile', 'D')\n  foldopen\n  2read Xinfofile\n  %foldclose\n  call assert_equal(1, foldlevel(1))\n  call assert_equal(2, foldclosedend(1))\n  call assert_equal(0, foldlevel(3))\n  call assert_equal(0, foldlevel(4))\n  call assert_equal(1, foldlevel(5))\n  call assert_equal(7, 5->foldclosedend())\n\n  bwipe!\n  set foldmethod&\nendfunc\n\nfunc Test_combining_folds_indent()\n  new\n  let one = \"\\<Tab>a\"\n  let zero = 'a'\n  call setline(1, [one, one, zero, zero, zero, one, one, one])\n  set foldmethod=indent\n  3,5d\n  %foldclose\n  call assert_equal(5, foldclosedend(1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc Test_combining_folds_marker()\n  new\n  call setline(1, ['{{{', '}}}', '', '', '', '{{{', '', '}}}'])\n  set foldmethod=marker\n  3,5d\n  %foldclose\n  call assert_equal(2, foldclosedend(1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc Test_folds_marker_in_comment()\n  new\n  call setline(1, ['\" foo', 'bar', 'baz'])\n  setl fen fdm=marker\n  setl com=sO:\\\"\\ -,mO:\\\"\\ \\ ,eO:\\\"\\\",:\\\" cms=\\\"%s\n  norm! zf2j\n  setl nofen\n  :1y\n  call assert_equal(['\" foo{{{'], getreg(0,1,1))\n  :+2y\n  call assert_equal(['baz\"}}}'], getreg(0,1,1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc s:TestFoldExpr(lnum)\n  let thisline = getline(a:lnum)\n  if thisline == 'a'\n    return 1\n  elseif thisline == 'b'\n    return 0\n  elseif thisline == 'c'\n    return '<1'\n  elseif thisline == 'd'\n    return '>1'\n  endif\n  return 0\nendfunction\n\nfunc Test_update_folds_expr_read()\n  new\n  call setline(1, ['a', 'a', 'a', 'a', 'a', 'a'])\n  set foldmethod=expr\n  set foldexpr=s:TestFoldExpr(v:lnum)\n  2\n  foldopen\n  call writefile(['b', 'b', 'a', 'a', 'd', 'a', 'a', 'c'], 'Xupfofile', 'D')\n  read Xupfofile\n  %foldclose\n  call assert_equal(2, foldclosedend(1))\n  call assert_equal(0, foldlevel(3))\n  call assert_equal(0, 4->foldlevel())\n  call assert_equal(6, foldclosedend(5))\n  call assert_equal(10, foldclosedend(7))\n  call assert_equal(14, foldclosedend(11))\n\n  bwipe!\n  set foldmethod& foldexpr&\nendfunc\n\n\" Test for what patch 8.1.0535 fixes.\nfunc Test_foldexpr_no_interrupt_addsub()\n  new\n  func! FoldFunc()\n    call setpos('.', getcurpos())\n    return '='\n  endfunc\n\n  set foldmethod=expr\n  set foldexpr=FoldFunc()\n  call setline(1, '1.2')\n\n  exe \"norm! $\\<C-A>\"\n  call assert_equal('1.3', getline(1))\n\n  bwipe!\n  delfunc FoldFunc\n  set foldmethod& foldexpr&\nendfunc\n\n\" Fold function defined in another script\nfunc Test_foldexpr_compiled()\n  new\n  let lines =<< trim END\n      vim9script\n      def FoldFunc(): number\n        return v:lnum\n      enddef\n\n      set foldmethod=expr\n      set foldexpr=s:FoldFunc()\n  END\n  call writefile(lines, 'XfoldExpr', 'D')\n  source XfoldExpr\n\n  call setline(1, ['one', 'two', 'three'])\n  redraw\n  call assert_equal(1, foldlevel(1))\n  call assert_equal(2, foldlevel(2))\n  call assert_equal(3, foldlevel(3))\n\n  bwipe!\n  set foldmethod& foldexpr&\nendfunc\n\nfunc Check_foldlevels(expected)\n  call assert_equal(a:expected, map(range(1, line('$')), 'foldlevel(v:val)'))\nendfunc\n\nfunc Test_move_folds_around_manual()\n  new\n  let input = PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\")\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  let folds=[-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14]\n  \" all folds closed\n  set foldenable foldlevel=0 fdm=indent\n  \" needs a forced redraw\n  redraw!\n  set fdm=manual\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  call assert_equal(input, getline(1, '$'))\n  7,12m0\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  10,12m0\n  call assert_equal(PrepIndent(\"a\")[1:] + PrepIndent(\"b\") + [\"a\"] +  PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal([1, 1, 1, 1, 1, -1, 7, 7, 7, 7, 7, -1, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  \" moving should not close the folds\n  %d\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  set fdm=indent\n  redraw!\n  set fdm=manual\n  call cursor(2, 1)\n  %foldopen\n  7,12m0\n  let folds=repeat([-1], 18)\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  norm! zM\n  \" folds are not corrupted and all have been closed\n  call assert_equal([-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\"])\n  set fdm=indent\n  redraw!\n  set fdm=manual\n  %foldopen\n  3m4\n  %foldclose\n  call assert_equal([\"a\", \"\\tb\", \"\\td\", \"\\tc\", \"\\te\"], getline(1, '$'))\n  call assert_equal([-1, 5, 5, 5, 5], map(range(1, line('$')), 'foldclosedend(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"])\n  set fdm=indent foldlevel=0\n  set fdm=manual\n  %foldopen\n  3m1\n  %foldclose\n  call assert_equal([\"a\", \"\\tc\", \"\\tb\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"], getline(1, '$'))\n  call assert_equal(0, foldlevel(2))\n  call assert_equal(5, foldclosedend(3))\n  call assert_equal([-1, -1, 3, 3, 3, -1, 7, 7, 7, 7], map(range(1, line('$')), 'foldclosed(v:val)'))\n  2,6m$\n  %foldclose\n  call assert_equal(5, foldclosedend(2))\n  call assert_equal(0, foldlevel(6))\n  call assert_equal(9, foldclosedend(7))\n  call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, -1], map(range(1, line('$')), 'foldclosed(v:val)'))\n\n  %d\n  \" Ensure moving around the edges still works.\n  call setline(1, PrepIndent(\"a\") + repeat([\"a\"], 3) + [\"\\ta\"])\n  set fdm=indent foldlevel=0\n  set fdm=manual\n  %foldopen\n  6m$\n  \" The first fold has been truncated to the 5'th line.\n  \" Second fold has been moved up because the moved line is now below it.\n  call Check_foldlevels([0, 1, 1, 1, 1, 0, 0, 0, 1, 0])\n\n  %delete\n  set fdm=indent foldlevel=0\n  call setline(1, [\n\t\\ \"a\",\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"a\",\n\t\\ \"a\"])\n  set fdm=manual\n  %foldopen!\n  4,5m6\n  call Check_foldlevels([0, 1, 2, 0, 0, 0, 0])\n\n  %delete\n  set fdm=indent\n  call setline(1, [\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\t\\ta\",\n\t\\ \"\\ta\",\n\t\\ \"a\"])\n  set fdm=manual\n  %foldopen!\n  13m7\n  call Check_foldlevels([1, 2, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 0])\n  \n  bw!\nendfunc\n\nfunc Test_move_folds_around_indent()\n  new\n  let input = PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\")\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  let folds=[-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14]\n  \" all folds closed\n  set fdm=indent\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  call assert_equal(input, getline(1, '$'))\n  7,12m0\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  10,12m0\n  call assert_equal(PrepIndent(\"a\")[1:] + PrepIndent(\"b\") + [\"a\"] +  PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal([1, 1, 1, 1, 1, -1, 7, 7, 7, 7, 7, -1, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  \" moving should not close the folds\n  %d\n  call setline(1, PrepIndent(\"a\") + PrepIndent(\"b\") + PrepIndent(\"c\"))\n  set fdm=indent\n  call cursor(2, 1)\n  %foldopen\n  7,12m0\n  let folds=repeat([-1], 18)\n  call assert_equal(PrepIndent(\"b\") + PrepIndent(\"a\") + PrepIndent(\"c\"), getline(1, '$'))\n  call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))\n  norm! zM\n  \" folds are not corrupted and all have been closed\n  call assert_equal([-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\"])\n  set fdm=indent\n  %foldopen\n  3m4\n  %foldclose\n  call assert_equal([\"a\", \"\\tb\", \"\\td\", \"\\tc\", \"\\te\"], getline(1, '$'))\n  call assert_equal([-1, 5, 5, 5, 5], map(range(1, line('$')), 'foldclosedend(v:val)'))\n  %d\n  call setline(1, [\"a\", \"\\tb\", \"\\tc\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"])\n  set fdm=indent foldlevel=0\n  %foldopen\n  3m1\n  %foldclose\n  call assert_equal([\"a\", \"\\tc\", \"\\tb\", \"\\td\", \"\\te\", \"z\", \"\\ty\", \"\\tx\", \"\\tw\", \"\\tv\"], getline(1, '$'))\n  call assert_equal(1, foldlevel(2))\n  call assert_equal(5, foldclosedend(3))\n  call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, 7], map(range(1, line('$')), 'foldclosed(v:val)'))\n  2,6m$\n  %foldclose\n  call assert_equal(9, foldclosedend(2))\n  call assert_equal(1, foldlevel(6))\n  call assert_equal(9, foldclosedend(7))\n  call assert_equal([-1, 2, 2, 2, 2, 2, 2, 2, 2, -1], map(range(1, line('$')), 'foldclosed(v:val)'))\n  \" Ensure moving around the edges still works.\n  %d\n  call setline(1, PrepIndent(\"a\") + repeat([\"a\"], 3) + [\"\\ta\"])\n  set fdm=indent foldlevel=0\n  %foldopen\n  6m$\n  \" The first fold has been truncated to the 5'th line.\n  \" Second fold has been moved up because the moved line is now below it.\n  call Check_foldlevels([0, 1, 1, 1, 1, 0, 0, 0, 1, 1])\n  bw!\nendfunc\n\nfunc Test_folddoopen_folddoclosed()\n  new\n  call setline(1, range(1, 9))\n  set foldmethod=manual\n  1,3 fold\n  6,8 fold\n\n  \" Test without range.\n  folddoopen   s/$/o/\n  folddoclosed s/$/c/\n  call assert_equal(['1c', '2c', '3c',\n  \\                  '4o', '5o',\n  \\                  '6c', '7c', '8c',\n  \\                  '9o'], getline(1, '$'))\n\n  \" Test with range.\n  call setline(1, range(1, 9))\n  1,8 folddoopen   s/$/o/\n  4,$ folddoclosed s/$/c/\n  call assert_equal(['1',  '2', '3',\n  \\                  '4o', '5o',\n  \\                  '6c', '7c', '8c',\n  \\                  '9'], getline(1, '$'))\n\n  set foldmethod&\n  bw!\nendfunc\n\nfunc Test_fold_error()\n  new\n  call setline(1, [1, 2])\n\n  for fm in ['indent', 'expr', 'syntax', 'diff']\n    exe 'set foldmethod=' . fm\n    call assert_fails('norm zf', 'E350:')\n    call assert_fails('norm zd', 'E351:')\n    call assert_fails('norm zE', 'E352:')\n  endfor\n\n  set foldmethod=manual\n  call assert_fails('norm zd', 'E490:')\n  call assert_fails('norm zo', 'E490:')\n  call assert_fails('3fold',   'E16:')\n\n  set foldmethod=marker\n  set nomodifiable\n  call assert_fails('1,2fold', 'E21:')\n\n  set modifiable&\n  set foldmethod&\n  bw!\nendfunc\n\nfunc Test_foldtext_recursive()\n  new\n  call setline(1, ['{{{', 'some text', '}}}'])\n  setlocal foldenable foldmethod=marker foldtext=foldtextresult(v\\:foldstart)\n  \" This was crashing because of endless recursion.\n  2foldclose\n  redraw\n  call assert_equal(1, foldlevel(2))\n  call assert_equal(1, foldclosed(2))\n  call assert_equal(3, foldclosedend(2))\n  bwipe!\nendfunc\n\n\" Various fold related tests\n\n\" Basic test if a fold can be created, opened, moving to the end and closed\nfunc Test_fold_manual()\n  new\n  set fdm=manual\n\n  let content = ['1 aa', '2 bb', '3 cc']\n  call append(0, content)\n  call cursor(1, 1)\n  normal zf2j\n  call assert_equal('1 aa', getline(foldclosed('.')))\n  normal zo\n  call assert_equal(-1, foldclosed('.'))\n  normal ]z\n  call assert_equal('3 cc', getline('.'))\n  normal zc\n  call assert_equal('1 aa', getline(foldclosed('.')))\n\n  \" Create a fold inside a closed fold after setting 'foldlevel'\n  %d _\n  call setline(1, range(1, 5))\n  1,5fold\n  normal zR\n  2,4fold\n  set foldlevel=1\n  3fold\n  call assert_equal([1, 3, 3, 3, 1], map(range(1, 5), {->foldlevel(v:val)}))\n  set foldlevel&\n\n  \" Create overlapping folds (at the start and at the end)\n  normal zE\n  2,3fold\n  normal zR\n  3,4fold\n  call assert_equal([0, 2, 2, 1, 0], map(range(1, 5), {->foldlevel(v:val)}))\n  normal zE\n  3,4fold\n  normal zR\n  2,3fold\n  call assert_equal([0, 1, 2, 2, 0], map(range(1, 5), {->foldlevel(v:val)}))\n\n  \" Create a nested fold across two non-adjoining folds\n  %d _\n  call setline(1, range(1, 7))\n  1,2fold\n  normal zR\n  4,5fold\n  normal zR\n  6,7fold\n  normal zR\n  1,5fold\n  call assert_equal([2, 2, 1, 2, 2, 1, 1],\n        \\ map(range(1, 7), {->foldlevel(v:val)}))\n\n  \" A newly created nested fold should be closed\n  %d _\n  call setline(1, range(1, 6))\n  1,6fold\n  normal zR\n  3,4fold\n  normal zR\n  2,5fold\n  call assert_equal([1, 2, 3, 3, 2, 1], map(range(1, 6), {->foldlevel(v:val)}))\n  call assert_equal(2, foldclosed(4))\n  call assert_equal(5, foldclosedend(4))\n\n  \" Test zO, zC and zA on a line with no folds.\n  normal zE\n  call assert_fails('normal zO', 'E490:')\n  call assert_fails('normal zC', 'E490:')\n  call assert_fails('normal zA', 'E490:')\n\n  set fdm&\n  bw!\nendfunc\n\n\" test folding with markers.\nfunc Test_fold_marker()\n  new\n  set fdm=marker fdl=1 fdc=3\n\n  let content = ['4 dd {{{', '5 ee {{{ }}}', '6 ff }}}']\n  call append(0, content)\n  call cursor(2, 1)\n  call assert_equal(2, foldlevel('.'))\n  normal [z\n  call assert_equal(1, foldlevel('.'))\n  exe \"normal jo{{ \\<Esc>r{jj\"\n  call assert_equal(1, foldlevel('.'))\n  normal kYpj\n  call assert_equal(0, foldlevel('.'))\n\n  \" Use only closing fold marker (without and with a count)\n  set fdl&\n  %d _\n  call setline(1, ['one }}}', 'two'])\n  call assert_equal([0, 0], [foldlevel(1), foldlevel(2)])\n  %d _\n  call setline(1, ['one }}}4', 'two'])\n  call assert_equal([4, 3], [foldlevel(1), foldlevel(2)])\n\n  set fdm& fdl& fdc&\n  bw!\nendfunc\n\n\" test create fold markers with C filetype\nfunc Test_fold_create_marker_in_C()\n  bw!\n  set fdm=marker fdl=9\n  set filetype=c\n\n  let content =<< trim [CODE]\n    /*\n     * comment\n     * \n     *\n     */\n    int f(int* p) {\n        *p = 3;\n        return 0;\n    }\n  [CODE]\n\n  for c in range(len(content) - 1)\n    bw!\n    call append(0, content)\n    call cursor(c + 1, 1)\n    norm! zfG\n    call assert_equal(content[c] . (c < 4 ? '{{{' : '/*{{{*/'), getline(c + 1))\n  endfor\n\n  set fdm& fdl&\n  bw!\nendfunc\n\n\" test folding with indent\nfunc Test_fold_indent()\n  new\n  set fdm=indent sw=2\n\n  let content = ['1 aa', '2 bb', '3 cc']\n  call append(0, content)\n  call cursor(2, 1)\n  exe \"normal i  \\<Esc>jI    \"\n  call assert_equal(2, foldlevel('.'))\n  normal k\n  call assert_equal(1, foldlevel('.'))\n\n  set fdm& sw&\n  bw!\nendfunc\n\n\" test syntax folding\nfunc Test_fold_syntax()\n  CheckFeature syntax\n\n  new\n  set fdm=syntax fdl=0\n\n  syn region Hup start=\"dd\" end=\"ii\" fold contains=Fd1,Fd2,Fd3\n  syn region Fd1 start=\"ee\" end=\"ff\" fold contained\n  syn region Fd2 start=\"gg\" end=\"hh\" fold contained\n  syn region Fd3 start=\"commentstart\" end=\"commentend\" fold contained\n  let content = ['3 cc', '4 dd {{{', '5 ee {{{ }}}', '{{{{', '6 ff }}}',\n\t      \\ '6 ff }}}', '7 gg', '8 hh', '9 ii']\n  call append(0, content)\n  normal Gzk\n  call assert_equal('9 ii', getline('.'))\n  normal k\n  call assert_equal('3 cc', getline('.'))\n  exe \"normal jAcommentstart   \\<Esc>Acommentend\"\n  set fdl=1\n  normal 3j\n  call assert_equal('7 gg', getline('.'))\n  set fdl=0\n  exe \"normal zO\\<C-L>j\"\n  call assert_equal('8 hh', getline('.'))\n  syn clear Fd1 Fd2 Fd3 Hup\n\n  set fdm& fdl&\n  bw!\nendfunc\n\nfunc Flvl()\n  let l = getline(v:lnum)\n  if l =~ \"bb$\"\n    return 2\n  elseif l =~ \"gg$\"\n    return \"s1\"\n  elseif l =~ \"ii$\"\n    return \">2\"\n  elseif l =~ \"kk$\"\n    return \"0\"\n  endif\n  return \"=\"\nendfun\n\n\" test expression folding\nfunc Test_fold_expr()\n  new\n  set fdm=expr fde=Flvl()\n\n  let content = ['1 aa',\n\t      \\ '2 bb',\n\t      \\ '3 cc',\n\t      \\ '4 dd {{{commentstart  commentend',\n\t      \\ '5 ee {{{ }}}',\n\t      \\ '{{{',\n\t      \\ '6 ff }}}',\n\t      \\ '6 ff }}}',\n\t      \\ '  7 gg',\n\t      \\ '    8 hh',\n\t      \\ '9 ii',\n\t      \\ 'a jj',\n\t      \\ 'b kk']\n  call append(0, content)\n  call cursor(1, 1)\n  exe \"normal /bb$\\<CR>\"\n  call assert_equal(2, foldlevel('.'))\n  exe \"normal /hh$\\<CR>\"\n  call assert_equal(1, foldlevel('.'))\n  exe \"normal /ii$\\<CR>\"\n  call assert_equal(2, foldlevel('.'))\n  exe \"normal /kk$\\<CR>\"\n  call assert_equal(0, foldlevel('.'))\n\n  set fdm& fde&\n  bw!\nendfunc\n\n\" Bug with fdm=indent and moving folds\n\" Moving a fold a few times, messes up the folds below the moved fold.\n\" Fixed by 7.4.700\nfunc Test_fold_move()\n  new\n  set fdm=indent sw=2 fdl=0\n\n  let content = ['', '', 'Line1', '  Line2', '  Line3',\n\t      \\ 'Line4', '  Line5', '  Line6',\n\t      \\ 'Line7', '  Line8', '  Line9']\n  call append(0, content)\n  normal zM\n  call cursor(4, 1)\n  move 2\n  move 1\n  call assert_equal(7, foldclosed(7))\n  call assert_equal(8, foldclosedend(7))\n  call assert_equal(0, foldlevel(9))\n  call assert_equal(10, foldclosed(10))\n  call assert_equal(11, foldclosedend(10))\n  call assert_equal('+--  2 lines: Line2', foldtextresult(2))\n  call assert_equal('+--  2 lines: Line8', 10->foldtextresult())\n\n  set fdm& sw& fdl&\n  bw!\nendfunc\n\n\" test for patch 7.3.637\n\" Cannot catch the error caused by a foldopen when there is no fold.\nfunc Test_foldopen_exception()\n  new\n  let a = 'No error caught'\n  try\n    foldopen\n  catch\n    let a = matchstr(v:exception,'^[^ ]*')\n  endtry\n  call assert_equal('Vim(foldopen):E490:', a)\n\n  let a = 'No error caught'\n  try\n    foobar\n  catch\n    let a = matchstr(v:exception,'^[^ ]*')\n  endtry\n  call assert_match('E492:', a)\n  bw!\nendfunc\n\nfunc Test_fold_last_line_with_pagedown()\n  new\n  set fdm=manual\n\n  let expect = '+-- 11 lines: 9---'\n  let content = range(1,19)\n  call append(0, content)\n  normal dd9G\n  normal zfG\n  normal zt\n  call assert_equal('9', getline(foldclosed('.')))\n  call assert_equal('19', getline(foldclosedend('.')))\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n  call feedkeys(\"\\<C-F>\", 'xt')\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n  call feedkeys(\"\\<C-F>\", 'xt')\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n  call feedkeys(\"\\<C-B>\\<C-F>\\<C-F>\", 'xt')\n  call assert_equal(expect, ScreenLines(1, len(expect))[0])\n\n  set fdm&\n  bw!\nendfunc\n\nfunc Test_folds_with_rnu()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set fdm=marker rnu foldcolumn=2',\n\t\\ 'call setline(1, [\"{{{1\", \"nline 1\", \"{{{1\", \"line 2\"])',\n\t\\ ], 'Xtest_folds_with_rnu', 'D')\n  let buf = RunVimInTerminal('-S Xtest_folds_with_rnu', {})\n\n  call VerifyScreenDump(buf, 'Test_folds_with_rnu_01', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_folds_with_rnu_02', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_folds_marker_in_comment2()\n  new\n  call setline(1, ['Lorem ipsum dolor sit', 'Lorem ipsum dolor sit', 'Lorem ipsum dolor sit'])\n  setl fen fdm=marker\n  setl commentstring=<!--%s-->\n  setl comments=s:<!--,m:\\ \\ \\ \\ ,e:-->\n  norm! zf2j\n  setl nofen\n  :1y\n  call assert_equal(['Lorem ipsum dolor sit<!--{{{-->'], getreg(0,1,1))\n  :+2y\n  call assert_equal(['Lorem ipsum dolor sit<!--}}}-->'], getreg(0,1,1))\n\n  set foldmethod&\n  bwipe!\nendfunc\n\nfunc Test_fold_delete_with_marker()\n  new\n  call setline(1, ['func Func() {{{1', 'endfunc'])\n  1,2yank\n  new\n  set fdm=marker\n  call setline(1, 'x')\n  normal! Vp\n  normal! zd\n  call assert_equal(['func Func() ', 'endfunc'], getline(1, '$'))\n\n  set fdm&\n  bwipe!\n  bwipe!\nendfunc\n\nfunc Test_fold_delete_with_marker_and_whichwrap()\n  new\n  let content1 = ['']\n  let content2 = ['folded line 1 \"{{{1', '  test', '  test2', '  test3', '', 'folded line 2 \"{{{1', '  test', '  test2', '  test3']\n  call setline(1, content1 + content2)\n  set fdm=marker ww+=l\n  normal! x\n  call assert_equal(content2, getline(1, '$'))\n  set fdm& ww&\n  bwipe!\nendfunc\n\nfunc Test_fold_delete_first_line()\n  new\n  call setline(1, [\n\t\\ '\" x {{{1',\n\t\\ '\" a',\n\t\\ '\" aa',\n\t\\ '\" x {{{1',\n\t\\ '\" b',\n\t\\ '\" bb',\n\t\\ '\" x {{{1',\n\t\\ '\" c',\n\t\\ '\" cc',\n\t\\ ])\n  set foldmethod=marker\n  1\n  normal dj\n  call assert_equal([\n\t\\ '\" x {{{1',\n\t\\ '\" c',\n\t\\ '\" cc',\n\t\\ ], getline(1,'$'))\n  bwipe!\n  set foldmethod&\nendfunc\n\n\" Add a test for deleting the outer fold of a nested fold and promoting the\n\" inner folds to one level up with already a fold at that level following the\n\" nested fold.\nfunc Test_fold_delete_recursive_fold()\n  new\n  call setline(1, range(1, 7))\n  2,3fold\n  normal zR\n  4,5fold\n  normal zR\n  1,5fold\n  normal zR\n  6,7fold\n  normal zR\n  normal 1Gzd\n  normal 1Gzj\n  call assert_equal(2, line('.'))\n  normal zj\n  call assert_equal(4, line('.'))\n  normal zj\n  call assert_equal(6, line('.'))\n  bw!\nendfunc\n\n\" Test for errors in 'foldexpr'\nfunc Test_fold_expr_error()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  \" In a window with no folds, foldlevel() should return 0\n  call assert_equal(0, foldlevel(1))\n\n  \" Return a list from the expression\n  set foldexpr=[]\n  set foldmethod=expr\n  for i in range(3)\n    call assert_equal(0, foldlevel(i))\n  endfor\n\n  \" expression error\n  set foldexpr=[{]\n  set foldmethod=expr\n  for i in range(3)\n    call assert_equal(0, foldlevel(i))\n  endfor\n\n  set foldmethod& foldexpr&\n  close!\nendfunc\n\nfunc Test_undo_fold_deletion()\n  new\n  set fdm=marker\n  let lines =<< trim END\n      \" {{{\n      \" }}}1\n      \" {{{\n  END\n  call setline(1, lines)\n  3d\n  g/\"/d\n  undo\n  redo\n  eval getline(1, '$')->assert_equal([''])\n\n  set fdm&vim\n  bwipe!\nendfunc\n\n\" this was crashing\nfunc Test_move_no_folds()\n  new\n  fold\n  setlocal fdm=expr\n  normal zj\n  bwipe!\nendfunc\n\n\" this was crashing\nfunc Test_fold_create_delete_create()\n  new\n  fold\n  fold\n  normal zd\n  fold\n  bwipe!\nendfunc\n\n\" this was crashing\nfunc Test_fold_create_delete()\n  new\n  norm zFzFzdzj\n  bwipe!\nendfunc\n\nfunc Test_fold_relative_move()\n  new\n  set fdm=indent sw=2 wrap tw=80\n\n  let longtext = repeat('x', &columns + 1)\n  let content = [ '  foo', '  ' .. longtext, '  baz',\n              \\   longtext,\n              \\   '  foo', '  ' .. longtext, '  baz'\n              \\ ]\n  call append(0, content)\n\n  normal zM\n\n  for lnum in range(1, 3)\n    call cursor(lnum, 1)\n    call assert_true(foldclosed(line('.')))\n    normal gj\n    call assert_equal(2, winline())\n  endfor\n\n  call cursor(2, 1)\n  call assert_true(foldclosed(line('.')))\n  normal 2gj\n  call assert_equal(3, winline())\n\n  for lnum in range(5, 7)\n    call cursor(lnum, 1)\n    call assert_true(foldclosed(line('.')))\n    normal gk\n    call assert_equal(3, winline())\n  endfor\n\n  call cursor(6, 1)\n  call assert_true(foldclosed(line('.')))\n  normal 2gk\n  call assert_equal(2, winline())\n\n  set fdm& sw& wrap& tw&\n  bw!\nendfunc\n\n\" Test for using multibyte characters as 'foldopen', 'foldclose' and\n\" 'foldsetp' items in 'fillchars'\nfunc s:mbyte_fillchar_tests(fo, fc, fs)\n  setlocal foldcolumn=3\n\n  normal zE\n  1,2fold\n  call assert_equal([a:fc .. '  +--  2 ', '   three  '],\n        \\ ScreenLines([1, 2], 10))\n  1,2foldopen\n  call assert_equal([a:fo .. '  one ', a:fs .. '  two '],\n        \\ ScreenLines([1, 2], 7))\n  1,2foldclose\n  redraw!\n  call assert_equal([a:fc .. '  +--  2 ', '   three  '],\n        \\  ScreenLines([1, 2], 10))\n\n  \" Two level fold\n  normal zE\n  2,3fold\n  1,4fold\n  call assert_equal([a:fc .. '  +--  4 ', '   five   '],\n        \\ ScreenLines([1, 2], 10))\n  1,4foldopen\n  call assert_equal([a:fo .. '  one    ', a:fs .. a:fc .. ' +---  2'],\n        \\ ScreenLines([1, 2], 10))\n  1,4foldopen\n  call assert_equal([a:fo .. '  one    ', a:fs .. a:fo .. ' two    ',\n        \\ a:fs .. a:fs .. ' three  '], ScreenLines([1, 3], 10))\n  2,3foldclose\n  call assert_equal([a:fo .. '  one    ', a:fs .. a:fc .. ' +---  2'],\n        \\ ScreenLines([1, 2], 10))\n  1,4foldclose\n  call assert_equal([a:fc .. '  +--  4 ', '   five   '],\n        \\ ScreenLines([1, 2], 10))\n\n  \" Three level fold\n  normal zE\n  3,4fold\n  2,5fold\n  1,6fold\n  call assert_equal([a:fc .. '  +--  6 '], ScreenLines(1, 10))\n  \" open all the folds\n  normal zR\n  call assert_equal([\n        \\ a:fo .. '  one    ',\n        \\ a:fs .. a:fo .. ' two    ',\n        \\ '2' .. a:fo .. ' three  ',\n        \\ '23 four   ',\n        \\ a:fs .. a:fs .. ' five   ',\n        \\ a:fs .. '  six    ',\n        \\ ], ScreenLines([1, 6], 10))\n  \" close the innermost fold\n  3,4foldclose\n  call assert_equal([\n        \\ a:fo .. '  one    ',\n        \\ a:fs .. a:fo .. ' two    ',\n        \\ a:fs .. a:fs .. a:fc .. '+----  ',\n        \\ a:fs .. a:fs .. ' five   ',\n        \\ a:fs .. '  six    ',\n        \\ ], ScreenLines([1, 5], 10))\n  \" close the next fold\n  2,5foldclose\n  call assert_equal([\n        \\ a:fo .. '  one    ',\n        \\ a:fs .. a:fc .. ' +---  4',\n        \\ a:fs .. '  six    ',\n        \\ ], ScreenLines([1, 3], 10))\n\n  \" set the fold column size to 2\n  setlocal fdc=2\n  normal zR\n  call assert_equal([\n        \\ a:fo .. ' one  ',\n        \\ a:fo .. ' two  ',\n        \\ a:fo .. ' three',\n        \\ '3 four ',\n        \\ '2 five ',\n        \\ a:fs .. ' six  ',\n        \\ ], ScreenLines([1, 6], 7))\n\n  \" set the fold column size to 1\n  setlocal fdc=1\n  normal zR\n  call assert_equal([\n        \\ a:fo .. 'one   ',\n        \\ a:fo .. 'two   ',\n        \\ a:fo .. 'three ',\n        \\ '3four  ',\n        \\ '2five  ',\n        \\ a:fs .. 'six   ',\n        \\ ], ScreenLines([1, 6], 7))\n\n  \" Enable number and sign columns and place some signs\n  setlocal fdc=3\n  setlocal number\n  setlocal signcolumn=auto\n  sign define S1 text=->\n  sign place 10 line=3 name=S1\n  call assert_equal([\n        \\ a:fo .. '      1 one  ',\n        \\ a:fs .. a:fo .. '     2 two  ',\n        \\ '2' .. a:fo .. ' ->  3 three',\n        \\ '23     4 four ',\n        \\ a:fs .. a:fs .. '     5 five ',\n        \\ a:fs .. '      6 six  '\n        \\ ], ScreenLines([1, 6], 14))\n\n  \" Test with 'rightleft'\n  if has('rightleft')\n    setlocal rightleft\n    let lines = ScreenLines([1, 6], winwidth(0))\n    call assert_equal('o 1      ' .. a:fo,\n          \\  strcharpart(lines[0], strchars(lines[0]) - 10, 10))\n    call assert_equal('t 2     ' .. a:fo .. a:fs,\n          \\  strcharpart(lines[1], strchars(lines[1]) - 10, 10))\n    call assert_equal('t 3  >- ' .. a:fo .. '2',\n          \\  strcharpart(lines[2], strchars(lines[2]) - 10, 10))\n    call assert_equal('f 4     32',\n          \\  strcharpart(lines[3], strchars(lines[3]) - 10, 10))\n    call assert_equal('f 5     ' .. a:fs .. a:fs,\n          \\  strcharpart(lines[4], strchars(lines[4]) - 10, 10))\n    call assert_equal('s 6      ' .. a:fs,\n          \\  strcharpart(lines[5], strchars(lines[5]) - 10, 10))\n    setlocal norightleft\n  endif\n\n  sign unplace *\n  sign undefine S1\n  setlocal number& signcolumn&\n\n  \" Add a test with more than 9 folds (and then delete some folds)\n  normal zE\n  for i in range(1, 10)\n    normal zfGzo\n  endfor\n  normal zR\n  call assert_equal([\n        \\ a:fo .. a:fo .. ' one ',\n        \\ '9> two '\n        \\ ], ScreenLines([1, 2], 7))\n  normal 1Gzd\n  call assert_equal([\n        \\ a:fo .. a:fo .. ' one ',\n        \\ '89 two '\n        \\ ], ScreenLines([1, 2], 7))\n  normal 1Gzdzdzdzdzdzdzd\n  call assert_equal([\n        \\ a:fo .. a:fo .. ' one ',\n        \\ a:fs .. a:fs .. ' two '\n        \\ ], ScreenLines([1, 2], 7))\n\n  setlocal foldcolumn& number& signcolumn&\nendfunc\n\nfunc Test_foldcolumn_multibyte_char()\n  new\n  call setline(1, ['one', 'two', 'three', 'four', 'five', 'six'])\n  setlocal foldenable foldmethod=manual\n\n  \" First test with the default setting\n  call s:mbyte_fillchar_tests('-', '+', '|')\n\n  \" Use multi-byte characters\n  set fillchars+=foldopen:\u25be,foldsep:\u2502,foldclose:\u25b8\n  call s:mbyte_fillchar_tests('\u25be', '\u25b8', '\u2502')\n\n  \" Use a mix of multi-byte and single-byte characters\n  set fillchars+=foldopen:\u00ac,foldsep:\\|,foldclose:+\n  call s:mbyte_fillchar_tests('\u00ac', '+', '|')\n  set fillchars+=foldopen:+,foldsep:\\|,foldclose:\u00ac\n  call s:mbyte_fillchar_tests('+', '\u00ac', '|')\n\n  bw!\n  set foldenable& fdc& fdm& fillchars&\nendfunc\n\n\" Test for calling foldlevel() from a fold expression\nlet g:FoldLevels = []\nfunc FoldExpr1(lnum)\n  let f = [a:lnum]\n  for i in range(1, line('$'))\n    call add(f, foldlevel(i))\n  endfor\n  call add(g:FoldLevels, f)\n  return getline(a:lnum)[0] == \"\\t\"\nendfunc\n\nfunc Test_foldexpr_foldlevel()\n  new\n  call setline(1, ['one', \"\\ttwo\", \"\\tthree\"])\n  setlocal foldmethod=expr\n  setlocal foldexpr=FoldExpr1(v:lnum)\n  setlocal foldenable\n  setlocal foldcolumn=3\n  redraw!\n  call assert_equal([[1, -1, -1, -1], [2, -1, -1, -1], [3, 0, 1, -1]],\n        \\ g:FoldLevels)\n  set foldmethod& foldexpr& foldenable& foldcolumn&\n  bw!\nendfunc\n\n\" Test for returning different values from a fold expression\nfunc FoldExpr2(lnum)\n  if a:lnum == 1 || a:lnum == 4\n    return -2\n  elseif a:lnum == 2\n    return 'a1'\n  elseif a:lnum == 3\n    return 's4'\n  endif\n  return '='\nendfunc\n\nfunc Test_foldexpr_2()\n  new\n  call setline(1, ['one', 'two', 'three', 'four'])\n  setlocal foldexpr=FoldExpr2(v:lnum)\n  setlocal foldmethod=expr\n  call assert_equal([0, 1, 1, 0], [foldlevel(1), foldlevel(2), foldlevel(3),\n        \\ foldlevel(4)])\n  bw!\nendfunc\n\n\" Test for the 'foldclose' option\nfunc Test_foldclose_opt()\n  CheckScreendump\n\n  let lines =<< trim END\n    set foldmethod=manual foldclose=all foldopen=all\n    call setline(1, ['one', 'two', 'three', 'four'])\n    2,3fold\n    func XsaveFoldLevels()\n      redraw!\n      call writefile([json_encode([foldclosed(1), foldclosed(2), foldclosed(3),\n        \\ foldclosed(4)])], 'Xoutput', 'a')\n    endfunc\n  END\n  call writefile(lines, 'Xscript', 'D')\n  let rows = 10\n  let buf = RunVimInTerminal('-S Xscript', {'rows': rows})\n  call term_wait(buf)\n  call term_sendkeys(buf, \":set noruler\\n\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"2G\")\n  call WaitForAssert({-> assert_equal('two', term_getline(buf, 2))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"4G\")\n  call WaitForAssert({-> assert_equal('four', term_getline(buf, 3))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"3G\")\n  call WaitForAssert({-> assert_equal('three', term_getline(buf, 3))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"1G\")\n  call WaitForAssert({-> assert_equal('four', term_getline(buf, 3))})\n  call term_sendkeys(buf, \":call XsaveFoldLevels()\\n\")\n  call term_sendkeys(buf, \"2G\")\n  call WaitForAssert({-> assert_equal('two', term_getline(buf, 2))})\n  call term_sendkeys(buf, \"k\")\n  call WaitForAssert({-> assert_equal('four', term_getline(buf, 3))})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['[-1,2,2,-1]', '[-1,-1,-1,-1]', '[-1,2,2,-1]',\n        \\ '[-1,-1,-1,-1]', '[-1,2,2,-1]'], readfile('Xoutput'))\n  call delete('Xoutput')\nendfunc\n\n\" Test for foldtextresult()\nfunc Test_foldtextresult()\n  new\n  call assert_equal('', foldtextresult(-1))\n  call assert_equal('', foldtextresult(0))\n  call assert_equal('', foldtextresult(1))\n  call setline(1, ['one', 'two', 'three', 'four'])\n  2,3fold\n  call assert_equal('', foldtextresult(1))\n  call assert_equal('+--  2 lines: two', foldtextresult(2))\n  setlocal foldtext=\n  call assert_equal('+--  2 lines folded ', foldtextresult(2))\n\n  \" Fold text for a C comment fold\n  %d _\n  setlocal foldtext&\n  call setline(1, ['', '/*', ' * Comment', ' */', ''])\n  2,4fold\n  call assert_equal('+--  3 lines: Comment', foldtextresult(2))\n\n  bw!\nendfunc\n\n\" Test for merging two recursive folds when an intermediate line with no fold\n\" is removed\nfunc Test_fold_merge_recursive()\n  new\n  call setline(1, ['  one', '    two', 'xxxx', '    three',\n        \\ '      four', \"\\tfive\"])\n  setlocal foldmethod=indent shiftwidth=2\n  3d_\n  %foldclose\n  call assert_equal([1, 5], [foldclosed(5), foldclosedend(1)])\n  bw!\nendfunc\n\n\" Test for moving a line which is the start of a fold from a recursive fold to\n\" outside. The fold length should reduce.\nfunc Test_fold_move_foldlevel()\n  new\n  call setline(1, ['a{{{', 'b{{{', 'c{{{', 'd}}}', 'e}}}', 'f}}}', 'g'])\n  setlocal foldmethod=marker\n  normal zR\n  call assert_equal([3, 2, 1], [foldlevel(4), foldlevel(5), foldlevel(6)])\n  3move 7\n  call assert_equal([2, 1, 0], [foldlevel(3), foldlevel(4), foldlevel(5)])\n  call assert_equal(1, foldlevel(7))\n\n  \" Move a line from outside a fold to inside the fold.\n  %d _\n  call setline(1, ['a', 'b{{{', 'c}}}'])\n  normal zR\n  1move 2\n  call assert_equal([1, 1, 1], [foldlevel(1), foldlevel(2), foldlevel(3)])\n\n  \" Move the start of one fold to inside another fold\n  %d _\n  call setline(1, ['a', 'b{{{', 'c}}}', 'd{{{', 'e}}}'])\n  normal zR\n  call assert_equal([0, 1, 1, 1, 1], [foldlevel(1), foldlevel(2),\n        \\ foldlevel(3), foldlevel(4), foldlevel(5)])\n  1,2move 4\n  call assert_equal([0, 1, 1, 2, 2], [foldlevel(1), foldlevel(2),\n        \\ foldlevel(3), foldlevel(4), foldlevel(5)])\n\n  bw!\nendfunc\n\n\" Test for using zj and zk to move downwards and upwards to the start and end\n\" of the next fold.\n\" Test for using [z and ]z in a closed fold to jump to the beginning and end\n\" of the fold.\nfunc Test_fold_jump()\n  new\n  call setline(1, [\"\\t1\", \"\\t2\", \"\\t\\t3\", \"\\t\\t4\", \"\\t\\t\\t5\", \"\\t\\t\\t6\", \"\\t\\t7\", \"\\t\\t8\", \"\\t9\", \"\\t10\"])\n  setlocal foldmethod=indent\n  normal zR\n  normal zj\n  call assert_equal(3, line('.'))\n  normal zj\n  call assert_equal(5, line('.'))\n  call assert_beeps('normal zj')\n  call assert_equal(5, line('.'))\n  call assert_beeps('normal 9Gzj')\n  call assert_equal(9, line('.'))\n  normal Gzk\n  call assert_equal(8, line('.'))\n  normal zk\n  call assert_equal(6, line('.'))\n  call assert_beeps('normal zk')\n  call assert_equal(6, line('.'))\n  call assert_beeps('normal 2Gzk')\n  call assert_equal(2, line('.'))\n\n  \" Using [z or ]z in a closed fold should not move the cursor\n  %d _\n  call setline(1, [\"1\", \"\\t2\", \"\\t3\", \"\\t4\", \"\\t5\", \"\\t6\", \"7\"])\n  normal zR4Gzc\n  call assert_equal(4, line('.'))\n  call assert_beeps('normal [z')\n  call assert_equal(4, line('.'))\n  call assert_beeps('normal ]z')\n  call assert_equal(4, line('.'))\n  bw!\nendfunc\n\n\" Test for using a script-local function for 'foldexpr'\nfunc Test_foldexpr_scriptlocal_func()\n  func! s:FoldFunc()\n    let g:FoldLnum = v:lnum\n  endfunc\n  new | only\n  call setline(1, 'abc')\n  let g:FoldLnum = 0\n  set foldmethod=expr foldexpr=s:FoldFunc()\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldFunc()', &foldexpr)\n  call assert_equal(1, g:FoldLnum)\n  set foldmethod& foldexpr=\n  bw!\n  new | only\n  call setline(1, 'abc')\n  let g:FoldLnum = 0\n  set foldmethod=expr foldexpr=<SID>FoldFunc()\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldFunc()', &foldexpr)\n  call assert_equal(1, g:FoldLnum)\n  set foldmethod& foldexpr=\n  delfunc s:FoldFunc\n  bw!\nendfunc\n\n\" Test for using a script-local function for 'foldtext'\nfunc Test_foldtext_scriptlocal_func()\n  func! s:FoldText()\n    let g:FoldTextArgs = [v:foldstart, v:foldend]\n    return foldtext()\n  endfunc\n  new | only\n  call setline(1, range(50))\n  let g:FoldTextArgs = []\n  set foldmethod=manual\n  set foldtext=s:FoldText()\n  norm! 4Gzf4j\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldText()', &foldtext)\n  call assert_equal([4, 8], g:FoldTextArgs)\n  set foldtext&\n  bw!\n  new | only\n  call setline(1, range(50))\n  let g:FoldTextArgs = []\n  set foldmethod=manual\n  set foldtext=<SID>FoldText()\n  norm! 8Gzf4j\n  redraw!\n  call assert_equal(expand('<SID>') .. 'FoldText()', &foldtext)\n  call assert_equal([8, 12], g:FoldTextArgs)\n  set foldtext&\n  bw!\n  delfunc s:FoldText\nendfunc\n\n\" Make sure a fold containing a nested fold is split correctly when using\n\" foldmethod=indent\nfunc Test_fold_split()\n  new\n  let lines =<< trim END\n    line 1\n      line 2\n      line 3\n        line 4\n        line 5\n  END\n  call setline(1, lines)\n  setlocal sw=2\n  setlocal foldmethod=indent foldenable\n  call assert_equal([0, 1, 1, 2, 2], range(1, 5)->map('foldlevel(v:val)'))\n  call append(2, 'line 2.5')\n  call assert_equal([0, 1, 0, 1, 2, 2], range(1, 6)->map('foldlevel(v:val)'))\n  3d\n  call assert_equal([0, 1, 1, 2, 2], range(1, 5)->map('foldlevel(v:val)'))\n  bw!\nendfunc\n\n\" Make sure that when you append under a blank line that is under a fold with\n\" the same indent level as your appended line, the fold expands across the\n\" blank line\nfunc Test_indent_append_under_blank_line()\n  new\n  let lines =<< trim END\n    line 1\n      line 2\n      line 3\n  END\n  call setline(1, lines)\n  setlocal sw=2\n  setlocal foldmethod=indent foldenable\n  call assert_equal([0, 1, 1], range(1, 3)->map('foldlevel(v:val)'))\n  call append(3, '')\n  call append(4, '  line 5')\n  call assert_equal([0, 1, 1, 1, 1], range(1, 5)->map('foldlevel(v:val)'))\n  bw!\nendfunc\n\n\" Make sure that when you delete 1 line of a fold whose length is 2 lines, the\n\" fold can't be closed since its length (1) is now less than foldminlines.\nfunc Test_indent_one_line_fold_close()\n  let lines =<< trim END\n    line 1\n      line 2\n      line 3\n  END\n\n  new\n  setlocal sw=2 foldmethod=indent\n  call setline(1, lines)\n  \" open all folds, delete line, then close all folds\n  normal zR\n  3delete\n  normal zM\n  call assert_equal(-1, foldclosed(2)) \" the fold should not be closed\n\n  \" Now do the same, but delete line 2 this time; this covers different code.\n  \" (Combining this code with the above code doesn't expose both bugs.)\n  1,$delete\n  call setline(1, lines)\n  normal zR\n  2delete\n  normal zM\n  call assert_equal(-1, foldclosed(2))\n  bw!\nendfunc\n\n\" Make sure that when appending [an indented line then a blank line] right\n\" before a single indented line, the resulting extended fold can be closed\nfunc Test_indent_append_blank_small_fold_close()\n  new\n  setlocal sw=2 foldmethod=indent\n  \" at first, the fold at the second line can't be closed since it's smaller\n  \" than foldminlines\n  let lines =<< trim END\n    line 1\n      line 4\n  END\n  call setline(1, lines)\n  call append(1, ['  line 2', ''])\n  \" close all folds\n  normal zM\n  call assert_notequal(-1, foldclosed(2)) \" the fold should be closed now\n  bw!\nendfunc\n\nfunc Test_sort_closed_fold()\n  CheckExecutable sort\n\n  call setline(1, [\n        \\ 'Section 1',\n        \\ '   how',\n        \\ '   now',\n        \\ '   brown',\n        \\ '   cow',\n        \\ 'Section 2',\n        \\ '   how',\n        \\ '   now',\n        \\ '   brown',\n        \\ '   cow',\n        \\])\n  setlocal foldmethod=indent sw=3\n  normal 2G\n\n  \" The \"!!\" expands to \".,.+3\" and must only sort four lines\n  call feedkeys(\"!!sort\\<CR>\", 'xt')\n  call assert_equal([\n        \\ 'Section 1',\n        \\ '   brown',\n        \\ '   cow',\n        \\ '   how',\n        \\ '   now',\n        \\ 'Section 2',\n        \\ '   how',\n        \\ '   now',\n        \\ '   brown',\n        \\ '   cow',\n        \\ ], getline(1, 10))\n\n  bwipe!\nendfunc\n\nfunc Test_indent_with_L_command()\n  \" The \"L\" command moved the cursor to line zero, causing the text saved for\n  \" undo to use line number -1, which caused trouble for undo later.\n  new\n  sil! norm 8R\r\u0003V{zf8=Lu\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/normal.c", "src/testdir/test_fold.vim", "src/version.c"], "buggy_code_start_loc": [3732, 1677, 697], "buggy_code_end_loc": [3733, 1677, 697], "fixing_code_start_loc": [3732, 1678, 698], "fixing_code_end_loc": [3734, 1687, 700], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1189.", "other": {"cve": {"id": "CVE-2023-0288", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-13T16:15:08.900", "lastModified": "2023-03-28T05:15:13.117", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1189."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1189", "matchCriteriaId": "3B4D5E94-20F8-4C04-BECD-CA7C2F7B655A"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Mar/17", "source": "security@huntr.dev"}, {"url": "https://github.com/vim/vim/commit/232bdaaca98c34a99ffadf27bf6ee08be6cc8f6a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/550a0852-9be0-4abe-906c-f803b34e41d3", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WYC22GGZ6QA66HLNLHCTAJU265TT3O33/", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213670", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/232bdaaca98c34a99ffadf27bf6ee08be6cc8f6a"}}