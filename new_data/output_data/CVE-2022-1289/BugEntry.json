{"buggy_code": ["/**\n * Furnace Tracker - multi-system chiptune tracker\n * Copyright (C) 2021-2022 tildearrow and contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#define _USE_MATH_DEFINES\n#include \"gui.h\"\n#include \"../ta-log.h\"\n#include \"imgui_internal.h\"\n#include \"IconsFontAwesome4.h\"\n#include \"misc/cpp/imgui_stdlib.h\"\n#include \"guiConst.h\"\n#include <fmt/printf.h>\n\nconst FurnaceGUIColors fxColors[16]={\n  GUI_COLOR_PATTERN_EFFECT_MISC, // 00\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 01\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 02\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 03\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 04\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 05\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 06\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 07\n  GUI_COLOR_PATTERN_EFFECT_PANNING, // 08\n  GUI_COLOR_PATTERN_EFFECT_SPEED, // 09\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 0A\n  GUI_COLOR_PATTERN_EFFECT_SONG, // 0B\n  GUI_COLOR_PATTERN_EFFECT_TIME, // 0C\n  GUI_COLOR_PATTERN_EFFECT_SONG, // 0D\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // 0E\n  GUI_COLOR_PATTERN_EFFECT_SPEED, // 0F\n};\n\nconst FurnaceGUIColors extFxColors[32]={\n  GUI_COLOR_PATTERN_EFFECT_MISC, // E0\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // E1\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // E2\n  GUI_COLOR_PATTERN_EFFECT_MISC, // E3\n  GUI_COLOR_PATTERN_EFFECT_MISC, // E4\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // E5\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E6\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E7\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E8\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E9\n  GUI_COLOR_PATTERN_EFFECT_MISC, // EA\n  GUI_COLOR_PATTERN_EFFECT_MISC, // EB\n  GUI_COLOR_PATTERN_EFFECT_TIME, // EC\n  GUI_COLOR_PATTERN_EFFECT_TIME, // ED\n  GUI_COLOR_PATTERN_EFFECT_SONG, // EE\n  GUI_COLOR_PATTERN_EFFECT_SONG, // EF\n  GUI_COLOR_PATTERN_EFFECT_SPEED, // F0\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // F1\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // F2\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F3\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F4\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // F5\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // F6\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // F7\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F8\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F9\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // FA\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FB\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FC\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FD\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FE\n  GUI_COLOR_PATTERN_EFFECT_SONG, // FF\n};\n\ninline float randRange(float min, float max) {\n  return min+((float)rand()/(float)RAND_MAX)*(max-min);\n}\n\n// draw a pattern row\ninline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}\n\nvoid FurnaceGUI::drawPattern() {\n  //int delta0=SDL_GetPerformanceCounter();\n  if (nextWindow==GUI_WINDOW_PATTERN) {\n    patternOpen=true;\n    ImGui::SetNextWindowFocus();\n    nextWindow=GUI_WINDOW_NOTHING;\n  }\n  if (!patternOpen) return;\n\n  bool inhibitMenu=false;\n  float scrollX=0;\n\n  if (e->isPlaying() && followPattern) cursor.y=oldRow;\n  demandX=0;\n  sel1=selStart;\n  sel2=selEnd;\n  if (sel2.y<sel1.y) {\n    sel2.y^=sel1.y;\n    sel1.y^=sel2.y;\n    sel2.y^=sel1.y;\n  }\n  if (sel2.xCoarse<sel1.xCoarse) {\n    sel2.xCoarse^=sel1.xCoarse;\n    sel1.xCoarse^=sel2.xCoarse;\n    sel2.xCoarse^=sel1.xCoarse;\n\n    sel2.xFine^=sel1.xFine;\n    sel1.xFine^=sel2.xFine;\n    sel2.xFine^=sel1.xFine;\n  } else if (sel2.xCoarse==sel1.xCoarse && sel2.xFine<sel1.xFine) {\n    sel2.xFine^=sel1.xFine;\n    sel1.xFine^=sel2.xFine;\n    sel2.xFine^=sel1.xFine;\n  }\n  ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding,ImVec2(0.0f,0.0f));\n  if (ImGui::Begin(\"Pattern\",&patternOpen,settings.avoidRaisingPattern?ImGuiWindowFlags_NoBringToFrontOnFocus:0)) {\n    //ImGui::SetWindowSize(ImVec2(scrW*dpiScale,scrH*dpiScale));\n    patWindowPos=ImGui::GetWindowPos();\n    patWindowSize=ImGui::GetWindowSize();\n    //char id[32];\n    ImGui::PushFont(patFont);\n    int ord=e->isPlaying()?oldOrder:e->getOrder();\n    oldOrder=e->getOrder();\n    int chans=e->getTotalChannelCount();\n    int displayChans=0;\n    const DivPattern* patCache[DIV_MAX_CHANS];\n    for (int i=0; i<chans; i++) {\n      if (e->song.chanShow[i]) displayChans++;\n    }\n    ImGui::PushStyleVar(ImGuiStyleVar_CellPadding,ImVec2(0.0f,0.0f));\n    ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n    ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_SELECTION_HOVER]);\n    ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_SELECTION_ACTIVE]);\n    if (ImGui::BeginTable(\"PatternView\",displayChans+2,ImGuiTableFlags_BordersInnerV|ImGuiTableFlags_ScrollX|ImGuiTableFlags_ScrollY|ImGuiTableFlags_NoPadInnerX)) {\n      ImGui::TableSetupColumn(\"pos\",ImGuiTableColumnFlags_WidthFixed);\n      char chanID[2048];\n      float lineHeight=(ImGui::GetTextLineHeight()+2*dpiScale);\n      int curRow=e->getRow();\n      if (e->isPlaying() && followPattern) updateScroll(curRow);\n      if (nextScroll>-0.5f) {\n        ImGui::SetScrollY(nextScroll);\n        nextScroll=-1.0f;\n        nextAddScroll=0.0f;\n      }\n      if (nextAddScroll!=0.0f) {\n        ImGui::SetScrollY(ImGui::GetScrollY()+nextAddScroll);\n        nextScroll=-1.0f;\n        nextAddScroll=0.0f;\n      }\n      ImGui::TableSetupScrollFreeze(1,1);\n      for (int i=0; i<chans; i++) {\n        if (!e->song.chanShow[i]) continue;\n        ImGui::TableSetupColumn(fmt::sprintf(\"c%d\",i).c_str(),ImGuiTableColumnFlags_WidthFixed);\n      }\n      ImGui::TableNextRow();\n      ImGui::TableNextColumn();\n      if (ImGui::Selectable((extraChannelButtons==2)?\" --##ExtraChannelButtons\":\" ++##ExtraChannelButtons\",false,ImGuiSelectableFlags_NoPadWithHalfSpacing,ImVec2(0.0f,lineHeight+1.0f*dpiScale))) {\n        if (++extraChannelButtons>2) extraChannelButtons=0;\n      }\n      if (ImGui::IsItemHovered()) {\n        if (extraChannelButtons==2) {\n          ImGui::SetTooltip(\"Pattern names (click to collapse)\\nRight-click for visualizer\");\n        } else if (extraChannelButtons==1) {\n          ImGui::SetTooltip(\"Expanded (click for pattern names)\\nRight-click for visualizer\");\n        } else {\n          ImGui::SetTooltip(\"Compact (click to expand)\\nRight-click for visualizer\");\n        }\n      }\n      if (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n        fancyPattern=!fancyPattern;\n        inhibitMenu=true;\n        e->enableCommandStream(fancyPattern);\n        e->getCommandStream(cmdStream);\n        cmdStream.clear();\n      }\n      for (int i=0; i<chans; i++) {\n        if (!e->song.chanShow[i]) continue;\n        ImGui::TableNextColumn();\n        bool displayTooltip=false;\n        if (e->song.chanCollapse[i]) {\n          const char* chName=e->getChannelShortName(i);\n          if (strlen(chName)>3) {\n            snprintf(chanID,2048,\"...##_CH%d\",i);\n          } else {\n            snprintf(chanID,2048,\"%s##_CH%d\",chName,i);\n          }\n          displayTooltip=true;\n        } else {\n          const char* chName=e->getChannelName(i);\n          size_t chNameLimit=6+4*e->song.pat[i].effectRows;\n          if (strlen(chName)>chNameLimit) {\n            String shortChName=chName;\n            shortChName.resize(chNameLimit-3);\n            shortChName+=\"...\";\n            snprintf(chanID,2048,\" %s##_CH%d\",shortChName.c_str(),i);\n            displayTooltip=true;\n          } else {\n            snprintf(chanID,2048,\" %s##_CH%d\",chName,i);\n          }\n        }\n        bool muted=e->isChannelMuted(i);\n        ImVec4 chanHead=muted?uiColors[GUI_COLOR_CHANNEL_MUTED]:uiColors[GUI_COLOR_CHANNEL_FM+e->getChannelType(i)];\n        ImVec4 chanHeadActive=chanHead;\n        ImVec4 chanHeadHover=chanHead;\n        if (e->keyHit[i]) {\n          keyHit[i]=0.2;\n          e->keyHit[i]=false;\n        }\n        if (settings.guiColorsBase) {\n          chanHead.x*=1.0-keyHit[i]; chanHead.y*=1.0-keyHit[i]; chanHead.z*=1.0-keyHit[i];\n          chanHeadActive.x*=0.5; chanHeadActive.y*=0.5; chanHeadActive.z*=0.5;\n          chanHeadHover.x*=0.9-keyHit[i]; chanHeadHover.y*=0.9-keyHit[i]; chanHeadHover.z*=0.9-keyHit[i];\n        } else {\n          chanHead.x*=0.25+keyHit[i]; chanHead.y*=0.25+keyHit[i]; chanHead.z*=0.25+keyHit[i];\n          chanHeadActive.x*=0.8; chanHeadActive.y*=0.8; chanHeadActive.z*=0.8;\n          chanHeadHover.x*=0.4+keyHit[i]; chanHeadHover.y*=0.4+keyHit[i]; chanHeadHover.z*=0.4+keyHit[i];\n        }\n        keyHit[i]-=0.02*60.0*ImGui::GetIO().DeltaTime;\n        if (keyHit[i]<0) keyHit[i]=0;\n        ImGui::PushStyleColor(ImGuiCol_Header,chanHead);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,chanHeadActive);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,chanHeadHover);\n        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg,ImGui::GetColorU32(chanHead));\n        if (muted) ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_CHANNEL_MUTED]);\n        ImGui::Selectable(chanID,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,ImVec2(0.0f,lineHeight+1.0f*dpiScale));\n        if (displayTooltip && ImGui::IsItemHovered()) {\n          ImGui::SetTooltip(\"%s\",e->getChannelName(i));\n        }\n        if (ImGui::IsItemClicked(ImGuiMouseButton_Left)) {\n          if (settings.soloAction!=1 && soloTimeout>0 && soloChan==i) {\n            e->toggleSolo(i);\n            soloTimeout=0;\n          } else {\n            e->toggleMute(i);\n            soloTimeout=20;\n            soloChan=i;\n          }\n        }\n        if (muted) ImGui::PopStyleColor();\n        ImGui::PopStyleColor(3);\n        if (settings.soloAction!=2) if (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n          inhibitMenu=true;\n          e->toggleSolo(i);\n        }\n        if (extraChannelButtons==2) {\n          DivPattern* pat=e->song.pat[i].getPattern(e->song.orders.ord[i][ord],true);\n          ImGui::PushFont(mainFont);\n          if (patNameTarget==i) {\n            snprintf(chanID,2048,\"##PatNameI%d_%d\",i,ord);\n            ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x-(8.0f*dpiScale));\n            ImGui::SetCursorPosX(ImGui::GetCursorPosX()+4.0f*dpiScale);\n            ImGui::InputText(chanID,&pat->name);\n            if (wantPatName) {\n              wantPatName=false;\n              ImGui::SetItemDefaultFocus();\n              ImGui::SetKeyboardFocusHere(-1);\n            } else {\n              if (!ImGui::IsItemActive()) {\n                patNameTarget=-1;\n              }\n            }\n          } else {\n            snprintf(chanID,2048,\" %s##PatName%d\",pat->name.c_str(),i);\n            if (ImGui::Selectable(chanID,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,ImVec2(0.0f,lineHeight+1.0f*dpiScale))) {\n              patNameTarget=i;\n              wantPatName=true;\n              snprintf(chanID,2048,\"##PatNameI%d_%d\",i,ord);\n              ImGui::SetActiveID(ImGui::GetID(chanID),ImGui::GetCurrentWindow());\n            }\n          }\n          ImGui::PopFont();\n        } else if (extraChannelButtons==1) {\n          snprintf(chanID,2048,\"%c##_HCH%d\",e->song.chanCollapse[i]?'+':'-',i);\n          ImGui::SetCursorPosX(ImGui::GetCursorPosX()+4.0f*dpiScale);\n          if (ImGui::SmallButton(chanID)) {\n            e->song.chanCollapse[i]=!e->song.chanCollapse[i];\n          }\n          if (!e->song.chanCollapse[i]) {\n            ImGui::SameLine();\n            snprintf(chanID,2048,\"<##_LCH%d\",i);\n            ImGui::BeginDisabled(e->song.pat[i].effectRows<=1);\n            if (ImGui::SmallButton(chanID)) {\n              e->song.pat[i].effectRows--;\n              if (e->song.pat[i].effectRows<1) e->song.pat[i].effectRows=1;\n            }\n            ImGui::EndDisabled();\n            ImGui::SameLine();\n            ImGui::BeginDisabled(e->song.pat[i].effectRows>=8);\n            snprintf(chanID,2048,\">##_RCH%d\",i);\n            if (ImGui::SmallButton(chanID)) {\n              e->song.pat[i].effectRows++;\n              if (e->song.pat[i].effectRows>8) e->song.pat[i].effectRows=8;\n            }\n            ImGui::EndDisabled();\n          }\n          ImGui::Spacing();\n        }\n      }\n      ImGui::TableNextColumn();\n      if (e->hasExtValue()) {\n        ImGui::TextColored(uiColors[GUI_COLOR_EE_VALUE],\" %.2X\",e->getExtValue());\n      }\n      float oneCharSize=ImGui::CalcTextSize(\"A\").x;\n      threeChars=ImVec2(oneCharSize*3.0f,lineHeight);\n      twoChars=ImVec2(oneCharSize*2.0f,lineHeight);\n      //ImVec2 oneChar=ImVec2(oneCharSize,lineHeight);\n      dummyRows=(ImGui::GetWindowSize().y/lineHeight)/2;\n      // \u30aa\u30c3\u30d7\u30ca\u30fc2608 i owe you one more for this horrible code\n      // previous pattern\n      ImGui::BeginDisabled();\n      if (settings.viewPrevPattern) {\n        if ((ord-1)>=0) for (int i=0; i<chans; i++) {\n          patCache[i]=e->song.pat[i].getPattern(e->song.orders.ord[i][ord-1],true);\n        }\n        for (int i=0; i<dummyRows-1; i++) {\n          patternRow(e->song.patLen+i-dummyRows+1,e->isPlaying(),lineHeight,chans,ord-1,patCache);\n        }\n      } else {\n        for (int i=0; i<dummyRows-1; i++) {\n          ImGui::TableNextRow(0,lineHeight);\n          ImGui::TableNextColumn();\n        }\n      }\n      ImGui::EndDisabled();\n      // active area\n      for (int i=0; i<chans; i++) {\n        patCache[i]=e->song.pat[i].getPattern(e->song.orders.ord[i][ord],true);\n      }\n      for (int i=0; i<e->song.patLen; i++) {\n        patternRow(i,e->isPlaying(),lineHeight,chans,ord,patCache);\n      }\n      // next pattern\n      ImGui::BeginDisabled();\n      if (settings.viewPrevPattern) {\n        if ((ord+1)<e->song.ordersLen) for (int i=0; i<chans; i++) {\n          patCache[i]=e->song.pat[i].getPattern(e->song.orders.ord[i][ord+1],true);\n        }\n        for (int i=0; i<=dummyRows; i++) {\n          patternRow(i,e->isPlaying(),lineHeight,chans,ord+1,patCache);\n        }\n      } else {\n        for (int i=0; i<=dummyRows; i++) {\n          ImGui::TableNextRow(0,lineHeight);\n          ImGui::TableNextColumn();\n        }\n      }\n      ImGui::EndDisabled();\n      oldRow=curRow;\n      if (demandScrollX) {\n        int totalDemand=demandX-ImGui::GetScrollX();\n        if (totalDemand<80) {\n          ImGui::SetScrollX(demandX-200*dpiScale);\n        } else if (totalDemand>(ImGui::GetWindowWidth()-200*dpiScale)) {\n          ImGui::SetScrollX(demandX+200*dpiScale);\n        }\n        demandScrollX=false;\n      }\n      scrollX=ImGui::GetScrollX();\n      ImGui::EndTable();\n    }\n\n    if (fancyPattern) { // visualizer\n      e->getCommandStream(cmdStream);\n      ImDrawList* dl=ImGui::GetWindowDrawList();\n      ImVec2 off=ImGui::GetWindowPos();\n      \n      // commands\n      for (DivCommand& i: cmdStream) {\n        if (i.cmd==DIV_CMD_PITCH) continue;\n        if (i.cmd==DIV_CMD_NOTE_PORTA) continue;\n        //if (i.cmd==DIV_CMD_NOTE_ON) continue;\n        if (i.cmd==DIV_CMD_PRE_PORTA) continue;\n        if (i.cmd==DIV_CMD_PRE_NOTE) continue;\n        if (i.cmd==DIV_CMD_SAMPLE_BANK) continue;\n        if (i.cmd==DIV_CMD_GET_VOLUME) continue;\n        if (i.cmd==DIV_ALWAYS_SET_VOLUME) continue;\n\n        float width=patChanX[i.chan+1]-patChanX[i.chan];\n        float speedX=0.0f;\n        float speedY=-18.0f;\n        float grav=0.6f;\n        float frict=1.0f;\n        float life=255.0f;\n        float lifeSpeed=8.0f;\n        float spread=5.0f;\n        int num=3;\n        const char* partIcon=ICON_FA_MICROCHIP;\n        ImU32* color=noteGrad;\n\n        switch (i.cmd) {\n          case DIV_CMD_NOTE_ON:\n            partIcon=ICON_FA_ASTERISK;\n            life=96.0f;\n            lifeSpeed=3.0f;\n            break;\n          case DIV_CMD_LEGATO:\n            partIcon=ICON_FA_COG;\n            color=insGrad;\n            life=64.0f;\n            lifeSpeed=2.0f;\n            break;\n          case DIV_CMD_NOTE_OFF:\n          case DIV_CMD_NOTE_OFF_ENV:\n          case DIV_CMD_ENV_RELEASE:\n            partIcon=ICON_FA_ASTERISK;\n            speedX=0.0f;\n            speedY=0.0f;\n            grav=0.0f;\n            life=24.0f;\n            lifeSpeed=4.0f;\n            break;\n          case DIV_CMD_VOLUME: {\n            float scaledVol=(float)i.value/(float)e->getMaxVolumeChan(i.chan);\n            if (scaledVol>1.0f) scaledVol=1.0f;\n            speedY=-18.0f-(10.0f*scaledVol);\n            life=128+scaledVol*127;\n            partIcon=ICON_FA_VOLUME_UP;\n            num=12.0f*pow(scaledVol,2.0);\n            color=volGrad;\n            break;\n          }\n          case DIV_CMD_INSTRUMENT: {\n            if (lastIns[i.chan]==i.value) {\n              num=0;\n              break;\n            }\n            lastIns[i.chan]=i.value;\n            speedX=0.0f;\n            speedY=0.0f;\n            grav=0.0f;\n            frict=0.98;\n            spread=30.0f;\n            life=128.0f;\n            lifeSpeed=6.0f;\n            color=insGrad;\n            num=7+pow(i.value,0.6);\n            break;\n          }\n          case DIV_CMD_PANNING: {\n            if (i.value==0) {\n              num=0;\n              break;\n            }\n            float ratio=float(((i.value>>4)&15)-(i.value&15))/MAX(((i.value>>4)&15),(i.value&15));\n            speedX=-22.0f*sin(ratio*M_PI*0.5);\n            speedY=-22.0f*cos(ratio*M_PI*0.5);\n            spread=5.0f+fabs(sin(ratio*M_PI*0.5))*7.0f;\n            grav=0.0f;\n            frict=0.96f;\n            if (((i.value>>4)&15)==(i.value&15)) {\n              partIcon=ICON_FA_ARROWS_H;\n            } else if (ratio>0) {\n              partIcon=ICON_FA_ARROW_LEFT;\n            } else {\n              partIcon=ICON_FA_ARROW_RIGHT;\n            }\n            num=9;\n            color=panGrad;\n            break;\n          }\n          case DIV_CMD_SAMPLE_FREQ:\n            speedX=0.0f;\n            speedY=0.0f;\n            grav=0.0f;\n            frict=0.98;\n            spread=19.0f;\n            life=128.0f;\n            lifeSpeed=3.0f;\n            color=sysCmd2Grad;\n            num=10+pow(i.value,0.6);\n            break;\n          default:\n            //printf(\"unhandled %d\\n\",i.cmd);\n            color=sysCmd1Grad;\n            break;\n        }\n\n        for (int j=0; j<num; j++) {\n          particles.push_back(Particle(\n            color,\n            partIcon,\n            off.x+patChanX[i.chan]+fmod(rand(),width)-scrollX,\n            off.y+(ImGui::GetWindowHeight()*0.5f)+randRange(0,patFont->FontSize),\n            (speedX+randRange(-spread,spread))*0.5*dpiScale,\n            (speedY+randRange(-spread,spread))*0.5*dpiScale,\n            grav,\n            frict,\n            life-randRange(0,8),\n            lifeSpeed\n          ));\n        }\n      }\n\n      float frameTime=ImGui::GetIO().DeltaTime*60.0f;\n\n      // note slides\n      ImVec2 arrowPoints[7];\n      if (e->isPlaying()) for (int i=0; i<chans; i++) {\n        if (!e->song.chanShow[i]) continue;\n        DivChannelState* ch=e->getChanState(i);\n        if (ch->portaSpeed>0) {\n          ImVec4 col=uiColors[GUI_COLOR_PATTERN_EFFECT_PITCH];\n          col.w*=0.2;\n          float width=patChanX[i+1]-patChanX[i];\n\n          particles.push_back(Particle(\n            pitchGrad,\n            (ch->portaNote<=ch->note)?ICON_FA_CHEVRON_DOWN:ICON_FA_CHEVRON_UP,\n            off.x+patChanX[i]+fmod(rand(),width)-scrollX,\n            off.y+fmod(rand(),MAX(1,ImGui::GetWindowHeight())),\n            0.0f,\n            (7.0f+(rand()%5)+pow(ch->portaSpeed,0.7f))*((ch->portaNote<=ch->note)?1:-1),\n            0.0f,\n            1.0f,\n            255.0f,\n            15.0f\n          ));\n\n          if (width>0.1) for (float j=-patChanSlideY[i]; j<ImGui::GetWindowHeight(); j+=width*0.7) {\n            ImVec2 tMin=ImVec2(off.x+patChanX[i]-scrollX,off.y+j);\n            ImVec2 tMax=ImVec2(off.x+patChanX[i+1]-scrollX,off.y+j+width*0.6);\n            if (ch->portaNote<=ch->note) {\n              arrowPoints[0]=ImLerp(tMin,tMax,ImVec2(0.1,1.0-0.8));\n              arrowPoints[1]=ImLerp(tMin,tMax,ImVec2(0.5,1.0-0.0));\n              arrowPoints[2]=ImLerp(tMin,tMax,ImVec2(0.9,1.0-0.8));\n              arrowPoints[3]=ImLerp(tMin,tMax,ImVec2(0.8,1.0-1.0));\n              arrowPoints[4]=ImLerp(tMin,tMax,ImVec2(0.5,1.0-0.37));\n              arrowPoints[5]=ImLerp(tMin,tMax,ImVec2(0.2,1.0-1.0));\n              arrowPoints[6]=arrowPoints[0];\n              dl->AddPolyline(arrowPoints,7,ImGui::GetColorU32(col),ImDrawFlags_None,5.0f*dpiScale);\n            } else {\n              arrowPoints[0]=ImLerp(tMin,tMax,ImVec2(0.1,0.8));\n              arrowPoints[1]=ImLerp(tMin,tMax,ImVec2(0.5,0.0));\n              arrowPoints[2]=ImLerp(tMin,tMax,ImVec2(0.9,0.8));\n              arrowPoints[3]=ImLerp(tMin,tMax,ImVec2(0.8,1.0));\n              arrowPoints[4]=ImLerp(tMin,tMax,ImVec2(0.5,0.37));\n              arrowPoints[5]=ImLerp(tMin,tMax,ImVec2(0.2,1.0));\n              arrowPoints[6]=arrowPoints[0];\n              dl->AddPolyline(arrowPoints,7,ImGui::GetColorU32(col),ImDrawFlags_None,5.0f*dpiScale);\n            }\n          }\n          patChanSlideY[i]+=((ch->portaNote<=ch->note)?-8:8)*dpiScale*frameTime;\n          if (width>0) {\n            if (patChanSlideY[i]<0) {\n              patChanSlideY[i]=-fmod(-patChanSlideY[i],width*0.7);\n            } else {\n              patChanSlideY[i]=fmod(patChanSlideY[i],width*0.7);\n            }\n          }\n        }\n      }\n\n      // particle simulation\n      ImDrawList* fdl=ImGui::GetForegroundDrawList();\n      for (size_t i=0; i<particles.size(); i++) {\n        Particle& part=particles[i];\n        if (part.update(frameTime)) {\n          if (part.life>255) part.life=255;\n          fdl->AddText(\n            iconFont,\n            iconFont->FontSize,\n            ImVec2(part.pos.x-iconFont->FontSize*0.5,part.pos.y-iconFont->FontSize*0.5),\n            part.colors[(int)part.life],\n            part.type\n          );\n        } else {\n          particles.erase(particles.begin()+i);\n          i--;\n        }\n      }\n    }\n\n    ImGui::PopStyleColor(3);\n    ImGui::PopStyleVar();\n    ImGui::PopFont();\n  }\n  ImGui::PopStyleVar();\n  if (patternOpen) {\n    if (!inhibitMenu && ImGui::IsItemClicked(ImGuiMouseButton_Right)) ImGui::OpenPopup(\"patternActionMenu\");\n    if (ImGui::BeginPopup(\"patternActionMenu\",ImGuiWindowFlags_NoMove|ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings)) {\n      editOptions(false);\n      ImGui::EndPopup();\n    }\n  }\n  if (ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows)) curWindow=GUI_WINDOW_PATTERN;\n  ImGui::End();\n  //int delta1=SDL_GetPerformanceCounter();\n  //logV(\"render time: %d\u00b5s\\n\",(delta1-delta0)/(SDL_GetPerformanceFrequency()/1000000));\n}\n\n"], "fixing_code": ["/**\n * Furnace Tracker - multi-system chiptune tracker\n * Copyright (C) 2021-2022 tildearrow and contributors\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#define _USE_MATH_DEFINES\n#include \"gui.h\"\n#include \"../ta-log.h\"\n#include \"imgui_internal.h\"\n#include \"IconsFontAwesome4.h\"\n#include \"misc/cpp/imgui_stdlib.h\"\n#include \"guiConst.h\"\n#include <fmt/printf.h>\n\nconst FurnaceGUIColors fxColors[16]={\n  GUI_COLOR_PATTERN_EFFECT_MISC, // 00\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 01\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 02\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 03\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // 04\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 05\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 06\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 07\n  GUI_COLOR_PATTERN_EFFECT_PANNING, // 08\n  GUI_COLOR_PATTERN_EFFECT_SPEED, // 09\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // 0A\n  GUI_COLOR_PATTERN_EFFECT_SONG, // 0B\n  GUI_COLOR_PATTERN_EFFECT_TIME, // 0C\n  GUI_COLOR_PATTERN_EFFECT_SONG, // 0D\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // 0E\n  GUI_COLOR_PATTERN_EFFECT_SPEED, // 0F\n};\n\nconst FurnaceGUIColors extFxColors[32]={\n  GUI_COLOR_PATTERN_EFFECT_MISC, // E0\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // E1\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // E2\n  GUI_COLOR_PATTERN_EFFECT_MISC, // E3\n  GUI_COLOR_PATTERN_EFFECT_MISC, // E4\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // E5\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E6\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E7\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E8\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // E9\n  GUI_COLOR_PATTERN_EFFECT_MISC, // EA\n  GUI_COLOR_PATTERN_EFFECT_MISC, // EB\n  GUI_COLOR_PATTERN_EFFECT_TIME, // EC\n  GUI_COLOR_PATTERN_EFFECT_TIME, // ED\n  GUI_COLOR_PATTERN_EFFECT_SONG, // EE\n  GUI_COLOR_PATTERN_EFFECT_SONG, // EF\n  GUI_COLOR_PATTERN_EFFECT_SPEED, // F0\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // F1\n  GUI_COLOR_PATTERN_EFFECT_PITCH, // F2\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F3\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F4\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // F5\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // F6\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // F7\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F8\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // F9\n  GUI_COLOR_PATTERN_EFFECT_VOLUME, // FA\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FB\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FC\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FD\n  GUI_COLOR_PATTERN_EFFECT_INVALID, // FE\n  GUI_COLOR_PATTERN_EFFECT_SONG, // FF\n};\n\ninline float randRange(float min, float max) {\n  return min+((float)rand()/(float)RAND_MAX)*(max-min);\n}\n\n// draw a pattern row\ninline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}\n\nvoid FurnaceGUI::drawPattern() {\n  //int delta0=SDL_GetPerformanceCounter();\n  if (nextWindow==GUI_WINDOW_PATTERN) {\n    patternOpen=true;\n    ImGui::SetNextWindowFocus();\n    nextWindow=GUI_WINDOW_NOTHING;\n  }\n  if (!patternOpen) return;\n\n  bool inhibitMenu=false;\n  float scrollX=0;\n\n  if (e->isPlaying() && followPattern) cursor.y=oldRow;\n  demandX=0;\n  sel1=selStart;\n  sel2=selEnd;\n  if (sel2.y<sel1.y) {\n    sel2.y^=sel1.y;\n    sel1.y^=sel2.y;\n    sel2.y^=sel1.y;\n  }\n  if (sel2.xCoarse<sel1.xCoarse) {\n    sel2.xCoarse^=sel1.xCoarse;\n    sel1.xCoarse^=sel2.xCoarse;\n    sel2.xCoarse^=sel1.xCoarse;\n\n    sel2.xFine^=sel1.xFine;\n    sel1.xFine^=sel2.xFine;\n    sel2.xFine^=sel1.xFine;\n  } else if (sel2.xCoarse==sel1.xCoarse && sel2.xFine<sel1.xFine) {\n    sel2.xFine^=sel1.xFine;\n    sel1.xFine^=sel2.xFine;\n    sel2.xFine^=sel1.xFine;\n  }\n  ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding,ImVec2(0.0f,0.0f));\n  if (ImGui::Begin(\"Pattern\",&patternOpen,settings.avoidRaisingPattern?ImGuiWindowFlags_NoBringToFrontOnFocus:0)) {\n    //ImGui::SetWindowSize(ImVec2(scrW*dpiScale,scrH*dpiScale));\n    patWindowPos=ImGui::GetWindowPos();\n    patWindowSize=ImGui::GetWindowSize();\n    //char id[32];\n    ImGui::PushFont(patFont);\n    int ord=e->isPlaying()?oldOrder:e->getOrder();\n    oldOrder=e->getOrder();\n    int chans=e->getTotalChannelCount();\n    int displayChans=0;\n    const DivPattern* patCache[DIV_MAX_CHANS];\n    for (int i=0; i<chans; i++) {\n      if (e->song.chanShow[i]) displayChans++;\n    }\n    ImGui::PushStyleVar(ImGuiStyleVar_CellPadding,ImVec2(0.0f,0.0f));\n    ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n    ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_SELECTION_HOVER]);\n    ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_SELECTION_ACTIVE]);\n    if (ImGui::BeginTable(\"PatternView\",displayChans+2,ImGuiTableFlags_BordersInnerV|ImGuiTableFlags_ScrollX|ImGuiTableFlags_ScrollY|ImGuiTableFlags_NoPadInnerX)) {\n      ImGui::TableSetupColumn(\"pos\",ImGuiTableColumnFlags_WidthFixed);\n      char chanID[2048];\n      float lineHeight=(ImGui::GetTextLineHeight()+2*dpiScale);\n      int curRow=e->getRow();\n      if (e->isPlaying() && followPattern) updateScroll(curRow);\n      if (nextScroll>-0.5f) {\n        ImGui::SetScrollY(nextScroll);\n        nextScroll=-1.0f;\n        nextAddScroll=0.0f;\n      }\n      if (nextAddScroll!=0.0f) {\n        ImGui::SetScrollY(ImGui::GetScrollY()+nextAddScroll);\n        nextScroll=-1.0f;\n        nextAddScroll=0.0f;\n      }\n      ImGui::TableSetupScrollFreeze(1,1);\n      for (int i=0; i<chans; i++) {\n        if (!e->song.chanShow[i]) continue;\n        ImGui::TableSetupColumn(fmt::sprintf(\"c%d\",i).c_str(),ImGuiTableColumnFlags_WidthFixed);\n      }\n      ImGui::TableNextRow();\n      ImGui::TableNextColumn();\n      if (ImGui::Selectable((extraChannelButtons==2)?\" --##ExtraChannelButtons\":\" ++##ExtraChannelButtons\",false,ImGuiSelectableFlags_NoPadWithHalfSpacing,ImVec2(0.0f,lineHeight+1.0f*dpiScale))) {\n        if (++extraChannelButtons>2) extraChannelButtons=0;\n      }\n      if (ImGui::IsItemHovered()) {\n        if (extraChannelButtons==2) {\n          ImGui::SetTooltip(\"Pattern names (click to collapse)\\nRight-click for visualizer\");\n        } else if (extraChannelButtons==1) {\n          ImGui::SetTooltip(\"Expanded (click for pattern names)\\nRight-click for visualizer\");\n        } else {\n          ImGui::SetTooltip(\"Compact (click to expand)\\nRight-click for visualizer\");\n        }\n      }\n      if (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n        fancyPattern=!fancyPattern;\n        inhibitMenu=true;\n        e->enableCommandStream(fancyPattern);\n        e->getCommandStream(cmdStream);\n        cmdStream.clear();\n      }\n      for (int i=0; i<chans; i++) {\n        if (!e->song.chanShow[i]) continue;\n        ImGui::TableNextColumn();\n        bool displayTooltip=false;\n        if (e->song.chanCollapse[i]) {\n          const char* chName=e->getChannelShortName(i);\n          if (strlen(chName)>3) {\n            snprintf(chanID,2048,\"...##_CH%d\",i);\n          } else {\n            snprintf(chanID,2048,\"%s##_CH%d\",chName,i);\n          }\n          displayTooltip=true;\n        } else {\n          const char* chName=e->getChannelName(i);\n          size_t chNameLimit=6+4*e->song.pat[i].effectRows;\n          if (strlen(chName)>chNameLimit) {\n            String shortChName=chName;\n            shortChName.resize(chNameLimit-3);\n            shortChName+=\"...\";\n            snprintf(chanID,2048,\" %s##_CH%d\",shortChName.c_str(),i);\n            displayTooltip=true;\n          } else {\n            snprintf(chanID,2048,\" %s##_CH%d\",chName,i);\n          }\n        }\n        bool muted=e->isChannelMuted(i);\n        ImVec4 chanHead=muted?uiColors[GUI_COLOR_CHANNEL_MUTED]:uiColors[GUI_COLOR_CHANNEL_FM+e->getChannelType(i)];\n        ImVec4 chanHeadActive=chanHead;\n        ImVec4 chanHeadHover=chanHead;\n        if (e->keyHit[i]) {\n          keyHit[i]=0.2;\n          e->keyHit[i]=false;\n        }\n        if (settings.guiColorsBase) {\n          chanHead.x*=1.0-keyHit[i]; chanHead.y*=1.0-keyHit[i]; chanHead.z*=1.0-keyHit[i];\n          chanHeadActive.x*=0.5; chanHeadActive.y*=0.5; chanHeadActive.z*=0.5;\n          chanHeadHover.x*=0.9-keyHit[i]; chanHeadHover.y*=0.9-keyHit[i]; chanHeadHover.z*=0.9-keyHit[i];\n        } else {\n          chanHead.x*=0.25+keyHit[i]; chanHead.y*=0.25+keyHit[i]; chanHead.z*=0.25+keyHit[i];\n          chanHeadActive.x*=0.8; chanHeadActive.y*=0.8; chanHeadActive.z*=0.8;\n          chanHeadHover.x*=0.4+keyHit[i]; chanHeadHover.y*=0.4+keyHit[i]; chanHeadHover.z*=0.4+keyHit[i];\n        }\n        keyHit[i]-=0.02*60.0*ImGui::GetIO().DeltaTime;\n        if (keyHit[i]<0) keyHit[i]=0;\n        ImGui::PushStyleColor(ImGuiCol_Header,chanHead);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,chanHeadActive);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,chanHeadHover);\n        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg,ImGui::GetColorU32(chanHead));\n        if (muted) ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_CHANNEL_MUTED]);\n        ImGui::Selectable(chanID,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,ImVec2(0.0f,lineHeight+1.0f*dpiScale));\n        if (displayTooltip && ImGui::IsItemHovered()) {\n          ImGui::SetTooltip(\"%s\",e->getChannelName(i));\n        }\n        if (ImGui::IsItemClicked(ImGuiMouseButton_Left)) {\n          if (settings.soloAction!=1 && soloTimeout>0 && soloChan==i) {\n            e->toggleSolo(i);\n            soloTimeout=0;\n          } else {\n            e->toggleMute(i);\n            soloTimeout=20;\n            soloChan=i;\n          }\n        }\n        if (muted) ImGui::PopStyleColor();\n        ImGui::PopStyleColor(3);\n        if (settings.soloAction!=2) if (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n          inhibitMenu=true;\n          e->toggleSolo(i);\n        }\n        if (extraChannelButtons==2) {\n          DivPattern* pat=e->song.pat[i].getPattern(e->song.orders.ord[i][ord],true);\n          ImGui::PushFont(mainFont);\n          if (patNameTarget==i) {\n            snprintf(chanID,2048,\"##PatNameI%d_%d\",i,ord);\n            ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x-(8.0f*dpiScale));\n            ImGui::SetCursorPosX(ImGui::GetCursorPosX()+4.0f*dpiScale);\n            ImGui::InputText(chanID,&pat->name);\n            if (wantPatName) {\n              wantPatName=false;\n              ImGui::SetItemDefaultFocus();\n              ImGui::SetKeyboardFocusHere(-1);\n            } else {\n              if (!ImGui::IsItemActive()) {\n                patNameTarget=-1;\n              }\n            }\n          } else {\n            snprintf(chanID,2048,\" %s##PatName%d\",pat->name.c_str(),i);\n            if (ImGui::Selectable(chanID,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,ImVec2(0.0f,lineHeight+1.0f*dpiScale))) {\n              patNameTarget=i;\n              wantPatName=true;\n              snprintf(chanID,2048,\"##PatNameI%d_%d\",i,ord);\n              ImGui::SetActiveID(ImGui::GetID(chanID),ImGui::GetCurrentWindow());\n            }\n          }\n          ImGui::PopFont();\n        } else if (extraChannelButtons==1) {\n          snprintf(chanID,2048,\"%c##_HCH%d\",e->song.chanCollapse[i]?'+':'-',i);\n          ImGui::SetCursorPosX(ImGui::GetCursorPosX()+4.0f*dpiScale);\n          if (ImGui::SmallButton(chanID)) {\n            e->song.chanCollapse[i]=!e->song.chanCollapse[i];\n          }\n          if (!e->song.chanCollapse[i]) {\n            ImGui::SameLine();\n            snprintf(chanID,2048,\"<##_LCH%d\",i);\n            ImGui::BeginDisabled(e->song.pat[i].effectRows<=1);\n            if (ImGui::SmallButton(chanID)) {\n              e->song.pat[i].effectRows--;\n              if (e->song.pat[i].effectRows<1) e->song.pat[i].effectRows=1;\n            }\n            ImGui::EndDisabled();\n            ImGui::SameLine();\n            ImGui::BeginDisabled(e->song.pat[i].effectRows>=8);\n            snprintf(chanID,2048,\">##_RCH%d\",i);\n            if (ImGui::SmallButton(chanID)) {\n              e->song.pat[i].effectRows++;\n              if (e->song.pat[i].effectRows>8) e->song.pat[i].effectRows=8;\n            }\n            ImGui::EndDisabled();\n          }\n          ImGui::Spacing();\n        }\n      }\n      ImGui::TableNextColumn();\n      if (e->hasExtValue()) {\n        ImGui::TextColored(uiColors[GUI_COLOR_EE_VALUE],\" %.2X\",e->getExtValue());\n      }\n      float oneCharSize=ImGui::CalcTextSize(\"A\").x;\n      threeChars=ImVec2(oneCharSize*3.0f,lineHeight);\n      twoChars=ImVec2(oneCharSize*2.0f,lineHeight);\n      //ImVec2 oneChar=ImVec2(oneCharSize,lineHeight);\n      dummyRows=(ImGui::GetWindowSize().y/lineHeight)/2;\n      // \u30aa\u30c3\u30d7\u30ca\u30fc2608 i owe you one more for this horrible code\n      // previous pattern\n      ImGui::BeginDisabled();\n      if (settings.viewPrevPattern) {\n        if ((ord-1)>=0) for (int i=0; i<chans; i++) {\n          patCache[i]=e->song.pat[i].getPattern(e->song.orders.ord[i][ord-1],true);\n        }\n        for (int i=0; i<dummyRows-1; i++) {\n          patternRow(e->song.patLen+i-dummyRows+1,e->isPlaying(),lineHeight,chans,ord-1,patCache);\n        }\n      } else {\n        for (int i=0; i<dummyRows-1; i++) {\n          ImGui::TableNextRow(0,lineHeight);\n          ImGui::TableNextColumn();\n        }\n      }\n      ImGui::EndDisabled();\n      // active area\n      for (int i=0; i<chans; i++) {\n        patCache[i]=e->song.pat[i].getPattern(e->song.orders.ord[i][ord],true);\n      }\n      for (int i=0; i<e->song.patLen; i++) {\n        patternRow(i,e->isPlaying(),lineHeight,chans,ord,patCache);\n      }\n      // next pattern\n      ImGui::BeginDisabled();\n      if (settings.viewPrevPattern) {\n        if ((ord+1)<e->song.ordersLen) for (int i=0; i<chans; i++) {\n          patCache[i]=e->song.pat[i].getPattern(e->song.orders.ord[i][ord+1],true);\n        }\n        for (int i=0; i<=dummyRows; i++) {\n          patternRow(i,e->isPlaying(),lineHeight,chans,ord+1,patCache);\n        }\n      } else {\n        for (int i=0; i<=dummyRows; i++) {\n          ImGui::TableNextRow(0,lineHeight);\n          ImGui::TableNextColumn();\n        }\n      }\n      ImGui::EndDisabled();\n      oldRow=curRow;\n      if (demandScrollX) {\n        int totalDemand=demandX-ImGui::GetScrollX();\n        if (totalDemand<80) {\n          ImGui::SetScrollX(demandX-200*dpiScale);\n        } else if (totalDemand>(ImGui::GetWindowWidth()-200*dpiScale)) {\n          ImGui::SetScrollX(demandX+200*dpiScale);\n        }\n        demandScrollX=false;\n      }\n      scrollX=ImGui::GetScrollX();\n      ImGui::EndTable();\n    }\n\n    if (fancyPattern) { // visualizer\n      e->getCommandStream(cmdStream);\n      ImDrawList* dl=ImGui::GetWindowDrawList();\n      ImVec2 off=ImGui::GetWindowPos();\n      \n      // commands\n      for (DivCommand& i: cmdStream) {\n        if (i.cmd==DIV_CMD_PITCH) continue;\n        if (i.cmd==DIV_CMD_NOTE_PORTA) continue;\n        //if (i.cmd==DIV_CMD_NOTE_ON) continue;\n        if (i.cmd==DIV_CMD_PRE_PORTA) continue;\n        if (i.cmd==DIV_CMD_PRE_NOTE) continue;\n        if (i.cmd==DIV_CMD_SAMPLE_BANK) continue;\n        if (i.cmd==DIV_CMD_GET_VOLUME) continue;\n        if (i.cmd==DIV_ALWAYS_SET_VOLUME) continue;\n\n        float width=patChanX[i.chan+1]-patChanX[i.chan];\n        float speedX=0.0f;\n        float speedY=-18.0f;\n        float grav=0.6f;\n        float frict=1.0f;\n        float life=255.0f;\n        float lifeSpeed=8.0f;\n        float spread=5.0f;\n        int num=3;\n        const char* partIcon=ICON_FA_MICROCHIP;\n        ImU32* color=noteGrad;\n\n        switch (i.cmd) {\n          case DIV_CMD_NOTE_ON:\n            partIcon=ICON_FA_ASTERISK;\n            life=96.0f;\n            lifeSpeed=3.0f;\n            break;\n          case DIV_CMD_LEGATO:\n            partIcon=ICON_FA_COG;\n            color=insGrad;\n            life=64.0f;\n            lifeSpeed=2.0f;\n            break;\n          case DIV_CMD_NOTE_OFF:\n          case DIV_CMD_NOTE_OFF_ENV:\n          case DIV_CMD_ENV_RELEASE:\n            partIcon=ICON_FA_ASTERISK;\n            speedX=0.0f;\n            speedY=0.0f;\n            grav=0.0f;\n            life=24.0f;\n            lifeSpeed=4.0f;\n            break;\n          case DIV_CMD_VOLUME: {\n            float scaledVol=(float)i.value/(float)e->getMaxVolumeChan(i.chan);\n            if (scaledVol>1.0f) scaledVol=1.0f;\n            speedY=-18.0f-(10.0f*scaledVol);\n            life=128+scaledVol*127;\n            partIcon=ICON_FA_VOLUME_UP;\n            num=12.0f*pow(scaledVol,2.0);\n            color=volGrad;\n            break;\n          }\n          case DIV_CMD_INSTRUMENT: {\n            if (lastIns[i.chan]==i.value) {\n              num=0;\n              break;\n            }\n            lastIns[i.chan]=i.value;\n            speedX=0.0f;\n            speedY=0.0f;\n            grav=0.0f;\n            frict=0.98;\n            spread=30.0f;\n            life=128.0f;\n            lifeSpeed=6.0f;\n            color=insGrad;\n            num=7+pow(i.value,0.6);\n            break;\n          }\n          case DIV_CMD_PANNING: {\n            if (i.value==0) {\n              num=0;\n              break;\n            }\n            float ratio=float(((i.value>>4)&15)-(i.value&15))/MAX(((i.value>>4)&15),(i.value&15));\n            speedX=-22.0f*sin(ratio*M_PI*0.5);\n            speedY=-22.0f*cos(ratio*M_PI*0.5);\n            spread=5.0f+fabs(sin(ratio*M_PI*0.5))*7.0f;\n            grav=0.0f;\n            frict=0.96f;\n            if (((i.value>>4)&15)==(i.value&15)) {\n              partIcon=ICON_FA_ARROWS_H;\n            } else if (ratio>0) {\n              partIcon=ICON_FA_ARROW_LEFT;\n            } else {\n              partIcon=ICON_FA_ARROW_RIGHT;\n            }\n            num=9;\n            color=panGrad;\n            break;\n          }\n          case DIV_CMD_SAMPLE_FREQ:\n            speedX=0.0f;\n            speedY=0.0f;\n            grav=0.0f;\n            frict=0.98;\n            spread=19.0f;\n            life=128.0f;\n            lifeSpeed=3.0f;\n            color=sysCmd2Grad;\n            num=10+pow(i.value,0.6);\n            break;\n          default:\n            //printf(\"unhandled %d\\n\",i.cmd);\n            color=sysCmd1Grad;\n            break;\n        }\n\n        for (int j=0; j<num; j++) {\n          particles.push_back(Particle(\n            color,\n            partIcon,\n            off.x+patChanX[i.chan]+fmod(rand(),width)-scrollX,\n            off.y+(ImGui::GetWindowHeight()*0.5f)+randRange(0,patFont->FontSize),\n            (speedX+randRange(-spread,spread))*0.5*dpiScale,\n            (speedY+randRange(-spread,spread))*0.5*dpiScale,\n            grav,\n            frict,\n            life-randRange(0,8),\n            lifeSpeed\n          ));\n        }\n      }\n\n      float frameTime=ImGui::GetIO().DeltaTime*60.0f;\n\n      // note slides\n      ImVec2 arrowPoints[7];\n      if (e->isPlaying()) for (int i=0; i<chans; i++) {\n        if (!e->song.chanShow[i]) continue;\n        DivChannelState* ch=e->getChanState(i);\n        if (ch->portaSpeed>0) {\n          ImVec4 col=uiColors[GUI_COLOR_PATTERN_EFFECT_PITCH];\n          col.w*=0.2;\n          float width=patChanX[i+1]-patChanX[i];\n\n          particles.push_back(Particle(\n            pitchGrad,\n            (ch->portaNote<=ch->note)?ICON_FA_CHEVRON_DOWN:ICON_FA_CHEVRON_UP,\n            off.x+patChanX[i]+fmod(rand(),width)-scrollX,\n            off.y+fmod(rand(),MAX(1,ImGui::GetWindowHeight())),\n            0.0f,\n            (7.0f+(rand()%5)+pow(ch->portaSpeed,0.7f))*((ch->portaNote<=ch->note)?1:-1),\n            0.0f,\n            1.0f,\n            255.0f,\n            15.0f\n          ));\n\n          if (width>0.1) for (float j=-patChanSlideY[i]; j<ImGui::GetWindowHeight(); j+=width*0.7) {\n            ImVec2 tMin=ImVec2(off.x+patChanX[i]-scrollX,off.y+j);\n            ImVec2 tMax=ImVec2(off.x+patChanX[i+1]-scrollX,off.y+j+width*0.6);\n            if (ch->portaNote<=ch->note) {\n              arrowPoints[0]=ImLerp(tMin,tMax,ImVec2(0.1,1.0-0.8));\n              arrowPoints[1]=ImLerp(tMin,tMax,ImVec2(0.5,1.0-0.0));\n              arrowPoints[2]=ImLerp(tMin,tMax,ImVec2(0.9,1.0-0.8));\n              arrowPoints[3]=ImLerp(tMin,tMax,ImVec2(0.8,1.0-1.0));\n              arrowPoints[4]=ImLerp(tMin,tMax,ImVec2(0.5,1.0-0.37));\n              arrowPoints[5]=ImLerp(tMin,tMax,ImVec2(0.2,1.0-1.0));\n              arrowPoints[6]=arrowPoints[0];\n              dl->AddPolyline(arrowPoints,7,ImGui::GetColorU32(col),ImDrawFlags_None,5.0f*dpiScale);\n            } else {\n              arrowPoints[0]=ImLerp(tMin,tMax,ImVec2(0.1,0.8));\n              arrowPoints[1]=ImLerp(tMin,tMax,ImVec2(0.5,0.0));\n              arrowPoints[2]=ImLerp(tMin,tMax,ImVec2(0.9,0.8));\n              arrowPoints[3]=ImLerp(tMin,tMax,ImVec2(0.8,1.0));\n              arrowPoints[4]=ImLerp(tMin,tMax,ImVec2(0.5,0.37));\n              arrowPoints[5]=ImLerp(tMin,tMax,ImVec2(0.2,1.0));\n              arrowPoints[6]=arrowPoints[0];\n              dl->AddPolyline(arrowPoints,7,ImGui::GetColorU32(col),ImDrawFlags_None,5.0f*dpiScale);\n            }\n          }\n          patChanSlideY[i]+=((ch->portaNote<=ch->note)?-8:8)*dpiScale*frameTime;\n          if (width>0) {\n            if (patChanSlideY[i]<0) {\n              patChanSlideY[i]=-fmod(-patChanSlideY[i],width*0.7);\n            } else {\n              patChanSlideY[i]=fmod(patChanSlideY[i],width*0.7);\n            }\n          }\n        }\n      }\n\n      // particle simulation\n      ImDrawList* fdl=ImGui::GetForegroundDrawList();\n      for (size_t i=0; i<particles.size(); i++) {\n        Particle& part=particles[i];\n        if (part.update(frameTime)) {\n          if (part.life>255) part.life=255;\n          fdl->AddText(\n            iconFont,\n            iconFont->FontSize,\n            ImVec2(part.pos.x-iconFont->FontSize*0.5,part.pos.y-iconFont->FontSize*0.5),\n            part.colors[(int)part.life],\n            part.type\n          );\n        } else {\n          particles.erase(particles.begin()+i);\n          i--;\n        }\n      }\n    }\n\n    ImGui::PopStyleColor(3);\n    ImGui::PopStyleVar();\n    ImGui::PopFont();\n  }\n  ImGui::PopStyleVar();\n  if (patternOpen) {\n    if (!inhibitMenu && ImGui::IsItemClicked(ImGuiMouseButton_Right)) ImGui::OpenPopup(\"patternActionMenu\");\n    if (ImGui::BeginPopup(\"patternActionMenu\",ImGuiWindowFlags_NoMove|ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings)) {\n      editOptions(false);\n      ImGui::EndPopup();\n    }\n  }\n  if (ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows)) curWindow=GUI_WINDOW_PATTERN;\n  ImGui::End();\n  //int delta1=SDL_GetPerformanceCounter();\n  //logV(\"render time: %d\u00b5s\\n\",(delta1-delta0)/(SDL_GetPerformanceFrequency()/1000000));\n}\n\n"], "filenames": ["src/gui/pattern.cpp"], "buggy_code_start_loc": [285], "buggy_code_end_loc": [306], "fixing_code_start_loc": [285], "fixing_code_end_loc": [312], "type": "NVD-CWE-noinfo", "message": "A denial of service vulnerability was found in tildearrow Furnace. It has been classified as problematic. This is due to an incomplete fix of CVE-2022-1211. It is possible to initiate the attack remotely but it requires user interaction. The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce.", "other": {"cve": {"id": "CVE-2022-1289", "sourceIdentifier": "cna@vuldb.com", "published": "2022-04-10T16:15:07.847", "lastModified": "2023-03-07T22:38:43.943", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A denial of service vulnerability was found in tildearrow Furnace. It has been classified as problematic. This is due to an incomplete fix of CVE-2022-1211. It is possible to initiate the attack remotely but it requires user interaction. The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de denegaci\u00f3n de servicio en tildearrow Furnace. Ha sido clasificada como problem\u00e1tica. Esto es debido a una correcci\u00f3n incompleta de CVE-2022-1211. Es posible iniciar el ataque de forma remota, pero requiere una interacci\u00f3n del usuario. El problema ha sido corregido con el parche 0eb02422d5161767e9983bdaa5c429762d3477ce"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:-:*:*:*:*:*:*:*", "matchCriteriaId": "2CFFA314-6943-4498-B845-E1A1ABCE4E31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E015EA7E-4720-4757-96E9-5260CFBC1043"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "E776BB42-A08E-4F3C-947D-332DCB2CBF88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "051B2A23-EDCF-4539-9CA8-E5714F6F6DF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "FDE66467-B30B-4B77-BB41-6A4C647E457B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D42E6328-AF1D-45D9-9DBB-382E8EDE3E40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4:*:*:*:*:*:*:*", "matchCriteriaId": "E76E15CA-9D90-4B4C-B987-E8608AA60236"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "F20B01FD-07A2-4D09-AAE5-11E464D4454B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "50763220-BBF6-4CB5-8E05-150B53714F61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "AAB16783-A272-4E66-AF78-17B024DCEA88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "6689F024-5C0F-42DC-B048-20268EBE49AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "6BC4CEB4-803F-4D09-905C-270617E56336"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.5:real:*:*:*:*:*:*", "matchCriteriaId": "7ADEB444-C64D-48EF-8F4E-BA88BD8509B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "B0A54674-881E-4448-83A8-9FF06E58ECCD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "7F8660DE-0B05-48C0-80D5-970EFA31E9F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8CDBEA41-070A-43B9-A2C6-C168D3C70AE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "76BA3B0D-EDC6-4B79-8DDC-09360E93F6C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "B25DEC4B-7531-40D8-B476-7C9FE8762515"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "8BA49882-11C5-4F54-AEEE-415F3DC68406"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "198DFD86-6858-41F0-8AA5-CC85F1A27E92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "767CA8B0-9454-4F06-A12E-D7C4555E8BBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "E33824AB-E32F-4F82-9E51-138B3183DA80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.7:-:*:*:*:*:*:*", "matchCriteriaId": "541CF21B-7719-42CB-97F1-CB7AF2F77FA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.7:pre4:*:*:*:*:*:*", "matchCriteriaId": "CD522023-C8DF-4BEA-911F-DE65428FCF34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.5.8:*:*:*:*:*:*:*", "matchCriteriaId": "B8952D4C-334E-43D6-B6B8-0E9EC7F2253B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:0.6:pre0:*:*:*:*:*:*", "matchCriteriaId": "3F99C267-EA7C-4ADA-8BE9-7E51D143B5E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev5:*:*:*:*:*:*:*", "matchCriteriaId": "73F24C96-A83E-4F53-B852-9262C7CFC387"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev6:*:*:*:*:*:*:*", "matchCriteriaId": "9B5A5017-B4F4-480E-9CED-ADF09100A4F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev7:*:*:*:*:*:*:*", "matchCriteriaId": "A726A198-CBBD-4FAE-B3D7-C51F0F3D10B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev8:*:*:*:*:*:*:*", "matchCriteriaId": "05E6200E-5061-4F71-9FD8-E19F9F6D2557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev9:*:*:*:*:*:*:*", "matchCriteriaId": "9934631B-564C-4823-B509-75DA02940CB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev10:*:*:*:*:*:*:*", "matchCriteriaId": "2FEAE377-ED50-4A3B-971A-BDB1780EE242"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev62:*:*:*:*:*:*:*", "matchCriteriaId": "065CEC21-3C18-476F-B714-E2F20233F296"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev63:*:*:*:*:*:*:*", "matchCriteriaId": "9D67EC62-0FFD-4951-BA17-633DCD5C65C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev64:*:*:*:*:*:*:*", "matchCriteriaId": "87E9A121-6A91-4636-8453-3CFC6FA24B56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev65:*:*:*:*:*:*:*", "matchCriteriaId": "67EFBF91-2CF9-4095-B8DF-425AE1917A25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev66:*:*:*:*:*:*:*", "matchCriteriaId": "C1D41EEE-621B-4366-9097-27EF1472B38A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev67:*:*:*:*:*:*:*", "matchCriteriaId": "7CAF3983-5034-4095-9221-C464EBE6A0D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev68:*:*:*:*:*:*:*", "matchCriteriaId": "A145138D-19AB-4290-B145-DBB9DFB025D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev69:*:*:*:*:*:*:*", "matchCriteriaId": "3F812509-1F77-4024-85EB-CDD325BFCE6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev70:*:*:*:*:*:*:*", "matchCriteriaId": "F60A5D1D-4B4C-4B67-B541-A5F14ACB820A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev71:*:*:*:*:*:*:*", "matchCriteriaId": "45C270A3-E380-4022-861D-6697DB73D895"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev72:*:*:*:*:*:*:*", "matchCriteriaId": "7A015763-407E-4283-9A39-4CFB9D699110"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev73:*:*:*:*:*:*:*", "matchCriteriaId": "48D91A45-1102-4081-BBEC-ED6CD9DF6689"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev75:*:*:*:*:*:*:*", "matchCriteriaId": "7F9BFF65-6CB4-4466-B8C1-3584FEBCB626"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev76:*:*:*:*:*:*:*", "matchCriteriaId": "CDB48FE2-3476-4180-8754-724A153DF5C5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev77:*:*:*:*:*:*:*", "matchCriteriaId": "0B8C8373-5E16-493C-B736-26C2676782D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev78:*:*:*:*:*:*:*", "matchCriteriaId": "37EF1C85-71ED-4592-AF40-88CA608761F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev79:*:*:*:*:*:*:*", "matchCriteriaId": "73FED9B5-3C85-4C59-B2F7-AC96439A52D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tildearrow:furnace:dev80:*:*:*:*:*:*:*", "matchCriteriaId": "E53F9DDD-249D-4BD1-8AC9-D361508E8487"}]}]}], "references": [{"url": "https://github.com/tildearrow/furnace/commit/0eb02422d5161767e9983bdaa5c429762d3477ce", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tildearrow/furnace/issues/325#issuecomment-1094139655", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.196755", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tildearrow/furnace/commit/0eb02422d5161767e9983bdaa5c429762d3477ce"}}