{"buggy_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Ethereum pallet\n//!\n//! The Ethereum pallet works together with EVM pallet to provide full emulation\n//! for Ethereum block processing.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse codec::{Decode, Encode};\nuse ethereum_types::{Bloom, BloomInput, H160, H256, H64, U256};\nuse evm::ExitReason;\nuse fp_consensus::{PostLog, PreLog, FRONTIER_ENGINE_ID};\nuse fp_evm::CallOrCreateInfo;\nuse fp_storage::PALLET_ETHEREUM_SCHEMA;\nuse frame_support::{\n\tdispatch::DispatchResultWithPostInfo,\n\tensure,\n\ttraits::{EnsureOrigin, Get},\n\tweights::{Pays, PostDispatchInfo, Weight},\n};\nuse frame_system::pallet_prelude::OriginFor;\nuse pallet_evm::{BlockHashMapping, FeeCalculator, GasWeightMapping, Runner};\nuse sha3::{Digest, Keccak256};\nuse sp_runtime::{\n\tgeneric::DigestItem,\n\ttraits::{One, Saturating, UniqueSaturatedInto, Zero},\n\ttransaction_validity::{\n\t\tInvalidTransaction, TransactionValidity, TransactionValidityError, ValidTransactionBuilder,\n\t},\n\tDispatchError, RuntimeDebug,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n\npub use ethereum::{\n\tBlockV0 as Block, LegacyTransactionMessage, Log, Receipt, TransactionAction,\n\tTransactionV0 as Transaction,\n};\npub use fp_rpc::TransactionStatus;\n\n#[cfg(all(feature = \"std\", test))]\nmod mock;\n#[cfg(all(feature = \"std\", test))]\nmod tests;\n\n#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug)]\npub enum RawOrigin {\n\tEthereumTransaction(H160),\n}\n\npub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,\n{\n\tmatch o.into() {\n\t\tOk(RawOrigin::EthereumTransaction(n)) => Ok(n),\n\t\t_ => Err(\"bad origin: expected to be an Ethereum transaction\"),\n\t}\n}\n\npub struct EnsureEthereumTransaction;\nimpl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>\n\tfor EnsureEthereumTransaction\n{\n\ttype Success = H160;\n\tfn try_origin(o: O) -> Result<Self::Success, O> {\n\t\to.into().and_then(|o| match o {\n\t\t\tRawOrigin::EthereumTransaction(id) => Ok(id),\n\t\t})\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\tfn successful_origin() -> O {\n\t\tO::from(RawOrigin::EthereumTransaction(Default::default()))\n\t}\n}\n\nimpl<T: Config> Call<T>\nwhere\n\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n{\n\tpub fn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::transact(_) => true,\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tpub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tlet check = || {\n\t\t\t\tlet origin = Pallet::<T>::recover_signer(&transaction).ok_or_else(|| {\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)\n\t\t\t\t})?;\n\n\t\t\t\tOk(origin)\n\t\t\t};\n\n\t\t\tSome(check())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tlet validate = || {\n\t\t\t\t// We must ensure a transaction can pay the cost of its data bytes.\n\t\t\t\t// If it can't it should not be included in a block.\n\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\t\t\ttransaction.gas_limit.low_u64(),\n\t\t\t\t\t<T as pallet_evm::Config>::config(),\n\t\t\t\t);\n\t\t\t\tlet transaction_cost = match transaction.action {\n\t\t\t\t\tTransactionAction::Call(_) => {\n\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n\t\t\t\t\t}\n\t\t\t\t\tTransactionAction::Create => {\n\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into();\n\t\t\t\t}\n\n\t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n\t\t\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.into();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into();\n\t\t\t\t}\n\n\t\t\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n\n\t\t\t\tif transaction.nonce < account_data.nonce {\n\t\t\t\t\treturn InvalidTransaction::Stale.into();\n\t\t\t\t}\n\n\t\t\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n\t\t\t\tlet total_payment = transaction.value.saturating_add(fee);\n\t\t\t\tif account_data.balance < total_payment {\n\t\t\t\t\treturn InvalidTransaction::Payment.into();\n\t\t\t\t}\n\n\t\t\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n\n\t\t\t\tif transaction.gas_price < min_gas_price {\n\t\t\t\t\treturn InvalidTransaction::Payment.into();\n\t\t\t\t}\n\n\t\t\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t\t\t.and_provides((origin, transaction.nonce))\n\t\t\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n\n\t\t\t\tif transaction.nonce > account_data.nonce {\n\t\t\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n\t\t\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbuilder.build()\n\t\t\t};\n\n\t\t\tSome(validate())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\npub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config\n\t\t+ pallet_balances::Config\n\t\t+ pallet_timestamp::Config\n\t\t+ pallet_evm::Config\n\t{\n\t\t/// The overarching event type.\n\t\ttype Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;\n\t\t/// How Ethereum state root is calculated.\n\t\ttype StateRoot: Get<H256>;\n\t}\n\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\tpub struct Pallet<T>(PhantomData<T>);\n\n\t#[pallet::origin]\n\tpub type Origin = RawOrigin;\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_finalize(n: T::BlockNumber) {\n\t\t\t<Pallet<T>>::store_block(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tU256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(\n\t\t\t\t\tframe_system::Pallet::<T>::block_number(),\n\t\t\t\t)),\n\t\t\t);\n\t\t\t// move block hash pruning window by one block\n\t\t\tlet block_hash_count = T::BlockHashCount::get();\n\t\t\tlet to_remove = n\n\t\t\t\t.saturating_sub(block_hash_count)\n\t\t\t\t.saturating_sub(One::one());\n\t\t\t// keep genesis hash\n\t\t\tif !to_remove.is_zero() {\n\t\t\t\t<BlockHash<T>>::remove(U256::from(\n\t\t\t\t\tUniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tfn on_initialize(_: T::BlockNumber) -> Weight {\n\t\t\tPending::<T>::kill();\n\n\t\t\t// If the digest contain an existing ethereum block(encoded as PreLog), If contains,\n\t\t\t// execute the imported block firstly and disable transact dispatch function.\n\t\t\tif let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {\n\t\t\t\tlet PreLog::Block(block) = log;\n\n\t\t\t\tfor transaction in block.transactions {\n\t\t\t\t\tlet source = Self::recover_signer(&transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n\t\t\t\t\t);\n\n\t\t\t\t\tSelf::do_transact(source, transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t0\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T>\n\twhere\n\t\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\t{\n\t\t/// Transact an Ethereum transaction.\n\t\t#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight(transaction.gas_limit.unique_saturated_into()))]\n\t\tpub fn transact(\n\t\t\torigin: OriginFor<T>,\n\t\t\ttransaction: Transaction,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tlet source = ensure_ethereum_transaction(origin)?;\n\t\t\t// Disable transact functionality if PreLog exist.\n\t\t\tensure!(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tError::<T>::PreLogExists,\n\t\t\t);\n\n\t\t\tSelf::do_transact(source, transaction)\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event {\n\t\t/// An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]\n\t\tExecuted(H160, H160, H256, ExitReason),\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Signature is invalid.\n\t\tInvalidSignature,\n\t\t/// Pre-log is present, therefore transact is not allowed.\n\t\tPreLogExists,\n\t}\n\n\t/// Current building block's transactions and receipts.\n\t#[pallet::storage]\n\tpub(super) type Pending<T: Config> =\n\t\tStorageValue<_, Vec<(Transaction, TransactionStatus, ethereum::Receipt)>, ValueQuery>;\n\n\t/// The current Ethereum block.\n\t#[pallet::storage]\n\tpub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV0>;\n\n\t/// The current Ethereum receipts.\n\t#[pallet::storage]\n\tpub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<ethereum::Receipt>>;\n\n\t/// The current transaction statuses.\n\t#[pallet::storage]\n\tpub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;\n\n\t// Mapping for block number and hashes.\n\t#[pallet::storage]\n\tpub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;\n\n\t#[pallet::genesis_config]\n\t#[derive(Default)]\n\tpub struct GenesisConfig {}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig {\n\t\tfn build(&self) {\n\t\t\t<Pallet<T>>::store_block(false, U256::zero());\n\t\t\tframe_support::storage::unhashed::put::<EthereumStorageSchema>(\n\t\t\t\t&PALLET_ETHEREUM_SCHEMA,\n\t\t\t\t&EthereumStorageSchema::V1,\n\t\t\t);\n\t\t}\n\t}\n}\n\nimpl<T: Config> Pallet<T> {\n\tfn recover_signer(transaction: &Transaction) -> Option<H160> {\n\t\tlet mut sig = [0u8; 65];\n\t\tlet mut msg = [0u8; 32];\n\t\tsig[0..32].copy_from_slice(&transaction.signature.r()[..]);\n\t\tsig[32..64].copy_from_slice(&transaction.signature.s()[..]);\n\t\tsig[64] = transaction.signature.standard_v();\n\t\tmsg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);\n\n\t\tlet pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;\n\t\tSome(H160::from(H256::from_slice(\n\t\t\tKeccak256::digest(&pubkey).as_slice(),\n\t\t)))\n\t}\n\n\tfn store_block(post_log: bool, block_number: U256) {\n\t\tlet mut transactions = Vec::new();\n\t\tlet mut statuses = Vec::new();\n\t\tlet mut receipts = Vec::new();\n\t\tlet mut logs_bloom = Bloom::default();\n\t\tfor (transaction, status, receipt) in Pending::<T>::get() {\n\t\t\ttransactions.push(transaction);\n\t\t\tstatuses.push(status);\n\t\t\treceipts.push(receipt.clone());\n\t\t\tSelf::logs_bloom(receipt.logs.clone(), &mut logs_bloom);\n\t\t}\n\n\t\tlet ommers = Vec::<ethereum::Header>::new();\n\t\tlet receipts_root =\n\t\t\tethereum::util::ordered_trie_root(receipts.iter().map(|r| rlp::encode(r)));\n\t\tlet partial_header = ethereum::PartialHeader {\n\t\t\tparent_hash: Self::current_block_hash().unwrap_or_default(),\n\t\t\tbeneficiary: pallet_evm::Pallet::<T>::find_author(),\n\t\t\tstate_root: T::StateRoot::get(),\n\t\t\treceipts_root,\n\t\t\tlogs_bloom,\n\t\t\tdifficulty: U256::zero(),\n\t\t\tnumber: block_number,\n\t\t\tgas_limit: T::BlockGasLimit::get(),\n\t\t\tgas_used: receipts\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.fold(U256::zero(), |acc, r| acc + r.used_gas),\n\t\t\ttimestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(\n\t\t\t\tpallet_timestamp::Pallet::<T>::get(),\n\t\t\t),\n\t\t\textra_data: Vec::new(),\n\t\t\tmix_hash: H256::default(),\n\t\t\tnonce: H64::default(),\n\t\t};\n\t\tlet block = ethereum::Block::new(partial_header, transactions.clone(), ommers);\n\n\t\tCurrentBlock::<T>::put(block.clone());\n\t\tCurrentReceipts::<T>::put(receipts.clone());\n\t\tCurrentTransactionStatuses::<T>::put(statuses.clone());\n\t\tBlockHash::<T>::insert(block_number, block.header.hash());\n\n\t\tif post_log {\n\t\t\tlet digest = DigestItem::<T::Hash>::Consensus(\n\t\t\t\tFRONTIER_ENGINE_ID,\n\t\t\t\tPostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),\n\t\t\t);\n\t\t\tframe_system::Pallet::<T>::deposit_log(digest.into());\n\t\t}\n\t}\n\n\tfn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {\n\t\tfor log in logs {\n\t\t\tbloom.accrue(BloomInput::Raw(&log.address[..]));\n\t\t\tfor topic in log.topics {\n\t\t\t\tbloom.accrue(BloomInput::Raw(&topic[..]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfn do_transact(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {\n\t\tlet transaction_hash =\n\t\t\tH256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());\n\t\tlet transaction_index = Pending::<T>::get().len() as u32;\n\n\t\tlet (to, _, info) = Self::execute(\n\t\t\tsource,\n\t\t\ttransaction.input.clone(),\n\t\t\ttransaction.value,\n\t\t\ttransaction.gas_limit,\n\t\t\tSome(transaction.gas_price),\n\t\t\tSome(transaction.nonce),\n\t\t\ttransaction.action,\n\t\t\tNone,\n\t\t)?;\n\n\t\tlet (reason, status, used_gas, dest) = match info {\n\t\t\tCallOrCreateInfo::Call(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: None,\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tto,\n\t\t\t),\n\t\t\tCallOrCreateInfo::Create(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: Some(info.value),\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tSome(info.value),\n\t\t\t),\n\t\t};\n\n\t\tlet receipt = ethereum::Receipt {\n\t\t\tstate_root: match reason {\n\t\t\t\tExitReason::Succeed(_) => H256::from_low_u64_be(1),\n\t\t\t\tExitReason::Error(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Revert(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Fatal(_) => H256::from_low_u64_le(0),\n\t\t\t},\n\t\t\tused_gas,\n\t\t\tlogs_bloom: status.clone().logs_bloom,\n\t\t\tlogs: status.clone().logs,\n\t\t};\n\n\t\tPending::<T>::append((transaction, status, receipt));\n\n\t\tSelf::deposit_event(Event::Executed(\n\t\t\tsource,\n\t\t\tdest.unwrap_or_default(),\n\t\t\ttransaction_hash,\n\t\t\treason,\n\t\t));\n\t\tOk(PostDispatchInfo {\n\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\tused_gas.unique_saturated_into(),\n\t\t\t)),\n\t\t\tpays_fee: Pays::No,\n\t\t})\n\t\t.into()\n\t}\n\n\t/// Get the transaction status with given index.\n\tpub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\tCurrentTransactionStatuses::<T>::get()\n\t}\n\n\t/// Get current block.\n\tpub fn current_block() -> Option<ethereum::BlockV0> {\n\t\tCurrentBlock::<T>::get()\n\t}\n\n\t/// Get current block hash\n\tpub fn current_block_hash() -> Option<H256> {\n\t\tSelf::current_block().map(|block| block.header.hash())\n\t}\n\n\t/// Get receipts by number.\n\tpub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {\n\t\tCurrentReceipts::<T>::get()\n\t}\n\n\t/// Execute an Ethereum transaction.\n\tpub fn execute(\n\t\tfrom: H160,\n\t\tinput: Vec<u8>,\n\t\tvalue: U256,\n\t\tgas_limit: U256,\n\t\tgas_price: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taction: TransactionAction,\n\t\tconfig: Option<evm::Config>,\n\t) -> Result<(Option<H160>, Option<H160>, CallOrCreateInfo), DispatchError> {\n\t\tmatch action {\n\t\t\tethereum::TransactionAction::Call(target) => {\n\t\t\t\tlet res = T::Runner::call(\n\t\t\t\t\tfrom,\n\t\t\t\t\ttarget,\n\t\t\t\t\tinput.clone(),\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tgas_price,\n\t\t\t\t\tnonce,\n\t\t\t\t\tconfig.as_ref().unwrap_or(T::config()),\n\t\t\t\t)\n\t\t\t\t.map_err(Into::into)?;\n\n\t\t\t\tOk((Some(target), None, CallOrCreateInfo::Call(res)))\n\t\t\t}\n\t\t\tethereum::TransactionAction::Create => {\n\t\t\t\tlet res = T::Runner::create(\n\t\t\t\t\tfrom,\n\t\t\t\t\tinput.clone(),\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tgas_price,\n\t\t\t\t\tnonce,\n\t\t\t\t\tconfig.as_ref().unwrap_or(T::config()),\n\t\t\t\t)\n\t\t\t\t.map_err(Into::into)?;\n\n\t\t\t\tOk((None, Some(res.value), CallOrCreateInfo::Create(res)))\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[derive(Eq, PartialEq, Clone, sp_runtime::RuntimeDebug)]\npub enum ReturnValue {\n\tBytes(Vec<u8>),\n\tHash(H160),\n}\n\n/// The schema version for Pallet Ethereum's storage\n#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, PartialOrd, Ord)]\npub enum EthereumStorageSchema {\n\tUndefined,\n\tV1,\n}\n\nimpl Default for EthereumStorageSchema {\n\tfn default() -> Self {\n\t\tSelf::Undefined\n\t}\n}\n\npub struct IntermediateStateRoot;\nimpl Get<H256> for IntermediateStateRoot {\n\tfn get() -> H256 {\n\t\tH256::decode(&mut &sp_io::storage::root()[..])\n\t\t\t.expect(\"Node is configured to use the same hash; qed\")\n\t}\n}\n\n/// Returns the Ethereum block hash by number.\npub struct EthereumBlockHashMapping<T>(PhantomData<T>);\nimpl<T: Config> BlockHashMapping for EthereumBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tBlockHash::<T>::get(U256::from(number))\n\t}\n}\n\n#[repr(u8)]\nenum TransactionValidationError {\n\t#[allow(dead_code)]\n\tUnknownError,\n\tInvalidChainId,\n\tInvalidSignature,\n\tInvalidGasLimit,\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Test utilities\n\nuse super::*;\nuse crate::IntermediateStateRoot;\nuse ethereum::{TransactionAction, TransactionSignature};\nuse frame_support::{parameter_types, traits::FindAuthor, ConsensusEngineId, PalletId};\nuse pallet_evm::{AddressMapping, EnsureAddressTruncated, FeeCalculator};\nuse rlp::*;\nuse sha3::Digest;\nuse sp_core::{H160, H256, U256};\nuse sp_runtime::{\n\ttesting::Header,\n\ttraits::{BlakeTwo256, IdentityLookup},\n\tAccountId32,\n};\n\ntype UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic<Test>;\ntype Block = frame_system::mocking::MockBlock<Test>;\n\nframe_support::construct_runtime! {\n\tpub enum Test where\n\t\tBlock = Block,\n\t\tNodeBlock = Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event<T>},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage},\n\t\tEVM: pallet_evm::{Pallet, Call, Storage, Config, Event<T>},\n\t\tEthereum: crate::{Pallet, Call, Storage, Event, Origin},\n\t}\n}\n\nparameter_types! {\n\tpub const BlockHashCount: u64 = 250;\n\tpub BlockWeights: frame_system::limits::BlockWeights =\n\t\tframe_system::limits::BlockWeights::simple_max(1024);\n}\n\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype Origin = Origin;\n\ttype Index = u64;\n\ttype BlockNumber = u64;\n\ttype Hash = H256;\n\ttype Call = Call;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = AccountId32;\n\ttype Lookup = IdentityLookup<Self::AccountId>;\n\ttype Header = Header;\n\ttype Event = Event;\n\ttype BlockHashCount = BlockHashCount;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = pallet_balances::AccountData<u64>;\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = ();\n\ttype OnSetCode = ();\n}\n\nparameter_types! {\n\t// For weight estimation, we assume that the most locks on an individual account will be 50.\n\t// This number may need to be adjusted in the future if this assumption no longer holds true.\n\tpub const MaxLocks: u32 = 50;\n\tpub const ExistentialDeposit: u64 = 500;\n}\n\nimpl pallet_balances::Config for Test {\n\ttype MaxLocks = MaxLocks;\n\ttype Balance = u64;\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = 6000 / 2;\n}\n\nimpl pallet_timestamp::Config for Test {\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\npub struct FixedGasPrice;\nimpl FeeCalculator for FixedGasPrice {\n\tfn min_gas_price() -> U256 {\n\t\t1.into()\n\t}\n}\n\npub struct FindAuthorTruncated;\nimpl FindAuthor<H160> for FindAuthorTruncated {\n\tfn find_author<'a, I>(_digests: I) -> Option<H160>\n\twhere\n\t\tI: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,\n\t{\n\t\tSome(address_build(0).address)\n\t}\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: u64 = 1;\n\tpub const ChainId: u64 = 42;\n\tpub const EVMModuleId: PalletId = PalletId(*b\"py/evmpa\");\n\tpub const BlockGasLimit: U256 = U256::MAX;\n}\n\npub struct HashedAddressMapping;\n\nimpl AddressMapping<AccountId32> for HashedAddressMapping {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 32];\n\t\tdata[0..20].copy_from_slice(&address[..]);\n\t\tAccountId32::from(Into::<[u8; 32]>::into(data))\n\t}\n}\n\nimpl pallet_evm::Config for Test {\n\ttype FeeCalculator = FixedGasPrice;\n\ttype GasWeightMapping = ();\n\ttype CallOrigin = EnsureAddressTruncated;\n\ttype WithdrawOrigin = EnsureAddressTruncated;\n\ttype AddressMapping = HashedAddressMapping;\n\ttype Currency = Balances;\n\ttype Event = Event;\n\ttype Precompiles = ();\n\ttype Runner = pallet_evm::runner::stack::Runner<Self>;\n\ttype ChainId = ChainId;\n\ttype BlockGasLimit = BlockGasLimit;\n\ttype OnChargeTransaction = ();\n\ttype FindAuthor = FindAuthorTruncated;\n\ttype BlockHashMapping = crate::EthereumBlockHashMapping<Self>;\n}\n\nimpl crate::Config for Test {\n\ttype Event = Event;\n\ttype StateRoot = IntermediateStateRoot;\n}\n\npub struct AccountInfo {\n\tpub address: H160,\n\tpub account_id: AccountId32,\n\tpub private_key: H256,\n}\n\nfn address_build(seed: u8) -> AccountInfo {\n\tlet private_key = H256::from_slice(&[(seed + 1) as u8; 32]); //H256::from_low_u64_be((i + 1) as u64);\n\tlet secret_key = libsecp256k1::SecretKey::parse_slice(&private_key[..]).unwrap();\n\tlet public_key = &libsecp256k1::PublicKey::from_secret_key(&secret_key).serialize()[1..65];\n\tlet address = H160::from(H256::from_slice(&Keccak256::digest(public_key)[..]));\n\n\tlet mut data = [0u8; 32];\n\tdata[0..20].copy_from_slice(&address[..]);\n\n\tAccountInfo {\n\t\tprivate_key,\n\t\taccount_id: AccountId32::from(Into::<[u8; 32]>::into(data)),\n\t\taddress,\n\t}\n}\n\n// This function basically just builds a genesis storage key/value store according to\n// our desired mockup.\npub fn new_test_ext(accounts_len: usize) -> (Vec<AccountInfo>, sp_io::TestExternalities) {\n\t// sc_cli::init_logger(\"\");\n\tlet mut ext = frame_system::GenesisConfig::default()\n\t\t.build_storage::<Test>()\n\t\t.unwrap();\n\n\tlet pairs = (0..accounts_len)\n\t\t.map(|i| address_build(i as u8))\n\t\t.collect::<Vec<_>>();\n\n\tlet balances: Vec<_> = (0..accounts_len)\n\t\t.map(|i| (pairs[i].account_id.clone(), 10_000_000))\n\t\t.collect();\n\n\tpallet_balances::GenesisConfig::<Test> { balances }\n\t\t.assimilate_storage(&mut ext)\n\t\t.unwrap();\n\n\t(pairs, ext.into())\n}\n\npub fn contract_address(sender: H160, nonce: u64) -> H160 {\n\tlet mut rlp = RlpStream::new_list(2);\n\trlp.append(&sender);\n\trlp.append(&nonce);\n\n\tH160::from_slice(&Keccak256::digest(&rlp.out())[12..])\n}\n\npub fn storage_address(sender: H160, slot: H256) -> H256 {\n\tH256::from_slice(&Keccak256::digest(\n\t\t[&H256::from(sender)[..], &slot[..]].concat().as_slice(),\n\t))\n}\n\npub struct UnsignedTransaction {\n\tpub nonce: U256,\n\tpub gas_price: U256,\n\tpub gas_limit: U256,\n\tpub action: TransactionAction,\n\tpub value: U256,\n\tpub input: Vec<u8>,\n}\n\nimpl UnsignedTransaction {\n\tfn signing_rlp_append(&self, s: &mut RlpStream) {\n\t\ts.begin_list(9);\n\t\ts.append(&self.nonce);\n\t\ts.append(&self.gas_price);\n\t\ts.append(&self.gas_limit);\n\t\ts.append(&self.action);\n\t\ts.append(&self.value);\n\t\ts.append(&self.input);\n\t\ts.append(&ChainId::get());\n\t\ts.append(&0u8);\n\t\ts.append(&0u8);\n\t}\n\n\tfn signing_hash(&self) -> H256 {\n\t\tlet mut stream = RlpStream::new();\n\t\tself.signing_rlp_append(&mut stream);\n\t\tH256::from_slice(&Keccak256::digest(&stream.out()).as_slice())\n\t}\n\n\tpub fn sign(&self, key: &H256) -> Transaction {\n\t\tlet hash = self.signing_hash();\n\t\tlet msg = libsecp256k1::Message::parse(hash.as_fixed_bytes());\n\t\tlet s = libsecp256k1::sign(\n\t\t\t&msg,\n\t\t\t&libsecp256k1::SecretKey::parse_slice(&key[..]).unwrap(),\n\t\t);\n\t\tlet sig = s.0.serialize();\n\n\t\tlet sig = TransactionSignature::new(\n\t\t\ts.1.serialize() as u64 % 2 + ChainId::get() * 2 + 35,\n\t\t\tH256::from_slice(&sig[0..32]),\n\t\t\tH256::from_slice(&sig[32..64]),\n\t\t)\n\t\t.unwrap();\n\n\t\tTransaction {\n\t\t\tnonce: self.nonce,\n\t\t\tgas_price: self.gas_price,\n\t\t\tgas_limit: self.gas_limit,\n\t\t\taction: self.action,\n\t\t\tvalue: self.value,\n\t\t\tinput: self.input.clone(),\n\t\t\tsignature: sig,\n\t\t}\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Consensus extension module tests for BABE consensus.\n\nuse crate::{\n\tmock::*, CallOrCreateInfo, Error, RawOrigin, Transaction, TransactionAction,\n\tValidTransactionBuilder, H160, H256, U256,\n};\nuse ethereum::TransactionSignature;\nuse frame_support::{assert_err, assert_noop, assert_ok, unsigned::ValidateUnsigned};\nuse rustc_hex::{FromHex, ToHex};\nuse sp_runtime::transaction_validity::{InvalidTransaction, TransactionSource};\nuse std::str::FromStr;\n\n// This ERC-20 contract mints the maximum amount of tokens to the contract creator.\n// pragma solidity ^0.5.0;`\n// import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/token/ERC20/ERC20.sol\";\n// contract MyToken is ERC20 {\n//\t constructor() public { _mint(msg.sender, 2**256 - 1); }\n// }\nconst ERC20_CONTRACT_BYTECODE: &str = include_str!(\"../res/erc20_contract_bytecode.txt\");\n\nfn default_erc20_creation_unsigned_transaction() -> UnsignedTransaction {\n\tUnsignedTransaction {\n\t\tnonce: U256::zero(),\n\t\tgas_price: U256::from(1),\n\t\tgas_limit: U256::from(0x100000),\n\t\taction: ethereum::TransactionAction::Create,\n\t\tvalue: U256::zero(),\n\t\tinput: FromHex::from_hex(ERC20_CONTRACT_BYTECODE).unwrap(),\n\t}\n}\n\nfn default_erc20_creation_transaction(account: &AccountInfo) -> Transaction {\n\tdefault_erc20_creation_unsigned_transaction().sign(&account.private_key)\n}\n\n#[test]\nfn transaction_should_increment_nonce() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\tassert_eq!(EVM::account_basic(&alice.address).nonce, U256::from(1));\n\t});\n}\n\n#[test]\nfn transaction_without_enough_gas_should_not_work() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet mut transaction = default_erc20_creation_transaction(alice);\n\t\ttransaction.gas_price = U256::from(11_000_000);\n\n\t\tlet call = crate::Call::<Test>::transact(transaction);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\n\t\tassert_err!(\n\t\t\tcall.validate_self_contained(&source).unwrap(),\n\t\t\tInvalidTransaction::Payment\n\t\t);\n\t});\n}\n\n#[test]\nfn transaction_with_invalid_nonce_should_not_work() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\t// nonce is 0\n\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n\t\ttransaction.nonce = U256::from(1);\n\n\t\tlet signed = transaction.sign(&alice.private_key);\n\t\tlet call = crate::Call::<Test>::transact(signed);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\n\t\tassert_eq!(\n\t\t\tcall.validate_self_contained(&source).unwrap(),\n\t\t\tValidTransactionBuilder::default()\n\t\t\t\t.and_provides((alice.address, U256::from(1)))\n\t\t\t\t.priority(1u64)\n\t\t\t\t.and_requires((alice.address, U256::from(0)))\n\t\t\t\t.build()\n\t\t);\n\n\t\tlet t = default_erc20_creation_transaction(alice);\n\n\t\t// nonce is 1\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\n\t\ttransaction.nonce = U256::from(0);\n\n\t\tlet signed2 = transaction.sign(&alice.private_key);\n\t\tlet call2 = crate::Call::<Test>::transact(signed2);\n\t\tlet source2 = call2.check_self_contained().unwrap().unwrap();\n\n\t\tassert_err!(\n\t\t\tcall2.validate_self_contained(&source2).unwrap(),\n\t\t\tInvalidTransaction::Stale\n\t\t);\n\t});\n}\n\n#[test]\nfn contract_constructor_should_get_executed() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\tlet erc20_address = contract_address(alice.address, 0);\n\tlet alice_storage_address = storage_address(alice.address, H256::zero());\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\tassert_eq!(\n\t\t\tEVM::account_storages(erc20_address, alice_storage_address),\n\t\t\tH256::from_str(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")\n\t\t\t\t.unwrap()\n\t\t)\n\t});\n}\n\n#[test]\nfn source_should_be_derived_from_signature() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\tlet erc20_address = contract_address(alice.address, 0);\n\tlet alice_storage_address = storage_address(alice.address, H256::zero());\n\n\text.execute_with(|| {\n\t\tEthereum::transact(\n\t\t\tRawOrigin::EthereumTransaction(alice.address).into(),\n\t\t\tdefault_erc20_creation_transaction(alice),\n\t\t)\n\t\t.expect(\"Failed to execute transaction\");\n\n\t\t// We verify the transaction happened with alice account.\n\t\tassert_eq!(\n\t\t\tEVM::account_storages(erc20_address, alice_storage_address),\n\t\t\tH256::from_str(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")\n\t\t\t\t.unwrap()\n\t\t)\n\t});\n}\n\n#[test]\nfn contract_should_be_created_at_given_address() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\tlet erc20_address = contract_address(alice.address, 0);\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\tassert_ne!(EVM::account_codes(erc20_address).len(), 0);\n\t});\n}\n\n#[test]\nfn transaction_should_generate_correct_gas_used() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\tlet expected_gas = U256::from(891328);\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tlet (_, _, info) = Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tmatch info {\n\t\t\tCallOrCreateInfo::Create(info) => {\n\t\t\t\tassert_eq!(info.used_gas, expected_gas);\n\t\t\t}\n\t\t\tCallOrCreateInfo::Call(_) => panic!(\"expected create info\"),\n\t\t}\n\t});\n}\n\n#[test]\nfn call_should_handle_errors() {\n\t// \tpragma solidity ^0.6.6;\n\t// \tcontract Test {\n\t// \t\tfunction foo() external pure returns (bool) {\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t\tfunction bar() external pure {\n\t// \t\t\trequire(false, \"error_msg\");\n\t// \t\t}\n\t// \t}\n\tlet contract: &str = \"608060405234801561001057600080fd5b50610113806100206000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c8063c2985578146037578063febb0f7e146057575b600080fd5b603d605f565b604051808215151515815260200191505060405180910390f35b605d6068565b005b60006001905090565b600060db576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260098152602001807f6572726f725f6d7367000000000000000000000000000000000000000000000081525060200191505060405180910390fd5b56fea2646970667358221220fde68a3968e0e99b16fabf9b2997a78218b32214031f8e07e2c502daf603a69e64736f6c63430006060033\";\n\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet t = UnsignedTransaction {\n\t\t\tnonce: U256::zero(),\n\t\t\tgas_price: U256::from(1),\n\t\t\tgas_limit: U256::from(0x100000),\n\t\t\taction: ethereum::TransactionAction::Create,\n\t\t\tvalue: U256::zero(),\n\t\t\tinput: FromHex::from_hex(contract).unwrap(),\n\t\t}\n\t\t.sign(&alice.private_key);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\n\t\tlet contract_address: Vec<u8> =\n\t\t\tFromHex::from_hex(\"32dcab0ef3fb2de2fce1d2e0799d36239671f04a\").unwrap();\n\t\tlet foo: Vec<u8> = FromHex::from_hex(\"c2985578\").unwrap();\n\t\tlet bar: Vec<u8> = FromHex::from_hex(\"febb0f7e\").unwrap();\n\n\t\t// calling foo will succeed\n\t\tlet (_, _, info) = Ethereum::execute(\n\t\t\talice.address,\n\t\t\tfoo,\n\t\t\tU256::zero(),\n\t\t\tU256::from(1048576),\n\t\t\tSome(U256::from(1)),\n\t\t\tSome(U256::from(1)),\n\t\t\tTransactionAction::Call(H160::from_slice(&contract_address)),\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tmatch info {\n\t\t\tCallOrCreateInfo::Call(info) => {\n\t\t\t\tassert_eq!(\n\t\t\t\t\tinfo.value.to_hex::<String>(),\n\t\t\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\".to_owned()\n\t\t\t\t);\n\t\t\t}\n\t\t\tCallOrCreateInfo::Create(_) => panic!(\"expected call info\"),\n\t\t}\n\n\t\t// calling should always succeed even if the inner EVM execution fails.\n\t\tEthereum::execute(\n\t\t\talice.address,\n\t\t\tbar,\n\t\t\tU256::zero(),\n\t\t\tU256::from(1048576),\n\t\t\tSome(U256::from(1)),\n\t\t\tSome(U256::from(2)),\n\t\t\tTransactionAction::Call(H160::from_slice(&contract_address)),\n\t\t\tNone,\n\t\t)\n\t\t.ok()\n\t\t.unwrap();\n\t});\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::SelfContainedCall;\nuse frame_support::weights::{DispatchInfo, GetDispatchInfo};\nuse sp_runtime::{\n\ttraits::{\n\t\tself, DispatchInfoOf, Dispatchable, MaybeDisplay, Member, PostDispatchInfoOf,\n\t\tSignedExtension, ValidateUnsigned,\n\t},\n\ttransaction_validity::{\n\t\tInvalidTransaction, TransactionSource, TransactionValidity, TransactionValidityError,\n\t},\n};\n\n#[derive(PartialEq, Eq, Clone, sp_core::RuntimeDebug)]\npub enum CheckedSignature<AccountId, Extra, SelfContainedSignedInfo> {\n\tSigned(AccountId, Extra),\n\tUnsigned,\n\tSelfContained(SelfContainedSignedInfo),\n}\n\n/// Definition of something that the external world might want to say; its\n/// existence implies that it has been checked and is good, particularly with\n/// regards to the signature.\n#[derive(PartialEq, Eq, Clone, sp_core::RuntimeDebug)]\npub struct CheckedExtrinsic<AccountId, Call, Extra, SelfContainedSignedInfo> {\n\t/// Who this purports to be from and the number of extrinsics have come before\n\t/// from the same signer, if anyone (note this is not a signature).\n\tpub signed: CheckedSignature<AccountId, Extra, SelfContainedSignedInfo>,\n\n\t/// The function that should be called.\n\tpub function: Call,\n}\n\nimpl<AccountId, Call: GetDispatchInfo, Extra, SelfContainedSignedInfo> GetDispatchInfo\n\tfor CheckedExtrinsic<AccountId, Call, Extra, SelfContainedSignedInfo>\n{\n\tfn get_dispatch_info(&self) -> DispatchInfo {\n\t\tself.function.get_dispatch_info()\n\t}\n}\n\nimpl<AccountId, Call, Extra, SelfContainedSignedInfo, Origin> traits::Applyable\n\tfor CheckedExtrinsic<AccountId, Call, Extra, SelfContainedSignedInfo>\nwhere\n\tAccountId: Member + MaybeDisplay,\n\tCall: Member\n\t\t+ Dispatchable<Origin = Origin>\n\t\t+ SelfContainedCall<SignedInfo = SelfContainedSignedInfo>,\n\tExtra: SignedExtension<AccountId = AccountId, Call = Call>,\n\tOrigin: From<Option<AccountId>>,\n\tSelfContainedSignedInfo: Send + Sync + 'static,\n{\n\ttype Call = Call;\n\n\tfn validate<U: ValidateUnsigned<Call = Self::Call>>(\n\t\t&self,\n\t\t// TODO [#5006;ToDr] should source be passed to `SignedExtension`s?\n\t\t// Perhaps a change for 2.0 to avoid breaking too much APIs?\n\t\tsource: TransactionSource,\n\t\tinfo: &DispatchInfoOf<Self::Call>,\n\t\tlen: usize,\n\t) -> TransactionValidity {\n\t\tmatch &self.signed {\n\t\t\tCheckedSignature::Signed(id, extra) => {\n\t\t\t\tExtra::validate(extra, id, &self.function, info, len)\n\t\t\t}\n\t\t\tCheckedSignature::Unsigned => {\n\t\t\t\tlet valid = Extra::validate_unsigned(&self.function, info, len)?;\n\t\t\t\tlet unsigned_validation = U::validate_unsigned(source, &self.function)?;\n\t\t\t\tOk(valid.combine_with(unsigned_validation))\n\t\t\t}\n\t\t\tCheckedSignature::SelfContained(signed_info) => {\n\t\t\t\tself.function.validate_self_contained(&signed_info).ok_or(\n\t\t\t\t\tTransactionValidityError::Invalid(InvalidTransaction::BadProof),\n\t\t\t\t)?\n\t\t\t}\n\t\t}\n\t}\n\n\tfn apply<U: ValidateUnsigned<Call = Self::Call>>(\n\t\tself,\n\t\tinfo: &DispatchInfoOf<Self::Call>,\n\t\tlen: usize,\n\t) -> sp_runtime::ApplyExtrinsicResultWithInfo<PostDispatchInfoOf<Self::Call>> {\n\t\tmatch self.signed {\n\t\t\tCheckedSignature::Signed(id, extra) => {\n\t\t\t\tlet pre = Extra::pre_dispatch(extra, &id, &self.function, info, len)?;\n\t\t\t\tlet maybe_who = Some(id);\n\t\t\t\tlet res = self.function.dispatch(Origin::from(maybe_who));\n\t\t\t\tlet post_info = match res {\n\t\t\t\t\tOk(info) => info,\n\t\t\t\t\tErr(err) => err.post_info,\n\t\t\t\t};\n\t\t\t\tExtra::post_dispatch(\n\t\t\t\t\tpre,\n\t\t\t\t\tinfo,\n\t\t\t\t\t&post_info,\n\t\t\t\t\tlen,\n\t\t\t\t\t&res.map(|_| ()).map_err(|e| e.error),\n\t\t\t\t)?;\n\t\t\t\tOk(res)\n\t\t\t}\n\t\t\tCheckedSignature::Unsigned => {\n\t\t\t\tlet pre = Extra::pre_dispatch_unsigned(&self.function, info, len)?;\n\t\t\t\tU::pre_dispatch(&self.function)?;\n\t\t\t\tlet maybe_who = None;\n\t\t\t\tlet res = self.function.dispatch(Origin::from(maybe_who));\n\t\t\t\tlet post_info = match res {\n\t\t\t\t\tOk(info) => info,\n\t\t\t\t\tErr(err) => err.post_info,\n\t\t\t\t};\n\t\t\t\tExtra::post_dispatch(\n\t\t\t\t\tpre,\n\t\t\t\t\tinfo,\n\t\t\t\t\t&post_info,\n\t\t\t\t\tlen,\n\t\t\t\t\t&res.map(|_| ()).map_err(|e| e.error),\n\t\t\t\t)?;\n\t\t\t\tOk(res)\n\t\t\t}\n\t\t\tCheckedSignature::SelfContained(signed_info) => {\n\t\t\t\tOk(self.function.apply_self_contained(signed_info).ok_or(\n\t\t\t\t\tTransactionValidityError::Invalid(InvalidTransaction::BadProof),\n\t\t\t\t)?)\n\t\t\t}\n\t\t}\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nmod checked_extrinsic;\nmod unchecked_extrinsic;\n\npub use crate::{\n\tchecked_extrinsic::{CheckedExtrinsic, CheckedSignature},\n\tunchecked_extrinsic::UncheckedExtrinsic,\n};\n\nuse sp_runtime::{\n\ttraits::{Dispatchable, PostDispatchInfoOf},\n\ttransaction_validity::{TransactionValidity, TransactionValidityError},\n};\n\n/// A call that has self-contained functions. A self-contained\n/// function is something that has its signature embedded in its call.\npub trait SelfContainedCall: Dispatchable {\n\t/// Validated signature info.\n\ttype SignedInfo;\n\n\t/// Returns whether the current call is a self-contained function.\n\tfn is_self_contained(&self) -> bool;\n\t/// Check signatures of a self-contained function. Returns `None`\n\t/// if the function is not a self-contained.\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>>;\n\t/// Validate a self-contained function. Returns `None` if the\n\t/// function is not a self-contained.\n\tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity>;\n\t/// Apply a self-contained function. Returns `None` if the\n\t/// function is not a self-contained.\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>>;\n}\n", "//! The Substrate Node Template runtime. This can be compiled with `#[no_std]`, ready for Wasm.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nuse codec::{Decode, Encode};\nuse pallet_grandpa::{\n\tfg_primitives, AuthorityId as GrandpaId, AuthorityList as GrandpaAuthorityList,\n};\nuse sp_api::impl_runtime_apis;\nuse sp_consensus_aura::sr25519::AuthorityId as AuraId;\nuse sp_core::{\n\tcrypto::{KeyTypeId, Public},\n\tOpaqueMetadata, H160, H256, U256,\n};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdLookup, BlakeTwo256, Block as BlockT, Dispatchable, IdentifyAccount, NumberFor,\n\t\tPostDispatchInfoOf, Verify,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity, TransactionValidityError},\n\tApplyExtrinsicResult, MultiSignature,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\n// A few exports that help ease life for downstream crates.\nuse fp_rpc::TransactionStatus;\npub use frame_support::{\n\tconstruct_runtime, parameter_types,\n\ttraits::{FindAuthor, KeyOwnerProofSystem, Randomness},\n\tweights::{\n\t\tconstants::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight, WEIGHT_PER_SECOND},\n\t\tIdentityFee, Weight,\n\t},\n\tConsensusEngineId, StorageValue,\n};\npub use pallet_balances::Call as BalancesCall;\nuse pallet_ethereum::{Call::transact, Transaction as EthereumTransaction};\nuse pallet_evm::{Account as EVMAccount, EnsureAddressTruncated, HashedAddressMapping, Runner};\npub use pallet_timestamp::Call as TimestampCall;\nuse pallet_transaction_payment::CurrencyAdapter;\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\npub use sp_runtime::{Perbill, Permill};\n\n/// Type of block number.\npub type BlockNumber = u32;\n\n/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n/// Some way of identifying an account on the chain. We intentionally make it equivalent\n/// to the public key of our transaction signing scheme.\npub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;\n\n/// The type for looking up accounts. We don't expect more than 4 billion of them, but you\n/// never know...\npub type AccountIndex = u32;\n\n/// Balance of an account.\npub type Balance = u128;\n\n/// Index of a transaction in the chain.\npub type Index = u32;\n\n/// A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n/// Digest item type.\npub type DigestItem = generic::DigestItem<Hash>;\n\n/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know\n/// the specifics of the runtime. They can then be made to be agnostic over specific formats\n/// of data like extrinsics, allowing for them to continue syncing the network through upgrades\n/// to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\n\t/// Opaque block header type.\n\tpub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// Opaque block type.\n\tpub type Block = generic::Block<Header, UncheckedExtrinsic>;\n\t/// Opaque block identifier type.\n\tpub type BlockId = generic::BlockId<Block>;\n\n\timpl_opaque_keys! {\n\t\tpub struct SessionKeys {\n\t\t\tpub aura: Aura,\n\t\t\tpub grandpa: Grandpa,\n\t\t}\n\t}\n}\n\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"node-frontier-template\"),\n\timpl_name: create_runtime_str!(\"node-frontier-template\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 1,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n};\n\npub const MILLISECS_PER_BLOCK: u64 = 6000;\n\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -> NativeVersion {\n\tNativeVersion {\n\t\truntime_version: VERSION,\n\t\tcan_author_with: Default::default(),\n\t}\n}\n\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\tpub const BlockHashCount: BlockNumber = 256;\n\t/// We allow for 2 seconds of compute with a 6 second average block time.\n\tpub BlockWeights: frame_system::limits::BlockWeights = frame_system::limits::BlockWeights\n\t\t::with_sensible_defaults(2 * WEIGHT_PER_SECOND, NORMAL_DISPATCH_RATIO);\n\tpub BlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength\n\t\t::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub const SS58Prefix: u8 = 42;\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\t/// Block & extrinsics weights: base values and limits.\n\ttype BlockWeights = BlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = BlockLength;\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype Call = Call;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup<AccountId, ()>;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\t/// The ubiquitous origin type.\n\ttype Origin = Origin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// Version of the runtime.\n\ttype Version = Version;\n\t/// Converts a module to the index of the module in `construct_runtime!`.\n\t///\n\t/// This type is being generated by `construct_runtime!`.\n\ttype PalletInfo = PalletInfo;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData<Balance>;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// This is used as an identifier of the chain. 42 is the generic substrate prefix.\n\ttype SS58Prefix = SS58Prefix;\n\t/// The set code logic, just the default since we're not a parachain.\n\ttype OnSetCode = ();\n}\n\nparameter_types! {\n\tpub const MaxAuthorities: u32 = 100;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nimpl pallet_grandpa::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n\n\ttype KeyOwnerProofSystem = ();\n\n\ttype KeyOwnerProof =\n\t\t<Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(KeyTypeId, GrandpaId)>>::Proof;\n\n\ttype KeyOwnerIdentification = <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(\n\t\tKeyTypeId,\n\t\tGrandpaId,\n\t)>>::IdentificationTuple;\n\n\ttype HandleEquivocation = ();\n\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n\t#[cfg(feature = \"aura\")]\n\ttype OnTimestampSet = Aura;\n\t#[cfg(feature = \"manual-seal\")]\n\ttype OnTimestampSet = ();\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: u128 = 500;\n\t// For weight estimation, we assume that the most locks on an individual account will be 50.\n\t// This number may need to be adjusted in the future if this assumption no longer holds true.\n\tpub const MaxLocks: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = [u8; 8];\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 1;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype OnChargeTransaction = CurrencyAdapter<Balances, ()>;\n\ttype TransactionByteFee = TransactionByteFee;\n\ttype WeightToFee = IdentityFee<Balance>;\n\ttype FeeMultiplierUpdate = ();\n}\n\nimpl pallet_sudo::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n}\n\npub struct FindAuthorTruncated<F>(PhantomData<F>);\nimpl<F: FindAuthor<u32>> FindAuthor<H160> for FindAuthorTruncated<F> {\n\tfn find_author<'a, I>(digests: I) -> Option<H160>\n\twhere\n\t\tI: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,\n\t{\n\t\tif let Some(author_index) = F::find_author(digests) {\n\t\t\tlet authority_id = Aura::authorities()[author_index as usize].clone();\n\t\t\treturn Some(H160::from_slice(&authority_id.to_raw_vec()[4..24]));\n\t\t}\n\t\tNone\n\t}\n}\n\nparameter_types! {\n\tpub const ChainId: u64 = 42;\n\tpub BlockGasLimit: U256 = U256::from(u32::max_value());\n}\n\nimpl pallet_evm::Config for Runtime {\n\ttype FeeCalculator = pallet_dynamic_fee::Pallet<Self>;\n\ttype GasWeightMapping = ();\n\ttype BlockHashMapping = pallet_ethereum::EthereumBlockHashMapping<Self>;\n\ttype CallOrigin = EnsureAddressTruncated;\n\ttype WithdrawOrigin = EnsureAddressTruncated;\n\ttype AddressMapping = HashedAddressMapping<BlakeTwo256>;\n\ttype Currency = Balances;\n\ttype Event = Event;\n\ttype Runner = pallet_evm::runner::stack::Runner<Self>;\n\ttype Precompiles = (\n\t\tpallet_evm_precompile_simple::ECRecover,\n\t\tpallet_evm_precompile_simple::Sha256,\n\t\tpallet_evm_precompile_simple::Ripemd160,\n\t\tpallet_evm_precompile_simple::Identity,\n\t\tpallet_evm_precompile_modexp::Modexp,\n\t\tpallet_evm_precompile_simple::ECRecoverPublicKey,\n\t\tpallet_evm_precompile_sha3fips::Sha3FIPS256,\n\t\tpallet_evm_precompile_sha3fips::Sha3FIPS512,\n\t);\n\ttype ChainId = ChainId;\n\ttype BlockGasLimit = BlockGasLimit;\n\ttype OnChargeTransaction = ();\n\ttype FindAuthor = FindAuthorTruncated<Aura>;\n}\n\nimpl pallet_ethereum::Config for Runtime {\n\ttype Event = Event;\n\ttype StateRoot = pallet_ethereum::IntermediateStateRoot;\n}\n\nframe_support::parameter_types! {\n\tpub BoundDivision: U256 = U256::from(1024);\n}\n\nimpl pallet_dynamic_fee::Config for Runtime {\n\ttype MinGasPriceBoundDivisor = BoundDivision;\n}\n\nimpl pallet_randomness_collective_flip::Config for Runtime {}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event<T>},\n\t\tRandomnessCollectiveFlip: pallet_randomness_collective_flip::{Pallet, Storage},\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent},\n\t\tAura: pallet_aura::{Pallet, Config<T>},\n\t\tGrandpa: pallet_grandpa::{Pallet, Call, Storage, Config, Event},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage},\n\t\tSudo: pallet_sudo::{Pallet, Call, Config<T>, Storage, Event<T>},\n\t\tEthereum: pallet_ethereum::{Pallet, Call, Storage, Event, Config, Origin},\n\t\tEVM: pallet_evm::{Pallet, Config, Call, Storage, Event<T>},\n\t\tDynamicFee: pallet_dynamic_fee::{Pallet, Call, Storage, Config, Inherent},\n\t}\n);\n\npub struct TransactionConverter;\n\nimpl fp_rpc::ConvertTransaction<UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(&self, transaction: pallet_ethereum::Transaction) -> UncheckedExtrinsic {\n\t\tUncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact(transaction).into(),\n\t\t)\n\t}\n}\n\nimpl fp_rpc::ConvertTransaction<opaque::UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(\n\t\t&self,\n\t\ttransaction: pallet_ethereum::Transaction,\n\t) -> opaque::UncheckedExtrinsic {\n\t\tlet extrinsic = UncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact(transaction).into(),\n\t\t);\n\t\tlet encoded = extrinsic.encode();\n\t\topaque::UncheckedExtrinsic::decode(&mut &encoded[..])\n\t\t\t.expect(\"Encoded extrinsic is always valid\")\n\t}\n}\n\n/// The address format for describing accounts.\npub type Address = sp_runtime::MultiAddress<AccountId, ()>;\n/// Block header type as expected by this runtime.\npub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n/// Block type as expected by this runtime.\npub type Block = generic::Block<Header, UncheckedExtrinsic>;\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock<Block>;\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId<Block>;\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckSpecVersion<Runtime>,\n\tframe_system::CheckTxVersion<Runtime>,\n\tframe_system::CheckGenesis<Runtime>,\n\tframe_system::CheckEra<Runtime>,\n\tframe_system::CheckNonce<Runtime>,\n\tframe_system::CheckWeight<Runtime>,\n\tpallet_transaction_payment::ChargeTransactionPayment<Runtime>,\n);\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tfp_self_contained::UncheckedExtrinsic<Address, Call, Signature, SignedExtra>;\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = fp_self_contained::CheckedExtrinsic<AccountId, Call, SignedExtra, H160>;\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive<\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext<Runtime>,\n\tRuntime,\n\tAllPallets,\n>;\n\nimpl fp_self_contained::SelfContainedCall for Call {\n\ttype SignedInfo = H160;\n\n\tfn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.is_self_contained(),\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.check_self_contained(),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.validate_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>> {\n\t\tmatch self {\n\t\t\tcall @ Call::Ethereum(pallet_ethereum::Call::transact(_)) => Some(call.dispatch(\n\t\t\t\tOrigin::from(pallet_ethereum::RawOrigin::EthereumTransaction(info)),\n\t\t\t)),\n\t\t\t_ => None,\n\t\t}\n\t}\n}\n\nimpl_runtime_apis! {\n\timpl sp_api::Core<Block> for Runtime {\n\t\tfn version() -> RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata<Block> for Runtime {\n\t\tfn metadata() -> OpaqueMetadata {\n\t\t\tRuntime::metadata().into()\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder<Block> for Runtime {\n\t\tfn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -> <Block as BlockT>::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as BlockT>::Extrinsic> {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -> sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(&block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: <Block as BlockT>::Extrinsic,\n\t\t\tblock_hash: <Block as BlockT>::Hash,\n\t\t) -> TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi<Block> for Runtime {\n\t\tfn offchain_worker(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_consensus_aura::AuraApi<Block, AuraId> for Runtime {\n\t\tfn slot_duration() -> sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -> Vec<AuraId> {\n\t\t\tAura::authorities().to_vec()\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi<Block, AccountId, Index> for Runtime {\n\t\tfn account_nonce(account: AccountId) -> Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl fp_rpc::EthereumRuntimeRPCApi<Block> for Runtime {\n\t\tfn chain_id() -> u64 {\n\t\t\t<Runtime as pallet_evm::Config>::ChainId::get()\n\t\t}\n\n\t\tfn account_basic(address: H160) -> EVMAccount {\n\t\t\tEVM::account_basic(&address)\n\t\t}\n\n\t\tfn gas_price() -> U256 {\n\t\t\t<Runtime as pallet_evm::Config>::FeeCalculator::min_gas_price()\n\t\t}\n\n\t\tfn account_code_at(address: H160) -> Vec<u8> {\n\t\t\tEVM::account_codes(address)\n\t\t}\n\n\t\tfn author() -> H160 {\n\t\t\t<pallet_evm::Pallet<Runtime>>::find_author()\n\t\t}\n\n\t\tfn storage_at(address: H160, index: U256) -> H256 {\n\t\t\tlet mut tmp = [0u8; 32];\n\t\t\tindex.to_big_endian(&mut tmp);\n\t\t\tEVM::account_storages(address, H256::from_slice(&tmp[..]))\n\t\t}\n\n\t\tfn call(\n\t\t\tfrom: H160,\n\t\t\tto: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tgas_price: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t) -> Result<pallet_evm::CallInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\t<Runtime as pallet_evm::Config>::Runner::call(\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.low_u64(),\n\t\t\t\tgas_price,\n\t\t\t\tnonce,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.into())\n\t\t}\n\n\t\tfn create(\n\t\t\tfrom: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tgas_price: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t) -> Result<pallet_evm::CreateInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\t<Runtime as pallet_evm::Config>::Runner::create(\n\t\t\t\tfrom,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.low_u64(),\n\t\t\t\tgas_price,\n\t\t\t\tnonce,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.into())\n\t\t}\n\n\t\tfn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\t\tEthereum::current_transaction_statuses()\n\t\t}\n\n\t\tfn current_block() -> Option<pallet_ethereum::Block> {\n\t\t\tEthereum::current_block()\n\t\t}\n\n\t\tfn current_receipts() -> Option<Vec<pallet_ethereum::Receipt>> {\n\t\t\tEthereum::current_receipts()\n\t\t}\n\n\t\tfn current_all() -> (\n\t\t\tOption<pallet_ethereum::Block>,\n\t\t\tOption<Vec<pallet_ethereum::Receipt>>,\n\t\t\tOption<Vec<TransactionStatus>>\n\t\t) {\n\t\t\t(\n\t\t\t\tEthereum::current_block(),\n\t\t\t\tEthereum::current_receipts(),\n\t\t\t\tEthereum::current_transaction_statuses()\n\t\t\t)\n\t\t}\n\n\t\tfn extrinsic_filter(\n\t\t\txts: Vec<<Block as BlockT>::Extrinsic>,\n\t\t) -> Vec<EthereumTransaction> {\n\t\t\txts.into_iter().filter_map(|xt| match xt.0.function {\n\t\t\t\tCall::Ethereum(transact(t)) => Some(t),\n\t\t\t\t_ => None\n\t\t\t}).collect::<Vec<EthereumTransaction>>()\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<\n\t\tBlock,\n\t\tBalance,\n\t> for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32\n\t\t) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\n\t\tfn query_fee_details(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -> pallet_transaction_payment::FeeDetails<Balance> {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys<Block> for Runtime {\n\t\tfn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {\n\t\t\topaque::SessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec<u8>,\n\t\t) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {\n\t\t\topaque::SessionKeys::decode_into_raw_public_keys(&encoded)\n\t\t}\n\t}\n\n\timpl fg_primitives::GrandpaApi<Block> for Runtime {\n\t\tfn grandpa_authorities() -> GrandpaAuthorityList {\n\t\t\tGrandpa::grandpa_authorities()\n\t\t}\n\n\t\tfn current_set_id() -> fg_primitives::SetId {\n\t\t\tGrandpa::current_set_id()\n\t\t}\n\n\t\tfn submit_report_equivocation_unsigned_extrinsic(\n\t\t\t_equivocation_proof: fg_primitives::EquivocationProof<\n\t\t\t\t<Block as BlockT>::Hash,\n\t\t\t\tNumberFor<Block>,\n\t\t\t>,\n\t\t\t_key_owner_proof: fg_primitives::OpaqueKeyOwnershipProof,\n\t\t) -> Option<()> {\n\t\t\tNone\n\t\t}\n\n\t\tfn generate_key_ownership_proof(\n\t\t\t_set_id: fg_primitives::SetId,\n\t\t\t_authority_id: GrandpaId,\n\t\t) -> Option<fg_primitives::OpaqueKeyOwnershipProof> {\n\t\t\t// NOTE: this is the only implementation possible since we've\n\t\t\t// defined our key owner proof type as a bottom type (i.e. a type\n\t\t\t// with no values).\n\t\t\tNone\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark<Block> for Runtime {\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -> Result<Vec<frame_benchmarking::BenchmarkBatch>, sp_runtime::RuntimeString> {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkBatch, add_benchmark, TrackedStorageKey};\n\t\t\tuse pallet_evm::Module as PalletEvmBench;\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec<TrackedStorageKey> = vec![];\n\n\t\t\tlet mut batches = Vec::<BenchmarkBatch>::new();\n\t\t\tlet params = (&config, &whitelist);\n\n\t\t\tadd_benchmark!(params, batches, pallet_evm, PalletEvmBench::<Runtime>);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n"], "fixing_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Ethereum pallet\n//!\n//! The Ethereum pallet works together with EVM pallet to provide full emulation\n//! for Ethereum block processing.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse codec::{Decode, Encode};\nuse ethereum_types::{Bloom, BloomInput, H160, H256, H64, U256};\nuse evm::ExitReason;\nuse fp_consensus::{PostLog, PreLog, FRONTIER_ENGINE_ID};\nuse fp_evm::CallOrCreateInfo;\nuse fp_storage::PALLET_ETHEREUM_SCHEMA;\nuse frame_support::{\n\tdispatch::DispatchResultWithPostInfo,\n\tensure,\n\ttraits::{EnsureOrigin, Get},\n\tweights::{Pays, PostDispatchInfo, Weight},\n};\nuse frame_system::pallet_prelude::OriginFor;\nuse pallet_evm::{BlockHashMapping, FeeCalculator, GasWeightMapping, Runner};\nuse sha3::{Digest, Keccak256};\nuse sp_runtime::{\n\tgeneric::DigestItem,\n\ttraits::{One, Saturating, UniqueSaturatedInto, Zero},\n\ttransaction_validity::{\n\t\tInvalidTransaction, TransactionValidity, TransactionValidityError, ValidTransactionBuilder,\n\t},\n\tDispatchError, RuntimeDebug,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n\npub use ethereum::{\n\tBlockV0 as Block, LegacyTransactionMessage, Log, Receipt, TransactionAction,\n\tTransactionV0 as Transaction,\n};\npub use fp_rpc::TransactionStatus;\n\n#[cfg(all(feature = \"std\", test))]\nmod mock;\n#[cfg(all(feature = \"std\", test))]\nmod tests;\n\n#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug)]\npub enum RawOrigin {\n\tEthereumTransaction(H160),\n}\n\npub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,\n{\n\tmatch o.into() {\n\t\tOk(RawOrigin::EthereumTransaction(n)) => Ok(n),\n\t\t_ => Err(\"bad origin: expected to be an Ethereum transaction\"),\n\t}\n}\n\npub struct EnsureEthereumTransaction;\nimpl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>\n\tfor EnsureEthereumTransaction\n{\n\ttype Success = H160;\n\tfn try_origin(o: O) -> Result<Self::Success, O> {\n\t\to.into().and_then(|o| match o {\n\t\t\tRawOrigin::EthereumTransaction(id) => Ok(id),\n\t\t})\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\tfn successful_origin() -> O {\n\t\tO::from(RawOrigin::EthereumTransaction(Default::default()))\n\t}\n}\n\nimpl<T: Config> Call<T>\nwhere\n\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n{\n\tpub fn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::transact(_) => true,\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tpub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tlet check = || {\n\t\t\t\tlet origin = Pallet::<T>::recover_signer(&transaction).ok_or_else(|| {\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)\n\t\t\t\t})?;\n\n\t\t\t\tOk(origin)\n\t\t\t};\n\n\t\t\tSome(check())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn pre_dispatch_self_contained(\n\t\t&self,\n\t\torigin: &H160,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tSome(Pallet::<T>::validate_transaction_in_block(\n\t\t\t\t*origin,\n\t\t\t\t&transaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tSome(Pallet::<T>::validate_transaction_in_pool(\n\t\t\t\t*origin,\n\t\t\t\ttransaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\npub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config\n\t\t+ pallet_balances::Config\n\t\t+ pallet_timestamp::Config\n\t\t+ pallet_evm::Config\n\t{\n\t\t/// The overarching event type.\n\t\ttype Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;\n\t\t/// How Ethereum state root is calculated.\n\t\ttype StateRoot: Get<H256>;\n\t}\n\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\tpub struct Pallet<T>(PhantomData<T>);\n\n\t#[pallet::origin]\n\tpub type Origin = RawOrigin;\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_finalize(n: T::BlockNumber) {\n\t\t\t<Pallet<T>>::store_block(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tU256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(\n\t\t\t\t\tframe_system::Pallet::<T>::block_number(),\n\t\t\t\t)),\n\t\t\t);\n\t\t\t// move block hash pruning window by one block\n\t\t\tlet block_hash_count = T::BlockHashCount::get();\n\t\t\tlet to_remove = n\n\t\t\t\t.saturating_sub(block_hash_count)\n\t\t\t\t.saturating_sub(One::one());\n\t\t\t// keep genesis hash\n\t\t\tif !to_remove.is_zero() {\n\t\t\t\t<BlockHash<T>>::remove(U256::from(\n\t\t\t\t\tUniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tfn on_initialize(_: T::BlockNumber) -> Weight {\n\t\t\tPending::<T>::kill();\n\n\t\t\t// If the digest contain an existing ethereum block(encoded as PreLog), If contains,\n\t\t\t// execute the imported block firstly and disable transact dispatch function.\n\t\t\tif let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {\n\t\t\t\tlet PreLog::Block(block) = log;\n\n\t\t\t\tfor transaction in block.transactions {\n\t\t\t\t\tlet source = Self::recover_signer(&transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n\t\t\t\t\t);\n\n\t\t\t\t\tSelf::validate_transaction_in_block(source, &transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t\tSelf::apply_validated_transaction(source, transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction execution failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t0\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T>\n\twhere\n\t\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\t{\n\t\t/// Transact an Ethereum transaction.\n\t\t#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight(transaction.gas_limit.unique_saturated_into()))]\n\t\tpub fn transact(\n\t\t\torigin: OriginFor<T>,\n\t\t\ttransaction: Transaction,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tlet source = ensure_ethereum_transaction(origin)?;\n\t\t\t// Disable transact functionality if PreLog exist.\n\t\t\tensure!(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tError::<T>::PreLogExists,\n\t\t\t);\n\n\t\t\tSelf::apply_validated_transaction(source, transaction)\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event {\n\t\t/// An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]\n\t\tExecuted(H160, H160, H256, ExitReason),\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Signature is invalid.\n\t\tInvalidSignature,\n\t\t/// Pre-log is present, therefore transact is not allowed.\n\t\tPreLogExists,\n\t}\n\n\t/// Current building block's transactions and receipts.\n\t#[pallet::storage]\n\tpub(super) type Pending<T: Config> =\n\t\tStorageValue<_, Vec<(Transaction, TransactionStatus, ethereum::Receipt)>, ValueQuery>;\n\n\t/// The current Ethereum block.\n\t#[pallet::storage]\n\tpub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV0>;\n\n\t/// The current Ethereum receipts.\n\t#[pallet::storage]\n\tpub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<ethereum::Receipt>>;\n\n\t/// The current transaction statuses.\n\t#[pallet::storage]\n\tpub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;\n\n\t// Mapping for block number and hashes.\n\t#[pallet::storage]\n\tpub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;\n\n\t#[pallet::genesis_config]\n\t#[derive(Default)]\n\tpub struct GenesisConfig {}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig {\n\t\tfn build(&self) {\n\t\t\t<Pallet<T>>::store_block(false, U256::zero());\n\t\t\tframe_support::storage::unhashed::put::<EthereumStorageSchema>(\n\t\t\t\t&PALLET_ETHEREUM_SCHEMA,\n\t\t\t\t&EthereumStorageSchema::V1,\n\t\t\t);\n\t\t}\n\t}\n}\n\nimpl<T: Config> Pallet<T> {\n\tfn recover_signer(transaction: &Transaction) -> Option<H160> {\n\t\tlet mut sig = [0u8; 65];\n\t\tlet mut msg = [0u8; 32];\n\t\tsig[0..32].copy_from_slice(&transaction.signature.r()[..]);\n\t\tsig[32..64].copy_from_slice(&transaction.signature.s()[..]);\n\t\tsig[64] = transaction.signature.standard_v();\n\t\tmsg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);\n\n\t\tlet pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;\n\t\tSome(H160::from(H256::from_slice(\n\t\t\tKeccak256::digest(&pubkey).as_slice(),\n\t\t)))\n\t}\n\n\tfn store_block(post_log: bool, block_number: U256) {\n\t\tlet mut transactions = Vec::new();\n\t\tlet mut statuses = Vec::new();\n\t\tlet mut receipts = Vec::new();\n\t\tlet mut logs_bloom = Bloom::default();\n\t\tfor (transaction, status, receipt) in Pending::<T>::get() {\n\t\t\ttransactions.push(transaction);\n\t\t\tstatuses.push(status);\n\t\t\treceipts.push(receipt.clone());\n\t\t\tSelf::logs_bloom(receipt.logs.clone(), &mut logs_bloom);\n\t\t}\n\n\t\tlet ommers = Vec::<ethereum::Header>::new();\n\t\tlet receipts_root =\n\t\t\tethereum::util::ordered_trie_root(receipts.iter().map(|r| rlp::encode(r)));\n\t\tlet partial_header = ethereum::PartialHeader {\n\t\t\tparent_hash: Self::current_block_hash().unwrap_or_default(),\n\t\t\tbeneficiary: pallet_evm::Pallet::<T>::find_author(),\n\t\t\tstate_root: T::StateRoot::get(),\n\t\t\treceipts_root,\n\t\t\tlogs_bloom,\n\t\t\tdifficulty: U256::zero(),\n\t\t\tnumber: block_number,\n\t\t\tgas_limit: T::BlockGasLimit::get(),\n\t\t\tgas_used: receipts\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.fold(U256::zero(), |acc, r| acc + r.used_gas),\n\t\t\ttimestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(\n\t\t\t\tpallet_timestamp::Pallet::<T>::get(),\n\t\t\t),\n\t\t\textra_data: Vec::new(),\n\t\t\tmix_hash: H256::default(),\n\t\t\tnonce: H64::default(),\n\t\t};\n\t\tlet block = ethereum::Block::new(partial_header, transactions.clone(), ommers);\n\n\t\tCurrentBlock::<T>::put(block.clone());\n\t\tCurrentReceipts::<T>::put(receipts.clone());\n\t\tCurrentTransactionStatuses::<T>::put(statuses.clone());\n\t\tBlockHash::<T>::insert(block_number, block.header.hash());\n\n\t\tif post_log {\n\t\t\tlet digest = DigestItem::<T::Hash>::Consensus(\n\t\t\t\tFRONTIER_ENGINE_ID,\n\t\t\t\tPostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),\n\t\t\t);\n\t\t\tframe_system::Pallet::<T>::deposit_log(digest.into());\n\t\t}\n\t}\n\n\tfn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {\n\t\tfor log in logs {\n\t\t\tbloom.accrue(BloomInput::Raw(&log.address[..]));\n\t\t\tfor topic in log.topics {\n\t\t\t\tbloom.accrue(BloomInput::Raw(&topic[..]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Common controls to be performed in the same way by the pool and the\n\t// State Transition Function (STF).\n\t// This is the case for all controls except those concerning the nonce.\n\tfn validate_transaction_common(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> Result<U256, TransactionValidityError> {\n\t\t// We must ensure a transaction can pay the cost of its data bytes.\n\t\t// If it can't it should not be included in a block.\n\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\ttransaction.gas_limit.low_u64(),\n\t\t\t<T as pallet_evm::Config>::config(),\n\t\t);\n\t\tlet transaction_cost = match transaction.action {\n\t\t\tTransactionAction::Call(_) => evm::gasometer::call_transaction_cost(&transaction.input),\n\t\t\tTransactionAction::Create => {\n\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n\t\t\t}\n\t\t};\n\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\n\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t)\n\t\t\t\t.into());\n\t\t\t}\n\t\t}\n\n\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\n\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n\n\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n\t\tlet total_payment = transaction.value.saturating_add(fee);\n\t\tif account_data.balance < total_payment {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\n\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n\n\t\tif transaction.gas_price < min_gas_price {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\n\t\tOk(account_data.nonce)\n\t}\n\n\t// Controls that must be performed by the pool.\n\t// The controls common with the State Transition Function (STF) are in\n\t// the function `validate_transaction_common`.\n\tfn validate_transaction_in_pool(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> TransactionValidity {\n\t\tlet account_nonce = Self::validate_transaction_common(origin, transaction)?;\n\n\t\tif transaction.nonce < account_nonce {\n\t\t\treturn Err(InvalidTransaction::Stale.into());\n\t\t}\n\n\t\t// The tag provides and requires must be filled correctly according to the nonce.\n\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t.and_provides((origin, transaction.nonce))\n\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n\n\t\t// In the context of the pool, a transaction with\n\t\t// too high a nonce is still considered valid\n\t\tif transaction.nonce > account_nonce {\n\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t}\n\t\t}\n\n\t\tbuilder.build()\n\t}\n\n\tfn apply_validated_transaction(\n\t\tsource: H160,\n\t\ttransaction: Transaction,\n\t) -> DispatchResultWithPostInfo {\n\t\tlet transaction_hash =\n\t\t\tH256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());\n\t\tlet transaction_index = Pending::<T>::get().len() as u32;\n\n\t\tlet (to, _, info) = Self::execute(\n\t\t\tsource,\n\t\t\ttransaction.input.clone(),\n\t\t\ttransaction.value,\n\t\t\ttransaction.gas_limit,\n\t\t\tSome(transaction.gas_price),\n\t\t\tSome(transaction.nonce),\n\t\t\ttransaction.action,\n\t\t\tNone,\n\t\t)?;\n\n\t\tlet (reason, status, used_gas, dest) = match info {\n\t\t\tCallOrCreateInfo::Call(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: None,\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tto,\n\t\t\t),\n\t\t\tCallOrCreateInfo::Create(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: Some(info.value),\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tSome(info.value),\n\t\t\t),\n\t\t};\n\n\t\tlet receipt = ethereum::Receipt {\n\t\t\tstate_root: match reason {\n\t\t\t\tExitReason::Succeed(_) => H256::from_low_u64_be(1),\n\t\t\t\tExitReason::Error(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Revert(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Fatal(_) => H256::from_low_u64_le(0),\n\t\t\t},\n\t\t\tused_gas,\n\t\t\tlogs_bloom: status.clone().logs_bloom,\n\t\t\tlogs: status.clone().logs,\n\t\t};\n\n\t\tPending::<T>::append((transaction, status, receipt));\n\n\t\tSelf::deposit_event(Event::Executed(\n\t\t\tsource,\n\t\t\tdest.unwrap_or_default(),\n\t\t\ttransaction_hash,\n\t\t\treason,\n\t\t));\n\t\tOk(PostDispatchInfo {\n\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\tused_gas.unique_saturated_into(),\n\t\t\t)),\n\t\t\tpays_fee: Pays::No,\n\t\t})\n\t\t.into()\n\t}\n\n\t/// Get the transaction status with given index.\n\tpub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\tCurrentTransactionStatuses::<T>::get()\n\t}\n\n\t/// Get current block.\n\tpub fn current_block() -> Option<ethereum::BlockV0> {\n\t\tCurrentBlock::<T>::get()\n\t}\n\n\t/// Get current block hash\n\tpub fn current_block_hash() -> Option<H256> {\n\t\tSelf::current_block().map(|block| block.header.hash())\n\t}\n\n\t/// Get receipts by number.\n\tpub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {\n\t\tCurrentReceipts::<T>::get()\n\t}\n\n\t/// Execute an Ethereum transaction.\n\tpub fn execute(\n\t\tfrom: H160,\n\t\tinput: Vec<u8>,\n\t\tvalue: U256,\n\t\tgas_limit: U256,\n\t\tgas_price: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taction: TransactionAction,\n\t\tconfig: Option<evm::Config>,\n\t) -> Result<(Option<H160>, Option<H160>, CallOrCreateInfo), DispatchError> {\n\t\tmatch action {\n\t\t\tethereum::TransactionAction::Call(target) => {\n\t\t\t\tlet res = T::Runner::call(\n\t\t\t\t\tfrom,\n\t\t\t\t\ttarget,\n\t\t\t\t\tinput.clone(),\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tgas_price,\n\t\t\t\t\tnonce,\n\t\t\t\t\tconfig.as_ref().unwrap_or(T::config()),\n\t\t\t\t)\n\t\t\t\t.map_err(Into::into)?;\n\n\t\t\t\tOk((Some(target), None, CallOrCreateInfo::Call(res)))\n\t\t\t}\n\t\t\tethereum::TransactionAction::Create => {\n\t\t\t\tlet res = T::Runner::create(\n\t\t\t\t\tfrom,\n\t\t\t\t\tinput.clone(),\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tgas_price,\n\t\t\t\t\tnonce,\n\t\t\t\t\tconfig.as_ref().unwrap_or(T::config()),\n\t\t\t\t)\n\t\t\t\t.map_err(Into::into)?;\n\n\t\t\t\tOk((None, Some(res.value), CallOrCreateInfo::Create(res)))\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Validate an Ethereum transaction already in block\n\t///\n\t/// This function must be called during the pre-dispatch phase\n\t/// (just before applying the extrinsic).\n\tpub fn validate_transaction_in_block(\n\t\torigin: H160,\n\t\ttransaction: &ethereum::TransactionV0,\n\t) -> Result<(), TransactionValidityError> {\n\t\tlet account_nonce = Self::validate_transaction_common(origin, transaction)?;\n\n\t\t// In the context of the block, a transaction with a nonce that is\n\t\t// too high should be considered invalid and make the whole block invalid.\n\t\tif transaction.nonce > account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(\n\t\t\t\tInvalidTransaction::Future,\n\t\t\t))\n\t\t} else if transaction.nonce < account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(InvalidTransaction::Stale))\n\t\t} else {\n\t\t\tOk(())\n\t\t}\n\t}\n}\n\n#[derive(Eq, PartialEq, Clone, sp_runtime::RuntimeDebug)]\npub enum ReturnValue {\n\tBytes(Vec<u8>),\n\tHash(H160),\n}\n\n/// The schema version for Pallet Ethereum's storage\n#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, PartialOrd, Ord)]\npub enum EthereumStorageSchema {\n\tUndefined,\n\tV1,\n}\n\nimpl Default for EthereumStorageSchema {\n\tfn default() -> Self {\n\t\tSelf::Undefined\n\t}\n}\n\npub struct IntermediateStateRoot;\nimpl Get<H256> for IntermediateStateRoot {\n\tfn get() -> H256 {\n\t\tH256::decode(&mut &sp_io::storage::root()[..])\n\t\t\t.expect(\"Node is configured to use the same hash; qed\")\n\t}\n}\n\n/// Returns the Ethereum block hash by number.\npub struct EthereumBlockHashMapping<T>(PhantomData<T>);\nimpl<T: Config> BlockHashMapping for EthereumBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tBlockHash::<T>::get(U256::from(number))\n\t}\n}\n\n#[repr(u8)]\nenum TransactionValidationError {\n\t#[allow(dead_code)]\n\tUnknownError,\n\tInvalidChainId,\n\tInvalidSignature,\n\tInvalidGasLimit,\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Test utilities\n\nuse super::*;\nuse crate::IntermediateStateRoot;\nuse codec::{WrapperTypeDecode, WrapperTypeEncode};\nuse ethereum::{TransactionAction, TransactionSignature};\nuse frame_support::{parameter_types, traits::FindAuthor, ConsensusEngineId, PalletId};\nuse pallet_evm::{AddressMapping, EnsureAddressTruncated, FeeCalculator};\nuse rlp::*;\nuse sha3::Digest;\nuse sp_core::{H160, H256, U256};\nuse sp_runtime::{\n\ttesting::Header,\n\ttraits::{BlakeTwo256, IdentityLookup, SignedExtension},\n\tAccountId32,\n};\n\npub type SignedExtra = (frame_system::CheckSpecVersion<Test>,);\n\ntype UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic<Test, (), SignedExtra>;\ntype Block = frame_system::mocking::MockBlock<Test>;\n\nframe_support::construct_runtime! {\n\tpub enum Test where\n\t\tBlock = Block,\n\t\tNodeBlock = Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event<T>},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage},\n\t\tEVM: pallet_evm::{Pallet, Call, Storage, Config, Event<T>},\n\t\tEthereum: crate::{Pallet, Call, Storage, Event, Origin},\n\t}\n}\n\nparameter_types! {\n\tpub const BlockHashCount: u64 = 250;\n\tpub BlockWeights: frame_system::limits::BlockWeights =\n\t\tframe_system::limits::BlockWeights::simple_max(1024);\n}\n\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype Origin = Origin;\n\ttype Index = u64;\n\ttype BlockNumber = u64;\n\ttype Hash = H256;\n\ttype Call = Call;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = AccountId32;\n\ttype Lookup = IdentityLookup<Self::AccountId>;\n\ttype Header = Header;\n\ttype Event = Event;\n\ttype BlockHashCount = BlockHashCount;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = pallet_balances::AccountData<u64>;\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = ();\n\ttype OnSetCode = ();\n}\n\nparameter_types! {\n\t// For weight estimation, we assume that the most locks on an individual account will be 50.\n\t// This number may need to be adjusted in the future if this assumption no longer holds true.\n\tpub const MaxLocks: u32 = 50;\n\tpub const ExistentialDeposit: u64 = 500;\n}\n\nimpl pallet_balances::Config for Test {\n\ttype MaxLocks = MaxLocks;\n\ttype Balance = u64;\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = 6000 / 2;\n}\n\nimpl pallet_timestamp::Config for Test {\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\npub struct FixedGasPrice;\nimpl FeeCalculator for FixedGasPrice {\n\tfn min_gas_price() -> U256 {\n\t\t1.into()\n\t}\n}\n\npub struct FindAuthorTruncated;\nimpl FindAuthor<H160> for FindAuthorTruncated {\n\tfn find_author<'a, I>(_digests: I) -> Option<H160>\n\twhere\n\t\tI: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,\n\t{\n\t\tSome(address_build(0).address)\n\t}\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: u64 = 1;\n\tpub const ChainId: u64 = 42;\n\tpub const EVMModuleId: PalletId = PalletId(*b\"py/evmpa\");\n\tpub const BlockGasLimit: U256 = U256::MAX;\n}\n\npub struct HashedAddressMapping;\n\nimpl AddressMapping<AccountId32> for HashedAddressMapping {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 32];\n\t\tdata[0..20].copy_from_slice(&address[..]);\n\t\tAccountId32::from(Into::<[u8; 32]>::into(data))\n\t}\n}\n\nimpl pallet_evm::Config for Test {\n\ttype FeeCalculator = FixedGasPrice;\n\ttype GasWeightMapping = ();\n\ttype CallOrigin = EnsureAddressTruncated;\n\ttype WithdrawOrigin = EnsureAddressTruncated;\n\ttype AddressMapping = HashedAddressMapping;\n\ttype Currency = Balances;\n\ttype Event = Event;\n\ttype Precompiles = ();\n\ttype Runner = pallet_evm::runner::stack::Runner<Self>;\n\ttype ChainId = ChainId;\n\ttype BlockGasLimit = BlockGasLimit;\n\ttype OnChargeTransaction = ();\n\ttype FindAuthor = FindAuthorTruncated;\n\ttype BlockHashMapping = crate::EthereumBlockHashMapping<Self>;\n}\n\nimpl crate::Config for Test {\n\ttype Event = Event;\n\ttype StateRoot = IntermediateStateRoot;\n}\n\nimpl fp_self_contained::SelfContainedCall for Call {\n\ttype SignedInfo = H160;\n\n\tfn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.is_self_contained(),\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.check_self_contained(),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.validate_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn pre_dispatch_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.pre_dispatch_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<sp_runtime::traits::PostDispatchInfoOf<Self>>> {\n\t\tuse sp_runtime::traits::Dispatchable as _;\n\t\tmatch self {\n\t\t\tcall @ Call::Ethereum(crate::Call::transact(_)) => {\n\t\t\t\tSome(call.dispatch(Origin::from(crate::RawOrigin::EthereumTransaction(info))))\n\t\t\t}\n\t\t\t_ => None,\n\t\t}\n\t}\n}\n\npub struct AccountInfo {\n\tpub address: H160,\n\tpub account_id: AccountId32,\n\tpub private_key: H256,\n}\n\nfn address_build(seed: u8) -> AccountInfo {\n\tlet private_key = H256::from_slice(&[(seed + 1) as u8; 32]); //H256::from_low_u64_be((i + 1) as u64);\n\tlet secret_key = libsecp256k1::SecretKey::parse_slice(&private_key[..]).unwrap();\n\tlet public_key = &libsecp256k1::PublicKey::from_secret_key(&secret_key).serialize()[1..65];\n\tlet address = H160::from(H256::from_slice(&Keccak256::digest(public_key)[..]));\n\n\tlet mut data = [0u8; 32];\n\tdata[0..20].copy_from_slice(&address[..]);\n\n\tAccountInfo {\n\t\tprivate_key,\n\t\taccount_id: AccountId32::from(Into::<[u8; 32]>::into(data)),\n\t\taddress,\n\t}\n}\n\n// This function basically just builds a genesis storage key/value store according to\n// our desired mockup.\npub fn new_test_ext(accounts_len: usize) -> (Vec<AccountInfo>, sp_io::TestExternalities) {\n\t// sc_cli::init_logger(\"\");\n\tlet mut ext = frame_system::GenesisConfig::default()\n\t\t.build_storage::<Test>()\n\t\t.unwrap();\n\n\tlet pairs = (0..accounts_len)\n\t\t.map(|i| address_build(i as u8))\n\t\t.collect::<Vec<_>>();\n\n\tlet balances: Vec<_> = (0..accounts_len)\n\t\t.map(|i| (pairs[i].account_id.clone(), 10_000_000))\n\t\t.collect();\n\n\tpallet_balances::GenesisConfig::<Test> { balances }\n\t\t.assimilate_storage(&mut ext)\n\t\t.unwrap();\n\n\t(pairs, ext.into())\n}\n\npub fn contract_address(sender: H160, nonce: u64) -> H160 {\n\tlet mut rlp = RlpStream::new_list(2);\n\trlp.append(&sender);\n\trlp.append(&nonce);\n\n\tH160::from_slice(&Keccak256::digest(&rlp.out())[12..])\n}\n\npub fn storage_address(sender: H160, slot: H256) -> H256 {\n\tH256::from_slice(&Keccak256::digest(\n\t\t[&H256::from(sender)[..], &slot[..]].concat().as_slice(),\n\t))\n}\n\npub struct UnsignedTransaction {\n\tpub nonce: U256,\n\tpub gas_price: U256,\n\tpub gas_limit: U256,\n\tpub action: TransactionAction,\n\tpub value: U256,\n\tpub input: Vec<u8>,\n}\n\nimpl UnsignedTransaction {\n\tfn signing_rlp_append(&self, s: &mut RlpStream) {\n\t\ts.begin_list(9);\n\t\ts.append(&self.nonce);\n\t\ts.append(&self.gas_price);\n\t\ts.append(&self.gas_limit);\n\t\ts.append(&self.action);\n\t\ts.append(&self.value);\n\t\ts.append(&self.input);\n\t\ts.append(&ChainId::get());\n\t\ts.append(&0u8);\n\t\ts.append(&0u8);\n\t}\n\n\tfn signing_hash(&self) -> H256 {\n\t\tlet mut stream = RlpStream::new();\n\t\tself.signing_rlp_append(&mut stream);\n\t\tH256::from_slice(&Keccak256::digest(&stream.out()).as_slice())\n\t}\n\n\tpub fn sign(&self, key: &H256) -> Transaction {\n\t\tself.sign_with_chain_id(key, ChainId::get())\n\t}\n\n\tpub fn sign_with_chain_id(&self, key: &H256, chain_id: u64) -> Transaction {\n\t\tlet hash = self.signing_hash();\n\t\tlet msg = libsecp256k1::Message::parse(hash.as_fixed_bytes());\n\t\tlet s = libsecp256k1::sign(\n\t\t\t&msg,\n\t\t\t&libsecp256k1::SecretKey::parse_slice(&key[..]).unwrap(),\n\t\t);\n\t\tlet sig = s.0.serialize();\n\n\t\tlet sig = TransactionSignature::new(\n\t\t\ts.1.serialize() as u64 % 2 + chain_id * 2 + 35,\n\t\t\tH256::from_slice(&sig[0..32]),\n\t\t\tH256::from_slice(&sig[32..64]),\n\t\t)\n\t\t.unwrap();\n\n\t\tTransaction {\n\t\t\tnonce: self.nonce,\n\t\t\tgas_price: self.gas_price,\n\t\t\tgas_limit: self.gas_limit,\n\t\t\taction: self.action,\n\t\t\tvalue: self.value,\n\t\t\tinput: self.input.clone(),\n\t\t\tsignature: sig,\n\t\t}\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Consensus extension module tests for BABE consensus.\n\nuse crate::{\n\tmock::*, CallOrCreateInfo, Error, RawOrigin, Transaction, TransactionAction, H160, H256, U256,\n};\nuse ethereum::TransactionSignature;\nuse frame_support::{\n\tassert_err, assert_noop, assert_ok,\n\tunsigned::{TransactionValidityError, ValidateUnsigned},\n};\nuse rustc_hex::{FromHex, ToHex};\nuse sp_runtime::traits::Applyable;\nuse sp_runtime::transaction_validity::{\n\tInvalidTransaction, TransactionSource, ValidTransactionBuilder,\n};\nuse std::str::FromStr;\n\n// This ERC-20 contract mints the maximum amount of tokens to the contract creator.\n// pragma solidity ^0.5.0;`\n// import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/token/ERC20/ERC20.sol\";\n// contract MyToken is ERC20 {\n//\t constructor() public { _mint(msg.sender, 2**256 - 1); }\n// }\nconst ERC20_CONTRACT_BYTECODE: &str = include_str!(\"../res/erc20_contract_bytecode.txt\");\n\nfn default_erc20_creation_unsigned_transaction() -> UnsignedTransaction {\n\tUnsignedTransaction {\n\t\tnonce: U256::zero(),\n\t\tgas_price: U256::from(1),\n\t\tgas_limit: U256::from(0x100000),\n\t\taction: ethereum::TransactionAction::Create,\n\t\tvalue: U256::zero(),\n\t\tinput: FromHex::from_hex(ERC20_CONTRACT_BYTECODE).unwrap(),\n\t}\n}\n\nfn default_erc20_creation_transaction(account: &AccountInfo) -> Transaction {\n\tdefault_erc20_creation_unsigned_transaction().sign(&account.private_key)\n}\n\n#[test]\nfn transaction_should_increment_nonce() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\tassert_eq!(EVM::account_basic(&alice.address).nonce, U256::from(1));\n\t});\n}\n\n#[test]\nfn transaction_without_enough_gas_should_not_work() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet mut transaction = default_erc20_creation_transaction(alice);\n\t\ttransaction.gas_price = U256::from(11_000_000);\n\n\t\tlet call = crate::Call::<Test>::transact(transaction);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\n\t\tassert_err!(\n\t\t\tcall.validate_self_contained(&source).unwrap(),\n\t\t\tInvalidTransaction::Payment\n\t\t);\n\t});\n}\n\n#[test]\nfn transaction_with_to_low_nonce_should_not_work() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\t// nonce is 0\n\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n\t\ttransaction.nonce = U256::from(1);\n\n\t\tlet signed = transaction.sign(&alice.private_key);\n\t\tlet call = crate::Call::<Test>::transact(signed);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\n\t\tassert_eq!(\n\t\t\tcall.validate_self_contained(&source).unwrap(),\n\t\t\tValidTransactionBuilder::default()\n\t\t\t\t.and_provides((alice.address, U256::from(1)))\n\t\t\t\t.priority(1u64)\n\t\t\t\t.and_requires((alice.address, U256::from(0)))\n\t\t\t\t.build()\n\t\t);\n\n\t\tlet t = default_erc20_creation_transaction(alice);\n\n\t\t// nonce is 1\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\n\t\ttransaction.nonce = U256::from(0);\n\n\t\tlet signed2 = transaction.sign(&alice.private_key);\n\t\tlet call2 = crate::Call::<Test>::transact(signed2);\n\t\tlet source2 = call2.check_self_contained().unwrap().unwrap();\n\n\t\tassert_err!(\n\t\t\tcall2.validate_self_contained(&source2).unwrap(),\n\t\t\tInvalidTransaction::Stale\n\t\t);\n\t});\n}\n\n#[test]\nfn transaction_with_to_hight_nonce_should_fail_in_block() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n\t\ttransaction.nonce = U256::one();\n\n\t\tlet signed = transaction.sign(&alice.private_key);\n\t\tlet call = crate::Call::<Test>::transact(signed);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\t\tlet extrinsic = fp_self_contained::CheckedExtrinsic::<_, _, SignedExtra, _> {\n\t\t\tsigned: fp_self_contained::CheckedSignature::SelfContained(source),\n\t\t\tfunction: Call::Ethereum(call),\n\t\t};\n\t\tuse frame_support::weights::GetDispatchInfo as _;\n\t\tlet dispatch_info = extrinsic.get_dispatch_info();\n\t\tassert_err!(\n\t\t\textrinsic.apply::<Test>(&dispatch_info, 0),\n\t\t\tTransactionValidityError::Invalid(InvalidTransaction::Future)\n\t\t);\n\t});\n}\n\n#[test]\nfn transaction_with_invalid_chain_id_should_fail_in_block() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet transaction =\n\t\t\tdefault_erc20_creation_unsigned_transaction().sign_with_chain_id(&alice.private_key, 1);\n\n\t\tlet call = crate::Call::<Test>::transact(transaction);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\t\tlet extrinsic = fp_self_contained::CheckedExtrinsic::<_, _, SignedExtra, _> {\n\t\t\tsigned: fp_self_contained::CheckedSignature::SelfContained(source),\n\t\t\tfunction: Call::Ethereum(call),\n\t\t};\n\t\tuse frame_support::weights::GetDispatchInfo as _;\n\t\tlet dispatch_info = extrinsic.get_dispatch_info();\n\t\tassert_err!(\n\t\t\textrinsic.apply::<Test>(&dispatch_info, 0),\n\t\t\tTransactionValidityError::Invalid(InvalidTransaction::Custom(\n\t\t\t\tcrate::TransactionValidationError::InvalidChainId as u8,\n\t\t\t))\n\t\t);\n\t});\n}\n\n#[test]\nfn contract_constructor_should_get_executed() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\tlet erc20_address = contract_address(alice.address, 0);\n\tlet alice_storage_address = storage_address(alice.address, H256::zero());\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\tassert_eq!(\n\t\t\tEVM::account_storages(erc20_address, alice_storage_address),\n\t\t\tH256::from_str(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")\n\t\t\t\t.unwrap()\n\t\t)\n\t});\n}\n\n#[test]\nfn source_should_be_derived_from_signature() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\tlet erc20_address = contract_address(alice.address, 0);\n\tlet alice_storage_address = storage_address(alice.address, H256::zero());\n\n\text.execute_with(|| {\n\t\tEthereum::transact(\n\t\t\tRawOrigin::EthereumTransaction(alice.address).into(),\n\t\t\tdefault_erc20_creation_transaction(alice),\n\t\t)\n\t\t.expect(\"Failed to execute transaction\");\n\n\t\t// We verify the transaction happened with alice account.\n\t\tassert_eq!(\n\t\t\tEVM::account_storages(erc20_address, alice_storage_address),\n\t\t\tH256::from_str(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\")\n\t\t\t\t.unwrap()\n\t\t)\n\t});\n}\n\n#[test]\nfn contract_should_be_created_at_given_address() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\tlet erc20_address = contract_address(alice.address, 0);\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\tassert_ne!(EVM::account_codes(erc20_address).len(), 0);\n\t});\n}\n\n#[test]\nfn transaction_should_generate_correct_gas_used() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\tlet expected_gas = U256::from(891328);\n\n\text.execute_with(|| {\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tlet (_, _, info) = Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tmatch info {\n\t\t\tCallOrCreateInfo::Create(info) => {\n\t\t\t\tassert_eq!(info.used_gas, expected_gas);\n\t\t\t}\n\t\t\tCallOrCreateInfo::Call(_) => panic!(\"expected create info\"),\n\t\t}\n\t});\n}\n\n#[test]\nfn call_should_handle_errors() {\n\t// \tpragma solidity ^0.6.6;\n\t// \tcontract Test {\n\t// \t\tfunction foo() external pure returns (bool) {\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t\tfunction bar() external pure {\n\t// \t\t\trequire(false, \"error_msg\");\n\t// \t\t}\n\t// \t}\n\tlet contract: &str = \"608060405234801561001057600080fd5b50610113806100206000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c8063c2985578146037578063febb0f7e146057575b600080fd5b603d605f565b604051808215151515815260200191505060405180910390f35b605d6068565b005b60006001905090565b600060db576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260098152602001807f6572726f725f6d7367000000000000000000000000000000000000000000000081525060200191505060405180910390fd5b56fea2646970667358221220fde68a3968e0e99b16fabf9b2997a78218b32214031f8e07e2c502daf603a69e64736f6c63430006060033\";\n\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\n\text.execute_with(|| {\n\t\tlet t = UnsignedTransaction {\n\t\t\tnonce: U256::zero(),\n\t\t\tgas_price: U256::from(1),\n\t\t\tgas_limit: U256::from(0x100000),\n\t\t\taction: ethereum::TransactionAction::Create,\n\t\t\tvalue: U256::zero(),\n\t\t\tinput: FromHex::from_hex(contract).unwrap(),\n\t\t}\n\t\t.sign(&alice.private_key);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\n\t\tlet contract_address: Vec<u8> =\n\t\t\tFromHex::from_hex(\"32dcab0ef3fb2de2fce1d2e0799d36239671f04a\").unwrap();\n\t\tlet foo: Vec<u8> = FromHex::from_hex(\"c2985578\").unwrap();\n\t\tlet bar: Vec<u8> = FromHex::from_hex(\"febb0f7e\").unwrap();\n\n\t\t// calling foo will succeed\n\t\tlet (_, _, info) = Ethereum::execute(\n\t\t\talice.address,\n\t\t\tfoo,\n\t\t\tU256::zero(),\n\t\t\tU256::from(1048576),\n\t\t\tSome(U256::from(1)),\n\t\t\tSome(U256::from(1)),\n\t\t\tTransactionAction::Call(H160::from_slice(&contract_address)),\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tmatch info {\n\t\t\tCallOrCreateInfo::Call(info) => {\n\t\t\t\tassert_eq!(\n\t\t\t\t\tinfo.value.to_hex::<String>(),\n\t\t\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\".to_owned()\n\t\t\t\t);\n\t\t\t}\n\t\t\tCallOrCreateInfo::Create(_) => panic!(\"expected call info\"),\n\t\t}\n\n\t\t// calling should always succeed even if the inner EVM execution fails.\n\t\tEthereum::execute(\n\t\t\talice.address,\n\t\t\tbar,\n\t\t\tU256::zero(),\n\t\t\tU256::from(1048576),\n\t\t\tSome(U256::from(1)),\n\t\t\tSome(U256::from(2)),\n\t\t\tTransactionAction::Call(H160::from_slice(&contract_address)),\n\t\t\tNone,\n\t\t)\n\t\t.ok()\n\t\t.unwrap();\n\t});\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::SelfContainedCall;\nuse frame_support::weights::{DispatchInfo, GetDispatchInfo};\nuse sp_runtime::{\n\ttraits::{\n\t\tself, DispatchInfoOf, Dispatchable, MaybeDisplay, Member, PostDispatchInfoOf,\n\t\tSignedExtension, ValidateUnsigned,\n\t},\n\ttransaction_validity::{\n\t\tInvalidTransaction, TransactionSource, TransactionValidity, TransactionValidityError,\n\t},\n};\n\n#[derive(PartialEq, Eq, Clone, sp_core::RuntimeDebug)]\npub enum CheckedSignature<AccountId, Extra, SelfContainedSignedInfo> {\n\tSigned(AccountId, Extra),\n\tUnsigned,\n\tSelfContained(SelfContainedSignedInfo),\n}\n\n/// Definition of something that the external world might want to say; its\n/// existence implies that it has been checked and is good, particularly with\n/// regards to the signature.\n#[derive(PartialEq, Eq, Clone, sp_core::RuntimeDebug)]\npub struct CheckedExtrinsic<AccountId, Call, Extra, SelfContainedSignedInfo> {\n\t/// Who this purports to be from and the number of extrinsics have come before\n\t/// from the same signer, if anyone (note this is not a signature).\n\tpub signed: CheckedSignature<AccountId, Extra, SelfContainedSignedInfo>,\n\n\t/// The function that should be called.\n\tpub function: Call,\n}\n\nimpl<AccountId, Call: GetDispatchInfo, Extra, SelfContainedSignedInfo> GetDispatchInfo\n\tfor CheckedExtrinsic<AccountId, Call, Extra, SelfContainedSignedInfo>\n{\n\tfn get_dispatch_info(&self) -> DispatchInfo {\n\t\tself.function.get_dispatch_info()\n\t}\n}\n\nimpl<AccountId, Call, Extra, SelfContainedSignedInfo, Origin> traits::Applyable\n\tfor CheckedExtrinsic<AccountId, Call, Extra, SelfContainedSignedInfo>\nwhere\n\tAccountId: Member + MaybeDisplay,\n\tCall: Member\n\t\t+ Dispatchable<Origin = Origin>\n\t\t+ SelfContainedCall<SignedInfo = SelfContainedSignedInfo>,\n\tExtra: SignedExtension<AccountId = AccountId, Call = Call>,\n\tOrigin: From<Option<AccountId>>,\n\tSelfContainedSignedInfo: Send + Sync + 'static,\n{\n\ttype Call = Call;\n\n\tfn validate<U: ValidateUnsigned<Call = Self::Call>>(\n\t\t&self,\n\t\t// TODO [#5006;ToDr] should source be passed to `SignedExtension`s?\n\t\t// Perhaps a change for 2.0 to avoid breaking too much APIs?\n\t\tsource: TransactionSource,\n\t\tinfo: &DispatchInfoOf<Self::Call>,\n\t\tlen: usize,\n\t) -> TransactionValidity {\n\t\tmatch &self.signed {\n\t\t\tCheckedSignature::Signed(id, extra) => {\n\t\t\t\tExtra::validate(extra, id, &self.function, info, len)\n\t\t\t}\n\t\t\tCheckedSignature::Unsigned => {\n\t\t\t\tlet valid = Extra::validate_unsigned(&self.function, info, len)?;\n\t\t\t\tlet unsigned_validation = U::validate_unsigned(source, &self.function)?;\n\t\t\t\tOk(valid.combine_with(unsigned_validation))\n\t\t\t}\n\t\t\tCheckedSignature::SelfContained(signed_info) => {\n\t\t\t\tself.function.validate_self_contained(&signed_info).ok_or(\n\t\t\t\t\tTransactionValidityError::Invalid(InvalidTransaction::BadProof),\n\t\t\t\t)?\n\t\t\t}\n\t\t}\n\t}\n\n\tfn apply<U: ValidateUnsigned<Call = Self::Call>>(\n\t\tself,\n\t\tinfo: &DispatchInfoOf<Self::Call>,\n\t\tlen: usize,\n\t) -> sp_runtime::ApplyExtrinsicResultWithInfo<PostDispatchInfoOf<Self::Call>> {\n\t\tmatch self.signed {\n\t\t\tCheckedSignature::Signed(id, extra) => {\n\t\t\t\tlet pre = Extra::pre_dispatch(extra, &id, &self.function, info, len)?;\n\t\t\t\tlet maybe_who = Some(id);\n\t\t\t\tlet res = self.function.dispatch(Origin::from(maybe_who));\n\t\t\t\tlet post_info = match res {\n\t\t\t\t\tOk(info) => info,\n\t\t\t\t\tErr(err) => err.post_info,\n\t\t\t\t};\n\t\t\t\tExtra::post_dispatch(\n\t\t\t\t\tpre,\n\t\t\t\t\tinfo,\n\t\t\t\t\t&post_info,\n\t\t\t\t\tlen,\n\t\t\t\t\t&res.map(|_| ()).map_err(|e| e.error),\n\t\t\t\t)?;\n\t\t\t\tOk(res)\n\t\t\t}\n\t\t\tCheckedSignature::Unsigned => {\n\t\t\t\tlet pre = Extra::pre_dispatch_unsigned(&self.function, info, len)?;\n\t\t\t\tU::pre_dispatch(&self.function)?;\n\t\t\t\tlet maybe_who = None;\n\t\t\t\tlet res = self.function.dispatch(Origin::from(maybe_who));\n\t\t\t\tlet post_info = match res {\n\t\t\t\t\tOk(info) => info,\n\t\t\t\t\tErr(err) => err.post_info,\n\t\t\t\t};\n\t\t\t\tExtra::post_dispatch(\n\t\t\t\t\tpre,\n\t\t\t\t\tinfo,\n\t\t\t\t\t&post_info,\n\t\t\t\t\tlen,\n\t\t\t\t\t&res.map(|_| ()).map_err(|e| e.error),\n\t\t\t\t)?;\n\t\t\t\tOk(res)\n\t\t\t}\n\t\t\tCheckedSignature::SelfContained(signed_info) => {\n\t\t\t\t// If pre-dispatch fail, the block must be considered invalid\n\t\t\t\tself.function\n\t\t\t\t\t.pre_dispatch_self_contained(&signed_info)\n\t\t\t\t\t.ok_or(TransactionValidityError::Invalid(\n\t\t\t\t\t\tInvalidTransaction::BadProof,\n\t\t\t\t\t))??;\n\t\t\t\tOk(self.function.apply_self_contained(signed_info).ok_or(\n\t\t\t\t\tTransactionValidityError::Invalid(InvalidTransaction::BadProof),\n\t\t\t\t)?)\n\t\t\t}\n\t\t}\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nmod checked_extrinsic;\nmod unchecked_extrinsic;\n\npub use crate::{\n\tchecked_extrinsic::{CheckedExtrinsic, CheckedSignature},\n\tunchecked_extrinsic::UncheckedExtrinsic,\n};\n\nuse sp_runtime::{\n\ttraits::{Dispatchable, PostDispatchInfoOf},\n\ttransaction_validity::{TransactionValidity, TransactionValidityError},\n};\n\n/// A call that has self-contained functions. A self-contained\n/// function is something that has its signature embedded in its call.\npub trait SelfContainedCall: Dispatchable {\n\t/// Validated signature info.\n\ttype SignedInfo;\n\n\t/// Returns whether the current call is a self-contained function.\n\tfn is_self_contained(&self) -> bool;\n\t/// Check signatures of a self-contained function. Returns `None`\n\t/// if the function is not a self-contained.\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>>;\n\t/// Validate a self-contained function. Returns `None` if the\n\t/// function is not a self-contained.\n\tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity>;\n\t/// Do any pre-flight stuff for a self-contained call.\n\t///\n\t/// Note this function by default delegates to `validate_self_contained`, so that\n\t/// all checks performed for the transaction queue are also performed during\n\t/// the dispatch phase (applying the extrinsic).\n\t///\n\t/// If you ever override this function, you need to make sure to always\n\t/// perform the same validation as in `validate_self_contained`.\n\t///\n\t/// Returns `None` if the function is not a self-contained.\n\tfn pre_dispatch_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t) -> Option<Result<(), TransactionValidityError>>;\n\t/// Apply a self-contained function. Returns `None` if the\n\t/// function is not a self-contained.\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>>;\n}\n", "//! The Substrate Node Template runtime. This can be compiled with `#[no_std]`, ready for Wasm.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nuse codec::{Decode, Encode};\nuse pallet_grandpa::{\n\tfg_primitives, AuthorityId as GrandpaId, AuthorityList as GrandpaAuthorityList,\n};\nuse sp_api::impl_runtime_apis;\nuse sp_consensus_aura::sr25519::AuthorityId as AuraId;\nuse sp_core::{\n\tcrypto::{KeyTypeId, Public},\n\tOpaqueMetadata, H160, H256, U256,\n};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdLookup, BlakeTwo256, Block as BlockT, Dispatchable, IdentifyAccount, NumberFor,\n\t\tPostDispatchInfoOf, Verify,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity, TransactionValidityError},\n\tApplyExtrinsicResult, MultiSignature,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\n// A few exports that help ease life for downstream crates.\nuse fp_rpc::TransactionStatus;\npub use frame_support::{\n\tconstruct_runtime, parameter_types,\n\ttraits::{FindAuthor, KeyOwnerProofSystem, Randomness},\n\tweights::{\n\t\tconstants::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight, WEIGHT_PER_SECOND},\n\t\tIdentityFee, Weight,\n\t},\n\tConsensusEngineId, StorageValue,\n};\npub use pallet_balances::Call as BalancesCall;\nuse pallet_ethereum::{Call::transact, Transaction as EthereumTransaction};\nuse pallet_evm::{Account as EVMAccount, EnsureAddressTruncated, HashedAddressMapping, Runner};\npub use pallet_timestamp::Call as TimestampCall;\nuse pallet_transaction_payment::CurrencyAdapter;\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\npub use sp_runtime::{Perbill, Permill};\n\n/// Type of block number.\npub type BlockNumber = u32;\n\n/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n/// Some way of identifying an account on the chain. We intentionally make it equivalent\n/// to the public key of our transaction signing scheme.\npub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;\n\n/// The type for looking up accounts. We don't expect more than 4 billion of them, but you\n/// never know...\npub type AccountIndex = u32;\n\n/// Balance of an account.\npub type Balance = u128;\n\n/// Index of a transaction in the chain.\npub type Index = u32;\n\n/// A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n/// Digest item type.\npub type DigestItem = generic::DigestItem<Hash>;\n\n/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know\n/// the specifics of the runtime. They can then be made to be agnostic over specific formats\n/// of data like extrinsics, allowing for them to continue syncing the network through upgrades\n/// to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\n\t/// Opaque block header type.\n\tpub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// Opaque block type.\n\tpub type Block = generic::Block<Header, UncheckedExtrinsic>;\n\t/// Opaque block identifier type.\n\tpub type BlockId = generic::BlockId<Block>;\n\n\timpl_opaque_keys! {\n\t\tpub struct SessionKeys {\n\t\t\tpub aura: Aura,\n\t\t\tpub grandpa: Grandpa,\n\t\t}\n\t}\n}\n\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"node-frontier-template\"),\n\timpl_name: create_runtime_str!(\"node-frontier-template\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 1,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n};\n\npub const MILLISECS_PER_BLOCK: u64 = 6000;\n\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -> NativeVersion {\n\tNativeVersion {\n\t\truntime_version: VERSION,\n\t\tcan_author_with: Default::default(),\n\t}\n}\n\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\tpub const BlockHashCount: BlockNumber = 256;\n\t/// We allow for 2 seconds of compute with a 6 second average block time.\n\tpub BlockWeights: frame_system::limits::BlockWeights = frame_system::limits::BlockWeights\n\t\t::with_sensible_defaults(2 * WEIGHT_PER_SECOND, NORMAL_DISPATCH_RATIO);\n\tpub BlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength\n\t\t::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub const SS58Prefix: u8 = 42;\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\t/// Block & extrinsics weights: base values and limits.\n\ttype BlockWeights = BlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = BlockLength;\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype Call = Call;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup<AccountId, ()>;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\t/// The ubiquitous origin type.\n\ttype Origin = Origin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// Version of the runtime.\n\ttype Version = Version;\n\t/// Converts a module to the index of the module in `construct_runtime!`.\n\t///\n\t/// This type is being generated by `construct_runtime!`.\n\ttype PalletInfo = PalletInfo;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData<Balance>;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// This is used as an identifier of the chain. 42 is the generic substrate prefix.\n\ttype SS58Prefix = SS58Prefix;\n\t/// The set code logic, just the default since we're not a parachain.\n\ttype OnSetCode = ();\n}\n\nparameter_types! {\n\tpub const MaxAuthorities: u32 = 100;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nimpl pallet_grandpa::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n\n\ttype KeyOwnerProofSystem = ();\n\n\ttype KeyOwnerProof =\n\t\t<Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(KeyTypeId, GrandpaId)>>::Proof;\n\n\ttype KeyOwnerIdentification = <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(\n\t\tKeyTypeId,\n\t\tGrandpaId,\n\t)>>::IdentificationTuple;\n\n\ttype HandleEquivocation = ();\n\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n\t#[cfg(feature = \"aura\")]\n\ttype OnTimestampSet = Aura;\n\t#[cfg(feature = \"manual-seal\")]\n\ttype OnTimestampSet = ();\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: u128 = 500;\n\t// For weight estimation, we assume that the most locks on an individual account will be 50.\n\t// This number may need to be adjusted in the future if this assumption no longer holds true.\n\tpub const MaxLocks: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = [u8; 8];\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 1;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype OnChargeTransaction = CurrencyAdapter<Balances, ()>;\n\ttype TransactionByteFee = TransactionByteFee;\n\ttype WeightToFee = IdentityFee<Balance>;\n\ttype FeeMultiplierUpdate = ();\n}\n\nimpl pallet_sudo::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n}\n\npub struct FindAuthorTruncated<F>(PhantomData<F>);\nimpl<F: FindAuthor<u32>> FindAuthor<H160> for FindAuthorTruncated<F> {\n\tfn find_author<'a, I>(digests: I) -> Option<H160>\n\twhere\n\t\tI: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,\n\t{\n\t\tif let Some(author_index) = F::find_author(digests) {\n\t\t\tlet authority_id = Aura::authorities()[author_index as usize].clone();\n\t\t\treturn Some(H160::from_slice(&authority_id.to_raw_vec()[4..24]));\n\t\t}\n\t\tNone\n\t}\n}\n\nparameter_types! {\n\tpub const ChainId: u64 = 42;\n\tpub BlockGasLimit: U256 = U256::from(u32::max_value());\n}\n\nimpl pallet_evm::Config for Runtime {\n\ttype FeeCalculator = pallet_dynamic_fee::Pallet<Self>;\n\ttype GasWeightMapping = ();\n\ttype BlockHashMapping = pallet_ethereum::EthereumBlockHashMapping<Self>;\n\ttype CallOrigin = EnsureAddressTruncated;\n\ttype WithdrawOrigin = EnsureAddressTruncated;\n\ttype AddressMapping = HashedAddressMapping<BlakeTwo256>;\n\ttype Currency = Balances;\n\ttype Event = Event;\n\ttype Runner = pallet_evm::runner::stack::Runner<Self>;\n\ttype Precompiles = (\n\t\tpallet_evm_precompile_simple::ECRecover,\n\t\tpallet_evm_precompile_simple::Sha256,\n\t\tpallet_evm_precompile_simple::Ripemd160,\n\t\tpallet_evm_precompile_simple::Identity,\n\t\tpallet_evm_precompile_modexp::Modexp,\n\t\tpallet_evm_precompile_simple::ECRecoverPublicKey,\n\t\tpallet_evm_precompile_sha3fips::Sha3FIPS256,\n\t\tpallet_evm_precompile_sha3fips::Sha3FIPS512,\n\t);\n\ttype ChainId = ChainId;\n\ttype BlockGasLimit = BlockGasLimit;\n\ttype OnChargeTransaction = ();\n\ttype FindAuthor = FindAuthorTruncated<Aura>;\n}\n\nimpl pallet_ethereum::Config for Runtime {\n\ttype Event = Event;\n\ttype StateRoot = pallet_ethereum::IntermediateStateRoot;\n}\n\nframe_support::parameter_types! {\n\tpub BoundDivision: U256 = U256::from(1024);\n}\n\nimpl pallet_dynamic_fee::Config for Runtime {\n\ttype MinGasPriceBoundDivisor = BoundDivision;\n}\n\nimpl pallet_randomness_collective_flip::Config for Runtime {}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event<T>},\n\t\tRandomnessCollectiveFlip: pallet_randomness_collective_flip::{Pallet, Storage},\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent},\n\t\tAura: pallet_aura::{Pallet, Config<T>},\n\t\tGrandpa: pallet_grandpa::{Pallet, Call, Storage, Config, Event},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage},\n\t\tSudo: pallet_sudo::{Pallet, Call, Config<T>, Storage, Event<T>},\n\t\tEthereum: pallet_ethereum::{Pallet, Call, Storage, Event, Config, Origin},\n\t\tEVM: pallet_evm::{Pallet, Config, Call, Storage, Event<T>},\n\t\tDynamicFee: pallet_dynamic_fee::{Pallet, Call, Storage, Config, Inherent},\n\t}\n);\n\npub struct TransactionConverter;\n\nimpl fp_rpc::ConvertTransaction<UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(&self, transaction: pallet_ethereum::Transaction) -> UncheckedExtrinsic {\n\t\tUncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact(transaction).into(),\n\t\t)\n\t}\n}\n\nimpl fp_rpc::ConvertTransaction<opaque::UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(\n\t\t&self,\n\t\ttransaction: pallet_ethereum::Transaction,\n\t) -> opaque::UncheckedExtrinsic {\n\t\tlet extrinsic = UncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact(transaction).into(),\n\t\t);\n\t\tlet encoded = extrinsic.encode();\n\t\topaque::UncheckedExtrinsic::decode(&mut &encoded[..])\n\t\t\t.expect(\"Encoded extrinsic is always valid\")\n\t}\n}\n\n/// The address format for describing accounts.\npub type Address = sp_runtime::MultiAddress<AccountId, ()>;\n/// Block header type as expected by this runtime.\npub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n/// Block type as expected by this runtime.\npub type Block = generic::Block<Header, UncheckedExtrinsic>;\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock<Block>;\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId<Block>;\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckSpecVersion<Runtime>,\n\tframe_system::CheckTxVersion<Runtime>,\n\tframe_system::CheckGenesis<Runtime>,\n\tframe_system::CheckEra<Runtime>,\n\tframe_system::CheckNonce<Runtime>,\n\tframe_system::CheckWeight<Runtime>,\n\tpallet_transaction_payment::ChargeTransactionPayment<Runtime>,\n);\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tfp_self_contained::UncheckedExtrinsic<Address, Call, Signature, SignedExtra>;\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = fp_self_contained::CheckedExtrinsic<AccountId, Call, SignedExtra, H160>;\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive<\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext<Runtime>,\n\tRuntime,\n\tAllPallets,\n>;\n\nimpl fp_self_contained::SelfContainedCall for Call {\n\ttype SignedInfo = H160;\n\n\tfn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.is_self_contained(),\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.check_self_contained(),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn validate_self_contained(&self, info: &Self::SignedInfo) -> Option<TransactionValidity> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.validate_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn pre_dispatch_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.pre_dispatch_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>> {\n\t\tmatch self {\n\t\t\tcall @ Call::Ethereum(pallet_ethereum::Call::transact(_)) => Some(call.dispatch(\n\t\t\t\tOrigin::from(pallet_ethereum::RawOrigin::EthereumTransaction(info)),\n\t\t\t)),\n\t\t\t_ => None,\n\t\t}\n\t}\n}\n\nimpl_runtime_apis! {\n\timpl sp_api::Core<Block> for Runtime {\n\t\tfn version() -> RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata<Block> for Runtime {\n\t\tfn metadata() -> OpaqueMetadata {\n\t\t\tRuntime::metadata().into()\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder<Block> for Runtime {\n\t\tfn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -> <Block as BlockT>::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as BlockT>::Extrinsic> {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -> sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(&block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: <Block as BlockT>::Extrinsic,\n\t\t\tblock_hash: <Block as BlockT>::Hash,\n\t\t) -> TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi<Block> for Runtime {\n\t\tfn offchain_worker(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_consensus_aura::AuraApi<Block, AuraId> for Runtime {\n\t\tfn slot_duration() -> sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -> Vec<AuraId> {\n\t\t\tAura::authorities().to_vec()\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi<Block, AccountId, Index> for Runtime {\n\t\tfn account_nonce(account: AccountId) -> Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl fp_rpc::EthereumRuntimeRPCApi<Block> for Runtime {\n\t\tfn chain_id() -> u64 {\n\t\t\t<Runtime as pallet_evm::Config>::ChainId::get()\n\t\t}\n\n\t\tfn account_basic(address: H160) -> EVMAccount {\n\t\t\tEVM::account_basic(&address)\n\t\t}\n\n\t\tfn gas_price() -> U256 {\n\t\t\t<Runtime as pallet_evm::Config>::FeeCalculator::min_gas_price()\n\t\t}\n\n\t\tfn account_code_at(address: H160) -> Vec<u8> {\n\t\t\tEVM::account_codes(address)\n\t\t}\n\n\t\tfn author() -> H160 {\n\t\t\t<pallet_evm::Pallet<Runtime>>::find_author()\n\t\t}\n\n\t\tfn storage_at(address: H160, index: U256) -> H256 {\n\t\t\tlet mut tmp = [0u8; 32];\n\t\t\tindex.to_big_endian(&mut tmp);\n\t\t\tEVM::account_storages(address, H256::from_slice(&tmp[..]))\n\t\t}\n\n\t\tfn call(\n\t\t\tfrom: H160,\n\t\t\tto: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tgas_price: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t) -> Result<pallet_evm::CallInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\t<Runtime as pallet_evm::Config>::Runner::call(\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.low_u64(),\n\t\t\t\tgas_price,\n\t\t\t\tnonce,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.into())\n\t\t}\n\n\t\tfn create(\n\t\t\tfrom: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tgas_price: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t) -> Result<pallet_evm::CreateInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\t<Runtime as pallet_evm::Config>::Runner::create(\n\t\t\t\tfrom,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.low_u64(),\n\t\t\t\tgas_price,\n\t\t\t\tnonce,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.into())\n\t\t}\n\n\t\tfn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\t\tEthereum::current_transaction_statuses()\n\t\t}\n\n\t\tfn current_block() -> Option<pallet_ethereum::Block> {\n\t\t\tEthereum::current_block()\n\t\t}\n\n\t\tfn current_receipts() -> Option<Vec<pallet_ethereum::Receipt>> {\n\t\t\tEthereum::current_receipts()\n\t\t}\n\n\t\tfn current_all() -> (\n\t\t\tOption<pallet_ethereum::Block>,\n\t\t\tOption<Vec<pallet_ethereum::Receipt>>,\n\t\t\tOption<Vec<TransactionStatus>>\n\t\t) {\n\t\t\t(\n\t\t\t\tEthereum::current_block(),\n\t\t\t\tEthereum::current_receipts(),\n\t\t\t\tEthereum::current_transaction_statuses()\n\t\t\t)\n\t\t}\n\n\t\tfn extrinsic_filter(\n\t\t\txts: Vec<<Block as BlockT>::Extrinsic>,\n\t\t) -> Vec<EthereumTransaction> {\n\t\t\txts.into_iter().filter_map(|xt| match xt.0.function {\n\t\t\t\tCall::Ethereum(transact(t)) => Some(t),\n\t\t\t\t_ => None\n\t\t\t}).collect::<Vec<EthereumTransaction>>()\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<\n\t\tBlock,\n\t\tBalance,\n\t> for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32\n\t\t) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\n\t\tfn query_fee_details(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -> pallet_transaction_payment::FeeDetails<Balance> {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys<Block> for Runtime {\n\t\tfn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {\n\t\t\topaque::SessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec<u8>,\n\t\t) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {\n\t\t\topaque::SessionKeys::decode_into_raw_public_keys(&encoded)\n\t\t}\n\t}\n\n\timpl fg_primitives::GrandpaApi<Block> for Runtime {\n\t\tfn grandpa_authorities() -> GrandpaAuthorityList {\n\t\t\tGrandpa::grandpa_authorities()\n\t\t}\n\n\t\tfn current_set_id() -> fg_primitives::SetId {\n\t\t\tGrandpa::current_set_id()\n\t\t}\n\n\t\tfn submit_report_equivocation_unsigned_extrinsic(\n\t\t\t_equivocation_proof: fg_primitives::EquivocationProof<\n\t\t\t\t<Block as BlockT>::Hash,\n\t\t\t\tNumberFor<Block>,\n\t\t\t>,\n\t\t\t_key_owner_proof: fg_primitives::OpaqueKeyOwnershipProof,\n\t\t) -> Option<()> {\n\t\t\tNone\n\t\t}\n\n\t\tfn generate_key_ownership_proof(\n\t\t\t_set_id: fg_primitives::SetId,\n\t\t\t_authority_id: GrandpaId,\n\t\t) -> Option<fg_primitives::OpaqueKeyOwnershipProof> {\n\t\t\t// NOTE: this is the only implementation possible since we've\n\t\t\t// defined our key owner proof type as a bottom type (i.e. a type\n\t\t\t// with no values).\n\t\t\tNone\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark<Block> for Runtime {\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -> Result<Vec<frame_benchmarking::BenchmarkBatch>, sp_runtime::RuntimeString> {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkBatch, add_benchmark, TrackedStorageKey};\n\t\t\tuse pallet_evm::Module as PalletEvmBench;\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec<TrackedStorageKey> = vec![];\n\n\t\t\tlet mut batches = Vec::<BenchmarkBatch>::new();\n\t\t\tlet params = (&config, &whitelist);\n\n\t\t\tadd_benchmark!(params, batches, pallet_evm, PalletEvmBench::<Runtime>);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n"], "filenames": ["frame/ethereum/src/lib.rs", "frame/ethereum/src/mock.rs", "frame/ethereum/src/tests.rs", "primitives/self-contained/src/checked_extrinsic.rs", "primitives/self-contained/src/lib.rs", "template/runtime/src/lib.rs"], "buggy_code_start_loc": [120, 21, 21, 137, 46, 442], "buggy_code_end_loc": [567, 268, 138, 137, 46, 442], "fixing_code_start_loc": [121, 22, 21, 138, 47, 443], "fixing_code_end_loc": [633, 323, 195, 144, 61, 453], "type": "CWE-20", "message": "Frontier is Substrate's Ethereum compatibility layer. In the newly introduced signed Frontier-specific extrinsic for `pallet-ethereum`, a large part of transaction validation logic was only called in transaction pool validation, but not in block execution. Malicious validators can take advantage of this to put invalid transactions into a block. The attack is limited in that the signature is always validated, and the majority of the validation is done again in the subsequent `pallet-evm` execution logic. However, do note that a chain ID replay attack was possible. In addition, spamming attacks are of main concerns, while they are limited by Substrate block size limits and other factors. The issue is patched in commit `146bb48849e5393004be5c88beefe76fdf009aba`.", "other": {"cve": {"id": "CVE-2021-41138", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-13T16:15:07.847", "lastModified": "2021-10-20T16:45:01.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Frontier is Substrate's Ethereum compatibility layer. In the newly introduced signed Frontier-specific extrinsic for `pallet-ethereum`, a large part of transaction validation logic was only called in transaction pool validation, but not in block execution. Malicious validators can take advantage of this to put invalid transactions into a block. The attack is limited in that the signature is always validated, and the majority of the validation is done again in the subsequent `pallet-evm` execution logic. However, do note that a chain ID replay attack was possible. In addition, spamming attacks are of main concerns, while they are limited by Substrate block size limits and other factors. The issue is patched in commit `146bb48849e5393004be5c88beefe76fdf009aba`."}, {"lang": "es", "value": "Frontier es la capa de compatibilidad con Ethereum de Substrate. En la reci\u00e9n introducida extr\u00ednseca espec\u00edfica de Frontier para \"pallet-ethereum\", una gran parte de la l\u00f3gica de comprobaci\u00f3n de transacciones s\u00f3lo se llamaba en la comprobaci\u00f3n del conjunto de transacciones, pero no en la ejecuci\u00f3n del bloque. Los comprobadores maliciosos pueden aprovechar esto para poner transacciones no v\u00e1lidas en un bloque. El ataque est\u00e1 limitado en el sentido de que la firma siempre es validada, y la mayor parte de la comprobaci\u00f3n es realizada de nuevo en la l\u00f3gica de ejecuci\u00f3n posterior de \"pallet-evm\". Sin embargo, es debido tener en cuenta que es posible un ataque de repetici\u00f3n de ID de cadena. Adem\u00e1s, los ataques de spam son de las principales preocupaciones, mientras que est\u00e1n limitados por los l\u00edmites de tama\u00f1o de bloque del sustrato y otros factores. El problema est\u00e1 parcheado en el commit \"146bb48849e5393004be5c88beefe76fdf009aba\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parity:frontier:*:*:*:*:*:*:*:*", "versionStartIncluding": "2021-09-30", "versionEndExcluding": "2021-10-13", "matchCriteriaId": "DFC2C906-5789-4816-87DF-5EB4B6760564"}]}]}], "references": [{"url": "https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/pull/497", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/security/advisories/GHSA-vj62-g63v-f8mf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba"}}