{"buggy_code": ["'use strict'\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    endOfFile,\n    nextToken,\n    position\n  }\n}\n", "import { readFileSync } from 'fs'\nimport { resolve } from 'path'\nimport { eachTest, jsonify, testPath } from 'postcss-parser-tests'\nimport { test } from 'uvu'\nimport { equal, is, match, not, throws } from 'uvu/assert'\n\nimport { AtRule, Declaration, parse, Root, Rule } from '../lib/postcss.js'\n\ntest('works with file reads', () => {\n  let stream = readFileSync(testPath('atrule-empty.css'))\n  is(parse(stream) instanceof Root, true)\n})\n\neachTest((name, css, json) => {\n  test(`parses ${name}`, () => {\n    css = css.replace(/\\r\\n/g, '\\n')\n    let parsed = jsonify(parse(css, { from: name }))\n    equal(parsed, json)\n  })\n})\n\ntest('parses UTF-8 BOM', () => {\n  let css = parse('\\uFEFF@host { a {\\f} }')\n  equal(css.nodes[0].raws.before, '')\n})\n\ntest('should has true at hasBOM property', () => {\n  let css = parse('\\uFEFF@host { a {\\f} }')\n  is(css.first?.source?.input.hasBOM, true)\n})\n\ntest('should has false at hasBOM property', () => {\n  let css = parse('@host { a {\\f} }')\n  is(css.first?.source?.input.hasBOM, false)\n})\n\ntest('saves source file', () => {\n  let css = parse('a {}', { from: 'a.css' })\n  is(css.first?.source?.input.css, 'a {}')\n  is(css.first?.source?.input.file, resolve('a.css'))\n  is(css.first?.source?.input.from, resolve('a.css'))\n})\n\ntest('keeps absolute path in source', () => {\n  let css = parse('a {}', { from: 'http://example.com/a.css' })\n  is(css.first?.source?.input.file, 'http://example.com/a.css')\n  is(css.first?.source?.input.from, 'http://example.com/a.css')\n})\n\ntest('saves source file on previous map', () => {\n  let root1 = parse('a {}', { map: { inline: true } })\n  let css = root1.toResult({ map: { inline: true } }).css\n  let root2 = parse(css)\n  is(root2.first?.source?.input.file, resolve('to.css'))\n})\n\ntest('sets unique ID for file without name', () => {\n  let css1 = parse('a {}')\n  let css2 = parse('a {}')\n  match(String(css1.first?.source?.input.id), /^<input css [\\w-]+>$/)\n  match(String(css1.first?.source?.input.from), /^<input css [\\w-]+>$/)\n  is.not(css2.first?.source?.input.id, css1.first?.source?.input.id)\n})\n\ntest('sets parent node', () => {\n  let file = testPath('atrule-rules.css')\n  let css = parse(readFileSync(file))\n\n  let support = css.first as AtRule\n  let keyframes = support.first as AtRule\n  let from = keyframes.first as Rule\n  let decl = from.first as Declaration\n\n  is(decl.parent, from)\n  is(from.parent, keyframes)\n  is(support.parent, css)\n  is(keyframes.parent, support)\n})\n\ntest('ignores wrong close bracket', () => {\n  let root = parse('a { p: ()) }')\n  let a = root.first as Rule\n  let decl = a.first as Declaration\n  is(decl.value, '())')\n})\n\ntest('parses unofficial --mixins', () => {\n  let root = parse(':root { --x { color: pink; }; }')\n  let rule = root.first as Rule\n  let prop = rule.first as Rule\n  is(prop.selector, '--x')\n})\n\ntest('ignores symbols before declaration', () => {\n  let root = parse('a { :one: 1 }')\n  let a = root.first as Rule\n  let prop = a.first as Declaration\n  is(prop.raws.before, ' :')\n})\n\ntest('parses double semicolon after rule', () => {\n  is(parse('a { };;').toString(), 'a { };;')\n})\n\ntest('parses a functional property', () => {\n  let root = parse('a { b(c): d }')\n  let a = root.first as Rule\n  let b = a.first as Declaration\n\n  is(b.prop, 'b(c)')\n})\n\ntest('parses a functional tagname', () => {\n  let root = parse('a { b(c): d {} }')\n  let a = root.first as Rule\n  let b = a.first as Rule\n\n  is(b.selector, 'b(c): d')\n})\n\ntest('throws on unclosed blocks', () => {\n  throws(() => {\n    parse('\\na {\\n')\n  }, /:2:1: Unclosed block/)\n})\n\ntest('throws on unnecessary block close', () => {\n  throws(() => {\n    parse('a {\\n} }')\n  }, /:2:3: Unexpected }/)\n})\n\ntest('throws on unclosed comment', () => {\n  throws(() => {\n    parse('\\n/*\\n ')\n  }, /:2:1: Unclosed comment/)\n})\n\ntest('throws on unclosed quote', () => {\n  throws(() => {\n    parse('\\n\"\\n\\na ')\n  }, /:2:1: Unclosed string/)\n})\n\ntest('throws on unclosed bracket', () => {\n  throws(() => {\n    parse(':not(one() { }')\n  }, /:1:5: Unclosed bracket/)\n})\n\ntest('throws on property without value', () => {\n  throws(() => {\n    parse('a { b;}')\n  }, /:1:5: Unknown word/)\n  throws(() => {\n    parse('a { b b }')\n  }, /:1:5: Unknown word/)\n  throws(() => {\n    parse('a { b(); }')\n  }, /:1:5: Unknown word/)\n})\n\ntest('throws on nameless at-rule', () => {\n  throws(() => {\n    parse('@')\n  }, /:1:1: At-rule without name/)\n})\n\ntest('throws on property without semicolon', () => {\n  throws(() => {\n    parse('a { one: filter(a:\"\") two: 2 }')\n  }, /:1:21: Missed semicolon/)\n})\n\ntest('throws on double colon', () => {\n  throws(() => {\n    parse('a { one:: 1 }')\n  }, /:1:9: Double colon/)\n})\n\ntest('do not throws on comment in between', () => {\n  parse('a { b/* c */: 1 }')\n})\n\ntest('throws on two words in between', () => {\n  throws(() => {\n    parse('a { b c: 1 }')\n  }, /:1:7: Unknown word/)\n})\n\ntest('throws on just colon', () => {\n  throws(() => {\n    parse(':')\n  }, /:1:1: Unknown word/)\n  throws(() => {\n    parse(' : ')\n  }, /:1:2: Unknown word/)\n})\n\ntest('does not suggest different parsers for CSS', () => {\n  let error: any\n  try {\n    parse('a { one:: 1 }', { from: 'app.css' })\n  } catch (e) {\n    error = e\n  }\n  not.match(error.message, /postcss-less|postcss-scss/)\n})\n\ntest('suggests postcss-scss for SCSS sources', () => {\n  throws(() => {\n    parse('a { #{var}: 1 }', { from: 'app.scss' })\n  }, /postcss-scss/)\n})\n\ntest('suggests postcss-sass for Sass sources', () => {\n  throws(() => {\n    parse('a\\n  #{var}: 1', { from: 'app.sass' })\n  }, /postcss-sass/)\n})\n\ntest('suggests postcss-less for Less sources', () => {\n  throws(() => {\n    parse('.@{my-selector} { }', { from: 'app.less' })\n  }, /postcss-less/)\n})\n\ntest('should give the correct column of missed semicolon with !important', () => {\n  let error: any\n  try {\n    parse('a { \\n    color: red !important\\n    background-color: black;\\n}')\n  } catch (e) {\n    error = e\n  }\n  match(error.message, /2:26: Missed semicolon/)\n})\n\ntest('should give the correct column of missed semicolon without !important', () => {\n  let error: any\n  try {\n    parse('a { \\n    color: red\\n    background-color: black;\\n}')\n  } catch (e) {\n    error = e\n  }\n  match(error.message, /2:15: Missed semicolon/)\n})\n\ntest.run()\n"], "fixing_code": ["'use strict'\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    endOfFile,\n    nextToken,\n    position\n  }\n}\n", "import { readFileSync } from 'fs'\nimport { resolve } from 'path'\nimport { eachTest, jsonify, testPath } from 'postcss-parser-tests'\nimport { test } from 'uvu'\nimport { equal, is, match, not, throws } from 'uvu/assert'\n\nimport { AtRule, Declaration, parse, Root, Rule } from '../lib/postcss.js'\n\ntest('works with file reads', () => {\n  let stream = readFileSync(testPath('atrule-empty.css'))\n  is(parse(stream) instanceof Root, true)\n})\n\neachTest((name, css, json) => {\n  test(`parses ${name}`, () => {\n    css = css.replace(/\\r\\n/g, '\\n')\n    let parsed = jsonify(parse(css, { from: name }))\n    equal(parsed, json)\n  })\n})\n\ntest('parses UTF-8 BOM', () => {\n  let css = parse('\\uFEFF@host { a {\\f} }')\n  equal(css.nodes[0].raws.before, '')\n})\n\ntest('should has true at hasBOM property', () => {\n  let css = parse('\\uFEFF@host { a {\\f} }')\n  is(css.first?.source?.input.hasBOM, true)\n})\n\ntest('should has false at hasBOM property', () => {\n  let css = parse('@host { a {\\f} }')\n  is(css.first?.source?.input.hasBOM, false)\n})\n\ntest('parses carrier return', () => {\n  throws(() => {\n    parse('@font-face{ font:(\\r/*);} body { a: \"a*/)} a{}\"}')\n  }, /:1:46: Unclosed string/)\n})\n\ntest('saves source file', () => {\n  let css = parse('a {}', { from: 'a.css' })\n  is(css.first?.source?.input.css, 'a {}')\n  is(css.first?.source?.input.file, resolve('a.css'))\n  is(css.first?.source?.input.from, resolve('a.css'))\n})\n\ntest('keeps absolute path in source', () => {\n  let css = parse('a {}', { from: 'http://example.com/a.css' })\n  is(css.first?.source?.input.file, 'http://example.com/a.css')\n  is(css.first?.source?.input.from, 'http://example.com/a.css')\n})\n\ntest('saves source file on previous map', () => {\n  let root1 = parse('a {}', { map: { inline: true } })\n  let css = root1.toResult({ map: { inline: true } }).css\n  let root2 = parse(css)\n  is(root2.first?.source?.input.file, resolve('to.css'))\n})\n\ntest('sets unique ID for file without name', () => {\n  let css1 = parse('a {}')\n  let css2 = parse('a {}')\n  match(String(css1.first?.source?.input.id), /^<input css [\\w-]+>$/)\n  match(String(css1.first?.source?.input.from), /^<input css [\\w-]+>$/)\n  is.not(css2.first?.source?.input.id, css1.first?.source?.input.id)\n})\n\ntest('sets parent node', () => {\n  let file = testPath('atrule-rules.css')\n  let css = parse(readFileSync(file))\n\n  let support = css.first as AtRule\n  let keyframes = support.first as AtRule\n  let from = keyframes.first as Rule\n  let decl = from.first as Declaration\n\n  is(decl.parent, from)\n  is(from.parent, keyframes)\n  is(support.parent, css)\n  is(keyframes.parent, support)\n})\n\ntest('ignores wrong close bracket', () => {\n  let root = parse('a { p: ()) }')\n  let a = root.first as Rule\n  let decl = a.first as Declaration\n  is(decl.value, '())')\n})\n\ntest('parses unofficial --mixins', () => {\n  let root = parse(':root { --x { color: pink; }; }')\n  let rule = root.first as Rule\n  let prop = rule.first as Rule\n  is(prop.selector, '--x')\n})\n\ntest('ignores symbols before declaration', () => {\n  let root = parse('a { :one: 1 }')\n  let a = root.first as Rule\n  let prop = a.first as Declaration\n  is(prop.raws.before, ' :')\n})\n\ntest('parses double semicolon after rule', () => {\n  is(parse('a { };;').toString(), 'a { };;')\n})\n\ntest('parses a functional property', () => {\n  let root = parse('a { b(c): d }')\n  let a = root.first as Rule\n  let b = a.first as Declaration\n\n  is(b.prop, 'b(c)')\n})\n\ntest('parses a functional tagname', () => {\n  let root = parse('a { b(c): d {} }')\n  let a = root.first as Rule\n  let b = a.first as Rule\n\n  is(b.selector, 'b(c): d')\n})\n\ntest('throws on unclosed blocks', () => {\n  throws(() => {\n    parse('\\na {\\n')\n  }, /:2:1: Unclosed block/)\n})\n\ntest('throws on unnecessary block close', () => {\n  throws(() => {\n    parse('a {\\n} }')\n  }, /:2:3: Unexpected }/)\n})\n\ntest('throws on unclosed comment', () => {\n  throws(() => {\n    parse('\\n/*\\n ')\n  }, /:2:1: Unclosed comment/)\n})\n\ntest('throws on unclosed quote', () => {\n  throws(() => {\n    parse('\\n\"\\n\\na ')\n  }, /:2:1: Unclosed string/)\n})\n\ntest('throws on unclosed bracket', () => {\n  throws(() => {\n    parse(':not(one() { }')\n  }, /:1:5: Unclosed bracket/)\n})\n\ntest('throws on property without value', () => {\n  throws(() => {\n    parse('a { b;}')\n  }, /:1:5: Unknown word/)\n  throws(() => {\n    parse('a { b b }')\n  }, /:1:5: Unknown word/)\n  throws(() => {\n    parse('a { b(); }')\n  }, /:1:5: Unknown word/)\n})\n\ntest('throws on nameless at-rule', () => {\n  throws(() => {\n    parse('@')\n  }, /:1:1: At-rule without name/)\n})\n\ntest('throws on property without semicolon', () => {\n  throws(() => {\n    parse('a { one: filter(a:\"\") two: 2 }')\n  }, /:1:21: Missed semicolon/)\n})\n\ntest('throws on double colon', () => {\n  throws(() => {\n    parse('a { one:: 1 }')\n  }, /:1:9: Double colon/)\n})\n\ntest('do not throws on comment in between', () => {\n  parse('a { b/* c */: 1 }')\n})\n\ntest('throws on two words in between', () => {\n  throws(() => {\n    parse('a { b c: 1 }')\n  }, /:1:7: Unknown word/)\n})\n\ntest('throws on just colon', () => {\n  throws(() => {\n    parse(':')\n  }, /:1:1: Unknown word/)\n  throws(() => {\n    parse(' : ')\n  }, /:1:2: Unknown word/)\n})\n\ntest('does not suggest different parsers for CSS', () => {\n  let error: any\n  try {\n    parse('a { one:: 1 }', { from: 'app.css' })\n  } catch (e) {\n    error = e\n  }\n  not.match(error.message, /postcss-less|postcss-scss/)\n})\n\ntest('suggests postcss-scss for SCSS sources', () => {\n  throws(() => {\n    parse('a { #{var}: 1 }', { from: 'app.scss' })\n  }, /postcss-scss/)\n})\n\ntest('suggests postcss-sass for Sass sources', () => {\n  throws(() => {\n    parse('a\\n  #{var}: 1', { from: 'app.sass' })\n  }, /postcss-sass/)\n})\n\ntest('suggests postcss-less for Less sources', () => {\n  throws(() => {\n    parse('.@{my-selector} { }', { from: 'app.less' })\n  }, /postcss-less/)\n})\n\ntest('should give the correct column of missed semicolon with !important', () => {\n  let error: any\n  try {\n    parse('a { \\n    color: red !important\\n    background-color: black;\\n}')\n  } catch (e) {\n    error = e\n  }\n  match(error.message, /2:26: Missed semicolon/)\n})\n\ntest('should give the correct column of missed semicolon without !important', () => {\n  let error: any\n  try {\n    parse('a { \\n    color: red\\n    background-color: black;\\n}')\n  } catch (e) {\n    error = e\n  }\n  match(error.message, /2:15: Missed semicolon/)\n})\n\ntest.run()\n"], "filenames": ["lib/tokenize.js", "test/parse.test.ts"], "buggy_code_start_loc": [25, 34], "buggy_code_end_loc": [26, 34], "fixing_code_start_loc": [25, 35], "fixing_code_end_loc": [26, 41], "type": "CWE-74", "message": "An issue was discovered in PostCSS before 8.4.31. The vulnerability affects linters using PostCSS to parse external untrusted CSS. An attacker can prepare CSS in such a way that it will contains parts parsed by PostCSS as a CSS comment. After processing by PostCSS, it will be included in the PostCSS output in CSS nodes (rules, properties) despite being included in a comment.", "other": {"cve": {"id": "CVE-2023-44270", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-29T22:15:11.867", "lastModified": "2023-10-10T17:19:55.690", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in PostCSS before 8.4.31. The vulnerability affects linters using PostCSS to parse external untrusted CSS. An attacker can prepare CSS in such a way that it will contains parts parsed by PostCSS as a CSS comment. After processing by PostCSS, it will be included in the PostCSS output in CSS nodes (rules, properties) despite being included in a comment."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en PostCSS antes de la versi\u00f3n 8.4.31. La vulnerabilidad afecta a los linters que utilizan PostCSS para analizar CSS externos que no son de confianza. Un atacante puede preparar CSS de tal manera que contenga partes analizadas por PostCSS como un comentario CSS. Despu\u00e9s del procesamiento por PostCSS, se incluir\u00e1 en la salida de PostCSS en los nodos CSS (reglas, propiedades) a pesar de estar incluido en un comentario."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:postcss:postcss:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "8.4.31", "matchCriteriaId": "FB38A6C8-B41F-41C9-9093-E46BAC3B54CB"}]}]}], "references": [{"url": "https://github.com/github/advisory-database/issues/2820", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/postcss/postcss/blob/main/lib/tokenize.js#L25", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/postcss/postcss/commit/58cc860b4c1707510c9cd1bc1fa30b423a9ad6c5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/postcss/postcss/releases/tag/8.4.31", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}]}, "github_commit_url": "https://github.com/postcss/postcss/commit/58cc860b4c1707510c9cd1bc1fa30b423a9ad6c5"}}