{"buggy_code": ["/*\n *\n * (C) 2013-17 - ntop.org\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"ntop_includes.h\"\n\n#ifndef _GETOPT_H\n#define _GETOPT_H\n#endif\n\n#ifndef LIB_VERSION\n#define LIB_VERSION \"1.4.7\"\n#endif\n\nextern \"C\" {\n#include \"rrd.h\"\n#ifdef HAVE_GEOIP\n  extern const char * GeoIP_lib_version(void);\n#endif\n\n#include \"../third-party/snmp/snmp.c\"\n#include \"../third-party/snmp/asn1.c\"\n#include \"../third-party/snmp/net.c\"\n};\n\n#include \"../third-party/lsqlite3/lsqlite3.c\"\n\nstruct keyval string_to_replace[MAX_NUM_HTTP_REPLACEMENTS] = { { NULL, NULL } };\n\n/* ******************************* */\n\nLua::Lua() {\n  L = luaL_newstate();\n\n  if(L == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to create Lua interpreter\");\n    return;\n  }\n}\n\n/* ******************************* */\n\nLua::~Lua() {\n  if(L) lua_close(L);\n}\n\n/* ******************************* */\n\n/**\n * @brief Check the expected type of lua function.\n * @details Find in the lua stack the function and check the function parameters types.\n *\n * @param vm The lua state.\n * @param func The function name.\n * @param pos Index of lua stack.\n * @param expected_type Index of expected type.\n * @return @ref CONST_LUA_ERROR if the expected type is equal to function type, @ref CONST_LUA_PARAM_ERROR otherwise.\n */\nint ntop_lua_check(lua_State* vm, const char* func, int pos, int expected_type) {\n  if(lua_type(vm, pos) != expected_type) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR,\n\t\t\t\t \"%s : expected %s, got %s\", func,\n\t\t\t\t lua_typename(vm, expected_type),\n\t\t\t\t lua_typename(vm, lua_type(vm,pos)));\n    return(CONST_LUA_PARAM_ERROR);\n  }\n\n  return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic void get_host_vlan_info(char* lua_ip, char** host_ip,\n\t\t\t       u_int16_t* vlan_id,\n\t\t\t       char *buf, u_int buf_len) {\n  char *where, *vlan = NULL;\n\n  snprintf(buf, buf_len, \"%s\", lua_ip);\n\n  if(((*host_ip) = strtok_r(buf, \"@\", &where)) != NULL)\n    vlan = strtok_r(NULL, \"@\", &where);\n\n  if(vlan)\n    (*vlan_id) = (u_int16_t)atoi(vlan);\n}\n\n/* ****************************************** */\n\nstatic NetworkInterface* handle_null_interface(lua_State* vm) {\n  char allowed_ifname[MAX_INTERFACE_NAME_LEN];\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"NULL interface: did you restart ntopng in the meantime?\");\n\n  if(ntop->getInterfaceAllowed(vm, allowed_ifname)) {\n      return ntop->getNetworkInterface(allowed_ifname);\n  }\n\n  return(ntop->getInterfaceAtId(0));\n}\n\n/* ****************************************** */\n\nstatic int ntop_dump_file(lua_State* vm) {\n  char *fname;\n  FILE *fd;\n  struct mg_connection *conn;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_HTTP_CONN);\n  if((conn = (struct mg_connection*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: null HTTP connection\");\n    return(CONST_LUA_ERROR);\n  }\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((fname = (char*)lua_tostring(vm, 1)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  ntop->fixPath(fname);\n  if((fd = fopen(fname, \"r\")) != NULL) {\n    char tmp[1024];\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Serving file %s\", fname);\n\n    while((fgets(tmp, sizeof(tmp)-256 /* To make sure we have room for replacements */, fd)) != NULL) {\n      for(int i=0; string_to_replace[i].key != NULL; i++)\n\tUtils::replacestr(tmp, string_to_replace[i].key, string_to_replace[i].val);\n\n      mg_printf(conn, \"%s\", tmp);\n    }\n\n    fclose(fd);\n    return(CONST_LUA_OK);\n  } else {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Unable to read file %s\", fname);\n    return(CONST_LUA_ERROR);\n  }\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get default interface name.\n * @details Push the default interface name of ntop into the lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK.\n */\nstatic int ntop_get_default_interface_name(lua_State* vm) {\n  char ifname[MAX_INTERFACE_NAME_LEN];\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop->getInterfaceAllowed(vm, ifname)) {\n    // if there is an allowed interface for the user\n    // we return that interface\n    lua_pushstring(vm,\n\t\t   ntop->getNetworkInterface(ifname)->get_name());\n  } else {\n    lua_pushstring(vm, ntop->getInterfaceAtId(NULL, /* no need to check as there is no constaint */\n\t\t\t\t\t      0)->get_name());\n  }\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Set the name of active interface id into lua stack.\n *\n * @param vm The lua stack.\n * @return @ref CONST_LUA_OK.\n */\nstatic int ntop_set_active_interface_id(lua_State* vm) {\n  NetworkInterface *iface;\n  int id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  id = (u_int32_t)lua_tonumber(vm, 1);\n\n  iface = ntop->getNetworkInterface(vm, id);\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"Index: %d, Name: %s\", id, iface ? iface->get_name() : \"<unknown>\");\n\n  if(iface != NULL)\n    lua_pushstring(vm, iface->get_name());\n  else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n/**\n * @brief Get the ntopng interface names.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK.\n */\nstatic int ntop_get_interface_names(lua_State* vm) {\n  lua_newtable(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  for(int i=0; i<ntop->get_num_interfaces(); i++) {\n    NetworkInterface *iface;\n\n    if((iface = ntop->getInterfaceAtId(vm, i)) != NULL) {\n      char num[8];\n\n      ntop->getTrace()->traceEvent(TRACE_DEBUG, \"Returning name %s\", iface->get_name());\n      snprintf(num, sizeof(num), \"%d\", i);\n      lua_push_str_table_entry(vm, num, iface->get_name());\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic AddressTree* get_allowed_nets(lua_State* vm) {\n  AddressTree *ptree;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_ALLOWED_NETS);\n  ptree = (AddressTree*)lua_touserdata(vm, lua_gettop(vm));\n  //ntop->getTrace()->traceEvent(TRACE_WARNING, \"GET %p\", ptree);\n  return(ptree);\n}\n\n/* ****************************************** */\n\nstatic NetworkInterface* getCurrentInterface(lua_State* vm) {\n  NetworkInterface *ntop_interface;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, \"ntop_interface\");\n  if((ntop_interface = (NetworkInterface*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop_interface = handle_null_interface(vm);\n  }\n\n  return(ntop_interface);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Find the network interface and set it as global variable to lua.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_select_interface(lua_State* vm) {\n  char *ifname;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TNIL)\n    ifname = (char*)\"any\";\n  else {\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n    ifname = (char*)lua_tostring(vm, 1);\n  }\n\n  lua_pushlightuserdata(vm, (char*)ntop->getNetworkInterface(vm, ifname));\n  lua_setglobal(vm, \"ntop_interface\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the nDPI statistics of interface.\n * @details Get the ntop interface global variable of lua, get nDpistats of interface and push it into lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_ndpi_interface_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  /* Optional host */\n  if(lua_type(vm, 1) == LUA_TSTRING) get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if(ntop_interface) {\n    ntop_interface->getnDPIStats(&stats, get_allowed_nets(vm), host_ip, vlan_id);\n\n    lua_newtable(vm);\n    stats.lua(ntop_interface, vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\n/**\n * @brief Get the Host Pool statistics of interface.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_host_pool_interface_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n    ntop_interface->luaHostPoolsStats(vm);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n\n}\n\n/**\n * @brief Get the Host Pool volatile members\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_host_pool_volatile_members(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n    ntop_interface->luaHostPoolsVolatileMembers(vm);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n\n}\n\n\n#endif\n\n/* ****************************************** */\n\n/**\n * @brief Get the ndpi flows count of interface.\n * @details Get the ntop interface global variable of lua, get nDpi flow count of interface and push it into lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_ndpi_interface_flows_count(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n    lua_newtable(vm);\n    ntop_interface->getnDPIFlowsCount(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the flow status for flows in cache\n * @details Get the ntop interface global variable of lua, get flow stats of interface and push it into lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_ndpi_interface_flows_status(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n    lua_newtable(vm);\n    ntop_interface->getFlowsStatus(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the ndpi protocol name of protocol id of network interface.\n * @details Get the ntop interface global variable of lua. Once do that, get the protocol id of lua stack and return into lua stack \"Host-to-Host Contact\" if protocol id is equal to host family id; the protocol name or null otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_ndpi_protocol_name(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  int proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  proto = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(proto == HOST_FAMILY_ID)\n    lua_pushstring(vm, \"Host-to-Host Contact\");\n  else {\n    if(ntop_interface)\n      lua_pushstring(vm, ntop_interface->get_ndpi_proto_name(proto));\n    else\n      lua_pushnil(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_protocol_id(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  char *proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  proto = (char*)lua_tostring(vm, 1);\n\n  if(ntop_interface && proto)\n    lua_pushnumber(vm, ntop_interface->get_ndpi_proto_id(proto));\n  else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_protocol_category(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  proto = (u_int)lua_tonumber(vm, 1);\n\n  if(ntop_interface) {\n    ndpi_protocol_category_t category = ntop_interface->get_ndpi_proto_category(proto);\n\n    lua_newtable(vm);\n    lua_push_int32_table_entry(vm, \"id\", category);\n    lua_push_str_table_entry(vm, \"name\", (char*)ndpi_category_str(category));\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Same as ntop_get_ndpi_protocol_name() with the exception that the protocol breed is returned\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_ndpi_protocol_breed(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  int proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  proto = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(proto == HOST_FAMILY_ID)\n    lua_pushstring(vm, \"Unrated-to-Host Contact\");\n  else {\n    if(ntop_interface)\n      lua_pushstring(vm, ntop_interface->get_ndpi_proto_breed_name(proto));\n    else\n      lua_pushnil(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_hosts(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool show_details = true;\n  char *sortColumn = (char*)\"column_ip\", *country = NULL, *os_filter = NULL, *mac_filter = NULL;\n  bool a2zSortOrder = true;\n  u_int16_t vlan_filter,  *vlan_filter_ptr    = NULL;\n  u_int32_t asn_filter,   *asn_filter_ptr     = NULL;\n  int16_t network_filter, *network_filter_ptr = NULL;\n  u_int16_t pool_filter, *pool_filter_ptr = NULL;\n  u_int32_t toSkip = 0, maxHits = CONST_MAX_NUM_HITS;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN) show_details   = lua_toboolean(vm, 1) ? true : false;\n  if(lua_type(vm, 2) == LUA_TSTRING)  sortColumn     = (char*)lua_tostring(vm, 2);\n  if(lua_type(vm, 3) == LUA_TNUMBER)  maxHits        = (u_int16_t)lua_tonumber(vm, 3);\n  if(lua_type(vm, 4) == LUA_TNUMBER)  toSkip         = (u_int16_t)lua_tonumber(vm, 4);\n  if(lua_type(vm, 5) == LUA_TBOOLEAN) a2zSortOrder   = lua_toboolean(vm, 5) ? true : false;\n  if(lua_type(vm, 6) == LUA_TSTRING)  country        = (char*)lua_tostring(vm, 6);\n  if(lua_type(vm, 7) == LUA_TSTRING)  os_filter      = (char*)lua_tostring(vm, 7);\n  if(lua_type(vm, 8) == LUA_TNUMBER)  vlan_filter    = (u_int16_t)lua_tonumber(vm, 8), vlan_filter_ptr = &vlan_filter;\n  if(lua_type(vm, 9) == LUA_TNUMBER)  asn_filter     = (u_int32_t)lua_tonumber(vm, 9), asn_filter_ptr = &asn_filter;\n  if(lua_type(vm,10) == LUA_TNUMBER)  network_filter = (int16_t)lua_tonumber(vm, 10),  network_filter_ptr = &network_filter;\n  if(lua_type(vm,11) == LUA_TSTRING)  mac_filter     = (char*)lua_tostring(vm, 11);\n  if(lua_type(vm,12) == LUA_TNUMBER)  pool_filter    = (u_int16_t)lua_tonumber(vm, 12), pool_filter_ptr = &pool_filter;\n\n  if(!ntop_interface ||\n    ntop_interface->getActiveHostsList(vm, get_allowed_nets(vm),\n                                       show_details, location,\n                                       country, mac_filter,\n\t\t\t\t       vlan_filter_ptr, os_filter, asn_filter_ptr,\n\t\t\t\t       network_filter_ptr, pool_filter_ptr,\n\t\t\t\t       sortColumn, maxHits,\n\t\t\t\t       toSkip, a2zSortOrder) < 0)\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_latest_activity_hosts_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  ntop_interface->getLatestActivityHostsList(vm, get_allowed_nets(vm));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the host information of network interface grouped according to the criteria.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or the host is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_grouped_interface_hosts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool show_details = true, hostsOnly = true;\n  char *country = NULL, *os_filter = NULL;\n  char *groupBy = (char*)\"column_ip\";\n  u_int16_t vlan_filter,  *vlan_filter_ptr    = NULL;\n  u_int32_t asn_filter,   *asn_filter_ptr     = NULL;\n  u_int16_t pool_filter,  *pool_filter_ptr    = NULL;\n  int16_t network_filter, *network_filter_ptr = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN) show_details = lua_toboolean(vm, 1) ? true : false;\n  if(lua_type(vm, 2) == LUA_TSTRING)  groupBy    = (char*)lua_tostring(vm, 2);\n  if(lua_type(vm, 3) == LUA_TSTRING)  country = (char*)lua_tostring(vm, 3);\n  if(lua_type(vm, 4) == LUA_TSTRING)  os_filter      = (char*)lua_tostring(vm, 4);\n  if(lua_type(vm, 5) == LUA_TNUMBER)  vlan_filter    = (u_int16_t)lua_tonumber(vm, 5), vlan_filter_ptr = &vlan_filter;\n  if(lua_type(vm, 6) == LUA_TNUMBER)  asn_filter     = (u_int32_t)lua_tonumber(vm, 6), asn_filter_ptr = &asn_filter;\n  if(lua_type(vm, 7) == LUA_TNUMBER)  network_filter = (int16_t)lua_tonumber(vm, 7),  network_filter_ptr = &network_filter;\n  if(lua_type(vm, 8) == LUA_TBOOLEAN) hostsOnly      = lua_toboolean(vm, 8) ? true : false;\n  if(lua_type(vm, 9) == LUA_TNUMBER)  pool_filter    = (u_int16_t)lua_tonumber(vm, 9), pool_filter_ptr = &pool_filter;\n\n  if((!ntop_interface)\n     || ntop_interface->getActiveHostsGroup(vm, get_allowed_nets(vm),\n\t\t\t\t\t    show_details, location_all,\n\t\t\t\t\t    country,\n\t\t\t\t\t    vlan_filter_ptr, os_filter,\n\t\t\t\t\t    asn_filter_ptr, network_filter_ptr,\n\t\t\t\t\t    pool_filter_ptr,\n\t\t\t\t\t    hostsOnly, groupBy) < 0)\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the hosts information of network interface.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the host information.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_hosts_info(lua_State* vm) {\n  return(ntop_get_interface_hosts(vm, location_all));\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_macs_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *sortColumn = (char*)\"column_mac\";\n  u_int32_t toSkip = 0, maxHits = CONST_MAX_NUM_HITS;\n  u_int16_t vlan_id = 0;\n  bool a2zSortOrder = true,\n    skipSpecialMacs = false, hostMacsOnly = false;\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    sortColumn = (char*)lua_tostring(vm, 1);\n\n    if(lua_type(vm, 2) == LUA_TNUMBER) {\n      maxHits = (u_int16_t)lua_tonumber(vm, 2);\n\n      if(lua_type(vm, 3) == LUA_TNUMBER) {\n\ttoSkip = (u_int16_t)lua_tonumber(vm, 3);\n\n\tif(lua_type(vm, 4) == LUA_TBOOLEAN) {\n\t  a2zSortOrder = lua_toboolean(vm, 4) ? true : false;\n\n\t  if(lua_type(vm, 5) == LUA_TNUMBER) {\n\t    vlan_id = (u_int16_t)lua_tonumber(vm, 5);\n\n\t    if(lua_type(vm, 6) == LUA_TBOOLEAN) {\n\t      skipSpecialMacs = lua_toboolean(vm, 6) ? true : false;\n\t    }\n\t    if(lua_type(vm, 7) == LUA_TBOOLEAN) {\n\t      hostMacsOnly = lua_toboolean(vm, 7) ? true : false;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(!ntop_interface ||\n     ntop_interface->getActiveMacList(vm, vlan_id, skipSpecialMacs,\n\t\t\t\t      hostMacsOnly,\n\t\t\t\t      sortColumn, maxHits,\n\t\t\t\t      toSkip, a2zSortOrder) < 0)\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_mac_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *mac = NULL;\n  u_int16_t vlan_id = 0;\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    mac = (char*)lua_tostring(vm, 1);\n\n    if(lua_type(vm, 2) == LUA_TNUMBER) {\n      vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n    }\n  }\n\n  if((!ntop_interface)\n     || (!mac)\n     || (!ntop_interface->getMacInfo(vm, mac, vlan_id)))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_mac_manufacturer(lua_State* vm) {\n  const char *mac = NULL;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  mac = (char*)lua_tostring(vm, 1);\n\n  ntop->getMacManufacturer(mac, vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_site_categories(lua_State* vm) {\n  Flashstart *flash = ntop->get_flashstart();\n\n  if (!flash)\n    lua_pushnil(vm);\n  else\n    flash->lua(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get local hosts information of network interface.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the local host information.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_local_hosts_info(lua_State* vm) {\n  return(ntop_get_interface_hosts(vm, location_local_only));\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get remote hosts information of network interface.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the remote host information.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_remote_hosts_info(lua_State* vm) {\n  return(ntop_get_interface_hosts(vm, location_remote_only));\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get local hosts activity information.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the local host activities.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or host is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  const char * host = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if (lua_type(vm, 1) == LUA_TSTRING)\n    host = lua_tostring(vm, 1);\n\n  if (ntop_interface == NULL || host == NULL)\n    return CONST_LUA_ERROR;\n\n  ntop_interface->getLocalHostActivity(vm, host);\n\n  return CONST_LUA_OK;\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the specified path is a directory and it exists.\n * @details True if if the specified path is a directory and it exists, false otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_is_dir(lua_State* vm) {\n  char *path;\n  struct stat buf;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  rc = ((stat(path, &buf) != 0) || (!S_ISDIR(buf.st_mode))) ? 0 : 1;\n  lua_pushboolean(vm, rc);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the file is exists and is not empty\n * @details Simple check for existance + non empty file\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_is_not_empty_file(lua_State* vm) {\n  char *path;\n  struct stat buf;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  rc = (stat(path, &buf) != 0) ? 0 : 1;\n  if(rc && (buf.st_size == 0)) rc = 0;\n  lua_pushboolean(vm, rc);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the file or directory exists.\n * @details Get the path of file/directory from to lua stack and push true into lua stack if it exists, false otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_get_file_dir_exists(lua_State* vm) {\n  char *path;\n  struct stat buf;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  rc = (stat(path, &buf) != 0) ? 0 : 1;\n  //   ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s: %d\", path, rc);\n  lua_pushboolean(vm, rc);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Return the epoch of the file last change\n * @details This function return that time (epoch) of the last chnge on a file, or -1 if the file does not exist.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_get_file_last_change(lua_State* vm) {\n  char *path;\n  struct stat buf;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  if(stat(path, &buf) == 0)\n    lua_pushnumber(vm, (lua_Number)buf.st_mtime);\n  else\n    lua_pushnumber(vm, -1); /* not found */\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if ntop has seen VLAN tagged packets on this interface.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_has_vlans(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface)\n    lua_pushboolean(vm, ntop_interface->hasSeenVlanTaggedPackets());\n  else\n    lua_pushboolean(vm, 0);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if ntop has loaded ASN information (via GeoIP)\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_has_geoip(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if ntop is running on windows.\n * @details Push into lua stack 1 if ntop is running on windows, 0 otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_is_windows(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm,\n#ifdef WIN32\n\t\t  1\n#else\n\t\t  0\n#endif\n\t\t  );\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_allocHostBlacklist(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop->allocHostBlacklist();\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_swapHostBlacklist(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop->swapHostBlacklist();\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_addToHostBlacklist(lua_State* vm) {\n  char *net;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  net = (char*)lua_tostring(vm, 1);\n\n  ntop->addToHostBlacklist(net);\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Wrapper for the libc call getservbyport()\n * @details Wrapper for the libc call getservbyport()\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_getservbyport(lua_State* vm) {\n  int port;\n  char *proto;\n  struct servent *s = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  port = (int)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  proto = (char*)lua_tostring(vm, 2);\n\n  if((port > 0) && (proto != NULL))\n    s = getservbyport(htons(port), proto);\n\n  if(s && s->s_name)\n    lua_pushstring(vm, s->s_name);\n  else {\n    char buf[32];\n\n    snprintf(buf, sizeof(buf), \"%d\", port);\n    lua_pushstring(vm, buf);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Scan the input directory and return the list of files.\n * @details Get the path from the lua stack and push into a new hashtable the files name existing in the directory.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_list_dir_files(lua_State* vm) {\n  char *path;\n  DIR *dirp;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n  ntop->fixPath(path);\n\n  lua_newtable(vm);\n\n  if((dirp = opendir(path)) != NULL) {\n    struct dirent *dp;\n\n    while ((dp = readdir(dirp)) != NULL)\n      if((dp->d_name[0] != '\\0')\n\t && (dp->d_name[0] != '.')) {\n\tlua_push_str_table_entry(vm, dp->d_name, dp->d_name);\n      }\n    (void)closedir(dirp);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/* Adapted from http://stackoverflow.com/questions/2256945/removing-a-non-empty-directory-programmatically-in-c-or-c */\nstatic int remove_recursively(const char * path) {\n  DIR *d = opendir(path);\n  size_t path_len = strlen(path);\n  int r = -1;\n  size_t len;\n  char *buf;\n\n  if (d) {\n    struct dirent *p;\n\n    r = 0;\n\n    while ((r==0) && (p=readdir(d))) {\n      /* Skip the names \".\" and \"..\" as we don't want to recurse on them. */\n      if (!strcmp(p->d_name, \".\") || !strcmp(p->d_name, \"..\"))\n         continue;\n\n      len = path_len + strlen(p->d_name) + 2;\n      buf = (char *) malloc(len);\n\n      if (buf) {\n        struct stat statbuf;\n\n        snprintf(buf, len, \"%s/%s\", path, p->d_name);\n\n        if (stat(buf, &statbuf) == 0) {\n          if (S_ISDIR(statbuf.st_mode))\n            r = remove_recursively(buf);\n          else\n            r = unlink(buf);\n        }\n\n        free(buf);\n      }\n    }\n\n    closedir(d);\n  }\n\n  if (r == 0)\n    r = rmdir(path);\n\n  return r;\n}\n\n/**\n * @brief Scan the input directory, removes it and its contets.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_remove_dir_recursively(lua_State* vm) {\n  char *path;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n  ntop->fixPath(path);\n\n  remove_recursively(path);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the system time and push it into the lua stack.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_gettimemsec(lua_State* vm) {\n  struct timeval tp;\n  double ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  gettimeofday(&tp, NULL);\n\n  ret = (((double)tp.tv_usec) / (double)1000) + tp.tv_sec;\n\n  lua_pushnumber(vm, ret);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Lua-equivaled ot C inet_ntoa\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_inet_ntoa(lua_State* vm) {\n  u_int32_t ip;\n  struct in_addr in;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING)\n    ip = atol((char*)lua_tostring(vm, 1));\n  else if(lua_type(vm, 1) == LUA_TNUMBER)\n    ip = (u_int32_t)lua_tonumber(vm, 1);\n  else\n    return(CONST_LUA_ERROR);\n\n  in.s_addr = htonl(ip);\n  lua_pushstring(vm, inet_ntoa(in));\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_zmq_connect(lua_State* vm) {\n  char *endpoint, *topic;\n  void *context, *subscriber;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((endpoint = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((topic = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  context = zmq_ctx_new(), subscriber = zmq_socket(context, ZMQ_SUB);\n\n  if(zmq_connect(subscriber, endpoint) != 0) {\n    zmq_close(subscriber);\n    zmq_ctx_destroy(context);\n    return(CONST_LUA_PARAM_ERROR);\n  }\n\n  if(zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, topic, strlen(topic)) != 0) {\n    zmq_close(subscriber);\n    zmq_ctx_destroy(context);\n    return -1;\n  }\n\n  lua_pushlightuserdata(vm, context);\n  lua_setglobal(vm, \"zmq_context\");\n\n  lua_pushlightuserdata(vm, subscriber);\n  lua_setglobal(vm, \"zmq_subscriber\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Delete the specified member(field) from the redis hash stored at key.\n * @details Get the key parameter from the lua stack and delete it from redis.\n *\n * @param vm The lua stack.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_delete_redis_key(lua_State* vm) {\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n  ntop->getRedis()->del(key);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/* ****************************************** */\n\n/**\n * @brief Add a member to the a redis set.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_add_set_member_redis(lua_State* vm) {\n  char *key, *value;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if (ntop->getRedis()->sadd(key, value) == 0)\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/**\n * @brief Removes a member from a redis set.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_del_set_member_redis(lua_State* vm) {\n  char *key, *value;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if (ntop->getRedis()->srem(key, value) == 0)\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the members of a redis set.\n * @details Get the set key form the lua stack and push the mambers name into lua stack.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_get_set_members_redis(lua_State* vm) {\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n  ntop->getRedis()->smembers(vm, key);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Delete the specified member(field) from the redis hash stored at key.\n * @details Get the member name and the hash key form the lua stack and remove the specified member.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_delete_hash_redis_key(lua_State* vm) {\n  char *key, *member;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  ntop->getRedis()->hashDel(key, member);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_zmq_disconnect(lua_State* vm) {\n  void *context, *subscriber;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, \"zmq_context\");\n  if((context = (void*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: NULL context\");\n    return(CONST_LUA_ERROR);\n  }\n\n  lua_getglobal(vm, \"zmq_subscriber\");\n  if((subscriber = (void*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: NULL subscriber\");\n    return(CONST_LUA_ERROR);\n  }\n\n  zmq_close(subscriber);\n  zmq_ctx_destroy(context);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_zmq_receive(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  void *subscriber;\n  int size;\n  struct zmq_msg_hdr h;\n  char *payload;\n  int payload_len;\n  zmq_pollitem_t item;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, \"zmq_subscriber\");\n  if((subscriber = (void*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: NULL subscriber\");\n    return(CONST_LUA_ERROR);\n  }\n\n  item.socket = subscriber;\n  item.events = ZMQ_POLLIN;\n  do {\n    rc = zmq_poll(&item, 1, 1000);\n    if(rc < 0 || !ntop_interface->isRunning()) /* CHECK */\n      return(CONST_LUA_PARAM_ERROR);\n  } while (rc == 0);\n\n  size = zmq_recv(subscriber, &h, sizeof(h), 0);\n\n  if(size != sizeof(h) || h.version != ZMQ_MSG_VERSION) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unsupported publisher version [%d]\", h.version);\n    return -1;\n  }\n\n  payload_len = h.size + 1;\n  if((payload = (char*)malloc(payload_len)) != NULL) {\n    size = zmq_recv(subscriber, payload, payload_len, 0);\n    payload[h.size] = '\\0';\n\n    if(size > 0) {\n      enum json_tokener_error jerr = json_tokener_success;\n      json_object *o = json_tokener_parse_verbose(payload, &jerr);\n\n      if(o != NULL) {\n\tstruct json_object_iterator it = json_object_iter_begin(o);\n\tstruct json_object_iterator itEnd = json_object_iter_end(o);\n\n\twhile (!json_object_iter_equal(&it, &itEnd)) {\n\t  char *key   = (char*)json_object_iter_peek_name(&it);\n\t  const char *value = json_object_get_string(json_object_iter_peek_value(&it));\n\n\t  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[%s]=[%s]\", key, value);\n\n\t  json_object_iter_next(&it);\n\t}\n\n\tjson_object_put(o);\n      } else\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"JSON Parse error [%s]: %s\",\n\t\t\t\t     json_tokener_error_desc(jerr),\n\t\t\t\t     payload);\n\n      lua_pushfstring(vm, \"%s\", payload);\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[%u] %s\", h.size, payload);\n      free(payload);\n      return(CONST_LUA_OK);\n    } else {\n      free(payload);\n      return(CONST_LUA_PARAM_ERROR);\n    }\n  } else\n    return(CONST_LUA_PARAM_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_local_networks(lua_State* vm) {\n  lua_newtable(vm);\n  ntop->getLocalNetworks(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reload_preferences(lua_State* vm) {\n  lua_newtable(vm);\n  ntop->getPrefs()->reloadPrefsFromRedis();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the trace level of ntop is verbose.\n * @details Push true into the lua stack if the trace level of ntop is set to MAX_TRACE_LEVEL, false otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_verbose_trace(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm, (ntop->getTrace()->get_trace_level() == MAX_TRACE_LEVEL) ? true : false);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_send_udp_data(lua_State* vm) {\n  int rc, port, sockfd = ntop->getUdpSock();\n  char *host, *data;\n\n  if(sockfd == -1)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  host = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  port = (u_int16_t)lua_tonumber(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  data = (char*)lua_tostring(vm, 3);\n\n  if(strchr(host, ':') != NULL) {\n    struct sockaddr_in6 server_addr;\n\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin6_family = AF_INET6;\n    inet_pton(AF_INET6, host, &server_addr.sin6_addr);\n    server_addr.sin6_port = htons(port);\n\n    rc = sendto(sockfd, data, strlen(data),0,\n\t\t(struct sockaddr *)&server_addr,\n\t\tsizeof(server_addr));\n  } else {\n    struct sockaddr_in server_addr;\n\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(host); /* FIX: add IPv6 support */\n    server_addr.sin_port = htons(port);\n\n    rc = sendto(sockfd, data, strlen(data),0,\n\t\t(struct sockaddr *)&server_addr,\n\t\tsizeof(server_addr));\n  }\n\n  if(rc == -1)\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_flows(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char buf[64];\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  Host *host = NULL;\n  Paginator *p = NULL;\n  int numFlows = -1;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  if((p = new(std::nothrow) Paginator()) == NULL)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n    host = ntop_interface->getHost(host_ip, vlan_id);\n  }\n\n  if(lua_type(vm, 2) == LUA_TTABLE)\n    p->readOptions(vm, 2);\n\n  if(ntop_interface)\n    numFlows = ntop_interface->getFlows(vm, get_allowed_nets(vm), location, host, p);\n\n  if(p) delete p;\n  return numFlows < 0 ? CONST_LUA_ERROR : CONST_LUA_OK;\n}\n\nstatic int ntop_get_interface_flows_info(lua_State* vm)        { return(ntop_get_interface_flows(vm, location_all));          }\nstatic int ntop_get_interface_local_flows_info(lua_State* vm)  { return(ntop_get_interface_flows(vm, location_local_only));   }\nstatic int ntop_get_interface_remote_flows_info(lua_State* vm) { return(ntop_get_interface_flows(vm, location_remote_only));  }\n\n/* ****************************************** */\n\n/**\n * @brief Get nDPI stats for flows\n * @details Compute nDPI flow statistics\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_get_interface_flows_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(ntop_interface) ntop_interface->getFlowsStats(vm);\n\n  return(CONST_LUA_OK);\n}\n/* ****************************************** */\n\n/**\n * @brief Get interface stats for local networks\n * @details Returns traffic statistics per local network\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_get_interface_networks_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(ntop_interface) ntop_interface->getNetworksStats(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the host information of network interface.\n * @details Get the ntop interface global variable of lua, the host ip and optional the VLAN id form the lua stack and push a new hash table of hash tables containing the host information into lua stack.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or the host is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_host_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->getHostInfo(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n#ifdef NOTUSED\nstatic int ntop_get_grouped_interface_host(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *country_s = NULL, *os_s = NULL;\n  u_int16_t vlan_n,    *vlan_ptr    = NULL;\n  u_int32_t as_n,      *as_ptr      = NULL;\n  int16_t   network_n, *network_ptr = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TNUMBER) vlan_n    = (u_int16_t)lua_tonumber(vm, 1), vlan_ptr  = &vlan_n;\n  if(lua_type(vm, 2) == LUA_TNUMBER) as_n      = (u_int32_t)lua_tonumber(vm, 2), as_ptr    = &as_n;\n  if(lua_type(vm, 3) == LUA_TNUMBER) network_n = (int16_t)lua_tonumber(vm, 3), network_ptr = &network_n;\n  if(lua_type(vm, 4) == LUA_TSTRING) country_s = (char*)lua_tostring(vm, 4);\n  if(lua_type(vm, 5) == LUA_TSTRING) os_s      = (char*)lua_tostring(vm, 5);\n\n  if(!ntop_interface || ntop_interface->getActiveHostsGroup(vm, get_allowed_nets(vm), false, false, country_s, vlan_ptr, os_s, as_ptr,\n\t\t\t\t\t\t\t    network_ptr, (char*)\"column_ip\", (char*)\"country\", CONST_MAX_NUM_HITS, 0 /* toSkip */, true /* a2zSortOrder */) < 0)\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n#endif\n\n/* ****************************************** */\n\nstatic int ntop_getflowdevices(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n  else {\n    ntop_interface->getFlowDevices(vm);\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_getflowdeviceinfo(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *device_ip;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  device_ip = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n  else {\n    in_addr_t addr = inet_addr(device_ip);\n\n    ntop_interface->getFlowDeviceInfo(vm, ntohl(addr));\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_load_host_alert_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->loadHostAlertPrefs(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_host_reset_periodic_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->resetPeriodicStats();\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_host_trigger_alerts(lua_State* vm, bool trigger) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER)\n    vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(trigger)\n    h->enableAlerts();\n  else\n    h->disableAlerts();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_host_enable_alerts(lua_State* vm) {\n  return ntop_interface_host_trigger_alerts(vm, true);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_host_disable_alerts(lua_State* vm) {\n  return ntop_interface_host_trigger_alerts(vm, false);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_refresh_num_alerts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  AlertsManager *am;\n  Host *h;\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  u_int32_t num_alerts;\n  char buf[128];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((!ntop_interface))\n    return(CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n    /* Optional VLAN id */\n    if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n    if((h = ntop_interface->getHost(host_ip, vlan_id))) {\n\n      if(lua_type(vm, 3) == LUA_TNUMBER) {\n\tnum_alerts = (u_int32_t)lua_tonumber(vm, 3);\n\th->setNumAlerts(num_alerts);\n      } else {\n\th->getNumAlerts(true /* From AlertsManager re-reads the values */);\n      }\n    }\n\n  } else {\n\n    if((am = ntop_interface->getAlertsManager()) == NULL)\n      return(CONST_LUA_ERROR);\n\n    am->refreshCachedNumAlerts();\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_correalate_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n   /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->correlateHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_similar_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->similarHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_host_activitymap(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  GenericHost *h;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)  return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  h = ntop_interface->getHost(host_ip, vlan_id);\n\n  if(h == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    if(h->match(get_allowed_nets(vm))) {\n      char *json = h->getJsonActivityMap();\n\n      lua_pushfstring(vm, \"%s\", json);\n      free(json);\n    }\n\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\n/**\n * @brief Restore the host of network interface.\n * @details Get the ntop interface global variable of lua and the IP address of host form the lua stack and restore the host into hash host of network interface.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or if is impossible to restore the host, CONST_LUA_OK otherwise.\n */\nstatic int ntop_restore_interface_host(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  bool skip_privileges_check = false;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* make sure skip privileges check cannot be set from the web interface */\n  if(lua_type(vm, 2) == LUA_TBOOLEAN) skip_privileges_check = lua_toboolean(vm, 2);\n\n  if(!skip_privileges_check && !Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if((!ntop_interface) || !ntop_interface->restoreHost(host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_flow_key(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  Host *cli, *srv;\n  char *cli_name = NULL; u_int16_t cli_vlan = 0; u_int16_t cli_port = 0;\n  char *srv_name = NULL; u_int16_t srv_vlan = 0; u_int16_t srv_port = 0;\n  u_int16_t protocol;\n  char cli_buf[256], srv_buf[256];\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)    /* cli_host@cli_vlan */\n     || ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER) /* cli port          */\n     || ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING) /* srv_host@srv_vlan */\n     || ntop_lua_check(vm, __FUNCTION__, 4, LUA_TNUMBER) /* srv port          */\n     || ntop_lua_check(vm, __FUNCTION__, 5, LUA_TNUMBER) /* protocol          */\n     ) return(CONST_LUA_ERROR);\n\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &cli_name, &cli_vlan, cli_buf, sizeof(cli_buf));\n  cli_port = htons((u_int16_t)lua_tonumber(vm, 2));\n\n  get_host_vlan_info((char*)lua_tostring(vm, 3), &srv_name, &srv_vlan, srv_buf, sizeof(srv_buf));\n  srv_port = htons((u_int16_t)lua_tonumber(vm, 4));\n\n  protocol = (u_int16_t)lua_tonumber(vm, 5);\n\n  if(cli_vlan != srv_vlan) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Client and Server vlans don't match.\");\n    return(CONST_LUA_ERROR);\n  }\n\n  if(cli_name == NULL || srv_name == NULL\n     ||(cli = ntop_interface->getHost(cli_name, cli_vlan)) == NULL\n     ||(srv = ntop_interface->getHost(srv_name, srv_vlan)) == NULL) {\n    lua_pushnil(vm);\n  } else {\n    lua_pushnumber(vm, Flow::key(cli, cli_port, srv, srv_port, cli_vlan, protocol));\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_flow_by_key(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t key;\n  Flow *f;\n  AddressTree *ptree = get_allowed_nets(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(false);\n\n  f = ntop_interface->findFlowByKey(key, ptree);\n\n  if(f == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    f->lua(vm, ptree, details_high, false);\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_drop_flow_traffic(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t key;\n  Flow *f;\n  AddressTree *ptree = get_allowed_nets(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(false);\n\n  f = ntop_interface->findFlowByKey(key, ptree);\n\n  if(f == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    f->setDropVerdict();\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_dump_flow_traffic(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t key, what;\n  Flow *f;\n  AddressTree *ptree = get_allowed_nets(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  what = (u_int32_t)lua_tonumber(vm, 2);\n\n  if(!ntop_interface) return(false);\n\n  f = ntop_interface->findFlowByKey(key, ptree);\n\n  if(f == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    f->setDumpFlowTraffic(what ? true : false);\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_dump_local_hosts_2_redis(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop_interface->dumpLocalHosts2redis(true /* must disable purge as we are called from lua */);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_user_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  key = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findUserFlows(vm, key);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_pid_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t pid;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  pid = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findPidFlows(vm, pid);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_father_pid_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t father_pid;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  father_pid = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findFatherPidFlows(vm, father_pid);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_proc_name_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *proc_name;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  proc_name = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findProcNameFlows(vm, proc_name);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_list_http_hosts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) != LUA_TSTRING) /* Optional */\n    key = NULL;\n  else\n    key = (char*)lua_tostring(vm, 1);\n\n  ntop_interface->listHTTPHosts(vm, key);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_host(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  key = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  ntop_interface->findHostsByName(vm, get_allowed_nets(vm), key);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_update_host_traffic_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->updateHostTrafficPolicy(host_ip);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_update_host_alert_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->readAlertPrefs();\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_second_traffic(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  ntop_interface->updateSecondTraffic(time(NULL));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_host_dump_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  bool dump_traffic_to_disk;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TBOOLEAN)) return(CONST_LUA_ERROR);\n  dump_traffic_to_disk = lua_toboolean(vm, 1) ? true : false;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 2), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 3) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 3);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->setDumpTrafficPolicy(dump_traffic_to_disk);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_host_hit_rate(lua_State* vm) {\n#ifdef NOTUSED\n    NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  u_int32_t peer_key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  peer_key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 2), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 3) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 3);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->getPeerBytes(vm, peer_key);\n  return(CONST_LUA_OK);\n#else\n  return(CONST_LUA_ERROR); // not supported\n#endif\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_host_quota(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  u_int32_t quota;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  quota = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 2), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 3) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 3);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->setQuota(quota);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_tap_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool dump_traffic_to_tap;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  dump_traffic_to_tap = ntop_interface->getDumpTrafficTapPolicy();\n\n  lua_pushboolean(vm, dump_traffic_to_tap ? 1 : 0);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_tap_name(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, ntop_interface->getDumpTrafficTapName());\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_disk_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool dump_traffic_to_disk;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  dump_traffic_to_disk = ntop_interface->getDumpTrafficDiskPolicy();\n\n  lua_pushboolean(vm, dump_traffic_to_disk ? 1 : 0);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_max_pkts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int max_pkts;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  max_pkts = ntop_interface->getDumpTrafficMaxPktsPerFile();\n\n  lua_pushnumber(vm, max_pkts);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_max_sec(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int max_sec;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  max_sec = ntop_interface->getDumpTrafficMaxSecPerFile();\n\n  lua_pushnumber(vm, max_sec);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_max_files(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int max_files;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  max_files = ntop_interface->getDumpTrafficMaxFiles();\n\n  lua_pushnumber(vm, max_files);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_pkts_dumped_file(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int num_pkts;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  PacketDumper *dumper = ntop_interface->getPacketDumper();\n  if(!dumper)\n    return(CONST_LUA_ERROR);\n\n  num_pkts = dumper->get_num_dumped_packets();\n\n  lua_pushnumber(vm, num_pkts);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_pkts_dumped_tap(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int num_pkts;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  PacketDumperTuntap *dumper = ntop_interface->getPacketDumperTap();\n  if(!dumper)\n    return(CONST_LUA_ERROR);\n\n  num_pkts = dumper->get_num_dumped_packets();\n\n  lua_pushnumber(vm, num_pkts);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_endpoint(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int8_t id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) != LUA_TNUMBER) /* Optional */\n    id = 0;\n  else\n    id = (u_int8_t)lua_tonumber(vm, 1);\n\n  if(ntop_interface) {\n    char *endpoint = ntop_interface->getEndpoint(id); /* CHECK */\n\n    lua_pushfstring(vm, \"%s\", endpoint ? endpoint : \"\");\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_packet_interface(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  lua_pushboolean(vm, ntop_interface->isPacketInterface());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_bridge_interface(lua_State* vm) {\n  int ifid;\n  NetworkInterface *iface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((lua_type(vm, 1) == LUA_TNUMBER)) {\n    ifid = lua_tointeger(vm, 1);\n\n    if(ifid < 0 || !(iface = ntop->getNetworkInterface(ifid)))\n      return (CONST_LUA_ERROR);\n  }\n\n  lua_pushboolean(vm, iface->is_bridge_interface());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_pcap_dump_interface(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  const char *interface_type;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface\n     || ((interface_type = ntop_interface->get_type()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  lua_pushboolean(vm, strcmp(interface_type, CONST_INTERFACE_TYPE_PCAP_DUMP) == 0);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_running(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  return(ntop_interface->isRunning());\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_idle(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  return(ntop_interface->idle());\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_set_idle(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool state;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TBOOLEAN)) return(CONST_LUA_ERROR);\n  state = lua_toboolean(vm, 1) ? true : false;\n\n  ntop_interface->setIdleState(state);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_name2id(lua_State* vm) {\n  char *if_name;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TNIL)\n    if_name = NULL;\n  else {\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n    if_name = (char*)lua_tostring(vm, 1);\n  }\n\n  lua_pushinteger(vm, ntop->getInterfaceIdByName(if_name));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_protocols(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  ndpi_protocol_category_t category_filter;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((lua_type(vm, 1) == LUA_TNUMBER)) {\n    category_filter = (ndpi_protocol_category_t)lua_tointeger(vm, 1);\n\n    if(category_filter >= NDPI_PROTOCOL_NUM_CATEGORIES)\n      return (CONST_LUA_ERROR);\n\n    ntop_interface->getnDPIProtocols(vm, category_filter);\n  } else\n    ntop_interface->getnDPIProtocols(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_categories(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_newtable(vm);\n\n  for (int i=0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {\n    char buf[8];\n\n    snprintf(buf, sizeof(buf), \"%d\", i);\n    lua_push_str_table_entry(vm, ndpi_category_str((ndpi_protocol_category_t)i), buf);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_load_dump_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop_interface->loadDumpPrefs();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_load_scaling_factor_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop_interface->loadScalingFactorPrefs();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/*\n  Code partially taken from third-party/rrdtool-1.4.7/bindings/lua/rrdlua.c\n  and made reentrant\n*/\n\nstatic void reset_rrd_state(void) {\n  optind = 0;\n  opterr = 0;\n  rrd_clear_error();\n}\n\n/* ****************************************** */\n\nstatic const char **make_argv(lua_State * vm, u_int offset) {\n  const char **argv;\n  int i;\n  int argc = lua_gettop(vm) - offset;\n\n  if(!(argv = (const char**)calloc(argc, sizeof (char *))))\n    /* raise an error and never return */\n    luaL_error(vm, \"Can't allocate memory for arguments array\");\n\n  /* fprintf(stderr, \"%s\\n\", argv[0]); */\n  for(i=0; i<argc; i++) {\n    u_int idx = i + offset;\n    /* accepts string or number */\n    if(lua_isstring(vm, idx) || lua_isnumber(vm, idx)) {\n      if(!(argv[i] = (char*)lua_tostring (vm, idx))) {\n\t/* raise an error and never return */\n\tluaL_error(vm, \"Error duplicating string area for arg #%d\", i);\n      }\n    } else {\n      /* raise an error and never return */\n      luaL_error(vm, \"Invalid arg #%d: args must be strings or numbers\", i);\n    }\n\n    // ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[%d] %s\", i, argv[i]);\n  }\n\n  return(argv);\n}\n\n/* ****************************************** */\n\nstatic int ntop_rrd_create(lua_State* vm) {\n  const char *filename;\n  unsigned long pdp_step;\n  const char **argv;\n  int argc, status, offset = 3;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((filename = (const char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  pdp_step = (unsigned long)lua_tonumber(vm, 2);\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s(%s)\", __FUNCTION__, filename);\n\n  argc = lua_gettop(vm) - offset;\n  argv = make_argv(vm, offset);\n\n  reset_rrd_state();\n  status = rrd_create_r(filename, pdp_step, time(NULL)-86400 /* 1 day */, argc, argv);\n  free(argv);\n\n  if(status != 0) {\n    char *err = rrd_get_error();\n\n    if(err != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_ERROR);\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_rrd_update(lua_State* vm) {\n  const char *filename, *update_arg;\n  int status;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((filename = (const char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((update_arg = (const char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s(%s) %s\", __FUNCTION__, filename, update_arg);\n\n  reset_rrd_state();\n  status = rrd_update_r(filename, NULL, 1, &update_arg);\n\n  if(status != 0) {\n    char *err = rrd_get_error();\n\n    if(err != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_ERROR);\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_rrd_lastupdate(lua_State* vm) {\n  const char *filename;\n  time_t    last_update;\n  char    **ds_names;\n  char    **last_ds;\n  unsigned long ds_count, i;\n  int status;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((filename = (const char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  status = rrd_lastupdate_r(filename, &last_update, &ds_count, &ds_names, &last_ds);\n\n  if(status != 0) {\n    return(CONST_LUA_ERROR);\n  } else {\n    for(i = 0; i < ds_count; i++)\n      free(last_ds[i]), free(ds_names[i]);\n\n    free(last_ds), free(ds_names);\n\n    lua_pushnumber(vm, last_update);\n    lua_pushnumber(vm, ds_count);\n    return(2 /* 2 values returned */);\n  }\n}\n\n/* ****************************************** */\n\n/* positional 1:4 parameters for ntop_rrd_fetch */\nstatic int __ntop_rrd_args (lua_State* vm, char **filename, char **cf, time_t *start, time_t *end) {\n  char *start_s, *end_s, *err;\n  rrd_time_value_t start_tv, end_tv;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((*filename = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((*cf = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if((lua_type(vm, 3) == LUA_TNUMBER) && (lua_type(vm, 4) == LUA_TNUMBER))\n    *start = (time_t)lua_tonumber(vm, 3), *end = (time_t)lua_tonumber(vm, 4);\n  else {\n    if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n    if((start_s = (char*)lua_tostring(vm, 3)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n    if((err = rrd_parsetime(start_s, &start_tv)) != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_PARAM_ERROR);\n    }\n\n    if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n    if((end_s = (char*)lua_tostring(vm, 4)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n    if((err = rrd_parsetime(end_s, &end_tv)) != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_PARAM_ERROR);\n    }\n\n    if(rrd_proc_start_end(&start_tv, &end_tv, start, end) == -1)\n      return(CONST_LUA_PARAM_ERROR);\n  }\n\n  return(CONST_LUA_OK);\n}\n\nstatic int __ntop_rrd_status(lua_State* vm, int status, char *filename, char *cf) {\n  char * err;\n\n  if(status != 0) {\n    err = rrd_get_error();\n\n    if(err != NULL) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR,\n                                   \"Error '%s' while calling rrd_fetch_r(%s, %s): is the RRD corrupted perhaps?\",\n                                   err, filename, cf);\n      lua_pushnil(vm);\n      lua_pushnil(vm);\n      lua_pushnil(vm);\n      lua_pushnil(vm);\n      return(CONST_LUA_ERROR);\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* Fetches data from RRD by rows */\nstatic int ntop_rrd_fetch(lua_State* vm) {\n  unsigned long i, j, step = 0, ds_cnt = 0;\n  rrd_value_t *data, *p;\n  char **names;\n  char *filename, *cf;\n  time_t t, start, end;\n  int status;\n\n  if ((status = __ntop_rrd_args(vm, &filename, &cf, &start, &end)) != CONST_LUA_OK) return status;\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s(%s)\", __FUNCTION__, filename);\n\n  reset_rrd_state();\n\n  if ((status = __ntop_rrd_status(vm, rrd_fetch_r(filename, cf, &start, &end, &step, &ds_cnt, &names, &data), filename, cf)) != CONST_LUA_OK) return status;\n\n  lua_pushnumber(vm, (lua_Number) start);\n  lua_pushnumber(vm, (lua_Number) step);\n  /* fprintf(stderr, \"%lu, %lu, %lu, %lu\\n\", start, end, step, num_points); */\n\n  /* create the ds names array */\n  lua_newtable(vm);\n  for(i=0; i<ds_cnt; i++) {\n    lua_pushstring(vm, names[i]);\n    lua_rawseti(vm, -2, i+1);\n    rrd_freemem(names[i]);\n  }\n  rrd_freemem(names);\n\n  /* create the data points array */\n  lua_newtable(vm);\n  p = data;\n  for(t=start+1, i=0; t<end; t+=step, i++) {\n    lua_newtable(vm);\n    for(j=0; j<ds_cnt; j++) {\n      rrd_value_t value = *p++;\n\n      if(value != DNAN /* Skip NaN */) {\n        lua_pushnumber(vm, (lua_Number)value);\n        lua_rawseti(vm, -2, j+1);\n        // ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%u / %.f\", t, value);\n      }\n    }\n    lua_rawseti(vm, -2, i+1);\n  }\n  rrd_freemem(data);\n\n  /* return the end as the last value */\n  lua_pushnumber(vm, (lua_Number) end);\n\n  /* number of return values: start, step, names, data, end */\n  return(5);\n}\n\n/* ****************************************** */\n\n/*\n * Similar to ntop_rrd_fetch, but data series oriented  (reads RRD by columns)\n *\n * Positional parameters:\n *    filename: RRD file path\n *    cf: RRD cf\n *    start: the start time you wish to query\n *    end: the end time you wish to query\n *\n * Positional return values:\n *    start: the time of the first data in the series\n *     step: the fetched data step\n *     data: a table, where each key is an RRD name, and the value is its series data\n *      end: the time of the last data in each series\n *  npoints: the number of points in each series\n */\nstatic int ntop_rrd_fetch_columns(lua_State* vm) {\n  char *filename, *cf;\n  time_t start, end;\n  int status;\n  unsigned int npoints = 0, i, j;\n  char **names;\n  unsigned long step = 0, ds_cnt = 0;\n  rrd_value_t *data, *p;\n\n  if ((status = __ntop_rrd_args(vm, &filename, &cf, &start, &end)) != CONST_LUA_OK) return status;\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s(%s)\", __FUNCTION__, filename);\n\n  reset_rrd_state();\n\n  if ((status = __ntop_rrd_status(vm, rrd_fetch_r(filename, cf, &start, &end, &step, &ds_cnt, &names, &data), filename, cf)) != CONST_LUA_OK) return status;\n\n  npoints = (end - start) / step;\n\n  lua_pushnumber(vm, (lua_Number) start);\n  lua_pushnumber(vm, (lua_Number) step);\n\n  /* create the data series table */\n  lua_createtable(vm, 0, ds_cnt);\n\n  for(i=0; i<ds_cnt; i++) {\n    /* a single serie table, preallocated */\n    lua_createtable(vm, npoints, 0);\n    p = data + i;\n\n    for(j=0; j<npoints; j++) {\n      rrd_value_t value = *p;\n      /* we are accessing data table by columns */\n      p = p + ds_cnt;\n      lua_pushnumber(vm, (lua_Number)value);\n      lua_rawseti(vm, -2, j+1);\n    }\n\n    /* add the single serie to the series table */\n    lua_setfield(vm, -2, names[i]);\n    rrd_freemem(names[i]);\n  }\n\n  rrd_freemem(names);\n  rrd_freemem(data);\n\n  /* end and npoints as last values */\n  lua_pushnumber(vm, (lua_Number) end);\n  lua_pushnumber(vm, (lua_Number) npoints);\n\n  /* number of return values */\n  return(5);\n}\n\n/* ****************************************** */\n\nstatic int ntop_http_redirect(lua_State* vm) {\n  char *url, str[512];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((url = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  snprintf(str, sizeof(str), \"HTTP/1.1 302 Found\\r\\n\"\n\t   \"Location: %s\\r\\n\\r\\n\"\n\t   \"<html>\\n\"\n\t   \"<head>\\n\"\n\t   \"<title>Moved</title>\\n\"\n\t   \"</head>\\n\"\n\t   \"<body>\\n\"\n\t   \"<h1>Moved</h1>\\n\"\n\t   \"<p>This page has moved to <a href=\\\"%s\\\">%s</a>.</p>\\n\"\n\t   \"</body>\\n\"\n\t   \"</html>\\n\", url, url, url);\n\n  lua_pushstring(vm, str);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_http_get(lua_State* vm) {\n  char *url, *username = NULL, *pwd = NULL;\n  int timeout = 30;\n  bool return_content = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((url = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 2) == LUA_TSTRING) {\n    username = (char*)lua_tostring(vm, 2);\n\n    if(lua_type(vm, 3) == LUA_TSTRING) {\n      pwd = (char*)lua_tostring(vm, 3);\n\n      if(lua_type(vm, 4) == LUA_TNUMBER) {\n\ttimeout = lua_tointeger(vm, 4);\n\tif(timeout < 1) timeout = 1;\n\n\t/*\n\t  This optional parameter specifies if the result of HTTP GET has to be returned\n\t  to LUA or not. Usually the content has to be returned, but in some causes\n\t  it just matters to time (for instance when use for testing HTTP services)\n\t*/\n\tif(lua_type(vm, 4) == LUA_TBOOLEAN) {\n\t  return_content = lua_toboolean(vm, 5) ? true : false;\n\t}\n      }\n    }\n  }\n\n  if(Utils::httpGet(vm, url, username, pwd, timeout, return_content))\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_http_get_prefix(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushstring(vm, ntop->getPrefs()->get_http_prefix());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_prefs(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getPrefs()->lua(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_nologin_username(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushstring(vm, NTOP_NOLOGIN_USER);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_users(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getUsers(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_user_group(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getUserGroup(vm);\n  return(CONST_LUA_OK);\n}\n\n\n/* ****************************************** */\n\nstatic int ntop_get_allowed_networks(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getAllowedNetworks(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reset_user_password(lua_State* vm) {\n  char *who, *username, *old_password, *new_password;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  /* Username who requested the password change */\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((who = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((old_password = (char*)lua_tostring(vm, 3)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((new_password = (char*)lua_tostring(vm, 4)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if((!Utils::isUserAdministrator(vm)) && (strcmp(who, username)))\n    return(CONST_LUA_ERROR);\n\n  return(ntop->resetUserPassword(username, old_password, new_password));\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_user_role(lua_State* vm) {\n  char *username, *user_role;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((user_role = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeUserRole(username, user_role);\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_allowed_nets(lua_State* vm) {\n  char *username, *allowed_nets;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_nets = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeAllowedNets(username, allowed_nets);\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_allowed_ifname(lua_State* vm) {\n  char *username, *allowed_ifname;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_ifname = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeAllowedIfname(username, allowed_ifname);\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_user_host_pool(lua_State* vm) {\n  char *username, *host_pool_id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((host_pool_id = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeUserHostPool(username, host_pool_id);\n}\n\n/* ****************************************** */\n\nstatic int ntop_post_http_json_data(lua_State* vm) {\n  char *username, *password, *url, *json;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((password = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((url = (char*)lua_tostring(vm, 3)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((json = (char*)lua_tostring(vm, 4)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(Utils::postHTTPJsonData(username, password, url, json))\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_add_user(lua_State* vm) {\n  char *username, *full_name, *password, *host_role, *allowed_networks, *allowed_interface, *host_pool_id = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((full_name = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((password = (char*)lua_tostring(vm, 3)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((host_role = (char*)lua_tostring(vm, 4)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 5, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_networks = (char*)lua_tostring(vm, 5)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 6, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_interface = (char*)lua_tostring(vm, 6)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 7) == LUA_TSTRING)\n    if((host_pool_id = (char*)lua_tostring(vm, 7)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->addUser(username, full_name, password, host_role,\n\t\t       allowed_networks, allowed_interface, host_pool_id);\n}\n\n/* ****************************************** */\n\nstatic int ntop_add_user_lifetime(lua_State* vm) {\n  char *username;\n  int32_t num_secs;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_PARAM_ERROR);\n  num_secs = (int32_t)lua_tonumber(vm, 2);\n\n  if(num_secs > 0)\n    return ntop->addUserLifetime(username, num_secs) ? CONST_LUA_OK : CONST_LUA_ERROR;\n\n  return CONST_LUA_OK; /* Negative or zero lifetimes means unlimited */\n}\n\n/* ****************************************** */\n\nstatic int ntop_clear_user_lifetime(lua_State* vm) {\n  char *username;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->clearUserLifetime(username) ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_delete_user(lua_State* vm) {\n  char *username;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->deleteUser(username);\n}\n\n/* ****************************************** */\n\nstatic int ntop_resolve_address(lua_State* vm) {\n  char *numIP, symIP[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((numIP = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  ntop->resolveHostName(numIP, symIP, sizeof(symIP));\n  lua_pushstring(vm, symIP);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nvoid lua_push_str_table_entry(lua_State *L, const char *key, char *value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushstring(L, value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_nil_table_entry(lua_State *L, const char *key) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushnil(L);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_bool_table_entry(lua_State *L, const char *key, bool value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushboolean(L, value ? 1 : 0);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_int_table_entry(lua_State *L, const char *key, u_int64_t value) {\n  if(L) {\n    lua_pushstring(L, key);\n    /* using LUA_NUMBER (double: 64 bit) in place of LUA_INTEGER (ptrdiff_t: 32 or 64 bit\n     * according to the platform, as defined in luaconf.h) to handle big counters */\n    lua_pushnumber(L, (lua_Number)value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_int32_table_entry(lua_State *L, const char *key, int32_t value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushnumber(L, (lua_Number)value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_float_table_entry(lua_State *L, const char *key, float value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushnumber(L, value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  /*\n  ntop_interface->getAlertsManager()->engageAlert(alert_entity_host, \"127.0.0.1\",\n\t\t\t\t\t\t  \"min_bytes\",\n\t\t\t\t\t\t  alert_threshold_exceeded,\n\t\t\t\t\t\t  alert_level_warning,\n\t\t\t\t\t\t  \"miao\");\n  ntop_interface->getAlertsManager()->releaseAlert(alert_entity_host, \"127.0.0.1\",\n\t\t\t\t\t\t   \"min_bytes\",\n\t\t\t\t\t\t   alert_threshold_exceeded,\n\t\t\t\t\t\t   alert_level_warning,\n\t\t\t\t\t\t   \"miao\");\n  */\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) ntop_interface->lua(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_reset_counters(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool only_drops = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    only_drops = lua_toboolean(vm, 1) ? true : false;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop_interface->checkPointCounters(only_drops);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_is_pro(lua_State *vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  lua_pushboolean(vm, ntop->getPrefs()->is_pro_edition());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_is_enterprise(lua_State *vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  lua_pushboolean(vm, ntop->getPrefs()->is_enterprise_edition());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reload_host_pools(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n\n    ntop_interface->getHostPools()->reloadPools();\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n#ifdef NTOPNG_PRO\nstatic int ntop_purge_expired_host_pools_members(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n\n    ntop_interface->getHostPools()->purgeExpiredVolatileMembers();\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\nstatic int ntop_remove_volatile_member_from_pool(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_or_mac;\n  u_int16_t pool_id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((host_or_mac = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_PARAM_ERROR);\n  pool_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n\n    ntop_interface->getHostPools()->removeVolatileMemberFromPool(host_or_mac, pool_id);\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n#endif\n/* ****************************************** */\n\nstatic int ntop_reload_l7_rules(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_interface) {\n#ifdef NTOPNG_PRO\n    u_int16_t host_pool_id = (u_int16_t)lua_tonumber(vm, 1);\n\n#ifdef SHAPER_DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%s(%i)\", __FUNCTION__, host_pool_id);\n#endif\n\n    ntop_interface->refreshL7Rules();\n    ntop_interface->updateHostsL7Policy(host_pool_id);\n    ntop_interface->updateFlowsL7Policy();\n#endif\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reload_shapers(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n#ifdef NTOPNG_PRO\n    ntop_interface->refreshShapers();\n#endif\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_exec_sql_query(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool limit_rows = true;  // honour the limit by default\n  bool wait_for_db_created = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n  else {\n    char *sql;\n\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n    if((sql = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n    if(lua_type(vm, 2) == LUA_TBOOLEAN) {\n      limit_rows = lua_toboolean(vm, 2) ? true : false;\n    }\n\n    if(lua_type(vm, 3) == LUA_TBOOLEAN) {\n      wait_for_db_created = lua_toboolean(vm, 3) ? true : false;\n    }\n\n    if(ntop_interface->exec_sql_query(vm, sql, limit_rows, wait_for_db_created) < 0)\n      lua_pushnil(vm);\n\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_dirs(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_newtable(vm);\n  lua_push_str_table_entry(vm, \"installdir\", ntop->get_install_dir());\n  lua_push_str_table_entry(vm, \"workingdir\", ntop->get_working_dir());\n  lua_push_str_table_entry(vm, \"scriptdir\", ntop->getPrefs()->get_scripts_dir());\n  lua_push_str_table_entry(vm, \"httpdocsdir\", ntop->getPrefs()->get_docs_dir());\n  lua_push_str_table_entry(vm, \"callbacksdir\", ntop->getPrefs()->get_callbacks_dir());\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_uptime(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushinteger(vm, ntop->getGlobals()->getUptime());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_check_license(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n#ifdef NTOPNG_PRO\n  ntop->getPro()->check_license();\n#endif\n\n  lua_pushinteger(vm,1);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_info(lua_State* vm) {\n  char rsp[256];\n  int major, minor, patch;\n  bool verbose = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    verbose = lua_toboolean(vm, 1) ? true : false;\n\n  lua_newtable(vm);\n  lua_push_str_table_entry(vm, \"product\", (char*)\"ntopng\");\n  lua_push_str_table_entry(vm, \"copyright\", (char*)\"&copy; 1998-17 - ntop.org\");\n  lua_push_str_table_entry(vm, \"authors\", (char*)\"The ntop.org team\");\n  lua_push_str_table_entry(vm, \"license\", (char*)\"GNU GPLv3\");\n\n  lua_push_str_table_entry(vm, \"version\", (char*)PACKAGE_VERSION);\n  lua_push_str_table_entry(vm, \"git\", (char*)NTOPNG_GIT_RELEASE);\n\n  snprintf(rsp, sizeof(rsp), \"%s [%s][%s]\",\n\t   PACKAGE_OSNAME, PACKAGE_MACHINE, PACKAGE_OS);\n  lua_push_str_table_entry(vm, \"platform\", rsp);\n  lua_push_str_table_entry(vm, \"OS\",\n#ifdef WIN32\n\t\t\t   (char*)\"Windows\"\n#else\n\t\t\t   (char*)PACKAGE_OS\n#endif\n\t\t\t   );\n  lua_push_int_table_entry(vm, \"bits\", (sizeof(void*) == 4) ? 32 : 64);\n  lua_push_int_table_entry(vm, \"uptime\", ntop->getGlobals()->getUptime());\n  lua_push_str_table_entry(vm, \"command_line\", ntop->getPrefs()->get_command_line());\n\n  if(verbose) {\n    lua_push_str_table_entry(vm, \"version.rrd\", rrd_strversion());\n    lua_push_str_table_entry(vm, \"version.redis\", ntop->getRedis()->getVersion(rsp, sizeof(rsp)));\n    lua_push_str_table_entry(vm, \"version.httpd\", (char*)mg_version());\n    lua_push_str_table_entry(vm, \"version.git\", (char*)NTOPNG_GIT_RELEASE);\n    lua_push_str_table_entry(vm, \"version.luajit\", (char*)LUAJIT_VERSION);\n#ifdef HAVE_GEOIP\n    lua_push_str_table_entry(vm, \"version.geoip\", (char*)GeoIP_lib_version());\n#endif\n    lua_push_str_table_entry(vm, \"version.ndpi\", ndpi_revision());\n    lua_push_bool_table_entry(vm, \"version.enterprise_edition\", ntop->getPrefs()->is_enterprise_edition());\n    lua_push_bool_table_entry(vm, \"version.embedded_edition\", ntop->getPrefs()->is_embedded_edition());\n\n    lua_push_bool_table_entry(vm, \"pro.release\", ntop->getPrefs()->is_pro_edition());\n    lua_push_int_table_entry(vm, \"pro.demo_ends_at\", ntop->getPrefs()->pro_edition_demo_ends_at());\n#ifdef NTOPNG_PRO\n    lua_push_str_table_entry(vm, \"pro.license\", ntop->getPro()->get_license());\n    lua_push_bool_table_entry(vm, \"pro.use_redis_license\", ntop->getPro()->use_redis_license());\n    lua_push_str_table_entry(vm, \"pro.systemid\", ntop->getPro()->get_system_id());\n#endif\n\n#if 0\n    ntop->getRedis()->get((char*)CONST_STR_NTOPNG_LICENSE, rsp, sizeof(rsp));\n    lua_push_str_table_entry(vm, \"ntopng.license\", rsp);\n#endif\n\n    zmq_version(&major, &minor, &patch);\n    snprintf(rsp, sizeof(rsp), \"%d.%d.%d\", major, minor, patch);\n    lua_push_str_table_entry(vm, \"version.zmq\", rsp);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_resolved_address(lua_State* vm) {\n  char *key, *tmp,rsp[256],value[64];\n  Redis *redis = ntop->getRedis();\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &key, &vlan_id, buf, sizeof(buf));\n\n  if(key == NULL)\n    return(CONST_LUA_ERROR);\n\n  if(redis->getAddress(key, rsp, sizeof(rsp), true) == 0)\n    tmp = rsp;\n  else\n    tmp = key;\n\n  if(vlan_id != 0)\n    snprintf(value, sizeof(value), \"%s@%u\", tmp, vlan_id);\n  else\n    snprintf(value, sizeof(value), \"%s\", tmp);\n\n#if 0\n  if(!strcmp(value, key)) {\n    char rsp[64];\n\n    if((ntop->getRedis()->hashGet((char*)HOST_LABEL_NAMES, key, rsp, sizeof(rsp)) == 0)\n       && (rsp[0] !='\\0'))\n      lua_pushfstring(vm, \"%s\", rsp);\n    else\n      lua_pushfstring(vm, \"%s\", value);\n  } else\n    lua_pushfstring(vm, \"%s\", value);\n#else\n  lua_pushfstring(vm, \"%s\", value);\n#endif\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_snmp_get_fctn(lua_State* vm, int operation) {\n  char *agent_host, *oid, *community;\n  u_int agent_port = 161, timeout = 5, request_id = (u_int)time(NULL);\n  int sock, i = 0, rc = CONST_LUA_OK;\n  SNMPMessage *message;\n  int len;\n  unsigned char *buf;\n  bool debug = false;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  agent_host = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  community = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  oid = (char*)lua_tostring(vm, 3);\n\n  sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n  if(sock < 0) return(CONST_LUA_ERROR);\n\n  message = snmp_create_message();\n  snmp_set_version(message, 0);\n  snmp_set_community(message, community);\n  snmp_set_pdu_type(message, operation);\n  snmp_set_request_id(message, request_id);\n  snmp_set_error(message, 0);\n  snmp_set_error_index(message, 0);\n  snmp_add_varbind_null(message, oid);\n\n  /* Add additional OIDs */\n  i = 4;\n  while(lua_type(vm, i) == LUA_TSTRING) {\n    snmp_add_varbind_null(message, (char*)lua_tostring(vm, i));\n    i++;\n  }\n\n  len = snmp_message_length(message);\n  buf = (unsigned char*)malloc(len);\n  snmp_render_message(message, buf);\n  snmp_destroy_message(message);\n\n  send_udp_datagram(buf, len, sock, agent_host, agent_port);\n  free(buf);\n\n  if(debug)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"SNMP %s %s@%s %s\",\n\t\t\t\t (operation == SNMP_GET_REQUEST_TYPE) ? \"Get\" : \"GetNext\",\n\t\t\t\t agent_host, community, oid);\n\n  if(input_timeout(sock, timeout) == 0) {\n    /* Timeout */\n\n    if(debug)\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"SNMP Timeout %s@%s %s\", agent_host, community, oid);\n    rc = CONST_LUA_ERROR;\n    lua_pushnil(vm);\n  } else {\n    char buf[BUFLEN];\n    SNMPMessage *message;\n    char *sender_host, *oid_str,  *value_str;\n    int sender_port, added = 0, len;\n\n    len = receive_udp_datagram(buf, BUFLEN, sock, &sender_host, &sender_port);\n    message = snmp_parse_message(buf, len);\n\n    i = 0;\n    while(snmp_get_varbind_as_string(message, i, &oid_str, NULL, &value_str)) {\n      if(!added) lua_newtable(vm), added = 1;\n      lua_push_str_table_entry(vm, oid_str, value_str);\n      if(debug)\n\tntop->getTrace()->traceEvent(TRACE_NORMAL, \"SNMP OK %s@%s %s=%s\", agent_host, community, oid_str, value_str);\n      i++;\n    }\n\n    snmp_destroy_message(message);\n\n    if(!added) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"SNMP Error %s@%s\", agent_host, community);\n      lua_pushnil(vm), rc = CONST_LUA_ERROR;\n    }\n  }\n\n  closesocket(sock);\n  return(rc);\n}\n\n/* ****************************************** */\n\nstatic int ntop_snmpget(lua_State* vm)     { return(ntop_snmp_get_fctn(vm, SNMP_GET_REQUEST_TYPE)); }\nstatic int ntop_snmpgetnext(lua_State* vm) { return(ntop_snmp_get_fctn(vm, SNMP_GETNEXT_REQUEST_TYPE)); }\n\n/* ****************************************** */\n\n/**\n * @brief Send a message to the system syslog\n * @details Send a message to the syslog syslog: callers can specify if it is an error or informational message\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_ERROR if the expected type is equal to function type, @ref CONST_LUA_PARAM_ERROR otherwise.\n */\nstatic int ntop_syslog(lua_State* vm) {\n#ifndef WIN32\n  char *msg;\n  bool is_error;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TBOOLEAN)) return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING))  return(CONST_LUA_ERROR);\n\n  is_error = lua_toboolean(vm, 1) ? true : false;\n  msg = (char*)lua_tostring(vm, 2);\n\n  syslog(is_error ? LOG_ERR : LOG_INFO, \"%s\", msg);\n#endif\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Generate a random value to prevent CSRF and XSRF attacks\n * @details See http://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/\n *\n * @param vm The lua state.\n * @return The random value just generated\n */\nstatic int ntop_generate_csrf_value(lua_State* vm) {\n  char random_a[32], random_b[32], csrf[33], user[64] = { '\\0' };\n  Redis *redis = ntop->getRedis();\n  struct mg_connection *conn;\n\n  lua_getglobal(vm, CONST_HTTP_CONN);\n  if((conn = (struct mg_connection*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: null HTTP connection\");\n    return(CONST_LUA_OK);\n  }\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n#ifdef __OpenBSD__\n  snprintf(random_a, sizeof(random_a), \"%d\", arc4random());\n  snprintf(random_b, sizeof(random_b), \"%lu\", time(NULL)*arc4random());\n#else\n  snprintf(random_a, sizeof(random_a), \"%d\", rand());\n  snprintf(random_b, sizeof(random_b), \"%lu\", time(NULL)*rand());\n#endif\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  mg_md5(csrf, random_a, random_b, NULL);\n\n  redis->set(csrf, (char*)user, MAX_CSRF_DURATION);\n  lua_pushfstring(vm, \"%s\", csrf);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstruct ntopng_sqlite_state {\n  lua_State* vm;\n  u_int num_rows;\n};\n\nstatic int sqlite_callback(void *data, int argc,\n\t\t\t   char **argv, char **azColName) {\n  struct ntopng_sqlite_state *s = (struct ntopng_sqlite_state*)data;\n\n  lua_newtable(s->vm);\n\n  for(int i=0; i<argc; i++)\n    lua_push_str_table_entry(s->vm, (const char*)azColName[i],\n\t\t\t     (char*)(argv[i] ? argv[i] : \"NULL\"));\n\n  lua_pushinteger(s->vm, ++s->num_rows);\n  lua_insert(s->vm, -2);\n  lua_settable(s->vm, -3);\n\n  return(0);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Exec SQL query\n * @details Execute the specified query and return the results\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_ERROR in case of error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_sqlite_exec_query(lua_State* vm) {\n  char *db_path, *db_query;\n  sqlite3 *db;\n  char *zErrMsg = 0;\n  struct ntopng_sqlite_state state;\n  struct stat buf;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  db_path = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  db_query = (char*)lua_tostring(vm, 2);\n\n  if(stat(db_path, &buf) != 0) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Not found database %s\",\n\t\t\t\t db_path);\n    return(CONST_LUA_ERROR);\n  }\n\n  if(sqlite3_open(db_path, &db)) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Unable to open %s: %s\",\n\t\t\t\t db_path, sqlite3_errmsg(db));\n    return(CONST_LUA_ERROR);\n  }\n\n  state.vm = vm, state.num_rows = 0;\n  lua_newtable(vm);\n  if(sqlite3_exec(db, db_query, sqlite_callback, (void*)&state, &zErrMsg)) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"SQL Error: %s\", zErrMsg);\n    sqlite3_free(zErrMsg);\n  }\n\n  sqlite3_close(db);\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Insert a new minute sampling in the historical database\n * @details Given a certain sampling point, store statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_insert_minute_sampling(lua_State *vm) {\n  char *sampling;\n  time_t rawtime;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((sampling = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  time(&rawtime);\n\n  if(sm->insertMinuteSampling(rawtime, sampling))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Insert a new hour sampling in the historical database\n * @details Given a certain sampling point, store statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_insert_hour_sampling(lua_State *vm) {\n  char *sampling;\n  time_t rawtime;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((sampling = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  time(&rawtime);\n  rawtime -= (rawtime % 60);\n\n  if(sm->insertHourSampling(rawtime, sampling))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Insert a new day sampling in the historical database\n * @details Given a certain sampling point, store statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_insert_day_sampling(lua_State *vm) {\n  char *sampling;\n  time_t rawtime;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((sampling = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  time(&rawtime);\n  rawtime -= (rawtime % 60);\n\n  if(sm->insertDaySampling(rawtime, sampling))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Get a minute sampling from the historical database\n * @details Given a certain sampling point, get statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_minute_sampling(lua_State *vm) {\n  time_t epoch;\n  string sampling;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch = (time_t)lua_tointeger(vm, 2);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->getMinuteSampling(epoch, &sampling))\n    return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, sampling.c_str());\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Delete minute stats older than a certain number of days.\n * @details Given a number of days, delete stats for the current interface that\n *          are older than a certain number of days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_delete_minute_older_than(lua_State *vm) {\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 2);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->deleteMinuteStatsOlderThan(num_days))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Delete hour stats older than a certain number of days.\n * @details Given a number of days, delete stats for the current interface that\n *          are older than a certain number of days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_delete_hour_older_than(lua_State *vm) {\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 2);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->deleteHourStatsOlderThan(num_days))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Delete day stats older than a certain number of days.\n * @details Given a number of days, delete stats for the current interface that\n *          are older than a certain number of days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_delete_day_older_than(lua_State *vm) {\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 2);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->deleteDayStatsOlderThan(num_days))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Get an interval of minute stats samplings from the historical database\n * @details Given a certain interval of sampling points, get statistics for said\n *          sampling points.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_minute_samplings_interval(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_start = lua_tointeger(vm, 2);\n  if(epoch_start < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 3);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->retrieveMinuteStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Given an epoch, get minute stats for the latest n minutes\n * @details Given a certain sampling point, get statistics for that point and\n *          for all timepoints spanning an interval of a given number of\n *          minutes.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_samplings_of_minutes_from_epoch(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int num_minutes;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 2);\n  epoch_end -= (epoch_end % 60);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_minutes = lua_tointeger(vm, 3);\n  if(num_minutes < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  epoch_start = epoch_end - (60 * num_minutes);\n\n  if(sm->retrieveMinuteStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Given an epoch, get hour stats for the latest n hours\n * @details Given a certain sampling point, get statistics for that point and\n *          for all timepoints spanning an interval of a given number of\n *          hours.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_samplings_of_hours_from_epoch(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int num_hours;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 2);\n  epoch_end -= (epoch_end % 60);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_hours = lua_tointeger(vm, 3);\n  if(num_hours < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  epoch_start = epoch_end - (num_hours * 60 * 60);\n\n  if(sm->retrieveHourStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Given an epoch, get hour stats for the latest n days\n * @details Given a certain sampling point, get statistics for that point and\n *          for all timepoints spanning an interval of a given number of\n *          days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_samplings_of_days_from_epoch(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 2);\n  epoch_end -= (epoch_end % 60);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 3);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  epoch_start = epoch_end - (num_days * 24 * 60 * 60);\n\n  if(sm->retrieveDayStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_delete_dump_files(lua_State *vm) {\n  int ifid;\n  char pcap_path[MAX_PATH];\n  NetworkInterface *iface;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  if((ifid = lua_tointeger(vm, 1)) < 0) return(CONST_LUA_ERROR);\n  if(!(iface = ntop->getNetworkInterface(ifid))) return(CONST_LUA_ERROR);\n\n  snprintf(pcap_path, sizeof(pcap_path), \"%s/%d/pcap/\",\n\t   ntop->get_working_dir(), ifid);\n  ntop->fixPath(pcap_path);\n\n  if(Utils::discardOldFilesExceeding(pcap_path, iface->getDumpTrafficMaxFiles()))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_mkdir_tree(lua_State* vm) {\n  char *dir;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((dir = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if(dir[0] == '\\0')                                   return(CONST_LUA_OK); /* Nothing to do */\n\n  return(Utils::mkdir_tree(dir));\n}\n\n/* ****************************************** */\n\nstatic int ntop_list_reports(lua_State* vm) {\n  DIR *dir;\n  char fullpath[MAX_PATH];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_newtable(vm);\n  snprintf(fullpath, sizeof(fullpath), \"%s/%s\", ntop->get_working_dir(), \"reports\");\n  ntop->fixPath(fullpath);\n  if((dir = opendir(fullpath)) != NULL) {\n    struct dirent *ent;\n\n    while ((ent = readdir(dir)) != NULL) {\n      char filepath[MAX_PATH];\n      snprintf(filepath, sizeof(filepath), \"%s/%s\", fullpath, ent->d_name);\n      ntop->fixPath(filepath);\n      struct stat buf;\n      if(!stat(filepath, &buf) && !S_ISDIR(buf.st_mode))\n\tlua_push_str_table_entry(vm, ent->d_name, (char*)\"\");\n    }\n    closedir(dir);\n  }\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_redis(lua_State* vm) {\n  char *key, *rsp;\n  u_int rsp_len = 32768;\n  Redis *redis = ntop->getRedis();\n  bool cache_it = false;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  /* Optional cache_it */\n  if(lua_type(vm, 2) == LUA_TBOOLEAN) cache_it = lua_toboolean(vm, 2);\n\n\n  if((rsp = (char*)malloc(rsp_len)) != NULL) {\n    lua_pushfstring(vm, \"%s\", (redis->get(key, rsp, rsp_len, cache_it) == 0) ? rsp : (char*)\"\");\n    free(rsp);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_hash_redis(lua_State* vm) {\n  char *key, *member, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  lua_pushfstring(vm, \"%s\", (redis->hashGet(key, member, rsp, sizeof(rsp)) == 0) ? rsp : (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_hash_redis(lua_State* vm) {\n  char *key, *member, *value;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n  if((value  = (char*)lua_tostring(vm, 3)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  redis->hashSet(key, member, value);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_del_hash_redis(lua_State* vm) {\n  char *key, *member;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  redis->hashDel(key, member);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_hash_keys_redis(lua_State* vm) {\n  char *key, **vals;\n  Redis *redis = ntop->getRedis();\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  rc = redis->hashKeys(key, &vals);\n\n  if(rc > 0) {\n    lua_newtable(vm);\n\n    for(int i = 0; i < rc; i++) {\n      lua_push_str_table_entry(vm, vals[i] ? vals[i] : \"\", (char*)\"\");\n      if(vals[i]) free(vals[i]);\n    }\n    free(vals);\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_keys_redis(lua_State* vm) {\n  char *pattern, **keys;\n  Redis *redis = ntop->getRedis();\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((pattern = (char*)lua_tostring(vm, 1)) == NULL)   return(CONST_LUA_PARAM_ERROR);\n\n  rc = redis->keys(pattern, &keys);\n\n  if(rc > 0) {\n    lua_newtable(vm);\n\n    for(int i = 0; i < rc; i++) {\n      lua_push_str_table_entry(vm, keys[i] ? keys[i] : \"\", (char*)\"\");\n      if(keys[i]) free(keys[i]);\n    }\n    free(keys);\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lrange_redis(lua_State* vm) {\n  char *l_name, **l_elements;\n  Redis *redis = ntop->getRedis();\n  int start_offset = 0, end_offset = -1;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((l_name = (char*)lua_tostring(vm, 1)) == NULL)   return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 2) == LUA_TNUMBER) {\n    start_offset = lua_tointeger(vm, 2);\n  }\n  if(lua_type(vm, 3) == LUA_TNUMBER) {\n    end_offset = lua_tointeger(vm, 3);\n  }\n\n  rc = redis->lrange(l_name, &l_elements, start_offset, end_offset);\n\n  if(rc > 0) {\n    lua_newtable(vm);\n\n    for(int i = 0; i < rc; i++) {\n      lua_push_str_table_entry(vm, l_elements[i] ? l_elements[i] : \"\", (char*)\"\");\n      if(l_elements[i]) free(l_elements[i]);\n    }\n    free(l_elements);\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_redis_set_pop(lua_State* vm) {\n  char *set_name, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((set_name = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n  lua_pushfstring(vm, \"%s\", redis->popSet(set_name, rsp, sizeof(rsp)));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_list_index_redis(lua_State* vm) {\n  char *index_name, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n  int idx;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  if((index_name = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  idx = lua_tointeger(vm, 2);\n\n  if(redis->lindex(index_name, idx, rsp, sizeof(rsp)) != 0)\n    return(CONST_LUA_ERROR);\n\n  lua_pushfstring(vm, \"%s\", rsp);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lpop_redis(lua_State* vm) {\n  char msg[1024], *list_name;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((list_name = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(redis->lpop(list_name, msg, sizeof(msg)) == 0) {\n    lua_pushfstring(vm, \"%s\", msg);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lpush_redis(lua_State* vm) {\n  char *list_name, *value;\n  u_int list_trim_size = 0;  // default 0 = no trim\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((list_name = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  /* Optional trim list up to the specified number of elements */\n  if(lua_type(vm, 3) == LUA_TNUMBER)\n      list_trim_size = (u_int)lua_tonumber(vm, 3);\n\n  if(redis->lpush(list_name, value, list_trim_size) == 0) {\n      return(CONST_LUA_OK);\n  }else\n      return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_redis_get_host_id(lua_State* vm) {\n  char *host_name;\n  Redis *redis = ntop->getRedis();\n  char daybuf[32];\n  time_t when = time(NULL);\n  bool new_key;\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((host_name = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  strftime(daybuf, sizeof(daybuf), CONST_DB_DAY_FORMAT, localtime(&when));\n  lua_pushinteger(vm, redis->host_to_id(ntop_interface, daybuf, host_name, &new_key)); /* CHECK */\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_redis_get_id_to_host(lua_State* vm) {\n  char *host_idx, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n  char daybuf[32];\n  time_t when = time(NULL);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((host_idx = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  strftime(daybuf, sizeof(daybuf), CONST_DB_DAY_FORMAT, localtime(&when));\n  lua_pushfstring(vm, \"%d\", redis->id_to_host(daybuf, host_idx, rsp, sizeof(rsp)));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n#ifdef NOTUSED\nstatic int ntop_interface_store_alert(lua_State* vm) {\n  int ifid;\n  NetworkInterface* iface;\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TTABLE)) return(CONST_LUA_ERROR);\n\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(vm, ifid)) ||\n     !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  return am->storeAlert(vm, 2) ? CONST_LUA_ERROR : CONST_LUA_OK;\n}\n#endif\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_release_host_alert(lua_State* vm, bool engage) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  int alert_severity;\n  int alert_type;\n  char *alert_json, *engaged_alert_id;\n  AlertsManager *am;\n  int ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  engaged_alert_id = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_type = (int)lua_tonumber(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_severity = (int)lua_tonumber(vm, 4);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 5, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_json = (char*)lua_tostring(vm, 5);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(engage)\n    ret = am->engageHostAlert(h, engaged_alert_id,\n\t\t\t      (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n  else\n    ret = am->releaseHostAlert(h, engaged_alert_id,\n\t\t\t       (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n\n  return ret >= 0 ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_release_network_alert(lua_State* vm, bool engage) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *cidr;\n  int alert_severity;\n  int alert_type;\n  char *alert_json, *engaged_alert_id;\n  AlertsManager *am;\n  int ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  cidr = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  engaged_alert_id = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_type = (int)lua_tonumber(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_severity = (int)lua_tonumber(vm, 4);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 5, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_json = (char*)lua_tostring(vm, 5);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(engage)\n    ret = am->engageNetworkAlert(cidr, engaged_alert_id,\n\t\t\t\t (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n  else\n    ret = am->releaseNetworkAlert(cidr, engaged_alert_id,\n\t\t\t\t  (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n\n  return ret >= 0 ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_release_interface_alert(lua_State* vm, bool engage) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int alert_severity;\n  int alert_type;\n  char *alert_json, *engaged_alert_id;\n  AlertsManager *am;\n  int ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  engaged_alert_id = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_type = (int)lua_tonumber(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_severity = (int)lua_tonumber(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_json = (char*)lua_tostring(vm, 4);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(engage)\n    ret = am->engageInterfaceAlert(ntop_interface, engaged_alert_id,\n\t\t\t\t   (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n  else\n    ret = am->releaseInterfaceAlert(ntop_interface, engaged_alert_id,\n\t\t\t\t    (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n\n  return ret >= 0 ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_host_alert(lua_State* vm) {\n  return ntop_interface_engage_release_host_alert(vm, true /* engage */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_release_host_alert(lua_State* vm) {\n  return ntop_interface_engage_release_host_alert(vm, false /* release */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_network_alert(lua_State* vm) {\n  return ntop_interface_engage_release_network_alert(vm, true /* engage */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_release_network_alert(lua_State* vm) {\n  return ntop_interface_engage_release_network_alert(vm, false /* release */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_interface_alert(lua_State* vm) {\n  return ntop_interface_engage_release_interface_alert(vm, true /* engage */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_release_interface_alert(lua_State* vm) {\n  return ntop_interface_engage_release_interface_alert(vm, false /* release */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_get_cached_num_alerts(lua_State* vm) {\n  NetworkInterface *iface = getCurrentInterface(vm);\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!iface || !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  return (!am->getCachedNumAlerts(vm)) ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_make_room_alerts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int alert_entity;\n  char *alert_entity_value, *table_name;\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_entity = (int)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_entity_value = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  table_name = (char*)lua_tostring(vm, 3);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  am->makeRoom((AlertEntity)alert_entity, alert_entity_value, table_name);\n\n  return CONST_LUA_OK;\n}\n\n\n/* ****************************************** */\n\nstatic int ntop_interface_make_room_requested(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  lua_pushboolean(vm, am->makeRoomRequested());\n\n  return(CONST_LUA_OK);\n\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_query_alerts_raw(lua_State* vm) {\n  NetworkInterface *iface = getCurrentInterface(vm);\n  AlertsManager *am;\n  bool engaged = false;\n  char *selection = NULL, *clauses = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!iface || !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    engaged = lua_toboolean(vm, 1);\n\n  if(lua_type(vm, 2) == LUA_TSTRING)\n    if((selection = (char*)lua_tostring(vm, 2)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 3) == LUA_TSTRING)\n    if((clauses = (char*)lua_tostring(vm, 3)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(am->queryAlertsRaw(vm, engaged, selection, clauses))\n    return(CONST_LUA_ERROR);\n\n  return (CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_query_flow_alerts_raw(lua_State* vm) {\n  NetworkInterface *iface = getCurrentInterface(vm);\n  AlertsManager *am;\n  char *selection = NULL, *clauses = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!iface || !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) == LUA_TSTRING)\n    if((selection = (char*)lua_tostring(vm, 1)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 2) == LUA_TSTRING)\n    if((clauses = (char*)lua_tostring(vm, 2)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(am->queryFlowAlertsRaw(vm, selection, clauses))\n    return(CONST_LUA_ERROR);\n\n  return (CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n#if NTOPNG_PRO\n\nstatic int ntop_nagios_reload_config(lua_State* vm) {\n  NagiosManager *nagios = ntop->getNagios();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!nagios) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s(): unable to get the nagios manager\",\n\t\t\t\t __FUNCTION__);\n    return(CONST_LUA_ERROR);\n  }\n  nagios->loadConfig();\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\nstatic int ntop_nagios_send_alert(lua_State* vm) {\n  NagiosManager *nagios = ntop->getNagios();\n  char *alert_source;\n  char *timespan;\n  char *alarmed_metric;\n  char *alert_msg;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_source = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  timespan = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alarmed_metric = (char*)lua_tostring(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_msg = (char*)lua_tostring(vm, 4);\n\n  nagios->sendAlert(alert_source, timespan, alarmed_metric, alert_msg);\n\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\nstatic int ntop_nagios_withdraw_alert(lua_State* vm) {\n  NagiosManager *nagios = ntop->getNagios();\n  char *alert_source;\n  char *timespan;\n  char *alarmed_metric;\n  char *alert_msg;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_source = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  timespan = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alarmed_metric = (char*)lua_tostring(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_msg = (char*)lua_tostring(vm, 4);\n\n  nagios->withdrawAlert(alert_source, timespan, alarmed_metric, alert_msg);\n\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n#endif\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\nstatic int ntop_check_profile_syntax(lua_State* vm) {\n  char *filter;\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  filter = (char*)lua_tostring(vm, 1);\n\n  lua_pushboolean(vm, ntop_interface ? ntop_interface->checkProfileSyntax(filter) : false);\n\n  return(CONST_LUA_OK);\n}\n#endif\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\nstatic int ntop_reload_traffic_profiles(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface)\n    ntop_interface->updateFlowProfiles(); /* Reload profiles in memory */\n\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n#endif\n\n/* ****************************************** */\n\nstatic int ntop_set_redis(lua_State* vm) {\n  char *key, *value;\n  u_int expire_secs = 0;  // default 0 = no expiration\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  /* Optional key expiration in SECONDS */\n  if(lua_type(vm, 3) == LUA_TNUMBER)\n      expire_secs = (u_int)lua_tonumber(vm, 3);\n\n  if(redis->set(key, value, expire_secs) == 0) {\n      return(CONST_LUA_OK);\n  }else\n      return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_redis_preference(lua_State* vm) {\n  char *key, *value;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  if(redis->set(key, value) ||\n     ntop->getPrefs()->refresh(key, value))\n      return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lua_http_print(lua_State* vm) {\n  struct mg_connection *conn;\n  char *printtype;\n  int t;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_HTTP_CONN);\n  if((conn = (struct mg_connection*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: null HTTP connection\");\n    return(CONST_LUA_OK);\n  }\n\n  /* Handle binary blob */\n  if(lua_type(vm, 2) == LUA_TSTRING &&\n     (printtype = (char*)lua_tostring(vm, 2)) != NULL)\n    if(!strncmp(printtype, \"blob\", 4)) {\n      char *str = NULL;\n\n      if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return (CONST_LUA_ERROR);\n      if((str = (char*)lua_tostring(vm, 1)) != NULL) {\n\tint len = strlen(str);\n\n\tif(len <= 1)\n\t  mg_printf(conn, \"%c\", str[0]);\n\telse\n\t  return (CONST_LUA_PARAM_ERROR);\n      }\n\n      return (CONST_LUA_OK);\n    }\n\n  switch(t = lua_type(vm, 1)) {\n  case LUA_TNIL:\n    mg_printf(conn, \"%s\", \"nil\");\n    break;\n\n  case LUA_TBOOLEAN:\n    {\n      int v = lua_toboolean(vm, 1);\n\n      mg_printf(conn, \"%s\", v ? \"true\" : \"false\");\n    }\n    break;\n\n  case LUA_TSTRING:\n    {\n      char *str = (char*)lua_tostring(vm, 1);\n\n      if(str && (strlen(str) > 0))\n\tmg_printf(conn, \"%s\", str);\n    }\n    break;\n\n  case LUA_TNUMBER:\n    {\n      char str[64];\n\n      snprintf(str, sizeof(str), \"%f\", (float)lua_tonumber(vm, 1));\n      mg_printf(conn, \"%s\", str);\n    }\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s(): Lua type %d is not handled\",\n\t\t\t\t __FUNCTION__, t);\n    return(CONST_LUA_ERROR);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nint ntop_lua_cli_print(lua_State* vm) {\n  int t;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  switch(t = lua_type(vm, 1)) {\n  case LUA_TSTRING:\n    {\n      char *str = (char*)lua_tostring(vm, 1);\n\n      if(str && (strlen(str) > 0))\n\tntop->getTrace()->traceEvent(TRACE_NORMAL, \"%s\", str);\n    }\n    break;\n\n  case LUA_TNUMBER:\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%f\", (float)lua_tonumber(vm, 1));\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s(): Lua type %d is not handled\",\n\t\t\t\t __FUNCTION__, t);\n    return(CONST_LUA_ERROR);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\nstatic int __ntop_lua_handlefile(lua_State* L, char *script_path, bool ex)\n{\n  int rc;\n  LuaHandler *lh = new LuaHandler(L, script_path);\n\n  rc = lh->luaL_dofileM(ex);\n  delete lh;\n  return rc;\n}\n\n/* This function is called by Lua scripts when the call require(...) */\nstatic int ntop_lua_require(lua_State* L)\n{\n  char *script_name;\n\n  if(lua_type(L, 1) != LUA_TSTRING ||\n     (script_name = (char*)lua_tostring(L, 1)) == NULL)\n    return 0;\n\n  lua_getglobal( L, \"package\" );\n  lua_getfield( L, -1, \"path\" );\n\n  string cur_path = lua_tostring( L, -1 ), parsed, script_path = \"\";\n  stringstream input_stringstream(cur_path);\n  while(getline(input_stringstream, parsed, ';')) {\n    /* Example: package.path = dirs.installdir .. \"/scripts/lua/modules/?.lua;\" .. package.path */\n    unsigned found = parsed.find_last_of(\"?\");\n    if(found) {\n      string s = parsed.substr(0, found) + script_name + \".lua\";\n      if(Utils::file_exists(s.c_str())) {\n\tscript_path = s;\n\tbreak;\n      }\n    }\n  }\n\n  if(script_path == \"\" ||\n     __ntop_lua_handlefile(L, (char *)script_path.c_str(), false))\n    return 0;\n\n  return 1;\n}\n\nstatic int ntop_lua_dofile(lua_State* L)\n{\n  char *script_path;\n\n  if(lua_type(L, 1) != LUA_TSTRING ||\n     (script_path = (char*)lua_tostring(L, 1)) == NULL ||\n     __ntop_lua_handlefile(L, script_path, true))\n    return 0;\n\n  return 1;\n}\n#endif\n\n/* ****************************************** */\n\n/**\n * @brief Return true if login has been disabled\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK and push the return code into the Lua stack\n */\nstatic int ntop_is_login_disabled(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  bool ret = ntop->getPrefs()->is_localhost_users_login_disabled()\n    || !ntop->getPrefs()->is_users_login_enabled();\n\n  lua_pushboolean(vm, ret);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Convert the network Id to a symbolic name (network/mask)\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK and push the return code into the Lua stack\n */\nstatic int ntop_network_name_by_id(lua_State* vm) {\n  int id;\n  char *name;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  id = (u_int32_t)lua_tonumber(vm, 1);\n\n  name = ntop->getLocalNetworkName(id);\n\n  lua_pushstring(vm, name ? name : \"\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_logging_level(lua_State* vm) {\n    char *lvlStr;\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"%s() called\", __FUNCTION__);\n\n    if(ntop->getPrefs()->hasCmdlTraceLevel()) return(CONST_LUA_OK);\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n    lvlStr = (char*)lua_tostring(vm, 1);\n    if(!strcmp(lvlStr, \"trace\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_TRACE);\n    }\n    else if(!strcmp(lvlStr, \"debug\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_DEBUG);\n    }\n    else if(!strcmp(lvlStr, \"info\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_INFO);\n    }\n    else if(!strcmp(lvlStr, \"normal\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_NORMAL);\n    }\n    else if(!strcmp(lvlStr, \"warning\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_WARNING);\n    }\n    else if(!strcmp(lvlStr, \"error\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_ERROR);\n    }\n    else{\n        return(CONST_LUA_ERROR);\n    }\n\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic const luaL_Reg ntop_interface_reg[] = {\n  { \"getDefaultIfName\",       ntop_get_default_interface_name },\n  { \"setActiveInterfaceId\",   ntop_set_active_interface_id },\n  { \"getIfNames\",             ntop_get_interface_names },\n  { \"select\",                 ntop_select_interface },\n  { \"getStats\",               ntop_get_interface_stats },\n  { \"resetCounters\",          ntop_interface_reset_counters },\n\n  { \"getnDPIStats\",           ntop_get_ndpi_interface_stats },\n  { \"getnDPIProtoName\",       ntop_get_ndpi_protocol_name },\n  { \"getnDPIProtoId\",         ntop_get_ndpi_protocol_id },\n  { \"getnDPIProtoCategory\",   ntop_get_ndpi_protocol_category },\n  { \"getnDPIFlowsCount\",      ntop_get_ndpi_interface_flows_count },\n  { \"getFlowsStatus\",         ntop_get_ndpi_interface_flows_status },\n  { \"getnDPIProtoBreed\",      ntop_get_ndpi_protocol_breed },\n  { \"getnDPIProtocols\",       ntop_get_ndpi_protocols },\n  { \"getnDPICategories\",      ntop_get_ndpi_categories },\n  { \"getHostsInfo\",           ntop_get_interface_hosts_info },\n  { \"getLocalHostsInfo\",      ntop_get_interface_local_hosts_info },\n  { \"getRemoteHostsInfo\",     ntop_get_interface_remote_hosts_info },\n  { \"getHostActivity\",        ntop_get_interface_host_activity },\n  { \"getHostInfo\",            ntop_get_interface_host_info },\n  { \"getGroupedHosts\",        ntop_get_grouped_interface_hosts },\n  { \"getNetworksStats\",       ntop_get_interface_networks_stats },\n  { \"resetPeriodicStats\",     ntop_host_reset_periodic_stats },\n  { \"correlateHostActivity\",  ntop_correalate_host_activity },\n  { \"similarHostActivity\",    ntop_similar_host_activity },\n  { \"getHostActivityMap\",     ntop_get_interface_host_activitymap },\n  { \"restoreHost\",            ntop_restore_interface_host },\n  { \"getFlowsInfo\",           ntop_get_interface_flows_info },\n  { \"getLocalFlowsInfo\",      ntop_get_interface_local_flows_info },\n  { \"getRemoteFlowsInfo\",     ntop_get_interface_remote_flows_info },\n  { \"getFlowsStats\",          ntop_get_interface_flows_stats },\n  { \"getFlowKey\",             ntop_get_interface_flow_key   },\n  { \"findFlowByKey\",          ntop_get_interface_find_flow_by_key },\n  { \"dropFlowTraffic\",        ntop_drop_flow_traffic },\n  { \"dumpFlowTraffic\",        ntop_dump_flow_traffic },\n  { \"dumpLocalHosts2redis\",   ntop_dump_local_hosts_2_redis },\n  { \"findUserFlows\",          ntop_get_interface_find_user_flows },\n  { \"findPidFlows\",           ntop_get_interface_find_pid_flows },\n  { \"findFatherPidFlows\",     ntop_get_interface_find_father_pid_flows },\n  { \"findNameFlows\",          ntop_get_interface_find_proc_name_flows },\n  { \"listHTTPhosts\",          ntop_list_http_hosts },\n  { \"findHost\",               ntop_get_interface_find_host },\n  { \"updateHostTrafficPolicy\", ntop_update_host_traffic_policy },\n  { \"updateHostAlertPolicy\",  ntop_update_host_alert_policy },\n  { \"setSecondTraffic\",       ntop_set_second_traffic },\n  { \"setHostDumpPolicy\",      ntop_set_host_dump_policy },\n  { \"setHostQuota\",           ntop_set_host_quota },\n  { \"getPeerHitRate\",            ntop_get_host_hit_rate },\n  { \"getLatestActivityHostsInfo\",     ntop_get_interface_latest_activity_hosts_info },\n  { \"getInterfaceDumpDiskPolicy\",     ntop_get_interface_dump_disk_policy },\n  { \"getInterfaceDumpTapPolicy\",      ntop_get_interface_dump_tap_policy },\n  { \"getInterfaceDumpTapName\",        ntop_get_interface_dump_tap_name },\n  { \"getInterfaceDumpMaxPkts\",        ntop_get_interface_dump_max_pkts },\n  { \"getInterfaceDumpMaxSec\",         ntop_get_interface_dump_max_sec },\n  { \"getInterfaceDumpMaxFiles\",       ntop_get_interface_dump_max_files },\n  { \"getInterfacePacketsDumpedFile\",  ntop_get_interface_pkts_dumped_file },\n  { \"getInterfacePacketsDumpedTap\",   ntop_get_interface_pkts_dumped_tap },\n  { \"getEndpoint\",                    ntop_get_interface_endpoint },\n  { \"isPacketInterface\",              ntop_interface_is_packet_interface },\n  { \"isBridgeInterface\",              ntop_interface_is_bridge_interface },\n  { \"isPcapDumpInterface\",            ntop_interface_is_pcap_dump_interface },\n  { \"isRunning\",                      ntop_interface_is_running },\n  { \"isIdle\",                         ntop_interface_is_idle },\n  { \"setInterfaceIdleState\",          ntop_interface_set_idle },\n  { \"name2id\",                        ntop_interface_name2id },\n  { \"loadDumpPrefs\",                  ntop_load_dump_prefs },\n  { \"loadScalingFactorPrefs\",         ntop_load_scaling_factor_prefs },\n  { \"loadHostAlertPrefs\",             ntop_interface_load_host_alert_prefs },\n\n  /* Mac */\n  { \"getMacsInfo\",                    ntop_get_interface_macs_info },\n  { \"getMacInfo\",                     ntop_get_interface_mac_info },\n\n  /* L7 */\n  { \"reloadL7Rules\",                  ntop_reload_l7_rules },\n  { \"reloadShapers\",                  ntop_reload_shapers },\n\n  /* Host pools */\n  { \"reloadHostPools\",                ntop_reload_host_pools                },\n  #ifdef NTOPNG_PRO\n  { \"getHostPoolsStats\",              ntop_get_host_pool_interface_stats    },\n  { \"getHostPoolsVolatileMembers\",    ntop_get_host_pool_volatile_members   },\n  { \"purgeExpiredPoolsMembers\",       ntop_purge_expired_host_pools_members },\n  { \"removeVolatileMemberFromPool\",   ntop_remove_volatile_member_from_pool },\n#endif\n\n  /* DB */\n  { \"execSQLQuery\",                   ntop_interface_exec_sql_query },\n\n  /* Flows */\n  { \"getFlowDevices\",  ntop_getflowdevices },\n  { \"getFlowDeviceInfo\",  ntop_getflowdeviceinfo },\n\n  /* New generation alerts */\n  { \"getCachedNumAlerts\",   ntop_interface_get_cached_num_alerts    },\n  { \"queryAlertsRaw\",       ntop_interface_query_alerts_raw         },\n  { \"queryFlowAlertsRaw\",   ntop_interface_query_flow_alerts_raw    },\n  { \"engageHostAlert\",      ntop_interface_engage_host_alert        },\n  { \"releaseHostAlert\",     ntop_interface_release_host_alert       },\n  { \"engageNetworkAlert\",   ntop_interface_engage_network_alert     },\n  { \"releaseNetworkAlert\",  ntop_interface_release_network_alert    },\n  { \"engageInterfaceAlert\", ntop_interface_engage_interface_alert   },\n  { \"releaseInterfaceAlert\",ntop_interface_release_interface_alert  },\n  { \"enableHostAlerts\",     ntop_interface_host_enable_alerts       },\n  { \"disableHostAlerts\",    ntop_interface_host_disable_alerts      },\n  { \"refreshNumAlerts\",     ntop_interface_refresh_num_alerts       },\n  { \"makeRoomAlerts\",       ntop_interface_make_room_alerts         },\n  { \"makeRoomRequested\",    ntop_interface_make_room_requested      },\n  { NULL,                             NULL }\n};\n\n/* **************************************************************** */\n\nstatic const luaL_Reg ntop_reg[] = {\n  { \"getDirs\",        ntop_get_dirs },\n  { \"getInfo\",        ntop_get_info },\n  { \"getUptime\",      ntop_get_uptime },\n  { \"dumpFile\",       ntop_dump_file },\n  { \"checkLicense\",   ntop_check_license },\n\n  /* Redis */\n  { \"getCache\",        ntop_get_redis },\n  { \"setCache\",        ntop_set_redis },\n  { \"delCache\",        ntop_delete_redis_key },\n  { \"listIndexCache\",  ntop_list_index_redis },\n  { \"lpushCache\",      ntop_lpush_redis },\n  { \"lpopCache\",       ntop_lpop_redis },\n  { \"lrangeCache\",     ntop_lrange_redis },\n  { \"setMembersCache\", ntop_add_set_member_redis },\n  { \"delMembersCache\", ntop_del_set_member_redis },\n  { \"getMembersCache\", ntop_get_set_members_redis },\n  { \"getHashCache\",    ntop_get_hash_redis },\n  { \"setHashCache\",    ntop_set_hash_redis },\n  { \"delHashCache\",    ntop_del_hash_redis },\n  { \"getHashKeysCache\",ntop_get_hash_keys_redis },\n  { \"getKeysCache\",    ntop_get_keys_redis },\n  { \"delHashCache\",    ntop_delete_hash_redis_key },\n  { \"setPopCache\",     ntop_get_redis_set_pop },\n  { \"getHostId\",       ntop_redis_get_host_id },\n  { \"getIdToHost\",     ntop_redis_get_id_to_host },\n\n  /* Redis Preferences */\n  { \"setPref\",         ntop_set_redis_preference },\n  { \"getPref\",         ntop_get_redis },\n\n  { \"isdir\",          ntop_is_dir },\n  { \"mkdir\",          ntop_mkdir_tree },\n  { \"notEmptyFile\",   ntop_is_not_empty_file },\n  { \"exists\",         ntop_get_file_dir_exists },\n  { \"listReports\",    ntop_list_reports },\n  { \"fileLastChange\", ntop_get_file_last_change },\n  { \"readdir\",        ntop_list_dir_files },\n  { \"rmdir\",          ntop_remove_dir_recursively },\n  { \"zmq_connect\",    ntop_zmq_connect },\n  { \"zmq_disconnect\", ntop_zmq_disconnect },\n  { \"zmq_receive\",    ntop_zmq_receive },\n  { \"getLocalNetworks\",  ntop_get_local_networks },\n  { \"reloadPreferences\", ntop_reload_preferences },\n\n#ifdef NTOPNG_PRO\n  { \"sendNagiosAlert\",      ntop_nagios_send_alert },\n  { \"withdrawNagiosAlert\",  ntop_nagios_withdraw_alert },\n  { \"reloadNagiosConfig\",   ntop_nagios_reload_config },\n  { \"checkProfileSyntax\",   ntop_check_profile_syntax },\n  { \"reloadProfiles\",       ntop_reload_traffic_profiles },\n#endif\n\n  /* Pro */\n  { \"isPro\",                ntop_is_pro },\n  { \"isEnterprise\",         ntop_is_enterprise },\n\n  /* Historical database */\n  { \"insertMinuteSampling\",        ntop_stats_insert_minute_sampling },\n  { \"insertHourSampling\",          ntop_stats_insert_hour_sampling },\n  { \"insertDaySampling\",           ntop_stats_insert_day_sampling },\n  { \"getMinuteSampling\",           ntop_stats_get_minute_sampling },\n  { \"deleteMinuteStatsOlderThan\",  ntop_stats_delete_minute_older_than },\n  { \"deleteHourStatsOlderThan\",    ntop_stats_delete_hour_older_than },\n  { \"deleteDayStatsOlderThan\",     ntop_stats_delete_day_older_than },\n  { \"getMinuteSamplingsFromEpoch\", ntop_stats_get_samplings_of_minutes_from_epoch },\n  { \"getHourSamplingsFromEpoch\",   ntop_stats_get_samplings_of_hours_from_epoch },\n  { \"getDaySamplingsFromEpoch\",    ntop_stats_get_samplings_of_days_from_epoch },\n  { \"getMinuteSamplingsInterval\",  ntop_stats_get_minute_samplings_interval },\n\n  { \"deleteDumpFiles\", ntop_delete_dump_files },\n\n  /* Time */\n  { \"gettimemsec\",    ntop_gettimemsec },\n\n  /* Trace */\n  { \"verboseTrace\",   ntop_verbose_trace },\n\n  /* UDP */\n  { \"send_udp_data\",  ntop_send_udp_data },\n\n  /* IP */\n  { \"inet_ntoa\",      ntop_inet_ntoa },\n\n  /* RRD */\n  { \"rrd_create\",     ntop_rrd_create },\n  { \"rrd_update\",     ntop_rrd_update },\n  { \"rrd_fetch\",      ntop_rrd_fetch  },\n  { \"rrd_fetch_columns\", ntop_rrd_fetch_columns },\n  { \"rrd_lastupdate\", ntop_rrd_lastupdate  },\n\n  /* Prefs */\n  { \"getPrefs\",          ntop_get_prefs },\n\n  /* HTTP */\n  { \"httpRedirect\",   ntop_http_redirect },\n  { \"httpGet\",        ntop_http_get },\n  { \"getHttpPrefix\",  ntop_http_get_prefix },\n\n  /* Admin */\n  { \"getNologinUser\",     ntop_get_nologin_username },\n  { \"getUsers\",           ntop_get_users },\n  { \"getUserGroup\",       ntop_get_user_group },\n  { \"getAllowedNetworks\", ntop_get_allowed_networks },\n  { \"resetUserPassword\",  ntop_reset_user_password },\n  { \"changeUserRole\",     ntop_change_user_role },\n  { \"changeAllowedNets\",  ntop_change_allowed_nets },\n  { \"changeAllowedIfname\",ntop_change_allowed_ifname },\n  { \"changeUserHostPool\", ntop_change_user_host_pool },\n  { \"addUser\",            ntop_add_user },\n  { \"addUserLifetime\",    ntop_add_user_lifetime },\n  { \"clearUserLifetime\",  ntop_clear_user_lifetime },\n  { \"deleteUser\",         ntop_delete_user },\n  { \"isLoginDisabled\",    ntop_is_login_disabled },\n  { \"getNetworkNameById\", ntop_network_name_by_id },\n\n  /* Security */\n  { \"getRandomCSRFValue\",     ntop_generate_csrf_value },\n\n  /* HTTP */\n  { \"postHTTPJsonData\",       ntop_post_http_json_data },\n\n  /* Address Resolution */\n  { \"resolveAddress\",     ntop_resolve_address },\n  { \"getResolvedAddress\", ntop_get_resolved_address },\n\n  /* Logging */\n  { \"syslog\",         ntop_syslog },\n  { \"setLoggingLevel\",ntop_set_logging_level },\n\n  /* SNMP */\n  { \"snmpget\",        ntop_snmpget },\n  { \"snmpgetnext\",    ntop_snmpgetnext },\n\n  /* SQLite */\n  { \"execQuery\",      ntop_sqlite_exec_query },\n\n  /* Runtime */\n  { \"hasVLANs\",       ntop_has_vlans },\n  { \"hasGeoIP\",       ntop_has_geoip },\n  { \"isWindows\",      ntop_is_windows },\n\n  /* Host Blacklist */\n  { \"allocHostBlacklist\", ntop_allocHostBlacklist },\n  { \"swapHostBlacklist\",  ntop_swapHostBlacklist  },\n  { \"addToHostBlacklist\", ntop_addToHostBlacklist },\n\n  /* Misc */\n  { \"getservbyport\",      ntop_getservbyport      },\n  { \"getMacManufacturer\", ntop_get_mac_manufacturer },\n  { \"getSiteCategories\",  ntop_get_site_categories },\n\n  { NULL,          NULL}\n};\n\n/* ****************************************** */\n\nvoid Lua::lua_register_classes(lua_State *L, bool http_mode) {\n  static const luaL_Reg _meta[] = { { NULL, NULL } };\n  int i;\n\n  ntop_class_reg ntop_lua_reg[] = {\n    { \"interface\", ntop_interface_reg },\n    { \"ntop\",      ntop_reg },\n    {NULL,         NULL}\n  };\n\n  if(!L) return;\n\n  luaopen_lsqlite3(L);\n\n  for(i=0; ntop_lua_reg[i].class_name != NULL; i++) {\n    int lib_id, meta_id;\n\n    /* newclass = {} */\n    lua_createtable(L, 0, 0);\n    lib_id = lua_gettop(L);\n\n    /* metatable = {} */\n    luaL_newmetatable(L, ntop_lua_reg[i].class_name);\n    meta_id = lua_gettop(L);\n    luaL_register(L, NULL, _meta);\n\n    /* metatable.__index = class_methods */\n    lua_newtable(L), luaL_register(L, NULL, ntop_lua_reg[i].class_methods);\n    lua_setfield(L, meta_id, \"__index\");\n\n    /* class.__metatable = metatable */\n    lua_setmetatable(L, lib_id);\n\n    /* _G[\"Foo\"] = newclass */\n    lua_setglobal(L, ntop_lua_reg[i].class_name);\n  }\n\n  if(http_mode) {\n    /* Overload the standard Lua print() with ntop_lua_http_print that dumps data on HTTP server */\n    lua_register(L, \"print\", ntop_lua_http_print);\n  } else\n    lua_register(L, \"print\", ntop_lua_cli_print);\n\n#ifdef NTOPNG_PRO\n  if(ntop->getPro()->has_valid_license()) {\n    lua_register(L, \"ntopRequire\", ntop_lua_require);\n    luaL_dostring(L, \"table.insert(package.loaders, 1, ntopRequire)\");\n    lua_register(L, \"dofile\", ntop_lua_dofile);\n  }\n#endif\n}\n\n/* ****************************************** */\n\n#if 0\n/**\n * Iterator over key-value pairs where the value\n * maybe made available in increments and/or may\n * not be zero-terminated.  Used for processing\n * POST data.\n *\n * @param cls user-specified closure\n * @param kind type of the value\n * @param key 0-terminated key for the value\n * @param filename name of the uploaded file, NULL if not known\n * @param content_type mime-type of the data, NULL if not known\n * @param transfer_encoding encoding of the data, NULL if not known\n * @param data pointer to size bytes of data at the\n *              specified offset\n * @param off offset of data in the overall value\n * @param size number of bytes in data available\n * @return MHD_YES to continue iterating,\n *         MHD_NO to abort the iteration\n */\nstatic int post_iterator(void *cls,\n\t\t\t enum MHD_ValueKind kind,\n\t\t\t const char *key,\n\t\t\t const char *filename,\n\t\t\t const char *content_type,\n\t\t\t const char *transfer_encoding,\n\t\t\t const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  char tmp[1024];\n  u_int len = min(size, sizeof(tmp)-1);\n\n  memcpy(tmp, &data[off], len);\n  tmp[len] = '\\0';\n\n  fprintf(stdout, \"[POST] [%s][%s]\\n\", key, tmp);\n  return MHD_YES;\n}\n#endif\n\n/* ****************************************** */\n\n/*\n  Run a Lua script from within ntopng (no HTTP GUI)\n*/\nint Lua::run_script(char *script_path) {\n  int rc = 0;\n\n  if(!L) return(-1);\n\n  try {\n    luaL_openlibs(L); /* Load base libraries */\n    lua_register_classes(L, false); /* Load custom classes */\n\n#ifndef NTOPNG_PRO\n    rc = luaL_dofile(L, script_path);\n#else\n    if(ntop->getPro()->has_valid_license())\n      rc = __ntop_lua_handlefile(L, script_path, true);\n    else\n      rc = luaL_dofile(L, script_path);\n#endif\n\n    if(rc != 0) {\n      const char *err = lua_tostring(L, -1);\n\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n      rc = -1;\n    }\n  } catch(...) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s]\", script_path);\n    rc = -2;\n  }\n\n  return(rc);\n}\n\n/* ****************************************** */\n\n/* http://www.geekhideout.com/downloads/urlcode.c */\n\n#if 0\n/* Converts an integer value to its hex character*/\nstatic char to_hex(char code) {\n  static char hex[] = \"0123456789abcdef\";\n  return hex[code & 15];\n}\n\n/* ****************************************** */\n\n/* Returns a url-encoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nstatic char* http_encode(char *str) {\n  char *pstr = str, *buf = (char*)malloc(strlen(str) * 3 + 1), *pbuf = buf;\n  while (*pstr) {\n    if(isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~')\n      *pbuf++ = *pstr;\n    else if(*pstr == ' ')\n      *pbuf++ = '+';\n    else\n      *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);\n    pstr++;\n  }\n  *pbuf = '\\0';\n  return buf;\n}\n#endif\n\n/* ****************************************** */\n\nvoid Lua::purifyHTTPParameter(char *param) {\n  char *ampercent;\n\n  if((ampercent = strchr(param, '%')) != NULL) {\n    /* We allow only a few chars, removing all the others */\n\n    if((ampercent[1] != 0) && (ampercent[2] != 0)) {\n      char c;\n      char b = ampercent[3];\n\n      ampercent[3] = '\\0';\n      c = (char)strtol(&ampercent[1], NULL, 16);\n      ampercent[3] = b;\n\n      switch(c) {\n      case '/':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '$':\n      case ',':\n      case '^':\n      case '*':\n      case '_':\n      case '&':\n      case ' ':\n      case '=':\n      case '<':\n      case '>':\n      case '@':\n      case '#':\n\tbreak;\n\n      default:\n\tif(!Utils::isPrintableChar(c)) {\n\t  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded char '0x%02x' in URI [%s]\", c, param);\n\t  ampercent[0] = '\\0';\n\t  return;\n\t}\n      }\n\n      purifyHTTPParameter(&ampercent[3]);\n    } else\n      ampercent[0] = '\\0';\n  }\n}\n\n/* ****************************************** */\n\nvoid Lua::setInterface(const char *user) {\n  char key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  bool enforce_allowed_interface = false;\n\n  if(user[0] != '\\0') {\n    // check if the user is restricted to browse only a given interface\n\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      // there is only one allowed interface for the user\n      enforce_allowed_interface = true;\n      goto set_preferred_interface;\n    } else if(snprintf(key, sizeof(key), \"ntopng.prefs.%s.ifname\", user)\n\t      && ntop->getRedis()->get(key, ifname, sizeof(ifname)) < 0) {\n      // no allowed interface and no default set interface\n    set_default_if_name_in_session:\n      snprintf(ifname, sizeof(ifname), \"%s\",\n\t       ntop->getInterfaceAtId(NULL /* allowed user interface check already enforced */,\n\t\t\t\t      0)->get_name());\n      lua_push_str_table_entry(L, \"ifname\", ifname);\n      ntop->getRedis()->set(key, ifname, 3600 /* 1h */);\n    } else {\n      goto set_preferred_interface;\n    }\n  } else {\n    // We need to check if ntopng is running with the option --disable-login\n    snprintf(key, sizeof(key), \"ntopng.prefs.ifname\");\n    if(ntop->getRedis()->get(key, ifname, sizeof(ifname)) < 0) {\n      goto set_preferred_interface;\n    }\n\n  set_preferred_interface:\n    NetworkInterface *iface;\n\n    if((iface = ntop->getNetworkInterface(NULL /* allowed user interface check already enforced */,\n\t\t\t\t\t      ifname)) != NULL) {\n      /* The specified interface still exists */\n      lua_push_str_table_entry(L, \"ifname\", iface->get_name());\n    } else if(!enforce_allowed_interface) {\n      goto set_default_if_name_in_session;\n    } else {\n      // TODO: handle the case where the user has\n      // an allowed interface that is not presently available\n      // (e.g., not running?)\n    }\n  }\n}\n\n/* ****************************************** */\n\nvoid Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n\n      tok = strtok_r(NULL, \"&\", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); /* Default */\n}\n\n/* ****************************************** */\n\nint Lua::handle_script_request(struct mg_connection *conn,\n\t\t\t       const struct mg_request_info *request_info,\n\t\t\t       char *script_path) {\n  char buf[64], key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  char *_cookies, user[64] = { '\\0' };\n  AddressTree ptree;\n  int rc;\n  const char * content_type;\n\n  if(!L) return(-1);\n\n  luaL_openlibs(L); /* Load base libraries */\n  lua_register_classes(L, true); /* Load custom classes */\n\n  lua_pushlightuserdata(L, (char*)conn);\n  lua_setglobal(L, CONST_HTTP_CONN);\n\n  content_type = mg_get_header(conn, \"Content-Type\");\n\n  /* Check for POST requests */\n  if((strcmp(request_info->request_method, \"POST\") == 0) &&\n      ((content_type != NULL) && (strstr(content_type, \"application/x-www-form-urlencoded\") == content_type))) {\n    char post_data[1024] = { '\\0' };\n    char rsp[32];\n    char csrf[64] = { '\\0' };\n    char user[64] = { '\\0' };\n    int post_data_len = mg_read(conn, post_data, sizeof(post_data));\n    u_int8_t valid_csrf = 1;\n\n    post_data[sizeof(post_data)-1] = '\\0';\n\n    /* CSRF is mandatory in POST request */\n    mg_get_var(post_data, post_data_len, \"csrf\", csrf, sizeof(csrf));\n    mg_get_cookie(conn, \"user\", user, sizeof(user));\n\n    if((ntop->getRedis()->get(csrf, rsp, sizeof(rsp)) == -1)\n       || (strcmp(rsp, user) != 0)) {\n#if 0\n      const char *msg = \"The submitted form is expired. Please reload the page and try again. <p>[ <A HREF=/>Home</A> ]\";\n\n      ntop->getTrace()->traceEvent(TRACE_WARNING,\n          \"Invalid CSRF parameter specified [%s][%s][%s][%s]: page expired?\",\n          csrf, rsp, user, \"csrf\");\n\n      return(send_error(conn, 500 /* Internal server error */,\n          msg, PAGE_ERROR, script_path, msg));\n#else\n      valid_csrf = 0;\n#endif\n    } else {\n      /* Invalidate csrf */\n      ntop->getRedis()->del(csrf);\n    }\n\n    if(valid_csrf)\n      setParamsTable(L, \"_POST\", post_data); /* CSRF is valid here, now fill the _POST table with POST parameters */\n    else\n      setParamsTable(L, \"_POST\", NULL /* Empty */);\n  } else\n    setParamsTable(L, \"_POST\", NULL /* Empty */);\n\n  /* Put the GET params into the environment */\n  if(request_info->query_string)\n    setParamsTable(L, \"_GET\", request_info->query_string);\n  else\n    setParamsTable(L, \"_GET\", NULL /* Empty */);\n\n  /* _SERVER */\n  lua_newtable(L);\n  lua_push_str_table_entry(L, \"REQUEST_METHOD\", (char*)request_info->request_method);\n  lua_push_str_table_entry(L, \"URI\", (char*)request_info->uri ? (char*)request_info->uri : (char*)\"\");\n  lua_push_str_table_entry(L, \"REFERER\", (char*)mg_get_header(conn, \"Referer\") ? (char*)mg_get_header(conn, \"Referer\") : (char*)\"\");\n  if(request_info->remote_user)  lua_push_str_table_entry(L, \"REMOTE_USER\", (char*)request_info->remote_user);\n  if(request_info->query_string) lua_push_str_table_entry(L, \"QUERY_STRING\", (char*)request_info->query_string);\n\n  for(int i=0; ((request_info->http_headers[i].name != NULL) \n\t\t&& request_info->http_headers[i].name[0] != '\\0'); i++)\n    lua_push_str_table_entry(L,\n\t\t\t     request_info->http_headers[i].name,\n\t\t\t     (char*)request_info->http_headers[i].value);  \n  lua_setglobal(L, (char*)\"_SERVER\");\n\n  /* Cookies */\n  lua_newtable(L);\n  if((_cookies = (char*)mg_get_header(conn, \"Cookie\")) != NULL) {\n    char *cookies = strdup(_cookies);\n    char *tok, *where;\n\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"=> '%s'\", cookies);\n    tok = strtok_r(cookies, \"=\", &where);\n    while(tok != NULL) {\n      char *val;\n\n      while(tok[0] == ' ') tok++;\n\n      if((val = strtok_r(NULL, \";\", &where)) != NULL) {\n\tlua_push_str_table_entry(L, tok, val);\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, val);\n      } else\n\tbreak;\n\n      tok = strtok_r(NULL, \"=\", &where);\n    }\n\n    free(cookies);\n  }\n  lua_setglobal(L, \"_COOKIE\"); /* Like in php */\n\n  /* Put the _SESSION params into the environment */\n  lua_newtable(L);\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  lua_push_str_table_entry(L, \"user\", user);\n  mg_get_cookie(conn, \"session\", buf, sizeof(buf));\n  lua_push_str_table_entry(L, \"session\", buf);\n\n  // now it's time to set the interface.\n  setInterface(user);\n\n  lua_setglobal(L, \"_SESSION\"); /* Like in php */\n\n  if(user[0] != '\\0') {\n    char val[255];\n\n    lua_pushlightuserdata(L, user);\n    lua_setglobal(L, \"user\");\n\n    snprintf(key, sizeof(key), \"ntopng.user.%s.allowed_nets\", user);\n    if((ntop->getRedis()->get(key, val, sizeof(val)) != -1)\n       && (val[0] != '\\0')) {\n      ptree.addAddresses(val);\n      lua_pushlightuserdata(L, &ptree);\n      lua_setglobal(L, CONST_ALLOWED_NETS);\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"SET %p\", ptree);\n    }\n\n    snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user);\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      lua_pushlightuserdata(L, ifname);\n      lua_setglobal(L, CONST_ALLOWED_IFNAME);\n    }\n  }\n\n#ifndef NTOPNG_PRO\n  rc = luaL_dofile(L, script_path);\n#else\n  if(ntop->getPro()->has_valid_license())\n    rc = __ntop_lua_handlefile(L, script_path, true);\n  else\n    rc = luaL_dofile(L, script_path);\n#endif\n\n  if(rc != 0) {\n    const char *err = lua_tostring(L, -1);\n\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n    return(send_error(conn, 500 /* Internal server error */,\n\t\t      \"Internal server error\", PAGE_ERROR, script_path, err));\n  }\n\n  return(CONST_LUA_OK);\n}\n", "/*\n *\n * (C) 2013-17 - ntop.org\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"ntop_includes.h\"\n\n#ifdef __APPLE__\n#include <uuid/uuid.h>\n#endif\n\n/* UserActivityStats.cpp */\nextern const char* activity_names[];\n\n/* Lua.cpp */\nextern int ntop_lua_cli_print(lua_State* vm);\nextern int ntop_lua_check(lua_State* vm, const char* func, int pos, int expected_type);\n\nstatic bool help_printed = false;\n\n/* **************************************************** */\n\n/* Method used for collateral activities */\nNetworkInterface::NetworkInterface() { init(); }\n\n/* **************************************************** */\n\nNetworkInterface::NetworkInterface(const char *name,\n\t\t\t\t   const char *custom_interface_type) {\n  NDPI_PROTOCOL_BITMASK all;\n  char _ifname[64];\n  bool isViewInterface = (strncmp(name, \"view:\", 5) == 0) ? 1 : 0; /* We need to do it as isView() is not yet initialized */\n\n  customIftype = custom_interface_type, flowHashingMode = flowhashing_none;\n  init();\n\n#ifdef WIN32\n  if(name == NULL) name = \"1\"; /* First available interface */\n#endif\n\n  scalingFactor = 1, remoteIfname = remoteIfIPaddr = remoteProbeIPaddr = remoteProbePublicIPaddr = NULL;\n  if(strcmp(name, \"-\") == 0) name = \"stdin\";\n  if(strcmp(name, \"-\") == 0) name = \"stdin\";\n\n  if(ntop->getRedis())\n    id = Utils::ifname2id(name);\n  else\n    id = -1;\n\n  purge_idle_flows_hosts = true;\n\n  if(name == NULL) {\n    char pcap_error_buffer[PCAP_ERRBUF_SIZE];\n\n    if(!help_printed)\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"No capture interface specified\");\n\n    printAvailableInterfaces(false, 0, NULL, 0);\n\n    name = pcap_lookupdev(pcap_error_buffer);\n\n    if(name == NULL) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR,\n\t\t\t\t   \"Unable to locate default interface (%s)\\n\",\n\t\t\t\t   pcap_error_buffer);\n      exit(0);\n    }\n  } else {\n    if(isNumber(name)) {\n      /* We need to convert this numeric index into an interface name */\n      int id = atoi(name);\n\n      _ifname[0] = '\\0';\n      printAvailableInterfaces(false, id, _ifname, sizeof(_ifname));\n\n      if(_ifname[0] == '\\0') {\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to locate interface Id %d\", id);\n\tprintAvailableInterfaces(false, 0, NULL, 0);\n\texit(0);\n      }\n\n      name = _ifname;\n    }\n  }\n\n  pkt_dumper_tap = NULL, lastSecUpdate = 0;\n  ifname = strdup(name);\n\n  if(id >= 0) {\n    u_int32_t num_hashes;\n    ndpi_port_range d_port[MAX_DEFAULT_PORTS];\n    u_int16_t no_master[2] = { NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO };\n\n    num_hashes = max_val(4096, ntop->getPrefs()->get_max_num_flows()/4);\n    flows_hash = new FlowHash(this, num_hashes, ntop->getPrefs()->get_max_num_flows());\n\n    num_hashes = max_val(4096, ntop->getPrefs()->get_max_num_hosts()/4);\n    hosts_hash = new HostHash(this, num_hashes, ntop->getPrefs()->get_max_num_hosts());\n\n    macs_hash = new MacHash(this, 4, ntop->getPrefs()->get_max_num_hosts());\n\n    // init global detection structure\n    ndpi_struct = ndpi_init_detection_module();\n    if(ndpi_struct == NULL) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"Global structure initialization failed\");\n      exit(-1);\n    }\n\n    if(ntop->getCustomnDPIProtos() != NULL)\n      ndpi_load_protocols_file(ndpi_struct, ntop->getCustomnDPIProtos());\n\n    ndpi_struct->http_dont_dissect_response = 1;\n\n    memset(d_port, 0, sizeof(d_port));\n    ndpi_set_proto_defaults(ndpi_struct, NDPI_PROTOCOL_UNRATED, NTOPNG_NDPI_OS_PROTO_ID,\n\t\t\t    no_master, no_master,\n\t\t\t    (char*)\"Operating System\",\n\t\t\t    NDPI_PROTOCOL_CATEGORY_SYSTEM,\n\t\t\t    d_port, d_port);\n\n    // enable all protocols\n    NDPI_BITMASK_SET_ALL(all);\n    ndpi_set_protocol_detection_bitmask2(ndpi_struct, &all);\n\n    last_pkt_rcvd = last_pkt_rcvd_remote = 0, pollLoopCreated = false, bridge_interface = false;\n    next_idle_flow_purge = next_idle_host_purge = 0;\n    cpu_affinity = -1 /* no affinity */, has_vlan_packets = false, pkt_dumper = NULL;\n    if(ntop->getPrefs()->are_taps_enabled())\n      pkt_dumper_tap = new PacketDumperTuntap(this);\n\n    running = false, sprobe_interface = false, inline_interface = false, db = NULL;\n\n    if((!isViewInterface) && (ntop->getPrefs()->do_dump_flows_on_mysql())) {\n#ifdef NTOPNG_PRO\n      if(ntop->getPrefs()->is_enterprise_edition()) db = new BatchedMySQLDB(this);\n#endif\n\n      if(db == NULL)\n\tdb = new MySQLDB(this);\n\n      if(!db) throw \"Not enough memory\";\n    }\n\n    checkIdle();\n    ifSpeed = Utils::getMaxIfSpeed(name);\n    ifMTU = Utils::getIfMTU(name), mtuWarningShown = false;\n  } else {\n    flows_hash = NULL, hosts_hash = NULL;\n    ndpi_struct = NULL, db = NULL, ifSpeed = 0;\n    pkt_dumper = NULL, pkt_dumper_tap = NULL;\n  }\n\n  networkStats = NULL;\n  \n#ifdef NTOPNG_PRO\n  policer = NULL; /* possibly instantiated by subclass PacketBridge */\n  flow_profiles = ntop->getPro()->has_valid_license() ? new FlowProfiles(id) : NULL;\n  if(flow_profiles) flow_profiles->loadProfiles();\n  shadow_flow_profiles = NULL;\n#endif\n\n  loadDumpPrefs();\n  loadScalingFactorPrefs();\n\n  if(((statsManager  = new StatsManager(id, STATS_MANAGER_STORE_NAME)) == NULL)\n     || ((alertsManager = new AlertsManager(id, ALERTS_MANAGER_STORE_NAME)) == NULL))\n    throw \"Not enough memory\";\n\n  if((host_pools = new HostPools(this)) == NULL)\n    throw \"Not enough memory\";\n\n  alertLevel = alertsManager->getNumAlerts(true);\n\n#ifdef linux\n  /*\n    A bit aggressive but as people usually\n    ignore warnings let's be proactive\n  */\n  if(ifname\n     && (!isViewInterface)\n     && (!strstr(ifname, \":\"))\n     && (!strstr(ifname, \".pcap\"))\n     && strncmp(ifname, \"lo\", 2)\n     ) {\n    char buf[64];\n    \n    snprintf(buf, sizeof(buf), \"ethtool -K %s gro off gso off tso off\", ifname);\n    system(buf);\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Executing %s\", buf);\n  }\n#endif  \n\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::init() {\n  ifname = remoteIfname = remoteIfIPaddr = remoteProbeIPaddr = NULL,\n    remoteProbePublicIPaddr = NULL, flows_hash = NULL, hosts_hash = NULL,\n    ndpi_struct = NULL, zmq_initial_bytes = 0, zmq_initial_pkts = 0,\n    sprobe_interface = inline_interface = false, has_vlan_packets = false,\n    last_pkt_rcvd = last_pkt_rcvd_remote = 0,\n    next_idle_flow_purge = next_idle_host_purge = 0,\n    running = false, numSubInterfaces = 0,\n    numVirtualInterfaces = 0, flowHashing = NULL,\n    pcap_datalink_type = 0, mtuWarningShown = false, lastSecUpdate = 0,\n    purge_idle_flows_hosts = true, id = (u_int8_t)-1,\n    last_remote_pps = 0, last_remote_bps = 0,\n    sprobe_interface = false, has_vlan_packets = false,\n    pcap_datalink_type = 0, cpu_affinity = -1 /* no affinity */,\n    inline_interface = false, running = false, interfaceStats = NULL,\n    tooManyFlowsAlertTriggered = tooManyHostsAlertTriggered = false,\n    pkt_dumper = NULL, numL2Devices = 0,\n    checkpointPktCount = checkpointBytesCount = checkpointPktDropCount = 0,\n    pollLoopCreated = false, bridge_interface = false;\n\n  if(ntop && ntop->getPrefs() && ntop->getPrefs()->are_taps_enabled())\n    pkt_dumper_tap = new PacketDumperTuntap(this);\n  else\n    pkt_dumper_tap = NULL;\n\n  memset(subInterfaces, 0, sizeof(subInterfaces));\n  ip_addresses = \"\", networkStats = NULL,\n    pcap_datalink_type = 0, cpu_affinity = -1,\n    pkt_dumper = NULL;\n\n  memset(lastMinuteTraffic, 0, sizeof(lastMinuteTraffic));\n  resetSecondTraffic();\n\n  reloadLuaInterpreter = true, L_flow_create_delete_ndpi = L_flow_update = NULL;\n\n  db = NULL;\n#ifdef NTOPNG_PRO\n  policer = NULL;\n#endif\n  statsManager = NULL, alertsManager = NULL, ifSpeed = 0;\n  host_pools = NULL;\n  checkIdle();\n  dump_all_traffic = dump_to_disk = dump_unknown_traffic\n    = dump_security_packets = dump_to_tap = false;\n  dump_sampling_rate = CONST_DUMP_SAMPLING_RATE;\n  dump_max_pkts_file = CONST_MAX_NUM_PACKETS_PER_DUMP;\n  dump_max_duration = CONST_MAX_DUMP_DURATION;\n  dump_max_files = CONST_MAX_DUMP;\n  ifMTU = CONST_DEFAULT_MAX_PACKET_SIZE, mtuWarningShown = false;\n#ifdef NTOPNG_PRO\n  flow_profiles = shadow_flow_profiles = NULL;\n#endif\n}\n\n/* **************************************************** */\n\n#ifdef NTOPNG_PRO\n\nvoid NetworkInterface::initL7Policer() {\n  /* Instantiate the policer */\n  policer = new L7Policer(this);\n}\n\n#endif\n\n/* **************************************************** */\n\nvoid NetworkInterface::checkAggregationMode() {\n if(!customIftype) {\n    char rsp[32];\n\n    if(!strcmp(get_type(), CONST_INTERFACE_TYPE_ZMQ)) {\n      if(ntop->getRedis()->get((char*)CONST_RUNTIME_PREFS_IFACE_FLOW_COLLECTION, rsp, sizeof(rsp)) == 0) {\n\n\tif(!strcmp(rsp, \"probe_ip\")) flowHashingMode = flowhashing_probe_ip;\n\telse if(!strcmp(rsp, \"ingress_iface_idx\")) flowHashingMode = flowhashing_ingress_iface_idx;\n      }\n    } else {\n      if((ntop->getRedis()->get((char*)CONST_RUNTIME_PREFS_IFACE_VLAN_CREATION, rsp, sizeof(rsp)) == 0)\n\t && (!strncmp(rsp, \"1\", 1)))\n\tflowHashingMode = flowhashing_vlan;\n    }\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::loadDumpPrefs() {\n  if(ntop->getRedis() != NULL) {\n    updateDumpAllTrafficPolicy();\n    updateDumpTrafficDiskPolicy();\n    updateDumpTrafficTapPolicy();\n    updateDumpTrafficSamplingRate();\n    updateDumpTrafficMaxPktsPerFile();\n    updateDumpTrafficMaxSecPerFile();\n    updateDumpTrafficMaxFiles();\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::loadScalingFactorPrefs() {\n  if(ntop->getRedis() != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), CONST_IFACE_SCALING_FACTOR_PREFS, id);\n\n    if((ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0) && (rsp[0] != '\\0'))\n      scalingFactor = atol(rsp);\n\n    if(scalingFactor == 0) {\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"INTERNAL ERROR: scalingFactor can't be 0!\");\n      scalingFactor = 1;\n    }\n  }\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::updateDumpTrafficTapPolicy(void) {\n  bool retval = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_tap\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = !strncmp(rsp, \"true\", 5);\n    else\n      retval = false;\n  }\n\n  dump_to_tap = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::updateDumpAllTrafficPolicy(void) {\n  bool retval = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_all_traffic\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = !strncmp(rsp, \"true\", 5);\n  }\n\n  dump_all_traffic = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::updateDumpTrafficDiskPolicy(void) {\n  bool retval = false, retval_u = false, retval_s = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_disk\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = !strncmp(rsp, \"true\", 5);\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_unknown_disk\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval_u = !strncmp(rsp, \"true\", 5);\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_security_disk\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval_s = !strncmp(rsp, \"true\", 5);\n  }\n\n  dump_to_disk = retval;\n  dump_unknown_traffic = retval_u;\n  dump_security_packets = retval_s;\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficSamplingRate(void) {\n  int retval = 1;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_sampling_rate\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  dump_sampling_rate = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficMaxPktsPerFile(void) {\n  int retval = 0;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_max_pkts_file\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  retval = retval > 0 ? retval : CONST_MAX_NUM_PACKETS_PER_DUMP;\n\n  dump_max_pkts_file = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficMaxSecPerFile(void) {\n  int retval = 0;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_max_sec_file\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  retval = retval > 0 ? retval : CONST_MAX_DUMP_DURATION;\n\n  dump_max_duration = retval;\n\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficMaxFiles(void) {\n  int retval = 0;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_max_files\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  retval = retval > 0 ? retval : CONST_MAX_DUMP;\n\n  dump_max_files = retval;\n\n  return retval;\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::checkIdle() {\n  is_idle = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s_not_idle\", ifname);\n    if((ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0) && (rsp[0] != '\\0')) {\n      int val = atoi(rsp);\n\n      if(val == 0) is_idle = true;\n    }\n  }\n\n  return(is_idle);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::deleteDataStructures() {\n  if(flows_hash) { delete(flows_hash); flows_hash = NULL; }\n  if(hosts_hash) { delete(hosts_hash); hosts_hash = NULL; }\n  if(macs_hash)  { delete(macs_hash);  macs_hash = NULL;  }\n\n  if(ndpi_struct) {\n    ndpi_exit_detection_module(ndpi_struct);\n    ndpi_struct = NULL;\n  }\n\n  if(ifname) {\n    //ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Interface %s shutdown\", ifname);\n    free(ifname);\n    ifname = NULL;\n  }\n}\n\n/* **************************************************** */\n\nNetworkInterface::~NetworkInterface() {\n  if(getNumPackets() > 0) {\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"Flushing host contacts for interface %s\",\n\t\t\t\t get_name());\n    cleanup();\n  }\n\n  if(host_pools)     delete host_pools;     /* note: this requires ndpi_struct */\n  deleteDataStructures();\n\n  if(remoteIfname)      free(remoteIfname);\n  if(remoteIfIPaddr)    free(remoteIfIPaddr);\n  if(remoteProbeIPaddr) free(remoteProbeIPaddr);\n  if(remoteProbePublicIPaddr) free(remoteProbePublicIPaddr);\n  if(db)             delete db;\n  if(statsManager)   delete statsManager;\n  if(alertsManager)  delete alertsManager;\n  if(networkStats)   delete []networkStats;\n  if(pkt_dumper)     delete pkt_dumper;\n  if(pkt_dumper_tap) delete pkt_dumper_tap;\n  if(interfaceStats) delete interfaceStats;\n\n  if(flowHashing) {\n    FlowHashing *current, *tmp;\n\n    HASH_ITER(hh, flowHashing, current, tmp) {\n      /* Interfaces are deleted by the main termination function */\n      HASH_DEL(flowHashing, current);\n      free(current);\n    }\n  }\n\n#ifdef NTOPNG_PRO\n  if(policer)       delete(policer);\n  if(flow_profiles) delete(flow_profiles);\n  if(shadow_flow_profiles) delete(shadow_flow_profiles);\n#endif\n\n  termLuaInterpreter();\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpFlow(time_t when, bool idle_flow, Flow *f) {\n  if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    return(dumpDBFlow(when, idle_flow, f));\n  } else if(ntop->getPrefs()->do_dump_flows_on_es())\n    return(dumpEsFlow(when, f));\n  else {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error\");\n    return(-1);\n  }\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpEsFlow(time_t when, Flow *f) {\n  char *json = f->serialize(true);\n  int rc;\n\n  if(json) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[ES] %s\", json);\n    rc = ntop->getElasticSearch()->sendToES(json);\n    free(json);\n  } else\n    rc = -1;\n\n  return(rc);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpDBFlow(time_t when, bool idle_flow, Flow *f) {\n  char *json = f->serialize(false);\n  int rc;\n\n  if(json) {\n    rc = db->dumpFlow(when, idle_flow, f, json);\n    free(json);\n  } else\n    rc = -1;\n\n  return(rc);\n}\n\n/* **************************************************** */\n\nstatic bool local_hosts_2_redis_walker(GenericHashEntry *h, void *user_data) {\n  Host *host = (Host*)h;\n\n  if(host && (host->isLocalHost() || host->isSystemHost()))\n    host->serialize2redis();\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpLocalHosts2redis(bool disable_purge) {\n  int rc;\n\n  if(disable_purge) disablePurge(false /* on hosts */);\n  rc = walker(walker_hosts, local_hosts_2_redis_walker, NULL) ? 0 : -1;\n  if(disable_purge) enablePurge(false /* on hosts */);\n\n  return rc;\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getHostsHashSize() {\n  if(!isView())\n    return(hosts_hash->getNumEntries());\n  else {\n    u_int32_t tot = 0;\n\n    for(u_int8_t s = 0; s<numSubInterfaces; s++)\n      tot += subInterfaces[s]->get_hosts_hash()->getNumEntries();\n\n    return(tot);\n  }\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getFlowsHashSize() {\n  if(!isView())\n    return(flows_hash->getNumEntries());\n  else {\n    u_int32_t tot = 0;\n\n    for(u_int8_t s = 0; s<numSubInterfaces; s++)\n      tot += subInterfaces[s]->get_flows_hash()->getNumEntries();\n\n    return(tot);\n  }\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getMacsHashSize() {\n  if(!isView())\n    return(macs_hash->getNumEntries());\n  else {\n    u_int32_t tot = 0;\n\n    for(u_int8_t s = 0; s<numSubInterfaces; s++)\n      tot += subInterfaces[s]->get_macs_hash()->getNumEntries();\n\n    return(tot);\n  }\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::walker(WalkerType wtype,\n\t\t\t      bool (*walker)(GenericHashEntry *h, void *user_data),\n\t\t\t      void *user_data) {\n  bool ret = false;\n\n  switch(wtype) {\n  case walker_hosts:\n    if(!isView())\n      ret = hosts_hash->walk(walker, user_data);\n    else {\n      for(u_int8_t s = 0; s<numSubInterfaces; s++)\n\tret |= subInterfaces[s]->get_hosts_hash()->walk(walker, user_data);\n    }\n    break;\n\n  case walker_flows:\n    if(!isView())\n      ret = flows_hash->walk(walker, user_data);\n    else {\n      for(u_int8_t s = 0; s<numSubInterfaces; s++)\n\tret |= subInterfaces[s]->get_flows_hash()->walk(walker, user_data);\n    }\n    break;\n\n  case walker_macs:\n    if(!isView())\n      ret = macs_hash->walk(walker, user_data);\n    else {\n      for(u_int8_t s = 0; s<numSubInterfaces; s++)\n\tret |= subInterfaces[s]->get_macs_hash()->walk(walker, user_data);\n    }\n\n    break;\n  }\n\n  return(ret);\n}\n\n/* **************************************************** */\n\nFlow* NetworkInterface::getFlow(u_int8_t *src_eth, u_int8_t *dst_eth,\n\t\t\t\tu_int16_t vlan_id,\n\t\t\t\tu_int32_t deviceIP, u_int16_t inIndex, u_int16_t outIndex,\n  \t\t\t\tIpAddress *src_ip, IpAddress *dst_ip,\n  \t\t\t\tu_int16_t src_port, u_int16_t dst_port,\n\t\t\t\tu_int8_t l4_proto,\n\t\t\t\tbool *src2dst_direction,\n\t\t\t\ttime_t first_seen, time_t last_seen,\n\t\t\t\tbool *new_flow) {\n  Flow *ret;\n\n  if(vlan_id != 0) setSeenVlanTaggedPackets();\n\n  ret = flows_hash->find(src_ip, dst_ip, src_port, dst_port,\n\t\t\t vlan_id, l4_proto, src2dst_direction);\n\n  if(ret == NULL) {\n    *new_flow = true;\n\n    try {\n      ret = new Flow(this, vlan_id, l4_proto,\n\t\t     src_eth, src_ip, src_port,\n\t\t     dst_eth, dst_ip, dst_port,\n\t\t     first_seen, last_seen);\n    } catch(std::bad_alloc& ba) {\n      static bool oom_warning_sent = false;\n\n      if(!oom_warning_sent) {\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\toom_warning_sent = true;\n      }\n\n      triggerTooManyFlowsAlert();\n      return(NULL);\n    }\n\n    if(flows_hash->add(ret)) {\n      *src2dst_direction = true;\n      if(inIndex && ret->get_cli_host()) {\n\t  Host *host = (Host*)ret->get_cli_host();\n\n\t  if(host->isLocalHost() || host->isSystemHost())\n\t      ret->get_cli_host()->setDeviceIfIdx(deviceIP, inIndex);\n      }\n\n      /*\n\tWe have decided to set only ingress traffic to make sure we do not mix truth with invalid data\n\tif(outIndex && ret->get_srv_host()) ret->get_srv_host()->setDeviceIfIdx(deviceIP, outIndex);\n      */\n      return(ret);\n    } else {\n      delete ret;\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many flows\");\n      return(NULL);\n    }\n  } else {\n    *new_flow = false;\n    return(ret);\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::triggerTooManyFlowsAlert() {\n  if(!tooManyFlowsAlertTriggered) {\n    char alert_msg[512];\n\n    snprintf(alert_msg, sizeof(alert_msg),\n\t     \"Interface <A HREF='%s/lua/if_stats.lua?ifid=%d'>%s</A> has too many flows. Please extend the --max-num-flows/-X command line option\",\n\t     ntop->getPrefs()->get_http_prefix(),\n\t     id, get_name());\n\n    alertsManager->engageInterfaceAlert(this,\n\t\t\t\t\t(char*)\"app_misconfiguration\",\n\t\t\t\t\talert_app_misconfiguration, alert_level_error, alert_msg);\n    tooManyFlowsAlertTriggered = true;\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::triggerTooManyHostsAlert() {\n  if(!tooManyHostsAlertTriggered) {\n    char alert_msg[512];\n\n    snprintf(alert_msg, sizeof(alert_msg),\n\t     \"Interface <A HREF='%s/lua/if_stats.lua?ifid=%d'>%s</A> has too many hosts. Please extend the --max-num-hosts/-x command line option\",\n\t     ntop->getPrefs()->get_http_prefix(),\n\t     id, get_name());\n\n    alertsManager->releaseInterfaceAlert(this,\n\t\t\t\t\t (char*)\"app_misconfiguration\",\n\t\t\t\t\t alert_app_misconfiguration, alert_level_error, alert_msg);\n    tooManyHostsAlertTriggered = true;\n  }\n}\n\n/* **************************************************** */\n\nNetworkInterface* NetworkInterface::getSubInterface(u_int32_t criteria) {\n  FlowHashing *h = NULL;\n\n  HASH_FIND_INT(flowHashing, &criteria, h);\n\n  if(h == NULL) {\n    /* Interface not found */\n\n    if(numVirtualInterfaces < MAX_NUM_VIRTUAL_INTERFACES) {\n      if((h = (FlowHashing*)malloc(sizeof(FlowHashing))) != NULL) {\n\tchar buf[64], buf1[48];\n\tconst char *vIface_type;\n\n\th->criteria = criteria;\n\n\tswitch(flowHashingMode) {\n\tcase flowhashing_vlan:\n\t  vIface_type = CONST_INTERFACE_TYPE_VLAN;\n\t  snprintf(buf, sizeof(buf), \"%s [vlanId: %u]\", ifname, criteria);\n\t  break;\n\n\tcase flowhashing_probe_ip:\n\t  vIface_type = CONST_INTERFACE_TYPE_FLOW;\n\t  snprintf(buf, sizeof(buf), \"%s [probeIP: %s]\", ifname,\n\t\t   Utils::intoaV4(criteria, buf1, sizeof(buf1)));\n\t  break;\n\n\tcase flowhashing_ingress_iface_idx:\n\t  vIface_type = CONST_INTERFACE_TYPE_FLOW;\n\t  snprintf(buf, sizeof(buf), \"%s [ifIdx: %u]\", ifname, criteria);\n\t  break;\n\n\tdefault:\n\t  free(h);\n\t  return(NULL);\n\t  break;\n\t}\n\n\tif((h->iface = new NetworkInterface(buf, vIface_type)) != NULL) {\n\t  HASH_ADD_INT(flowHashing, criteria, h);\n\t  ntop->registerInterface(h->iface);\n\t  numVirtualInterfaces++;\n\t}\n      } else\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n    }\n  }\n\n  if(h) return(h->iface);\n\n  return(NULL);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::processFlow(ZMQ_Flow *zflow) {\n  bool src2dst_direction, new_flow;\n  Flow *flow;\n  ndpi_protocol p;\n  time_t now = time(NULL);\n\n  if(flowHashingMode != flowhashing_none) {\n    NetworkInterface *vIface;\n\n    switch(flowHashingMode) {\n    case flowhashing_probe_ip:\n      vIface = getSubInterface((u_int32_t)zflow->deviceIP);\n      break;\n\n    case flowhashing_ingress_iface_idx:\n      vIface = getSubInterface((u_int32_t)zflow->inIndex);\n      break;\n\n    default:\n      vIface = NULL;\n      break;\n    }\n\n    if(vIface) {\n      vIface->setTimeLastPktRcvd(getTimeLastPktRcvd());\n      vIface->processFlow(zflow);\n      return;\n    }\n  }\n\n  if(last_pkt_rcvd_remote > 0) {\n    int drift = now - last_pkt_rcvd_remote;\n\n    if(drift >= 0)\n      zflow->last_switched += drift, zflow->first_switched += drift;\n    else {\n      u_int32_t d = (u_int32_t)-drift;\n\n      if(d < zflow->last_switched)  zflow->last_switched  += drift;\n      if(d < zflow->first_switched) zflow->first_switched += drift;\n    }\n\n#ifdef DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"[first=%u][last=%u][duration: %u][drift: %d][now: %u][remote: %u]\",\n\t\t\t\t zflow->first_switched,  zflow->last_switched,\n\t\t\t\t zflow->last_switched-zflow->first_switched, drift,\n\t\t\t\t now, last_pkt_rcvd_remote);\n#endif\n  } else {\n    /* Old nProbe */\n\n    if((time_t)zflow->last_switched > (time_t)last_pkt_rcvd_remote)\n      last_pkt_rcvd_remote = zflow->last_switched;\n\n#ifdef DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[first=%u][last=%u][duration: %u]\",\n\t\t\t\t zflow->first_switched,  zflow->last_switched,\n\t\t\t\t zflow->last_switched- zflow->first_switched);\n#endif\n  }\n\n  /* Updating Flow */\n  flow = getFlow((u_int8_t*)zflow->src_mac, (u_int8_t*)zflow->dst_mac, zflow->vlan_id,\n\t\t zflow->deviceIP, zflow->inIndex, zflow->outIndex,\n\t\t &zflow->src_ip, &zflow->dst_ip,\n\t\t zflow->src_port, zflow->dst_port,\n\t\t zflow->l4_proto, &src2dst_direction,\n\t\t zflow->first_switched,\n\t\t zflow->last_switched, &new_flow);\n\n  incStats(now, zflow->src_ip.isIPv4() ? ETHERTYPE_IP : ETHERTYPE_IPV6,\n\t   flow ? flow->get_detected_protocol().protocol : NDPI_PROTOCOL_UNKNOWN,\n\t   zflow->pkt_sampling_rate*(zflow->in_bytes + zflow->out_bytes),\n\t   zflow->pkt_sampling_rate*(zflow->in_pkts + zflow->out_pkts),\n\t   24 /* 8 Preamble + 4 CRC + 12 IFG */ + 14 /* Ethernet header */);\n\n  if(flow == NULL)\n    return;\n\n  if(zflow->l4_proto == IPPROTO_TCP) {\n    struct timeval when;\n\n    when.tv_sec = (long)now, when.tv_usec = 0;\n    flow->updateTcpFlags((const struct bpf_timeval*)&when,\n\t\t\t zflow->tcp_flags, src2dst_direction);\n    flow->incTcpBadStats(true,\n       zflow->tcp.ooo_in_pkts, zflow->tcp.retr_in_pkts, zflow->tcp.lost_in_pkts);\n    flow->incTcpBadStats(false,\n       zflow->tcp.ooo_out_pkts, zflow->tcp.retr_out_pkts, zflow->tcp.lost_out_pkts);\n  }\n\n  flow->addFlowStats(src2dst_direction,\n\t\t     zflow->pkt_sampling_rate*zflow->in_pkts,\n\t\t     zflow->pkt_sampling_rate*zflow->in_bytes, 0,\n\t\t     zflow->pkt_sampling_rate*zflow->out_pkts,\n\t\t     zflow->pkt_sampling_rate*zflow->out_bytes, 0,\n\t\t     zflow->last_switched);\n  p.protocol = zflow->l7_proto, p.master_protocol = NDPI_PROTOCOL_UNKNOWN;\n  flow->setDetectedProtocol(p, true);\n  flow->setJSONInfo(json_object_to_json_string(zflow->additional_fields));\n  flow->updateActivities();\n\n  flow->updateInterfaceLocalStats(src2dst_direction,\n\t\t\t\t  zflow->pkt_sampling_rate*(zflow->in_pkts+zflow->out_pkts),\n\t\t\t\t  zflow->pkt_sampling_rate*(zflow->in_bytes+zflow->out_bytes));\n\n  if(zflow->src_process.pid || zflow->dst_process.pid) {\n    if(zflow->src_process.pid) flow->handle_process(&zflow->src_process, src2dst_direction ? true : false);\n    if(zflow->dst_process.pid) flow->handle_process(&zflow->dst_process, src2dst_direction ? false : true);\n\n    if(zflow->l7_proto == NDPI_PROTOCOL_UNKNOWN)\n      flow->guessProtocol();\n  }\n\n  if(zflow->dns_query) flow->setDNSQuery(zflow->dns_query);\n  if(zflow->http_url)  flow->setHTTPURL(zflow->http_url);\n  if(zflow->http_site) flow->setServerName(zflow->http_site);\n  if(zflow->ssl_server_name) flow->setServerName(zflow->ssl_server_name);\n  if(zflow->bittorrent_hash) flow->setBTHash(zflow->bittorrent_hash);\n\n  /* purge is actually performed at most one time every FLOW_PURGE_FREQUENCY */\n  // purgeIdle(zflow->last_switched);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::dumpPacketDisk(const struct pcap_pkthdr *h, const u_char *packet,\n                                      dump_reason reason) {\n  if(pkt_dumper == NULL)\n    pkt_dumper = new PacketDumper(this);\n  if(pkt_dumper)\n    pkt_dumper->dumpPacket(h, packet, reason, getDumpTrafficSamplingRate(),\n                           getDumpTrafficMaxPktsPerFile(),\n                           getDumpTrafficMaxSecPerFile());\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::dumpPacketTap(const struct pcap_pkthdr *h, const u_char *packet,\n                                     dump_reason reason) {\n  if(pkt_dumper_tap)\n    pkt_dumper_tap->writeTap((unsigned char *)packet, h->len, reason,\n                             getDumpTrafficSamplingRate());\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::processPacket(const struct bpf_timeval *when,\n\t\t\t\t     const u_int64_t time,\n\t\t\t\t     struct ndpi_ethhdr *eth,\n\t\t\t\t     u_int16_t vlan_id,\n\t\t\t\t     struct ndpi_iphdr *iph,\n\t\t\t\t     struct ndpi_ipv6hdr *ip6,\n\t\t\t\t     u_int16_t ipsize,\n\t\t\t\t     u_int32_t rawsize,\n\t\t\t\t     const struct pcap_pkthdr *h,\n\t\t\t\t     const u_char *packet,\n\t\t\t\t     u_int16_t *ndpiProtocol,\n\t\t\t\t     Host **srcHost, Host **dstHost,\n\t\t\t\t     Flow **hostFlow) {\n  bool src2dst_direction;\n  u_int8_t l4_proto;\n  Flow *flow;\n  u_int8_t *eth_src = eth->h_source, *eth_dst = eth->h_dest;\n  IpAddress src_ip, dst_ip;\n  u_int16_t src_port = 0, dst_port = 0, payload_len = 0;\n  struct ndpi_tcphdr *tcph = NULL;\n  struct ndpi_udphdr *udph = NULL;\n  u_int16_t l4_packet_len;\n  u_int8_t *l4, tcp_flags = 0, *payload = NULL;\n  u_int8_t *ip;\n  bool is_fragment = false, new_flow;\n  bool pass_verdict = true;\n\n  /* VLAN disaggregation */\n  if((flowHashingMode == flowhashing_vlan) && (vlan_id > 0)) {\n    NetworkInterface *vIface;\n\n    if((vIface = getSubInterface((u_int32_t)vlan_id)) != NULL) {\n      vIface->setTimeLastPktRcvd(getTimeLastPktRcvd());\n      return(vIface->processPacket(when, time, eth, vlan_id,\n\t\t\t\t   iph, ip6, ipsize, rawsize,\n\t\t\t\t   h, packet, ndpiProtocol,\n\t\t\t\t   srcHost, dstHost, hostFlow));\n    }\n  }\n\n decode_ip:\n  if(iph != NULL) {\n    /* IPv4 */\n    if(ipsize < 20) {\n      incStats(when->tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN,\n\t       rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n\n    if((iph->ihl * 4) > ipsize || ipsize < ntohs(iph->tot_len)\n       || (iph->frag_off & htons(0x1FFF /* IP_OFFSET */)) != 0) {\n      is_fragment = true;\n    }\n\n    l4_packet_len = ntohs(iph->tot_len) - (iph->ihl * 4);\n    l4_proto = iph->protocol;\n    l4 = ((u_int8_t *) iph + iph->ihl * 4);\n    ip = (u_int8_t*)iph;\n  } else {\n    /* IPv6 */\n    u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);\n\n    if(ipsize < sizeof(const struct ndpi_ipv6hdr)) {\n      incStats(when->tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize,\n\t       1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n\n    l4_packet_len = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);\n    l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;\n\n    if(l4_proto == 0x3C /* IPv6 destination option */) {\n      u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;\n\n      l4_proto = options[0];\n      ipv6_shift = 8 * (options[1] + 1);\n\n      if(ipsize < ipv6_shift) {\n\tincStats(when->tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\treturn(pass_verdict);\n      }\n    }\n\n    l4 = (u_int8_t*)ip6 + ipv6_shift;\n    ip = (u_int8_t*)ip6;\n  }\n\n  if(l4_proto == IPPROTO_TCP) {\n    if(l4_packet_len >= sizeof(struct ndpi_tcphdr)) {\n      u_int tcp_len;\n\n      /* TCP */\n      tcph = (struct ndpi_tcphdr *)l4;\n      src_port = tcph->source, dst_port = tcph->dest;\n      tcp_flags = l4[13];\n      tcp_len = min_val(4*tcph->doff, l4_packet_len);\n      payload = &l4[tcp_len];\n      payload_len = max_val(0, l4_packet_len-4*tcph->doff);\n      // TODO: check if payload should be set to NULL when payload_len == 0\n    } else {\n      /* Packet too short: this is a faked packet */\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Invalid TCP packet received [%u bytes long]\", l4_packet_len);\n      incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n  } else if(l4_proto == IPPROTO_UDP) {\n    if(l4_packet_len >= sizeof(struct ndpi_udphdr)) {\n      /* UDP */\n      udph = (struct ndpi_udphdr *)l4;\n      src_port = udph->source,  dst_port = udph->dest;\n      payload = &l4[sizeof(struct ndpi_udphdr)];\n      payload_len = max_val(0, l4_packet_len-sizeof(struct ndpi_udphdr));\n    } else {\n      /* Packet too short: this is a faked packet */\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Invalid UDP packet received [%u bytes long]\", l4_packet_len);\n      incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n  } else if(l4_proto == IPPROTO_GRE) {\n    struct grev1_header gre;\n    int offset = sizeof(struct grev1_header);\n\n    memcpy(&gre, l4, sizeof(struct grev1_header));\n    gre.flags_and_version = ntohs(gre.flags_and_version);\n    gre.proto = ntohs(gre.proto);\n\n    if(gre.flags_and_version & (GRE_HEADER_CHECKSUM | GRE_HEADER_ROUTING)) offset += 4;\n    if(gre.flags_and_version & GRE_HEADER_KEY)      offset += 4;\n    if(gre.flags_and_version & GRE_HEADER_SEQ_NUM)  offset += 4;\n\n    if(gre.proto == ETHERTYPE_IP) {\n      iph = (struct ndpi_iphdr*)(l4 + offset), ip6 = NULL;\n      goto decode_ip;\n    } else if(gre.proto == ETHERTYPE_IPV6) {\n      iph = (struct ndpi_iphdr*)(l4 + offset), ip6 = NULL;\n      goto decode_ip;\n    } else {\n      /* Unknown encapsulation */\n    }\n  } else {\n    /* non TCP/UDP protocols */\n  }\n\n  if(iph != NULL)\n    src_ip.set(iph->saddr), dst_ip.set(iph->daddr);\n  else\n    src_ip.set(&ip6->ip6_src), dst_ip.set(&ip6->ip6_dst);\n\n#if defined(WIN32) && defined(DEMO_WIN32)\n  if(this->ethStats.getNumPackets() > MAX_NUM_PACKETS) {\n    static bool showMsg = false;\n\n    if(!showMsg) {\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"-----------------------------------------------------------\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"WARNING: this demo application is a limited ntopng version able to\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"capture up to %d packets. If you are interested\", MAX_NUM_PACKETS);\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"in the full version please have a look at the ntop\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"home page http://www.ntop.org/.\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"-----------------------------------------------------------\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"\");\n      showMsg = true;\n    }\n\n    return(pass_verdict);\n  }\n#endif\n\n  /* Updating Flow */\n  flow = getFlow(eth_src, eth_dst, vlan_id, 0, 0, 0, &src_ip, &dst_ip, src_port, dst_port,\n\t\t l4_proto, &src2dst_direction, last_pkt_rcvd, last_pkt_rcvd, &new_flow);\n\n  if(flow == NULL) {\n    incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN,\n\t     rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n    return(pass_verdict);\n  } else {\n    *srcHost = src2dst_direction ? flow->get_cli_host() : flow->get_srv_host();\n    *dstHost = src2dst_direction ? flow->get_srv_host() : flow->get_cli_host();\n    *hostFlow = flow;\n\n    switch(l4_proto) {\n    case IPPROTO_TCP:\n      flow->updateTcpFlags(when, tcp_flags, src2dst_direction);\n      flow->updateTcpSeqNum(when, ntohl(tcph->seq), ntohl(tcph->ack_seq), ntohs(tcph->window),\n\t\t\t    tcp_flags, l4_packet_len - (4 * tcph->doff),\n\t\t\t    src2dst_direction);\n      break;\n\n    case IPPROTO_ICMP:\n    case IPPROTO_ICMPV6:\n      if(l4_packet_len > 2) {\n        u_int8_t icmp_type = l4[0];\n        u_int8_t icmp_code = l4[1];\n\n        if((flow->get_cli_host()->isLocalHost()) && (flow->get_srv_host()->isLocalHost())) {\n          /* Set correct direction in localhost ping */\n          if((icmp_type == 8) ||                  /* ICMP Echo [RFC792] */\n            (icmp_type == 128))                   /* ICMPV6 Echo Request [RFC4443] */\n            src2dst_direction = true;\n          else if((icmp_type == 0) ||             /* ICMP Echo Reply [RFC792] */\n            (icmp_type == 129))                   /* ICMPV6 Echo Reply [RFC4443] */\n            src2dst_direction = false;\n        }\n\n        flow->setICMP(icmp_type, icmp_code);\n      }\n      break;\n    }\n\n#ifdef __OpenBSD__\n    struct timeval tv_ts;\n    tv_ts.tv_sec  = h->ts.tv_sec;\n    tv_ts.tv_usec = h->ts.tv_usec;\n    flow->incStats(src2dst_direction, rawsize, payload, payload_len, l4_proto, &tv_ts);\n#else\n    flow->incStats(src2dst_direction, rawsize, payload, payload_len, l4_proto, &h->ts);\n#endif\n  }\n\n  /* Protocol Detection */\n  flow->updateActivities();\n  flow->updateInterfaceLocalStats(src2dst_direction, 1, rawsize);\n\n  if(!flow->isDetectionCompleted()) {\n    if(isSampledTraffic())\n      flow->guessProtocol();\n    else {\n      if(!is_fragment) {\n\tstruct ndpi_flow_struct *ndpi_flow = flow->get_ndpi_flow();\n\tstruct ndpi_id_struct *cli = (struct ndpi_id_struct*)flow->get_cli_id();\n\tstruct ndpi_id_struct *srv = (struct ndpi_id_struct*)flow->get_srv_id();\n\n\tif(flow->get_packets() >= NDPI_MIN_NUM_PACKETS)\n\t  flow->setDetectedProtocol(ndpi_detection_giveup(ndpi_struct, ndpi_flow), false);\n\telse\n\t  flow->setDetectedProtocol(ndpi_detection_process_packet(ndpi_struct, ndpi_flow,\n\t\t\t\t\t\t\t\t  ip, ipsize, (u_int32_t)time,\n\t\t\t\t\t\t\t\t  cli, srv), false);\n      } else {\n\t// FIX - only handle unfragmented packets\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"IP fragments are not handled yet!\");\n      }\n    }\n  }\n\n  if(flow->isDetectionCompleted()\n     && (!isSampledTraffic())\n     && flow->get_cli_host()\n     && flow->get_srv_host()) {\n    struct ndpi_flow_struct *ndpi_flow;\n\n    switch(ndpi_get_lower_proto(flow->get_detected_protocol())) {\n    case NDPI_PROTOCOL_DHCP:\n      if(payload_len > 240) {\n\tfor(int i = 240; i<payload_len; ) {\n\t  u_int8_t id  = payload[i], len = payload[i+1];\n\n\t  if(len == 0) break;\n\n\t  if(id == 12 /* Host Name */) {\n\t    char name[64], buf[24], *client_mac, key[64];\n\t    int j;\n\n\t    j = ndpi_min(len, sizeof(name)-1);\n\t    strncpy((char*)name, (char*)&payload[i+2], j);\n\t    name[j] = '\\0';\n\n\t    client_mac = Utils::formatMac(&payload[28], buf, sizeof(buf)),\n\t    ntop->getTrace()->traceEvent(TRACE_INFO, \"[DHCP] %s = '%s'\", client_mac, name);\n\n\t    snprintf(key, sizeof(key), DHCP_CACHE, get_id());\n\t    ntop->getRedis()->hashSet(key, client_mac, name);\n\t    break;\n\t  } else if(id == 0xFF)\n\t    break; /* End of options */\n\n\t  i += len + 2;\n\t}\n      }\n      break;\n\n    case NDPI_PROTOCOL_BITTORRENT:\n      if((flow->getBitTorrentHash() == NULL)\n\t && (l4_proto == IPPROTO_UDP)\n\t && (flow->get_packets() < 8))\n\tflow->dissectBittorrent((char*)payload, payload_len);\n      break;\n\n    case NDPI_PROTOCOL_HTTP:\n      if(payload_len > 0)\n\tflow->dissectHTTP(src2dst_direction, (char*)payload, payload_len);\n      break;\n\n    case NDPI_PROTOCOL_DNS:\n      ndpi_flow = flow->get_ndpi_flow();\n\n      /*\n      DNS-over-TCP flows may carry zero-payload TCP segments\n      e.g., during three-way-handshake, or when acknowledging.\n      Make sure only non-zero-payload segments are processed.\n      */\n      if((payload_len > 0) && payload) {\n\t/*\n\tDNS-over-TCP has a 2-bytes field with DNS payload length\n\tat the beginning. See RFC1035 section 4.2.2. TCP usage.\n\t*/\n\tu_int8_t dns_offset = l4_proto == IPPROTO_TCP && payload_len > 1 ? 2 : 0;\n\n\tstruct ndpi_dns_packet_header *header = (struct ndpi_dns_packet_header*)(payload + dns_offset);\n\tu_int16_t dns_flags = ntohs(header->flags);\n\tbool is_query   = ((dns_flags & 0x8000) == 0x8000) ? false : true;\n\n\tif(flow->get_cli_host() && flow->get_srv_host()) {\n\t  Host *client = src2dst_direction ? flow->get_cli_host() : flow->get_srv_host();\n\t  Host *server = src2dst_direction ? flow->get_srv_host() : flow->get_cli_host();\n\n\t  /*\n\t    Inside the DNS packet it is possible to have multiple queries\n\t    and mix query types. In general this is not a practice followed\n\t    by applications.\n\t  */\n\n\t  if(is_query) {\n\t    u_int16_t query_type = ndpi_flow ? ndpi_flow->protos.dns.query_type : 0;\n\n\t    client->incNumDNSQueriesSent(query_type), server->incNumDNSQueriesRcvd(query_type);\n\t  } else {\n\t    u_int8_t ret_code = (dns_flags & 0x000F);\n\n\t    client->incNumDNSResponsesSent(ret_code), server->incNumDNSResponsesRcvd(ret_code);\n\t  }\n\t}\n      }\n\n      if(ndpi_flow) {\n\tstruct ndpi_id_struct *cli = (struct ndpi_id_struct*)flow->get_cli_id();\n\tstruct ndpi_id_struct *srv = (struct ndpi_id_struct*)flow->get_srv_id();\n\n\tmemset(&ndpi_flow->detected_protocol_stack,\n\t       0, sizeof(ndpi_flow->detected_protocol_stack));\n\n\tndpi_detection_process_packet(ndpi_struct, ndpi_flow,\n\t\t\t\t      ip, ipsize, (u_int32_t)time,\n\t\t\t\t      src2dst_direction ? cli : srv,\n\t\t\t\t      src2dst_direction ? srv : cli);\n\n\t/*\n\t  We reset the nDPI flow so that it can decode new packets\n\t  of the same flow (e.g. the DNS response)\n\t*/\n\tndpi_flow->detected_protocol_stack[0] = NDPI_PROTOCOL_UNKNOWN;\n      }\n      break;\n\n    default:\n      if(flow->isSSLProto())\n        flow->dissectSSL(payload, payload_len, when, src2dst_direction);\n    }\n\n    flow->processDetectedProtocol();\n\n#ifdef NTOPNG_PRO\n    if(is_bridge_interface()) {\n\tpass_verdict = flow->isPassVerdict();\n\n\tif(pass_verdict) {\n\t    u_int8_t shaper_ingress, shaper_engress;\n\t    char buf[64];\n\n\t    flow->getFlowShapers(src2dst_direction, &shaper_ingress, &shaper_engress);\n\t    ntop->getTrace()->traceEvent(TRACE_DEBUG, \"[%s] %u / %u \",\n\t\t\t\t\t flow->get_detected_protocol_name(buf, sizeof(buf)),\n\t\t\t\t\t shaper_ingress, shaper_engress);\n\t    pass_verdict = passShaperPacket(shaper_ingress, shaper_engress, (struct pcap_pkthdr*)h);\n\t}\n    }\n#endif\n\n    bool dump_if_unknown = dump_unknown_traffic\n      && (!flow->isDetectionCompleted() ||\n\t  flow->get_detected_protocol().protocol == NDPI_PROTOCOL_UNKNOWN);\n\n    if(dump_if_unknown\n       || dump_all_traffic\n       || dump_security_packets\n       || flow->dumpFlowTraffic()) {\n      if(dump_to_disk) dumpPacketDisk(h, packet, dump_if_unknown ? UNKNOWN : GUI);\n      if(dump_to_tap)  dumpPacketTap(h, packet, GUI);\n    }\n  }\n\n  incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6,\n\t   flow->get_detected_protocol().protocol,\n\t   rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\n  // Detect user activities\n  if((!isSampledTraffic())\n      && (ntop->getPrefs()->is_flow_activity_enabled())) {\n    Host *cli = flow->get_cli_host();\n    Host *srv = flow->get_srv_host();\n\n    if((cli->isLocalHost() || srv->isLocalHost())\n       && (!flow->isSSLProto() || flow->isSSLData())) {\n      UserActivityID activity;\n      u_int64_t up = 0, down = 0, backgr = 0, bytes = payload_len;\n\n      if(flow->getActivityId(&activity)) {\n#ifdef __OpenBSD__\n        struct timeval* tv_when;\n        tv_when->tv_sec  = when->tv_sec;\n        tv_when->tv_usec = when->tv_usec;\n        if(flow->invokeActivityFilter(tv_when, src2dst_direction, payload_len)) {\n#else \n        if(flow->invokeActivityFilter(when, src2dst_direction, payload_len)) {\n#endif\n          if(src2dst_direction)\n            up = bytes;\n          else\n            down = bytes;\n        } else {\n          backgr = bytes;\n        }\n\n        if(cli->isLocalHost())\n          cli->incActivityBytes(activity, up, down, backgr);\n\n        if(srv->isLocalHost())\n          srv->incActivityBytes(activity, down, up, backgr);\n      }\n    }\n  }\n\n  return(pass_verdict);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::purgeIdle(time_t when) {\n  if(purge_idle_flows_hosts) {\n    u_int n;\n\n    last_pkt_rcvd = when;\n\n    if((n = purgeIdleFlows()) > 0)\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle flows on %s\",\n\t\t\t\t   n, getNumFlows(), ifname);\n\n    if((n = purgeIdleHostsMacs()) > 0)\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle hosts/macs on %s\",\n\t\t\t\t   n, getNumHosts()+getNumMacs(), ifname);\n  }\n\n  if(pkt_dumper) pkt_dumper->idle(when);\n  updateSecondTraffic(when);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::dissectPacket(const struct pcap_pkthdr *h,\n\t\t\t\t     const u_char *packet,\n\t\t\t\t     u_int16_t *ndpiProtocol,\n\t\t\t\t     Host **srcHost, Host **dstHost,\n\t\t\t\t     Flow **flow) {\n  struct ndpi_ethhdr *ethernet, dummy_ethernet;\n  u_int64_t time;\n  u_int16_t eth_type, ip_offset, vlan_id = 0, eth_offset = 0;\n  u_int32_t null_type;\n  int pcap_datalink_type = get_datalink();\n  bool pass_verdict = true;\n  u_int32_t rawsize = h->len * scalingFactor;\n\n  if(h->len > ifMTU) {\n    if(!mtuWarningShown) {\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Invalid packet received [len: %u][max-len: %u].\", h->len, ifMTU);\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"If you have TSO/GRO enabled, please disable it\");\n#ifdef linux\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Use sudo ethtool -K %s gro off gso off tso off\", ifname);\n#endif\n      mtuWarningShown = true;\n    }\n  }\n\n  setTimeLastPktRcvd(h->ts.tv_sec);\n\n  time = ((uint64_t) h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;\n\n datalink_check:\n  if(pcap_datalink_type == DLT_NULL) {\n    memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));\n\n    switch(null_type) {\n    case BSD_AF_INET:\n      eth_type = ETHERTYPE_IP;\n      break;\n    case BSD_AF_INET6_BSD:\n    case BSD_AF_INET6_FREEBSD:\n    case BSD_AF_INET6_DARWIN:\n      eth_type = ETHERTYPE_IPV6;\n      break;\n    default:\n      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict); /* Any other non IP protocol */\n    }\n\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    ip_offset = 4 + eth_offset;\n  } else if(pcap_datalink_type == DLT_EN10MB) {\n    ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];\n    ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;\n    eth_type = ntohs(ethernet->h_proto);\n  } else if(pcap_datalink_type == 113 /* Linux Cooked Capture */) {\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    eth_type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];\n    ip_offset = 16 + eth_offset;\n    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n#ifdef DLT_RAW\n  } else if(pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */) {\n    switch((packet[eth_offset] & 0xf0) >> 4) {\n    case 4:\n      eth_type = ETHERTYPE_IP;\n      break;\n    case 6:\n      eth_type = ETHERTYPE_IPV6;\n      break;\n    default:\n      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict); /* Unknown IP protocol version */\n    }\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    ip_offset = eth_offset;\n#endif /* DLT_RAW */\n  } else if(pcap_datalink_type == DLT_IPV4) {\n    eth_type = ETHERTYPE_IP;\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    ip_offset = 0;\n  } else {\n    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n    return(pass_verdict);\n  }\n\n  while(true) {\n    if(eth_type == 0x8100 /* VLAN */) {\n      Ether80211q *qType = (Ether80211q*)&packet[ip_offset];\n\n      vlan_id = ntohs(qType->vlanId) & 0xFFF;\n      eth_type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];\n      ip_offset += 4;\n    } else if(eth_type == 0x8847 /* MPLS */) {\n      u_int8_t bos; /* bottom_of_stack */\n\n      bos = (((u_int8_t)packet[ip_offset+2]) & 0x1), ip_offset += 4;\n      if(bos) {\n\teth_type = ETHERTYPE_IP;\n\tbreak;\n      }\n    } else\n      break;\n  }\n\n decode_packet_eth:\n  switch(eth_type) {\n  case ETHERTYPE_PPOE:\n    eth_type = ETHERTYPE_IP;\n    ip_offset += 8;\n    goto decode_packet_eth;\n    break;\n\n  case ETHERTYPE_IP:\n    if(h->caplen >= ip_offset) {\n      u_int16_t frag_off;\n      struct ndpi_iphdr *iph = (struct ndpi_iphdr *) &packet[ip_offset];\n      struct ndpi_ipv6hdr *ip6 = NULL;\n\n      if(iph->version != 4) {\n\t/* This is not IPv4 */\n\tincStats(h->ts.tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\treturn(pass_verdict);\n      } else\n\tfrag_off = ntohs(iph->frag_off);\n\n      if(ntop->getGlobals()->decode_tunnels() && (iph->protocol == IPPROTO_UDP)\n\t && ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */ ) == 0)) {\n\tu_short ip_len = ((u_short)iph->ihl * 4);\n\tstruct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];\n\tu_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);\n\n\tif((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {\n\t  /* Check if it's GTPv1 */\n\t  u_int offset = (u_int)(ip_offset+ip_len+sizeof(struct ndpi_udphdr));\n\t  u_int8_t flags = packet[offset];\n\t  u_int8_t message_type = packet[offset+1];\n\n\t  if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) && (message_type == 0xFF /* T-PDU */)) {\n\t    ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8 /* GTPv1 header len */;\n\n\t    if(flags & 0x04) ip_offset += 1; /* next_ext_header is present */\n\t    if(flags & 0x02) ip_offset += 4; /* sequence_number is present (it also includes next_ext_header and pdu_number) */\n\t    if(flags & 0x01) ip_offset += 1; /* pdu_number is present */\n\n\t    iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\n\t    if(iph->version != 4) {\n\t      /* FIX - Add IPv6 support */\n\t      incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t      return(pass_verdict);\n\t    }\n\t  }\n\t} else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {\n\t  /* https://en.wikipedia.org/wiki/TZSP */\n\t  u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\t  u_int8_t version = packet[offset];\n\t  u_int8_t type    = packet[offset+1];\n\t  u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));\n\n\t  if((version == 1) && (type == 0) && (encapsulates == 1)) {\n\t    u_int8_t stop = 0;\n\n\t    offset += 4;\n\n\t    while((!stop) && (offset < h->caplen)) {\n\t      u_int8_t tag_type = packet[offset];\n\t      u_int8_t tag_len;\n\n\t      switch(tag_type) {\n\t      case 0: /* PADDING Tag */\n\t\ttag_len = 1;\n\t\tbreak;\n\t      case 1: /* END Tag */\n\t\ttag_len = 1, stop = 1;\n\t\tbreak;\n\t      default:\n\t\ttag_len = packet[offset+1];\n\t\tbreak;\n\t      }\n\n\t      offset += tag_len;\n\n\t      if(offset >= h->caplen) {\n\t\tincStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t\treturn(pass_verdict);\n\t      } else {\n\t\teth_offset = offset;\n\t\tgoto datalink_check;\n\t      }\n\t    }\n\t  }\n\t}\n\n\tif((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {\n\t  /*\n\t    Control And Provisioning of Wireless Access Points\n\n\t    https://www.rfc-editor.org/rfc/rfc5415.txt\n\n\t    CAPWAP Header          - variable length (5 MSB of byte 2 of header)\n\t    IEEE 802.11 Data Flags - 24 bytes\n\t    Logical-Link Control   - 8  bytes\n\n\t    Total = CAPWAP_header_length + 24 + 8\n\t  */\n\t  u_short eth_type;\n\t  ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\t  u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;\n\t  ip_offset = ip_offset+capwap_header_len+24+8;\n\n\t  if(ip_offset >= h->len) {\n\t    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t    return(pass_verdict);\n\t  }\n\t  eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);\n\n\t  switch(eth_type) {\n\t  case ETHERTYPE_IP:\n\t    iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\t    break;\n\t  case ETHERTYPE_IPV6:\n\t    iph = NULL;\n\t    ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];\n\t    break;\n\t  default:\n\t    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t    return(pass_verdict);\n\t  }\n\t}\n      }\n\n      if((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())\n\tvlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;\n\n      try {\n\tpass_verdict = processPacket(&h->ts, time, ethernet, vlan_id, iph,\n\t\t\t\t     ip6, h->caplen - ip_offset, rawsize,\n\t\t\t\t     h, packet, ndpiProtocol, srcHost, dstHost, flow);\n      } catch(std::bad_alloc& ba) {\n\tstatic bool oom_warning_sent = false;\n\n\tif(!oom_warning_sent) {\n\t  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t  oom_warning_sent = true;\n\t}\n      }\n    }\n    break;\n\n  case ETHERTYPE_IPV6:\n    if(h->caplen >= ip_offset) {\n      struct ndpi_iphdr *iph = NULL;\n      struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];\n\n      if((ntohl(ip6->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0xF0000000) != 0x60000000) {\n\t/* This is not IPv6 */\n\tincStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\treturn(pass_verdict);\n      } else {\n\tu_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);\n\tu_int8_t l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;\n\n\tif(l4_proto == 0x3C /* IPv6 destination option */) {\n\t  u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;\n\t  l4_proto = options[0];\n\t  ipv6_shift = 8 * (options[1] + 1);\n\t}\n\n\tif(ntop->getGlobals()->decode_tunnels() && (l4_proto == IPPROTO_UDP)) {\n\t  ip_offset += ipv6_shift;\n\t  if(ip_offset >= h->len) {\n\t    incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t    return(pass_verdict);\n\t  }\n\n\t  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];\n\t  u_int16_t sport = udp->source,  dport = udp->dest;\n\n\t  if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {\n\t    /*\n\t      Control And Provisioning of Wireless Access Points\n\n\t      https://www.rfc-editor.org/rfc/rfc5415.txt\n\n\t      CAPWAP Header          - variable length (5 MSB of byte 2 of header)\n\t      IEEE 802.11 Data Flags - 24 bytes\n\t      Logical-Link Control   - 8  bytes\n\n\t      Total = CAPWAP_header_length + 24 + 8\n\t    */\n\n\t    u_short eth_type;\n\t    ip_offset = ip_offset+sizeof(struct ndpi_udphdr);\n\t    u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;\n\t    ip_offset = ip_offset+capwap_header_len+24+8;\n\n\t    if(ip_offset >= h->len) {\n\t      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t      return(pass_verdict);\n\t    }\n\t    eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);\n\n\t    switch(eth_type) {\n\t    case ETHERTYPE_IP:\n\t      iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\t      ip6 = NULL;\n\t      break;\n\t    case ETHERTYPE_IPV6:\n\t      ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];\n\t      break;\n\t    default:\n\t      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t      return(pass_verdict);\n\t    }\n\t  }\n\t}\n\n\tif((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())\n\t  vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;\n\n\ttry {\n\t  pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id,\n\t\t\t\t       iph, ip6, h->len - ip_offset, rawsize,\n\t\t\t\t       h, packet, ndpiProtocol, srcHost, dstHost, flow);\n\t} catch(std::bad_alloc& ba) {\n\t  static bool oom_warning_sent = false;\n\n\t  if(!oom_warning_sent) {\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t    oom_warning_sent = true;\n\t  }\n\t}\n      }\n    }\n    break;\n\n  default: /* No IPv4 nor IPv6 */\n    Mac *srcMac = getMac(ethernet->h_source, vlan_id, true);\n    Mac *dstMac = getMac(ethernet->h_dest, vlan_id, true);\n\n    if(srcMac) srcMac->incSentStats(rawsize);\n    if(dstMac) dstMac->incRcvdStats(rawsize);\n\n    incStats(h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN, rawsize,\n\t     1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n    break;\n  }\n\n  purgeIdle(last_pkt_rcvd);\n\n  return(pass_verdict);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::startPacketPolling() {\n  if((cpu_affinity != -1) && (ntop->getNumCPUs() > 1)) {\n    if(Utils::setThreadAffinity(pollLoop, cpu_affinity))\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Could not set affinity of interface %s to core %d\",\n\t\t\t\t   get_name(), cpu_affinity);\n    else\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting affinity of interface %s to core %d\",\n\t\t\t\t   get_name(), cpu_affinity);\n  }\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t       \"Started packet polling on interface %s [id: %u]...\",\n\t\t\t       get_name(), get_id());\n  running = true;\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::shutdown() {\n  running = false;\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::cleanup() {\n  next_idle_flow_purge = next_idle_host_purge = 0;\n  cpu_affinity = -1, has_vlan_packets = false;\n  running = false, sprobe_interface = false, inline_interface = false;\n\n  getStats()->cleanup();\n\n  flows_hash->cleanup();\n  hosts_hash->cleanup();\n  macs_hash->cleanup();\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Cleanup interface %s\", get_name());\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::findFlowHosts(u_int16_t vlanId,\n\t\t\t\t     u_int8_t src_mac[6], IpAddress *_src_ip, Host **src,\n\t\t\t\t     u_int8_t dst_mac[6], IpAddress *_dst_ip, Host **dst) {\n\n  if(!isView())\n    (*src) = hosts_hash->get(vlanId, _src_ip);\n  else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if(((*src) = subInterfaces[s]->get_hosts_hash()->get(vlanId, _src_ip)) != NULL)\n\tbreak;\n    }\n  }\n\n  if((*src) == NULL) {\n    if(!hosts_hash->hasEmptyRoom()) {\n      *src = *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n\n    (*src) = new Host(this, src_mac, vlanId, _src_ip);\n    if(!hosts_hash->add(*src)) {\n      //ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many hosts in interface %s\", ifname);\n      delete *src;\n      *src = *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n  }\n\n  /* ***************************** */\n\n  (*dst) = hosts_hash->get(vlanId, _dst_ip);\n\n  if((*dst) == NULL) {\n    if(!hosts_hash->hasEmptyRoom()) {\n      *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n\n    (*dst) = new Host(this, dst_mac, vlanId, _dst_ip);\n    if(!hosts_hash->add(*dst)) {\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many hosts in interface %s\", ifname);\n      delete *dst;\n      *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n  }\n}\n\n/* **************************************************** */\n\nstruct ndpiStatsRetrieverData {\n  nDPIStats *stats;\n  Host *host;\n};\n\nstatic bool flow_sum_protos(GenericHashEntry *flow, void *user_data) {\n  ndpiStatsRetrieverData *retriever = (ndpiStatsRetrieverData*)user_data;\n  nDPIStats *stats = retriever->stats;\n  Flow *f = (Flow*)flow;\n\n  if(retriever->host\n       && (retriever->host != f->get_cli_host())\n       && (retriever->host != f->get_srv_host()))\n    return(false); /* false = keep on walking */\n\n  f->sumStats(stats);\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getnDPIStats(nDPIStats *stats, AddressTree *allowed_hosts,\n          const char *host_ip, u_int16_t vlan_id) {\n  ndpiStatsRetrieverData retriever;\n\n  Host *h = NULL;\n  if (host_ip)\n    h = findHostsByIP(allowed_hosts, (char *)host_ip, vlan_id);\n\n  retriever.stats = stats;\n  retriever.host = h;\n  walker(walker_flows, flow_sum_protos, (void*)&retriever);\n}\n\n/* **************************************************** */\n\nstatic bool flow_update_hosts_stats(GenericHashEntry *node, void *user_data) {\n  Flow *flow = (Flow*)node;\n  struct timeval *tv = (struct timeval*)user_data;\n\n  flow->update_hosts_stats(tv, false);\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool update_hosts_stats(GenericHashEntry *node, void *user_data) {\n  Host *host = (Host*)node;\n  struct timeval *tv = (struct timeval*)user_data;\n\n  host->updateStats(tv);\n\n  /*\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Updated: %s [%d]\",\n    ((StringHost*)node)->host_key(),\n    host->getThptTrend());\n  */\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool update_macs_stats(GenericHashEntry *node, void *user_data) {\n  Mac *mac = (Mac*)node;\n  struct timeval *tv = (struct timeval*)user_data;\n\n  mac->updateStats(tv);\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::periodicStatsUpdate() {\n  struct timeval tv;\n\n  if(isView()) return;\n\n  gettimeofday(&tv, NULL);\n\n  flows_hash->walk(flow_update_hosts_stats, (void*)&tv);\n  hosts_hash->walk(update_hosts_stats, (void*)&tv);\n  macs_hash->walk(update_macs_stats, (void*)&tv);\n\n  if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    static_cast<MySQLDB*>(db)->updateStats(&tv);\n    db->flush(false /* not idle, periodic activities */);\n  }\n\n#ifdef NTOPNG_PRO\n  if(host_pools)\n    host_pools->updateStats(&tv);\n#endif\n}\n\n/* **************************************************** */\n\nstruct update_host_pool_l7policy {\n  bool update_pool_id;\n  bool update_l7policy;\n};\n\nstatic bool update_host_host_pool_l7policy(GenericHashEntry *node, void *user_data) {\n  Host *h = (Host*)node;\n  update_host_pool_l7policy *up = (update_host_pool_l7policy*)user_data;\n#ifdef HOST_POOLS_DEBUG\n  char buf[128];\n  u_int16_t cur_pool_id = h->get_host_pool();\n#endif\n\n  if(up->update_pool_id)\n    h->updateHostPool();\n\n  if(up->update_l7policy)\n    h->updateHostL7Policy();\n\n#ifdef HOST_POOLS_DEBUG\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t       \"Going to refresh pool for %s \"\n\t\t\t       \"[refresh pool id: %i] \"\n\t\t\t       \"[refresh l7policy: %i] \"\n\t\t\t       \"[host pool id before refresh: %i] \"\n\t\t\t       \"[host pool id after refresh: %i] \",\n\t\t\t       h->get_ip()->print(buf, sizeof(buf)),\n\t\t\t       up->update_pool_id ? 1 : 0,\n\t\t\t       up->update_l7policy ? 1 : 0,\n\t\t\t       cur_pool_id,\n\t\t\t       h->get_host_pool());\n\n#endif\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::refreshHostPools() {\n  if(isView()) return;\n\n  struct update_host_pool_l7policy update_host;\n  update_host.update_pool_id = true;\n  update_host.update_l7policy = false;\n\n#ifdef NTOPNG_PRO\n  if(is_bridge_interface() && getL7Policer()) {\n    /* Every pool is associated with a set of L7 rules\n     so a refresh must be triggered to seal this association */\n    getL7Policer()->refreshL7Rules();\n    /* Must refresh host l7policies as a change in the host pool id\n       may determine an l7policy change for that host */\n    update_host.update_l7policy = true;\n  }\n#endif\n\n  hosts_hash->walk(update_host_host_pool_l7policy, &update_host);\n\n#ifdef NTOPNG_PRO\n  if(update_host.update_l7policy)\n    updateFlowsL7Policy();\n#endif\n}\n\n/* **************************************************** */\n\n#ifdef NTOPNG_PRO\n\n/* **************************************************** */\n\nstatic bool update_flow_l7_policy(GenericHashEntry *node, void *user_data) {\n  Flow *f = (Flow*)node;\n\n  f->updateFlowShapers();\n  f->updateProfile();\n\n  return(false); /* false = keep on walking */\n}\n\n\n/* **************************************************** */\n\nvoid NetworkInterface::updateHostsL7Policy(u_int16_t host_pool_id) {\n  if(isView()) return;\n\n  struct update_host_pool_l7policy update_host;\n  update_host.update_pool_id = false;\n  update_host.update_l7policy = true;\n\n  hosts_hash->walk(update_host_host_pool_l7policy, &update_host);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::updateFlowsL7Policy() {\n  if(isView()) return;\n\n  flows_hash->walk(update_flow_l7_policy, NULL);\n}\n\n#endif\n\n/* **************************************************** */\n\nstruct host_find_info {\n  char *host_to_find;\n  u_int16_t vlan_id;\n  Host *h;\n};\n\n/* **************************************************** */\n\nstruct mac_find_info {\n  u_int8_t mac[6];\n  u_int16_t vlan_id;\n  Mac *m;\n};\n\n/* **************************************************** */\n\nstatic bool find_host_by_name(GenericHashEntry *h, void *user_data) {\n  struct host_find_info *info = (struct host_find_info*)user_data;\n  Host *host                  = (Host*)h;\n\n#ifdef DEBUG\n  char buf[64];\n  ntop->getTrace()->traceEvent(TRACE_WARNING, \"[%s][%s][%s]\",\n\t\t\t       host->get_ip() ? host->get_ip()->print(buf, sizeof(buf)) : \"\",\n\t\t\t       host->get_name(), info->host_to_find);\n#endif\n\n  if((info->h == NULL) && (host->get_vlan_id() == info->vlan_id)) {\n    if((host->get_name() == NULL) && host->get_ip()) {\n      char ip_buf[32], name_buf[96];\n      char *ipaddr = host->get_ip()->print(ip_buf, sizeof(ip_buf));\n      int rc = ntop->getRedis()->getAddress(ipaddr, name_buf, sizeof(name_buf),\n\t\t\t\t\t    false /* Don't resolve it if not known */);\n\n      if(rc == 0 /* found */) host->setName(name_buf);\n    }\n\n    if(host->get_name() && (!strcmp(host->get_name(), info->host_to_find))) {\n      info->h = host;\n      return(true); /* found */\n    }\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool find_mac_by_name(GenericHashEntry *h, void *user_data) {\n  struct mac_find_info *info = (struct mac_find_info*)user_data;\n  Mac *m = (Mac*)h;\n\n  if((info->m == NULL)\n     && (m->get_vlan_id() == info->vlan_id)\n     && (!memcmp(info->mac, m->get_mac(), 6))\n     ) {\n    info->m = m;\n    return(true); /* found */\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::restoreHost(char *host_ip, u_int16_t vlan_id) {\n  Host *h = new Host(this, host_ip, vlan_id);\n\n  if(!h) return(false);\n\n  if(!hosts_hash->add(h)) {\n    //ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many hosts in interface %s\", ifname);\n    delete h;\n    return(false);\n  }\n\n  return(true);\n}\n\n/* **************************************************** */\n\nHost* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n  struct in_addr  a4;\n  struct in6_addr a6;\n  Host *h = NULL;\n\n  /* Check if address is invalid */\n  if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n     && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n    /* Looks like a symbolic name */\n    struct host_find_info info;\n\n    memset(&info, 0, sizeof(info));\n    info.host_to_find = host_ip, info.vlan_id = vlan_id;\n    walker(walker_hosts, find_host_by_name, (void*)&info);\n\n    h = info.h;\n  } else {\n    IpAddress *ip = new IpAddress();\n\n    if(ip) {\n      ip->set(host_ip);\n\n      if(!isView())\n\th = hosts_hash->get(vlan_id, ip);\n      else {\n\tfor(u_int8_t s = 0; s<numSubInterfaces; s++) {\n\t  h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);\n\t  if(h) break;\n\t}\n      }\n\n      delete ip;\n    }\n  }\n\n  return(h);\n}\n\n/* **************************************************** */\n\n#ifdef NTOPNG_PRO\n\nstatic bool update_flow_profile(GenericHashEntry *h, void *user_data) {\n  Flow *flow = (Flow*)h;\n\n  flow->updateProfile();\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::updateFlowProfiles() {\n  if(isView()) return;\n\n  if(ntop->getPro()->has_valid_license()) {\n    FlowProfiles *newP;\n\n    if(shadow_flow_profiles) {\n      delete shadow_flow_profiles;\n      shadow_flow_profiles = NULL;\n    }\n\n    flow_profiles->dumpCounters();\n    shadow_flow_profiles = flow_profiles, newP = new FlowProfiles(id);\n\n    newP->loadProfiles(); /* and reload */\n    flow_profiles = newP; /* Overwrite the current profiles */\n\n    flows_hash->walk(update_flow_profile, NULL);\n  }\n}\n\n#endif\n\n/* **************************************************** */\n\nbool NetworkInterface::getHostInfo(lua_State* vm,\n\t\t\t\t   AddressTree *allowed_hosts,\n\t\t\t\t   char *host_ip, u_int16_t vlan_id) {\n  Host *h = findHostsByIP(allowed_hosts, host_ip, vlan_id);\n\n  if(h) {\n    h->lua(vm, allowed_hosts, true, true, true, false, false);\n    return(true);\n  } else\n    return(false);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::loadHostAlertPrefs(lua_State* vm,\n\t\t\t\t          AddressTree *allowed_hosts,\n\t\t\t\t          char *host_ip, u_int16_t vlan_id) {\n  Host *h = findHostsByIP(allowed_hosts, host_ip, vlan_id);\n\n  if(h) {\n    h->loadAlertPrefs();\n    return(true);\n  }\n  return(false);\n}\n\n/* **************************************************** */\n\nHost* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,\n\t\t\t\t      char *host_ip, u_int16_t vlan_id) {\n  if(host_ip != NULL) {\n    Host *h = getHost(host_ip, vlan_id);\n\n    if(h && h->match(allowed_hosts))\n      return(h);\n  }\n\n  return(NULL);\n}\n\n/* **************************************************** */\n\nstruct flowHostRetrieveList {\n  Flow *flow;\n  /* Value */\n  Host *hostValue;\n  Mac *macValue;\n  u_int64_t numericValue;\n  char *stringValue;\n};\n\nstruct flowHostRetriever {\n  /* Search criteria */\n  AddressTree *allowed_hosts;\n  Host *host;\n  Mac *mac;\n  char *manufacturer;\n  bool skipSpecialMacs, hostMacsOnly;\n  char *country;\n  int ndpi_proto;\n  sortField sorter;\n  LocationPolicy location;\n  u_int16_t *vlan_id;\n  char *osFilter;\n  u_int32_t *asnFilter;\n  int16_t *networkFilter;\n  u_int16_t *poolFilter;\n\n  /* Return values */\n  u_int32_t maxNumEntries, actNumEntries;\n  struct flowHostRetrieveList *elems;\n\n  /* Paginator */\n  Paginator *pag;\n};\n\n/* **************************************************** */\n\nstatic bool flow_search_walker(GenericHashEntry *h, void *user_data) {\n  struct flowHostRetriever *retriever = (struct flowHostRetriever*)user_data;\n  Flow *f = (Flow*)h;\n  int ndpi_proto;\n  u_int16_t port;\n  int16_t local_network_id;\n\n  if(retriever->actNumEntries >= retriever->maxNumEntries)\n    return(true); /* Limit reached */\n\n  if(f && (!f->idle())) {\n    if(retriever->host\n       && (retriever->host != f->get_cli_host())\n       && (retriever->host != f->get_srv_host()))\n    return(false); /* false = keep on walking */\n\n    if(retriever->pag\n       && retriever->pag->l7protoFilter(&ndpi_proto)\n       && ndpi_proto != -1\n       && (f->get_detected_protocol().protocol != ndpi_proto)\n       && (f->get_detected_protocol().master_protocol != ndpi_proto))\n      return(false); /* false = keep on walking */\n\n    if(retriever->pag\n       && retriever->pag->portFilter(&port)\n       && f->get_cli_port() != port\n       && f->get_srv_port() != port)\n      return(false); /* false = keep on walking */\n\n    if(retriever->pag\n       && retriever->pag->localNetworkFilter(&local_network_id)\n       && f->get_cli_host()->get_local_network_id() != local_network_id\n       && f->get_srv_host()->get_local_network_id() != local_network_id)\n      return(false); /* false = keep on walking */\n\n    if(retriever->location == location_local_only) {\n      if((!f->get_cli_host()->isLocalHost())\n\t || (!f->get_srv_host()->isLocalHost()))\n\treturn(false); /* false = keep on walking */\n    } else if(retriever->location == location_remote_only) {\n      if((f->get_cli_host()->isLocalHost())\n\t || (f->get_srv_host()->isLocalHost()))\n\treturn(false); /* false = keep on walking */\n    }\n\n    retriever->elems[retriever->actNumEntries].flow = f;\n\n    if(f->match(retriever->allowed_hosts)) {\n      switch(retriever->sorter) {\n      case column_client:\n\tretriever->elems[retriever->actNumEntries++].hostValue = f->get_cli_host();\n\tbreak;\n      case column_server:\n\tretriever->elems[retriever->actNumEntries++].hostValue = f->get_srv_host();\n\tbreak;\n      case column_vlan:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_vlan_id();\n\tbreak;\n      case column_proto_l4:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_protocol();\n\tbreak;\n      case column_ndpi:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_detected_protocol().protocol;\n\tbreak;\n      case column_duration:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_duration();\n\tbreak;\n      case column_thpt:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes_thpt();\n\tbreak;\n      case column_bytes:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes();\n\tbreak;\n      case column_info:\n\tif(f->getDNSQuery())            retriever->elems[retriever->actNumEntries++].stringValue = f->getDNSQuery();\n\telse if(f->getHTTPURL())        retriever->elems[retriever->actNumEntries++].stringValue = f->getHTTPURL();\n\telse if(f->getSSLCertificate()) retriever->elems[retriever->actNumEntries++].stringValue = f->getSSLCertificate();\n\telse retriever->elems[retriever->actNumEntries++].stringValue = (char*)\"\";\n\tbreak;\n      default:\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", retriever->sorter);\n\tbreak;\n      }\n    }\n  }\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool host_search_walker(GenericHashEntry *he, void *user_data) {\n  char buf[64];\n  struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;\n  Host *h = (Host*)he;\n\n  if(r->actNumEntries >= r->maxNumEntries)\n    return(true); /* Limit reached */\n\n  if(!h || h->idle() || !h->match(r->allowed_hosts))\n    return(false);\n\n  if((r->location == location_local_only      && !h->isLocalHost())         ||\n     (r->location == location_remote_only     && h->isLocalHost())          ||\n     (r->vlan_id       && *(r->vlan_id)       != h->get_vlan_id())          ||\n     (r->asnFilter     && *(r->asnFilter)     != h->get_asn())              ||\n     (r->networkFilter && *(r->networkFilter) != h->get_local_network_id()) ||\n     (r->networkFilter && *(r->networkFilter) != h->get_local_network_id()) ||\n     (r->hostMacsOnly  && h->getMac() && h->getMac()->isSpecialMac())       ||\n     (r->mac           && (h->getMac() != r->mac))                          ||\n     (r->poolFilter    && *(r->poolFilter)    != h->get_host_pool())        ||\n     (r->country  && strlen(r->country)  && (!h->get_country() || strcmp(h->get_country(), r->country))) ||\n     (r->osFilter && strlen(r->osFilter) && (!h->get_os()      || strcmp(h->get_os(), r->osFilter))))\n    return(false); /* false = keep on walking */\n\n  r->elems[r->actNumEntries].hostValue = h;\n\n  switch(r->sorter) {\n  case column_ip:\n    r->elems[r->actNumEntries++].hostValue = h; /* hostValue was already set */\n    break;\n\n  case column_alerts:\n    r->elems[r->actNumEntries++].numericValue = h->getNumAlerts();\n    break;\n\n  case column_name:\n    r->elems[r->actNumEntries++].stringValue = strdup(h->get_name(buf, sizeof(buf), false));\n    break;\n\n  case column_country:\n    r->elems[r->actNumEntries++].stringValue = strdup(h->get_country() ? h->get_country() : (char*)\"\");\n    break;\n\n  case column_os:\n    r->elems[r->actNumEntries++].stringValue = strdup(h->get_os() ? h->get_os() : (char*)\"\");\n    break;\n\n  case column_vlan:\n    r->elems[r->actNumEntries++].numericValue = h->get_vlan_id();\n    break;\n\n  case column_since:\n    r->elems[r->actNumEntries++].numericValue = h->get_first_seen();\n    break;\n\n  case column_asn:\n    r->elems[r->actNumEntries++].numericValue = h->get_asn();\n    break;\n\n  case column_thpt:\n    r->elems[r->actNumEntries++].numericValue = h->getBytesThpt();\n    break;\n\n  case column_num_flows:\n    r->elems[r->actNumEntries++].numericValue = h->getNumActiveFlows();\n    break;\n\n  case column_traffic:\n    r->elems[r->actNumEntries++].numericValue = h->getNumBytes();\n    break;\n\n  case column_local_network_id:\n    r->elems[r->actNumEntries++].numericValue = h->get_local_network_id();\n    break;\n\n  case column_mac:\n    r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(h->get_mac());\n    break;\n\n  case column_pool_id:\n    r->elems[r->actNumEntries++].numericValue = h->get_host_pool();\n    break;\n\n    /* Criteria */\n  case column_uploaders:      r->elems[r->actNumEntries++].numericValue = h->getNumBytesSent(); break;\n  case column_downloaders:    r->elems[r->actNumEntries++].numericValue = h->getNumBytesRcvd(); break;\n  case column_unknowers:      r->elems[r->actNumEntries++].numericValue = h->get_ndpi_stats()->getProtoBytes(NDPI_PROTOCOL_UNKNOWN); break;\n  case column_incomingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumIncomingFlows(); break;\n  case column_outgoingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumOutgoingFlows(); break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);\n    break;\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool mac_search_walker(GenericHashEntry *he, void *user_data) {\n  struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;\n  Mac *m = (Mac*)he;\n\n  if(r->actNumEntries >= r->maxNumEntries)\n    return(true); /* Limit reached */\n\n  if(!m\n     || m->idle()\n     || ((r->vlan_id && (*(r->vlan_id) != m->get_vlan_id())))\n     || (r->skipSpecialMacs && m->isSpecialMac())\n     || (r->hostMacsOnly && m->getNumHosts() == 0))\n    return(false); /* false = keep on walking */\n\n  r->elems[r->actNumEntries].macValue = m;\n\n  switch(r->sorter) {\n  case column_mac:\n    r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(m->get_mac());\n    break;\n\n  case column_vlan:\n    r->elems[r->actNumEntries++].numericValue = m->get_vlan_id();\n    break;\n\n  case column_since:\n    r->elems[r->actNumEntries++].numericValue = m->get_first_seen();\n    break;\n\n  case column_thpt:\n    r->elems[r->actNumEntries++].numericValue = m->getBytesThpt();\n    break;\n\n  case column_traffic:\n    r->elems[r->actNumEntries++].numericValue = m->getNumBytes();\n    break;\n\n  case column_num_hosts:\n    r->elems[r->actNumEntries++].numericValue = m->getNumHosts();\n    break;\n\n  case column_manufacturer:\n    r->elems[r->actNumEntries++].stringValue = m->get_manufacturer() ? (char*)m->get_manufacturer() : (char*)\"zzz\";\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);\n    break;\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nint hostSorter(const void *_a, const void *_b) {\n  struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;\n  struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;\n\n  return(a->hostValue->get_ip()->compare(b->hostValue->get_ip()));\n}\n\nint numericSorter(const void *_a, const void *_b) {\n  struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;\n  struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;\n\n  if(a->numericValue < b->numericValue)      return(-1);\n  else if(a->numericValue > b->numericValue) return(1);\n  else return(0);\n}\n\nint stringSorter(const void *_a, const void *_b) {\n  struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;\n  struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;\n\n  return(strcmp(a->stringValue, b->stringValue));\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::disablePurge(bool on_flows) {\n  if(!isView()) {\n    if(on_flows)\n      flows_hash->disablePurge();\n    else {\n      hosts_hash->disablePurge();\n      macs_hash->disablePurge();\n    }\n  } else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if(on_flows)\n\tsubInterfaces[s]->get_flows_hash()->disablePurge();\n      else {\n\tsubInterfaces[s]->get_hosts_hash()->disablePurge();\n\tsubInterfaces[s]->get_macs_hash()->disablePurge();\n      }\n    }\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::enablePurge(bool on_flows) {\n  if(!isView()) {\n    if(on_flows)\n      flows_hash->enablePurge();\n    else {\n      hosts_hash->enablePurge();\n      macs_hash->enablePurge();\n    }\n  } else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if(on_flows)\n\tsubInterfaces[s]->get_flows_hash()->enablePurge();\n      else {\n\tsubInterfaces[s]->get_hosts_hash()->enablePurge();\n\tsubInterfaces[s]->get_macs_hash()->enablePurge();\n      }\n    }\n  }\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getFlows(lua_State* vm,\n\t\t\t       AddressTree *allowed_hosts,\n\t\t\t       Host *host, int ndpi_proto,\n\t\t\t       LocationPolicy location,\n\t\t\t       char *sortColumn,\n\t\t\t       u_int32_t maxHits,\n\t\t\t       u_int32_t toSkip,\n\t\t\t       bool a2zSortOrder) {\n  struct flowHostRetriever retriever;\n  int (*sorter)(const void *_a, const void *_b);\n  DetailsLevel highDetails = (location == location_local_only || (maxHits != CONST_MAX_NUM_HITS)) ? details_high : details_normal;\n\n  if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0)) maxHits = CONST_MAX_NUM_HITS;\n  retriever.pag = NULL;\n  retriever.host = host, retriever.ndpi_proto = ndpi_proto, retriever.location = location;\n  retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;\n  retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);\n\n  if(retriever.elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;\n  else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;\n  else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;\n\n  /* ******************************* */\n\n  disablePurge(true);\n  walker(walker_flows, flow_search_walker, (void*)&retriever);\n\n  qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  lua_newtable(vm);\n\n  if(a2zSortOrder) {\n    for(int i=toSkip, num=0; i<(int)retriever.actNumEntries; i++) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)maxHits) break;\n\n    }\n  } else {\n    for(int i=(retriever.actNumEntries-1-toSkip), num=0; i>=0; i--) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)maxHits) break;\n    }\n  }\n\n  enablePurge(true);\n  free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getFlows(lua_State* vm,\n\t\t\t       AddressTree *allowed_hosts,\n\t\t\t       LocationPolicy location, Host *host,\n\t\t\t       Paginator *p) {\n  struct flowHostRetriever retriever;\n  int (*sorter)(const void *_a, const void *_b);\n  char sortColumn[32];\n  DetailsLevel highDetails;\n\n  if(p == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to return results with a NULL paginator\");\n    return(-1);\n  }\n\n  highDetails = p->detailedResults() ? details_high : (location == location_local_only || (p && p->maxHits() != CONST_MAX_NUM_HITS)) ? details_high : details_normal;\n\n  retriever.pag = p;\n  retriever.host = host, retriever.location = location;\n  retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;\n  retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);\n\n  if(retriever.elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  snprintf(sortColumn, sizeof(sortColumn), \"%s\", p->sortColumn());\n  if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;\n  else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;\n  else {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);\n    retriever.sorter = column_bytes, sorter = numericSorter;\n  }\n\n  /* ******************************* */\n\n  disablePurge(true);\n  walker(walker_flows, flow_search_walker, (void*)&retriever);\n\n  qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"numFlows\", retriever.actNumEntries);\n\n  lua_newtable(vm);\n\n  if(p->a2zSortOrder()) {\n    for(int i=p->toSkip(), num=0; i<(int)retriever.actNumEntries; i++) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)p->maxHits()) break;\n\n    }\n  } else {\n    for(int i=(retriever.actNumEntries-1-p->toSkip()), num=0; i>=0; i--) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)p->maxHits()) break;\n    }\n  }\n\n  lua_pushstring(vm, \"flows\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  enablePurge(true);\n  free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getLatestActivityHostsList(lua_State* vm, AddressTree *allowed_hosts) {\n  struct flowHostRetriever retriever;\n\n  memset(&retriever, 0, sizeof(retriever));\n\n  // there's not even the need to use the retriever or to sort results here\n  // we use the retriever just to leverage on the exising code.\n  retriever.allowed_hosts = allowed_hosts, retriever.location = location_all;\n  retriever.actNumEntries = 0, retriever.maxNumEntries = getHostsHashSize();\n  retriever.sorter = column_vlan; // just a placeholder, we don't care as we won't sort\n  retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);\n\n  if(retriever.elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  disablePurge(false);\n  walker(walker_hosts, host_search_walker, (void*)&retriever);\n\n  lua_newtable(vm);\n\n  if(retriever.actNumEntries > 0) {\n    for(int i=0; i<(int)retriever.actNumEntries; i++) {\n      Host *h = retriever.elems[i].hostValue;\n\n      if(i < CONST_MAX_NUM_HITS)\n\th->lua(vm, NULL /* Already checked */,\n\t       false /* host details */,\n\t       false /* verbose */,\n\t       false /* return host */,\n\t       true  /* as list element*/,\n\t       true  /* exclude deserialized bytes */);\n    }\n  }\n\n  enablePurge(false);\n  free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::sortHosts(struct flowHostRetriever *retriever,\n\t\t\t\tAddressTree *allowed_hosts,\n\t\t\t\tbool host_details,\n\t\t\t\tLocationPolicy location,\n\t\t\t\tchar *countryFilter, char *mac_filter,\n\t\t\t\tu_int16_t *vlan_id, char *osFilter,\n\t\t\t\tu_int32_t *asnFilter, int16_t *networkFilter,\n\t\t\t\tu_int16_t *pool_filter,\n\t\t\t\tbool hostMacsOnly, char *sortColumn) {\n  u_int32_t maxHits;\n  int (*sorter)(const void *_a, const void *_b);\n\n  if(retriever == NULL)\n    return -1;\n\n  maxHits = getHostsHashSize();\n  if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))\n    maxHits = CONST_MAX_NUM_HITS;\n\n  memset(retriever, 0, sizeof(struct flowHostRetriever));\n\n  if(mac_filter) {\n    u_int8_t macAddr[6];\n\n    Utils::parseMac(macAddr, mac_filter);\n\n    retriever->mac = macs_hash->get(vlan_id ? *vlan_id : 0, (const u_int8_t*)macAddr);\n  }\n\n  retriever->allowed_hosts = allowed_hosts, retriever->location = location,\n  retriever->country = countryFilter, retriever->vlan_id = vlan_id,\n  retriever->osFilter = osFilter, retriever->asnFilter = asnFilter,\n  retriever->networkFilter = networkFilter, retriever->actNumEntries = 0,\n  retriever->poolFilter = pool_filter;\n  retriever->maxNumEntries = maxHits, retriever->hostMacsOnly = hostMacsOnly;\n  retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);\n\n  if(retriever->elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  if((!strcmp(sortColumn, \"column_ip\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_ip, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\")) retriever->sorter = column_vlan, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_alerts\")) retriever->sorter = column_alerts, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_name\")) retriever->sorter = column_name, sorter = stringSorter;\n  else if(!strcmp(sortColumn, \"column_country\")) retriever->sorter = column_country, sorter = stringSorter;\n  else if(!strcmp(sortColumn, \"column_os\")) retriever->sorter = column_os, sorter = stringSorter;\n  else if(!strcmp(sortColumn, \"column_since\")) retriever->sorter = column_since, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_asn\")) retriever->sorter = column_asn, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\")) retriever->sorter = column_thpt, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_num_flows\")) retriever->sorter = column_num_flows, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_traffic\")) retriever->sorter = column_traffic, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_local_network_id\")) retriever->sorter = column_local_network_id, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_mac\")) retriever->sorter = column_mac, sorter = numericSorter;\n  /* criteria (datatype sortField in ntop_typedefs.h / see also host_search_walker:NetworkInterface.cpp) */\n  else if(!strcmp(sortColumn, \"column_uploaders\")) retriever->sorter = column_uploaders, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_downloaders\")) retriever->sorter = column_downloaders, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_unknowers\")) retriever->sorter = column_unknowers, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_incomingflows\")) retriever->sorter = column_incomingflows, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_outgoingflows\")) retriever->sorter = column_outgoingflows, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_pool_id\")) retriever->sorter = column_pool_id, sorter = numericSorter;\n  else {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);\n    retriever->sorter = column_traffic, sorter = numericSorter;\n  }\n\n  // make sure the caller has disabled the purge!!\n  walker(walker_hosts, host_search_walker, (void*)retriever);\n\n  qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  return(retriever->actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::sortMacs(struct flowHostRetriever *retriever,\n\t\t\t       u_int16_t vlan_id, bool skipSpecialMacs,\n\t\t\t       bool hostMacsOnly,\n\t\t\t       char *sortColumn) {\n  u_int32_t maxHits;\n  int (*sorter)(const void *_a, const void *_b);\n\n  if(retriever == NULL)\n    return -1;\n\n  maxHits = getMacsHashSize();\n  if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))\n    maxHits = CONST_MAX_NUM_HITS;\n\n  retriever->vlan_id = &vlan_id, retriever->skipSpecialMacs = skipSpecialMacs,\n    retriever->hostMacsOnly = hostMacsOnly, retriever->actNumEntries = 0,\n    retriever->maxNumEntries = maxHits,\n    retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);\n\n  if(retriever->elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  if((!strcmp(sortColumn, \"column_mac\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_mac, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\"))         retriever->sorter = column_vlan,         sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_manufacturer\")) retriever->sorter = column_manufacturer, sorter = stringSorter;\n  else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;\n\n  // make sure the caller has disabled the purge!!\n  walker(walker_macs, mac_search_walker, (void*)retriever);\n\n  qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  return(retriever->actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getActiveHostsList(lua_State* vm, AddressTree *allowed_hosts,\n\t\t\t\t\t bool host_details, LocationPolicy location,\n\t\t\t\t\t char *countryFilter, char *mac_filter,\n\t\t\t\t\t u_int16_t *vlan_id, char *osFilter,\n\t\t\t\t\t u_int32_t *asnFilter, int16_t *networkFilter,\n\t\t\t\t\t u_int16_t *pool_filter,\n\t\t\t\t\t char *sortColumn, u_int32_t maxHits,\n\t\t\t\t\t u_int32_t toSkip, bool a2zSortOrder) {\n  struct flowHostRetriever retriever;\n\n  disablePurge(false);\n\n  if(sortHosts(&retriever, allowed_hosts, host_details, location,\n\t       countryFilter, mac_filter, vlan_id, osFilter,\n\t       asnFilter, networkFilter, pool_filter, true, sortColumn) < 0) {\n    enablePurge(false);\n    return -1;\n  }\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"numHosts\", retriever.actNumEntries);\n\n  lua_newtable(vm);\n\n  if(a2zSortOrder) {\n    for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {\n      Host *h = retriever.elems[i].hostValue;\n      h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);\n    }\n  } else {\n    for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {\n      Host *h = retriever.elems[i].hostValue;\n      h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);\n    }\n  }\n\n  lua_pushstring(vm, \"hosts\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  enablePurge(false);\n\n  // it's up to us to clean sorted data\n  // make sure first to free elements in case a string sorter has been used\n  if(retriever.sorter == column_name\n     || retriever.sorter == column_country\n     || retriever.sorter == column_os) {\n    for(u_int i=0; i<retriever.maxNumEntries; i++)\n      if(retriever.elems[i].stringValue)\n\tfree(retriever.elems[i].stringValue);\n  }\n\n  // finally free the elements regardless of the sorted kind\n  if(retriever.elems) free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n/* **************************************************** */\n\nint NetworkInterface::getActiveHostsGroup(lua_State* vm, AddressTree *allowed_hosts,\n\t\t\t\t\t  bool host_details, LocationPolicy location,\n\t\t\t\t\t  char *countryFilter,\n\t\t\t\t\t  u_int16_t *vlan_id, char *osFilter,\n\t\t\t\t\t  u_int32_t *asnFilter, int16_t *networkFilter,\n\t\t\t\t\t  u_int16_t *pool_filter,\n\t\t\t\t\t  bool local_macs, char *groupColumn) {\n  struct flowHostRetriever retriever;\n  Grouper *gper;\n\n  disablePurge(false);\n\n  // sort hosts according to the grouping criterion\n  if(sortHosts(&retriever, allowed_hosts, host_details, location,\n\t       countryFilter, NULL /* Mac */, vlan_id,\n\t       osFilter, asnFilter, networkFilter, pool_filter,\n\t       local_macs, groupColumn) < 0 ) {\n    enablePurge(false);\n    return -1;\n  }\n\n  // build a new grouper that will help in aggregating stats\n  if((gper = new(std::nothrow) Grouper(retriever.sorter)) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR,\n\t\t\t\t \"Unable to allocate memory for a Grouper.\");\n    enablePurge(false);\n    return -1;\n  }\n\n  lua_newtable(vm);\n\n  for(int i=0; i<(int)retriever.actNumEntries; i++) {\n    Host *h = retriever.elems[i].hostValue;\n\n    if(h) {\n      if(gper->inGroup(h) == false) {\n\tif(gper->getNumEntries() > 0)\n\t  gper->lua(vm);\n\tgper->newGroup(h);\n      }\n\n      gper->incStats(h);\n    }\n  }\n\n  if(gper->getNumEntries() > 0)\n    gper->lua(vm);\n\n delete gper;\n  gper = NULL;\n\n  enablePurge(false);\n\n  // it's up to us to clean sorted data\n  // make sure first to free elements in case a string sorter has been used\n  if((retriever.sorter == column_name)\n     || (retriever.sorter == column_country)\n     || (retriever.sorter == column_os)) {\n    for(u_int i=0; i<retriever.maxNumEntries; i++)\n      if(retriever.elems[i].stringValue)\n\tfree(retriever.elems[i].stringValue);\n  }\n\n  // finally free the elements regardless of the sorted kind\n  if(retriever.elems) free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nstatic bool flow_stats_walker(GenericHashEntry *h, void *user_data) {\n  struct active_flow_stats *stats = (struct active_flow_stats*)user_data;\n  Flow *flow = (Flow*)h;\n\n  stats->num_flows++,\n    stats->ndpi_bytes[flow->get_detected_protocol().protocol] += (u_int32_t)flow->get_bytes(),\n    stats->breeds_bytes[flow->get_protocol_breed()] += (u_int32_t)flow->get_bytes();\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getFlowsStats(lua_State* vm) {\n  struct active_flow_stats stats;\n\n  memset(&stats, 0, sizeof(stats));\n  walker(walker_flows, flow_stats_walker, (void*)&stats);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"num_flows\", stats.num_flows);\n\n  lua_newtable(vm);\n  for(int i=0; i<NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS; i++) {\n    if(stats.ndpi_bytes[i] > 0)\n      lua_push_int_table_entry(vm,\n\t\t\t       ndpi_get_proto_name(get_ndpi_struct(), i),\n\t\t\t       stats.ndpi_bytes[i]);\n  }\n\n  lua_pushstring(vm, \"protos\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  lua_newtable(vm);\n  for(int i=0; i<NUM_BREEDS; i++) {\n    if(stats.breeds_bytes[i] > 0)\n      lua_push_int_table_entry(vm,\n\t\t\t       ndpi_get_proto_breed_name(get_ndpi_struct(),\n\t\t\t\t\t\t\t (ndpi_protocol_breed_t)i),\n\t\t\t       stats.breeds_bytes[i]);\n  }\n\n  lua_pushstring(vm, \"breeds\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n}\n/* **************************************************** */\n\nvoid NetworkInterface::getNetworksStats(lua_State* vm) {\n  NetworkStats *network_stats;\n  u_int8_t num_local_networks = ntop->getNumLocalNetworks();\n\n  lua_newtable(vm);\n  for(u_int8_t network_id = 0; network_id < num_local_networks; network_id++) {\n    network_stats = getNetworkStats(network_id);\n    // do not add stats of networks that have not generated any traffic\n    if(!network_stats || !network_stats->trafficSeen())\n      continue;\n    lua_newtable(vm);\n    network_stats->lua(vm);\n    lua_push_int32_table_entry(vm, \"network_id\", network_id);\n    lua_pushstring(vm, ntop->getLocalNetworkName(network_id));\n    lua_insert(vm, -2);\n    lua_settable(vm, -3);\n  }\n}\n\n/* **************************************************** */\n\nstatic bool host_activity_walker(GenericHashEntry *he, void *user_data) {\n  HostActivityRetriever * r = (HostActivityRetriever *)user_data;\n  Host *h = (Host*)he;\n  int i;\n\n  if(!h\n     || !h->equal(&r->search)\n     || (!h->get_user_activities()))\n    return(false); /* false = keep on walking */\n\n  r->found = true;\n  for(i=0; i<UserActivitiesN; i++)\n    r->counters[i] = *h->getActivityBytes((UserActivityID)i);\n\n  return true; /* found, stop walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getLocalHostActivity(lua_State* vm, const char *host) {\n  HostActivityRetriever retriever(host);\n  int i;\n\n  disablePurge(false);\n  walker(walker_hosts, host_activity_walker, &retriever);\n  enablePurge(false);\n\n  if(retriever.found) {\n    lua_newtable(vm);\n    for(i=0; i<UserActivitiesN; i++) {\n      lua_newtable(vm);\n\n      lua_push_int_table_entry(vm, \"up\", retriever.counters[i].up);\n      lua_push_int_table_entry(vm, \"down\", retriever.counters[i].down);\n      lua_push_int_table_entry(vm, \"background\", retriever.counters[i].background);\n\n      lua_pushstring(vm, activity_names[i]);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n    }\n  } else\n    lua_pushnil(vm);\n}\n\n/* **************************************************** */\n\nu_int NetworkInterface::purgeIdleFlows() {\n  if(!purge_idle_flows_hosts) return(0);\n\n  if(next_idle_flow_purge == 0) {\n    next_idle_flow_purge = last_pkt_rcvd + FLOW_PURGE_FREQUENCY;\n    return(0);\n  } else if(last_pkt_rcvd < next_idle_flow_purge)\n    return(0); /* Too early */\n  else {\n    /* Time to purge flows */\n    u_int n;\n\n    // ntop->getTrace()->traceEvent(TRACE_INFO, \"Purging idle flows\");\n    n = flows_hash->purgeIdle();\n\n    if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n      // flush the queue\n      db->flush(true /* idle */);\n    }\n\n    next_idle_flow_purge = last_pkt_rcvd + FLOW_PURGE_FREQUENCY;\n    return(n);\n  }\n}\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getNumPackets() {\n  u_int64_t tot = ethStats.getNumPackets();\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumPackets();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getNumBytes() {\n  u_int64_t tot = ethStats.getNumBytes();\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumBytes();\n  return(tot);\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getNumPacketDrops() {\n  u_int32_t tot = getNumDroppedPackets();\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumDroppedPackets();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumFlows()        {\n  u_int tot = flows_hash ? flows_hash->getNumEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumFlows();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumHosts()        {\n  u_int tot = hosts_hash ? hosts_hash->getNumEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHosts();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumHTTPHosts()    {\n  u_int tot = hosts_hash ? hosts_hash->getNumHTTPEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHTTPHosts();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumMacs()        {\n  u_int tot = macs_hash ? macs_hash->getNumEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumMacs();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::purgeIdleHostsMacs() {\n  if(!purge_idle_flows_hosts) return(0);\n\n  if(next_idle_host_purge == 0) {\n    next_idle_host_purge = last_pkt_rcvd + HOST_PURGE_FREQUENCY;\n    return(0);\n  } else if(last_pkt_rcvd < next_idle_host_purge)\n    return(0); /* Too early */\n  else {\n    /* Time to purge hosts */\n    u_int n;\n\n    // ntop->getTrace()->traceEvent(TRACE_INFO, \"Purging idle hosts\");\n    n = hosts_hash->purgeIdle() + macs_hash->purgeIdle();\n    next_idle_host_purge = last_pkt_rcvd + HOST_PURGE_FREQUENCY;\n    return(n);\n  }\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::getnDPIProtocols(lua_State *vm) {\n  int i;\n\n  lua_newtable(vm);\n\n  for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {\n    char buf[8];\n\n    snprintf(buf, sizeof(buf), \"%d\", i);\n    lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getnDPIProtocols(lua_State *vm, ndpi_protocol_category_t filter) {\n  int i;\n\n  lua_newtable(vm);\n\n  for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {\n    char buf[8];\n\n    if (ndpi_struct->proto_defaults[i].protoCategory == filter) {\n      snprintf(buf, sizeof(buf), \"%d\", i);\n      lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);\n    }\n  }\n}\n\n/* **************************************************** */\n\n#define NUM_TCP_STATES      4\n/*\n  0 = RST\n  1 = SYN\n  2 = Established\n  3 = FIN\n*/\n\nstatic bool num_flows_state_walker(GenericHashEntry *node, void *user_data) {\n  Flow *flow = (Flow*)node;\n  u_int32_t *num_flows = (u_int32_t*)user_data;\n\n  switch(flow->getFlowState()) {\n  case flow_state_syn:\n    num_flows[1]++;\n    break;\n  case flow_state_established:\n    num_flows[2]++;\n    break;\n  case flow_state_rst:\n    num_flows[0]++;\n    break;\n  case flow_state_fin:\n    num_flows[3]++;\n    break;\n  default:\n    /* UDP... */\n    break;\n  }\n\n  return(false /* keep walking */);\n}\n\n/* *************************************** */\n\nstatic bool num_flows_walker(GenericHashEntry *node, void *user_data) {\n  Flow *flow = (Flow*)node;\n  u_int32_t *num_flows = (u_int32_t*)user_data;\n\n  num_flows[flow->get_detected_protocol().protocol]++;\n\n  return(false /* keep walking */);\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::getFlowsStatus(lua_State *vm) {\n  u_int32_t num_flows[NUM_TCP_STATES] = { 0 };\n\n  walker(walker_flows, num_flows_state_walker, num_flows);\n\n  lua_push_int_table_entry(vm, \"RST\", num_flows[0]);\n  lua_push_int_table_entry(vm, \"SYN\", num_flows[1]);\n  lua_push_int_table_entry(vm, \"Established\", num_flows[2]);\n  lua_push_int_table_entry(vm, \"FIN\", num_flows[3]);\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::getnDPIFlowsCount(lua_State *vm) {\n  u_int32_t *num_flows;\n\n  num_flows = (u_int32_t*)calloc(ndpi_struct->ndpi_num_supported_protocols, sizeof(u_int32_t));\n\n  if(num_flows) {\n    walker(walker_flows, num_flows_walker, num_flows);\n\n    for(int i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {\n      if(num_flows[i] > 0)\n\tlua_push_int_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, num_flows[i]);\n    }\n\n    free(num_flows);\n  }\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::sumStats(TcpFlowStats *_tcpFlowStats,\n\t\t\t\tEthStats *_ethStats,\n\t\t\t\tLocalTrafficStats *_localStats,\n\t\t\t\tnDPIStats *_ndpiStats,\n\t\t\t\tPacketStats *_pktStats,\n\t\t\t\tTcpPacketStats *_tcpPacketStats) {\n  tcpFlowStats.sum(_tcpFlowStats), ethStats.sum(_ethStats), localStats.sum(_localStats),\n    ndpiStats.sum(_ndpiStats), pktStats.sum(_pktStats), tcpPacketStats.sum(_tcpPacketStats);\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::lua(lua_State *vm) {\n  TcpFlowStats _tcpFlowStats;\n  EthStats _ethStats;\n  LocalTrafficStats _localStats;\n  nDPIStats _ndpiStats;\n  PacketStats _pktStats;\n  TcpPacketStats _tcpPacketStats;\n\n  lua_newtable(vm);\n\n  lua_push_str_table_entry(vm, \"name\", ifname);\n  lua_push_int_table_entry(vm, \"scalingFactor\", scalingFactor);\n  lua_push_int_table_entry(vm,  \"id\", id);\n  lua_push_bool_table_entry(vm, \"isView\", isView()); /* View interface */\n  lua_push_int_table_entry(vm,  \"seen.last\", getTimeLastPktRcvd());\n  lua_push_bool_table_entry(vm, \"sprobe\", get_sprobe_interface());\n  lua_push_bool_table_entry(vm, \"inline\", get_inline_interface());\n  lua_push_bool_table_entry(vm, \"vlan\",   get_has_vlan_packets());\n\n  if(remoteIfname)      lua_push_str_table_entry(vm, \"remote.name\",    remoteIfname);\n  if(remoteIfIPaddr)    lua_push_str_table_entry(vm, \"remote.if_addr\", remoteIfIPaddr);\n  if(remoteProbeIPaddr) lua_push_str_table_entry(vm, \"probe.ip\", remoteProbeIPaddr);\n  if(remoteProbePublicIPaddr) lua_push_str_table_entry(vm, \"probe.public_ip\", remoteProbePublicIPaddr);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"packets\",     getNumPackets());\n  lua_push_int_table_entry(vm, \"bytes\",       getNumBytes());\n  lua_push_int_table_entry(vm, \"flows\",       getNumFlows());\n  lua_push_int_table_entry(vm, \"hosts\",       getNumHosts());\n  lua_push_int_table_entry(vm, \"http_hosts\",  getNumHTTPHosts());\n  lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops());\n  lua_push_int_table_entry(vm, \"devices\", numL2Devices);\n  /* even if the counter is global, we put it here on every interface\n     as we may decide to make an elasticsearch thread per interface.\n   */\n  if(ntop->getPrefs()->do_dump_flows_on_es()) {\n    ntop->getElasticSearch()->lua(vm, false /* Overall */);\n  } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    if(db) db->lua(vm, false /* Overall */);\n  }\n  lua_pushstring(vm, \"stats\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"packets\",     getNumPackets() - getCheckPointNumPackets());\n  lua_push_int_table_entry(vm, \"bytes\",       getNumBytes() - getCheckPointNumBytes());\n  lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops() - getCheckPointNumPacketDrops());\n  if(ntop->getPrefs()->do_dump_flows_on_es()) {\n    ntop->getElasticSearch()->lua(vm, true /* Since last checkpoint */);\n  } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    if(db) db->lua(vm, true /* Since last checkpoint */);\n  }\n  lua_pushstring(vm, \"stats_since_reset\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  lua_push_int_table_entry(vm, \"remote_pps\", last_remote_pps);\n  lua_push_int_table_entry(vm, \"remote_bps\", last_remote_bps);\n\n  lua_push_str_table_entry(vm, \"type\", (char*)get_type());\n  lua_push_int_table_entry(vm, \"speed\", ifSpeed);\n  lua_push_int_table_entry(vm, \"mtu\", ifMTU);\n  lua_push_int_table_entry(vm, \"alertLevel\", alertLevel);\n  lua_push_str_table_entry(vm, \"ip_addresses\", (char*)getLocalIPAddresses());\n\n  sumStats(&_tcpFlowStats, &_ethStats, &_localStats,\n\t   &_ndpiStats, &_pktStats, &_tcpPacketStats);\n\n  for(u_int8_t s = 0; s<numSubInterfaces; s++)\n    subInterfaces[s]->sumStats(&_tcpFlowStats, &_ethStats,\n\t\t\t       &_localStats, &_ndpiStats, &_pktStats, &_tcpPacketStats);\n\n  _tcpFlowStats.lua(vm, \"tcpFlowStats\");\n  _ethStats.lua(vm);\n  _localStats.lua(vm);\n  _ndpiStats.lua(this, vm);\n  _pktStats.lua(vm, \"pktSizeDistribution\");\n  _tcpPacketStats.lua(vm, \"tcpPacketStats\");\n\n  if(!isView()) {\n    if(pkt_dumper)    pkt_dumper->lua(vm);\n#ifdef NTOPNG_PRO\n    if(flow_profiles) flow_profiles->lua(vm);\n#endif\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::runHousekeepingTasks() {\n  /* NOTE NOTE NOTE\n\n     This task runs asynchronously with respect to ntopng\n     so if you need to allocate memory you must LOCK\n\n     Example HTTPStats::updateHTTPHostRequest() is called\n     by both this function and the main thread\n  */\n\n  periodicStatsUpdate();\n}\n\n/* **************************************************** */\n\nMac* NetworkInterface::getMac(u_int8_t _mac[6], u_int16_t vlanId,\n\t\t\t      bool createIfNotPresent) {\n  Mac *ret = NULL;\n\n  if(_mac == NULL) return(NULL);\n\n  if(!isView())\n    ret = macs_hash->get(vlanId, _mac);\n  else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if((ret = subInterfaces[s]->get_macs_hash()->get(vlanId, _mac)) != NULL)\n\tbreak;\n    }\n  }\n\n  if((ret == NULL) && createIfNotPresent) {\n    try {\n      if((ret = new Mac(this, _mac, vlanId)) != NULL)\n\tmacs_hash->add(ret);\n    } catch(std::bad_alloc& ba) {\n      static bool oom_warning_sent = false;\n\n      if(!oom_warning_sent) {\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\toom_warning_sent = true;\n      }\n\n      return(NULL);\n    }\n  }\n\n  return(ret);\n}\n\n/* **************************************************** */\n\nFlow* NetworkInterface::findFlowByKey(u_int32_t key,\n\t\t\t\t      AddressTree *allowed_hosts) {\n  Flow *f;\n\n  if(!isView())\n    f = (Flow*)(flows_hash->findByKey(key));\n  else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      f = (Flow*)subInterfaces[s]->get_flows_hash()->findByKey(key);\n      if(f) break;\n    }\n  }\n\n  if(f && (!f->match(allowed_hosts))) f = NULL;\n  return(f);\n}\n\n/* **************************************************** */\n\nstruct search_host_info {\n  lua_State *vm;\n  char *host_name_or_ip;\n  u_int num_matches;\n  AddressTree *allowed_hosts;\n};\n\n/* **************************************************** */\n\nstatic bool hosts_search_walker(GenericHashEntry *h, void *user_data) {\n  Host *host = (Host*)h;\n  struct search_host_info *info = (struct search_host_info*)user_data;\n\n  if(host->addIfMatching(info->vm, info->allowed_hosts, info->host_name_or_ip))\n    info->num_matches++;\n\n  /* Stop after CONST_MAX_NUM_FIND_HITS matches */\n  return((info->num_matches > CONST_MAX_NUM_FIND_HITS) ? true /* stop */ : false /* keep walking */);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::findHostsByName(lua_State* vm,\n\t\t\t\t       AddressTree *allowed_hosts,\n\t\t\t\t       char *key) {\n  struct search_host_info info;\n\n  info.vm = vm, info.host_name_or_ip = key, info.num_matches = 0, info.allowed_hosts = allowed_hosts;\n\n  lua_newtable(vm);\n  walker(walker_hosts, hosts_search_walker, (void*)&info);\n  return(info.num_matches > 0);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::validInterface(char *name) {\n  if(name &&\n     (strstr(name, \"PPP\")            /* Avoid to use the PPP interface              */\n      || strstr(name, \"dialup\")      /* Avoid to use the dialup interface           */\n      || strstr(name, \"ICSHARE\")     /* Avoid to use the internet sharing interface */\n      || strstr(name, \"NdisWan\"))) { /* Avoid to use the internet sharing interface */\n    return(false);\n  }\n\n  return(true);\n}\n\n/* **************************************************** */\n\nu_int NetworkInterface::printAvailableInterfaces(bool printHelp, int idx,\n\t\t\t\t\t\t char *ifname, u_int ifname_len) {\n  char ebuf[256];\n  int numInterfaces = 0;\n  pcap_if_t *devpointer;\n\n  if(printHelp && help_printed)\n    return(0);\n\n  ebuf[0] = '\\0';\n\n  if(pcap_findalldevs(&devpointer, ebuf) < 0) {\n    ;\n  } else {\n    if(ifname == NULL) {\n      if(printHelp)\n\tprintf(\"Available interfaces (-i <interface index>):\\n\");\n      else if(!help_printed)\n\tntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t     \"Available interfaces (-i <interface index>):\");\n    }\n\n    for(int i = 0; devpointer != NULL; i++) {\n      if(validInterface(devpointer->description)) {\n\tnumInterfaces++;\n\n\tif(ifname == NULL) {\n\t  if(printHelp) {\n#ifdef WIN32\n\t    printf(\"   %d. %s\\n\"\n\t\t   \"\\t%s\\n\", numInterfaces,\n\t\t   devpointer->description ? devpointer->description : \"\",\n\t\t   devpointer->name);\n#else\n\t    printf(\"   %d. %s\\n\", numInterfaces, devpointer->name);\n#endif\n\t  } else if(!help_printed)\n\t    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%d. %s (%s)\\n\",\n\t\t\t\t\t numInterfaces, devpointer->name,\n\t\t\t\t\t devpointer->description ? devpointer->description : devpointer->name);\n\t} else if(numInterfaces == idx) {\n\t  snprintf(ifname, ifname_len, \"%s\", devpointer->name);\n\t  break;\n\t}\n      }\n\n      devpointer = devpointer->next;\n    } /* for */\n  } /* else */\n\n  if(numInterfaces == 0) {\n#ifdef WIN32\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available! This application cannot work\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Make sure that winpcap is installed properly,\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"that you have administrative rights,\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"and that you have network interfaces installed.\");\n#else\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available: are you superuser?\");\n#endif\n  }\n\n  help_printed = true;\n\n  return(numInterfaces);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::isNumber(const char *str) {\n  while(*str) {\n    if(!isdigit(*str))\n      return(false);\n\n    str++;\n  }\n\n  return(true);\n}\n\n/* **************************************************** */\n\nstruct correlator_host_info {\n  lua_State* vm;\n  Host *h;\n  activity_bitmap x;\n};\n\nstatic bool correlator_walker(GenericHashEntry *node, void *user_data) {\n  Host *h = (Host*)node;\n  struct correlator_host_info *info = (struct correlator_host_info*)user_data;\n\n  if(h\n     // && h->isLocalHost() /* Consider only local hosts */\n     && h->get_ip()\n     && (h != info->h)) {\n    char buf[32], *name = h->get_ip()->print(buf, sizeof(buf));\n    activity_bitmap y;\n    double pearson;\n\n    h->getActivityStats()->extractPoints(&y);\n\n    pearson = Utils::pearsonValueCorrelation(&(info->x), &y);\n\n    /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s: %f\", name, pearson); */\n    lua_push_float_table_entry(info->vm, name, (float)pearson);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\nstatic bool similarity_walker(GenericHashEntry *node, void *user_data) {\n  Host *h = (Host*)node;\n  struct correlator_host_info *info = (struct correlator_host_info*)user_data;\n\n  if(h\n     // && h->isLocalHost() /* Consider only local hosts */\n     && h->get_ip()\n     && (h != info->h)) {\n    char buf[32], name[64];\n\n    if(h->get_vlan_id() == 0) {\n      sprintf(name, \"%s\",h->get_ip()->print(buf, sizeof(buf)));\n    } else {\n      sprintf(name, \"%s@%d\",h->get_ip()->print(buf, sizeof(buf)),h->get_vlan_id());\n    }\n\n    activity_bitmap y;\n    double jaccard;\n\n    h->getActivityStats()->extractPoints(&y);\n\n    jaccard = Utils::JaccardSimilarity(&(info->x), &y);\n\n    /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s: %f\", name, pearson); */\n    lua_push_float_table_entry(info->vm, name, (float)jaccard);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::correlateHostActivity(lua_State* vm,\n\t\t\t\t\t     AddressTree *allowed_hosts,\n\t\t\t\t\t     char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, correlator_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::similarHostActivity(lua_State* vm,\n\t\t\t\t\t   AddressTree *allowed_hosts,\n\t\t\t\t\t   char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, similarity_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}\n\n/* **************************************************** */\n\nstruct user_flows {\n  lua_State* vm;\n  char *username;\n};\n\nstatic bool userfinder_walker(GenericHashEntry *node, void *user_data) {\n  Flow *f = (Flow*)node;\n  struct user_flows *info = (struct user_flows*)user_data;\n  char *user = f->get_username(true);\n\n  if(user == NULL)\n    user = f->get_username(false);\n\n  if(user && (strcmp(user, info->username) == 0)) {\n    f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n    lua_pushnumber(info->vm, f->key()); // Key\n    lua_insert(info->vm, -2);\n    lua_settable(info->vm, -3);\n  }\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::findUserFlows(lua_State *vm, char *username) {\n  struct user_flows u;\n\n  u.vm = vm, u.username = username;\n  walker(walker_flows, userfinder_walker, &u);\n}\n\n/* **************************************************** */\n\nstruct proc_name_flows {\n  lua_State* vm;\n  char *proc_name;\n};\n\nstatic bool proc_name_finder_walker(GenericHashEntry *node, void *user_data) {\n  Flow *f = (Flow*)node;\n  struct proc_name_flows *info = (struct proc_name_flows*)user_data;\n  char *name = f->get_proc_name(true);\n\n  if(name && (strcmp(name, info->proc_name) == 0)) {\n      f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n      lua_pushnumber(info->vm, f->key()); // Key\n      lua_insert(info->vm, -2);\n      lua_settable(info->vm, -3);\n  } else {\n    name = f->get_proc_name(false);\n\n    if(name && (strcmp(name, info->proc_name) == 0)) {\n        f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n        lua_pushnumber(info->vm, f->key()); // Key\n        lua_insert(info->vm, -2);\n        lua_settable(info->vm, -3);\n    }\n  }\n\n  return(false); /* false = keep on walking */\n}\n\nvoid NetworkInterface::findProcNameFlows(lua_State *vm, char *proc_name) {\n  struct proc_name_flows u;\n\n  u.vm = vm, u.proc_name = proc_name;\n  walker(walker_flows, proc_name_finder_walker, &u);\n}\n\n/* **************************************************** */\n\nstruct pid_flows {\n  lua_State* vm;\n  u_int32_t pid;\n};\n\nstatic bool pidfinder_walker(GenericHashEntry *node, void *pid_data) {\n  Flow *f = (Flow*)node;\n  struct pid_flows *info = (struct pid_flows*)pid_data;\n\n  if((f->getPid(true) == info->pid) || (f->getPid(false) == info->pid)) {\n    f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n    lua_pushnumber(info->vm, f->key()); // Key\n    lua_insert(info->vm, -2);\n    lua_settable(info->vm, -3);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::findPidFlows(lua_State *vm, u_int32_t pid) {\n  struct pid_flows u;\n\n  u.vm = vm, u.pid = pid;\n  walker(walker_flows, pidfinder_walker, &u);\n}\n\n/* **************************************** */\n\nstatic bool father_pidfinder_walker(GenericHashEntry *node, void *father_pid_data) {\n  Flow *f = (Flow*)node;\n  struct pid_flows *info = (struct pid_flows*)father_pid_data;\n\n  if((f->getFatherPid(true) == info->pid) || (f->getFatherPid(false) == info->pid)) {\n    f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n    lua_pushnumber(info->vm, f->key()); // Key\n    lua_insert(info->vm, -2);\n    lua_settable(info->vm, -3);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::findFatherPidFlows(lua_State *vm, u_int32_t father_pid) {\n  struct pid_flows u;\n\n  u.vm = vm, u.pid = father_pid;\n  walker(walker_flows, father_pidfinder_walker, &u);\n}\n\n/* **************************************** */\n\nstruct virtual_host_valk_info {\n  lua_State *vm;\n  char *key;\n  u_int32_t num;\n};\n\nstatic bool virtual_http_hosts_walker(GenericHashEntry *node, void *data) {\n  Host *h = (Host*)node;\n  struct virtual_host_valk_info *info = (struct virtual_host_valk_info*)data;\n  HTTPstats *s = h->getHTTPstats();\n\n  if(s)\n    info->num += s->luaVirtualHosts(info->vm, info->key, h);\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::listHTTPHosts(lua_State *vm, char *key) {\n  struct virtual_host_valk_info info;\n\n  lua_newtable(vm);\n\n  info.vm = vm, info.key = key, info.num = 0;\n  walker(walker_hosts, virtual_http_hosts_walker, &info);\n}\n\n/* **************************************** */\n\nbool NetworkInterface::isInterfaceUp(char *name) {\n#ifdef WIN32\n  return(true);\n#else\n  struct ifreq ifr;\n  int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);\n\n  if(strlen(name) >= sizeof(ifr.ifr_name))\n    return(false);\n\n  memset(&ifr, 0, sizeof(ifr));\n  strcpy(ifr.ifr_name, name);\n  if(ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {\n    closesocket(sock);\n    return(false);\n  }\n  closesocket(sock);\n  return(!!(ifr.ifr_flags & IFF_UP));\n#endif\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::addAllAvailableInterfaces() {\n  char ebuf[256] = { '\\0' };\n  pcap_if_t *devpointer;\n\n  if(pcap_findalldevs(&devpointer, ebuf) < 0) {\n    ;\n  } else {\n    for(int i = 0; devpointer != 0; i++) {\n      if(validInterface(devpointer->description)\n\t && isInterfaceUp(devpointer->name)) {\n\tntop->getPrefs()->add_network_interface(devpointer->name,\n\t\t\t\t\t\tdevpointer->description);\n      } else\n\tntop->getTrace()->traceEvent(TRACE_INFO, \"Interface [%s][%s] not valid or down: discarded\",\n\t\t\t\t     devpointer->name, devpointer->description);\n\n      devpointer = devpointer->next;\n    } /* for */\n    pcap_freealldevs(devpointer);\n  }\n}\n\n/* **************************************** */\n\n#ifdef NTOPNG_PRO\nvoid NetworkInterface::refreshL7Rules() {\n  if(ntop->getPro()->has_valid_license() && policer)\n    policer->refreshL7Rules();\n}\n#endif\n\n/* **************************************** */\n\n#ifdef NTOPNG_PRO\nvoid NetworkInterface::refreshShapers() {\n  if(ntop->getPro()->has_valid_license() && policer)\n    policer->refreshShapers();\n}\n#endif\n\n/* **************************************** */\n\nvoid NetworkInterface::addInterfaceAddress(char *addr) {\n  if(ip_addresses.size() == 0)\n    ip_addresses = addr;\n  else {\n    string s = addr;\n\n    ip_addresses = ip_addresses + \",\" + s;\n  }\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::allocateNetworkStats() {\n  u_int8_t numNetworks = ntop->getNumLocalNetworks();\n\n  try {\n    networkStats = new NetworkStats[numNetworks];\n  } catch(std::bad_alloc& ba) {\n    static bool oom_warning_sent = false;\n\n    if(!oom_warning_sent) {\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      oom_warning_sent = true;\n    }\n\n    networkStats = NULL;\n  }\n}\n\n/* **************************************** */\n\nNetworkStats* NetworkInterface::getNetworkStats(u_int8_t networkId) {\n  if((networkStats == NULL) || (networkId >= ntop->getNumLocalNetworks()))\n    return(NULL);\n  else\n    return(&networkStats[networkId]);\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::updateSecondTraffic(time_t when) {\n  u_int64_t bytes = ethStats.getNumBytes();\n  u_int16_t sec = when % 60;\n\n  if(sec == 0) {\n    /* Beginning of a new minute */\n    memcpy(lastMinuteTraffic, currentMinuteTraffic, sizeof(currentMinuteTraffic));\n    resetSecondTraffic();\n  }\n\n  currentMinuteTraffic[sec] = max_val(0, bytes-lastSecTraffic);\n  lastSecTraffic = bytes;\n};\n\n/* **************************************** */\n\nvoid NetworkInterface::checkPointCounters(bool drops_only) {\n  if(!drops_only) {\n    checkpointPktCount = getNumPackets(),\n      checkpointBytesCount = getNumBytes();\n  }\n  checkpointPktDropCount = getNumPacketDrops();\n\n  if(ntop->getPrefs()->do_dump_flows_on_es()) {\n    ntop->getElasticSearch()->checkPointCounters(drops_only);\n  } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    if(db) db->checkPointCounters(drops_only);\n  }\n}\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getCheckPointNumPackets() {\n  u_int64_t tot = checkpointPktCount;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPackets();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getCheckPointNumBytes() {\n  u_int64_t tot = checkpointBytesCount;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumBytes();\n  return(tot);\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getCheckPointNumPacketDrops() {\n  u_int32_t tot = checkpointPktDropCount;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPacketDrops();\n  return(tot);\n};\n\n/* **************************************** */\n\nvoid NetworkInterface::setRemoteStats(char *name, char *address, u_int32_t speedMbit,\n\t\t\t\t      char *remoteProbeAddress, char *remoteProbePublicAddress,\n\t\t\t\t      u_int64_t remBytes, u_int64_t remPkts,\n\t\t\t\t      u_int32_t remTime, u_int32_t last_pps, u_int32_t last_bps) {\n  if(name)               setRemoteIfname(name);\n  if(address)            setRemoteIfIPaddr(address);\n  if(remoteProbeAddress) setRemoteProbeAddr(remoteProbeAddress);\n  if(remoteProbePublicAddress) setRemoteProbePublicAddr(remoteProbePublicAddress);\n  ifSpeed = speedMbit, last_pkt_rcvd_remote = remTime, last_remote_pps = last_pps, last_remote_bps = last_bps;\n\n  if((zmq_initial_pkts == 0) /* ntopng has been restarted */\n     || (remBytes < zmq_initial_bytes) /* nProbe has been restarted */\n     ) {\n    /* Start over */\n    zmq_initial_bytes = remBytes, zmq_initial_pkts = remPkts;\n  } else {\n    remBytes -= zmq_initial_bytes, remPkts -= zmq_initial_pkts;\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][bytes=%u/%u (%d)][pkts=%u/%u (%d)]\",\n\t\t\t\t ifname, remBytes, ethStats.getNumBytes(), remBytes-ethStats.getNumBytes(),\n\t\t\t\t remPkts, ethStats.getNumPackets(), remPkts-ethStats.getNumPackets());\n    /*\n     * Don't override ethStats here, these stats are properly updated\n     * inside NetworkInterface::processFlow for ZMQ interfaces.\n     * Overriding values here may cause glitches and non-strictly-increasing counters\n     * yielding negative rates.\n    ethStats.setNumBytes(remBytes), ethStats.setNumPackets(remPkts);\n     *\n    */\n  }\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::processInterfaceStats(sFlowInterfaceStats *stats) {\n  if(interfaceStats == NULL)\n    interfaceStats = new InterfaceStatsHash(NUM_IFACE_STATS_HASH);\n\n  if(interfaceStats) {\n    char a[64];\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][ifIndex=%u]\",\n\t\t\t\t Utils::intoaV4(stats->deviceIP, a, sizeof(a)),\n\t\t\t\t stats->ifIndex);\n\n    interfaceStats->set(stats->deviceIP, stats->ifIndex, stats);\n  }\n}\n\n/* **************************************** */\n\nndpi_protocol_category_t NetworkInterface::get_ndpi_proto_category(u_int protoid) {\n  ndpi_protocol proto;\n  proto.protocol = NDPI_PROTOCOL_UNKNOWN;\n  proto.master_protocol = protoid;\n  return get_ndpi_proto_category(proto);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_ndpi_category(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, ndpi_category_str(f->get_detected_protocol_category()));\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_ndpi_proto(lua_State* vm) {\n  Flow *f;\n  char buf[32];\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, f->get_detected_protocol_name(buf, sizeof(buf)));\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_ndpi_proto_id(lua_State* vm) {\n  Flow *f;\n  ndpi_protocol p;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR); else p = f->get_detected_protocol();\n\n  lua_pushnumber(vm, (p.protocol != NDPI_PROTOCOL_UNKNOWN) ? p.protocol : p.master_protocol);\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_first_seen(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushnumber(vm, f->get_first_seen());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_last_seen(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushnumber(vm, f->get_last_seen());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_server_name(lua_State* vm) {\n  Flow *f;\n  char buf[64];\n  const char *srv;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  srv = f->getFlowServerInfo();\n  if(!srv && f->get_srv_host())\n    srv = f->get_srv_host()->get_name(buf, sizeof(buf), false);\n  if(!srv) srv = \"\";\n\n  lua_pushstring(vm, srv);\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_http_url(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, f->getHTTPURL());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_http_content_type(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, f->getHTTPContentType());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_dump(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  f->lua(vm, NULL, details_high, false);\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\n/* -1 on error */\nstatic int lua_flow_get_profile_id(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  UserActivityID uaid;\n  lua_pushnumber(vm, f->getActivityId(&uaid) ? uaid : -1);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/* -1 on error */\nstatic int lua_flow_get_activity_filter_id(lua_State* vm) {\n  Flow * f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  ActivityFilterID fid;\n  lua_pushnumber(vm, f->getActivityFilterId(&fid) ? fid : -1);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/*\n * lua params:\n *    activityID  - ID of the activity to apply for filtered bytes\n *    filterID    - ID of the filter to apply to the flow for activity recording\n *    *parametes  - parameters to pass to the filter - See below\n *\n * SMA/WMA filter params:\n *    edge         - moving average edge to trigger activity\n *    minsamples   - minimum number of samples for activity detection\n * WMA filter params:\n *    timescale    - division scale for each second difference from previous packet. 0 to disable\n *    aggrsecs     - max packet seconds difference to aggregate. 0 to disable\n * SMA filter params:\n *    timebound    - expected time tick in milliseconds between activity packets. 0 to disable\n *    sustain      - time, in milliseconds, between packets to be considered activity. 0 to disable\n *\n * CommandSequence filter params:\n *    mustwait     - if true, activity trigger requires server to wait after command request\n *    minbytes     - minimum number of bytes to trigger activity\n *    maxinterval  - maximum milliseconds difference between interactions\n *    mincommands  - minimum number of commands seen in the flow to trigger activity\n *    minflips     - minimum number of server interactions to trigger activity\n *\n * Web filter params:\n *    numsamples   - number of packets to process for detection\n *    minbytes     - minimum number of bytes to trigger activity\n *    maxinterval  - maximum milliseconds difference between packets\n *    serverdominant - if true, server bytes must be more then client bytes\n *    forceWebProfile - if true, force 'web' profile for unknown and 'other' flow profiles\n *\n * Ratio filter params:\n *    numsamples   - number of packets to process for detection\n *    minbytes     - minimum number of bytes to trigger activity\n *    clisrv_ratio - minimum (positive ? client/server : server/client) bytes to trigger activity\n *\n * Interflow filter params:\n *    minflows     - minimum number of concurrent flows. -1 to disable [1]\n *    minpkts      - minimum number of cumulative packets in concurrent flows to trigger activity\n *    minduration  - minimum (max duration of cumulative packets) in concurrent flows. -1 to disable [1]\n *    sslonly      - if true, only SSL traffic can trigger activity\n *   NOTE: At least one of [1] must be satisfied to trigger activity\n */\nstatic int lua_flow_set_activity_filter(lua_State* vm) {\n  UserActivityID activityID;\n  ActivityFilterID filterID;\n  Flow *f;\n  activity_filter_config config = {};\n  u_int8_t params = 0;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, params+1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  activityID = (UserActivityID)lua_tonumber(vm, ++params);\n  if(activityID >= UserActivitiesN) return(CONST_LUA_ERROR);\n\n  if(lua_type(vm, params+1) == LUA_TNUMBER)\n    filterID = (ActivityFilterID)lua_tonumber(vm, ++params);\n  else\n    return(CONST_LUA_ERROR);\n\n  // filter specific parameters\n  switch(filterID) {\n    case activity_filter_all:\n      if(lua_type(vm, params+1) == LUA_TBOOLEAN) {\n        config.all.pass = lua_toboolean(vm, ++params);\n      }\n      switch (params) {\n        case 2+0: config.all.pass = true;\n      }\n      break;\n\n    case activity_filter_web:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.web.numsamples = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.web.minbytes = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.web.maxinterval = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TBOOLEAN) {\n              config.web.forceWebProfile = lua_toboolean(vm, ++params);\n\n              if(lua_type(vm, params+1) == LUA_TBOOLEAN)\n                config.web.serverdominant = lua_toboolean(vm, ++params);\n            }\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.web.numsamples = 4;\n        case 2+1: config.web.minbytes = 0;\n        case 2+2: config.web.maxinterval = 2000;\n        case 2+3: config.web.forceWebProfile = true;\n        case 2+4: config.web.serverdominant = true;\n      }\n      break;\n\n    case activity_filter_ratio:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.ratio.numsamples = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.ratio.minbytes = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER)\n            config.ratio.clisrv_ratio = lua_tonumber(vm, ++params);\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.ratio.numsamples = 4;\n        case 2+1: config.ratio.minbytes = 0;\n        case 2+2: config.ratio.clisrv_ratio = -1.f;\n      }\n      break;\n\n    case activity_filter_interflow:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.interflow.minflows = min((int)lua_tonumber(vm, ++params), INTER_FLOW_ACTIVITY_SLOTS);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.interflow.minpkts = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.interflow.minduration = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TBOOLEAN)\n              config.interflow.sslonly = lua_toboolean(vm, ++params);\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.interflow.minflows = INTER_FLOW_ACTIVITY_SLOTS;\n        case 2+1: config.interflow.minpkts = 200;\n        case 2+2: config.interflow.minduration = -1;\n        case 2+3: config.interflow.sslonly = false;\n      }\n      break;\n\n    case activity_filter_metrics_test:\n      break;\n\n    case activity_filter_sma:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.sma.edge = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.sma.minsamples = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.sma.timebound = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TNUMBER)\n              config.sma.sustain = lua_tonumber(vm, ++params);\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.sma.edge = 0;\n        case 2+1: config.sma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;\n        case 2+2: config.sma.timebound = 2000;\n        case 2+3: config.sma.sustain = 1000;\n      }\n      break;\n\n    case activity_filter_wma:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.wma.edge = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.wma.minsamples = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.wma.timescale = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TNUMBER)\n              config.wma.aggrsecs = lua_tonumber(vm, ++params);\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.wma.edge = 0;\n        case 2+1: config.wma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;\n        case 2+2: config.wma.timescale = 1.f;\n        case 2+3: config.wma.aggrsecs = 0;\n      }\n      break;\n\n    case activity_filter_command_sequence:\n      if(lua_type(vm, params+1) == LUA_TBOOLEAN) {\n        config.command_sequence.mustwait = lua_toboolean(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.command_sequence.minbytes = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.command_sequence.maxinterval = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TNUMBER) {\n              config.command_sequence.mincommands = lua_tonumber(vm, ++params);\n\n              if(lua_type(vm, params+1) == LUA_TNUMBER)\n                config.command_sequence.minflips = lua_tonumber(vm, ++params);\n            }\n          }\n        }\n      }\n      switch (params) {\n        case 2+0: config.command_sequence.mustwait = false;\n        case 2+1: config.command_sequence.minbytes = 0;\n        case 2+2: config.command_sequence.maxinterval = 3000;\n        case 2+3: config.command_sequence.mincommands = 1;\n        case 2+4: config.command_sequence.minflips = 1;\n      }\n      break;\n\n    default:\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid activity filter (%d)\", filterID);\n      return (CONST_LUA_ERROR);\n  }\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"Flow %p setActivityFilter: filter=%d activity=%d\", f, filterID, activityID);\n  f->setActivityFilter(filterID, &config);\n  f->setActivityId(activityID);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic const luaL_Reg flow_reg[] = {\n  { \"getNdpiCategory\",   lua_flow_get_ndpi_category },\n  { \"getNdpiProto\",      lua_flow_get_ndpi_proto },\n  { \"getNdpiProtoId\",    lua_flow_get_ndpi_proto_id },\n  { \"getFirstSeen\",      lua_flow_get_first_seen },\n  { \"getLastSeen\",       lua_flow_get_last_seen },\n  { \"getServerName\",     lua_flow_get_server_name },\n  { \"getHTTPUrl\",        lua_flow_get_http_url },\n  { \"getHTTPContentType\",lua_flow_get_http_content_type },\n  { \"dump\",              lua_flow_dump },\n  { \"setActivityFilter\", lua_flow_set_activity_filter },\n  { \"getProfileId\",      lua_flow_get_profile_id },\n  { \"getActivityFilterId\", lua_flow_get_activity_filter_id },\n  { NULL,         NULL }\n};\n\nntop_class_reg ntop_lua_reg[] = {\n  { \"flow\",   flow_reg  },\n  {NULL,      NULL}\n};\n\nlua_State* NetworkInterface::initLuaInterpreter(const char *lua_file) {\n  static const luaL_Reg _meta[] = { { NULL, NULL } };\n  int i;\n  char script_path[256];\n  lua_State *L;\n\n  L = luaL_newstate();\n\n  if(!L) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to initialize lua interpreter\");\n    return(NULL);\n  }\n\n  snprintf(script_path, sizeof(script_path), \"%s/%s\",\n\t   ntop->getPrefs()->get_callbacks_dir(),\n\t   lua_file);\n\n  /* ******************************************** */\n\n  luaL_openlibs(L); /* Load base libraries */\n\n  for(i=0; ntop_lua_reg[i].class_name != NULL; i++) {\n    int lib_id, meta_id;\n\n    /* newclass = {} */\n    lua_createtable(L, 0, 0);\n    lib_id = lua_gettop(L);\n\n    /* metatable = {} */\n    luaL_newmetatable(L, ntop_lua_reg[i].class_name);\n    meta_id = lua_gettop(L);\n    luaL_register(L, NULL, _meta);\n\n    /* metatable.__index = class_methods */\n    lua_newtable(L), luaL_register(L, NULL, ntop_lua_reg[i].class_methods);\n    lua_setfield(L, meta_id, \"__index\");\n\n    /* class.__metatable = metatable */\n    lua_setmetatable(L, lib_id);\n\n    /* _G[\"Foo\"] = newclass */\n    lua_setglobal(L, ntop_lua_reg[i].class_name);\n  }\n\n  lua_register(L, \"print\", ntop_lua_cli_print);\n\n  // Activity profiles - see ntop_typedefs.h\n  lua_newtable(L);\n  for(int i=0; i<UserActivitiesN; i++)\n    lua_push_int_table_entry(L, activity_names[i], i);\n  lua_setglobal(L, CONST_USERACTIVITY_PROFILES);\n\n  // Activity filters\n  lua_newtable(L);\n  lua_push_int_table_entry(L, \"All\", activity_filter_all);\n  lua_push_int_table_entry(L, \"SMA\", activity_filter_sma);\n  lua_push_int_table_entry(L, \"WMA\", activity_filter_wma);\n  lua_push_int_table_entry(L, \"CommandSequence\", activity_filter_command_sequence);\n  lua_push_int_table_entry(L, \"Web\", activity_filter_web);\n  lua_push_int_table_entry(L, \"Ratio\", activity_filter_ratio);\n  lua_push_int_table_entry(L, \"Interflow\", activity_filter_interflow);\n  lua_push_int_table_entry(L, \"Metrics\", activity_filter_metrics_test);\n  lua_setglobal(L, CONST_USERACTIVITY_FILTERS);\n\n  if(luaL_loadfile(L, script_path) || lua_pcall(L, 0, 0, 0)) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Cannot run lua file %s: %s\",\n\t\t\t\t script_path, lua_tostring(L, -1));\n    lua_close(L);\n    L = NULL;\n  } else {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Successfully interpreted %s\", script_path);\n\n    lua_pushlightuserdata(L, NULL);\n    lua_setglobal(L, CONST_USERACTIVITY_FLOW);\n  }\n\n  return(L);\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::termLuaInterpreter() {\n  if(L_flow_create_delete_ndpi) { lua_close(L_flow_create_delete_ndpi); L_flow_create_delete_ndpi = NULL; }\n  if(L_flow_update) { lua_close(L_flow_update); L_flow_update = NULL; }\n}\n\n/* **************************************** */\n\nint NetworkInterface::luaEvalFlow(Flow *f, const LuaCallback cb) {\n  int rc;\n  lua_State *L;\n  const char *luaFunction;\n\n  return(0); // FIX\n  if(reloadLuaInterpreter) {\n    if(L_flow_create_delete_ndpi || L_flow_update) termLuaInterpreter();\n    L_flow_create_delete_ndpi = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);\n    L_flow_update = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);\n    reloadLuaInterpreter = false;\n  }\n\n  switch(cb) {\n  case callback_flow_create:\n    L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_CREATE;\n    break;\n\n  case callback_flow_delete:\n    L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_DELETE;\n    break;\n\n  case callback_flow_update:\n    L = L_flow_update, luaFunction = CONST_LUA_FLOW_UPDATE;\n    break;\n\n  case callback_flow_proto_callback:\n    L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_NDPI_DETECT;\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid lua callback (%d)\", cb);\n    return(-1);\n  }\n\n  if(L == NULL)\n    return(-2);\n\n  lua_settop(L, 0); /* Reset stack */\n  lua_pushlightuserdata(L, f);\n  lua_setglobal(L, CONST_USERACTIVITY_FLOW);\n\n  lua_getglobal(L, luaFunction); /* function to be called */\n  if((rc = lua_pcall(L, 0 /* 0 parameters */, 0 /* no return values */, 0)) != 0) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Error while executing %s [rc=%d][%s]\", luaFunction, rc, lua_tostring(L, -1));\n  }\n\n  return(rc);\n}\n\n/* **************************************** */\n\nint NetworkInterface::getActiveMacList(lua_State* vm, u_int16_t vlan_id,\n\t\t\t\t       bool skipSpecialMacs,\n\t\t\t\t       bool hostMacsOnly,\n\t\t\t\t       char *sortColumn, u_int32_t maxHits,\n\t\t\t\t       u_int32_t toSkip, bool a2zSortOrder) {\n  struct flowHostRetriever retriever;\n  bool show_details = true;\n\n  disablePurge(false);\n\n  if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, sortColumn) < 0) {\n    enablePurge(false);\n    return -1;\n  }\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"numMacs\", retriever.actNumEntries);\n\n  lua_newtable(vm);\n\n  if(a2zSortOrder) {\n    for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {\n      Mac *m = retriever.elems[i].macValue;\n\n      m->lua(vm, show_details, false);\n      lua_rawseti(vm, -2, num + 1); /* Must use integer keys to preserve and iterate inorder with ipairs */\n    }\n  } else {\n    for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {\n      Mac *m = retriever.elems[i].macValue;\n\n      m->lua(vm, show_details, false);\n      lua_rawseti(vm, -2, num + 1);\n    }\n  }\n\n  lua_pushstring(vm, \"macs\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  enablePurge(false);\n\n  // finally free the elements regardless of the sorted kind\n  if(retriever.elems) free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************** */\n\nbool NetworkInterface::getMacInfo(lua_State* vm, char *mac, u_int16_t vlan_id) {\n  struct mac_find_info info;\n\n  memset(&info, 0, sizeof(info));\n  Utils::parseMac(info.mac, mac), info.vlan_id = vlan_id;\n\n  walker(walker_macs, find_mac_by_name, (void*)&info);\n\n  if(info.m) {\n    info.m->lua(vm, true, false);\n\n    return(true);\n  } else\n    return(false);\n}\n\n\n"], "fixing_code": ["/*\n *\n * (C) 2013-17 - ntop.org\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"ntop_includes.h\"\n\n#ifndef _GETOPT_H\n#define _GETOPT_H\n#endif\n\n#ifndef LIB_VERSION\n#define LIB_VERSION \"1.4.7\"\n#endif\n\nextern \"C\" {\n#include \"rrd.h\"\n#ifdef HAVE_GEOIP\n  extern const char * GeoIP_lib_version(void);\n#endif\n\n#include \"../third-party/snmp/snmp.c\"\n#include \"../third-party/snmp/asn1.c\"\n#include \"../third-party/snmp/net.c\"\n};\n\n#include \"../third-party/lsqlite3/lsqlite3.c\"\n\nstruct keyval string_to_replace[MAX_NUM_HTTP_REPLACEMENTS] = { { NULL, NULL } };\n\n/* ******************************* */\n\nLua::Lua() {\n  L = luaL_newstate();\n\n  if(L == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to create Lua interpreter\");\n    return;\n  }\n}\n\n/* ******************************* */\n\nLua::~Lua() {\n  if(L) lua_close(L);\n}\n\n/* ******************************* */\n\n/**\n * @brief Check the expected type of lua function.\n * @details Find in the lua stack the function and check the function parameters types.\n *\n * @param vm The lua state.\n * @param func The function name.\n * @param pos Index of lua stack.\n * @param expected_type Index of expected type.\n * @return @ref CONST_LUA_ERROR if the expected type is equal to function type, @ref CONST_LUA_PARAM_ERROR otherwise.\n */\nint ntop_lua_check(lua_State* vm, const char* func, int pos, int expected_type) {\n  if(lua_type(vm, pos) != expected_type) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR,\n\t\t\t\t \"%s : expected %s, got %s\", func,\n\t\t\t\t lua_typename(vm, expected_type),\n\t\t\t\t lua_typename(vm, lua_type(vm,pos)));\n    return(CONST_LUA_PARAM_ERROR);\n  }\n\n  return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic void get_host_vlan_info(char* lua_ip, char** host_ip,\n\t\t\t       u_int16_t* vlan_id,\n\t\t\t       char *buf, u_int buf_len) {\n  char *where, *vlan = NULL;\n\n  snprintf(buf, buf_len, \"%s\", lua_ip);\n\n  if(((*host_ip) = strtok_r(buf, \"@\", &where)) != NULL)\n    vlan = strtok_r(NULL, \"@\", &where);\n\n  if(vlan)\n    (*vlan_id) = (u_int16_t)atoi(vlan);\n}\n\n/* ****************************************** */\n\nstatic NetworkInterface* handle_null_interface(lua_State* vm) {\n  char allowed_ifname[MAX_INTERFACE_NAME_LEN];\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"NULL interface: did you restart ntopng in the meantime?\");\n\n  if(ntop->getInterfaceAllowed(vm, allowed_ifname)) {\n      return ntop->getNetworkInterface(allowed_ifname);\n  }\n\n  return(ntop->getInterfaceAtId(0));\n}\n\n/* ****************************************** */\n\nstatic int ntop_dump_file(lua_State* vm) {\n  char *fname;\n  FILE *fd;\n  struct mg_connection *conn;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_HTTP_CONN);\n  if((conn = (struct mg_connection*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: null HTTP connection\");\n    return(CONST_LUA_ERROR);\n  }\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((fname = (char*)lua_tostring(vm, 1)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  ntop->fixPath(fname);\n  if((fd = fopen(fname, \"r\")) != NULL) {\n    char tmp[1024];\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Serving file %s\", fname);\n\n    while((fgets(tmp, sizeof(tmp)-256 /* To make sure we have room for replacements */, fd)) != NULL) {\n      for(int i=0; string_to_replace[i].key != NULL; i++)\n\tUtils::replacestr(tmp, string_to_replace[i].key, string_to_replace[i].val);\n\n      mg_printf(conn, \"%s\", tmp);\n    }\n\n    fclose(fd);\n    return(CONST_LUA_OK);\n  } else {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Unable to read file %s\", fname);\n    return(CONST_LUA_ERROR);\n  }\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get default interface name.\n * @details Push the default interface name of ntop into the lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK.\n */\nstatic int ntop_get_default_interface_name(lua_State* vm) {\n  char ifname[MAX_INTERFACE_NAME_LEN];\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop->getInterfaceAllowed(vm, ifname)) {\n    // if there is an allowed interface for the user\n    // we return that interface\n    lua_pushstring(vm,\n\t\t   ntop->getNetworkInterface(ifname)->get_name());\n  } else {\n    lua_pushstring(vm, ntop->getInterfaceAtId(NULL, /* no need to check as there is no constaint */\n\t\t\t\t\t      0)->get_name());\n  }\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Set the name of active interface id into lua stack.\n *\n * @param vm The lua stack.\n * @return @ref CONST_LUA_OK.\n */\nstatic int ntop_set_active_interface_id(lua_State* vm) {\n  NetworkInterface *iface;\n  int id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  id = (u_int32_t)lua_tonumber(vm, 1);\n\n  iface = ntop->getNetworkInterface(vm, id);\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"Index: %d, Name: %s\", id, iface ? iface->get_name() : \"<unknown>\");\n\n  if(iface != NULL)\n    lua_pushstring(vm, iface->get_name());\n  else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n/**\n * @brief Get the ntopng interface names.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK.\n */\nstatic int ntop_get_interface_names(lua_State* vm) {\n  lua_newtable(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  for(int i=0; i<ntop->get_num_interfaces(); i++) {\n    NetworkInterface *iface;\n\n    if((iface = ntop->getInterfaceAtId(vm, i)) != NULL) {\n      char num[8];\n\n      ntop->getTrace()->traceEvent(TRACE_DEBUG, \"Returning name %s\", iface->get_name());\n      snprintf(num, sizeof(num), \"%d\", i);\n      lua_push_str_table_entry(vm, num, iface->get_name());\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic AddressTree* get_allowed_nets(lua_State* vm) {\n  AddressTree *ptree;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_ALLOWED_NETS);\n  ptree = (AddressTree*)lua_touserdata(vm, lua_gettop(vm));\n  //ntop->getTrace()->traceEvent(TRACE_WARNING, \"GET %p\", ptree);\n  return(ptree);\n}\n\n/* ****************************************** */\n\nstatic NetworkInterface* getCurrentInterface(lua_State* vm) {\n  NetworkInterface *ntop_interface;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, \"ntop_interface\");\n  if((ntop_interface = (NetworkInterface*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop_interface = handle_null_interface(vm);\n  }\n\n  return(ntop_interface);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Find the network interface and set it as global variable to lua.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_select_interface(lua_State* vm) {\n  char *ifname;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TNIL)\n    ifname = (char*)\"any\";\n  else {\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n    ifname = (char*)lua_tostring(vm, 1);\n  }\n\n  lua_pushlightuserdata(vm, (char*)ntop->getNetworkInterface(vm, ifname));\n  lua_setglobal(vm, \"ntop_interface\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the nDPI statistics of interface.\n * @details Get the ntop interface global variable of lua, get nDpistats of interface and push it into lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_ndpi_interface_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  /* Optional host */\n  if(lua_type(vm, 1) == LUA_TSTRING) get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if(ntop_interface) {\n    ntop_interface->getnDPIStats(&stats, get_allowed_nets(vm), host_ip, vlan_id);\n\n    lua_newtable(vm);\n    stats.lua(ntop_interface, vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\n/**\n * @brief Get the Host Pool statistics of interface.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_host_pool_interface_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n    ntop_interface->luaHostPoolsStats(vm);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n\n}\n\n/**\n * @brief Get the Host Pool volatile members\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_host_pool_volatile_members(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n    ntop_interface->luaHostPoolsVolatileMembers(vm);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n\n}\n\n\n#endif\n\n/* ****************************************** */\n\n/**\n * @brief Get the ndpi flows count of interface.\n * @details Get the ntop interface global variable of lua, get nDpi flow count of interface and push it into lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_ndpi_interface_flows_count(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n    lua_newtable(vm);\n    ntop_interface->getnDPIFlowsCount(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the flow status for flows in cache\n * @details Get the ntop interface global variable of lua, get flow stats of interface and push it into lua stack.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK\n */\nstatic int ntop_get_ndpi_interface_flows_status(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n    lua_newtable(vm);\n    ntop_interface->getFlowsStatus(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the ndpi protocol name of protocol id of network interface.\n * @details Get the ntop interface global variable of lua. Once do that, get the protocol id of lua stack and return into lua stack \"Host-to-Host Contact\" if protocol id is equal to host family id; the protocol name or null otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_ndpi_protocol_name(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  int proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  proto = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(proto == HOST_FAMILY_ID)\n    lua_pushstring(vm, \"Host-to-Host Contact\");\n  else {\n    if(ntop_interface)\n      lua_pushstring(vm, ntop_interface->get_ndpi_proto_name(proto));\n    else\n      lua_pushnil(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_protocol_id(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  char *proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  proto = (char*)lua_tostring(vm, 1);\n\n  if(ntop_interface && proto)\n    lua_pushnumber(vm, ntop_interface->get_ndpi_proto_id(proto));\n  else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_protocol_category(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  proto = (u_int)lua_tonumber(vm, 1);\n\n  if(ntop_interface) {\n    ndpi_protocol_category_t category = ntop_interface->get_ndpi_proto_category(proto);\n\n    lua_newtable(vm);\n    lua_push_int32_table_entry(vm, \"id\", category);\n    lua_push_str_table_entry(vm, \"name\", (char*)ndpi_category_str(category));\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Same as ntop_get_ndpi_protocol_name() with the exception that the protocol breed is returned\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_ndpi_protocol_breed(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  nDPIStats stats;\n  int proto;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  proto = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(proto == HOST_FAMILY_ID)\n    lua_pushstring(vm, \"Unrated-to-Host Contact\");\n  else {\n    if(ntop_interface)\n      lua_pushstring(vm, ntop_interface->get_ndpi_proto_breed_name(proto));\n    else\n      lua_pushnil(vm);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_hosts(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool show_details = true;\n  char *sortColumn = (char*)\"column_ip\", *country = NULL, *os_filter = NULL, *mac_filter = NULL;\n  bool a2zSortOrder = true;\n  u_int16_t vlan_filter,  *vlan_filter_ptr    = NULL;\n  u_int32_t asn_filter,   *asn_filter_ptr     = NULL;\n  int16_t network_filter, *network_filter_ptr = NULL;\n  u_int16_t pool_filter, *pool_filter_ptr = NULL;\n  u_int32_t toSkip = 0, maxHits = CONST_MAX_NUM_HITS;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN) show_details   = lua_toboolean(vm, 1) ? true : false;\n  if(lua_type(vm, 2) == LUA_TSTRING)  sortColumn     = (char*)lua_tostring(vm, 2);\n  if(lua_type(vm, 3) == LUA_TNUMBER)  maxHits        = (u_int16_t)lua_tonumber(vm, 3);\n  if(lua_type(vm, 4) == LUA_TNUMBER)  toSkip         = (u_int16_t)lua_tonumber(vm, 4);\n  if(lua_type(vm, 5) == LUA_TBOOLEAN) a2zSortOrder   = lua_toboolean(vm, 5) ? true : false;\n  if(lua_type(vm, 6) == LUA_TSTRING)  country        = (char*)lua_tostring(vm, 6);\n  if(lua_type(vm, 7) == LUA_TSTRING)  os_filter      = (char*)lua_tostring(vm, 7);\n  if(lua_type(vm, 8) == LUA_TNUMBER)  vlan_filter    = (u_int16_t)lua_tonumber(vm, 8), vlan_filter_ptr = &vlan_filter;\n  if(lua_type(vm, 9) == LUA_TNUMBER)  asn_filter     = (u_int32_t)lua_tonumber(vm, 9), asn_filter_ptr = &asn_filter;\n  if(lua_type(vm,10) == LUA_TNUMBER)  network_filter = (int16_t)lua_tonumber(vm, 10),  network_filter_ptr = &network_filter;\n  if(lua_type(vm,11) == LUA_TSTRING)  mac_filter     = (char*)lua_tostring(vm, 11);\n  if(lua_type(vm,12) == LUA_TNUMBER)  pool_filter    = (u_int16_t)lua_tonumber(vm, 12), pool_filter_ptr = &pool_filter;\n\n  if(!ntop_interface ||\n    ntop_interface->getActiveHostsList(vm, get_allowed_nets(vm),\n                                       show_details, location,\n                                       country, mac_filter,\n\t\t\t\t       vlan_filter_ptr, os_filter, asn_filter_ptr,\n\t\t\t\t       network_filter_ptr, pool_filter_ptr,\n\t\t\t\t       sortColumn, maxHits,\n\t\t\t\t       toSkip, a2zSortOrder) < 0)\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_latest_activity_hosts_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  ntop_interface->getLatestActivityHostsList(vm, get_allowed_nets(vm));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the host information of network interface grouped according to the criteria.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or the host is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_grouped_interface_hosts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool show_details = true, hostsOnly = true;\n  char *country = NULL, *os_filter = NULL;\n  char *groupBy = (char*)\"column_ip\";\n  u_int16_t vlan_filter,  *vlan_filter_ptr    = NULL;\n  u_int32_t asn_filter,   *asn_filter_ptr     = NULL;\n  u_int16_t pool_filter,  *pool_filter_ptr    = NULL;\n  int16_t network_filter, *network_filter_ptr = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN) show_details = lua_toboolean(vm, 1) ? true : false;\n  if(lua_type(vm, 2) == LUA_TSTRING)  groupBy    = (char*)lua_tostring(vm, 2);\n  if(lua_type(vm, 3) == LUA_TSTRING)  country = (char*)lua_tostring(vm, 3);\n  if(lua_type(vm, 4) == LUA_TSTRING)  os_filter      = (char*)lua_tostring(vm, 4);\n  if(lua_type(vm, 5) == LUA_TNUMBER)  vlan_filter    = (u_int16_t)lua_tonumber(vm, 5), vlan_filter_ptr = &vlan_filter;\n  if(lua_type(vm, 6) == LUA_TNUMBER)  asn_filter     = (u_int32_t)lua_tonumber(vm, 6), asn_filter_ptr = &asn_filter;\n  if(lua_type(vm, 7) == LUA_TNUMBER)  network_filter = (int16_t)lua_tonumber(vm, 7),  network_filter_ptr = &network_filter;\n  if(lua_type(vm, 8) == LUA_TBOOLEAN) hostsOnly      = lua_toboolean(vm, 8) ? true : false;\n  if(lua_type(vm, 9) == LUA_TNUMBER)  pool_filter    = (u_int16_t)lua_tonumber(vm, 9), pool_filter_ptr = &pool_filter;\n\n  if((!ntop_interface)\n     || ntop_interface->getActiveHostsGroup(vm, get_allowed_nets(vm),\n\t\t\t\t\t    show_details, location_all,\n\t\t\t\t\t    country,\n\t\t\t\t\t    vlan_filter_ptr, os_filter,\n\t\t\t\t\t    asn_filter_ptr, network_filter_ptr,\n\t\t\t\t\t    pool_filter_ptr,\n\t\t\t\t\t    hostsOnly, groupBy) < 0)\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the hosts information of network interface.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the host information.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_hosts_info(lua_State* vm) {\n  return(ntop_get_interface_hosts(vm, location_all));\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_macs_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *sortColumn = (char*)\"column_mac\";\n  u_int32_t toSkip = 0, maxHits = CONST_MAX_NUM_HITS;\n  u_int16_t vlan_id = 0;\n  bool a2zSortOrder = true,\n    skipSpecialMacs = false, hostMacsOnly = false;\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    sortColumn = (char*)lua_tostring(vm, 1);\n\n    if(lua_type(vm, 2) == LUA_TNUMBER) {\n      maxHits = (u_int16_t)lua_tonumber(vm, 2);\n\n      if(lua_type(vm, 3) == LUA_TNUMBER) {\n\ttoSkip = (u_int16_t)lua_tonumber(vm, 3);\n\n\tif(lua_type(vm, 4) == LUA_TBOOLEAN) {\n\t  a2zSortOrder = lua_toboolean(vm, 4) ? true : false;\n\n\t  if(lua_type(vm, 5) == LUA_TNUMBER) {\n\t    vlan_id = (u_int16_t)lua_tonumber(vm, 5);\n\n\t    if(lua_type(vm, 6) == LUA_TBOOLEAN) {\n\t      skipSpecialMacs = lua_toboolean(vm, 6) ? true : false;\n\t    }\n\t    if(lua_type(vm, 7) == LUA_TBOOLEAN) {\n\t      hostMacsOnly = lua_toboolean(vm, 7) ? true : false;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(!ntop_interface ||\n     ntop_interface->getActiveMacList(vm, vlan_id, skipSpecialMacs,\n\t\t\t\t      hostMacsOnly,\n\t\t\t\t      sortColumn, maxHits,\n\t\t\t\t      toSkip, a2zSortOrder) < 0)\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_mac_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *mac = NULL;\n  u_int16_t vlan_id = 0;\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    mac = (char*)lua_tostring(vm, 1);\n\n    if(lua_type(vm, 2) == LUA_TNUMBER) {\n      vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n    }\n  }\n\n  if((!ntop_interface)\n     || (!mac)\n     || (!ntop_interface->getMacInfo(vm, mac, vlan_id)))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_mac_manufacturer(lua_State* vm) {\n  const char *mac = NULL;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  mac = (char*)lua_tostring(vm, 1);\n\n  ntop->getMacManufacturer(mac, vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_site_categories(lua_State* vm) {\n  Flashstart *flash = ntop->get_flashstart();\n\n  if (!flash)\n    lua_pushnil(vm);\n  else\n    flash->lua(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get local hosts information of network interface.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the local host information.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_local_hosts_info(lua_State* vm) {\n  return(ntop_get_interface_hosts(vm, location_local_only));\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get remote hosts information of network interface.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the remote host information.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_remote_hosts_info(lua_State* vm) {\n  return(ntop_get_interface_hosts(vm, location_remote_only));\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get local hosts activity information.\n * @details Get the ntop interface global variable of lua and return into lua stack a new hash table of hash tables containing the local host activities.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or host is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  const char * host = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if (lua_type(vm, 1) == LUA_TSTRING)\n    host = lua_tostring(vm, 1);\n\n  if (ntop_interface == NULL || host == NULL)\n    return CONST_LUA_ERROR;\n\n  ntop_interface->getLocalHostActivity(vm, host);\n\n  return CONST_LUA_OK;\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the specified path is a directory and it exists.\n * @details True if if the specified path is a directory and it exists, false otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_is_dir(lua_State* vm) {\n  char *path;\n  struct stat buf;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  rc = ((stat(path, &buf) != 0) || (!S_ISDIR(buf.st_mode))) ? 0 : 1;\n  lua_pushboolean(vm, rc);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the file is exists and is not empty\n * @details Simple check for existance + non empty file\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_is_not_empty_file(lua_State* vm) {\n  char *path;\n  struct stat buf;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  rc = (stat(path, &buf) != 0) ? 0 : 1;\n  if(rc && (buf.st_size == 0)) rc = 0;\n  lua_pushboolean(vm, rc);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the file or directory exists.\n * @details Get the path of file/directory from to lua stack and push true into lua stack if it exists, false otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_get_file_dir_exists(lua_State* vm) {\n  char *path;\n  struct stat buf;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  rc = (stat(path, &buf) != 0) ? 0 : 1;\n  //   ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s: %d\", path, rc);\n  lua_pushboolean(vm, rc);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Return the epoch of the file last change\n * @details This function return that time (epoch) of the last chnge on a file, or -1 if the file does not exist.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK\n */\nstatic int ntop_get_file_last_change(lua_State* vm) {\n  char *path;\n  struct stat buf;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n\n  if(stat(path, &buf) == 0)\n    lua_pushnumber(vm, (lua_Number)buf.st_mtime);\n  else\n    lua_pushnumber(vm, -1); /* not found */\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if ntop has seen VLAN tagged packets on this interface.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_has_vlans(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface)\n    lua_pushboolean(vm, ntop_interface->hasSeenVlanTaggedPackets());\n  else\n    lua_pushboolean(vm, 0);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if ntop has loaded ASN information (via GeoIP)\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_has_geoip(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if ntop is running on windows.\n * @details Push into lua stack 1 if ntop is running on windows, 0 otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_is_windows(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm,\n#ifdef WIN32\n\t\t  1\n#else\n\t\t  0\n#endif\n\t\t  );\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_allocHostBlacklist(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop->allocHostBlacklist();\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_swapHostBlacklist(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop->swapHostBlacklist();\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_addToHostBlacklist(lua_State* vm) {\n  char *net;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  net = (char*)lua_tostring(vm, 1);\n\n  ntop->addToHostBlacklist(net);\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Wrapper for the libc call getservbyport()\n * @details Wrapper for the libc call getservbyport()\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_getservbyport(lua_State* vm) {\n  int port;\n  char *proto;\n  struct servent *s = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  port = (int)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  proto = (char*)lua_tostring(vm, 2);\n\n  if((port > 0) && (proto != NULL))\n    s = getservbyport(htons(port), proto);\n\n  if(s && s->s_name)\n    lua_pushstring(vm, s->s_name);\n  else {\n    char buf[32];\n\n    snprintf(buf, sizeof(buf), \"%d\", port);\n    lua_pushstring(vm, buf);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Scan the input directory and return the list of files.\n * @details Get the path from the lua stack and push into a new hashtable the files name existing in the directory.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_list_dir_files(lua_State* vm) {\n  char *path;\n  DIR *dirp;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n  ntop->fixPath(path);\n\n  lua_newtable(vm);\n\n  if((dirp = opendir(path)) != NULL) {\n    struct dirent *dp;\n\n    while ((dp = readdir(dirp)) != NULL)\n      if((dp->d_name[0] != '\\0')\n\t && (dp->d_name[0] != '.')) {\n\tlua_push_str_table_entry(vm, dp->d_name, dp->d_name);\n      }\n    (void)closedir(dirp);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/* Adapted from http://stackoverflow.com/questions/2256945/removing-a-non-empty-directory-programmatically-in-c-or-c */\nstatic int remove_recursively(const char * path) {\n  DIR *d = opendir(path);\n  size_t path_len = strlen(path);\n  int r = -1;\n  size_t len;\n  char *buf;\n\n  if (d) {\n    struct dirent *p;\n\n    r = 0;\n\n    while ((r==0) && (p=readdir(d))) {\n      /* Skip the names \".\" and \"..\" as we don't want to recurse on them. */\n      if (!strcmp(p->d_name, \".\") || !strcmp(p->d_name, \"..\"))\n         continue;\n\n      len = path_len + strlen(p->d_name) + 2;\n      buf = (char *) malloc(len);\n\n      if (buf) {\n        struct stat statbuf;\n\n        snprintf(buf, len, \"%s/%s\", path, p->d_name);\n\n        if (stat(buf, &statbuf) == 0) {\n          if (S_ISDIR(statbuf.st_mode))\n            r = remove_recursively(buf);\n          else\n            r = unlink(buf);\n        }\n\n        free(buf);\n      }\n    }\n\n    closedir(d);\n  }\n\n  if (r == 0)\n    r = rmdir(path);\n\n  return r;\n}\n\n/**\n * @brief Scan the input directory, removes it and its contets.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_remove_dir_recursively(lua_State* vm) {\n  char *path;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  path = (char*)lua_tostring(vm, 1);\n  ntop->fixPath(path);\n\n  remove_recursively(path);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the system time and push it into the lua stack.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_gettimemsec(lua_State* vm) {\n  struct timeval tp;\n  double ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  gettimeofday(&tp, NULL);\n\n  ret = (((double)tp.tv_usec) / (double)1000) + tp.tv_sec;\n\n  lua_pushnumber(vm, ret);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Lua-equivaled ot C inet_ntoa\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_inet_ntoa(lua_State* vm) {\n  u_int32_t ip;\n  struct in_addr in;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING)\n    ip = atol((char*)lua_tostring(vm, 1));\n  else if(lua_type(vm, 1) == LUA_TNUMBER)\n    ip = (u_int32_t)lua_tonumber(vm, 1);\n  else\n    return(CONST_LUA_ERROR);\n\n  in.s_addr = htonl(ip);\n  lua_pushstring(vm, inet_ntoa(in));\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_zmq_connect(lua_State* vm) {\n  char *endpoint, *topic;\n  void *context, *subscriber;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((endpoint = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((topic = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  context = zmq_ctx_new(), subscriber = zmq_socket(context, ZMQ_SUB);\n\n  if(zmq_connect(subscriber, endpoint) != 0) {\n    zmq_close(subscriber);\n    zmq_ctx_destroy(context);\n    return(CONST_LUA_PARAM_ERROR);\n  }\n\n  if(zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, topic, strlen(topic)) != 0) {\n    zmq_close(subscriber);\n    zmq_ctx_destroy(context);\n    return -1;\n  }\n\n  lua_pushlightuserdata(vm, context);\n  lua_setglobal(vm, \"zmq_context\");\n\n  lua_pushlightuserdata(vm, subscriber);\n  lua_setglobal(vm, \"zmq_subscriber\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Delete the specified member(field) from the redis hash stored at key.\n * @details Get the key parameter from the lua stack and delete it from redis.\n *\n * @param vm The lua stack.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_delete_redis_key(lua_State* vm) {\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n  ntop->getRedis()->del(key);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/* ****************************************** */\n\n/**\n * @brief Add a member to the a redis set.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_add_set_member_redis(lua_State* vm) {\n  char *key, *value;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if (ntop->getRedis()->sadd(key, value) == 0)\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/**\n * @brief Removes a member from a redis set.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_del_set_member_redis(lua_State* vm) {\n  char *key, *value;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if (ntop->getRedis()->srem(key, value) == 0)\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the members of a redis set.\n * @details Get the set key form the lua stack and push the mambers name into lua stack.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_get_set_members_redis(lua_State* vm) {\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n  ntop->getRedis()->smembers(vm, key);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Delete the specified member(field) from the redis hash stored at key.\n * @details Get the member name and the hash key form the lua stack and remove the specified member.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_delete_hash_redis_key(lua_State* vm) {\n  char *key, *member;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  ntop->getRedis()->hashDel(key, member);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_zmq_disconnect(lua_State* vm) {\n  void *context, *subscriber;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, \"zmq_context\");\n  if((context = (void*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: NULL context\");\n    return(CONST_LUA_ERROR);\n  }\n\n  lua_getglobal(vm, \"zmq_subscriber\");\n  if((subscriber = (void*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: NULL subscriber\");\n    return(CONST_LUA_ERROR);\n  }\n\n  zmq_close(subscriber);\n  zmq_ctx_destroy(context);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_zmq_receive(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  void *subscriber;\n  int size;\n  struct zmq_msg_hdr h;\n  char *payload;\n  int payload_len;\n  zmq_pollitem_t item;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, \"zmq_subscriber\");\n  if((subscriber = (void*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: NULL subscriber\");\n    return(CONST_LUA_ERROR);\n  }\n\n  item.socket = subscriber;\n  item.events = ZMQ_POLLIN;\n  do {\n    rc = zmq_poll(&item, 1, 1000);\n    if(rc < 0 || !ntop_interface->isRunning()) /* CHECK */\n      return(CONST_LUA_PARAM_ERROR);\n  } while (rc == 0);\n\n  size = zmq_recv(subscriber, &h, sizeof(h), 0);\n\n  if(size != sizeof(h) || h.version != ZMQ_MSG_VERSION) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unsupported publisher version [%d]\", h.version);\n    return -1;\n  }\n\n  payload_len = h.size + 1;\n  if((payload = (char*)malloc(payload_len)) != NULL) {\n    size = zmq_recv(subscriber, payload, payload_len, 0);\n    payload[h.size] = '\\0';\n\n    if(size > 0) {\n      enum json_tokener_error jerr = json_tokener_success;\n      json_object *o = json_tokener_parse_verbose(payload, &jerr);\n\n      if(o != NULL) {\n\tstruct json_object_iterator it = json_object_iter_begin(o);\n\tstruct json_object_iterator itEnd = json_object_iter_end(o);\n\n\twhile (!json_object_iter_equal(&it, &itEnd)) {\n\t  char *key   = (char*)json_object_iter_peek_name(&it);\n\t  const char *value = json_object_get_string(json_object_iter_peek_value(&it));\n\n\t  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[%s]=[%s]\", key, value);\n\n\t  json_object_iter_next(&it);\n\t}\n\n\tjson_object_put(o);\n      } else\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"JSON Parse error [%s]: %s\",\n\t\t\t\t     json_tokener_error_desc(jerr),\n\t\t\t\t     payload);\n\n      lua_pushfstring(vm, \"%s\", payload);\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[%u] %s\", h.size, payload);\n      free(payload);\n      return(CONST_LUA_OK);\n    } else {\n      free(payload);\n      return(CONST_LUA_PARAM_ERROR);\n    }\n  } else\n    return(CONST_LUA_PARAM_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_local_networks(lua_State* vm) {\n  lua_newtable(vm);\n  ntop->getLocalNetworks(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reload_preferences(lua_State* vm) {\n  lua_newtable(vm);\n  ntop->getPrefs()->reloadPrefsFromRedis();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Check if the trace level of ntop is verbose.\n * @details Push true into the lua stack if the trace level of ntop is set to MAX_TRACE_LEVEL, false otherwise.\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_verbose_trace(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm, (ntop->getTrace()->get_trace_level() == MAX_TRACE_LEVEL) ? true : false);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_send_udp_data(lua_State* vm) {\n  int rc, port, sockfd = ntop->getUdpSock();\n  char *host, *data;\n\n  if(sockfd == -1)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  host = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  port = (u_int16_t)lua_tonumber(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  data = (char*)lua_tostring(vm, 3);\n\n  if(strchr(host, ':') != NULL) {\n    struct sockaddr_in6 server_addr;\n\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin6_family = AF_INET6;\n    inet_pton(AF_INET6, host, &server_addr.sin6_addr);\n    server_addr.sin6_port = htons(port);\n\n    rc = sendto(sockfd, data, strlen(data),0,\n\t\t(struct sockaddr *)&server_addr,\n\t\tsizeof(server_addr));\n  } else {\n    struct sockaddr_in server_addr;\n\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(host); /* FIX: add IPv6 support */\n    server_addr.sin_port = htons(port);\n\n    rc = sendto(sockfd, data, strlen(data),0,\n\t\t(struct sockaddr *)&server_addr,\n\t\tsizeof(server_addr));\n  }\n\n  if(rc == -1)\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_flows(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char buf[64];\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  Host *host = NULL;\n  Paginator *p = NULL;\n  int numFlows = -1;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  if((p = new(std::nothrow) Paginator()) == NULL)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n    host = ntop_interface->getHost(host_ip, vlan_id);\n  }\n\n  if(lua_type(vm, 2) == LUA_TTABLE)\n    p->readOptions(vm, 2);\n\n  if(ntop_interface)\n    numFlows = ntop_interface->getFlows(vm, get_allowed_nets(vm), location, host, p);\n\n  if(p) delete p;\n  return numFlows < 0 ? CONST_LUA_ERROR : CONST_LUA_OK;\n}\n\nstatic int ntop_get_interface_flows_info(lua_State* vm)        { return(ntop_get_interface_flows(vm, location_all));          }\nstatic int ntop_get_interface_local_flows_info(lua_State* vm)  { return(ntop_get_interface_flows(vm, location_local_only));   }\nstatic int ntop_get_interface_remote_flows_info(lua_State* vm) { return(ntop_get_interface_flows(vm, location_remote_only));  }\n\n/* ****************************************** */\n\n/**\n * @brief Get nDPI stats for flows\n * @details Compute nDPI flow statistics\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_get_interface_flows_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(ntop_interface) ntop_interface->getFlowsStats(vm);\n\n  return(CONST_LUA_OK);\n}\n/* ****************************************** */\n\n/**\n * @brief Get interface stats for local networks\n * @details Returns traffic statistics per local network\n *\n * @param vm The lua state.\n * @return CONST_LUA_OK.\n */\nstatic int ntop_get_interface_networks_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(ntop_interface) ntop_interface->getNetworksStats(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Get the host information of network interface.\n * @details Get the ntop interface global variable of lua, the host ip and optional the VLAN id form the lua stack and push a new hash table of hash tables containing the host information into lua stack.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or the host is null, CONST_LUA_OK otherwise.\n */\nstatic int ntop_get_interface_host_info(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->getHostInfo(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n#ifdef NOTUSED\nstatic int ntop_get_grouped_interface_host(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *country_s = NULL, *os_s = NULL;\n  u_int16_t vlan_n,    *vlan_ptr    = NULL;\n  u_int32_t as_n,      *as_ptr      = NULL;\n  int16_t   network_n, *network_ptr = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TNUMBER) vlan_n    = (u_int16_t)lua_tonumber(vm, 1), vlan_ptr  = &vlan_n;\n  if(lua_type(vm, 2) == LUA_TNUMBER) as_n      = (u_int32_t)lua_tonumber(vm, 2), as_ptr    = &as_n;\n  if(lua_type(vm, 3) == LUA_TNUMBER) network_n = (int16_t)lua_tonumber(vm, 3), network_ptr = &network_n;\n  if(lua_type(vm, 4) == LUA_TSTRING) country_s = (char*)lua_tostring(vm, 4);\n  if(lua_type(vm, 5) == LUA_TSTRING) os_s      = (char*)lua_tostring(vm, 5);\n\n  if(!ntop_interface || ntop_interface->getActiveHostsGroup(vm, get_allowed_nets(vm), false, false, country_s, vlan_ptr, os_s, as_ptr,\n\t\t\t\t\t\t\t    network_ptr, (char*)\"column_ip\", (char*)\"country\", CONST_MAX_NUM_HITS, 0 /* toSkip */, true /* a2zSortOrder */) < 0)\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n#endif\n\n/* ****************************************** */\n\nstatic int ntop_getflowdevices(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n  else {\n    ntop_interface->getFlowDevices(vm);\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_getflowdeviceinfo(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *device_ip;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  device_ip = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n  else {\n    in_addr_t addr = inet_addr(device_ip);\n\n    ntop_interface->getFlowDeviceInfo(vm, ntohl(addr));\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_load_host_alert_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->loadHostAlertPrefs(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_host_reset_periodic_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->resetPeriodicStats();\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_host_trigger_alerts(lua_State* vm, bool trigger) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER)\n    vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(trigger)\n    h->enableAlerts();\n  else\n    h->disableAlerts();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_host_enable_alerts(lua_State* vm) {\n  return ntop_interface_host_trigger_alerts(vm, true);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_host_disable_alerts(lua_State* vm) {\n  return ntop_interface_host_trigger_alerts(vm, false);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_refresh_num_alerts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  AlertsManager *am;\n  Host *h;\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  u_int32_t num_alerts;\n  char buf[128];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((!ntop_interface))\n    return(CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n    /* Optional VLAN id */\n    if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n    if((h = ntop_interface->getHost(host_ip, vlan_id))) {\n\n      if(lua_type(vm, 3) == LUA_TNUMBER) {\n\tnum_alerts = (u_int32_t)lua_tonumber(vm, 3);\n\th->setNumAlerts(num_alerts);\n      } else {\n\th->getNumAlerts(true /* From AlertsManager re-reads the values */);\n      }\n    }\n\n  } else {\n\n    if((am = ntop_interface->getAlertsManager()) == NULL)\n      return(CONST_LUA_ERROR);\n\n    am->refreshCachedNumAlerts();\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_correalate_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n   /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->correlateHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_similar_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->similarHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_host_activitymap(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  GenericHost *h;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)  return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  h = ntop_interface->getHost(host_ip, vlan_id);\n\n  if(h == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    if(h->match(get_allowed_nets(vm))) {\n      char *json = h->getJsonActivityMap();\n\n      lua_pushfstring(vm, \"%s\", json);\n      free(json);\n    }\n\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\n/**\n * @brief Restore the host of network interface.\n * @details Get the ntop interface global variable of lua and the IP address of host form the lua stack and restore the host into hash host of network interface.\n *\n * @param vm The lua state.\n * @return CONST_LUA_ERROR if ntop_interface is null or if is impossible to restore the host, CONST_LUA_OK otherwise.\n */\nstatic int ntop_restore_interface_host(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  bool skip_privileges_check = false;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* make sure skip privileges check cannot be set from the web interface */\n  if(lua_type(vm, 2) == LUA_TBOOLEAN) skip_privileges_check = lua_toboolean(vm, 2);\n\n  if(!skip_privileges_check && !Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if((!ntop_interface) || !ntop_interface->restoreHost(host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_flow_key(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  Host *cli, *srv;\n  char *cli_name = NULL; u_int16_t cli_vlan = 0; u_int16_t cli_port = 0;\n  char *srv_name = NULL; u_int16_t srv_vlan = 0; u_int16_t srv_port = 0;\n  u_int16_t protocol;\n  char cli_buf[256], srv_buf[256];\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)    /* cli_host@cli_vlan */\n     || ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER) /* cli port          */\n     || ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING) /* srv_host@srv_vlan */\n     || ntop_lua_check(vm, __FUNCTION__, 4, LUA_TNUMBER) /* srv port          */\n     || ntop_lua_check(vm, __FUNCTION__, 5, LUA_TNUMBER) /* protocol          */\n     ) return(CONST_LUA_ERROR);\n\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &cli_name, &cli_vlan, cli_buf, sizeof(cli_buf));\n  cli_port = htons((u_int16_t)lua_tonumber(vm, 2));\n\n  get_host_vlan_info((char*)lua_tostring(vm, 3), &srv_name, &srv_vlan, srv_buf, sizeof(srv_buf));\n  srv_port = htons((u_int16_t)lua_tonumber(vm, 4));\n\n  protocol = (u_int16_t)lua_tonumber(vm, 5);\n\n  if(cli_vlan != srv_vlan) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Client and Server vlans don't match.\");\n    return(CONST_LUA_ERROR);\n  }\n\n  if(cli_name == NULL || srv_name == NULL\n     ||(cli = ntop_interface->getHost(cli_name, cli_vlan)) == NULL\n     ||(srv = ntop_interface->getHost(srv_name, srv_vlan)) == NULL) {\n    lua_pushnil(vm);\n  } else {\n    lua_pushnumber(vm, Flow::key(cli, cli_port, srv, srv_port, cli_vlan, protocol));\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_flow_by_key(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t key;\n  Flow *f;\n  AddressTree *ptree = get_allowed_nets(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(false);\n\n  f = ntop_interface->findFlowByKey(key, ptree);\n\n  if(f == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    f->lua(vm, ptree, details_high, false);\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_drop_flow_traffic(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t key;\n  Flow *f;\n  AddressTree *ptree = get_allowed_nets(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(false);\n\n  f = ntop_interface->findFlowByKey(key, ptree);\n\n  if(f == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    f->setDropVerdict();\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_dump_flow_traffic(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t key, what;\n  Flow *f;\n  AddressTree *ptree = get_allowed_nets(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  what = (u_int32_t)lua_tonumber(vm, 2);\n\n  if(!ntop_interface) return(false);\n\n  f = ntop_interface->findFlowByKey(key, ptree);\n\n  if(f == NULL)\n    return(CONST_LUA_ERROR);\n  else {\n    f->setDumpFlowTraffic(what ? true : false);\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_dump_local_hosts_2_redis(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop_interface->dumpLocalHosts2redis(true /* must disable purge as we are called from lua */);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_user_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  key = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findUserFlows(vm, key);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_pid_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t pid;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  pid = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findPidFlows(vm, pid);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_father_pid_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int32_t father_pid;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  father_pid = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findFatherPidFlows(vm, father_pid);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_proc_name_flows(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *proc_name;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  proc_name = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  ntop_interface->findProcNameFlows(vm, proc_name);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_list_http_hosts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) != LUA_TSTRING) /* Optional */\n    key = NULL;\n  else\n    key = (char*)lua_tostring(vm, 1);\n\n  ntop_interface->listHTTPHosts(vm, key);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_find_host(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  key = (char*)lua_tostring(vm, 1);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  ntop_interface->findHostsByName(vm, get_allowed_nets(vm), key);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_update_host_traffic_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->updateHostTrafficPolicy(host_ip);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_update_host_alert_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->readAlertPrefs();\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_second_traffic(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  ntop_interface->updateSecondTraffic(time(NULL));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_host_dump_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  bool dump_traffic_to_disk;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TBOOLEAN)) return(CONST_LUA_ERROR);\n  dump_traffic_to_disk = lua_toboolean(vm, 1) ? true : false;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 2), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 3) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 3);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->setDumpTrafficPolicy(dump_traffic_to_disk);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_host_hit_rate(lua_State* vm) {\n#ifdef NOTUSED\n    NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  u_int32_t peer_key;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  peer_key = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 2), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 3) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 3);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->getPeerBytes(vm, peer_key);\n  return(CONST_LUA_OK);\n#else\n  return(CONST_LUA_ERROR); // not supported\n#endif\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_host_quota(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  u_int32_t quota;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  quota = (u_int32_t)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 2), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 3) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 3);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL))\n    return(CONST_LUA_ERROR);\n\n  h->setQuota(quota);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_tap_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool dump_traffic_to_tap;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  dump_traffic_to_tap = ntop_interface->getDumpTrafficTapPolicy();\n\n  lua_pushboolean(vm, dump_traffic_to_tap ? 1 : 0);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_tap_name(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, ntop_interface->getDumpTrafficTapName());\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_disk_policy(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool dump_traffic_to_disk;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  dump_traffic_to_disk = ntop_interface->getDumpTrafficDiskPolicy();\n\n  lua_pushboolean(vm, dump_traffic_to_disk ? 1 : 0);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_max_pkts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int max_pkts;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  max_pkts = ntop_interface->getDumpTrafficMaxPktsPerFile();\n\n  lua_pushnumber(vm, max_pkts);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_max_sec(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int max_sec;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  max_sec = ntop_interface->getDumpTrafficMaxSecPerFile();\n\n  lua_pushnumber(vm, max_sec);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_dump_max_files(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int max_files;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  max_files = ntop_interface->getDumpTrafficMaxFiles();\n\n  lua_pushnumber(vm, max_files);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_pkts_dumped_file(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int num_pkts;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  PacketDumper *dumper = ntop_interface->getPacketDumper();\n  if(!dumper)\n    return(CONST_LUA_ERROR);\n\n  num_pkts = dumper->get_num_dumped_packets();\n\n  lua_pushnumber(vm, num_pkts);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_pkts_dumped_tap(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int num_pkts;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  PacketDumperTuntap *dumper = ntop_interface->getPacketDumperTap();\n  if(!dumper)\n    return(CONST_LUA_ERROR);\n\n  num_pkts = dumper->get_num_dumped_packets();\n\n  lua_pushnumber(vm, num_pkts);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_endpoint(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  u_int8_t id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) != LUA_TNUMBER) /* Optional */\n    id = 0;\n  else\n    id = (u_int8_t)lua_tonumber(vm, 1);\n\n  if(ntop_interface) {\n    char *endpoint = ntop_interface->getEndpoint(id); /* CHECK */\n\n    lua_pushfstring(vm, \"%s\", endpoint ? endpoint : \"\");\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_packet_interface(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  lua_pushboolean(vm, ntop_interface->isPacketInterface());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_bridge_interface(lua_State* vm) {\n  int ifid;\n  NetworkInterface *iface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((lua_type(vm, 1) == LUA_TNUMBER)) {\n    ifid = lua_tointeger(vm, 1);\n\n    if(ifid < 0 || !(iface = ntop->getNetworkInterface(ifid)))\n      return (CONST_LUA_ERROR);\n  }\n\n  lua_pushboolean(vm, iface->is_bridge_interface());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_pcap_dump_interface(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  const char *interface_type;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface\n     || ((interface_type = ntop_interface->get_type()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  lua_pushboolean(vm, strcmp(interface_type, CONST_INTERFACE_TYPE_PCAP_DUMP) == 0);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_running(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  return(ntop_interface->isRunning());\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_is_idle(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n  return(ntop_interface->idle());\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_set_idle(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool state;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TBOOLEAN)) return(CONST_LUA_ERROR);\n  state = lua_toboolean(vm, 1) ? true : false;\n\n  ntop_interface->setIdleState(state);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_name2id(lua_State* vm) {\n  char *if_name;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TNIL)\n    if_name = NULL;\n  else {\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n    if_name = (char*)lua_tostring(vm, 1);\n  }\n\n  lua_pushinteger(vm, ntop->getInterfaceIdByName(if_name));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_protocols(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  ndpi_protocol_category_t category_filter;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((lua_type(vm, 1) == LUA_TNUMBER)) {\n    category_filter = (ndpi_protocol_category_t)lua_tointeger(vm, 1);\n\n    if(category_filter >= NDPI_PROTOCOL_NUM_CATEGORIES)\n      return (CONST_LUA_ERROR);\n\n    ntop_interface->getnDPIProtocols(vm, category_filter);\n  } else\n    ntop_interface->getnDPIProtocols(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_ndpi_categories(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_newtable(vm);\n\n  for (int i=0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {\n    char buf[8];\n\n    snprintf(buf, sizeof(buf), \"%d\", i);\n    lua_push_str_table_entry(vm, ndpi_category_str((ndpi_protocol_category_t)i), buf);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_load_dump_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop_interface->loadDumpPrefs();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_load_scaling_factor_prefs(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  ntop_interface->loadScalingFactorPrefs();\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/*\n  Code partially taken from third-party/rrdtool-1.4.7/bindings/lua/rrdlua.c\n  and made reentrant\n*/\n\nstatic void reset_rrd_state(void) {\n  optind = 0;\n  opterr = 0;\n  rrd_clear_error();\n}\n\n/* ****************************************** */\n\nstatic const char **make_argv(lua_State * vm, u_int offset) {\n  const char **argv;\n  int i;\n  int argc = lua_gettop(vm) - offset;\n\n  if(!(argv = (const char**)calloc(argc, sizeof (char *))))\n    /* raise an error and never return */\n    luaL_error(vm, \"Can't allocate memory for arguments array\");\n\n  /* fprintf(stderr, \"%s\\n\", argv[0]); */\n  for(i=0; i<argc; i++) {\n    u_int idx = i + offset;\n    /* accepts string or number */\n    if(lua_isstring(vm, idx) || lua_isnumber(vm, idx)) {\n      if(!(argv[i] = (char*)lua_tostring (vm, idx))) {\n\t/* raise an error and never return */\n\tluaL_error(vm, \"Error duplicating string area for arg #%d\", i);\n      }\n    } else {\n      /* raise an error and never return */\n      luaL_error(vm, \"Invalid arg #%d: args must be strings or numbers\", i);\n    }\n\n    // ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[%d] %s\", i, argv[i]);\n  }\n\n  return(argv);\n}\n\n/* ****************************************** */\n\nstatic int ntop_rrd_create(lua_State* vm) {\n  const char *filename;\n  unsigned long pdp_step;\n  const char **argv;\n  int argc, status, offset = 3;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((filename = (const char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  pdp_step = (unsigned long)lua_tonumber(vm, 2);\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s(%s)\", __FUNCTION__, filename);\n\n  argc = lua_gettop(vm) - offset;\n  argv = make_argv(vm, offset);\n\n  reset_rrd_state();\n  status = rrd_create_r(filename, pdp_step, time(NULL)-86400 /* 1 day */, argc, argv);\n  free(argv);\n\n  if(status != 0) {\n    char *err = rrd_get_error();\n\n    if(err != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_ERROR);\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_rrd_update(lua_State* vm) {\n  const char *filename, *update_arg;\n  int status;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((filename = (const char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((update_arg = (const char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s(%s) %s\", __FUNCTION__, filename, update_arg);\n\n  reset_rrd_state();\n  status = rrd_update_r(filename, NULL, 1, &update_arg);\n\n  if(status != 0) {\n    char *err = rrd_get_error();\n\n    if(err != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_ERROR);\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_rrd_lastupdate(lua_State* vm) {\n  const char *filename;\n  time_t    last_update;\n  char    **ds_names;\n  char    **last_ds;\n  unsigned long ds_count, i;\n  int status;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((filename = (const char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  status = rrd_lastupdate_r(filename, &last_update, &ds_count, &ds_names, &last_ds);\n\n  if(status != 0) {\n    return(CONST_LUA_ERROR);\n  } else {\n    for(i = 0; i < ds_count; i++)\n      free(last_ds[i]), free(ds_names[i]);\n\n    free(last_ds), free(ds_names);\n\n    lua_pushnumber(vm, last_update);\n    lua_pushnumber(vm, ds_count);\n    return(2 /* 2 values returned */);\n  }\n}\n\n/* ****************************************** */\n\n/* positional 1:4 parameters for ntop_rrd_fetch */\nstatic int __ntop_rrd_args (lua_State* vm, char **filename, char **cf, time_t *start, time_t *end) {\n  char *start_s, *end_s, *err;\n  rrd_time_value_t start_tv, end_tv;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((*filename = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((*cf = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if((lua_type(vm, 3) == LUA_TNUMBER) && (lua_type(vm, 4) == LUA_TNUMBER))\n    *start = (time_t)lua_tonumber(vm, 3), *end = (time_t)lua_tonumber(vm, 4);\n  else {\n    if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n    if((start_s = (char*)lua_tostring(vm, 3)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n    if((err = rrd_parsetime(start_s, &start_tv)) != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_PARAM_ERROR);\n    }\n\n    if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n    if((end_s = (char*)lua_tostring(vm, 4)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n    if((err = rrd_parsetime(end_s, &end_tv)) != NULL) {\n      luaL_error(vm, err);\n      return(CONST_LUA_PARAM_ERROR);\n    }\n\n    if(rrd_proc_start_end(&start_tv, &end_tv, start, end) == -1)\n      return(CONST_LUA_PARAM_ERROR);\n  }\n\n  return(CONST_LUA_OK);\n}\n\nstatic int __ntop_rrd_status(lua_State* vm, int status, char *filename, char *cf) {\n  char * err;\n\n  if(status != 0) {\n    err = rrd_get_error();\n\n    if(err != NULL) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR,\n                                   \"Error '%s' while calling rrd_fetch_r(%s, %s): is the RRD corrupted perhaps?\",\n                                   err, filename, cf);\n      lua_pushnil(vm);\n      lua_pushnil(vm);\n      lua_pushnil(vm);\n      lua_pushnil(vm);\n      return(CONST_LUA_ERROR);\n    }\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* Fetches data from RRD by rows */\nstatic int ntop_rrd_fetch(lua_State* vm) {\n  unsigned long i, j, step = 0, ds_cnt = 0;\n  rrd_value_t *data, *p;\n  char **names;\n  char *filename, *cf;\n  time_t t, start, end;\n  int status;\n\n  if ((status = __ntop_rrd_args(vm, &filename, &cf, &start, &end)) != CONST_LUA_OK) return status;\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s(%s)\", __FUNCTION__, filename);\n\n  reset_rrd_state();\n\n  if ((status = __ntop_rrd_status(vm, rrd_fetch_r(filename, cf, &start, &end, &step, &ds_cnt, &names, &data), filename, cf)) != CONST_LUA_OK) return status;\n\n  lua_pushnumber(vm, (lua_Number) start);\n  lua_pushnumber(vm, (lua_Number) step);\n  /* fprintf(stderr, \"%lu, %lu, %lu, %lu\\n\", start, end, step, num_points); */\n\n  /* create the ds names array */\n  lua_newtable(vm);\n  for(i=0; i<ds_cnt; i++) {\n    lua_pushstring(vm, names[i]);\n    lua_rawseti(vm, -2, i+1);\n    rrd_freemem(names[i]);\n  }\n  rrd_freemem(names);\n\n  /* create the data points array */\n  lua_newtable(vm);\n  p = data;\n  for(t=start+1, i=0; t<end; t+=step, i++) {\n    lua_newtable(vm);\n    for(j=0; j<ds_cnt; j++) {\n      rrd_value_t value = *p++;\n\n      if(value != DNAN /* Skip NaN */) {\n        lua_pushnumber(vm, (lua_Number)value);\n        lua_rawseti(vm, -2, j+1);\n        // ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%u / %.f\", t, value);\n      }\n    }\n    lua_rawseti(vm, -2, i+1);\n  }\n  rrd_freemem(data);\n\n  /* return the end as the last value */\n  lua_pushnumber(vm, (lua_Number) end);\n\n  /* number of return values: start, step, names, data, end */\n  return(5);\n}\n\n/* ****************************************** */\n\n/*\n * Similar to ntop_rrd_fetch, but data series oriented  (reads RRD by columns)\n *\n * Positional parameters:\n *    filename: RRD file path\n *    cf: RRD cf\n *    start: the start time you wish to query\n *    end: the end time you wish to query\n *\n * Positional return values:\n *    start: the time of the first data in the series\n *     step: the fetched data step\n *     data: a table, where each key is an RRD name, and the value is its series data\n *      end: the time of the last data in each series\n *  npoints: the number of points in each series\n */\nstatic int ntop_rrd_fetch_columns(lua_State* vm) {\n  char *filename, *cf;\n  time_t start, end;\n  int status;\n  unsigned int npoints = 0, i, j;\n  char **names;\n  unsigned long step = 0, ds_cnt = 0;\n  rrd_value_t *data, *p;\n\n  if ((status = __ntop_rrd_args(vm, &filename, &cf, &start, &end)) != CONST_LUA_OK) return status;\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s(%s)\", __FUNCTION__, filename);\n\n  reset_rrd_state();\n\n  if ((status = __ntop_rrd_status(vm, rrd_fetch_r(filename, cf, &start, &end, &step, &ds_cnt, &names, &data), filename, cf)) != CONST_LUA_OK) return status;\n\n  npoints = (end - start) / step;\n\n  lua_pushnumber(vm, (lua_Number) start);\n  lua_pushnumber(vm, (lua_Number) step);\n\n  /* create the data series table */\n  lua_createtable(vm, 0, ds_cnt);\n\n  for(i=0; i<ds_cnt; i++) {\n    /* a single serie table, preallocated */\n    lua_createtable(vm, npoints, 0);\n    p = data + i;\n\n    for(j=0; j<npoints; j++) {\n      rrd_value_t value = *p;\n      /* we are accessing data table by columns */\n      p = p + ds_cnt;\n      lua_pushnumber(vm, (lua_Number)value);\n      lua_rawseti(vm, -2, j+1);\n    }\n\n    /* add the single serie to the series table */\n    lua_setfield(vm, -2, names[i]);\n    rrd_freemem(names[i]);\n  }\n\n  rrd_freemem(names);\n  rrd_freemem(data);\n\n  /* end and npoints as last values */\n  lua_pushnumber(vm, (lua_Number) end);\n  lua_pushnumber(vm, (lua_Number) npoints);\n\n  /* number of return values */\n  return(5);\n}\n\n/* ****************************************** */\n\nstatic int ntop_http_redirect(lua_State* vm) {\n  char *url, str[512];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((url = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  snprintf(str, sizeof(str), \"HTTP/1.1 302 Found\\r\\n\"\n\t   \"Location: %s\\r\\n\\r\\n\"\n\t   \"<html>\\n\"\n\t   \"<head>\\n\"\n\t   \"<title>Moved</title>\\n\"\n\t   \"</head>\\n\"\n\t   \"<body>\\n\"\n\t   \"<h1>Moved</h1>\\n\"\n\t   \"<p>This page has moved to <a href=\\\"%s\\\">%s</a>.</p>\\n\"\n\t   \"</body>\\n\"\n\t   \"</html>\\n\", url, url, url);\n\n  lua_pushstring(vm, str);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_http_get(lua_State* vm) {\n  char *url, *username = NULL, *pwd = NULL;\n  int timeout = 30;\n  bool return_content = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((url = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 2) == LUA_TSTRING) {\n    username = (char*)lua_tostring(vm, 2);\n\n    if(lua_type(vm, 3) == LUA_TSTRING) {\n      pwd = (char*)lua_tostring(vm, 3);\n\n      if(lua_type(vm, 4) == LUA_TNUMBER) {\n\ttimeout = lua_tointeger(vm, 4);\n\tif(timeout < 1) timeout = 1;\n\n\t/*\n\t  This optional parameter specifies if the result of HTTP GET has to be returned\n\t  to LUA or not. Usually the content has to be returned, but in some causes\n\t  it just matters to time (for instance when use for testing HTTP services)\n\t*/\n\tif(lua_type(vm, 4) == LUA_TBOOLEAN) {\n\t  return_content = lua_toboolean(vm, 5) ? true : false;\n\t}\n      }\n    }\n  }\n\n  if(Utils::httpGet(vm, url, username, pwd, timeout, return_content))\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_http_get_prefix(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushstring(vm, ntop->getPrefs()->get_http_prefix());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_prefs(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getPrefs()->lua(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_nologin_username(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushstring(vm, NTOP_NOLOGIN_USER);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_users(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getUsers(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_user_group(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getUserGroup(vm);\n  return(CONST_LUA_OK);\n}\n\n\n/* ****************************************** */\n\nstatic int ntop_get_allowed_networks(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  ntop->getAllowedNetworks(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reset_user_password(lua_State* vm) {\n  char *who, *username, *old_password, *new_password;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  /* Username who requested the password change */\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((who = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((old_password = (char*)lua_tostring(vm, 3)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((new_password = (char*)lua_tostring(vm, 4)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if((!Utils::isUserAdministrator(vm)) && (strcmp(who, username)))\n    return(CONST_LUA_ERROR);\n\n  return(ntop->resetUserPassword(username, old_password, new_password));\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_user_role(lua_State* vm) {\n  char *username, *user_role;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((user_role = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeUserRole(username, user_role);\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_allowed_nets(lua_State* vm) {\n  char *username, *allowed_nets;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_nets = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeAllowedNets(username, allowed_nets);\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_allowed_ifname(lua_State* vm) {\n  char *username, *allowed_ifname;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_ifname = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeAllowedIfname(username, allowed_ifname);\n}\n\n/* ****************************************** */\n\nstatic int ntop_change_user_host_pool(lua_State* vm) {\n  char *username, *host_pool_id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((host_pool_id = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->changeUserHostPool(username, host_pool_id);\n}\n\n/* ****************************************** */\n\nstatic int ntop_post_http_json_data(lua_State* vm) {\n  char *username, *password, *url, *json;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((password = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((url = (char*)lua_tostring(vm, 3)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((json = (char*)lua_tostring(vm, 4)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(Utils::postHTTPJsonData(username, password, url, json))\n    return(CONST_LUA_OK);\n  else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_add_user(lua_State* vm) {\n  char *username, *full_name, *password, *host_role, *allowed_networks, *allowed_interface, *host_pool_id = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((full_name = (char*)lua_tostring(vm, 2)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((password = (char*)lua_tostring(vm, 3)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((host_role = (char*)lua_tostring(vm, 4)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 5, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_networks = (char*)lua_tostring(vm, 5)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 6, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((allowed_interface = (char*)lua_tostring(vm, 6)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 7) == LUA_TSTRING)\n    if((host_pool_id = (char*)lua_tostring(vm, 7)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->addUser(username, full_name, password, host_role,\n\t\t       allowed_networks, allowed_interface, host_pool_id);\n}\n\n/* ****************************************** */\n\nstatic int ntop_add_user_lifetime(lua_State* vm) {\n  char *username;\n  int32_t num_secs;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_PARAM_ERROR);\n  num_secs = (int32_t)lua_tonumber(vm, 2);\n\n  if(num_secs > 0)\n    return ntop->addUserLifetime(username, num_secs) ? CONST_LUA_OK : CONST_LUA_ERROR;\n\n  return CONST_LUA_OK; /* Negative or zero lifetimes means unlimited */\n}\n\n/* ****************************************** */\n\nstatic int ntop_clear_user_lifetime(lua_State* vm) {\n  char *username;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->clearUserLifetime(username) ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_delete_user(lua_State* vm) {\n  char *username;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((username = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  return ntop->deleteUser(username);\n}\n\n/* ****************************************** */\n\nstatic int ntop_resolve_address(lua_State* vm) {\n  char *numIP, symIP[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((numIP = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  ntop->resolveHostName(numIP, symIP, sizeof(symIP));\n  lua_pushstring(vm, symIP);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nvoid lua_push_str_table_entry(lua_State *L, const char *key, char *value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushstring(L, value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_nil_table_entry(lua_State *L, const char *key) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushnil(L);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_bool_table_entry(lua_State *L, const char *key, bool value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushboolean(L, value ? 1 : 0);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_int_table_entry(lua_State *L, const char *key, u_int64_t value) {\n  if(L) {\n    lua_pushstring(L, key);\n    /* using LUA_NUMBER (double: 64 bit) in place of LUA_INTEGER (ptrdiff_t: 32 or 64 bit\n     * according to the platform, as defined in luaconf.h) to handle big counters */\n    lua_pushnumber(L, (lua_Number)value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_int32_table_entry(lua_State *L, const char *key, int32_t value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushnumber(L, (lua_Number)value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nvoid lua_push_float_table_entry(lua_State *L, const char *key, float value) {\n  if(L) {\n    lua_pushstring(L, key);\n    lua_pushnumber(L, value);\n    lua_settable(L, -3);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_interface_stats(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  /*\n  ntop_interface->getAlertsManager()->engageAlert(alert_entity_host, \"127.0.0.1\",\n\t\t\t\t\t\t  \"min_bytes\",\n\t\t\t\t\t\t  alert_threshold_exceeded,\n\t\t\t\t\t\t  alert_level_warning,\n\t\t\t\t\t\t  \"miao\");\n  ntop_interface->getAlertsManager()->releaseAlert(alert_entity_host, \"127.0.0.1\",\n\t\t\t\t\t\t   \"min_bytes\",\n\t\t\t\t\t\t   alert_threshold_exceeded,\n\t\t\t\t\t\t   alert_level_warning,\n\t\t\t\t\t\t   \"miao\");\n  */\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) ntop_interface->lua(vm);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_reset_counters(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool only_drops = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    only_drops = lua_toboolean(vm, 1) ? true : false;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  ntop_interface->checkPointCounters(only_drops);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_is_pro(lua_State *vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  lua_pushboolean(vm, ntop->getPrefs()->is_pro_edition());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_is_enterprise(lua_State *vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  lua_pushboolean(vm, ntop->getPrefs()->is_enterprise_edition());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reload_host_pools(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n\n    ntop_interface->getHostPools()->reloadPools();\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n#ifdef NTOPNG_PRO\nstatic int ntop_purge_expired_host_pools_members(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n\n    ntop_interface->getHostPools()->purgeExpiredVolatileMembers();\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\nstatic int ntop_remove_volatile_member_from_pool(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_or_mac;\n  u_int16_t pool_id;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n  if((host_or_mac = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_PARAM_ERROR);\n  pool_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if(ntop_interface && ntop_interface->getHostPools()) {\n\n    ntop_interface->getHostPools()->removeVolatileMemberFromPool(host_or_mac, pool_id);\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n#endif\n/* ****************************************** */\n\nstatic int ntop_reload_l7_rules(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_interface) {\n#ifdef NTOPNG_PRO\n    u_int16_t host_pool_id = (u_int16_t)lua_tonumber(vm, 1);\n\n#ifdef SHAPER_DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%s(%i)\", __FUNCTION__, host_pool_id);\n#endif\n\n    ntop_interface->refreshL7Rules();\n    ntop_interface->updateHostsL7Policy(host_pool_id);\n    ntop_interface->updateFlowsL7Policy();\n#endif\n\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_reload_shapers(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface) {\n#ifdef NTOPNG_PRO\n    ntop_interface->refreshShapers();\n#endif\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_exec_sql_query(lua_State *vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  bool limit_rows = true;  // honour the limit by default\n  bool wait_for_db_created = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n  else {\n    char *sql;\n\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_PARAM_ERROR);\n    if((sql = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n    if(lua_type(vm, 2) == LUA_TBOOLEAN) {\n      limit_rows = lua_toboolean(vm, 2) ? true : false;\n    }\n\n    if(lua_type(vm, 3) == LUA_TBOOLEAN) {\n      wait_for_db_created = lua_toboolean(vm, 3) ? true : false;\n    }\n\n    if(ntop_interface->exec_sql_query(vm, sql, limit_rows, wait_for_db_created) < 0)\n      lua_pushnil(vm);\n\n    return(CONST_LUA_OK);\n  }\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_dirs(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_newtable(vm);\n  lua_push_str_table_entry(vm, \"installdir\", ntop->get_install_dir());\n  lua_push_str_table_entry(vm, \"workingdir\", ntop->get_working_dir());\n  lua_push_str_table_entry(vm, \"scriptdir\", ntop->getPrefs()->get_scripts_dir());\n  lua_push_str_table_entry(vm, \"httpdocsdir\", ntop->getPrefs()->get_docs_dir());\n  lua_push_str_table_entry(vm, \"callbacksdir\", ntop->getPrefs()->get_callbacks_dir());\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_uptime(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushinteger(vm, ntop->getGlobals()->getUptime());\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_check_license(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n#ifdef NTOPNG_PRO\n  ntop->getPro()->check_license();\n#endif\n\n  lua_pushinteger(vm,1);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_info(lua_State* vm) {\n  char rsp[256];\n  int major, minor, patch;\n  bool verbose = true;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    verbose = lua_toboolean(vm, 1) ? true : false;\n\n  lua_newtable(vm);\n  lua_push_str_table_entry(vm, \"product\", (char*)\"ntopng\");\n  lua_push_str_table_entry(vm, \"copyright\", (char*)\"&copy; 1998-17 - ntop.org\");\n  lua_push_str_table_entry(vm, \"authors\", (char*)\"The ntop.org team\");\n  lua_push_str_table_entry(vm, \"license\", (char*)\"GNU GPLv3\");\n\n  lua_push_str_table_entry(vm, \"version\", (char*)PACKAGE_VERSION);\n  lua_push_str_table_entry(vm, \"git\", (char*)NTOPNG_GIT_RELEASE);\n\n  snprintf(rsp, sizeof(rsp), \"%s [%s][%s]\",\n\t   PACKAGE_OSNAME, PACKAGE_MACHINE, PACKAGE_OS);\n  lua_push_str_table_entry(vm, \"platform\", rsp);\n  lua_push_str_table_entry(vm, \"OS\",\n#ifdef WIN32\n\t\t\t   (char*)\"Windows\"\n#else\n\t\t\t   (char*)PACKAGE_OS\n#endif\n\t\t\t   );\n  lua_push_int_table_entry(vm, \"bits\", (sizeof(void*) == 4) ? 32 : 64);\n  lua_push_int_table_entry(vm, \"uptime\", ntop->getGlobals()->getUptime());\n  lua_push_str_table_entry(vm, \"command_line\", ntop->getPrefs()->get_command_line());\n\n  if(verbose) {\n    lua_push_str_table_entry(vm, \"version.rrd\", rrd_strversion());\n    lua_push_str_table_entry(vm, \"version.redis\", ntop->getRedis()->getVersion(rsp, sizeof(rsp)));\n    lua_push_str_table_entry(vm, \"version.httpd\", (char*)mg_version());\n    lua_push_str_table_entry(vm, \"version.git\", (char*)NTOPNG_GIT_RELEASE);\n    lua_push_str_table_entry(vm, \"version.luajit\", (char*)LUAJIT_VERSION);\n#ifdef HAVE_GEOIP\n    lua_push_str_table_entry(vm, \"version.geoip\", (char*)GeoIP_lib_version());\n#endif\n    lua_push_str_table_entry(vm, \"version.ndpi\", ndpi_revision());\n    lua_push_bool_table_entry(vm, \"version.enterprise_edition\", ntop->getPrefs()->is_enterprise_edition());\n    lua_push_bool_table_entry(vm, \"version.embedded_edition\", ntop->getPrefs()->is_embedded_edition());\n\n    lua_push_bool_table_entry(vm, \"pro.release\", ntop->getPrefs()->is_pro_edition());\n    lua_push_int_table_entry(vm, \"pro.demo_ends_at\", ntop->getPrefs()->pro_edition_demo_ends_at());\n#ifdef NTOPNG_PRO\n    lua_push_str_table_entry(vm, \"pro.license\", ntop->getPro()->get_license());\n    lua_push_bool_table_entry(vm, \"pro.use_redis_license\", ntop->getPro()->use_redis_license());\n    lua_push_str_table_entry(vm, \"pro.systemid\", ntop->getPro()->get_system_id());\n#endif\n\n#if 0\n    ntop->getRedis()->get((char*)CONST_STR_NTOPNG_LICENSE, rsp, sizeof(rsp));\n    lua_push_str_table_entry(vm, \"ntopng.license\", rsp);\n#endif\n\n    zmq_version(&major, &minor, &patch);\n    snprintf(rsp, sizeof(rsp), \"%d.%d.%d\", major, minor, patch);\n    lua_push_str_table_entry(vm, \"version.zmq\", rsp);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_resolved_address(lua_State* vm) {\n  char *key, *tmp,rsp[256],value[64];\n  Redis *redis = ntop->getRedis();\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &key, &vlan_id, buf, sizeof(buf));\n\n  if(key == NULL)\n    return(CONST_LUA_ERROR);\n\n  if(redis->getAddress(key, rsp, sizeof(rsp), true) == 0)\n    tmp = rsp;\n  else\n    tmp = key;\n\n  if(vlan_id != 0)\n    snprintf(value, sizeof(value), \"%s@%u\", tmp, vlan_id);\n  else\n    snprintf(value, sizeof(value), \"%s\", tmp);\n\n#if 0\n  if(!strcmp(value, key)) {\n    char rsp[64];\n\n    if((ntop->getRedis()->hashGet((char*)HOST_LABEL_NAMES, key, rsp, sizeof(rsp)) == 0)\n       && (rsp[0] !='\\0'))\n      lua_pushfstring(vm, \"%s\", rsp);\n    else\n      lua_pushfstring(vm, \"%s\", value);\n  } else\n    lua_pushfstring(vm, \"%s\", value);\n#else\n  lua_pushfstring(vm, \"%s\", value);\n#endif\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_snmp_get_fctn(lua_State* vm, int operation) {\n  char *agent_host, *oid, *community;\n  u_int agent_port = 161, timeout = 5, request_id = (u_int)time(NULL);\n  int sock, i = 0, rc = CONST_LUA_OK;\n  SNMPMessage *message;\n  int len;\n  unsigned char *buf;\n  bool debug = false;\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  agent_host = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  community = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  oid = (char*)lua_tostring(vm, 3);\n\n  sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n  if(sock < 0) return(CONST_LUA_ERROR);\n\n  message = snmp_create_message();\n  snmp_set_version(message, 0);\n  snmp_set_community(message, community);\n  snmp_set_pdu_type(message, operation);\n  snmp_set_request_id(message, request_id);\n  snmp_set_error(message, 0);\n  snmp_set_error_index(message, 0);\n  snmp_add_varbind_null(message, oid);\n\n  /* Add additional OIDs */\n  i = 4;\n  while(lua_type(vm, i) == LUA_TSTRING) {\n    snmp_add_varbind_null(message, (char*)lua_tostring(vm, i));\n    i++;\n  }\n\n  len = snmp_message_length(message);\n  buf = (unsigned char*)malloc(len);\n  snmp_render_message(message, buf);\n  snmp_destroy_message(message);\n\n  send_udp_datagram(buf, len, sock, agent_host, agent_port);\n  free(buf);\n\n  if(debug)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"SNMP %s %s@%s %s\",\n\t\t\t\t (operation == SNMP_GET_REQUEST_TYPE) ? \"Get\" : \"GetNext\",\n\t\t\t\t agent_host, community, oid);\n\n  if(input_timeout(sock, timeout) == 0) {\n    /* Timeout */\n\n    if(debug)\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"SNMP Timeout %s@%s %s\", agent_host, community, oid);\n    rc = CONST_LUA_ERROR;\n    lua_pushnil(vm);\n  } else {\n    char buf[BUFLEN];\n    SNMPMessage *message;\n    char *sender_host, *oid_str,  *value_str;\n    int sender_port, added = 0, len;\n\n    len = receive_udp_datagram(buf, BUFLEN, sock, &sender_host, &sender_port);\n    message = snmp_parse_message(buf, len);\n\n    i = 0;\n    while(snmp_get_varbind_as_string(message, i, &oid_str, NULL, &value_str)) {\n      if(!added) lua_newtable(vm), added = 1;\n      lua_push_str_table_entry(vm, oid_str, value_str);\n      if(debug)\n\tntop->getTrace()->traceEvent(TRACE_NORMAL, \"SNMP OK %s@%s %s=%s\", agent_host, community, oid_str, value_str);\n      i++;\n    }\n\n    snmp_destroy_message(message);\n\n    if(!added) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"SNMP Error %s@%s\", agent_host, community);\n      lua_pushnil(vm), rc = CONST_LUA_ERROR;\n    }\n  }\n\n  closesocket(sock);\n  return(rc);\n}\n\n/* ****************************************** */\n\nstatic int ntop_snmpget(lua_State* vm)     { return(ntop_snmp_get_fctn(vm, SNMP_GET_REQUEST_TYPE)); }\nstatic int ntop_snmpgetnext(lua_State* vm) { return(ntop_snmp_get_fctn(vm, SNMP_GETNEXT_REQUEST_TYPE)); }\n\n/* ****************************************** */\n\n/**\n * @brief Send a message to the system syslog\n * @details Send a message to the syslog syslog: callers can specify if it is an error or informational message\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_ERROR if the expected type is equal to function type, @ref CONST_LUA_PARAM_ERROR otherwise.\n */\nstatic int ntop_syslog(lua_State* vm) {\n#ifndef WIN32\n  char *msg;\n  bool is_error;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TBOOLEAN)) return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING))  return(CONST_LUA_ERROR);\n\n  is_error = lua_toboolean(vm, 1) ? true : false;\n  msg = (char*)lua_tostring(vm, 2);\n\n  syslog(is_error ? LOG_ERR : LOG_INFO, \"%s\", msg);\n#endif\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Generate a random value to prevent CSRF and XSRF attacks\n * @details See http://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/\n *\n * @param vm The lua state.\n * @return The random value just generated\n */\nstatic int ntop_generate_csrf_value(lua_State* vm) {\n  char random_a[32], random_b[32], csrf[33], user[64] = { '\\0' };\n  Redis *redis = ntop->getRedis();\n  struct mg_connection *conn;\n\n  lua_getglobal(vm, CONST_HTTP_CONN);\n  if((conn = (struct mg_connection*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: null HTTP connection\");\n    return(CONST_LUA_OK);\n  }\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n#ifdef __OpenBSD__\n  snprintf(random_a, sizeof(random_a), \"%d\", arc4random());\n  snprintf(random_b, sizeof(random_b), \"%lu\", time(NULL)*arc4random());\n#else\n  snprintf(random_a, sizeof(random_a), \"%d\", rand());\n  snprintf(random_b, sizeof(random_b), \"%lu\", time(NULL)*rand());\n#endif\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  mg_md5(csrf, random_a, random_b, NULL);\n\n  redis->set(csrf, (char*)user, MAX_CSRF_DURATION);\n  lua_pushfstring(vm, \"%s\", csrf);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstruct ntopng_sqlite_state {\n  lua_State* vm;\n  u_int num_rows;\n};\n\nstatic int sqlite_callback(void *data, int argc,\n\t\t\t   char **argv, char **azColName) {\n  struct ntopng_sqlite_state *s = (struct ntopng_sqlite_state*)data;\n\n  lua_newtable(s->vm);\n\n  for(int i=0; i<argc; i++)\n    lua_push_str_table_entry(s->vm, (const char*)azColName[i],\n\t\t\t     (char*)(argv[i] ? argv[i] : \"NULL\"));\n\n  lua_pushinteger(s->vm, ++s->num_rows);\n  lua_insert(s->vm, -2);\n  lua_settable(s->vm, -3);\n\n  return(0);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Exec SQL query\n * @details Execute the specified query and return the results\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_ERROR in case of error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_sqlite_exec_query(lua_State* vm) {\n  char *db_path, *db_query;\n  sqlite3 *db;\n  char *zErrMsg = 0;\n  struct ntopng_sqlite_state state;\n  struct stat buf;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  db_path = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  db_query = (char*)lua_tostring(vm, 2);\n\n  if(stat(db_path, &buf) != 0) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Not found database %s\",\n\t\t\t\t db_path);\n    return(CONST_LUA_ERROR);\n  }\n\n  if(sqlite3_open(db_path, &db)) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Unable to open %s: %s\",\n\t\t\t\t db_path, sqlite3_errmsg(db));\n    return(CONST_LUA_ERROR);\n  }\n\n  state.vm = vm, state.num_rows = 0;\n  lua_newtable(vm);\n  if(sqlite3_exec(db, db_query, sqlite_callback, (void*)&state, &zErrMsg)) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"SQL Error: %s\", zErrMsg);\n    sqlite3_free(zErrMsg);\n  }\n\n  sqlite3_close(db);\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Insert a new minute sampling in the historical database\n * @details Given a certain sampling point, store statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_insert_minute_sampling(lua_State *vm) {\n  char *sampling;\n  time_t rawtime;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((sampling = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  time(&rawtime);\n\n  if(sm->insertMinuteSampling(rawtime, sampling))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Insert a new hour sampling in the historical database\n * @details Given a certain sampling point, store statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_insert_hour_sampling(lua_State *vm) {\n  char *sampling;\n  time_t rawtime;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((sampling = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  time(&rawtime);\n  rawtime -= (rawtime % 60);\n\n  if(sm->insertHourSampling(rawtime, sampling))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Insert a new day sampling in the historical database\n * @details Given a certain sampling point, store statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_insert_day_sampling(lua_State *vm) {\n  char *sampling;\n  time_t rawtime;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((sampling = (char*)lua_tostring(vm, 2)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  time(&rawtime);\n  rawtime -= (rawtime % 60);\n\n  if(sm->insertDaySampling(rawtime, sampling))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Get a minute sampling from the historical database\n * @details Given a certain sampling point, get statistics for said\n *          sampling point.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_minute_sampling(lua_State *vm) {\n  time_t epoch;\n  string sampling;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch = (time_t)lua_tointeger(vm, 2);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->getMinuteSampling(epoch, &sampling))\n    return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, sampling.c_str());\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Delete minute stats older than a certain number of days.\n * @details Given a number of days, delete stats for the current interface that\n *          are older than a certain number of days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_delete_minute_older_than(lua_State *vm) {\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 2);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->deleteMinuteStatsOlderThan(num_days))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Delete hour stats older than a certain number of days.\n * @details Given a number of days, delete stats for the current interface that\n *          are older than a certain number of days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_delete_hour_older_than(lua_State *vm) {\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 2);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->deleteHourStatsOlderThan(num_days))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Delete day stats older than a certain number of days.\n * @details Given a number of days, delete stats for the current interface that\n *          are older than a certain number of days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_delete_day_older_than(lua_State *vm) {\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!Utils::isUserAdministrator(vm)) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 2);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->deleteDayStatsOlderThan(num_days))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Get an interval of minute stats samplings from the historical database\n * @details Given a certain interval of sampling points, get statistics for said\n *          sampling points.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_minute_samplings_interval(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_start = lua_tointeger(vm, 2);\n  if(epoch_start < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 3);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(sm->retrieveMinuteStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Given an epoch, get minute stats for the latest n minutes\n * @details Given a certain sampling point, get statistics for that point and\n *          for all timepoints spanning an interval of a given number of\n *          minutes.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_samplings_of_minutes_from_epoch(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int num_minutes;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 2);\n  epoch_end -= (epoch_end % 60);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_minutes = lua_tointeger(vm, 3);\n  if(num_minutes < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  epoch_start = epoch_end - (60 * num_minutes);\n\n  if(sm->retrieveMinuteStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Given an epoch, get hour stats for the latest n hours\n * @details Given a certain sampling point, get statistics for that point and\n *          for all timepoints spanning an interval of a given number of\n *          hours.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_samplings_of_hours_from_epoch(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int num_hours;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 2);\n  epoch_end -= (epoch_end % 60);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_hours = lua_tointeger(vm, 3);\n  if(num_hours < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  epoch_start = epoch_end - (num_hours * 60 * 60);\n\n  if(sm->retrieveHourStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/**\n * @brief Given an epoch, get hour stats for the latest n days\n * @details Given a certain sampling point, get statistics for that point and\n *          for all timepoints spanning an interval of a given number of\n *          days.\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_PARAM_ERROR in case of wrong parameter,\n *              CONST_LUA_ERROR in case of generic error, CONST_LUA_OK otherwise.\n */\nstatic int ntop_stats_get_samplings_of_days_from_epoch(lua_State *vm) {\n  time_t epoch_start, epoch_end;\n  int num_days;\n  int ifid;\n  NetworkInterface* iface;\n  StatsManager *sm;\n  struct statsManagerRetrieval retvals;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  epoch_end = lua_tointeger(vm, 2);\n  epoch_end -= (epoch_end % 60);\n  if(epoch_end < 0)\n    return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  num_days = lua_tointeger(vm, 3);\n  if(num_days < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(ifid)) ||\n     !(sm = iface->getStatsManager()))\n    return (CONST_LUA_ERROR);\n\n  epoch_start = epoch_end - (num_days * 24 * 60 * 60);\n\n  if(sm->retrieveDayStatsInterval(epoch_start, epoch_end, &retvals))\n    return(CONST_LUA_ERROR);\n\n  lua_newtable(vm);\n\n  for (unsigned i = 0 ; i < retvals.rows.size() ; i++)\n    lua_push_str_table_entry(vm, retvals.rows[i].c_str(), (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_delete_dump_files(lua_State *vm) {\n  int ifid;\n  char pcap_path[MAX_PATH];\n  NetworkInterface *iface;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  if((ifid = lua_tointeger(vm, 1)) < 0) return(CONST_LUA_ERROR);\n  if(!(iface = ntop->getNetworkInterface(ifid))) return(CONST_LUA_ERROR);\n\n  snprintf(pcap_path, sizeof(pcap_path), \"%s/%d/pcap/\",\n\t   ntop->get_working_dir(), ifid);\n  ntop->fixPath(pcap_path);\n\n  if(Utils::discardOldFilesExceeding(pcap_path, iface->getDumpTrafficMaxFiles()))\n    return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_mkdir_tree(lua_State* vm) {\n  char *dir;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((dir = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if(dir[0] == '\\0')                                   return(CONST_LUA_OK); /* Nothing to do */\n\n  return(Utils::mkdir_tree(dir));\n}\n\n/* ****************************************** */\n\nstatic int ntop_list_reports(lua_State* vm) {\n  DIR *dir;\n  char fullpath[MAX_PATH];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_newtable(vm);\n  snprintf(fullpath, sizeof(fullpath), \"%s/%s\", ntop->get_working_dir(), \"reports\");\n  ntop->fixPath(fullpath);\n  if((dir = opendir(fullpath)) != NULL) {\n    struct dirent *ent;\n\n    while ((ent = readdir(dir)) != NULL) {\n      char filepath[MAX_PATH];\n      snprintf(filepath, sizeof(filepath), \"%s/%s\", fullpath, ent->d_name);\n      ntop->fixPath(filepath);\n      struct stat buf;\n      if(!stat(filepath, &buf) && !S_ISDIR(buf.st_mode))\n\tlua_push_str_table_entry(vm, ent->d_name, (char*)\"\");\n    }\n    closedir(dir);\n  }\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_redis(lua_State* vm) {\n  char *key, *rsp;\n  u_int rsp_len = 32768;\n  Redis *redis = ntop->getRedis();\n  bool cache_it = false;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  /* Optional cache_it */\n  if(lua_type(vm, 2) == LUA_TBOOLEAN) cache_it = lua_toboolean(vm, 2);\n\n\n  if((rsp = (char*)malloc(rsp_len)) != NULL) {\n    lua_pushfstring(vm, \"%s\", (redis->get(key, rsp, rsp_len, cache_it) == 0) ? rsp : (char*)\"\");\n    free(rsp);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_hash_redis(lua_State* vm) {\n  char *key, *member, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  lua_pushfstring(vm, \"%s\", (redis->hashGet(key, member, rsp, sizeof(rsp)) == 0) ? rsp : (char*)\"\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_hash_redis(lua_State* vm) {\n  char *key, *member, *value;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n  if((value  = (char*)lua_tostring(vm, 3)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  redis->hashSet(key, member, value);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_del_hash_redis(lua_State* vm) {\n  char *key, *member;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  redis->hashDel(key, member);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_hash_keys_redis(lua_State* vm) {\n  char *key, **vals;\n  Redis *redis = ntop->getRedis();\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  rc = redis->hashKeys(key, &vals);\n\n  if(rc > 0) {\n    lua_newtable(vm);\n\n    for(int i = 0; i < rc; i++) {\n      lua_push_str_table_entry(vm, vals[i] ? vals[i] : \"\", (char*)\"\");\n      if(vals[i]) free(vals[i]);\n    }\n    free(vals);\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_keys_redis(lua_State* vm) {\n  char *pattern, **keys;\n  Redis *redis = ntop->getRedis();\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((pattern = (char*)lua_tostring(vm, 1)) == NULL)   return(CONST_LUA_PARAM_ERROR);\n\n  rc = redis->keys(pattern, &keys);\n\n  if(rc > 0) {\n    lua_newtable(vm);\n\n    for(int i = 0; i < rc; i++) {\n      lua_push_str_table_entry(vm, keys[i] ? keys[i] : \"\", (char*)\"\");\n      if(keys[i]) free(keys[i]);\n    }\n    free(keys);\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lrange_redis(lua_State* vm) {\n  char *l_name, **l_elements;\n  Redis *redis = ntop->getRedis();\n  int start_offset = 0, end_offset = -1;\n  int rc;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((l_name = (char*)lua_tostring(vm, 1)) == NULL)   return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 2) == LUA_TNUMBER) {\n    start_offset = lua_tointeger(vm, 2);\n  }\n  if(lua_type(vm, 3) == LUA_TNUMBER) {\n    end_offset = lua_tointeger(vm, 3);\n  }\n\n  rc = redis->lrange(l_name, &l_elements, start_offset, end_offset);\n\n  if(rc > 0) {\n    lua_newtable(vm);\n\n    for(int i = 0; i < rc; i++) {\n      lua_push_str_table_entry(vm, l_elements[i] ? l_elements[i] : \"\", (char*)\"\");\n      if(l_elements[i]) free(l_elements[i]);\n    }\n    free(l_elements);\n  } else\n    lua_pushnil(vm);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_get_redis_set_pop(lua_State* vm) {\n  char *set_name, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((set_name = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n  lua_pushfstring(vm, \"%s\", redis->popSet(set_name, rsp, sizeof(rsp)));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_list_index_redis(lua_State* vm) {\n  char *index_name, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n  int idx;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n  if((index_name = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  idx = lua_tointeger(vm, 2);\n\n  if(redis->lindex(index_name, idx, rsp, sizeof(rsp)) != 0)\n    return(CONST_LUA_ERROR);\n\n  lua_pushfstring(vm, \"%s\", rsp);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lpop_redis(lua_State* vm) {\n  char msg[1024], *list_name;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((list_name = (char*)lua_tostring(vm, 1)) == NULL) return(CONST_LUA_PARAM_ERROR);\n\n  if(redis->lpop(list_name, msg, sizeof(msg)) == 0) {\n    lua_pushfstring(vm, \"%s\", msg);\n    return(CONST_LUA_OK);\n  } else\n    return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lpush_redis(lua_State* vm) {\n  char *list_name, *value;\n  u_int list_trim_size = 0;  // default 0 = no trim\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((list_name = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  /* Optional trim list up to the specified number of elements */\n  if(lua_type(vm, 3) == LUA_TNUMBER)\n      list_trim_size = (u_int)lua_tonumber(vm, 3);\n\n  if(redis->lpush(list_name, value, list_trim_size) == 0) {\n      return(CONST_LUA_OK);\n  }else\n      return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_redis_get_host_id(lua_State* vm) {\n  char *host_name;\n  Redis *redis = ntop->getRedis();\n  char daybuf[32];\n  time_t when = time(NULL);\n  bool new_key;\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((host_name = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  strftime(daybuf, sizeof(daybuf), CONST_DB_DAY_FORMAT, localtime(&when));\n  lua_pushinteger(vm, redis->host_to_id(ntop_interface, daybuf, host_name, &new_key)); /* CHECK */\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_redis_get_id_to_host(lua_State* vm) {\n  char *host_idx, rsp[CONST_MAX_LEN_REDIS_VALUE];\n  Redis *redis = ntop->getRedis();\n  char daybuf[32];\n  time_t when = time(NULL);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((host_idx = (char*)lua_tostring(vm, 1)) == NULL)  return(CONST_LUA_PARAM_ERROR);\n\n  strftime(daybuf, sizeof(daybuf), CONST_DB_DAY_FORMAT, localtime(&when));\n  lua_pushfstring(vm, \"%d\", redis->id_to_host(daybuf, host_idx, rsp, sizeof(rsp)));\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n#ifdef NOTUSED\nstatic int ntop_interface_store_alert(lua_State* vm) {\n  int ifid;\n  NetworkInterface* iface;\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TTABLE)) return(CONST_LUA_ERROR);\n\n  ifid = lua_tointeger(vm, 1);\n  if(ifid < 0)\n    return(CONST_LUA_ERROR);\n\n  if(!(iface = ntop->getNetworkInterface(vm, ifid)) ||\n     !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  return am->storeAlert(vm, 2) ? CONST_LUA_ERROR : CONST_LUA_OK;\n}\n#endif\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_release_host_alert(lua_State* vm, bool engage) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n  Host *h;\n  int alert_severity;\n  int alert_type;\n  char *alert_json, *engaged_alert_id;\n  AlertsManager *am;\n  int ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  engaged_alert_id = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_type = (int)lua_tonumber(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_severity = (int)lua_tonumber(vm, 4);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 5, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_json = (char*)lua_tostring(vm, 5);\n\n  if((!ntop_interface)\n     || ((h = ntop_interface->findHostsByIP(get_allowed_nets(vm), host_ip, vlan_id)) == NULL)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(engage)\n    ret = am->engageHostAlert(h, engaged_alert_id,\n\t\t\t      (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n  else\n    ret = am->releaseHostAlert(h, engaged_alert_id,\n\t\t\t       (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n\n  return ret >= 0 ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_release_network_alert(lua_State* vm, bool engage) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *cidr;\n  int alert_severity;\n  int alert_type;\n  char *alert_json, *engaged_alert_id;\n  AlertsManager *am;\n  int ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  cidr = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  engaged_alert_id = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_type = (int)lua_tonumber(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_severity = (int)lua_tonumber(vm, 4);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 5, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_json = (char*)lua_tostring(vm, 5);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(engage)\n    ret = am->engageNetworkAlert(cidr, engaged_alert_id,\n\t\t\t\t (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n  else\n    ret = am->releaseNetworkAlert(cidr, engaged_alert_id,\n\t\t\t\t  (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n\n  return ret >= 0 ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_release_interface_alert(lua_State* vm, bool engage) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int alert_severity;\n  int alert_type;\n  char *alert_json, *engaged_alert_id;\n  AlertsManager *am;\n  int ret;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  engaged_alert_id = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_type = (int)lua_tonumber(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_severity = (int)lua_tonumber(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_json = (char*)lua_tostring(vm, 4);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  if(engage)\n    ret = am->engageInterfaceAlert(ntop_interface, engaged_alert_id,\n\t\t\t\t   (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n  else\n    ret = am->releaseInterfaceAlert(ntop_interface, engaged_alert_id,\n\t\t\t\t    (AlertType)alert_type, (AlertLevel)alert_severity, alert_json);\n\n  return ret >= 0 ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_host_alert(lua_State* vm) {\n  return ntop_interface_engage_release_host_alert(vm, true /* engage */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_release_host_alert(lua_State* vm) {\n  return ntop_interface_engage_release_host_alert(vm, false /* release */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_network_alert(lua_State* vm) {\n  return ntop_interface_engage_release_network_alert(vm, true /* engage */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_release_network_alert(lua_State* vm) {\n  return ntop_interface_engage_release_network_alert(vm, false /* release */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_engage_interface_alert(lua_State* vm) {\n  return ntop_interface_engage_release_interface_alert(vm, true /* engage */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_release_interface_alert(lua_State* vm) {\n  return ntop_interface_engage_release_interface_alert(vm, false /* release */);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_get_cached_num_alerts(lua_State* vm) {\n  NetworkInterface *iface = getCurrentInterface(vm);\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!iface || !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  return (!am->getCachedNumAlerts(vm)) ? CONST_LUA_OK : CONST_LUA_ERROR;\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_make_room_alerts(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  int alert_entity;\n  char *alert_entity_value, *table_name;\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  alert_entity = (int)lua_tonumber(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_entity_value = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  table_name = (char*)lua_tostring(vm, 3);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  am->makeRoom((AlertEntity)alert_entity, alert_entity_value, table_name);\n\n  return CONST_LUA_OK;\n}\n\n\n/* ****************************************** */\n\nstatic int ntop_interface_make_room_requested(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  AlertsManager *am;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if((!ntop_interface)\n     || ((am = ntop_interface->getAlertsManager()) == NULL))\n    return(CONST_LUA_ERROR);\n\n  lua_pushboolean(vm, am->makeRoomRequested());\n\n  return(CONST_LUA_OK);\n\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_query_alerts_raw(lua_State* vm) {\n  NetworkInterface *iface = getCurrentInterface(vm);\n  AlertsManager *am;\n  bool engaged = false;\n  char *selection = NULL, *clauses = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!iface || !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) == LUA_TBOOLEAN)\n    engaged = lua_toboolean(vm, 1);\n\n  if(lua_type(vm, 2) == LUA_TSTRING)\n    if((selection = (char*)lua_tostring(vm, 2)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 3) == LUA_TSTRING)\n    if((clauses = (char*)lua_tostring(vm, 3)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(am->queryAlertsRaw(vm, engaged, selection, clauses))\n    return(CONST_LUA_ERROR);\n\n  return (CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_interface_query_flow_alerts_raw(lua_State* vm) {\n  NetworkInterface *iface = getCurrentInterface(vm);\n  AlertsManager *am;\n  char *selection = NULL, *clauses = NULL;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(!iface || !(am = iface->getAlertsManager()))\n    return (CONST_LUA_ERROR);\n\n  if(lua_type(vm, 1) == LUA_TSTRING)\n    if((selection = (char*)lua_tostring(vm, 1)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(lua_type(vm, 2) == LUA_TSTRING)\n    if((clauses = (char*)lua_tostring(vm, 2)) == NULL)\n      return(CONST_LUA_PARAM_ERROR);\n\n  if(am->queryFlowAlertsRaw(vm, selection, clauses))\n    return(CONST_LUA_ERROR);\n\n  return (CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n#if NTOPNG_PRO\n\nstatic int ntop_nagios_reload_config(lua_State* vm) {\n  NagiosManager *nagios = ntop->getNagios();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n  if(!nagios) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s(): unable to get the nagios manager\",\n\t\t\t\t __FUNCTION__);\n    return(CONST_LUA_ERROR);\n  }\n  nagios->loadConfig();\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\nstatic int ntop_nagios_send_alert(lua_State* vm) {\n  NagiosManager *nagios = ntop->getNagios();\n  char *alert_source;\n  char *timespan;\n  char *alarmed_metric;\n  char *alert_msg;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_source = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  timespan = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alarmed_metric = (char*)lua_tostring(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_msg = (char*)lua_tostring(vm, 4);\n\n  nagios->sendAlert(alert_source, timespan, alarmed_metric, alert_msg);\n\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\nstatic int ntop_nagios_withdraw_alert(lua_State* vm) {\n  NagiosManager *nagios = ntop->getNagios();\n  char *alert_source;\n  char *timespan;\n  char *alarmed_metric;\n  char *alert_msg;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_source = (char*)lua_tostring(vm, 1);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  timespan = (char*)lua_tostring(vm, 2);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 3, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alarmed_metric = (char*)lua_tostring(vm, 3);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 4, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  alert_msg = (char*)lua_tostring(vm, 4);\n\n  nagios->withdrawAlert(alert_source, timespan, alarmed_metric, alert_msg);\n\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n\n#endif\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\nstatic int ntop_check_profile_syntax(lua_State* vm) {\n  char *filter;\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  filter = (char*)lua_tostring(vm, 1);\n\n  lua_pushboolean(vm, ntop_interface ? ntop_interface->checkProfileSyntax(filter) : false);\n\n  return(CONST_LUA_OK);\n}\n#endif\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\nstatic int ntop_reload_traffic_profiles(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_interface)\n    ntop_interface->updateFlowProfiles(); /* Reload profiles in memory */\n\n  lua_pushnil(vm);\n  return(CONST_LUA_OK);\n}\n#endif\n\n/* ****************************************** */\n\nstatic int ntop_set_redis(lua_State* vm) {\n  char *key, *value;\n  u_int expire_secs = 0;  // default 0 = no expiration\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  /* Optional key expiration in SECONDS */\n  if(lua_type(vm, 3) == LUA_TNUMBER)\n      expire_secs = (u_int)lua_tonumber(vm, 3);\n\n  if(redis->set(key, value, expire_secs) == 0) {\n      return(CONST_LUA_OK);\n  }else\n      return(CONST_LUA_ERROR);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_redis_preference(lua_State* vm) {\n  char *key, *value;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 2, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((value = (char*)lua_tostring(vm, 2)) == NULL)     return(CONST_LUA_PARAM_ERROR);\n\n  if(redis->set(key, value) ||\n     ntop->getPrefs()->refresh(key, value))\n      return(CONST_LUA_ERROR);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_lua_http_print(lua_State* vm) {\n  struct mg_connection *conn;\n  char *printtype;\n  int t;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_HTTP_CONN);\n  if((conn = (struct mg_connection*)lua_touserdata(vm, lua_gettop(vm))) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"INTERNAL ERROR: null HTTP connection\");\n    return(CONST_LUA_OK);\n  }\n\n  /* Handle binary blob */\n  if(lua_type(vm, 2) == LUA_TSTRING &&\n     (printtype = (char*)lua_tostring(vm, 2)) != NULL)\n    if(!strncmp(printtype, \"blob\", 4)) {\n      char *str = NULL;\n\n      if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return (CONST_LUA_ERROR);\n      if((str = (char*)lua_tostring(vm, 1)) != NULL) {\n\tint len = strlen(str);\n\n\tif(len <= 1)\n\t  mg_printf(conn, \"%c\", str[0]);\n\telse\n\t  return (CONST_LUA_PARAM_ERROR);\n      }\n\n      return (CONST_LUA_OK);\n    }\n\n  switch(t = lua_type(vm, 1)) {\n  case LUA_TNIL:\n    mg_printf(conn, \"%s\", \"nil\");\n    break;\n\n  case LUA_TBOOLEAN:\n    {\n      int v = lua_toboolean(vm, 1);\n\n      mg_printf(conn, \"%s\", v ? \"true\" : \"false\");\n    }\n    break;\n\n  case LUA_TSTRING:\n    {\n      char *str = (char*)lua_tostring(vm, 1);\n\n      if(str && (strlen(str) > 0))\n\tmg_printf(conn, \"%s\", str);\n    }\n    break;\n\n  case LUA_TNUMBER:\n    {\n      char str[64];\n\n      snprintf(str, sizeof(str), \"%f\", (float)lua_tonumber(vm, 1));\n      mg_printf(conn, \"%s\", str);\n    }\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s(): Lua type %d is not handled\",\n\t\t\t\t __FUNCTION__, t);\n    return(CONST_LUA_ERROR);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nint ntop_lua_cli_print(lua_State* vm) {\n  int t;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  switch(t = lua_type(vm, 1)) {\n  case LUA_TSTRING:\n    {\n      char *str = (char*)lua_tostring(vm, 1);\n\n      if(str && (strlen(str) > 0))\n\tntop->getTrace()->traceEvent(TRACE_NORMAL, \"%s\", str);\n    }\n    break;\n\n  case LUA_TNUMBER:\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%f\", (float)lua_tonumber(vm, 1));\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s(): Lua type %d is not handled\",\n\t\t\t\t __FUNCTION__, t);\n    return(CONST_LUA_ERROR);\n  }\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n#ifdef NTOPNG_PRO\nstatic int __ntop_lua_handlefile(lua_State* L, char *script_path, bool ex)\n{\n  int rc;\n  LuaHandler *lh = new LuaHandler(L, script_path);\n\n  rc = lh->luaL_dofileM(ex);\n  delete lh;\n  return rc;\n}\n\n/* This function is called by Lua scripts when the call require(...) */\nstatic int ntop_lua_require(lua_State* L)\n{\n  char *script_name;\n\n  if(lua_type(L, 1) != LUA_TSTRING ||\n     (script_name = (char*)lua_tostring(L, 1)) == NULL)\n    return 0;\n\n  lua_getglobal( L, \"package\" );\n  lua_getfield( L, -1, \"path\" );\n\n  string cur_path = lua_tostring( L, -1 ), parsed, script_path = \"\";\n  stringstream input_stringstream(cur_path);\n  while(getline(input_stringstream, parsed, ';')) {\n    /* Example: package.path = dirs.installdir .. \"/scripts/lua/modules/?.lua;\" .. package.path */\n    unsigned found = parsed.find_last_of(\"?\");\n    if(found) {\n      string s = parsed.substr(0, found) + script_name + \".lua\";\n      if(Utils::file_exists(s.c_str())) {\n\tscript_path = s;\n\tbreak;\n      }\n    }\n  }\n\n  if(script_path == \"\" ||\n     __ntop_lua_handlefile(L, (char *)script_path.c_str(), false))\n    return 0;\n\n  return 1;\n}\n\nstatic int ntop_lua_dofile(lua_State* L)\n{\n  char *script_path;\n\n  if(lua_type(L, 1) != LUA_TSTRING ||\n     (script_path = (char*)lua_tostring(L, 1)) == NULL ||\n     __ntop_lua_handlefile(L, script_path, true))\n    return 0;\n\n  return 1;\n}\n#endif\n\n/* ****************************************** */\n\n/**\n * @brief Return true if login has been disabled\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK and push the return code into the Lua stack\n */\nstatic int ntop_is_login_disabled(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  bool ret = ntop->getPrefs()->is_localhost_users_login_disabled()\n    || !ntop->getPrefs()->is_users_login_enabled();\n\n  lua_pushboolean(vm, ret);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/**\n * @brief Convert the network Id to a symbolic name (network/mask)\n *\n * @param vm The lua state.\n * @return @ref CONST_LUA_OK and push the return code into the Lua stack\n */\nstatic int ntop_network_name_by_id(lua_State* vm) {\n  int id;\n  char *name;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  id = (u_int32_t)lua_tonumber(vm, 1);\n\n  name = ntop->getLocalNetworkName(id);\n\n  lua_pushstring(vm, name ? name : \"\");\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic int ntop_set_logging_level(lua_State* vm) {\n    char *lvlStr;\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"%s() called\", __FUNCTION__);\n\n    if(ntop->getPrefs()->hasCmdlTraceLevel()) return(CONST_LUA_OK);\n    if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING))  return(CONST_LUA_ERROR);\n    lvlStr = (char*)lua_tostring(vm, 1);\n    if(!strcmp(lvlStr, \"trace\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_TRACE);\n    }\n    else if(!strcmp(lvlStr, \"debug\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_DEBUG);\n    }\n    else if(!strcmp(lvlStr, \"info\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_INFO);\n    }\n    else if(!strcmp(lvlStr, \"normal\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_NORMAL);\n    }\n    else if(!strcmp(lvlStr, \"warning\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_WARNING);\n    }\n    else if(!strcmp(lvlStr, \"error\")){\n        ntop->getTrace()->set_trace_level(TRACE_LEVEL_ERROR);\n    }\n    else{\n        return(CONST_LUA_ERROR);\n    }\n\n    return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic const luaL_Reg ntop_interface_reg[] = {\n  { \"getDefaultIfName\",       ntop_get_default_interface_name },\n  { \"setActiveInterfaceId\",   ntop_set_active_interface_id },\n  { \"getIfNames\",             ntop_get_interface_names },\n  { \"select\",                 ntop_select_interface },\n  { \"getStats\",               ntop_get_interface_stats },\n  { \"resetCounters\",          ntop_interface_reset_counters },\n\n  { \"getnDPIStats\",           ntop_get_ndpi_interface_stats },\n  { \"getnDPIProtoName\",       ntop_get_ndpi_protocol_name },\n  { \"getnDPIProtoId\",         ntop_get_ndpi_protocol_id },\n  { \"getnDPIProtoCategory\",   ntop_get_ndpi_protocol_category },\n  { \"getnDPIFlowsCount\",      ntop_get_ndpi_interface_flows_count },\n  { \"getFlowsStatus\",         ntop_get_ndpi_interface_flows_status },\n  { \"getnDPIProtoBreed\",      ntop_get_ndpi_protocol_breed },\n  { \"getnDPIProtocols\",       ntop_get_ndpi_protocols },\n  { \"getnDPICategories\",      ntop_get_ndpi_categories },\n  { \"getHostsInfo\",           ntop_get_interface_hosts_info },\n  { \"getLocalHostsInfo\",      ntop_get_interface_local_hosts_info },\n  { \"getRemoteHostsInfo\",     ntop_get_interface_remote_hosts_info },\n  { \"getHostActivity\",        ntop_get_interface_host_activity },\n  { \"getHostInfo\",            ntop_get_interface_host_info },\n  { \"getGroupedHosts\",        ntop_get_grouped_interface_hosts },\n  { \"getNetworksStats\",       ntop_get_interface_networks_stats },\n  { \"resetPeriodicStats\",     ntop_host_reset_periodic_stats },\n  { \"correlateHostActivity\",  ntop_correalate_host_activity },\n  { \"similarHostActivity\",    ntop_similar_host_activity },\n  { \"getHostActivityMap\",     ntop_get_interface_host_activitymap },\n  { \"restoreHost\",            ntop_restore_interface_host },\n  { \"getFlowsInfo\",           ntop_get_interface_flows_info },\n  { \"getLocalFlowsInfo\",      ntop_get_interface_local_flows_info },\n  { \"getRemoteFlowsInfo\",     ntop_get_interface_remote_flows_info },\n  { \"getFlowsStats\",          ntop_get_interface_flows_stats },\n  { \"getFlowKey\",             ntop_get_interface_flow_key   },\n  { \"findFlowByKey\",          ntop_get_interface_find_flow_by_key },\n  { \"dropFlowTraffic\",        ntop_drop_flow_traffic },\n  { \"dumpFlowTraffic\",        ntop_dump_flow_traffic },\n  { \"dumpLocalHosts2redis\",   ntop_dump_local_hosts_2_redis },\n  { \"findUserFlows\",          ntop_get_interface_find_user_flows },\n  { \"findPidFlows\",           ntop_get_interface_find_pid_flows },\n  { \"findFatherPidFlows\",     ntop_get_interface_find_father_pid_flows },\n  { \"findNameFlows\",          ntop_get_interface_find_proc_name_flows },\n  { \"listHTTPhosts\",          ntop_list_http_hosts },\n  { \"findHost\",               ntop_get_interface_find_host },\n  { \"updateHostTrafficPolicy\", ntop_update_host_traffic_policy },\n  { \"updateHostAlertPolicy\",  ntop_update_host_alert_policy },\n  { \"setSecondTraffic\",       ntop_set_second_traffic },\n  { \"setHostDumpPolicy\",      ntop_set_host_dump_policy },\n  { \"setHostQuota\",           ntop_set_host_quota },\n  { \"getPeerHitRate\",            ntop_get_host_hit_rate },\n  { \"getLatestActivityHostsInfo\",     ntop_get_interface_latest_activity_hosts_info },\n  { \"getInterfaceDumpDiskPolicy\",     ntop_get_interface_dump_disk_policy },\n  { \"getInterfaceDumpTapPolicy\",      ntop_get_interface_dump_tap_policy },\n  { \"getInterfaceDumpTapName\",        ntop_get_interface_dump_tap_name },\n  { \"getInterfaceDumpMaxPkts\",        ntop_get_interface_dump_max_pkts },\n  { \"getInterfaceDumpMaxSec\",         ntop_get_interface_dump_max_sec },\n  { \"getInterfaceDumpMaxFiles\",       ntop_get_interface_dump_max_files },\n  { \"getInterfacePacketsDumpedFile\",  ntop_get_interface_pkts_dumped_file },\n  { \"getInterfacePacketsDumpedTap\",   ntop_get_interface_pkts_dumped_tap },\n  { \"getEndpoint\",                    ntop_get_interface_endpoint },\n  { \"isPacketInterface\",              ntop_interface_is_packet_interface },\n  { \"isBridgeInterface\",              ntop_interface_is_bridge_interface },\n  { \"isPcapDumpInterface\",            ntop_interface_is_pcap_dump_interface },\n  { \"isRunning\",                      ntop_interface_is_running },\n  { \"isIdle\",                         ntop_interface_is_idle },\n  { \"setInterfaceIdleState\",          ntop_interface_set_idle },\n  { \"name2id\",                        ntop_interface_name2id },\n  { \"loadDumpPrefs\",                  ntop_load_dump_prefs },\n  { \"loadScalingFactorPrefs\",         ntop_load_scaling_factor_prefs },\n  { \"loadHostAlertPrefs\",             ntop_interface_load_host_alert_prefs },\n\n  /* Mac */\n  { \"getMacsInfo\",                    ntop_get_interface_macs_info },\n  { \"getMacInfo\",                     ntop_get_interface_mac_info },\n\n  /* L7 */\n  { \"reloadL7Rules\",                  ntop_reload_l7_rules },\n  { \"reloadShapers\",                  ntop_reload_shapers },\n\n  /* Host pools */\n  { \"reloadHostPools\",                ntop_reload_host_pools                },\n  #ifdef NTOPNG_PRO\n  { \"getHostPoolsStats\",              ntop_get_host_pool_interface_stats    },\n  { \"getHostPoolsVolatileMembers\",    ntop_get_host_pool_volatile_members   },\n  { \"purgeExpiredPoolsMembers\",       ntop_purge_expired_host_pools_members },\n  { \"removeVolatileMemberFromPool\",   ntop_remove_volatile_member_from_pool },\n#endif\n\n  /* DB */\n  { \"execSQLQuery\",                   ntop_interface_exec_sql_query },\n\n  /* Flows */\n  { \"getFlowDevices\",  ntop_getflowdevices },\n  { \"getFlowDeviceInfo\",  ntop_getflowdeviceinfo },\n\n  /* New generation alerts */\n  { \"getCachedNumAlerts\",   ntop_interface_get_cached_num_alerts    },\n  { \"queryAlertsRaw\",       ntop_interface_query_alerts_raw         },\n  { \"queryFlowAlertsRaw\",   ntop_interface_query_flow_alerts_raw    },\n  { \"engageHostAlert\",      ntop_interface_engage_host_alert        },\n  { \"releaseHostAlert\",     ntop_interface_release_host_alert       },\n  { \"engageNetworkAlert\",   ntop_interface_engage_network_alert     },\n  { \"releaseNetworkAlert\",  ntop_interface_release_network_alert    },\n  { \"engageInterfaceAlert\", ntop_interface_engage_interface_alert   },\n  { \"releaseInterfaceAlert\",ntop_interface_release_interface_alert  },\n  { \"enableHostAlerts\",     ntop_interface_host_enable_alerts       },\n  { \"disableHostAlerts\",    ntop_interface_host_disable_alerts      },\n  { \"refreshNumAlerts\",     ntop_interface_refresh_num_alerts       },\n  { \"makeRoomAlerts\",       ntop_interface_make_room_alerts         },\n  { \"makeRoomRequested\",    ntop_interface_make_room_requested      },\n  { NULL,                             NULL }\n};\n\n/* **************************************************************** */\n\nstatic const luaL_Reg ntop_reg[] = {\n  { \"getDirs\",        ntop_get_dirs },\n  { \"getInfo\",        ntop_get_info },\n  { \"getUptime\",      ntop_get_uptime },\n  { \"dumpFile\",       ntop_dump_file },\n  { \"checkLicense\",   ntop_check_license },\n\n  /* Redis */\n  { \"getCache\",        ntop_get_redis },\n  { \"setCache\",        ntop_set_redis },\n  { \"delCache\",        ntop_delete_redis_key },\n  { \"listIndexCache\",  ntop_list_index_redis },\n  { \"lpushCache\",      ntop_lpush_redis },\n  { \"lpopCache\",       ntop_lpop_redis },\n  { \"lrangeCache\",     ntop_lrange_redis },\n  { \"setMembersCache\", ntop_add_set_member_redis },\n  { \"delMembersCache\", ntop_del_set_member_redis },\n  { \"getMembersCache\", ntop_get_set_members_redis },\n  { \"getHashCache\",    ntop_get_hash_redis },\n  { \"setHashCache\",    ntop_set_hash_redis },\n  { \"delHashCache\",    ntop_del_hash_redis },\n  { \"getHashKeysCache\",ntop_get_hash_keys_redis },\n  { \"getKeysCache\",    ntop_get_keys_redis },\n  { \"delHashCache\",    ntop_delete_hash_redis_key },\n  { \"setPopCache\",     ntop_get_redis_set_pop },\n  { \"getHostId\",       ntop_redis_get_host_id },\n  { \"getIdToHost\",     ntop_redis_get_id_to_host },\n\n  /* Redis Preferences */\n  { \"setPref\",         ntop_set_redis_preference },\n  { \"getPref\",         ntop_get_redis },\n\n  { \"isdir\",          ntop_is_dir },\n  { \"mkdir\",          ntop_mkdir_tree },\n  { \"notEmptyFile\",   ntop_is_not_empty_file },\n  { \"exists\",         ntop_get_file_dir_exists },\n  { \"listReports\",    ntop_list_reports },\n  { \"fileLastChange\", ntop_get_file_last_change },\n  { \"readdir\",        ntop_list_dir_files },\n  { \"rmdir\",          ntop_remove_dir_recursively },\n  { \"zmq_connect\",    ntop_zmq_connect },\n  { \"zmq_disconnect\", ntop_zmq_disconnect },\n  { \"zmq_receive\",    ntop_zmq_receive },\n  { \"getLocalNetworks\",  ntop_get_local_networks },\n  { \"reloadPreferences\", ntop_reload_preferences },\n\n#ifdef NTOPNG_PRO\n  { \"sendNagiosAlert\",      ntop_nagios_send_alert },\n  { \"withdrawNagiosAlert\",  ntop_nagios_withdraw_alert },\n  { \"reloadNagiosConfig\",   ntop_nagios_reload_config },\n  { \"checkProfileSyntax\",   ntop_check_profile_syntax },\n  { \"reloadProfiles\",       ntop_reload_traffic_profiles },\n#endif\n\n  /* Pro */\n  { \"isPro\",                ntop_is_pro },\n  { \"isEnterprise\",         ntop_is_enterprise },\n\n  /* Historical database */\n  { \"insertMinuteSampling\",        ntop_stats_insert_minute_sampling },\n  { \"insertHourSampling\",          ntop_stats_insert_hour_sampling },\n  { \"insertDaySampling\",           ntop_stats_insert_day_sampling },\n  { \"getMinuteSampling\",           ntop_stats_get_minute_sampling },\n  { \"deleteMinuteStatsOlderThan\",  ntop_stats_delete_minute_older_than },\n  { \"deleteHourStatsOlderThan\",    ntop_stats_delete_hour_older_than },\n  { \"deleteDayStatsOlderThan\",     ntop_stats_delete_day_older_than },\n  { \"getMinuteSamplingsFromEpoch\", ntop_stats_get_samplings_of_minutes_from_epoch },\n  { \"getHourSamplingsFromEpoch\",   ntop_stats_get_samplings_of_hours_from_epoch },\n  { \"getDaySamplingsFromEpoch\",    ntop_stats_get_samplings_of_days_from_epoch },\n  { \"getMinuteSamplingsInterval\",  ntop_stats_get_minute_samplings_interval },\n\n  { \"deleteDumpFiles\", ntop_delete_dump_files },\n\n  /* Time */\n  { \"gettimemsec\",    ntop_gettimemsec },\n\n  /* Trace */\n  { \"verboseTrace\",   ntop_verbose_trace },\n\n  /* UDP */\n  { \"send_udp_data\",  ntop_send_udp_data },\n\n  /* IP */\n  { \"inet_ntoa\",      ntop_inet_ntoa },\n\n  /* RRD */\n  { \"rrd_create\",     ntop_rrd_create },\n  { \"rrd_update\",     ntop_rrd_update },\n  { \"rrd_fetch\",      ntop_rrd_fetch  },\n  { \"rrd_fetch_columns\", ntop_rrd_fetch_columns },\n  { \"rrd_lastupdate\", ntop_rrd_lastupdate  },\n\n  /* Prefs */\n  { \"getPrefs\",          ntop_get_prefs },\n\n  /* HTTP */\n  { \"httpRedirect\",   ntop_http_redirect },\n  { \"httpGet\",        ntop_http_get },\n  { \"getHttpPrefix\",  ntop_http_get_prefix },\n\n  /* Admin */\n  { \"getNologinUser\",     ntop_get_nologin_username },\n  { \"getUsers\",           ntop_get_users },\n  { \"getUserGroup\",       ntop_get_user_group },\n  { \"getAllowedNetworks\", ntop_get_allowed_networks },\n  { \"resetUserPassword\",  ntop_reset_user_password },\n  { \"changeUserRole\",     ntop_change_user_role },\n  { \"changeAllowedNets\",  ntop_change_allowed_nets },\n  { \"changeAllowedIfname\",ntop_change_allowed_ifname },\n  { \"changeUserHostPool\", ntop_change_user_host_pool },\n  { \"addUser\",            ntop_add_user },\n  { \"addUserLifetime\",    ntop_add_user_lifetime },\n  { \"clearUserLifetime\",  ntop_clear_user_lifetime },\n  { \"deleteUser\",         ntop_delete_user },\n  { \"isLoginDisabled\",    ntop_is_login_disabled },\n  { \"getNetworkNameById\", ntop_network_name_by_id },\n\n  /* Security */\n  { \"getRandomCSRFValue\",     ntop_generate_csrf_value },\n\n  /* HTTP */\n  { \"postHTTPJsonData\",       ntop_post_http_json_data },\n\n  /* Address Resolution */\n  { \"resolveAddress\",     ntop_resolve_address },\n  { \"getResolvedAddress\", ntop_get_resolved_address },\n\n  /* Logging */\n  { \"syslog\",         ntop_syslog },\n  { \"setLoggingLevel\",ntop_set_logging_level },\n\n  /* SNMP */\n  { \"snmpget\",        ntop_snmpget },\n  { \"snmpgetnext\",    ntop_snmpgetnext },\n\n  /* SQLite */\n  { \"execQuery\",      ntop_sqlite_exec_query },\n\n  /* Runtime */\n  { \"hasVLANs\",       ntop_has_vlans },\n  { \"hasGeoIP\",       ntop_has_geoip },\n  { \"isWindows\",      ntop_is_windows },\n\n  /* Host Blacklist */\n  { \"allocHostBlacklist\", ntop_allocHostBlacklist },\n  { \"swapHostBlacklist\",  ntop_swapHostBlacklist  },\n  { \"addToHostBlacklist\", ntop_addToHostBlacklist },\n\n  /* Misc */\n  { \"getservbyport\",      ntop_getservbyport      },\n  { \"getMacManufacturer\", ntop_get_mac_manufacturer },\n  { \"getSiteCategories\",  ntop_get_site_categories },\n\n  { NULL,          NULL}\n};\n\n/* ****************************************** */\n\nvoid Lua::lua_register_classes(lua_State *L, bool http_mode) {\n  static const luaL_Reg _meta[] = { { NULL, NULL } };\n  int i;\n\n  ntop_class_reg ntop_lua_reg[] = {\n    { \"interface\", ntop_interface_reg },\n    { \"ntop\",      ntop_reg },\n    {NULL,         NULL}\n  };\n\n  if(!L) return;\n\n  luaopen_lsqlite3(L);\n\n  for(i=0; ntop_lua_reg[i].class_name != NULL; i++) {\n    int lib_id, meta_id;\n\n    /* newclass = {} */\n    lua_createtable(L, 0, 0);\n    lib_id = lua_gettop(L);\n\n    /* metatable = {} */\n    luaL_newmetatable(L, ntop_lua_reg[i].class_name);\n    meta_id = lua_gettop(L);\n    luaL_register(L, NULL, _meta);\n\n    /* metatable.__index = class_methods */\n    lua_newtable(L), luaL_register(L, NULL, ntop_lua_reg[i].class_methods);\n    lua_setfield(L, meta_id, \"__index\");\n\n    /* class.__metatable = metatable */\n    lua_setmetatable(L, lib_id);\n\n    /* _G[\"Foo\"] = newclass */\n    lua_setglobal(L, ntop_lua_reg[i].class_name);\n  }\n\n  if(http_mode) {\n    /* Overload the standard Lua print() with ntop_lua_http_print that dumps data on HTTP server */\n    lua_register(L, \"print\", ntop_lua_http_print);\n  } else\n    lua_register(L, \"print\", ntop_lua_cli_print);\n\n#ifdef NTOPNG_PRO\n  if(ntop->getPro()->has_valid_license()) {\n    lua_register(L, \"ntopRequire\", ntop_lua_require);\n    luaL_dostring(L, \"table.insert(package.loaders, 1, ntopRequire)\");\n    lua_register(L, \"dofile\", ntop_lua_dofile);\n  }\n#endif\n}\n\n/* ****************************************** */\n\n#if 0\n/**\n * Iterator over key-value pairs where the value\n * maybe made available in increments and/or may\n * not be zero-terminated.  Used for processing\n * POST data.\n *\n * @param cls user-specified closure\n * @param kind type of the value\n * @param key 0-terminated key for the value\n * @param filename name of the uploaded file, NULL if not known\n * @param content_type mime-type of the data, NULL if not known\n * @param transfer_encoding encoding of the data, NULL if not known\n * @param data pointer to size bytes of data at the\n *              specified offset\n * @param off offset of data in the overall value\n * @param size number of bytes in data available\n * @return MHD_YES to continue iterating,\n *         MHD_NO to abort the iteration\n */\nstatic int post_iterator(void *cls,\n\t\t\t enum MHD_ValueKind kind,\n\t\t\t const char *key,\n\t\t\t const char *filename,\n\t\t\t const char *content_type,\n\t\t\t const char *transfer_encoding,\n\t\t\t const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  char tmp[1024];\n  u_int len = min(size, sizeof(tmp)-1);\n\n  memcpy(tmp, &data[off], len);\n  tmp[len] = '\\0';\n\n  fprintf(stdout, \"[POST] [%s][%s]\\n\", key, tmp);\n  return MHD_YES;\n}\n#endif\n\n/* ****************************************** */\n\n/*\n  Run a Lua script from within ntopng (no HTTP GUI)\n*/\nint Lua::run_script(char *script_path) {\n  int rc = 0;\n\n  if(!L) return(-1);\n\n  try {\n    luaL_openlibs(L); /* Load base libraries */\n    lua_register_classes(L, false); /* Load custom classes */\n\n#ifndef NTOPNG_PRO\n    rc = luaL_dofile(L, script_path);\n#else\n    if(ntop->getPro()->has_valid_license())\n      rc = __ntop_lua_handlefile(L, script_path, true);\n    else\n      rc = luaL_dofile(L, script_path);\n#endif\n\n    if(rc != 0) {\n      const char *err = lua_tostring(L, -1);\n\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n      rc = -1;\n    }\n  } catch(...) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s]\", script_path);\n    rc = -2;\n  }\n\n  return(rc);\n}\n\n/* ****************************************** */\n\n/* http://www.geekhideout.com/downloads/urlcode.c */\n\n#if 0\n/* Converts an integer value to its hex character*/\nstatic char to_hex(char code) {\n  static char hex[] = \"0123456789abcdef\";\n  return hex[code & 15];\n}\n\n/* ****************************************** */\n\n/* Returns a url-encoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nstatic char* http_encode(char *str) {\n  char *pstr = str, *buf = (char*)malloc(strlen(str) * 3 + 1), *pbuf = buf;\n  while (*pstr) {\n    if(isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~')\n      *pbuf++ = *pstr;\n    else if(*pstr == ' ')\n      *pbuf++ = '+';\n    else\n      *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);\n    pstr++;\n  }\n  *pbuf = '\\0';\n  return buf;\n}\n#endif\n\n/* ****************************************** */\n\nvoid Lua::purifyHTTPParameter(char *param) {\n  char *ampercent;\n\n  if((ampercent = strchr(param, '%')) != NULL) {\n    /* We allow only a few chars, removing all the others */\n\n    if((ampercent[1] != 0) && (ampercent[2] != 0)) {\n      char c;\n      char b = ampercent[3];\n\n      ampercent[3] = '\\0';\n      c = (char)strtol(&ampercent[1], NULL, 16);\n      ampercent[3] = b;\n\n      switch(c) {\n      case '/':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '$':\n      case ',':\n      case '^':\n      case '*':\n      case '_':\n      case '&':\n      case ' ':\n      case '=':\n      case '<':\n      case '>':\n      case '@':\n      case '#':\n\tbreak;\n\n      default:\n\tif(!Utils::isPrintableChar(c)) {\n\t  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded char '0x%02x' in URI [%s]\", c, param);\n\t  ampercent[0] = '\\0';\n\t  return;\n\t}\n      }\n\n      purifyHTTPParameter(&ampercent[3]);\n    } else\n      ampercent[0] = '\\0';\n  }\n}\n\n/* ****************************************** */\n\nvoid Lua::setInterface(const char *user) {\n  char key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  bool enforce_allowed_interface = false;\n\n  if(user[0] != '\\0') {\n    // check if the user is restricted to browse only a given interface\n\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      // there is only one allowed interface for the user\n      enforce_allowed_interface = true;\n      goto set_preferred_interface;\n    } else if(snprintf(key, sizeof(key), \"ntopng.prefs.%s.ifname\", user)\n\t      && ntop->getRedis()->get(key, ifname, sizeof(ifname)) < 0) {\n      // no allowed interface and no default set interface\n    set_default_if_name_in_session:\n      snprintf(ifname, sizeof(ifname), \"%s\",\n\t       ntop->getInterfaceAtId(NULL /* allowed user interface check already enforced */,\n\t\t\t\t      0)->get_name());\n      lua_push_str_table_entry(L, \"ifname\", ifname);\n      ntop->getRedis()->set(key, ifname, 3600 /* 1h */);\n    } else {\n      goto set_preferred_interface;\n    }\n  } else {\n    // We need to check if ntopng is running with the option --disable-login\n    snprintf(key, sizeof(key), \"ntopng.prefs.ifname\");\n    if(ntop->getRedis()->get(key, ifname, sizeof(ifname)) < 0) {\n      goto set_preferred_interface;\n    }\n\n  set_preferred_interface:\n    NetworkInterface *iface;\n\n    if((iface = ntop->getNetworkInterface(NULL /* allowed user interface check already enforced */,\n\t\t\t\t\t      ifname)) != NULL) {\n      /* The specified interface still exists */\n      lua_push_str_table_entry(L, \"ifname\", iface->get_name());\n    } else if(!enforce_allowed_interface) {\n      goto set_default_if_name_in_session;\n    } else {\n      // TODO: handle the case where the user has\n      // an allowed interface that is not presently available\n      // (e.g., not running?)\n    }\n  }\n}\n\n/* ****************************************** */\n\nvoid Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n\n      tok = strtok_r(NULL, \"&\", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); /* Default */\n}\n\n/* ****************************************** */\n\nint Lua::handle_script_request(struct mg_connection *conn,\n\t\t\t       const struct mg_request_info *request_info,\n\t\t\t       char *script_path) {\n  char buf[64], key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  char *_cookies, user[64] = { '\\0' };\n  AddressTree ptree;\n  int rc;\n  const char * content_type;\n\n  if(!L) return(-1);\n\n  luaL_openlibs(L); /* Load base libraries */\n  lua_register_classes(L, true); /* Load custom classes */\n\n  lua_pushlightuserdata(L, (char*)conn);\n  lua_setglobal(L, CONST_HTTP_CONN);\n\n  content_type = mg_get_header(conn, \"Content-Type\");\n\n  /* Check for POST requests */\n  if((strcmp(request_info->request_method, \"POST\") == 0) &&\n      ((content_type != NULL) && (strstr(content_type, \"application/x-www-form-urlencoded\") == content_type))) {\n    char post_data[1024] = { '\\0' };\n    char rsp[32];\n    char csrf[64] = { '\\0' };\n    char user[64] = { '\\0' };\n    int post_data_len = mg_read(conn, post_data, sizeof(post_data));\n    u_int8_t valid_csrf = 1;\n\n    post_data[sizeof(post_data)-1] = '\\0';\n\n    /* CSRF is mandatory in POST request */\n    mg_get_var(post_data, post_data_len, \"csrf\", csrf, sizeof(csrf));\n    mg_get_cookie(conn, \"user\", user, sizeof(user));\n\n    if((ntop->getRedis()->get(csrf, rsp, sizeof(rsp)) == -1)\n       || (strcmp(rsp, user) != 0)) {\n#if 0\n      const char *msg = \"The submitted form is expired. Please reload the page and try again. <p>[ <A HREF=/>Home</A> ]\";\n\n      ntop->getTrace()->traceEvent(TRACE_WARNING,\n          \"Invalid CSRF parameter specified [%s][%s][%s][%s]: page expired?\",\n          csrf, rsp, user, \"csrf\");\n\n      return(send_error(conn, 500 /* Internal server error */,\n          msg, PAGE_ERROR, script_path, msg));\n#else\n      valid_csrf = 0;\n#endif\n    } else {\n      /* Invalidate csrf */\n      ntop->getRedis()->del(csrf);\n    }\n\n    if(valid_csrf)\n      setParamsTable(L, \"_POST\", post_data); /* CSRF is valid here, now fill the _POST table with POST parameters */\n    else\n      setParamsTable(L, \"_POST\", NULL /* Empty */);\n  } else\n    setParamsTable(L, \"_POST\", NULL /* Empty */);\n\n  /* Put the GET params into the environment */\n  if(request_info->query_string)\n    setParamsTable(L, \"_GET\", request_info->query_string);\n  else\n    setParamsTable(L, \"_GET\", NULL /* Empty */);\n\n  /* _SERVER */\n  lua_newtable(L);\n  lua_push_str_table_entry(L, \"REQUEST_METHOD\", (char*)request_info->request_method);\n  lua_push_str_table_entry(L, \"URI\", (char*)request_info->uri ? (char*)request_info->uri : (char*)\"\");\n  lua_push_str_table_entry(L, \"REFERER\", (char*)mg_get_header(conn, \"Referer\") ? (char*)mg_get_header(conn, \"Referer\") : (char*)\"\");\n  if(request_info->remote_user)  lua_push_str_table_entry(L, \"REMOTE_USER\", (char*)request_info->remote_user);\n  if(request_info->query_string) lua_push_str_table_entry(L, \"QUERY_STRING\", (char*)request_info->query_string);\n\n  for(int i=0; ((request_info->http_headers[i].name != NULL) \n\t\t&& request_info->http_headers[i].name[0] != '\\0'); i++)\n    lua_push_str_table_entry(L,\n\t\t\t     request_info->http_headers[i].name,\n\t\t\t     (char*)request_info->http_headers[i].value);  \n  lua_setglobal(L, (char*)\"_SERVER\");\n\n  /* Cookies */\n  lua_newtable(L);\n  if((_cookies = (char*)mg_get_header(conn, \"Cookie\")) != NULL) {\n    char *cookies = strdup(_cookies);\n    char *tok, *where;\n\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"=> '%s'\", cookies);\n    tok = strtok_r(cookies, \"=\", &where);\n    while(tok != NULL) {\n      char *val;\n\n      while(tok[0] == ' ') tok++;\n\n      if((val = strtok_r(NULL, \";\", &where)) != NULL) {\n\tlua_push_str_table_entry(L, tok, val);\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, val);\n      } else\n\tbreak;\n\n      tok = strtok_r(NULL, \"=\", &where);\n    }\n\n    free(cookies);\n  }\n  lua_setglobal(L, \"_COOKIE\"); /* Like in php */\n\n  /* Put the _SESSION params into the environment */\n  lua_newtable(L);\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  lua_push_str_table_entry(L, \"user\", user);\n  mg_get_cookie(conn, \"session\", buf, sizeof(buf));\n  lua_push_str_table_entry(L, \"session\", buf);\n\n  // now it's time to set the interface.\n  setInterface(user);\n\n  lua_setglobal(L, \"_SESSION\"); /* Like in php */\n\n  if(user[0] != '\\0') {\n    char val[255];\n\n    lua_pushlightuserdata(L, user);\n    lua_setglobal(L, \"user\");\n\n    snprintf(key, sizeof(key), \"ntopng.user.%s.allowed_nets\", user);\n    if((ntop->getRedis()->get(key, val, sizeof(val)) != -1)\n       && (val[0] != '\\0')) {\n      ptree.addAddresses(val);\n      lua_pushlightuserdata(L, &ptree);\n      lua_setglobal(L, CONST_ALLOWED_NETS);\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"SET %p\", ptree);\n    }\n\n    snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user);\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      lua_pushlightuserdata(L, ifname);\n      lua_setglobal(L, CONST_ALLOWED_IFNAME);\n    }\n  }\n\n#ifndef NTOPNG_PRO\n  rc = luaL_dofile(L, script_path);\n#else\n  if(ntop->getPro()->has_valid_license())\n    rc = __ntop_lua_handlefile(L, script_path, true);\n  else\n    rc = luaL_dofile(L, script_path);\n#endif\n\n  if(rc != 0) {\n    const char *err = lua_tostring(L, -1);\n\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n    return(send_error(conn, 500 /* Internal server error */,\n\t\t      \"Internal server error\", PAGE_ERROR, script_path, err));\n  }\n\n  return(CONST_LUA_OK);\n}\n", "/*\n *\n * (C) 2013-17 - ntop.org\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"ntop_includes.h\"\n\n#ifdef __APPLE__\n#include <uuid/uuid.h>\n#endif\n\n/* UserActivityStats.cpp */\nextern const char* activity_names[];\n\n/* Lua.cpp */\nextern int ntop_lua_cli_print(lua_State* vm);\nextern int ntop_lua_check(lua_State* vm, const char* func, int pos, int expected_type);\n\nstatic bool help_printed = false;\n\n/* **************************************************** */\n\n/* Method used for collateral activities */\nNetworkInterface::NetworkInterface() { init(); }\n\n/* **************************************************** */\n\nNetworkInterface::NetworkInterface(const char *name,\n\t\t\t\t   const char *custom_interface_type) {\n  NDPI_PROTOCOL_BITMASK all;\n  char _ifname[64];\n  bool isViewInterface = (strncmp(name, \"view:\", 5) == 0) ? 1 : 0; /* We need to do it as isView() is not yet initialized */\n\n  customIftype = custom_interface_type, flowHashingMode = flowhashing_none;\n  init();\n\n#ifdef WIN32\n  if(name == NULL) name = \"1\"; /* First available interface */\n#endif\n\n  scalingFactor = 1, remoteIfname = remoteIfIPaddr = remoteProbeIPaddr = remoteProbePublicIPaddr = NULL;\n  if(strcmp(name, \"-\") == 0) name = \"stdin\";\n  if(strcmp(name, \"-\") == 0) name = \"stdin\";\n\n  if(ntop->getRedis())\n    id = Utils::ifname2id(name);\n  else\n    id = -1;\n\n  purge_idle_flows_hosts = true;\n\n  if(name == NULL) {\n    char pcap_error_buffer[PCAP_ERRBUF_SIZE];\n\n    if(!help_printed)\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"No capture interface specified\");\n\n    printAvailableInterfaces(false, 0, NULL, 0);\n\n    name = pcap_lookupdev(pcap_error_buffer);\n\n    if(name == NULL) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR,\n\t\t\t\t   \"Unable to locate default interface (%s)\\n\",\n\t\t\t\t   pcap_error_buffer);\n      exit(0);\n    }\n  } else {\n    if(isNumber(name)) {\n      /* We need to convert this numeric index into an interface name */\n      int id = atoi(name);\n\n      _ifname[0] = '\\0';\n      printAvailableInterfaces(false, id, _ifname, sizeof(_ifname));\n\n      if(_ifname[0] == '\\0') {\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to locate interface Id %d\", id);\n\tprintAvailableInterfaces(false, 0, NULL, 0);\n\texit(0);\n      }\n\n      name = _ifname;\n    }\n  }\n\n  pkt_dumper_tap = NULL, lastSecUpdate = 0;\n  ifname = strdup(name);\n\n  if(id >= 0) {\n    u_int32_t num_hashes;\n    ndpi_port_range d_port[MAX_DEFAULT_PORTS];\n    u_int16_t no_master[2] = { NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO };\n\n    num_hashes = max_val(4096, ntop->getPrefs()->get_max_num_flows()/4);\n    flows_hash = new FlowHash(this, num_hashes, ntop->getPrefs()->get_max_num_flows());\n\n    num_hashes = max_val(4096, ntop->getPrefs()->get_max_num_hosts()/4);\n    hosts_hash = new HostHash(this, num_hashes, ntop->getPrefs()->get_max_num_hosts());\n\n    macs_hash = new MacHash(this, 4, ntop->getPrefs()->get_max_num_hosts());\n\n    // init global detection structure\n    ndpi_struct = ndpi_init_detection_module();\n    if(ndpi_struct == NULL) {\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"Global structure initialization failed\");\n      exit(-1);\n    }\n\n    if(ntop->getCustomnDPIProtos() != NULL)\n      ndpi_load_protocols_file(ndpi_struct, ntop->getCustomnDPIProtos());\n\n    ndpi_struct->http_dont_dissect_response = 1;\n\n    memset(d_port, 0, sizeof(d_port));\n    ndpi_set_proto_defaults(ndpi_struct, NDPI_PROTOCOL_UNRATED, NTOPNG_NDPI_OS_PROTO_ID,\n\t\t\t    no_master, no_master,\n\t\t\t    (char*)\"Operating System\",\n\t\t\t    NDPI_PROTOCOL_CATEGORY_SYSTEM,\n\t\t\t    d_port, d_port);\n\n    // enable all protocols\n    NDPI_BITMASK_SET_ALL(all);\n    ndpi_set_protocol_detection_bitmask2(ndpi_struct, &all);\n\n    last_pkt_rcvd = last_pkt_rcvd_remote = 0, pollLoopCreated = false, bridge_interface = false;\n    next_idle_flow_purge = next_idle_host_purge = 0;\n    cpu_affinity = -1 /* no affinity */, has_vlan_packets = false, pkt_dumper = NULL;\n    if(ntop->getPrefs()->are_taps_enabled())\n      pkt_dumper_tap = new PacketDumperTuntap(this);\n\n    running = false, sprobe_interface = false, inline_interface = false, db = NULL;\n\n    if((!isViewInterface) && (ntop->getPrefs()->do_dump_flows_on_mysql())) {\n#ifdef NTOPNG_PRO\n      if(ntop->getPrefs()->is_enterprise_edition()) db = new BatchedMySQLDB(this);\n#endif\n\n      if(db == NULL)\n\tdb = new MySQLDB(this);\n\n      if(!db) throw \"Not enough memory\";\n    }\n\n    checkIdle();\n    ifSpeed = Utils::getMaxIfSpeed(name);\n    ifMTU = Utils::getIfMTU(name), mtuWarningShown = false;\n  } else {\n    flows_hash = NULL, hosts_hash = NULL;\n    ndpi_struct = NULL, db = NULL, ifSpeed = 0;\n    pkt_dumper = NULL, pkt_dumper_tap = NULL;\n  }\n\n  networkStats = NULL;\n  \n#ifdef NTOPNG_PRO\n  policer = NULL; /* possibly instantiated by subclass PacketBridge */\n  flow_profiles = ntop->getPro()->has_valid_license() ? new FlowProfiles(id) : NULL;\n  if(flow_profiles) flow_profiles->loadProfiles();\n  shadow_flow_profiles = NULL;\n#endif\n\n  loadDumpPrefs();\n  loadScalingFactorPrefs();\n\n  if(((statsManager  = new StatsManager(id, STATS_MANAGER_STORE_NAME)) == NULL)\n     || ((alertsManager = new AlertsManager(id, ALERTS_MANAGER_STORE_NAME)) == NULL))\n    throw \"Not enough memory\";\n\n  if((host_pools = new HostPools(this)) == NULL)\n    throw \"Not enough memory\";\n\n  alertLevel = alertsManager->getNumAlerts(true);\n\n#ifdef linux\n  /*\n    A bit aggressive but as people usually\n    ignore warnings let's be proactive\n  */\n  if(ifname\n     && (!isViewInterface)\n     && (!strstr(ifname, \":\"))\n     && (!strstr(ifname, \".pcap\"))\n     && strncmp(ifname, \"lo\", 2)\n     ) {\n    char buf[64];\n    \n    snprintf(buf, sizeof(buf), \"ethtool -K %s gro off gso off tso off\", ifname);\n    system(buf);\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Executing %s\", buf);\n  }\n#endif  \n\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::init() {\n  ifname = remoteIfname = remoteIfIPaddr = remoteProbeIPaddr = NULL,\n    remoteProbePublicIPaddr = NULL, flows_hash = NULL, hosts_hash = NULL,\n    ndpi_struct = NULL, zmq_initial_bytes = 0, zmq_initial_pkts = 0,\n    sprobe_interface = inline_interface = false, has_vlan_packets = false,\n    last_pkt_rcvd = last_pkt_rcvd_remote = 0,\n    next_idle_flow_purge = next_idle_host_purge = 0,\n    running = false, numSubInterfaces = 0,\n    numVirtualInterfaces = 0, flowHashing = NULL,\n    pcap_datalink_type = 0, mtuWarningShown = false, lastSecUpdate = 0,\n    purge_idle_flows_hosts = true, id = (u_int8_t)-1,\n    last_remote_pps = 0, last_remote_bps = 0,\n    sprobe_interface = false, has_vlan_packets = false,\n    pcap_datalink_type = 0, cpu_affinity = -1 /* no affinity */,\n    inline_interface = false, running = false, interfaceStats = NULL,\n    tooManyFlowsAlertTriggered = tooManyHostsAlertTriggered = false,\n    pkt_dumper = NULL, numL2Devices = 0,\n    checkpointPktCount = checkpointBytesCount = checkpointPktDropCount = 0,\n    pollLoopCreated = false, bridge_interface = false;\n\n  if(ntop && ntop->getPrefs() && ntop->getPrefs()->are_taps_enabled())\n    pkt_dumper_tap = new PacketDumperTuntap(this);\n  else\n    pkt_dumper_tap = NULL;\n\n  memset(subInterfaces, 0, sizeof(subInterfaces));\n  ip_addresses = \"\", networkStats = NULL,\n    pcap_datalink_type = 0, cpu_affinity = -1,\n    pkt_dumper = NULL;\n\n  memset(lastMinuteTraffic, 0, sizeof(lastMinuteTraffic));\n  resetSecondTraffic();\n\n  reloadLuaInterpreter = true, L_flow_create_delete_ndpi = L_flow_update = NULL;\n\n  db = NULL;\n#ifdef NTOPNG_PRO\n  policer = NULL;\n#endif\n  statsManager = NULL, alertsManager = NULL, ifSpeed = 0;\n  host_pools = NULL;\n  checkIdle();\n  dump_all_traffic = dump_to_disk = dump_unknown_traffic\n    = dump_security_packets = dump_to_tap = false;\n  dump_sampling_rate = CONST_DUMP_SAMPLING_RATE;\n  dump_max_pkts_file = CONST_MAX_NUM_PACKETS_PER_DUMP;\n  dump_max_duration = CONST_MAX_DUMP_DURATION;\n  dump_max_files = CONST_MAX_DUMP;\n  ifMTU = CONST_DEFAULT_MAX_PACKET_SIZE, mtuWarningShown = false;\n#ifdef NTOPNG_PRO\n  flow_profiles = shadow_flow_profiles = NULL;\n#endif\n}\n\n/* **************************************************** */\n\n#ifdef NTOPNG_PRO\n\nvoid NetworkInterface::initL7Policer() {\n  /* Instantiate the policer */\n  policer = new L7Policer(this);\n}\n\n#endif\n\n/* **************************************************** */\n\nvoid NetworkInterface::checkAggregationMode() {\n if(!customIftype) {\n    char rsp[32];\n\n    if(!strcmp(get_type(), CONST_INTERFACE_TYPE_ZMQ)) {\n      if(ntop->getRedis()->get((char*)CONST_RUNTIME_PREFS_IFACE_FLOW_COLLECTION, rsp, sizeof(rsp)) == 0) {\n\n\tif(!strcmp(rsp, \"probe_ip\")) flowHashingMode = flowhashing_probe_ip;\n\telse if(!strcmp(rsp, \"ingress_iface_idx\")) flowHashingMode = flowhashing_ingress_iface_idx;\n      }\n    } else {\n      if((ntop->getRedis()->get((char*)CONST_RUNTIME_PREFS_IFACE_VLAN_CREATION, rsp, sizeof(rsp)) == 0)\n\t && (!strncmp(rsp, \"1\", 1)))\n\tflowHashingMode = flowhashing_vlan;\n    }\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::loadDumpPrefs() {\n  if(ntop->getRedis() != NULL) {\n    updateDumpAllTrafficPolicy();\n    updateDumpTrafficDiskPolicy();\n    updateDumpTrafficTapPolicy();\n    updateDumpTrafficSamplingRate();\n    updateDumpTrafficMaxPktsPerFile();\n    updateDumpTrafficMaxSecPerFile();\n    updateDumpTrafficMaxFiles();\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::loadScalingFactorPrefs() {\n  if(ntop->getRedis() != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), CONST_IFACE_SCALING_FACTOR_PREFS, id);\n\n    if((ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0) && (rsp[0] != '\\0'))\n      scalingFactor = atol(rsp);\n\n    if(scalingFactor == 0) {\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"INTERNAL ERROR: scalingFactor can't be 0!\");\n      scalingFactor = 1;\n    }\n  }\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::updateDumpTrafficTapPolicy(void) {\n  bool retval = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_tap\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = !strncmp(rsp, \"true\", 5);\n    else\n      retval = false;\n  }\n\n  dump_to_tap = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::updateDumpAllTrafficPolicy(void) {\n  bool retval = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_all_traffic\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = !strncmp(rsp, \"true\", 5);\n  }\n\n  dump_all_traffic = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::updateDumpTrafficDiskPolicy(void) {\n  bool retval = false, retval_u = false, retval_s = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_disk\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = !strncmp(rsp, \"true\", 5);\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_unknown_disk\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval_u = !strncmp(rsp, \"true\", 5);\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_security_disk\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval_s = !strncmp(rsp, \"true\", 5);\n  }\n\n  dump_to_disk = retval;\n  dump_unknown_traffic = retval_u;\n  dump_security_packets = retval_s;\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficSamplingRate(void) {\n  int retval = 1;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_sampling_rate\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  dump_sampling_rate = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficMaxPktsPerFile(void) {\n  int retval = 0;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_max_pkts_file\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  retval = retval > 0 ? retval : CONST_MAX_NUM_PACKETS_PER_DUMP;\n\n  dump_max_pkts_file = retval;\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficMaxSecPerFile(void) {\n  int retval = 0;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_max_sec_file\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  retval = retval > 0 ? retval : CONST_MAX_DUMP_DURATION;\n\n  dump_max_duration = retval;\n\n  return retval;\n}\n\n/* **************************************************** */\n\nint NetworkInterface::updateDumpTrafficMaxFiles(void) {\n  int retval = 0;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s.dump_max_files\", ifname);\n    if(ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0)\n      retval = atoi(rsp);\n  }\n\n  retval = retval > 0 ? retval : CONST_MAX_DUMP;\n\n  dump_max_files = retval;\n\n  return retval;\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::checkIdle() {\n  is_idle = false;\n\n  if(ifname != NULL) {\n    char rkey[128], rsp[16];\n\n    snprintf(rkey, sizeof(rkey), \"ntopng.prefs.%s_not_idle\", ifname);\n    if((ntop->getRedis()->get(rkey, rsp, sizeof(rsp)) == 0) && (rsp[0] != '\\0')) {\n      int val = atoi(rsp);\n\n      if(val == 0) is_idle = true;\n    }\n  }\n\n  return(is_idle);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::deleteDataStructures() {\n  if(flows_hash) { delete(flows_hash); flows_hash = NULL; }\n  if(hosts_hash) { delete(hosts_hash); hosts_hash = NULL; }\n  if(macs_hash)  { delete(macs_hash);  macs_hash = NULL;  }\n\n  if(ndpi_struct) {\n    ndpi_exit_detection_module(ndpi_struct);\n    ndpi_struct = NULL;\n  }\n\n  if(ifname) {\n    //ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Interface %s shutdown\", ifname);\n    free(ifname);\n    ifname = NULL;\n  }\n}\n\n/* **************************************************** */\n\nNetworkInterface::~NetworkInterface() {\n  if(getNumPackets() > 0) {\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"Flushing host contacts for interface %s\",\n\t\t\t\t get_name());\n    cleanup();\n  }\n\n  if(host_pools)     delete host_pools;     /* note: this requires ndpi_struct */\n  deleteDataStructures();\n\n  if(remoteIfname)      free(remoteIfname);\n  if(remoteIfIPaddr)    free(remoteIfIPaddr);\n  if(remoteProbeIPaddr) free(remoteProbeIPaddr);\n  if(remoteProbePublicIPaddr) free(remoteProbePublicIPaddr);\n  if(db)             delete db;\n  if(statsManager)   delete statsManager;\n  if(alertsManager)  delete alertsManager;\n  if(networkStats)   delete []networkStats;\n  if(pkt_dumper)     delete pkt_dumper;\n  if(pkt_dumper_tap) delete pkt_dumper_tap;\n  if(interfaceStats) delete interfaceStats;\n\n  if(flowHashing) {\n    FlowHashing *current, *tmp;\n\n    HASH_ITER(hh, flowHashing, current, tmp) {\n      /* Interfaces are deleted by the main termination function */\n      HASH_DEL(flowHashing, current);\n      free(current);\n    }\n  }\n\n#ifdef NTOPNG_PRO\n  if(policer)       delete(policer);\n  if(flow_profiles) delete(flow_profiles);\n  if(shadow_flow_profiles) delete(shadow_flow_profiles);\n#endif\n\n  termLuaInterpreter();\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpFlow(time_t when, bool idle_flow, Flow *f) {\n  if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    return(dumpDBFlow(when, idle_flow, f));\n  } else if(ntop->getPrefs()->do_dump_flows_on_es())\n    return(dumpEsFlow(when, f));\n  else {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error\");\n    return(-1);\n  }\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpEsFlow(time_t when, Flow *f) {\n  char *json = f->serialize(true);\n  int rc;\n\n  if(json) {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[ES] %s\", json);\n    rc = ntop->getElasticSearch()->sendToES(json);\n    free(json);\n  } else\n    rc = -1;\n\n  return(rc);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpDBFlow(time_t when, bool idle_flow, Flow *f) {\n  char *json = f->serialize(false);\n  int rc;\n\n  if(json) {\n    rc = db->dumpFlow(when, idle_flow, f, json);\n    free(json);\n  } else\n    rc = -1;\n\n  return(rc);\n}\n\n/* **************************************************** */\n\nstatic bool local_hosts_2_redis_walker(GenericHashEntry *h, void *user_data) {\n  Host *host = (Host*)h;\n\n  if(host && (host->isLocalHost() || host->isSystemHost()))\n    host->serialize2redis();\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nint NetworkInterface::dumpLocalHosts2redis(bool disable_purge) {\n  int rc;\n\n  if(disable_purge) disablePurge(false /* on hosts */);\n  rc = walker(walker_hosts, local_hosts_2_redis_walker, NULL) ? 0 : -1;\n  if(disable_purge) enablePurge(false /* on hosts */);\n\n  return rc;\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getHostsHashSize() {\n  if(!isView())\n    return(hosts_hash->getNumEntries());\n  else {\n    u_int32_t tot = 0;\n\n    for(u_int8_t s = 0; s<numSubInterfaces; s++)\n      tot += subInterfaces[s]->get_hosts_hash()->getNumEntries();\n\n    return(tot);\n  }\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getFlowsHashSize() {\n  if(!isView())\n    return(flows_hash->getNumEntries());\n  else {\n    u_int32_t tot = 0;\n\n    for(u_int8_t s = 0; s<numSubInterfaces; s++)\n      tot += subInterfaces[s]->get_flows_hash()->getNumEntries();\n\n    return(tot);\n  }\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getMacsHashSize() {\n  if(!isView())\n    return(macs_hash->getNumEntries());\n  else {\n    u_int32_t tot = 0;\n\n    for(u_int8_t s = 0; s<numSubInterfaces; s++)\n      tot += subInterfaces[s]->get_macs_hash()->getNumEntries();\n\n    return(tot);\n  }\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::walker(WalkerType wtype,\n\t\t\t      bool (*walker)(GenericHashEntry *h, void *user_data),\n\t\t\t      void *user_data) {\n  bool ret = false;\n\n  switch(wtype) {\n  case walker_hosts:\n    if(!isView())\n      ret = hosts_hash->walk(walker, user_data);\n    else {\n      for(u_int8_t s = 0; s<numSubInterfaces; s++)\n\tret |= subInterfaces[s]->get_hosts_hash()->walk(walker, user_data);\n    }\n    break;\n\n  case walker_flows:\n    if(!isView())\n      ret = flows_hash->walk(walker, user_data);\n    else {\n      for(u_int8_t s = 0; s<numSubInterfaces; s++)\n\tret |= subInterfaces[s]->get_flows_hash()->walk(walker, user_data);\n    }\n    break;\n\n  case walker_macs:\n    if(!isView())\n      ret = macs_hash->walk(walker, user_data);\n    else {\n      for(u_int8_t s = 0; s<numSubInterfaces; s++)\n\tret |= subInterfaces[s]->get_macs_hash()->walk(walker, user_data);\n    }\n\n    break;\n  }\n\n  return(ret);\n}\n\n/* **************************************************** */\n\nFlow* NetworkInterface::getFlow(u_int8_t *src_eth, u_int8_t *dst_eth,\n\t\t\t\tu_int16_t vlan_id,\n\t\t\t\tu_int32_t deviceIP, u_int16_t inIndex, u_int16_t outIndex,\n  \t\t\t\tIpAddress *src_ip, IpAddress *dst_ip,\n  \t\t\t\tu_int16_t src_port, u_int16_t dst_port,\n\t\t\t\tu_int8_t l4_proto,\n\t\t\t\tbool *src2dst_direction,\n\t\t\t\ttime_t first_seen, time_t last_seen,\n\t\t\t\tbool *new_flow) {\n  Flow *ret;\n\n  if(vlan_id != 0) setSeenVlanTaggedPackets();\n\n  ret = flows_hash->find(src_ip, dst_ip, src_port, dst_port,\n\t\t\t vlan_id, l4_proto, src2dst_direction);\n\n  if(ret == NULL) {\n    *new_flow = true;\n\n    try {\n      ret = new Flow(this, vlan_id, l4_proto,\n\t\t     src_eth, src_ip, src_port,\n\t\t     dst_eth, dst_ip, dst_port,\n\t\t     first_seen, last_seen);\n    } catch(std::bad_alloc& ba) {\n      static bool oom_warning_sent = false;\n\n      if(!oom_warning_sent) {\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\toom_warning_sent = true;\n      }\n\n      triggerTooManyFlowsAlert();\n      return(NULL);\n    }\n\n    if(flows_hash->add(ret)) {\n      *src2dst_direction = true;\n      if(inIndex && ret->get_cli_host()) {\n\t  Host *host = (Host*)ret->get_cli_host();\n\n\t  if(host->isLocalHost() || host->isSystemHost())\n\t      ret->get_cli_host()->setDeviceIfIdx(deviceIP, inIndex);\n      }\n\n      /*\n\tWe have decided to set only ingress traffic to make sure we do not mix truth with invalid data\n\tif(outIndex && ret->get_srv_host()) ret->get_srv_host()->setDeviceIfIdx(deviceIP, outIndex);\n      */\n      return(ret);\n    } else {\n      delete ret;\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many flows\");\n      return(NULL);\n    }\n  } else {\n    *new_flow = false;\n    return(ret);\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::triggerTooManyFlowsAlert() {\n  if(!tooManyFlowsAlertTriggered) {\n    char alert_msg[512];\n\n    snprintf(alert_msg, sizeof(alert_msg),\n\t     \"Interface <A HREF='%s/lua/if_stats.lua?ifid=%d'>%s</A> has too many flows. Please extend the --max-num-flows/-X command line option\",\n\t     ntop->getPrefs()->get_http_prefix(),\n\t     id, get_name());\n\n    alertsManager->engageInterfaceAlert(this,\n\t\t\t\t\t(char*)\"app_misconfiguration\",\n\t\t\t\t\talert_app_misconfiguration, alert_level_error, alert_msg);\n    tooManyFlowsAlertTriggered = true;\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::triggerTooManyHostsAlert() {\n  if(!tooManyHostsAlertTriggered) {\n    char alert_msg[512];\n\n    snprintf(alert_msg, sizeof(alert_msg),\n\t     \"Interface <A HREF='%s/lua/if_stats.lua?ifid=%d'>%s</A> has too many hosts. Please extend the --max-num-hosts/-x command line option\",\n\t     ntop->getPrefs()->get_http_prefix(),\n\t     id, get_name());\n\n    alertsManager->releaseInterfaceAlert(this,\n\t\t\t\t\t (char*)\"app_misconfiguration\",\n\t\t\t\t\t alert_app_misconfiguration, alert_level_error, alert_msg);\n    tooManyHostsAlertTriggered = true;\n  }\n}\n\n/* **************************************************** */\n\nNetworkInterface* NetworkInterface::getSubInterface(u_int32_t criteria) {\n  FlowHashing *h = NULL;\n\n  HASH_FIND_INT(flowHashing, &criteria, h);\n\n  if(h == NULL) {\n    /* Interface not found */\n\n    if(numVirtualInterfaces < MAX_NUM_VIRTUAL_INTERFACES) {\n      if((h = (FlowHashing*)malloc(sizeof(FlowHashing))) != NULL) {\n\tchar buf[64], buf1[48];\n\tconst char *vIface_type;\n\n\th->criteria = criteria;\n\n\tswitch(flowHashingMode) {\n\tcase flowhashing_vlan:\n\t  vIface_type = CONST_INTERFACE_TYPE_VLAN;\n\t  snprintf(buf, sizeof(buf), \"%s [vlanId: %u]\", ifname, criteria);\n\t  break;\n\n\tcase flowhashing_probe_ip:\n\t  vIface_type = CONST_INTERFACE_TYPE_FLOW;\n\t  snprintf(buf, sizeof(buf), \"%s [probeIP: %s]\", ifname,\n\t\t   Utils::intoaV4(criteria, buf1, sizeof(buf1)));\n\t  break;\n\n\tcase flowhashing_ingress_iface_idx:\n\t  vIface_type = CONST_INTERFACE_TYPE_FLOW;\n\t  snprintf(buf, sizeof(buf), \"%s [ifIdx: %u]\", ifname, criteria);\n\t  break;\n\n\tdefault:\n\t  free(h);\n\t  return(NULL);\n\t  break;\n\t}\n\n\tif((h->iface = new NetworkInterface(buf, vIface_type)) != NULL) {\n\t  HASH_ADD_INT(flowHashing, criteria, h);\n\t  ntop->registerInterface(h->iface);\n\t  numVirtualInterfaces++;\n\t}\n      } else\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n    }\n  }\n\n  if(h) return(h->iface);\n\n  return(NULL);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::processFlow(ZMQ_Flow *zflow) {\n  bool src2dst_direction, new_flow;\n  Flow *flow;\n  ndpi_protocol p;\n  time_t now = time(NULL);\n\n  if(flowHashingMode != flowhashing_none) {\n    NetworkInterface *vIface;\n\n    switch(flowHashingMode) {\n    case flowhashing_probe_ip:\n      vIface = getSubInterface((u_int32_t)zflow->deviceIP);\n      break;\n\n    case flowhashing_ingress_iface_idx:\n      vIface = getSubInterface((u_int32_t)zflow->inIndex);\n      break;\n\n    default:\n      vIface = NULL;\n      break;\n    }\n\n    if(vIface) {\n      vIface->setTimeLastPktRcvd(getTimeLastPktRcvd());\n      vIface->processFlow(zflow);\n      return;\n    }\n  }\n\n  if(last_pkt_rcvd_remote > 0) {\n    int drift = now - last_pkt_rcvd_remote;\n\n    if(drift >= 0)\n      zflow->last_switched += drift, zflow->first_switched += drift;\n    else {\n      u_int32_t d = (u_int32_t)-drift;\n\n      if(d < zflow->last_switched)  zflow->last_switched  += drift;\n      if(d < zflow->first_switched) zflow->first_switched += drift;\n    }\n\n#ifdef DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"[first=%u][last=%u][duration: %u][drift: %d][now: %u][remote: %u]\",\n\t\t\t\t zflow->first_switched,  zflow->last_switched,\n\t\t\t\t zflow->last_switched-zflow->first_switched, drift,\n\t\t\t\t now, last_pkt_rcvd_remote);\n#endif\n  } else {\n    /* Old nProbe */\n\n    if((time_t)zflow->last_switched > (time_t)last_pkt_rcvd_remote)\n      last_pkt_rcvd_remote = zflow->last_switched;\n\n#ifdef DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[first=%u][last=%u][duration: %u]\",\n\t\t\t\t zflow->first_switched,  zflow->last_switched,\n\t\t\t\t zflow->last_switched- zflow->first_switched);\n#endif\n  }\n\n  /* Updating Flow */\n  flow = getFlow((u_int8_t*)zflow->src_mac, (u_int8_t*)zflow->dst_mac, zflow->vlan_id,\n\t\t zflow->deviceIP, zflow->inIndex, zflow->outIndex,\n\t\t &zflow->src_ip, &zflow->dst_ip,\n\t\t zflow->src_port, zflow->dst_port,\n\t\t zflow->l4_proto, &src2dst_direction,\n\t\t zflow->first_switched,\n\t\t zflow->last_switched, &new_flow);\n\n  incStats(now, zflow->src_ip.isIPv4() ? ETHERTYPE_IP : ETHERTYPE_IPV6,\n\t   flow ? flow->get_detected_protocol().protocol : NDPI_PROTOCOL_UNKNOWN,\n\t   zflow->pkt_sampling_rate*(zflow->in_bytes + zflow->out_bytes),\n\t   zflow->pkt_sampling_rate*(zflow->in_pkts + zflow->out_pkts),\n\t   24 /* 8 Preamble + 4 CRC + 12 IFG */ + 14 /* Ethernet header */);\n\n  if(flow == NULL)\n    return;\n\n  if(zflow->l4_proto == IPPROTO_TCP) {\n    struct timeval when;\n\n    when.tv_sec = (long)now, when.tv_usec = 0;\n    flow->updateTcpFlags((const struct bpf_timeval*)&when,\n\t\t\t zflow->tcp_flags, src2dst_direction);\n    flow->incTcpBadStats(true,\n       zflow->tcp.ooo_in_pkts, zflow->tcp.retr_in_pkts, zflow->tcp.lost_in_pkts);\n    flow->incTcpBadStats(false,\n       zflow->tcp.ooo_out_pkts, zflow->tcp.retr_out_pkts, zflow->tcp.lost_out_pkts);\n  }\n\n  flow->addFlowStats(src2dst_direction,\n\t\t     zflow->pkt_sampling_rate*zflow->in_pkts,\n\t\t     zflow->pkt_sampling_rate*zflow->in_bytes, 0,\n\t\t     zflow->pkt_sampling_rate*zflow->out_pkts,\n\t\t     zflow->pkt_sampling_rate*zflow->out_bytes, 0,\n\t\t     zflow->last_switched);\n  p.protocol = zflow->l7_proto, p.master_protocol = NDPI_PROTOCOL_UNKNOWN;\n  flow->setDetectedProtocol(p, true);\n  flow->setJSONInfo(json_object_to_json_string(zflow->additional_fields));\n  flow->updateActivities();\n\n  flow->updateInterfaceLocalStats(src2dst_direction,\n\t\t\t\t  zflow->pkt_sampling_rate*(zflow->in_pkts+zflow->out_pkts),\n\t\t\t\t  zflow->pkt_sampling_rate*(zflow->in_bytes+zflow->out_bytes));\n\n  if(zflow->src_process.pid || zflow->dst_process.pid) {\n    if(zflow->src_process.pid) flow->handle_process(&zflow->src_process, src2dst_direction ? true : false);\n    if(zflow->dst_process.pid) flow->handle_process(&zflow->dst_process, src2dst_direction ? false : true);\n\n    if(zflow->l7_proto == NDPI_PROTOCOL_UNKNOWN)\n      flow->guessProtocol();\n  }\n\n  if(zflow->dns_query) flow->setDNSQuery(zflow->dns_query);\n  if(zflow->http_url)  flow->setHTTPURL(zflow->http_url);\n  if(zflow->http_site) flow->setServerName(zflow->http_site);\n  if(zflow->ssl_server_name) flow->setServerName(zflow->ssl_server_name);\n  if(zflow->bittorrent_hash) flow->setBTHash(zflow->bittorrent_hash);\n\n  /* purge is actually performed at most one time every FLOW_PURGE_FREQUENCY */\n  // purgeIdle(zflow->last_switched);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::dumpPacketDisk(const struct pcap_pkthdr *h, const u_char *packet,\n                                      dump_reason reason) {\n  if(pkt_dumper == NULL)\n    pkt_dumper = new PacketDumper(this);\n  if(pkt_dumper)\n    pkt_dumper->dumpPacket(h, packet, reason, getDumpTrafficSamplingRate(),\n                           getDumpTrafficMaxPktsPerFile(),\n                           getDumpTrafficMaxSecPerFile());\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::dumpPacketTap(const struct pcap_pkthdr *h, const u_char *packet,\n                                     dump_reason reason) {\n  if(pkt_dumper_tap)\n    pkt_dumper_tap->writeTap((unsigned char *)packet, h->len, reason,\n                             getDumpTrafficSamplingRate());\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::processPacket(const struct bpf_timeval *when,\n\t\t\t\t     const u_int64_t time,\n\t\t\t\t     struct ndpi_ethhdr *eth,\n\t\t\t\t     u_int16_t vlan_id,\n\t\t\t\t     struct ndpi_iphdr *iph,\n\t\t\t\t     struct ndpi_ipv6hdr *ip6,\n\t\t\t\t     u_int16_t ipsize,\n\t\t\t\t     u_int32_t rawsize,\n\t\t\t\t     const struct pcap_pkthdr *h,\n\t\t\t\t     const u_char *packet,\n\t\t\t\t     u_int16_t *ndpiProtocol,\n\t\t\t\t     Host **srcHost, Host **dstHost,\n\t\t\t\t     Flow **hostFlow) {\n  bool src2dst_direction;\n  u_int8_t l4_proto;\n  Flow *flow;\n  u_int8_t *eth_src = eth->h_source, *eth_dst = eth->h_dest;\n  IpAddress src_ip, dst_ip;\n  u_int16_t src_port = 0, dst_port = 0, payload_len = 0;\n  struct ndpi_tcphdr *tcph = NULL;\n  struct ndpi_udphdr *udph = NULL;\n  u_int16_t l4_packet_len;\n  u_int8_t *l4, tcp_flags = 0, *payload = NULL;\n  u_int8_t *ip;\n  bool is_fragment = false, new_flow;\n  bool pass_verdict = true;\n\n  /* VLAN disaggregation */\n  if((flowHashingMode == flowhashing_vlan) && (vlan_id > 0)) {\n    NetworkInterface *vIface;\n\n    if((vIface = getSubInterface((u_int32_t)vlan_id)) != NULL) {\n      vIface->setTimeLastPktRcvd(getTimeLastPktRcvd());\n      return(vIface->processPacket(when, time, eth, vlan_id,\n\t\t\t\t   iph, ip6, ipsize, rawsize,\n\t\t\t\t   h, packet, ndpiProtocol,\n\t\t\t\t   srcHost, dstHost, hostFlow));\n    }\n  }\n\n decode_ip:\n  if(iph != NULL) {\n    /* IPv4 */\n    if(ipsize < 20) {\n      incStats(when->tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN,\n\t       rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n\n    if((iph->ihl * 4) > ipsize || ipsize < ntohs(iph->tot_len)\n       || (iph->frag_off & htons(0x1FFF /* IP_OFFSET */)) != 0) {\n      is_fragment = true;\n    }\n\n    l4_packet_len = ntohs(iph->tot_len) - (iph->ihl * 4);\n    l4_proto = iph->protocol;\n    l4 = ((u_int8_t *) iph + iph->ihl * 4);\n    ip = (u_int8_t*)iph;\n  } else {\n    /* IPv6 */\n    u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);\n\n    if(ipsize < sizeof(const struct ndpi_ipv6hdr)) {\n      incStats(when->tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize,\n\t       1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n\n    l4_packet_len = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);\n    l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;\n\n    if(l4_proto == 0x3C /* IPv6 destination option */) {\n      u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;\n\n      l4_proto = options[0];\n      ipv6_shift = 8 * (options[1] + 1);\n\n      if(ipsize < ipv6_shift) {\n\tincStats(when->tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\treturn(pass_verdict);\n      }\n    }\n\n    l4 = (u_int8_t*)ip6 + ipv6_shift;\n    ip = (u_int8_t*)ip6;\n  }\n\n  if(l4_proto == IPPROTO_TCP) {\n    if(l4_packet_len >= sizeof(struct ndpi_tcphdr)) {\n      u_int tcp_len;\n\n      /* TCP */\n      tcph = (struct ndpi_tcphdr *)l4;\n      src_port = tcph->source, dst_port = tcph->dest;\n      tcp_flags = l4[13];\n      tcp_len = min_val(4*tcph->doff, l4_packet_len);\n      payload = &l4[tcp_len];\n      payload_len = max_val(0, l4_packet_len-4*tcph->doff);\n      // TODO: check if payload should be set to NULL when payload_len == 0\n    } else {\n      /* Packet too short: this is a faked packet */\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Invalid TCP packet received [%u bytes long]\", l4_packet_len);\n      incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n  } else if(l4_proto == IPPROTO_UDP) {\n    if(l4_packet_len >= sizeof(struct ndpi_udphdr)) {\n      /* UDP */\n      udph = (struct ndpi_udphdr *)l4;\n      src_port = udph->source,  dst_port = udph->dest;\n      payload = &l4[sizeof(struct ndpi_udphdr)];\n      payload_len = max_val(0, l4_packet_len-sizeof(struct ndpi_udphdr));\n    } else {\n      /* Packet too short: this is a faked packet */\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Invalid UDP packet received [%u bytes long]\", l4_packet_len);\n      incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict);\n    }\n  } else if(l4_proto == IPPROTO_GRE) {\n    struct grev1_header gre;\n    int offset = sizeof(struct grev1_header);\n\n    memcpy(&gre, l4, sizeof(struct grev1_header));\n    gre.flags_and_version = ntohs(gre.flags_and_version);\n    gre.proto = ntohs(gre.proto);\n\n    if(gre.flags_and_version & (GRE_HEADER_CHECKSUM | GRE_HEADER_ROUTING)) offset += 4;\n    if(gre.flags_and_version & GRE_HEADER_KEY)      offset += 4;\n    if(gre.flags_and_version & GRE_HEADER_SEQ_NUM)  offset += 4;\n\n    if(gre.proto == ETHERTYPE_IP) {\n      iph = (struct ndpi_iphdr*)(l4 + offset), ip6 = NULL;\n      goto decode_ip;\n    } else if(gre.proto == ETHERTYPE_IPV6) {\n      iph = (struct ndpi_iphdr*)(l4 + offset), ip6 = NULL;\n      goto decode_ip;\n    } else {\n      /* Unknown encapsulation */\n    }\n  } else {\n    /* non TCP/UDP protocols */\n  }\n\n  if(iph != NULL)\n    src_ip.set(iph->saddr), dst_ip.set(iph->daddr);\n  else\n    src_ip.set(&ip6->ip6_src), dst_ip.set(&ip6->ip6_dst);\n\n#if defined(WIN32) && defined(DEMO_WIN32)\n  if(this->ethStats.getNumPackets() > MAX_NUM_PACKETS) {\n    static bool showMsg = false;\n\n    if(!showMsg) {\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"-----------------------------------------------------------\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"WARNING: this demo application is a limited ntopng version able to\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"capture up to %d packets. If you are interested\", MAX_NUM_PACKETS);\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"in the full version please have a look at the ntop\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"home page http://www.ntop.org/.\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"-----------------------------------------------------------\");\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"\");\n      showMsg = true;\n    }\n\n    return(pass_verdict);\n  }\n#endif\n\n  /* Updating Flow */\n  flow = getFlow(eth_src, eth_dst, vlan_id, 0, 0, 0, &src_ip, &dst_ip, src_port, dst_port,\n\t\t l4_proto, &src2dst_direction, last_pkt_rcvd, last_pkt_rcvd, &new_flow);\n\n  if(flow == NULL) {\n    incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN,\n\t     rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n    return(pass_verdict);\n  } else {\n    *srcHost = src2dst_direction ? flow->get_cli_host() : flow->get_srv_host();\n    *dstHost = src2dst_direction ? flow->get_srv_host() : flow->get_cli_host();\n    *hostFlow = flow;\n\n    switch(l4_proto) {\n    case IPPROTO_TCP:\n      flow->updateTcpFlags(when, tcp_flags, src2dst_direction);\n      flow->updateTcpSeqNum(when, ntohl(tcph->seq), ntohl(tcph->ack_seq), ntohs(tcph->window),\n\t\t\t    tcp_flags, l4_packet_len - (4 * tcph->doff),\n\t\t\t    src2dst_direction);\n      break;\n\n    case IPPROTO_ICMP:\n    case IPPROTO_ICMPV6:\n      if(l4_packet_len > 2) {\n        u_int8_t icmp_type = l4[0];\n        u_int8_t icmp_code = l4[1];\n\n        if((flow->get_cli_host()->isLocalHost()) && (flow->get_srv_host()->isLocalHost())) {\n          /* Set correct direction in localhost ping */\n          if((icmp_type == 8) ||                  /* ICMP Echo [RFC792] */\n            (icmp_type == 128))                   /* ICMPV6 Echo Request [RFC4443] */\n            src2dst_direction = true;\n          else if((icmp_type == 0) ||             /* ICMP Echo Reply [RFC792] */\n            (icmp_type == 129))                   /* ICMPV6 Echo Reply [RFC4443] */\n            src2dst_direction = false;\n        }\n\n        flow->setICMP(icmp_type, icmp_code);\n      }\n      break;\n    }\n\n#ifdef __OpenBSD__\n    struct timeval tv_ts;\n    tv_ts.tv_sec  = h->ts.tv_sec;\n    tv_ts.tv_usec = h->ts.tv_usec;\n    flow->incStats(src2dst_direction, rawsize, payload, payload_len, l4_proto, &tv_ts);\n#else\n    flow->incStats(src2dst_direction, rawsize, payload, payload_len, l4_proto, &h->ts);\n#endif\n  }\n\n  /* Protocol Detection */\n  flow->updateActivities();\n  flow->updateInterfaceLocalStats(src2dst_direction, 1, rawsize);\n\n  if(!flow->isDetectionCompleted()) {\n    if(isSampledTraffic())\n      flow->guessProtocol();\n    else {\n      if(!is_fragment) {\n\tstruct ndpi_flow_struct *ndpi_flow = flow->get_ndpi_flow();\n\tstruct ndpi_id_struct *cli = (struct ndpi_id_struct*)flow->get_cli_id();\n\tstruct ndpi_id_struct *srv = (struct ndpi_id_struct*)flow->get_srv_id();\n\n\tif(flow->get_packets() >= NDPI_MIN_NUM_PACKETS)\n\t  flow->setDetectedProtocol(ndpi_detection_giveup(ndpi_struct, ndpi_flow), false);\n\telse\n\t  flow->setDetectedProtocol(ndpi_detection_process_packet(ndpi_struct, ndpi_flow,\n\t\t\t\t\t\t\t\t  ip, ipsize, (u_int32_t)time,\n\t\t\t\t\t\t\t\t  cli, srv), false);\n      } else {\n\t// FIX - only handle unfragmented packets\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"IP fragments are not handled yet!\");\n      }\n    }\n  }\n\n  if(flow->isDetectionCompleted()\n     && (!isSampledTraffic())\n     && flow->get_cli_host()\n     && flow->get_srv_host()) {\n    struct ndpi_flow_struct *ndpi_flow;\n\n    switch(ndpi_get_lower_proto(flow->get_detected_protocol())) {\n    case NDPI_PROTOCOL_DHCP:\n      if(payload_len > 240) {\n\tfor(int i = 240; i<payload_len; ) {\n\t  u_int8_t id  = payload[i], len = payload[i+1];\n\n\t  if(len == 0) break;\n\n\t  if(id == 12 /* Host Name */) {\n\t    char name[64], buf[24], *client_mac, key[64];\n\t    int j;\n\n\t    j = ndpi_min(len, sizeof(name)-1);\n\t    strncpy((char*)name, (char*)&payload[i+2], j);\n\t    name[j] = '\\0';\n\n\t    client_mac = Utils::formatMac(&payload[28], buf, sizeof(buf)),\n\t    ntop->getTrace()->traceEvent(TRACE_INFO, \"[DHCP] %s = '%s'\", client_mac, name);\n\n\t    snprintf(key, sizeof(key), DHCP_CACHE, get_id());\n\t    ntop->getRedis()->hashSet(key, client_mac, name);\n\t    break;\n\t  } else if(id == 0xFF)\n\t    break; /* End of options */\n\n\t  i += len + 2;\n\t}\n      }\n      break;\n\n    case NDPI_PROTOCOL_BITTORRENT:\n      if((flow->getBitTorrentHash() == NULL)\n\t && (l4_proto == IPPROTO_UDP)\n\t && (flow->get_packets() < 8))\n\tflow->dissectBittorrent((char*)payload, payload_len);\n      break;\n\n    case NDPI_PROTOCOL_HTTP:\n      if(payload_len > 0)\n\tflow->dissectHTTP(src2dst_direction, (char*)payload, payload_len);\n      break;\n\n    case NDPI_PROTOCOL_DNS:\n      ndpi_flow = flow->get_ndpi_flow();\n\n      /*\n      DNS-over-TCP flows may carry zero-payload TCP segments\n      e.g., during three-way-handshake, or when acknowledging.\n      Make sure only non-zero-payload segments are processed.\n      */\n      if((payload_len > 0) && payload) {\n\t/*\n\tDNS-over-TCP has a 2-bytes field with DNS payload length\n\tat the beginning. See RFC1035 section 4.2.2. TCP usage.\n\t*/\n\tu_int8_t dns_offset = l4_proto == IPPROTO_TCP && payload_len > 1 ? 2 : 0;\n\n\tstruct ndpi_dns_packet_header *header = (struct ndpi_dns_packet_header*)(payload + dns_offset);\n\tu_int16_t dns_flags = ntohs(header->flags);\n\tbool is_query   = ((dns_flags & 0x8000) == 0x8000) ? false : true;\n\n\tif(flow->get_cli_host() && flow->get_srv_host()) {\n\t  Host *client = src2dst_direction ? flow->get_cli_host() : flow->get_srv_host();\n\t  Host *server = src2dst_direction ? flow->get_srv_host() : flow->get_cli_host();\n\n\t  /*\n\t    Inside the DNS packet it is possible to have multiple queries\n\t    and mix query types. In general this is not a practice followed\n\t    by applications.\n\t  */\n\n\t  if(is_query) {\n\t    u_int16_t query_type = ndpi_flow ? ndpi_flow->protos.dns.query_type : 0;\n\n\t    client->incNumDNSQueriesSent(query_type), server->incNumDNSQueriesRcvd(query_type);\n\t  } else {\n\t    u_int8_t ret_code = (dns_flags & 0x000F);\n\n\t    client->incNumDNSResponsesSent(ret_code), server->incNumDNSResponsesRcvd(ret_code);\n\t  }\n\t}\n      }\n\n      if(ndpi_flow) {\n\tstruct ndpi_id_struct *cli = (struct ndpi_id_struct*)flow->get_cli_id();\n\tstruct ndpi_id_struct *srv = (struct ndpi_id_struct*)flow->get_srv_id();\n\n\tmemset(&ndpi_flow->detected_protocol_stack,\n\t       0, sizeof(ndpi_flow->detected_protocol_stack));\n\n\tndpi_detection_process_packet(ndpi_struct, ndpi_flow,\n\t\t\t\t      ip, ipsize, (u_int32_t)time,\n\t\t\t\t      src2dst_direction ? cli : srv,\n\t\t\t\t      src2dst_direction ? srv : cli);\n\n\t/*\n\t  We reset the nDPI flow so that it can decode new packets\n\t  of the same flow (e.g. the DNS response)\n\t*/\n\tndpi_flow->detected_protocol_stack[0] = NDPI_PROTOCOL_UNKNOWN;\n      }\n      break;\n\n    default:\n      if(flow->isSSLProto())\n        flow->dissectSSL(payload, payload_len, when, src2dst_direction);\n    }\n\n    flow->processDetectedProtocol();\n\n#ifdef NTOPNG_PRO\n    if(is_bridge_interface()) {\n\tpass_verdict = flow->isPassVerdict();\n\n\tif(pass_verdict) {\n\t    u_int8_t shaper_ingress, shaper_engress;\n\t    char buf[64];\n\n\t    flow->getFlowShapers(src2dst_direction, &shaper_ingress, &shaper_engress);\n\t    ntop->getTrace()->traceEvent(TRACE_DEBUG, \"[%s] %u / %u \",\n\t\t\t\t\t flow->get_detected_protocol_name(buf, sizeof(buf)),\n\t\t\t\t\t shaper_ingress, shaper_engress);\n\t    pass_verdict = passShaperPacket(shaper_ingress, shaper_engress, (struct pcap_pkthdr*)h);\n\t}\n    }\n#endif\n\n    bool dump_if_unknown = dump_unknown_traffic\n      && (!flow->isDetectionCompleted() ||\n\t  flow->get_detected_protocol().protocol == NDPI_PROTOCOL_UNKNOWN);\n\n    if(dump_if_unknown\n       || dump_all_traffic\n       || dump_security_packets\n       || flow->dumpFlowTraffic()) {\n      if(dump_to_disk) dumpPacketDisk(h, packet, dump_if_unknown ? UNKNOWN : GUI);\n      if(dump_to_tap)  dumpPacketTap(h, packet, GUI);\n    }\n  }\n\n  incStats(when->tv_sec, iph ? ETHERTYPE_IP : ETHERTYPE_IPV6,\n\t   flow->get_detected_protocol().protocol,\n\t   rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\n  // Detect user activities\n  if((!isSampledTraffic())\n      && (ntop->getPrefs()->is_flow_activity_enabled())) {\n    Host *cli = flow->get_cli_host();\n    Host *srv = flow->get_srv_host();\n\n    if((cli->isLocalHost() || srv->isLocalHost())\n       && (!flow->isSSLProto() || flow->isSSLData())) {\n      UserActivityID activity;\n      u_int64_t up = 0, down = 0, backgr = 0, bytes = payload_len;\n\n      if(flow->getActivityId(&activity)) {\n#ifdef __OpenBSD__\n        struct timeval* tv_when;\n        tv_when->tv_sec  = when->tv_sec;\n        tv_when->tv_usec = when->tv_usec;\n        if(flow->invokeActivityFilter(tv_when, src2dst_direction, payload_len)) {\n#else \n        if(flow->invokeActivityFilter(when, src2dst_direction, payload_len)) {\n#endif\n          if(src2dst_direction)\n            up = bytes;\n          else\n            down = bytes;\n        } else {\n          backgr = bytes;\n        }\n\n        if(cli->isLocalHost())\n          cli->incActivityBytes(activity, up, down, backgr);\n\n        if(srv->isLocalHost())\n          srv->incActivityBytes(activity, down, up, backgr);\n      }\n    }\n  }\n\n  return(pass_verdict);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::purgeIdle(time_t when) {\n  if(purge_idle_flows_hosts) {\n    u_int n;\n\n    last_pkt_rcvd = when;\n\n    if((n = purgeIdleFlows()) > 0)\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle flows on %s\",\n\t\t\t\t   n, getNumFlows(), ifname);\n\n    if((n = purgeIdleHostsMacs()) > 0)\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle hosts/macs on %s\",\n\t\t\t\t   n, getNumHosts()+getNumMacs(), ifname);\n  }\n\n  if(pkt_dumper) pkt_dumper->idle(when);\n  updateSecondTraffic(when);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::dissectPacket(const struct pcap_pkthdr *h,\n\t\t\t\t     const u_char *packet,\n\t\t\t\t     u_int16_t *ndpiProtocol,\n\t\t\t\t     Host **srcHost, Host **dstHost,\n\t\t\t\t     Flow **flow) {\n  struct ndpi_ethhdr *ethernet, dummy_ethernet;\n  u_int64_t time;\n  u_int16_t eth_type, ip_offset, vlan_id = 0, eth_offset = 0;\n  u_int32_t null_type;\n  int pcap_datalink_type = get_datalink();\n  bool pass_verdict = true;\n  u_int32_t rawsize = h->len * scalingFactor;\n\n  if(h->len > ifMTU) {\n    if(!mtuWarningShown) {\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Invalid packet received [len: %u][max-len: %u].\", h->len, ifMTU);\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"If you have TSO/GRO enabled, please disable it\");\n#ifdef linux\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Use sudo ethtool -K %s gro off gso off tso off\", ifname);\n#endif\n      mtuWarningShown = true;\n    }\n  }\n\n  setTimeLastPktRcvd(h->ts.tv_sec);\n\n  time = ((uint64_t) h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;\n\n datalink_check:\n  if(pcap_datalink_type == DLT_NULL) {\n    memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));\n\n    switch(null_type) {\n    case BSD_AF_INET:\n      eth_type = ETHERTYPE_IP;\n      break;\n    case BSD_AF_INET6_BSD:\n    case BSD_AF_INET6_FREEBSD:\n    case BSD_AF_INET6_DARWIN:\n      eth_type = ETHERTYPE_IPV6;\n      break;\n    default:\n      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict); /* Any other non IP protocol */\n    }\n\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    ip_offset = 4 + eth_offset;\n  } else if(pcap_datalink_type == DLT_EN10MB) {\n    ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];\n    ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;\n    eth_type = ntohs(ethernet->h_proto);\n  } else if(pcap_datalink_type == 113 /* Linux Cooked Capture */) {\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    eth_type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];\n    ip_offset = 16 + eth_offset;\n    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n#ifdef DLT_RAW\n  } else if(pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */) {\n    switch((packet[eth_offset] & 0xf0) >> 4) {\n    case 4:\n      eth_type = ETHERTYPE_IP;\n      break;\n    case 6:\n      eth_type = ETHERTYPE_IPV6;\n      break;\n    default:\n      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n      return(pass_verdict); /* Unknown IP protocol version */\n    }\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    ip_offset = eth_offset;\n#endif /* DLT_RAW */\n  } else if(pcap_datalink_type == DLT_IPV4) {\n    eth_type = ETHERTYPE_IP;\n    memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));\n    ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;\n    ip_offset = 0;\n  } else {\n    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n    return(pass_verdict);\n  }\n\n  while(true) {\n    if(eth_type == 0x8100 /* VLAN */) {\n      Ether80211q *qType = (Ether80211q*)&packet[ip_offset];\n\n      vlan_id = ntohs(qType->vlanId) & 0xFFF;\n      eth_type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];\n      ip_offset += 4;\n    } else if(eth_type == 0x8847 /* MPLS */) {\n      u_int8_t bos; /* bottom_of_stack */\n\n      bos = (((u_int8_t)packet[ip_offset+2]) & 0x1), ip_offset += 4;\n      if(bos) {\n\teth_type = ETHERTYPE_IP;\n\tbreak;\n      }\n    } else\n      break;\n  }\n\n decode_packet_eth:\n  switch(eth_type) {\n  case ETHERTYPE_PPOE:\n    eth_type = ETHERTYPE_IP;\n    ip_offset += 8;\n    goto decode_packet_eth;\n    break;\n\n  case ETHERTYPE_IP:\n    if(h->caplen >= ip_offset) {\n      u_int16_t frag_off;\n      struct ndpi_iphdr *iph = (struct ndpi_iphdr *) &packet[ip_offset];\n      struct ndpi_ipv6hdr *ip6 = NULL;\n\n      if(iph->version != 4) {\n\t/* This is not IPv4 */\n\tincStats(h->ts.tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\treturn(pass_verdict);\n      } else\n\tfrag_off = ntohs(iph->frag_off);\n\n      if(ntop->getGlobals()->decode_tunnels() && (iph->protocol == IPPROTO_UDP)\n\t && ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */ ) == 0)) {\n\tu_short ip_len = ((u_short)iph->ihl * 4);\n\tstruct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];\n\tu_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);\n\n\tif((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {\n\t  /* Check if it's GTPv1 */\n\t  u_int offset = (u_int)(ip_offset+ip_len+sizeof(struct ndpi_udphdr));\n\t  u_int8_t flags = packet[offset];\n\t  u_int8_t message_type = packet[offset+1];\n\n\t  if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) && (message_type == 0xFF /* T-PDU */)) {\n\t    ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8 /* GTPv1 header len */;\n\n\t    if(flags & 0x04) ip_offset += 1; /* next_ext_header is present */\n\t    if(flags & 0x02) ip_offset += 4; /* sequence_number is present (it also includes next_ext_header and pdu_number) */\n\t    if(flags & 0x01) ip_offset += 1; /* pdu_number is present */\n\n\t    iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\n\t    if(iph->version != 4) {\n\t      /* FIX - Add IPv6 support */\n\t      incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t      return(pass_verdict);\n\t    }\n\t  }\n\t} else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {\n\t  /* https://en.wikipedia.org/wiki/TZSP */\n\t  u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\t  u_int8_t version = packet[offset];\n\t  u_int8_t type    = packet[offset+1];\n\t  u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));\n\n\t  if((version == 1) && (type == 0) && (encapsulates == 1)) {\n\t    u_int8_t stop = 0;\n\n\t    offset += 4;\n\n\t    while((!stop) && (offset < h->caplen)) {\n\t      u_int8_t tag_type = packet[offset];\n\t      u_int8_t tag_len;\n\n\t      switch(tag_type) {\n\t      case 0: /* PADDING Tag */\n\t\ttag_len = 1;\n\t\tbreak;\n\t      case 1: /* END Tag */\n\t\ttag_len = 1, stop = 1;\n\t\tbreak;\n\t      default:\n\t\ttag_len = packet[offset+1];\n\t\tbreak;\n\t      }\n\n\t      offset += tag_len;\n\n\t      if(offset >= h->caplen) {\n\t\tincStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t\treturn(pass_verdict);\n\t      } else {\n\t\teth_offset = offset;\n\t\tgoto datalink_check;\n\t      }\n\t    }\n\t  }\n\t}\n\n\tif((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {\n\t  /*\n\t    Control And Provisioning of Wireless Access Points\n\n\t    https://www.rfc-editor.org/rfc/rfc5415.txt\n\n\t    CAPWAP Header          - variable length (5 MSB of byte 2 of header)\n\t    IEEE 802.11 Data Flags - 24 bytes\n\t    Logical-Link Control   - 8  bytes\n\n\t    Total = CAPWAP_header_length + 24 + 8\n\t  */\n\t  u_short eth_type;\n\t  ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\t  u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;\n\t  ip_offset = ip_offset+capwap_header_len+24+8;\n\n\t  if(ip_offset >= h->len) {\n\t    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t    return(pass_verdict);\n\t  }\n\t  eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);\n\n\t  switch(eth_type) {\n\t  case ETHERTYPE_IP:\n\t    iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\t    break;\n\t  case ETHERTYPE_IPV6:\n\t    iph = NULL;\n\t    ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];\n\t    break;\n\t  default:\n\t    incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t    return(pass_verdict);\n\t  }\n\t}\n      }\n\n      if((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())\n\tvlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;\n\n      try {\n\tpass_verdict = processPacket(&h->ts, time, ethernet, vlan_id, iph,\n\t\t\t\t     ip6, h->caplen - ip_offset, rawsize,\n\t\t\t\t     h, packet, ndpiProtocol, srcHost, dstHost, flow);\n      } catch(std::bad_alloc& ba) {\n\tstatic bool oom_warning_sent = false;\n\n\tif(!oom_warning_sent) {\n\t  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t  oom_warning_sent = true;\n\t}\n      }\n    }\n    break;\n\n  case ETHERTYPE_IPV6:\n    if(h->caplen >= ip_offset) {\n      struct ndpi_iphdr *iph = NULL;\n      struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];\n\n      if((ntohl(ip6->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0xF0000000) != 0x60000000) {\n\t/* This is not IPv6 */\n\tincStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\treturn(pass_verdict);\n      } else {\n\tu_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);\n\tu_int8_t l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;\n\n\tif(l4_proto == 0x3C /* IPv6 destination option */) {\n\t  u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;\n\t  l4_proto = options[0];\n\t  ipv6_shift = 8 * (options[1] + 1);\n\t}\n\n\tif(ntop->getGlobals()->decode_tunnels() && (l4_proto == IPPROTO_UDP)) {\n\t  ip_offset += ipv6_shift;\n\t  if(ip_offset >= h->len) {\n\t    incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t    return(pass_verdict);\n\t  }\n\n\t  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset];\n\t  u_int16_t sport = udp->source,  dport = udp->dest;\n\n\t  if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {\n\t    /*\n\t      Control And Provisioning of Wireless Access Points\n\n\t      https://www.rfc-editor.org/rfc/rfc5415.txt\n\n\t      CAPWAP Header          - variable length (5 MSB of byte 2 of header)\n\t      IEEE 802.11 Data Flags - 24 bytes\n\t      Logical-Link Control   - 8  bytes\n\n\t      Total = CAPWAP_header_length + 24 + 8\n\t    */\n\n\t    u_short eth_type;\n\t    ip_offset = ip_offset+sizeof(struct ndpi_udphdr);\n\t    u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;\n\t    ip_offset = ip_offset+capwap_header_len+24+8;\n\n\t    if(ip_offset >= h->len) {\n\t      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t      return(pass_verdict);\n\t    }\n\t    eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);\n\n\t    switch(eth_type) {\n\t    case ETHERTYPE_IP:\n\t      iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\t      ip6 = NULL;\n\t      break;\n\t    case ETHERTYPE_IPV6:\n\t      ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];\n\t      break;\n\t    default:\n\t      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n\t      return(pass_verdict);\n\t    }\n\t  }\n\t}\n\n\tif((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())\n\t  vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;\n\n\ttry {\n\t  pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id,\n\t\t\t\t       iph, ip6, h->len - ip_offset, rawsize,\n\t\t\t\t       h, packet, ndpiProtocol, srcHost, dstHost, flow);\n\t} catch(std::bad_alloc& ba) {\n\t  static bool oom_warning_sent = false;\n\n\t  if(!oom_warning_sent) {\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t    oom_warning_sent = true;\n\t  }\n\t}\n      }\n    }\n    break;\n\n  default: /* No IPv4 nor IPv6 */\n    Mac *srcMac = getMac(ethernet->h_source, vlan_id, true);\n    Mac *dstMac = getMac(ethernet->h_dest, vlan_id, true);\n\n    if(srcMac) srcMac->incSentStats(rawsize);\n    if(dstMac) dstMac->incRcvdStats(rawsize);\n\n    incStats(h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN, rawsize,\n\t     1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);\n    break;\n  }\n\n  purgeIdle(last_pkt_rcvd);\n\n  return(pass_verdict);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::startPacketPolling() {\n  if((cpu_affinity != -1) && (ntop->getNumCPUs() > 1)) {\n    if(Utils::setThreadAffinity(pollLoop, cpu_affinity))\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Could not set affinity of interface %s to core %d\",\n\t\t\t\t   get_name(), cpu_affinity);\n    else\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting affinity of interface %s to core %d\",\n\t\t\t\t   get_name(), cpu_affinity);\n  }\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t       \"Started packet polling on interface %s [id: %u]...\",\n\t\t\t       get_name(), get_id());\n  running = true;\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::shutdown() {\n  running = false;\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::cleanup() {\n  next_idle_flow_purge = next_idle_host_purge = 0;\n  cpu_affinity = -1, has_vlan_packets = false;\n  running = false, sprobe_interface = false, inline_interface = false;\n\n  getStats()->cleanup();\n\n  flows_hash->cleanup();\n  hosts_hash->cleanup();\n  macs_hash->cleanup();\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Cleanup interface %s\", get_name());\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::findFlowHosts(u_int16_t vlanId,\n\t\t\t\t     u_int8_t src_mac[6], IpAddress *_src_ip, Host **src,\n\t\t\t\t     u_int8_t dst_mac[6], IpAddress *_dst_ip, Host **dst) {\n\n  if(!isView())\n    (*src) = hosts_hash->get(vlanId, _src_ip);\n  else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if(((*src) = subInterfaces[s]->get_hosts_hash()->get(vlanId, _src_ip)) != NULL)\n\tbreak;\n    }\n  }\n\n  if((*src) == NULL) {\n    if(!hosts_hash->hasEmptyRoom()) {\n      *src = *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n\n    (*src) = new Host(this, src_mac, vlanId, _src_ip);\n    if(!hosts_hash->add(*src)) {\n      //ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many hosts in interface %s\", ifname);\n      delete *src;\n      *src = *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n  }\n\n  /* ***************************** */\n\n  (*dst) = hosts_hash->get(vlanId, _dst_ip);\n\n  if((*dst) == NULL) {\n    if(!hosts_hash->hasEmptyRoom()) {\n      *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n\n    (*dst) = new Host(this, dst_mac, vlanId, _dst_ip);\n    if(!hosts_hash->add(*dst)) {\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many hosts in interface %s\", ifname);\n      delete *dst;\n      *dst = NULL;\n      triggerTooManyHostsAlert();\n      return;\n    }\n  }\n}\n\n/* **************************************************** */\n\nstruct ndpiStatsRetrieverData {\n  nDPIStats *stats;\n  Host *host;\n};\n\nstatic bool flow_sum_protos(GenericHashEntry *flow, void *user_data) {\n  ndpiStatsRetrieverData *retriever = (ndpiStatsRetrieverData*)user_data;\n  nDPIStats *stats = retriever->stats;\n  Flow *f = (Flow*)flow;\n\n  if(retriever->host\n       && (retriever->host != f->get_cli_host())\n       && (retriever->host != f->get_srv_host()))\n    return(false); /* false = keep on walking */\n\n  f->sumStats(stats);\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getnDPIStats(nDPIStats *stats, AddressTree *allowed_hosts,\n          const char *host_ip, u_int16_t vlan_id) {\n  ndpiStatsRetrieverData retriever;\n\n  Host *h = NULL;\n  if (host_ip)\n    h = findHostsByIP(allowed_hosts, (char *)host_ip, vlan_id);\n\n  retriever.stats = stats;\n  retriever.host = h;\n  walker(walker_flows, flow_sum_protos, (void*)&retriever);\n}\n\n/* **************************************************** */\n\nstatic bool flow_update_hosts_stats(GenericHashEntry *node, void *user_data) {\n  Flow *flow = (Flow*)node;\n  struct timeval *tv = (struct timeval*)user_data;\n\n  flow->update_hosts_stats(tv, false);\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool update_hosts_stats(GenericHashEntry *node, void *user_data) {\n  Host *host = (Host*)node;\n  struct timeval *tv = (struct timeval*)user_data;\n\n  host->updateStats(tv);\n\n  /*\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Updated: %s [%d]\",\n    ((StringHost*)node)->host_key(),\n    host->getThptTrend());\n  */\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool update_macs_stats(GenericHashEntry *node, void *user_data) {\n  Mac *mac = (Mac*)node;\n  struct timeval *tv = (struct timeval*)user_data;\n\n  mac->updateStats(tv);\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::periodicStatsUpdate() {\n  struct timeval tv;\n\n  if(isView()) return;\n\n  gettimeofday(&tv, NULL);\n\n  flows_hash->walk(flow_update_hosts_stats, (void*)&tv);\n  hosts_hash->walk(update_hosts_stats, (void*)&tv);\n  macs_hash->walk(update_macs_stats, (void*)&tv);\n\n  if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    static_cast<MySQLDB*>(db)->updateStats(&tv);\n    db->flush(false /* not idle, periodic activities */);\n  }\n\n#ifdef NTOPNG_PRO\n  if(host_pools)\n    host_pools->updateStats(&tv);\n#endif\n}\n\n/* **************************************************** */\n\nstruct update_host_pool_l7policy {\n  bool update_pool_id;\n  bool update_l7policy;\n};\n\nstatic bool update_host_host_pool_l7policy(GenericHashEntry *node, void *user_data) {\n  Host *h = (Host*)node;\n  update_host_pool_l7policy *up = (update_host_pool_l7policy*)user_data;\n#ifdef HOST_POOLS_DEBUG\n  char buf[128];\n  u_int16_t cur_pool_id = h->get_host_pool();\n#endif\n\n  if(up->update_pool_id)\n    h->updateHostPool();\n\n  if(up->update_l7policy)\n    h->updateHostL7Policy();\n\n#ifdef HOST_POOLS_DEBUG\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t       \"Going to refresh pool for %s \"\n\t\t\t       \"[refresh pool id: %i] \"\n\t\t\t       \"[refresh l7policy: %i] \"\n\t\t\t       \"[host pool id before refresh: %i] \"\n\t\t\t       \"[host pool id after refresh: %i] \",\n\t\t\t       h->get_ip()->print(buf, sizeof(buf)),\n\t\t\t       up->update_pool_id ? 1 : 0,\n\t\t\t       up->update_l7policy ? 1 : 0,\n\t\t\t       cur_pool_id,\n\t\t\t       h->get_host_pool());\n\n#endif\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::refreshHostPools() {\n  if(isView()) return;\n\n  struct update_host_pool_l7policy update_host;\n  update_host.update_pool_id = true;\n  update_host.update_l7policy = false;\n\n#ifdef NTOPNG_PRO\n  if(is_bridge_interface() && getL7Policer()) {\n    /* Every pool is associated with a set of L7 rules\n     so a refresh must be triggered to seal this association */\n    getL7Policer()->refreshL7Rules();\n    /* Must refresh host l7policies as a change in the host pool id\n       may determine an l7policy change for that host */\n    update_host.update_l7policy = true;\n  }\n#endif\n\n  hosts_hash->walk(update_host_host_pool_l7policy, &update_host);\n\n#ifdef NTOPNG_PRO\n  if(update_host.update_l7policy)\n    updateFlowsL7Policy();\n#endif\n}\n\n/* **************************************************** */\n\n#ifdef NTOPNG_PRO\n\n/* **************************************************** */\n\nstatic bool update_flow_l7_policy(GenericHashEntry *node, void *user_data) {\n  Flow *f = (Flow*)node;\n\n  f->updateFlowShapers();\n  f->updateProfile();\n\n  return(false); /* false = keep on walking */\n}\n\n\n/* **************************************************** */\n\nvoid NetworkInterface::updateHostsL7Policy(u_int16_t host_pool_id) {\n  if(isView()) return;\n\n  struct update_host_pool_l7policy update_host;\n  update_host.update_pool_id = false;\n  update_host.update_l7policy = true;\n\n  hosts_hash->walk(update_host_host_pool_l7policy, &update_host);\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::updateFlowsL7Policy() {\n  if(isView()) return;\n\n  flows_hash->walk(update_flow_l7_policy, NULL);\n}\n\n#endif\n\n/* **************************************************** */\n\nstruct host_find_info {\n  char *host_to_find;\n  u_int16_t vlan_id;\n  Host *h;\n};\n\n/* **************************************************** */\n\nstruct mac_find_info {\n  u_int8_t mac[6];\n  u_int16_t vlan_id;\n  Mac *m;\n};\n\n/* **************************************************** */\n\nstatic bool find_host_by_name(GenericHashEntry *h, void *user_data) {\n  struct host_find_info *info = (struct host_find_info*)user_data;\n  Host *host                  = (Host*)h;\n\n#ifdef DEBUG\n  char buf[64];\n  ntop->getTrace()->traceEvent(TRACE_WARNING, \"[%s][%s][%s]\",\n\t\t\t       host->get_ip() ? host->get_ip()->print(buf, sizeof(buf)) : \"\",\n\t\t\t       host->get_name(), info->host_to_find);\n#endif\n\n  if((info->h == NULL) && (host->get_vlan_id() == info->vlan_id)) {\n    if((host->get_name() == NULL) && host->get_ip()) {\n      char ip_buf[32], name_buf[96];\n      char *ipaddr = host->get_ip()->print(ip_buf, sizeof(ip_buf));\n      int rc = ntop->getRedis()->getAddress(ipaddr, name_buf, sizeof(name_buf),\n\t\t\t\t\t    false /* Don't resolve it if not known */);\n\n      if(rc == 0 /* found */) host->setName(name_buf);\n    }\n\n    if(host->get_name() && (!strcmp(host->get_name(), info->host_to_find))) {\n      info->h = host;\n      return(true); /* found */\n    }\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool find_mac_by_name(GenericHashEntry *h, void *user_data) {\n  struct mac_find_info *info = (struct mac_find_info*)user_data;\n  Mac *m = (Mac*)h;\n\n  if((info->m == NULL)\n     && (m->get_vlan_id() == info->vlan_id)\n     && (!memcmp(info->mac, m->get_mac(), 6))\n     ) {\n    info->m = m;\n    return(true); /* found */\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::restoreHost(char *host_ip, u_int16_t vlan_id) {\n  Host *h = new Host(this, host_ip, vlan_id);\n\n  if(!h) return(false);\n\n  if(!hosts_hash->add(h)) {\n    //ntop->getTrace()->traceEvent(TRACE_WARNING, \"Too many hosts in interface %s\", ifname);\n    delete h;\n    return(false);\n  }\n\n  return(true);\n}\n\n/* **************************************************** */\n\nHost* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n  struct in_addr  a4;\n  struct in6_addr a6;\n  Host *h = NULL;\n\n  if(!host_ip) return(NULL);\n\n  /* Check if address is invalid */\n  if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n     && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n    /* Looks like a symbolic name */\n    struct host_find_info info;\n\n    memset(&info, 0, sizeof(info));\n    info.host_to_find = host_ip, info.vlan_id = vlan_id;\n    walker(walker_hosts, find_host_by_name, (void*)&info);\n\n    h = info.h;\n  } else {\n    IpAddress *ip = new IpAddress();\n\n    if(ip) {\n      ip->set(host_ip);\n\n      if(!isView())\n\th = hosts_hash->get(vlan_id, ip);\n      else {\n\tfor(u_int8_t s = 0; s<numSubInterfaces; s++) {\n\t  h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);\n\t  if(h) break;\n\t}\n      }\n\n      delete ip;\n    }\n  }\n\n  return(h);\n}\n\n/* **************************************************** */\n\n#ifdef NTOPNG_PRO\n\nstatic bool update_flow_profile(GenericHashEntry *h, void *user_data) {\n  Flow *flow = (Flow*)h;\n\n  flow->updateProfile();\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::updateFlowProfiles() {\n  if(isView()) return;\n\n  if(ntop->getPro()->has_valid_license()) {\n    FlowProfiles *newP;\n\n    if(shadow_flow_profiles) {\n      delete shadow_flow_profiles;\n      shadow_flow_profiles = NULL;\n    }\n\n    flow_profiles->dumpCounters();\n    shadow_flow_profiles = flow_profiles, newP = new FlowProfiles(id);\n\n    newP->loadProfiles(); /* and reload */\n    flow_profiles = newP; /* Overwrite the current profiles */\n\n    flows_hash->walk(update_flow_profile, NULL);\n  }\n}\n\n#endif\n\n/* **************************************************** */\n\nbool NetworkInterface::getHostInfo(lua_State* vm,\n\t\t\t\t   AddressTree *allowed_hosts,\n\t\t\t\t   char *host_ip, u_int16_t vlan_id) {\n  Host *h = findHostsByIP(allowed_hosts, host_ip, vlan_id);\n\n  if(h) {\n    h->lua(vm, allowed_hosts, true, true, true, false, false);\n    return(true);\n  } else\n    return(false);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::loadHostAlertPrefs(lua_State* vm,\n\t\t\t\t          AddressTree *allowed_hosts,\n\t\t\t\t          char *host_ip, u_int16_t vlan_id) {\n  Host *h = findHostsByIP(allowed_hosts, host_ip, vlan_id);\n\n  if(h) {\n    h->loadAlertPrefs();\n    return(true);\n  }\n  return(false);\n}\n\n/* **************************************************** */\n\nHost* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,\n\t\t\t\t      char *host_ip, u_int16_t vlan_id) {\n  if(host_ip != NULL) {\n    Host *h = getHost(host_ip, vlan_id);\n\n    if(h && h->match(allowed_hosts))\n      return(h);\n  }\n\n  return(NULL);\n}\n\n/* **************************************************** */\n\nstruct flowHostRetrieveList {\n  Flow *flow;\n  /* Value */\n  Host *hostValue;\n  Mac *macValue;\n  u_int64_t numericValue;\n  char *stringValue;\n};\n\nstruct flowHostRetriever {\n  /* Search criteria */\n  AddressTree *allowed_hosts;\n  Host *host;\n  Mac *mac;\n  char *manufacturer;\n  bool skipSpecialMacs, hostMacsOnly;\n  char *country;\n  int ndpi_proto;\n  sortField sorter;\n  LocationPolicy location;\n  u_int16_t *vlan_id;\n  char *osFilter;\n  u_int32_t *asnFilter;\n  int16_t *networkFilter;\n  u_int16_t *poolFilter;\n\n  /* Return values */\n  u_int32_t maxNumEntries, actNumEntries;\n  struct flowHostRetrieveList *elems;\n\n  /* Paginator */\n  Paginator *pag;\n};\n\n/* **************************************************** */\n\nstatic bool flow_search_walker(GenericHashEntry *h, void *user_data) {\n  struct flowHostRetriever *retriever = (struct flowHostRetriever*)user_data;\n  Flow *f = (Flow*)h;\n  int ndpi_proto;\n  u_int16_t port;\n  int16_t local_network_id;\n\n  if(retriever->actNumEntries >= retriever->maxNumEntries)\n    return(true); /* Limit reached */\n\n  if(f && (!f->idle())) {\n    if(retriever->host\n       && (retriever->host != f->get_cli_host())\n       && (retriever->host != f->get_srv_host()))\n    return(false); /* false = keep on walking */\n\n    if(retriever->pag\n       && retriever->pag->l7protoFilter(&ndpi_proto)\n       && ndpi_proto != -1\n       && (f->get_detected_protocol().protocol != ndpi_proto)\n       && (f->get_detected_protocol().master_protocol != ndpi_proto))\n      return(false); /* false = keep on walking */\n\n    if(retriever->pag\n       && retriever->pag->portFilter(&port)\n       && f->get_cli_port() != port\n       && f->get_srv_port() != port)\n      return(false); /* false = keep on walking */\n\n    if(retriever->pag\n       && retriever->pag->localNetworkFilter(&local_network_id)\n       && f->get_cli_host()->get_local_network_id() != local_network_id\n       && f->get_srv_host()->get_local_network_id() != local_network_id)\n      return(false); /* false = keep on walking */\n\n    if(retriever->location == location_local_only) {\n      if((!f->get_cli_host()->isLocalHost())\n\t || (!f->get_srv_host()->isLocalHost()))\n\treturn(false); /* false = keep on walking */\n    } else if(retriever->location == location_remote_only) {\n      if((f->get_cli_host()->isLocalHost())\n\t || (f->get_srv_host()->isLocalHost()))\n\treturn(false); /* false = keep on walking */\n    }\n\n    retriever->elems[retriever->actNumEntries].flow = f;\n\n    if(f->match(retriever->allowed_hosts)) {\n      switch(retriever->sorter) {\n      case column_client:\n\tretriever->elems[retriever->actNumEntries++].hostValue = f->get_cli_host();\n\tbreak;\n      case column_server:\n\tretriever->elems[retriever->actNumEntries++].hostValue = f->get_srv_host();\n\tbreak;\n      case column_vlan:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_vlan_id();\n\tbreak;\n      case column_proto_l4:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_protocol();\n\tbreak;\n      case column_ndpi:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_detected_protocol().protocol;\n\tbreak;\n      case column_duration:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_duration();\n\tbreak;\n      case column_thpt:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes_thpt();\n\tbreak;\n      case column_bytes:\n\tretriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes();\n\tbreak;\n      case column_info:\n\tif(f->getDNSQuery())            retriever->elems[retriever->actNumEntries++].stringValue = f->getDNSQuery();\n\telse if(f->getHTTPURL())        retriever->elems[retriever->actNumEntries++].stringValue = f->getHTTPURL();\n\telse if(f->getSSLCertificate()) retriever->elems[retriever->actNumEntries++].stringValue = f->getSSLCertificate();\n\telse retriever->elems[retriever->actNumEntries++].stringValue = (char*)\"\";\n\tbreak;\n      default:\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", retriever->sorter);\n\tbreak;\n      }\n    }\n  }\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool host_search_walker(GenericHashEntry *he, void *user_data) {\n  char buf[64];\n  struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;\n  Host *h = (Host*)he;\n\n  if(r->actNumEntries >= r->maxNumEntries)\n    return(true); /* Limit reached */\n\n  if(!h || h->idle() || !h->match(r->allowed_hosts))\n    return(false);\n\n  if((r->location == location_local_only      && !h->isLocalHost())         ||\n     (r->location == location_remote_only     && h->isLocalHost())          ||\n     (r->vlan_id       && *(r->vlan_id)       != h->get_vlan_id())          ||\n     (r->asnFilter     && *(r->asnFilter)     != h->get_asn())              ||\n     (r->networkFilter && *(r->networkFilter) != h->get_local_network_id()) ||\n     (r->networkFilter && *(r->networkFilter) != h->get_local_network_id()) ||\n     (r->hostMacsOnly  && h->getMac() && h->getMac()->isSpecialMac())       ||\n     (r->mac           && (h->getMac() != r->mac))                          ||\n     (r->poolFilter    && *(r->poolFilter)    != h->get_host_pool())        ||\n     (r->country  && strlen(r->country)  && (!h->get_country() || strcmp(h->get_country(), r->country))) ||\n     (r->osFilter && strlen(r->osFilter) && (!h->get_os()      || strcmp(h->get_os(), r->osFilter))))\n    return(false); /* false = keep on walking */\n\n  r->elems[r->actNumEntries].hostValue = h;\n\n  switch(r->sorter) {\n  case column_ip:\n    r->elems[r->actNumEntries++].hostValue = h; /* hostValue was already set */\n    break;\n\n  case column_alerts:\n    r->elems[r->actNumEntries++].numericValue = h->getNumAlerts();\n    break;\n\n  case column_name:\n    r->elems[r->actNumEntries++].stringValue = strdup(h->get_name(buf, sizeof(buf), false));\n    break;\n\n  case column_country:\n    r->elems[r->actNumEntries++].stringValue = strdup(h->get_country() ? h->get_country() : (char*)\"\");\n    break;\n\n  case column_os:\n    r->elems[r->actNumEntries++].stringValue = strdup(h->get_os() ? h->get_os() : (char*)\"\");\n    break;\n\n  case column_vlan:\n    r->elems[r->actNumEntries++].numericValue = h->get_vlan_id();\n    break;\n\n  case column_since:\n    r->elems[r->actNumEntries++].numericValue = h->get_first_seen();\n    break;\n\n  case column_asn:\n    r->elems[r->actNumEntries++].numericValue = h->get_asn();\n    break;\n\n  case column_thpt:\n    r->elems[r->actNumEntries++].numericValue = h->getBytesThpt();\n    break;\n\n  case column_num_flows:\n    r->elems[r->actNumEntries++].numericValue = h->getNumActiveFlows();\n    break;\n\n  case column_traffic:\n    r->elems[r->actNumEntries++].numericValue = h->getNumBytes();\n    break;\n\n  case column_local_network_id:\n    r->elems[r->actNumEntries++].numericValue = h->get_local_network_id();\n    break;\n\n  case column_mac:\n    r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(h->get_mac());\n    break;\n\n  case column_pool_id:\n    r->elems[r->actNumEntries++].numericValue = h->get_host_pool();\n    break;\n\n    /* Criteria */\n  case column_uploaders:      r->elems[r->actNumEntries++].numericValue = h->getNumBytesSent(); break;\n  case column_downloaders:    r->elems[r->actNumEntries++].numericValue = h->getNumBytesRcvd(); break;\n  case column_unknowers:      r->elems[r->actNumEntries++].numericValue = h->get_ndpi_stats()->getProtoBytes(NDPI_PROTOCOL_UNKNOWN); break;\n  case column_incomingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumIncomingFlows(); break;\n  case column_outgoingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumOutgoingFlows(); break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);\n    break;\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nstatic bool mac_search_walker(GenericHashEntry *he, void *user_data) {\n  struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;\n  Mac *m = (Mac*)he;\n\n  if(r->actNumEntries >= r->maxNumEntries)\n    return(true); /* Limit reached */\n\n  if(!m\n     || m->idle()\n     || ((r->vlan_id && (*(r->vlan_id) != m->get_vlan_id())))\n     || (r->skipSpecialMacs && m->isSpecialMac())\n     || (r->hostMacsOnly && m->getNumHosts() == 0))\n    return(false); /* false = keep on walking */\n\n  r->elems[r->actNumEntries].macValue = m;\n\n  switch(r->sorter) {\n  case column_mac:\n    r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(m->get_mac());\n    break;\n\n  case column_vlan:\n    r->elems[r->actNumEntries++].numericValue = m->get_vlan_id();\n    break;\n\n  case column_since:\n    r->elems[r->actNumEntries++].numericValue = m->get_first_seen();\n    break;\n\n  case column_thpt:\n    r->elems[r->actNumEntries++].numericValue = m->getBytesThpt();\n    break;\n\n  case column_traffic:\n    r->elems[r->actNumEntries++].numericValue = m->getNumBytes();\n    break;\n\n  case column_num_hosts:\n    r->elems[r->actNumEntries++].numericValue = m->getNumHosts();\n    break;\n\n  case column_manufacturer:\n    r->elems[r->actNumEntries++].stringValue = m->get_manufacturer() ? (char*)m->get_manufacturer() : (char*)\"zzz\";\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);\n    break;\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nint hostSorter(const void *_a, const void *_b) {\n  struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;\n  struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;\n\n  return(a->hostValue->get_ip()->compare(b->hostValue->get_ip()));\n}\n\nint numericSorter(const void *_a, const void *_b) {\n  struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;\n  struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;\n\n  if(a->numericValue < b->numericValue)      return(-1);\n  else if(a->numericValue > b->numericValue) return(1);\n  else return(0);\n}\n\nint stringSorter(const void *_a, const void *_b) {\n  struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;\n  struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;\n\n  return(strcmp(a->stringValue, b->stringValue));\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::disablePurge(bool on_flows) {\n  if(!isView()) {\n    if(on_flows)\n      flows_hash->disablePurge();\n    else {\n      hosts_hash->disablePurge();\n      macs_hash->disablePurge();\n    }\n  } else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if(on_flows)\n\tsubInterfaces[s]->get_flows_hash()->disablePurge();\n      else {\n\tsubInterfaces[s]->get_hosts_hash()->disablePurge();\n\tsubInterfaces[s]->get_macs_hash()->disablePurge();\n      }\n    }\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::enablePurge(bool on_flows) {\n  if(!isView()) {\n    if(on_flows)\n      flows_hash->enablePurge();\n    else {\n      hosts_hash->enablePurge();\n      macs_hash->enablePurge();\n    }\n  } else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if(on_flows)\n\tsubInterfaces[s]->get_flows_hash()->enablePurge();\n      else {\n\tsubInterfaces[s]->get_hosts_hash()->enablePurge();\n\tsubInterfaces[s]->get_macs_hash()->enablePurge();\n      }\n    }\n  }\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getFlows(lua_State* vm,\n\t\t\t       AddressTree *allowed_hosts,\n\t\t\t       Host *host, int ndpi_proto,\n\t\t\t       LocationPolicy location,\n\t\t\t       char *sortColumn,\n\t\t\t       u_int32_t maxHits,\n\t\t\t       u_int32_t toSkip,\n\t\t\t       bool a2zSortOrder) {\n  struct flowHostRetriever retriever;\n  int (*sorter)(const void *_a, const void *_b);\n  DetailsLevel highDetails = (location == location_local_only || (maxHits != CONST_MAX_NUM_HITS)) ? details_high : details_normal;\n\n  if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0)) maxHits = CONST_MAX_NUM_HITS;\n  retriever.pag = NULL;\n  retriever.host = host, retriever.ndpi_proto = ndpi_proto, retriever.location = location;\n  retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;\n  retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);\n\n  if(retriever.elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;\n  else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;\n  else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;\n\n  /* ******************************* */\n\n  disablePurge(true);\n  walker(walker_flows, flow_search_walker, (void*)&retriever);\n\n  qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  lua_newtable(vm);\n\n  if(a2zSortOrder) {\n    for(int i=toSkip, num=0; i<(int)retriever.actNumEntries; i++) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)maxHits) break;\n\n    }\n  } else {\n    for(int i=(retriever.actNumEntries-1-toSkip), num=0; i>=0; i--) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)maxHits) break;\n    }\n  }\n\n  enablePurge(true);\n  free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getFlows(lua_State* vm,\n\t\t\t       AddressTree *allowed_hosts,\n\t\t\t       LocationPolicy location, Host *host,\n\t\t\t       Paginator *p) {\n  struct flowHostRetriever retriever;\n  int (*sorter)(const void *_a, const void *_b);\n  char sortColumn[32];\n  DetailsLevel highDetails;\n\n  if(p == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to return results with a NULL paginator\");\n    return(-1);\n  }\n\n  highDetails = p->detailedResults() ? details_high : (location == location_local_only || (p && p->maxHits() != CONST_MAX_NUM_HITS)) ? details_high : details_normal;\n\n  retriever.pag = p;\n  retriever.host = host, retriever.location = location;\n  retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;\n  retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);\n\n  if(retriever.elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  snprintf(sortColumn, sizeof(sortColumn), \"%s\", p->sortColumn());\n  if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;\n  else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;\n  else {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);\n    retriever.sorter = column_bytes, sorter = numericSorter;\n  }\n\n  /* ******************************* */\n\n  disablePurge(true);\n  walker(walker_flows, flow_search_walker, (void*)&retriever);\n\n  qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"numFlows\", retriever.actNumEntries);\n\n  lua_newtable(vm);\n\n  if(p->a2zSortOrder()) {\n    for(int i=p->toSkip(), num=0; i<(int)retriever.actNumEntries; i++) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)p->maxHits()) break;\n\n    }\n  } else {\n    for(int i=(retriever.actNumEntries-1-p->toSkip()), num=0; i>=0; i--) {\n      lua_newtable(vm);\n\n      retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);\n\n      lua_pushnumber(vm, num + 1);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n\n      if(++num >= (int)p->maxHits()) break;\n    }\n  }\n\n  lua_pushstring(vm, \"flows\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  enablePurge(true);\n  free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getLatestActivityHostsList(lua_State* vm, AddressTree *allowed_hosts) {\n  struct flowHostRetriever retriever;\n\n  memset(&retriever, 0, sizeof(retriever));\n\n  // there's not even the need to use the retriever or to sort results here\n  // we use the retriever just to leverage on the exising code.\n  retriever.allowed_hosts = allowed_hosts, retriever.location = location_all;\n  retriever.actNumEntries = 0, retriever.maxNumEntries = getHostsHashSize();\n  retriever.sorter = column_vlan; // just a placeholder, we don't care as we won't sort\n  retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);\n\n  if(retriever.elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  disablePurge(false);\n  walker(walker_hosts, host_search_walker, (void*)&retriever);\n\n  lua_newtable(vm);\n\n  if(retriever.actNumEntries > 0) {\n    for(int i=0; i<(int)retriever.actNumEntries; i++) {\n      Host *h = retriever.elems[i].hostValue;\n\n      if(i < CONST_MAX_NUM_HITS)\n\th->lua(vm, NULL /* Already checked */,\n\t       false /* host details */,\n\t       false /* verbose */,\n\t       false /* return host */,\n\t       true  /* as list element*/,\n\t       true  /* exclude deserialized bytes */);\n    }\n  }\n\n  enablePurge(false);\n  free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::sortHosts(struct flowHostRetriever *retriever,\n\t\t\t\tAddressTree *allowed_hosts,\n\t\t\t\tbool host_details,\n\t\t\t\tLocationPolicy location,\n\t\t\t\tchar *countryFilter, char *mac_filter,\n\t\t\t\tu_int16_t *vlan_id, char *osFilter,\n\t\t\t\tu_int32_t *asnFilter, int16_t *networkFilter,\n\t\t\t\tu_int16_t *pool_filter,\n\t\t\t\tbool hostMacsOnly, char *sortColumn) {\n  u_int32_t maxHits;\n  int (*sorter)(const void *_a, const void *_b);\n\n  if(retriever == NULL)\n    return -1;\n\n  maxHits = getHostsHashSize();\n  if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))\n    maxHits = CONST_MAX_NUM_HITS;\n\n  memset(retriever, 0, sizeof(struct flowHostRetriever));\n\n  if(mac_filter) {\n    u_int8_t macAddr[6];\n\n    Utils::parseMac(macAddr, mac_filter);\n\n    retriever->mac = macs_hash->get(vlan_id ? *vlan_id : 0, (const u_int8_t*)macAddr);\n  }\n\n  retriever->allowed_hosts = allowed_hosts, retriever->location = location,\n  retriever->country = countryFilter, retriever->vlan_id = vlan_id,\n  retriever->osFilter = osFilter, retriever->asnFilter = asnFilter,\n  retriever->networkFilter = networkFilter, retriever->actNumEntries = 0,\n  retriever->poolFilter = pool_filter;\n  retriever->maxNumEntries = maxHits, retriever->hostMacsOnly = hostMacsOnly;\n  retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);\n\n  if(retriever->elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  if((!strcmp(sortColumn, \"column_ip\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_ip, sorter = hostSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\")) retriever->sorter = column_vlan, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_alerts\")) retriever->sorter = column_alerts, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_name\")) retriever->sorter = column_name, sorter = stringSorter;\n  else if(!strcmp(sortColumn, \"column_country\")) retriever->sorter = column_country, sorter = stringSorter;\n  else if(!strcmp(sortColumn, \"column_os\")) retriever->sorter = column_os, sorter = stringSorter;\n  else if(!strcmp(sortColumn, \"column_since\")) retriever->sorter = column_since, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_asn\")) retriever->sorter = column_asn, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\")) retriever->sorter = column_thpt, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_num_flows\")) retriever->sorter = column_num_flows, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_traffic\")) retriever->sorter = column_traffic, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_local_network_id\")) retriever->sorter = column_local_network_id, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_mac\")) retriever->sorter = column_mac, sorter = numericSorter;\n  /* criteria (datatype sortField in ntop_typedefs.h / see also host_search_walker:NetworkInterface.cpp) */\n  else if(!strcmp(sortColumn, \"column_uploaders\")) retriever->sorter = column_uploaders, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_downloaders\")) retriever->sorter = column_downloaders, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_unknowers\")) retriever->sorter = column_unknowers, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_incomingflows\")) retriever->sorter = column_incomingflows, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_outgoingflows\")) retriever->sorter = column_outgoingflows, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_pool_id\")) retriever->sorter = column_pool_id, sorter = numericSorter;\n  else {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);\n    retriever->sorter = column_traffic, sorter = numericSorter;\n  }\n\n  // make sure the caller has disabled the purge!!\n  walker(walker_hosts, host_search_walker, (void*)retriever);\n\n  qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  return(retriever->actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::sortMacs(struct flowHostRetriever *retriever,\n\t\t\t       u_int16_t vlan_id, bool skipSpecialMacs,\n\t\t\t       bool hostMacsOnly,\n\t\t\t       char *sortColumn) {\n  u_int32_t maxHits;\n  int (*sorter)(const void *_a, const void *_b);\n\n  if(retriever == NULL)\n    return -1;\n\n  maxHits = getMacsHashSize();\n  if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))\n    maxHits = CONST_MAX_NUM_HITS;\n\n  retriever->vlan_id = &vlan_id, retriever->skipSpecialMacs = skipSpecialMacs,\n    retriever->hostMacsOnly = hostMacsOnly, retriever->actNumEntries = 0,\n    retriever->maxNumEntries = maxHits,\n    retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);\n\n  if(retriever->elems == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");\n    return(-1);\n  }\n\n  if((!strcmp(sortColumn, \"column_mac\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_mac, sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_vlan\"))         retriever->sorter = column_vlan,         sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;\n  else if(!strcmp(sortColumn, \"column_manufacturer\")) retriever->sorter = column_manufacturer, sorter = stringSorter;\n  else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;\n\n  // make sure the caller has disabled the purge!!\n  walker(walker_macs, mac_search_walker, (void*)retriever);\n\n  qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);\n\n  return(retriever->actNumEntries);\n}\n\n/* **************************************************** */\n\nint NetworkInterface::getActiveHostsList(lua_State* vm, AddressTree *allowed_hosts,\n\t\t\t\t\t bool host_details, LocationPolicy location,\n\t\t\t\t\t char *countryFilter, char *mac_filter,\n\t\t\t\t\t u_int16_t *vlan_id, char *osFilter,\n\t\t\t\t\t u_int32_t *asnFilter, int16_t *networkFilter,\n\t\t\t\t\t u_int16_t *pool_filter,\n\t\t\t\t\t char *sortColumn, u_int32_t maxHits,\n\t\t\t\t\t u_int32_t toSkip, bool a2zSortOrder) {\n  struct flowHostRetriever retriever;\n\n  disablePurge(false);\n\n  if(sortHosts(&retriever, allowed_hosts, host_details, location,\n\t       countryFilter, mac_filter, vlan_id, osFilter,\n\t       asnFilter, networkFilter, pool_filter, true, sortColumn) < 0) {\n    enablePurge(false);\n    return -1;\n  }\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"numHosts\", retriever.actNumEntries);\n\n  lua_newtable(vm);\n\n  if(a2zSortOrder) {\n    for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {\n      Host *h = retriever.elems[i].hostValue;\n      h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);\n    }\n  } else {\n    for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {\n      Host *h = retriever.elems[i].hostValue;\n      h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);\n    }\n  }\n\n  lua_pushstring(vm, \"hosts\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  enablePurge(false);\n\n  // it's up to us to clean sorted data\n  // make sure first to free elements in case a string sorter has been used\n  if(retriever.sorter == column_name\n     || retriever.sorter == column_country\n     || retriever.sorter == column_os) {\n    for(u_int i=0; i<retriever.maxNumEntries; i++)\n      if(retriever.elems[i].stringValue)\n\tfree(retriever.elems[i].stringValue);\n  }\n\n  // finally free the elements regardless of the sorted kind\n  if(retriever.elems) free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n/* **************************************************** */\n\nint NetworkInterface::getActiveHostsGroup(lua_State* vm, AddressTree *allowed_hosts,\n\t\t\t\t\t  bool host_details, LocationPolicy location,\n\t\t\t\t\t  char *countryFilter,\n\t\t\t\t\t  u_int16_t *vlan_id, char *osFilter,\n\t\t\t\t\t  u_int32_t *asnFilter, int16_t *networkFilter,\n\t\t\t\t\t  u_int16_t *pool_filter,\n\t\t\t\t\t  bool local_macs, char *groupColumn) {\n  struct flowHostRetriever retriever;\n  Grouper *gper;\n\n  disablePurge(false);\n\n  // sort hosts according to the grouping criterion\n  if(sortHosts(&retriever, allowed_hosts, host_details, location,\n\t       countryFilter, NULL /* Mac */, vlan_id,\n\t       osFilter, asnFilter, networkFilter, pool_filter,\n\t       local_macs, groupColumn) < 0 ) {\n    enablePurge(false);\n    return -1;\n  }\n\n  // build a new grouper that will help in aggregating stats\n  if((gper = new(std::nothrow) Grouper(retriever.sorter)) == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR,\n\t\t\t\t \"Unable to allocate memory for a Grouper.\");\n    enablePurge(false);\n    return -1;\n  }\n\n  lua_newtable(vm);\n\n  for(int i=0; i<(int)retriever.actNumEntries; i++) {\n    Host *h = retriever.elems[i].hostValue;\n\n    if(h) {\n      if(gper->inGroup(h) == false) {\n\tif(gper->getNumEntries() > 0)\n\t  gper->lua(vm);\n\tgper->newGroup(h);\n      }\n\n      gper->incStats(h);\n    }\n  }\n\n  if(gper->getNumEntries() > 0)\n    gper->lua(vm);\n\n delete gper;\n  gper = NULL;\n\n  enablePurge(false);\n\n  // it's up to us to clean sorted data\n  // make sure first to free elements in case a string sorter has been used\n  if((retriever.sorter == column_name)\n     || (retriever.sorter == column_country)\n     || (retriever.sorter == column_os)) {\n    for(u_int i=0; i<retriever.maxNumEntries; i++)\n      if(retriever.elems[i].stringValue)\n\tfree(retriever.elems[i].stringValue);\n  }\n\n  // finally free the elements regardless of the sorted kind\n  if(retriever.elems) free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************************** */\n\nstatic bool flow_stats_walker(GenericHashEntry *h, void *user_data) {\n  struct active_flow_stats *stats = (struct active_flow_stats*)user_data;\n  Flow *flow = (Flow*)h;\n\n  stats->num_flows++,\n    stats->ndpi_bytes[flow->get_detected_protocol().protocol] += (u_int32_t)flow->get_bytes(),\n    stats->breeds_bytes[flow->get_protocol_breed()] += (u_int32_t)flow->get_bytes();\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getFlowsStats(lua_State* vm) {\n  struct active_flow_stats stats;\n\n  memset(&stats, 0, sizeof(stats));\n  walker(walker_flows, flow_stats_walker, (void*)&stats);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"num_flows\", stats.num_flows);\n\n  lua_newtable(vm);\n  for(int i=0; i<NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS; i++) {\n    if(stats.ndpi_bytes[i] > 0)\n      lua_push_int_table_entry(vm,\n\t\t\t       ndpi_get_proto_name(get_ndpi_struct(), i),\n\t\t\t       stats.ndpi_bytes[i]);\n  }\n\n  lua_pushstring(vm, \"protos\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  lua_newtable(vm);\n  for(int i=0; i<NUM_BREEDS; i++) {\n    if(stats.breeds_bytes[i] > 0)\n      lua_push_int_table_entry(vm,\n\t\t\t       ndpi_get_proto_breed_name(get_ndpi_struct(),\n\t\t\t\t\t\t\t (ndpi_protocol_breed_t)i),\n\t\t\t       stats.breeds_bytes[i]);\n  }\n\n  lua_pushstring(vm, \"breeds\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n}\n/* **************************************************** */\n\nvoid NetworkInterface::getNetworksStats(lua_State* vm) {\n  NetworkStats *network_stats;\n  u_int8_t num_local_networks = ntop->getNumLocalNetworks();\n\n  lua_newtable(vm);\n  for(u_int8_t network_id = 0; network_id < num_local_networks; network_id++) {\n    network_stats = getNetworkStats(network_id);\n    // do not add stats of networks that have not generated any traffic\n    if(!network_stats || !network_stats->trafficSeen())\n      continue;\n    lua_newtable(vm);\n    network_stats->lua(vm);\n    lua_push_int32_table_entry(vm, \"network_id\", network_id);\n    lua_pushstring(vm, ntop->getLocalNetworkName(network_id));\n    lua_insert(vm, -2);\n    lua_settable(vm, -3);\n  }\n}\n\n/* **************************************************** */\n\nstatic bool host_activity_walker(GenericHashEntry *he, void *user_data) {\n  HostActivityRetriever * r = (HostActivityRetriever *)user_data;\n  Host *h = (Host*)he;\n  int i;\n\n  if(!h\n     || !h->equal(&r->search)\n     || (!h->get_user_activities()))\n    return(false); /* false = keep on walking */\n\n  r->found = true;\n  for(i=0; i<UserActivitiesN; i++)\n    r->counters[i] = *h->getActivityBytes((UserActivityID)i);\n\n  return true; /* found, stop walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getLocalHostActivity(lua_State* vm, const char *host) {\n  HostActivityRetriever retriever(host);\n  int i;\n\n  disablePurge(false);\n  walker(walker_hosts, host_activity_walker, &retriever);\n  enablePurge(false);\n\n  if(retriever.found) {\n    lua_newtable(vm);\n    for(i=0; i<UserActivitiesN; i++) {\n      lua_newtable(vm);\n\n      lua_push_int_table_entry(vm, \"up\", retriever.counters[i].up);\n      lua_push_int_table_entry(vm, \"down\", retriever.counters[i].down);\n      lua_push_int_table_entry(vm, \"background\", retriever.counters[i].background);\n\n      lua_pushstring(vm, activity_names[i]);\n      lua_insert(vm, -2);\n      lua_settable(vm, -3);\n    }\n  } else\n    lua_pushnil(vm);\n}\n\n/* **************************************************** */\n\nu_int NetworkInterface::purgeIdleFlows() {\n  if(!purge_idle_flows_hosts) return(0);\n\n  if(next_idle_flow_purge == 0) {\n    next_idle_flow_purge = last_pkt_rcvd + FLOW_PURGE_FREQUENCY;\n    return(0);\n  } else if(last_pkt_rcvd < next_idle_flow_purge)\n    return(0); /* Too early */\n  else {\n    /* Time to purge flows */\n    u_int n;\n\n    // ntop->getTrace()->traceEvent(TRACE_INFO, \"Purging idle flows\");\n    n = flows_hash->purgeIdle();\n\n    if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n      // flush the queue\n      db->flush(true /* idle */);\n    }\n\n    next_idle_flow_purge = last_pkt_rcvd + FLOW_PURGE_FREQUENCY;\n    return(n);\n  }\n}\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getNumPackets() {\n  u_int64_t tot = ethStats.getNumPackets();\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumPackets();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getNumBytes() {\n  u_int64_t tot = ethStats.getNumBytes();\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumBytes();\n  return(tot);\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getNumPacketDrops() {\n  u_int32_t tot = getNumDroppedPackets();\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumDroppedPackets();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumFlows()        {\n  u_int tot = flows_hash ? flows_hash->getNumEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumFlows();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumHosts()        {\n  u_int tot = hosts_hash ? hosts_hash->getNumEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHosts();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumHTTPHosts()    {\n  u_int tot = hosts_hash ? hosts_hash->getNumHTTPEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHTTPHosts();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::getNumMacs()        {\n  u_int tot = macs_hash ? macs_hash->getNumEntries() : 0;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumMacs();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int NetworkInterface::purgeIdleHostsMacs() {\n  if(!purge_idle_flows_hosts) return(0);\n\n  if(next_idle_host_purge == 0) {\n    next_idle_host_purge = last_pkt_rcvd + HOST_PURGE_FREQUENCY;\n    return(0);\n  } else if(last_pkt_rcvd < next_idle_host_purge)\n    return(0); /* Too early */\n  else {\n    /* Time to purge hosts */\n    u_int n;\n\n    // ntop->getTrace()->traceEvent(TRACE_INFO, \"Purging idle hosts\");\n    n = hosts_hash->purgeIdle() + macs_hash->purgeIdle();\n    next_idle_host_purge = last_pkt_rcvd + HOST_PURGE_FREQUENCY;\n    return(n);\n  }\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::getnDPIProtocols(lua_State *vm) {\n  int i;\n\n  lua_newtable(vm);\n\n  for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {\n    char buf[8];\n\n    snprintf(buf, sizeof(buf), \"%d\", i);\n    lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::getnDPIProtocols(lua_State *vm, ndpi_protocol_category_t filter) {\n  int i;\n\n  lua_newtable(vm);\n\n  for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {\n    char buf[8];\n\n    if (ndpi_struct->proto_defaults[i].protoCategory == filter) {\n      snprintf(buf, sizeof(buf), \"%d\", i);\n      lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);\n    }\n  }\n}\n\n/* **************************************************** */\n\n#define NUM_TCP_STATES      4\n/*\n  0 = RST\n  1 = SYN\n  2 = Established\n  3 = FIN\n*/\n\nstatic bool num_flows_state_walker(GenericHashEntry *node, void *user_data) {\n  Flow *flow = (Flow*)node;\n  u_int32_t *num_flows = (u_int32_t*)user_data;\n\n  switch(flow->getFlowState()) {\n  case flow_state_syn:\n    num_flows[1]++;\n    break;\n  case flow_state_established:\n    num_flows[2]++;\n    break;\n  case flow_state_rst:\n    num_flows[0]++;\n    break;\n  case flow_state_fin:\n    num_flows[3]++;\n    break;\n  default:\n    /* UDP... */\n    break;\n  }\n\n  return(false /* keep walking */);\n}\n\n/* *************************************** */\n\nstatic bool num_flows_walker(GenericHashEntry *node, void *user_data) {\n  Flow *flow = (Flow*)node;\n  u_int32_t *num_flows = (u_int32_t*)user_data;\n\n  num_flows[flow->get_detected_protocol().protocol]++;\n\n  return(false /* keep walking */);\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::getFlowsStatus(lua_State *vm) {\n  u_int32_t num_flows[NUM_TCP_STATES] = { 0 };\n\n  walker(walker_flows, num_flows_state_walker, num_flows);\n\n  lua_push_int_table_entry(vm, \"RST\", num_flows[0]);\n  lua_push_int_table_entry(vm, \"SYN\", num_flows[1]);\n  lua_push_int_table_entry(vm, \"Established\", num_flows[2]);\n  lua_push_int_table_entry(vm, \"FIN\", num_flows[3]);\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::getnDPIFlowsCount(lua_State *vm) {\n  u_int32_t *num_flows;\n\n  num_flows = (u_int32_t*)calloc(ndpi_struct->ndpi_num_supported_protocols, sizeof(u_int32_t));\n\n  if(num_flows) {\n    walker(walker_flows, num_flows_walker, num_flows);\n\n    for(int i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {\n      if(num_flows[i] > 0)\n\tlua_push_int_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, num_flows[i]);\n    }\n\n    free(num_flows);\n  }\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::sumStats(TcpFlowStats *_tcpFlowStats,\n\t\t\t\tEthStats *_ethStats,\n\t\t\t\tLocalTrafficStats *_localStats,\n\t\t\t\tnDPIStats *_ndpiStats,\n\t\t\t\tPacketStats *_pktStats,\n\t\t\t\tTcpPacketStats *_tcpPacketStats) {\n  tcpFlowStats.sum(_tcpFlowStats), ethStats.sum(_ethStats), localStats.sum(_localStats),\n    ndpiStats.sum(_ndpiStats), pktStats.sum(_pktStats), tcpPacketStats.sum(_tcpPacketStats);\n}\n\n/* *************************************** */\n\nvoid NetworkInterface::lua(lua_State *vm) {\n  TcpFlowStats _tcpFlowStats;\n  EthStats _ethStats;\n  LocalTrafficStats _localStats;\n  nDPIStats _ndpiStats;\n  PacketStats _pktStats;\n  TcpPacketStats _tcpPacketStats;\n\n  lua_newtable(vm);\n\n  lua_push_str_table_entry(vm, \"name\", ifname);\n  lua_push_int_table_entry(vm, \"scalingFactor\", scalingFactor);\n  lua_push_int_table_entry(vm,  \"id\", id);\n  lua_push_bool_table_entry(vm, \"isView\", isView()); /* View interface */\n  lua_push_int_table_entry(vm,  \"seen.last\", getTimeLastPktRcvd());\n  lua_push_bool_table_entry(vm, \"sprobe\", get_sprobe_interface());\n  lua_push_bool_table_entry(vm, \"inline\", get_inline_interface());\n  lua_push_bool_table_entry(vm, \"vlan\",   get_has_vlan_packets());\n\n  if(remoteIfname)      lua_push_str_table_entry(vm, \"remote.name\",    remoteIfname);\n  if(remoteIfIPaddr)    lua_push_str_table_entry(vm, \"remote.if_addr\", remoteIfIPaddr);\n  if(remoteProbeIPaddr) lua_push_str_table_entry(vm, \"probe.ip\", remoteProbeIPaddr);\n  if(remoteProbePublicIPaddr) lua_push_str_table_entry(vm, \"probe.public_ip\", remoteProbePublicIPaddr);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"packets\",     getNumPackets());\n  lua_push_int_table_entry(vm, \"bytes\",       getNumBytes());\n  lua_push_int_table_entry(vm, \"flows\",       getNumFlows());\n  lua_push_int_table_entry(vm, \"hosts\",       getNumHosts());\n  lua_push_int_table_entry(vm, \"http_hosts\",  getNumHTTPHosts());\n  lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops());\n  lua_push_int_table_entry(vm, \"devices\", numL2Devices);\n  /* even if the counter is global, we put it here on every interface\n     as we may decide to make an elasticsearch thread per interface.\n   */\n  if(ntop->getPrefs()->do_dump_flows_on_es()) {\n    ntop->getElasticSearch()->lua(vm, false /* Overall */);\n  } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    if(db) db->lua(vm, false /* Overall */);\n  }\n  lua_pushstring(vm, \"stats\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"packets\",     getNumPackets() - getCheckPointNumPackets());\n  lua_push_int_table_entry(vm, \"bytes\",       getNumBytes() - getCheckPointNumBytes());\n  lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops() - getCheckPointNumPacketDrops());\n  if(ntop->getPrefs()->do_dump_flows_on_es()) {\n    ntop->getElasticSearch()->lua(vm, true /* Since last checkpoint */);\n  } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    if(db) db->lua(vm, true /* Since last checkpoint */);\n  }\n  lua_pushstring(vm, \"stats_since_reset\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  lua_push_int_table_entry(vm, \"remote_pps\", last_remote_pps);\n  lua_push_int_table_entry(vm, \"remote_bps\", last_remote_bps);\n\n  lua_push_str_table_entry(vm, \"type\", (char*)get_type());\n  lua_push_int_table_entry(vm, \"speed\", ifSpeed);\n  lua_push_int_table_entry(vm, \"mtu\", ifMTU);\n  lua_push_int_table_entry(vm, \"alertLevel\", alertLevel);\n  lua_push_str_table_entry(vm, \"ip_addresses\", (char*)getLocalIPAddresses());\n\n  sumStats(&_tcpFlowStats, &_ethStats, &_localStats,\n\t   &_ndpiStats, &_pktStats, &_tcpPacketStats);\n\n  for(u_int8_t s = 0; s<numSubInterfaces; s++)\n    subInterfaces[s]->sumStats(&_tcpFlowStats, &_ethStats,\n\t\t\t       &_localStats, &_ndpiStats, &_pktStats, &_tcpPacketStats);\n\n  _tcpFlowStats.lua(vm, \"tcpFlowStats\");\n  _ethStats.lua(vm);\n  _localStats.lua(vm);\n  _ndpiStats.lua(this, vm);\n  _pktStats.lua(vm, \"pktSizeDistribution\");\n  _tcpPacketStats.lua(vm, \"tcpPacketStats\");\n\n  if(!isView()) {\n    if(pkt_dumper)    pkt_dumper->lua(vm);\n#ifdef NTOPNG_PRO\n    if(flow_profiles) flow_profiles->lua(vm);\n#endif\n  }\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::runHousekeepingTasks() {\n  /* NOTE NOTE NOTE\n\n     This task runs asynchronously with respect to ntopng\n     so if you need to allocate memory you must LOCK\n\n     Example HTTPStats::updateHTTPHostRequest() is called\n     by both this function and the main thread\n  */\n\n  periodicStatsUpdate();\n}\n\n/* **************************************************** */\n\nMac* NetworkInterface::getMac(u_int8_t _mac[6], u_int16_t vlanId,\n\t\t\t      bool createIfNotPresent) {\n  Mac *ret = NULL;\n\n  if(_mac == NULL) return(NULL);\n\n  if(!isView())\n    ret = macs_hash->get(vlanId, _mac);\n  else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      if((ret = subInterfaces[s]->get_macs_hash()->get(vlanId, _mac)) != NULL)\n\tbreak;\n    }\n  }\n\n  if((ret == NULL) && createIfNotPresent) {\n    try {\n      if((ret = new Mac(this, _mac, vlanId)) != NULL)\n\tmacs_hash->add(ret);\n    } catch(std::bad_alloc& ba) {\n      static bool oom_warning_sent = false;\n\n      if(!oom_warning_sent) {\n\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\toom_warning_sent = true;\n      }\n\n      return(NULL);\n    }\n  }\n\n  return(ret);\n}\n\n/* **************************************************** */\n\nFlow* NetworkInterface::findFlowByKey(u_int32_t key,\n\t\t\t\t      AddressTree *allowed_hosts) {\n  Flow *f;\n\n  if(!isView())\n    f = (Flow*)(flows_hash->findByKey(key));\n  else {\n    for(u_int8_t s = 0; s<numSubInterfaces; s++) {\n      f = (Flow*)subInterfaces[s]->get_flows_hash()->findByKey(key);\n      if(f) break;\n    }\n  }\n\n  if(f && (!f->match(allowed_hosts))) f = NULL;\n  return(f);\n}\n\n/* **************************************************** */\n\nstruct search_host_info {\n  lua_State *vm;\n  char *host_name_or_ip;\n  u_int num_matches;\n  AddressTree *allowed_hosts;\n};\n\n/* **************************************************** */\n\nstatic bool hosts_search_walker(GenericHashEntry *h, void *user_data) {\n  Host *host = (Host*)h;\n  struct search_host_info *info = (struct search_host_info*)user_data;\n\n  if(host->addIfMatching(info->vm, info->allowed_hosts, info->host_name_or_ip))\n    info->num_matches++;\n\n  /* Stop after CONST_MAX_NUM_FIND_HITS matches */\n  return((info->num_matches > CONST_MAX_NUM_FIND_HITS) ? true /* stop */ : false /* keep walking */);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::findHostsByName(lua_State* vm,\n\t\t\t\t       AddressTree *allowed_hosts,\n\t\t\t\t       char *key) {\n  struct search_host_info info;\n\n  info.vm = vm, info.host_name_or_ip = key, info.num_matches = 0, info.allowed_hosts = allowed_hosts;\n\n  lua_newtable(vm);\n  walker(walker_hosts, hosts_search_walker, (void*)&info);\n  return(info.num_matches > 0);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::validInterface(char *name) {\n  if(name &&\n     (strstr(name, \"PPP\")            /* Avoid to use the PPP interface              */\n      || strstr(name, \"dialup\")      /* Avoid to use the dialup interface           */\n      || strstr(name, \"ICSHARE\")     /* Avoid to use the internet sharing interface */\n      || strstr(name, \"NdisWan\"))) { /* Avoid to use the internet sharing interface */\n    return(false);\n  }\n\n  return(true);\n}\n\n/* **************************************************** */\n\nu_int NetworkInterface::printAvailableInterfaces(bool printHelp, int idx,\n\t\t\t\t\t\t char *ifname, u_int ifname_len) {\n  char ebuf[256];\n  int numInterfaces = 0;\n  pcap_if_t *devpointer;\n\n  if(printHelp && help_printed)\n    return(0);\n\n  ebuf[0] = '\\0';\n\n  if(pcap_findalldevs(&devpointer, ebuf) < 0) {\n    ;\n  } else {\n    if(ifname == NULL) {\n      if(printHelp)\n\tprintf(\"Available interfaces (-i <interface index>):\\n\");\n      else if(!help_printed)\n\tntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t     \"Available interfaces (-i <interface index>):\");\n    }\n\n    for(int i = 0; devpointer != NULL; i++) {\n      if(validInterface(devpointer->description)) {\n\tnumInterfaces++;\n\n\tif(ifname == NULL) {\n\t  if(printHelp) {\n#ifdef WIN32\n\t    printf(\"   %d. %s\\n\"\n\t\t   \"\\t%s\\n\", numInterfaces,\n\t\t   devpointer->description ? devpointer->description : \"\",\n\t\t   devpointer->name);\n#else\n\t    printf(\"   %d. %s\\n\", numInterfaces, devpointer->name);\n#endif\n\t  } else if(!help_printed)\n\t    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%d. %s (%s)\\n\",\n\t\t\t\t\t numInterfaces, devpointer->name,\n\t\t\t\t\t devpointer->description ? devpointer->description : devpointer->name);\n\t} else if(numInterfaces == idx) {\n\t  snprintf(ifname, ifname_len, \"%s\", devpointer->name);\n\t  break;\n\t}\n      }\n\n      devpointer = devpointer->next;\n    } /* for */\n  } /* else */\n\n  if(numInterfaces == 0) {\n#ifdef WIN32\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available! This application cannot work\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Make sure that winpcap is installed properly,\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"that you have administrative rights,\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"and that you have network interfaces installed.\");\n#else\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available: are you superuser?\");\n#endif\n  }\n\n  help_printed = true;\n\n  return(numInterfaces);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::isNumber(const char *str) {\n  while(*str) {\n    if(!isdigit(*str))\n      return(false);\n\n    str++;\n  }\n\n  return(true);\n}\n\n/* **************************************************** */\n\nstruct correlator_host_info {\n  lua_State* vm;\n  Host *h;\n  activity_bitmap x;\n};\n\nstatic bool correlator_walker(GenericHashEntry *node, void *user_data) {\n  Host *h = (Host*)node;\n  struct correlator_host_info *info = (struct correlator_host_info*)user_data;\n\n  if(h\n     // && h->isLocalHost() /* Consider only local hosts */\n     && h->get_ip()\n     && (h != info->h)) {\n    char buf[32], *name = h->get_ip()->print(buf, sizeof(buf));\n    activity_bitmap y;\n    double pearson;\n\n    h->getActivityStats()->extractPoints(&y);\n\n    pearson = Utils::pearsonValueCorrelation(&(info->x), &y);\n\n    /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s: %f\", name, pearson); */\n    lua_push_float_table_entry(info->vm, name, (float)pearson);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\nstatic bool similarity_walker(GenericHashEntry *node, void *user_data) {\n  Host *h = (Host*)node;\n  struct correlator_host_info *info = (struct correlator_host_info*)user_data;\n\n  if(h\n     // && h->isLocalHost() /* Consider only local hosts */\n     && h->get_ip()\n     && (h != info->h)) {\n    char buf[32], name[64];\n\n    if(h->get_vlan_id() == 0) {\n      sprintf(name, \"%s\",h->get_ip()->print(buf, sizeof(buf)));\n    } else {\n      sprintf(name, \"%s@%d\",h->get_ip()->print(buf, sizeof(buf)),h->get_vlan_id());\n    }\n\n    activity_bitmap y;\n    double jaccard;\n\n    h->getActivityStats()->extractPoints(&y);\n\n    jaccard = Utils::JaccardSimilarity(&(info->x), &y);\n\n    /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s: %f\", name, pearson); */\n    lua_push_float_table_entry(info->vm, name, (float)jaccard);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::correlateHostActivity(lua_State* vm,\n\t\t\t\t\t     AddressTree *allowed_hosts,\n\t\t\t\t\t     char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, correlator_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}\n\n/* **************************************************** */\n\nbool NetworkInterface::similarHostActivity(lua_State* vm,\n\t\t\t\t\t   AddressTree *allowed_hosts,\n\t\t\t\t\t   char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, similarity_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}\n\n/* **************************************************** */\n\nstruct user_flows {\n  lua_State* vm;\n  char *username;\n};\n\nstatic bool userfinder_walker(GenericHashEntry *node, void *user_data) {\n  Flow *f = (Flow*)node;\n  struct user_flows *info = (struct user_flows*)user_data;\n  char *user = f->get_username(true);\n\n  if(user == NULL)\n    user = f->get_username(false);\n\n  if(user && (strcmp(user, info->username) == 0)) {\n    f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n    lua_pushnumber(info->vm, f->key()); // Key\n    lua_insert(info->vm, -2);\n    lua_settable(info->vm, -3);\n  }\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************************** */\n\nvoid NetworkInterface::findUserFlows(lua_State *vm, char *username) {\n  struct user_flows u;\n\n  u.vm = vm, u.username = username;\n  walker(walker_flows, userfinder_walker, &u);\n}\n\n/* **************************************************** */\n\nstruct proc_name_flows {\n  lua_State* vm;\n  char *proc_name;\n};\n\nstatic bool proc_name_finder_walker(GenericHashEntry *node, void *user_data) {\n  Flow *f = (Flow*)node;\n  struct proc_name_flows *info = (struct proc_name_flows*)user_data;\n  char *name = f->get_proc_name(true);\n\n  if(name && (strcmp(name, info->proc_name) == 0)) {\n      f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n      lua_pushnumber(info->vm, f->key()); // Key\n      lua_insert(info->vm, -2);\n      lua_settable(info->vm, -3);\n  } else {\n    name = f->get_proc_name(false);\n\n    if(name && (strcmp(name, info->proc_name) == 0)) {\n        f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n        lua_pushnumber(info->vm, f->key()); // Key\n        lua_insert(info->vm, -2);\n        lua_settable(info->vm, -3);\n    }\n  }\n\n  return(false); /* false = keep on walking */\n}\n\nvoid NetworkInterface::findProcNameFlows(lua_State *vm, char *proc_name) {\n  struct proc_name_flows u;\n\n  u.vm = vm, u.proc_name = proc_name;\n  walker(walker_flows, proc_name_finder_walker, &u);\n}\n\n/* **************************************************** */\n\nstruct pid_flows {\n  lua_State* vm;\n  u_int32_t pid;\n};\n\nstatic bool pidfinder_walker(GenericHashEntry *node, void *pid_data) {\n  Flow *f = (Flow*)node;\n  struct pid_flows *info = (struct pid_flows*)pid_data;\n\n  if((f->getPid(true) == info->pid) || (f->getPid(false) == info->pid)) {\n    f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n    lua_pushnumber(info->vm, f->key()); // Key\n    lua_insert(info->vm, -2);\n    lua_settable(info->vm, -3);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::findPidFlows(lua_State *vm, u_int32_t pid) {\n  struct pid_flows u;\n\n  u.vm = vm, u.pid = pid;\n  walker(walker_flows, pidfinder_walker, &u);\n}\n\n/* **************************************** */\n\nstatic bool father_pidfinder_walker(GenericHashEntry *node, void *father_pid_data) {\n  Flow *f = (Flow*)node;\n  struct pid_flows *info = (struct pid_flows*)father_pid_data;\n\n  if((f->getFatherPid(true) == info->pid) || (f->getFatherPid(false) == info->pid)) {\n    f->lua(info->vm, NULL, details_normal /* Minimum details */, false);\n    lua_pushnumber(info->vm, f->key()); // Key\n    lua_insert(info->vm, -2);\n    lua_settable(info->vm, -3);\n  }\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::findFatherPidFlows(lua_State *vm, u_int32_t father_pid) {\n  struct pid_flows u;\n\n  u.vm = vm, u.pid = father_pid;\n  walker(walker_flows, father_pidfinder_walker, &u);\n}\n\n/* **************************************** */\n\nstruct virtual_host_valk_info {\n  lua_State *vm;\n  char *key;\n  u_int32_t num;\n};\n\nstatic bool virtual_http_hosts_walker(GenericHashEntry *node, void *data) {\n  Host *h = (Host*)node;\n  struct virtual_host_valk_info *info = (struct virtual_host_valk_info*)data;\n  HTTPstats *s = h->getHTTPstats();\n\n  if(s)\n    info->num += s->luaVirtualHosts(info->vm, info->key, h);\n\n  return(false); /* false = keep on walking */\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::listHTTPHosts(lua_State *vm, char *key) {\n  struct virtual_host_valk_info info;\n\n  lua_newtable(vm);\n\n  info.vm = vm, info.key = key, info.num = 0;\n  walker(walker_hosts, virtual_http_hosts_walker, &info);\n}\n\n/* **************************************** */\n\nbool NetworkInterface::isInterfaceUp(char *name) {\n#ifdef WIN32\n  return(true);\n#else\n  struct ifreq ifr;\n  int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);\n\n  if(strlen(name) >= sizeof(ifr.ifr_name))\n    return(false);\n\n  memset(&ifr, 0, sizeof(ifr));\n  strcpy(ifr.ifr_name, name);\n  if(ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {\n    closesocket(sock);\n    return(false);\n  }\n  closesocket(sock);\n  return(!!(ifr.ifr_flags & IFF_UP));\n#endif\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::addAllAvailableInterfaces() {\n  char ebuf[256] = { '\\0' };\n  pcap_if_t *devpointer;\n\n  if(pcap_findalldevs(&devpointer, ebuf) < 0) {\n    ;\n  } else {\n    for(int i = 0; devpointer != 0; i++) {\n      if(validInterface(devpointer->description)\n\t && isInterfaceUp(devpointer->name)) {\n\tntop->getPrefs()->add_network_interface(devpointer->name,\n\t\t\t\t\t\tdevpointer->description);\n      } else\n\tntop->getTrace()->traceEvent(TRACE_INFO, \"Interface [%s][%s] not valid or down: discarded\",\n\t\t\t\t     devpointer->name, devpointer->description);\n\n      devpointer = devpointer->next;\n    } /* for */\n    pcap_freealldevs(devpointer);\n  }\n}\n\n/* **************************************** */\n\n#ifdef NTOPNG_PRO\nvoid NetworkInterface::refreshL7Rules() {\n  if(ntop->getPro()->has_valid_license() && policer)\n    policer->refreshL7Rules();\n}\n#endif\n\n/* **************************************** */\n\n#ifdef NTOPNG_PRO\nvoid NetworkInterface::refreshShapers() {\n  if(ntop->getPro()->has_valid_license() && policer)\n    policer->refreshShapers();\n}\n#endif\n\n/* **************************************** */\n\nvoid NetworkInterface::addInterfaceAddress(char *addr) {\n  if(ip_addresses.size() == 0)\n    ip_addresses = addr;\n  else {\n    string s = addr;\n\n    ip_addresses = ip_addresses + \",\" + s;\n  }\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::allocateNetworkStats() {\n  u_int8_t numNetworks = ntop->getNumLocalNetworks();\n\n  try {\n    networkStats = new NetworkStats[numNetworks];\n  } catch(std::bad_alloc& ba) {\n    static bool oom_warning_sent = false;\n\n    if(!oom_warning_sent) {\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      oom_warning_sent = true;\n    }\n\n    networkStats = NULL;\n  }\n}\n\n/* **************************************** */\n\nNetworkStats* NetworkInterface::getNetworkStats(u_int8_t networkId) {\n  if((networkStats == NULL) || (networkId >= ntop->getNumLocalNetworks()))\n    return(NULL);\n  else\n    return(&networkStats[networkId]);\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::updateSecondTraffic(time_t when) {\n  u_int64_t bytes = ethStats.getNumBytes();\n  u_int16_t sec = when % 60;\n\n  if(sec == 0) {\n    /* Beginning of a new minute */\n    memcpy(lastMinuteTraffic, currentMinuteTraffic, sizeof(currentMinuteTraffic));\n    resetSecondTraffic();\n  }\n\n  currentMinuteTraffic[sec] = max_val(0, bytes-lastSecTraffic);\n  lastSecTraffic = bytes;\n};\n\n/* **************************************** */\n\nvoid NetworkInterface::checkPointCounters(bool drops_only) {\n  if(!drops_only) {\n    checkpointPktCount = getNumPackets(),\n      checkpointBytesCount = getNumBytes();\n  }\n  checkpointPktDropCount = getNumPacketDrops();\n\n  if(ntop->getPrefs()->do_dump_flows_on_es()) {\n    ntop->getElasticSearch()->checkPointCounters(drops_only);\n  } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {\n    if(db) db->checkPointCounters(drops_only);\n  }\n}\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getCheckPointNumPackets() {\n  u_int64_t tot = checkpointPktCount;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPackets();\n  return(tot);\n};\n\n/* **************************************************** */\n\nu_int64_t NetworkInterface::getCheckPointNumBytes() {\n  u_int64_t tot = checkpointBytesCount;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumBytes();\n  return(tot);\n}\n\n/* **************************************************** */\n\nu_int32_t NetworkInterface::getCheckPointNumPacketDrops() {\n  u_int32_t tot = checkpointPktDropCount;\n  for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPacketDrops();\n  return(tot);\n};\n\n/* **************************************** */\n\nvoid NetworkInterface::setRemoteStats(char *name, char *address, u_int32_t speedMbit,\n\t\t\t\t      char *remoteProbeAddress, char *remoteProbePublicAddress,\n\t\t\t\t      u_int64_t remBytes, u_int64_t remPkts,\n\t\t\t\t      u_int32_t remTime, u_int32_t last_pps, u_int32_t last_bps) {\n  if(name)               setRemoteIfname(name);\n  if(address)            setRemoteIfIPaddr(address);\n  if(remoteProbeAddress) setRemoteProbeAddr(remoteProbeAddress);\n  if(remoteProbePublicAddress) setRemoteProbePublicAddr(remoteProbePublicAddress);\n  ifSpeed = speedMbit, last_pkt_rcvd_remote = remTime, last_remote_pps = last_pps, last_remote_bps = last_bps;\n\n  if((zmq_initial_pkts == 0) /* ntopng has been restarted */\n     || (remBytes < zmq_initial_bytes) /* nProbe has been restarted */\n     ) {\n    /* Start over */\n    zmq_initial_bytes = remBytes, zmq_initial_pkts = remPkts;\n  } else {\n    remBytes -= zmq_initial_bytes, remPkts -= zmq_initial_pkts;\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][bytes=%u/%u (%d)][pkts=%u/%u (%d)]\",\n\t\t\t\t ifname, remBytes, ethStats.getNumBytes(), remBytes-ethStats.getNumBytes(),\n\t\t\t\t remPkts, ethStats.getNumPackets(), remPkts-ethStats.getNumPackets());\n    /*\n     * Don't override ethStats here, these stats are properly updated\n     * inside NetworkInterface::processFlow for ZMQ interfaces.\n     * Overriding values here may cause glitches and non-strictly-increasing counters\n     * yielding negative rates.\n    ethStats.setNumBytes(remBytes), ethStats.setNumPackets(remPkts);\n     *\n    */\n  }\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::processInterfaceStats(sFlowInterfaceStats *stats) {\n  if(interfaceStats == NULL)\n    interfaceStats = new InterfaceStatsHash(NUM_IFACE_STATS_HASH);\n\n  if(interfaceStats) {\n    char a[64];\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][ifIndex=%u]\",\n\t\t\t\t Utils::intoaV4(stats->deviceIP, a, sizeof(a)),\n\t\t\t\t stats->ifIndex);\n\n    interfaceStats->set(stats->deviceIP, stats->ifIndex, stats);\n  }\n}\n\n/* **************************************** */\n\nndpi_protocol_category_t NetworkInterface::get_ndpi_proto_category(u_int protoid) {\n  ndpi_protocol proto;\n  proto.protocol = NDPI_PROTOCOL_UNKNOWN;\n  proto.master_protocol = protoid;\n  return get_ndpi_proto_category(proto);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_ndpi_category(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, ndpi_category_str(f->get_detected_protocol_category()));\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_ndpi_proto(lua_State* vm) {\n  Flow *f;\n  char buf[32];\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, f->get_detected_protocol_name(buf, sizeof(buf)));\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_ndpi_proto_id(lua_State* vm) {\n  Flow *f;\n  ndpi_protocol p;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR); else p = f->get_detected_protocol();\n\n  lua_pushnumber(vm, (p.protocol != NDPI_PROTOCOL_UNKNOWN) ? p.protocol : p.master_protocol);\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_first_seen(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushnumber(vm, f->get_first_seen());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_last_seen(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushnumber(vm, f->get_last_seen());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_server_name(lua_State* vm) {\n  Flow *f;\n  char buf[64];\n  const char *srv;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  srv = f->getFlowServerInfo();\n  if(!srv && f->get_srv_host())\n    srv = f->get_srv_host()->get_name(buf, sizeof(buf), false);\n  if(!srv) srv = \"\";\n\n  lua_pushstring(vm, srv);\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_http_url(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, f->getHTTPURL());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_get_http_content_type(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  lua_pushstring(vm, f->getHTTPContentType());\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\nstatic int lua_flow_dump(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  f->lua(vm, NULL, details_high, false);\n  return(CONST_LUA_OK);\n}\n\n/* **************************************** */\n\n/* -1 on error */\nstatic int lua_flow_get_profile_id(lua_State* vm) {\n  Flow *f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  UserActivityID uaid;\n  lua_pushnumber(vm, f->getActivityId(&uaid) ? uaid : -1);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/* -1 on error */\nstatic int lua_flow_get_activity_filter_id(lua_State* vm) {\n  Flow * f;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  ActivityFilterID fid;\n  lua_pushnumber(vm, f->getActivityFilterId(&fid) ? fid : -1);\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\n/*\n * lua params:\n *    activityID  - ID of the activity to apply for filtered bytes\n *    filterID    - ID of the filter to apply to the flow for activity recording\n *    *parametes  - parameters to pass to the filter - See below\n *\n * SMA/WMA filter params:\n *    edge         - moving average edge to trigger activity\n *    minsamples   - minimum number of samples for activity detection\n * WMA filter params:\n *    timescale    - division scale for each second difference from previous packet. 0 to disable\n *    aggrsecs     - max packet seconds difference to aggregate. 0 to disable\n * SMA filter params:\n *    timebound    - expected time tick in milliseconds between activity packets. 0 to disable\n *    sustain      - time, in milliseconds, between packets to be considered activity. 0 to disable\n *\n * CommandSequence filter params:\n *    mustwait     - if true, activity trigger requires server to wait after command request\n *    minbytes     - minimum number of bytes to trigger activity\n *    maxinterval  - maximum milliseconds difference between interactions\n *    mincommands  - minimum number of commands seen in the flow to trigger activity\n *    minflips     - minimum number of server interactions to trigger activity\n *\n * Web filter params:\n *    numsamples   - number of packets to process for detection\n *    minbytes     - minimum number of bytes to trigger activity\n *    maxinterval  - maximum milliseconds difference between packets\n *    serverdominant - if true, server bytes must be more then client bytes\n *    forceWebProfile - if true, force 'web' profile for unknown and 'other' flow profiles\n *\n * Ratio filter params:\n *    numsamples   - number of packets to process for detection\n *    minbytes     - minimum number of bytes to trigger activity\n *    clisrv_ratio - minimum (positive ? client/server : server/client) bytes to trigger activity\n *\n * Interflow filter params:\n *    minflows     - minimum number of concurrent flows. -1 to disable [1]\n *    minpkts      - minimum number of cumulative packets in concurrent flows to trigger activity\n *    minduration  - minimum (max duration of cumulative packets) in concurrent flows. -1 to disable [1]\n *    sslonly      - if true, only SSL traffic can trigger activity\n *   NOTE: At least one of [1] must be satisfied to trigger activity\n */\nstatic int lua_flow_set_activity_filter(lua_State* vm) {\n  UserActivityID activityID;\n  ActivityFilterID filterID;\n  Flow *f;\n  activity_filter_config config = {};\n  u_int8_t params = 0;\n\n  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);\n  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));\n  if(!f) return(CONST_LUA_ERROR);\n\n  if(ntop_lua_check(vm, __FUNCTION__, params+1, LUA_TNUMBER)) return(CONST_LUA_ERROR);\n  activityID = (UserActivityID)lua_tonumber(vm, ++params);\n  if(activityID >= UserActivitiesN) return(CONST_LUA_ERROR);\n\n  if(lua_type(vm, params+1) == LUA_TNUMBER)\n    filterID = (ActivityFilterID)lua_tonumber(vm, ++params);\n  else\n    return(CONST_LUA_ERROR);\n\n  // filter specific parameters\n  switch(filterID) {\n    case activity_filter_all:\n      if(lua_type(vm, params+1) == LUA_TBOOLEAN) {\n        config.all.pass = lua_toboolean(vm, ++params);\n      }\n      switch (params) {\n        case 2+0: config.all.pass = true;\n      }\n      break;\n\n    case activity_filter_web:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.web.numsamples = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.web.minbytes = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.web.maxinterval = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TBOOLEAN) {\n              config.web.forceWebProfile = lua_toboolean(vm, ++params);\n\n              if(lua_type(vm, params+1) == LUA_TBOOLEAN)\n                config.web.serverdominant = lua_toboolean(vm, ++params);\n            }\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.web.numsamples = 4;\n        case 2+1: config.web.minbytes = 0;\n        case 2+2: config.web.maxinterval = 2000;\n        case 2+3: config.web.forceWebProfile = true;\n        case 2+4: config.web.serverdominant = true;\n      }\n      break;\n\n    case activity_filter_ratio:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.ratio.numsamples = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.ratio.minbytes = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER)\n            config.ratio.clisrv_ratio = lua_tonumber(vm, ++params);\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.ratio.numsamples = 4;\n        case 2+1: config.ratio.minbytes = 0;\n        case 2+2: config.ratio.clisrv_ratio = -1.f;\n      }\n      break;\n\n    case activity_filter_interflow:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.interflow.minflows = min((int)lua_tonumber(vm, ++params), INTER_FLOW_ACTIVITY_SLOTS);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.interflow.minpkts = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.interflow.minduration = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TBOOLEAN)\n              config.interflow.sslonly = lua_toboolean(vm, ++params);\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.interflow.minflows = INTER_FLOW_ACTIVITY_SLOTS;\n        case 2+1: config.interflow.minpkts = 200;\n        case 2+2: config.interflow.minduration = -1;\n        case 2+3: config.interflow.sslonly = false;\n      }\n      break;\n\n    case activity_filter_metrics_test:\n      break;\n\n    case activity_filter_sma:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.sma.edge = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.sma.minsamples = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.sma.timebound = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TNUMBER)\n              config.sma.sustain = lua_tonumber(vm, ++params);\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.sma.edge = 0;\n        case 2+1: config.sma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;\n        case 2+2: config.sma.timebound = 2000;\n        case 2+3: config.sma.sustain = 1000;\n      }\n      break;\n\n    case activity_filter_wma:\n      if(lua_type(vm, params+1) == LUA_TNUMBER) {\n        config.wma.edge = lua_tonumber(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.wma.minsamples = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.wma.timescale = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TNUMBER)\n              config.wma.aggrsecs = lua_tonumber(vm, ++params);\n          }\n        }\n      }\n      // defaults\n      switch (params) {\n        case 2+0: config.wma.edge = 0;\n        case 2+1: config.wma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;\n        case 2+2: config.wma.timescale = 1.f;\n        case 2+3: config.wma.aggrsecs = 0;\n      }\n      break;\n\n    case activity_filter_command_sequence:\n      if(lua_type(vm, params+1) == LUA_TBOOLEAN) {\n        config.command_sequence.mustwait = lua_toboolean(vm, ++params);\n\n        if(lua_type(vm, params+1) == LUA_TNUMBER) {\n          config.command_sequence.minbytes = lua_tonumber(vm, ++params);\n\n          if(lua_type(vm, params+1) == LUA_TNUMBER) {\n            config.command_sequence.maxinterval = lua_tonumber(vm, ++params);\n\n            if(lua_type(vm, params+1) == LUA_TNUMBER) {\n              config.command_sequence.mincommands = lua_tonumber(vm, ++params);\n\n              if(lua_type(vm, params+1) == LUA_TNUMBER)\n                config.command_sequence.minflips = lua_tonumber(vm, ++params);\n            }\n          }\n        }\n      }\n      switch (params) {\n        case 2+0: config.command_sequence.mustwait = false;\n        case 2+1: config.command_sequence.minbytes = 0;\n        case 2+2: config.command_sequence.maxinterval = 3000;\n        case 2+3: config.command_sequence.mincommands = 1;\n        case 2+4: config.command_sequence.minflips = 1;\n      }\n      break;\n\n    default:\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid activity filter (%d)\", filterID);\n      return (CONST_LUA_ERROR);\n  }\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"Flow %p setActivityFilter: filter=%d activity=%d\", f, filterID, activityID);\n  f->setActivityFilter(filterID, &config);\n  f->setActivityId(activityID);\n\n  return(CONST_LUA_OK);\n}\n\n/* ****************************************** */\n\nstatic const luaL_Reg flow_reg[] = {\n  { \"getNdpiCategory\",   lua_flow_get_ndpi_category },\n  { \"getNdpiProto\",      lua_flow_get_ndpi_proto },\n  { \"getNdpiProtoId\",    lua_flow_get_ndpi_proto_id },\n  { \"getFirstSeen\",      lua_flow_get_first_seen },\n  { \"getLastSeen\",       lua_flow_get_last_seen },\n  { \"getServerName\",     lua_flow_get_server_name },\n  { \"getHTTPUrl\",        lua_flow_get_http_url },\n  { \"getHTTPContentType\",lua_flow_get_http_content_type },\n  { \"dump\",              lua_flow_dump },\n  { \"setActivityFilter\", lua_flow_set_activity_filter },\n  { \"getProfileId\",      lua_flow_get_profile_id },\n  { \"getActivityFilterId\", lua_flow_get_activity_filter_id },\n  { NULL,         NULL }\n};\n\nntop_class_reg ntop_lua_reg[] = {\n  { \"flow\",   flow_reg  },\n  {NULL,      NULL}\n};\n\nlua_State* NetworkInterface::initLuaInterpreter(const char *lua_file) {\n  static const luaL_Reg _meta[] = { { NULL, NULL } };\n  int i;\n  char script_path[256];\n  lua_State *L;\n\n  L = luaL_newstate();\n\n  if(!L) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to initialize lua interpreter\");\n    return(NULL);\n  }\n\n  snprintf(script_path, sizeof(script_path), \"%s/%s\",\n\t   ntop->getPrefs()->get_callbacks_dir(),\n\t   lua_file);\n\n  /* ******************************************** */\n\n  luaL_openlibs(L); /* Load base libraries */\n\n  for(i=0; ntop_lua_reg[i].class_name != NULL; i++) {\n    int lib_id, meta_id;\n\n    /* newclass = {} */\n    lua_createtable(L, 0, 0);\n    lib_id = lua_gettop(L);\n\n    /* metatable = {} */\n    luaL_newmetatable(L, ntop_lua_reg[i].class_name);\n    meta_id = lua_gettop(L);\n    luaL_register(L, NULL, _meta);\n\n    /* metatable.__index = class_methods */\n    lua_newtable(L), luaL_register(L, NULL, ntop_lua_reg[i].class_methods);\n    lua_setfield(L, meta_id, \"__index\");\n\n    /* class.__metatable = metatable */\n    lua_setmetatable(L, lib_id);\n\n    /* _G[\"Foo\"] = newclass */\n    lua_setglobal(L, ntop_lua_reg[i].class_name);\n  }\n\n  lua_register(L, \"print\", ntop_lua_cli_print);\n\n  // Activity profiles - see ntop_typedefs.h\n  lua_newtable(L);\n  for(int i=0; i<UserActivitiesN; i++)\n    lua_push_int_table_entry(L, activity_names[i], i);\n  lua_setglobal(L, CONST_USERACTIVITY_PROFILES);\n\n  // Activity filters\n  lua_newtable(L);\n  lua_push_int_table_entry(L, \"All\", activity_filter_all);\n  lua_push_int_table_entry(L, \"SMA\", activity_filter_sma);\n  lua_push_int_table_entry(L, \"WMA\", activity_filter_wma);\n  lua_push_int_table_entry(L, \"CommandSequence\", activity_filter_command_sequence);\n  lua_push_int_table_entry(L, \"Web\", activity_filter_web);\n  lua_push_int_table_entry(L, \"Ratio\", activity_filter_ratio);\n  lua_push_int_table_entry(L, \"Interflow\", activity_filter_interflow);\n  lua_push_int_table_entry(L, \"Metrics\", activity_filter_metrics_test);\n  lua_setglobal(L, CONST_USERACTIVITY_FILTERS);\n\n  if(luaL_loadfile(L, script_path) || lua_pcall(L, 0, 0, 0)) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Cannot run lua file %s: %s\",\n\t\t\t\t script_path, lua_tostring(L, -1));\n    lua_close(L);\n    L = NULL;\n  } else {\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Successfully interpreted %s\", script_path);\n\n    lua_pushlightuserdata(L, NULL);\n    lua_setglobal(L, CONST_USERACTIVITY_FLOW);\n  }\n\n  return(L);\n}\n\n/* **************************************** */\n\nvoid NetworkInterface::termLuaInterpreter() {\n  if(L_flow_create_delete_ndpi) { lua_close(L_flow_create_delete_ndpi); L_flow_create_delete_ndpi = NULL; }\n  if(L_flow_update) { lua_close(L_flow_update); L_flow_update = NULL; }\n}\n\n/* **************************************** */\n\nint NetworkInterface::luaEvalFlow(Flow *f, const LuaCallback cb) {\n  int rc;\n  lua_State *L;\n  const char *luaFunction;\n\n  return(0); // FIX\n  if(reloadLuaInterpreter) {\n    if(L_flow_create_delete_ndpi || L_flow_update) termLuaInterpreter();\n    L_flow_create_delete_ndpi = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);\n    L_flow_update = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);\n    reloadLuaInterpreter = false;\n  }\n\n  switch(cb) {\n  case callback_flow_create:\n    L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_CREATE;\n    break;\n\n  case callback_flow_delete:\n    L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_DELETE;\n    break;\n\n  case callback_flow_update:\n    L = L_flow_update, luaFunction = CONST_LUA_FLOW_UPDATE;\n    break;\n\n  case callback_flow_proto_callback:\n    L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_NDPI_DETECT;\n    break;\n\n  default:\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid lua callback (%d)\", cb);\n    return(-1);\n  }\n\n  if(L == NULL)\n    return(-2);\n\n  lua_settop(L, 0); /* Reset stack */\n  lua_pushlightuserdata(L, f);\n  lua_setglobal(L, CONST_USERACTIVITY_FLOW);\n\n  lua_getglobal(L, luaFunction); /* function to be called */\n  if((rc = lua_pcall(L, 0 /* 0 parameters */, 0 /* no return values */, 0)) != 0) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Error while executing %s [rc=%d][%s]\", luaFunction, rc, lua_tostring(L, -1));\n  }\n\n  return(rc);\n}\n\n/* **************************************** */\n\nint NetworkInterface::getActiveMacList(lua_State* vm, u_int16_t vlan_id,\n\t\t\t\t       bool skipSpecialMacs,\n\t\t\t\t       bool hostMacsOnly,\n\t\t\t\t       char *sortColumn, u_int32_t maxHits,\n\t\t\t\t       u_int32_t toSkip, bool a2zSortOrder) {\n  struct flowHostRetriever retriever;\n  bool show_details = true;\n\n  disablePurge(false);\n\n  if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, sortColumn) < 0) {\n    enablePurge(false);\n    return -1;\n  }\n\n  lua_newtable(vm);\n  lua_push_int_table_entry(vm, \"numMacs\", retriever.actNumEntries);\n\n  lua_newtable(vm);\n\n  if(a2zSortOrder) {\n    for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {\n      Mac *m = retriever.elems[i].macValue;\n\n      m->lua(vm, show_details, false);\n      lua_rawseti(vm, -2, num + 1); /* Must use integer keys to preserve and iterate inorder with ipairs */\n    }\n  } else {\n    for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {\n      Mac *m = retriever.elems[i].macValue;\n\n      m->lua(vm, show_details, false);\n      lua_rawseti(vm, -2, num + 1);\n    }\n  }\n\n  lua_pushstring(vm, \"macs\");\n  lua_insert(vm, -2);\n  lua_settable(vm, -3);\n\n  enablePurge(false);\n\n  // finally free the elements regardless of the sorted kind\n  if(retriever.elems) free(retriever.elems);\n\n  return(retriever.actNumEntries);\n}\n\n/* **************************************** */\n\nbool NetworkInterface::getMacInfo(lua_State* vm, char *mac, u_int16_t vlan_id) {\n  struct mac_find_info info;\n\n  memset(&info, 0, sizeof(info));\n  Utils::parseMac(info.mac, mac), info.vlan_id = vlan_id;\n\n  walker(walker_macs, find_mac_by_name, (void*)&info);\n\n  if(info.m) {\n    info.m->lua(vm, true, false);\n\n    return(true);\n  } else\n    return(false);\n}\n\n\n"], "filenames": ["src/Lua.cpp", "src/NetworkInterface.cpp"], "buggy_code_start_loc": [6021, 2201], "buggy_code_end_loc": [6022, 2201], "fixing_code_start_loc": [6021, 2202], "fixing_code_end_loc": [6023, 2204], "type": "CWE-476", "message": "The NetworkInterface::getHost function in NetworkInterface.cpp in ntopng before 3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty field that should have contained a hostname or IP address.", "other": {"cve": {"id": "CVE-2017-7458", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-26T23:29:00.190", "lastModified": "2017-06-29T15:31:14.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The NetworkInterface::getHost function in NetworkInterface.cpp in ntopng before 3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty field that should have contained a hostname or IP address."}, {"lang": "es", "value": "La funci\u00f3n NetworkInterface::getHost en NetworkInterface.cpp en ntopng en versiones anteriores a la 3.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL y cierre inesperado de la aplicaci\u00f3n) mediante un campo vac\u00edo que deber\u00eda haber contenido un nombre de host o una direcci\u00f3n IP."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ntopng:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4", "matchCriteriaId": "553EDC87-EF7A-4FD1-9CA0-447B22340CC7"}]}]}], "references": [{"url": "https://github.com/ntop/ntopng/blob/3.0/CHANGELOG.md", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ntop/ntopng/commit/01f47e04fd7c8d54399c9e465f823f0017069f8f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/ntopng/commit/01f47e04fd7c8d54399c9e465f823f0017069f8f"}}