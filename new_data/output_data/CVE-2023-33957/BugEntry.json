{"buggy_code": ["package main\n\nimport (\n\t\"crypto/sha256\"\n\tb64 \"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/notaryproject/notation-core-go/signature\"\n\t\"github.com/notaryproject/notation-go/plugin/proto\"\n\t\"github.com/notaryproject/notation-go/registry\"\n\t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n\t\"github.com/notaryproject/notation/internal/cmd\"\n\t\"github.com/notaryproject/notation/internal/envelope\"\n\t\"github.com/notaryproject/notation/internal/ioutil\"\n\t\"github.com/notaryproject/notation/internal/tree\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype inspectOpts struct {\n\tcmd.LoggingFlagOpts\n\tSecureFlagOpts\n\treference         string\n\toutputFormat      string\n\tallowReferrersAPI bool\n}\n\ntype inspectOutput struct {\n\tMediaType  string `json:\"mediaType\"`\n\tSignatures []signatureOutput\n}\n\ntype signatureOutput struct {\n\tMediaType             string              `json:\"mediaType\"`\n\tDigest                string              `json:\"digest\"`\n\tSignatureAlgorithm    string              `json:\"signatureAlgorithm\"`\n\tSignedAttributes      map[string]string   `json:\"signedAttributes\"`\n\tUserDefinedAttributes map[string]string   `json:\"userDefinedAttributes\"`\n\tUnsignedAttributes    map[string]string   `json:\"unsignedAttributes\"`\n\tCertificates          []certificateOutput `json:\"certificates\"`\n\tSignedArtifact        ocispec.Descriptor  `json:\"signedArtifact\"`\n}\n\ntype certificateOutput struct {\n\tSHA256Fingerprint string `json:\"SHA256Fingerprint\"`\n\tIssuedTo          string `json:\"issuedTo\"`\n\tIssuedBy          string `json:\"issuedBy\"`\n\tExpiry            string `json:\"expiry\"`\n}\n\nfunc inspectCommand(opts *inspectOpts) *cobra.Command {\n\tif opts == nil {\n\t\topts = &inspectOpts{}\n\t}\n\tlongMessage := `Inspect all signatures associated with the signed artifact.\n\nExample - Inspect signatures on an OCI artifact identified by a digest:\n  notation inspect <registry>/<repository>@<digest>\n\nExample - Inspect signatures on an OCI artifact identified by a tag  (Notation will resolve tag to digest):\n  notation inspect <registry>/<repository>:<tag>\n\nExample - Inspect signatures on an OCI artifact identified by a digest and output as json:\n  notation inspect --output json <registry>/<repository>@<digest>\n`\n\texperimentalExamples := `\nExample - [Experimental] Inspect signatures on an OCI artifact identified by a digest using the Referrers API, if not supported (returns 404), fallback to the Referrers tag schema\n  notation inspect --allow-referrers-api <registry>/<repository>@<digest>\n`\n\tcommand := &cobra.Command{\n\t\tUse:   \"inspect [reference]\",\n\t\tShort: \"Inspect all signatures associated with the signed artifact\",\n\t\tLong:  longMessage,\n\t\tArgs: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"missing reference\")\n\t\t\t}\n\t\t\topts.reference = args[0]\n\t\t\treturn nil\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\")\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn runInspect(cmd, opts)\n\t\t},\n\t}\n\n\topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n\topts.SecureFlagOpts.ApplyFlags(command.Flags())\n\tcmd.SetPflagOutput(command.Flags(), &opts.outputFormat, cmd.PflagOutputUsage)\n\tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"inspect\"))\n\texperimental.HideFlags(command, experimentalExamples, []string{\"allow-referrers-api\"})\n\treturn command\n}\n\nfunc runInspect(command *cobra.Command, opts *inspectOpts) error {\n\t// set log level\n\tctx := opts.LoggingFlagOpts.SetLoggerLevel(command.Context())\n\n\tif opts.outputFormat != cmd.OutputJSON && opts.outputFormat != cmd.OutputPlaintext {\n\t\treturn fmt.Errorf(\"unrecognized output format %s\", opts.outputFormat)\n\t}\n\n\t// initialize\n\treference := opts.reference\n\tsigRepo, err := getRemoteRepository(ctx, &opts.SecureFlagOpts, reference, opts.allowReferrersAPI)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmanifestDesc, resolvedRef, err := resolveReferenceWithWarning(ctx, inputTypeRegistry, reference, sigRepo, \"inspect\")\n\tif err != nil {\n\t\treturn err\n\t}\n\toutput := inspectOutput{MediaType: manifestDesc.MediaType, Signatures: []signatureOutput{}}\n\tskippedSignatures := false\n\terr = sigRepo.ListSignatures(ctx, manifestDesc, func(signatureManifests []ocispec.Descriptor) error {\n\t\tfor _, sigManifestDesc := range signatureManifests {\n\t\t\tsigBlob, sigDesc, err := sigRepo.FetchSignatureBlob(ctx, sigManifestDesc)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Warning: unable to fetch signature %s due to error: %v\\n\", sigManifestDesc.Digest.String(), err)\n\t\t\t\tskippedSignatures = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsigEnvelope, err := signature.ParseEnvelope(sigDesc.MediaType, sigBlob)\n\t\t\tif err != nil {\n\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\t\tskippedSignatures = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tenvelopeContent, err := sigEnvelope.Content()\n\t\t\tif err != nil {\n\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\t\tskippedSignatures = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsignedArtifactDesc, err := envelope.DescriptorFromSignaturePayload(&envelopeContent.Payload)\n\t\t\tif err != nil {\n\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\t\tskippedSignatures = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsignatureAlgorithm, err := proto.EncodeSigningAlgorithm(envelopeContent.SignerInfo.SignatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\t\tskippedSignatures = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsig := signatureOutput{\n\t\t\t\tMediaType:             sigDesc.MediaType,\n\t\t\t\tDigest:                sigManifestDesc.Digest.String(),\n\t\t\t\tSignatureAlgorithm:    string(signatureAlgorithm),\n\t\t\t\tSignedAttributes:      getSignedAttributes(opts.outputFormat, envelopeContent),\n\t\t\t\tUserDefinedAttributes: signedArtifactDesc.Annotations,\n\t\t\t\tUnsignedAttributes:    getUnsignedAttributes(envelopeContent),\n\t\t\t\tCertificates:          getCertificates(opts.outputFormat, envelopeContent),\n\t\t\t\tSignedArtifact:        *signedArtifactDesc,\n\t\t\t}\n\n\t\t\t// clearing annotations from the SignedArtifact field since they're already\n\t\t\t// displayed as UserDefinedAttributes\n\t\t\tsig.SignedArtifact.Annotations = nil\n\n\t\t\toutput.Signatures = append(output.Signatures, sig)\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = printOutput(opts.outputFormat, resolvedRef, output)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif skippedSignatures {\n\t\treturn errors.New(\"at least one signature was skipped and not displayed\")\n\t}\n\n\treturn nil\n}\n\nfunc logSkippedSignature(sigDesc ocispec.Descriptor, err error) {\n\tfmt.Fprintf(os.Stderr, \"Warning: Skipping signature %s because of error: %v\\n\", sigDesc.Digest.String(), err)\n}\n\nfunc getSignedAttributes(outputFormat string, envContent *signature.EnvelopeContent) map[string]string {\n\tsignedAttributes := map[string]string{\n\t\t\"signingScheme\": string(envContent.SignerInfo.SignedAttributes.SigningScheme),\n\t\t\"signingTime\":   formatTimestamp(outputFormat, envContent.SignerInfo.SignedAttributes.SigningTime),\n\t}\n\texpiry := envContent.SignerInfo.SignedAttributes.Expiry\n\tif !expiry.IsZero() {\n\t\tsignedAttributes[\"expiry\"] = formatTimestamp(outputFormat, expiry)\n\t}\n\n\tfor _, attribute := range envContent.SignerInfo.SignedAttributes.ExtendedAttributes {\n\t\tsignedAttributes[fmt.Sprint(attribute.Key)] = fmt.Sprint(attribute.Value)\n\t}\n\n\treturn signedAttributes\n}\n\nfunc getUnsignedAttributes(envContent *signature.EnvelopeContent) map[string]string {\n\tunsignedAttributes := map[string]string{}\n\n\tif envContent.SignerInfo.UnsignedAttributes.TimestampSignature != nil {\n\t\tunsignedAttributes[\"timestampSignature\"] = b64.StdEncoding.EncodeToString(envContent.SignerInfo.UnsignedAttributes.TimestampSignature)\n\t}\n\n\tif envContent.SignerInfo.UnsignedAttributes.SigningAgent != \"\" {\n\t\tunsignedAttributes[\"signingAgent\"] = envContent.SignerInfo.UnsignedAttributes.SigningAgent\n\t}\n\n\treturn unsignedAttributes\n}\n\nfunc formatTimestamp(outputFormat string, t time.Time) string {\n\tswitch outputFormat {\n\tcase cmd.OutputJSON:\n\t\treturn t.Format(time.RFC3339)\n\tdefault:\n\t\treturn t.Format(time.ANSIC)\n\t}\n}\n\nfunc getCertificates(outputFormat string, envContent *signature.EnvelopeContent) []certificateOutput {\n\tcertificates := []certificateOutput{}\n\n\tfor _, cert := range envContent.SignerInfo.CertificateChain {\n\t\th := sha256.Sum256(cert.Raw)\n\t\tfingerprint := strings.ToLower(hex.EncodeToString(h[:]))\n\n\t\tcertificate := certificateOutput{\n\t\t\tSHA256Fingerprint: fingerprint,\n\t\t\tIssuedTo:          cert.Subject.String(),\n\t\t\tIssuedBy:          cert.Issuer.String(),\n\t\t\tExpiry:            formatTimestamp(outputFormat, cert.NotAfter),\n\t\t}\n\n\t\tcertificates = append(certificates, certificate)\n\t}\n\n\treturn certificates\n}\n\nfunc printOutput(outputFormat string, ref string, output inspectOutput) error {\n\tif outputFormat == cmd.OutputJSON {\n\t\treturn ioutil.PrintObjectAsJSON(output)\n\t}\n\n\tif len(output.Signatures) == 0 {\n\t\tfmt.Printf(\"%s has no associated signature\\n\", ref)\n\t\treturn nil\n\t}\n\n\tfmt.Println(\"Inspecting all signatures for signed artifact\")\n\troot := tree.New(ref)\n\tcncfSigNode := root.Add(registry.ArtifactTypeNotation)\n\n\tfor _, signature := range output.Signatures {\n\t\tsigNode := cncfSigNode.Add(signature.Digest)\n\t\tsigNode.AddPair(\"media type\", signature.MediaType)\n\t\tsigNode.AddPair(\"signature algorithm\", signature.SignatureAlgorithm)\n\n\t\tsignedAttributesNode := sigNode.Add(\"signed attributes\")\n\t\taddMapToTree(signedAttributesNode, signature.SignedAttributes)\n\n\t\tuserDefinedAttributesNode := sigNode.Add(\"user defined attributes\")\n\t\taddMapToTree(userDefinedAttributesNode, signature.UserDefinedAttributes)\n\n\t\tunsignedAttributesNode := sigNode.Add(\"unsigned attributes\")\n\t\taddMapToTree(unsignedAttributesNode, signature.UnsignedAttributes)\n\n\t\tcertListNode := sigNode.Add(\"certificates\")\n\t\tfor _, cert := range signature.Certificates {\n\t\t\tcertNode := certListNode.AddPair(\"SHA256 fingerprint\", cert.SHA256Fingerprint)\n\t\t\tcertNode.AddPair(\"issued to\", cert.IssuedTo)\n\t\t\tcertNode.AddPair(\"issued by\", cert.IssuedBy)\n\t\t\tcertNode.AddPair(\"expiry\", cert.Expiry)\n\t\t}\n\n\t\tartifactNode := sigNode.Add(\"signed artifact\")\n\t\tartifactNode.AddPair(\"media type\", signature.SignedArtifact.MediaType)\n\t\tartifactNode.AddPair(\"digest\", signature.SignedArtifact.Digest.String())\n\t\tartifactNode.AddPair(\"size\", strconv.FormatInt(signature.SignedArtifact.Size, 10))\n\t}\n\n\troot.Print()\n\treturn nil\n}\n\nfunc addMapToTree(node *tree.Node, m map[string]string) {\n\tif len(m) > 0 {\n\t\tfor k, v := range m {\n\t\t\tnode.AddPair(k, v)\n\t\t}\n\t} else {\n\t\tnode.Add(\"(empty)\")\n\t}\n}\n", "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/notaryproject/notation/internal/cmd\"\n)\n\nfunc TestInspectCommand_SecretsFromArgs(t *testing.T) {\n\topts := &inspectOpts{}\n\tcommand := inspectCommand(opts)\n\texpected := &inspectOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword:         \"password\",\n\t\t\tInsecureRegistry: true,\n\t\t\tUsername:         \"user\",\n\t\t},\n\t\toutputFormat: cmd.OutputPlaintext,\n\t}\n\tif err := command.ParseFlags([]string{\n\t\t\"--password\", expected.Password,\n\t\texpected.reference,\n\t\t\"-u\", expected.Username,\n\t\t\"--insecure-registry\",\n\t\t\"--output\", \"text\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect inspect opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestInspectCommand_SecretsFromEnv(t *testing.T) {\n\tt.Setenv(defaultUsernameEnv, \"user\")\n\tt.Setenv(defaultPasswordEnv, \"password\")\n\topts := &inspectOpts{}\n\texpected := &inspectOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword: \"password\",\n\t\t\tUsername: \"user\",\n\t\t},\n\t\toutputFormat: cmd.OutputJSON,\n\t}\n\tcommand := inspectCommand(opts)\n\tif err := command.ParseFlags([]string{\n\t\texpected.reference,\n\t\t\"--output\", \"json\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect inspect opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestInspectCommand_MissingArgs(t *testing.T) {\n\tcommand := inspectCommand(nil)\n\tif err := command.ParseFlags(nil); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err == nil {\n\t\tt.Fatal(\"Parse Args expected error, but ok\")\n\t}\n}\n", "package errors\n\n// ErrorReferrersAPINotSupported is used when the target registry does not\n// support the Referrers API\ntype ErrorReferrersAPINotSupported struct {\n\tMsg string\n}\n\nfunc (e ErrorReferrersAPINotSupported) Error() string {\n\tif e.Msg != \"\" {\n\t\treturn e.Msg\n\t}\n\treturn \"referrers API not supported\"\n}\n\n// ErrorOCILayoutMissingReference is used when signing local content in oci\n// layout folder but missing input tag or digest.\ntype ErrorOCILayoutMissingReference struct {\n\tMsg string\n}\n\nfunc (e ErrorOCILayoutMissingReference) Error() string {\n\tif e.Msg != \"\" {\n\t\treturn e.Msg\n\t}\n\treturn \"reference is missing either digest or tag\"\n}\n", "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\tnotationregistry \"github.com/notaryproject/notation-go/registry\"\n\t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n\t\"github.com/notaryproject/notation/internal/cmd\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype listOpts struct {\n\tcmd.LoggingFlagOpts\n\tSecureFlagOpts\n\treference         string\n\tallowReferrersAPI bool\n\tociLayout         bool\n\tinputType         inputType\n}\n\nfunc listCommand(opts *listOpts) *cobra.Command {\n\tif opts == nil {\n\t\topts = &listOpts{\n\t\t\tinputType: inputTypeRegistry, // remote registry by default\n\t\t}\n\t}\n\tcommand := &cobra.Command{\n\t\tUse:     \"list [flags] <reference>\",\n\t\tAliases: []string{\"ls\"},\n\t\tShort:   \"List signatures of the signed artifact\",\n\t\tLong:    \"List all the signatures associated with signed artifact\",\n\t\tArgs: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"no reference specified\")\n\t\t\t}\n\t\t\topts.reference = args[0]\n\t\t\treturn nil\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.ociLayout {\n\t\t\t\topts.inputType = inputTypeOCILayout\n\t\t\t}\n\t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\", \"oci-layout\")\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn runList(cmd.Context(), opts)\n\t\t},\n\t}\n\topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n\topts.SecureFlagOpts.ApplyFlags(command.Flags())\n\tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"list\"))\n\tcommand.Flags().BoolVar(&opts.ociLayout, \"oci-layout\", false, \"[Experimental] list signatures stored in OCI image layout\")\n\texperimental.HideFlags(command, \"\", []string{\"allow-referrers-api\", \"oci-layout\"})\n\treturn command\n}\n\nfunc runList(ctx context.Context, opts *listOpts) error {\n\t// set log level\n\tctx = opts.LoggingFlagOpts.SetLoggerLevel(ctx)\n\n\t// initialize\n\treference := opts.reference\n\tsigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttargetDesc, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, \"list\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t// print all signature manifest digests\n\treturn printSignatureManifestDigests(ctx, targetDesc, sigRepo, resolvedRef)\n}\n\n// printSignatureManifestDigests returns the signature manifest digests of\n// the subject manifest.\nfunc printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descriptor, sigRepo notationregistry.Repository, ref string) error {\n\ttitlePrinted := false\n\tprintTitle := func() {\n\t\tif !titlePrinted {\n\t\t\tfmt.Println(ref)\n\t\t\tfmt.Printf(\"\u2514\u2500\u2500 %s\\n\", notationregistry.ArtifactTypeNotation)\n\t\t\ttitlePrinted = true\n\t\t}\n\t}\n\n\tvar prevDigest digest.Digest\n\terr := sigRepo.ListSignatures(ctx, targetDesc, func(signatureManifests []ocispec.Descriptor) error {\n\t\tfor _, sigManifestDesc := range signatureManifests {\n\t\t\tif prevDigest != \"\" {\n\t\t\t\t// check and print title\n\t\t\t\tprintTitle()\n\n\t\t\t\t// print each signature digest\n\t\t\t\tfmt.Printf(\"    \u251c\u2500\u2500 %s\\n\", prevDigest)\n\t\t\t}\n\t\t\tprevDigest = sigManifestDesc.Digest\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif prevDigest != \"\" {\n\t\t// check and print title\n\t\tprintTitle()\n\n\t\t// print last signature digest\n\t\tfmt.Printf(\"    \u2514\u2500\u2500 %s\\n\", prevDigest)\n\t}\n\n\tif !titlePrinted {\n\t\tfmt.Printf(\"%s has no associated signature\\n\", ref)\n\t}\n\treturn nil\n}\n", "package main\n\nimport (\n\t\"testing\"\n)\n\nfunc TestListCommand_SecretsFromArgs(t *testing.T) {\n\topts := &listOpts{}\n\tcmd := listCommand(opts)\n\texpected := &listOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword:         \"password\",\n\t\t\tInsecureRegistry: true,\n\t\t\tUsername:         \"user\",\n\t\t},\n\t}\n\tif err := cmd.ParseFlags([]string{\n\t\t\"--password\", expected.Password,\n\t\texpected.reference,\n\t\t\"-u\", expected.Username,\n\t\t\"--insecure-registry\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect list opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestListCommand_SecretsFromEnv(t *testing.T) {\n\tt.Setenv(defaultUsernameEnv, \"user\")\n\tt.Setenv(defaultPasswordEnv, \"password\")\n\topts := &listOpts{}\n\texpected := &listOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword: \"password\",\n\t\t\tUsername: \"user\",\n\t\t},\n\t}\n\tcmd := listCommand(opts)\n\tif err := cmd.ParseFlags([]string{\n\t\texpected.reference}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect list opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestListCommand_MissingArgs(t *testing.T) {\n\tcmd := listCommand(nil)\n\tif err := cmd.ParseFlags(nil); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {\n\t\tt.Fatal(\"Parse Args expected error, but ok\")\n\t}\n}\n", "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"reflect\"\n\n\t\"github.com/notaryproject/notation-go\"\n\t\"github.com/notaryproject/notation-go/verifier\"\n\t\"github.com/notaryproject/notation-go/verifier/trustpolicy\"\n\t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n\t\"github.com/notaryproject/notation/internal/cmd\"\n\t\"github.com/notaryproject/notation/internal/ioutil\"\n\t\"github.com/spf13/cobra\"\n)\n\nconst maxSignatureAttempts = math.MaxInt64\n\ntype verifyOpts struct {\n\tcmd.LoggingFlagOpts\n\tSecureFlagOpts\n\treference         string\n\tpluginConfig      []string\n\tuserMetadata      []string\n\tallowReferrersAPI bool\n\tociLayout         bool\n\ttrustPolicyScope  string\n\tinputType         inputType\n}\n\nfunc verifyCommand(opts *verifyOpts) *cobra.Command {\n\tif opts == nil {\n\t\topts = &verifyOpts{\n\t\t\tinputType: inputTypeRegistry, // remote registry by default\n\t\t}\n\t}\n\tlongMessage := `Verify OCI artifacts\n\nPrerequisite: added a certificate into trust store and created a trust policy.\n\nExample - Verify a signature on an OCI artifact identified by a digest:\n  notation verify <registry>/<repository>@<digest>\n\nExample - Verify a signature on an OCI artifact identified by a tag  (Notation will resolve tag to digest):\n  notation verify <registry>/<repository>:<tag>\n`\n\texperimentalExamples := `\nExample - [Experimental] Verify an OCI artifact using the Referrers API, if not supported (returns 404), fallback to the Referrers tag schema\n  notation verify --allow-referrers-api <registry>/<repository>@<digest>\n\nExample - [Experimental] Verify a signature on an OCI artifact referenced in an OCI layout using trust policy statement specified by scope.\n  notation verify --oci-layout <registry>/<repository>@<digest> --scope <trust_policy_scope>\n\nExample - [Experimental] Verify a signature on an OCI artifact identified by a tag and referenced in an OCI layout using trust policy statement specified by scope.\n  notation verify --oci-layout <registry>/<repository>:<tag> --scope <trust_policy_scope>\n`\n\tcommand := &cobra.Command{\n\t\tUse:   \"verify [reference]\",\n\t\tShort: \"Verify OCI artifacts\",\n\t\tLong:  longMessage,\n\t\tArgs: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"missing reference\")\n\t\t\t}\n\t\t\topts.reference = args[0]\n\t\t\treturn nil\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.ociLayout {\n\t\t\t\topts.inputType = inputTypeOCILayout\n\t\t\t}\n\t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\", \"oci-layout\", \"scope\")\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn runVerify(cmd, opts)\n\t\t},\n\t}\n\topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n\topts.SecureFlagOpts.ApplyFlags(command.Flags())\n\tcommand.Flags().StringArrayVar(&opts.pluginConfig, \"plugin-config\", nil, \"{key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values\")\n\tcmd.SetPflagUserMetadata(command.Flags(), &opts.userMetadata, cmd.PflagUserMetadataVerifyUsage)\n\tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"verify\"))\n\tcommand.Flags().BoolVar(&opts.ociLayout, \"oci-layout\", false, \"[Experimental] verify the artifact stored as OCI image layout\")\n\tcommand.Flags().StringVar(&opts.trustPolicyScope, \"scope\", \"\", \"[Experimental] set trust policy scope for artifact verification, required and can only be used when flag \\\"--oci-layout\\\" is set\")\n\tcommand.MarkFlagsRequiredTogether(\"oci-layout\", \"scope\")\n\texperimental.HideFlags(command, experimentalExamples, []string{\"allow-referrers-api\", \"oci-layout\", \"scope\"})\n\treturn command\n}\n\nfunc runVerify(command *cobra.Command, opts *verifyOpts) error {\n\t// set log level\n\tctx := opts.LoggingFlagOpts.SetLoggerLevel(command.Context())\n\n\t// initialize\n\tsigVerifier, err := verifier.NewFromConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set up verification plugin config.\n\tconfigs, err := cmd.ParseFlagMap(opts.pluginConfig, cmd.PflagPluginConfig.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set up user metadata\n\tuserMetadata, err := cmd.ParseFlagMap(opts.userMetadata, cmd.PflagUserMetadata.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// core verify process\n\treference := opts.reference\n\tsigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// resolve the given reference and set the digest\n\t_, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, \"verify\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tintendedRef := resolveArtifactDigestReference(resolvedRef, opts.trustPolicyScope)\n\tverifyOpts := notation.VerifyOptions{\n\t\tArtifactReference: intendedRef,\n\t\tPluginConfig:      configs,\n\t\t// TODO: need to change MaxSignatureAttempts as a user input flag or\n\t\t// a field in config.json\n\t\tMaxSignatureAttempts: maxSignatureAttempts,\n\t\tUserMetadata:         userMetadata,\n\t}\n\t_, outcomes, err := notation.Verify(ctx, sigVerifier, sigRepo, verifyOpts)\n\terr = checkVerificationFailure(outcomes, resolvedRef, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treportVerificationSuccess(outcomes, resolvedRef)\n\treturn nil\n}\n\nfunc checkVerificationFailure(outcomes []*notation.VerificationOutcome, printOut string, err error) error {\n\t// write out on failure\n\tif err != nil || len(outcomes) == 0 {\n\t\tif err != nil {\n\t\t\tvar errorVerificationFailed notation.ErrorVerificationFailed\n\t\t\tif !errors.As(err, &errorVerificationFailed) {\n\t\t\t\treturn fmt.Errorf(\"signature verification failed: %w\", err)\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"signature verification failed for all the signatures associated with %s\", printOut)\n\t}\n\treturn nil\n}\n\nfunc reportVerificationSuccess(outcomes []*notation.VerificationOutcome, printout string) {\n\t// write out on success\n\toutcome := outcomes[0]\n\t// print out warning for any failed result with logged verification action\n\tfor _, result := range outcome.VerificationResults {\n\t\tif result.Error != nil {\n\t\t\t// at this point, the verification action has to be logged and\n\t\t\t// it's failed\n\t\t\tfmt.Fprintf(os.Stderr, \"Warning: %v was set to %q and failed with error: %v\\n\", result.Type, result.Action, result.Error)\n\t\t}\n\t}\n\tif reflect.DeepEqual(outcome.VerificationLevel, trustpolicy.LevelSkip) {\n\t\tfmt.Println(\"Trust policy is configured to skip signature verification for\", printout)\n\t} else {\n\t\tfmt.Println(\"Successfully verified signature for\", printout)\n\t\tprintMetadataIfPresent(outcome)\n\t}\n}\n\nfunc printMetadataIfPresent(outcome *notation.VerificationOutcome) {\n\t// the signature envelope is parsed as part of verification.\n\t// since user metadata is only printed on successful verification,\n\t// this error can be ignored\n\tmetadata, _ := outcome.UserMetadata()\n\n\tif len(metadata) > 0 {\n\t\tfmt.Println(\"\\nThe artifact was signed with the following user metadata.\")\n\t\tioutil.PrintMetadataMap(os.Stdout, metadata)\n\t}\n}\n", "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestVerifyCommand_BasicArgs(t *testing.T) {\n\topts := &verifyOpts{}\n\tcommand := verifyCommand(opts)\n\texpected := &verifyOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tUsername: \"user\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t\tpluginConfig: []string{\"key1=val1\"},\n\t}\n\tif err := command.ParseFlags([]string{\n\t\texpected.reference,\n\t\t\"--username\", expected.Username,\n\t\t\"--password\", expected.Password,\n\t\t\"--plugin-config\", \"key1=val1\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse args failed: %v\", err)\n\t}\n\tif !reflect.DeepEqual(*expected, *opts) {\n\t\tt.Fatalf(\"Expect verify opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestVerifyCommand_MoreArgs(t *testing.T) {\n\topts := &verifyOpts{}\n\tcommand := verifyCommand(opts)\n\texpected := &verifyOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tInsecureRegistry: true,\n\t\t},\n\t\tpluginConfig: []string{\"key1=val1\", \"key2=val2\"},\n\t}\n\tif err := command.ParseFlags([]string{\n\t\texpected.reference,\n\t\t\"--insecure-registry\",\n\t\t\"--plugin-config\", \"key1=val1\",\n\t\t\"--plugin-config\", \"key2=val2\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse args failed: %v\", err)\n\t}\n\tif !reflect.DeepEqual(*expected, *opts) {\n\t\tt.Fatalf(\"Expect verify opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestVerifyCommand_MissingArgs(t *testing.T) {\n\tcmd := verifyCommand(nil)\n\tif err := cmd.ParseFlags(nil); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {\n\t\tt.Fatal(\"Parse Args expected error, but ok\")\n\t}\n}\n", "# notation inspect\n\n## Description\n\nUse `notation inspect` command to inspect all the signatures associated with signed artifact in a human readable format.\n\nUpon successful execution, both the digest of the signed artifact and the digests of signatures manifest along with their properties associated with the signed artifact are printed in the following format:\n\n```shell\n<registry>/<repository>@<digest>\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 <digest of signature manifest>\n    \u2502   \u251c\u2500\u2500 <signature algorithm>\n    \u2502   \u251c\u2500\u2500 <signed attributes>\n    \u2502   \u251c\u2500\u2500 <user defined attributes>\n    \u2502   \u251c\u2500\u2500 <unsigned attributes>\n    \u2502   \u251c\u2500\u2500 <certificates>\n    \u2502   \u2514\u2500\u2500 <signed artifact>\n    \u2514\u2500\u2500 <digest of signature manifest>\n        \u251c\u2500\u2500 <signature algorithm>\n        \u251c\u2500\u2500 <signed attributes>\n        \u251c\u2500\u2500 <unsigned attributes>\n        \u251c\u2500\u2500 <certificates>\n        \u2514\u2500\u2500 <signed artifact>\n```\n\n## Outline\n\n```text\nInspect all signatures associated with the signed artifact.\n\nUsage:\n    notation inspect [flags] <reference>\n\nFlags:\n      --allow-referrers-api   [Experimental] use the Referrers API to inspect signatures, if not supported (returns 404), fallback to the Referrers tag schema\n  -d, --debug                 debug mode\n  -h, --help                  help for inspect\n      --insecure-registry     use HTTP protocol while connecting to registries. Should be used only for testing\n  -o, --output string         output format, options: 'json', 'text' (default \"text\")\n  -p, --password string       password for registry operations (default to $NOTATION_PASSWORD if not specified)\n  -u, --username string       username for registry operations (default to $NOTATION_USERNAME if not specified)\n  -v, --verbose               verbose mode\n```\n\n## Usage\n\n### Display the details of all the listed signatures and its associated certificate properties of the signed container image\n\n\n```text\nnotation inspect [flags] <registry>/<repository>@<digest>\n```\n\n## Inspect signatures on the supplied OCI artifact identified by the digest\n\n```shell\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\nnotation inspect localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da1ac484efe37a5380ee9088f7ace2efcde9\n```\n\nAn example output:\n```shell\nInspecting all signatures for signed artifact\nlocalhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac4efe37a5380ee9088f7ace2efcde9\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    \u2502   \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n    \u2502   \u251c\u2500\u2500 signed attributes\n    \u2502   \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n    \u2502   \u2502   \u251c\u2500\u2500 signing scheme: notary.default.x509\n    \u2502   \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n    \u2502   \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin    //extended attributes\n    \u2502   \u251c\u2500\u2500 user defined attributes\n    \u2502   \u2502   \u2514\u2500\u2500 io.wabbit-networks.buildId: 123                             //user defined metadata\n    \u2502   \u251c\u2500\u2500 unsigned attributes\n    \u2502   \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)> //TSA response\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0                 //client version\n    \u2502   \u251c\u2500\u2500 certificates\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: E8C15B4C98AD91E051EE5AF5F524A8729050B2A\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n    \u2502   \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n    \u2502   \u2514\u2500\u2500 signed artifact                                                 //descriptor of signed artifact\n    \u2502       \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n    \u2502       \u251c\u2500\u2500 digest: sha256:b94d27b9934d3e08a52e52d7da7dabfac48437a5380ee9088f7ace2efcde9\n    \u2502       \u2514\u2500\u2500 size: 16724\n    \u2514\u2500\u2500 sha256:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n        \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n        \u251c\u2500\u2500 signed attributes\n        \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n        \u2502   \u251c\u2500\u2500 signing scheme: notary.signingAuthority.x509\n        \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n        \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin\n        \u251c\u2500\u2500 unsigned attributes\n        \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)>\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0\n        \u251c\u2500\u2500 certificates\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA 2010\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n        \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n        \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n        \u2514\u2500\u2500 signed artifact\n            \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n            \u251c\u2500\u2500 digest: sha256:b94d27b9934d3e08a52e52d7da7fac484efe37a5380ee9088f7ace2efcde9\n            \u2514\u2500\u2500 size: 16724\n```\n\n## Inspect signatures on an OCI artifact identified by a tag\n\n`Tags` are mutable, but `Digests` uniquely and immutably identify an artifact. If a tag is used to identify a signed artifact, notation resolves the tag to the `digest` first.\n\n```shell\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\nnotation inspect localhost:5000/net-monitor:v1\n```\n\nAn example output:\n```text\nResolved artifact tag `v1` to digest `sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9` before inspect.\nWarning: The resolved digest may not point to the same signed artifact, since tags are mutable.\n```\n\n```shell\nInspecting all signatures for signed artifact\nlocalhost:5000/net-monitor@sha256:ca5427b5567d3e06a72e52d7da7dabfac484efe37a5380ee9088f7ace2eaab9\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    \u2502   \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n    \u2502   \u251c\u2500\u2500 signed attributes\n    \u2502   \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n    \u2502   \u2502   \u251c\u2500\u2500 signing scheme: notary.default.x509\n    \u2502   \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n    \u2502   \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin\n    \u2502   \u251c\u2500\u2500 user defined attributes\n    \u2502   \u2502   \u2514\u2500\u2500 io.wabbit-networks.buildId: 123\n    \u2502   \u251c\u2500\u2500 unsigned attributes\n    \u2502   \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)>\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0\n    \u2502   \u251c\u2500\u2500 certificates\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n    \u2502   \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n    \u2502   \u2514\u2500\u2500 signed artifact\n    \u2502       \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n    \u2502       \u251c\u2500\u2500 digest: sha256:ca5427b5567d3e06a72e52d7da7dabfac484efe37a5380ee9088f7ace2eaab9\n    \u2502       \u2514\u2500\u2500 size: 16724\n    \u2514\u2500\u2500 sha256:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n        \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n        \u251c\u2500\u2500 signed attributes\n        \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n        \u2502   \u251c\u2500\u2500 signing scheme: notary.signingAuthority.x509\n        \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n        \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin\n        \u251c\u2500\u2500 unsigned attributes\n        \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)>\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0\n        \u251c\u2500\u2500 certificates\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n        \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n        \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n        \u2514\u2500\u2500 signed artifact\n            \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n            \u251c\u2500\u2500 digest: sha256:ca5427b5567d3e06a72e52d7da7dabfac484efe37a5380ee9088f7ace2eaab9\n            \u2514\u2500\u2500 size: 16724\n```\n## Inspect signatures on the supplied OCI artifact with an example of JSON Output\n\n```shell\nnotation inspect localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52da7dabfac484efe37a5380ee9088f7ace2efcde9 -o json\n```\n\nAn example output:\n```jsonc\n{\n  \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n  \"signatures\": [\n    {\n      \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b00369da519a33\",\n      \"signatureAlgorithm\": \"RSASSA-PSS-SHA-256\",\n      \"signedAttributes\": {\n        \"contentType\": \"application/vnd.cncf.notary.payload.v1+json\",\n        \"signingScheme\": \"notary.default.x509\",\n        \"signingTime\": \"2022-02-06T20:50:17Z\",\n        \"expiry\": \"2023-02-06T20:50:17Z\",\n        \"io.cncf.notary.verificationPlugin\": \"com.example.nv2plugin\"\n      },\n      \"userDefinedAttributes\": {\n        \"io.wabbit-networks.buildId\": \"123\"\n      },\n      \"unsignedAttributes\": {\n        \"io.cncf.notary.timestampSignature\": \"<Base64(TimeStampToken)>\",\n        \"io.cncf.notary.signingAgent\": \"notation/1.0.0\"\n      },\n      \"certificates\": [\n        {\n          \"SHA256Fingerprint\": \"b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\",\n          \"issuedTo\": \"wabbit-com Software\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\",\n          \"issuedTo\": \"wabbit-com Software Code Signing PCA\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\",\n          \"issuedTo\": \"wabbit-com Software Root Certificate Authority\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2035-07-06T20:50:17Z\"\n        }\n      ],\n      \"signedArtifact\": {\n        \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n        \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b00369519a3c333\",\n        \"size\": 16724\n      }\n    },\n    {\n      \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b00369da519a3c333\",\n      \"signatureAlgorithm\": \"RSASSA-PSS-SHA-256\",\n      \"signedAttributes\": {\n        \"contentType\": \"application/vnd.cncf.notary.payload.v1+json\",\n        \"signingScheme\": \"notary.signingAuthority.x509\",\n        \"signingTime\": \"2022-02-06T20:50:17Z\",\n        \"expiry\": \"2023-02-06T20:50:17Z\",\n        \"io.cncf.notary.verificationPlugin\": \"com.example.nv2plugin\"\n      },\n      \"unsignedAttributes\": {\n        \"io.cncf.notary.timestampSignature\": \"<Base64(TimeStampToken)>\",\n        \"io.cncf.notary.signingAgent\": \"notation/1.0.0\"\n      },\n      \"certificates\": [\n        {\n          \"SHA256Fingerprint\": \"b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\",\n          \"issuedTo\": \"wabbit-com Software\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\",\n          \"issuedTo\": \"wabbit-com Software Code Signing PCA\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\",\n          \"issuedTo\": \"wabbit-com Software Root Certificate Authority\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2035-07-06T20:50:17Z\"\n        }\n      ],\n      \"signedArtifact\": {\n        \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n        \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b069da519a3c333\",\n        \"size\": 16724\n      }\n    }\n  ]\n}\n```\n", "# notation list\n\n## Description\n\nUse `notation list` to list all the signatures associated with signed artifact.\n\n`Tags` are mutable, but `Digests` uniquely and immutably identify an artifact. If a tag is used to identify a signed artifact, notation resolves the tag to the `digest` first.\n\nUpon successful execution, both the digest of the signed artifact and the digests of signatures manifest associated with signed artifact are printed out as following:\n\n```shell\n<registry>/<repository>@<digest>\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500<digest_of_signature_manifest>\n    \u2514\u2500\u2500<digest_of_signature_manifest>\n```\n\n## Outline\n\n```text\nList all the signatures associated with signed artifact\n\nUsage:\n  notation list [flags] <reference>\n\nAliases:\n  list, ls\n\nFlags:\n      --allow-referrers-api   [Experimental] use the Referrers API to list signatures, if not supported (returns 404), fallback to the Referrers tag schema\n  -d, --debug                 debug mode\n  -h, --help                  help for list\n      --insecure-registry     use HTTP protocol while connecting to registries. Should be used only for testing\n      --oci-layout            [Experimental] list signatures stored in OCI image layout\n  -p, --password string       password for registry operations (default to $NOTATION_PASSWORD if not specified)\n  -u, --username string       username for registry operations (default to $NOTATION_USERNAME if not specified)\n  -v, --verbose               verbose mode\n```\n\n## Usage\n\n### List all the signatures of the signed container image\n\n```shell\nnotation list <registry>/<repository>:<tag>\n```\n\nAn example output:\n\n```shell\nlocalhost:5000/net-monitor:v1\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:647039638efb22a021f59675c9449dd09956c981a44b82c1ff074513c2c9f273\n    \u2514\u2500\u2500 sha256:6bfb3c4fd485d6810f9656ddd4fb603f0c414c5f0b175ef90eeb4090ebd9bfa1\n```\n\n### [Experimental] List all the signatures associated with the image in OCI layout directory\n\nThe following example lists the signatures associated with the image in OCI layout directory named `hello-world`. To access this flag `--oci-layout` , set the environment variable `NOTATION_EXPERIMENTAL=1`.\n\nReference an image in OCI layout directory using tags:\n\n```shell\nexport NOTATION_EXPERIMENTAL=1\n# Assume OCI layout directory hello-world is under current path\nnotation list --oci-layout hello-world:v1\n```\n\nReference an image in OCI layout directory using exact digest:\n\n```shell\nexport NOTATION_EXPERIMENTAL=1\n# Assume OCI layout directory hello-world is under current path\nnotation list --oci-layout hello-world@sha256:xxx\n```\n\nAn example output:\n\n```shell\nhello-world@sha256:a08753c0c7bcdaaf5c2fdb375f68e860c34bffb146368982c201d41769e1763c\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:647039638efb22a021f59675c9449dd09956c981a44b82c1ff074513c2c9f273\n    \u2514\u2500\u2500 sha256:6bfb3c4fd485d6810f9656ddd4fb603f0c414c5f0b175ef90eeb4090ebd9bfa1\n```\n", "# notation verify\n\n## Description\n\nUse `notation verify` command to verify signatures associated with the artifact. Signature verification succeeds if verification succeeds for at least one of the signatures associated with the artifact. Upon successful verification, the output message is printed out as follows:\n\n```text\nSuccessfully verified signature for <registry>/<repository>@<digest>\n```\n\nTags are mutable and a tag reference can point to a different artifact than that was signed referred by the same tag. If a `tag` is used to identify the OCI artifact, the output message is as follows:\n\n```text\nWarning:  Always verify the artifact using digest(@sha256:...) rather than a tag(:v1) because resolved digest may not point to the same signed artifact, as tags are mutable.\nSuccessfully verified signature for <registry>/<repository>@<digest>\n```\n\nA signature can have user defined metadata. If the signature for the OCI artifact contains any metadata, the output message is as follows:\n\n```text\nSuccessfully verified signature for <registry>/<repository>@<digest>\n\nThe artifact was signed with the following user metadata.\n\nKEY    VALUE\n<key>  <value>\n```\n\n## Outline\n\n```text\nVerify signatures associated with the artifact.\n\nUsage:\n  notation verify [flags] <reference>\n\nFlags:\n       --allow-referrers-api         [Experimental] use the Referrers API to verify signatures, if not supported (returns 404), fallback to the Referrers tag schema\n  -d,  --debug                       debug mode\n  -h,  --help                        help for verify\n       --insecure-registry           use HTTP protocol while connecting to registries. Should be used only for testing\n       --oci-layout                  [Experimental] verify the artifact stored as OCI image layout\n  -p,  --password string             password for registry operations (default to $NOTATION_PASSWORD if not specified)\n       --plugin-config stringArray   {key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values\n       --scope string                [Experimental] set trust policy scope for artifact verification, required and can only be used when flag \"--oci-layout\" is set\n  -u,  --username string             username for registry operations (default to $NOTATION_USERNAME if not specified)\n  -m,  --user-metadata stringArray   user defined {key}={value} pairs that must be present in the signature for successful verification if provided\n  -v,  --verbose                     verbose mode\n```\n\n## Usage\n\nPre-requisite: User needs to configure trust store and trust policy properly before using `notation verify` command.\n\n### Configure Trust Store\n\nUse `notation certificate` command to configure trust stores.\n\n### Configure Trust Policy\n\nUsers who consume signed artifact from a registry use the trust policy to specify trusted identities which sign the artifacts, and level of signature verification to use. The trust policy is a JSON document. User needs to create a file named `trustpolicy.json` under `{NOTATION_CONFIG}`. See [Notation Directory Structure](https://notaryproject.dev/docs/tutorials/directory-structure/) for `{NOTATION_CONFIG}`.\n\nAn example of `trustpolicy.json`:\n\n```jsonc\n{\n    \"version\": \"1.0\",\n    \"trustPolicies\": [\n        {\n            // Policy for all artifacts, from any registry location.\n            \"name\": \"wabbit-networks-images\",                         // Name of the policy.\n            \"registryScopes\": [ \"localhost:5000/net-monitor\" ],       // The registry artifacts to which the policy applies.\n            \"signatureVerification\": {                                // The level of verification - strict, permissive, audit, skip.\n                \"level\": \"strict\"\n            },\n            \"trustStores\": [ \"ca:wabbit-networks\" ],                  // The trust stores that contains the X.509 trusted roots.\n            \"trustedIdentities\": [                                    // Identities that are trusted to sign the artifact.\n                \"x509.subject: C=US, ST=WA, L=Seattle, O=wabbit-networks.io, OU=Finance, CN=SecureBuilder\"\n            ]\n        }\n    ]\n}\n```\n\nFor a Linux user, store file `trustpolicy.json` under directory `${HOME}/.config/notation/`.\n\nFor a MacOS user, store file `trustpolicy.json` under directory `${HOME}/Library/Application Support/notation/`.\n\nFor a Windows user, store file `trustpolicy.json` under directory `%USERPROFILE%\\AppData\\Roaming\\notation\\`.\n\nExample values on trust policy properties:\n\n| Property name         | Value                                                                                      | Meaning                                                                                                                                                            |\n| ----------------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| name                  | \"wabbit-networks-images\"                                                                   | The name of the policy is \"wabbit-networks-images\".                                                                                                                |\n| registryScopes        | \"localhost:5000/net-monitor\"                                                               | The policy only applies to artifacts stored in repository `localhost:5000/net-monitor`.                                                                            |\n| registryScopes        | \"localhost:5000/net-monitor\", \"localhost:5000/nginx\"                                       | The policy applies to artifacts stored in two repositories: `localhost:5000/net-monitor` and `localhost:5000/nginx`.                                               |\n| registryScopes        | \"*\"                                                                                        | The policy applies to all the artifacts stored in any repositories.                                                                                                |\n| signatureVerification | \"level\": \"strict\"                                                                          | Signature verification is performed at strict level, which enforces all validations: `integrity`, `authenticity`, `authentic timestamp`, `expiry` and `revocation`.|\n| signatureVerification | \"level\": \"permissive\"                                                                      | The permissive level enforces most validations, but will only logs failures for `revocation` and `expiry`.                                                         |\n| signatureVerification | \"level\": \"audit\"                                                                           | The audit level only enforces signature `integrity` if a signature is present. Failure of all other validations are only logged.                                   |\n| signatureVerification | \"level\": \"skip\"                                                                            | The skip level does not fetch signatures for artifacts and does not perform any signature verification.                                                            |\n| trustStores           | \"ca:wabbit-networks\"                                                                       | Specify the trust store that uses the format {trust-store-type}:{named-store}. The trust store is added using `notation certificate add` command.                  |\n| trustStores           | \"ca:wabbit-networks\", \"ca:rocket-networks\"                                                 | Specify two trust stores, each of which contains the trusted roots against which signatures are verified.                                                          |\n| trustedIdentities     | \"x509.subject: C=US, ST=WA, L=Seattle, O=wabbit-networks.io, OU=Finance, CN=SecureBuilder\" | User only trusts the identity with specific subject. User can use `notation certificate show` command to get the `subject` info.                                   |\n| trustedIdentities     | \"*\"                                                                                        | User trusts any identity (signing certificate) issued by the CA(s) in trust stores.                                                                                |\n\nUser can configure multiple trust policies for different scenarios. See [Trust Policy Schema and properties](https://github.com/notaryproject/notaryproject/blob/main/specs/trust-store-trust-policy.md#trust-policy) for details.\n\n### Verify signatures on an OCI artifact stored in a registry\n\nConfigure trust store and trust policy properly before using `notation verify` command.\n\n```shell\n\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\n# Configure trust store by adding a certificate file into trust store named \"wabbit-network\" of type \"ca\"\nnotation certificate add --type ca --store wabbit-networks wabbit-networks.crt\n\n# Create a JSON file named \"trustpolicy.json\" under directory \"{NOTATION_CONFIG}\".\n\n# Verify signatures on the supplied OCI artifact identified by the digest\nnotation verify localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\nAn example of output messages for a successful verification:\n\n```text\nSuccessfully verified signature for localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\n### Verify signatures on an OCI artifact with user metadata\n\nUse the `--user-metadata` flag to verify that provided key-value pairs are present in the payload of the valid signature.\n\n```shell\n# Verify signatures on the supplied OCI artifact identified by the digest and verify that io.wabbit-networks.buildId=123 is present in the signed payload\nnotation verify --user-metadata io.wabbit-networks.buildId=123 localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\nAn example of output messages for a successful verification:\n\n```text\nSuccessfully verified signature for localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n\nThe artifact is signed with the following user metadata.\n\nKEY                         VALUE\nio.wabbit-networks.buildId  123\n```\n\nAn example of output messages for an unsuccessful verification:\n\n```text\nError: signature verification failed: unable to find specified metadata in any signatures\n```\n\n### Verify signatures on an OCI artifact identified by a tag\n\nA tag is resolved to a digest first before verification.\n\n```shell\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\n# Verify signatures on an OCI artifact identified by the tag\nnotation verify localhost:5000/net-monitor:v1\n```\n\nAn example of output messages for a successful verification:\n\n```text\nWarning:  Always verify the artifact using digest(@sha256:...) rather than a tag(:v1) because resolved digest may not point to the same signed artifact, as tags are mutable.\nSuccessfully verified signature for localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\n### [Experimental] Verify container images in OCI layout directory\n\nUsers should configure trust policy properly before verifying artifacts in OCI layout directory. According to trust policy specification, `registryScopes` property of trust policy configuration determines which trust policy is applicable for the given artifact. For example, an image stored in a remote registry is referenced by \"localhost:5000/net-monitor:v1\". In order to verify the image, the value of `registryScopes` should contain \"localhost:5000/net-monitor\", which is the repository URL of the image. However, the reference to the image stored in OCI layout directory doesn't contain repository URL information. Users can set `registryScopes` to the URL that the image is supposed to be stored in the registry, and then use flag `--scope` for `notation verify` command to determine which trust policy is used for verification. Here is an example of trust policy configured for image `hello-world:v1`:\n\n```jsonc\n{\n    \"name\": \"images stored as OCI layout\",\n    \"registryScopes\": [ \"local/hello-world\" ],\n    \"signatureVerification\": {\n        \"level\" : \"strict\"\n    },\n    \"trustStores\": [ \"ca:hello-world\" ],\n    \"trustedIdentities\": [\"*\"]\n}\n```\n\nTo verify image `hello-world:v1`, user should set the environment variable `NOTATION_EXPERIMENTAL` and use flags `--oci-layout` and `--scope` together. for example:\n\n```shell\nexport NOTATION_EXPERIMENTAL=1\n# Assume OCI layout directory hello-world is under current path\n# The value of --scope should be set base on the trust policy configuration\nnotation verify --oci-layout --scope \"local/hello-world\" hello-world:v1\n```\n"], "fixing_code": ["package main\n\nimport (\n\t\"crypto/sha256\"\n\tb64 \"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/notaryproject/notation-core-go/signature\"\n\t\"github.com/notaryproject/notation-go/plugin/proto\"\n\t\"github.com/notaryproject/notation-go/registry\"\n\tcmderr \"github.com/notaryproject/notation/cmd/notation/internal/errors\"\n\t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n\t\"github.com/notaryproject/notation/internal/cmd\"\n\t\"github.com/notaryproject/notation/internal/envelope\"\n\t\"github.com/notaryproject/notation/internal/ioutil\"\n\t\"github.com/notaryproject/notation/internal/tree\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype inspectOpts struct {\n\tcmd.LoggingFlagOpts\n\tSecureFlagOpts\n\treference         string\n\toutputFormat      string\n\tallowReferrersAPI bool\n\tmaxSignatures     int\n}\n\ntype inspectOutput struct {\n\tMediaType  string `json:\"mediaType\"`\n\tSignatures []signatureOutput\n}\n\ntype signatureOutput struct {\n\tMediaType             string              `json:\"mediaType\"`\n\tDigest                string              `json:\"digest\"`\n\tSignatureAlgorithm    string              `json:\"signatureAlgorithm\"`\n\tSignedAttributes      map[string]string   `json:\"signedAttributes\"`\n\tUserDefinedAttributes map[string]string   `json:\"userDefinedAttributes\"`\n\tUnsignedAttributes    map[string]string   `json:\"unsignedAttributes\"`\n\tCertificates          []certificateOutput `json:\"certificates\"`\n\tSignedArtifact        ocispec.Descriptor  `json:\"signedArtifact\"`\n}\n\ntype certificateOutput struct {\n\tSHA256Fingerprint string `json:\"SHA256Fingerprint\"`\n\tIssuedTo          string `json:\"issuedTo\"`\n\tIssuedBy          string `json:\"issuedBy\"`\n\tExpiry            string `json:\"expiry\"`\n}\n\nfunc inspectCommand(opts *inspectOpts) *cobra.Command {\n\tif opts == nil {\n\t\topts = &inspectOpts{}\n\t}\n\tlongMessage := `Inspect all signatures associated with the signed artifact.\n\nExample - Inspect signatures on an OCI artifact identified by a digest:\n  notation inspect <registry>/<repository>@<digest>\n\nExample - Inspect signatures on an OCI artifact identified by a tag  (Notation will resolve tag to digest):\n  notation inspect <registry>/<repository>:<tag>\n\nExample - Inspect signatures on an OCI artifact identified by a digest and output as json:\n  notation inspect --output json <registry>/<repository>@<digest>\n`\n\texperimentalExamples := `\nExample - [Experimental] Inspect signatures on an OCI artifact identified by a digest using the Referrers API, if not supported (returns 404), fallback to the Referrers tag schema\n  notation inspect --allow-referrers-api <registry>/<repository>@<digest>\n`\n\tcommand := &cobra.Command{\n\t\tUse:   \"inspect [reference]\",\n\t\tShort: \"Inspect all signatures associated with the signed artifact\",\n\t\tLong:  longMessage,\n\t\tArgs: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"missing reference\")\n\t\t\t}\n\t\t\topts.reference = args[0]\n\t\t\treturn nil\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\")\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.maxSignatures <= 0 {\n\t\t\t\treturn fmt.Errorf(\"max-signatures value %d must be a positive number\", opts.maxSignatures)\n\t\t\t}\n\t\t\treturn runInspect(cmd, opts)\n\t\t},\n\t}\n\n\topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n\topts.SecureFlagOpts.ApplyFlags(command.Flags())\n\tcmd.SetPflagOutput(command.Flags(), &opts.outputFormat, cmd.PflagOutputUsage)\n\tcommand.Flags().IntVar(&opts.maxSignatures, \"max-signatures\", 100, \"maximum number of signatures to evaluate or examine\")\n\tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"inspect\"))\n\texperimental.HideFlags(command, experimentalExamples, []string{\"allow-referrers-api\"})\n\treturn command\n}\n\nfunc runInspect(command *cobra.Command, opts *inspectOpts) error {\n\t// set log level\n\tctx := opts.LoggingFlagOpts.SetLoggerLevel(command.Context())\n\n\tif opts.outputFormat != cmd.OutputJSON && opts.outputFormat != cmd.OutputPlaintext {\n\t\treturn fmt.Errorf(\"unrecognized output format %s\", opts.outputFormat)\n\t}\n\n\t// initialize\n\treference := opts.reference\n\tsigRepo, err := getRemoteRepository(ctx, &opts.SecureFlagOpts, reference, opts.allowReferrersAPI)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmanifestDesc, resolvedRef, err := resolveReferenceWithWarning(ctx, inputTypeRegistry, reference, sigRepo, \"inspect\")\n\tif err != nil {\n\t\treturn err\n\t}\n\toutput := inspectOutput{MediaType: manifestDesc.MediaType, Signatures: []signatureOutput{}}\n\tskippedSignatures := false\n\terr = listSignatures(ctx, sigRepo, manifestDesc, opts.maxSignatures, func(sigManifestDesc ocispec.Descriptor) error {\n\t\tsigBlob, sigDesc, err := sigRepo.FetchSignatureBlob(ctx, sigManifestDesc)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Warning: unable to fetch signature %s due to error: %v\\n\", sigManifestDesc.Digest.String(), err)\n\t\t\tskippedSignatures = true\n\t\t\treturn nil\n\t\t}\n\n\t\tsigEnvelope, err := signature.ParseEnvelope(sigDesc.MediaType, sigBlob)\n\t\tif err != nil {\n\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\tskippedSignatures = true\n\t\t\treturn nil\n\t\t}\n\n\t\tenvelopeContent, err := sigEnvelope.Content()\n\t\tif err != nil {\n\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\tskippedSignatures = true\n\t\t\treturn nil\n\t\t}\n\n\t\tsignedArtifactDesc, err := envelope.DescriptorFromSignaturePayload(&envelopeContent.Payload)\n\t\tif err != nil {\n\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\tskippedSignatures = true\n\t\t\treturn nil\n\t\t}\n\n\t\tsignatureAlgorithm, err := proto.EncodeSigningAlgorithm(envelopeContent.SignerInfo.SignatureAlgorithm)\n\t\tif err != nil {\n\t\t\tlogSkippedSignature(sigManifestDesc, err)\n\t\t\tskippedSignatures = true\n\t\t\treturn nil\n\t\t}\n\n\t\tsig := signatureOutput{\n\t\t\tMediaType:             sigDesc.MediaType,\n\t\t\tDigest:                sigManifestDesc.Digest.String(),\n\t\t\tSignatureAlgorithm:    string(signatureAlgorithm),\n\t\t\tSignedAttributes:      getSignedAttributes(opts.outputFormat, envelopeContent),\n\t\t\tUserDefinedAttributes: signedArtifactDesc.Annotations,\n\t\t\tUnsignedAttributes:    getUnsignedAttributes(envelopeContent),\n\t\t\tCertificates:          getCertificates(opts.outputFormat, envelopeContent),\n\t\t\tSignedArtifact:        *signedArtifactDesc,\n\t\t}\n\n\t\t// clearing annotations from the SignedArtifact field since they're already\n\t\t// displayed as UserDefinedAttributes\n\t\tsig.SignedArtifact.Annotations = nil\n\n\t\toutput.Signatures = append(output.Signatures, sig)\n\n\t\treturn nil\n\t})\n\tvar errorExceedMaxSignatures cmderr.ErrorExceedMaxSignatures\n\tif err != nil && !errors.As(err, &errorExceedMaxSignatures) {\n\t\treturn err\n\t}\n\n\tif err := printOutput(opts.outputFormat, resolvedRef, output); err != nil {\n\t\treturn err\n\t}\n\n\tif errorExceedMaxSignatures.MaxSignatures > 0 {\n\t\tfmt.Println(\"Warning:\", errorExceedMaxSignatures)\n\t}\n\n\tif skippedSignatures {\n\t\treturn errors.New(\"at least one signature was skipped and not displayed\")\n\t}\n\n\treturn nil\n}\n\nfunc logSkippedSignature(sigDesc ocispec.Descriptor, err error) {\n\tfmt.Fprintf(os.Stderr, \"Warning: Skipping signature %s because of error: %v\\n\", sigDesc.Digest.String(), err)\n}\n\nfunc getSignedAttributes(outputFormat string, envContent *signature.EnvelopeContent) map[string]string {\n\tsignedAttributes := map[string]string{\n\t\t\"signingScheme\": string(envContent.SignerInfo.SignedAttributes.SigningScheme),\n\t\t\"signingTime\":   formatTimestamp(outputFormat, envContent.SignerInfo.SignedAttributes.SigningTime),\n\t}\n\texpiry := envContent.SignerInfo.SignedAttributes.Expiry\n\tif !expiry.IsZero() {\n\t\tsignedAttributes[\"expiry\"] = formatTimestamp(outputFormat, expiry)\n\t}\n\n\tfor _, attribute := range envContent.SignerInfo.SignedAttributes.ExtendedAttributes {\n\t\tsignedAttributes[fmt.Sprint(attribute.Key)] = fmt.Sprint(attribute.Value)\n\t}\n\n\treturn signedAttributes\n}\n\nfunc getUnsignedAttributes(envContent *signature.EnvelopeContent) map[string]string {\n\tunsignedAttributes := map[string]string{}\n\n\tif envContent.SignerInfo.UnsignedAttributes.TimestampSignature != nil {\n\t\tunsignedAttributes[\"timestampSignature\"] = b64.StdEncoding.EncodeToString(envContent.SignerInfo.UnsignedAttributes.TimestampSignature)\n\t}\n\n\tif envContent.SignerInfo.UnsignedAttributes.SigningAgent != \"\" {\n\t\tunsignedAttributes[\"signingAgent\"] = envContent.SignerInfo.UnsignedAttributes.SigningAgent\n\t}\n\n\treturn unsignedAttributes\n}\n\nfunc formatTimestamp(outputFormat string, t time.Time) string {\n\tswitch outputFormat {\n\tcase cmd.OutputJSON:\n\t\treturn t.Format(time.RFC3339)\n\tdefault:\n\t\treturn t.Format(time.ANSIC)\n\t}\n}\n\nfunc getCertificates(outputFormat string, envContent *signature.EnvelopeContent) []certificateOutput {\n\tcertificates := []certificateOutput{}\n\n\tfor _, cert := range envContent.SignerInfo.CertificateChain {\n\t\th := sha256.Sum256(cert.Raw)\n\t\tfingerprint := strings.ToLower(hex.EncodeToString(h[:]))\n\n\t\tcertificate := certificateOutput{\n\t\t\tSHA256Fingerprint: fingerprint,\n\t\t\tIssuedTo:          cert.Subject.String(),\n\t\t\tIssuedBy:          cert.Issuer.String(),\n\t\t\tExpiry:            formatTimestamp(outputFormat, cert.NotAfter),\n\t\t}\n\n\t\tcertificates = append(certificates, certificate)\n\t}\n\n\treturn certificates\n}\n\nfunc printOutput(outputFormat string, ref string, output inspectOutput) error {\n\tif outputFormat == cmd.OutputJSON {\n\t\treturn ioutil.PrintObjectAsJSON(output)\n\t}\n\n\tif len(output.Signatures) == 0 {\n\t\tfmt.Printf(\"%s has no associated signature\\n\", ref)\n\t\treturn nil\n\t}\n\n\tfmt.Println(\"Inspecting all signatures for signed artifact\")\n\troot := tree.New(ref)\n\tcncfSigNode := root.Add(registry.ArtifactTypeNotation)\n\n\tfor _, signature := range output.Signatures {\n\t\tsigNode := cncfSigNode.Add(signature.Digest)\n\t\tsigNode.AddPair(\"media type\", signature.MediaType)\n\t\tsigNode.AddPair(\"signature algorithm\", signature.SignatureAlgorithm)\n\n\t\tsignedAttributesNode := sigNode.Add(\"signed attributes\")\n\t\taddMapToTree(signedAttributesNode, signature.SignedAttributes)\n\n\t\tuserDefinedAttributesNode := sigNode.Add(\"user defined attributes\")\n\t\taddMapToTree(userDefinedAttributesNode, signature.UserDefinedAttributes)\n\n\t\tunsignedAttributesNode := sigNode.Add(\"unsigned attributes\")\n\t\taddMapToTree(unsignedAttributesNode, signature.UnsignedAttributes)\n\n\t\tcertListNode := sigNode.Add(\"certificates\")\n\t\tfor _, cert := range signature.Certificates {\n\t\t\tcertNode := certListNode.AddPair(\"SHA256 fingerprint\", cert.SHA256Fingerprint)\n\t\t\tcertNode.AddPair(\"issued to\", cert.IssuedTo)\n\t\t\tcertNode.AddPair(\"issued by\", cert.IssuedBy)\n\t\t\tcertNode.AddPair(\"expiry\", cert.Expiry)\n\t\t}\n\n\t\tartifactNode := sigNode.Add(\"signed artifact\")\n\t\tartifactNode.AddPair(\"media type\", signature.SignedArtifact.MediaType)\n\t\tartifactNode.AddPair(\"digest\", signature.SignedArtifact.Digest.String())\n\t\tartifactNode.AddPair(\"size\", strconv.FormatInt(signature.SignedArtifact.Size, 10))\n\t}\n\n\troot.Print()\n\treturn nil\n}\n\nfunc addMapToTree(node *tree.Node, m map[string]string) {\n\tif len(m) > 0 {\n\t\tfor k, v := range m {\n\t\t\tnode.AddPair(k, v)\n\t\t}\n\t} else {\n\t\tnode.Add(\"(empty)\")\n\t}\n}\n", "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/notaryproject/notation/internal/cmd\"\n)\n\nfunc TestInspectCommand_SecretsFromArgs(t *testing.T) {\n\topts := &inspectOpts{}\n\tcommand := inspectCommand(opts)\n\texpected := &inspectOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword:         \"password\",\n\t\t\tInsecureRegistry: true,\n\t\t\tUsername:         \"user\",\n\t\t},\n\t\toutputFormat:  cmd.OutputPlaintext,\n\t\tmaxSignatures: 100,\n\t}\n\tif err := command.ParseFlags([]string{\n\t\t\"--password\", expected.Password,\n\t\texpected.reference,\n\t\t\"-u\", expected.Username,\n\t\t\"--insecure-registry\",\n\t\t\"--output\", \"text\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect inspect opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestInspectCommand_SecretsFromEnv(t *testing.T) {\n\tt.Setenv(defaultUsernameEnv, \"user\")\n\tt.Setenv(defaultPasswordEnv, \"password\")\n\topts := &inspectOpts{}\n\texpected := &inspectOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword: \"password\",\n\t\t\tUsername: \"user\",\n\t\t},\n\t\toutputFormat:  cmd.OutputJSON,\n\t\tmaxSignatures: 100,\n\t}\n\tcommand := inspectCommand(opts)\n\tif err := command.ParseFlags([]string{\n\t\texpected.reference,\n\t\t\"--output\", \"json\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect inspect opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestInspectCommand_MissingArgs(t *testing.T) {\n\tcommand := inspectCommand(nil)\n\tif err := command.ParseFlags(nil); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err == nil {\n\t\tt.Fatal(\"Parse Args expected error, but ok\")\n\t}\n}\n", "package errors\n\nimport \"fmt\"\n\n// ErrorReferrersAPINotSupported is used when the target registry does not\n// support the Referrers API\ntype ErrorReferrersAPINotSupported struct {\n\tMsg string\n}\n\nfunc (e ErrorReferrersAPINotSupported) Error() string {\n\tif e.Msg != \"\" {\n\t\treturn e.Msg\n\t}\n\treturn \"referrers API not supported\"\n}\n\n// ErrorOCILayoutMissingReference is used when signing local content in oci\n// layout folder but missing input tag or digest.\ntype ErrorOCILayoutMissingReference struct {\n\tMsg string\n}\n\nfunc (e ErrorOCILayoutMissingReference) Error() string {\n\tif e.Msg != \"\" {\n\t\treturn e.Msg\n\t}\n\treturn \"reference is missing either digest or tag\"\n}\n\n// ErrorExceedMaxSignatures is used when the number of signatures has surpassed\n// the maximum limit that can be evaluated.\ntype ErrorExceedMaxSignatures struct {\n\tMaxSignatures int\n}\n\nfunc (e ErrorExceedMaxSignatures) Error() string {\n\treturn fmt.Sprintf(\"exceeded configured limit of max signatures %d to examine\", e.MaxSignatures)\n}\n", "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\tnotationregistry \"github.com/notaryproject/notation-go/registry\"\n\tcmderr \"github.com/notaryproject/notation/cmd/notation/internal/errors\"\n\t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n\t\"github.com/notaryproject/notation/internal/cmd\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype listOpts struct {\n\tcmd.LoggingFlagOpts\n\tSecureFlagOpts\n\treference         string\n\tallowReferrersAPI bool\n\tociLayout         bool\n\tinputType         inputType\n\tmaxSignatures     int\n}\n\nfunc listCommand(opts *listOpts) *cobra.Command {\n\tif opts == nil {\n\t\topts = &listOpts{\n\t\t\tinputType: inputTypeRegistry, // remote registry by default\n\t\t}\n\t}\n\tcommand := &cobra.Command{\n\t\tUse:     \"list [flags] <reference>\",\n\t\tAliases: []string{\"ls\"},\n\t\tShort:   \"List signatures of the signed artifact\",\n\t\tLong:    \"List all the signatures associated with signed artifact\",\n\t\tArgs: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"no reference specified\")\n\t\t\t}\n\t\t\topts.reference = args[0]\n\t\t\treturn nil\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.ociLayout {\n\t\t\t\topts.inputType = inputTypeOCILayout\n\t\t\t}\n\t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\", \"oci-layout\")\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.maxSignatures <= 0 {\n\t\t\t\treturn fmt.Errorf(\"max-signatures value %d must be a positive number\", opts.maxSignatures)\n\t\t\t}\n\t\t\treturn runList(cmd.Context(), opts)\n\t\t},\n\t}\n\topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n\topts.SecureFlagOpts.ApplyFlags(command.Flags())\n\tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"list\"))\n\tcommand.Flags().BoolVar(&opts.ociLayout, \"oci-layout\", false, \"[Experimental] list signatures stored in OCI image layout\")\n\texperimental.HideFlags(command, \"\", []string{\"allow-referrers-api\", \"oci-layout\"})\n\tcommand.Flags().IntVar(&opts.maxSignatures, \"max-signatures\", 100, \"maximum number of signatures to evaluate or examine\")\n\treturn command\n}\n\nfunc runList(ctx context.Context, opts *listOpts) error {\n\t// set log level\n\tctx = opts.LoggingFlagOpts.SetLoggerLevel(ctx)\n\n\t// initialize\n\treference := opts.reference\n\tsigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttargetDesc, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, \"list\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t// print all signature manifest digests\n\treturn printSignatureManifestDigests(ctx, targetDesc, sigRepo, resolvedRef, opts.maxSignatures)\n}\n\n// printSignatureManifestDigests returns the signature manifest digests of\n// the subject manifest.\nfunc printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descriptor, sigRepo notationregistry.Repository, ref string, maxSigs int) error {\n\ttitlePrinted := false\n\tprintTitle := func() {\n\t\tif !titlePrinted {\n\t\t\tfmt.Println(ref)\n\t\t\tfmt.Printf(\"\u2514\u2500\u2500 %s\\n\", notationregistry.ArtifactTypeNotation)\n\t\t\ttitlePrinted = true\n\t\t}\n\t}\n\n\tvar prevDigest digest.Digest\n\terr := listSignatures(ctx, sigRepo, targetDesc, maxSigs, func(sigManifestDesc ocispec.Descriptor) error {\n\t\t// print the previous signature digest\n\t\tif prevDigest != \"\" {\n\t\t\tprintTitle()\n\t\t\tfmt.Printf(\"    \u251c\u2500\u2500 %s\\n\", prevDigest)\n\t\t}\n\t\tprevDigest = sigManifestDesc.Digest\n\t\treturn nil\n\t})\n\t// print the last signature digest\n\tif prevDigest != \"\" {\n\t\tprintTitle()\n\t\tfmt.Printf(\"    \u2514\u2500\u2500 %s\\n\", prevDigest)\n\t}\n\tif err != nil {\n\t\tvar errExceedMaxSignatures cmderr.ErrorExceedMaxSignatures\n\t\tif !errors.As(err, &errExceedMaxSignatures) {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(\"Warning:\", errExceedMaxSignatures)\n\t}\n\n\tif !titlePrinted {\n\t\tfmt.Printf(\"%s has no associated signature\\n\", ref)\n\t}\n\treturn nil\n}\n\n// listSignatures lists signatures associated with manifestDesc with number of\n// signatures limited by maxSig\nfunc listSignatures(ctx context.Context, sigRepo notationregistry.Repository, manifestDesc ocispec.Descriptor, maxSig int, fn func(sigManifest ocispec.Descriptor) error) error {\n\tnumOfSignatureProcessed := 0\n\treturn sigRepo.ListSignatures(ctx, manifestDesc, func(signatureManifests []ocispec.Descriptor) error {\n\t\tfor _, sigManifestDesc := range signatureManifests {\n\t\t\tif numOfSignatureProcessed >= maxSig {\n\t\t\t\treturn cmderr.ErrorExceedMaxSignatures{MaxSignatures: maxSig}\n\t\t\t}\n\t\t\tnumOfSignatureProcessed++\n\t\t\tif err := fn(sigManifestDesc); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package main\n\nimport (\n\t\"testing\"\n)\n\nfunc TestListCommand_SecretsFromArgs(t *testing.T) {\n\topts := &listOpts{}\n\tcmd := listCommand(opts)\n\texpected := &listOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword:         \"password\",\n\t\t\tInsecureRegistry: true,\n\t\t\tUsername:         \"user\",\n\t\t},\n\t\tmaxSignatures: 100,\n\t}\n\tif err := cmd.ParseFlags([]string{\n\t\t\"--password\", expected.Password,\n\t\texpected.reference,\n\t\t\"-u\", expected.Username,\n\t\t\"--insecure-registry\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect list opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestListCommand_SecretsFromEnv(t *testing.T) {\n\tt.Setenv(defaultUsernameEnv, \"user\")\n\tt.Setenv(defaultPasswordEnv, \"password\")\n\topts := &listOpts{}\n\texpected := &listOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tPassword: \"password\",\n\t\t\tUsername: \"user\",\n\t\t},\n\t\tmaxSignatures: 100,\n\t}\n\tcmd := listCommand(opts)\n\tif err := cmd.ParseFlags([]string{\n\t\texpected.reference}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse Args failed: %v\", err)\n\t}\n\tif *opts != *expected {\n\t\tt.Fatalf(\"Expect list opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestListCommand_MissingArgs(t *testing.T) {\n\tcmd := listCommand(nil)\n\tif err := cmd.ParseFlags(nil); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {\n\t\tt.Fatal(\"Parse Args expected error, but ok\")\n\t}\n}\n", "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\n\t\"github.com/notaryproject/notation-go\"\n\t\"github.com/notaryproject/notation-go/verifier\"\n\t\"github.com/notaryproject/notation-go/verifier/trustpolicy\"\n\t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n\t\"github.com/notaryproject/notation/internal/cmd\"\n\t\"github.com/notaryproject/notation/internal/ioutil\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype verifyOpts struct {\n\tcmd.LoggingFlagOpts\n\tSecureFlagOpts\n\treference            string\n\tpluginConfig         []string\n\tuserMetadata         []string\n\tallowReferrersAPI    bool\n\tociLayout            bool\n\ttrustPolicyScope     string\n\tinputType            inputType\n\tmaxSignatureAttempts int\n}\n\nfunc verifyCommand(opts *verifyOpts) *cobra.Command {\n\tif opts == nil {\n\t\topts = &verifyOpts{\n\t\t\tinputType: inputTypeRegistry, // remote registry by default\n\t\t}\n\t}\n\tlongMessage := `Verify OCI artifacts\n\nPrerequisite: added a certificate into trust store and created a trust policy.\n\nExample - Verify a signature on an OCI artifact identified by a digest:\n  notation verify <registry>/<repository>@<digest>\n\nExample - Verify a signature on an OCI artifact identified by a tag  (Notation will resolve tag to digest):\n  notation verify <registry>/<repository>:<tag>\n`\n\texperimentalExamples := `\nExample - [Experimental] Verify an OCI artifact using the Referrers API, if not supported (returns 404), fallback to the Referrers tag schema\n  notation verify --allow-referrers-api <registry>/<repository>@<digest>\n\nExample - [Experimental] Verify a signature on an OCI artifact referenced in an OCI layout using trust policy statement specified by scope.\n  notation verify --oci-layout <registry>/<repository>@<digest> --scope <trust_policy_scope>\n\nExample - [Experimental] Verify a signature on an OCI artifact identified by a tag and referenced in an OCI layout using trust policy statement specified by scope.\n  notation verify --oci-layout <registry>/<repository>:<tag> --scope <trust_policy_scope>\n`\n\tcommand := &cobra.Command{\n\t\tUse:   \"verify [reference]\",\n\t\tShort: \"Verify OCI artifacts\",\n\t\tLong:  longMessage,\n\t\tArgs: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"missing reference\")\n\t\t\t}\n\t\t\topts.reference = args[0]\n\t\t\treturn nil\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.ociLayout {\n\t\t\t\topts.inputType = inputTypeOCILayout\n\t\t\t}\n\t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\", \"oci-layout\", \"scope\")\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif opts.maxSignatureAttempts <= 0 {\n\t\t\t\treturn fmt.Errorf(\"max-signatures value %d must be a positive number\", opts.maxSignatureAttempts)\n\t\t\t}\n\t\t\treturn runVerify(cmd, opts)\n\t\t},\n\t}\n\topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n\topts.SecureFlagOpts.ApplyFlags(command.Flags())\n\tcommand.Flags().StringArrayVar(&opts.pluginConfig, \"plugin-config\", nil, \"{key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values\")\n\tcmd.SetPflagUserMetadata(command.Flags(), &opts.userMetadata, cmd.PflagUserMetadataVerifyUsage)\n\tcommand.Flags().IntVar(&opts.maxSignatureAttempts, \"max-signatures\", 100, \"maximum number of signatures to evaluate or examine\")\n\tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"verify\"))\n\tcommand.Flags().BoolVar(&opts.ociLayout, \"oci-layout\", false, \"[Experimental] verify the artifact stored as OCI image layout\")\n\tcommand.Flags().StringVar(&opts.trustPolicyScope, \"scope\", \"\", \"[Experimental] set trust policy scope for artifact verification, required and can only be used when flag \\\"--oci-layout\\\" is set\")\n\tcommand.MarkFlagsRequiredTogether(\"oci-layout\", \"scope\")\n\texperimental.HideFlags(command, experimentalExamples, []string{\"allow-referrers-api\", \"oci-layout\", \"scope\"})\n\treturn command\n}\n\nfunc runVerify(command *cobra.Command, opts *verifyOpts) error {\n\t// set log level\n\tctx := opts.LoggingFlagOpts.SetLoggerLevel(command.Context())\n\n\t// initialize\n\tsigVerifier, err := verifier.NewFromConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set up verification plugin config.\n\tconfigs, err := cmd.ParseFlagMap(opts.pluginConfig, cmd.PflagPluginConfig.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set up user metadata\n\tuserMetadata, err := cmd.ParseFlagMap(opts.userMetadata, cmd.PflagUserMetadata.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// core verify process\n\treference := opts.reference\n\tsigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// resolve the given reference and set the digest\n\t_, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, \"verify\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tintendedRef := resolveArtifactDigestReference(resolvedRef, opts.trustPolicyScope)\n\tverifyOpts := notation.VerifyOptions{\n\t\tArtifactReference:    intendedRef,\n\t\tPluginConfig:         configs,\n\t\tMaxSignatureAttempts: opts.maxSignatureAttempts,\n\t\tUserMetadata:         userMetadata,\n\t}\n\t_, outcomes, err := notation.Verify(ctx, sigVerifier, sigRepo, verifyOpts)\n\terr = checkVerificationFailure(outcomes, resolvedRef, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treportVerificationSuccess(outcomes, resolvedRef)\n\treturn nil\n}\n\nfunc checkVerificationFailure(outcomes []*notation.VerificationOutcome, printOut string, err error) error {\n\t// write out on failure\n\tif err != nil || len(outcomes) == 0 {\n\t\tif err != nil {\n\t\t\tvar errorVerificationFailed notation.ErrorVerificationFailed\n\t\t\tif !errors.As(err, &errorVerificationFailed) {\n\t\t\t\treturn fmt.Errorf(\"signature verification failed: %w\", err)\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"signature verification failed for all the signatures associated with %s\", printOut)\n\t}\n\treturn nil\n}\n\nfunc reportVerificationSuccess(outcomes []*notation.VerificationOutcome, printout string) {\n\t// write out on success\n\toutcome := outcomes[0]\n\t// print out warning for any failed result with logged verification action\n\tfor _, result := range outcome.VerificationResults {\n\t\tif result.Error != nil {\n\t\t\t// at this point, the verification action has to be logged and\n\t\t\t// it's failed\n\t\t\tfmt.Fprintf(os.Stderr, \"Warning: %v was set to %q and failed with error: %v\\n\", result.Type, result.Action, result.Error)\n\t\t}\n\t}\n\tif reflect.DeepEqual(outcome.VerificationLevel, trustpolicy.LevelSkip) {\n\t\tfmt.Println(\"Trust policy is configured to skip signature verification for\", printout)\n\t} else {\n\t\tfmt.Println(\"Successfully verified signature for\", printout)\n\t\tprintMetadataIfPresent(outcome)\n\t}\n}\n\nfunc printMetadataIfPresent(outcome *notation.VerificationOutcome) {\n\t// the signature envelope is parsed as part of verification.\n\t// since user metadata is only printed on successful verification,\n\t// this error can be ignored\n\tmetadata, _ := outcome.UserMetadata()\n\n\tif len(metadata) > 0 {\n\t\tfmt.Println(\"\\nThe artifact was signed with the following user metadata.\")\n\t\tioutil.PrintMetadataMap(os.Stdout, metadata)\n\t}\n}\n", "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestVerifyCommand_BasicArgs(t *testing.T) {\n\topts := &verifyOpts{}\n\tcommand := verifyCommand(opts)\n\texpected := &verifyOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tUsername: \"user\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t\tpluginConfig:         []string{\"key1=val1\"},\n\t\tmaxSignatureAttempts: 100,\n\t}\n\tif err := command.ParseFlags([]string{\n\t\texpected.reference,\n\t\t\"--username\", expected.Username,\n\t\t\"--password\", expected.Password,\n\t\t\"--plugin-config\", \"key1=val1\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse args failed: %v\", err)\n\t}\n\tif !reflect.DeepEqual(*expected, *opts) {\n\t\tt.Fatalf(\"Expect verify opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestVerifyCommand_MoreArgs(t *testing.T) {\n\topts := &verifyOpts{}\n\tcommand := verifyCommand(opts)\n\texpected := &verifyOpts{\n\t\treference: \"ref\",\n\t\tSecureFlagOpts: SecureFlagOpts{\n\t\t\tInsecureRegistry: true,\n\t\t},\n\t\tpluginConfig:         []string{\"key1=val1\", \"key2=val2\"},\n\t\tmaxSignatureAttempts: 100,\n\t}\n\tif err := command.ParseFlags([]string{\n\t\texpected.reference,\n\t\t\"--insecure-registry\",\n\t\t\"--plugin-config\", \"key1=val1\",\n\t\t\"--plugin-config\", \"key2=val2\"}); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := command.Args(command, command.Flags().Args()); err != nil {\n\t\tt.Fatalf(\"Parse args failed: %v\", err)\n\t}\n\tif !reflect.DeepEqual(*expected, *opts) {\n\t\tt.Fatalf(\"Expect verify opts: %v, got: %v\", expected, opts)\n\t}\n}\n\nfunc TestVerifyCommand_MissingArgs(t *testing.T) {\n\tcmd := verifyCommand(nil)\n\tif err := cmd.ParseFlags(nil); err != nil {\n\t\tt.Fatalf(\"Parse Flag failed: %v\", err)\n\t}\n\tif err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {\n\t\tt.Fatal(\"Parse Args expected error, but ok\")\n\t}\n}\n", "# notation inspect\n\n## Description\n\nUse `notation inspect` command to inspect all the signatures associated with signed artifact in a human readable format.\n\nUpon successful execution, both the digest of the signed artifact and the digests of signatures manifest along with their properties associated with the signed artifact are printed in the following format:\n\n```shell\n<registry>/<repository>@<digest>\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 <digest of signature manifest>\n    \u2502   \u251c\u2500\u2500 <signature algorithm>\n    \u2502   \u251c\u2500\u2500 <signed attributes>\n    \u2502   \u251c\u2500\u2500 <user defined attributes>\n    \u2502   \u251c\u2500\u2500 <unsigned attributes>\n    \u2502   \u251c\u2500\u2500 <certificates>\n    \u2502   \u2514\u2500\u2500 <signed artifact>\n    \u2514\u2500\u2500 <digest of signature manifest>\n        \u251c\u2500\u2500 <signature algorithm>\n        \u251c\u2500\u2500 <signed attributes>\n        \u251c\u2500\u2500 <unsigned attributes>\n        \u251c\u2500\u2500 <certificates>\n        \u2514\u2500\u2500 <signed artifact>\n```\n\n## Outline\n\n```text\nInspect all signatures associated with the signed artifact.\n\nUsage:\n    notation inspect [flags] <reference>\n\nFlags:\n      --allow-referrers-api   [Experimental] use the Referrers API to inspect signatures, if not supported (returns 404), fallback to the Referrers tag schema\n  -d, --debug                 debug mode\n  -h, --help                  help for inspect\n      --insecure-registry     use HTTP protocol while connecting to registries. Should be used only for testing\n      --max-signatures int    maximum number of signatures to evaluate or examine (default 100)\n  -o, --output string         output format, options: 'json', 'text' (default \"text\")\n  -p, --password string       password for registry operations (default to $NOTATION_PASSWORD if not specified)\n  -u, --username string       username for registry operations (default to $NOTATION_USERNAME if not specified)\n  -v, --verbose               verbose mode\n```\n\n## Usage\n\n### Display the details of all the listed signatures and its associated certificate properties of the signed container image\n\n\n```text\nnotation inspect [flags] <registry>/<repository>@<digest>\n```\n\n## Inspect signatures on the supplied OCI artifact identified by the digest\n\n```shell\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\nnotation inspect localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da1ac484efe37a5380ee9088f7ace2efcde9\n```\n\nAn example output:\n```shell\nInspecting all signatures for signed artifact\nlocalhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac4efe37a5380ee9088f7ace2efcde9\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    \u2502   \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n    \u2502   \u251c\u2500\u2500 signed attributes\n    \u2502   \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n    \u2502   \u2502   \u251c\u2500\u2500 signing scheme: notary.default.x509\n    \u2502   \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n    \u2502   \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin    //extended attributes\n    \u2502   \u251c\u2500\u2500 user defined attributes\n    \u2502   \u2502   \u2514\u2500\u2500 io.wabbit-networks.buildId: 123                             //user defined metadata\n    \u2502   \u251c\u2500\u2500 unsigned attributes\n    \u2502   \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)> //TSA response\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0                 //client version\n    \u2502   \u251c\u2500\u2500 certificates\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: E8C15B4C98AD91E051EE5AF5F524A8729050B2A\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n    \u2502   \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n    \u2502   \u2514\u2500\u2500 signed artifact                                                 //descriptor of signed artifact\n    \u2502       \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n    \u2502       \u251c\u2500\u2500 digest: sha256:b94d27b9934d3e08a52e52d7da7dabfac48437a5380ee9088f7ace2efcde9\n    \u2502       \u2514\u2500\u2500 size: 16724\n    \u2514\u2500\u2500 sha256:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n        \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n        \u251c\u2500\u2500 signed attributes\n        \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n        \u2502   \u251c\u2500\u2500 signing scheme: notary.signingAuthority.x509\n        \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n        \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin\n        \u251c\u2500\u2500 unsigned attributes\n        \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)>\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0\n        \u251c\u2500\u2500 certificates\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA 2010\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n        \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n        \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n        \u2514\u2500\u2500 signed artifact\n            \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n            \u251c\u2500\u2500 digest: sha256:b94d27b9934d3e08a52e52d7da7fac484efe37a5380ee9088f7ace2efcde9\n            \u2514\u2500\u2500 size: 16724\n```\n\n## Inspect signatures on an OCI artifact identified by a tag\n\n`Tags` are mutable, but `Digests` uniquely and immutably identify an artifact. If a tag is used to identify a signed artifact, notation resolves the tag to the `digest` first.\n\n```shell\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\nnotation inspect localhost:5000/net-monitor:v1\n```\n\nAn example output:\n```text\nResolved artifact tag `v1` to digest `sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9` before inspect.\nWarning: The resolved digest may not point to the same signed artifact, since tags are mutable.\n```\n\n```shell\nInspecting all signatures for signed artifact\nlocalhost:5000/net-monitor@sha256:ca5427b5567d3e06a72e52d7da7dabfac484efe37a5380ee9088f7ace2eaab9\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    \u2502   \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n    \u2502   \u251c\u2500\u2500 signed attributes\n    \u2502   \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n    \u2502   \u2502   \u251c\u2500\u2500 signing scheme: notary.default.x509\n    \u2502   \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n    \u2502   \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin\n    \u2502   \u251c\u2500\u2500 user defined attributes\n    \u2502   \u2502   \u2514\u2500\u2500 io.wabbit-networks.buildId: 123\n    \u2502   \u251c\u2500\u2500 unsigned attributes\n    \u2502   \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)>\n    \u2502   \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0\n    \u2502   \u251c\u2500\u2500 certificates\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n    \u2502   \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n    \u2502   \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n    \u2502   \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n    \u2502   \u2514\u2500\u2500 signed artifact\n    \u2502       \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n    \u2502       \u251c\u2500\u2500 digest: sha256:ca5427b5567d3e06a72e52d7da7dabfac484efe37a5380ee9088f7ace2eaab9\n    \u2502       \u2514\u2500\u2500 size: 16724\n    \u2514\u2500\u2500 sha256:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n        \u251c\u2500\u2500 signature algorithm: RSASSA-PSS-SHA-256\n        \u251c\u2500\u2500 signed attributes\n        \u2502   \u251c\u2500\u2500 content type: application/vnd.cncf.notary.payload.v1+json\n        \u2502   \u251c\u2500\u2500 signing scheme: notary.signingAuthority.x509\n        \u2502   \u251c\u2500\u2500 signing time: Fri Jun 23 22:04:01 2023\n        \u2502   \u251c\u2500\u2500 expiry: Sat Jun 29 22:04:01 2024\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.verificationPlugin: com.example.nv2plugin\n        \u251c\u2500\u2500 unsigned attributes\n        \u2502   \u251c\u2500\u2500 io.cncf.notary.timestampSignature: <Base64(TimeStampToken)>\n        \u2502   \u2514\u2500\u2500 io.cncf.notary.signingAgent: notation/1.0.0\n        \u251c\u2500\u2500 certificates\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u251c\u2500\u2500 SHA256 fingerprint: 4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\n        \u2502   \u2502   \u251c\u2500\u2500 issued to: wabbit-com Software Code Signing PCA\n        \u2502   \u2502   \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502   \u2502   \u2514\u2500\u2500 expiry: Sun Jul 06 20:50:17 2025\n        \u2502   \u2514\u2500\u2500 SHA256 fingerprint: ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\n        \u2502       \u251c\u2500\u2500 issued to: wabbit-com Software Root Certificate Authority\n        \u2502       \u251c\u2500\u2500 issued by: wabbit-com Software Root Certificate Authority\n        \u2502       \u2514\u2500\u2500 expiry: Sat Jun 23 22:04:01 2035\n        \u2514\u2500\u2500 signed artifact\n            \u251c\u2500\u2500 media type: application/vnd.oci.image.manifest.v1+json\n            \u251c\u2500\u2500 digest: sha256:ca5427b5567d3e06a72e52d7da7dabfac484efe37a5380ee9088f7ace2eaab9\n            \u2514\u2500\u2500 size: 16724\n```\n## Inspect signatures on the supplied OCI artifact with an example of JSON Output\n\n```shell\nnotation inspect localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52da7dabfac484efe37a5380ee9088f7ace2efcde9 -o json\n```\n\nAn example output:\n```jsonc\n{\n  \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n  \"signatures\": [\n    {\n      \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b00369da519a33\",\n      \"signatureAlgorithm\": \"RSASSA-PSS-SHA-256\",\n      \"signedAttributes\": {\n        \"contentType\": \"application/vnd.cncf.notary.payload.v1+json\",\n        \"signingScheme\": \"notary.default.x509\",\n        \"signingTime\": \"2022-02-06T20:50:17Z\",\n        \"expiry\": \"2023-02-06T20:50:17Z\",\n        \"io.cncf.notary.verificationPlugin\": \"com.example.nv2plugin\"\n      },\n      \"userDefinedAttributes\": {\n        \"io.wabbit-networks.buildId\": \"123\"\n      },\n      \"unsignedAttributes\": {\n        \"io.cncf.notary.timestampSignature\": \"<Base64(TimeStampToken)>\",\n        \"io.cncf.notary.signingAgent\": \"notation/1.0.0\"\n      },\n      \"certificates\": [\n        {\n          \"SHA256Fingerprint\": \"b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\",\n          \"issuedTo\": \"wabbit-com Software\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\",\n          \"issuedTo\": \"wabbit-com Software Code Signing PCA\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\",\n          \"issuedTo\": \"wabbit-com Software Root Certificate Authority\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2035-07-06T20:50:17Z\"\n        }\n      ],\n      \"signedArtifact\": {\n        \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n        \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b00369519a3c333\",\n        \"size\": 16724\n      }\n    },\n    {\n      \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b00369da519a3c333\",\n      \"signatureAlgorithm\": \"RSASSA-PSS-SHA-256\",\n      \"signedAttributes\": {\n        \"contentType\": \"application/vnd.cncf.notary.payload.v1+json\",\n        \"signingScheme\": \"notary.signingAuthority.x509\",\n        \"signingTime\": \"2022-02-06T20:50:17Z\",\n        \"expiry\": \"2023-02-06T20:50:17Z\",\n        \"io.cncf.notary.verificationPlugin\": \"com.example.nv2plugin\"\n      },\n      \"unsignedAttributes\": {\n        \"io.cncf.notary.timestampSignature\": \"<Base64(TimeStampToken)>\",\n        \"io.cncf.notary.signingAgent\": \"notation/1.0.0\"\n      },\n      \"certificates\": [\n        {\n          \"SHA256Fingerprint\": \"b13a843be16b1f461f08d61c14f3eab7d87c073570da077217541a7eb31c084d\",\n          \"issuedTo\": \"wabbit-com Software\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"4b9fa61d5aed0fabbc7cb8fe2efd049da57957ed44f2b98f7863ce18effd3b89\",\n          \"issuedTo\": \"wabbit-com Software Code Signing PCA\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2025-07-06T20:50:17Z\"\n        },\n        {\n          \"SHA256Fingerprint\": \"ea3939548ad0c0a86f164ab8b97858854238c797f30bddeba6cb28688f3f6536\",\n          \"issuedTo\": \"wabbit-com Software Root Certificate Authority\",\n          \"issuedBy\": \"wabbit-com Software Root Certificate Authority\",\n          \"expiry\": \"2035-07-06T20:50:17Z\"\n        }\n      ],\n      \"signedArtifact\": {\n        \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n        \"digest\": \"sha256:73c803930ea3ba1e54bc25c2bdc53edd0284c62ed651fe7b069da519a3c333\",\n        \"size\": 16724\n      }\n    }\n  ]\n}\n```\n", "# notation list\n\n## Description\n\nUse `notation list` to list all the signatures associated with signed artifact.\n\n`Tags` are mutable, but `Digests` uniquely and immutably identify an artifact. If a tag is used to identify a signed artifact, notation resolves the tag to the `digest` first.\n\nUpon successful execution, both the digest of the signed artifact and the digests of signatures manifest associated with signed artifact are printed out as following:\n\n```shell\n<registry>/<repository>@<digest>\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500<digest_of_signature_manifest>\n    \u2514\u2500\u2500<digest_of_signature_manifest>\n```\n\n## Outline\n\n```text\nList all the signatures associated with signed artifact\n\nUsage:\n  notation list [flags] <reference>\n\nAliases:\n  list, ls\n\nFlags:\n      --allow-referrers-api   [Experimental] use the Referrers API to list signatures, if not supported (returns 404), fallback to the Referrers tag schema\n  -d, --debug                 debug mode\n  -h, --help                  help for list\n      --insecure-registry     use HTTP protocol while connecting to registries. Should be used only for testing\n      --max-signatures int    maximum number of signatures to evaluate or examine (default 100)\n      --oci-layout            [Experimental] list signatures stored in OCI image layout\n  -p, --password string       password for registry operations (default to $NOTATION_PASSWORD if not specified)\n  -u, --username string       username for registry operations (default to $NOTATION_USERNAME if not specified)\n  -v, --verbose               verbose mode\n```\n\n## Usage\n\n### List all the signatures of the signed container image\n\n```shell\nnotation list <registry>/<repository>:<tag>\n```\n\nAn example output:\n\n```shell\nlocalhost:5000/net-monitor:v1\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:647039638efb22a021f59675c9449dd09956c981a44b82c1ff074513c2c9f273\n    \u2514\u2500\u2500 sha256:6bfb3c4fd485d6810f9656ddd4fb603f0c414c5f0b175ef90eeb4090ebd9bfa1\n```\n\n### [Experimental] List all the signatures associated with the image in OCI layout directory\n\nThe following example lists the signatures associated with the image in OCI layout directory named `hello-world`. To access this flag `--oci-layout` , set the environment variable `NOTATION_EXPERIMENTAL=1`.\n\nReference an image in OCI layout directory using tags:\n\n```shell\nexport NOTATION_EXPERIMENTAL=1\n# Assume OCI layout directory hello-world is under current path\nnotation list --oci-layout hello-world:v1\n```\n\nReference an image in OCI layout directory using exact digest:\n\n```shell\nexport NOTATION_EXPERIMENTAL=1\n# Assume OCI layout directory hello-world is under current path\nnotation list --oci-layout hello-world@sha256:xxx\n```\n\nAn example output:\n\n```shell\nhello-world@sha256:a08753c0c7bcdaaf5c2fdb375f68e860c34bffb146368982c201d41769e1763c\n\u2514\u2500\u2500 application/vnd.cncf.notary.signature\n    \u251c\u2500\u2500 sha256:647039638efb22a021f59675c9449dd09956c981a44b82c1ff074513c2c9f273\n    \u2514\u2500\u2500 sha256:6bfb3c4fd485d6810f9656ddd4fb603f0c414c5f0b175ef90eeb4090ebd9bfa1\n```\n", "# notation verify\n\n## Description\n\nUse `notation verify` command to verify signatures associated with the artifact. Signature verification succeeds if verification succeeds for at least one of the signatures associated with the artifact. Upon successful verification, the output message is printed out as follows:\n\n```text\nSuccessfully verified signature for <registry>/<repository>@<digest>\n```\n\nTags are mutable and a tag reference can point to a different artifact than that was signed referred by the same tag. If a `tag` is used to identify the OCI artifact, the output message is as follows:\n\n```text\nWarning:  Always verify the artifact using digest(@sha256:...) rather than a tag(:v1) because resolved digest may not point to the same signed artifact, as tags are mutable.\nSuccessfully verified signature for <registry>/<repository>@<digest>\n```\n\nA signature can have user defined metadata. If the signature for the OCI artifact contains any metadata, the output message is as follows:\n\n```text\nSuccessfully verified signature for <registry>/<repository>@<digest>\n\nThe artifact was signed with the following user metadata.\n\nKEY    VALUE\n<key>  <value>\n```\n\n## Outline\n\n```text\nVerify signatures associated with the artifact.\n\nUsage:\n  notation verify [flags] <reference>\n\nFlags:\n       --allow-referrers-api         [Experimental] use the Referrers API to verify signatures, if not supported (returns 404), fallback to the Referrers tag schema\n  -d,  --debug                       debug mode\n  -h,  --help                        help for verify\n       --insecure-registry           use HTTP protocol while connecting to registries. Should be used only for testing\n       --max-signatures int          maximum number of signatures to evaluate or examine (default 100)\n       --oci-layout                  [Experimental] verify the artifact stored as OCI image layout\n  -p,  --password string             password for registry operations (default to $NOTATION_PASSWORD if not specified)\n       --plugin-config stringArray   {key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values\n       --scope string                [Experimental] set trust policy scope for artifact verification, required and can only be used when flag \"--oci-layout\" is set\n  -u,  --username string             username for registry operations (default to $NOTATION_USERNAME if not specified)\n  -m,  --user-metadata stringArray   user defined {key}={value} pairs that must be present in the signature for successful verification if provided\n  -v,  --verbose                     verbose mode\n```\n\n## Usage\n\nPre-requisite: User needs to configure trust store and trust policy properly before using `notation verify` command.\n\n### Configure Trust Store\n\nUse `notation certificate` command to configure trust stores.\n\n### Configure Trust Policy\n\nUsers who consume signed artifact from a registry use the trust policy to specify trusted identities which sign the artifacts, and level of signature verification to use. The trust policy is a JSON document. User needs to create a file named `trustpolicy.json` under `{NOTATION_CONFIG}`. See [Notation Directory Structure](https://notaryproject.dev/docs/tutorials/directory-structure/) for `{NOTATION_CONFIG}`.\n\nAn example of `trustpolicy.json`:\n\n```jsonc\n{\n    \"version\": \"1.0\",\n    \"trustPolicies\": [\n        {\n            // Policy for all artifacts, from any registry location.\n            \"name\": \"wabbit-networks-images\",                         // Name of the policy.\n            \"registryScopes\": [ \"localhost:5000/net-monitor\" ],       // The registry artifacts to which the policy applies.\n            \"signatureVerification\": {                                // The level of verification - strict, permissive, audit, skip.\n                \"level\": \"strict\"\n            },\n            \"trustStores\": [ \"ca:wabbit-networks\" ],                  // The trust stores that contains the X.509 trusted roots.\n            \"trustedIdentities\": [                                    // Identities that are trusted to sign the artifact.\n                \"x509.subject: C=US, ST=WA, L=Seattle, O=wabbit-networks.io, OU=Finance, CN=SecureBuilder\"\n            ]\n        }\n    ]\n}\n```\n\nFor a Linux user, store file `trustpolicy.json` under directory `${HOME}/.config/notation/`.\n\nFor a MacOS user, store file `trustpolicy.json` under directory `${HOME}/Library/Application Support/notation/`.\n\nFor a Windows user, store file `trustpolicy.json` under directory `%USERPROFILE%\\AppData\\Roaming\\notation\\`.\n\nExample values on trust policy properties:\n\n| Property name         | Value                                                                                      | Meaning                                                                                                                                                            |\n| ----------------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| name                  | \"wabbit-networks-images\"                                                                   | The name of the policy is \"wabbit-networks-images\".                                                                                                                |\n| registryScopes        | \"localhost:5000/net-monitor\"                                                               | The policy only applies to artifacts stored in repository `localhost:5000/net-monitor`.                                                                            |\n| registryScopes        | \"localhost:5000/net-monitor\", \"localhost:5000/nginx\"                                       | The policy applies to artifacts stored in two repositories: `localhost:5000/net-monitor` and `localhost:5000/nginx`.                                               |\n| registryScopes        | \"*\"                                                                                        | The policy applies to all the artifacts stored in any repositories.                                                                                                |\n| signatureVerification | \"level\": \"strict\"                                                                          | Signature verification is performed at strict level, which enforces all validations: `integrity`, `authenticity`, `authentic timestamp`, `expiry` and `revocation`.|\n| signatureVerification | \"level\": \"permissive\"                                                                      | The permissive level enforces most validations, but will only logs failures for `revocation` and `expiry`.                                                         |\n| signatureVerification | \"level\": \"audit\"                                                                           | The audit level only enforces signature `integrity` if a signature is present. Failure of all other validations are only logged.                                   |\n| signatureVerification | \"level\": \"skip\"                                                                            | The skip level does not fetch signatures for artifacts and does not perform any signature verification.                                                            |\n| trustStores           | \"ca:wabbit-networks\"                                                                       | Specify the trust store that uses the format {trust-store-type}:{named-store}. The trust store is added using `notation certificate add` command.                  |\n| trustStores           | \"ca:wabbit-networks\", \"ca:rocket-networks\"                                                 | Specify two trust stores, each of which contains the trusted roots against which signatures are verified.                                                          |\n| trustedIdentities     | \"x509.subject: C=US, ST=WA, L=Seattle, O=wabbit-networks.io, OU=Finance, CN=SecureBuilder\" | User only trusts the identity with specific subject. User can use `notation certificate show` command to get the `subject` info.                                   |\n| trustedIdentities     | \"*\"                                                                                        | User trusts any identity (signing certificate) issued by the CA(s) in trust stores.                                                                                |\n\nUser can configure multiple trust policies for different scenarios. See [Trust Policy Schema and properties](https://github.com/notaryproject/notaryproject/blob/main/specs/trust-store-trust-policy.md#trust-policy) for details.\n\n### Verify signatures on an OCI artifact stored in a registry\n\nConfigure trust store and trust policy properly before using `notation verify` command.\n\n```shell\n\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\n# Configure trust store by adding a certificate file into trust store named \"wabbit-network\" of type \"ca\"\nnotation certificate add --type ca --store wabbit-networks wabbit-networks.crt\n\n# Create a JSON file named \"trustpolicy.json\" under directory \"{NOTATION_CONFIG}\".\n\n# Verify signatures on the supplied OCI artifact identified by the digest\nnotation verify localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\nAn example of output messages for a successful verification:\n\n```text\nSuccessfully verified signature for localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\n### Verify signatures on an OCI artifact with user metadata\n\nUse the `--user-metadata` flag to verify that provided key-value pairs are present in the payload of the valid signature.\n\n```shell\n# Verify signatures on the supplied OCI artifact identified by the digest and verify that io.wabbit-networks.buildId=123 is present in the signed payload\nnotation verify --user-metadata io.wabbit-networks.buildId=123 localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\nAn example of output messages for a successful verification:\n\n```text\nSuccessfully verified signature for localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n\nThe artifact is signed with the following user metadata.\n\nKEY                         VALUE\nio.wabbit-networks.buildId  123\n```\n\nAn example of output messages for an unsuccessful verification:\n\n```text\nError: signature verification failed: unable to find specified metadata in any signatures\n```\n\n### Verify signatures on an OCI artifact identified by a tag\n\nA tag is resolved to a digest first before verification.\n\n```shell\n# Prerequisites: Signatures are stored in a registry referencing the signed OCI artifact\n# Verify signatures on an OCI artifact identified by the tag\nnotation verify localhost:5000/net-monitor:v1\n```\n\nAn example of output messages for a successful verification:\n\n```text\nWarning:  Always verify the artifact using digest(@sha256:...) rather than a tag(:v1) because resolved digest may not point to the same signed artifact, as tags are mutable.\nSuccessfully verified signature for localhost:5000/net-monitor@sha256:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n```\n\n### [Experimental] Verify container images in OCI layout directory\n\nUsers should configure trust policy properly before verifying artifacts in OCI layout directory. According to trust policy specification, `registryScopes` property of trust policy configuration determines which trust policy is applicable for the given artifact. For example, an image stored in a remote registry is referenced by \"localhost:5000/net-monitor:v1\". In order to verify the image, the value of `registryScopes` should contain \"localhost:5000/net-monitor\", which is the repository URL of the image. However, the reference to the image stored in OCI layout directory doesn't contain repository URL information. Users can set `registryScopes` to the URL that the image is supposed to be stored in the registry, and then use flag `--scope` for `notation verify` command to determine which trust policy is used for verification. Here is an example of trust policy configured for image `hello-world:v1`:\n\n```jsonc\n{\n    \"name\": \"images stored as OCI layout\",\n    \"registryScopes\": [ \"local/hello-world\" ],\n    \"signatureVerification\": {\n        \"level\" : \"strict\"\n    },\n    \"trustStores\": [ \"ca:hello-world\" ],\n    \"trustedIdentities\": [\"*\"]\n}\n```\n\nTo verify image `hello-world:v1`, user should set the environment variable `NOTATION_EXPERIMENTAL` and use flags `--oci-layout` and `--scope` together. for example:\n\n```shell\nexport NOTATION_EXPERIMENTAL=1\n# Assume OCI layout directory hello-world is under current path\n# The value of --scope should be set base on the trust policy configuration\nnotation verify --oci-layout --scope \"local/hello-world\" hello-world:v1\n```\n"], "filenames": ["cmd/notation/inspect.go", "cmd/notation/inspect_test.go", "cmd/notation/internal/errors/errors.go", "cmd/notation/list.go", "cmd/notation/list_test.go", "cmd/notation/verify.go", "cmd/notation/verify_test.go", "specs/commandline/inspect.md", "specs/commandline/list.md", "specs/commandline/verify.md"], "buggy_code_start_loc": [16, 19, 1, 8, 16, 6, 17, 39, 33, 41], "buggy_code_end_loc": [186, 48, 27, 122, 42, 132, 43, 39, 33, 41], "fixing_code_start_loc": [17, 19, 2, 9, 17, 5, 17, 40, 34, 42], "fixing_code_end_loc": [195, 50, 40, 143, 45, 132, 45, 41, 35, 43], "type": "CWE-400", "message": "notation is a CLI tool to sign and verify OCI artifacts and container images. An attacker who has compromised a registry and added a high number of signatures to an artifact can cause denial of service of services on the machine, if a user runs notation inspect command on the same machine. The problem has been fixed in the release v1.0.0-rc.6. Users should upgrade their notation packages to v1.0.0-rc.6 or above. Users are advised to upgrade. Users unable to upgrade may restrict container registries to a set of secure and trusted container registries.", "other": {"cve": {"id": "CVE-2023-33957", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-06T19:15:12.363", "lastModified": "2024-02-29T21:16:49.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "notation is a CLI tool to sign and verify OCI artifacts and container images. An attacker who has compromised a registry and added a high number of signatures to an artifact can cause denial of service of services on the machine, if a user runs notation inspect command on the same machine. The problem has been fixed in the release v1.0.0-rc.6. Users should upgrade their notation packages to v1.0.0-rc.6 or above. Users are advised to upgrade. Users unable to upgrade may restrict container registries to a set of secure and trusted container registries."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "E048A2E7-0021-480A-AD91-F07F8BFDE9CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "A6851C33-6C20-4B20-B26F-E258C681265E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "99878E6C-4778-4ECE-9E29-D2A1AFB9DB82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "0B583E52-5510-42E2-AD05-F574ACCB13E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:1.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "C23C91C1-C4D1-47AC-B167-CCFF71A00C5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:1.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "EB72FE70-F2E3-4540-A6BE-2EE0DB662365"}]}]}], "references": [{"url": "https://github.com/notaryproject/notation/commit/ed22fde52f6d70ae0b53521bd28c9ccafa868c24", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/notaryproject/notation/security/advisories/GHSA-9m3v-v4r5-ppx7", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/notaryproject/notation/commit/ed22fde52f6d70ae0b53521bd28c9ccafa868c24"}}