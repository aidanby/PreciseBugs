{"buggy_code": ["$Id: Changelog.txt,v 1.43 2015/08/06 14:05:49 nanard Exp $\n\nVERSION 1.5:\n\n2016/01/13:\n\tadd \"notification\" mode (command 5)\n\n2015/08/06:\n\tdisable multicast loop\n\tadd -f command line option to filter for a specific device type\n\nVERSION 1.4:\n\n2015/08/06:\n\tadded command 0 (version)\n\n2015/07/21:\n\tset multicast TTL to 2 by default and configurable\n\n2015/05/27:\n\tsupport larger buffer size (useful for type 3 requests)\n\nVERSION 1.3:\n\n2014/12/05:\n\tclean up select call()\n\tfix non blocking write to sockets\n\n2014/12/04:\n\tFixes removing of devices on ssdp:byebye\n\thandle ssdp:update messages\n\n2014/11/28:\n\trevert \"listen on only 1 IPv4 if only 1 interface is specified\"\n\tbecause it prevents broadcast messages to be received\n\tChange the list of LAN addresses/interfaces (code taken from miniupnpd)\n\tCheck that the peer is from a LAN for each SSDP packet\n\n2014/11/06:\n\tlisten on only 1 IPv4 if only 1 interface is specified\n\talso when ENABLE_IPV6 is not defined\n\n2014/09/06:\n\tfreebsd-glue for Debian/kFreeBSD\n\tuse LDFLAGS when linking binary\n\n2014/05/01:\n\tlisten on only 1 IPv4 if only 1 interface is specified\n\n2014/02/03:\n\tsilently ignore EAGAIN, EWOULDBLOCK, EINTR of recv calls\n\tDiscover devices on the network at startup\n\n2013/08/19:\n\tTranslate README in english\n\n2012/09/27:\n\tRename all include guards to not clash with C99\n\t(7.1.3 Reserved identifiers).\n\nVERSION 1.2:\n\n2012/05/21:\n\tClean signal handling\n\tSet sockets non blocking\n\n2012/05/18:\n\tImprove ProcessInterfaceWatch() under BSD.\n\n2012/05/15:\n\tImprove ProcessInterfaceWatch() under linux.\n\n2012/05/02:\n\tClean CLFAGS in Makefile.\n\tRemove a few signed/unsigned compares\n\n2012/04/09:\n\tAdded -ansi to compilation flags.\n\tHandle ssdp:update messages and update logging\n\n2012/01/02:\n\tInstall manpage. Fix installation under Mac OS X.\n\n2011/10/07:\n\tunlink unix socket before binding.\n\tset SO_REUSEADDR on SSDP socket.\n\tdaemonize after init\n\nVERSION 1.1:\n\n2011/07/30:\n\tfixes. More overflow checks\n\n2011/07/29:\n\tadded a lot of buffer overflow checks. Check malloc() failure, etc.\n\tBetter cleanup in case of crash at start.\n\tnetwork interface watch to add/drop multicast membership when the interface get live.\n\n2011/06/18:\n\tStarting to add support for UPnP Device Architecture v1.1\n\n2011/05/23:\n\tAdded IPv6 support.\n\t-i option now understands interface names as well as addresses.\n\nVERSION 1.0:\n\n2008/10/07:\n\tadded codelength.h\n\tFixing response to M-SEARCH\n\tDoc update\n\n2008/10/06:\n\tUPnP server support (answering M-SEARCH)\n\n2008/10/04:\n\tlistening on several interfaces.\n\n2008/10/01:\n\tuse of daemon() instead of home made daemonize.\n\n2007/12/19:\n\tadded uuid in responses\n\t3 types of requests supported.\n\tpreventing buffer overflow\n\n2007/12/18:\n\tIt is now possible to change the location of both pid file and\n\tunix socket.\n\n2007/10/08:\n\tAdded a man page\n\n2007/09/27:\n\tSupport for install in different location $ PREFIX=... make install\n\n2007/09/23:\n\tadded a script for use in /etc/init.d\n\timproved Makefile\n\tcreating /var/run/minissdpd.pid\n\tadding synthetic messages for new devices/removed devices\n\n2007/09/19:\n\tTake SSDP announce packets lifetime into account.\n\n", "/* $Id: minissdpd.c,v 1.50 2015/08/06 14:05:49 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * (c) 2007-2016 Thomas Bernard\n * website : http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/queue.h>\n/* for chmod : */\n#include <sys/stat.h>\n/* unix sockets */\n#include <sys/un.h>\n/* for getpwnam() and getgrnam() */\n#if 0\n#include <pwd.h>\n#include <grp.h>\n#endif\n\n#include \"getifaddr.h\"\n#include \"upnputils.h\"\n#include \"openssdpsocket.h\"\n#include \"daemonize.h\"\n#include \"codelength.h\"\n#include \"ifacewatch.h\"\n#include \"minissdpdtypes.h\"\n#include \"asyncsendto.h\"\n\n#define SET_MAX(max, x)\tif((x) > (max)) (max) = (x)\n\n/* current request management stucture */\nstruct reqelem {\n\tint socket;\n\tint is_notify;\t/* has subscribed to notifications */\n\tLIST_ENTRY(reqelem) entries;\n\tunsigned char * output_buffer;\n\tint output_buffer_offset;\n\tint output_buffer_len;\n};\n\n/* device data structures */\nstruct header {\n\tconst char * p; /* string pointer */\n\tint l;          /* string length */\n};\n\n#define HEADER_NT\t0\n#define HEADER_USN\t1\n#define HEADER_LOCATION\t2\n\nstruct device {\n\tstruct device * next;\n\ttime_t t;                 /* validity time */\n\tstruct header headers[3]; /* NT, USN and LOCATION headers */\n\tchar data[];\n};\n\n/* Services stored for answering to M-SEARCH */\nstruct service {\n\tchar * st;\t/* Service type */\n\tchar * usn;\t/* Unique identifier */\n\tchar * server;\t/* Server string */\n\tchar * location;\t/* URL */\n\tLIST_ENTRY(service) entries;\n};\nLIST_HEAD(servicehead, service) servicelisthead;\n\n#define NTS_SSDP_ALIVE\t1\n#define NTS_SSDP_BYEBYE\t2\n#define NTS_SSDP_UPDATE\t3\n\n/* request types */\nenum request_type {\n\tMINISSDPD_GET_VERSION = 0,\n\tMINISSDPD_SEARCH_TYPE = 1,\n\tMINISSDPD_SEARCH_USN = 2,\n\tMINISSDPD_SEARCH_ALL = 3,\n\tMINISSDPD_SUBMIT = 4,\n\tMINISSDPD_NOTIF = 5\n};\n\n/* discovered device list kept in memory */\nstruct device * devlist = 0;\n\n/* bootid and configid */\nunsigned int upnp_bootid = 1;\nunsigned int upnp_configid = 1337;\n\n/* LAN interfaces/addresses */\nstruct lan_addr_list lan_addrs;\n\n/* connected clients */\nLIST_HEAD(reqstructhead, reqelem) reqlisthead;\n\n/* functions prototypes */\n\n#define NOTIF_NEW    1\n#define NOTIF_UPDATE 2\n#define NOTIF_REMOVE 3\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv);\n\n/* functions */\n\n/* parselanaddr()\n * parse address with mask\n * ex: 192.168.1.1/24 or 192.168.1.1/255.255.255.0\n *\n * Can also use the interface name (ie eth0)\n *\n * return value :\n *    0 : ok\n *   -1 : error */\nstatic int\nparselanaddr(struct lan_addr_s * lan_addr, const char * str)\n{\n\tconst char * p;\n\tint n;\n\tchar tmp[16];\n\n\tmemset(lan_addr, 0, sizeof(struct lan_addr_s));\n\tp = str;\n\twhile(*p && *p != '/' && !isspace(*p))\n\t\tp++;\n\tn = p - str;\n\tif(!isdigit(str[0]) && n < (int)sizeof(lan_addr->ifname)) {\n\t\t/* not starting with a digit : suppose it is an interface name */\n\t\tmemcpy(lan_addr->ifname, str, n);\n\t\tlan_addr->ifname[n] = '\\0';\n\t\tif(getifaddr(lan_addr->ifname, lan_addr->str, sizeof(lan_addr->str),\n\t\t             &lan_addr->addr, &lan_addr->mask) < 0)\n\t\t\tgoto parselan_error;\n\t\t/*printf(\"%s => %s\\n\", lan_addr->ifname, lan_addr->str);*/\n\t} else {\n\t\tif(n>15)\n\t\t\tgoto parselan_error;\n\t\tmemcpy(lan_addr->str, str, n);\n\t\tlan_addr->str[n] = '\\0';\n\t\tif(!inet_aton(lan_addr->str, &lan_addr->addr))\n\t\t\tgoto parselan_error;\n\t}\n\tif(*p == '/') {\n\t\tconst char * q = ++p;\n\t\twhile(*p && isdigit(*p))\n\t\t\tp++;\n\t\tif(*p=='.') {\n\t\t\t/* parse mask in /255.255.255.0 format */\n\t\t\twhile(*p && (*p=='.' || isdigit(*p)))\n\t\t\t\tp++;\n\t\t\tn = p - q;\n\t\t\tif(n>15)\n\t\t\t\tgoto parselan_error;\n\t\t\tmemcpy(tmp, q, n);\n\t\t\ttmp[n] = '\\0';\n\t\t\tif(!inet_aton(tmp, &lan_addr->mask))\n\t\t\t\tgoto parselan_error;\n\t\t} else {\n\t\t\t/* it is a /24 format */\n\t\t\tint nbits = atoi(q);\n\t\t\tif(nbits > 32 || nbits < 0)\n\t\t\t\tgoto parselan_error;\n\t\t\tlan_addr->mask.s_addr = htonl(nbits ? (0xffffffffu << (32 - nbits)) : 0);\n\t\t}\n\t} else if(lan_addr->mask.s_addr == 0) {\n\t\t/* by default, networks are /24 */\n\t\tlan_addr->mask.s_addr = htonl(0xffffff00u);\n\t}\n#ifdef ENABLE_IPV6\n\tif(lan_addr->ifname[0] != '\\0') {\n\t\tlan_addr->index = if_nametoindex(lan_addr->ifname);\n\t\tif(lan_addr->index == 0)\n\t\t\tfprintf(stderr, \"Cannot get index for network interface %s\",\n\t\t\t        lan_addr->ifname);\n\t} else {\n\t\tfprintf(stderr,\n\t\t        \"Error: please specify LAN network interface by name instead of IPv4 address : %s\\n\",\n\t\t        str);\n\t\treturn -1;\n\t}\n#endif /* ENABLE_IPV6 */\n\treturn 0;\nparselan_error:\n\tfprintf(stderr, \"Error parsing address/mask (or interface name) : %s\\n\",\n\t        str);\n\treturn -1;\n}\n\nstatic int\nwrite_buffer(struct reqelem * req)\n{\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\tint n = write(req->socket,\n\t\t              req->output_buffer + req->output_buffer_offset,\n\t\t              req->output_buffer_len);\n\t\tif(n >= 0) {\n\t\t\treq->output_buffer_offset += n;\n\t\t\treq->output_buffer_len -= n;\n\t\t} else if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn n;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int\nadd_to_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tunsigned char * tmp;\n\tif(req->output_buffer_offset > 0) {\n\t\tmemmove(req->output_buffer, req->output_buffer + req->output_buffer_offset, req->output_buffer_len);\n\t\treq->output_buffer_offset = 0;\n\t}\n\ttmp = realloc(req->output_buffer, req->output_buffer_len + len);\n\tif(tmp == NULL) {\n\t\tsyslog(LOG_ERR, \"%s: failed to allocate %d bytes\",\n\t\t       __func__, req->output_buffer_len + len);\n\t\treturn -1;\n\t}\n\treq->output_buffer = tmp;\n\tmemcpy(req->output_buffer + req->output_buffer_len, data, len);\n\treq->output_buffer_len += len;\n\treturn len;\n}\n\nstatic int\nwrite_or_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tif(write_buffer(req) < 0)\n\t\treturn -1;\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\treturn add_to_buffer(req, data, len);\n\t} else {\n\t\tint n = write(req->socket, data, len);\n\t\tif(n == len)\n\t\t\treturn len;\n\t\tif(n < 0) {\n\t\t\tif(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\t\tn = add_to_buffer(req, data, len);\n\t\t\t\tif(n < 0) return n;\n\t\t\t} else {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} else {\n\t\t\tn = add_to_buffer(req, data + n, len - n);\n\t\t\tif(n < 0) return n;\n\t\t}\n\t}\n\treturn len;\n}\n\nstatic const char *\nnts_to_str(int nts)\n{\n\tswitch(nts)\n\t{\n\tcase NTS_SSDP_ALIVE:\n\t\treturn \"ssdp:alive\";\n\tcase NTS_SSDP_BYEBYE:\n\t\treturn \"ssdp:byebye\";\n\tcase NTS_SSDP_UPDATE:\n\t\treturn \"ssdp:update\";\n\t}\n\treturn \"unknown\";\n}\n\n/* updateDevice() :\n * adds or updates the device to the list.\n * return value :\n *   0 : the device was updated (or nothing done)\n *   1 : the device was new    */\nstatic int\nupdateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}\n\n/* removeDevice() :\n * remove a device from the list\n * return value :\n *    0 : no device removed\n *   -1 : device removed */\nstatic int\nremoveDevice(const struct header * headers)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"remove device : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tsendNotifications(NOTIF_REMOVE, p, NULL);\n\t\t\t*pp = p->next;\n\t\t\tfree(p);\n\t\t\treturn -1;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_WARNING, \"device not found for removing : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\treturn 0;\n}\n\n/* sent notifications to client having subscribed */\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv)\n{\n\tstruct reqelem * req;\n\tunsigned int m;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\n\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\tif(!req->is_notify) continue;\n\t\trbuf[0] = '\\xff'; /* special code for notifications */\n\t\trbuf[1] = (unsigned char)notif_type;\n\t\trbuf[2] = 0;\n\t\trp = rbuf + 3;\n\t\tif(dev) {\n\t\t\t/* response :\n\t\t\t * 1 - Location\n\t\t\t * 2 - NT (device/service type)\n\t\t\t * 3 - usn */\n\t\t\tm = dev->headers[HEADER_LOCATION].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_LOCATION].p, dev->headers[HEADER_LOCATION].l);\n\t\t\trp += dev->headers[HEADER_LOCATION].l;\n\t\t\tm = dev->headers[HEADER_NT].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_NT].p, dev->headers[HEADER_NT].l);\n\t\t\trp += dev->headers[HEADER_NT].l;\n\t\t\tm = dev->headers[HEADER_USN].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_USN].p, dev->headers[HEADER_USN].l);\n\t\t\trp += dev->headers[HEADER_USN].l;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(serv) {\n\t\t\t/* response :\n\t\t\t * 1 - Location\n\t\t\t * 2 - NT (device/service type)\n\t\t\t * 3 - usn */\n\t\t\tm = strlen(serv->location);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->location, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->st);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->st, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->usn);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\trp += m;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(rbuf[2] > 0) {\n\t\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\t\t/*goto error;*/\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* SendSSDPMSEARCHResponse() :\n * build and send response to M-SEARCH SSDP packets. */\nstatic void\nSendSSDPMSEARCHResponse(int s, const struct sockaddr * sockname,\n                        const char * st, const char * usn,\n                        const char * server, const char * location)\n{\n\tint l, n;\n\tchar buf[512];\n\tsocklen_t sockname_len;\n\t/*\n\t * follow guideline from document \"UPnP Device Architecture 1.0\"\n\t * uppercase is recommended.\n\t * DATE: is recommended\n\t * SERVER: OS/ver UPnP/1.0 miniupnpd/1.0\n\t * - check what to put in the 'Cache-Control' header\n\t *\n\t * have a look at the document \"UPnP Device Architecture v1.1 */\n\tl = snprintf(buf, sizeof(buf), \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\"CACHE-CONTROL: max-age=120\\r\\n\"\n\t\t/*\"DATE: ...\\r\\n\"*/\n\t\t\"ST: %s\\r\\n\"\n\t\t\"USN: %s\\r\\n\"\n\t\t\"EXT:\\r\\n\"\n\t\t\"SERVER: %s\\r\\n\"\n\t\t\"LOCATION: %s\\r\\n\"\n\t\t\"OPT: \\\"http://schemas.upnp.org/upnp/1/0/\\\"; ns=01\\r\\n\" /* UDA v1.1 */\n\t\t\"01-NLS: %u\\r\\n\" /* same as BOOTID. UDA v1.1 */\n\t\t\"BOOTID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"CONFIGID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"\\r\\n\",\n\t\tst, usn,\n\t\tserver, location,\n\t\tupnp_bootid, upnp_bootid, upnp_configid);\n#ifdef ENABLE_IPV6\n\tsockname_len = (sockname->sa_family == PF_INET6)\n\t             ? sizeof(struct sockaddr_in6)\n\t             : sizeof(struct sockaddr_in);\n#else\t/* ENABLE_IPV6 */\n\tsockname_len = sizeof(struct sockaddr_in);\n#endif\t/* ENABLE_IPV6 */\n\tn = sendto_or_schedule(s, buf, l, 0, sockname, sockname_len);\n\tif(n < 0) {\n\t\tsyslog(LOG_ERR, \"%s: sendto(udp): %m\", __func__);\n\t}\n}\n\n/* Process M-SEARCH requests */\nstatic void\nprocessMSEARCH(int s, const char * st, int st_len,\n               const struct sockaddr * addr)\n{\n\tstruct service * serv;\n#ifdef ENABLE_IPV6\n\tchar buf[64];\n#endif /* ENABLE_IPV6 */\n\n\tif(!st || st_len==0)\n\t\treturn;\n#ifdef ENABLE_IPV6\n\tsockaddr_to_string(addr, buf, sizeof(buf));\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s ST:%.*s\",\n\t       buf, st_len, st);\n#else\t/* ENABLE_IPV6 */\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s:%d ST: %.*s\",\n\t       inet_ntoa(((const struct sockaddr_in *)addr)->sin_addr),\n\t       ntohs(((const struct sockaddr_in *)addr)->sin_port),\n\t       st_len, st);\n#endif\t/* ENABLE_IPV6 */\n\tif(st_len==8 && (0==memcmp(st, \"ssdp:all\", 8))) {\n\t\t/* send a response for all services */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t                        serv->st, serv->usn,\n\t\t\t                        serv->server, serv->location);\n\t\t}\n\t} else if(st_len > 5 && (0==memcmp(st, \"uuid:\", 5))) {\n\t\t/* find a matching UUID value */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->usn, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* find matching services */\n\t\t/* remove version at the end of the ST string */\n\t\tif(st[st_len-2]==':' && isdigit(st[st_len-1]))\n\t\t\tst_len -= 2;\n\t\t/* answer for each matching service */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->st, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * helper function.\n * reject any non ASCII or non printable character.\n */\nstatic int\ncontainsForbiddenChars(const unsigned char * p, int len)\n{\n\twhile(len > 0) {\n\t\tif(*p < ' ' || *p >= '\\x7f')\n\t\t\treturn 1;\n\t\tp++;\n\t\tlen--;\n\t}\n\treturn 0;\n}\n\n#define METHOD_MSEARCH 1\n#define METHOD_NOTIFY 2\n\n/* ParseSSDPPacket() :\n * parse a received SSDP Packet and call\n * updateDevice() or removeDevice() as needed\n * return value :\n *    -1 : a device was removed\n *     0 : no device removed nor added\n *     1 : a device was added.  */\nstatic int\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr,\n                const char * searched_device)\n{\n\tconst char * linestart;\n\tconst char * lineend;\n\tconst char * nameend;\n\tconst char * valuestart;\n\tstruct header headers[3];\n\tint i, r = 0;\n\tint methodlen;\n\tint nts = -1;\n\tint method = -1;\n\tunsigned int lifetime = 180;\t/* 3 minutes by default */\n\tconst char * st = NULL;\n\tint st_len = 0;\n\n\t/* first check from what subnet is the sender */\n\tif(get_lan_for_peer(addr) == NULL) {\n\t\tchar addr_str[64];\n\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\tsyslog(LOG_WARNING, \"peer %s is not from a LAN\",\n\t\t       addr_str);\n\t\treturn 0;\n\t}\n\n\t/* do the parsing */\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\t\tmethod = METHOD_MSEARCH;\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t\t/* answer to a M-SEARCH => process it as a NOTIFY\n\t\t * with NTS: ssdp:alive */\n\t\tmethod = METHOD_NOTIFY;\n\t\tnts = NTS_SSDP_ALIVE;\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\t/* start parsing the line : detect line end */\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\t/*printf(\"line: '%.*s'\\n\", lineend - linestart, linestart);*/\n\t\t/* detect name end : ':' character */\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\t/* detect value */\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\t/* trim spaces */\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\t/* suppress leading \" if needed */\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint l = nameend - linestart;\t/* header name length */\n\t\t\tint m = lineend - valuestart;\t/* header value length */\n\t\t\t/* suppress tailing spaces */\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\t/* suppress tailing ' if needed */\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\ti = -1;\n\t\t\t/*printf(\"--%.*s: (%d)%.*s--\\n\", l, linestart,\n\t\t\t                           m, m, valuestart);*/\n\t\t\tif(l==2 && 0==strncasecmp(linestart, \"nt\", 2))\n\t\t\t\ti = HEADER_NT;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t\tif(m==10 && 0==strncasecmp(valuestart, \"ssdp:alive\", 10))\n\t\t\t\t\tnts = NTS_SSDP_ALIVE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:byebye\", 11))\n\t\t\t\t\tnts = NTS_SSDP_BYEBYE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:update\", 11))\n\t\t\t\t\tnts = NTS_SSDP_UPDATE;\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\t/* parse \"name1=value1, name_alone, name2=value2\" string */\n\t\t\t\tconst char * name = valuestart;\t/* name */\n\t\t\t\tconst char * val;\t\t\t\t/* value */\n\t\t\t\tint rem = m;\t/* remaining bytes to process */\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\t/* move to the next name=value pair */\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* skip spaces */\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*syslog(LOG_DEBUG, \"**%.*s**%u\", m, valuestart, lifetime);*/\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\t\t\tst = valuestart;\n\t\t\t\tst_len = m;\n\t\t\t\tif(method == METHOD_NOTIFY)\n\t\t\t\t\ti = HEADER_NT;\t/* it was a M-SEARCH response */\n\t\t\t}\n\t\t\tif(i>=0) {\n\t\t\t\theaders[i].p = valuestart;\n\t\t\t\theaders[i].l = m;\n\t\t\t}\n\t\t}\n\t\tlinestart = lineend;\n\t\twhile((*linestart == '\\n' || *linestart == '\\r') && linestart < p + n)\n\t\t\tlinestart++;\n\t}\n#if 0\n\tprintf(\"NTS=%d\\n\", nts);\n\tfor(i=0; i<3; i++) {\n\t\tif(headers[i].p)\n\t\t\tprintf(\"%d-'%.*s'\\n\", i, headers[i].l, headers[i].p);\n\t}\n#endif\n\tsyslog(LOG_DEBUG,\"SSDP request: '%.*s' (%d) %s %s=%.*s\",\n\t       methodlen, p, method, nts_to_str(nts),\n\t       (method==METHOD_NOTIFY)?\"nt\":\"st\",\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].l:st_len,\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].p:st);\n\tswitch(method) {\n\tcase METHOD_NOTIFY:\n\t\tif(nts==NTS_SSDP_ALIVE || nts==NTS_SSDP_UPDATE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p && headers[HEADER_LOCATION].p) {\n\t\t\t\t/* filter if needed */\n\t\t\t\tif(searched_device &&\n\t\t\t\t   0 != memcmp(headers[HEADER_NT].p, searched_device, headers[HEADER_NT].l))\n\t\t\t\t\tbreak;\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p location=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p,\n\t\t\t\t       headers[HEADER_LOCATION].p);\n\t\t\t}\n\t\t} else if(nts==NTS_SSDP_BYEBYE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p) {\n\t\t\t\tr = removeDevice(headers);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase METHOD_MSEARCH:\n\t\tprocessMSEARCH(s, st, st_len, addr);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tchar addr_str[64];\n\t\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\t\tsyslog(LOG_WARNING, \"method %.*s, don't know what to do (from %s)\",\n\t\t\t       methodlen, p, addr_str);\n\t\t}\n\t}\n\treturn r;\n}\n\n/* OpenUnixSocket()\n * open the unix socket and call bind() and listen()\n * return -1 in case of error */\nstatic int\nOpenUnixSocket(const char * path)\n{\n\tstruct sockaddr_un addr;\n\tint s;\n\tint rv;\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif(s < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"socket(AF_UNIX): %m\");\n\t\treturn -1;\n\t}\n\t/* unlink the socket pseudo file before binding */\n\trv = unlink(path);\n\tif(rv < 0 && errno != ENOENT)\n\t{\n\t\tsyslog(LOG_ERR, \"unlink(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, path, sizeof(addr.sun_path));\n\tif(bind(s, (struct sockaddr *)&addr,\n\t           sizeof(struct sockaddr_un)) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"bind(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\telse if(listen(s, 5) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"listen(unixsocket): %m\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\t/* Change rights so everyone can communicate with us */\n\tif(chmod(path, 0666) < 0)\n\t{\n\t\tsyslog(LOG_WARNING, \"chmod(\\\"%s\\\"): %m\", path);\n\t}\n\treturn s;\n}\n\n/* processRequest() :\n * process the request coming from a unix socket */\nvoid processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tenum request_type type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t/* try again later */\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding l=%u n=%u)\",\n\t\t       l, (unsigned)n);\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != MINISSDPD_SEARCH_ALL\n\t   && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0, type=%d)\", type);\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase MINISSDPD_GET_VERSION:\n\t\trp = rbuf;\n\t\tCODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);\n\t\tmemcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);\n\t\trp += (sizeof(MINISSDPD_VERSION) - 1);\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase MINISSDPD_SEARCH_TYPE:\t/* request by type */\n\tcase MINISSDPD_SEARCH_USN:\t/* request by USN (unique id) */\n\tcase MINISSDPD_SEARCH_ALL:\t/* everything */\n\t\trp = rbuf+1;\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\t/* test if we can put more responses in the buffer */\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\t\t/* response :\n\t\t\t\t\t * 1 - Location\n\t\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t\t * 3 - usn */\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\t/* Also look in service list */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\t/* test if we can put more responses in the buffer */\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\t/* response :\n\t\t\t\t * 1 - Location\n\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t * 3 - usn */\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase MINISSDPD_SUBMIT:\t/* submit service */\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(newserv, 0, sizeof(struct service));\t/* set pointers to NULL */\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\t/* look in service list for duplicate */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service already in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* Inserting new service */\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tsendNotifications(NOTIF_NEW, NULL, newserv);\n\t\tnewserv = NULL;\n\t\tbreak;\n\tcase MINISSDPD_NOTIF:\t/* switch socket to notify */\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\treq->is_notify = 1;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\n\nstatic volatile sig_atomic_t quitting = 0;\n/* SIGTERM signal handler */\nstatic void\nsigterm(int sig)\n{\n\t(void)sig;\n\t/*int save_errno = errno;*/\n\t/*signal(sig, SIG_IGN);*/\n#if 0\n\t/* calling syslog() is forbidden in a signal handler according to\n\t * signal(3) */\n\tsyslog(LOG_NOTICE, \"received signal %d, good-bye\", sig);\n#endif\n\tquitting = 1;\n\t/*errno = save_errno;*/\n}\n\n#define PORT 1900\n#define XSTR(s) STR(s)\n#define STR(s) #s\n#define UPNP_MCAST_ADDR \"239.255.255.250\"\n/* for IPv6 */\n#define UPNP_MCAST_LL_ADDR \"FF02::C\" /* link-local */\n#define UPNP_MCAST_SL_ADDR \"FF05::C\" /* site-local */\n\n/* send the M-SEARCH request for devices\n * either all devices (third argument is NULL or \"*\") or a specific one */\nstatic void ssdpDiscover(int s, int ipv6, const char * search)\n{\n\tstatic const char MSearchMsgFmt[] =\n\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\"HOST: %s:\" XSTR(PORT) \"\\r\\n\"\n\t\"ST: %s\\r\\n\"\n\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\"MX: %u\\r\\n\"\n\t\"\\r\\n\";\n\tchar bufr[512];\n\tint n;\n\tint mx = 3;\n\tint linklocal = 1;\n\tstruct sockaddr_storage sockudp_w;\n\n\t{\n\t\tn = snprintf(bufr, sizeof(bufr),\n\t\t             MSearchMsgFmt,\n\t\t             ipv6 ?\n\t\t             (linklocal ? \"[\" UPNP_MCAST_LL_ADDR \"]\" :  \"[\" UPNP_MCAST_SL_ADDR \"]\")\n\t\t             : UPNP_MCAST_ADDR,\n\t\t             (search ? search : \"ssdp:all\"), mx);\n\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_storage));\n\t\tif(ipv6) {\n\t\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_w;\n\t\t\tp->sin6_family = AF_INET6;\n\t\t\tp->sin6_port = htons(PORT);\n\t\t\tinet_pton(AF_INET6,\n\t\t\t          linklocal ? UPNP_MCAST_LL_ADDR : UPNP_MCAST_SL_ADDR,\n\t\t\t          &(p->sin6_addr));\n\t\t} else {\n\t\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_w;\n\t\t\tp->sin_family = AF_INET;\n\t\t\tp->sin_port = htons(PORT);\n\t\t\tp->sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n\t\t}\n\n\t\tn = sendto_or_schedule(s, bufr, n, 0, (const struct sockaddr *)&sockudp_w,\n\t\t                       ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\t\tif (n < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: sendto: %m\", __func__);\n\t\t}\n\t}\n}\n\n/* main(): program entry point */\nint main(int argc, char * * argv)\n{\n\tint ret = 0;\n\tint pid;\n\tstruct sigaction sa;\n\tchar buf[1500];\n\tssize_t n;\n\tint s_ssdp = -1;\t/* udp socket receiving ssdp packets */\n#ifdef ENABLE_IPV6\n\tint s_ssdp6 = -1;\t/* udp socket receiving ssdp packets IPv6*/\n#else\t/* ENABLE_IPV6 */\n#define s_ssdp6 (-1)\n#endif\t/* ENABLE_IPV6 */\n\tint s_unix = -1;\t/* unix socket communicating with clients */\n\tint s_ifacewatch = -1;\t/* socket to receive Route / network interface config changes */\n\tstruct reqelem * req;\n\tstruct reqelem * reqnext;\n\tfd_set readfds;\n\tfd_set writefds;\n\tstruct timeval now;\n\tint max_fd;\n\tstruct lan_addr_s * lan_addr;\n\tint i;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tconst char * pidfilename = \"/var/run/minissdpd.pid\";\n\tint debug_flag = 0;\n#ifdef ENABLE_IPV6\n\tint ipv6 = 0;\n#endif /* ENABLE_IPV6 */\n\tint deltadev = 0;\n\tstruct sockaddr_in sendername;\n\tsocklen_t sendername_len;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 sendername6;\n\tsocklen_t sendername6_len;\n#endif\t/* ENABLE_IPV6 */\n\tunsigned char ttl = 2;\t/* UDA says it should default to 2 */\n\tconst char * searched_device = NULL;\t/* if not NULL, search/filter a specific device type */\n\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&servicelisthead);\n\tLIST_INIT(&lan_addrs);\n\t/* process command line */\n\tfor(i=1; i<argc; i++)\n\t{\n \t\tif(0==strcmp(argv[i], \"-d\"))\n\t\t\tdebug_flag = 1;\n#ifdef ENABLE_IPV6\n\t\telse if(0==strcmp(argv[i], \"-6\"))\n\t\t\tipv6 = 1;\n#endif\t/* ENABLE_IPV6 */\n\t\telse {\n\t\t\tif((i + 1) >= argc) {\n\t\t\t\tfprintf(stderr, \"option %s needs an argument.\\n\", argv[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(0==strcmp(argv[i], \"-i\")) {\n\t\t\t\tlan_addr = malloc(sizeof(struct lan_addr_s));\n\t\t\t\tif(lan_addr == NULL) {\n\t\t\t\t\tfprintf(stderr, \"malloc(%d) FAILED\\n\", (int)sizeof(struct lan_addr_s));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(parselanaddr(lan_addr, argv[++i]) != 0) {\n\t\t\t\t\tfprintf(stderr, \"can't parse \\\"%s\\\" as a valid address or interface name\\n\", argv[i]);\n\t\t\t\t\tfree(lan_addr);\n\t\t\t\t} else {\n\t\t\t\t\tLIST_INSERT_HEAD(&lan_addrs, lan_addr, list);\n\t\t\t\t}\n\t\t\t} else if(0==strcmp(argv[i], \"-s\"))\n\t\t\t\tsockpath = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\t\tpidfilename = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-t\"))\n\t\t\t\tttl = (unsigned char)atoi(argv[++i]);\n\t\t\telse if(0==strcmp(argv[i], \"-f\"))\n\t\t\t\tsearched_device = argv[++i];\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"unknown commandline option %s.\\n\", argv[i]);\n\t\t}\n\t}\n\tif(lan_addrs.lh_first == NULL)\n\t{\n\t\tfprintf(stderr,\n\t\t        \"Usage: %s [-d] \"\n#ifdef ENABLE_IPV6\n\t\t        \"[-6] \"\n#endif /* ENABLE_IPV6 */\n\t\t        \"[-s socket] [-p pidfile] [-t TTL] \"\n\t\t        \"[-f device] \"\n\t\t        \"-i <interface> [-i <interface2>] ...\\n\",\n\t\t        argv[0]);\n\t\tfprintf(stderr,\n\t\t        \"\\n  <interface> is either an IPv4 address with mask such as\\n\"\n\t\t        \"  192.168.1.42/255.255.255.0, or an interface name such as eth0.\\n\");\n\t\tfprintf(stderr,\n\t\t        \"\\n  By default, socket will be open as %s\\n\"\n\t\t        \"  and pid written to file %s\\n\",\n\t\t        sockpath, pidfilename);\n\t\treturn 1;\n\t}\n\n\t/* open log */\n\topenlog(\"minissdpd\",\n\t        LOG_CONS|LOG_PID|(debug_flag?LOG_PERROR:0),\n\t\t\tLOG_MINISSDPD);\n\tif(!debug_flag) /* speed things up and ignore LOG_INFO and LOG_DEBUG */\n\t\tsetlogmask(LOG_UPTO(LOG_NOTICE));\n\n\tif(checkforrunning(pidfilename) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"MiniSSDPd is already running. EXITING\");\n\t\treturn 1;\n\t}\n\n\tupnp_bootid = (unsigned int)time(NULL);\n\n\t/* set signal handlers */\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGTERM handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\tif(sigaction(SIGINT, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGINT handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\t/* open route/interface config changes socket */\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\t/* open UDP socket(s) for receiving SSDP packets */\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(0, ttl);\n\tif(s_ssdp < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages, exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#ifdef ENABLE_IPV6\n\tif(ipv6) {\n\t\ts_ssdp6 = OpenAndConfSSDPReceiveSocket(1, ttl);\n\t\tif(s_ssdp6 < 0)\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages (IPv6), exiting\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\t/* ENABLE_IPV6 */\n\t/* Open Unix socket to communicate with other programs on\n\t * the same machine */\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open unix socket for communicating with clients. Exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\n\t/* drop privileges */\n#if 0\n\t/* if we drop privileges, how to unlink(/var/run/minissdpd.sock) ? */\n\tif(getuid() == 0) {\n\t\tstruct passwd * user;\n\t\tstruct group * group;\n\t\tuser = getpwnam(\"nobody\");\n\t\tif(!user) {\n\t\t\tsyslog(LOG_ERR, \"getpwnam(\\\"%s\\\") : %m\", \"nobody\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tgroup = getgrnam(\"nogroup\");\n\t\tif(!group) {\n\t\t\tsyslog(LOG_ERR, \"getgrnam(\\\"%s\\\") : %m\", \"nogroup\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setgid(group->gr_gid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setgit(%d) : %m\", group->gr_gid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setuid(user->pw_uid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setuid(%d) : %m\", user->pw_uid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\n\t/* daemonize or in any case get pid ! */\n\tif(debug_flag)\n\t\tpid = getpid();\n\telse {\n#ifdef USE_DAEMON\n\t\tif(daemon(0, 0) < 0)\n\t\t\tperror(\"daemon()\");\n\t\tpid = getpid();\n#else  /* USE_DAEMON */\n\t\tpid = daemonize();\n#endif /* USE_DAEMON */\n\t}\n\n\twritepidfile(pidfilename, pid);\n\n\t/* send M-SEARCH ssdp:all Requests */\n\tif(s_ssdp >= 0)\n\t\tssdpDiscover(s_ssdp, 0, searched_device);\n\tif(s_ssdp6 >= 0)\n\t\tssdpDiscover(s_ssdp6, 1, searched_device);\n\n\t/* Main loop */\n\twhile(!quitting) {\n\t\t/* fill readfds fd_set */\n\t\tFD_ZERO(&readfds);\n\t\tFD_ZERO(&writefds);\n\n\t\tFD_SET(s_unix, &readfds);\n\t\tmax_fd = s_unix;\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp);\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif(s_ssdp6 >= 0) {\n\t\t\tFD_SET(s_ssdp6, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp6);\n\t\t}\n#endif /* ENABLE_IPV6 */\n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t\tSET_MAX(max_fd, s_ifacewatch);\n\t\t}\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\t\tif(req->socket >= 0) {\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t\tif(req->output_buffer_len > 0) {\n\t\t\t\tFD_SET(req->socket, &writefds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t}\n\t\tgettimeofday(&now, NULL);\n\t\ti = get_sendto_fds(&writefds, &max_fd, &now);\n\t\t/* select call */\n\t\tif(select(max_fd + 1, &readfds, &writefds, 0, 0) < 0) {\n\t\t\tif(errno != EINTR) {\n\t\t\t\tsyslog(LOG_ERR, \"select: %m\");\n\t\t\t\tbreak;\t/* quit */\n\t\t\t}\n\t\t\tcontinue;\t/* try again */\n\t\t}\n\t\tif(try_sendto(&writefds) < 0) {\n\t\t\tsyslog(LOG_ERR, \"try_sendto: %m\");\n\t\t\tbreak;\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif((s_ssdp6 >= 0) && FD_ISSET(s_ssdp6, &readfds))\n\t\t{\n\t\t\tsendername6_len = sizeof(struct sockaddr_in6);\n\t\t\tn = recvfrom(s_ssdp6, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername6, &sendername6_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp6, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername6, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\t/* ENABLE_IPV6 */\n\t\tif((s_ssdp >= 0) && FD_ISSET(s_ssdp, &readfds))\n\t\t{\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing unix socket requests */\n\t\tfor(req = reqlisthead.lh_first; req;) {\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds)) {\n\t\t\t\tprocessRequest(req);\n\t\t\t}\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &writefds)) {\n\t\t\t\twrite_buffer(req);\n\t\t\t}\n\t\t\tif(req->socket < 0) {\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req->output_buffer);\n\t\t\t\tfree(req);\n\t\t\t}\n\t\t\treq = reqnext;\n\t\t}\n\t\t/* processing new requests */\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t{\n\t\t\tstruct reqelem * tmp;\n\t\t\tint s = accept(s_unix, NULL, NULL);\n\t\t\tif(s < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"accept(s_unix): %m\");\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\t\tsyslog(LOG_WARNING, \"Failed to set new socket non blocking : %m\");\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp) {\n\t\t\t\t\tsyslog(LOG_ERR, \"cannot allocate memory for request\");\n\t\t\t\t\tclose(s);\n\t\t\t\t} else {\n\t\t\t\t\tmemset(tmp, 0, sizeof(struct reqelem));\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing route/network interface config changes */\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6);\n\t\t}\n\t}\n\tsyslog(LOG_DEBUG, \"quitting...\");\n\tfinalize_sendto();\n\n\t/* closing and cleaning everything */\nquit:\n\tif(s_ssdp >= 0) {\n\t\tclose(s_ssdp);\n\t\ts_ssdp = -1;\n\t}\n#ifdef ENABLE_IPV6\n\tif(s_ssdp6 >= 0) {\n\t\tclose(s_ssdp6);\n\t\ts_ssdp6 = -1;\n\t}\n#endif\t/* ENABLE_IPV6 */\n\tif(s_unix >= 0) {\n\t\tclose(s_unix);\n\t\ts_unix = -1;\n\t\tif(unlink(sockpath) < 0)\n\t\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", sockpath);\n\t}\n\tif(s_ifacewatch >= 0) {\n\t\tclose(s_ifacewatch);\n\t\ts_ifacewatch = -1;\n\t}\n\t/* empty LAN interface/address list */\n\twhile(lan_addrs.lh_first != NULL) {\n\t\tlan_addr = lan_addrs.lh_first;\n\t\tLIST_REMOVE(lan_addrs.lh_first, list);\n\t\tfree(lan_addr);\n\t}\n\t/* empty device list */\n\twhile(devlist != NULL) {\n\t\tstruct device * next = devlist->next;\n\t\tfree(devlist);\n\t\tdevlist = next;\n\t}\n\t/* empty service list */\n\twhile(servicelisthead.lh_first != NULL) {\n\t\tstruct service * serv = servicelisthead.lh_first;\n\t\tLIST_REMOVE(servicelisthead.lh_first, entries);\n\t\tfree(serv->st);\n\t\tfree(serv->usn);\n\t\tfree(serv->server);\n\t\tfree(serv->location);\n\t\tfree(serv);\n\t}\n\tif(unlink(pidfilename) < 0)\n\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", pidfilename);\n\tcloselog();\n\treturn ret;\n}\n\n", "/* $Id: testminissdpd.c,v 1.12 2015/08/06 13:16:59 nanard Exp $ */\n/* Project : miniupnp\n * website : http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * Author : Thomas BERNARD\n * copyright (c) 2005-2016 Thomas Bernard\n * This software is subjet to the conditions detailed in the\n * provided LICENCE file. */\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n\n#include \"codelength.h\"\n#include \"printresponse.h\"\n\nvoid printversion(const unsigned char * resp, int n)\n{\n\tint l;\n\tconst unsigned char * p;\n\n\tp = resp;\n\tDECODELENGTH(l, p);\n\tif(resp + n < p + l) {\n\t\tprintf(\"get version error\\n\");\n\t}\n\tprintf(\"MiniSSDPd version : %.*s\\n\", l, p);\n}\n\n#define SENDCOMMAND(command, size) write(s, command, size); \\\n              printf(\"Command written type=%u\\n\", (unsigned char)command[0]);\n\nint connect_unix_socket(const char * sockpath)\n{\n\tint s;\n\tstruct sockaddr_un addr;\n\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, sockpath, sizeof(addr.sun_path));\n\tif(connect(s, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) < 0) {\n\t\tfprintf(stderr, \"connecting to %s : \", addr.sun_path);\n\t\tperror(\"connect\");\n\t\texit(1);\n\t}\n\tprintf(\"Connected to %s\\n\", addr.sun_path);\n\treturn s;\n}\n\n/* test program for minissdpd */\nint\nmain(int argc, char * * argv)\n{\n\tconst char command0[] = { 0x00, 0x00 };\n\tchar command1[] = \"\\x01\\x00urn:schemas-upnp-org:device:InternetGatewayDevice\";\n\tchar command2[] = \"\\x02\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice\";\n\tconst char command3[] = { 0x03, 0x00 };\n\t/* old versions of minissdpd would reject a command with\n\t * a zero length string argument */\n\tchar command3compat[] = \"\\x03\\x00ssdp:all\";\n\tchar command4[] = \"\\x04\\x00test:test:test\";\n\tconst char bad_command[] = { 0xff, 0xff };\n\tconst char overflow[] = { 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tconst char command5[] = { 0x05, 0x00 };\n\tint s;\n\tint i;\n\tvoid * tmp;\n\tunsigned char * resp = NULL;\n\tsize_t respsize = 0;\n\tunsigned char buf[4096];\n\tssize_t n;\n\tint total = 0;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\n\tfor(i=0; i<argc-1; i++) {\n\t\tif(0==strcmp(argv[i], \"-s\"))\n\t\t\tsockpath = argv[++i];\n\t}\n\tcommand1[1] = sizeof(command1) - 3;\n\tcommand2[1] = sizeof(command2) - 3;\n\tcommand3compat[1] = sizeof(command3compat) - 3;\n\tcommand4[1] = sizeof(command4) - 3;\n\ts = connect_unix_socket(sockpath);\n\n\tn = SENDCOMMAND(command0, sizeof(command0));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tif(n > 0) {\n\t\tprintversion(buf, n);\n\t} else {\n\t\tprintf(\"Command 0 (get version) not supported\\n\");\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command1, sizeof(command1) - 1);\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command2, sizeof(command2) - 1);\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tbuf[0] = 0; /* Slight hack for printing num devices when 0 */\n\tn = SENDCOMMAND(command3, sizeof(command3));\n\tn = read(s, buf, sizeof(buf));\n\tif(n == 0) {\n\t\tprintf(\"command3 failed, testing compatible one\\n\");\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t\tn = SENDCOMMAND(command3compat, sizeof(command3compat) - 1);\n\t\tn = read(s, buf, sizeof(buf));\n\t}\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintf(\"Number of devices %d\\n\", (int)buf[0]);\n\twhile(n > 0) {\n\t\ttmp = realloc(resp, respsize + n);\n\t\tif(tmp == NULL) {\n\t\t\tfprintf(stderr, \"memory allocation error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tresp = tmp;\n\t\trespsize += n;\n\t\tif (n > 0) {\n\t\t\tmemcpy(resp + total, buf, n);\n\t\t\ttotal += n;\n\t\t}\n\t\tif (n < (ssize_t)sizeof(buf)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = read(s, buf, sizeof(buf));\n\t\tprintf(\"response received %d bytes\\n\", (int)n);\n\t}\n\tif(resp != NULL) {\n\t\tprintresponse(resp, total);\n\t\tfree(resp);\n\t\tresp = NULL;\n\t}\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command4, sizeof(command4));\n\t/* no response for request type 4 */\n\n\tn = SENDCOMMAND(bad_command, sizeof(bad_command));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(overflow, sizeof(overflow));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command5, sizeof(command5));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\n\tclose(s);\n\treturn 0;\n}\n"], "fixing_code": ["$Id: Changelog.txt,v 1.45 2016/03/01 18:06:46 nanard Exp $\n\n2016/03/01:\n\tFix broken overflow test (p+l > buf+n) thanks to Salva Piero\n\nVERSION 1.5:\n\n2016/01/13:\n\tadd \"notification\" mode (command 5)\n\n2015/08/06:\n\tdisable multicast loop\n\tadd -f command line option to filter for a specific device type\n\nVERSION 1.4:\n\n2015/08/06:\n\tadded command 0 (version)\n\n2015/07/21:\n\tset multicast TTL to 2 by default and configurable\n\n2015/05/27:\n\tsupport larger buffer size (useful for type 3 requests)\n\nVERSION 1.3:\n\n2014/12/05:\n\tclean up select call()\n\tfix non blocking write to sockets\n\n2014/12/04:\n\tFixes removing of devices on ssdp:byebye\n\thandle ssdp:update messages\n\n2014/11/28:\n\trevert \"listen on only 1 IPv4 if only 1 interface is specified\"\n\tbecause it prevents broadcast messages to be received\n\tChange the list of LAN addresses/interfaces (code taken from miniupnpd)\n\tCheck that the peer is from a LAN for each SSDP packet\n\n2014/11/06:\n\tlisten on only 1 IPv4 if only 1 interface is specified\n\talso when ENABLE_IPV6 is not defined\n\n2014/09/06:\n\tfreebsd-glue for Debian/kFreeBSD\n\tuse LDFLAGS when linking binary\n\n2014/05/01:\n\tlisten on only 1 IPv4 if only 1 interface is specified\n\n2014/02/03:\n\tsilently ignore EAGAIN, EWOULDBLOCK, EINTR of recv calls\n\tDiscover devices on the network at startup\n\n2013/08/19:\n\tTranslate README in english\n\n2012/09/27:\n\tRename all include guards to not clash with C99\n\t(7.1.3 Reserved identifiers).\n\nVERSION 1.2:\n\n2012/05/21:\n\tClean signal handling\n\tSet sockets non blocking\n\n2012/05/18:\n\tImprove ProcessInterfaceWatch() under BSD.\n\n2012/05/15:\n\tImprove ProcessInterfaceWatch() under linux.\n\n2012/05/02:\n\tClean CLFAGS in Makefile.\n\tRemove a few signed/unsigned compares\n\n2012/04/09:\n\tAdded -ansi to compilation flags.\n\tHandle ssdp:update messages and update logging\n\n2012/01/02:\n\tInstall manpage. Fix installation under Mac OS X.\n\n2011/10/07:\n\tunlink unix socket before binding.\n\tset SO_REUSEADDR on SSDP socket.\n\tdaemonize after init\n\nVERSION 1.1:\n\n2011/07/30:\n\tfixes. More overflow checks\n\n2011/07/29:\n\tadded a lot of buffer overflow checks. Check malloc() failure, etc.\n\tBetter cleanup in case of crash at start.\n\tnetwork interface watch to add/drop multicast membership when the interface get live.\n\n2011/06/18:\n\tStarting to add support for UPnP Device Architecture v1.1\n\n2011/05/23:\n\tAdded IPv6 support.\n\t-i option now understands interface names as well as addresses.\n\nVERSION 1.0:\n\n2008/10/07:\n\tadded codelength.h\n\tFixing response to M-SEARCH\n\tDoc update\n\n2008/10/06:\n\tUPnP server support (answering M-SEARCH)\n\n2008/10/04:\n\tlistening on several interfaces.\n\n2008/10/01:\n\tuse of daemon() instead of home made daemonize.\n\n2007/12/19:\n\tadded uuid in responses\n\t3 types of requests supported.\n\tpreventing buffer overflow\n\n2007/12/18:\n\tIt is now possible to change the location of both pid file and\n\tunix socket.\n\n2007/10/08:\n\tAdded a man page\n\n2007/09/27:\n\tSupport for install in different location $ PREFIX=... make install\n\n2007/09/23:\n\tadded a script for use in /etc/init.d\n\timproved Makefile\n\tcreating /var/run/minissdpd.pid\n\tadding synthetic messages for new devices/removed devices\n\n2007/09/19:\n\tTake SSDP announce packets lifetime into account.\n\n", "/* $Id: minissdpd.c,v 1.53 2016/03/01 18:06:46 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * (c) 2007-2016 Thomas Bernard\n * website : http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/queue.h>\n/* for chmod : */\n#include <sys/stat.h>\n/* unix sockets */\n#include <sys/un.h>\n/* for getpwnam() and getgrnam() */\n#if 0\n#include <pwd.h>\n#include <grp.h>\n#endif\n\n#include \"getifaddr.h\"\n#include \"upnputils.h\"\n#include \"openssdpsocket.h\"\n#include \"daemonize.h\"\n#include \"codelength.h\"\n#include \"ifacewatch.h\"\n#include \"minissdpdtypes.h\"\n#include \"asyncsendto.h\"\n\n#define SET_MAX(max, x)\tif((x) > (max)) (max) = (x)\n\n/* current request management stucture */\nstruct reqelem {\n\tint socket;\n\tint is_notify;\t/* has subscribed to notifications */\n\tLIST_ENTRY(reqelem) entries;\n\tunsigned char * output_buffer;\n\tint output_buffer_offset;\n\tint output_buffer_len;\n};\n\n/* device data structures */\nstruct header {\n\tconst char * p; /* string pointer */\n\tint l;          /* string length */\n};\n\n#define HEADER_NT\t0\n#define HEADER_USN\t1\n#define HEADER_LOCATION\t2\n\nstruct device {\n\tstruct device * next;\n\ttime_t t;                 /* validity time */\n\tstruct header headers[3]; /* NT, USN and LOCATION headers */\n\tchar data[];\n};\n\n/* Services stored for answering to M-SEARCH */\nstruct service {\n\tchar * st;\t/* Service type */\n\tchar * usn;\t/* Unique identifier */\n\tchar * server;\t/* Server string */\n\tchar * location;\t/* URL */\n\tLIST_ENTRY(service) entries;\n};\nLIST_HEAD(servicehead, service) servicelisthead;\n\n#define NTS_SSDP_ALIVE\t1\n#define NTS_SSDP_BYEBYE\t2\n#define NTS_SSDP_UPDATE\t3\n\n/* request types */\nenum request_type {\n\tMINISSDPD_GET_VERSION = 0,\n\tMINISSDPD_SEARCH_TYPE = 1,\n\tMINISSDPD_SEARCH_USN = 2,\n\tMINISSDPD_SEARCH_ALL = 3,\n\tMINISSDPD_SUBMIT = 4,\n\tMINISSDPD_NOTIF = 5\n};\n\n/* discovered device list kept in memory */\nstruct device * devlist = 0;\n\n/* bootid and configid */\nunsigned int upnp_bootid = 1;\nunsigned int upnp_configid = 1337;\n\n/* LAN interfaces/addresses */\nstruct lan_addr_list lan_addrs;\n\n/* connected clients */\nLIST_HEAD(reqstructhead, reqelem) reqlisthead;\n\n/* functions prototypes */\n\n#define NOTIF_NEW    1\n#define NOTIF_UPDATE 2\n#define NOTIF_REMOVE 3\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv);\n\n/* functions */\n\n/* parselanaddr()\n * parse address with mask\n * ex: 192.168.1.1/24 or 192.168.1.1/255.255.255.0\n *\n * Can also use the interface name (ie eth0)\n *\n * return value :\n *    0 : ok\n *   -1 : error */\nstatic int\nparselanaddr(struct lan_addr_s * lan_addr, const char * str)\n{\n\tconst char * p;\n\tint n;\n\tchar tmp[16];\n\n\tmemset(lan_addr, 0, sizeof(struct lan_addr_s));\n\tp = str;\n\twhile(*p && *p != '/' && !isspace(*p))\n\t\tp++;\n\tn = p - str;\n\tif(!isdigit(str[0]) && n < (int)sizeof(lan_addr->ifname)) {\n\t\t/* not starting with a digit : suppose it is an interface name */\n\t\tmemcpy(lan_addr->ifname, str, n);\n\t\tlan_addr->ifname[n] = '\\0';\n\t\tif(getifaddr(lan_addr->ifname, lan_addr->str, sizeof(lan_addr->str),\n\t\t             &lan_addr->addr, &lan_addr->mask) < 0)\n\t\t\tgoto parselan_error;\n\t\t/*printf(\"%s => %s\\n\", lan_addr->ifname, lan_addr->str);*/\n\t} else {\n\t\tif(n>15)\n\t\t\tgoto parselan_error;\n\t\tmemcpy(lan_addr->str, str, n);\n\t\tlan_addr->str[n] = '\\0';\n\t\tif(!inet_aton(lan_addr->str, &lan_addr->addr))\n\t\t\tgoto parselan_error;\n\t}\n\tif(*p == '/') {\n\t\tconst char * q = ++p;\n\t\twhile(*p && isdigit(*p))\n\t\t\tp++;\n\t\tif(*p=='.') {\n\t\t\t/* parse mask in /255.255.255.0 format */\n\t\t\twhile(*p && (*p=='.' || isdigit(*p)))\n\t\t\t\tp++;\n\t\t\tn = p - q;\n\t\t\tif(n>15)\n\t\t\t\tgoto parselan_error;\n\t\t\tmemcpy(tmp, q, n);\n\t\t\ttmp[n] = '\\0';\n\t\t\tif(!inet_aton(tmp, &lan_addr->mask))\n\t\t\t\tgoto parselan_error;\n\t\t} else {\n\t\t\t/* it is a /24 format */\n\t\t\tint nbits = atoi(q);\n\t\t\tif(nbits > 32 || nbits < 0)\n\t\t\t\tgoto parselan_error;\n\t\t\tlan_addr->mask.s_addr = htonl(nbits ? (0xffffffffu << (32 - nbits)) : 0);\n\t\t}\n\t} else if(lan_addr->mask.s_addr == 0) {\n\t\t/* by default, networks are /24 */\n\t\tlan_addr->mask.s_addr = htonl(0xffffff00u);\n\t}\n#ifdef ENABLE_IPV6\n\tif(lan_addr->ifname[0] != '\\0') {\n\t\tlan_addr->index = if_nametoindex(lan_addr->ifname);\n\t\tif(lan_addr->index == 0)\n\t\t\tfprintf(stderr, \"Cannot get index for network interface %s\",\n\t\t\t        lan_addr->ifname);\n\t} else {\n\t\tfprintf(stderr,\n\t\t        \"Error: please specify LAN network interface by name instead of IPv4 address : %s\\n\",\n\t\t        str);\n\t\treturn -1;\n\t}\n#endif /* ENABLE_IPV6 */\n\treturn 0;\nparselan_error:\n\tfprintf(stderr, \"Error parsing address/mask (or interface name) : %s\\n\",\n\t        str);\n\treturn -1;\n}\n\nstatic int\nwrite_buffer(struct reqelem * req)\n{\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\tint n = write(req->socket,\n\t\t              req->output_buffer + req->output_buffer_offset,\n\t\t              req->output_buffer_len);\n\t\tif(n >= 0) {\n\t\t\treq->output_buffer_offset += n;\n\t\t\treq->output_buffer_len -= n;\n\t\t} else if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn n;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int\nadd_to_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tunsigned char * tmp;\n\tif(req->output_buffer_offset > 0) {\n\t\tmemmove(req->output_buffer, req->output_buffer + req->output_buffer_offset, req->output_buffer_len);\n\t\treq->output_buffer_offset = 0;\n\t}\n\ttmp = realloc(req->output_buffer, req->output_buffer_len + len);\n\tif(tmp == NULL) {\n\t\tsyslog(LOG_ERR, \"%s: failed to allocate %d bytes\",\n\t\t       __func__, req->output_buffer_len + len);\n\t\treturn -1;\n\t}\n\treq->output_buffer = tmp;\n\tmemcpy(req->output_buffer + req->output_buffer_len, data, len);\n\treq->output_buffer_len += len;\n\treturn len;\n}\n\nstatic int\nwrite_or_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tif(write_buffer(req) < 0)\n\t\treturn -1;\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\treturn add_to_buffer(req, data, len);\n\t} else {\n\t\tint n = write(req->socket, data, len);\n\t\tif(n == len)\n\t\t\treturn len;\n\t\tif(n < 0) {\n\t\t\tif(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\t\tn = add_to_buffer(req, data, len);\n\t\t\t\tif(n < 0) return n;\n\t\t\t} else {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} else {\n\t\t\tn = add_to_buffer(req, data + n, len - n);\n\t\t\tif(n < 0) return n;\n\t\t}\n\t}\n\treturn len;\n}\n\nstatic const char *\nnts_to_str(int nts)\n{\n\tswitch(nts)\n\t{\n\tcase NTS_SSDP_ALIVE:\n\t\treturn \"ssdp:alive\";\n\tcase NTS_SSDP_BYEBYE:\n\t\treturn \"ssdp:byebye\";\n\tcase NTS_SSDP_UPDATE:\n\t\treturn \"ssdp:update\";\n\t}\n\treturn \"unknown\";\n}\n\n/* updateDevice() :\n * adds or updates the device to the list.\n * return value :\n *   0 : the device was updated (or nothing done)\n *   1 : the device was new    */\nstatic int\nupdateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t/* TODO : check p->headers[HEADER_LOCATION].l */\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}\n\n/* removeDevice() :\n * remove a device from the list\n * return value :\n *    0 : no device removed\n *   -1 : device removed */\nstatic int\nremoveDevice(const struct header * headers)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"remove device : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tsendNotifications(NOTIF_REMOVE, p, NULL);\n\t\t\t*pp = p->next;\n\t\t\tfree(p);\n\t\t\treturn -1;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_WARNING, \"device not found for removing : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\treturn 0;\n}\n\n/* sent notifications to client having subscribed */\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv)\n{\n\tstruct reqelem * req;\n\tunsigned int m;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\n\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\tif(!req->is_notify) continue;\n\t\trbuf[0] = '\\xff'; /* special code for notifications */\n\t\trbuf[1] = (unsigned char)notif_type;\n\t\trbuf[2] = 0;\n\t\trp = rbuf + 3;\n\t\tif(dev) {\n\t\t\t/* response :\n\t\t\t * 1 - Location\n\t\t\t * 2 - NT (device/service type)\n\t\t\t * 3 - usn */\n\t\t\tm = dev->headers[HEADER_LOCATION].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_LOCATION].p, dev->headers[HEADER_LOCATION].l);\n\t\t\trp += dev->headers[HEADER_LOCATION].l;\n\t\t\tm = dev->headers[HEADER_NT].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_NT].p, dev->headers[HEADER_NT].l);\n\t\t\trp += dev->headers[HEADER_NT].l;\n\t\t\tm = dev->headers[HEADER_USN].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_USN].p, dev->headers[HEADER_USN].l);\n\t\t\trp += dev->headers[HEADER_USN].l;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(serv) {\n\t\t\t/* response :\n\t\t\t * 1 - Location\n\t\t\t * 2 - NT (device/service type)\n\t\t\t * 3 - usn */\n\t\t\tm = strlen(serv->location);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->location, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->st);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->st, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->usn);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\trp += m;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(rbuf[2] > 0) {\n\t\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\t\t/*goto error;*/\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* SendSSDPMSEARCHResponse() :\n * build and send response to M-SEARCH SSDP packets. */\nstatic void\nSendSSDPMSEARCHResponse(int s, const struct sockaddr * sockname,\n                        const char * st, const char * usn,\n                        const char * server, const char * location)\n{\n\tint l, n;\n\tchar buf[512];\n\tsocklen_t sockname_len;\n\t/*\n\t * follow guideline from document \"UPnP Device Architecture 1.0\"\n\t * uppercase is recommended.\n\t * DATE: is recommended\n\t * SERVER: OS/ver UPnP/1.0 miniupnpd/1.0\n\t * - check what to put in the 'Cache-Control' header\n\t *\n\t * have a look at the document \"UPnP Device Architecture v1.1 */\n\tl = snprintf(buf, sizeof(buf), \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\"CACHE-CONTROL: max-age=120\\r\\n\"\n\t\t/*\"DATE: ...\\r\\n\"*/\n\t\t\"ST: %s\\r\\n\"\n\t\t\"USN: %s\\r\\n\"\n\t\t\"EXT:\\r\\n\"\n\t\t\"SERVER: %s\\r\\n\"\n\t\t\"LOCATION: %s\\r\\n\"\n\t\t\"OPT: \\\"http://schemas.upnp.org/upnp/1/0/\\\"; ns=01\\r\\n\" /* UDA v1.1 */\n\t\t\"01-NLS: %u\\r\\n\" /* same as BOOTID. UDA v1.1 */\n\t\t\"BOOTID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"CONFIGID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"\\r\\n\",\n\t\tst, usn,\n\t\tserver, location,\n\t\tupnp_bootid, upnp_bootid, upnp_configid);\n#ifdef ENABLE_IPV6\n\tsockname_len = (sockname->sa_family == PF_INET6)\n\t             ? sizeof(struct sockaddr_in6)\n\t             : sizeof(struct sockaddr_in);\n#else\t/* ENABLE_IPV6 */\n\tsockname_len = sizeof(struct sockaddr_in);\n#endif\t/* ENABLE_IPV6 */\n\tn = sendto_or_schedule(s, buf, l, 0, sockname, sockname_len);\n\tif(n < 0) {\n\t\tsyslog(LOG_ERR, \"%s: sendto(udp): %m\", __func__);\n\t}\n}\n\n/* Process M-SEARCH requests */\nstatic void\nprocessMSEARCH(int s, const char * st, int st_len,\n               const struct sockaddr * addr)\n{\n\tstruct service * serv;\n#ifdef ENABLE_IPV6\n\tchar buf[64];\n#endif /* ENABLE_IPV6 */\n\n\tif(!st || st_len==0)\n\t\treturn;\n#ifdef ENABLE_IPV6\n\tsockaddr_to_string(addr, buf, sizeof(buf));\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s ST:%.*s\",\n\t       buf, st_len, st);\n#else\t/* ENABLE_IPV6 */\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s:%d ST: %.*s\",\n\t       inet_ntoa(((const struct sockaddr_in *)addr)->sin_addr),\n\t       ntohs(((const struct sockaddr_in *)addr)->sin_port),\n\t       st_len, st);\n#endif\t/* ENABLE_IPV6 */\n\tif(st_len==8 && (0==memcmp(st, \"ssdp:all\", 8))) {\n\t\t/* send a response for all services */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t                        serv->st, serv->usn,\n\t\t\t                        serv->server, serv->location);\n\t\t}\n\t} else if(st_len > 5 && (0==memcmp(st, \"uuid:\", 5))) {\n\t\t/* find a matching UUID value */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->usn, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* find matching services */\n\t\t/* remove version at the end of the ST string */\n\t\tif(st[st_len-2]==':' && isdigit(st[st_len-1]))\n\t\t\tst_len -= 2;\n\t\t/* answer for each matching service */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->st, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * helper function.\n * reject any non ASCII or non printable character.\n */\nstatic int\ncontainsForbiddenChars(const unsigned char * p, int len)\n{\n\twhile(len > 0) {\n\t\tif(*p < ' ' || *p >= '\\x7f')\n\t\t\treturn 1;\n\t\tp++;\n\t\tlen--;\n\t}\n\treturn 0;\n}\n\n#define METHOD_MSEARCH 1\n#define METHOD_NOTIFY 2\n\n/* ParseSSDPPacket() :\n * parse a received SSDP Packet and call\n * updateDevice() or removeDevice() as needed\n * return value :\n *    -1 : a device was removed\n *     0 : no device removed nor added\n *     1 : a device was added.  */\nstatic int\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr,\n                const char * searched_device)\n{\n\tconst char * linestart;\n\tconst char * lineend;\n\tconst char * nameend;\n\tconst char * valuestart;\n\tstruct header headers[3];\n\tint i, r = 0;\n\tint methodlen;\n\tint nts = -1;\n\tint method = -1;\n\tunsigned int lifetime = 180;\t/* 3 minutes by default */\n\tconst char * st = NULL;\n\tint st_len = 0;\n\n\t/* first check from what subnet is the sender */\n\tif(get_lan_for_peer(addr) == NULL) {\n\t\tchar addr_str[64];\n\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\tsyslog(LOG_WARNING, \"peer %s is not from a LAN\",\n\t\t       addr_str);\n\t\treturn 0;\n\t}\n\n\t/* do the parsing */\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\t\tmethod = METHOD_MSEARCH;\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t\t/* answer to a M-SEARCH => process it as a NOTIFY\n\t\t * with NTS: ssdp:alive */\n\t\tmethod = METHOD_NOTIFY;\n\t\tnts = NTS_SSDP_ALIVE;\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\t/* start parsing the line : detect line end */\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\t/*printf(\"line: '%.*s'\\n\", lineend - linestart, linestart);*/\n\t\t/* detect name end : ':' character */\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\t/* detect value */\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\t/* trim spaces */\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\t/* suppress leading \" if needed */\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint l = nameend - linestart;\t/* header name length */\n\t\t\tint m = lineend - valuestart;\t/* header value length */\n\t\t\t/* suppress tailing spaces */\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\t/* suppress tailing ' if needed */\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\ti = -1;\n\t\t\t/*printf(\"--%.*s: (%d)%.*s--\\n\", l, linestart,\n\t\t\t                           m, m, valuestart);*/\n\t\t\tif(l==2 && 0==strncasecmp(linestart, \"nt\", 2))\n\t\t\t\ti = HEADER_NT;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t\tif(m==10 && 0==strncasecmp(valuestart, \"ssdp:alive\", 10))\n\t\t\t\t\tnts = NTS_SSDP_ALIVE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:byebye\", 11))\n\t\t\t\t\tnts = NTS_SSDP_BYEBYE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:update\", 11))\n\t\t\t\t\tnts = NTS_SSDP_UPDATE;\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\t/* parse \"name1=value1, name_alone, name2=value2\" string */\n\t\t\t\tconst char * name = valuestart;\t/* name */\n\t\t\t\tconst char * val;\t\t\t\t/* value */\n\t\t\t\tint rem = m;\t/* remaining bytes to process */\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\t/* move to the next name=value pair */\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* skip spaces */\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*syslog(LOG_DEBUG, \"**%.*s**%u\", m, valuestart, lifetime);*/\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\t\t\tst = valuestart;\n\t\t\t\tst_len = m;\n\t\t\t\tif(method == METHOD_NOTIFY)\n\t\t\t\t\ti = HEADER_NT;\t/* it was a M-SEARCH response */\n\t\t\t}\n\t\t\tif(i>=0) {\n\t\t\t\theaders[i].p = valuestart;\n\t\t\t\theaders[i].l = m;\n\t\t\t}\n\t\t}\n\t\tlinestart = lineend;\n\t\twhile((*linestart == '\\n' || *linestart == '\\r') && linestart < p + n)\n\t\t\tlinestart++;\n\t}\n#if 0\n\tprintf(\"NTS=%d\\n\", nts);\n\tfor(i=0; i<3; i++) {\n\t\tif(headers[i].p)\n\t\t\tprintf(\"%d-'%.*s'\\n\", i, headers[i].l, headers[i].p);\n\t}\n#endif\n\tsyslog(LOG_DEBUG,\"SSDP request: '%.*s' (%d) %s %s=%.*s\",\n\t       methodlen, p, method, nts_to_str(nts),\n\t       (method==METHOD_NOTIFY)?\"nt\":\"st\",\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].l:st_len,\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].p:st);\n\tswitch(method) {\n\tcase METHOD_NOTIFY:\n\t\tif(nts==NTS_SSDP_ALIVE || nts==NTS_SSDP_UPDATE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p && headers[HEADER_LOCATION].p) {\n\t\t\t\t/* filter if needed */\n\t\t\t\tif(searched_device &&\n\t\t\t\t   0 != memcmp(headers[HEADER_NT].p, searched_device, headers[HEADER_NT].l))\n\t\t\t\t\tbreak;\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p location=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p,\n\t\t\t\t       headers[HEADER_LOCATION].p);\n\t\t\t}\n\t\t} else if(nts==NTS_SSDP_BYEBYE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p) {\n\t\t\t\tr = removeDevice(headers);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase METHOD_MSEARCH:\n\t\tprocessMSEARCH(s, st, st_len, addr);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tchar addr_str[64];\n\t\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\t\tsyslog(LOG_WARNING, \"method %.*s, don't know what to do (from %s)\",\n\t\t\t       methodlen, p, addr_str);\n\t\t}\n\t}\n\treturn r;\n}\n\n/* OpenUnixSocket()\n * open the unix socket and call bind() and listen()\n * return -1 in case of error */\nstatic int\nOpenUnixSocket(const char * path)\n{\n\tstruct sockaddr_un addr;\n\tint s;\n\tint rv;\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif(s < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"socket(AF_UNIX): %m\");\n\t\treturn -1;\n\t}\n\t/* unlink the socket pseudo file before binding */\n\trv = unlink(path);\n\tif(rv < 0 && errno != ENOENT)\n\t{\n\t\tsyslog(LOG_ERR, \"unlink(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, path, sizeof(addr.sun_path));\n\tif(bind(s, (struct sockaddr *)&addr,\n\t           sizeof(struct sockaddr_un)) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"bind(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\telse if(listen(s, 5) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"listen(unixsocket): %m\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\t/* Change rights so everyone can communicate with us */\n\tif(chmod(path, 0666) < 0)\n\t{\n\t\tsyslog(LOG_WARNING, \"chmod(\\\"%s\\\"): %m\", path);\n\t}\n\treturn s;\n}\n\n/* processRequest() :\n * process the request coming from a unix socket */\nvoid processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tenum request_type type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t/* try again later */\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(l > (unsigned)(buf+n-p)) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding l=%u n=%u)\",\n\t\t       l, (unsigned)n);\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != MINISSDPD_SEARCH_ALL\n\t   && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0, type=%d)\", type);\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase MINISSDPD_GET_VERSION:\n\t\trp = rbuf;\n\t\tCODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);\n\t\tmemcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);\n\t\trp += (sizeof(MINISSDPD_VERSION) - 1);\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase MINISSDPD_SEARCH_TYPE:\t/* request by type */\n\tcase MINISSDPD_SEARCH_USN:\t/* request by USN (unique id) */\n\tcase MINISSDPD_SEARCH_ALL:\t/* everything */\n\t\trp = rbuf+1;\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\t/* test if we can put more responses in the buffer */\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\t\t/* response :\n\t\t\t\t\t * 1 - Location\n\t\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t\t * 3 - usn */\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\t/* Also look in service list */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\t/* test if we can put more responses in the buffer */\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\t/* response :\n\t\t\t\t * 1 - Location\n\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t * 3 - usn */\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase MINISSDPD_SUBMIT:\t/* submit service */\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(newserv, 0, sizeof(struct service));\t/* set pointers to NULL */\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(l > (unsigned)(buf+n-p)) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(l > (unsigned)(buf+n-p)) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(l > (unsigned)(buf+n-p)) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\t/* look in service list for duplicate */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service already in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* Inserting new service */\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tsendNotifications(NOTIF_NEW, NULL, newserv);\n\t\tnewserv = NULL;\n\t\tbreak;\n\tcase MINISSDPD_NOTIF:\t/* switch socket to notify */\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\treq->is_notify = 1;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\n\nstatic volatile sig_atomic_t quitting = 0;\n/* SIGTERM signal handler */\nstatic void\nsigterm(int sig)\n{\n\t(void)sig;\n\t/*int save_errno = errno;*/\n\t/*signal(sig, SIG_IGN);*/\n#if 0\n\t/* calling syslog() is forbidden in a signal handler according to\n\t * signal(3) */\n\tsyslog(LOG_NOTICE, \"received signal %d, good-bye\", sig);\n#endif\n\tquitting = 1;\n\t/*errno = save_errno;*/\n}\n\n#define PORT 1900\n#define XSTR(s) STR(s)\n#define STR(s) #s\n#define UPNP_MCAST_ADDR \"239.255.255.250\"\n/* for IPv6 */\n#define UPNP_MCAST_LL_ADDR \"FF02::C\" /* link-local */\n#define UPNP_MCAST_SL_ADDR \"FF05::C\" /* site-local */\n\n/* send the M-SEARCH request for devices\n * either all devices (third argument is NULL or \"*\") or a specific one */\nstatic void ssdpDiscover(int s, int ipv6, const char * search)\n{\n\tstatic const char MSearchMsgFmt[] =\n\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\"HOST: %s:\" XSTR(PORT) \"\\r\\n\"\n\t\"ST: %s\\r\\n\"\n\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\"MX: %u\\r\\n\"\n\t\"\\r\\n\";\n\tchar bufr[512];\n\tint n;\n\tint mx = 3;\n\tint linklocal = 1;\n\tstruct sockaddr_storage sockudp_w;\n\n\t{\n\t\tn = snprintf(bufr, sizeof(bufr),\n\t\t             MSearchMsgFmt,\n\t\t             ipv6 ?\n\t\t             (linklocal ? \"[\" UPNP_MCAST_LL_ADDR \"]\" :  \"[\" UPNP_MCAST_SL_ADDR \"]\")\n\t\t             : UPNP_MCAST_ADDR,\n\t\t             (search ? search : \"ssdp:all\"), mx);\n\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_storage));\n\t\tif(ipv6) {\n\t\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_w;\n\t\t\tp->sin6_family = AF_INET6;\n\t\t\tp->sin6_port = htons(PORT);\n\t\t\tinet_pton(AF_INET6,\n\t\t\t          linklocal ? UPNP_MCAST_LL_ADDR : UPNP_MCAST_SL_ADDR,\n\t\t\t          &(p->sin6_addr));\n\t\t} else {\n\t\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_w;\n\t\t\tp->sin_family = AF_INET;\n\t\t\tp->sin_port = htons(PORT);\n\t\t\tp->sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n\t\t}\n\n\t\tn = sendto_or_schedule(s, bufr, n, 0, (const struct sockaddr *)&sockudp_w,\n\t\t                       ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\t\tif (n < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: sendto: %m\", __func__);\n\t\t}\n\t}\n}\n\n/* main(): program entry point */\nint main(int argc, char * * argv)\n{\n\tint ret = 0;\n\tint pid;\n\tstruct sigaction sa;\n\tchar buf[1500];\n\tssize_t n;\n\tint s_ssdp = -1;\t/* udp socket receiving ssdp packets */\n#ifdef ENABLE_IPV6\n\tint s_ssdp6 = -1;\t/* udp socket receiving ssdp packets IPv6*/\n#else\t/* ENABLE_IPV6 */\n#define s_ssdp6 (-1)\n#endif\t/* ENABLE_IPV6 */\n\tint s_unix = -1;\t/* unix socket communicating with clients */\n\tint s_ifacewatch = -1;\t/* socket to receive Route / network interface config changes */\n\tstruct reqelem * req;\n\tstruct reqelem * reqnext;\n\tfd_set readfds;\n\tfd_set writefds;\n\tstruct timeval now;\n\tint max_fd;\n\tstruct lan_addr_s * lan_addr;\n\tint i;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tconst char * pidfilename = \"/var/run/minissdpd.pid\";\n\tint debug_flag = 0;\n#ifdef ENABLE_IPV6\n\tint ipv6 = 0;\n#endif /* ENABLE_IPV6 */\n\tint deltadev = 0;\n\tstruct sockaddr_in sendername;\n\tsocklen_t sendername_len;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 sendername6;\n\tsocklen_t sendername6_len;\n#endif\t/* ENABLE_IPV6 */\n\tunsigned char ttl = 2;\t/* UDA says it should default to 2 */\n\tconst char * searched_device = NULL;\t/* if not NULL, search/filter a specific device type */\n\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&servicelisthead);\n\tLIST_INIT(&lan_addrs);\n\t/* process command line */\n\tfor(i=1; i<argc; i++)\n\t{\n \t\tif(0==strcmp(argv[i], \"-d\"))\n\t\t\tdebug_flag = 1;\n#ifdef ENABLE_IPV6\n\t\telse if(0==strcmp(argv[i], \"-6\"))\n\t\t\tipv6 = 1;\n#endif\t/* ENABLE_IPV6 */\n\t\telse {\n\t\t\tif((i + 1) >= argc) {\n\t\t\t\tfprintf(stderr, \"option %s needs an argument.\\n\", argv[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(0==strcmp(argv[i], \"-i\")) {\n\t\t\t\tlan_addr = malloc(sizeof(struct lan_addr_s));\n\t\t\t\tif(lan_addr == NULL) {\n\t\t\t\t\tfprintf(stderr, \"malloc(%d) FAILED\\n\", (int)sizeof(struct lan_addr_s));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(parselanaddr(lan_addr, argv[++i]) != 0) {\n\t\t\t\t\tfprintf(stderr, \"can't parse \\\"%s\\\" as a valid address or interface name\\n\", argv[i]);\n\t\t\t\t\tfree(lan_addr);\n\t\t\t\t} else {\n\t\t\t\t\tLIST_INSERT_HEAD(&lan_addrs, lan_addr, list);\n\t\t\t\t}\n\t\t\t} else if(0==strcmp(argv[i], \"-s\"))\n\t\t\t\tsockpath = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\t\tpidfilename = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-t\"))\n\t\t\t\tttl = (unsigned char)atoi(argv[++i]);\n\t\t\telse if(0==strcmp(argv[i], \"-f\"))\n\t\t\t\tsearched_device = argv[++i];\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"unknown commandline option %s.\\n\", argv[i]);\n\t\t}\n\t}\n\tif(lan_addrs.lh_first == NULL)\n\t{\n\t\tfprintf(stderr,\n\t\t        \"Usage: %s [-d] \"\n#ifdef ENABLE_IPV6\n\t\t        \"[-6] \"\n#endif /* ENABLE_IPV6 */\n\t\t        \"[-s socket] [-p pidfile] [-t TTL] \"\n\t\t        \"[-f device] \"\n\t\t        \"-i <interface> [-i <interface2>] ...\\n\",\n\t\t        argv[0]);\n\t\tfprintf(stderr,\n\t\t        \"\\n  <interface> is either an IPv4 address with mask such as\\n\"\n\t\t        \"  192.168.1.42/255.255.255.0, or an interface name such as eth0.\\n\");\n\t\tfprintf(stderr,\n\t\t        \"\\n  By default, socket will be open as %s\\n\"\n\t\t        \"  and pid written to file %s\\n\",\n\t\t        sockpath, pidfilename);\n\t\treturn 1;\n\t}\n\n\t/* open log */\n\topenlog(\"minissdpd\",\n\t        LOG_CONS|LOG_PID|(debug_flag?LOG_PERROR:0),\n\t\t\tLOG_MINISSDPD);\n\tif(!debug_flag) /* speed things up and ignore LOG_INFO and LOG_DEBUG */\n\t\tsetlogmask(LOG_UPTO(LOG_NOTICE));\n\n\tif(checkforrunning(pidfilename) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"MiniSSDPd is already running. EXITING\");\n\t\treturn 1;\n\t}\n\n\tupnp_bootid = (unsigned int)time(NULL);\n\n\t/* set signal handlers */\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGTERM handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\tif(sigaction(SIGINT, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGINT handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\t/* open route/interface config changes socket */\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\t/* open UDP socket(s) for receiving SSDP packets */\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(0, ttl);\n\tif(s_ssdp < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages, exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#ifdef ENABLE_IPV6\n\tif(ipv6) {\n\t\ts_ssdp6 = OpenAndConfSSDPReceiveSocket(1, ttl);\n\t\tif(s_ssdp6 < 0)\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages (IPv6), exiting\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\t/* ENABLE_IPV6 */\n\t/* Open Unix socket to communicate with other programs on\n\t * the same machine */\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open unix socket for communicating with clients. Exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\n\t/* drop privileges */\n#if 0\n\t/* if we drop privileges, how to unlink(/var/run/minissdpd.sock) ? */\n\tif(getuid() == 0) {\n\t\tstruct passwd * user;\n\t\tstruct group * group;\n\t\tuser = getpwnam(\"nobody\");\n\t\tif(!user) {\n\t\t\tsyslog(LOG_ERR, \"getpwnam(\\\"%s\\\") : %m\", \"nobody\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tgroup = getgrnam(\"nogroup\");\n\t\tif(!group) {\n\t\t\tsyslog(LOG_ERR, \"getgrnam(\\\"%s\\\") : %m\", \"nogroup\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setgid(group->gr_gid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setgit(%d) : %m\", group->gr_gid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setuid(user->pw_uid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setuid(%d) : %m\", user->pw_uid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\n\t/* daemonize or in any case get pid ! */\n\tif(debug_flag)\n\t\tpid = getpid();\n\telse {\n#ifdef USE_DAEMON\n\t\tif(daemon(0, 0) < 0)\n\t\t\tperror(\"daemon()\");\n\t\tpid = getpid();\n#else  /* USE_DAEMON */\n\t\tpid = daemonize();\n#endif /* USE_DAEMON */\n\t}\n\n\twritepidfile(pidfilename, pid);\n\n\t/* send M-SEARCH ssdp:all Requests */\n\tif(s_ssdp >= 0)\n\t\tssdpDiscover(s_ssdp, 0, searched_device);\n\tif(s_ssdp6 >= 0)\n\t\tssdpDiscover(s_ssdp6, 1, searched_device);\n\n\t/* Main loop */\n\twhile(!quitting) {\n\t\t/* fill readfds fd_set */\n\t\tFD_ZERO(&readfds);\n\t\tFD_ZERO(&writefds);\n\n\t\tFD_SET(s_unix, &readfds);\n\t\tmax_fd = s_unix;\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp);\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif(s_ssdp6 >= 0) {\n\t\t\tFD_SET(s_ssdp6, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp6);\n\t\t}\n#endif /* ENABLE_IPV6 */\n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t\tSET_MAX(max_fd, s_ifacewatch);\n\t\t}\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\t\tif(req->socket >= 0) {\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t\tif(req->output_buffer_len > 0) {\n\t\t\t\tFD_SET(req->socket, &writefds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t}\n\t\tgettimeofday(&now, NULL);\n\t\ti = get_sendto_fds(&writefds, &max_fd, &now);\n\t\t/* select call */\n\t\tif(select(max_fd + 1, &readfds, &writefds, 0, 0) < 0) {\n\t\t\tif(errno != EINTR) {\n\t\t\t\tsyslog(LOG_ERR, \"select: %m\");\n\t\t\t\tbreak;\t/* quit */\n\t\t\t}\n\t\t\tcontinue;\t/* try again */\n\t\t}\n\t\tif(try_sendto(&writefds) < 0) {\n\t\t\tsyslog(LOG_ERR, \"try_sendto: %m\");\n\t\t\tbreak;\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif((s_ssdp6 >= 0) && FD_ISSET(s_ssdp6, &readfds))\n\t\t{\n\t\t\tsendername6_len = sizeof(struct sockaddr_in6);\n\t\t\tn = recvfrom(s_ssdp6, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername6, &sendername6_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp6, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername6, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\t/* ENABLE_IPV6 */\n\t\tif((s_ssdp >= 0) && FD_ISSET(s_ssdp, &readfds))\n\t\t{\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing unix socket requests */\n\t\tfor(req = reqlisthead.lh_first; req;) {\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds)) {\n\t\t\t\tprocessRequest(req);\n\t\t\t}\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &writefds)) {\n\t\t\t\twrite_buffer(req);\n\t\t\t}\n\t\t\tif(req->socket < 0) {\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req->output_buffer);\n\t\t\t\tfree(req);\n\t\t\t}\n\t\t\treq = reqnext;\n\t\t}\n\t\t/* processing new requests */\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t{\n\t\t\tstruct reqelem * tmp;\n\t\t\tint s = accept(s_unix, NULL, NULL);\n\t\t\tif(s < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"accept(s_unix): %m\");\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\t\tsyslog(LOG_WARNING, \"Failed to set new socket non blocking : %m\");\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp) {\n\t\t\t\t\tsyslog(LOG_ERR, \"cannot allocate memory for request\");\n\t\t\t\t\tclose(s);\n\t\t\t\t} else {\n\t\t\t\t\tmemset(tmp, 0, sizeof(struct reqelem));\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing route/network interface config changes */\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6);\n\t\t}\n\t}\n\tsyslog(LOG_DEBUG, \"quitting...\");\n\tfinalize_sendto();\n\n\t/* closing and cleaning everything */\nquit:\n\tif(s_ssdp >= 0) {\n\t\tclose(s_ssdp);\n\t\ts_ssdp = -1;\n\t}\n#ifdef ENABLE_IPV6\n\tif(s_ssdp6 >= 0) {\n\t\tclose(s_ssdp6);\n\t\ts_ssdp6 = -1;\n\t}\n#endif\t/* ENABLE_IPV6 */\n\tif(s_unix >= 0) {\n\t\tclose(s_unix);\n\t\ts_unix = -1;\n\t\tif(unlink(sockpath) < 0)\n\t\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", sockpath);\n\t}\n\tif(s_ifacewatch >= 0) {\n\t\tclose(s_ifacewatch);\n\t\ts_ifacewatch = -1;\n\t}\n\t/* empty LAN interface/address list */\n\twhile(lan_addrs.lh_first != NULL) {\n\t\tlan_addr = lan_addrs.lh_first;\n\t\tLIST_REMOVE(lan_addrs.lh_first, list);\n\t\tfree(lan_addr);\n\t}\n\t/* empty device list */\n\twhile(devlist != NULL) {\n\t\tstruct device * next = devlist->next;\n\t\tfree(devlist);\n\t\tdevlist = next;\n\t}\n\t/* empty service list */\n\twhile(servicelisthead.lh_first != NULL) {\n\t\tstruct service * serv = servicelisthead.lh_first;\n\t\tLIST_REMOVE(servicelisthead.lh_first, entries);\n\t\tfree(serv->st);\n\t\tfree(serv->usn);\n\t\tfree(serv->server);\n\t\tfree(serv->location);\n\t\tfree(serv);\n\t}\n\tif(unlink(pidfilename) < 0)\n\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", pidfilename);\n\tcloselog();\n\treturn ret;\n}\n\n", "/* $Id: testminissdpd.c,v 1.14 2016/03/01 17:49:51 nanard Exp $ */\n/* Project : miniupnp\n * website : http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * Author : Thomas BERNARD\n * copyright (c) 2005-2016 Thomas Bernard\n * This software is subjet to the conditions detailed in the\n * provided LICENCE file. */\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n\n#include \"codelength.h\"\n#include \"printresponse.h\"\n\nvoid printversion(const unsigned char * resp, int n)\n{\n\tint l;\n\tconst unsigned char * p;\n\n\tp = resp;\n\tDECODELENGTH(l, p);\n\tif(resp + n < p + l) {\n\t\tprintf(\"get version error\\n\");\n\t}\n\tprintf(\"MiniSSDPd version : %.*s\\n\", l, p);\n}\n\n#define SENDCOMMAND(command, size) write(s, command, size); \\\n              printf(\"Command written type=%u\\n\", (unsigned char)command[0]);\n\nint connect_unix_socket(const char * sockpath)\n{\n\tint s;\n\tstruct sockaddr_un addr;\n\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, sockpath, sizeof(addr.sun_path));\n\tif(connect(s, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) < 0) {\n\t\tfprintf(stderr, \"connecting to %s : \", addr.sun_path);\n\t\tperror(\"connect\");\n\t\texit(1);\n\t}\n\tprintf(\"Connected to %s\\n\", addr.sun_path);\n\treturn s;\n}\n\n/* test program for minissdpd */\nint\nmain(int argc, char * * argv)\n{\n\tconst char command0[] = { 0x00, 0x00 };\n\tchar command1[] = \"\\x01\\x00urn:schemas-upnp-org:device:InternetGatewayDevice\";\n\tchar command2[] = \"\\x02\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice\";\n\tconst char command3[] = { 0x03, 0x00 };\n\t/* old versions of minissdpd would reject a command with\n\t * a zero length string argument */\n\tchar command3compat[] = \"\\x03\\x00ssdp:all\";\n\tchar command4[] = \"\\x04\\x00test:test:test\";\n\tconst char bad_command[] = { 0xff, 0xff };\n\tconst char overflow[] = { 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tconst char command5[] = { 0x05, 0x00 };\n\tconst char bad_command4[] = { 0x04, 0x01, 0x60, 0x8f, 0xff, 0xff, 0xff, 0x7f};\n\tint s;\n\tint i;\n\tvoid * tmp;\n\tunsigned char * resp = NULL;\n\tsize_t respsize = 0;\n\tunsigned char buf[4096];\n\tssize_t n;\n\tint total = 0;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\n\tfor(i=0; i<argc-1; i++) {\n\t\tif(0==strcmp(argv[i], \"-s\"))\n\t\t\tsockpath = argv[++i];\n\t}\n\tcommand1[1] = sizeof(command1) - 3;\n\tcommand2[1] = sizeof(command2) - 3;\n\tcommand3compat[1] = sizeof(command3compat) - 3;\n\tcommand4[1] = sizeof(command4) - 3;\n\ts = connect_unix_socket(sockpath);\n\n\tn = SENDCOMMAND(command0, sizeof(command0));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tif(n > 0) {\n\t\tprintversion(buf, n);\n\t} else {\n\t\tprintf(\"Command 0 (get version) not supported\\n\");\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command1, sizeof(command1) - 1);\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command2, sizeof(command2) - 1);\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tbuf[0] = 0; /* Slight hack for printing num devices when 0 */\n\tn = SENDCOMMAND(command3, sizeof(command3));\n\tn = read(s, buf, sizeof(buf));\n\tif(n == 0) {\n\t\tprintf(\"command3 failed, testing compatible one\\n\");\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t\tn = SENDCOMMAND(command3compat, sizeof(command3compat) - 1);\n\t\tn = read(s, buf, sizeof(buf));\n\t}\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintf(\"Number of devices %d\\n\", (int)buf[0]);\n\twhile(n > 0) {\n\t\ttmp = realloc(resp, respsize + n);\n\t\tif(tmp == NULL) {\n\t\t\tfprintf(stderr, \"memory allocation error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tresp = tmp;\n\t\trespsize += n;\n\t\tif (n > 0) {\n\t\t\tmemcpy(resp + total, buf, n);\n\t\t\ttotal += n;\n\t\t}\n\t\tif (n < (ssize_t)sizeof(buf)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = read(s, buf, sizeof(buf));\n\t\tprintf(\"response received %d bytes\\n\", (int)n);\n\t}\n\tif(resp != NULL) {\n\t\tprintresponse(resp, total);\n\t\tfree(resp);\n\t\tresp = NULL;\n\t}\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command4, sizeof(command4));\n\t/* no response for request type 4 */\n\n\tn = SENDCOMMAND(bad_command, sizeof(bad_command));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(overflow, sizeof(overflow));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(command5, sizeof(command5));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\n\tn = SENDCOMMAND(bad_command4, sizeof(bad_command4));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\n\tclose(s);\n\treturn 0;\n}\n"], "filenames": ["minissdpd/Changelog.txt", "minissdpd/minissdpd.c", "minissdpd/testminissdpd.c"], "buggy_code_start_loc": [1, 1, 1], "buggy_code_end_loc": [2, 1009, 182], "fixing_code_start_loc": [1, 1, 1], "fixing_code_end_loc": [5, 1009, 193], "type": "CWE-125", "message": "The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (out-of-bounds memory access and daemon crash) via vectors involving a negative length value.", "other": {"cve": {"id": "CVE-2016-3178", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-24T15:59:00.607", "lastModified": "2021-04-23T17:27:28.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (out-of-bounds memory access and daemon crash) via vectors involving a negative length value."}, {"lang": "es", "value": "La funci\u00f3n processRequest en minissdpd.c en MiniSSDPd 1.2.20130907-3 permite a los usuarios locales causar una denegaci\u00f3n de servicio (acceso a memoria fuera de los l\u00edmites y ca\u00edda de daemon) a trav\u00e9s de vectores que implican un valor de longitud negativo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:minissdpd:1.2.20130907-3:*:*:*:*:*:*:*", "matchCriteriaId": "7DC6953D-FC60-4181-AB76-4722408AC1E9"}]}]}], "references": [{"url": "http://speirofr.appspot.com/files/advisory/SPADV-2016-02.md", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/03/16/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=816759", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47"}}