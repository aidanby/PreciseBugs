{"buggy_code": ["\"\"\"\nBlock rendering\n\"\"\"\n\nfrom __future__ import annotations\nimport json\nimport logging\nimport textwrap\nfrom collections import OrderedDict\n\nfrom functools import partial\n\nfrom completion.services import CompletionService\nfrom django.conf import settings\nfrom django.contrib.auth.models import AnonymousUser, User  # lint-amnesty, pylint: disable=imported-auth-user\nfrom django.core.cache import cache\nfrom django.db import transaction\nfrom django.http import Http404, HttpResponse, HttpResponseForbidden\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template.context_processors import csrf\nfrom django.urls import reverse\nfrom django.utils.text import slugify\nfrom django.views.decorators.clickjacking import xframe_options_exempt\nfrom django.views.decorators.csrf import csrf_exempt\nfrom edx_django_utils.cache import DEFAULT_REQUEST_CACHE, RequestCache\nfrom edx_django_utils.monitoring import set_custom_attributes_for_course_key, set_monitoring_transaction_name\nfrom edx_proctoring.api import get_attempt_status_summary\nfrom edx_proctoring.services import ProctoringService\nfrom edx_rest_framework_extensions.auth.jwt.authentication import JwtAuthentication\nfrom edx_when.field_data import DateLookupFieldData\nfrom eventtracking import tracker\nfrom opaque_keys import InvalidKeyError\nfrom opaque_keys.edx.keys import CourseKey, UsageKey\nfrom rest_framework.decorators import api_view\nfrom rest_framework.exceptions import APIException\nfrom typing import Callable, TYPE_CHECKING\nfrom web_fragments.fragment import Fragment\nfrom xblock.django.request import django_to_webob_request, webob_to_django_response\nfrom xblock.exceptions import NoSuchHandlerError, NoSuchViewError\nfrom xblock.reference.plugins import FSService\nfrom xblock.runtime import KvsFieldData\n\nfrom lms.djangoapps.teams.services import TeamsService\nfrom openedx.core.lib.xblock_services.call_to_action import CallToActionService\nfrom xmodule.contentstore.django import contentstore\nfrom xmodule.exceptions import NotFoundError, ProcessingError\nfrom xmodule.library_tools import LibraryToolsService\nfrom xmodule.modulestore.django import XBlockI18nService, modulestore\nfrom xmodule.modulestore.exceptions import ItemNotFoundError\nfrom xmodule.partitions.partitions_service import PartitionService\nfrom xmodule.util.sandboxing import SandboxService\nfrom xmodule.services import EventPublishingService, RebindUserService, SettingsService, TeamsConfigurationService\nfrom common.djangoapps.static_replace.services import ReplaceURLService\nfrom common.djangoapps.static_replace.wrapper import replace_urls_wrapper\nfrom lms.djangoapps.courseware.access import get_user_role, has_access\nfrom lms.djangoapps.courseware.entrance_exams import user_can_skip_entrance_exam, user_has_passed_entrance_exam\nfrom lms.djangoapps.courseware.masquerade import (\n    MasqueradingKeyValueStore,\n    filter_displayed_blocks,\n    is_masquerading_as_specific_student,\n    setup_masquerade\n)\nfrom lms.djangoapps.courseware.model_data import DjangoKeyValueStore, FieldDataCache\nfrom lms.djangoapps.courseware.field_overrides import OverrideFieldData\nfrom lms.djangoapps.courseware.services import UserStateService\nfrom lms.djangoapps.grades.api import GradesUtilService\nfrom lms.djangoapps.lms_xblock.field_data import LmsFieldData\nfrom lms.djangoapps.lms_xblock.runtime import UserTagsService, lms_wrappers_aside, lms_applicable_aside_types\nfrom lms.djangoapps.verify_student.services import XBlockVerificationService\nfrom openedx.core.djangoapps.bookmarks.api import BookmarksService\nfrom openedx.core.djangoapps.crawlers.models import CrawlersConfig\nfrom openedx.core.djangoapps.credit.services import CreditService\nfrom openedx.core.djangoapps.util.user_utils import SystemUser\nfrom openedx.core.djangolib.markup import HTML\nfrom openedx.core.lib.api.authentication import BearerAuthenticationAllowInactiveUser\nfrom openedx.core.lib.api.view_utils import view_auth_classes\nfrom openedx.core.lib.gating.services import GatingService\nfrom openedx.core.lib.license import wrap_with_license\nfrom openedx.core.lib.url_utils import quote_slashes, unquote_slashes\nfrom openedx.core.lib.xblock_utils import (\n    add_staff_markup,\n    get_aside_from_xblock,\n    hash_resource,\n    is_xblock_aside\n)\nfrom openedx.core.lib.xblock_utils import request_token as xblock_request_token\nfrom openedx.core.lib.xblock_utils import wrap_xblock\nfrom openedx.features.course_duration_limits.access import course_expiration_wrapper\nfrom openedx.features.discounts.utils import offer_banner_wrapper\nfrom openedx.features.content_type_gating.services import ContentTypeGatingService\nfrom common.djangoapps.student.models import anonymous_id_for_user\nfrom common.djangoapps.student.roles import CourseBetaTesterRole\nfrom common.djangoapps.util import milestones_helpers\nfrom common.djangoapps.util.json_request import JsonResponse\nfrom common.djangoapps.edxmako.services import MakoService\nfrom common.djangoapps.xblock_django.user_service import DjangoXBlockUserService\nfrom openedx.core.lib.cache_utils import CacheService\n\nif TYPE_CHECKING:\n    from rest_framework.request import Request\n    from xblock.core import XBlock\n    from xblock.runtime import Runtime\n\n    from xmodule.course_block import CourseBlock\n\nlog = logging.getLogger(__name__)\n\n# TODO: course_id and course_key are used interchangeably in this file, which is wrong.\n# Some brave person should make the variable names consistently someday, but the code's\n# coupled enough that it's kind of tricky--you've been warned!\n\n\nclass LmsModuleRenderError(Exception):\n    \"\"\"\n    An exception class for exceptions thrown by block_render that don't fit well elsewhere\n    \"\"\"\n    pass  # lint-amnesty, pylint: disable=unnecessary-pass\n\n\ndef make_track_function(request):\n    '''\n    Make a tracking function that logs what happened.\n    For use in DescriptorSystem.\n    '''\n    from common.djangoapps.track import views as track_views\n\n    def function(event_type, event):\n        return track_views.server_track(request, event_type, event, page='x_module')\n    return function\n\n\ndef toc_for_course(user, request, course, active_chapter, active_section, field_data_cache):\n    '''\n    Create a table of contents from the module store\n\n    Return format:\n    { 'chapters': [\n            {'display_name': name, 'url_name': url_name, 'sections': SECTIONS, 'active': bool},\n        ],\n        'previous_of_active_section': {..},\n        'next_of_active_section': {..}\n    }\n\n    where SECTIONS is a list\n    [ {'display_name': name, 'url_name': url_name,\n       'format': format, 'due': due, 'active' : bool, 'graded': bool}, ...]\n\n    where previous_of_active_section and next_of_active_section have information on the\n    next/previous sections of the active section.\n\n    active is set for the section and chapter corresponding to the passed\n    parameters, which are expected to be url_names of the chapter+section.\n    Everything else comes from the xml, or defaults to \"\".\n\n    chapters with name 'hidden' are skipped.\n\n    NOTE: assumes that if we got this far, user has access to course.  Returns\n    None if this is not the case.\n\n    field_data_cache must include data from the course blocks and 2 levels of its descendants\n    '''\n    with modulestore().bulk_operations(course.id):\n        course_block = get_block_for_descriptor(\n            user, request, course, field_data_cache, course.id, course=course\n        )\n        if course_block is None:\n            return None, None, None\n\n        toc_chapters = []\n        chapters = course_block.get_children()\n\n        # Check for content which needs to be completed\n        # before the rest of the content is made available\n        required_content = milestones_helpers.get_required_content(course.id, user)\n\n        # The user may not actually have to complete the entrance exam, if one is required\n        if user_can_skip_entrance_exam(user, course):\n            required_content = [content for content in required_content if not content == course.entrance_exam_id]\n\n        previous_of_active_section, next_of_active_section = None, None\n        last_processed_section, last_processed_chapter = None, None\n        found_active_section = False\n        for chapter in chapters:\n            # Only show required content, if there is required content\n            # chapter.hide_from_toc is read-only (bool)\n            # xss-lint: disable=python-deprecated-display-name\n            display_id = slugify(chapter.display_name_with_default_escaped)\n            local_hide_from_toc = False\n            if required_content:\n                if str(chapter.location) not in required_content:\n                    local_hide_from_toc = True\n\n            # Skip the current chapter if a hide flag is tripped\n            if chapter.hide_from_toc or local_hide_from_toc:\n                continue\n\n            sections = []\n            for section in chapter.get_children():\n                # skip the section if it is hidden from the user\n                if section.hide_from_toc:\n                    continue\n\n                is_section_active = (chapter.url_name == active_chapter and section.url_name == active_section)\n                if is_section_active:\n                    found_active_section = True\n\n                section_context = {\n                    # xss-lint: disable=python-deprecated-display-name\n                    'display_name': section.display_name_with_default_escaped,\n                    'url_name': section.url_name,\n                    'format': section.format if section.format is not None else '',\n                    'due': section.due,\n                    'active': is_section_active,\n                    'graded': section.graded,\n                }\n                _add_timed_exam_info(user, course, section, section_context)\n\n                # update next and previous of active section, if applicable\n                if is_section_active:\n                    if last_processed_section:\n                        previous_of_active_section = last_processed_section.copy()\n                        previous_of_active_section['chapter_url_name'] = last_processed_chapter.url_name\n                elif found_active_section and not next_of_active_section:\n                    next_of_active_section = section_context.copy()\n                    next_of_active_section['chapter_url_name'] = chapter.url_name\n\n                sections.append(section_context)\n                last_processed_section = section_context\n                last_processed_chapter = chapter\n\n            toc_chapters.append({\n                # xss-lint: disable=python-deprecated-display-name\n                'display_name': chapter.display_name_with_default_escaped,\n                'display_id': display_id,\n                'url_name': chapter.url_name,\n                'sections': sections,\n                'active': chapter.url_name == active_chapter\n            })\n        return {\n            'chapters': toc_chapters,\n            'previous_of_active_section': previous_of_active_section,\n            'next_of_active_section': next_of_active_section,\n        }\n\n\ndef _add_timed_exam_info(user, course, section, section_context):\n    \"\"\"\n    Add in rendering context if exam is a timed exam (which includes proctored)\n    \"\"\"\n    section_is_time_limited = (\n        getattr(section, 'is_time_limited', False) and\n        settings.FEATURES.get('ENABLE_SPECIAL_EXAMS', False)\n    )\n    if section_is_time_limited:\n        # call into edx_proctoring subsystem\n        # to get relevant proctoring information regarding this\n        # level of the courseware\n        #\n        # This will return None, if (user, course_id, content_id)\n        # is not applicable\n        timed_exam_attempt_context = None\n        try:\n            timed_exam_attempt_context = get_attempt_status_summary(\n                user.id,\n                str(course.id),\n                str(section.location)\n            )\n        except Exception as ex:  # pylint: disable=broad-except\n            # safety net in case something blows up in edx_proctoring\n            # as this is just informational descriptions, it is better\n            # to log and continue (which is safe) than to have it be an\n            # unhandled exception\n            log.exception(ex)\n\n        if timed_exam_attempt_context:\n            # yes, user has proctoring context about\n            # this level of the courseware\n            # so add to the accordion data context\n            section_context.update({\n                'proctoring': timed_exam_attempt_context,\n            })\n\n\ndef get_block(user, request, usage_key, field_data_cache, position=None, log_if_not_found=True,\n              wrap_xblock_display=True, grade_bucket_type=None, depth=0, static_asset_path='', course=None,\n              will_recheck_access=False):\n    \"\"\"\n    Get an instance of the XBlock class identified by location,\n    setting the state based on an existing StudentModule, or creating one if none\n    exists.\n\n    Arguments:\n      - user                  : User for whom we're getting the block\n      - request               : current django HTTPrequest.  Note: request.user isn't used for anything--all auth\n                                and such works based on user.\n      - usage_key             : A UsageKey object identifying the module to load\n      - field_data_cache      : a FieldDataCache\n      - position              : Extra information from URL for user-specified position within module.\n                                It is used to determine the active tab within the `SequenceBlock`/subsection.\n                                Once the legacy course experience is removed, it should be safe to remove this, too.\n      - log_if_not_found      : If this is True, we log a debug message if we cannot find the requested xmodule.\n      - wrap_xblock_display   : If this is True, wrap the output display in a single div to allow for the\n                                XModule javascript to be bound correctly\n      - depth                 : number of levels of descendents to cache when loading this module.\n                                None means cache all descendents\n      - static_asset_path     : static asset path to use (overrides block's value); needed\n                                by get_course_info_section, because info section modules\n                                do not have a course as the parent module, and thus do not\n                                inherit this lms key value.\n      - will_recheck_access   : If True, the caller commits to re-checking access on each child XBlock\n                                before rendering the content in order to display access error messages\n                                to the user.\n\n    Returns: XBlock instance, or None if the user does not have access to the\n    block.  If there's an error, will try to return an instance of ErrorBlock\n    if possible.  If not possible, return None.\n    \"\"\"\n    try:\n        block = modulestore().get_item(usage_key, depth=depth)\n        return get_block_for_descriptor(user, request, block, field_data_cache, usage_key.course_key,\n                                        position=position,\n                                        wrap_xblock_display=wrap_xblock_display,\n                                        grade_bucket_type=grade_bucket_type,\n                                        static_asset_path=static_asset_path,\n                                        course=course, will_recheck_access=will_recheck_access)\n    except ItemNotFoundError:\n        if log_if_not_found:\n            log.debug(\"Error in get_block: ItemNotFoundError\")\n        return None\n\n    except:  # pylint: disable=W0702\n        # Something has gone terribly wrong, but still not letting it turn into a 500.\n        log.exception(\"Error in get_block\")\n        return None\n\n\ndef display_access_messages(user, block, view, frag, context):  # pylint: disable=W0613\n    \"\"\"\n    An XBlock wrapper that replaces the content fragment with a fragment or message determined by\n    the has_access check.\n    \"\"\"\n    blocked_prior_sibling = RequestCache('display_access_messages_prior_sibling')\n\n    load_access = has_access(user, 'load', block, block.scope_ids.usage_id.course_key)\n    if load_access:\n        blocked_prior_sibling.delete(block.parent)\n        return frag\n\n    prior_sibling = blocked_prior_sibling.get_cached_response(block.parent)\n\n    if prior_sibling.is_found and prior_sibling.value.error_code == load_access.error_code:\n        return Fragment(\"\")\n    else:\n        blocked_prior_sibling.set(block.parent, load_access)\n\n    if load_access.user_fragment:\n        msg_fragment = load_access.user_fragment\n    elif load_access.user_message:\n        msg_fragment = Fragment(textwrap.dedent(HTML(\"\"\"\\\n            <div>{}</div>\n        \"\"\").format(load_access.user_message)))\n    else:\n        msg_fragment = Fragment(\"\")\n\n    if load_access.developer_message and has_access(user, 'staff', block, block.scope_ids.usage_id.course_key):\n        msg_fragment.content += textwrap.dedent(HTML(\"\"\"\\\n            <div>{}</div>\n        \"\"\").format(load_access.developer_message))\n\n    return msg_fragment\n\n\n# pylint: disable=too-many-statements\ndef get_block_for_descriptor(\n    user: User | AnonymousUser,\n    request: Request | None,\n    block: XBlock,\n    field_data_cache: FieldDataCache | None,\n    course_key: CourseKey,\n    position: int | None = None,\n    wrap_xblock_display: bool = True,\n    grade_bucket_type: str | None = None,\n    static_asset_path: str = '',\n    disable_staff_debug_info: bool = False,\n    course: CourseBlock | None = None,\n    will_recheck_access: bool = False,\n    track_function: Callable[[str, dict], None] | None = None,\n    student_data: KvsFieldData | None = None,\n    request_token: str | None = None,\n    user_location: str | None = None,\n) -> XBlock | None:\n    \"\"\"\n    Implements get_block, extracting out the request-specific functionality.\n\n    disable_staff_debug_info : If this is True, exclude staff debug information in the rendering of the block.\n\n    See get_block() docstring for further details.\n    \"\"\"\n    if request:\n        track_function = track_function or make_track_function(request)\n        user_location = user_location or getattr(request, 'session', {}).get('country_code')\n        request_token = request_token or xblock_request_token(request)\n\n    if not student_data:\n        student_kvs = DjangoKeyValueStore(field_data_cache)\n        if is_masquerading_as_specific_student(user, course_key):\n            student_kvs = MasqueradingKeyValueStore(student_kvs, request.session)\n        student_data = KvsFieldData(student_kvs)\n\n    # The runtime is already shared between XBlocks. If there are no wrappers, it is the first initialization.\n    should_recreate_runtime = not block.runtime.wrappers\n\n    # If the runtime was prepared for another user, it should be recreated.\n    # This part can be removed if we remove all user-specific handling from the runtime services and pull this\n    # information directly from XBlocks during the service initialization.\n    if not should_recreate_runtime:\n        # If the user service is absent (which should never happen), the runtime should be reinitialized.\n        # We retrieve this service directly to bypass service declaration checks.\n        if user_service := block.runtime._services.get('user'):  # pylint: disable=protected-access\n            # Check the user ID bound to the runtime. This operation can run often for complex course structures, so we\n            # are accessing the protected attribute of the user service to reduce the number of queries.\n            should_recreate_runtime = user.id != user_service._django_user.id  # pylint: disable=protected-access\n        else:\n            should_recreate_runtime = True\n\n    if should_recreate_runtime:\n        prepare_runtime_for_user(\n            user=user,\n            student_data=student_data,  # These have implicit user bindings, the rest of args are considered not to\n            runtime=block.runtime,\n            course_id=course_key,\n            track_function=track_function,\n            wrap_xblock_display=wrap_xblock_display,\n            grade_bucket_type=grade_bucket_type,\n            static_asset_path=static_asset_path,\n            user_location=user_location,\n            request_token=request_token,\n            disable_staff_debug_info=disable_staff_debug_info,\n            course=course,\n            will_recheck_access=will_recheck_access,\n        )\n\n    # Pass position specified in URL to runtime.\n    if position is not None:\n        try:\n            position = int(position)\n        except (ValueError, TypeError):\n            log.exception('Non-integer %r passed as position.', position)\n            position = None\n\n    block.runtime.set('position', position)\n\n    block.bind_for_student(\n        user.id,\n        [\n            partial(DateLookupFieldData, course_id=course_key, user=user),\n            partial(OverrideFieldData.wrap, user, course),\n            partial(LmsFieldData, student_data=student_data),\n        ],\n    )\n\n    # Do not check access when it's a noauth request.\n    # Not that the access check needs to happen after the block is bound\n    # for the student, since there may be field override data for the student\n    # that affects xblock visibility.\n    user_needs_access_check = getattr(user, 'known', True) and not isinstance(user, SystemUser)\n    if user_needs_access_check:\n        access = has_access(user, 'load', block, course_key)\n        # A block should only be returned if either the user has access, or the user doesn't have access, but\n        # the failed access has a message for the user and the caller of this function specifies it will check access\n        # again. This allows blocks to show specific error message or upsells when access is denied.\n        caller_will_handle_access_error = (\n            not access\n            and will_recheck_access\n            and (access.user_message or access.user_fragment)\n        )\n        if access or caller_will_handle_access_error:\n            block.has_access_error = bool(caller_will_handle_access_error)\n            return block\n        return None\n    return block\n\n\ndef prepare_runtime_for_user(\n        user: User | AnonymousUser,\n        student_data: KvsFieldData,\n        # Arguments preceding this comment have user binding, those following don't\n        runtime: Runtime,\n        course_id: CourseKey,\n        track_function: Callable[[str, dict], None],\n        request_token: str,\n        position: int | None = None,\n        wrap_xblock_display: bool = True,\n        grade_bucket_type: str | None = None,\n        static_asset_path: str = '',\n        user_location: str | None = None,\n        disable_staff_debug_info: bool = False,\n        course: CourseBlock | None = None,\n        will_recheck_access: bool = False,\n):\n    \"\"\"\n    Helper function that binds the given xblock to a user and student_data to a user and the block.\n\n    The purpose of this function is to factor out everywhere a user is implicitly bound when creating a module,\n    to allow an existing block to be re-bound to a user.\n\n    The arguments fall into two categories: those that have explicit or implicit user binding, which are user\n    and student_data, and those don't and are used to instantiate the service required in LMS, which\n    are all the other arguments.\n\n    Arguments:\n        see arguments for get_block()\n        request_token (str): A token unique to the request use by xblock initialization\n    \"\"\"\n\n    def inner_get_block(block: XBlock) -> XBlock | None:\n        \"\"\"\n        Delegate to get_block_for_descriptor() with all values except `block` set.\n\n        Because it does an access check, it may return None.\n        \"\"\"\n        return get_block_for_descriptor(\n            user=user,\n            request=None,\n            field_data_cache=None,\n            block=block,\n            student_data=student_data,\n            course_key=course_id,\n            track_function=track_function,\n            request_token=request_token,\n            position=position,\n            wrap_xblock_display=wrap_xblock_display,\n            grade_bucket_type=grade_bucket_type,\n            static_asset_path=static_asset_path,\n            user_location=user_location,\n            course=course,\n            will_recheck_access=will_recheck_access,\n        )\n\n    # Build a list of wrapping functions that will be applied in order\n    # to the Fragment content coming out of the xblocks that are about to be rendered.\n    block_wrappers = []\n\n    if is_masquerading_as_specific_student(user, course_id):\n        block_wrappers.append(filter_displayed_blocks)\n\n    mako_service = MakoService()\n    if settings.FEATURES.get(\"LICENSING\", False):\n        block_wrappers.append(partial(wrap_with_license, mako_service=mako_service))\n\n    # Wrap the output display in a single div to allow for the XBlock\n    # javascript to be bound correctly\n    if wrap_xblock_display is True:\n        block_wrappers.append(partial(\n            wrap_xblock,\n            'LmsRuntime',\n            extra_data={'course-id': str(course_id)},\n            usage_id_serializer=lambda usage_id: quote_slashes(str(usage_id)),\n            request_token=request_token,\n        ))\n\n    replace_url_service = partial(\n        ReplaceURLService,\n        static_asset_path=static_asset_path,\n        jump_to_id_base_url=reverse('jump_to_id', kwargs={'course_id': str(course_id), 'module_id': ''}),\n    )\n\n    # Rewrite static urls with course-specific absolute urls\n    block_wrappers.append(partial(replace_urls_wrapper, replace_url_service=replace_url_service))\n\n    block_wrappers.append(partial(display_access_messages, user))\n    block_wrappers.append(partial(course_expiration_wrapper, user))\n    block_wrappers.append(partial(offer_banner_wrapper, user))\n\n    user_is_staff = bool(has_access(user, 'staff', course_id))\n\n    if settings.FEATURES.get('DISPLAY_DEBUG_INFO_TO_STAFF'):\n        if user_is_staff or is_masquerading_as_specific_student(user, course_id):\n            # When masquerading as a specific student, we want to show the debug button\n            # unconditionally to enable resetting the state of the student we are masquerading as.\n            # We already know the user has staff access when masquerading is active.\n            block_wrappers.append(partial(add_staff_markup, user, disable_staff_debug_info))\n\n    store = modulestore()\n\n    services = {\n        'fs': FSService(),\n        'mako': mako_service,\n        'user': DjangoXBlockUserService(\n            user,\n            user_is_beta_tester=CourseBetaTesterRole(course_id).has_user(user),\n            user_is_staff=user_is_staff,\n            user_is_global_staff=bool(has_access(user, 'staff', 'global')),\n            user_role=get_user_role(user, course_id),\n            anonymous_user_id=anonymous_id_for_user(user, course_id),\n            # See the docstring of `DjangoXBlockUserService`.\n            deprecated_anonymous_user_id=anonymous_id_for_user(user, None),\n            request_country_code=user_location,\n        ),\n        'verification': XBlockVerificationService(),\n        'proctoring': ProctoringService(),\n        'milestones': milestones_helpers.get_service(),\n        'credit': CreditService(),\n        'bookmarks': BookmarksService(user=user),\n        'gating': GatingService(),\n        'grade_utils': GradesUtilService(course_id=course_id),\n        'user_state': UserStateService(),\n        'content_type_gating': ContentTypeGatingService(),\n        'cache': CacheService(cache),\n        'sandbox': SandboxService(contentstore=contentstore, course_id=course_id),\n        'replace_urls': replace_url_service,\n        # Rebind module service to deal with noauth modules getting attached to users.\n        'rebind_user': RebindUserService(\n            user,\n            course_id,\n            track_function=track_function,\n            position=position,\n            wrap_xblock_display=wrap_xblock_display,\n            grade_bucket_type=grade_bucket_type,\n            static_asset_path=static_asset_path,\n            user_location=user_location,\n            request_token=request_token,\n            will_recheck_access=will_recheck_access,\n        ),\n        'completion': CompletionService(user=user, context_key=course_id) if user and user.is_authenticated else None,\n        'i18n': XBlockI18nService,\n        'library_tools': LibraryToolsService(store, user_id=user.id if user else None),\n        'partitions': PartitionService(course_id=course_id, cache=DEFAULT_REQUEST_CACHE.data),\n        'settings': SettingsService(),\n        'user_tags': UserTagsService(user=user, course_id=course_id),\n        'teams': TeamsService(),\n        'teams_configuration': TeamsConfigurationService(),\n        'call_to_action': CallToActionService(),\n        'publish': EventPublishingService(user, course_id, track_function),\n    }\n\n    runtime.get_block_for_descriptor = inner_get_block\n\n    runtime.wrappers = block_wrappers\n    runtime._services.update(services)  # lint-amnesty, pylint: disable=protected-access\n    runtime.request_token = request_token\n    runtime.wrap_asides_override = lms_wrappers_aside\n    runtime.applicable_aside_types_override = lms_applicable_aside_types\n\n\ndef load_single_xblock(request, user_id, course_id, usage_key_string, course=None, will_recheck_access=False):\n    \"\"\"\n    Load a single XBlock identified by usage_key_string.\n    \"\"\"\n    usage_key = UsageKey.from_string(usage_key_string)\n    course_key = CourseKey.from_string(course_id)\n    usage_key = usage_key.map_into_course(course_key)\n    user = User.objects.get(id=user_id)\n    field_data_cache = FieldDataCache.cache_for_block_descendents(\n        course_key,\n        user,\n        modulestore().get_item(usage_key),\n        depth=0,\n    )\n    instance = get_block(\n        user,\n        request,\n        usage_key,\n        field_data_cache,\n        grade_bucket_type='xqueue',\n        course=course,\n        will_recheck_access=will_recheck_access\n    )\n    if instance is None:\n        msg = f\"No module {usage_key_string} for user {user}--access denied?\"\n        log.debug(msg)\n        raise Http404\n    return instance\n\n\n@csrf_exempt\ndef xqueue_callback(request, course_id, userid, mod_id, dispatch):\n    '''\n    Entry point for graded results from the queueing system.\n    '''\n    data = request.POST.copy()\n\n    # Test xqueue package, which we expect to be:\n    #   xpackage = {'xqueue_header': json.dumps({'lms_key':'secretkey',...}),\n    #               'xqueue_body'  : 'Message from grader'}\n    for key in ['xqueue_header', 'xqueue_body']:\n        if key not in data:\n            raise Http404\n\n    header = json.loads(data['xqueue_header'])\n    if not isinstance(header, dict) or 'lms_key' not in header:\n        raise Http404\n\n    course_key = CourseKey.from_string(course_id)\n\n    with modulestore().bulk_operations(course_key):\n        course = modulestore().get_course(course_key, depth=0)\n\n        instance = load_single_xblock(request, userid, course_id, mod_id, course=course)\n\n        # Transfer 'queuekey' from xqueue response header to the data.\n        # This is required to use the interface defined by 'handle_ajax'\n        data.update({'queuekey': header['lms_key']})\n\n        # We go through the \"AJAX\" path\n        # So far, the only dispatch from xqueue will be 'score_update'\n        try:\n            # Can ignore the return value--not used for xqueue_callback\n            instance.handle_ajax(dispatch, data)\n            # Save any state that has changed to the underlying KeyValueStore\n            instance.save()\n        except:\n            log.exception(\"error processing ajax call\")\n            raise\n\n        return HttpResponse(\"\")\n\n\n@csrf_exempt\n@xframe_options_exempt\n@transaction.non_atomic_requests\ndef handle_xblock_callback_noauth(request, course_id, usage_id, handler, suffix=None):\n    \"\"\"\n    Entry point for unauthenticated XBlock handlers.\n    \"\"\"\n    request.user.known = False\n\n    course_key = CourseKey.from_string(course_id)\n    with modulestore().bulk_operations(course_key):\n        course = modulestore().get_course(course_key, depth=0)\n        return _invoke_xblock_handler(request, course_id, usage_id, handler, suffix, course=course)\n\n\n@csrf_exempt\n@xframe_options_exempt\n@transaction.non_atomic_requests\ndef handle_xblock_callback(request, course_id, usage_id, handler, suffix=None):\n    \"\"\"\n    Generic view for extensions. This is where AJAX calls go.\n\n    Arguments:\n        request (Request): Django request.\n        course_id (str): Course containing the block\n        usage_id (str)\n        handler (str)\n        suffix (str)\n\n    Raises:\n        HttpResponseForbidden: If the request method is not `GET` and user is not authenticated.\n        Http404: If the course is not found in the modulestore.\n    \"\"\"\n    # In this case, we are using Session based authentication, so we need to check CSRF token.\n    if request.user.is_authenticated:\n        error = CsrfViewMiddleware(get_response=lambda request: None).process_view(request, None, (), {})\n        if error:\n            return error\n\n    # We are reusing DRF logic to provide support for JWT and Oauth2. We abandoned the idea of using DRF view here\n    # to avoid introducing backwards-incompatible changes.\n    # You can see https://github.com/openedx/XBlock/pull/383 for more details.\n    else:\n        authentication_classes = (JwtAuthentication, BearerAuthenticationAllowInactiveUser)\n        authenticators = [auth() for auth in authentication_classes]\n\n        for authenticator in authenticators:\n            try:\n                user_auth_tuple = authenticator.authenticate(request)\n            except APIException:\n                log.exception(\n                    \"XBlock handler %r failed to authenticate with %s\", handler, authenticator.__class__.__name__\n                )\n            else:\n                if user_auth_tuple is not None:\n                    request.user, _ = user_auth_tuple\n                    break\n\n    # NOTE (CCB): Allow anonymous GET calls (e.g. for transcripts). Modifying this view is simpler than updating\n    # the XBlocks to use `handle_xblock_callback_noauth`, which is practically identical to this view.\n    if request.method != 'GET' and not (request.user and request.user.is_authenticated):\n        return HttpResponseForbidden('Unauthenticated')\n\n    request.user.known = request.user.is_authenticated\n\n    try:\n        course_key = CourseKey.from_string(course_id)\n    except InvalidKeyError:\n        raise Http404(f'{course_id} is not a valid course key')  # lint-amnesty, pylint: disable=raise-missing-from\n\n    with modulestore().bulk_operations(course_key):\n        try:\n            course = modulestore().get_course(course_key)\n        except ItemNotFoundError:\n            raise Http404(f'{course_id} does not exist in the modulestore')  # lint-amnesty, pylint: disable=raise-missing-from\n\n        return _invoke_xblock_handler(request, course_id, usage_id, handler, suffix, course=course)\n\n\ndef _get_usage_key_for_course(course_key, usage_id) -> UsageKey:\n    \"\"\"\n    Returns UsageKey mapped into the course for a given usage_id string\n    \"\"\"\n    try:\n        return UsageKey.from_string(unquote_slashes(usage_id)).map_into_course(course_key)\n    except InvalidKeyError as exc:\n        raise Http404(\"Invalid location\") from exc\n\n\ndef _get_block_by_usage_key(usage_key):\n    \"\"\"\n    Gets a block instance based on a mapped-to-course usage_key\n\n    Returns (instance, tracking_context)\n    \"\"\"\n    try:\n        block = modulestore().get_item(usage_key)\n        block_orig_usage_key, block_orig_version = modulestore().get_block_original_usage(usage_key)\n    except ItemNotFoundError as exc:\n        log.warning(\n            \"Invalid location for course id %s: %s\",\n            usage_key.course_key,\n            usage_key\n        )\n        raise Http404 from exc\n\n    tracking_context = {\n        'module': {\n            # xss-lint: disable=python-deprecated-display-name\n            'display_name': block.display_name_with_default_escaped,\n            'usage_key': str(block.location),\n        }\n    }\n\n    # For blocks that are inherited from a content library, we add some additional metadata:\n    if block_orig_usage_key is not None:\n        tracking_context['module']['original_usage_key'] = str(block_orig_usage_key)\n        tracking_context['module']['original_usage_version'] = str(block_orig_version)\n\n    return block, tracking_context\n\n\ndef get_block_by_usage_id(request, course_id, usage_id, disable_staff_debug_info=False, course=None,\n                          will_recheck_access=False):\n    \"\"\"\n    Gets a block instance based on its `usage_id` in a course, for a given request/user\n\n    Returns (instance, tracking_context)\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    usage_key = _get_usage_key_for_course(course_key, usage_id)\n    block, tracking_context = _get_block_by_usage_key(usage_key)\n\n    _, user = setup_masquerade(request, course_key, has_access(request.user, 'staff', block, course_key))\n    field_data_cache = FieldDataCache.cache_for_block_descendents(\n        course_key,\n        user,\n        block,\n        read_only=CrawlersConfig.is_crawler(request),\n    )\n    instance = get_block_for_descriptor(\n        user,\n        request,\n        block,\n        field_data_cache,\n        usage_key.course_key,\n        disable_staff_debug_info=disable_staff_debug_info,\n        course=course,\n        will_recheck_access=will_recheck_access,\n    )\n    if instance is None:\n        # Either permissions just changed, or someone is trying to be clever\n        # and load something they shouldn't have access to.\n        log.debug(\"No module %s for user %s -- access denied?\", usage_key, user)\n        raise Http404\n\n    return instance, tracking_context\n\n\ndef _invoke_xblock_handler(request, course_id, usage_id, handler, suffix, course=None):\n    \"\"\"\n    Invoke an XBlock handler, either authenticated or not.\n\n    Arguments:\n        request (HttpRequest): the current request\n        course_id (str): A string of the form org/course/run\n        usage_id (str): A string of the form i4x://org/course/category/name@revision\n        handler (str): The name of the handler to invoke\n        suffix (str): The suffix to pass to the handler when invoked\n    \"\"\"\n\n    # Check submitted files\n    files = request.FILES or {}\n    error_msg = _check_files_limits(files)\n    if error_msg:\n        return JsonResponse({'success': error_msg}, status=413)\n\n    # Make a CourseKey from the course_id, raising a 404 upon parse error.\n    try:\n        course_key = CourseKey.from_string(course_id)\n    except InvalidKeyError as exc:\n        raise Http404 from exc\n\n    set_custom_attributes_for_course_key(course_key)\n\n    with modulestore().bulk_operations(course_key):\n        usage_key = _get_usage_key_for_course(course_key, usage_id)\n        if is_xblock_aside(usage_key):\n            # Get the usage key for the block being wrapped by the aside (not the aside itself)\n            block_usage_key = usage_key.usage_key\n        else:\n            block_usage_key = usage_key\n\n        # Peek at the handler method to see if it actually wants to check access itself. (The handler may not want\n        # inaccessible blocks stripped from the tree.) This ends up doing two modulestore lookups for the block,\n        # but the blocks should be available in the request cache the second time.\n        # At the time of writing, this is only used by one handler. If this usage grows, we may want to re-evaluate\n        # how we do this to something more elegant. If you are the author of a third party block that decides it wants\n        # to set this too, please let us know so we can consider making this easier / better-documented.\n        block, _ = _get_block_by_usage_key(block_usage_key)\n        handler_method = getattr(block, handler, False)\n        will_recheck_access = handler_method and getattr(handler_method, 'will_recheck_access', False)\n\n        instance, tracking_context = get_block_by_usage_id(\n            request, course_id, str(block_usage_key), course=course, will_recheck_access=will_recheck_access,\n        )\n\n        # Name the transaction so that we can view XBlock handlers separately in\n        # New Relic. The suffix is necessary for XBlock handlers because the\n        # \"handler\" in those cases is always just \"xmodule_handler\".\n        nr_tx_name = f\"{instance.__class__.__name__}.{handler}\"\n        nr_tx_name += f\"/{suffix}\" if (suffix and handler == \"xmodule_handler\") else \"\"\n        set_monitoring_transaction_name(nr_tx_name, group=\"Python/XBlock/Handler\")\n\n        tracking_context_name = 'module_callback_handler'\n        req = django_to_webob_request(request)\n        try:\n            with tracker.get_tracker().context(tracking_context_name, tracking_context):\n                if is_xblock_aside(usage_key):\n                    # In this case, 'instance' is the XBlock being wrapped by the aside, so\n                    # the actual aside instance needs to be retrieved in order to invoke its\n                    # handler method.\n                    handler_instance = get_aside_from_xblock(instance, usage_key.aside_type)\n                else:\n                    handler_instance = instance\n                resp = handler_instance.handle(handler, req, suffix)\n                if suffix == 'problem_check' \\\n                        and course \\\n                        and getattr(course, 'entrance_exam_enabled', False) \\\n                        and getattr(instance, 'in_entrance_exam', False):\n                    ee_data = {'entrance_exam_passed': user_has_passed_entrance_exam(request.user, course)}\n                    resp = append_data_to_webob_response(resp, ee_data)\n\n        except NoSuchHandlerError:\n            log.exception(\"XBlock %s attempted to access missing handler %r\", instance, handler)\n            raise Http404  # lint-amnesty, pylint: disable=raise-missing-from\n\n        # If we can't find the block, respond with a 404\n        except NotFoundError:\n            log.exception(\"Module indicating to user that request doesn't exist\")\n            raise Http404  # lint-amnesty, pylint: disable=raise-missing-from\n\n        # For XBlock-specific errors, we log the error and respond with an error message\n        except ProcessingError as err:\n            log.warning(\"Module encountered an error while processing AJAX call\",\n                        exc_info=True)\n            return JsonResponse({'success': err.args[0]}, status=200)\n\n        # If any other error occurred, re-raise it to trigger a 500 response\n        except Exception:\n            log.exception(\"error executing xblock handler\")\n            raise\n\n    return webob_to_django_response(resp)\n\n\n@api_view(['GET'])\n@view_auth_classes(is_authenticated=True)\ndef xblock_view(request, course_id, usage_id, view_name):\n    \"\"\"\n    Returns the rendered view of a given XBlock, with related resources\n\n    Returns a json object containing two keys:\n        html: The rendered html of the view\n        resources: A list of tuples where the first element is the resource hash, and\n            the second is the resource description\n    \"\"\"\n    if not settings.FEATURES.get('ENABLE_XBLOCK_VIEW_ENDPOINT', False):\n        log.warning(\"Attempt to use deactivated XBlock view endpoint -\"\n                    \" see FEATURES['ENABLE_XBLOCK_VIEW_ENDPOINT']\")\n        raise Http404\n\n    try:\n        course_key = CourseKey.from_string(course_id)\n    except InvalidKeyError:\n        raise Http404(\"Invalid location\")  # lint-amnesty, pylint: disable=raise-missing-from\n\n    with modulestore().bulk_operations(course_key):\n        course = modulestore().get_course(course_key)\n        instance, _ = get_block_by_usage_id(request, course_id, usage_id, course=course)\n\n        try:\n            fragment = instance.render(view_name, context=request.GET)\n        except NoSuchViewError:\n            log.exception(\"Attempt to render missing view on %s: %s\", instance, view_name)\n            raise Http404  # lint-amnesty, pylint: disable=raise-missing-from\n\n        hashed_resources = OrderedDict()\n        for resource in fragment.resources:\n            hashed_resources[hash_resource(resource)] = resource\n\n        return JsonResponse({\n            'html': fragment.content,\n            'resources': list(hashed_resources.items()),\n            'csrf_token': str(csrf(request)['csrf_token']),\n        })\n\n\ndef _check_files_limits(files):\n    \"\"\"\n    Check if the files in a request are under the limits defined by\n    `settings.MAX_FILEUPLOADS_PER_INPUT` and\n    `settings.STUDENT_FILEUPLOAD_MAX_SIZE`.\n\n    Returns None if files are correct or an error messages otherwise.\n    \"\"\"\n    for fileinput_id in files.keys():\n        inputfiles = files.getlist(fileinput_id)\n\n        # Check number of files submitted\n        if len(inputfiles) > settings.MAX_FILEUPLOADS_PER_INPUT:\n            msg = 'Submission aborted! Maximum %d files may be submitted at once' % \\\n                  settings.MAX_FILEUPLOADS_PER_INPUT\n            return msg\n\n        # Check file sizes\n        for inputfile in inputfiles:\n            if inputfile.size > settings.STUDENT_FILEUPLOAD_MAX_SIZE:  # Bytes\n                msg = 'Submission aborted! Your file \"%s\" is too large (max size: %d MB)' % \\\n                      (inputfile.name, settings.STUDENT_FILEUPLOAD_MAX_SIZE / (1000 ** 2))\n                return msg\n\n    return None\n\n\ndef append_data_to_webob_response(response, data):\n    \"\"\"\n    Appends data to a JSON webob response.\n\n    Arguments:\n        response (webob response object):  the webob response object that needs to be modified\n        data (dict):  dictionary containing data that needs to be appended to response body\n\n    Returns:\n        (webob response object):  webob response with updated body.\n\n    \"\"\"\n    if getattr(response, 'content_type', None) == 'application/json':\n        json_input = response.body.decode('utf-8') if isinstance(response.body, bytes) else response.body\n        response_data = json.loads(json_input)\n        response_data.update(data)\n        response.body = json.dumps(response_data).encode('utf-8')\n    return response\n", "\"\"\"\nTest for lms courseware app, block render unit\n\"\"\"\nimport json\nimport textwrap\nfrom datetime import datetime\nfrom functools import partial\nfrom unittest.mock import MagicMock, Mock, patch\nimport warnings\n\nimport pytest\nimport ddt\nimport pytz\nfrom bson import ObjectId\nfrom completion.waffle import ENABLE_COMPLETION_TRACKING_SWITCH  # lint-amnesty, pylint: disable=wrong-import-order\nfrom completion.models import BlockCompletion  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.conf import settings  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.contrib.auth.models import AnonymousUser  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.http import Http404, HttpResponse  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.middleware.csrf import get_token  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.test.client import RequestFactory  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.test.utils import override_settings  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.urls import reverse  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_proctoring.api import create_exam, create_exam_attempt, update_attempt_status  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_proctoring.runtime import set_runtime_service  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_proctoring.tests.test_services import MockCertificateService, MockCreditService, MockGradesService  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_toggles.toggles.testutils import override_waffle_switch  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_when.field_data import DateLookupFieldData  # lint-amnesty, pylint: disable=wrong-import-order\nfrom freezegun import freeze_time  # lint-amnesty, pylint: disable=wrong-import-order\nfrom milestones.tests.utils import MilestonesTestCaseMixin  # lint-amnesty, pylint: disable=wrong-import-order\nfrom opaque_keys.edx.asides import AsideUsageKeyV2  # lint-amnesty, pylint: disable=wrong-import-order\nfrom opaque_keys.edx.keys import CourseKey, UsageKey  # lint-amnesty, pylint: disable=wrong-import-order\nfrom pyquery import PyQuery  # lint-amnesty, pylint: disable=wrong-import-order\nfrom web_fragments.fragment import Fragment  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.completable import CompletableXBlockMixin  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.core import XBlock, XBlockAside  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.exceptions import NoSuchServiceError\nfrom xblock.field_data import FieldData  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.fields import ScopeIds  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.runtime import DictKeyValueStore, KvsFieldData  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.test.tools import TestRuntime  # lint-amnesty, pylint: disable=wrong-import-order\n\nfrom xmodule.capa.tests.response_xml_factory import OptionResponseXMLFactory  # lint-amnesty, pylint: disable=reimported\nfrom xmodule.capa_block import ProblemBlock\nfrom xmodule.contentstore.django import contentstore\nfrom xmodule.html_block import AboutBlock, CourseInfoBlock, HtmlBlock, StaticTabBlock\nfrom xmodule.lti_block import LTIBlock\nfrom xmodule.modulestore import ModuleStoreEnum\nfrom xmodule.modulestore.django import XBlockI18nService, modulestore\nfrom xmodule.modulestore.tests.django_utils import (\n    TEST_DATA_SPLIT_MODULESTORE,\n    ModuleStoreTestCase,\n    SharedModuleStoreTestCase,\n    upload_file_to_course,\n)\nfrom xmodule.modulestore.tests.factories import CourseFactory, BlockFactory, ToyCourseFactory, check_mongo_calls  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xmodule.modulestore.tests.test_asides import AsideTestType  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xmodule.services import RebindUserServiceError\nfrom xmodule.video_block import VideoBlock  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xmodule.x_module import STUDENT_VIEW, DescriptorSystem  # lint-amnesty, pylint: disable=wrong-import-order\nfrom common.djangoapps.course_modes.models import CourseMode  # lint-amnesty, pylint: disable=reimported\nfrom common.djangoapps.student.tests.factories import (\n    BetaTesterFactory,\n    GlobalStaffFactory,\n    InstructorFactory,\n    RequestFactoryNoCsrf,\n    StaffFactory,\n    UserFactory,\n)\nfrom common.djangoapps.xblock_django.constants import (\n    ATTR_KEY_ANONYMOUS_USER_ID,\n    ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID,\n    ATTR_KEY_USER_IS_BETA_TESTER,\n    ATTR_KEY_USER_IS_GLOBAL_STAFF,\n    ATTR_KEY_USER_IS_STAFF,\n    ATTR_KEY_USER_ROLE,\n)\nfrom lms.djangoapps.courseware import block_render as render\nfrom lms.djangoapps.courseware.access_response import AccessResponse\nfrom lms.djangoapps.courseware.courses import get_course_info_section, get_course_with_access\nfrom lms.djangoapps.courseware.field_overrides import OverrideFieldData\nfrom lms.djangoapps.courseware.masquerade import CourseMasquerade\nfrom lms.djangoapps.courseware.model_data import FieldDataCache\nfrom lms.djangoapps.courseware.models import StudentModule\nfrom lms.djangoapps.courseware.block_render import get_block_for_descriptor, hash_resource\nfrom lms.djangoapps.courseware.tests.factories import StudentModuleFactory\nfrom lms.djangoapps.courseware.tests.test_submitting_problems import TestSubmittingProblems\nfrom lms.djangoapps.courseware.tests.tests import LoginEnrollmentTestCase\nfrom lms.djangoapps.lms_xblock.field_data import LmsFieldData\nfrom openedx.core.djangoapps.credit.api import set_credit_requirement_status, set_credit_requirements\nfrom openedx.core.djangoapps.credit.models import CreditCourse\nfrom openedx.core.djangoapps.oauth_dispatch.jwt import create_jwt_for_user\nfrom openedx.core.djangoapps.oauth_dispatch.tests.factories import AccessTokenFactory, ApplicationFactory\nfrom openedx.core.lib.courses import course_image_url\nfrom openedx.core.lib.gating import api as gating_api\nfrom openedx.core.lib.url_utils import quote_slashes\nfrom common.djangoapps.student.models import CourseEnrollment, anonymous_id_for_user\nfrom lms.djangoapps.verify_student.tests.factories import SoftwareSecurePhotoVerificationFactory\nfrom common.djangoapps.xblock_django.models import XBlockConfiguration\n\n\nTEST_DATA_DIR = settings.COMMON_TEST_DATA_ROOT\n\n\n@XBlock.needs('fs')\n@XBlock.needs('mako')\n@XBlock.needs('user')\n@XBlock.needs('verification')\n@XBlock.needs('proctoring')\n@XBlock.needs('milestones')\n@XBlock.needs('credit')\n@XBlock.needs('bookmarks')\n@XBlock.needs('gating')\n@XBlock.needs('grade_utils')\n@XBlock.needs('user_state')\n@XBlock.needs('content_type_gating')\n@XBlock.needs('cache')\n@XBlock.needs('sandbox')\n@XBlock.needs('replace_urls')\n@XBlock.needs('rebind_user')\n@XBlock.needs('completion')\n@XBlock.needs('i18n')\n@XBlock.needs('library_tools')\n@XBlock.needs('partitions')\n@XBlock.needs('settings')\n@XBlock.needs('user_tags')\n@XBlock.needs('badging')\n@XBlock.needs('teams')\n@XBlock.needs('teams_configuration')\n@XBlock.needs('call_to_action')\nclass PureXBlock(XBlock):\n    \"\"\"\n    Pure XBlock to use in tests.\n    \"\"\"\n    pass  # lint-amnesty, pylint: disable=unnecessary-pass\n\n\nclass GradedStatelessXBlock(XBlock):\n    \"\"\"\n    This XBlock exists to test grade storage for blocks that don't store\n    student state in a scoped field.\n    \"\"\"\n\n    @XBlock.json_handler\n    def set_score(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Set the score for this testing XBlock.\n        \"\"\"\n        self.runtime.publish(\n            self,\n            'grade',\n            {\n                'value': json_data['grade'],\n                'max_value': 1\n            }\n        )\n\n\nclass StubCompletableXBlock(CompletableXBlockMixin):\n    \"\"\"\n    This XBlock exists to test completion storage.\n    \"\"\"\n\n    @XBlock.json_handler\n    def complete(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Mark the block's completion value using the completion API.\n        \"\"\"\n        return self.runtime.publish(  # lint-amnesty, pylint: disable=no-member\n            self,\n            'completion',\n            {'completion': json_data['completion']},\n        )\n\n    @XBlock.json_handler\n    def progress(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Mark the block as complete using the deprecated progress interface.\n\n        New code should use the completion event instead.\n        \"\"\"\n        return self.runtime.publish(self, 'progress', {})  # lint-amnesty, pylint: disable=no-member\n\n\nclass XBlockWithoutCompletionAPI(XBlock):\n    \"\"\"\n    This XBlock exists to test completion storage for xblocks\n    that don't support completion API but do emit progress signal.\n    \"\"\"\n\n    @XBlock.json_handler\n    def progress(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Mark the block as complete using the deprecated progress interface.\n\n        New code should use the completion event instead.\n        \"\"\"\n        return self.runtime.publish(self, 'progress', {})\n\n\n@ddt.ddt\nclass BlockRenderTestCase(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Tests of courseware.block_render\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.toy_course = modulestore().get_course(cls.course_key)\n\n    # TODO: this test relies on the specific setup of the toy course.\n    # It should be rewritten to build the course it needs and then test that.\n    def setUp(self):\n        \"\"\"\n        Set up the course and user context\n        \"\"\"\n        super().setUp()\n        OverrideFieldData.provider_classes = None\n\n        self.mock_user = UserFactory()\n        self.mock_user.id = 1\n        self.request_factory = RequestFactoryNoCsrf()\n\n        # Construct a mock block for the modulestore to return\n        self.mock_block = MagicMock()\n        self.mock_block.id = 1\n        self.dispatch = 'score_update'\n\n        # Construct a 'standard' xqueue_callback url\n        self.callback_url = reverse(\n            'xqueue_callback',\n            kwargs=dict(\n                course_id=str(self.course_key),\n                userid=str(self.mock_user.id),\n                mod_id=self.mock_block.id,\n                dispatch=self.dispatch\n            )\n        )\n\n    def tearDown(self):\n        OverrideFieldData.provider_classes = None\n        super().tearDown()\n\n    def test_get_block(self):\n        assert render.get_block('dummyuser', None, 'invalid location', None) is None\n\n    def test_block_render_with_jump_to_id(self):\n        \"\"\"\n        This test validates that the /jump_to_id/<id> shorthand for intracourse linking works assertIn\n        expected. Note there's a HTML element in the 'toy' course with the url_name 'toyjumpto' which\n        defines this linkage\n        \"\"\"\n        mock_request = MagicMock()\n        mock_request.user = self.mock_user\n\n        course = get_course_with_access(self.mock_user, 'load', self.course_key)\n\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course_key, self.mock_user, course, depth=2)\n\n        block = render.get_block(\n            self.mock_user,\n            mock_request,\n            self.course_key.make_usage_key('html', 'toyjumpto'),\n            field_data_cache,\n        )\n\n        # get the rendered HTML output which should have the rewritten link\n        html = block.render(STUDENT_VIEW).content\n\n        # See if the url got rewritten to the target link\n        # note if the URL mapping changes then this assertion will break\n        assert '/courses/' + str(self.course_key) + '/jump_to_id/vertical_test' in html\n\n    def test_xqueue_callback_success(self):\n        \"\"\"\n        Test for happy-path xqueue_callback\n        \"\"\"\n        fake_key = 'fake key'\n        xqueue_header = json.dumps({'lms_key': fake_key})\n        data = {\n            'xqueue_header': xqueue_header,\n            'xqueue_body': 'hello world',\n        }\n\n        # Patch getmodule to return our mock block\n        with patch('lms.djangoapps.courseware.block_render.load_single_xblock', return_value=self.mock_block):\n            # call xqueue_callback with our mocked information\n            request = self.request_factory.post(self.callback_url, data)\n            render.xqueue_callback(\n                request,\n                str(self.course_key),\n                self.mock_user.id,\n                self.mock_block.id,\n                self.dispatch\n            )\n\n        # Verify that handle ajax is called with the correct data\n        request.POST._mutable = True  # lint-amnesty, pylint: disable=protected-access\n        request.POST['queuekey'] = fake_key\n        self.mock_block.handle_ajax.assert_called_once_with(self.dispatch, request.POST)\n\n    def test_xqueue_callback_missing_header_info(self):\n        data = {\n            'xqueue_header': '{}',\n            'xqueue_body': 'hello world',\n        }\n\n        with patch('lms.djangoapps.courseware.block_render.load_single_xblock', return_value=self.mock_block):\n            # Test with missing xqueue data\n            with pytest.raises(Http404):\n                request = self.request_factory.post(self.callback_url, {})\n                render.xqueue_callback(\n                    request,\n                    str(self.course_key),\n                    self.mock_user.id,\n                    self.mock_block.id,\n                    self.dispatch\n                )\n\n            # Test with missing xqueue_header\n            with pytest.raises(Http404):\n                request = self.request_factory.post(self.callback_url, data)\n                render.xqueue_callback(\n                    request,\n                    str(self.course_key),\n                    self.mock_user.id,\n                    self.mock_block.id,\n                    self.dispatch\n                )\n\n    def _get_dispatch_url(self):\n        \"\"\"Helper to get dispatch URL for testing xblock callback.\"\"\"\n        return reverse(\n            'xblock_handler',\n            args=[\n                str(self.course_key),\n                quote_slashes(str(self.course_key.make_usage_key('sequential', 'Toy_Videos'))),\n                'xmodule_handler',\n                'goto_position'\n            ]\n        )\n\n    def test_anonymous_get_xblock_callback(self):\n        \"\"\"Test that anonymous GET is allowed.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.get(dispatch_url)\n        assert 200 == response.status_code\n\n    def test_anonymous_post_xblock_callback(self):\n        \"\"\"Test that anonymous POST is not allowed.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.post(dispatch_url, {'position': 2})\n\n        # https://openedx.atlassian.net/browse/LEARNER-7131\n        assert 'Unauthenticated' == response.content.decode('utf-8')\n        assert 403 == response.status_code\n\n    def test_session_authentication(self):\n        \"\"\" Test that the xblock endpoint supports session authentication.\"\"\"\n        self.client.login(username=self.mock_user.username, password=self.TEST_PASSWORD)\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.post(dispatch_url)\n        assert 200 == response.status_code\n\n    def test_oauth_authentication(self):\n        \"\"\" Test that the xblock endpoint supports OAuth authentication.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        access_token = AccessTokenFactory(user=self.mock_user, application=ApplicationFactory()).token\n        headers = {'HTTP_AUTHORIZATION': 'Bearer ' + access_token}\n        response = self.client.post(dispatch_url, {}, **headers)\n        assert 200 == response.status_code\n\n    def test_jwt_authentication(self):\n        \"\"\" Test that the xblock endpoint supports JWT authentication.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        token = create_jwt_for_user(self.mock_user)\n        headers = {'HTTP_AUTHORIZATION': 'JWT ' + token}\n        response = self.client.post(dispatch_url, {}, **headers)\n        assert 200 == response.status_code\n\n    def test_missing_position_handler(self):\n        \"\"\"\n        Test that sending POST request without or invalid position argument don't raise server error\n        \"\"\"\n        self.client.login(username=self.mock_user.username, password=self.TEST_PASSWORD)\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.post(dispatch_url)\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': ''})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': '-1'})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': \"string\"})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': \"\u03a6\u03c5\u03c3\u03b9\u03ba\u03ac\"})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': ''})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n    @ddt.data('pure', 'vertical')\n    @XBlock.register_temp_plugin(PureXBlock, identifier='pure')\n    def test_rebinding_same_user(self, block_type):\n        request = self.request_factory.get('')\n        request.user = self.mock_user\n        course = CourseFactory()\n        block = BlockFactory(category=block_type, parent=course)\n        field_data_cache = FieldDataCache([self.toy_course, block], self.toy_course.id, self.mock_user)\n        # This is verifying that caching doesn't cause an error during get_block_for_descriptor, which\n        # is why it calls the method twice identically.\n        render.get_block_for_descriptor(\n            self.mock_user,\n            request,\n            block,\n            field_data_cache,\n            self.toy_course.id,\n            course=self.toy_course\n        )\n        render.get_block_for_descriptor(\n            self.mock_user,\n            request,\n            block,\n            field_data_cache,\n            self.toy_course.id,\n            course=self.toy_course\n        )\n\n    @override_settings(FIELD_OVERRIDE_PROVIDERS=(\n        'lms.djangoapps.courseware.student_field_overrides.IndividualStudentOverrideProvider',\n    ))\n    @patch('xmodule.modulestore.xml.ImportSystem.applicable_aside_types', lambda self, block: ['test_aside'])\n    @patch('xmodule.modulestore.split_mongo.caching_descriptor_system.CachingDescriptorSystem.applicable_aside_types',\n           lambda self, block: ['test_aside'])\n    @XBlockAside.register_temp_plugin(AsideTestType, 'test_aside')\n    @ddt.data('regular', 'test_aside')\n    def test_rebind_different_users(self, block_category):\n        \"\"\"\n        This tests the rebinding a block to a student does not result\n        in overly nested _field_data.\n        \"\"\"\n        def create_aside(item, block_type):\n            \"\"\"\n            Helper function to create aside\n            \"\"\"\n            key_store = DictKeyValueStore()\n            field_data = KvsFieldData(key_store)\n            runtime = TestRuntime(services={'field-data': field_data})\n\n            def_id = runtime.id_generator.create_definition(block_type)\n            usage_id = AsideUsageKeyV2(runtime.id_generator.create_usage(def_id), \"aside\")\n            aside = AsideTestType(scope_ids=ScopeIds('user', block_type, def_id, usage_id), runtime=runtime)\n            aside.content = '%s_new_value11' % block_type\n            aside.data_field = '%s_new_value12' % block_type\n            aside.has_score = False\n\n            modulestore().update_item(item, self.mock_user.id, asides=[aside])\n            return item\n\n        request = self.request_factory.get('')\n        request.user = self.mock_user\n        course = CourseFactory.create()\n\n        block = BlockFactory(category=\"html\", parent=course)\n        if block_category == 'test_aside':\n            block = create_aside(block, \"test_aside\")\n\n        field_data_cache = FieldDataCache(\n            [course, block], course.id, self.mock_user\n        )\n\n        # grab what _field_data was originally set to\n        original_field_data = block._field_data  # lint-amnesty, pylint: disable=no-member, protected-access\n\n        render.get_block_for_descriptor(\n            self.mock_user, request, block, field_data_cache, course.id, course=course\n        )\n\n        # check that block.runtime.service(block, 'field-data-unbound') is the same as the original\n        # _field_data, but now _field_data as been reset.\n        assert block.runtime.service(block, 'field-data-unbound') is original_field_data\n        assert block.runtime.service(block, 'field-data-unbound') is not block._field_data  # pylint: disable=protected-access, line-too-long\n\n        # now bind this block to a few other students\n        for user in [UserFactory(), UserFactory(), self.mock_user]:\n            render.get_block_for_descriptor(\n                user,\n                request,\n                block,\n                field_data_cache,\n                course.id,\n                course=course\n            )\n\n        # _field_data should now be wrapped by LmsFieldData\n        # pylint: disable=protected-access\n        assert isinstance(block._field_data, LmsFieldData)  # lint-amnesty, pylint: disable=no-member\n\n        # the LmsFieldData should now wrap OverrideFieldData\n        assert isinstance(block._field_data._authored_data._source, OverrideFieldData)   # lint-amnesty, pylint: disable=no-member, line-too-long\n\n        # the OverrideFieldData should point to the date FieldData\n        assert isinstance(block._field_data._authored_data._source.fallback, DateLookupFieldData)    # lint-amnesty, pylint: disable=no-member, line-too-long\n        assert block._field_data._authored_data._source.fallback._defaults \\\n            is block.runtime.service(block, 'field-data-unbound')\n\n    def test_hash_resource(self):\n        \"\"\"\n        Ensure that the resource hasher works and does not fail on unicode,\n        decoded or otherwise.\n        \"\"\"\n        resources = ['ASCII text', '\u2744 I am a special snowflake.', \"\u2744 So am I, but I didn't tell you.\"]\n        assert hash_resource(resources) == '50c2ae79fbce9980e0803848914b0a09'\n\n\n@ddt.ddt\nclass TestHandleXBlockCallback(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test the handle_xblock_callback function\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.toy_course = modulestore().get_course(cls.course_key)\n\n    def setUp(self):\n        super().setUp()\n\n        self.location = self.course_key.make_usage_key('chapter', 'Overview')\n        self.mock_user = UserFactory.create()\n        self.request_factory = RequestFactoryNoCsrf()\n\n        # Construct a mock block for the modulestore to return\n        self.mock_block = MagicMock()\n        self.mock_block.id = 1\n        self.dispatch = 'score_update'\n\n        # Construct a 'standard' xqueue_callback url\n        self.callback_url = reverse(\n            'xqueue_callback', kwargs={\n                'course_id': str(self.course_key),\n                'userid': str(self.mock_user.id),\n                'mod_id': self.mock_block.id,\n                'dispatch': self.dispatch\n            }\n        )\n\n    def _mock_file(self, name='file', size=10):\n        \"\"\"Create a mock file object for testing uploads\"\"\"\n        mock_file = MagicMock(\n            size=size,\n            read=lambda: 'x' * size\n        )\n        # We can't use `name` as a kwarg to Mock to set the name attribute\n        # because mock uses `name` to name the mock itself\n        mock_file.name = name\n        return mock_file\n\n    def make_xblock_callback_response(self, request_data, course, block, handler):\n        \"\"\"\n        Prepares an xblock callback request and returns response to it.\n        \"\"\"\n        request = self.request_factory.post(\n            '/',\n            data=json.dumps(request_data),\n            content_type='application/json',\n        )\n        request.user = self.mock_user\n        response = render.handle_xblock_callback(\n            request,\n            str(course.id),\n            quote_slashes(str(block.scope_ids.usage_id)),\n            handler,\n            '',\n        )\n\n        return response\n\n    def test_invalid_csrf_token(self):\n        \"\"\"\n        Verify that invalid CSRF token is rejected.\n        \"\"\"\n        request = RequestFactory().post('dummy_url', data={'position': 1})\n        csrf_token = get_token(request)\n        request._post = {'csrfmiddlewaretoken': f'{csrf_token}-dummy'}  # pylint: disable=protected-access\n        request.user = self.mock_user\n        request.COOKIES[settings.CSRF_COOKIE_NAME] = csrf_token\n\n        response = render.handle_xblock_callback(\n            request,\n            str(self.course_key),\n            quote_slashes(str(self.location)),\n            'xmodule_handler',\n            'goto_position',\n        )\n        assert 403 == response.status_code\n\n    def test_valid_csrf_token(self):\n        \"\"\"\n        Verify that valid CSRF token is accepted.\n        \"\"\"\n        request = RequestFactory().post('dummy_url', data={'position': 1})\n        csrf_token = get_token(request)\n        request._post = {'csrfmiddlewaretoken': csrf_token}  # pylint: disable=protected-access\n        request.user = self.mock_user\n        request.COOKIES[settings.CSRF_COOKIE_NAME] = csrf_token\n\n        response = render.handle_xblock_callback(\n            request,\n            str(self.course_key),\n            quote_slashes(str(self.location)),\n            'xmodule_handler',\n            'goto_position',\n        )\n        assert 200 == response.status_code\n\n    def test_invalid_location(self):\n        request = self.request_factory.post('dummy_url', data={'position': 1})\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                'invalid Location',\n                'dummy_handler'\n                'dummy_dispatch'\n            )\n\n    def test_too_many_files(self):\n        request = self.request_factory.post(\n            'dummy_url',\n            data={'file_id': (self._mock_file(), ) * (settings.MAX_FILEUPLOADS_PER_INPUT + 1)}\n        )\n        request.user = self.mock_user\n        assert render.handle_xblock_callback(request, str(self.course_key), quote_slashes(str(self.location)), 'dummy_handler').content.decode('utf-8') == json.dumps({'success': (f'Submission aborted! Maximum {settings.MAX_FILEUPLOADS_PER_INPUT:d} files may be submitted at once')}, indent=2)  # pylint: disable=line-too-long\n\n    def test_too_large_file(self):\n        inputfile = self._mock_file(size=1 + settings.STUDENT_FILEUPLOAD_MAX_SIZE)\n        request = self.request_factory.post(\n            'dummy_url',\n            data={'file_id': inputfile}\n        )\n        request.user = self.mock_user\n        assert render.handle_xblock_callback(request, str(self.course_key), quote_slashes(str(self.location)), 'dummy_handler').content.decode('utf-8') == json.dumps({'success': ('Submission aborted! Your file \"%s\" is too large (max size: %d MB)' % (inputfile.name, (settings.STUDENT_FILEUPLOAD_MAX_SIZE / (1000 ** 2))))}, indent=2)  # pylint: disable=line-too-long\n\n    def test_xblock_dispatch(self):\n        request = self.request_factory.post('dummy_url', data={'position': 1})\n        request.user = self.mock_user\n        response = render.handle_xblock_callback(\n            request,\n            str(self.course_key),\n            quote_slashes(str(self.location)),\n            'xmodule_handler',\n            'goto_position',\n        )\n        assert isinstance(response, HttpResponse)\n\n    def test_bad_course_id(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                'bad_course_id',\n                quote_slashes(str(self.location)),\n                'xmodule_handler',\n                'goto_position',\n            )\n\n    def test_bad_location(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                quote_slashes(str(self.course_key.make_usage_key('chapter', 'bad_location'))),\n                'xmodule_handler',\n                'goto_position',\n            )\n\n    def test_bad_xblock_dispatch(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                quote_slashes(str(self.location)),\n                'xmodule_handler',\n                'bad_dispatch',\n            )\n\n    def test_missing_handler(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                quote_slashes(str(self.location)),\n                'bad_handler',\n                'bad_dispatch',\n            )\n\n    @XBlock.register_temp_plugin(GradedStatelessXBlock, identifier='stateless_scorer')\n    def test_score_without_student_state(self):\n        course = CourseFactory.create()\n        block = BlockFactory.create(category='stateless_scorer', parent=course)\n\n        request = self.request_factory.post(\n            'dummy_url',\n            data=json.dumps({\"grade\": 0.75}),\n            content_type='application/json'\n        )\n        request.user = self.mock_user\n\n        response = render.handle_xblock_callback(\n            request,\n            str(course.id),\n            quote_slashes(str(block.scope_ids.usage_id)),\n            'set_score',\n            '',\n        )\n        assert response.status_code == 200\n        student_module = StudentModule.objects.get(\n            student=self.mock_user,\n            module_state_key=block.scope_ids.usage_id,\n        )\n        assert student_module.grade == 0.75\n        assert student_module.max_grade == 1\n\n    @ddt.data(\n        ('complete', {'completion': 0.625}),\n        ('progress', {}),\n    )\n    @ddt.unpack\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_completion_events_with_completion_disabled(self, signal, data):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, False):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n            request = self.request_factory.post(\n                '/',\n                data=json.dumps(data),\n                content_type='application/json',\n            )\n            request.user = self.mock_user\n            with patch('completion.models.BlockCompletionManager.submit_completion') as mock_complete:\n                render.handle_xblock_callback(\n                    request,\n                    str(course.id),\n                    quote_slashes(str(block.scope_ids.usage_id)),\n                    signal,\n                    '',\n                )\n                mock_complete.assert_not_called()\n            assert not BlockCompletion.objects.filter(block_key=block.scope_ids.usage_id).exists()\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_completion_signal_for_completable_xblock(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n\n            response = self.make_xblock_callback_response(\n                {'completion': 0.625}, course, block, 'complete'\n            )\n\n            assert response.status_code == 200\n            completion = BlockCompletion.objects.get(block_key=block.scope_ids.usage_id)\n            assert completion.completion == 0.625\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    @ddt.data((True, True), (False, False),)\n    @ddt.unpack\n    def test_aside(self, is_xblock_aside, is_get_aside_called):\n        \"\"\"\n        test get_aside_from_xblock called\n        \"\"\"\n        course = CourseFactory.create()\n        block = BlockFactory.create(category='comp', parent=course)\n        request = self.request_factory.post(\n            '/',\n            data=json.dumps({'completion': 0.625}),\n            content_type='application/json',\n        )\n        request.user = self.mock_user\n\n        def get_usage_key():\n            \"\"\"return usage key\"\"\"\n            return (\n                quote_slashes(str(AsideUsageKeyV2(block.scope_ids.usage_id, \"aside\")))\n                if is_xblock_aside\n                else str(block.scope_ids.usage_id)\n            )\n\n        with patch(\n            'lms.djangoapps.courseware.block_render.is_xblock_aside',\n            return_value=is_xblock_aside\n        ), patch(\n            'lms.djangoapps.courseware.block_render.get_aside_from_xblock'\n        ) as mocked_get_aside_from_xblock, patch(\n            'lms.djangoapps.courseware.block_render.webob_to_django_response'\n        ) as mocked_webob_to_django_response:\n            render.handle_xblock_callback(\n                request,\n                str(course.id),\n                get_usage_key(),\n                'complete',\n                '',\n            )\n            assert mocked_webob_to_django_response.called is True\n        assert mocked_get_aside_from_xblock.called is is_get_aside_called\n\n    def test_aside_invalid_usage_id(self):\n        \"\"\"\n        test aside work when invalid usage id\n        \"\"\"\n        course = CourseFactory.create()\n        request = self.request_factory.post(\n            '/',\n            data=json.dumps({'completion': 0.625}),\n            content_type='application/json',\n        )\n        request.user = self.mock_user\n\n        with patch(\n            'lms.djangoapps.courseware.block_render.is_xblock_aside',\n            return_value=True\n        ), self.assertRaises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(course.id),\n                \"foo@bar\",\n                'complete',\n                '',\n            )\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_progress_signal_ignored_for_completable_xblock(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n\n            response = self.make_xblock_callback_response(\n                {}, course, block, 'progress'\n            )\n\n            assert response.status_code == 200\n            assert not BlockCompletion.objects.filter(block_key=block.scope_ids.usage_id).exists()\n\n    @XBlock.register_temp_plugin(XBlockWithoutCompletionAPI, identifier='no_comp')\n    def test_progress_signal_processed_for_xblock_without_completion_api(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='no_comp', parent=course)\n\n            response = self.make_xblock_callback_response(\n                {}, course, block, 'progress'\n            )\n\n            assert response.status_code == 200\n            completion = BlockCompletion.objects.get(block_key=block.scope_ids.usage_id)\n            assert completion.completion == 1.0\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_skip_handlers_for_masquerading_staff(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n            request = self.request_factory.post(\n                '/',\n                data=json.dumps({'completion': 0.8}),\n                content_type='application/json',\n            )\n            request.user = self.mock_user\n            request.session = {}\n            request.user.real_user = GlobalStaffFactory.create()\n            request.user.real_user.masquerade_settings = CourseMasquerade(course.id, user_name=\"jem\")\n            with patch('xmodule.services.is_masquerading_as_specific_student') as mock_masq:\n                mock_masq.return_value = True\n                response = render.handle_xblock_callback(\n                    request,\n                    str(course.id),\n                    quote_slashes(str(block.scope_ids.usage_id)),\n                    'complete',\n                    '',\n                )\n            mock_masq.assert_called()\n        assert response.status_code == 200\n        with pytest.raises(BlockCompletion.DoesNotExist):\n            BlockCompletion.objects.get(block_key=block.scope_ids.usage_id)\n\n    @XBlock.register_temp_plugin(GradedStatelessXBlock, identifier='stateless_scorer')\n    @patch('xmodule.services.grades_signals.SCORE_PUBLISHED.send')\n    def test_anonymous_user_not_be_graded(self, mock_score_signal):\n        course = CourseFactory.create()\n        block_kwargs = {\n            'category': 'problem',\n        }\n        request = self.request_factory.get('/')\n        request.user = AnonymousUser()\n        block = BlockFactory.create(**block_kwargs)\n\n        render.handle_xblock_callback(\n            request,\n            str(course.id),\n            quote_slashes(str(block.location)),\n            'xmodule_handler',\n            'problem_check',\n        )\n        assert not mock_score_signal.called\n\n    @ddt.data(\n        # See seq_block.py for the definition of these handlers\n        ('get_completion', True),  # has the 'will_recheck_access' attribute set to True\n        ('goto_position', False),  # does not set it\n    )\n    @ddt.unpack\n    @patch('lms.djangoapps.courseware.block_render.get_block_for_descriptor', wraps=get_block_for_descriptor)\n    def test_will_recheck_access_handler_attribute(self, handler, will_recheck_access, mock_get_block):\n        \"\"\"Confirm that we pay attention to any 'will_recheck_access' attributes on handler methods\"\"\"\n        course = CourseFactory.create()\n        block_kwargs = {\n            'category': 'sequential',\n            'parent': course,\n        }\n        block = BlockFactory.create(**block_kwargs)\n        usage_id = str(block.location)\n\n        # Send no special parameters, which will be invalid, but we don't care\n        request = self.request_factory.post('/', data='{}', content_type='application/json')\n        request.user = self.mock_user\n\n        render.handle_xblock_callback(request, str(course.id), usage_id, handler)\n        assert mock_get_block.call_count == 2\n        assert mock_get_block.call_args[1]['will_recheck_access'] == will_recheck_access\n\n\n@ddt.ddt\n@patch.dict('django.conf.settings.FEATURES', {'ENABLE_XBLOCK_VIEW_ENDPOINT': True})\nclass TestXBlockView(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test the handle_xblock_callback function\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.toy_course = modulestore().get_course(cls.course_key)\n\n    def setUp(self):\n        super().setUp()\n\n        self.location = str(self.course_key.make_usage_key('html', 'toyhtml'))\n        self.request_factory = RequestFactory()\n\n        self.view_args = [str(self.course_key), quote_slashes(self.location), 'student_view']\n        self.xblock_view_url = reverse('xblock_view', args=self.view_args)\n\n    def test_xblock_view_handler(self):\n        request = self.request_factory.get(self.xblock_view_url)\n        request.user = UserFactory.create()\n        response = render.xblock_view(request, *self.view_args)\n        assert 200 == response.status_code\n\n        expected = ['csrf_token', 'html', 'resources']\n        content = json.loads(response.content.decode('utf-8'))\n        for section in expected:\n            assert section in content\n        doc = PyQuery(content['html'])\n        assert len(doc('div.xblock-student_view-html')) == 1\n\n    @ddt.data(True, False)\n    def test_hide_staff_markup(self, hide):\n        \"\"\"\n        When xblock_view gets 'hide_staff_markup' in its context, the staff markup\n        should not be included. See 'add_staff_markup' in xblock_utils/__init__.py\n        \"\"\"\n        request = self.request_factory.get(self.xblock_view_url)\n        request.user = GlobalStaffFactory.create()\n        request.session = {}\n        if hide:\n            request.GET = {'hide_staff_markup': 'true'}\n        response = render.xblock_view(request, *self.view_args)\n        assert 200 == response.status_code\n\n        html = json.loads(response.content.decode('utf-8'))['html']\n        assert ('Staff Debug Info' in html) == (not hide)\n\n    def test_xblock_view_handler_not_authenticated(self):\n        request = self.request_factory.get(self.xblock_view_url)\n        request.user = AnonymousUser()\n        response = render.xblock_view(request, *self.view_args)\n        assert 401 == response.status_code\n\n\n@ddt.ddt\nclass TestTOC(ModuleStoreTestCase):\n    \"\"\"Check the Table of Contents for a course\"\"\"\n\n    def setup_request_and_course(self, num_finds, num_sends):\n        \"\"\"\n        Sets up the toy course in the modulestore and the request object.\n        \"\"\"\n        self.course_key = ToyCourseFactory.create().id  # pylint: disable=attribute-defined-outside-init\n        self.chapter = 'Overview'  # lint-amnesty, pylint: disable=attribute-defined-outside-init\n        chapter_url = '{}/{}/{}'.format('/courses', self.course_key, self.chapter)\n        factory = RequestFactoryNoCsrf()\n        self.request = factory.get(chapter_url)  # lint-amnesty, pylint: disable=attribute-defined-outside-init\n        self.request.user = UserFactory()\n        self.modulestore = self.store._get_modulestore_for_courselike(self.course_key)  # pylint: disable=protected-access, attribute-defined-outside-init\n        with self.modulestore.bulk_operations(self.course_key):\n            with check_mongo_calls(num_finds, num_sends):\n                self.toy_course = self.store.get_course(self.course_key, depth=2)  # pylint: disable=attribute-defined-outside-init\n                self.field_data_cache = FieldDataCache.cache_for_block_descendents(  # lint-amnesty, pylint: disable=attribute-defined-outside-init\n                    self.course_key, self.request.user, self.toy_course, depth=2\n                )\n\n    # Split makes 2 queries to load the course to depth 2:\n    #     - 1 for the structure\n    #     - 1 for 5 definitions\n    # Split makes 1 MySQL query to render the toc:\n    #     - 1 MySQL for the active version at the start of the bulk operation (no mongo calls)\n    def test_toc_toy_from_chapter(self):\n        with self.store.default_store(ModuleStoreEnum.Type.split):\n            self.setup_request_and_course(2, 0)\n\n            expected = ([{'active': True, 'sections':\n                          [{'url_name': 'Toy_Videos', 'display_name': 'Toy Videos', 'graded': True,\n                            'format': 'Lecture Sequence', 'due': None, 'active': False},\n                           {'url_name': 'Welcome', 'display_name': 'Welcome', 'graded': True,\n                            'format': '', 'due': None, 'active': False},\n                           {'url_name': 'video_123456789012', 'display_name': 'Test Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False},\n                           {'url_name': 'video_4f66f493ac8f', 'display_name': 'Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'Overview', 'display_name': 'Overview', 'display_id': 'overview'},\n                         {'active': False, 'sections':\n                          [{'url_name': 'toyvideo', 'display_name': 'toyvideo', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'secret:magic', 'display_name': 'secret:magic', 'display_id': 'secretmagic'}])\n\n            course = self.store.get_course(self.toy_course.id, depth=2)\n            with check_mongo_calls(0):\n                actual = render.toc_for_course(\n                    self.request.user, self.request, course, self.chapter, None, self.field_data_cache\n                )\n        for toc_section in expected:\n            assert toc_section in actual['chapters']\n        assert actual['previous_of_active_section'] is None\n        assert actual['next_of_active_section'] is None\n\n    # Split makes 2 queries to load the course to depth 2:\n    #     - 1 for the structure\n    #     - 1 for 5 definitions\n    # Split makes 1 MySQL query to render the toc:\n    #     - 1 MySQL for the active version at the start of the bulk operation (no mongo calls)\n    def test_toc_toy_from_section(self):\n        with self.store.default_store(ModuleStoreEnum.Type.split):\n            self.setup_request_and_course(2, 0)\n            section = 'Welcome'\n            expected = ([{'active': True, 'sections':\n                          [{'url_name': 'Toy_Videos', 'display_name': 'Toy Videos', 'graded': True,\n                            'format': 'Lecture Sequence', 'due': None, 'active': False},\n                           {'url_name': 'Welcome', 'display_name': 'Welcome', 'graded': True,\n                            'format': '', 'due': None, 'active': True},\n                           {'url_name': 'video_123456789012', 'display_name': 'Test Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False},\n                           {'url_name': 'video_4f66f493ac8f', 'display_name': 'Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'Overview', 'display_name': 'Overview', 'display_id': 'overview'},\n                         {'active': False, 'sections':\n                          [{'url_name': 'toyvideo', 'display_name': 'toyvideo', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'secret:magic', 'display_name': 'secret:magic', 'display_id': 'secretmagic'}])\n\n            with check_mongo_calls(0):\n                actual = render.toc_for_course(\n                    self.request.user, self.request, self.toy_course, self.chapter, section, self.field_data_cache\n                )\n            for toc_section in expected:\n                assert toc_section in actual['chapters']\n            assert actual['previous_of_active_section']['url_name'] == 'Toy_Videos'\n            assert actual['next_of_active_section']['url_name'] == 'video_123456789012'\n\n\n@ddt.ddt\n@patch.dict('django.conf.settings.FEATURES', {'ENABLE_SPECIAL_EXAMS': True})\nclass TestProctoringRendering(ModuleStoreTestCase):\n    \"\"\"Check the Table of Contents for a course\"\"\"\n    def setUp(self):\n        \"\"\"\n        Set up the initial mongo datastores\n        \"\"\"\n        super().setUp()\n        self.course_key = ToyCourseFactory.create(enable_proctored_exams=True).id\n        self.chapter = 'Overview'\n        chapter_url = '{}/{}/{}'.format('/courses', self.course_key, self.chapter)\n        factory = RequestFactoryNoCsrf()\n        self.request = factory.get(chapter_url)\n        self.request.user = UserFactory.create()\n        self.user = UserFactory.create()\n        SoftwareSecurePhotoVerificationFactory.create(user=self.request.user)\n        self.modulestore = self.store._get_modulestore_for_courselike(self.course_key)  # pylint: disable=protected-access\n        with self.modulestore.bulk_operations(self.course_key):\n            self.toy_course = self.store.get_course(self.course_key, depth=2)\n            self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n                self.course_key, self.request.user, self.toy_course, depth=2\n            )\n\n    @ddt.data(\n        (CourseMode.DEFAULT_MODE_SLUG, False, None, None),\n        (\n            CourseMode.DEFAULT_MODE_SLUG,\n            True,\n            'eligible',\n            {\n                'status': 'eligible',\n                'short_description': 'Ungraded Practice Exam',\n                'suggested_icon': '',\n                'in_completed_state': False\n            }\n        ),\n        (\n            CourseMode.DEFAULT_MODE_SLUG,\n            True,\n            'submitted',\n            {\n                'status': 'submitted',\n                'short_description': 'Practice Exam Completed',\n                'suggested_icon': 'fa-check',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.DEFAULT_MODE_SLUG,\n            True,\n            'error',\n            {\n                'status': 'error',\n                'short_description': 'Practice Exam Failed',\n                'suggested_icon': 'fa-exclamation-triangle',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            None,\n            {\n                'status': 'eligible',\n                'short_description': 'Proctored Option Available',\n                'suggested_icon': 'fa-pencil-square-o',\n                'in_completed_state': False\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'declined',\n            {\n                'status': 'declined',\n                'short_description': 'Taking As Open Exam',\n                'suggested_icon': 'fa-pencil-square-o',\n                'in_completed_state': False\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'submitted',\n            {\n                'status': 'submitted',\n                'short_description': 'Pending Session Review',\n                'suggested_icon': 'fa-spinner fa-spin',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'verified',\n            {\n                'status': 'verified',\n                'short_description': 'Passed Proctoring',\n                'suggested_icon': 'fa-check',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'rejected',\n            {\n                'status': 'rejected',\n                'short_description': 'Failed Proctoring',\n                'suggested_icon': 'fa-exclamation-triangle',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'error',\n            {\n                'status': 'error',\n                'short_description': 'Failed Proctoring',\n                'suggested_icon': 'fa-exclamation-triangle',\n                'in_completed_state': True\n            }\n        ),\n    )\n    @ddt.unpack\n    def test_proctored_exam_toc(self, enrollment_mode, is_practice_exam,\n                                attempt_status, expected):\n        \"\"\"\n        Generate TOC for a course with a single chapter/sequence which contains proctored exam\n        \"\"\"\n        self._setup_test_data(enrollment_mode, is_practice_exam, attempt_status)\n\n        actual = render.toc_for_course(\n            self.request.user,\n            self.request,\n            self.toy_course,\n            self.chapter,\n            'Toy_Videos',\n            self.field_data_cache\n        )\n        section_actual = self._find_section(actual['chapters'], 'Overview', 'Toy_Videos')\n\n        if expected:\n            assert expected in [section_actual['proctoring']]\n        else:\n            # we expect there not to be a 'proctoring' key in the dict\n            assert 'proctoring' not in section_actual\n        assert actual['previous_of_active_section'] is None\n        assert actual['next_of_active_section']['url_name'] == 'Welcome'\n\n    @ddt.data(\n        (\n            CourseMode.VERIFIED,\n            False,\n            None,\n            'This exam is proctored',\n            False\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'submitted',\n            'You have submitted this proctored exam for review',\n            True\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'verified',\n            'Your proctoring session was reviewed successfully',\n            False\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'rejected',\n            'Your proctoring session was reviewed, but did not pass all requirements',\n            True\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'error',\n            'A system error has occurred with your proctored exam',\n            False\n        ),\n    )\n    @ddt.unpack\n    def test_render_proctored_exam(self, enrollment_mode, is_practice_exam,\n                                   attempt_status, expected, with_credit_context):\n        \"\"\"\n        Verifies gated content from the student view rendering of a sequence\n        this is labeled as a proctored exam\n        \"\"\"\n        usage_key = self._setup_test_data(enrollment_mode, is_practice_exam, attempt_status)\n\n        # initialize some credit requirements, if so then specify\n        if with_credit_context:\n            credit_course = CreditCourse(course_key=self.course_key, enabled=True)\n            credit_course.save()\n            set_credit_requirements(\n                self.course_key,\n                [\n                    {\n                        'namespace': 'reverification',\n                        'name': 'reverification-1',\n                        'display_name': 'ICRV1',\n                        'criteria': {},\n                    },\n                    {\n                        'namespace': 'proctored-exam',\n                        'name': 'Exam1',\n                        'display_name': 'A Proctored Exam',\n                        'criteria': {}\n                    }\n                ]\n            )\n\n            set_credit_requirement_status(\n                self.request.user,\n                self.course_key,\n                'reverification',\n                'ICRV1'\n            )\n\n        block = render.get_block(\n            self.request.user,\n            self.request,\n            usage_key,\n            self.field_data_cache,\n            wrap_xblock_display=True,\n        )\n        content = block.render(STUDENT_VIEW).content\n\n        assert expected in content\n\n    def _setup_test_data(self, enrollment_mode, is_practice_exam, attempt_status):\n        \"\"\"\n        Helper method to consolidate some courseware/proctoring/credit\n        test harness data\n        \"\"\"\n        usage_key = self.course_key.make_usage_key('sequential', 'Toy_Videos')\n\n        with self.modulestore.bulk_operations(self.toy_course.id):\n            sequence = self.modulestore.get_item(usage_key)\n            sequence.is_time_limited = True\n            sequence.is_proctored_exam = True\n            sequence.is_practice_exam = is_practice_exam\n            self.modulestore.update_item(sequence, self.user.id)\n\n        self.toy_course = self.update_course(self.toy_course, self.user.id)\n\n        # refresh cache after update\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course_key, self.request.user, self.toy_course, depth=2\n        )\n\n        set_runtime_service(\n            'credit',\n            MockCreditService(enrollment_mode=enrollment_mode)\n        )\n        CourseEnrollment.enroll(self.request.user, self.course_key, mode=enrollment_mode)\n\n        set_runtime_service(\n            'grades',\n            MockGradesService()\n        )\n\n        set_runtime_service(\n            'certificates',\n            MockCertificateService()\n        )\n\n        exam_id = create_exam(\n            course_id=str(self.course_key),\n            content_id=str(sequence.location.replace(branch=None, version=None)),\n            exam_name='foo',\n            time_limit_mins=10,\n            is_proctored=True,\n            is_practice_exam=is_practice_exam\n        )\n\n        if attempt_status:\n            attempt_id = create_exam_attempt(\n                str(exam_id).encode('utf-8'),\n                self.request.user.id,\n                taking_as_proctored=True\n            )\n            update_attempt_status(attempt_id, attempt_status)\n\n        return usage_key\n\n    def _find_url_name(self, toc, url_name):\n        \"\"\"\n        Helper to return the dict TOC section associated with a Chapter of url_name\n        \"\"\"\n\n        for entry in toc:\n            if entry['url_name'] == url_name:\n                return entry\n\n        return None\n\n    def _find_section(self, toc, chapter_url_name, section_url_name):\n        \"\"\"\n        Helper to return the dict TOC section associated with a section of url_name\n        \"\"\"\n\n        chapter = self._find_url_name(toc, chapter_url_name)\n        if chapter:\n            return self._find_url_name(chapter['sections'], section_url_name)\n\n        return None\n\n\nclass TestGatedSubsectionRendering(ModuleStoreTestCase, MilestonesTestCaseMixin):\n    \"\"\"\n    Test the toc for a course is rendered correctly when there is gated content\n    \"\"\"\n    def setUp(self):\n        \"\"\"\n        Set up the initial test data\n        \"\"\"\n        super().setUp()\n\n        self.course = CourseFactory.create(enable_subsection_gating=True)\n        self.chapter = BlockFactory.create(\n            parent=self.course,\n            category=\"chapter\",\n            display_name=\"Chapter\"\n        )\n        self.open_seq = BlockFactory.create(\n            parent=self.chapter,\n            category='sequential',\n            display_name=\"Open Sequential\"\n        )\n        self.gated_seq = BlockFactory.create(\n            parent=self.chapter,\n            category='sequential',\n            display_name=\"Gated Sequential\"\n        )\n        self.course = self.update_course(self.course, 0)\n\n        self.request = RequestFactoryNoCsrf().get(f'/courses/{self.course.id}/{self.chapter.display_name}')\n        self.request.user = UserFactory()\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id, self.request.user, self.course, depth=2\n        )\n        gating_api.add_prerequisite(self.course.id, self.open_seq.location)\n        gating_api.set_required_content(self.course.id, self.gated_seq.location, self.open_seq.location, 100)\n\n    def _find_url_name(self, toc, url_name):\n        \"\"\"\n        Helper to return the TOC section associated with url_name\n        \"\"\"\n\n        for entry in toc:\n            if entry['url_name'] == url_name:\n                return entry\n\n        return None\n\n    def _find_sequential(self, toc, chapter_url_name, sequential_url_name):\n        \"\"\"\n        Helper to return the sequential associated with sequential_url_name\n        \"\"\"\n\n        chapter = self._find_url_name(toc, chapter_url_name)\n        if chapter:\n            return self._find_url_name(chapter['sections'], sequential_url_name)\n\n        return None\n\n    def test_toc_with_gated_sequential(self):\n        \"\"\"\n        Test generation of TOC for a course with a gated subsection\n        \"\"\"\n        actual = render.toc_for_course(\n            self.request.user,\n            self.request,\n            self.course,\n            self.chapter.display_name,\n            self.open_seq.display_name,\n            self.field_data_cache\n        )\n        assert self._find_sequential(actual['chapters'], 'Chapter', 'Open_Sequential') is not None\n        assert self._find_sequential(actual['chapters'], 'Chapter', 'Gated_Sequential') is not None\n        assert self._find_sequential(actual['chapters'], 'Non-existent_Chapter', 'Non-existent_Sequential') is None\n        assert actual['previous_of_active_section'] is None\n        assert actual['next_of_active_section'] is None\n\n\n@ddt.ddt\nclass TestHtmlModifiers(ModuleStoreTestCase):\n    \"\"\"\n    Tests to verify that standard modifications to the output of XModule/XBlock\n    student_view are taking place\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.course = CourseFactory.create()\n        self.request = RequestFactoryNoCsrf().get('/')\n        self.request.user = self.user\n        self.request.session = {}\n        self.content_string = '<p>This is the content<p>'\n        self.rewrite_link = '<a href=\"/static/foo/content\">Test rewrite</a>'\n        self.rewrite_bad_link = '<img src=\"/static//file.jpg\" />'\n        self.course_link = '<a href=\"/course/bar/content\">Test course rewrite</a>'\n        self.block = BlockFactory.create(\n            category='html',\n            data=self.content_string + self.rewrite_link + self.rewrite_bad_link + self.course_link\n        )\n        self.location = self.block.location\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            self.block\n        )\n\n    def test_xblock_display_wrapper_enabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n            wrap_xblock_display=True,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        assert len(PyQuery(result_fragment.content)('div.xblock.xblock-student_view.xmodule_HtmlBlock')) == 1\n\n    def test_xmodule_display_wrapper_disabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n            wrap_xblock_display=False,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        assert 'div class=\"xblock xblock-student_view xmodule_display xmodule_HtmlBlock\"' not in result_fragment.content\n\n    def test_static_link_rewrite(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        key = self.course.location\n        assert f'/asset-v1:{key.org}+{key.course}+{key.run}+type@asset+block/foo_content' in result_fragment.content\n\n    def test_static_badlink_rewrite(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        key = self.course.location\n        assert f'/asset-v1:{key.org}+{key.course}+{key.run}+type@asset+block/file.jpg' in result_fragment.content\n\n    def test_static_asset_path_use(self):\n        '''\n        when a course is loaded with do_import_static=False (see xml_importer.py), then\n        static_asset_path is set as an lms kv in course.  That should make static paths\n        not be mangled (ie not changed to c4x://).\n        '''\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n            static_asset_path=\"toy_course_dir\",\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'href=\"/static/toy_course_dir' in result_fragment.content\n\n    def test_course_image(self):\n        url = course_image_url(self.course)\n        assert url.startswith('/asset-v1:')\n\n        self.course.static_asset_path = \"toy_course_dir\"\n        url = course_image_url(self.course)\n        assert url.startswith('/static/toy_course_dir/')\n        self.course.static_asset_path = \"\"\n\n    @override_settings(DEFAULT_COURSE_ABOUT_IMAGE_URL='test.png')\n    def test_course_image_for_split_course(self):\n        \"\"\"\n        for split courses if course_image is empty then course_image_url will be\n        the default image url defined in settings\n        \"\"\"\n        self.course = CourseFactory.create()\n        self.course.course_image = ''\n\n        url = course_image_url(self.course)\n        assert '/static/test.png' == url\n\n    def test_get_course_info_section(self):\n        self.course.static_asset_path = \"toy_course_dir\"\n        get_course_info_section(self.request, self.request.user, self.course, \"handouts\")\n        # NOTE: check handouts output...right now test course seems to have no such content\n        # at least this makes sure get_course_info_section returns without exception\n\n    def test_course_link_rewrite(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        assert f'/courses/{str(self.course.id)}/bar/content' in result_fragment.content\n\n\nclass XBlockWithJsonInitData(XBlock):\n    \"\"\"\n    Pure XBlock to use in tests, with JSON init data.\n    \"\"\"\n    the_json_data = None\n\n    def student_view(self, context=None):       # pylint: disable=unused-argument\n        \"\"\"\n        A simple view that returns just enough to test.\n        \"\"\"\n        frag = Fragment(\"Hello there!\")\n        frag.add_javascript('alert(\"Hi!\");')\n        frag.initialize_js('ThumbsBlock', self.the_json_data)\n        return frag\n\n\n@ddt.ddt\nclass JsonInitDataTest(ModuleStoreTestCase):\n    \"\"\"Tests for JSON data injected into the JS init function.\"\"\"\n\n    @ddt.data(\n        ({'a': 17}, '''{\"a\": 17}'''),\n        ({'xss': '</script>alert(\"XSS\")'}, r'''{\"xss\": \"\\u003c/script\\u003ealert(\\\"XSS\\\")\"}'''),\n    )\n    @ddt.unpack\n    @XBlock.register_temp_plugin(XBlockWithJsonInitData, identifier='withjson')\n    def test_json_init_data(self, json_data, json_output):\n        XBlockWithJsonInitData.the_json_data = json_data\n        mock_user = UserFactory()\n        mock_request = MagicMock()\n        mock_request.user = mock_user\n        course = CourseFactory()\n        block = BlockFactory(category='withjson', parent=course)\n        field_data_cache = FieldDataCache([course, block], course.id, mock_user)\n        block = render.get_block_for_descriptor(\n            mock_user,\n            mock_request,\n            block,\n            field_data_cache,\n            course.id,\n            course=course\n        )\n        html = block.render(STUDENT_VIEW).content\n        assert json_output in html\n        # No matter what data goes in, there should only be one close-script tag.\n        assert html.count('</script>') == 1\n\n\n@XBlock.tag(\"detached\")\nclass DetachedXBlock(XBlock):\n    \"\"\"\n    XBlock marked with the 'detached' flag.\n    \"\"\"\n\n    def student_view(self, context=None):  # pylint: disable=unused-argument\n        \"\"\"\n        A simple view that returns just enough to test.\n        \"\"\"\n        frag = Fragment(\"Hello there!\")\n        return frag\n\n\n@patch.dict('django.conf.settings.FEATURES', {'DISPLAY_DEBUG_INFO_TO_STAFF': True, 'DISPLAY_HISTOGRAMS_TO_STAFF': True})\n@patch('lms.djangoapps.courseware.block_render.has_access', Mock(return_value=True, autospec=True))\nclass TestStaffDebugInfo(SharedModuleStoreTestCase):\n    \"\"\"Tests to verify that Staff Debug Info panel and histograms are displayed to staff.\"\"\"\n    MODULESTORE = TEST_DATA_SPLIT_MODULESTORE\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super().setUp()\n        self.user = UserFactory.create()\n        self.request = RequestFactoryNoCsrf().get('/')\n        self.request.user = self.user\n        self.request.session = {}\n\n        problem_xml = OptionResponseXMLFactory().build_xml(\n            question_text='The correct answer is Correct',\n            num_inputs=2,\n            weight=2,\n            options=['Correct', 'Incorrect'],\n            correct_option='Correct'\n        )\n        self.block = BlockFactory.create(\n            category='problem',\n            data=problem_xml,\n            display_name='Option Response Problem'\n        )\n\n        self.location = self.block.location\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            self.block\n        )\n\n    @patch.dict('django.conf.settings.FEATURES', {'DISPLAY_DEBUG_INFO_TO_STAFF': False})\n    def test_staff_debug_info_disabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'Staff Debug' not in result_fragment.content\n\n    def test_staff_debug_info_enabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'Staff Debug' in result_fragment.content\n\n    def test_staff_debug_info_score_for_invalid_dropdown(self):\n        \"\"\"\n        Verifies that for an invalid drop down problem, the max score is set\n        to zero in the html.\n        \"\"\"\n        problem_xml = \"\"\"\n        <problem>\n            <optionresponse>\n              <p>You can use this template as a guide to the simple editor markdown and OLX markup to use for dropdown problems. Edit this component to replace this template with your own assessment.</p>\n            <label>Add the question text, or prompt, here. This text is required.</label>\n            <description>You can add an optional tip or note related to the prompt like this. </description>\n            <optioninput>\n                <option correct=\"False\">an incorrect answer</option>\n                <option correct=\"True\">the correct answer</option>\n                <option correct=\"True\">an incorrect answer</option>\n              </optioninput>\n            </optionresponse>\n        </problem>\n        \"\"\"\n        problem_block = BlockFactory.create(\n            category='problem',\n            data=problem_xml\n        )\n        block = render.get_block(\n            self.user,\n            self.request,\n            problem_block.location,\n            self.field_data_cache\n        )\n        html_fragment = block.render(STUDENT_VIEW)\n        expected_score_override_html = textwrap.dedent(\"\"\"<div>\n        <label for=\"sd_fs_{block_id}\">Score (for override only):</label>\n        <input type=\"text\" tabindex=\"0\" id=\"sd_fs_{block_id}\" placeholder=\"0\"/>\n        <label for=\"sd_fs_{block_id}\"> / 0</label>\n      </div>\"\"\")\n\n        assert expected_score_override_html.format(block_id=problem_block.location.block_id) in\\\n               html_fragment.content\n\n    @XBlock.register_temp_plugin(DetachedXBlock, identifier='detached-block')\n    def test_staff_debug_info_disabled_for_detached_blocks(self):\n        \"\"\"Staff markup should not be present on detached blocks.\"\"\"\n\n        detached_block = BlockFactory.create(\n            category='detached-block',\n            display_name='Detached Block'\n        )\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            detached_block\n        )\n        block = render.get_block(\n            self.user,\n            self.request,\n            detached_block.location,\n            field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'Staff Debug' not in result_fragment.content\n\n    @patch.dict('django.conf.settings.FEATURES', {'DISPLAY_HISTOGRAMS_TO_STAFF': False})\n    def test_histogram_disabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'histrogram' not in result_fragment.content\n\n    def test_histogram_enabled_for_unscored_xblocks(self):\n        \"\"\"Histograms should not display for xblocks which are not scored.\"\"\"\n\n        html_block = BlockFactory.create(\n            category='html',\n            data='Here are some course details.'\n        )\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            self.block\n        )\n        with patch('openedx.core.lib.xblock_utils.grade_histogram') as mock_grade_histogram:\n            mock_grade_histogram.return_value = []\n            block = render.get_block(\n                self.user,\n                self.request,\n                html_block.location,\n                field_data_cache,\n            )\n            block.render(STUDENT_VIEW)\n            assert not mock_grade_histogram.called\n\n    def test_histogram_enabled_for_scored_xblocks(self):\n        \"\"\"Histograms should display for xblocks which are scored.\"\"\"\n\n        StudentModuleFactory.create(\n            course_id=self.course.id,\n            module_state_key=self.location,\n            student=UserFactory(),\n            grade=1,\n            max_grade=1,\n            state=\"{}\",\n        )\n        with patch('openedx.core.lib.xblock_utils.grade_histogram') as mock_grade_histogram:\n            mock_grade_histogram.return_value = []\n            block = render.get_block(\n                self.user,\n                self.request,\n                self.location,\n                self.field_data_cache,\n            )\n            block.render(STUDENT_VIEW)\n            assert mock_grade_histogram.called\n\n\nPER_COURSE_ANONYMIZED_XBLOCKS = (\n    LTIBlock,\n    VideoBlock,\n)\nPER_STUDENT_ANONYMIZED_XBLOCKS = [\n    AboutBlock,\n    CourseInfoBlock,\n    HtmlBlock,\n    ProblemBlock,\n    StaticTabBlock,\n]\n\n\n@ddt.ddt\nclass TestAnonymousStudentId(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test that anonymous_student_id is set correctly across a variety of XBlock types\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.course = modulestore().get_course(cls.course_key)\n\n    def setUp(self):\n        super().setUp()\n        self.user = UserFactory()\n\n    @patch('lms.djangoapps.courseware.block_render.has_access', Mock(return_value=True, autospec=True))\n    def _get_anonymous_id(self, course_id, xblock_class, should_get_deprecated_id: bool):  # lint-amnesty, pylint: disable=missing-function-docstring\n        location = course_id.make_usage_key('dummy_category', 'dummy_name')\n        block = Mock(\n            spec=xblock_class,\n            _field_data=Mock(spec=FieldData, name='field_data'),\n            location=location,\n            static_asset_path=None,\n            _runtime=Mock(\n                spec=DescriptorSystem,\n                resources_fs=None,\n                mixologist=Mock(_mixins=(), name='mixologist'),\n                _services={},\n                name='runtime',\n            ),\n            scope_ids=Mock(spec=ScopeIds),\n            name='block',\n            _field_data_cache={},\n            _dirty_fields={},\n            fields={},\n            days_early_for_beta=None,\n        )\n        block.runtime = DescriptorSystem(None, None, None)\n        # Use the xblock_class's bind_for_student method\n        block.bind_for_student = partial(xblock_class.bind_for_student, block)\n\n        if hasattr(xblock_class, 'module_class'):\n            block.module_class = xblock_class.module_class\n\n        rendered_block = render.get_block_for_descriptor(\n            user=self.user,\n            block=block,\n            student_data=Mock(spec=FieldData, name='student_data'),\n            course_key=course_id,\n            track_function=Mock(name='track_function'),  # Track Function\n            request_token='request_token',\n            course=self.course,\n            request=None,\n            field_data_cache=None,\n        )\n        current_user = rendered_block.runtime.service(rendered_block, 'user').get_current_user()\n\n        if should_get_deprecated_id:\n            return current_user.opt_attrs.get(ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID)\n        return current_user.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID)\n\n    @ddt.data(*PER_STUDENT_ANONYMIZED_XBLOCKS)\n    def test_per_student_anonymized_id(self, block_class):\n        for course_id in ('MITx/6.00x/2012_Fall', 'MITx/6.00x/2013_Spring'):\n            assert 'de619ab51c7f4e9c7216b4644c24f3b5' == \\\n                   self._get_anonymous_id(CourseKey.from_string(course_id), block_class, True)\n\n    @ddt.data(*PER_COURSE_ANONYMIZED_XBLOCKS)\n    def test_per_course_anonymized_id(self, xblock_class):\n        assert '0c706d119cad686d28067412b9178454' == \\\n               self._get_anonymous_id(CourseKey.from_string('MITx/6.00x/2012_Fall'), xblock_class, False)\n\n        assert 'e9969c28c12c8efa6e987d6dbeedeb0b' == \\\n               self._get_anonymous_id(CourseKey.from_string('MITx/6.00x/2013_Spring'), xblock_class, False)\n\n\n@patch('common.djangoapps.track.views.eventtracker', autospec=True)\nclass TestModuleTrackingContext(SharedModuleStoreTestCase):\n    \"\"\"\n    Ensure correct tracking information is included in events emitted during XBlock callback handling.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super().setUp()\n\n        self.user = UserFactory.create()\n        self.request = RequestFactoryNoCsrf().get('/')\n        self.request.user = self.user\n        self.request.session = {}\n        self.course = CourseFactory.create()\n\n        self.problem_xml = OptionResponseXMLFactory().build_xml(\n            question_text='The correct answer is Correct',\n            num_inputs=2,\n            weight=2,\n            options=['Correct', 'Incorrect'],\n            correct_option='Correct'\n        )\n\n    def test_context_contains_display_name(self, mock_tracker):\n        problem_display_name = 'Option Response Problem'\n        block_info = self.handle_callback_and_get_block_info(mock_tracker, problem_display_name)\n        assert problem_display_name == block_info['display_name']\n\n    @XBlockAside.register_temp_plugin(AsideTestType, 'test_aside')\n    @patch('xmodule.modulestore.mongo.base.CachingDescriptorSystem.applicable_aside_types',\n           lambda self, block: ['test_aside'])\n    @patch('xmodule.x_module.DescriptorSystem.applicable_aside_types',\n           lambda self, block: ['test_aside'])\n    def test_context_contains_aside_info(self, mock_tracker):\n        \"\"\"\n        Check that related xblock asides populate information in the 'problem_check' event in case\n        the 'get_event_context' method is exist\n        \"\"\"\n        problem_display_name = 'Test Problem'\n\n        def get_event_context(self, event_type, event):  # pylint: disable=unused-argument\n            \"\"\"\n            This method return data that should be associated with the \"check_problem\" event\n            \"\"\"\n            return {'content': 'test1', 'data_field': 'test2'}\n\n        AsideTestType.get_event_context = get_event_context\n\n        # for different operations, there are different number of context calls.\n        # We are sending this `call_idx` to get the mock call that we are interested in.\n        context_info = self.handle_callback_and_get_context_info(mock_tracker, problem_display_name, call_idx=4)\n\n        assert 'asides' in context_info\n        assert 'test_aside' in context_info['asides']\n        assert 'content' in context_info['asides']['test_aside']\n        assert context_info['asides']['test_aside']['content'] == 'test1'\n        assert 'data_field' in context_info['asides']['test_aside']\n        assert context_info['asides']['test_aside']['data_field'] == 'test2'\n\n    def handle_callback_and_get_context_info(self,\n                                             mock_tracker,\n                                             problem_display_name=None,\n                                             call_idx=0):\n        \"\"\"\n        Creates a fake block, invokes the callback and extracts the 'context'\n        metadata from the emitted problem_check event.\n        \"\"\"\n\n        block_kwargs = {\n            'category': 'problem',\n            'data': self.problem_xml\n        }\n        if problem_display_name:\n            block_kwargs['display_name'] = problem_display_name\n\n        block = BlockFactory.create(**block_kwargs)\n        mock_tracker_for_context = MagicMock()\n        with patch('lms.djangoapps.courseware.block_render.tracker', mock_tracker_for_context), patch(\n            'xmodule.services.tracker', mock_tracker_for_context\n        ):\n            render.handle_xblock_callback(\n                self.request,\n                str(self.course.id),\n                quote_slashes(str(block.location)),\n                'xmodule_handler',\n                'problem_check',\n            )\n\n            assert len(mock_tracker.emit.mock_calls) == 1\n            mock_call = mock_tracker.emit.mock_calls[0]\n            event = mock_call[2]\n\n            assert event['name'] == 'problem_check'\n\n            # for different operations, there are different number of context calls.\n            # We are sending this `call_idx` to get the mock call that we are interested in.\n            context = mock_tracker_for_context.get_tracker.mock_calls[call_idx][1][1]\n\n            return context\n\n    def handle_callback_and_get_block_info(self, mock_tracker, problem_display_name=None):\n        \"\"\"\n        Creates a fake block, invokes the callback and extracts the 'block'\n        metadata from the emitted problem_check event.\n        \"\"\"\n        event = self.handle_callback_and_get_context_info(\n            mock_tracker, problem_display_name, call_idx=1\n        )\n        return event['module']\n\n    def test_missing_display_name(self, mock_tracker):\n        actual_display_name = self.handle_callback_and_get_block_info(mock_tracker)['display_name']\n        assert actual_display_name.startswith('problem')\n\n    def test_library_source_information(self, mock_tracker):\n        \"\"\"\n        Check that XBlocks that are inherited from a library include the\n        information about their library block source in events.\n        We patch the modulestore to avoid having to create a library.\n        \"\"\"\n        original_usage_key = UsageKey.from_string('block-v1:A+B+C+type@problem+block@abcd1234')\n        original_usage_version = ObjectId()\n\n        def _mock_get_original_usage(_, __):\n            return original_usage_key, original_usage_version\n\n        with patch('xmodule.modulestore.mixed.MixedModuleStore.get_block_original_usage', _mock_get_original_usage):\n            block_info = self.handle_callback_and_get_block_info(mock_tracker)\n            assert 'original_usage_key' in block_info\n            assert block_info['original_usage_key'] == str(original_usage_key)\n            assert 'original_usage_version' in block_info\n            assert block_info['original_usage_version'] == str(original_usage_version)\n\n\nclass TestXBlockRuntimeEvent(TestSubmittingProblems):\n    \"\"\"\n    Inherit from TestSubmittingProblems to get functionality that set up a course and problems structure\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.homework = self.add_graded_section_to_course('homework')\n        self.problem = self.add_dropdown_to_section(self.homework.location, 'p1', 1)\n        self.grade_dict = {'value': 0.18, 'max_value': 32}\n        self.delete_dict = {'value': None, 'max_value': None}\n\n    def get_block_for_user(self, user):\n        \"\"\"Helper function to get useful block at self.location in self.course_id for user\"\"\"\n        mock_request = MagicMock()\n        mock_request.user = user\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id, user, self.course, depth=2)\n\n        return render.get_block(\n            user,\n            mock_request,\n            self.problem.location,\n            field_data_cache,\n        )\n\n    def set_block_grade_using_publish(self, grade_dict):\n        \"\"\"Publish the user's grade, takes grade_dict as input\"\"\"\n        block = self.get_block_for_user(self.student_user)\n        block.runtime.publish(block, 'grade', grade_dict)\n        return block\n\n    def test_xblock_runtime_publish(self):\n        \"\"\"Tests the publish mechanism\"\"\"\n        self.set_block_grade_using_publish(self.grade_dict)\n        student_module = StudentModule.objects.get(student=self.student_user, module_state_key=self.problem.location)\n        assert student_module.grade == self.grade_dict['value']\n        assert student_module.max_grade == self.grade_dict['max_value']\n\n    def test_xblock_runtime_publish_delete(self):\n        \"\"\"Test deleting the grade using the publish mechanism\"\"\"\n        block = self.set_block_grade_using_publish(self.grade_dict)\n        block.runtime.publish(block, 'grade', self.delete_dict)\n        student_module = StudentModule.objects.get(student=self.student_user, module_state_key=self.problem.location)\n        assert student_module.grade is None\n        assert student_module.max_grade is None\n\n    @patch('lms.djangoapps.grades.signals.handlers.PROBLEM_RAW_SCORE_CHANGED.send')\n    def test_score_change_signal(self, send_mock):\n        \"\"\"Test that a Django signal is generated when a score changes\"\"\"\n        with freeze_time(datetime.now().replace(tzinfo=pytz.UTC)):\n            self.set_block_grade_using_publish(self.grade_dict)\n            expected_signal_kwargs = {\n                'sender': None,\n                'raw_possible': self.grade_dict['max_value'],\n                'raw_earned': self.grade_dict['value'],\n                'weight': None,\n                'user_id': self.student_user.id,\n                'course_id': str(self.course.id),\n                'usage_id': str(self.problem.location),\n                'only_if_higher': None,\n                'modified': datetime.now().replace(tzinfo=pytz.UTC),\n                'score_db_table': 'csm',\n                'score_deleted': None,\n                'grader_response': None\n            }\n            send_mock.assert_called_with(**expected_signal_kwargs)\n\n\nclass TestRebindBlock(TestSubmittingProblems):\n    \"\"\"\n    Tests to verify the functionality of rebinding a block.\n    Inherit from TestSubmittingProblems to get functionality that set up a course structure\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.homework = self.add_graded_section_to_course('homework')\n        self.lti = BlockFactory.create(category='lti', parent=self.homework)\n        self.problem = BlockFactory.create(category='problem', parent=self.homework)\n        self.user = UserFactory.create()\n        self.anon_user = AnonymousUser()\n\n    def get_block_for_user(self, user, item=None):\n        \"\"\"Helper function to get useful block at self.location in self.course_id for user\"\"\"\n        mock_request = MagicMock()\n        mock_request.user = user\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id, user, self.course, depth=2)\n\n        if item is None:\n            item = self.lti\n\n        return render.get_block(\n            user,\n            mock_request,\n            item.location,\n            field_data_cache,\n        )\n\n    def test_rebind_block_to_new_users(self):\n        block = self.get_block_for_user(self.user, self.problem)\n\n        # Bind the block to another student, which will remove \"correct_map\"\n        # from the block's _field_data_cache and _dirty_fields.\n        user2 = UserFactory.create()\n        block.bind_for_student(user2.id)\n\n        # XBlock's save method assumes that if a field is in _dirty_fields,\n        # then it's also in _field_data_cache. If this assumption\n        # doesn't hold, then we get an error trying to bind this block\n        # to a third student, since we've removed \"correct_map\" from\n        # _field_data cache, but not _dirty_fields, when we bound\n        # this block to the second student. (TNL-2640)\n        user3 = UserFactory.create()\n        block.bind_for_student(user3.id)\n\n    def test_rebind_noauth_block_to_user_not_anonymous(self):\n        \"\"\"\n        Tests that an exception is thrown when rebind_noauth_block_to_user is run from a\n        block bound to a real user\n        \"\"\"\n        block = self.get_block_for_user(self.user)\n        user2 = UserFactory()\n        user2.id = 2\n        with self.assertRaisesRegex(\n            RebindUserServiceError,\n            \"rebind_noauth_module_to_user can only be called from a module bound to an anonymous user\"\n        ):\n            assert block.runtime.service(block, 'rebind_user').rebind_noauth_module_to_user(block, user2)\n\n    def test_rebind_noauth_block_to_user_anonymous(self):\n        \"\"\"\n        Tests that get_user_block_for_noauth succeeds when rebind_noauth_block_to_user is run from a\n        block bound to AnonymousUser\n        \"\"\"\n        block = self.get_block_for_user(self.anon_user)\n        user2 = UserFactory()\n        user2.id = 2\n        block.runtime.service(block, 'rebind_user').rebind_noauth_module_to_user(block, user2)\n        assert block\n        block_user_info = block.runtime.service(block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID) == anonymous_id_for_user(user2, self.course.id)\n        assert block.scope_ids.user_id == user2.id\n        assert block.scope_ids.user_id == user2.id\n\n\n@ddt.ddt\nclass TestEventPublishing(ModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Tests of event publishing for both XModules and XBlocks.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"\n        Set up the course and user context\n        \"\"\"\n        super().setUp()\n\n        self.mock_user = UserFactory()\n        self.mock_user.id = 1\n        self.request_factory = RequestFactoryNoCsrf()\n\n    @XBlock.register_temp_plugin(PureXBlock, identifier='xblock')\n    @patch.object(render, 'make_track_function')\n    def test_event_publishing(self, mock_track_function):\n        request = self.request_factory.get('')\n        request.user = self.mock_user\n        course = CourseFactory()\n        block = BlockFactory(category='xblock', parent=course)\n        field_data_cache = FieldDataCache([course, block], course.id, self.mock_user)\n        block = render.get_block(self.mock_user, request, block.location, field_data_cache)\n\n        event_type = 'event_type'\n        event = {'event': 'data'}\n\n        block.runtime.publish(block, event_type, event)\n\n        mock_track_function.assert_called_once_with(request)\n\n        mock_track_function.return_value.assert_called_once_with(event_type, event)\n\n\nclass LMSXBlockServiceMixin(SharedModuleStoreTestCase):\n    \"\"\"\n    Helper class that initializes the runtime.\n    \"\"\"\n    def _prepare_runtime(self):\n        \"\"\"\n        Instantiate the runtem.\n        \"\"\"\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course\n        )\n\n    @XBlock.register_temp_plugin(PureXBlock, identifier='pure')\n    def setUp(self):\n        \"\"\"\n        Set up the user and other fields that will be used to instantiate the runtime.\n        \"\"\"\n        super().setUp()\n        self.course = CourseFactory.create()\n        self.user = UserFactory()\n        self.student_data = Mock()\n        self.track_function = Mock()\n        self.request_token = Mock()\n        self.block = BlockFactory(category=\"pure\", parent=self.course)\n        self._prepare_runtime()\n\n\n@ddt.ddt\nclass LMSXBlockServiceBindingTest(LMSXBlockServiceMixin):\n    \"\"\"\n    Tests that the LMS Module System (XBlock Runtime) provides an expected set of services.\n    \"\"\"\n\n    @ddt.data(\n        'fs',\n        'field-data',\n        'mako',\n        'user',\n        'verification',\n        'proctoring',\n        'milestones',\n        'credit',\n        'bookmarks',\n        'gating',\n        'grade_utils',\n        'user_state',\n        'content_type_gating',\n        'cache',\n        'sandbox',\n        'replace_urls',\n        'rebind_user',\n        'completion',\n        'i18n',\n        'library_tools',\n        'partitions',\n        'settings',\n        'user_tags',\n        'teams',\n        'teams_configuration',\n        'call_to_action',\n    )\n    def test_expected_services_exist(self, expected_service):\n        \"\"\"\n        Tests that the 'user', 'i18n', and 'fs' services are provided by the LMS runtime.\n        \"\"\"\n        service = self.block.runtime.service(self.block, expected_service)\n        assert service is not None\n\n    def test_get_set_tag(self):\n        \"\"\"\n        Tests the user service interface.\n        \"\"\"\n        scope = 'course'\n        key = 'key1'\n\n        # test for when we haven't set the tag yet\n        tag = self.block.runtime.service(self.block, 'user_tags').get_tag(scope, key)\n        assert tag is None\n\n        # set the tag\n        set_value = 'value'\n        self.block.runtime.service(self.block, 'user_tags').set_tag(scope, key, set_value)\n        tag = self.block.runtime.service(self.block, 'user_tags').get_tag(scope, key)\n\n        assert tag == set_value\n\n        # Try to set tag in wrong scope\n        with pytest.raises(ValueError):\n            self.block.runtime.service(self.block, 'user_tags').set_tag('fake_scope', key, set_value)\n\n        # Try to get tag in wrong scope\n        with pytest.raises(ValueError):\n            self.block.runtime.service(self.block, 'user_tags').get_tag('fake_scope', key)\n\n\nclass TestI18nService(LMSXBlockServiceMixin):\n    \"\"\" Test XBlockI18nService \"\"\"\n\n    def test_module_i18n_lms_service(self):\n        \"\"\"\n        Test: module i18n service in LMS\n        \"\"\"\n        i18n_service = self.block.runtime.service(self.block, 'i18n')\n        assert i18n_service is not None\n        assert isinstance(i18n_service, XBlockI18nService)\n\n    def test_no_service_exception_with_none_declaration_(self):\n        \"\"\"\n        Test: NoSuchServiceError should be raised block declaration returns none\n        \"\"\"\n        self.block.service_declaration = Mock(return_value=None)\n        with pytest.raises(NoSuchServiceError):\n            self.block.runtime.service(self.block, 'i18n')\n\n    def test_no_service_exception_(self):\n        \"\"\"\n        Test: NoSuchServiceError should be raised if i18n service is none.\n        \"\"\"\n        i18nService = self.block.runtime._services['i18n']  # pylint: disable=protected-access\n        self.block.runtime._services['i18n'] = None  # pylint: disable=protected-access\n        with pytest.raises(NoSuchServiceError):\n            self.block.runtime.service(self.block, 'i18n')\n        self.block.runtime._services['i18n'] = i18nService  # pylint: disable=protected-access\n\n    def test_i18n_service_callable(self):\n        \"\"\"\n        Test: _services dict should contain the callable i18n service in LMS.\n        \"\"\"\n        assert callable(self.block.runtime._services.get('i18n'))  # pylint: disable=protected-access\n\n    def test_i18n_service_not_callable(self):\n        \"\"\"\n        Test: i18n service should not be callable in LMS after initialization.\n        \"\"\"\n        assert not callable(self.block.runtime.service(self.block, 'i18n'))\n\n\nclass PureXBlockWithChildren(PureXBlock):\n    \"\"\"\n    Pure XBlock with children to use in tests.\n    \"\"\"\n    has_children = True\n\n\nUSER_NUMBERS = list(range(2))\n\n\n@ddt.ddt\nclass TestFilteredChildren(SharedModuleStoreTestCase):\n    \"\"\"\n    Tests that verify access to XBlock/XModule children work correctly\n    even when those children are filtered by the runtime when loaded.\n    \"\"\"\n    # pylint: disable=attribute-defined-outside-init\n    def setUp(self):\n        super().setUp()\n        self.course = CourseFactory.create()\n        self.users = {number: UserFactory() for number in USER_NUMBERS}\n\n        self._old_has_access = render.has_access\n        patcher = patch('lms.djangoapps.courseware.block_render.has_access', self._has_access)\n        patcher.start()\n        self.addCleanup(patcher.stop)\n\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_unbound(self):\n        block = self._load_block()\n        self.assertUnboundChildren(block)\n\n    @ddt.data(*USER_NUMBERS)\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_unbound_then_bound_as_xblock(self, user_number):\n        user = self.users[user_number]\n        block = self._load_block()\n        self.assertUnboundChildren(block)\n        self._bind_block(block, user)\n        self.assertBoundChildren(block, user)\n\n    @ddt.data(*USER_NUMBERS)\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_bound_only_as_xblock(self, user_number):\n        user = self.users[user_number]\n        block = self._load_block()\n        self._bind_block(block, user)\n        self.assertBoundChildren(block, user)\n\n    def _load_block(self):\n        \"\"\"\n        Instantiate an XBlock with the appropriate set of children.\n        \"\"\"\n        self.parent = BlockFactory(category='xblock', parent=self.course)\n\n        # Create a child for each user\n        self.children_for_user = {\n            user: BlockFactory(category='xblock', parent=self.parent).scope_ids.usage_id  # lint-amnesty, pylint: disable=no-member\n            for user in self.users.values()\n        }\n\n        self.all_children = self.children_for_user.values()\n\n        return modulestore().get_item(self.parent.scope_ids.usage_id)  # lint-amnesty, pylint: disable=no-member\n\n    def _bind_block(self, block, user):\n        \"\"\"\n        Bind `block` to the supplied `user`.\n        \"\"\"\n        course_id = self.course.id\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            course_id,\n            user,\n            block,\n        )\n        return get_block_for_descriptor(\n            user,\n            Mock(name='request', user=user),\n            block,\n            field_data_cache,\n            course_id,\n            course=self.course\n        )\n\n    def _has_access(self, user, action, obj, course_key=None):\n        \"\"\"\n        Mock implementation of `has_access` used to control which blocks\n        have access to which children during tests.\n        \"\"\"\n        if action != 'load':\n            return self._old_has_access(user, action, obj, course_key)\n\n        if isinstance(obj, XBlock):\n            key = obj.scope_ids.usage_id\n        elif isinstance(obj, UsageKey):\n            key = obj\n        if key == self.parent.scope_ids.usage_id:  # lint-amnesty, pylint: disable=no-member\n            return AccessResponse(True)\n        return AccessResponse(key == self.children_for_user[user])\n\n    def assertBoundChildren(self, block, user):\n        \"\"\"\n        Ensure the bound children are indeed children.\n        \"\"\"\n        self.assertChildren(block, [self.children_for_user[user]])\n\n    def assertUnboundChildren(self, block):\n        \"\"\"\n        Ensure unbound children are indeed children.\n        \"\"\"\n        self.assertChildren(block, self.all_children)\n\n    def assertChildren(self, block, child_usage_ids):\n        \"\"\"\n        Used to assert that sets of children are equivalent.\n        \"\"\"\n        assert set(child_usage_ids) == {child.scope_ids.usage_id for child in block.get_children()}\n\n\n@ddt.ddt\nclass TestDisabledXBlockTypes(ModuleStoreTestCase):\n    \"\"\"\n    Tests that verify disabled XBlock types are not loaded.\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        XBlockConfiguration(name='video', enabled=False).save()\n\n    def test_get_item(self):\n        course = CourseFactory()\n        self._verify_block('video', course, 'HiddenBlockWithMixins')\n\n    def test_dynamic_updates(self):\n        \"\"\"Tests that the list of disabled xblocks can dynamically update.\"\"\"\n        course = CourseFactory()\n        item_usage_id = self._verify_block('problem', course, 'ProblemBlockWithMixins')\n        XBlockConfiguration(name='problem', enabled=False).save()\n\n        # First verify that the cached value is used until there is a new request cache.\n        self._verify_block('problem', course, 'ProblemBlockWithMixins', item_usage_id)\n\n        # Now simulate a new request cache.\n        self.store.request_cache.data.clear()\n        self._verify_block('problem', course, 'HiddenBlockWithMixins', item_usage_id)\n\n    def _verify_block(self, category, course, block, item_id=None):\n        \"\"\"\n        Helper method that gets an item with the specified category from the\n        modulestore and verifies that it has the expected block name.\n\n        Returns the item's usage_id.\n        \"\"\"\n        if not item_id:\n            item = BlockFactory(category=category, parent=course)\n            item_id = item.scope_ids.usage_id  # lint-amnesty, pylint: disable=no-member\n\n        item = self.store.get_item(item_id)\n        assert item.__class__.__name__ == block\n        return item_id\n\n\n@ddt.ddt\nclass LmsModuleSystemShimTest(SharedModuleStoreTestCase):\n    \"\"\"\n    Tests that the deprecated attributes in the LMS Module System (XBlock Runtime) return the expected values.\n    \"\"\"\n    MODULESTORE = TEST_DATA_SPLIT_MODULESTORE\n    COURSE_ID = 'course-v1:edX+LmsModuleShimTest+2021_Fall'\n    PYTHON_LIB_FILENAME = 'test_python_lib.zip'\n    PYTHON_LIB_SOURCE_FILE = './common/test/data/uploads/python_lib.zip'\n\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"\n        Set up the course and block used to instantiate the runtime.\n        \"\"\"\n        super().setUpClass()\n        org = 'edX'\n        number = 'LmsModuleShimTest'\n        run = '2021_Fall'\n        cls.course = CourseFactory.create(org=org, number=number, run=run)\n        cls.block = BlockFactory(category=\"vertical\", parent=cls.course)\n        cls.problem_block = BlockFactory(category=\"problem\", parent=cls.course)\n\n    def setUp(self):\n        \"\"\"\n        Set up the user and other fields that will be used to instantiate the runtime.\n        \"\"\"\n        super().setUp()\n        self.user = UserFactory(id=232)\n        self.student_data = Mock()\n        self.track_function = Mock()\n        self.request_token = Mock()\n        self.contentstore = contentstore()\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n\n    @ddt.data(\n        ('seed', 232),\n        ('user_id', 232),\n        ('user_is_staff', False),\n    )\n    @ddt.unpack\n    def test_user_service_attributes(self, attribute, expected_value):\n        \"\"\"\n        Tests that the deprecated attributes provided by the user service match expected values.\n        \"\"\"\n        assert getattr(self.block.runtime, attribute) == expected_value\n\n    @ddt.data((True, 'staff'), (False, 'student'))\n    @ddt.unpack\n    def test_user_is_staff(self, is_staff, expected_role):\n        if is_staff:\n            self.user = StaffFactory(course_key=self.course.id)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_STAFF) == is_staff\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_ROLE) == expected_role\n        with warnings.catch_warnings():  # For now, also test the deprecated accessors for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.user_is_staff == is_staff\n            assert self.block.runtime.get_user_role() == expected_role\n\n    @ddt.data(True, False)\n    def test_user_is_admin(self, is_global_staff):\n        if is_global_staff:\n            self.user = GlobalStaffFactory.create()\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_GLOBAL_STAFF) == is_global_staff\n        with warnings.catch_warnings():  # For now, also test the deprecated accessors for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.user_is_admin == is_global_staff\n\n    @ddt.data(True, False)\n    def test_user_is_beta_tester(self, is_beta_tester):\n        if is_beta_tester:\n            self.user = BetaTesterFactory(course_key=self.course.id)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_BETA_TESTER) == is_beta_tester\n        with warnings.catch_warnings():  # For now, also test the deprecated accessors for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.user_is_beta_tester == is_beta_tester\n\n    @ddt.data((True, 'instructor'), (False, 'student'))\n    @ddt.unpack\n    def test_get_user_role(self, is_instructor, expected_role):\n        if is_instructor:\n            self.user = InstructorFactory(course_key=self.course.id)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_ROLE) == expected_role\n        with warnings.catch_warnings():  # For now, also test the deprecated accessor for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.get_user_role() == expected_role\n\n    def test_anonymous_student_id(self):\n        expected_anon_id = anonymous_id_for_user(self.user, self.course.id)\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID) == expected_anon_id\n        with warnings.catch_warnings():  # For now, also test the deprecated accessor for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.anonymous_student_id == expected_anon_id\n\n    def test_anonymous_student_id_bug(self):\n        \"\"\"\n        Verifies that subsequent calls to prepare_runtime_for_user have no effect on each block runtime's\n        anonymous_student_id value.\n        \"\"\"\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.problem_block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        # Ensure the problem block returns a per-user anonymous id\n        assert self.problem_block.runtime.service(self.problem_block, 'user').get_current_user().opt_attrs.get(\n            ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID\n        ) == anonymous_id_for_user(self.user, None)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        # Ensure the vertical block returns a per-course+user anonymous id\n        assert self.block.runtime.service(self.block, 'user').get_current_user().opt_attrs.get(\n            ATTR_KEY_ANONYMOUS_USER_ID\n        ) == anonymous_id_for_user(self.user, self.course.id)\n\n        # Ensure the problem runtime's anonymous student ID is unchanged after the above call.\n        assert self.problem_block.runtime.service(self.problem_block, 'user').get_current_user().opt_attrs.get(\n            ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID\n        ) == anonymous_id_for_user(self.user, None)\n\n    def test_user_service_with_anonymous_user(self):\n        render.prepare_runtime_for_user(\n            AnonymousUser(),\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID) is None\n        assert self.block.scope_ids.user_id is None\n        assert not block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_STAFF)\n        assert not block_user_info.opt_attrs.get(ATTR_KEY_USER_ROLE)\n        # Also test the deprecated accessors for backwards compatibility:\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.anonymous_student_id is None\n            assert self.block.runtime.seed == 0\n            assert self.block.runtime.user_id is None\n            assert not self.block.runtime.user_is_staff\n            assert not self.block.runtime.get_user_role()\n\n    def test_get_real_user(self):\n        \"\"\"\n        Test the deprecated runtime.get_real_user() method, to ensure backwards compatibility.\n\n        Newer code should use the user service, which gets tested in test_user_service.py\n        \"\"\"\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        course_anonymous_student_id = anonymous_id_for_user(self.user, self.course.id)\n        no_course_anonymous_student_id = anonymous_id_for_user(self.user, None)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            # pylint: disable=not-callable\n            assert self.block.runtime.get_real_user(course_anonymous_student_id) == self.user\n            assert self.block.runtime.get_real_user(no_course_anonymous_student_id) == self.user\n            # Tests that the default is to use the user service's anonymous_student_id\n            assert self.block.runtime.get_real_user() == self.user\n\n    def test_render_template(self):\n        rendered = self.block.runtime.render_template('templates/edxmako.html', {'element_id': 'hi'})  # pylint: disable=not-callable\n        assert rendered == '<div id=\"hi\" ns=\"main\">Testing the MakoService</div>\\n'\n\n    @override_settings(COURSES_WITH_UNSAFE_CODE=[r'course-v1:edX\\+LmsModuleShimTest\\+2021_Fall'])\n    def test_can_execute_unsafe_code_when_allowed(self):\n        assert self.block.runtime.can_execute_unsafe_code()\n\n    @override_settings(COURSES_WITH_UNSAFE_CODE=[r'course-v1:edX\\+full\\+2021_Fall'])\n    def test_cannot_execute_unsafe_code_when_disallowed(self):\n        assert not self.block.runtime.can_execute_unsafe_code()\n\n    def test_cannot_execute_unsafe_code(self):\n        assert not self.block.runtime.can_execute_unsafe_code()\n\n    @override_settings(PYTHON_LIB_FILENAME=PYTHON_LIB_FILENAME)\n    def test_get_python_lib_zip(self):\n        zipfile = upload_file_to_course(\n            course_key=self.course.id,\n            contentstore=self.contentstore,\n            source_file=self.PYTHON_LIB_SOURCE_FILE,\n            target_filename=self.PYTHON_LIB_FILENAME,\n        )\n        assert self.block.runtime.get_python_lib_zip() == zipfile\n\n    def test_no_get_python_lib_zip(self):\n        zipfile = upload_file_to_course(\n            course_key=self.course.id,\n            contentstore=self.contentstore,\n            source_file=self.PYTHON_LIB_SOURCE_FILE,\n            target_filename=self.PYTHON_LIB_FILENAME,\n        )\n        assert self.block.runtime.get_python_lib_zip() is None\n\n    def test_cache(self):\n        assert hasattr(self.block.runtime.cache, 'get')\n        assert hasattr(self.block.runtime.cache, 'set')\n\n    @XBlock.register_temp_plugin(PureXBlock, 'pure')\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_course_id(self):\n        block = BlockFactory(category=\"pure\", parent=self.course)\n\n        rendered_block = render.get_block(self.user, Mock(), block.location, None)\n        assert str(rendered_block.scope_ids.usage_id.context_key) == self.COURSE_ID\n        with warnings.catch_warnings():  # For now, also test the deprecated accessor for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert str(rendered_block.runtime.course_id) == self.COURSE_ID\n"], "fixing_code": ["\"\"\"\nBlock rendering\n\"\"\"\n\nfrom __future__ import annotations\nimport json\nimport logging\nimport textwrap\nfrom collections import OrderedDict\n\nfrom functools import partial\n\nfrom completion.services import CompletionService\nfrom django.conf import settings\nfrom django.contrib.auth.models import AnonymousUser, User  # lint-amnesty, pylint: disable=imported-auth-user\nfrom django.core.cache import cache\nfrom django.db import transaction\nfrom django.http import Http404, HttpResponse, HttpResponseForbidden\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template.context_processors import csrf\nfrom django.urls import reverse\nfrom django.utils.text import slugify\nfrom django.views.decorators.clickjacking import xframe_options_exempt\nfrom django.views.decorators.csrf import csrf_exempt\nfrom edx_django_utils.cache import DEFAULT_REQUEST_CACHE, RequestCache\nfrom edx_django_utils.monitoring import set_custom_attributes_for_course_key, set_monitoring_transaction_name\nfrom edx_proctoring.api import get_attempt_status_summary\nfrom edx_proctoring.services import ProctoringService\nfrom edx_rest_framework_extensions.auth.jwt.authentication import JwtAuthentication\nfrom edx_rest_framework_extensions.permissions import JwtRestrictedApplication\nfrom edx_when.field_data import DateLookupFieldData\nfrom eventtracking import tracker\nfrom opaque_keys import InvalidKeyError\nfrom opaque_keys.edx.keys import CourseKey, UsageKey\nfrom rest_framework.decorators import api_view\nfrom rest_framework.exceptions import APIException\nfrom typing import Callable, TYPE_CHECKING\nfrom web_fragments.fragment import Fragment\nfrom xblock.django.request import django_to_webob_request, webob_to_django_response\nfrom xblock.exceptions import NoSuchHandlerError, NoSuchViewError\nfrom xblock.reference.plugins import FSService\nfrom xblock.runtime import KvsFieldData\n\nfrom lms.djangoapps.teams.services import TeamsService\nfrom openedx.core.lib.xblock_services.call_to_action import CallToActionService\nfrom xmodule.contentstore.django import contentstore\nfrom xmodule.exceptions import NotFoundError, ProcessingError\nfrom xmodule.library_tools import LibraryToolsService\nfrom xmodule.modulestore.django import XBlockI18nService, modulestore\nfrom xmodule.modulestore.exceptions import ItemNotFoundError\nfrom xmodule.partitions.partitions_service import PartitionService\nfrom xmodule.util.sandboxing import SandboxService\nfrom xmodule.services import EventPublishingService, RebindUserService, SettingsService, TeamsConfigurationService\nfrom common.djangoapps.static_replace.services import ReplaceURLService\nfrom common.djangoapps.static_replace.wrapper import replace_urls_wrapper\nfrom lms.djangoapps.courseware.access import get_user_role, has_access\nfrom lms.djangoapps.courseware.entrance_exams import user_can_skip_entrance_exam, user_has_passed_entrance_exam\nfrom lms.djangoapps.courseware.masquerade import (\n    MasqueradingKeyValueStore,\n    filter_displayed_blocks,\n    is_masquerading_as_specific_student,\n    setup_masquerade\n)\nfrom lms.djangoapps.courseware.model_data import DjangoKeyValueStore, FieldDataCache\nfrom lms.djangoapps.courseware.field_overrides import OverrideFieldData\nfrom lms.djangoapps.courseware.services import UserStateService\nfrom lms.djangoapps.grades.api import GradesUtilService\nfrom lms.djangoapps.lms_xblock.field_data import LmsFieldData\nfrom lms.djangoapps.lms_xblock.runtime import UserTagsService, lms_wrappers_aside, lms_applicable_aside_types\nfrom lms.djangoapps.verify_student.services import XBlockVerificationService\nfrom openedx.core.djangoapps.bookmarks.api import BookmarksService\nfrom openedx.core.djangoapps.crawlers.models import CrawlersConfig\nfrom openedx.core.djangoapps.credit.services import CreditService\nfrom openedx.core.djangoapps.util.user_utils import SystemUser\nfrom openedx.core.djangolib.markup import HTML\nfrom openedx.core.lib.api.authentication import BearerAuthenticationAllowInactiveUser\nfrom openedx.core.lib.api.view_utils import view_auth_classes\nfrom openedx.core.lib.gating.services import GatingService\nfrom openedx.core.lib.license import wrap_with_license\nfrom openedx.core.lib.url_utils import quote_slashes, unquote_slashes\nfrom openedx.core.lib.xblock_utils import (\n    add_staff_markup,\n    get_aside_from_xblock,\n    hash_resource,\n    is_xblock_aside\n)\nfrom openedx.core.lib.xblock_utils import request_token as xblock_request_token\nfrom openedx.core.lib.xblock_utils import wrap_xblock\nfrom openedx.features.course_duration_limits.access import course_expiration_wrapper\nfrom openedx.features.discounts.utils import offer_banner_wrapper\nfrom openedx.features.content_type_gating.services import ContentTypeGatingService\nfrom common.djangoapps.student.models import anonymous_id_for_user\nfrom common.djangoapps.student.roles import CourseBetaTesterRole\nfrom common.djangoapps.util import milestones_helpers\nfrom common.djangoapps.util.json_request import JsonResponse\nfrom common.djangoapps.edxmako.services import MakoService\nfrom common.djangoapps.xblock_django.user_service import DjangoXBlockUserService\nfrom openedx.core.lib.cache_utils import CacheService\n\nif TYPE_CHECKING:\n    from rest_framework.request import Request\n    from xblock.core import XBlock\n    from xblock.runtime import Runtime\n\n    from xmodule.course_block import CourseBlock\n\nlog = logging.getLogger(__name__)\n\n# TODO: course_id and course_key are used interchangeably in this file, which is wrong.\n# Some brave person should make the variable names consistently someday, but the code's\n# coupled enough that it's kind of tricky--you've been warned!\n\n\nclass LmsModuleRenderError(Exception):\n    \"\"\"\n    An exception class for exceptions thrown by block_render that don't fit well elsewhere\n    \"\"\"\n    pass  # lint-amnesty, pylint: disable=unnecessary-pass\n\n\ndef make_track_function(request):\n    '''\n    Make a tracking function that logs what happened.\n    For use in DescriptorSystem.\n    '''\n    from common.djangoapps.track import views as track_views\n\n    def function(event_type, event):\n        return track_views.server_track(request, event_type, event, page='x_module')\n    return function\n\n\ndef toc_for_course(user, request, course, active_chapter, active_section, field_data_cache):\n    '''\n    Create a table of contents from the module store\n\n    Return format:\n    { 'chapters': [\n            {'display_name': name, 'url_name': url_name, 'sections': SECTIONS, 'active': bool},\n        ],\n        'previous_of_active_section': {..},\n        'next_of_active_section': {..}\n    }\n\n    where SECTIONS is a list\n    [ {'display_name': name, 'url_name': url_name,\n       'format': format, 'due': due, 'active' : bool, 'graded': bool}, ...]\n\n    where previous_of_active_section and next_of_active_section have information on the\n    next/previous sections of the active section.\n\n    active is set for the section and chapter corresponding to the passed\n    parameters, which are expected to be url_names of the chapter+section.\n    Everything else comes from the xml, or defaults to \"\".\n\n    chapters with name 'hidden' are skipped.\n\n    NOTE: assumes that if we got this far, user has access to course.  Returns\n    None if this is not the case.\n\n    field_data_cache must include data from the course blocks and 2 levels of its descendants\n    '''\n    with modulestore().bulk_operations(course.id):\n        course_block = get_block_for_descriptor(\n            user, request, course, field_data_cache, course.id, course=course\n        )\n        if course_block is None:\n            return None, None, None\n\n        toc_chapters = []\n        chapters = course_block.get_children()\n\n        # Check for content which needs to be completed\n        # before the rest of the content is made available\n        required_content = milestones_helpers.get_required_content(course.id, user)\n\n        # The user may not actually have to complete the entrance exam, if one is required\n        if user_can_skip_entrance_exam(user, course):\n            required_content = [content for content in required_content if not content == course.entrance_exam_id]\n\n        previous_of_active_section, next_of_active_section = None, None\n        last_processed_section, last_processed_chapter = None, None\n        found_active_section = False\n        for chapter in chapters:\n            # Only show required content, if there is required content\n            # chapter.hide_from_toc is read-only (bool)\n            # xss-lint: disable=python-deprecated-display-name\n            display_id = slugify(chapter.display_name_with_default_escaped)\n            local_hide_from_toc = False\n            if required_content:\n                if str(chapter.location) not in required_content:\n                    local_hide_from_toc = True\n\n            # Skip the current chapter if a hide flag is tripped\n            if chapter.hide_from_toc or local_hide_from_toc:\n                continue\n\n            sections = []\n            for section in chapter.get_children():\n                # skip the section if it is hidden from the user\n                if section.hide_from_toc:\n                    continue\n\n                is_section_active = (chapter.url_name == active_chapter and section.url_name == active_section)\n                if is_section_active:\n                    found_active_section = True\n\n                section_context = {\n                    # xss-lint: disable=python-deprecated-display-name\n                    'display_name': section.display_name_with_default_escaped,\n                    'url_name': section.url_name,\n                    'format': section.format if section.format is not None else '',\n                    'due': section.due,\n                    'active': is_section_active,\n                    'graded': section.graded,\n                }\n                _add_timed_exam_info(user, course, section, section_context)\n\n                # update next and previous of active section, if applicable\n                if is_section_active:\n                    if last_processed_section:\n                        previous_of_active_section = last_processed_section.copy()\n                        previous_of_active_section['chapter_url_name'] = last_processed_chapter.url_name\n                elif found_active_section and not next_of_active_section:\n                    next_of_active_section = section_context.copy()\n                    next_of_active_section['chapter_url_name'] = chapter.url_name\n\n                sections.append(section_context)\n                last_processed_section = section_context\n                last_processed_chapter = chapter\n\n            toc_chapters.append({\n                # xss-lint: disable=python-deprecated-display-name\n                'display_name': chapter.display_name_with_default_escaped,\n                'display_id': display_id,\n                'url_name': chapter.url_name,\n                'sections': sections,\n                'active': chapter.url_name == active_chapter\n            })\n        return {\n            'chapters': toc_chapters,\n            'previous_of_active_section': previous_of_active_section,\n            'next_of_active_section': next_of_active_section,\n        }\n\n\ndef _add_timed_exam_info(user, course, section, section_context):\n    \"\"\"\n    Add in rendering context if exam is a timed exam (which includes proctored)\n    \"\"\"\n    section_is_time_limited = (\n        getattr(section, 'is_time_limited', False) and\n        settings.FEATURES.get('ENABLE_SPECIAL_EXAMS', False)\n    )\n    if section_is_time_limited:\n        # call into edx_proctoring subsystem\n        # to get relevant proctoring information regarding this\n        # level of the courseware\n        #\n        # This will return None, if (user, course_id, content_id)\n        # is not applicable\n        timed_exam_attempt_context = None\n        try:\n            timed_exam_attempt_context = get_attempt_status_summary(\n                user.id,\n                str(course.id),\n                str(section.location)\n            )\n        except Exception as ex:  # pylint: disable=broad-except\n            # safety net in case something blows up in edx_proctoring\n            # as this is just informational descriptions, it is better\n            # to log and continue (which is safe) than to have it be an\n            # unhandled exception\n            log.exception(ex)\n\n        if timed_exam_attempt_context:\n            # yes, user has proctoring context about\n            # this level of the courseware\n            # so add to the accordion data context\n            section_context.update({\n                'proctoring': timed_exam_attempt_context,\n            })\n\n\ndef get_block(user, request, usage_key, field_data_cache, position=None, log_if_not_found=True,\n              wrap_xblock_display=True, grade_bucket_type=None, depth=0, static_asset_path='', course=None,\n              will_recheck_access=False):\n    \"\"\"\n    Get an instance of the XBlock class identified by location,\n    setting the state based on an existing StudentModule, or creating one if none\n    exists.\n\n    Arguments:\n      - user                  : User for whom we're getting the block\n      - request               : current django HTTPrequest.  Note: request.user isn't used for anything--all auth\n                                and such works based on user.\n      - usage_key             : A UsageKey object identifying the module to load\n      - field_data_cache      : a FieldDataCache\n      - position              : Extra information from URL for user-specified position within module.\n                                It is used to determine the active tab within the `SequenceBlock`/subsection.\n                                Once the legacy course experience is removed, it should be safe to remove this, too.\n      - log_if_not_found      : If this is True, we log a debug message if we cannot find the requested xmodule.\n      - wrap_xblock_display   : If this is True, wrap the output display in a single div to allow for the\n                                XModule javascript to be bound correctly\n      - depth                 : number of levels of descendents to cache when loading this module.\n                                None means cache all descendents\n      - static_asset_path     : static asset path to use (overrides block's value); needed\n                                by get_course_info_section, because info section modules\n                                do not have a course as the parent module, and thus do not\n                                inherit this lms key value.\n      - will_recheck_access   : If True, the caller commits to re-checking access on each child XBlock\n                                before rendering the content in order to display access error messages\n                                to the user.\n\n    Returns: XBlock instance, or None if the user does not have access to the\n    block.  If there's an error, will try to return an instance of ErrorBlock\n    if possible.  If not possible, return None.\n    \"\"\"\n    try:\n        block = modulestore().get_item(usage_key, depth=depth)\n        return get_block_for_descriptor(user, request, block, field_data_cache, usage_key.course_key,\n                                        position=position,\n                                        wrap_xblock_display=wrap_xblock_display,\n                                        grade_bucket_type=grade_bucket_type,\n                                        static_asset_path=static_asset_path,\n                                        course=course, will_recheck_access=will_recheck_access)\n    except ItemNotFoundError:\n        if log_if_not_found:\n            log.debug(\"Error in get_block: ItemNotFoundError\")\n        return None\n\n    except:  # pylint: disable=W0702\n        # Something has gone terribly wrong, but still not letting it turn into a 500.\n        log.exception(\"Error in get_block\")\n        return None\n\n\ndef display_access_messages(user, block, view, frag, context):  # pylint: disable=W0613\n    \"\"\"\n    An XBlock wrapper that replaces the content fragment with a fragment or message determined by\n    the has_access check.\n    \"\"\"\n    blocked_prior_sibling = RequestCache('display_access_messages_prior_sibling')\n\n    load_access = has_access(user, 'load', block, block.scope_ids.usage_id.course_key)\n    if load_access:\n        blocked_prior_sibling.delete(block.parent)\n        return frag\n\n    prior_sibling = blocked_prior_sibling.get_cached_response(block.parent)\n\n    if prior_sibling.is_found and prior_sibling.value.error_code == load_access.error_code:\n        return Fragment(\"\")\n    else:\n        blocked_prior_sibling.set(block.parent, load_access)\n\n    if load_access.user_fragment:\n        msg_fragment = load_access.user_fragment\n    elif load_access.user_message:\n        msg_fragment = Fragment(textwrap.dedent(HTML(\"\"\"\\\n            <div>{}</div>\n        \"\"\").format(load_access.user_message)))\n    else:\n        msg_fragment = Fragment(\"\")\n\n    if load_access.developer_message and has_access(user, 'staff', block, block.scope_ids.usage_id.course_key):\n        msg_fragment.content += textwrap.dedent(HTML(\"\"\"\\\n            <div>{}</div>\n        \"\"\").format(load_access.developer_message))\n\n    return msg_fragment\n\n\n# pylint: disable=too-many-statements\ndef get_block_for_descriptor(\n    user: User | AnonymousUser,\n    request: Request | None,\n    block: XBlock,\n    field_data_cache: FieldDataCache | None,\n    course_key: CourseKey,\n    position: int | None = None,\n    wrap_xblock_display: bool = True,\n    grade_bucket_type: str | None = None,\n    static_asset_path: str = '',\n    disable_staff_debug_info: bool = False,\n    course: CourseBlock | None = None,\n    will_recheck_access: bool = False,\n    track_function: Callable[[str, dict], None] | None = None,\n    student_data: KvsFieldData | None = None,\n    request_token: str | None = None,\n    user_location: str | None = None,\n) -> XBlock | None:\n    \"\"\"\n    Implements get_block, extracting out the request-specific functionality.\n\n    disable_staff_debug_info : If this is True, exclude staff debug information in the rendering of the block.\n\n    See get_block() docstring for further details.\n    \"\"\"\n    if request:\n        track_function = track_function or make_track_function(request)\n        user_location = user_location or getattr(request, 'session', {}).get('country_code')\n        request_token = request_token or xblock_request_token(request)\n\n    if not student_data:\n        student_kvs = DjangoKeyValueStore(field_data_cache)\n        if is_masquerading_as_specific_student(user, course_key):\n            student_kvs = MasqueradingKeyValueStore(student_kvs, request.session)\n        student_data = KvsFieldData(student_kvs)\n\n    # The runtime is already shared between XBlocks. If there are no wrappers, it is the first initialization.\n    should_recreate_runtime = not block.runtime.wrappers\n\n    # If the runtime was prepared for another user, it should be recreated.\n    # This part can be removed if we remove all user-specific handling from the runtime services and pull this\n    # information directly from XBlocks during the service initialization.\n    if not should_recreate_runtime:\n        # If the user service is absent (which should never happen), the runtime should be reinitialized.\n        # We retrieve this service directly to bypass service declaration checks.\n        if user_service := block.runtime._services.get('user'):  # pylint: disable=protected-access\n            # Check the user ID bound to the runtime. This operation can run often for complex course structures, so we\n            # are accessing the protected attribute of the user service to reduce the number of queries.\n            should_recreate_runtime = user.id != user_service._django_user.id  # pylint: disable=protected-access\n        else:\n            should_recreate_runtime = True\n\n    if should_recreate_runtime:\n        prepare_runtime_for_user(\n            user=user,\n            student_data=student_data,  # These have implicit user bindings, the rest of args are considered not to\n            runtime=block.runtime,\n            course_id=course_key,\n            track_function=track_function,\n            wrap_xblock_display=wrap_xblock_display,\n            grade_bucket_type=grade_bucket_type,\n            static_asset_path=static_asset_path,\n            user_location=user_location,\n            request_token=request_token,\n            disable_staff_debug_info=disable_staff_debug_info,\n            course=course,\n            will_recheck_access=will_recheck_access,\n        )\n\n    # Pass position specified in URL to runtime.\n    if position is not None:\n        try:\n            position = int(position)\n        except (ValueError, TypeError):\n            log.exception('Non-integer %r passed as position.', position)\n            position = None\n\n    block.runtime.set('position', position)\n\n    block.bind_for_student(\n        user.id,\n        [\n            partial(DateLookupFieldData, course_id=course_key, user=user),\n            partial(OverrideFieldData.wrap, user, course),\n            partial(LmsFieldData, student_data=student_data),\n        ],\n    )\n\n    # Do not check access when it's a noauth request.\n    # Not that the access check needs to happen after the block is bound\n    # for the student, since there may be field override data for the student\n    # that affects xblock visibility.\n    user_needs_access_check = getattr(user, 'known', True) and not isinstance(user, SystemUser)\n    if user_needs_access_check:\n        access = has_access(user, 'load', block, course_key)\n        # A block should only be returned if either the user has access, or the user doesn't have access, but\n        # the failed access has a message for the user and the caller of this function specifies it will check access\n        # again. This allows blocks to show specific error message or upsells when access is denied.\n        caller_will_handle_access_error = (\n            not access\n            and will_recheck_access\n            and (access.user_message or access.user_fragment)\n        )\n        if access or caller_will_handle_access_error:\n            block.has_access_error = bool(caller_will_handle_access_error)\n            return block\n        return None\n    return block\n\n\ndef prepare_runtime_for_user(\n        user: User | AnonymousUser,\n        student_data: KvsFieldData,\n        # Arguments preceding this comment have user binding, those following don't\n        runtime: Runtime,\n        course_id: CourseKey,\n        track_function: Callable[[str, dict], None],\n        request_token: str,\n        position: int | None = None,\n        wrap_xblock_display: bool = True,\n        grade_bucket_type: str | None = None,\n        static_asset_path: str = '',\n        user_location: str | None = None,\n        disable_staff_debug_info: bool = False,\n        course: CourseBlock | None = None,\n        will_recheck_access: bool = False,\n):\n    \"\"\"\n    Helper function that binds the given xblock to a user and student_data to a user and the block.\n\n    The purpose of this function is to factor out everywhere a user is implicitly bound when creating a module,\n    to allow an existing block to be re-bound to a user.\n\n    The arguments fall into two categories: those that have explicit or implicit user binding, which are user\n    and student_data, and those don't and are used to instantiate the service required in LMS, which\n    are all the other arguments.\n\n    Arguments:\n        see arguments for get_block()\n        request_token (str): A token unique to the request use by xblock initialization\n    \"\"\"\n\n    def inner_get_block(block: XBlock) -> XBlock | None:\n        \"\"\"\n        Delegate to get_block_for_descriptor() with all values except `block` set.\n\n        Because it does an access check, it may return None.\n        \"\"\"\n        return get_block_for_descriptor(\n            user=user,\n            request=None,\n            field_data_cache=None,\n            block=block,\n            student_data=student_data,\n            course_key=course_id,\n            track_function=track_function,\n            request_token=request_token,\n            position=position,\n            wrap_xblock_display=wrap_xblock_display,\n            grade_bucket_type=grade_bucket_type,\n            static_asset_path=static_asset_path,\n            user_location=user_location,\n            course=course,\n            will_recheck_access=will_recheck_access,\n        )\n\n    # Build a list of wrapping functions that will be applied in order\n    # to the Fragment content coming out of the xblocks that are about to be rendered.\n    block_wrappers = []\n\n    if is_masquerading_as_specific_student(user, course_id):\n        block_wrappers.append(filter_displayed_blocks)\n\n    mako_service = MakoService()\n    if settings.FEATURES.get(\"LICENSING\", False):\n        block_wrappers.append(partial(wrap_with_license, mako_service=mako_service))\n\n    # Wrap the output display in a single div to allow for the XBlock\n    # javascript to be bound correctly\n    if wrap_xblock_display is True:\n        block_wrappers.append(partial(\n            wrap_xblock,\n            'LmsRuntime',\n            extra_data={'course-id': str(course_id)},\n            usage_id_serializer=lambda usage_id: quote_slashes(str(usage_id)),\n            request_token=request_token,\n        ))\n\n    replace_url_service = partial(\n        ReplaceURLService,\n        static_asset_path=static_asset_path,\n        jump_to_id_base_url=reverse('jump_to_id', kwargs={'course_id': str(course_id), 'module_id': ''}),\n    )\n\n    # Rewrite static urls with course-specific absolute urls\n    block_wrappers.append(partial(replace_urls_wrapper, replace_url_service=replace_url_service))\n\n    block_wrappers.append(partial(display_access_messages, user))\n    block_wrappers.append(partial(course_expiration_wrapper, user))\n    block_wrappers.append(partial(offer_banner_wrapper, user))\n\n    user_is_staff = bool(has_access(user, 'staff', course_id))\n\n    if settings.FEATURES.get('DISPLAY_DEBUG_INFO_TO_STAFF'):\n        if user_is_staff or is_masquerading_as_specific_student(user, course_id):\n            # When masquerading as a specific student, we want to show the debug button\n            # unconditionally to enable resetting the state of the student we are masquerading as.\n            # We already know the user has staff access when masquerading is active.\n            block_wrappers.append(partial(add_staff_markup, user, disable_staff_debug_info))\n\n    store = modulestore()\n\n    services = {\n        'fs': FSService(),\n        'mako': mako_service,\n        'user': DjangoXBlockUserService(\n            user,\n            user_is_beta_tester=CourseBetaTesterRole(course_id).has_user(user),\n            user_is_staff=user_is_staff,\n            user_is_global_staff=bool(has_access(user, 'staff', 'global')),\n            user_role=get_user_role(user, course_id),\n            anonymous_user_id=anonymous_id_for_user(user, course_id),\n            # See the docstring of `DjangoXBlockUserService`.\n            deprecated_anonymous_user_id=anonymous_id_for_user(user, None),\n            request_country_code=user_location,\n        ),\n        'verification': XBlockVerificationService(),\n        'proctoring': ProctoringService(),\n        'milestones': milestones_helpers.get_service(),\n        'credit': CreditService(),\n        'bookmarks': BookmarksService(user=user),\n        'gating': GatingService(),\n        'grade_utils': GradesUtilService(course_id=course_id),\n        'user_state': UserStateService(),\n        'content_type_gating': ContentTypeGatingService(),\n        'cache': CacheService(cache),\n        'sandbox': SandboxService(contentstore=contentstore, course_id=course_id),\n        'replace_urls': replace_url_service,\n        # Rebind module service to deal with noauth modules getting attached to users.\n        'rebind_user': RebindUserService(\n            user,\n            course_id,\n            track_function=track_function,\n            position=position,\n            wrap_xblock_display=wrap_xblock_display,\n            grade_bucket_type=grade_bucket_type,\n            static_asset_path=static_asset_path,\n            user_location=user_location,\n            request_token=request_token,\n            will_recheck_access=will_recheck_access,\n        ),\n        'completion': CompletionService(user=user, context_key=course_id) if user and user.is_authenticated else None,\n        'i18n': XBlockI18nService,\n        'library_tools': LibraryToolsService(store, user_id=user.id if user else None),\n        'partitions': PartitionService(course_id=course_id, cache=DEFAULT_REQUEST_CACHE.data),\n        'settings': SettingsService(),\n        'user_tags': UserTagsService(user=user, course_id=course_id),\n        'teams': TeamsService(),\n        'teams_configuration': TeamsConfigurationService(),\n        'call_to_action': CallToActionService(),\n        'publish': EventPublishingService(user, course_id, track_function),\n    }\n\n    runtime.get_block_for_descriptor = inner_get_block\n\n    runtime.wrappers = block_wrappers\n    runtime._services.update(services)  # lint-amnesty, pylint: disable=protected-access\n    runtime.request_token = request_token\n    runtime.wrap_asides_override = lms_wrappers_aside\n    runtime.applicable_aside_types_override = lms_applicable_aside_types\n\n\ndef load_single_xblock(request, user_id, course_id, usage_key_string, course=None, will_recheck_access=False):\n    \"\"\"\n    Load a single XBlock identified by usage_key_string.\n    \"\"\"\n    usage_key = UsageKey.from_string(usage_key_string)\n    course_key = CourseKey.from_string(course_id)\n    usage_key = usage_key.map_into_course(course_key)\n    user = User.objects.get(id=user_id)\n    field_data_cache = FieldDataCache.cache_for_block_descendents(\n        course_key,\n        user,\n        modulestore().get_item(usage_key),\n        depth=0,\n    )\n    instance = get_block(\n        user,\n        request,\n        usage_key,\n        field_data_cache,\n        grade_bucket_type='xqueue',\n        course=course,\n        will_recheck_access=will_recheck_access\n    )\n    if instance is None:\n        msg = f\"No module {usage_key_string} for user {user}--access denied?\"\n        log.debug(msg)\n        raise Http404\n    return instance\n\n\n@csrf_exempt\ndef xqueue_callback(request, course_id, userid, mod_id, dispatch):\n    '''\n    Entry point for graded results from the queueing system.\n    '''\n    data = request.POST.copy()\n\n    # Test xqueue package, which we expect to be:\n    #   xpackage = {'xqueue_header': json.dumps({'lms_key':'secretkey',...}),\n    #               'xqueue_body'  : 'Message from grader'}\n    for key in ['xqueue_header', 'xqueue_body']:\n        if key not in data:\n            raise Http404\n\n    header = json.loads(data['xqueue_header'])\n    if not isinstance(header, dict) or 'lms_key' not in header:\n        raise Http404\n\n    course_key = CourseKey.from_string(course_id)\n\n    with modulestore().bulk_operations(course_key):\n        course = modulestore().get_course(course_key, depth=0)\n\n        instance = load_single_xblock(request, userid, course_id, mod_id, course=course)\n\n        # Transfer 'queuekey' from xqueue response header to the data.\n        # This is required to use the interface defined by 'handle_ajax'\n        data.update({'queuekey': header['lms_key']})\n\n        # We go through the \"AJAX\" path\n        # So far, the only dispatch from xqueue will be 'score_update'\n        try:\n            # Can ignore the return value--not used for xqueue_callback\n            instance.handle_ajax(dispatch, data)\n            # Save any state that has changed to the underlying KeyValueStore\n            instance.save()\n        except:\n            log.exception(\"error processing ajax call\")\n            raise\n\n        return HttpResponse(\"\")\n\n\n@csrf_exempt\n@xframe_options_exempt\n@transaction.non_atomic_requests\ndef handle_xblock_callback_noauth(request, course_id, usage_id, handler, suffix=None):\n    \"\"\"\n    Entry point for unauthenticated XBlock handlers.\n    \"\"\"\n    request.user.known = False\n\n    course_key = CourseKey.from_string(course_id)\n    with modulestore().bulk_operations(course_key):\n        course = modulestore().get_course(course_key, depth=0)\n        return _invoke_xblock_handler(request, course_id, usage_id, handler, suffix, course=course)\n\n\n@csrf_exempt\n@xframe_options_exempt\n@transaction.non_atomic_requests\ndef handle_xblock_callback(request, course_id, usage_id, handler, suffix=None):\n    \"\"\"\n    Generic view for extensions. This is where AJAX calls go.\n\n    Arguments:\n        request (Request): Django request.\n        course_id (str): Course containing the block\n        usage_id (str)\n        handler (str)\n        suffix (str)\n\n    Raises:\n        HttpResponseForbidden: If the request method is not `GET` and user is not authenticated.\n        Http404: If the course is not found in the modulestore.\n    \"\"\"\n    # In this case, we are using Session based authentication, so we need to check CSRF token.\n    if request.user.is_authenticated:\n        error = CsrfViewMiddleware(get_response=lambda request: None).process_view(request, None, (), {})\n        if error:\n            return error\n\n    # We are reusing DRF logic to provide support for JWT and Oauth2. We abandoned the idea of using DRF view here\n    # to avoid introducing backwards-incompatible changes.\n    # You can see https://github.com/openedx/XBlock/pull/383 for more details.\n    else:\n        authentication_classes = (JwtAuthentication, BearerAuthenticationAllowInactiveUser)\n        authenticators = [auth() for auth in authentication_classes]\n\n        for authenticator in authenticators:\n            try:\n                user_auth_tuple = authenticator.authenticate(request)\n            except APIException:\n                log.exception(\n                    \"XBlock handler %r failed to authenticate with %s\", handler, authenticator.__class__.__name__\n                )\n            else:\n                if user_auth_tuple is not None:\n                    # When using JWT authentication, the second element contains the JWT token. We need it to determine\n                    # whether the application that issued the token is restricted.\n                    request.user, request.auth = user_auth_tuple\n                    # This is verified by the `JwtRestrictedApplication` before it decodes the token.\n                    request.successful_authenticator = authenticator\n                    break\n\n    # NOTE (CCB): Allow anonymous GET calls (e.g. for transcripts). Modifying this view is simpler than updating\n    # the XBlocks to use `handle_xblock_callback_noauth`, which is practically identical to this view.\n    # Block all request types coming from restricted applications.\n    if (\n        request.method != 'GET' and not (request.user and request.user.is_authenticated)\n    ) or JwtRestrictedApplication().has_permission(request, None):  # type: ignore\n        return HttpResponseForbidden('Unauthenticated')\n\n    request.user.known = request.user.is_authenticated\n\n    try:\n        course_key = CourseKey.from_string(course_id)\n    except InvalidKeyError:\n        raise Http404(f'{course_id} is not a valid course key')  # lint-amnesty, pylint: disable=raise-missing-from\n\n    with modulestore().bulk_operations(course_key):\n        try:\n            course = modulestore().get_course(course_key)\n        except ItemNotFoundError:\n            raise Http404(f'{course_id} does not exist in the modulestore')  # lint-amnesty, pylint: disable=raise-missing-from\n\n        return _invoke_xblock_handler(request, course_id, usage_id, handler, suffix, course=course)\n\n\ndef _get_usage_key_for_course(course_key, usage_id) -> UsageKey:\n    \"\"\"\n    Returns UsageKey mapped into the course for a given usage_id string\n    \"\"\"\n    try:\n        return UsageKey.from_string(unquote_slashes(usage_id)).map_into_course(course_key)\n    except InvalidKeyError as exc:\n        raise Http404(\"Invalid location\") from exc\n\n\ndef _get_block_by_usage_key(usage_key):\n    \"\"\"\n    Gets a block instance based on a mapped-to-course usage_key\n\n    Returns (instance, tracking_context)\n    \"\"\"\n    try:\n        block = modulestore().get_item(usage_key)\n        block_orig_usage_key, block_orig_version = modulestore().get_block_original_usage(usage_key)\n    except ItemNotFoundError as exc:\n        log.warning(\n            \"Invalid location for course id %s: %s\",\n            usage_key.course_key,\n            usage_key\n        )\n        raise Http404 from exc\n\n    tracking_context = {\n        'module': {\n            # xss-lint: disable=python-deprecated-display-name\n            'display_name': block.display_name_with_default_escaped,\n            'usage_key': str(block.location),\n        }\n    }\n\n    # For blocks that are inherited from a content library, we add some additional metadata:\n    if block_orig_usage_key is not None:\n        tracking_context['module']['original_usage_key'] = str(block_orig_usage_key)\n        tracking_context['module']['original_usage_version'] = str(block_orig_version)\n\n    return block, tracking_context\n\n\ndef get_block_by_usage_id(request, course_id, usage_id, disable_staff_debug_info=False, course=None,\n                          will_recheck_access=False):\n    \"\"\"\n    Gets a block instance based on its `usage_id` in a course, for a given request/user\n\n    Returns (instance, tracking_context)\n    \"\"\"\n    course_key = CourseKey.from_string(course_id)\n    usage_key = _get_usage_key_for_course(course_key, usage_id)\n    block, tracking_context = _get_block_by_usage_key(usage_key)\n\n    _, user = setup_masquerade(request, course_key, has_access(request.user, 'staff', block, course_key))\n    field_data_cache = FieldDataCache.cache_for_block_descendents(\n        course_key,\n        user,\n        block,\n        read_only=CrawlersConfig.is_crawler(request),\n    )\n    instance = get_block_for_descriptor(\n        user,\n        request,\n        block,\n        field_data_cache,\n        usage_key.course_key,\n        disable_staff_debug_info=disable_staff_debug_info,\n        course=course,\n        will_recheck_access=will_recheck_access,\n    )\n    if instance is None:\n        # Either permissions just changed, or someone is trying to be clever\n        # and load something they shouldn't have access to.\n        log.debug(\"No module %s for user %s -- access denied?\", usage_key, user)\n        raise Http404\n\n    return instance, tracking_context\n\n\ndef _invoke_xblock_handler(request, course_id, usage_id, handler, suffix, course=None):\n    \"\"\"\n    Invoke an XBlock handler, either authenticated or not.\n\n    Arguments:\n        request (HttpRequest): the current request\n        course_id (str): A string of the form org/course/run\n        usage_id (str): A string of the form i4x://org/course/category/name@revision\n        handler (str): The name of the handler to invoke\n        suffix (str): The suffix to pass to the handler when invoked\n    \"\"\"\n\n    # Check submitted files\n    files = request.FILES or {}\n    error_msg = _check_files_limits(files)\n    if error_msg:\n        return JsonResponse({'success': error_msg}, status=413)\n\n    # Make a CourseKey from the course_id, raising a 404 upon parse error.\n    try:\n        course_key = CourseKey.from_string(course_id)\n    except InvalidKeyError as exc:\n        raise Http404 from exc\n\n    set_custom_attributes_for_course_key(course_key)\n\n    with modulestore().bulk_operations(course_key):\n        usage_key = _get_usage_key_for_course(course_key, usage_id)\n        if is_xblock_aside(usage_key):\n            # Get the usage key for the block being wrapped by the aside (not the aside itself)\n            block_usage_key = usage_key.usage_key\n        else:\n            block_usage_key = usage_key\n\n        # Peek at the handler method to see if it actually wants to check access itself. (The handler may not want\n        # inaccessible blocks stripped from the tree.) This ends up doing two modulestore lookups for the block,\n        # but the blocks should be available in the request cache the second time.\n        # At the time of writing, this is only used by one handler. If this usage grows, we may want to re-evaluate\n        # how we do this to something more elegant. If you are the author of a third party block that decides it wants\n        # to set this too, please let us know so we can consider making this easier / better-documented.\n        block, _ = _get_block_by_usage_key(block_usage_key)\n        handler_method = getattr(block, handler, False)\n        will_recheck_access = handler_method and getattr(handler_method, 'will_recheck_access', False)\n\n        instance, tracking_context = get_block_by_usage_id(\n            request, course_id, str(block_usage_key), course=course, will_recheck_access=will_recheck_access,\n        )\n\n        # Name the transaction so that we can view XBlock handlers separately in\n        # New Relic. The suffix is necessary for XBlock handlers because the\n        # \"handler\" in those cases is always just \"xmodule_handler\".\n        nr_tx_name = f\"{instance.__class__.__name__}.{handler}\"\n        nr_tx_name += f\"/{suffix}\" if (suffix and handler == \"xmodule_handler\") else \"\"\n        set_monitoring_transaction_name(nr_tx_name, group=\"Python/XBlock/Handler\")\n\n        tracking_context_name = 'module_callback_handler'\n        req = django_to_webob_request(request)\n        try:\n            with tracker.get_tracker().context(tracking_context_name, tracking_context):\n                if is_xblock_aside(usage_key):\n                    # In this case, 'instance' is the XBlock being wrapped by the aside, so\n                    # the actual aside instance needs to be retrieved in order to invoke its\n                    # handler method.\n                    handler_instance = get_aside_from_xblock(instance, usage_key.aside_type)\n                else:\n                    handler_instance = instance\n                resp = handler_instance.handle(handler, req, suffix)\n                if suffix == 'problem_check' \\\n                        and course \\\n                        and getattr(course, 'entrance_exam_enabled', False) \\\n                        and getattr(instance, 'in_entrance_exam', False):\n                    ee_data = {'entrance_exam_passed': user_has_passed_entrance_exam(request.user, course)}\n                    resp = append_data_to_webob_response(resp, ee_data)\n\n        except NoSuchHandlerError:\n            log.exception(\"XBlock %s attempted to access missing handler %r\", instance, handler)\n            raise Http404  # lint-amnesty, pylint: disable=raise-missing-from\n\n        # If we can't find the block, respond with a 404\n        except NotFoundError:\n            log.exception(\"Module indicating to user that request doesn't exist\")\n            raise Http404  # lint-amnesty, pylint: disable=raise-missing-from\n\n        # For XBlock-specific errors, we log the error and respond with an error message\n        except ProcessingError as err:\n            log.warning(\"Module encountered an error while processing AJAX call\",\n                        exc_info=True)\n            return JsonResponse({'success': err.args[0]}, status=200)\n\n        # If any other error occurred, re-raise it to trigger a 500 response\n        except Exception:\n            log.exception(\"error executing xblock handler\")\n            raise\n\n    return webob_to_django_response(resp)\n\n\n@api_view(['GET'])\n@view_auth_classes(is_authenticated=True)\ndef xblock_view(request, course_id, usage_id, view_name):\n    \"\"\"\n    Returns the rendered view of a given XBlock, with related resources\n\n    Returns a json object containing two keys:\n        html: The rendered html of the view\n        resources: A list of tuples where the first element is the resource hash, and\n            the second is the resource description\n    \"\"\"\n    if not settings.FEATURES.get('ENABLE_XBLOCK_VIEW_ENDPOINT', False):\n        log.warning(\"Attempt to use deactivated XBlock view endpoint -\"\n                    \" see FEATURES['ENABLE_XBLOCK_VIEW_ENDPOINT']\")\n        raise Http404\n\n    try:\n        course_key = CourseKey.from_string(course_id)\n    except InvalidKeyError:\n        raise Http404(\"Invalid location\")  # lint-amnesty, pylint: disable=raise-missing-from\n\n    with modulestore().bulk_operations(course_key):\n        course = modulestore().get_course(course_key)\n        instance, _ = get_block_by_usage_id(request, course_id, usage_id, course=course)\n\n        try:\n            fragment = instance.render(view_name, context=request.GET)\n        except NoSuchViewError:\n            log.exception(\"Attempt to render missing view on %s: %s\", instance, view_name)\n            raise Http404  # lint-amnesty, pylint: disable=raise-missing-from\n\n        hashed_resources = OrderedDict()\n        for resource in fragment.resources:\n            hashed_resources[hash_resource(resource)] = resource\n\n        return JsonResponse({\n            'html': fragment.content,\n            'resources': list(hashed_resources.items()),\n            'csrf_token': str(csrf(request)['csrf_token']),\n        })\n\n\ndef _check_files_limits(files):\n    \"\"\"\n    Check if the files in a request are under the limits defined by\n    `settings.MAX_FILEUPLOADS_PER_INPUT` and\n    `settings.STUDENT_FILEUPLOAD_MAX_SIZE`.\n\n    Returns None if files are correct or an error messages otherwise.\n    \"\"\"\n    for fileinput_id in files.keys():\n        inputfiles = files.getlist(fileinput_id)\n\n        # Check number of files submitted\n        if len(inputfiles) > settings.MAX_FILEUPLOADS_PER_INPUT:\n            msg = 'Submission aborted! Maximum %d files may be submitted at once' % \\\n                  settings.MAX_FILEUPLOADS_PER_INPUT\n            return msg\n\n        # Check file sizes\n        for inputfile in inputfiles:\n            if inputfile.size > settings.STUDENT_FILEUPLOAD_MAX_SIZE:  # Bytes\n                msg = 'Submission aborted! Your file \"%s\" is too large (max size: %d MB)' % \\\n                      (inputfile.name, settings.STUDENT_FILEUPLOAD_MAX_SIZE / (1000 ** 2))\n                return msg\n\n    return None\n\n\ndef append_data_to_webob_response(response, data):\n    \"\"\"\n    Appends data to a JSON webob response.\n\n    Arguments:\n        response (webob response object):  the webob response object that needs to be modified\n        data (dict):  dictionary containing data that needs to be appended to response body\n\n    Returns:\n        (webob response object):  webob response with updated body.\n\n    \"\"\"\n    if getattr(response, 'content_type', None) == 'application/json':\n        json_input = response.body.decode('utf-8') if isinstance(response.body, bytes) else response.body\n        response_data = json.loads(json_input)\n        response_data.update(data)\n        response.body = json.dumps(response_data).encode('utf-8')\n    return response\n", "\"\"\"\nTest for lms courseware app, block render unit\n\"\"\"\nimport json\nimport textwrap\nfrom datetime import datetime\nfrom functools import partial\nfrom unittest.mock import MagicMock, Mock, patch\nimport warnings\n\nimport pytest\nimport ddt\nimport pytz\nfrom bson import ObjectId\nfrom completion.waffle import ENABLE_COMPLETION_TRACKING_SWITCH  # lint-amnesty, pylint: disable=wrong-import-order\nfrom completion.models import BlockCompletion  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.conf import settings  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.contrib.auth.models import AnonymousUser  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.http import Http404, HttpResponse  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.middleware.csrf import get_token  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.test.client import RequestFactory  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.test.utils import override_settings  # lint-amnesty, pylint: disable=wrong-import-order\nfrom django.urls import reverse  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_proctoring.api import create_exam, create_exam_attempt, update_attempt_status  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_proctoring.runtime import set_runtime_service  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_proctoring.tests.test_services import MockCertificateService, MockCreditService, MockGradesService  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_toggles.toggles.testutils import override_waffle_switch  # lint-amnesty, pylint: disable=wrong-import-order\nfrom edx_when.field_data import DateLookupFieldData  # lint-amnesty, pylint: disable=wrong-import-order\nfrom freezegun import freeze_time  # lint-amnesty, pylint: disable=wrong-import-order\nfrom milestones.tests.utils import MilestonesTestCaseMixin  # lint-amnesty, pylint: disable=wrong-import-order\nfrom opaque_keys.edx.asides import AsideUsageKeyV2  # lint-amnesty, pylint: disable=wrong-import-order\nfrom opaque_keys.edx.keys import CourseKey, UsageKey  # lint-amnesty, pylint: disable=wrong-import-order\nfrom pyquery import PyQuery  # lint-amnesty, pylint: disable=wrong-import-order\nfrom web_fragments.fragment import Fragment  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.completable import CompletableXBlockMixin  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.core import XBlock, XBlockAside  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.exceptions import NoSuchServiceError\nfrom xblock.field_data import FieldData  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.fields import ScopeIds  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.runtime import DictKeyValueStore, KvsFieldData  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xblock.test.tools import TestRuntime  # lint-amnesty, pylint: disable=wrong-import-order\n\nfrom xmodule.capa.tests.response_xml_factory import OptionResponseXMLFactory  # lint-amnesty, pylint: disable=reimported\nfrom xmodule.capa_block import ProblemBlock\nfrom xmodule.contentstore.django import contentstore\nfrom xmodule.html_block import AboutBlock, CourseInfoBlock, HtmlBlock, StaticTabBlock\nfrom xmodule.lti_block import LTIBlock\nfrom xmodule.modulestore import ModuleStoreEnum\nfrom xmodule.modulestore.django import XBlockI18nService, modulestore\nfrom xmodule.modulestore.tests.django_utils import (\n    TEST_DATA_SPLIT_MODULESTORE,\n    ModuleStoreTestCase,\n    SharedModuleStoreTestCase,\n    upload_file_to_course,\n)\nfrom xmodule.modulestore.tests.factories import CourseFactory, BlockFactory, ToyCourseFactory, check_mongo_calls  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xmodule.modulestore.tests.test_asides import AsideTestType  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xmodule.services import RebindUserServiceError\nfrom xmodule.video_block import VideoBlock  # lint-amnesty, pylint: disable=wrong-import-order\nfrom xmodule.x_module import STUDENT_VIEW, DescriptorSystem  # lint-amnesty, pylint: disable=wrong-import-order\nfrom common.djangoapps.course_modes.models import CourseMode  # lint-amnesty, pylint: disable=reimported\nfrom common.djangoapps.student.tests.factories import (\n    BetaTesterFactory,\n    GlobalStaffFactory,\n    InstructorFactory,\n    RequestFactoryNoCsrf,\n    StaffFactory,\n    UserFactory,\n)\nfrom common.djangoapps.xblock_django.constants import (\n    ATTR_KEY_ANONYMOUS_USER_ID,\n    ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID,\n    ATTR_KEY_USER_IS_BETA_TESTER,\n    ATTR_KEY_USER_IS_GLOBAL_STAFF,\n    ATTR_KEY_USER_IS_STAFF,\n    ATTR_KEY_USER_ROLE,\n)\nfrom lms.djangoapps.courseware import block_render as render\nfrom lms.djangoapps.courseware.access_response import AccessResponse\nfrom lms.djangoapps.courseware.courses import get_course_info_section, get_course_with_access\nfrom lms.djangoapps.courseware.field_overrides import OverrideFieldData\nfrom lms.djangoapps.courseware.masquerade import CourseMasquerade\nfrom lms.djangoapps.courseware.model_data import FieldDataCache\nfrom lms.djangoapps.courseware.models import StudentModule\nfrom lms.djangoapps.courseware.block_render import get_block_for_descriptor, hash_resource\nfrom lms.djangoapps.courseware.tests.factories import StudentModuleFactory\nfrom lms.djangoapps.courseware.tests.test_submitting_problems import TestSubmittingProblems\nfrom lms.djangoapps.courseware.tests.tests import LoginEnrollmentTestCase\nfrom lms.djangoapps.lms_xblock.field_data import LmsFieldData\nfrom openedx.core.djangoapps.credit.api import set_credit_requirement_status, set_credit_requirements\nfrom openedx.core.djangoapps.credit.models import CreditCourse\nfrom openedx.core.djangoapps.oauth_dispatch.jwt import _create_jwt, create_jwt_for_user\nfrom openedx.core.djangoapps.oauth_dispatch.tests.factories import AccessTokenFactory, ApplicationFactory\nfrom openedx.core.lib.courses import course_image_url\nfrom openedx.core.lib.gating import api as gating_api\nfrom openedx.core.lib.url_utils import quote_slashes\nfrom common.djangoapps.student.models import CourseEnrollment, anonymous_id_for_user\nfrom lms.djangoapps.verify_student.tests.factories import SoftwareSecurePhotoVerificationFactory\nfrom common.djangoapps.xblock_django.models import XBlockConfiguration\n\n\nTEST_DATA_DIR = settings.COMMON_TEST_DATA_ROOT\n\n\n@XBlock.needs('fs')\n@XBlock.needs('mako')\n@XBlock.needs('user')\n@XBlock.needs('verification')\n@XBlock.needs('proctoring')\n@XBlock.needs('milestones')\n@XBlock.needs('credit')\n@XBlock.needs('bookmarks')\n@XBlock.needs('gating')\n@XBlock.needs('grade_utils')\n@XBlock.needs('user_state')\n@XBlock.needs('content_type_gating')\n@XBlock.needs('cache')\n@XBlock.needs('sandbox')\n@XBlock.needs('replace_urls')\n@XBlock.needs('rebind_user')\n@XBlock.needs('completion')\n@XBlock.needs('i18n')\n@XBlock.needs('library_tools')\n@XBlock.needs('partitions')\n@XBlock.needs('settings')\n@XBlock.needs('user_tags')\n@XBlock.needs('badging')\n@XBlock.needs('teams')\n@XBlock.needs('teams_configuration')\n@XBlock.needs('call_to_action')\nclass PureXBlock(XBlock):\n    \"\"\"\n    Pure XBlock to use in tests.\n    \"\"\"\n    pass  # lint-amnesty, pylint: disable=unnecessary-pass\n\n\nclass GradedStatelessXBlock(XBlock):\n    \"\"\"\n    This XBlock exists to test grade storage for blocks that don't store\n    student state in a scoped field.\n    \"\"\"\n\n    @XBlock.json_handler\n    def set_score(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Set the score for this testing XBlock.\n        \"\"\"\n        self.runtime.publish(\n            self,\n            'grade',\n            {\n                'value': json_data['grade'],\n                'max_value': 1\n            }\n        )\n\n\nclass StubCompletableXBlock(CompletableXBlockMixin):\n    \"\"\"\n    This XBlock exists to test completion storage.\n    \"\"\"\n\n    @XBlock.json_handler\n    def complete(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Mark the block's completion value using the completion API.\n        \"\"\"\n        return self.runtime.publish(  # lint-amnesty, pylint: disable=no-member\n            self,\n            'completion',\n            {'completion': json_data['completion']},\n        )\n\n    @XBlock.json_handler\n    def progress(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Mark the block as complete using the deprecated progress interface.\n\n        New code should use the completion event instead.\n        \"\"\"\n        return self.runtime.publish(self, 'progress', {})  # lint-amnesty, pylint: disable=no-member\n\n\nclass XBlockWithoutCompletionAPI(XBlock):\n    \"\"\"\n    This XBlock exists to test completion storage for xblocks\n    that don't support completion API but do emit progress signal.\n    \"\"\"\n\n    @XBlock.json_handler\n    def progress(self, json_data, suffix):  # pylint: disable=unused-argument\n        \"\"\"\n        Mark the block as complete using the deprecated progress interface.\n\n        New code should use the completion event instead.\n        \"\"\"\n        return self.runtime.publish(self, 'progress', {})\n\n\n@ddt.ddt\nclass BlockRenderTestCase(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Tests of courseware.block_render\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.toy_course = modulestore().get_course(cls.course_key)\n\n    # TODO: this test relies on the specific setup of the toy course.\n    # It should be rewritten to build the course it needs and then test that.\n    def setUp(self):\n        \"\"\"\n        Set up the course and user context\n        \"\"\"\n        super().setUp()\n        OverrideFieldData.provider_classes = None\n\n        self.mock_user = UserFactory()\n        self.mock_user.id = 1\n        self.request_factory = RequestFactoryNoCsrf()\n\n        # Construct a mock block for the modulestore to return\n        self.mock_block = MagicMock()\n        self.mock_block.id = 1\n        self.dispatch = 'score_update'\n\n        # Construct a 'standard' xqueue_callback url\n        self.callback_url = reverse(\n            'xqueue_callback',\n            kwargs=dict(\n                course_id=str(self.course_key),\n                userid=str(self.mock_user.id),\n                mod_id=self.mock_block.id,\n                dispatch=self.dispatch\n            )\n        )\n\n    def tearDown(self):\n        OverrideFieldData.provider_classes = None\n        super().tearDown()\n\n    def test_get_block(self):\n        assert render.get_block('dummyuser', None, 'invalid location', None) is None\n\n    def test_block_render_with_jump_to_id(self):\n        \"\"\"\n        This test validates that the /jump_to_id/<id> shorthand for intracourse linking works assertIn\n        expected. Note there's a HTML element in the 'toy' course with the url_name 'toyjumpto' which\n        defines this linkage\n        \"\"\"\n        mock_request = MagicMock()\n        mock_request.user = self.mock_user\n\n        course = get_course_with_access(self.mock_user, 'load', self.course_key)\n\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course_key, self.mock_user, course, depth=2)\n\n        block = render.get_block(\n            self.mock_user,\n            mock_request,\n            self.course_key.make_usage_key('html', 'toyjumpto'),\n            field_data_cache,\n        )\n\n        # get the rendered HTML output which should have the rewritten link\n        html = block.render(STUDENT_VIEW).content\n\n        # See if the url got rewritten to the target link\n        # note if the URL mapping changes then this assertion will break\n        assert '/courses/' + str(self.course_key) + '/jump_to_id/vertical_test' in html\n\n    def test_xqueue_callback_success(self):\n        \"\"\"\n        Test for happy-path xqueue_callback\n        \"\"\"\n        fake_key = 'fake key'\n        xqueue_header = json.dumps({'lms_key': fake_key})\n        data = {\n            'xqueue_header': xqueue_header,\n            'xqueue_body': 'hello world',\n        }\n\n        # Patch getmodule to return our mock block\n        with patch('lms.djangoapps.courseware.block_render.load_single_xblock', return_value=self.mock_block):\n            # call xqueue_callback with our mocked information\n            request = self.request_factory.post(self.callback_url, data)\n            render.xqueue_callback(\n                request,\n                str(self.course_key),\n                self.mock_user.id,\n                self.mock_block.id,\n                self.dispatch\n            )\n\n        # Verify that handle ajax is called with the correct data\n        request.POST._mutable = True  # lint-amnesty, pylint: disable=protected-access\n        request.POST['queuekey'] = fake_key\n        self.mock_block.handle_ajax.assert_called_once_with(self.dispatch, request.POST)\n\n    def test_xqueue_callback_missing_header_info(self):\n        data = {\n            'xqueue_header': '{}',\n            'xqueue_body': 'hello world',\n        }\n\n        with patch('lms.djangoapps.courseware.block_render.load_single_xblock', return_value=self.mock_block):\n            # Test with missing xqueue data\n            with pytest.raises(Http404):\n                request = self.request_factory.post(self.callback_url, {})\n                render.xqueue_callback(\n                    request,\n                    str(self.course_key),\n                    self.mock_user.id,\n                    self.mock_block.id,\n                    self.dispatch\n                )\n\n            # Test with missing xqueue_header\n            with pytest.raises(Http404):\n                request = self.request_factory.post(self.callback_url, data)\n                render.xqueue_callback(\n                    request,\n                    str(self.course_key),\n                    self.mock_user.id,\n                    self.mock_block.id,\n                    self.dispatch\n                )\n\n    def _get_dispatch_url(self):\n        \"\"\"Helper to get dispatch URL for testing xblock callback.\"\"\"\n        return reverse(\n            'xblock_handler',\n            args=[\n                str(self.course_key),\n                quote_slashes(str(self.course_key.make_usage_key('sequential', 'Toy_Videos'))),\n                'xmodule_handler',\n                'goto_position'\n            ]\n        )\n\n    def test_anonymous_get_xblock_callback(self):\n        \"\"\"Test that anonymous GET is allowed.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.get(dispatch_url)\n        assert 200 == response.status_code\n\n    def test_anonymous_post_xblock_callback(self):\n        \"\"\"Test that anonymous POST is not allowed.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.post(dispatch_url, {'position': 2})\n\n        # https://openedx.atlassian.net/browse/LEARNER-7131\n        assert 'Unauthenticated' == response.content.decode('utf-8')\n        assert 403 == response.status_code\n\n    def test_session_authentication(self):\n        \"\"\" Test that the xblock endpoint supports session authentication.\"\"\"\n        self.client.login(username=self.mock_user.username, password=self.TEST_PASSWORD)\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.post(dispatch_url)\n        assert 200 == response.status_code\n\n    def test_oauth_authentication(self):\n        \"\"\" Test that the xblock endpoint supports OAuth authentication.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        access_token = AccessTokenFactory(user=self.mock_user, application=ApplicationFactory()).token\n        headers = {'HTTP_AUTHORIZATION': 'Bearer ' + access_token}\n        response = self.client.post(dispatch_url, {}, **headers)\n        assert 200 == response.status_code\n\n    def test_jwt_authentication(self):\n        \"\"\" Test that the xblock endpoint supports JWT authentication.\"\"\"\n        dispatch_url = self._get_dispatch_url()\n        token = create_jwt_for_user(self.mock_user)\n        headers = {'HTTP_AUTHORIZATION': 'JWT ' + token}\n        response = self.client.post(dispatch_url, {}, **headers)\n        assert 200 == response.status_code\n\n    def test_jwt_authentication_with_restricted_application(self):\n        \"\"\"Test that the XBlock endpoint disallows JWT authentication with restricted applications.\"\"\"\n\n        def _mock_create_restricted_jwt(*args, **kwargs):\n            \"\"\"Pass an additional argument to `_create_jwt` without modifying the signature of `create_jwt_for_user`.\"\"\"\n            kwargs['is_restricted'] = True\n            return _create_jwt(*args, **kwargs)\n\n        with patch('openedx.core.djangoapps.oauth_dispatch.jwt._create_jwt', _mock_create_restricted_jwt):\n            token = create_jwt_for_user(self.mock_user)\n\n        dispatch_url = self._get_dispatch_url()\n        headers = {'HTTP_AUTHORIZATION': 'JWT ' + token}\n\n        response = self.client.get(dispatch_url, {}, **headers)\n        assert 403 == response.status_code\n\n        response = self.client.post(dispatch_url, {}, **headers)\n        assert 403 == response.status_code\n\n    def test_missing_position_handler(self):\n        \"\"\"\n        Test that sending POST request without or invalid position argument don't raise server error\n        \"\"\"\n        self.client.login(username=self.mock_user.username, password=self.TEST_PASSWORD)\n        dispatch_url = self._get_dispatch_url()\n        response = self.client.post(dispatch_url)\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': ''})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': '-1'})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': \"string\"})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': \"\u03a6\u03c5\u03c3\u03b9\u03ba\u03ac\"})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n        response = self.client.post(dispatch_url, {'position': ''})\n        assert 200 == response.status_code\n        assert json.loads(response.content.decode('utf-8')) == {'success': True}\n\n    @ddt.data('pure', 'vertical')\n    @XBlock.register_temp_plugin(PureXBlock, identifier='pure')\n    def test_rebinding_same_user(self, block_type):\n        request = self.request_factory.get('')\n        request.user = self.mock_user\n        course = CourseFactory()\n        block = BlockFactory(category=block_type, parent=course)\n        field_data_cache = FieldDataCache([self.toy_course, block], self.toy_course.id, self.mock_user)\n        # This is verifying that caching doesn't cause an error during get_block_for_descriptor, which\n        # is why it calls the method twice identically.\n        render.get_block_for_descriptor(\n            self.mock_user,\n            request,\n            block,\n            field_data_cache,\n            self.toy_course.id,\n            course=self.toy_course\n        )\n        render.get_block_for_descriptor(\n            self.mock_user,\n            request,\n            block,\n            field_data_cache,\n            self.toy_course.id,\n            course=self.toy_course\n        )\n\n    @override_settings(FIELD_OVERRIDE_PROVIDERS=(\n        'lms.djangoapps.courseware.student_field_overrides.IndividualStudentOverrideProvider',\n    ))\n    @patch('xmodule.modulestore.xml.ImportSystem.applicable_aside_types', lambda self, block: ['test_aside'])\n    @patch('xmodule.modulestore.split_mongo.caching_descriptor_system.CachingDescriptorSystem.applicable_aside_types',\n           lambda self, block: ['test_aside'])\n    @XBlockAside.register_temp_plugin(AsideTestType, 'test_aside')\n    @ddt.data('regular', 'test_aside')\n    def test_rebind_different_users(self, block_category):\n        \"\"\"\n        This tests the rebinding a block to a student does not result\n        in overly nested _field_data.\n        \"\"\"\n        def create_aside(item, block_type):\n            \"\"\"\n            Helper function to create aside\n            \"\"\"\n            key_store = DictKeyValueStore()\n            field_data = KvsFieldData(key_store)\n            runtime = TestRuntime(services={'field-data': field_data})\n\n            def_id = runtime.id_generator.create_definition(block_type)\n            usage_id = AsideUsageKeyV2(runtime.id_generator.create_usage(def_id), \"aside\")\n            aside = AsideTestType(scope_ids=ScopeIds('user', block_type, def_id, usage_id), runtime=runtime)\n            aside.content = '%s_new_value11' % block_type\n            aside.data_field = '%s_new_value12' % block_type\n            aside.has_score = False\n\n            modulestore().update_item(item, self.mock_user.id, asides=[aside])\n            return item\n\n        request = self.request_factory.get('')\n        request.user = self.mock_user\n        course = CourseFactory.create()\n\n        block = BlockFactory(category=\"html\", parent=course)\n        if block_category == 'test_aside':\n            block = create_aside(block, \"test_aside\")\n\n        field_data_cache = FieldDataCache(\n            [course, block], course.id, self.mock_user\n        )\n\n        # grab what _field_data was originally set to\n        original_field_data = block._field_data  # lint-amnesty, pylint: disable=no-member, protected-access\n\n        render.get_block_for_descriptor(\n            self.mock_user, request, block, field_data_cache, course.id, course=course\n        )\n\n        # check that block.runtime.service(block, 'field-data-unbound') is the same as the original\n        # _field_data, but now _field_data as been reset.\n        assert block.runtime.service(block, 'field-data-unbound') is original_field_data\n        assert block.runtime.service(block, 'field-data-unbound') is not block._field_data  # pylint: disable=protected-access, line-too-long\n\n        # now bind this block to a few other students\n        for user in [UserFactory(), UserFactory(), self.mock_user]:\n            render.get_block_for_descriptor(\n                user,\n                request,\n                block,\n                field_data_cache,\n                course.id,\n                course=course\n            )\n\n        # _field_data should now be wrapped by LmsFieldData\n        # pylint: disable=protected-access\n        assert isinstance(block._field_data, LmsFieldData)  # lint-amnesty, pylint: disable=no-member\n\n        # the LmsFieldData should now wrap OverrideFieldData\n        assert isinstance(block._field_data._authored_data._source, OverrideFieldData)   # lint-amnesty, pylint: disable=no-member, line-too-long\n\n        # the OverrideFieldData should point to the date FieldData\n        assert isinstance(block._field_data._authored_data._source.fallback, DateLookupFieldData)    # lint-amnesty, pylint: disable=no-member, line-too-long\n        assert block._field_data._authored_data._source.fallback._defaults \\\n            is block.runtime.service(block, 'field-data-unbound')\n\n    def test_hash_resource(self):\n        \"\"\"\n        Ensure that the resource hasher works and does not fail on unicode,\n        decoded or otherwise.\n        \"\"\"\n        resources = ['ASCII text', '\u2744 I am a special snowflake.', \"\u2744 So am I, but I didn't tell you.\"]\n        assert hash_resource(resources) == '50c2ae79fbce9980e0803848914b0a09'\n\n\n@ddt.ddt\nclass TestHandleXBlockCallback(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test the handle_xblock_callback function\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.toy_course = modulestore().get_course(cls.course_key)\n\n    def setUp(self):\n        super().setUp()\n\n        self.location = self.course_key.make_usage_key('chapter', 'Overview')\n        self.mock_user = UserFactory.create()\n        self.request_factory = RequestFactoryNoCsrf()\n\n        # Construct a mock block for the modulestore to return\n        self.mock_block = MagicMock()\n        self.mock_block.id = 1\n        self.dispatch = 'score_update'\n\n        # Construct a 'standard' xqueue_callback url\n        self.callback_url = reverse(\n            'xqueue_callback', kwargs={\n                'course_id': str(self.course_key),\n                'userid': str(self.mock_user.id),\n                'mod_id': self.mock_block.id,\n                'dispatch': self.dispatch\n            }\n        )\n\n    def _mock_file(self, name='file', size=10):\n        \"\"\"Create a mock file object for testing uploads\"\"\"\n        mock_file = MagicMock(\n            size=size,\n            read=lambda: 'x' * size\n        )\n        # We can't use `name` as a kwarg to Mock to set the name attribute\n        # because mock uses `name` to name the mock itself\n        mock_file.name = name\n        return mock_file\n\n    def make_xblock_callback_response(self, request_data, course, block, handler):\n        \"\"\"\n        Prepares an xblock callback request and returns response to it.\n        \"\"\"\n        request = self.request_factory.post(\n            '/',\n            data=json.dumps(request_data),\n            content_type='application/json',\n        )\n        request.user = self.mock_user\n        response = render.handle_xblock_callback(\n            request,\n            str(course.id),\n            quote_slashes(str(block.scope_ids.usage_id)),\n            handler,\n            '',\n        )\n\n        return response\n\n    def test_invalid_csrf_token(self):\n        \"\"\"\n        Verify that invalid CSRF token is rejected.\n        \"\"\"\n        request = RequestFactory().post('dummy_url', data={'position': 1})\n        csrf_token = get_token(request)\n        request._post = {'csrfmiddlewaretoken': f'{csrf_token}-dummy'}  # pylint: disable=protected-access\n        request.user = self.mock_user\n        request.COOKIES[settings.CSRF_COOKIE_NAME] = csrf_token\n\n        response = render.handle_xblock_callback(\n            request,\n            str(self.course_key),\n            quote_slashes(str(self.location)),\n            'xmodule_handler',\n            'goto_position',\n        )\n        assert 403 == response.status_code\n\n    def test_valid_csrf_token(self):\n        \"\"\"\n        Verify that valid CSRF token is accepted.\n        \"\"\"\n        request = RequestFactory().post('dummy_url', data={'position': 1})\n        csrf_token = get_token(request)\n        request._post = {'csrfmiddlewaretoken': csrf_token}  # pylint: disable=protected-access\n        request.user = self.mock_user\n        request.COOKIES[settings.CSRF_COOKIE_NAME] = csrf_token\n\n        response = render.handle_xblock_callback(\n            request,\n            str(self.course_key),\n            quote_slashes(str(self.location)),\n            'xmodule_handler',\n            'goto_position',\n        )\n        assert 200 == response.status_code\n\n    def test_invalid_location(self):\n        request = self.request_factory.post('dummy_url', data={'position': 1})\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                'invalid Location',\n                'dummy_handler'\n                'dummy_dispatch'\n            )\n\n    def test_too_many_files(self):\n        request = self.request_factory.post(\n            'dummy_url',\n            data={'file_id': (self._mock_file(), ) * (settings.MAX_FILEUPLOADS_PER_INPUT + 1)}\n        )\n        request.user = self.mock_user\n        assert render.handle_xblock_callback(request, str(self.course_key), quote_slashes(str(self.location)), 'dummy_handler').content.decode('utf-8') == json.dumps({'success': (f'Submission aborted! Maximum {settings.MAX_FILEUPLOADS_PER_INPUT:d} files may be submitted at once')}, indent=2)  # pylint: disable=line-too-long\n\n    def test_too_large_file(self):\n        inputfile = self._mock_file(size=1 + settings.STUDENT_FILEUPLOAD_MAX_SIZE)\n        request = self.request_factory.post(\n            'dummy_url',\n            data={'file_id': inputfile}\n        )\n        request.user = self.mock_user\n        assert render.handle_xblock_callback(request, str(self.course_key), quote_slashes(str(self.location)), 'dummy_handler').content.decode('utf-8') == json.dumps({'success': ('Submission aborted! Your file \"%s\" is too large (max size: %d MB)' % (inputfile.name, (settings.STUDENT_FILEUPLOAD_MAX_SIZE / (1000 ** 2))))}, indent=2)  # pylint: disable=line-too-long\n\n    def test_xblock_dispatch(self):\n        request = self.request_factory.post('dummy_url', data={'position': 1})\n        request.user = self.mock_user\n        response = render.handle_xblock_callback(\n            request,\n            str(self.course_key),\n            quote_slashes(str(self.location)),\n            'xmodule_handler',\n            'goto_position',\n        )\n        assert isinstance(response, HttpResponse)\n\n    def test_bad_course_id(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                'bad_course_id',\n                quote_slashes(str(self.location)),\n                'xmodule_handler',\n                'goto_position',\n            )\n\n    def test_bad_location(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                quote_slashes(str(self.course_key.make_usage_key('chapter', 'bad_location'))),\n                'xmodule_handler',\n                'goto_position',\n            )\n\n    def test_bad_xblock_dispatch(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                quote_slashes(str(self.location)),\n                'xmodule_handler',\n                'bad_dispatch',\n            )\n\n    def test_missing_handler(self):\n        request = self.request_factory.post('dummy_url')\n        request.user = self.mock_user\n        with pytest.raises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(self.course_key),\n                quote_slashes(str(self.location)),\n                'bad_handler',\n                'bad_dispatch',\n            )\n\n    @XBlock.register_temp_plugin(GradedStatelessXBlock, identifier='stateless_scorer')\n    def test_score_without_student_state(self):\n        course = CourseFactory.create()\n        block = BlockFactory.create(category='stateless_scorer', parent=course)\n\n        request = self.request_factory.post(\n            'dummy_url',\n            data=json.dumps({\"grade\": 0.75}),\n            content_type='application/json'\n        )\n        request.user = self.mock_user\n\n        response = render.handle_xblock_callback(\n            request,\n            str(course.id),\n            quote_slashes(str(block.scope_ids.usage_id)),\n            'set_score',\n            '',\n        )\n        assert response.status_code == 200\n        student_module = StudentModule.objects.get(\n            student=self.mock_user,\n            module_state_key=block.scope_ids.usage_id,\n        )\n        assert student_module.grade == 0.75\n        assert student_module.max_grade == 1\n\n    @ddt.data(\n        ('complete', {'completion': 0.625}),\n        ('progress', {}),\n    )\n    @ddt.unpack\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_completion_events_with_completion_disabled(self, signal, data):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, False):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n            request = self.request_factory.post(\n                '/',\n                data=json.dumps(data),\n                content_type='application/json',\n            )\n            request.user = self.mock_user\n            with patch('completion.models.BlockCompletionManager.submit_completion') as mock_complete:\n                render.handle_xblock_callback(\n                    request,\n                    str(course.id),\n                    quote_slashes(str(block.scope_ids.usage_id)),\n                    signal,\n                    '',\n                )\n                mock_complete.assert_not_called()\n            assert not BlockCompletion.objects.filter(block_key=block.scope_ids.usage_id).exists()\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_completion_signal_for_completable_xblock(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n\n            response = self.make_xblock_callback_response(\n                {'completion': 0.625}, course, block, 'complete'\n            )\n\n            assert response.status_code == 200\n            completion = BlockCompletion.objects.get(block_key=block.scope_ids.usage_id)\n            assert completion.completion == 0.625\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    @ddt.data((True, True), (False, False),)\n    @ddt.unpack\n    def test_aside(self, is_xblock_aside, is_get_aside_called):\n        \"\"\"\n        test get_aside_from_xblock called\n        \"\"\"\n        course = CourseFactory.create()\n        block = BlockFactory.create(category='comp', parent=course)\n        request = self.request_factory.post(\n            '/',\n            data=json.dumps({'completion': 0.625}),\n            content_type='application/json',\n        )\n        request.user = self.mock_user\n\n        def get_usage_key():\n            \"\"\"return usage key\"\"\"\n            return (\n                quote_slashes(str(AsideUsageKeyV2(block.scope_ids.usage_id, \"aside\")))\n                if is_xblock_aside\n                else str(block.scope_ids.usage_id)\n            )\n\n        with patch(\n            'lms.djangoapps.courseware.block_render.is_xblock_aside',\n            return_value=is_xblock_aside\n        ), patch(\n            'lms.djangoapps.courseware.block_render.get_aside_from_xblock'\n        ) as mocked_get_aside_from_xblock, patch(\n            'lms.djangoapps.courseware.block_render.webob_to_django_response'\n        ) as mocked_webob_to_django_response:\n            render.handle_xblock_callback(\n                request,\n                str(course.id),\n                get_usage_key(),\n                'complete',\n                '',\n            )\n            assert mocked_webob_to_django_response.called is True\n        assert mocked_get_aside_from_xblock.called is is_get_aside_called\n\n    def test_aside_invalid_usage_id(self):\n        \"\"\"\n        test aside work when invalid usage id\n        \"\"\"\n        course = CourseFactory.create()\n        request = self.request_factory.post(\n            '/',\n            data=json.dumps({'completion': 0.625}),\n            content_type='application/json',\n        )\n        request.user = self.mock_user\n\n        with patch(\n            'lms.djangoapps.courseware.block_render.is_xblock_aside',\n            return_value=True\n        ), self.assertRaises(Http404):\n            render.handle_xblock_callback(\n                request,\n                str(course.id),\n                \"foo@bar\",\n                'complete',\n                '',\n            )\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_progress_signal_ignored_for_completable_xblock(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n\n            response = self.make_xblock_callback_response(\n                {}, course, block, 'progress'\n            )\n\n            assert response.status_code == 200\n            assert not BlockCompletion.objects.filter(block_key=block.scope_ids.usage_id).exists()\n\n    @XBlock.register_temp_plugin(XBlockWithoutCompletionAPI, identifier='no_comp')\n    def test_progress_signal_processed_for_xblock_without_completion_api(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='no_comp', parent=course)\n\n            response = self.make_xblock_callback_response(\n                {}, course, block, 'progress'\n            )\n\n            assert response.status_code == 200\n            completion = BlockCompletion.objects.get(block_key=block.scope_ids.usage_id)\n            assert completion.completion == 1.0\n\n    @XBlock.register_temp_plugin(StubCompletableXBlock, identifier='comp')\n    def test_skip_handlers_for_masquerading_staff(self):\n        with override_waffle_switch(ENABLE_COMPLETION_TRACKING_SWITCH, True):\n            course = CourseFactory.create()\n            block = BlockFactory.create(category='comp', parent=course)\n            request = self.request_factory.post(\n                '/',\n                data=json.dumps({'completion': 0.8}),\n                content_type='application/json',\n            )\n            request.user = self.mock_user\n            request.session = {}\n            request.user.real_user = GlobalStaffFactory.create()\n            request.user.real_user.masquerade_settings = CourseMasquerade(course.id, user_name=\"jem\")\n            with patch('xmodule.services.is_masquerading_as_specific_student') as mock_masq:\n                mock_masq.return_value = True\n                response = render.handle_xblock_callback(\n                    request,\n                    str(course.id),\n                    quote_slashes(str(block.scope_ids.usage_id)),\n                    'complete',\n                    '',\n                )\n            mock_masq.assert_called()\n        assert response.status_code == 200\n        with pytest.raises(BlockCompletion.DoesNotExist):\n            BlockCompletion.objects.get(block_key=block.scope_ids.usage_id)\n\n    @XBlock.register_temp_plugin(GradedStatelessXBlock, identifier='stateless_scorer')\n    @patch('xmodule.services.grades_signals.SCORE_PUBLISHED.send')\n    def test_anonymous_user_not_be_graded(self, mock_score_signal):\n        course = CourseFactory.create()\n        block_kwargs = {\n            'category': 'problem',\n        }\n        request = self.request_factory.get('/')\n        request.user = AnonymousUser()\n        block = BlockFactory.create(**block_kwargs)\n\n        render.handle_xblock_callback(\n            request,\n            str(course.id),\n            quote_slashes(str(block.location)),\n            'xmodule_handler',\n            'problem_check',\n        )\n        assert not mock_score_signal.called\n\n    @ddt.data(\n        # See seq_block.py for the definition of these handlers\n        ('get_completion', True),  # has the 'will_recheck_access' attribute set to True\n        ('goto_position', False),  # does not set it\n    )\n    @ddt.unpack\n    @patch('lms.djangoapps.courseware.block_render.get_block_for_descriptor', wraps=get_block_for_descriptor)\n    def test_will_recheck_access_handler_attribute(self, handler, will_recheck_access, mock_get_block):\n        \"\"\"Confirm that we pay attention to any 'will_recheck_access' attributes on handler methods\"\"\"\n        course = CourseFactory.create()\n        block_kwargs = {\n            'category': 'sequential',\n            'parent': course,\n        }\n        block = BlockFactory.create(**block_kwargs)\n        usage_id = str(block.location)\n\n        # Send no special parameters, which will be invalid, but we don't care\n        request = self.request_factory.post('/', data='{}', content_type='application/json')\n        request.user = self.mock_user\n\n        render.handle_xblock_callback(request, str(course.id), usage_id, handler)\n        assert mock_get_block.call_count == 2\n        assert mock_get_block.call_args[1]['will_recheck_access'] == will_recheck_access\n\n\n@ddt.ddt\n@patch.dict('django.conf.settings.FEATURES', {'ENABLE_XBLOCK_VIEW_ENDPOINT': True})\nclass TestXBlockView(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test the handle_xblock_callback function\n    \"\"\"\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.toy_course = modulestore().get_course(cls.course_key)\n\n    def setUp(self):\n        super().setUp()\n\n        self.location = str(self.course_key.make_usage_key('html', 'toyhtml'))\n        self.request_factory = RequestFactory()\n\n        self.view_args = [str(self.course_key), quote_slashes(self.location), 'student_view']\n        self.xblock_view_url = reverse('xblock_view', args=self.view_args)\n\n    def test_xblock_view_handler(self):\n        request = self.request_factory.get(self.xblock_view_url)\n        request.user = UserFactory.create()\n        response = render.xblock_view(request, *self.view_args)\n        assert 200 == response.status_code\n\n        expected = ['csrf_token', 'html', 'resources']\n        content = json.loads(response.content.decode('utf-8'))\n        for section in expected:\n            assert section in content\n        doc = PyQuery(content['html'])\n        assert len(doc('div.xblock-student_view-html')) == 1\n\n    @ddt.data(True, False)\n    def test_hide_staff_markup(self, hide):\n        \"\"\"\n        When xblock_view gets 'hide_staff_markup' in its context, the staff markup\n        should not be included. See 'add_staff_markup' in xblock_utils/__init__.py\n        \"\"\"\n        request = self.request_factory.get(self.xblock_view_url)\n        request.user = GlobalStaffFactory.create()\n        request.session = {}\n        if hide:\n            request.GET = {'hide_staff_markup': 'true'}\n        response = render.xblock_view(request, *self.view_args)\n        assert 200 == response.status_code\n\n        html = json.loads(response.content.decode('utf-8'))['html']\n        assert ('Staff Debug Info' in html) == (not hide)\n\n    def test_xblock_view_handler_not_authenticated(self):\n        request = self.request_factory.get(self.xblock_view_url)\n        request.user = AnonymousUser()\n        response = render.xblock_view(request, *self.view_args)\n        assert 401 == response.status_code\n\n\n@ddt.ddt\nclass TestTOC(ModuleStoreTestCase):\n    \"\"\"Check the Table of Contents for a course\"\"\"\n\n    def setup_request_and_course(self, num_finds, num_sends):\n        \"\"\"\n        Sets up the toy course in the modulestore and the request object.\n        \"\"\"\n        self.course_key = ToyCourseFactory.create().id  # pylint: disable=attribute-defined-outside-init\n        self.chapter = 'Overview'  # lint-amnesty, pylint: disable=attribute-defined-outside-init\n        chapter_url = '{}/{}/{}'.format('/courses', self.course_key, self.chapter)\n        factory = RequestFactoryNoCsrf()\n        self.request = factory.get(chapter_url)  # lint-amnesty, pylint: disable=attribute-defined-outside-init\n        self.request.user = UserFactory()\n        self.modulestore = self.store._get_modulestore_for_courselike(self.course_key)  # pylint: disable=protected-access, attribute-defined-outside-init\n        with self.modulestore.bulk_operations(self.course_key):\n            with check_mongo_calls(num_finds, num_sends):\n                self.toy_course = self.store.get_course(self.course_key, depth=2)  # pylint: disable=attribute-defined-outside-init\n                self.field_data_cache = FieldDataCache.cache_for_block_descendents(  # lint-amnesty, pylint: disable=attribute-defined-outside-init\n                    self.course_key, self.request.user, self.toy_course, depth=2\n                )\n\n    # Split makes 2 queries to load the course to depth 2:\n    #     - 1 for the structure\n    #     - 1 for 5 definitions\n    # Split makes 1 MySQL query to render the toc:\n    #     - 1 MySQL for the active version at the start of the bulk operation (no mongo calls)\n    def test_toc_toy_from_chapter(self):\n        with self.store.default_store(ModuleStoreEnum.Type.split):\n            self.setup_request_and_course(2, 0)\n\n            expected = ([{'active': True, 'sections':\n                          [{'url_name': 'Toy_Videos', 'display_name': 'Toy Videos', 'graded': True,\n                            'format': 'Lecture Sequence', 'due': None, 'active': False},\n                           {'url_name': 'Welcome', 'display_name': 'Welcome', 'graded': True,\n                            'format': '', 'due': None, 'active': False},\n                           {'url_name': 'video_123456789012', 'display_name': 'Test Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False},\n                           {'url_name': 'video_4f66f493ac8f', 'display_name': 'Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'Overview', 'display_name': 'Overview', 'display_id': 'overview'},\n                         {'active': False, 'sections':\n                          [{'url_name': 'toyvideo', 'display_name': 'toyvideo', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'secret:magic', 'display_name': 'secret:magic', 'display_id': 'secretmagic'}])\n\n            course = self.store.get_course(self.toy_course.id, depth=2)\n            with check_mongo_calls(0):\n                actual = render.toc_for_course(\n                    self.request.user, self.request, course, self.chapter, None, self.field_data_cache\n                )\n        for toc_section in expected:\n            assert toc_section in actual['chapters']\n        assert actual['previous_of_active_section'] is None\n        assert actual['next_of_active_section'] is None\n\n    # Split makes 2 queries to load the course to depth 2:\n    #     - 1 for the structure\n    #     - 1 for 5 definitions\n    # Split makes 1 MySQL query to render the toc:\n    #     - 1 MySQL for the active version at the start of the bulk operation (no mongo calls)\n    def test_toc_toy_from_section(self):\n        with self.store.default_store(ModuleStoreEnum.Type.split):\n            self.setup_request_and_course(2, 0)\n            section = 'Welcome'\n            expected = ([{'active': True, 'sections':\n                          [{'url_name': 'Toy_Videos', 'display_name': 'Toy Videos', 'graded': True,\n                            'format': 'Lecture Sequence', 'due': None, 'active': False},\n                           {'url_name': 'Welcome', 'display_name': 'Welcome', 'graded': True,\n                            'format': '', 'due': None, 'active': True},\n                           {'url_name': 'video_123456789012', 'display_name': 'Test Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False},\n                           {'url_name': 'video_4f66f493ac8f', 'display_name': 'Video', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'Overview', 'display_name': 'Overview', 'display_id': 'overview'},\n                         {'active': False, 'sections':\n                          [{'url_name': 'toyvideo', 'display_name': 'toyvideo', 'graded': True,\n                            'format': '', 'due': None, 'active': False}],\n                          'url_name': 'secret:magic', 'display_name': 'secret:magic', 'display_id': 'secretmagic'}])\n\n            with check_mongo_calls(0):\n                actual = render.toc_for_course(\n                    self.request.user, self.request, self.toy_course, self.chapter, section, self.field_data_cache\n                )\n            for toc_section in expected:\n                assert toc_section in actual['chapters']\n            assert actual['previous_of_active_section']['url_name'] == 'Toy_Videos'\n            assert actual['next_of_active_section']['url_name'] == 'video_123456789012'\n\n\n@ddt.ddt\n@patch.dict('django.conf.settings.FEATURES', {'ENABLE_SPECIAL_EXAMS': True})\nclass TestProctoringRendering(ModuleStoreTestCase):\n    \"\"\"Check the Table of Contents for a course\"\"\"\n    def setUp(self):\n        \"\"\"\n        Set up the initial mongo datastores\n        \"\"\"\n        super().setUp()\n        self.course_key = ToyCourseFactory.create(enable_proctored_exams=True).id\n        self.chapter = 'Overview'\n        chapter_url = '{}/{}/{}'.format('/courses', self.course_key, self.chapter)\n        factory = RequestFactoryNoCsrf()\n        self.request = factory.get(chapter_url)\n        self.request.user = UserFactory.create()\n        self.user = UserFactory.create()\n        SoftwareSecurePhotoVerificationFactory.create(user=self.request.user)\n        self.modulestore = self.store._get_modulestore_for_courselike(self.course_key)  # pylint: disable=protected-access\n        with self.modulestore.bulk_operations(self.course_key):\n            self.toy_course = self.store.get_course(self.course_key, depth=2)\n            self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n                self.course_key, self.request.user, self.toy_course, depth=2\n            )\n\n    @ddt.data(\n        (CourseMode.DEFAULT_MODE_SLUG, False, None, None),\n        (\n            CourseMode.DEFAULT_MODE_SLUG,\n            True,\n            'eligible',\n            {\n                'status': 'eligible',\n                'short_description': 'Ungraded Practice Exam',\n                'suggested_icon': '',\n                'in_completed_state': False\n            }\n        ),\n        (\n            CourseMode.DEFAULT_MODE_SLUG,\n            True,\n            'submitted',\n            {\n                'status': 'submitted',\n                'short_description': 'Practice Exam Completed',\n                'suggested_icon': 'fa-check',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.DEFAULT_MODE_SLUG,\n            True,\n            'error',\n            {\n                'status': 'error',\n                'short_description': 'Practice Exam Failed',\n                'suggested_icon': 'fa-exclamation-triangle',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            None,\n            {\n                'status': 'eligible',\n                'short_description': 'Proctored Option Available',\n                'suggested_icon': 'fa-pencil-square-o',\n                'in_completed_state': False\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'declined',\n            {\n                'status': 'declined',\n                'short_description': 'Taking As Open Exam',\n                'suggested_icon': 'fa-pencil-square-o',\n                'in_completed_state': False\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'submitted',\n            {\n                'status': 'submitted',\n                'short_description': 'Pending Session Review',\n                'suggested_icon': 'fa-spinner fa-spin',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'verified',\n            {\n                'status': 'verified',\n                'short_description': 'Passed Proctoring',\n                'suggested_icon': 'fa-check',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'rejected',\n            {\n                'status': 'rejected',\n                'short_description': 'Failed Proctoring',\n                'suggested_icon': 'fa-exclamation-triangle',\n                'in_completed_state': True\n            }\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'error',\n            {\n                'status': 'error',\n                'short_description': 'Failed Proctoring',\n                'suggested_icon': 'fa-exclamation-triangle',\n                'in_completed_state': True\n            }\n        ),\n    )\n    @ddt.unpack\n    def test_proctored_exam_toc(self, enrollment_mode, is_practice_exam,\n                                attempt_status, expected):\n        \"\"\"\n        Generate TOC for a course with a single chapter/sequence which contains proctored exam\n        \"\"\"\n        self._setup_test_data(enrollment_mode, is_practice_exam, attempt_status)\n\n        actual = render.toc_for_course(\n            self.request.user,\n            self.request,\n            self.toy_course,\n            self.chapter,\n            'Toy_Videos',\n            self.field_data_cache\n        )\n        section_actual = self._find_section(actual['chapters'], 'Overview', 'Toy_Videos')\n\n        if expected:\n            assert expected in [section_actual['proctoring']]\n        else:\n            # we expect there not to be a 'proctoring' key in the dict\n            assert 'proctoring' not in section_actual\n        assert actual['previous_of_active_section'] is None\n        assert actual['next_of_active_section']['url_name'] == 'Welcome'\n\n    @ddt.data(\n        (\n            CourseMode.VERIFIED,\n            False,\n            None,\n            'This exam is proctored',\n            False\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'submitted',\n            'You have submitted this proctored exam for review',\n            True\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'verified',\n            'Your proctoring session was reviewed successfully',\n            False\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'rejected',\n            'Your proctoring session was reviewed, but did not pass all requirements',\n            True\n        ),\n        (\n            CourseMode.VERIFIED,\n            False,\n            'error',\n            'A system error has occurred with your proctored exam',\n            False\n        ),\n    )\n    @ddt.unpack\n    def test_render_proctored_exam(self, enrollment_mode, is_practice_exam,\n                                   attempt_status, expected, with_credit_context):\n        \"\"\"\n        Verifies gated content from the student view rendering of a sequence\n        this is labeled as a proctored exam\n        \"\"\"\n        usage_key = self._setup_test_data(enrollment_mode, is_practice_exam, attempt_status)\n\n        # initialize some credit requirements, if so then specify\n        if with_credit_context:\n            credit_course = CreditCourse(course_key=self.course_key, enabled=True)\n            credit_course.save()\n            set_credit_requirements(\n                self.course_key,\n                [\n                    {\n                        'namespace': 'reverification',\n                        'name': 'reverification-1',\n                        'display_name': 'ICRV1',\n                        'criteria': {},\n                    },\n                    {\n                        'namespace': 'proctored-exam',\n                        'name': 'Exam1',\n                        'display_name': 'A Proctored Exam',\n                        'criteria': {}\n                    }\n                ]\n            )\n\n            set_credit_requirement_status(\n                self.request.user,\n                self.course_key,\n                'reverification',\n                'ICRV1'\n            )\n\n        block = render.get_block(\n            self.request.user,\n            self.request,\n            usage_key,\n            self.field_data_cache,\n            wrap_xblock_display=True,\n        )\n        content = block.render(STUDENT_VIEW).content\n\n        assert expected in content\n\n    def _setup_test_data(self, enrollment_mode, is_practice_exam, attempt_status):\n        \"\"\"\n        Helper method to consolidate some courseware/proctoring/credit\n        test harness data\n        \"\"\"\n        usage_key = self.course_key.make_usage_key('sequential', 'Toy_Videos')\n\n        with self.modulestore.bulk_operations(self.toy_course.id):\n            sequence = self.modulestore.get_item(usage_key)\n            sequence.is_time_limited = True\n            sequence.is_proctored_exam = True\n            sequence.is_practice_exam = is_practice_exam\n            self.modulestore.update_item(sequence, self.user.id)\n\n        self.toy_course = self.update_course(self.toy_course, self.user.id)\n\n        # refresh cache after update\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course_key, self.request.user, self.toy_course, depth=2\n        )\n\n        set_runtime_service(\n            'credit',\n            MockCreditService(enrollment_mode=enrollment_mode)\n        )\n        CourseEnrollment.enroll(self.request.user, self.course_key, mode=enrollment_mode)\n\n        set_runtime_service(\n            'grades',\n            MockGradesService()\n        )\n\n        set_runtime_service(\n            'certificates',\n            MockCertificateService()\n        )\n\n        exam_id = create_exam(\n            course_id=str(self.course_key),\n            content_id=str(sequence.location.replace(branch=None, version=None)),\n            exam_name='foo',\n            time_limit_mins=10,\n            is_proctored=True,\n            is_practice_exam=is_practice_exam\n        )\n\n        if attempt_status:\n            attempt_id = create_exam_attempt(\n                str(exam_id).encode('utf-8'),\n                self.request.user.id,\n                taking_as_proctored=True\n            )\n            update_attempt_status(attempt_id, attempt_status)\n\n        return usage_key\n\n    def _find_url_name(self, toc, url_name):\n        \"\"\"\n        Helper to return the dict TOC section associated with a Chapter of url_name\n        \"\"\"\n\n        for entry in toc:\n            if entry['url_name'] == url_name:\n                return entry\n\n        return None\n\n    def _find_section(self, toc, chapter_url_name, section_url_name):\n        \"\"\"\n        Helper to return the dict TOC section associated with a section of url_name\n        \"\"\"\n\n        chapter = self._find_url_name(toc, chapter_url_name)\n        if chapter:\n            return self._find_url_name(chapter['sections'], section_url_name)\n\n        return None\n\n\nclass TestGatedSubsectionRendering(ModuleStoreTestCase, MilestonesTestCaseMixin):\n    \"\"\"\n    Test the toc for a course is rendered correctly when there is gated content\n    \"\"\"\n    def setUp(self):\n        \"\"\"\n        Set up the initial test data\n        \"\"\"\n        super().setUp()\n\n        self.course = CourseFactory.create(enable_subsection_gating=True)\n        self.chapter = BlockFactory.create(\n            parent=self.course,\n            category=\"chapter\",\n            display_name=\"Chapter\"\n        )\n        self.open_seq = BlockFactory.create(\n            parent=self.chapter,\n            category='sequential',\n            display_name=\"Open Sequential\"\n        )\n        self.gated_seq = BlockFactory.create(\n            parent=self.chapter,\n            category='sequential',\n            display_name=\"Gated Sequential\"\n        )\n        self.course = self.update_course(self.course, 0)\n\n        self.request = RequestFactoryNoCsrf().get(f'/courses/{self.course.id}/{self.chapter.display_name}')\n        self.request.user = UserFactory()\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id, self.request.user, self.course, depth=2\n        )\n        gating_api.add_prerequisite(self.course.id, self.open_seq.location)\n        gating_api.set_required_content(self.course.id, self.gated_seq.location, self.open_seq.location, 100)\n\n    def _find_url_name(self, toc, url_name):\n        \"\"\"\n        Helper to return the TOC section associated with url_name\n        \"\"\"\n\n        for entry in toc:\n            if entry['url_name'] == url_name:\n                return entry\n\n        return None\n\n    def _find_sequential(self, toc, chapter_url_name, sequential_url_name):\n        \"\"\"\n        Helper to return the sequential associated with sequential_url_name\n        \"\"\"\n\n        chapter = self._find_url_name(toc, chapter_url_name)\n        if chapter:\n            return self._find_url_name(chapter['sections'], sequential_url_name)\n\n        return None\n\n    def test_toc_with_gated_sequential(self):\n        \"\"\"\n        Test generation of TOC for a course with a gated subsection\n        \"\"\"\n        actual = render.toc_for_course(\n            self.request.user,\n            self.request,\n            self.course,\n            self.chapter.display_name,\n            self.open_seq.display_name,\n            self.field_data_cache\n        )\n        assert self._find_sequential(actual['chapters'], 'Chapter', 'Open_Sequential') is not None\n        assert self._find_sequential(actual['chapters'], 'Chapter', 'Gated_Sequential') is not None\n        assert self._find_sequential(actual['chapters'], 'Non-existent_Chapter', 'Non-existent_Sequential') is None\n        assert actual['previous_of_active_section'] is None\n        assert actual['next_of_active_section'] is None\n\n\n@ddt.ddt\nclass TestHtmlModifiers(ModuleStoreTestCase):\n    \"\"\"\n    Tests to verify that standard modifications to the output of XModule/XBlock\n    student_view are taking place\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.course = CourseFactory.create()\n        self.request = RequestFactoryNoCsrf().get('/')\n        self.request.user = self.user\n        self.request.session = {}\n        self.content_string = '<p>This is the content<p>'\n        self.rewrite_link = '<a href=\"/static/foo/content\">Test rewrite</a>'\n        self.rewrite_bad_link = '<img src=\"/static//file.jpg\" />'\n        self.course_link = '<a href=\"/course/bar/content\">Test course rewrite</a>'\n        self.block = BlockFactory.create(\n            category='html',\n            data=self.content_string + self.rewrite_link + self.rewrite_bad_link + self.course_link\n        )\n        self.location = self.block.location\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            self.block\n        )\n\n    def test_xblock_display_wrapper_enabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n            wrap_xblock_display=True,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        assert len(PyQuery(result_fragment.content)('div.xblock.xblock-student_view.xmodule_HtmlBlock')) == 1\n\n    def test_xmodule_display_wrapper_disabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n            wrap_xblock_display=False,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        assert 'div class=\"xblock xblock-student_view xmodule_display xmodule_HtmlBlock\"' not in result_fragment.content\n\n    def test_static_link_rewrite(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        key = self.course.location\n        assert f'/asset-v1:{key.org}+{key.course}+{key.run}+type@asset+block/foo_content' in result_fragment.content\n\n    def test_static_badlink_rewrite(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        key = self.course.location\n        assert f'/asset-v1:{key.org}+{key.course}+{key.run}+type@asset+block/file.jpg' in result_fragment.content\n\n    def test_static_asset_path_use(self):\n        '''\n        when a course is loaded with do_import_static=False (see xml_importer.py), then\n        static_asset_path is set as an lms kv in course.  That should make static paths\n        not be mangled (ie not changed to c4x://).\n        '''\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n            static_asset_path=\"toy_course_dir\",\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'href=\"/static/toy_course_dir' in result_fragment.content\n\n    def test_course_image(self):\n        url = course_image_url(self.course)\n        assert url.startswith('/asset-v1:')\n\n        self.course.static_asset_path = \"toy_course_dir\"\n        url = course_image_url(self.course)\n        assert url.startswith('/static/toy_course_dir/')\n        self.course.static_asset_path = \"\"\n\n    @override_settings(DEFAULT_COURSE_ABOUT_IMAGE_URL='test.png')\n    def test_course_image_for_split_course(self):\n        \"\"\"\n        for split courses if course_image is empty then course_image_url will be\n        the default image url defined in settings\n        \"\"\"\n        self.course = CourseFactory.create()\n        self.course.course_image = ''\n\n        url = course_image_url(self.course)\n        assert '/static/test.png' == url\n\n    def test_get_course_info_section(self):\n        self.course.static_asset_path = \"toy_course_dir\"\n        get_course_info_section(self.request, self.request.user, self.course, \"handouts\")\n        # NOTE: check handouts output...right now test course seems to have no such content\n        # at least this makes sure get_course_info_section returns without exception\n\n    def test_course_link_rewrite(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n\n        assert f'/courses/{str(self.course.id)}/bar/content' in result_fragment.content\n\n\nclass XBlockWithJsonInitData(XBlock):\n    \"\"\"\n    Pure XBlock to use in tests, with JSON init data.\n    \"\"\"\n    the_json_data = None\n\n    def student_view(self, context=None):       # pylint: disable=unused-argument\n        \"\"\"\n        A simple view that returns just enough to test.\n        \"\"\"\n        frag = Fragment(\"Hello there!\")\n        frag.add_javascript('alert(\"Hi!\");')\n        frag.initialize_js('ThumbsBlock', self.the_json_data)\n        return frag\n\n\n@ddt.ddt\nclass JsonInitDataTest(ModuleStoreTestCase):\n    \"\"\"Tests for JSON data injected into the JS init function.\"\"\"\n\n    @ddt.data(\n        ({'a': 17}, '''{\"a\": 17}'''),\n        ({'xss': '</script>alert(\"XSS\")'}, r'''{\"xss\": \"\\u003c/script\\u003ealert(\\\"XSS\\\")\"}'''),\n    )\n    @ddt.unpack\n    @XBlock.register_temp_plugin(XBlockWithJsonInitData, identifier='withjson')\n    def test_json_init_data(self, json_data, json_output):\n        XBlockWithJsonInitData.the_json_data = json_data\n        mock_user = UserFactory()\n        mock_request = MagicMock()\n        mock_request.user = mock_user\n        course = CourseFactory()\n        block = BlockFactory(category='withjson', parent=course)\n        field_data_cache = FieldDataCache([course, block], course.id, mock_user)\n        block = render.get_block_for_descriptor(\n            mock_user,\n            mock_request,\n            block,\n            field_data_cache,\n            course.id,\n            course=course\n        )\n        html = block.render(STUDENT_VIEW).content\n        assert json_output in html\n        # No matter what data goes in, there should only be one close-script tag.\n        assert html.count('</script>') == 1\n\n\n@XBlock.tag(\"detached\")\nclass DetachedXBlock(XBlock):\n    \"\"\"\n    XBlock marked with the 'detached' flag.\n    \"\"\"\n\n    def student_view(self, context=None):  # pylint: disable=unused-argument\n        \"\"\"\n        A simple view that returns just enough to test.\n        \"\"\"\n        frag = Fragment(\"Hello there!\")\n        return frag\n\n\n@patch.dict('django.conf.settings.FEATURES', {'DISPLAY_DEBUG_INFO_TO_STAFF': True, 'DISPLAY_HISTOGRAMS_TO_STAFF': True})\n@patch('lms.djangoapps.courseware.block_render.has_access', Mock(return_value=True, autospec=True))\nclass TestStaffDebugInfo(SharedModuleStoreTestCase):\n    \"\"\"Tests to verify that Staff Debug Info panel and histograms are displayed to staff.\"\"\"\n    MODULESTORE = TEST_DATA_SPLIT_MODULESTORE\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super().setUp()\n        self.user = UserFactory.create()\n        self.request = RequestFactoryNoCsrf().get('/')\n        self.request.user = self.user\n        self.request.session = {}\n\n        problem_xml = OptionResponseXMLFactory().build_xml(\n            question_text='The correct answer is Correct',\n            num_inputs=2,\n            weight=2,\n            options=['Correct', 'Incorrect'],\n            correct_option='Correct'\n        )\n        self.block = BlockFactory.create(\n            category='problem',\n            data=problem_xml,\n            display_name='Option Response Problem'\n        )\n\n        self.location = self.block.location\n        self.field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            self.block\n        )\n\n    @patch.dict('django.conf.settings.FEATURES', {'DISPLAY_DEBUG_INFO_TO_STAFF': False})\n    def test_staff_debug_info_disabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'Staff Debug' not in result_fragment.content\n\n    def test_staff_debug_info_enabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'Staff Debug' in result_fragment.content\n\n    def test_staff_debug_info_score_for_invalid_dropdown(self):\n        \"\"\"\n        Verifies that for an invalid drop down problem, the max score is set\n        to zero in the html.\n        \"\"\"\n        problem_xml = \"\"\"\n        <problem>\n            <optionresponse>\n              <p>You can use this template as a guide to the simple editor markdown and OLX markup to use for dropdown problems. Edit this component to replace this template with your own assessment.</p>\n            <label>Add the question text, or prompt, here. This text is required.</label>\n            <description>You can add an optional tip or note related to the prompt like this. </description>\n            <optioninput>\n                <option correct=\"False\">an incorrect answer</option>\n                <option correct=\"True\">the correct answer</option>\n                <option correct=\"True\">an incorrect answer</option>\n              </optioninput>\n            </optionresponse>\n        </problem>\n        \"\"\"\n        problem_block = BlockFactory.create(\n            category='problem',\n            data=problem_xml\n        )\n        block = render.get_block(\n            self.user,\n            self.request,\n            problem_block.location,\n            self.field_data_cache\n        )\n        html_fragment = block.render(STUDENT_VIEW)\n        expected_score_override_html = textwrap.dedent(\"\"\"<div>\n        <label for=\"sd_fs_{block_id}\">Score (for override only):</label>\n        <input type=\"text\" tabindex=\"0\" id=\"sd_fs_{block_id}\" placeholder=\"0\"/>\n        <label for=\"sd_fs_{block_id}\"> / 0</label>\n      </div>\"\"\")\n\n        assert expected_score_override_html.format(block_id=problem_block.location.block_id) in\\\n               html_fragment.content\n\n    @XBlock.register_temp_plugin(DetachedXBlock, identifier='detached-block')\n    def test_staff_debug_info_disabled_for_detached_blocks(self):\n        \"\"\"Staff markup should not be present on detached blocks.\"\"\"\n\n        detached_block = BlockFactory.create(\n            category='detached-block',\n            display_name='Detached Block'\n        )\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            detached_block\n        )\n        block = render.get_block(\n            self.user,\n            self.request,\n            detached_block.location,\n            field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'Staff Debug' not in result_fragment.content\n\n    @patch.dict('django.conf.settings.FEATURES', {'DISPLAY_HISTOGRAMS_TO_STAFF': False})\n    def test_histogram_disabled(self):\n        block = render.get_block(\n            self.user,\n            self.request,\n            self.location,\n            self.field_data_cache,\n        )\n        result_fragment = block.render(STUDENT_VIEW)\n        assert 'histrogram' not in result_fragment.content\n\n    def test_histogram_enabled_for_unscored_xblocks(self):\n        \"\"\"Histograms should not display for xblocks which are not scored.\"\"\"\n\n        html_block = BlockFactory.create(\n            category='html',\n            data='Here are some course details.'\n        )\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id,\n            self.user,\n            self.block\n        )\n        with patch('openedx.core.lib.xblock_utils.grade_histogram') as mock_grade_histogram:\n            mock_grade_histogram.return_value = []\n            block = render.get_block(\n                self.user,\n                self.request,\n                html_block.location,\n                field_data_cache,\n            )\n            block.render(STUDENT_VIEW)\n            assert not mock_grade_histogram.called\n\n    def test_histogram_enabled_for_scored_xblocks(self):\n        \"\"\"Histograms should display for xblocks which are scored.\"\"\"\n\n        StudentModuleFactory.create(\n            course_id=self.course.id,\n            module_state_key=self.location,\n            student=UserFactory(),\n            grade=1,\n            max_grade=1,\n            state=\"{}\",\n        )\n        with patch('openedx.core.lib.xblock_utils.grade_histogram') as mock_grade_histogram:\n            mock_grade_histogram.return_value = []\n            block = render.get_block(\n                self.user,\n                self.request,\n                self.location,\n                self.field_data_cache,\n            )\n            block.render(STUDENT_VIEW)\n            assert mock_grade_histogram.called\n\n\nPER_COURSE_ANONYMIZED_XBLOCKS = (\n    LTIBlock,\n    VideoBlock,\n)\nPER_STUDENT_ANONYMIZED_XBLOCKS = [\n    AboutBlock,\n    CourseInfoBlock,\n    HtmlBlock,\n    ProblemBlock,\n    StaticTabBlock,\n]\n\n\n@ddt.ddt\nclass TestAnonymousStudentId(SharedModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Test that anonymous_student_id is set correctly across a variety of XBlock types\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course_key = ToyCourseFactory.create().id\n        cls.course = modulestore().get_course(cls.course_key)\n\n    def setUp(self):\n        super().setUp()\n        self.user = UserFactory()\n\n    @patch('lms.djangoapps.courseware.block_render.has_access', Mock(return_value=True, autospec=True))\n    def _get_anonymous_id(self, course_id, xblock_class, should_get_deprecated_id: bool):  # lint-amnesty, pylint: disable=missing-function-docstring\n        location = course_id.make_usage_key('dummy_category', 'dummy_name')\n        block = Mock(\n            spec=xblock_class,\n            _field_data=Mock(spec=FieldData, name='field_data'),\n            location=location,\n            static_asset_path=None,\n            _runtime=Mock(\n                spec=DescriptorSystem,\n                resources_fs=None,\n                mixologist=Mock(_mixins=(), name='mixologist'),\n                _services={},\n                name='runtime',\n            ),\n            scope_ids=Mock(spec=ScopeIds),\n            name='block',\n            _field_data_cache={},\n            _dirty_fields={},\n            fields={},\n            days_early_for_beta=None,\n        )\n        block.runtime = DescriptorSystem(None, None, None)\n        # Use the xblock_class's bind_for_student method\n        block.bind_for_student = partial(xblock_class.bind_for_student, block)\n\n        if hasattr(xblock_class, 'module_class'):\n            block.module_class = xblock_class.module_class\n\n        rendered_block = render.get_block_for_descriptor(\n            user=self.user,\n            block=block,\n            student_data=Mock(spec=FieldData, name='student_data'),\n            course_key=course_id,\n            track_function=Mock(name='track_function'),  # Track Function\n            request_token='request_token',\n            course=self.course,\n            request=None,\n            field_data_cache=None,\n        )\n        current_user = rendered_block.runtime.service(rendered_block, 'user').get_current_user()\n\n        if should_get_deprecated_id:\n            return current_user.opt_attrs.get(ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID)\n        return current_user.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID)\n\n    @ddt.data(*PER_STUDENT_ANONYMIZED_XBLOCKS)\n    def test_per_student_anonymized_id(self, block_class):\n        for course_id in ('MITx/6.00x/2012_Fall', 'MITx/6.00x/2013_Spring'):\n            assert 'de619ab51c7f4e9c7216b4644c24f3b5' == \\\n                   self._get_anonymous_id(CourseKey.from_string(course_id), block_class, True)\n\n    @ddt.data(*PER_COURSE_ANONYMIZED_XBLOCKS)\n    def test_per_course_anonymized_id(self, xblock_class):\n        assert '0c706d119cad686d28067412b9178454' == \\\n               self._get_anonymous_id(CourseKey.from_string('MITx/6.00x/2012_Fall'), xblock_class, False)\n\n        assert 'e9969c28c12c8efa6e987d6dbeedeb0b' == \\\n               self._get_anonymous_id(CourseKey.from_string('MITx/6.00x/2013_Spring'), xblock_class, False)\n\n\n@patch('common.djangoapps.track.views.eventtracker', autospec=True)\nclass TestModuleTrackingContext(SharedModuleStoreTestCase):\n    \"\"\"\n    Ensure correct tracking information is included in events emitted during XBlock callback handling.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.course = CourseFactory.create()\n\n    def setUp(self):\n        super().setUp()\n\n        self.user = UserFactory.create()\n        self.request = RequestFactoryNoCsrf().get('/')\n        self.request.user = self.user\n        self.request.session = {}\n        self.course = CourseFactory.create()\n\n        self.problem_xml = OptionResponseXMLFactory().build_xml(\n            question_text='The correct answer is Correct',\n            num_inputs=2,\n            weight=2,\n            options=['Correct', 'Incorrect'],\n            correct_option='Correct'\n        )\n\n    def test_context_contains_display_name(self, mock_tracker):\n        problem_display_name = 'Option Response Problem'\n        block_info = self.handle_callback_and_get_block_info(mock_tracker, problem_display_name)\n        assert problem_display_name == block_info['display_name']\n\n    @XBlockAside.register_temp_plugin(AsideTestType, 'test_aside')\n    @patch('xmodule.modulestore.mongo.base.CachingDescriptorSystem.applicable_aside_types',\n           lambda self, block: ['test_aside'])\n    @patch('xmodule.x_module.DescriptorSystem.applicable_aside_types',\n           lambda self, block: ['test_aside'])\n    def test_context_contains_aside_info(self, mock_tracker):\n        \"\"\"\n        Check that related xblock asides populate information in the 'problem_check' event in case\n        the 'get_event_context' method is exist\n        \"\"\"\n        problem_display_name = 'Test Problem'\n\n        def get_event_context(self, event_type, event):  # pylint: disable=unused-argument\n            \"\"\"\n            This method return data that should be associated with the \"check_problem\" event\n            \"\"\"\n            return {'content': 'test1', 'data_field': 'test2'}\n\n        AsideTestType.get_event_context = get_event_context\n\n        # for different operations, there are different number of context calls.\n        # We are sending this `call_idx` to get the mock call that we are interested in.\n        context_info = self.handle_callback_and_get_context_info(mock_tracker, problem_display_name, call_idx=4)\n\n        assert 'asides' in context_info\n        assert 'test_aside' in context_info['asides']\n        assert 'content' in context_info['asides']['test_aside']\n        assert context_info['asides']['test_aside']['content'] == 'test1'\n        assert 'data_field' in context_info['asides']['test_aside']\n        assert context_info['asides']['test_aside']['data_field'] == 'test2'\n\n    def handle_callback_and_get_context_info(self,\n                                             mock_tracker,\n                                             problem_display_name=None,\n                                             call_idx=0):\n        \"\"\"\n        Creates a fake block, invokes the callback and extracts the 'context'\n        metadata from the emitted problem_check event.\n        \"\"\"\n\n        block_kwargs = {\n            'category': 'problem',\n            'data': self.problem_xml\n        }\n        if problem_display_name:\n            block_kwargs['display_name'] = problem_display_name\n\n        block = BlockFactory.create(**block_kwargs)\n        mock_tracker_for_context = MagicMock()\n        with patch('lms.djangoapps.courseware.block_render.tracker', mock_tracker_for_context), patch(\n            'xmodule.services.tracker', mock_tracker_for_context\n        ):\n            render.handle_xblock_callback(\n                self.request,\n                str(self.course.id),\n                quote_slashes(str(block.location)),\n                'xmodule_handler',\n                'problem_check',\n            )\n\n            assert len(mock_tracker.emit.mock_calls) == 1\n            mock_call = mock_tracker.emit.mock_calls[0]\n            event = mock_call[2]\n\n            assert event['name'] == 'problem_check'\n\n            # for different operations, there are different number of context calls.\n            # We are sending this `call_idx` to get the mock call that we are interested in.\n            context = mock_tracker_for_context.get_tracker.mock_calls[call_idx][1][1]\n\n            return context\n\n    def handle_callback_and_get_block_info(self, mock_tracker, problem_display_name=None):\n        \"\"\"\n        Creates a fake block, invokes the callback and extracts the 'block'\n        metadata from the emitted problem_check event.\n        \"\"\"\n        event = self.handle_callback_and_get_context_info(\n            mock_tracker, problem_display_name, call_idx=1\n        )\n        return event['module']\n\n    def test_missing_display_name(self, mock_tracker):\n        actual_display_name = self.handle_callback_and_get_block_info(mock_tracker)['display_name']\n        assert actual_display_name.startswith('problem')\n\n    def test_library_source_information(self, mock_tracker):\n        \"\"\"\n        Check that XBlocks that are inherited from a library include the\n        information about their library block source in events.\n        We patch the modulestore to avoid having to create a library.\n        \"\"\"\n        original_usage_key = UsageKey.from_string('block-v1:A+B+C+type@problem+block@abcd1234')\n        original_usage_version = ObjectId()\n\n        def _mock_get_original_usage(_, __):\n            return original_usage_key, original_usage_version\n\n        with patch('xmodule.modulestore.mixed.MixedModuleStore.get_block_original_usage', _mock_get_original_usage):\n            block_info = self.handle_callback_and_get_block_info(mock_tracker)\n            assert 'original_usage_key' in block_info\n            assert block_info['original_usage_key'] == str(original_usage_key)\n            assert 'original_usage_version' in block_info\n            assert block_info['original_usage_version'] == str(original_usage_version)\n\n\nclass TestXBlockRuntimeEvent(TestSubmittingProblems):\n    \"\"\"\n    Inherit from TestSubmittingProblems to get functionality that set up a course and problems structure\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.homework = self.add_graded_section_to_course('homework')\n        self.problem = self.add_dropdown_to_section(self.homework.location, 'p1', 1)\n        self.grade_dict = {'value': 0.18, 'max_value': 32}\n        self.delete_dict = {'value': None, 'max_value': None}\n\n    def get_block_for_user(self, user):\n        \"\"\"Helper function to get useful block at self.location in self.course_id for user\"\"\"\n        mock_request = MagicMock()\n        mock_request.user = user\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id, user, self.course, depth=2)\n\n        return render.get_block(\n            user,\n            mock_request,\n            self.problem.location,\n            field_data_cache,\n        )\n\n    def set_block_grade_using_publish(self, grade_dict):\n        \"\"\"Publish the user's grade, takes grade_dict as input\"\"\"\n        block = self.get_block_for_user(self.student_user)\n        block.runtime.publish(block, 'grade', grade_dict)\n        return block\n\n    def test_xblock_runtime_publish(self):\n        \"\"\"Tests the publish mechanism\"\"\"\n        self.set_block_grade_using_publish(self.grade_dict)\n        student_module = StudentModule.objects.get(student=self.student_user, module_state_key=self.problem.location)\n        assert student_module.grade == self.grade_dict['value']\n        assert student_module.max_grade == self.grade_dict['max_value']\n\n    def test_xblock_runtime_publish_delete(self):\n        \"\"\"Test deleting the grade using the publish mechanism\"\"\"\n        block = self.set_block_grade_using_publish(self.grade_dict)\n        block.runtime.publish(block, 'grade', self.delete_dict)\n        student_module = StudentModule.objects.get(student=self.student_user, module_state_key=self.problem.location)\n        assert student_module.grade is None\n        assert student_module.max_grade is None\n\n    @patch('lms.djangoapps.grades.signals.handlers.PROBLEM_RAW_SCORE_CHANGED.send')\n    def test_score_change_signal(self, send_mock):\n        \"\"\"Test that a Django signal is generated when a score changes\"\"\"\n        with freeze_time(datetime.now().replace(tzinfo=pytz.UTC)):\n            self.set_block_grade_using_publish(self.grade_dict)\n            expected_signal_kwargs = {\n                'sender': None,\n                'raw_possible': self.grade_dict['max_value'],\n                'raw_earned': self.grade_dict['value'],\n                'weight': None,\n                'user_id': self.student_user.id,\n                'course_id': str(self.course.id),\n                'usage_id': str(self.problem.location),\n                'only_if_higher': None,\n                'modified': datetime.now().replace(tzinfo=pytz.UTC),\n                'score_db_table': 'csm',\n                'score_deleted': None,\n                'grader_response': None\n            }\n            send_mock.assert_called_with(**expected_signal_kwargs)\n\n\nclass TestRebindBlock(TestSubmittingProblems):\n    \"\"\"\n    Tests to verify the functionality of rebinding a block.\n    Inherit from TestSubmittingProblems to get functionality that set up a course structure\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.homework = self.add_graded_section_to_course('homework')\n        self.lti = BlockFactory.create(category='lti', parent=self.homework)\n        self.problem = BlockFactory.create(category='problem', parent=self.homework)\n        self.user = UserFactory.create()\n        self.anon_user = AnonymousUser()\n\n    def get_block_for_user(self, user, item=None):\n        \"\"\"Helper function to get useful block at self.location in self.course_id for user\"\"\"\n        mock_request = MagicMock()\n        mock_request.user = user\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            self.course.id, user, self.course, depth=2)\n\n        if item is None:\n            item = self.lti\n\n        return render.get_block(\n            user,\n            mock_request,\n            item.location,\n            field_data_cache,\n        )\n\n    def test_rebind_block_to_new_users(self):\n        block = self.get_block_for_user(self.user, self.problem)\n\n        # Bind the block to another student, which will remove \"correct_map\"\n        # from the block's _field_data_cache and _dirty_fields.\n        user2 = UserFactory.create()\n        block.bind_for_student(user2.id)\n\n        # XBlock's save method assumes that if a field is in _dirty_fields,\n        # then it's also in _field_data_cache. If this assumption\n        # doesn't hold, then we get an error trying to bind this block\n        # to a third student, since we've removed \"correct_map\" from\n        # _field_data cache, but not _dirty_fields, when we bound\n        # this block to the second student. (TNL-2640)\n        user3 = UserFactory.create()\n        block.bind_for_student(user3.id)\n\n    def test_rebind_noauth_block_to_user_not_anonymous(self):\n        \"\"\"\n        Tests that an exception is thrown when rebind_noauth_block_to_user is run from a\n        block bound to a real user\n        \"\"\"\n        block = self.get_block_for_user(self.user)\n        user2 = UserFactory()\n        user2.id = 2\n        with self.assertRaisesRegex(\n            RebindUserServiceError,\n            \"rebind_noauth_module_to_user can only be called from a module bound to an anonymous user\"\n        ):\n            assert block.runtime.service(block, 'rebind_user').rebind_noauth_module_to_user(block, user2)\n\n    def test_rebind_noauth_block_to_user_anonymous(self):\n        \"\"\"\n        Tests that get_user_block_for_noauth succeeds when rebind_noauth_block_to_user is run from a\n        block bound to AnonymousUser\n        \"\"\"\n        block = self.get_block_for_user(self.anon_user)\n        user2 = UserFactory()\n        user2.id = 2\n        block.runtime.service(block, 'rebind_user').rebind_noauth_module_to_user(block, user2)\n        assert block\n        block_user_info = block.runtime.service(block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID) == anonymous_id_for_user(user2, self.course.id)\n        assert block.scope_ids.user_id == user2.id\n        assert block.scope_ids.user_id == user2.id\n\n\n@ddt.ddt\nclass TestEventPublishing(ModuleStoreTestCase, LoginEnrollmentTestCase):\n    \"\"\"\n    Tests of event publishing for both XModules and XBlocks.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"\n        Set up the course and user context\n        \"\"\"\n        super().setUp()\n\n        self.mock_user = UserFactory()\n        self.mock_user.id = 1\n        self.request_factory = RequestFactoryNoCsrf()\n\n    @XBlock.register_temp_plugin(PureXBlock, identifier='xblock')\n    @patch.object(render, 'make_track_function')\n    def test_event_publishing(self, mock_track_function):\n        request = self.request_factory.get('')\n        request.user = self.mock_user\n        course = CourseFactory()\n        block = BlockFactory(category='xblock', parent=course)\n        field_data_cache = FieldDataCache([course, block], course.id, self.mock_user)\n        block = render.get_block(self.mock_user, request, block.location, field_data_cache)\n\n        event_type = 'event_type'\n        event = {'event': 'data'}\n\n        block.runtime.publish(block, event_type, event)\n\n        mock_track_function.assert_called_once_with(request)\n\n        mock_track_function.return_value.assert_called_once_with(event_type, event)\n\n\nclass LMSXBlockServiceMixin(SharedModuleStoreTestCase):\n    \"\"\"\n    Helper class that initializes the runtime.\n    \"\"\"\n    def _prepare_runtime(self):\n        \"\"\"\n        Instantiate the runtem.\n        \"\"\"\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course\n        )\n\n    @XBlock.register_temp_plugin(PureXBlock, identifier='pure')\n    def setUp(self):\n        \"\"\"\n        Set up the user and other fields that will be used to instantiate the runtime.\n        \"\"\"\n        super().setUp()\n        self.course = CourseFactory.create()\n        self.user = UserFactory()\n        self.student_data = Mock()\n        self.track_function = Mock()\n        self.request_token = Mock()\n        self.block = BlockFactory(category=\"pure\", parent=self.course)\n        self._prepare_runtime()\n\n\n@ddt.ddt\nclass LMSXBlockServiceBindingTest(LMSXBlockServiceMixin):\n    \"\"\"\n    Tests that the LMS Module System (XBlock Runtime) provides an expected set of services.\n    \"\"\"\n\n    @ddt.data(\n        'fs',\n        'field-data',\n        'mako',\n        'user',\n        'verification',\n        'proctoring',\n        'milestones',\n        'credit',\n        'bookmarks',\n        'gating',\n        'grade_utils',\n        'user_state',\n        'content_type_gating',\n        'cache',\n        'sandbox',\n        'replace_urls',\n        'rebind_user',\n        'completion',\n        'i18n',\n        'library_tools',\n        'partitions',\n        'settings',\n        'user_tags',\n        'teams',\n        'teams_configuration',\n        'call_to_action',\n    )\n    def test_expected_services_exist(self, expected_service):\n        \"\"\"\n        Tests that the 'user', 'i18n', and 'fs' services are provided by the LMS runtime.\n        \"\"\"\n        service = self.block.runtime.service(self.block, expected_service)\n        assert service is not None\n\n    def test_get_set_tag(self):\n        \"\"\"\n        Tests the user service interface.\n        \"\"\"\n        scope = 'course'\n        key = 'key1'\n\n        # test for when we haven't set the tag yet\n        tag = self.block.runtime.service(self.block, 'user_tags').get_tag(scope, key)\n        assert tag is None\n\n        # set the tag\n        set_value = 'value'\n        self.block.runtime.service(self.block, 'user_tags').set_tag(scope, key, set_value)\n        tag = self.block.runtime.service(self.block, 'user_tags').get_tag(scope, key)\n\n        assert tag == set_value\n\n        # Try to set tag in wrong scope\n        with pytest.raises(ValueError):\n            self.block.runtime.service(self.block, 'user_tags').set_tag('fake_scope', key, set_value)\n\n        # Try to get tag in wrong scope\n        with pytest.raises(ValueError):\n            self.block.runtime.service(self.block, 'user_tags').get_tag('fake_scope', key)\n\n\nclass TestI18nService(LMSXBlockServiceMixin):\n    \"\"\" Test XBlockI18nService \"\"\"\n\n    def test_module_i18n_lms_service(self):\n        \"\"\"\n        Test: module i18n service in LMS\n        \"\"\"\n        i18n_service = self.block.runtime.service(self.block, 'i18n')\n        assert i18n_service is not None\n        assert isinstance(i18n_service, XBlockI18nService)\n\n    def test_no_service_exception_with_none_declaration_(self):\n        \"\"\"\n        Test: NoSuchServiceError should be raised block declaration returns none\n        \"\"\"\n        self.block.service_declaration = Mock(return_value=None)\n        with pytest.raises(NoSuchServiceError):\n            self.block.runtime.service(self.block, 'i18n')\n\n    def test_no_service_exception_(self):\n        \"\"\"\n        Test: NoSuchServiceError should be raised if i18n service is none.\n        \"\"\"\n        i18nService = self.block.runtime._services['i18n']  # pylint: disable=protected-access\n        self.block.runtime._services['i18n'] = None  # pylint: disable=protected-access\n        with pytest.raises(NoSuchServiceError):\n            self.block.runtime.service(self.block, 'i18n')\n        self.block.runtime._services['i18n'] = i18nService  # pylint: disable=protected-access\n\n    def test_i18n_service_callable(self):\n        \"\"\"\n        Test: _services dict should contain the callable i18n service in LMS.\n        \"\"\"\n        assert callable(self.block.runtime._services.get('i18n'))  # pylint: disable=protected-access\n\n    def test_i18n_service_not_callable(self):\n        \"\"\"\n        Test: i18n service should not be callable in LMS after initialization.\n        \"\"\"\n        assert not callable(self.block.runtime.service(self.block, 'i18n'))\n\n\nclass PureXBlockWithChildren(PureXBlock):\n    \"\"\"\n    Pure XBlock with children to use in tests.\n    \"\"\"\n    has_children = True\n\n\nUSER_NUMBERS = list(range(2))\n\n\n@ddt.ddt\nclass TestFilteredChildren(SharedModuleStoreTestCase):\n    \"\"\"\n    Tests that verify access to XBlock/XModule children work correctly\n    even when those children are filtered by the runtime when loaded.\n    \"\"\"\n    # pylint: disable=attribute-defined-outside-init\n    def setUp(self):\n        super().setUp()\n        self.course = CourseFactory.create()\n        self.users = {number: UserFactory() for number in USER_NUMBERS}\n\n        self._old_has_access = render.has_access\n        patcher = patch('lms.djangoapps.courseware.block_render.has_access', self._has_access)\n        patcher.start()\n        self.addCleanup(patcher.stop)\n\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_unbound(self):\n        block = self._load_block()\n        self.assertUnboundChildren(block)\n\n    @ddt.data(*USER_NUMBERS)\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_unbound_then_bound_as_xblock(self, user_number):\n        user = self.users[user_number]\n        block = self._load_block()\n        self.assertUnboundChildren(block)\n        self._bind_block(block, user)\n        self.assertBoundChildren(block, user)\n\n    @ddt.data(*USER_NUMBERS)\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_bound_only_as_xblock(self, user_number):\n        user = self.users[user_number]\n        block = self._load_block()\n        self._bind_block(block, user)\n        self.assertBoundChildren(block, user)\n\n    def _load_block(self):\n        \"\"\"\n        Instantiate an XBlock with the appropriate set of children.\n        \"\"\"\n        self.parent = BlockFactory(category='xblock', parent=self.course)\n\n        # Create a child for each user\n        self.children_for_user = {\n            user: BlockFactory(category='xblock', parent=self.parent).scope_ids.usage_id  # lint-amnesty, pylint: disable=no-member\n            for user in self.users.values()\n        }\n\n        self.all_children = self.children_for_user.values()\n\n        return modulestore().get_item(self.parent.scope_ids.usage_id)  # lint-amnesty, pylint: disable=no-member\n\n    def _bind_block(self, block, user):\n        \"\"\"\n        Bind `block` to the supplied `user`.\n        \"\"\"\n        course_id = self.course.id\n        field_data_cache = FieldDataCache.cache_for_block_descendents(\n            course_id,\n            user,\n            block,\n        )\n        return get_block_for_descriptor(\n            user,\n            Mock(name='request', user=user),\n            block,\n            field_data_cache,\n            course_id,\n            course=self.course\n        )\n\n    def _has_access(self, user, action, obj, course_key=None):\n        \"\"\"\n        Mock implementation of `has_access` used to control which blocks\n        have access to which children during tests.\n        \"\"\"\n        if action != 'load':\n            return self._old_has_access(user, action, obj, course_key)\n\n        if isinstance(obj, XBlock):\n            key = obj.scope_ids.usage_id\n        elif isinstance(obj, UsageKey):\n            key = obj\n        if key == self.parent.scope_ids.usage_id:  # lint-amnesty, pylint: disable=no-member\n            return AccessResponse(True)\n        return AccessResponse(key == self.children_for_user[user])\n\n    def assertBoundChildren(self, block, user):\n        \"\"\"\n        Ensure the bound children are indeed children.\n        \"\"\"\n        self.assertChildren(block, [self.children_for_user[user]])\n\n    def assertUnboundChildren(self, block):\n        \"\"\"\n        Ensure unbound children are indeed children.\n        \"\"\"\n        self.assertChildren(block, self.all_children)\n\n    def assertChildren(self, block, child_usage_ids):\n        \"\"\"\n        Used to assert that sets of children are equivalent.\n        \"\"\"\n        assert set(child_usage_ids) == {child.scope_ids.usage_id for child in block.get_children()}\n\n\n@ddt.ddt\nclass TestDisabledXBlockTypes(ModuleStoreTestCase):\n    \"\"\"\n    Tests that verify disabled XBlock types are not loaded.\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        XBlockConfiguration(name='video', enabled=False).save()\n\n    def test_get_item(self):\n        course = CourseFactory()\n        self._verify_block('video', course, 'HiddenBlockWithMixins')\n\n    def test_dynamic_updates(self):\n        \"\"\"Tests that the list of disabled xblocks can dynamically update.\"\"\"\n        course = CourseFactory()\n        item_usage_id = self._verify_block('problem', course, 'ProblemBlockWithMixins')\n        XBlockConfiguration(name='problem', enabled=False).save()\n\n        # First verify that the cached value is used until there is a new request cache.\n        self._verify_block('problem', course, 'ProblemBlockWithMixins', item_usage_id)\n\n        # Now simulate a new request cache.\n        self.store.request_cache.data.clear()\n        self._verify_block('problem', course, 'HiddenBlockWithMixins', item_usage_id)\n\n    def _verify_block(self, category, course, block, item_id=None):\n        \"\"\"\n        Helper method that gets an item with the specified category from the\n        modulestore and verifies that it has the expected block name.\n\n        Returns the item's usage_id.\n        \"\"\"\n        if not item_id:\n            item = BlockFactory(category=category, parent=course)\n            item_id = item.scope_ids.usage_id  # lint-amnesty, pylint: disable=no-member\n\n        item = self.store.get_item(item_id)\n        assert item.__class__.__name__ == block\n        return item_id\n\n\n@ddt.ddt\nclass LmsModuleSystemShimTest(SharedModuleStoreTestCase):\n    \"\"\"\n    Tests that the deprecated attributes in the LMS Module System (XBlock Runtime) return the expected values.\n    \"\"\"\n    MODULESTORE = TEST_DATA_SPLIT_MODULESTORE\n    COURSE_ID = 'course-v1:edX+LmsModuleShimTest+2021_Fall'\n    PYTHON_LIB_FILENAME = 'test_python_lib.zip'\n    PYTHON_LIB_SOURCE_FILE = './common/test/data/uploads/python_lib.zip'\n\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"\n        Set up the course and block used to instantiate the runtime.\n        \"\"\"\n        super().setUpClass()\n        org = 'edX'\n        number = 'LmsModuleShimTest'\n        run = '2021_Fall'\n        cls.course = CourseFactory.create(org=org, number=number, run=run)\n        cls.block = BlockFactory(category=\"vertical\", parent=cls.course)\n        cls.problem_block = BlockFactory(category=\"problem\", parent=cls.course)\n\n    def setUp(self):\n        \"\"\"\n        Set up the user and other fields that will be used to instantiate the runtime.\n        \"\"\"\n        super().setUp()\n        self.user = UserFactory(id=232)\n        self.student_data = Mock()\n        self.track_function = Mock()\n        self.request_token = Mock()\n        self.contentstore = contentstore()\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n\n    @ddt.data(\n        ('seed', 232),\n        ('user_id', 232),\n        ('user_is_staff', False),\n    )\n    @ddt.unpack\n    def test_user_service_attributes(self, attribute, expected_value):\n        \"\"\"\n        Tests that the deprecated attributes provided by the user service match expected values.\n        \"\"\"\n        assert getattr(self.block.runtime, attribute) == expected_value\n\n    @ddt.data((True, 'staff'), (False, 'student'))\n    @ddt.unpack\n    def test_user_is_staff(self, is_staff, expected_role):\n        if is_staff:\n            self.user = StaffFactory(course_key=self.course.id)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_STAFF) == is_staff\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_ROLE) == expected_role\n        with warnings.catch_warnings():  # For now, also test the deprecated accessors for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.user_is_staff == is_staff\n            assert self.block.runtime.get_user_role() == expected_role\n\n    @ddt.data(True, False)\n    def test_user_is_admin(self, is_global_staff):\n        if is_global_staff:\n            self.user = GlobalStaffFactory.create()\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_GLOBAL_STAFF) == is_global_staff\n        with warnings.catch_warnings():  # For now, also test the deprecated accessors for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.user_is_admin == is_global_staff\n\n    @ddt.data(True, False)\n    def test_user_is_beta_tester(self, is_beta_tester):\n        if is_beta_tester:\n            self.user = BetaTesterFactory(course_key=self.course.id)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_BETA_TESTER) == is_beta_tester\n        with warnings.catch_warnings():  # For now, also test the deprecated accessors for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.user_is_beta_tester == is_beta_tester\n\n    @ddt.data((True, 'instructor'), (False, 'student'))\n    @ddt.unpack\n    def test_get_user_role(self, is_instructor, expected_role):\n        if is_instructor:\n            self.user = InstructorFactory(course_key=self.course.id)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_USER_ROLE) == expected_role\n        with warnings.catch_warnings():  # For now, also test the deprecated accessor for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.get_user_role() == expected_role\n\n    def test_anonymous_student_id(self):\n        expected_anon_id = anonymous_id_for_user(self.user, self.course.id)\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID) == expected_anon_id\n        with warnings.catch_warnings():  # For now, also test the deprecated accessor for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.anonymous_student_id == expected_anon_id\n\n    def test_anonymous_student_id_bug(self):\n        \"\"\"\n        Verifies that subsequent calls to prepare_runtime_for_user have no effect on each block runtime's\n        anonymous_student_id value.\n        \"\"\"\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.problem_block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        # Ensure the problem block returns a per-user anonymous id\n        assert self.problem_block.runtime.service(self.problem_block, 'user').get_current_user().opt_attrs.get(\n            ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID\n        ) == anonymous_id_for_user(self.user, None)\n\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        # Ensure the vertical block returns a per-course+user anonymous id\n        assert self.block.runtime.service(self.block, 'user').get_current_user().opt_attrs.get(\n            ATTR_KEY_ANONYMOUS_USER_ID\n        ) == anonymous_id_for_user(self.user, self.course.id)\n\n        # Ensure the problem runtime's anonymous student ID is unchanged after the above call.\n        assert self.problem_block.runtime.service(self.problem_block, 'user').get_current_user().opt_attrs.get(\n            ATTR_KEY_DEPRECATED_ANONYMOUS_USER_ID\n        ) == anonymous_id_for_user(self.user, None)\n\n    def test_user_service_with_anonymous_user(self):\n        render.prepare_runtime_for_user(\n            AnonymousUser(),\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        block_user_info = self.block.runtime.service(self.block, \"user\").get_current_user()\n        assert block_user_info.opt_attrs.get(ATTR_KEY_ANONYMOUS_USER_ID) is None\n        assert self.block.scope_ids.user_id is None\n        assert not block_user_info.opt_attrs.get(ATTR_KEY_USER_IS_STAFF)\n        assert not block_user_info.opt_attrs.get(ATTR_KEY_USER_ROLE)\n        # Also test the deprecated accessors for backwards compatibility:\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert self.block.runtime.anonymous_student_id is None\n            assert self.block.runtime.seed == 0\n            assert self.block.runtime.user_id is None\n            assert not self.block.runtime.user_is_staff\n            assert not self.block.runtime.get_user_role()\n\n    def test_get_real_user(self):\n        \"\"\"\n        Test the deprecated runtime.get_real_user() method, to ensure backwards compatibility.\n\n        Newer code should use the user service, which gets tested in test_user_service.py\n        \"\"\"\n        render.prepare_runtime_for_user(\n            self.user,\n            self.student_data,\n            self.block.runtime,\n            self.course.id,\n            self.track_function,\n            self.request_token,\n            course=self.course,\n        )\n        course_anonymous_student_id = anonymous_id_for_user(self.user, self.course.id)\n        no_course_anonymous_student_id = anonymous_id_for_user(self.user, None)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            # pylint: disable=not-callable\n            assert self.block.runtime.get_real_user(course_anonymous_student_id) == self.user\n            assert self.block.runtime.get_real_user(no_course_anonymous_student_id) == self.user\n            # Tests that the default is to use the user service's anonymous_student_id\n            assert self.block.runtime.get_real_user() == self.user\n\n    def test_render_template(self):\n        rendered = self.block.runtime.render_template('templates/edxmako.html', {'element_id': 'hi'})  # pylint: disable=not-callable\n        assert rendered == '<div id=\"hi\" ns=\"main\">Testing the MakoService</div>\\n'\n\n    @override_settings(COURSES_WITH_UNSAFE_CODE=[r'course-v1:edX\\+LmsModuleShimTest\\+2021_Fall'])\n    def test_can_execute_unsafe_code_when_allowed(self):\n        assert self.block.runtime.can_execute_unsafe_code()\n\n    @override_settings(COURSES_WITH_UNSAFE_CODE=[r'course-v1:edX\\+full\\+2021_Fall'])\n    def test_cannot_execute_unsafe_code_when_disallowed(self):\n        assert not self.block.runtime.can_execute_unsafe_code()\n\n    def test_cannot_execute_unsafe_code(self):\n        assert not self.block.runtime.can_execute_unsafe_code()\n\n    @override_settings(PYTHON_LIB_FILENAME=PYTHON_LIB_FILENAME)\n    def test_get_python_lib_zip(self):\n        zipfile = upload_file_to_course(\n            course_key=self.course.id,\n            contentstore=self.contentstore,\n            source_file=self.PYTHON_LIB_SOURCE_FILE,\n            target_filename=self.PYTHON_LIB_FILENAME,\n        )\n        assert self.block.runtime.get_python_lib_zip() == zipfile\n\n    def test_no_get_python_lib_zip(self):\n        zipfile = upload_file_to_course(\n            course_key=self.course.id,\n            contentstore=self.contentstore,\n            source_file=self.PYTHON_LIB_SOURCE_FILE,\n            target_filename=self.PYTHON_LIB_FILENAME,\n        )\n        assert self.block.runtime.get_python_lib_zip() is None\n\n    def test_cache(self):\n        assert hasattr(self.block.runtime.cache, 'get')\n        assert hasattr(self.block.runtime.cache, 'set')\n\n    @XBlock.register_temp_plugin(PureXBlock, 'pure')\n    @XBlock.register_temp_plugin(PureXBlockWithChildren, identifier='xblock')\n    def test_course_id(self):\n        block = BlockFactory(category=\"pure\", parent=self.course)\n\n        rendered_block = render.get_block(self.user, Mock(), block.location, None)\n        assert str(rendered_block.scope_ids.usage_id.context_key) == self.COURSE_ID\n        with warnings.catch_warnings():  # For now, also test the deprecated accessor for backwards compatibility:\n            warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n            assert str(rendered_block.runtime.course_id) == self.COURSE_ID\n"], "filenames": ["lms/djangoapps/courseware/block_render.py", "lms/djangoapps/courseware/tests/test_block_render.py"], "buggy_code_start_loc": [29, 92], "buggy_code_end_loc": [780, 382], "fixing_code_start_loc": [30, 92], "fixing_code_end_loc": [788, 403], "type": "CWE-284", "message": "Open edX Platform is a service-oriented platform for authoring and delivering online learning. A user with a JWT and more limited scopes could call endpoints exceeding their access. This vulnerability has been patched in commit 019888f.", "other": {"cve": {"id": "CVE-2024-22209", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-13T08:15:07.557", "lastModified": "2024-01-22T19:20:27.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open edX Platform is a service-oriented platform for authoring and delivering online learning. A user with a JWT and more limited scopes could call endpoints exceeding their access. This vulnerability has been patched in commit 019888f."}, {"lang": "es", "value": "Open edX Platform es una plataforma orientada a servicios para crear y ofrecer aprendizaje en l\u00ednea. Un usuario con un JWT y alcances m\u00e1s limitados podr\u00eda llamar a endpoints que excedan su acceso. Esta vulnerabilidad ha sido parcheada en el commit 019888f."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:edx:edx-platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "2024-01-12", "matchCriteriaId": "1BD13825-8465-4BC9-86A9-392515F89403"}]}]}], "references": [{"url": "https://github.com/openedx/edx-platform/blob/0b3e4d73b6fb6f41ae87cf2b77bca12052ee1ac8/lms/djangoapps/courseware/block_render.py#L752-L775", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/openedx/edx-platform/commit/019888f3d15beaebcb7782934f6c43b0c2b3735e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/openedx/edx-platform/security/advisories/GHSA-qx8m-mqx3-j9fm", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openedx/edx-platform/commit/019888f3d15beaebcb7782934f6c43b0c2b3735e"}}