{"buggy_code": ["/*\n *  iso_presentation.c\n *\n *  Copyright 2013-2022 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n\n#include \"iso_presentation.h\"\n#include \"stack_config.h\"\n#include \"ber_encoder.h\"\n#include \"ber_decode.h\"\n#include \"buffer_chain.h\"\n\n#if ((DEBUG_ISO_SERVER == 1) || (DEBUG_ISO_CLIENT == 1))\n#define DEBUG_PRES 1\n#else\n#define DEBUG_PRES 0\n#endif\n\n\nstatic uint8_t calledPresentationSelector[] = { 0x00, 0x00, 0x00, 0x01 };\n\nstatic uint8_t asn_id_as_acse[] = { 0x52, 0x01, 0x00, 0x01 };\n\nstatic uint8_t asn_id_mms[] = { 0x28, 0xca, 0x22, 0x02, 0x01 };\n\nstatic uint8_t ber_id[] = { 0x51, 0x01 };\n\nstatic int\nencodeAcceptBer(uint8_t* buffer, int bufPos)\n{\n    bufPos = BerEncoder_encodeTL(0x30, 7, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, 1, buffer, bufPos);\n    buffer[bufPos++] = 0;\n    bufPos = BerEncoder_encodeTL(0x81, 2, buffer, bufPos);\n    buffer[bufPos++] = 0x51;\n    buffer[bufPos++] = 0x01;\n\n    return bufPos;\n}\n\nstatic int\nencodeUserData(uint8_t* buffer, int bufPos,\n        BufferChain payload, bool encode, uint8_t contextId)\n{\n    int payloadLength = payload->length;\n\n    int encodedDataSetLength = 3; /* presentation-selector */\n\n    /* presentation-data */\n    encodedDataSetLength += payloadLength + 1;\n    encodedDataSetLength += BerEncoder_determineLengthSize(payloadLength);\n\n    int fullyEncodedDataLength = encodedDataSetLength;\n\n    fullyEncodedDataLength += BerEncoder_determineLengthSize(encodedDataSetLength) + 1;\n\n    if (encode) {\n        /* fully-encoded-data */\n        bufPos = BerEncoder_encodeTL(0x61, fullyEncodedDataLength, buffer, bufPos);\n        bufPos = BerEncoder_encodeTL(0x30, encodedDataSetLength, buffer, bufPos);\n\n        /* presentation-selector acse */\n        bufPos = BerEncoder_encodeTL(0x02, 1, buffer, bufPos);\n        buffer[bufPos++] = contextId;\n\n        /* presentation-data (= acse payload) */\n        bufPos = BerEncoder_encodeTL(0xa0, payloadLength, buffer, bufPos);\n\n        return bufPos;\n    }\n    else {\n        int encodedUserDataLength = fullyEncodedDataLength + 1;\n        encodedUserDataLength += BerEncoder_determineLengthSize(fullyEncodedDataLength);\n\n        return encodedUserDataLength;\n    }\n}\n\nstatic void\ncreateConnectPdu(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int contentLength = 0;\n    int i;\n\n    /* mode-selector */\n    contentLength += 5;\n\n    int normalModeLength = 0;\n\n    /* called- and calling-presentation-selector */\n    normalModeLength += 12;\n\n    int pclLength = 27; /* 35; */\n    pclLength += self->callingPresentationSelector.size;\n    pclLength += self->calledPresentationSelector.size;\n\n    normalModeLength += pclLength;\n\n    normalModeLength += encodeUserData(NULL, 0, payload, false, self->acseContextId);\n\n    normalModeLength += 2;\n\n    contentLength += normalModeLength;\n\n    contentLength += 1 + BerEncoder_determineLengthSize(normalModeLength);\n\n    uint8_t* buffer = writeBuffer->buffer;\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0x31, contentLength, buffer, bufPos);\n\n    /* mode-selector */\n    bufPos = BerEncoder_encodeTL(0xa0, 3, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, 1, buffer, bufPos);\n    buffer[bufPos++] = 1; /* 1 = normal-mode */\n\n    /* normal-mode-parameters */\n    bufPos = BerEncoder_encodeTL(0xa2, normalModeLength, buffer, bufPos);\n\n    /* calling-presentation-selector */\n    bufPos = BerEncoder_encodeTL(0x81, self->callingPresentationSelector.size, buffer, bufPos);\n    for (i = 0; i < self->callingPresentationSelector.size; i++)\n        buffer[bufPos++] = self->callingPresentationSelector.value[i];\n\n    /* called-presentation-selector */\n    bufPos = BerEncoder_encodeTL(0x82, self->calledPresentationSelector.size, buffer, bufPos);\n    for (i = 0; i < self->calledPresentationSelector.size; i++)\n        buffer[bufPos++] = self->calledPresentationSelector.value[i];\n\n    /* presentation-context-id list */\n    bufPos = BerEncoder_encodeTL(0xa4, 35, buffer, bufPos);\n\n    /* acse context list item */\n    bufPos = BerEncoder_encodeTL(0x30, 15, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, 1, buffer, bufPos);\n    buffer[bufPos++] = 1;\n\n    bufPos = BerEncoder_encodeTL(0x06, 4, buffer, bufPos);\n    memcpy(buffer + bufPos, asn_id_as_acse, 4);\n    bufPos += 4;\n\n    bufPos = BerEncoder_encodeTL(0x30, 4, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x06, 2, buffer, bufPos);\n    memcpy(buffer + bufPos, ber_id, 2);\n    bufPos += 2;\n\n    /* mms context list item */\n    bufPos = BerEncoder_encodeTL(0x30, 16, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, 1, buffer, bufPos);\n    buffer[bufPos++] = 3;\n\n    bufPos = BerEncoder_encodeTL(0x06, 5, buffer, bufPos);\n    memcpy(buffer + bufPos, asn_id_mms, 5);\n    bufPos += 5;\n\n    bufPos = BerEncoder_encodeTL(0x30, 4, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x06, 2, buffer, bufPos);\n    memcpy(buffer + bufPos, ber_id, 2);\n    bufPos += 2;\n\n    /* encode user data */\n    bufPos = encodeUserData(buffer, bufPos, payload, true, self->acseContextId);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payload->length;\n    writeBuffer->nextPart = payload;\n}\n\nstatic int\nparseFullyEncodedData(IsoPresentation* self, uint8_t* buffer, int len, int bufPos)\n{\n    int presentationSelector = -1;\n    bool userDataPresent = false;\n\n    int endPos = bufPos + len;\n\n    if (buffer[bufPos++] != 0x30) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data parse error\\n\");\n        return -1;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: wrong parameter length\\n\");\n        return -1;\n    }\n\n    endPos = bufPos + len;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x02: /* presentation-context-identifier */\n            if (DEBUG_PRES)\n                printf(\"PRES: presentation-context-identifier\\n\");\n            {\n                presentationSelector = BerDecoder_decodeUint32(buffer, length, bufPos);\n                self->nextContextId = presentationSelector;\n                bufPos += length;\n            }\n            break;\n\n        case 0x06: /* transfer-syntax-name */\n            bufPos += length;\n            break;\n\n        case 0xa0:\n            if (DEBUG_PRES)\n                printf(\"PRES: fully-encoded-data\\n\");\n\n            userDataPresent = true;\n\n            self->nextPayload.buffer = buffer + bufPos;\n            self->nextPayload.size = length;\n\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: fed: unknown tag %02x\\n\", tag);\n\n            bufPos += length;\n            break;\n        }\n    }\n\n    if (!userDataPresent) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data not present\\n\");\n        return -1;\n    }\n\n    return bufPos;\n}\n\nstatic int\nparsePCDLEntry(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    int contextId = -1;\n    bool isAcse = false;\n    bool isMms = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: Invalid PDU\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x02: /* presentation-context-identifier */\n            contextId = BerDecoder_decodeUint32(buffer, len, bufPos);\n            bufPos += len;\n            break;\n\n        case 0x06: /* abstract-syntax-name */\n            if (DEBUG_PRES)\n                printf(\"PRES: abstract-syntax-name with len %i\\n\", len);\n\n            if (len == 5) {\n                if (memcmp(buffer + bufPos, asn_id_mms, 5) == 0)\n                    isMms = true;\n            }\n            else if (len == 4) {\n                if (memcmp(buffer + bufPos, asn_id_as_acse, 4) == 0)\n                    isAcse = true;\n            }\n\n            bufPos += len;\n\n            break;\n\n        case 0x30: /* transfer-syntax-name */\n            if (DEBUG_PRES)\n                printf(\"PRES: ignore transfer-syntax-name\\n\");\n\n            bufPos += len;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in presentation-context-definition-list-entry\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (contextId < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: ContextId not defined!\\n\");\n        return -1;\n    }\n\n    if ((isAcse == false) && (isMms == false)) {\n        if (DEBUG_PRES)\n            printf(\"PRES: not an ACSE or MMS context definition\\n\");\n\n        return -1;\n    }\n\n    if (isMms) {\n        self->mmsContextId = (uint8_t) contextId;\n        if (DEBUG_PRES)\n            printf(\"PRES: MMS context id is %i\\n\", contextId);\n    }\n    else {\n        self->acseContextId = (uint8_t) contextId;\n        if (DEBUG_PRES)\n            printf(\"PRES: ACSE context id is %i\\n\", contextId);\n    }\n\n    return bufPos;\n}\n\nstatic int\nparsePresentationContextDefinitionList(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n        if (bufPos < 0)\n            return -1;\n\n        switch (tag) {\n        case 0x30:\n            if (DEBUG_PRES)\n                printf(\"PRES: parse pcd entry\\n\");\n            bufPos = parsePCDLEntry(self, buffer, len, bufPos);\n            if (bufPos < 0)\n                return -1;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in presentation-context-definition-list\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    return bufPos;\n}\n\nstatic int\nparseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    self->calledPresentationSelector.size = 0;\n    self->callingPresentationSelector.size = 0;\n\n    bool hasUserData = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        if (bufPos == endPos) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message\\n\");\n            return -1;\n        }\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x81: /* calling-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: calling-presentation-sel too large\\n\");\n            }\n            else {\n                self->callingPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->callingPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x82: /* called-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: called-presentation-sel too large\\n\");\n            }\n            else {\n                self->calledPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->calledPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x83: /* responding-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: responding-presentation-sel too large\\n\");\n            }\n\n            bufPos += len;\n            break;\n\n        case 0xa4: /* presentation-context-definition list */\n            if (DEBUG_PRES)\n                printf(\"PRES: pcd list\\n\");\n            bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n            break;\n\n        case 0xa5: /* context-definition-result-list */\n\n            bufPos += len;\n            break;\n\n        case 0x61: /* user data */\n            if (DEBUG_PRES)\n                printf(\"PRES: user-data\\n\");\n\n            bufPos = parseFullyEncodedData(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            if (self->nextPayload.size > 0)\n                hasUserData = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in normal-mode\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasUserData == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data is missing\\n\");\n\n        return -1;\n    }\n\n    return bufPos;\n}\n\nint\nIsoPresentation_parseAcceptMessage(IsoPresentation* self, ByteBuffer* byteBuffer)\n{\n    uint8_t* buffer = byteBuffer->buffer;\n    int maxBufPos = byteBuffer->size;\n\n    int bufPos = 0;\n\n    uint8_t cpTag = buffer[bufPos++];\n\n    if (cpTag != 0x31) {\n        if (DEBUG_PRES)\n            printf(\"PRES: not a CPA message\\n\");\n        return 0;\n    }\n\n    int len;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: Invalid message\\n\");\n        return 0;\n    }\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return 0;\n        }\n\n        switch (tag) {\n        case 0xa0: /* mode-selector */\n            bufPos += len; /* ignore content since only normal mode is allowed */\n            break;\n        case 0xa2: /* normal-mode-parameters */\n            bufPos = parseNormalModeParameters(self, buffer, len, bufPos);\n\n            if (bufPos < 0) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: error parsing normal-mode-parameters\\n\");\n                return 0;\n            }\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: CPA unknown tag %i\\n\", tag);\n            bufPos += len;\n            break;\n        }\n    }\n\n    return 1;\n}\n\nvoid\nIsoPresentation_init(IsoPresentation* self)\n{\n    (void)self;\n}\n\nvoid\nIsoPresentation_createUserData(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int bufPos = 0;\n    uint8_t* buffer = writeBuffer->buffer;\n\n    int payloadLength = payload->length;\n\n    int userDataLengthFieldSize = BerEncoder_determineLengthSize(payloadLength);\n    ;\n    int pdvListLength = payloadLength + (userDataLengthFieldSize + 4);\n\n    int pdvListLengthFieldSize = BerEncoder_determineLengthSize(pdvListLength);\n    int presentationLength = pdvListLength + (pdvListLengthFieldSize + 1);\n\n    bufPos = BerEncoder_encodeTL(0x61, presentationLength, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, pdvListLength, buffer, bufPos);\n\n    buffer[bufPos++] = (uint8_t) 0x02;\n    buffer[bufPos++] = (uint8_t) 0x01;\n    buffer[bufPos++] = (uint8_t) self->mmsContextId; /* mms context id */\n\n    bufPos = BerEncoder_encodeTL(0xa0, payloadLength, buffer, bufPos);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payloadLength;\n    writeBuffer->nextPart = payload;\n}\n\nvoid\nIsoPresentation_createUserDataACSE(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int bufPos = 0;\n    uint8_t* buffer = writeBuffer->buffer;\n\n    int payloadLength = payload->length;\n\n    int userDataLengthFieldSize = BerEncoder_determineLengthSize(payloadLength);\n    ;\n    int pdvListLength = payloadLength + (userDataLengthFieldSize + 4);\n\n    int pdvListLengthFieldSize = BerEncoder_determineLengthSize(pdvListLength);\n    int presentationLength = pdvListLength + (pdvListLengthFieldSize + 1);\n\n    bufPos = BerEncoder_encodeTL(0x61, presentationLength, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, pdvListLength, buffer, bufPos);\n\n    buffer[bufPos++] = (uint8_t) 0x02;\n    buffer[bufPos++] = (uint8_t) 0x01;\n    buffer[bufPos++] = (uint8_t) self->acseContextId; /* ACSE context id */\n\n    bufPos = BerEncoder_encodeTL(0xa0, payloadLength, buffer, bufPos);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payloadLength;\n    writeBuffer->nextPart = payload;\n}\n\nint\nIsoPresentation_parseUserData(IsoPresentation* self, ByteBuffer* readBuffer)\n{\n    uint8_t* buffer = readBuffer->buffer;\n    int maxBufPos = readBuffer->size;\n    bool hasAbstractSyntaxName = false;\n\n    int bufPos = 0;\n\n    if (maxBufPos < 9)\n        return 0;\n\n    if (buffer[bufPos++] != 0x61)\n        return 0;\n\n    int len;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: invalid message!\\n\");\n        return 0;\n    }\n\n    if (buffer[bufPos++] != 0x30)\n        return 0;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: invalid message!\\n\");\n        return 0;\n    }\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        uint8_t lenField = buffer[bufPos];\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return 0;\n        }\n\n        switch (tag) {\n        case 0x02: /* abstract-syntax-name */\n            self->nextContextId = buffer[bufPos];\n            hasAbstractSyntaxName = true;\n            bufPos += len;\n            break;\n\n        case 0x06: /* transfer-syntax-name */\n            {\n                /* check if basic-encoding (2.1.1 - 51 01) */\n                if ((buffer[bufPos] != 0x51) || (buffer[bufPos + 1] != 0x01)) {\n                    if (DEBUG_PRES) {\n                        printf(\"PRES: unknown transfer-syntax-name\\n\");\n                    }\n\n                    return 0;\n                }\n\n                bufPos += len;\n            }\n            break;\n\n\n        case 0xa0: /* presentation data */\n            {\n                if (hasAbstractSyntaxName == false) {\n                    if (DEBUG_PRES)\n                        printf(\"PRES: abstract-syntax-name missing!\\n\");\n\n                    return 0;\n                }\n\n                int userDataLength = len;\n\n                if (lenField == 0x80)\n                    userDataLength = userDataLength - 2;\n\n                ByteBuffer_wrap(&(self->nextPayload), buffer + bufPos, userDataLength, userDataLength);\n\n                return 1;\n            }\n            break;\n        }\n    }\n\n    return 0;\n}\n\nint\nIsoPresentation_parseConnect(IsoPresentation* self, ByteBuffer* byteBuffer)\n{\n    uint8_t* buffer = byteBuffer->buffer;\n    int maxBufPos = byteBuffer->size;\n    bool hasNormalModeParameters = false;\n\n    int bufPos = 0;\n\n    uint8_t cpTag = buffer[bufPos++];\n\n    if (cpTag != 0x31) {\n        if (DEBUG_PRES)\n            printf(\"PRES: not a CP type\\n\");\n        return 0;\n    }\n\n    int len;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: invalid message!\\n\");\n        return 0;\n    }\n\n    if (DEBUG_PRES)\n        printf(\"PRES: CPType with len %i\\n\", len);\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message!\\n\");\n            return 0;\n        }\n\n        switch (tag) {\n        case 0xa0: /* mode-selection */\n            {\n                if (buffer[bufPos++] != 0x80) {\n                    if (DEBUG_PRES)\n                        printf(\"PRES: mode-value of wrong type!\\n\");\n                    return 0;\n                }\n\n                bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n                if (bufPos < 0) {\n                    if (DEBUG_PRES)\n                        printf(\"PRES: invalid message!\\n\");\n                    return 0;\n                }\n\n                uint32_t modeSelector = BerDecoder_decodeUint32(buffer, len, bufPos);\n\n                if (DEBUG_PRES)\n                    printf(\"PRES: modesel %ui\\n\", modeSelector);\n\n                bufPos += len;\n            }\n            break;\n        case 0xa2: /* normal-mode-parameters */\n            bufPos = parseNormalModeParameters(self, buffer, len, bufPos);\n\n            if (bufPos < 0) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: error parsing normal-mode-parameters\\n\");\n                return 0;\n            }\n            else {\n                hasNormalModeParameters = true;\n            }\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default: /* unsupported element */\n            if (DEBUG_PRES)\n                printf(\"PRES: tag %i not recognized\\n\", tag);\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasNormalModeParameters == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: error - normal mode parameters are missing\\n\");\n\n        return 0;\n    }\n\n    return 1;\n}\n\nvoid\nIsoPresentation_createConnectPdu(IsoPresentation* self, IsoConnectionParameters parameters,\n        BufferChain buffer, BufferChain payload)\n{\n    self->acseContextId = 1;\n    self->mmsContextId = 3;\n    self->callingPresentationSelector = parameters->localPSelector;\n    self->calledPresentationSelector = parameters->remotePSelector;\n    createConnectPdu(self, buffer, payload);\n}\n\nvoid\nIsoPresentation_createAbortUserMessage(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int contentLength = 0;\n\n    contentLength = +encodeUserData(NULL, 0, payload, false, self->acseContextId);\n\n    contentLength += BerEncoder_determineLengthSize(contentLength) + 1;\n\n    uint8_t* buffer = writeBuffer->buffer;\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa0, contentLength, buffer, bufPos);\n\n    /* encode user data */\n    bufPos = encodeUserData(buffer, bufPos, payload, true, self->acseContextId);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payload->length;\n    writeBuffer->nextPart = payload;\n}\n\nvoid\nIsoPresentation_createCpaMessage(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int contentLength = 0;\n\n    /* mode-selector */\n    contentLength += 5;\n\n    int normalModeLength = 0;\n\n    normalModeLength += 6; /* responding-presentation-selector */\n\n    normalModeLength += 20; /* context-definition-result-list */\n\n    normalModeLength += encodeUserData(NULL, 0, payload, false, self->acseContextId);\n\n    contentLength += normalModeLength;\n\n    contentLength += BerEncoder_determineLengthSize(normalModeLength) + 1;\n\n    uint8_t* buffer = writeBuffer->buffer;\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0x31, contentLength, buffer, bufPos);\n\n    /* mode-selector */\n    bufPos = BerEncoder_encodeTL(0xa0, 3, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, 1, buffer, bufPos);\n    buffer[bufPos++] = 1; /* 1 = normal-mode */\n\n    /* normal-mode-parameters */\n    bufPos = BerEncoder_encodeTL(0xa2, normalModeLength, buffer, bufPos);\n\n    /* responding-presentation-selector */\n    bufPos = BerEncoder_encodeTL(0x83, 4, buffer, bufPos);\n    memcpy(buffer + bufPos, calledPresentationSelector, 4);\n    bufPos += 4;\n\n    /* context-definition-result-list */\n    bufPos = BerEncoder_encodeTL(0xa5, 18, buffer, bufPos);\n    bufPos = encodeAcceptBer(buffer, bufPos); /* accept for acse */\n    bufPos = encodeAcceptBer(buffer, bufPos); /* accept for mms */\n\n    /* encode user data */\n    bufPos = encodeUserData(buffer, bufPos, payload, true, self->acseContextId);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payload->length;\n    writeBuffer->nextPart = payload;\n}\n"], "fixing_code": ["/*\n *  iso_presentation.c\n *\n *  Copyright 2013-2022 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n\n#include \"iso_presentation.h\"\n#include \"stack_config.h\"\n#include \"ber_encoder.h\"\n#include \"ber_decode.h\"\n#include \"buffer_chain.h\"\n\n#if ((DEBUG_ISO_SERVER == 1) || (DEBUG_ISO_CLIENT == 1))\n#define DEBUG_PRES 1\n#else\n#define DEBUG_PRES 0\n#endif\n\n\nstatic uint8_t calledPresentationSelector[] = { 0x00, 0x00, 0x00, 0x01 };\n\nstatic uint8_t asn_id_as_acse[] = { 0x52, 0x01, 0x00, 0x01 };\n\nstatic uint8_t asn_id_mms[] = { 0x28, 0xca, 0x22, 0x02, 0x01 };\n\nstatic uint8_t ber_id[] = { 0x51, 0x01 };\n\nstatic int\nencodeAcceptBer(uint8_t* buffer, int bufPos)\n{\n    bufPos = BerEncoder_encodeTL(0x30, 7, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, 1, buffer, bufPos);\n    buffer[bufPos++] = 0;\n    bufPos = BerEncoder_encodeTL(0x81, 2, buffer, bufPos);\n    buffer[bufPos++] = 0x51;\n    buffer[bufPos++] = 0x01;\n\n    return bufPos;\n}\n\nstatic int\nencodeUserData(uint8_t* buffer, int bufPos,\n        BufferChain payload, bool encode, uint8_t contextId)\n{\n    int payloadLength = payload->length;\n\n    int encodedDataSetLength = 3; /* presentation-selector */\n\n    /* presentation-data */\n    encodedDataSetLength += payloadLength + 1;\n    encodedDataSetLength += BerEncoder_determineLengthSize(payloadLength);\n\n    int fullyEncodedDataLength = encodedDataSetLength;\n\n    fullyEncodedDataLength += BerEncoder_determineLengthSize(encodedDataSetLength) + 1;\n\n    if (encode) {\n        /* fully-encoded-data */\n        bufPos = BerEncoder_encodeTL(0x61, fullyEncodedDataLength, buffer, bufPos);\n        bufPos = BerEncoder_encodeTL(0x30, encodedDataSetLength, buffer, bufPos);\n\n        /* presentation-selector acse */\n        bufPos = BerEncoder_encodeTL(0x02, 1, buffer, bufPos);\n        buffer[bufPos++] = contextId;\n\n        /* presentation-data (= acse payload) */\n        bufPos = BerEncoder_encodeTL(0xa0, payloadLength, buffer, bufPos);\n\n        return bufPos;\n    }\n    else {\n        int encodedUserDataLength = fullyEncodedDataLength + 1;\n        encodedUserDataLength += BerEncoder_determineLengthSize(fullyEncodedDataLength);\n\n        return encodedUserDataLength;\n    }\n}\n\nstatic void\ncreateConnectPdu(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int contentLength = 0;\n    int i;\n\n    /* mode-selector */\n    contentLength += 5;\n\n    int normalModeLength = 0;\n\n    /* called- and calling-presentation-selector */\n    normalModeLength += 12;\n\n    int pclLength = 27; /* 35; */\n    pclLength += self->callingPresentationSelector.size;\n    pclLength += self->calledPresentationSelector.size;\n\n    normalModeLength += pclLength;\n\n    normalModeLength += encodeUserData(NULL, 0, payload, false, self->acseContextId);\n\n    normalModeLength += 2;\n\n    contentLength += normalModeLength;\n\n    contentLength += 1 + BerEncoder_determineLengthSize(normalModeLength);\n\n    uint8_t* buffer = writeBuffer->buffer;\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0x31, contentLength, buffer, bufPos);\n\n    /* mode-selector */\n    bufPos = BerEncoder_encodeTL(0xa0, 3, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, 1, buffer, bufPos);\n    buffer[bufPos++] = 1; /* 1 = normal-mode */\n\n    /* normal-mode-parameters */\n    bufPos = BerEncoder_encodeTL(0xa2, normalModeLength, buffer, bufPos);\n\n    /* calling-presentation-selector */\n    bufPos = BerEncoder_encodeTL(0x81, self->callingPresentationSelector.size, buffer, bufPos);\n    for (i = 0; i < self->callingPresentationSelector.size; i++)\n        buffer[bufPos++] = self->callingPresentationSelector.value[i];\n\n    /* called-presentation-selector */\n    bufPos = BerEncoder_encodeTL(0x82, self->calledPresentationSelector.size, buffer, bufPos);\n    for (i = 0; i < self->calledPresentationSelector.size; i++)\n        buffer[bufPos++] = self->calledPresentationSelector.value[i];\n\n    /* presentation-context-id list */\n    bufPos = BerEncoder_encodeTL(0xa4, 35, buffer, bufPos);\n\n    /* acse context list item */\n    bufPos = BerEncoder_encodeTL(0x30, 15, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, 1, buffer, bufPos);\n    buffer[bufPos++] = 1;\n\n    bufPos = BerEncoder_encodeTL(0x06, 4, buffer, bufPos);\n    memcpy(buffer + bufPos, asn_id_as_acse, 4);\n    bufPos += 4;\n\n    bufPos = BerEncoder_encodeTL(0x30, 4, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x06, 2, buffer, bufPos);\n    memcpy(buffer + bufPos, ber_id, 2);\n    bufPos += 2;\n\n    /* mms context list item */\n    bufPos = BerEncoder_encodeTL(0x30, 16, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, 1, buffer, bufPos);\n    buffer[bufPos++] = 3;\n\n    bufPos = BerEncoder_encodeTL(0x06, 5, buffer, bufPos);\n    memcpy(buffer + bufPos, asn_id_mms, 5);\n    bufPos += 5;\n\n    bufPos = BerEncoder_encodeTL(0x30, 4, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x06, 2, buffer, bufPos);\n    memcpy(buffer + bufPos, ber_id, 2);\n    bufPos += 2;\n\n    /* encode user data */\n    bufPos = encodeUserData(buffer, bufPos, payload, true, self->acseContextId);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payload->length;\n    writeBuffer->nextPart = payload;\n}\n\nstatic int\nparseFullyEncodedData(IsoPresentation* self, uint8_t* buffer, int len, int bufPos)\n{\n    int presentationSelector = -1;\n    bool userDataPresent = false;\n\n    int endPos = bufPos + len;\n\n    if (buffer[bufPos++] != 0x30) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data parse error\\n\");\n        return -1;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: wrong parameter length\\n\");\n        return -1;\n    }\n\n    endPos = bufPos + len;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x02: /* presentation-context-identifier */\n            if (DEBUG_PRES)\n                printf(\"PRES: presentation-context-identifier\\n\");\n            {\n                presentationSelector = BerDecoder_decodeUint32(buffer, length, bufPos);\n                self->nextContextId = presentationSelector;\n                bufPos += length;\n            }\n            break;\n\n        case 0x06: /* transfer-syntax-name */\n            bufPos += length;\n            break;\n\n        case 0xa0:\n            if (DEBUG_PRES)\n                printf(\"PRES: fully-encoded-data\\n\");\n\n            userDataPresent = true;\n\n            self->nextPayload.buffer = buffer + bufPos;\n            self->nextPayload.size = length;\n\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: fed: unknown tag %02x\\n\", tag);\n\n            bufPos += length;\n            break;\n        }\n    }\n\n    if (!userDataPresent) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data not present\\n\");\n        return -1;\n    }\n\n    return bufPos;\n}\n\nstatic int\nparsePCDLEntry(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    int contextId = -1;\n    bool isAcse = false;\n    bool isMms = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: Invalid PDU\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x02: /* presentation-context-identifier */\n            contextId = BerDecoder_decodeUint32(buffer, len, bufPos);\n            bufPos += len;\n            break;\n\n        case 0x06: /* abstract-syntax-name */\n            if (DEBUG_PRES)\n                printf(\"PRES: abstract-syntax-name with len %i\\n\", len);\n\n            if (len == 5) {\n                if (memcmp(buffer + bufPos, asn_id_mms, 5) == 0)\n                    isMms = true;\n            }\n            else if (len == 4) {\n                if (memcmp(buffer + bufPos, asn_id_as_acse, 4) == 0)\n                    isAcse = true;\n            }\n\n            bufPos += len;\n\n            break;\n\n        case 0x30: /* transfer-syntax-name */\n            if (DEBUG_PRES)\n                printf(\"PRES: ignore transfer-syntax-name\\n\");\n\n            bufPos += len;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in presentation-context-definition-list-entry\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (contextId < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: ContextId not defined!\\n\");\n        return -1;\n    }\n\n    if ((isAcse == false) && (isMms == false)) {\n        if (DEBUG_PRES)\n            printf(\"PRES: not an ACSE or MMS context definition\\n\");\n\n        return -1;\n    }\n\n    if (isMms) {\n        self->mmsContextId = (uint8_t) contextId;\n        if (DEBUG_PRES)\n            printf(\"PRES: MMS context id is %i\\n\", contextId);\n    }\n    else {\n        self->acseContextId = (uint8_t) contextId;\n        if (DEBUG_PRES)\n            printf(\"PRES: ACSE context id is %i\\n\", contextId);\n    }\n\n    return bufPos;\n}\n\nstatic int\nparsePresentationContextDefinitionList(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n        if (bufPos < 0)\n            return -1;\n\n        switch (tag) {\n        case 0x30:\n            if (DEBUG_PRES)\n                printf(\"PRES: parse pcd entry\\n\");\n            bufPos = parsePCDLEntry(self, buffer, len, bufPos);\n            if (bufPos < 0)\n                return -1;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in presentation-context-definition-list\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    return bufPos;\n}\n\nstatic int\nparseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    self->calledPresentationSelector.size = 0;\n    self->callingPresentationSelector.size = 0;\n\n    bool hasUserData = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        if (bufPos == endPos) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message\\n\");\n            return -1;\n        }\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x81: /* calling-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: calling-presentation-sel too large\\n\");\n            }\n            else {\n                self->callingPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->callingPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x82: /* called-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: called-presentation-sel too large\\n\");\n            }\n            else {\n                self->calledPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->calledPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x83: /* responding-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: responding-presentation-sel too large\\n\");\n            }\n\n            bufPos += len;\n            break;\n\n        case 0xa4: /* presentation-context-definition list */\n            if (DEBUG_PRES)\n                printf(\"PRES: pcd list\\n\");\n            bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            break;\n\n        case 0xa5: /* context-definition-result-list */\n\n            bufPos += len;\n            break;\n\n        case 0x61: /* user data */\n            if (DEBUG_PRES)\n                printf(\"PRES: user-data\\n\");\n\n            bufPos = parseFullyEncodedData(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            if (self->nextPayload.size > 0)\n                hasUserData = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in normal-mode\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasUserData == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data is missing\\n\");\n\n        return -1;\n    }\n\n    return bufPos;\n}\n\nint\nIsoPresentation_parseAcceptMessage(IsoPresentation* self, ByteBuffer* byteBuffer)\n{\n    uint8_t* buffer = byteBuffer->buffer;\n    int maxBufPos = byteBuffer->size;\n\n    int bufPos = 0;\n\n    uint8_t cpTag = buffer[bufPos++];\n\n    if (cpTag != 0x31) {\n        if (DEBUG_PRES)\n            printf(\"PRES: not a CPA message\\n\");\n        return 0;\n    }\n\n    int len;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: Invalid message\\n\");\n        return 0;\n    }\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return 0;\n        }\n\n        switch (tag) {\n        case 0xa0: /* mode-selector */\n            bufPos += len; /* ignore content since only normal mode is allowed */\n            break;\n        case 0xa2: /* normal-mode-parameters */\n            bufPos = parseNormalModeParameters(self, buffer, len, bufPos);\n\n            if (bufPos < 0) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: error parsing normal-mode-parameters\\n\");\n                return 0;\n            }\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: CPA unknown tag %i\\n\", tag);\n            bufPos += len;\n            break;\n        }\n    }\n\n    return 1;\n}\n\nvoid\nIsoPresentation_init(IsoPresentation* self)\n{\n    (void)self;\n}\n\nvoid\nIsoPresentation_createUserData(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int bufPos = 0;\n    uint8_t* buffer = writeBuffer->buffer;\n\n    int payloadLength = payload->length;\n\n    int userDataLengthFieldSize = BerEncoder_determineLengthSize(payloadLength);\n    ;\n    int pdvListLength = payloadLength + (userDataLengthFieldSize + 4);\n\n    int pdvListLengthFieldSize = BerEncoder_determineLengthSize(pdvListLength);\n    int presentationLength = pdvListLength + (pdvListLengthFieldSize + 1);\n\n    bufPos = BerEncoder_encodeTL(0x61, presentationLength, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, pdvListLength, buffer, bufPos);\n\n    buffer[bufPos++] = (uint8_t) 0x02;\n    buffer[bufPos++] = (uint8_t) 0x01;\n    buffer[bufPos++] = (uint8_t) self->mmsContextId; /* mms context id */\n\n    bufPos = BerEncoder_encodeTL(0xa0, payloadLength, buffer, bufPos);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payloadLength;\n    writeBuffer->nextPart = payload;\n}\n\nvoid\nIsoPresentation_createUserDataACSE(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int bufPos = 0;\n    uint8_t* buffer = writeBuffer->buffer;\n\n    int payloadLength = payload->length;\n\n    int userDataLengthFieldSize = BerEncoder_determineLengthSize(payloadLength);\n    ;\n    int pdvListLength = payloadLength + (userDataLengthFieldSize + 4);\n\n    int pdvListLengthFieldSize = BerEncoder_determineLengthSize(pdvListLength);\n    int presentationLength = pdvListLength + (pdvListLengthFieldSize + 1);\n\n    bufPos = BerEncoder_encodeTL(0x61, presentationLength, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, pdvListLength, buffer, bufPos);\n\n    buffer[bufPos++] = (uint8_t) 0x02;\n    buffer[bufPos++] = (uint8_t) 0x01;\n    buffer[bufPos++] = (uint8_t) self->acseContextId; /* ACSE context id */\n\n    bufPos = BerEncoder_encodeTL(0xa0, payloadLength, buffer, bufPos);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payloadLength;\n    writeBuffer->nextPart = payload;\n}\n\nint\nIsoPresentation_parseUserData(IsoPresentation* self, ByteBuffer* readBuffer)\n{\n    uint8_t* buffer = readBuffer->buffer;\n    int maxBufPos = readBuffer->size;\n    bool hasAbstractSyntaxName = false;\n\n    int bufPos = 0;\n\n    if (maxBufPos < 9)\n        return 0;\n\n    if (buffer[bufPos++] != 0x61)\n        return 0;\n\n    int len;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: invalid message!\\n\");\n        return 0;\n    }\n\n    if (buffer[bufPos++] != 0x30)\n        return 0;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: invalid message!\\n\");\n        return 0;\n    }\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        uint8_t lenField = buffer[bufPos];\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return 0;\n        }\n\n        switch (tag) {\n        case 0x02: /* abstract-syntax-name */\n            self->nextContextId = buffer[bufPos];\n            hasAbstractSyntaxName = true;\n            bufPos += len;\n            break;\n\n        case 0x06: /* transfer-syntax-name */\n            {\n                /* check if basic-encoding (2.1.1 - 51 01) */\n                if ((buffer[bufPos] != 0x51) || (buffer[bufPos + 1] != 0x01)) {\n                    if (DEBUG_PRES) {\n                        printf(\"PRES: unknown transfer-syntax-name\\n\");\n                    }\n\n                    return 0;\n                }\n\n                bufPos += len;\n            }\n            break;\n\n\n        case 0xa0: /* presentation data */\n            {\n                if (hasAbstractSyntaxName == false) {\n                    if (DEBUG_PRES)\n                        printf(\"PRES: abstract-syntax-name missing!\\n\");\n\n                    return 0;\n                }\n\n                int userDataLength = len;\n\n                if (lenField == 0x80)\n                    userDataLength = userDataLength - 2;\n\n                ByteBuffer_wrap(&(self->nextPayload), buffer + bufPos, userDataLength, userDataLength);\n\n                return 1;\n            }\n            break;\n        }\n    }\n\n    return 0;\n}\n\nint\nIsoPresentation_parseConnect(IsoPresentation* self, ByteBuffer* byteBuffer)\n{\n    uint8_t* buffer = byteBuffer->buffer;\n    int maxBufPos = byteBuffer->size;\n    bool hasNormalModeParameters = false;\n\n    int bufPos = 0;\n\n    uint8_t cpTag = buffer[bufPos++];\n\n    if (cpTag != 0x31) {\n        if (DEBUG_PRES)\n            printf(\"PRES: not a CP type\\n\");\n        return 0;\n    }\n\n    int len;\n\n    bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n    if (bufPos < 0) {\n        if (DEBUG_PRES)\n            printf(\"PRES: invalid message!\\n\");\n        return 0;\n    }\n\n    if (DEBUG_PRES)\n        printf(\"PRES: CPType with len %i\\n\", len);\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message!\\n\");\n            return 0;\n        }\n\n        switch (tag) {\n        case 0xa0: /* mode-selection */\n            {\n                if (buffer[bufPos++] != 0x80) {\n                    if (DEBUG_PRES)\n                        printf(\"PRES: mode-value of wrong type!\\n\");\n                    return 0;\n                }\n\n                bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, maxBufPos);\n\n                if (bufPos < 0) {\n                    if (DEBUG_PRES)\n                        printf(\"PRES: invalid message!\\n\");\n                    return 0;\n                }\n\n                uint32_t modeSelector = BerDecoder_decodeUint32(buffer, len, bufPos);\n\n                if (DEBUG_PRES)\n                    printf(\"PRES: modesel %ui\\n\", modeSelector);\n\n                bufPos += len;\n            }\n            break;\n        case 0xa2: /* normal-mode-parameters */\n            bufPos = parseNormalModeParameters(self, buffer, len, bufPos);\n\n            if (bufPos < 0) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: error parsing normal-mode-parameters\\n\");\n                return 0;\n            }\n            else {\n                hasNormalModeParameters = true;\n            }\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default: /* unsupported element */\n            if (DEBUG_PRES)\n                printf(\"PRES: tag %i not recognized\\n\", tag);\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasNormalModeParameters == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: error - normal mode parameters are missing\\n\");\n\n        return 0;\n    }\n\n    return 1;\n}\n\nvoid\nIsoPresentation_createConnectPdu(IsoPresentation* self, IsoConnectionParameters parameters,\n        BufferChain buffer, BufferChain payload)\n{\n    self->acseContextId = 1;\n    self->mmsContextId = 3;\n    self->callingPresentationSelector = parameters->localPSelector;\n    self->calledPresentationSelector = parameters->remotePSelector;\n    createConnectPdu(self, buffer, payload);\n}\n\nvoid\nIsoPresentation_createAbortUserMessage(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int contentLength = 0;\n\n    contentLength = +encodeUserData(NULL, 0, payload, false, self->acseContextId);\n\n    contentLength += BerEncoder_determineLengthSize(contentLength) + 1;\n\n    uint8_t* buffer = writeBuffer->buffer;\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa0, contentLength, buffer, bufPos);\n\n    /* encode user data */\n    bufPos = encodeUserData(buffer, bufPos, payload, true, self->acseContextId);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payload->length;\n    writeBuffer->nextPart = payload;\n}\n\nvoid\nIsoPresentation_createCpaMessage(IsoPresentation* self, BufferChain writeBuffer, BufferChain payload)\n{\n    int contentLength = 0;\n\n    /* mode-selector */\n    contentLength += 5;\n\n    int normalModeLength = 0;\n\n    normalModeLength += 6; /* responding-presentation-selector */\n\n    normalModeLength += 20; /* context-definition-result-list */\n\n    normalModeLength += encodeUserData(NULL, 0, payload, false, self->acseContextId);\n\n    contentLength += normalModeLength;\n\n    contentLength += BerEncoder_determineLengthSize(normalModeLength) + 1;\n\n    uint8_t* buffer = writeBuffer->buffer;\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0x31, contentLength, buffer, bufPos);\n\n    /* mode-selector */\n    bufPos = BerEncoder_encodeTL(0xa0, 3, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, 1, buffer, bufPos);\n    buffer[bufPos++] = 1; /* 1 = normal-mode */\n\n    /* normal-mode-parameters */\n    bufPos = BerEncoder_encodeTL(0xa2, normalModeLength, buffer, bufPos);\n\n    /* responding-presentation-selector */\n    bufPos = BerEncoder_encodeTL(0x83, 4, buffer, bufPos);\n    memcpy(buffer + bufPos, calledPresentationSelector, 4);\n    bufPos += 4;\n\n    /* context-definition-result-list */\n    bufPos = BerEncoder_encodeTL(0xa5, 18, buffer, bufPos);\n    bufPos = encodeAcceptBer(buffer, bufPos); /* accept for acse */\n    bufPos = encodeAcceptBer(buffer, bufPos); /* accept for mms */\n\n    /* encode user data */\n    bufPos = encodeUserData(buffer, bufPos, payload, true, self->acseContextId);\n\n    writeBuffer->partLength = bufPos;\n    writeBuffer->length = bufPos + payload->length;\n    writeBuffer->nextPart = payload;\n}\n"], "filenames": ["src/mms/iso_presentation/iso_presentation.c"], "buggy_code_start_loc": [471], "buggy_code_end_loc": [471], "fixing_code_start_loc": [472], "fixing_code_end_loc": [476], "type": "CWE-835", "message": "A denial of service vulnerability exists in the parseNormalModeParameters functionality of MZ Automation GmbH libiec61850 1.5.0. A specially-crafted series of network requests can lead to denial of service. An attacker can send a sequence of malformed iec61850 messages to trigger this vulnerability.", "other": {"cve": {"id": "CVE-2022-21159", "sourceIdentifier": "talos-cna@cisco.com", "published": "2022-04-15T16:15:07.720", "lastModified": "2022-04-25T16:10:15.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A denial of service vulnerability exists in the parseNormalModeParameters functionality of MZ Automation GmbH libiec61850 1.5.0. A specially-crafted series of network requests can lead to denial of service. An attacker can send a sequence of malformed iec61850 messages to trigger this vulnerability."}, {"lang": "es", "value": "Se presenta Una vulnerabilidad de Denegaci\u00f3n de Servicio en la funcionalidad parseNormalModeParameters de MZ Automation GmbH libiec61850 versi\u00f3n 1.5.0. Una serie de peticiones de red especialmente dise\u00f1adas puede conllevar a una denegaci\u00f3n de servicio. Un atacante puede enviar una secuencia de mensajes iec61850 malformados para desencadenar esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "talos-cna@cisco.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "talos-cna@cisco.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mz-automation:libiec61850:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B45DE37F-A886-4609-AD93-FBBBE5895EF3"}]}]}], "references": [{"url": "https://github.com/mz-automation/libiec61850/commit/cfa94cbf10302bedc779703f874ee2e8387a0721", "source": "talos-cna@cisco.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://talosintelligence.com/vulnerability_reports/TALOS-2022-1467", "source": "talos-cna@cisco.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.talosintelligence.com/vulnerability_reports/TALOS-2022-1467", "source": "talos-cna@cisco.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mz-automation/libiec61850/commit/cfa94cbf10302bedc779703f874ee2e8387a0721"}}