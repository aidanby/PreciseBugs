{"buggy_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n\n#include <rdr/ZlibInStream.h>\n#include <rdr/Exception.h>\n#include <zlib.h>\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nZlibInStream::ZlibInStream(int bufSize_)\n  : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),\n    zs(NULL), bytesIn(0)\n{\n  ptr = end = start = new U8[bufSize];\n  init();\n}\n\nZlibInStream::~ZlibInStream()\n{\n  deinit();\n  delete [] start;\n}\n\nvoid ZlibInStream::setUnderlying(InStream* is, int bytesIn_)\n{\n  underlying = is;\n  bytesIn = bytesIn_;\n  ptr = end = start;\n}\n\nint ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nvoid ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; // throw away any data\n  }\n  underlying = 0;\n}\n\nvoid ZlibInStream::reset()\n{\n  deinit();\n  init();\n}\n\nvoid ZlibInStream::init()\n{\n  assert(zs == NULL);\n\n  zs = new z_stream;\n  zs->zalloc    = Z_NULL;\n  zs->zfree     = Z_NULL;\n  zs->opaque    = Z_NULL;\n  zs->next_in   = Z_NULL;\n  zs->avail_in  = 0;\n  if (inflateInit(zs) != Z_OK) {\n    delete zs;\n    zs = NULL;\n    throw Exception(\"ZlibInStream: inflateInit failed\");\n  }\n}\n\nvoid ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}\n\nint ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n// decompress() calls the decompressor once.  Note that this won't necessarily\n// generate any output data - it may just consume some input data.  Returns\n// false if wait is false and we would block on the underlying stream.\n\nbool ZlibInStream::decompress(bool wait)\n{\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZlibInStream streams from a compressed data stream (\"underlying\"),\n// decompressing with zlib on the fly.\n//\n\n#ifndef __RDR_ZLIBINSTREAM_H__\n#define __RDR_ZLIBINSTREAM_H__\n\n#include <rdr/InStream.h>\n\nstruct z_stream_s;\n\nnamespace rdr {\n\n  class ZlibInStream : public InStream {\n\n  public:\n\n    ZlibInStream(int bufSize=0);\n    virtual ~ZlibInStream();\n\n    void setUnderlying(InStream* is, int bytesIn);\n    void removeUnderlying();\n    int pos();\n    void reset();\n\n  private:\n\n    void init();\n    void deinit();\n\n    int overrun(int itemSize, int nItems, bool wait);\n    bool decompress(bool wait);\n\n    InStream* underlying;\n    int bufSize;\n    int offset;\n    z_stream_s* zs;\n    int bytesIn;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2009-2019 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n#include <stdio.h>\n\n#include <rdr/InStream.h>\n#include <rdr/ZlibInStream.h>\n\n#include <rfb/msgTypes.h>\n#include <rfb/clipboardTypes.h>\n#include <rfb/Exception.h>\n#include <rfb/LogWriter.h>\n#include <rfb/util.h>\n#include <rfb/CMsgHandler.h>\n#include <rfb/CMsgReader.h>\n\nstatic rfb::LogWriter vlog(\"CMsgReader\");\n\nstatic rfb::IntParameter maxCutText(\"MaxCutText\", \"Maximum permitted length of an incoming clipboard update\", 256*1024);\n\nusing namespace rfb;\n\nCMsgReader::CMsgReader(CMsgHandler* handler_, rdr::InStream* is_)\n  : imageBufIdealSize(0), handler(handler_), is(is_),\n    nUpdateRectsLeft(0)\n{\n}\n\nCMsgReader::~CMsgReader()\n{\n}\n\nvoid CMsgReader::readServerInit()\n{\n  int width = is->readU16();\n  int height = is->readU16();\n  PixelFormat pf;\n  pf.read(is);\n  CharArray name(is->readString());\n  handler->serverInit(width, height, pf, name.buf);\n}\n\nvoid CMsgReader::readMsg()\n{\n  if (nUpdateRectsLeft == 0) {\n    int type = is->readU8();\n\n    switch (type) {\n    case msgTypeSetColourMapEntries:\n      readSetColourMapEntries();\n      break;\n    case msgTypeBell:\n      readBell();\n      break;\n    case msgTypeServerCutText:\n      readServerCutText();\n      break;\n    case msgTypeFramebufferUpdate:\n      readFramebufferUpdate();\n      break;\n    case msgTypeServerFence:\n      readFence();\n      break;\n    case msgTypeEndOfContinuousUpdates:\n      readEndOfContinuousUpdates();\n      break;\n    default:\n      vlog.error(\"unknown message type %d\", type);\n      throw Exception(\"unknown message type\");\n    }\n  } else {\n    int x = is->readU16();\n    int y = is->readU16();\n    int w = is->readU16();\n    int h = is->readU16();\n    int encoding = is->readS32();\n\n    switch (encoding) {\n    case pseudoEncodingLastRect:\n      nUpdateRectsLeft = 1;     // this rectangle is the last one\n      break;\n    case pseudoEncodingXCursor:\n      readSetXCursor(w, h, Point(x,y));\n      break;\n    case pseudoEncodingCursor:\n      readSetCursor(w, h, Point(x,y));\n      break;\n    case pseudoEncodingCursorWithAlpha:\n      readSetCursorWithAlpha(w, h, Point(x,y));\n      break;\n    case pseudoEncodingVMwareCursor:\n      readSetVMwareCursor(w, h, Point(x,y));\n      break;\n    case pseudoEncodingDesktopName:\n      readSetDesktopName(x, y, w, h);\n      break;\n    case pseudoEncodingDesktopSize:\n      handler->setDesktopSize(w, h);\n      break;\n    case pseudoEncodingExtendedDesktopSize:\n      readExtendedDesktopSize(x, y, w, h);\n      break;\n    case pseudoEncodingLEDState:\n      readLEDState();\n      break;\n    case pseudoEncodingVMwareLEDState:\n      readVMwareLEDState();\n      break;\n    case pseudoEncodingQEMUKeyEvent:\n      handler->supportsQEMUKeyEvent();\n      break;\n    default:\n      readRect(Rect(x, y, x+w, y+h), encoding);\n      break;\n    };\n\n    nUpdateRectsLeft--;\n    if (nUpdateRectsLeft == 0)\n      handler->framebufferUpdateEnd();\n  }\n}\n\nvoid CMsgReader::readSetColourMapEntries()\n{\n  is->skip(1);\n  int firstColour = is->readU16();\n  int nColours = is->readU16();\n  rdr::U16Array rgbs(nColours * 3);\n  for (int i = 0; i < nColours * 3; i++)\n    rgbs.buf[i] = is->readU16();\n  handler->setColourMapEntries(firstColour, nColours, rgbs.buf);\n}\n\nvoid CMsgReader::readBell()\n{\n  handler->bell();\n}\n\nvoid CMsgReader::readServerCutText()\n{\n  is->skip(3);\n  rdr::U32 len = is->readU32();\n\n  if (len & 0x80000000) {\n    rdr::S32 slen = len;\n    slen = -slen;\n    readExtendedClipboard(slen);\n    return;\n  }\n\n  if (len > (size_t)maxCutText) {\n    is->skip(len);\n    vlog.error(\"cut text too long (%d bytes) - ignoring\",len);\n    return;\n  }\n  CharArray ca(len);\n  is->readBytes(ca.buf, len);\n  CharArray filtered(convertLF(ca.buf, len));\n  handler->serverCutText(filtered.buf);\n}\n\nvoid CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.removeUnderlying();\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}\n\nvoid CMsgReader::readFence()\n{\n  rdr::U32 flags;\n  rdr::U8 len;\n  char data[64];\n\n  is->skip(3);\n\n  flags = is->readU32();\n\n  len = is->readU8();\n  if (len > sizeof(data)) {\n    vlog.error(\"Ignoring fence with too large payload\");\n    is->skip(len);\n    return;\n  }\n\n  is->readBytes(data, len);\n\n  handler->fence(flags, len, data);\n}\n\nvoid CMsgReader::readEndOfContinuousUpdates()\n{\n  handler->endOfContinuousUpdates();\n}\n\nvoid CMsgReader::readFramebufferUpdate()\n{\n  is->skip(1);\n  nUpdateRectsLeft = is->readU16();\n  handler->framebufferUpdateStart();\n}\n\nvoid CMsgReader::readRect(const Rect& r, int encoding)\n{\n  if ((r.br.x > handler->server.width()) ||\n      (r.br.y > handler->server.height())) {\n    vlog.error(\"Rect too big: %dx%d at %d,%d exceeds %dx%d\",\n\t    r.width(), r.height(), r.tl.x, r.tl.y,\n            handler->server.width(), handler->server.height());\n    throw Exception(\"Rect too big\");\n  }\n\n  if (r.is_empty())\n    vlog.error(\"zero size rect\");\n\n  handler->dataRect(r, encoding);\n}\n\nvoid CMsgReader::readSetXCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  rdr::U8Array rgba(width*height*4);\n\n  if (width * height > 0) {\n    rdr::U8 pr, pg, pb;\n    rdr::U8 sr, sg, sb;\n    int data_len = ((width+7)/8) * height;\n    int mask_len = ((width+7)/8) * height;\n    rdr::U8Array data(data_len);\n    rdr::U8Array mask(mask_len);\n\n    int x, y;\n    rdr::U8* out;\n\n    pr = is->readU8();\n    pg = is->readU8();\n    pb = is->readU8();\n\n    sr = is->readU8();\n    sg = is->readU8();\n    sb = is->readU8();\n\n    is->readBytes(data.buf, data_len);\n    is->readBytes(mask.buf, mask_len);\n\n    int maskBytesPerRow = (width+7)/8;\n    out = rgba.buf;\n    for (y = 0;y < height;y++) {\n      for (x = 0;x < width;x++) {\n        int byte = y * maskBytesPerRow + x / 8;\n        int bit = 7 - x % 8;\n\n        if (data.buf[byte] & (1 << bit)) {\n          out[0] = pr;\n          out[1] = pg;\n          out[2] = pb;\n        } else {\n          out[0] = sr;\n          out[1] = sg;\n          out[2] = sb;\n        }\n\n        if (mask.buf[byte] & (1 << bit))\n          out[3] = 255;\n        else\n          out[3] = 0;\n\n        out += 4;\n      }\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}\n\nvoid CMsgReader::readSetCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  int data_len = width * height * (handler->server.pf().bpp/8);\n  int mask_len = ((width+7)/8) * height;\n  rdr::U8Array data(data_len);\n  rdr::U8Array mask(mask_len);\n\n  int x, y;\n  rdr::U8Array rgba(width*height*4);\n  rdr::U8* in;\n  rdr::U8* out;\n\n  is->readBytes(data.buf, data_len);\n  is->readBytes(mask.buf, mask_len);\n\n  int maskBytesPerRow = (width+7)/8;\n  in = data.buf;\n  out = rgba.buf;\n  for (y = 0;y < height;y++) {\n    for (x = 0;x < width;x++) {\n      int byte = y * maskBytesPerRow + x / 8;\n      int bit = 7 - x % 8;\n\n      handler->server.pf().rgbFromBuffer(out, in, 1);\n\n      if (mask.buf[byte] & (1 << bit))\n        out[3] = 255;\n      else\n        out[3] = 0;\n\n      in += handler->server.pf().bpp/8;\n      out += 4;\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}\n\nvoid CMsgReader::readSetCursorWithAlpha(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  int encoding;\n\n  const PixelFormat rgbaPF(32, 32, false, true, 255, 255, 255, 16, 8, 0);\n  ManagedPixelBuffer pb(rgbaPF, width, height);\n  PixelFormat origPF;\n\n  rdr::U8* buf;\n  int stride;\n\n  encoding = is->readS32();\n\n  origPF = handler->server.pf();\n  handler->server.setPF(rgbaPF);\n  handler->readAndDecodeRect(pb.getRect(), encoding, &pb);\n  handler->server.setPF(origPF);\n\n  // On-wire data has pre-multiplied alpha, but we store it\n  // non-pre-multiplied\n  buf = pb.getBufferRW(pb.getRect(), &stride);\n  assert(stride == width);\n\n  for (int i = 0;i < pb.area();i++) {\n    rdr::U8 alpha;\n\n    alpha = buf[3];\n    if (alpha == 0)\n      alpha = 1; // Avoid division by zero\n\n    buf[0] = (unsigned)buf[0] * 255/alpha;\n    buf[1] = (unsigned)buf[1] * 255/alpha;\n    buf[2] = (unsigned)buf[2] * 255/alpha;\n\n    buf += 4;\n  }\n\n  pb.commitBufferRW(pb.getRect());\n\n  handler->setCursor(width, height, hotspot,\n                     pb.getBuffer(pb.getRect(), &stride));\n}\n\nvoid CMsgReader::readSetVMwareCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  rdr::U8 type;\n\n  type = is->readU8();\n  is->skip(1);\n\n  if (type == 0) {\n    int len = width * height * (handler->server.pf().bpp/8);\n    rdr::U8Array andMask(len);\n    rdr::U8Array xorMask(len);\n\n    rdr::U8Array data(width*height*4);\n\n    rdr::U8* andIn;\n    rdr::U8* xorIn;\n    rdr::U8* out;\n    int Bpp;\n\n    is->readBytes(andMask.buf, len);\n    is->readBytes(xorMask.buf, len);\n\n    andIn = andMask.buf;\n    xorIn = xorMask.buf;\n    out = data.buf;\n    Bpp = handler->server.pf().bpp/8;\n    for (int y = 0;y < height;y++) {\n      for (int x = 0;x < width;x++) {\n        Pixel andPixel, xorPixel;\n\n        andPixel = handler->server.pf().pixelFromBuffer(andIn);\n        xorPixel = handler->server.pf().pixelFromBuffer(xorIn);\n        andIn += Bpp;\n        xorIn += Bpp;\n\n        if (andPixel == 0) {\n          rdr::U8 r, g, b;\n\n          // Opaque pixel\n\n          handler->server.pf().rgbFromPixel(xorPixel, &r, &g, &b);\n          *out++ = r;\n          *out++ = g;\n          *out++ = b;\n          *out++ = 0xff;\n        } else if (xorPixel == 0) {\n          // Fully transparent pixel\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n        } else if (andPixel == xorPixel) {\n          // Inverted pixel\n\n          // We don't really support this, so just turn the pixel black\n          // FIXME: Do an outline like WinVNC does?\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0xff;\n        } else {\n          // Partially transparent/inverted pixel\n\n          // We _really_ can't handle this, just make it black\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0xff;\n        }\n      }\n    }\n\n    handler->setCursor(width, height, hotspot, data.buf);\n  } else if (type == 1) {\n    rdr::U8Array data(width*height*4);\n\n    // FIXME: Is alpha premultiplied?\n    is->readBytes(data.buf, width*height*4);\n\n    handler->setCursor(width, height, hotspot, data.buf);\n  } else {\n    throw Exception(\"Unknown cursor type\");\n  }\n}\n\nvoid CMsgReader::readSetDesktopName(int x, int y, int w, int h)\n{\n  char* name = is->readString();\n\n  if (x || y || w || h) {\n    vlog.error(\"Ignoring DesktopName rect with non-zero position/size\");\n  } else {\n    handler->setName(name);\n  }\n\n  delete [] name;\n}\n\nvoid CMsgReader::readExtendedDesktopSize(int x, int y, int w, int h)\n{\n  unsigned int screens, i;\n  rdr::U32 id, flags;\n  int sx, sy, sw, sh;\n  ScreenSet layout;\n\n  screens = is->readU8();\n  is->skip(3);\n\n  for (i = 0;i < screens;i++) {\n    id = is->readU32();\n    sx = is->readU16();\n    sy = is->readU16();\n    sw = is->readU16();\n    sh = is->readU16();\n    flags = is->readU32();\n\n    layout.add_screen(Screen(id, sx, sy, sw, sh, flags));\n  }\n\n  handler->setExtendedDesktopSize(x, y, w, h, layout);\n}\n\nvoid CMsgReader::readLEDState()\n{\n  rdr::U8 state;\n\n  state = is->readU8();\n\n  handler->setLEDState(state);\n}\n\nvoid CMsgReader::readVMwareLEDState()\n{\n  rdr::U32 state;\n\n  state = is->readU32();\n\n  // As luck has it, this extension uses the same bit definitions,\n  // so no conversion required\n\n  handler->setLEDState(state);\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2009-2019 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n#include <stdio.h>\n\n#include <rdr/InStream.h>\n#include <rdr/ZlibInStream.h>\n\n#include <rfb/msgTypes.h>\n#include <rfb/qemuTypes.h>\n#include <rfb/clipboardTypes.h>\n#include <rfb/Exception.h>\n#include <rfb/util.h>\n#include <rfb/SMsgHandler.h>\n#include <rfb/SMsgReader.h>\n#include <rfb/Configuration.h>\n#include <rfb/LogWriter.h>\n\nusing namespace rfb;\n\nstatic LogWriter vlog(\"SMsgReader\");\n\nstatic IntParameter maxCutText(\"MaxCutText\", \"Maximum permitted length of an incoming clipboard update\", 256*1024);\n\nSMsgReader::SMsgReader(SMsgHandler* handler_, rdr::InStream* is_)\n  : handler(handler_), is(is_)\n{\n}\n\nSMsgReader::~SMsgReader()\n{\n}\n\nvoid SMsgReader::readClientInit()\n{\n  bool shared = is->readU8();\n  handler->clientInit(shared);\n}\n\nvoid SMsgReader::readMsg()\n{\n  int msgType = is->readU8();\n  switch (msgType) {\n  case msgTypeSetPixelFormat:\n    readSetPixelFormat();\n    break;\n  case msgTypeSetEncodings:\n    readSetEncodings();\n    break;\n  case msgTypeSetDesktopSize:\n    readSetDesktopSize();\n    break;\n  case msgTypeFramebufferUpdateRequest:\n    readFramebufferUpdateRequest();\n    break;\n  case msgTypeEnableContinuousUpdates:\n    readEnableContinuousUpdates();\n    break;\n  case msgTypeClientFence:\n    readFence();\n    break;\n  case msgTypeKeyEvent:\n    readKeyEvent();\n    break;\n  case msgTypePointerEvent:\n    readPointerEvent();\n    break;\n  case msgTypeClientCutText:\n    readClientCutText();\n    break;\n  case msgTypeQEMUClientMessage:\n    readQEMUMessage();\n    break;\n  default:\n    vlog.error(\"unknown message type %d\", msgType);\n    throw Exception(\"unknown message type\");\n  }\n}\n\nvoid SMsgReader::readSetPixelFormat()\n{\n  is->skip(3);\n  PixelFormat pf;\n  pf.read(is);\n  handler->setPixelFormat(pf);\n}\n\nvoid SMsgReader::readSetEncodings()\n{\n  is->skip(1);\n  int nEncodings = is->readU16();\n  rdr::S32Array encodings(nEncodings);\n  for (int i = 0; i < nEncodings; i++)\n    encodings.buf[i] = is->readU32();\n  handler->setEncodings(nEncodings, encodings.buf);\n}\n\nvoid SMsgReader::readSetDesktopSize()\n{\n  int width, height;\n  int screens, i;\n  rdr::U32 id, flags;\n  int sx, sy, sw, sh;\n  ScreenSet layout;\n\n  is->skip(1);\n\n  width = is->readU16();\n  height = is->readU16();\n\n  screens = is->readU8();\n  is->skip(1);\n\n  for (i = 0;i < screens;i++) {\n    id = is->readU32();\n    sx = is->readU16();\n    sy = is->readU16();\n    sw = is->readU16();\n    sh = is->readU16();\n    flags = is->readU32();\n\n    layout.add_screen(Screen(id, sx, sy, sw, sh, flags));\n  }\n\n  handler->setDesktopSize(width, height, layout);\n}\n\nvoid SMsgReader::readFramebufferUpdateRequest()\n{\n  bool inc = is->readU8();\n  int x = is->readU16();\n  int y = is->readU16();\n  int w = is->readU16();\n  int h = is->readU16();\n  handler->framebufferUpdateRequest(Rect(x, y, x+w, y+h), inc);\n}\n\nvoid SMsgReader::readEnableContinuousUpdates()\n{\n  bool enable;\n  int x, y, w, h;\n\n  enable = is->readU8();\n\n  x = is->readU16();\n  y = is->readU16();\n  w = is->readU16();\n  h = is->readU16();\n\n  handler->enableContinuousUpdates(enable, x, y, w, h);\n}\n\nvoid SMsgReader::readFence()\n{\n  rdr::U32 flags;\n  rdr::U8 len;\n  char data[64];\n\n  is->skip(3);\n\n  flags = is->readU32();\n\n  len = is->readU8();\n  if (len > sizeof(data)) {\n    vlog.error(\"Ignoring fence with too large payload\");\n    is->skip(len);\n    return;\n  }\n\n  is->readBytes(data, len);\n  \n  handler->fence(flags, len, data);\n}\n\nvoid SMsgReader::readKeyEvent()\n{\n  bool down = is->readU8();\n  is->skip(2);\n  rdr::U32 key = is->readU32();\n  handler->keyEvent(key, 0, down);\n}\n\nvoid SMsgReader::readPointerEvent()\n{\n  int mask = is->readU8();\n  int x = is->readU16();\n  int y = is->readU16();\n  handler->pointerEvent(Point(x, y), mask);\n}\n\n\nvoid SMsgReader::readClientCutText()\n{\n  is->skip(3);\n  rdr::U32 len = is->readU32();\n\n  if (len & 0x80000000) {\n    rdr::S32 slen = len;\n    slen = -slen;\n    readExtendedClipboard(slen);\n    return;\n  }\n\n  if (len > (size_t)maxCutText) {\n    is->skip(len);\n    vlog.error(\"Cut text too long (%d bytes) - ignoring\", len);\n    return;\n  }\n  CharArray ca(len);\n  is->readBytes(ca.buf, len);\n  CharArray filtered(convertLF(ca.buf, len));\n  handler->clientCutText(filtered.buf);\n}\n\nvoid SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.removeUnderlying();\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}\n\nvoid SMsgReader::readQEMUMessage()\n{\n  int subType = is->readU8();\n  switch (subType) {\n  case qemuExtendedKeyEvent:\n    readQEMUKeyEvent();\n    break;\n  default:\n    throw Exception(\"unknown QEMU submessage type %d\", subType);\n  }\n}\n\nvoid SMsgReader::readQEMUKeyEvent()\n{\n  bool down = is->readU16();\n  rdr::U32 keysym = is->readU32();\n  rdr::U32 keycode = is->readU32();\n  if (!keycode) {\n    vlog.error(\"Key event without keycode - ignoring\");\n    return;\n  }\n  handler->keyEvent(keysym, keycode, down);\n}\n", "/* Copyright (C) 2000-2003 Constantin Kaplinsky.  All Rights Reserved.\n * Copyright 2004-2005 Cendio AB.\n * Copyright 2009-2015 Pierre Ossman for Cendio AB\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n\n#include <rdr/InStream.h>\n#include <rdr/MemInStream.h>\n#include <rdr/OutStream.h>\n\n#include <rfb/ServerParams.h>\n#include <rfb/Exception.h>\n#include <rfb/PixelBuffer.h>\n#include <rfb/TightConstants.h>\n#include <rfb/TightDecoder.h>\n\nusing namespace rfb;\n\nstatic const int TIGHT_MAX_WIDTH = 2048;\nstatic const int TIGHT_MIN_TO_COMPRESS = 12;\n\n#define BPP 8\n#include <rfb/tightDecode.h>\n#undef BPP\n#define BPP 16\n#include <rfb/tightDecode.h>\n#undef BPP\n#define BPP 32\n#include <rfb/tightDecode.h>\n#undef BPP\n\nTightDecoder::TightDecoder() : Decoder(DecoderPartiallyOrdered)\n{\n}\n\nTightDecoder::~TightDecoder()\n{\n}\n\nvoid TightDecoder::readRect(const Rect& r, rdr::InStream* is,\n                            const ServerParams& server, rdr::OutStream* os)\n{\n  rdr::U8 comp_ctl;\n\n  comp_ctl = is->readU8();\n  os->writeU8(comp_ctl);\n\n  comp_ctl >>= 4;\n\n  // \"Fill\" compression type.\n  if (comp_ctl == tightFill) {\n    if (server.pf().is888())\n      os->copyBytes(is, 3);\n    else\n      os->copyBytes(is, server.pf().bpp/8);\n    return;\n  }\n\n  // \"JPEG\" compression type.\n  if (comp_ctl == tightJpeg) {\n    rdr::U32 len;\n\n    len = readCompact(is);\n    os->writeOpaque32(len);\n    os->copyBytes(is, len);\n    return;\n  }\n\n  // Quit on unsupported compression type.\n  if (comp_ctl > tightMaxSubencoding)\n    throw Exception(\"TightDecoder: bad subencoding value received\");\n\n  // \"Basic\" compression type.\n\n  int palSize = 0;\n\n  if (r.width() > TIGHT_MAX_WIDTH)\n    throw Exception(\"TightDecoder: too large rectangle (%d pixels)\", r.width());\n\n  // Possible palette\n  if ((comp_ctl & tightExplicitFilter) != 0) {\n    rdr::U8 filterId;\n\n    filterId = is->readU8();\n    os->writeU8(filterId);\n\n    switch (filterId) {\n    case tightFilterPalette:\n      palSize = is->readU8() + 1;\n      os->writeU8(palSize - 1);\n\n      if (server.pf().is888())\n        os->copyBytes(is, palSize * 3);\n      else\n        os->copyBytes(is, palSize * server.pf().bpp/8);\n      break;\n    case tightFilterGradient:\n      if (server.pf().bpp == 8)\n        throw Exception(\"TightDecoder: invalid BPP for gradient filter\");\n      break;\n    case tightFilterCopy:\n      break;\n    default:\n      throw Exception(\"TightDecoder: unknown filter code received\");\n    }\n  }\n\n  size_t rowSize, dataSize;\n\n  if (palSize != 0) {\n    if (palSize <= 2)\n      rowSize = (r.width() + 7) / 8;\n    else\n      rowSize = r.width();\n  } else if (server.pf().is888()) {\n    rowSize = r.width() * 3;\n  } else {\n    rowSize = r.width() * server.pf().bpp/8;\n  }\n\n  dataSize = r.height() * rowSize;\n\n  if (dataSize < TIGHT_MIN_TO_COMPRESS)\n    os->copyBytes(is, dataSize);\n  else {\n    rdr::U32 len;\n\n    len = readCompact(is);\n    os->writeOpaque32(len);\n    os->copyBytes(is, len);\n  }\n}\n\nbool TightDecoder::doRectsConflict(const Rect& rectA,\n                                   const void* bufferA,\n                                   size_t buflenA,\n                                   const Rect& rectB,\n                                   const void* bufferB,\n                                   size_t buflenB,\n                                   const ServerParams& server)\n{\n  rdr::U8 comp_ctl_a, comp_ctl_b;\n\n  assert(buflenA >= 1);\n  assert(buflenB >= 1);\n\n  comp_ctl_a = *(const rdr::U8*)bufferA;\n  comp_ctl_b = *(const rdr::U8*)bufferB;\n\n  // Resets or use of zlib pose the same problem, so merge them\n  if ((comp_ctl_a & 0x80) == 0x00)\n    comp_ctl_a |= 1 << ((comp_ctl_a >> 4) & 0x03);\n  if ((comp_ctl_b & 0x80) == 0x00)\n    comp_ctl_b |= 1 << ((comp_ctl_b >> 4) & 0x03);\n\n  if (((comp_ctl_a & 0x0f) & (comp_ctl_b & 0x0f)) != 0)\n    return true;\n\n  return false;\n}\n\nvoid TightDecoder::decodeRect(const Rect& r, const void* buffer,\n                              size_t buflen, const ServerParams& server,\n                              ModifiablePixelBuffer* pb)\n{\n  const rdr::U8* bufptr;\n  const PixelFormat& pf = server.pf();\n\n  rdr::U8 comp_ctl;\n\n  bufptr = (const rdr::U8*)buffer;\n\n  assert(buflen >= 1);\n\n  comp_ctl = *bufptr;\n  bufptr += 1;\n  buflen -= 1;\n\n  // Reset zlib streams if we are told by the server to do so.\n  for (int i = 0; i < 4; i++) {\n    if (comp_ctl & 1) {\n      zis[i].reset();\n    }\n    comp_ctl >>= 1;\n  }\n\n  // \"Fill\" compression type.\n  if (comp_ctl == tightFill) {\n    if (pf.is888()) {\n      rdr::U8 pix[4];\n\n      assert(buflen >= 3);\n\n      pf.bufferFromRGB(pix, bufptr, 1);\n      pb->fillRect(pf, r, pix);\n    } else {\n      assert(buflen >= (size_t)pf.bpp/8);\n      pb->fillRect(pf, r, bufptr);\n    }\n    return;\n  }\n\n  // \"JPEG\" compression type.\n  if (comp_ctl == tightJpeg) {\n    rdr::U32 len;\n\n    int stride;\n    rdr::U8 *buf;\n\n    JpegDecompressor jd;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    // We always use direct decoding with JPEG images\n    buf = pb->getBufferRW(r, &stride);\n    jd.decompress(bufptr, len, buf, stride, r, pb->getPF());\n    pb->commitBufferRW(r);\n    return;\n  }\n\n  // Quit on unsupported compression type.\n  assert(comp_ctl <= tightMaxSubencoding);\n\n  // \"Basic\" compression type.\n\n  int palSize = 0;\n  rdr::U8 palette[256 * 4];\n  bool useGradient = false;\n\n  if ((comp_ctl & tightExplicitFilter) != 0) {\n    rdr::U8 filterId;\n\n    assert(buflen >= 1);\n\n    filterId = *bufptr;\n    bufptr += 1;\n    buflen -= 1;\n\n    switch (filterId) {\n    case tightFilterPalette:\n      assert(buflen >= 1);\n\n      palSize = *bufptr + 1;\n      bufptr += 1;\n      buflen -= 1;\n\n      if (pf.is888()) {\n        size_t len = palSize * 3;\n        rdr::U8Array tightPalette(len);\n\n        assert(buflen >= len);\n\n        memcpy(tightPalette.buf, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n\n        pf.bufferFromRGB(palette, tightPalette.buf, palSize);\n      } else {\n        size_t len;\n\n        len = palSize * pf.bpp/8;\n\n        assert(buflen >= len);\n\n        memcpy(palette, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n      }\n      break;\n    case tightFilterGradient:\n      useGradient = true;\n      break;\n    case tightFilterCopy:\n      break;\n    default:\n      assert(false);\n    }\n  }\n\n  // Determine if the data should be decompressed or just copied.\n  size_t rowSize, dataSize;\n  rdr::U8* netbuf;\n\n  netbuf = NULL;\n\n  if (palSize != 0) {\n    if (palSize <= 2)\n      rowSize = (r.width() + 7) / 8;\n    else\n      rowSize = r.width();\n  } else if (pf.is888()) {\n    rowSize = r.width() * 3;\n  } else {\n    rowSize = r.width() * pf.bpp/8;\n  }\n\n  dataSize = r.height() * rowSize;\n\n  if (dataSize < TIGHT_MIN_TO_COMPRESS)\n    assert(buflen >= dataSize);\n  else {\n    rdr::U32 len;\n    int streamId;\n    rdr::MemInStream* ms;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    assert(buflen >= len);\n\n    streamId = comp_ctl & 0x03;\n    ms = new rdr::MemInStream(bufptr, len);\n    zis[streamId].setUnderlying(ms, len);\n\n    // Allocate buffer and decompress the data\n    netbuf = new rdr::U8[dataSize];\n\n    zis[streamId].readBytes(netbuf, dataSize);\n\n    zis[streamId].removeUnderlying();\n    delete ms;\n\n    bufptr = netbuf;\n    buflen = dataSize;\n  }\n\n  // Time to decode the actual data\n  bool directDecode;\n\n  rdr::U8* outbuf;\n  int stride;\n\n  if (pb->getPF().equal(pf)) {\n    // Decode directly into the framebuffer (fast path)\n    directDecode = true;\n  } else {\n    // Decode into an intermediate buffer and use pixel translation\n    directDecode = false;\n  }\n\n  if (directDecode)\n    outbuf = pb->getBufferRW(r, &stride);\n  else {\n    outbuf = new rdr::U8[r.area() * (pf.bpp/8)];\n    stride = r.width();\n  }\n\n  if (palSize == 0) {\n    // Truecolor data\n    if (useGradient) {\n      if (pf.is888())\n        FilterGradient24(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n      else {\n        switch (pf.bpp) {\n        case 8:\n          assert(false);\n          break;\n        case 16:\n          FilterGradient(bufptr, pf, (rdr::U16*)outbuf, stride, r);\n          break;\n        case 32:\n          FilterGradient(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n          break;\n        }\n      }\n    } else {\n      // Copy\n      rdr::U8* ptr = outbuf;\n      const rdr::U8* srcPtr = bufptr;\n      int w = r.width();\n      int h = r.height();\n      if (pf.is888()) {\n        while (h > 0) {\n          pf.bufferFromRGB(ptr, srcPtr, w);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * 3;\n          h--;\n        }\n      } else {\n        while (h > 0) {\n          memcpy(ptr, srcPtr, w * pf.bpp/8);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * pf.bpp/8;\n          h--;\n        }\n      }\n    }\n  } else {\n    // Indexed color\n    switch (pf.bpp) {\n    case 8:\n      FilterPalette((const rdr::U8*)palette, palSize,\n                    bufptr, (rdr::U8*)outbuf, stride, r);\n      break;\n    case 16:\n      FilterPalette((const rdr::U16*)palette, palSize,\n                    bufptr, (rdr::U16*)outbuf, stride, r);\n      break;\n    case 32:\n      FilterPalette((const rdr::U32*)palette, palSize,\n                    bufptr, (rdr::U32*)outbuf, stride, r);\n      break;\n    }\n  }\n\n  if (directDecode)\n    pb->commitBufferRW(r);\n  else {\n    pb->imageRect(pf, r, outbuf);\n    delete [] outbuf;\n  }\n\n  delete [] netbuf;\n}\n\nrdr::U32 TightDecoder::readCompact(rdr::InStream* is)\n{\n  rdr::U8 b;\n  rdr::U32 result;\n\n  b = is->readU8();\n  result = (int)b & 0x7F;\n  if (b & 0x80) {\n    b = is->readU8();\n    result |= ((int)b & 0x7F) << 7;\n    if (b & 0x80) {\n      b = is->readU8();\n      result |= ((int)b & 0xFF) << 14;\n    }\n  }\n\n  return result;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZRLE decoding function.\n//\n// This file is #included after having set the following macro:\n// BPP                - 8, 16 or 32\n\n#include <stdio.h>\n#include <rdr/InStream.h>\n#include <rdr/ZlibInStream.h>\n#include <rfb/Exception.h>\n\nnamespace rfb {\n\n// CONCAT2E concatenates its arguments, expanding them if they are macros\n\n#ifndef CONCAT2E\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#endif\n\n#ifdef CPIXEL\n#define PIXEL_T rdr::CONCAT2E(U,BPP)\n#define READ_PIXEL(is) CONCAT2E(readOpaque,CPIXEL)(is)\n#define ZRLE_DECODE CONCAT2E(zrleDecode,CPIXEL)\n#else\n#define PIXEL_T rdr::CONCAT2E(U,BPP)\n#define READ_PIXEL(is) is->CONCAT2E(readOpaque,BPP)()\n#define ZRLE_DECODE CONCAT2E(zrleDecode,BPP)\n#endif\n\nvoid ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n\n      if (!rle) {\n        if (palSize == 0) {\n\n          // raw\n\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n\n        } else {\n\n          // packed pixels\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n\n          PIXEL_T* ptr = buf;\n\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n\n      } else {\n\n        if (palSize == 0) {\n\n          // plain RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n\n            while (len-- > 0) *ptr++ = pix;\n\n          }\n        } else {\n\n          // palette RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n\n            index &= 127;\n\n            PIXEL_T pix = palette[index];\n\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n\n      pb->imageRect(pf, t, buf);\n    }\n  }\n\n  zis->removeUnderlying();\n}\n\n#undef ZRLE_DECODE\n#undef READ_PIXEL\n#undef PIXEL_T\n}\n"], "fixing_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n\n#include <rdr/ZlibInStream.h>\n#include <rdr/Exception.h>\n#include <zlib.h>\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nZlibInStream::ZlibInStream(int bufSize_)\n  : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),\n    zs(NULL), bytesIn(0)\n{\n  ptr = end = start = new U8[bufSize];\n  init();\n}\n\nZlibInStream::~ZlibInStream()\n{\n  deinit();\n  delete [] start;\n}\n\nvoid ZlibInStream::setUnderlying(InStream* is, int bytesIn_)\n{\n  underlying = is;\n  bytesIn = bytesIn_;\n  ptr = end = start;\n}\n\nint ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nvoid ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; // throw away any data\n  }\n\n  setUnderlying(NULL, 0);\n}\n\nvoid ZlibInStream::reset()\n{\n  deinit();\n  init();\n}\n\nvoid ZlibInStream::init()\n{\n  assert(zs == NULL);\n\n  zs = new z_stream;\n  zs->zalloc    = Z_NULL;\n  zs->zfree     = Z_NULL;\n  zs->opaque    = Z_NULL;\n  zs->next_in   = Z_NULL;\n  zs->avail_in  = 0;\n  if (inflateInit(zs) != Z_OK) {\n    delete zs;\n    zs = NULL;\n    throw Exception(\"ZlibInStream: inflateInit failed\");\n  }\n}\n\nvoid ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}\n\nint ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n// decompress() calls the decompressor once.  Note that this won't necessarily\n// generate any output data - it may just consume some input data.  Returns\n// false if wait is false and we would block on the underlying stream.\n\nbool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZlibInStream streams from a compressed data stream (\"underlying\"),\n// decompressing with zlib on the fly.\n//\n\n#ifndef __RDR_ZLIBINSTREAM_H__\n#define __RDR_ZLIBINSTREAM_H__\n\n#include <rdr/InStream.h>\n\nstruct z_stream_s;\n\nnamespace rdr {\n\n  class ZlibInStream : public InStream {\n\n  public:\n\n    ZlibInStream(int bufSize=0);\n    virtual ~ZlibInStream();\n\n    void setUnderlying(InStream* is, int bytesIn);\n    void flushUnderlying();\n    int pos();\n    void reset();\n\n  private:\n\n    void init();\n    void deinit();\n\n    int overrun(int itemSize, int nItems, bool wait);\n    bool decompress(bool wait);\n\n    InStream* underlying;\n    int bufSize;\n    int offset;\n    z_stream_s* zs;\n    int bytesIn;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2009-2019 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n#include <stdio.h>\n\n#include <rdr/InStream.h>\n#include <rdr/ZlibInStream.h>\n\n#include <rfb/msgTypes.h>\n#include <rfb/clipboardTypes.h>\n#include <rfb/Exception.h>\n#include <rfb/LogWriter.h>\n#include <rfb/util.h>\n#include <rfb/CMsgHandler.h>\n#include <rfb/CMsgReader.h>\n\nstatic rfb::LogWriter vlog(\"CMsgReader\");\n\nstatic rfb::IntParameter maxCutText(\"MaxCutText\", \"Maximum permitted length of an incoming clipboard update\", 256*1024);\n\nusing namespace rfb;\n\nCMsgReader::CMsgReader(CMsgHandler* handler_, rdr::InStream* is_)\n  : imageBufIdealSize(0), handler(handler_), is(is_),\n    nUpdateRectsLeft(0)\n{\n}\n\nCMsgReader::~CMsgReader()\n{\n}\n\nvoid CMsgReader::readServerInit()\n{\n  int width = is->readU16();\n  int height = is->readU16();\n  PixelFormat pf;\n  pf.read(is);\n  CharArray name(is->readString());\n  handler->serverInit(width, height, pf, name.buf);\n}\n\nvoid CMsgReader::readMsg()\n{\n  if (nUpdateRectsLeft == 0) {\n    int type = is->readU8();\n\n    switch (type) {\n    case msgTypeSetColourMapEntries:\n      readSetColourMapEntries();\n      break;\n    case msgTypeBell:\n      readBell();\n      break;\n    case msgTypeServerCutText:\n      readServerCutText();\n      break;\n    case msgTypeFramebufferUpdate:\n      readFramebufferUpdate();\n      break;\n    case msgTypeServerFence:\n      readFence();\n      break;\n    case msgTypeEndOfContinuousUpdates:\n      readEndOfContinuousUpdates();\n      break;\n    default:\n      vlog.error(\"unknown message type %d\", type);\n      throw Exception(\"unknown message type\");\n    }\n  } else {\n    int x = is->readU16();\n    int y = is->readU16();\n    int w = is->readU16();\n    int h = is->readU16();\n    int encoding = is->readS32();\n\n    switch (encoding) {\n    case pseudoEncodingLastRect:\n      nUpdateRectsLeft = 1;     // this rectangle is the last one\n      break;\n    case pseudoEncodingXCursor:\n      readSetXCursor(w, h, Point(x,y));\n      break;\n    case pseudoEncodingCursor:\n      readSetCursor(w, h, Point(x,y));\n      break;\n    case pseudoEncodingCursorWithAlpha:\n      readSetCursorWithAlpha(w, h, Point(x,y));\n      break;\n    case pseudoEncodingVMwareCursor:\n      readSetVMwareCursor(w, h, Point(x,y));\n      break;\n    case pseudoEncodingDesktopName:\n      readSetDesktopName(x, y, w, h);\n      break;\n    case pseudoEncodingDesktopSize:\n      handler->setDesktopSize(w, h);\n      break;\n    case pseudoEncodingExtendedDesktopSize:\n      readExtendedDesktopSize(x, y, w, h);\n      break;\n    case pseudoEncodingLEDState:\n      readLEDState();\n      break;\n    case pseudoEncodingVMwareLEDState:\n      readVMwareLEDState();\n      break;\n    case pseudoEncodingQEMUKeyEvent:\n      handler->supportsQEMUKeyEvent();\n      break;\n    default:\n      readRect(Rect(x, y, x+w, y+h), encoding);\n      break;\n    };\n\n    nUpdateRectsLeft--;\n    if (nUpdateRectsLeft == 0)\n      handler->framebufferUpdateEnd();\n  }\n}\n\nvoid CMsgReader::readSetColourMapEntries()\n{\n  is->skip(1);\n  int firstColour = is->readU16();\n  int nColours = is->readU16();\n  rdr::U16Array rgbs(nColours * 3);\n  for (int i = 0; i < nColours * 3; i++)\n    rgbs.buf[i] = is->readU16();\n  handler->setColourMapEntries(firstColour, nColours, rgbs.buf);\n}\n\nvoid CMsgReader::readBell()\n{\n  handler->bell();\n}\n\nvoid CMsgReader::readServerCutText()\n{\n  is->skip(3);\n  rdr::U32 len = is->readU32();\n\n  if (len & 0x80000000) {\n    rdr::S32 slen = len;\n    slen = -slen;\n    readExtendedClipboard(slen);\n    return;\n  }\n\n  if (len > (size_t)maxCutText) {\n    is->skip(len);\n    vlog.error(\"cut text too long (%d bytes) - ignoring\",len);\n    return;\n  }\n  CharArray ca(len);\n  is->readBytes(ca.buf, len);\n  CharArray filtered(convertLF(ca.buf, len));\n  handler->serverCutText(filtered.buf);\n}\n\nvoid CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.flushUnderlying();\n    zis.setUnderlying(NULL, 0);\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}\n\nvoid CMsgReader::readFence()\n{\n  rdr::U32 flags;\n  rdr::U8 len;\n  char data[64];\n\n  is->skip(3);\n\n  flags = is->readU32();\n\n  len = is->readU8();\n  if (len > sizeof(data)) {\n    vlog.error(\"Ignoring fence with too large payload\");\n    is->skip(len);\n    return;\n  }\n\n  is->readBytes(data, len);\n\n  handler->fence(flags, len, data);\n}\n\nvoid CMsgReader::readEndOfContinuousUpdates()\n{\n  handler->endOfContinuousUpdates();\n}\n\nvoid CMsgReader::readFramebufferUpdate()\n{\n  is->skip(1);\n  nUpdateRectsLeft = is->readU16();\n  handler->framebufferUpdateStart();\n}\n\nvoid CMsgReader::readRect(const Rect& r, int encoding)\n{\n  if ((r.br.x > handler->server.width()) ||\n      (r.br.y > handler->server.height())) {\n    vlog.error(\"Rect too big: %dx%d at %d,%d exceeds %dx%d\",\n\t    r.width(), r.height(), r.tl.x, r.tl.y,\n            handler->server.width(), handler->server.height());\n    throw Exception(\"Rect too big\");\n  }\n\n  if (r.is_empty())\n    vlog.error(\"zero size rect\");\n\n  handler->dataRect(r, encoding);\n}\n\nvoid CMsgReader::readSetXCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  rdr::U8Array rgba(width*height*4);\n\n  if (width * height > 0) {\n    rdr::U8 pr, pg, pb;\n    rdr::U8 sr, sg, sb;\n    int data_len = ((width+7)/8) * height;\n    int mask_len = ((width+7)/8) * height;\n    rdr::U8Array data(data_len);\n    rdr::U8Array mask(mask_len);\n\n    int x, y;\n    rdr::U8* out;\n\n    pr = is->readU8();\n    pg = is->readU8();\n    pb = is->readU8();\n\n    sr = is->readU8();\n    sg = is->readU8();\n    sb = is->readU8();\n\n    is->readBytes(data.buf, data_len);\n    is->readBytes(mask.buf, mask_len);\n\n    int maskBytesPerRow = (width+7)/8;\n    out = rgba.buf;\n    for (y = 0;y < height;y++) {\n      for (x = 0;x < width;x++) {\n        int byte = y * maskBytesPerRow + x / 8;\n        int bit = 7 - x % 8;\n\n        if (data.buf[byte] & (1 << bit)) {\n          out[0] = pr;\n          out[1] = pg;\n          out[2] = pb;\n        } else {\n          out[0] = sr;\n          out[1] = sg;\n          out[2] = sb;\n        }\n\n        if (mask.buf[byte] & (1 << bit))\n          out[3] = 255;\n        else\n          out[3] = 0;\n\n        out += 4;\n      }\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}\n\nvoid CMsgReader::readSetCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  int data_len = width * height * (handler->server.pf().bpp/8);\n  int mask_len = ((width+7)/8) * height;\n  rdr::U8Array data(data_len);\n  rdr::U8Array mask(mask_len);\n\n  int x, y;\n  rdr::U8Array rgba(width*height*4);\n  rdr::U8* in;\n  rdr::U8* out;\n\n  is->readBytes(data.buf, data_len);\n  is->readBytes(mask.buf, mask_len);\n\n  int maskBytesPerRow = (width+7)/8;\n  in = data.buf;\n  out = rgba.buf;\n  for (y = 0;y < height;y++) {\n    for (x = 0;x < width;x++) {\n      int byte = y * maskBytesPerRow + x / 8;\n      int bit = 7 - x % 8;\n\n      handler->server.pf().rgbFromBuffer(out, in, 1);\n\n      if (mask.buf[byte] & (1 << bit))\n        out[3] = 255;\n      else\n        out[3] = 0;\n\n      in += handler->server.pf().bpp/8;\n      out += 4;\n    }\n  }\n\n  handler->setCursor(width, height, hotspot, rgba.buf);\n}\n\nvoid CMsgReader::readSetCursorWithAlpha(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  int encoding;\n\n  const PixelFormat rgbaPF(32, 32, false, true, 255, 255, 255, 16, 8, 0);\n  ManagedPixelBuffer pb(rgbaPF, width, height);\n  PixelFormat origPF;\n\n  rdr::U8* buf;\n  int stride;\n\n  encoding = is->readS32();\n\n  origPF = handler->server.pf();\n  handler->server.setPF(rgbaPF);\n  handler->readAndDecodeRect(pb.getRect(), encoding, &pb);\n  handler->server.setPF(origPF);\n\n  // On-wire data has pre-multiplied alpha, but we store it\n  // non-pre-multiplied\n  buf = pb.getBufferRW(pb.getRect(), &stride);\n  assert(stride == width);\n\n  for (int i = 0;i < pb.area();i++) {\n    rdr::U8 alpha;\n\n    alpha = buf[3];\n    if (alpha == 0)\n      alpha = 1; // Avoid division by zero\n\n    buf[0] = (unsigned)buf[0] * 255/alpha;\n    buf[1] = (unsigned)buf[1] * 255/alpha;\n    buf[2] = (unsigned)buf[2] * 255/alpha;\n\n    buf += 4;\n  }\n\n  pb.commitBufferRW(pb.getRect());\n\n  handler->setCursor(width, height, hotspot,\n                     pb.getBuffer(pb.getRect(), &stride));\n}\n\nvoid CMsgReader::readSetVMwareCursor(int width, int height, const Point& hotspot)\n{\n  if (width > maxCursorSize || height > maxCursorSize)\n    throw Exception(\"Too big cursor\");\n\n  rdr::U8 type;\n\n  type = is->readU8();\n  is->skip(1);\n\n  if (type == 0) {\n    int len = width * height * (handler->server.pf().bpp/8);\n    rdr::U8Array andMask(len);\n    rdr::U8Array xorMask(len);\n\n    rdr::U8Array data(width*height*4);\n\n    rdr::U8* andIn;\n    rdr::U8* xorIn;\n    rdr::U8* out;\n    int Bpp;\n\n    is->readBytes(andMask.buf, len);\n    is->readBytes(xorMask.buf, len);\n\n    andIn = andMask.buf;\n    xorIn = xorMask.buf;\n    out = data.buf;\n    Bpp = handler->server.pf().bpp/8;\n    for (int y = 0;y < height;y++) {\n      for (int x = 0;x < width;x++) {\n        Pixel andPixel, xorPixel;\n\n        andPixel = handler->server.pf().pixelFromBuffer(andIn);\n        xorPixel = handler->server.pf().pixelFromBuffer(xorIn);\n        andIn += Bpp;\n        xorIn += Bpp;\n\n        if (andPixel == 0) {\n          rdr::U8 r, g, b;\n\n          // Opaque pixel\n\n          handler->server.pf().rgbFromPixel(xorPixel, &r, &g, &b);\n          *out++ = r;\n          *out++ = g;\n          *out++ = b;\n          *out++ = 0xff;\n        } else if (xorPixel == 0) {\n          // Fully transparent pixel\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n        } else if (andPixel == xorPixel) {\n          // Inverted pixel\n\n          // We don't really support this, so just turn the pixel black\n          // FIXME: Do an outline like WinVNC does?\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0xff;\n        } else {\n          // Partially transparent/inverted pixel\n\n          // We _really_ can't handle this, just make it black\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0;\n          *out++ = 0xff;\n        }\n      }\n    }\n\n    handler->setCursor(width, height, hotspot, data.buf);\n  } else if (type == 1) {\n    rdr::U8Array data(width*height*4);\n\n    // FIXME: Is alpha premultiplied?\n    is->readBytes(data.buf, width*height*4);\n\n    handler->setCursor(width, height, hotspot, data.buf);\n  } else {\n    throw Exception(\"Unknown cursor type\");\n  }\n}\n\nvoid CMsgReader::readSetDesktopName(int x, int y, int w, int h)\n{\n  char* name = is->readString();\n\n  if (x || y || w || h) {\n    vlog.error(\"Ignoring DesktopName rect with non-zero position/size\");\n  } else {\n    handler->setName(name);\n  }\n\n  delete [] name;\n}\n\nvoid CMsgReader::readExtendedDesktopSize(int x, int y, int w, int h)\n{\n  unsigned int screens, i;\n  rdr::U32 id, flags;\n  int sx, sy, sw, sh;\n  ScreenSet layout;\n\n  screens = is->readU8();\n  is->skip(3);\n\n  for (i = 0;i < screens;i++) {\n    id = is->readU32();\n    sx = is->readU16();\n    sy = is->readU16();\n    sw = is->readU16();\n    sh = is->readU16();\n    flags = is->readU32();\n\n    layout.add_screen(Screen(id, sx, sy, sw, sh, flags));\n  }\n\n  handler->setExtendedDesktopSize(x, y, w, h, layout);\n}\n\nvoid CMsgReader::readLEDState()\n{\n  rdr::U8 state;\n\n  state = is->readU8();\n\n  handler->setLEDState(state);\n}\n\nvoid CMsgReader::readVMwareLEDState()\n{\n  rdr::U32 state;\n\n  state = is->readU32();\n\n  // As luck has it, this extension uses the same bit definitions,\n  // so no conversion required\n\n  handler->setLEDState(state);\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2009-2019 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n#include <stdio.h>\n\n#include <rdr/InStream.h>\n#include <rdr/ZlibInStream.h>\n\n#include <rfb/msgTypes.h>\n#include <rfb/qemuTypes.h>\n#include <rfb/clipboardTypes.h>\n#include <rfb/Exception.h>\n#include <rfb/util.h>\n#include <rfb/SMsgHandler.h>\n#include <rfb/SMsgReader.h>\n#include <rfb/Configuration.h>\n#include <rfb/LogWriter.h>\n\nusing namespace rfb;\n\nstatic LogWriter vlog(\"SMsgReader\");\n\nstatic IntParameter maxCutText(\"MaxCutText\", \"Maximum permitted length of an incoming clipboard update\", 256*1024);\n\nSMsgReader::SMsgReader(SMsgHandler* handler_, rdr::InStream* is_)\n  : handler(handler_), is(is_)\n{\n}\n\nSMsgReader::~SMsgReader()\n{\n}\n\nvoid SMsgReader::readClientInit()\n{\n  bool shared = is->readU8();\n  handler->clientInit(shared);\n}\n\nvoid SMsgReader::readMsg()\n{\n  int msgType = is->readU8();\n  switch (msgType) {\n  case msgTypeSetPixelFormat:\n    readSetPixelFormat();\n    break;\n  case msgTypeSetEncodings:\n    readSetEncodings();\n    break;\n  case msgTypeSetDesktopSize:\n    readSetDesktopSize();\n    break;\n  case msgTypeFramebufferUpdateRequest:\n    readFramebufferUpdateRequest();\n    break;\n  case msgTypeEnableContinuousUpdates:\n    readEnableContinuousUpdates();\n    break;\n  case msgTypeClientFence:\n    readFence();\n    break;\n  case msgTypeKeyEvent:\n    readKeyEvent();\n    break;\n  case msgTypePointerEvent:\n    readPointerEvent();\n    break;\n  case msgTypeClientCutText:\n    readClientCutText();\n    break;\n  case msgTypeQEMUClientMessage:\n    readQEMUMessage();\n    break;\n  default:\n    vlog.error(\"unknown message type %d\", msgType);\n    throw Exception(\"unknown message type\");\n  }\n}\n\nvoid SMsgReader::readSetPixelFormat()\n{\n  is->skip(3);\n  PixelFormat pf;\n  pf.read(is);\n  handler->setPixelFormat(pf);\n}\n\nvoid SMsgReader::readSetEncodings()\n{\n  is->skip(1);\n  int nEncodings = is->readU16();\n  rdr::S32Array encodings(nEncodings);\n  for (int i = 0; i < nEncodings; i++)\n    encodings.buf[i] = is->readU32();\n  handler->setEncodings(nEncodings, encodings.buf);\n}\n\nvoid SMsgReader::readSetDesktopSize()\n{\n  int width, height;\n  int screens, i;\n  rdr::U32 id, flags;\n  int sx, sy, sw, sh;\n  ScreenSet layout;\n\n  is->skip(1);\n\n  width = is->readU16();\n  height = is->readU16();\n\n  screens = is->readU8();\n  is->skip(1);\n\n  for (i = 0;i < screens;i++) {\n    id = is->readU32();\n    sx = is->readU16();\n    sy = is->readU16();\n    sw = is->readU16();\n    sh = is->readU16();\n    flags = is->readU32();\n\n    layout.add_screen(Screen(id, sx, sy, sw, sh, flags));\n  }\n\n  handler->setDesktopSize(width, height, layout);\n}\n\nvoid SMsgReader::readFramebufferUpdateRequest()\n{\n  bool inc = is->readU8();\n  int x = is->readU16();\n  int y = is->readU16();\n  int w = is->readU16();\n  int h = is->readU16();\n  handler->framebufferUpdateRequest(Rect(x, y, x+w, y+h), inc);\n}\n\nvoid SMsgReader::readEnableContinuousUpdates()\n{\n  bool enable;\n  int x, y, w, h;\n\n  enable = is->readU8();\n\n  x = is->readU16();\n  y = is->readU16();\n  w = is->readU16();\n  h = is->readU16();\n\n  handler->enableContinuousUpdates(enable, x, y, w, h);\n}\n\nvoid SMsgReader::readFence()\n{\n  rdr::U32 flags;\n  rdr::U8 len;\n  char data[64];\n\n  is->skip(3);\n\n  flags = is->readU32();\n\n  len = is->readU8();\n  if (len > sizeof(data)) {\n    vlog.error(\"Ignoring fence with too large payload\");\n    is->skip(len);\n    return;\n  }\n\n  is->readBytes(data, len);\n  \n  handler->fence(flags, len, data);\n}\n\nvoid SMsgReader::readKeyEvent()\n{\n  bool down = is->readU8();\n  is->skip(2);\n  rdr::U32 key = is->readU32();\n  handler->keyEvent(key, 0, down);\n}\n\nvoid SMsgReader::readPointerEvent()\n{\n  int mask = is->readU8();\n  int x = is->readU16();\n  int y = is->readU16();\n  handler->pointerEvent(Point(x, y), mask);\n}\n\n\nvoid SMsgReader::readClientCutText()\n{\n  is->skip(3);\n  rdr::U32 len = is->readU32();\n\n  if (len & 0x80000000) {\n    rdr::S32 slen = len;\n    slen = -slen;\n    readExtendedClipboard(slen);\n    return;\n  }\n\n  if (len > (size_t)maxCutText) {\n    is->skip(len);\n    vlog.error(\"Cut text too long (%d bytes) - ignoring\", len);\n    return;\n  }\n  CharArray ca(len);\n  is->readBytes(ca.buf, len);\n  CharArray filtered(convertLF(ca.buf, len));\n  handler->clientCutText(filtered.buf);\n}\n\nvoid SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.flushUnderlying();\n    zis.setUnderlying(NULL, 0);\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}\n\nvoid SMsgReader::readQEMUMessage()\n{\n  int subType = is->readU8();\n  switch (subType) {\n  case qemuExtendedKeyEvent:\n    readQEMUKeyEvent();\n    break;\n  default:\n    throw Exception(\"unknown QEMU submessage type %d\", subType);\n  }\n}\n\nvoid SMsgReader::readQEMUKeyEvent()\n{\n  bool down = is->readU16();\n  rdr::U32 keysym = is->readU32();\n  rdr::U32 keycode = is->readU32();\n  if (!keycode) {\n    vlog.error(\"Key event without keycode - ignoring\");\n    return;\n  }\n  handler->keyEvent(keysym, keycode, down);\n}\n", "/* Copyright (C) 2000-2003 Constantin Kaplinsky.  All Rights Reserved.\n * Copyright 2004-2005 Cendio AB.\n * Copyright 2009-2015 Pierre Ossman for Cendio AB\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n\n#include <rdr/InStream.h>\n#include <rdr/MemInStream.h>\n#include <rdr/OutStream.h>\n\n#include <rfb/ServerParams.h>\n#include <rfb/Exception.h>\n#include <rfb/PixelBuffer.h>\n#include <rfb/TightConstants.h>\n#include <rfb/TightDecoder.h>\n\nusing namespace rfb;\n\nstatic const int TIGHT_MAX_WIDTH = 2048;\nstatic const int TIGHT_MIN_TO_COMPRESS = 12;\n\n#define BPP 8\n#include <rfb/tightDecode.h>\n#undef BPP\n#define BPP 16\n#include <rfb/tightDecode.h>\n#undef BPP\n#define BPP 32\n#include <rfb/tightDecode.h>\n#undef BPP\n\nTightDecoder::TightDecoder() : Decoder(DecoderPartiallyOrdered)\n{\n}\n\nTightDecoder::~TightDecoder()\n{\n}\n\nvoid TightDecoder::readRect(const Rect& r, rdr::InStream* is,\n                            const ServerParams& server, rdr::OutStream* os)\n{\n  rdr::U8 comp_ctl;\n\n  comp_ctl = is->readU8();\n  os->writeU8(comp_ctl);\n\n  comp_ctl >>= 4;\n\n  // \"Fill\" compression type.\n  if (comp_ctl == tightFill) {\n    if (server.pf().is888())\n      os->copyBytes(is, 3);\n    else\n      os->copyBytes(is, server.pf().bpp/8);\n    return;\n  }\n\n  // \"JPEG\" compression type.\n  if (comp_ctl == tightJpeg) {\n    rdr::U32 len;\n\n    len = readCompact(is);\n    os->writeOpaque32(len);\n    os->copyBytes(is, len);\n    return;\n  }\n\n  // Quit on unsupported compression type.\n  if (comp_ctl > tightMaxSubencoding)\n    throw Exception(\"TightDecoder: bad subencoding value received\");\n\n  // \"Basic\" compression type.\n\n  int palSize = 0;\n\n  if (r.width() > TIGHT_MAX_WIDTH)\n    throw Exception(\"TightDecoder: too large rectangle (%d pixels)\", r.width());\n\n  // Possible palette\n  if ((comp_ctl & tightExplicitFilter) != 0) {\n    rdr::U8 filterId;\n\n    filterId = is->readU8();\n    os->writeU8(filterId);\n\n    switch (filterId) {\n    case tightFilterPalette:\n      palSize = is->readU8() + 1;\n      os->writeU8(palSize - 1);\n\n      if (server.pf().is888())\n        os->copyBytes(is, palSize * 3);\n      else\n        os->copyBytes(is, palSize * server.pf().bpp/8);\n      break;\n    case tightFilterGradient:\n      if (server.pf().bpp == 8)\n        throw Exception(\"TightDecoder: invalid BPP for gradient filter\");\n      break;\n    case tightFilterCopy:\n      break;\n    default:\n      throw Exception(\"TightDecoder: unknown filter code received\");\n    }\n  }\n\n  size_t rowSize, dataSize;\n\n  if (palSize != 0) {\n    if (palSize <= 2)\n      rowSize = (r.width() + 7) / 8;\n    else\n      rowSize = r.width();\n  } else if (server.pf().is888()) {\n    rowSize = r.width() * 3;\n  } else {\n    rowSize = r.width() * server.pf().bpp/8;\n  }\n\n  dataSize = r.height() * rowSize;\n\n  if (dataSize < TIGHT_MIN_TO_COMPRESS)\n    os->copyBytes(is, dataSize);\n  else {\n    rdr::U32 len;\n\n    len = readCompact(is);\n    os->writeOpaque32(len);\n    os->copyBytes(is, len);\n  }\n}\n\nbool TightDecoder::doRectsConflict(const Rect& rectA,\n                                   const void* bufferA,\n                                   size_t buflenA,\n                                   const Rect& rectB,\n                                   const void* bufferB,\n                                   size_t buflenB,\n                                   const ServerParams& server)\n{\n  rdr::U8 comp_ctl_a, comp_ctl_b;\n\n  assert(buflenA >= 1);\n  assert(buflenB >= 1);\n\n  comp_ctl_a = *(const rdr::U8*)bufferA;\n  comp_ctl_b = *(const rdr::U8*)bufferB;\n\n  // Resets or use of zlib pose the same problem, so merge them\n  if ((comp_ctl_a & 0x80) == 0x00)\n    comp_ctl_a |= 1 << ((comp_ctl_a >> 4) & 0x03);\n  if ((comp_ctl_b & 0x80) == 0x00)\n    comp_ctl_b |= 1 << ((comp_ctl_b >> 4) & 0x03);\n\n  if (((comp_ctl_a & 0x0f) & (comp_ctl_b & 0x0f)) != 0)\n    return true;\n\n  return false;\n}\n\nvoid TightDecoder::decodeRect(const Rect& r, const void* buffer,\n                              size_t buflen, const ServerParams& server,\n                              ModifiablePixelBuffer* pb)\n{\n  const rdr::U8* bufptr;\n  const PixelFormat& pf = server.pf();\n\n  rdr::U8 comp_ctl;\n\n  bufptr = (const rdr::U8*)buffer;\n\n  assert(buflen >= 1);\n\n  comp_ctl = *bufptr;\n  bufptr += 1;\n  buflen -= 1;\n\n  // Reset zlib streams if we are told by the server to do so.\n  for (int i = 0; i < 4; i++) {\n    if (comp_ctl & 1) {\n      zis[i].reset();\n    }\n    comp_ctl >>= 1;\n  }\n\n  // \"Fill\" compression type.\n  if (comp_ctl == tightFill) {\n    if (pf.is888()) {\n      rdr::U8 pix[4];\n\n      assert(buflen >= 3);\n\n      pf.bufferFromRGB(pix, bufptr, 1);\n      pb->fillRect(pf, r, pix);\n    } else {\n      assert(buflen >= (size_t)pf.bpp/8);\n      pb->fillRect(pf, r, bufptr);\n    }\n    return;\n  }\n\n  // \"JPEG\" compression type.\n  if (comp_ctl == tightJpeg) {\n    rdr::U32 len;\n\n    int stride;\n    rdr::U8 *buf;\n\n    JpegDecompressor jd;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    // We always use direct decoding with JPEG images\n    buf = pb->getBufferRW(r, &stride);\n    jd.decompress(bufptr, len, buf, stride, r, pb->getPF());\n    pb->commitBufferRW(r);\n    return;\n  }\n\n  // Quit on unsupported compression type.\n  assert(comp_ctl <= tightMaxSubencoding);\n\n  // \"Basic\" compression type.\n\n  int palSize = 0;\n  rdr::U8 palette[256 * 4];\n  bool useGradient = false;\n\n  if ((comp_ctl & tightExplicitFilter) != 0) {\n    rdr::U8 filterId;\n\n    assert(buflen >= 1);\n\n    filterId = *bufptr;\n    bufptr += 1;\n    buflen -= 1;\n\n    switch (filterId) {\n    case tightFilterPalette:\n      assert(buflen >= 1);\n\n      palSize = *bufptr + 1;\n      bufptr += 1;\n      buflen -= 1;\n\n      if (pf.is888()) {\n        size_t len = palSize * 3;\n        rdr::U8Array tightPalette(len);\n\n        assert(buflen >= len);\n\n        memcpy(tightPalette.buf, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n\n        pf.bufferFromRGB(palette, tightPalette.buf, palSize);\n      } else {\n        size_t len;\n\n        len = palSize * pf.bpp/8;\n\n        assert(buflen >= len);\n\n        memcpy(palette, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n      }\n      break;\n    case tightFilterGradient:\n      useGradient = true;\n      break;\n    case tightFilterCopy:\n      break;\n    default:\n      assert(false);\n    }\n  }\n\n  // Determine if the data should be decompressed or just copied.\n  size_t rowSize, dataSize;\n  rdr::U8* netbuf;\n\n  netbuf = NULL;\n\n  if (palSize != 0) {\n    if (palSize <= 2)\n      rowSize = (r.width() + 7) / 8;\n    else\n      rowSize = r.width();\n  } else if (pf.is888()) {\n    rowSize = r.width() * 3;\n  } else {\n    rowSize = r.width() * pf.bpp/8;\n  }\n\n  dataSize = r.height() * rowSize;\n\n  if (dataSize < TIGHT_MIN_TO_COMPRESS)\n    assert(buflen >= dataSize);\n  else {\n    rdr::U32 len;\n    int streamId;\n    rdr::MemInStream* ms;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    assert(buflen >= len);\n\n    streamId = comp_ctl & 0x03;\n    ms = new rdr::MemInStream(bufptr, len);\n    zis[streamId].setUnderlying(ms, len);\n\n    // Allocate buffer and decompress the data\n    netbuf = new rdr::U8[dataSize];\n\n    zis[streamId].readBytes(netbuf, dataSize);\n\n    zis[streamId].flushUnderlying();\n    zis[streamId].setUnderlying(NULL, 0);\n    delete ms;\n\n    bufptr = netbuf;\n    buflen = dataSize;\n  }\n\n  // Time to decode the actual data\n  bool directDecode;\n\n  rdr::U8* outbuf;\n  int stride;\n\n  if (pb->getPF().equal(pf)) {\n    // Decode directly into the framebuffer (fast path)\n    directDecode = true;\n  } else {\n    // Decode into an intermediate buffer and use pixel translation\n    directDecode = false;\n  }\n\n  if (directDecode)\n    outbuf = pb->getBufferRW(r, &stride);\n  else {\n    outbuf = new rdr::U8[r.area() * (pf.bpp/8)];\n    stride = r.width();\n  }\n\n  if (palSize == 0) {\n    // Truecolor data\n    if (useGradient) {\n      if (pf.is888())\n        FilterGradient24(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n      else {\n        switch (pf.bpp) {\n        case 8:\n          assert(false);\n          break;\n        case 16:\n          FilterGradient(bufptr, pf, (rdr::U16*)outbuf, stride, r);\n          break;\n        case 32:\n          FilterGradient(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n          break;\n        }\n      }\n    } else {\n      // Copy\n      rdr::U8* ptr = outbuf;\n      const rdr::U8* srcPtr = bufptr;\n      int w = r.width();\n      int h = r.height();\n      if (pf.is888()) {\n        while (h > 0) {\n          pf.bufferFromRGB(ptr, srcPtr, w);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * 3;\n          h--;\n        }\n      } else {\n        while (h > 0) {\n          memcpy(ptr, srcPtr, w * pf.bpp/8);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * pf.bpp/8;\n          h--;\n        }\n      }\n    }\n  } else {\n    // Indexed color\n    switch (pf.bpp) {\n    case 8:\n      FilterPalette((const rdr::U8*)palette, palSize,\n                    bufptr, (rdr::U8*)outbuf, stride, r);\n      break;\n    case 16:\n      FilterPalette((const rdr::U16*)palette, palSize,\n                    bufptr, (rdr::U16*)outbuf, stride, r);\n      break;\n    case 32:\n      FilterPalette((const rdr::U32*)palette, palSize,\n                    bufptr, (rdr::U32*)outbuf, stride, r);\n      break;\n    }\n  }\n\n  if (directDecode)\n    pb->commitBufferRW(r);\n  else {\n    pb->imageRect(pf, r, outbuf);\n    delete [] outbuf;\n  }\n\n  delete [] netbuf;\n}\n\nrdr::U32 TightDecoder::readCompact(rdr::InStream* is)\n{\n  rdr::U8 b;\n  rdr::U32 result;\n\n  b = is->readU8();\n  result = (int)b & 0x7F;\n  if (b & 0x80) {\n    b = is->readU8();\n    result |= ((int)b & 0x7F) << 7;\n    if (b & 0x80) {\n      b = is->readU8();\n      result |= ((int)b & 0xFF) << 14;\n    }\n  }\n\n  return result;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZRLE decoding function.\n//\n// This file is #included after having set the following macro:\n// BPP                - 8, 16 or 32\n\n#include <stdio.h>\n#include <rdr/InStream.h>\n#include <rdr/ZlibInStream.h>\n#include <rfb/Exception.h>\n\nnamespace rfb {\n\n// CONCAT2E concatenates its arguments, expanding them if they are macros\n\n#ifndef CONCAT2E\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#endif\n\n#ifdef CPIXEL\n#define PIXEL_T rdr::CONCAT2E(U,BPP)\n#define READ_PIXEL(is) CONCAT2E(readOpaque,CPIXEL)(is)\n#define ZRLE_DECODE CONCAT2E(zrleDecode,CPIXEL)\n#else\n#define PIXEL_T rdr::CONCAT2E(U,BPP)\n#define READ_PIXEL(is) is->CONCAT2E(readOpaque,BPP)()\n#define ZRLE_DECODE CONCAT2E(zrleDecode,BPP)\n#endif\n\nvoid ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n\n      if (!rle) {\n        if (palSize == 0) {\n\n          // raw\n\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n\n        } else {\n\n          // packed pixels\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n\n          PIXEL_T* ptr = buf;\n\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n\n      } else {\n\n        if (palSize == 0) {\n\n          // plain RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n\n            while (len-- > 0) *ptr++ = pix;\n\n          }\n        } else {\n\n          // palette RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n\n            index &= 127;\n\n            PIXEL_T pix = palette[index];\n\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n\n      pb->imageRect(pf, t, buf);\n    }\n  }\n\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}\n\n#undef ZRLE_DECODE\n#undef READ_PIXEL\n#undef PIXEL_T\n}\n"], "filenames": ["common/rdr/ZlibInStream.cxx", "common/rdr/ZlibInStream.h", "common/rfb/CMsgReader.cxx", "common/rfb/SMsgReader.cxx", "common/rfb/TightDecoder.cxx", "common/rfb/zrleDecode.h"], "buggy_code_start_loc": [55, 41, 245, 296, 344, 177], "buggy_code_end_loc": [129, 42, 246, 297, 345, 178], "fixing_code_start_loc": [55, 41, 245, 296, 344, 177], "fixing_code_end_loc": [131, 42, 247, 298, 346, 179], "type": "CWE-672", "message": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "other": {"cve": {"id": "CVE-2019-15691", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-12-26T15:15:11.007", "lastModified": "2022-11-09T21:25:17.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity."}, {"lang": "es", "value": "TigerVNC versiones anteriores a 1.10.1, es vulnerable al uso de la pila previo al retorno, que se presenta debido a un uso incorrecto de la memoria de pila en ZRLEDecoder. Si la rutina de decodificaci\u00f3n arroja una excepci\u00f3n, ZRLEDecoder puede intentar acceder a la variable de la pila, que ya ha sido liberada durante el proceso del desempaquetado de la pila. La explotaci\u00f3n de esta vulnerabilidad podr\u00eda resultar potencialmente en una ejecuci\u00f3n de c\u00f3digo remota. Este ataque parece ser explotable a trav\u00e9s de la conectividad de red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-672"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-825"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "5DB31840-DC35-40A5-8126-FF5FDD81EAD7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html", "source": "vulnerability@kaspersky.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1", "source": "vulnerability@kaspersky.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/12/20/2", "source": "vulnerability@kaspersky.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40"}}