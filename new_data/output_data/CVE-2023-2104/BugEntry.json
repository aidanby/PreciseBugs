{"buggy_code": ["<?php defined('BASEPATH') or exit('No direct script access allowed');\n\n/* ----------------------------------------------------------------------------\n * Easy!Appointments - Online Appointment Scheduler\n *\n * @package     EasyAppointments\n * @author      A.Tselegidis <alextselegidis@gmail.com>\n * @copyright   Copyright (c) Alex Tselegidis\n * @license     https://opensource.org/licenses/GPL-3.0 - GPLv3\n * @link        https://easyappointments.org\n * @since       v1.5.0\n * ---------------------------------------------------------------------------- */\n\n/**\n * Calendar controller.\n *\n * Handles calendar related operations.\n *\n * @package Controllers\n */\nclass Calendar extends EA_Controller {\n    /**\n     * Calendar constructor.\n     */\n    public function __construct()\n    {\n        parent::__construct();\n\n        $this->load->model('appointments_model');\n        $this->load->model('unavailabilities_model');\n        $this->load->model('customers_model');\n        $this->load->model('services_model');\n        $this->load->model('providers_model');\n        $this->load->model('roles_model');\n\n        $this->load->library('accounts');\n        $this->load->library('google_sync');\n        $this->load->library('notifications');\n        $this->load->library('synchronization');\n        $this->load->library('timezones');\n        $this->load->library('webhooks_client');\n    }\n\n    /**\n     * Display the main backend page.\n     *\n     * This method displays the main backend page. All login permission can view this page which displays a calendar\n     * with the events of the selected provider or service. If a user has more privileges he will see more menus at the\n     * top of the page.\n     *\n     * @param string $appointment_hash Appointment hash.\n     */\n    public function index(string $appointment_hash = '')\n    {\n        session(['dest_url' => site_url('backend/index' . (! empty($appointment_hash) ? '/' . $appointment_hash : ''))]);\n\n        $user_id = session('user_id');\n\n        if (cannot('view', PRIV_APPOINTMENTS))\n        {\n            if ($user_id)\n            {\n                abort(403, 'Forbidden');\n            }\n\n            redirect('login');\n\n            return;\n        }\n\n        $role_slug = session('role_slug');\n\n        $user = $this->users_model->find($user_id);\n\n        $secretary_providers = [];\n\n        if ($role_slug === DB_SLUG_SECRETARY)\n        {\n            $secretary = $this->secretaries_model->find(session('user_id'));\n\n            $secretary_providers = $secretary['providers'];\n        }\n\n        $edit_appointment = NULL;\n\n        if ( ! empty($appointment_hash))\n        {\n            $occurrences = $this->appointments_model->get(['hash' => $appointment_hash]);\n\n            if ($appointment_hash !== '' && ! empty($occurrences))\n            {\n                $edit_appointment = $occurrences[0];\n\n                $this->appointments_model->load($edit_appointment, ['customer']);\n            }\n        }\n\n        $privileges = $this->roles_model->get_permissions_by_slug($role_slug);\n\n        $available_providers = $this->providers_model->get_available_providers();\n\n        if ($role_slug === DB_SLUG_PROVIDER)\n        {\n            $available_providers = array_values(array_filter($available_providers, function ($available_provider) use ($user_id) {\n                return (int)$available_provider['id'] === (int)$user_id;\n            }));\n        }\n\n        if ($role_slug === DB_SLUG_SECRETARY)\n        {\n            $available_providers = array_values(array_filter($available_providers, function ($available_provider) use ($secretary_providers) {\n                return in_array($available_provider['id'], $secretary_providers);\n            }));\n        }\n\n        $available_services = $this->services_model->get_available_services();\n\n        $calendar_view = request('view', $user['settings']['calendar_view']);\n\n        $appointment_status_options = setting('appointment_status_options');\n\n        script_vars([\n            'user_id' => $user_id,\n            'role_slug' => $role_slug,\n            'date_format' => setting('date_format'),\n            'time_format' => setting('time_format'),\n            'first_weekday' => setting('first_weekday'),\n            'company_working_plan' => setting('company_working_plan'),\n            'timezones' => $this->timezones->to_array(),\n            'privileges' => $privileges,\n            'calendar_view' => $calendar_view,\n            'available_providers' => $available_providers,\n            'available_services' => $available_services,\n            'secretary_providers' => $secretary_providers,\n            'edit_appointment' => $edit_appointment,\n            'customers' => $this->customers_model->get(NULL, 50, NULL, 'update_datetime DESC'),\n        ]);\n\n        html_vars([\n            'page_title' => lang('calendar'),\n            'active_menu' => PRIV_APPOINTMENTS,\n            'user_display_name' => $this->accounts->get_user_display_name($user_id),\n            'timezone' => session('timezone'),\n            'timezones' => $this->timezones->to_array(),\n            'grouped_timezones' => $this->timezones->to_grouped_array(),\n            'privileges' => $privileges,\n            'calendar_view' => $calendar_view,\n            'available_providers' => $available_providers,\n            'available_services' => $available_services,\n            'secretary_providers' => $secretary_providers,\n            'appointment_status_options' => json_decode($appointment_status_options, TRUE) ?? [],\n            'require_first_name' => setting('require_first_name'),\n            'require_last_name' => setting('require_last_name'),\n            'require_email' => setting('require_email'),\n            'require_phone_number' => setting('require_phone_number'),\n            'require_address' => setting('require_address'),\n            'require_city' => setting('require_city'),\n            'require_zip_code' => setting('require_zip_code'),\n            'require_notes' => setting('require_notes'),\n        ]);\n\n        $this->load->view('pages/calendar');\n    }\n\n    /**\n     * Render the calendar page and display the selected appointment.\n     *\n     * This method will call the \"index\" callback to handle the page rendering.\n     *\n     * @param string $appointment_hash Appointment hash.\n     */\n    public function reschedule(string $appointment_hash)\n    {\n        $this->index($appointment_hash);\n    }\n\n    /**\n     * Save appointment changes that are made from the backend calendar page.\n     */\n    public function save_appointment()\n    {\n        try\n        {\n            // Save customer changes to the database.\n            $customer_data = request('customer_data');\n\n            if ($customer_data)\n            {\n                $customer = $customer_data;\n\n                $required_permissions = ! empty($customer['id'])\n                    ? can('add', PRIV_CUSTOMERS)\n                    : can('edit', PRIV_CUSTOMERS);\n\n                if ( ! $required_permissions)\n                {\n                    throw new RuntimeException('You do not have the required permissions for this task.');\n                }\n\n                $this->customers_model->only($customer, [\n                    'id',\n                    'first_name',\n                    'last_name',\n                    'email',\n                    'phone_number',\n                    'address',\n                    'city',\n                    'state',\n                    'zip_code',\n                    'timezone',\n                    'language',\n                ]);\n\n                $customer['id'] = $this->customers_model->save($customer);\n            }\n\n            // Save appointment changes to the database.\n            $appointment_data = request('appointment_data');\n\n            $manage_mode = ! empty($appointment_data['id']);\n\n            if ($appointment_data)\n            {\n                $appointment = $appointment_data;\n\n                $required_permissions = ! empty($appointment['id'])\n                    ? can('add', PRIV_APPOINTMENTS)\n                    : can('edit', PRIV_APPOINTMENTS);\n\n                if ( ! $required_permissions)\n                {\n                    throw new RuntimeException('You do not have the required permissions for this task.');\n                }\n\n                // If the appointment does not contain the customer record id, then it means that is going to be\n                // inserted. \n                if ( ! isset($appointment['id_users_customer']))\n                {\n                    $appointment['id_users_customer'] = $customer['id'] ?? $customer_data['id'];\n                }\n\n                if ($manage_mode && ! empty($appointment['id']))\n                {\n                    $this->synchronization->remove_appointment_on_provider_change($appointment['id']);\n                }\n\n                $this->appointments_model->only($appointment, [\n                    'id',\n                    'start_datetime',\n                    'end_datetime',\n                    'location',\n                    'notes',\n                    'color',\n                    'status',\n                    'is_unavailability',\n                    'id_users_provider',\n                    'id_users_customer',\n                    'id_services',\n                ]);\n\n                $appointment['id'] = $this->appointments_model->save($appointment);\n            }\n\n            if (empty($appointment['id']))\n            {\n                throw new RuntimeException('The appointment ID is not available.');\n            }\n\n            $appointment = $this->appointments_model->find($appointment['id']);\n            $provider = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n            $customer = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            $service = $this->services_model->find($appointment['id_services'], TRUE);\n\n            $settings = [\n                'company_name' => setting('company_name'),\n                'company_link' => setting('company_link'),\n                'company_email' => setting('company_email'),\n                'date_format' => setting('date_format'),\n                'time_format' => setting('time_format')\n            ];\n\n            $this->synchronization->sync_appointment_saved($appointment, $service, $provider, $customer, $settings);\n\n            $this->notifications->notify_appointment_saved($appointment, $service, $provider, $customer, $settings, $manage_mode);\n\n            $this->webhooks_client->trigger(WEBHOOK_APPOINTMENT_SAVE, $appointment);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Delete appointment from the database.\n     *\n     * This method deletes an existing appointment from the database. Once this action is finished it cannot be undone.\n     * Notification emails are send to both provider and customer and the delete action is executed to the Google\n     * Calendar account of the provider, if the \"google_sync\" setting is enabled.\n     */\n    public function delete_appointment()\n    {\n        try\n        {\n            if (cannot('delete', 'appointments'))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $appointment_id = request('appointment_id');\n\n            if (empty($appointment_id))\n            {\n                throw new InvalidArgumentException('No appointment id provided.');\n            }\n\n            // Store appointment data for later use in this method.\n            $appointment = $this->appointments_model->find($appointment_id);\n            $provider = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n            $customer = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            $service = $this->services_model->find($appointment['id_services'], TRUE);\n\n            $settings = [\n                'company_name' => setting('company_name'),\n                'company_email' => setting('company_email'),\n                'company_link' => setting('company_link'),\n                'date_format' => setting('date_format'),\n                'time_format' => setting('time_format')\n            ];\n\n            // Delete appointment record from the database.\n            $this->appointments_model->delete($appointment_id);\n\n            $this->notifications->notify_appointment_deleted($appointment, $service, $provider, $customer, $settings);\n\n            $this->synchronization->sync_appointment_deleted($appointment, $provider);\n\n            $this->webhooks_client->trigger(WEBHOOK_APPOINTMENT_DELETE, $appointment);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Insert of update unavailability to database.\n     */\n    public function save_unavailability()\n    {\n        try\n        {\n            // Check privileges\n            $unavailability = request('unavailability');\n\n            $required_permissions = ( ! isset($unavailability['id']))\n                ? can('add', PRIV_APPOINTMENTS)\n                : can('edit', PRIV_APPOINTMENTS);\n\n            if ( ! $required_permissions)\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $provider = $this->providers_model->find($unavailability['id_users_provider']);\n\n            $unavailability_id = $this->unavailabilities_model->save($unavailability);\n\n            $unavailability = $this->unavailabilities_model->find($unavailability_id);\n\n            $this->synchronization->sync_unavailability_saved($unavailability, $provider);\n\n            $this->webhooks_client->trigger(WEBHOOK_UNAVAILABILITY_SAVE, $unavailability);\n\n            json_response([\n                'success' => TRUE,\n                'warnings' => $warnings ?? []\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Delete an unavailability from database.\n     */\n    public function delete_unavailability()\n    {\n        try\n        {\n            if (cannot('delete', PRIV_APPOINTMENTS))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $unavailability_id = request('unavailability_id');\n\n            $unavailability = $this->appointments_model->find($unavailability_id);\n\n            $provider = $this->providers_model->find($unavailability['id_users_provider']);\n\n            $this->unavailabilities_model->delete($unavailability_id);\n\n            $this->synchronization->sync_unavailability_deleted($unavailability, $provider);\n\n            $this->webhooks_client->trigger(WEBHOOK_UNAVAILABILITY_DELETE, $unavailability);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Insert of update working plan exceptions to database.\n     */\n    public function save_working_plan_exception()\n    {\n        try\n        {\n            if (cannot('edit', PRIV_USERS))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $date = request('date');\n\n            $working_plan_exception = request('working_plan_exception');\n\n            $provider_id = request('provider_id');\n\n            $this->providers_model->save_working_plan_exception($provider_id, $date, $working_plan_exception);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Delete a working plan exceptions time period to database.\n     */\n    public function delete_working_plan_exception()\n    {\n        try\n        {\n            $required_permissions = can('edit', PRIV_CUSTOMERS);\n\n            if ( ! $required_permissions)\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $date = request('date');\n\n            $provider_id = request('provider_id');\n\n            $this->providers_model->delete_working_plan_exception($provider_id, $date);\n\n            json_response([\n                'success' => TRUE\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Get Calendar Events\n     *\n     * This method will return all the calendar events within a specified period.\n     */\n    public function get_calendar_appointments_for_table_view()\n    {\n        try\n        {\n            $required_permissions = can('view', PRIV_APPOINTMENTS);\n\n            if ( ! $required_permissions)\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $start_date = request('start_date') . ' 00:00:00';\n\n            $end_date = request('end_date') . ' 23:59:59';\n\n            $response = [\n                'appointments' => $this->appointments_model->get([\n                    'start_datetime >=' => $start_date,\n                    'end_datetime <=' => $end_date\n                ]),\n                'unavailabilities' => $this->unavailabilities_model->get([\n                    'start_datetime >=' => $start_date,\n                    'end_datetime <=' => $end_date\n                ])\n            ];\n\n            foreach ($response['appointments'] as &$appointment)\n            {\n                $appointment['provider'] = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n                $appointment['service'] = $this->services_model->find($appointment['id_services'], TRUE);\n                $appointment['customer'] = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            }\n\n            unset($appointment);\n\n            $user_id = session('user_id');\n\n            $role_slug = session('role_slug');\n\n            // If the current user is a provider he must only see his own appointments.\n            if ($role_slug === DB_SLUG_PROVIDER)\n            {\n                foreach ($response['appointments'] as $index => $appointment)\n                {\n                    if ((int)$appointment['id_users_provider'] !== (int)$user_id)\n                    {\n                        unset($response['appointments'][$index]);\n                    }\n                }\n\n                $response['appointments'] = array_values($response['appointments']);\n\n                foreach ($response['unavailabilities'] as $index => $unavailability)\n                {\n                    if ((int)$unavailability['id_users_provider'] !== (int)$user_id)\n                    {\n                        unset($response['unavailabilities'][$index]);\n                    }\n                }\n\n                $response['unavailabilities'] = array_values($response['unavailabilities']);\n            }\n\n            // If the current user is a secretary he must only see the appointments of his providers.\n            if ($role_slug === DB_SLUG_SECRETARY)\n            {\n                $providers = $this->secretaries_model->find($user_id)['providers'];\n\n                foreach ($response['appointments'] as $index => $appointment)\n                {\n                    if ( ! in_array((int)$appointment['id_users_provider'], $providers))\n                    {\n                        unset($response['appointments'][$index]);\n                    }\n                }\n\n                $response['appointments'] = array_values($response['appointments']);\n\n                foreach ($response['unavailabilities'] as $index => $unavailability)\n                {\n                    if ( ! in_array((int)$unavailability['id_users_provider'], $providers))\n                    {\n                        unset($response['unavailabilities'][$index]);\n                    }\n                }\n\n                $response['unavailabilities'] = array_values($response['unavailabilities']);\n            }\n\n            json_response($response);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Get the registered appointments for the given date period and record.\n     *\n     * This method returns the database appointments and unavailability periods for the user selected date period and\n     * record type (provider or service).\n     */\n    public function get_calendar_appointments()\n    {\n        try\n        {\n            if (cannot('view', PRIV_APPOINTMENTS))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $record_id = request('record_id');\n\n            $filter_type = request('filter_type');\n\n            if ( ! $filter_type && $record_id !== FILTER_TYPE_ALL)\n            {\n                json_response([\n                    'appointments' => [],\n                    'unavailabilities' => []\n                ]);\n\n                return;\n            }\n\n            $record_id = $this->db->escape($record_id);\n\n            if ($filter_type == FILTER_TYPE_PROVIDER)\n            {\n                $where_id = 'id_users_provider';\n            }\n            elseif ($filter_type === FILTER_TYPE_SERVICE)\n            {\n                $where_id = 'id_services';\n            }\n            else\n            {\n                $where_id = $record_id;\n            }\n\n            // Get appointments\n            $start_date = $this->db->escape(request('start_date'));\n            $end_date = $this->db->escape(date('Y-m-d', strtotime(request('end_date') . ' +1 day')));\n\n            $where_clause = $where_id . ' = ' . $record_id . '\n                AND ((start_datetime > ' . $start_date . ' AND start_datetime < ' . $end_date . ') \n                or (end_datetime > ' . $start_date . ' AND end_datetime < ' . $end_date . ') \n                or (start_datetime <= ' . $start_date . ' AND end_datetime >= ' . $end_date . ')) \n                AND is_unavailability = 0\n            ';\n\n            $response['appointments'] = $this->appointments_model->get($where_clause);\n\n            foreach ($response['appointments'] as &$appointment)\n            {\n                $appointment['provider'] = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n                $appointment['service'] = $this->services_model->find($appointment['id_services'], TRUE);\n                $appointment['customer'] = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            }\n\n            // Get unavailability periods (only for provider).\n            $response['unavailabilities'] = [];\n\n            if ($filter_type == FILTER_TYPE_PROVIDER)\n            {\n                $where_clause = $where_id . ' = ' . $record_id . '\n                    AND ((start_datetime > ' . $start_date . ' AND start_datetime < ' . $end_date . ') \n                    or (end_datetime > ' . $start_date . ' AND end_datetime < ' . $end_date . ') \n                    or (start_datetime <= ' . $start_date . ' AND end_datetime >= ' . $end_date . ')) \n                    AND is_unavailability = 1\n                ';\n\n                $response['unavailabilities'] = $this->unavailabilities_model->get($where_clause);\n            }\n\n            foreach ($response['unavailabilities'] as &$unavailability)\n            {\n                $unavailability['provider'] = $this->providers_model->find($unavailability['id_users_provider']);\n            }\n\n            json_response($response);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n}\n"], "fixing_code": ["<?php defined('BASEPATH') or exit('No direct script access allowed');\n\n/* ----------------------------------------------------------------------------\n * Easy!Appointments - Online Appointment Scheduler\n *\n * @package     EasyAppointments\n * @author      A.Tselegidis <alextselegidis@gmail.com>\n * @copyright   Copyright (c) Alex Tselegidis\n * @license     https://opensource.org/licenses/GPL-3.0 - GPLv3\n * @link        https://easyappointments.org\n * @since       v1.5.0\n * ---------------------------------------------------------------------------- */\n\n/**\n * Calendar controller.\n *\n * Handles calendar related operations.\n *\n * @package Controllers\n */\nclass Calendar extends EA_Controller {\n    /**\n     * Calendar constructor.\n     */\n    public function __construct()\n    {\n        parent::__construct();\n\n        $this->load->model('appointments_model');\n        $this->load->model('unavailabilities_model');\n        $this->load->model('customers_model');\n        $this->load->model('services_model');\n        $this->load->model('providers_model');\n        $this->load->model('roles_model');\n\n        $this->load->library('accounts');\n        $this->load->library('google_sync');\n        $this->load->library('notifications');\n        $this->load->library('synchronization');\n        $this->load->library('timezones');\n        $this->load->library('webhooks_client');\n    }\n\n    /**\n     * Display the main backend page.\n     *\n     * This method displays the main backend page. All login permission can view this page which displays a calendar\n     * with the events of the selected provider or service. If a user has more privileges he will see more menus at the\n     * top of the page.\n     *\n     * @param string $appointment_hash Appointment hash.\n     */\n    public function index(string $appointment_hash = '')\n    {\n        session(['dest_url' => site_url('backend/index' . (! empty($appointment_hash) ? '/' . $appointment_hash : ''))]);\n\n        $user_id = session('user_id');\n\n        if (cannot('view', PRIV_APPOINTMENTS))\n        {\n            if ($user_id)\n            {\n                abort(403, 'Forbidden');\n            }\n\n            redirect('login');\n\n            return;\n        }\n\n        $role_slug = session('role_slug');\n\n        $user = $this->users_model->find($user_id);\n\n        $secretary_providers = [];\n\n        if ($role_slug === DB_SLUG_SECRETARY)\n        {\n            $secretary = $this->secretaries_model->find(session('user_id'));\n\n            $secretary_providers = $secretary['providers'];\n        }\n\n        $edit_appointment = NULL;\n\n        if ( ! empty($appointment_hash))\n        {\n            $occurrences = $this->appointments_model->get(['hash' => $appointment_hash]);\n\n            if ($appointment_hash !== '' && ! empty($occurrences))\n            {\n                $edit_appointment = $occurrences[0];\n\n                $this->appointments_model->load($edit_appointment, ['customer']);\n            }\n        }\n\n        $privileges = $this->roles_model->get_permissions_by_slug($role_slug);\n\n        $available_providers = $this->providers_model->get_available_providers();\n\n        if ($role_slug === DB_SLUG_PROVIDER)\n        {\n            $available_providers = array_values(array_filter($available_providers, function ($available_provider) use ($user_id) {\n                return (int)$available_provider['id'] === (int)$user_id;\n            }));\n        }\n\n        if ($role_slug === DB_SLUG_SECRETARY)\n        {\n            $available_providers = array_values(array_filter($available_providers, function ($available_provider) use ($secretary_providers) {\n                return in_array($available_provider['id'], $secretary_providers);\n            }));\n        }\n\n        $available_services = $this->services_model->get_available_services();\n\n        $calendar_view = request('view', $user['settings']['calendar_view']);\n\n        $appointment_status_options = setting('appointment_status_options');\n\n        script_vars([\n            'user_id' => $user_id,\n            'role_slug' => $role_slug,\n            'date_format' => setting('date_format'),\n            'time_format' => setting('time_format'),\n            'first_weekday' => setting('first_weekday'),\n            'company_working_plan' => setting('company_working_plan'),\n            'timezones' => $this->timezones->to_array(),\n            'privileges' => $privileges,\n            'calendar_view' => $calendar_view,\n            'available_providers' => $available_providers,\n            'available_services' => $available_services,\n            'secretary_providers' => $secretary_providers,\n            'edit_appointment' => $edit_appointment,\n            'customers' => $this->customers_model->get(NULL, 50, NULL, 'update_datetime DESC'),\n        ]);\n\n        html_vars([\n            'page_title' => lang('calendar'),\n            'active_menu' => PRIV_APPOINTMENTS,\n            'user_display_name' => $this->accounts->get_user_display_name($user_id),\n            'timezone' => session('timezone'),\n            'timezones' => $this->timezones->to_array(),\n            'grouped_timezones' => $this->timezones->to_grouped_array(),\n            'privileges' => $privileges,\n            'calendar_view' => $calendar_view,\n            'available_providers' => $available_providers,\n            'available_services' => $available_services,\n            'secretary_providers' => $secretary_providers,\n            'appointment_status_options' => json_decode($appointment_status_options, TRUE) ?? [],\n            'require_first_name' => setting('require_first_name'),\n            'require_last_name' => setting('require_last_name'),\n            'require_email' => setting('require_email'),\n            'require_phone_number' => setting('require_phone_number'),\n            'require_address' => setting('require_address'),\n            'require_city' => setting('require_city'),\n            'require_zip_code' => setting('require_zip_code'),\n            'require_notes' => setting('require_notes'),\n        ]);\n\n        $this->load->view('pages/calendar');\n    }\n\n    /**\n     * Render the calendar page and display the selected appointment.\n     *\n     * This method will call the \"index\" callback to handle the page rendering.\n     *\n     * @param string $appointment_hash Appointment hash.\n     */\n    public function reschedule(string $appointment_hash)\n    {\n        $this->index($appointment_hash);\n    }\n\n    /**\n     * Save appointment changes that are made from the backend calendar page.\n     */\n    public function save_appointment()\n    {\n        try\n        {\n            // Save customer changes to the database.\n            $customer_data = request('customer_data');\n\n            if ($customer_data)\n            {\n                $customer = $customer_data;\n\n                $required_permissions = ! empty($customer['id'])\n                    ? can('add', PRIV_CUSTOMERS)\n                    : can('edit', PRIV_CUSTOMERS);\n\n                if ( ! $required_permissions)\n                {\n                    throw new RuntimeException('You do not have the required permissions for this task.');\n                }\n\n                $this->customers_model->only($customer, [\n                    'id',\n                    'first_name',\n                    'last_name',\n                    'email',\n                    'phone_number',\n                    'address',\n                    'city',\n                    'state',\n                    'zip_code',\n                    'timezone',\n                    'language',\n                ]);\n\n                $customer['id'] = $this->customers_model->save($customer);\n            }\n\n            // Save appointment changes to the database.\n            $appointment_data = request('appointment_data');\n\n            $manage_mode = ! empty($appointment_data['id']);\n\n            if ($appointment_data)\n            {\n                $appointment = $appointment_data;\n\n                $required_permissions = ! empty($appointment['id'])\n                    ? can('add', PRIV_APPOINTMENTS)\n                    : can('edit', PRIV_APPOINTMENTS);\n\n                if ( ! $required_permissions)\n                {\n                    throw new RuntimeException('You do not have the required permissions for this task.');\n                }\n\n                // If the appointment does not contain the customer record id, then it means that is going to be\n                // inserted. \n                if ( ! isset($appointment['id_users_customer']))\n                {\n                    $appointment['id_users_customer'] = $customer['id'] ?? $customer_data['id'];\n                }\n\n                if ($manage_mode && ! empty($appointment['id']))\n                {\n                    $this->synchronization->remove_appointment_on_provider_change($appointment['id']);\n                }\n\n                $this->appointments_model->only($appointment, [\n                    'id',\n                    'start_datetime',\n                    'end_datetime',\n                    'location',\n                    'notes',\n                    'color',\n                    'status',\n                    'is_unavailability',\n                    'id_users_provider',\n                    'id_users_customer',\n                    'id_services',\n                ]);\n\n                $appointment['id'] = $this->appointments_model->save($appointment);\n            }\n\n            if (empty($appointment['id']))\n            {\n                throw new RuntimeException('The appointment ID is not available.');\n            }\n\n            $appointment = $this->appointments_model->find($appointment['id']);\n            $provider = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n            $customer = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            $service = $this->services_model->find($appointment['id_services'], TRUE);\n\n            $settings = [\n                'company_name' => setting('company_name'),\n                'company_link' => setting('company_link'),\n                'company_email' => setting('company_email'),\n                'date_format' => setting('date_format'),\n                'time_format' => setting('time_format')\n            ];\n\n            $this->synchronization->sync_appointment_saved($appointment, $service, $provider, $customer, $settings);\n\n            $this->notifications->notify_appointment_saved($appointment, $service, $provider, $customer, $settings, $manage_mode);\n\n            $this->webhooks_client->trigger(WEBHOOK_APPOINTMENT_SAVE, $appointment);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Delete appointment from the database.\n     *\n     * This method deletes an existing appointment from the database. Once this action is finished it cannot be undone.\n     * Notification emails are send to both provider and customer and the delete action is executed to the Google\n     * Calendar account of the provider, if the \"google_sync\" setting is enabled.\n     */\n    public function delete_appointment()\n    {\n        try\n        {\n            if (cannot('delete', 'appointments'))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $appointment_id = request('appointment_id');\n\n            if (empty($appointment_id))\n            {\n                throw new InvalidArgumentException('No appointment id provided.');\n            }\n\n            // Store appointment data for later use in this method.\n            $appointment = $this->appointments_model->find($appointment_id);\n            $provider = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n            $customer = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            $service = $this->services_model->find($appointment['id_services'], TRUE);\n\n            $settings = [\n                'company_name' => setting('company_name'),\n                'company_email' => setting('company_email'),\n                'company_link' => setting('company_link'),\n                'date_format' => setting('date_format'),\n                'time_format' => setting('time_format')\n            ];\n\n            // Delete appointment record from the database.\n            $this->appointments_model->delete($appointment_id);\n\n            $this->notifications->notify_appointment_deleted($appointment, $service, $provider, $customer, $settings);\n\n            $this->synchronization->sync_appointment_deleted($appointment, $provider);\n\n            $this->webhooks_client->trigger(WEBHOOK_APPOINTMENT_DELETE, $appointment);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Insert of update unavailability to database.\n     */\n    public function save_unavailability()\n    {\n        try\n        {\n            // Check privileges\n            $unavailability = request('unavailability');\n\n            $required_permissions = ( ! isset($unavailability['id']))\n                ? can('add', PRIV_APPOINTMENTS)\n                : can('edit', PRIV_APPOINTMENTS);\n\n            if ( ! $required_permissions)\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $provider = $this->providers_model->find($unavailability['id_users_provider']);\n\n            $unavailability_id = $this->unavailabilities_model->save($unavailability);\n\n            $unavailability = $this->unavailabilities_model->find($unavailability_id);\n\n            $this->synchronization->sync_unavailability_saved($unavailability, $provider);\n\n            $this->webhooks_client->trigger(WEBHOOK_UNAVAILABILITY_SAVE, $unavailability);\n\n            json_response([\n                'success' => TRUE,\n                'warnings' => $warnings ?? []\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Delete an unavailability from database.\n     */\n    public function delete_unavailability()\n    {\n        try\n        {\n            if (cannot('delete', PRIV_APPOINTMENTS))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $unavailability_id = request('unavailability_id');\n\n            $unavailability = $this->appointments_model->find($unavailability_id);\n\n            $provider = $this->providers_model->find($unavailability['id_users_provider']);\n\n            $this->unavailabilities_model->delete($unavailability_id);\n\n            $this->synchronization->sync_unavailability_deleted($unavailability, $provider);\n\n            $this->webhooks_client->trigger(WEBHOOK_UNAVAILABILITY_DELETE, $unavailability);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Insert of update working plan exceptions to database.\n     */\n    public function save_working_plan_exception()\n    {\n        try\n        {\n            if (cannot('edit', PRIV_USERS))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $date = request('date');\n\n            $working_plan_exception = request('working_plan_exception');\n\n            $provider_id = request('provider_id');\n\n            $this->providers_model->save_working_plan_exception($provider_id, $date, $working_plan_exception);\n\n            json_response([\n                'success' => TRUE,\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Delete a working plan exceptions time period to database.\n     */\n    public function delete_working_plan_exception()\n    {\n        try\n        {\n            $required_permissions = can('edit', PRIV_CUSTOMERS);\n\n            if ( ! $required_permissions)\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $date = request('date');\n\n            $provider_id = request('provider_id');\n\n            $this->providers_model->delete_working_plan_exception($provider_id, $date);\n\n            json_response([\n                'success' => TRUE\n            ]);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Get Calendar Events\n     *\n     * This method will return all the calendar events within a specified period.\n     */\n    public function get_calendar_appointments_for_table_view()\n    {\n        try\n        {\n            $required_permissions = can('view', PRIV_APPOINTMENTS);\n\n            if ( ! $required_permissions)\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $start_date = request('start_date') . ' 00:00:00';\n\n            $end_date = request('end_date') . ' 23:59:59';\n\n            $response = [\n                'appointments' => $this->appointments_model->get([\n                    'start_datetime >=' => $start_date,\n                    'end_datetime <=' => $end_date\n                ]),\n                'unavailabilities' => $this->unavailabilities_model->get([\n                    'start_datetime >=' => $start_date,\n                    'end_datetime <=' => $end_date\n                ])\n            ];\n\n            foreach ($response['appointments'] as &$appointment)\n            {\n                $appointment['provider'] = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n                $appointment['service'] = $this->services_model->find($appointment['id_services'], TRUE);\n                $appointment['customer'] = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            }\n\n            unset($appointment);\n\n            $user_id = session('user_id');\n\n            $role_slug = session('role_slug');\n\n            // If the current user is a provider he must only see his own appointments.\n            if ($role_slug === DB_SLUG_PROVIDER)\n            {\n                foreach ($response['appointments'] as $index => $appointment)\n                {\n                    if ((int)$appointment['id_users_provider'] !== (int)$user_id)\n                    {\n                        unset($response['appointments'][$index]);\n                    }\n                }\n\n                $response['appointments'] = array_values($response['appointments']);\n\n                foreach ($response['unavailabilities'] as $index => $unavailability)\n                {\n                    if ((int)$unavailability['id_users_provider'] !== (int)$user_id)\n                    {\n                        unset($response['unavailabilities'][$index]);\n                    }\n                }\n\n                $response['unavailabilities'] = array_values($response['unavailabilities']);\n            }\n\n            // If the current user is a secretary he must only see the appointments of his providers.\n            if ($role_slug === DB_SLUG_SECRETARY)\n            {\n                $providers = $this->secretaries_model->find($user_id)['providers'];\n\n                foreach ($response['appointments'] as $index => $appointment)\n                {\n                    if ( ! in_array((int)$appointment['id_users_provider'], $providers))\n                    {\n                        unset($response['appointments'][$index]);\n                    }\n                }\n\n                $response['appointments'] = array_values($response['appointments']);\n\n                foreach ($response['unavailabilities'] as $index => $unavailability)\n                {\n                    if ( ! in_array((int)$unavailability['id_users_provider'], $providers))\n                    {\n                        unset($response['unavailabilities'][$index]);\n                    }\n                }\n\n                $response['unavailabilities'] = array_values($response['unavailabilities']);\n            }\n\n            json_response($response);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n\n    /**\n     * Get the registered appointments for the given date period and record.\n     *\n     * This method returns the database appointments and unavailability periods for the user selected date period and\n     * record type (provider or service).\n     */\n    public function get_calendar_appointments()\n    {\n        try\n        {\n            if (cannot('view', PRIV_APPOINTMENTS))\n            {\n                throw new RuntimeException('You do not have the required permissions for this task.');\n            }\n\n            $record_id = request('record_id');\n\n            $filter_type = request('filter_type');\n\n            if ( ! $filter_type && $record_id !== FILTER_TYPE_ALL)\n            {\n                json_response([\n                    'appointments' => [],\n                    'unavailabilities' => []\n                ]);\n\n                return;\n            }\n\n            $record_id = $this->db->escape($record_id);\n\n            if ($filter_type == FILTER_TYPE_PROVIDER)\n            {\n                $where_id = 'id_users_provider';\n            }\n            elseif ($filter_type === FILTER_TYPE_SERVICE)\n            {\n                $where_id = 'id_services';\n            }\n            else\n            {\n                $where_id = $record_id;\n            }\n\n            // Get appointments\n            $start_date = $this->db->escape(request('start_date'));\n            $end_date = $this->db->escape(date('Y-m-d', strtotime(request('end_date') . ' +1 day')));\n\n            $where_clause = $where_id . ' = ' . $record_id . '\n                AND ((start_datetime > ' . $start_date . ' AND start_datetime < ' . $end_date . ') \n                or (end_datetime > ' . $start_date . ' AND end_datetime < ' . $end_date . ') \n                or (start_datetime <= ' . $start_date . ' AND end_datetime >= ' . $end_date . ')) \n                AND is_unavailability = 0\n            ';\n\n            $response['appointments'] = $this->appointments_model->get($where_clause);\n\n            foreach ($response['appointments'] as &$appointment)\n            {\n                $appointment['provider'] = $this->providers_model->find($appointment['id_users_provider'], TRUE);\n                $appointment['service'] = $this->services_model->find($appointment['id_services'], TRUE);\n                $appointment['customer'] = $this->customers_model->find($appointment['id_users_customer'], TRUE);\n            }\n\n            // Get unavailability periods (only for provider).\n            $response['unavailabilities'] = [];\n\n            if ($filter_type == FILTER_TYPE_PROVIDER)\n            {\n                $where_clause = $where_id . ' = ' . $record_id . '\n                    AND ((start_datetime > ' . $start_date . ' AND start_datetime < ' . $end_date . ') \n                    or (end_datetime > ' . $start_date . ' AND end_datetime < ' . $end_date . ') \n                    or (start_datetime <= ' . $start_date . ' AND end_datetime >= ' . $end_date . ')) \n                    AND is_unavailability = 1\n                ';\n\n                $response['unavailabilities'] = $this->unavailabilities_model->get($where_clause);\n            }\n\n            foreach ($response['unavailabilities'] as &$unavailability)\n            {\n                $unavailability['provider'] = $this->providers_model->find($unavailability['id_users_provider']);\n            }\n\n            unset($appointment);\n\n            $user_id = session('user_id');\n\n            $role_slug = session('role_slug');\n\n            // If the current user is a provider he must only see his own appointments.\n            if ($role_slug === DB_SLUG_PROVIDER)\n            {\n                foreach ($response['appointments'] as $index => $appointment)\n                {\n                    if ((int)$appointment['id_users_provider'] !== (int)$user_id)\n                    {\n                        unset($response['appointments'][$index]);\n                    }\n                }\n\n                $response['appointments'] = array_values($response['appointments']);\n\n                foreach ($response['unavailabilities'] as $index => $unavailability)\n                {\n                    if ((int)$unavailability['id_users_provider'] !== (int)$user_id)\n                    {\n                        unset($response['unavailabilities'][$index]);\n                    }\n                }\n\n                $response['unavailabilities'] = array_values($response['unavailabilities']);\n            }\n\n            // If the current user is a secretary he must only see the appointments of his providers.\n            if ($role_slug === DB_SLUG_SECRETARY)\n            {\n                $providers = $this->secretaries_model->find($user_id)['providers'];\n\n                foreach ($response['appointments'] as $index => $appointment)\n                {\n                    if ( ! in_array((int)$appointment['id_users_provider'], $providers))\n                    {\n                        unset($response['appointments'][$index]);\n                    }\n                }\n\n                $response['appointments'] = array_values($response['appointments']);\n\n                foreach ($response['unavailabilities'] as $index => $unavailability)\n                {\n                    if ( ! in_array((int)$unavailability['id_users_provider'], $providers))\n                    {\n                        unset($response['unavailabilities'][$index]);\n                    }\n                }\n\n                $response['unavailabilities'] = array_values($response['unavailabilities']);\n            }\n\n            json_response($response);\n        }\n        catch (Throwable $e)\n        {\n            json_exception($e);\n        }\n    }\n}\n"], "filenames": ["application/controllers/Calendar.php"], "buggy_code_start_loc": [673], "buggy_code_end_loc": [673], "fixing_code_start_loc": [674], "fixing_code_end_loc": [730], "type": "CWE-284", "message": "Improper Access Control in GitHub repository alextselegidis/easyappointments prior to 1.5.0.", "other": {"cve": {"id": "CVE-2023-2104", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-15T14:15:07.650", "lastModified": "2023-04-24T19:05:28.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository alextselegidis/easyappointments prior to 1.5.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:easyappointments:easyappointments:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.0", "matchCriteriaId": "063BC3E9-AA71-49D6-9CEE-F2E7E7B9D687"}]}]}], "references": [{"url": "https://github.com/alextselegidis/easyappointments/commit/75b24735767868344193fb2cc56e17ee4b9ac4be", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/3099b8d1-c49c-41b8-a929-73ccded6fc7c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/alextselegidis/easyappointments/commit/75b24735767868344193fb2cc56e17ee4b9ac4be"}}