{"buggy_code": ["/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.auth;\n\nimport gribbit.server.config.GribbitProperties;\nimport gribbit.util.RandomTokenGenerator;\nimport gribbit.util.WebUtils;\nimport io.netty.handler.codec.http.DefaultCookie;\nimport io.netty.handler.codec.http.ServerCookieEncoder;\n\n/**\n * Cookies!\n */\npublic class Cookie {\n\n    private final String name;\n\n    private final String path;\n\n    /** The unencoded cookie value. */\n    private String value;\n\n    private long maxAgeSeconds;\n\n    private boolean discardAtEndOfBrowserSession;\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /** The name of the email address cookie. Used to notify the Persona client as to who is logged in. */\n    public static final String EMAIL_COOKIE_NAME = \"_email\";\n\n    /** The name of the flash cookie. */\n    public static final String FLASH_COOKIE_NAME = \"_flash\";\n\n    /** The name of the cookie that indicates the auth-required URI the user was trying to visit before logging in. */\n    public static final String REDIRECT_AFTER_LOGIN_COOKIE_NAME = \"_redir\";\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /** The name of the session cookie. */\n    public static final String SESSION_COOKIE_NAME = \"_session\";\n\n    /** How long a session cookie lasts for. */\n    public static final int SESSION_COOKIE_MAX_AGE_SECONDS = 30 * 24 * 60 * 60;\n\n    /** Session cookie length (number of random bytes generated before base 64 encoding) */\n    public static final int SESSION_COOKIE_LENGTH = 20;\n\n    public static String generateRandomSessionToken() {\n        return RandomTokenGenerator.generateRandomTokenBase64(Cookie.SESSION_COOKIE_LENGTH);\n    }\n\n    // ------------------------------------------------------------------------------------------------------\n\n    // Valid characters for cookie fields and values\n    private static final boolean[] VALID_CHAR = new boolean[256];\n    static {\n        for (int i = 33; i <= 126; i++)\n            VALID_CHAR[i] = true;\n        for (char c : new char[] { '\\'', '\"', ',', ';', '\\\\' })\n            VALID_CHAR[c] = false;\n    }\n\n    // Check the chars in a cookie's name and path are valid\n    private static void checkValidCookieFieldStr(String str) {\n        if (str.length() > 3500) {\n            throw new RuntimeException(\"Cookie value too long: \" + str);\n        }\n        for (int i = 0, n = str.length(); i < n; i++) {\n            char c = str.charAt(i);\n            if (c > 255 || !VALID_CHAR[c]) {\n                throw new RuntimeException(\"Invalid cookie field: \" + str);\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Create a cookie.\n     */\n    public Cookie(String name, String path, String cookieValue, long maxAgeSeconds, boolean discardAtEndOfBrowserSession) {\n        this.name = name;\n        checkValidCookieFieldStr(name);\n        this.path = path;\n        if (path != null) {\n            checkValidCookieFieldStr(path);\n        }\n        this.value = cookieValue;\n        this.maxAgeSeconds = maxAgeSeconds;\n        this.discardAtEndOfBrowserSession = discardAtEndOfBrowserSession;\n\n        if (this.maxAgeSeconds <= 0 && this.maxAgeSeconds != Long.MIN_VALUE) {\n            // If maxAge <= 0, cookie is expired immediately (so there is nothing to encode)\n            this.value = \"\";\n            this.maxAgeSeconds = 0;\n        } else {\n            // if maxAge == Long.MIN_VALUE or discardAtEndOfBrowserSession is true, cookie expires at end of session\n            if (maxAgeSeconds == Long.MIN_VALUE) {\n                this.discardAtEndOfBrowserSession = true;\n            } else if (this.discardAtEndOfBrowserSession) {\n                this.maxAgeSeconds = Long.MIN_VALUE;\n            }\n        }\n    }\n\n    /**\n     * Create a cookie with the discard flag set to false (cookie is not discarded when browser session closes).\n     */\n    public Cookie(String name, String path, String cookieValue, long maxAgeInSeconds) {\n        this(name, path, cookieValue, maxAgeInSeconds, false);\n    }\n\n    /**\n     * Create a cookie with path unset (meaning, according to the HTTP spec, it will default to the path of the object\n     * currently being requested), and the discard flag set to false (cookie is not discarded when browser session\n     * closes).\n     */\n    public Cookie(String name, String cookieValue, long maxAgeInSeconds) {\n        this(name, null, cookieValue, maxAgeInSeconds, false);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Parse a cookie from a Netty Cookie. Will throw an exception if cookie decoding failed for some reason (in this\n     * case, ignore the cookie).\n     */\n    public Cookie(io.netty.handler.codec.http.Cookie nettyCookie) {\n        this.name = nettyCookie.name();\n        this.path = nettyCookie.path();\n        this.value = WebUtils.unescapeCookieValue(nettyCookie.value());\n        this.maxAgeSeconds = nettyCookie.maxAge();\n        this.discardAtEndOfBrowserSession = nettyCookie.isDiscard();\n    }\n\n    /** Create a Netty cookie from this Cookie object. */\n    public io.netty.handler.codec.http.Cookie toNettyCookie() {\n        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));\n        if (path != null && !path.isEmpty()) {\n            nettyCookie.setPath(path);\n        }\n        nettyCookie.setMaxAge(maxAgeSeconds);\n        nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n        nettyCookie.setHttpOnly(true);  // TODO\n        if (GribbitProperties.SSL) {\n            nettyCookie.setSecure(true);  // TODO\n        }\n        return nettyCookie;\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Create a cookie that, if set in response, overwrites and deletes the named cookie (by setting maxAgeSeconds to\n     * zero). Have to specify the path since there can be multiple cookies with the same name but with different paths;\n     * this will only delete the cookie with the matching path.\n     */\n    public static Cookie deleteCookie(String name, String path) {\n        return new Cookie(name, path, \"\", 0, false);\n    }\n\n    /**\n     * Create a cookie that, if set in response, overwrites and deletes the cookie with the same name and path (by\n     * setting maxAgeSeconds to zero).\n     */\n    public static Cookie deleteCookie(Cookie cookie) {\n        return new Cookie(cookie.getName(), cookie.getPath(), \"\", 0, false);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Get the cookie as an HTTP header string, including all cookie headers, with the value escaped or base64-encoded.\n     */\n    @Override\n    public String toString() {\n        return ServerCookieEncoder.encode(toNettyCookie());\n    }\n\n    /** Get the name of the cookie. */\n    public String getName() {\n        return name;\n    }\n\n    /** Get the cookie path, or \"\" if the cookie path is not set. */\n    public String getPath() {\n        return path == null ? \"\" : path;\n    }\n\n    /** Get unencoded value of cookie. */\n    public String getValue() {\n        return value;\n    }\n\n    /** Return true if the cookie has expired. */\n    public boolean hasExpired() {\n        return maxAgeSeconds <= 0 && maxAgeSeconds != Long.MIN_VALUE;\n    }\n}\n", "/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.auth;\n\nimport gribbit.auth.User.Token.TokenType;\nimport gribbit.exception.UnauthorizedException;\nimport gribbit.model.DBModelStringKey;\nimport gribbit.request.Request;\nimport gribbit.response.Response;\nimport gribbit.server.GribbitServer;\nimport gribbit.server.siteresources.Database;\nimport gribbit.util.AppException;\nimport gribbit.util.Hash;\nimport gribbit.util.WebUtils;\n\nimport java.time.Instant;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\nimport java.util.HashMap;\n\nimport org.mongojack.MongoCollection;\n\n/**\n * Used to store user identity and authentication information in the database.\n */\n@MongoCollection(name = \"users\")\npublic class User extends DBModelStringKey {\n\n    /** Key/value data for user */\n    public HashMap<String, String> data;\n\n    public String passwordHash;\n\n    public String createdDate;\n\n    public Boolean emailValidated;\n\n    /**\n     * Auth token, stored in both encrypted session-in-client cookie and server. Allows for browser cookie to be\n     * revoked.\n     */\n    public Token sessionTok;\n\n    /** Store CSRF token in User object to avoid re-calculating it where possible */\n    public String csrfTok;\n\n    /** Token used for validating email address. */\n    public Token emailValidationTok;\n\n    /** Token used for resetting password. */\n    public Token passwordResetTok;\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    // Placeholder in password field for federated logins\n    public static final String FEDERATED_LOGIN_PASSWORD_HASH_PLACEHOLDER = \"FEDERATED LOGIN\";\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public User() {\n    }\n\n    public User(String email) {\n        super(email);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** An authentication token, a password reset token or an email address verification token */\n    public static class Token {\n        public String token;\n        public Long expires;\n        public Token.TokenType tokType;\n\n        public enum TokenType {\n            SESSION, PW_RESET, EMAIL_VERIF\n        };\n\n        public Token() {\n        }\n\n        public Token(Token.TokenType tokType, Instant expires) {\n            if (expires.isBefore(Instant.now())) {\n                throw new IllegalArgumentException(\"Token already expired\");\n            }\n            this.tokType = tokType;\n            // Generate token as random base64-encoded number\n            this.token = Cookie.generateRandomSessionToken();\n            this.expires = expires.toEpochMilli();\n        }\n\n        public Token(Token.TokenType tokType, int numSecondsValid) {\n            this(tokType, Instant.now().plus(numSecondsValid, ChronoUnit.SECONDS));\n        }\n\n        public boolean hasExpired() {\n            return expires == null || expires < Instant.now().toEpochMilli();\n        }\n\n        @Override\n        public String toString() {\n            return tokType + \"\\t\" + token + \"\\t\" + expires;\n        }\n    }\n\n    /**\n     * Take an encrypted token, decrypt it, extract the username and token, look up the user, and make sure that the\n     * copy of the auth token in the user matches the copy in the encrypted token, and that the token has not expired.\n     * Throws an exception if any of this fails. Returns the user if it all succeeds.\n     */\n    // FIXME: remove this, and store tokens in user\n    public static User validateTok(String email, String suppliedToken, TokenType tokType) throws Exception {\n        if (email.isEmpty() || email.equals(\"null\") || email.indexOf('@') < 0) {\n            throw new AppException(\"Invalid email address\");\n        }\n        if (suppliedToken == null || suppliedToken.isEmpty()) {\n            throw new AppException(\"Invalid token\");\n        }\n\n        // Look up user with this email addr\n        User user = User.findByEmail(email);\n        if (user == null) {\n            throw new AppException(\"User account does not exist\");\n        }\n\n        switch (tokType) {\n\n        case SESSION:\n            if (user.sessionTok == null || user.sessionTok.hasExpired() || !user.sessionTok.token.equals(suppliedToken)) {\n                // Clear token if there is a mismatch, this will prevent users that manage to crack the cookie\n                // encryption key from doing much, because they would also have to guess the token to log in.\n                // Each attempt to guess the auth token will log them out and require them to log in successfully\n                // to generate a new token. The account cannot be accessed using any old session-in-client cookie,\n                // because there is no auth token on the server until the next successful login.\n                user.clearSessionTok();\n            } else {\n                // User exists and token is valid; return user\n                return user;\n            }\n            break;\n\n        case EMAIL_VERIF:\n            if (user.emailValidationTok == null || user.emailValidationTok.hasExpired()\n                    || !user.emailValidationTok.token.equals(suppliedToken)) {\n                // Clear token if there is a mismatch, this means that if a user uses an old email validation link,\n                // it will invalidate the most recent link.\n                user.clearEmailValidationTok();\n            } else {\n                // User exists and token is valid; return user\n                return user;\n            }\n            break;\n\n        case PW_RESET:\n            if (user.passwordResetTok == null || user.passwordResetTok.hasExpired()\n                    || !user.passwordResetTok.token.equals(suppliedToken)) {\n                // Clear token if there is a mismatch, this means that if a user uses an old password reset link,\n                // it will invalidate the most recent link.\n                user.clearPasswordResetTok();\n            } else {\n                // User exists and token is valid; return user\n                return user;\n            }\n            break;\n\n        default:\n            break;\n        }\n        throw new AppException(\"Token has expired or does not match\");\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Puts a key-value pair into the user data HashMap. N.B. does not save user, you need to do that manually once all\n     * key-value pairs have been put.\n     */\n    public void putData(String key, String val) {\n        if (this.data == null) {\n            this.data = new HashMap<>();\n        }\n        this.data.put(key, val);\n    }\n\n    /** Gets the value corresponding to a given key in the user data HashMap, or null if not found. */\n    public String getData(String key) {\n        return this.data == null ? null : this.data.get(key);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Return true if auth token is absent for user or has expired */\n    public boolean sessionTokHasExpired() {\n        return sessionTok == null || sessionTok.hasExpired();\n    }\n\n    /**\n     * Create a new email validation token, store it in the user's account, and return the token. Expires after 1 day.\n     */\n    public String generateNewEmailValidationTok() {\n        emailValidationTok = new Token(TokenType.EMAIL_VERIF, 1);\n        emailValidated = false;\n        save();\n        return emailValidationTok.token;\n    }\n\n    /**\n     * Create a new password reset token, store it in the user's account, and return the token. Expires after 1 day.\n     */\n    public String generateNewPasswordResetTok() {\n        passwordResetTok = new Token(TokenType.PW_RESET, 1);\n        save();\n        return passwordResetTok.token;\n    }\n\n    /** Clear the auth token, meaning the user will have to log in again to get another token. */\n    public void clearSessionTok() {\n        sessionTok = null;\n        csrfTok = null;\n        save();\n    }\n\n    /** Clear the password reset token, and save user account */\n    public void clearPasswordResetTok() {\n        passwordResetTok = null;\n        save();\n    }\n\n    /** Clear the email validation token, and save user account */\n    public void clearEmailValidationTok() {\n        emailValidationTok = null;\n        save();\n    }\n\n    public void markEmailValidated() {\n        emailValidated = true;\n        save();\n    }\n\n    public boolean emailIsValidated() {\n        return emailValidated != null && emailValidated;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Change a user's password, forcing other clients to be logged out, then log this client in with a new\n     * authentication token.\n     * \n     * @throws AppException\n     *             if new password is too short or invalid, or if user is not logged in, or session has expired.\n     * @throws UnauthorizedException\n     *             if user is not whitelisted for login\n     */\n    public void changePassword(String newPassword, Response response) throws UnauthorizedException, AppException {\n        if (sessionTokHasExpired()) {\n            throw new UnauthorizedException(\"Session has expired\");\n        }\n        // Re-hash user password\n        passwordHash = Hash.hashPassword(newPassword);\n        // Generate a new session token and save user.\n        // Invalidates current session, forcing other clients to be logged out.\n        logIn(response);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public static User findByEmail(String email) {\n        if (email == null || email.isEmpty())\n            return null;\n        String emailNormalized = WebUtils.validateAndNormalizeEmailAddr(email);\n        if (emailNormalized == null)\n            return null;\n        return Database.findOneById(User.class, email);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Authenticate a user based on values of POST params \"email\" and \"password\".\n     * \n     * @return User if successfully authenticated, null otherwise\n     */\n    public static User authenticate(String email, String password, Response response) throws UnauthorizedException {\n        // FIXME: Allow only one login attempt per email address every 5 seconds. Add email addrs to a ConcurrentTreeSet\n        // or something (*if* the email addr is already in the database, to prevent DoS), and every 5s, purge old\n        // entries from the tree. If an attempt is made in less than 5s, then return an error rather than blocking for\n        // up to 5s, again to prevent DoS.   \n        User user = findByEmail(email);\n        if (user != null) {\n            // Get the hash password from the salt + clear password (N.B. It takes 80ms to run BCrypt)\n            if (!FEDERATED_LOGIN_PASSWORD_HASH_PLACEHOLDER.equals(user.passwordHash)\n                    && Hash.checkPassword(password, user.passwordHash)) {\n                // User successfully authenticated.\n                user.logIn(response);\n                return user;\n            }\n        }\n        // If user was not successfully logged in for some reason, delete cookie to be extra paranoid\n        user.logOut(response);\n        return null;\n    }\n\n    /**\n     * Decrypt the session cookie in the HttpRequest, look up the user, and return the user if the user's auth token is\n     * valid (i.e. if their session has not expired or been revoked).\n     * \n     * @return Returns null if session is invalid or user is no longer allowed to log in.\n     */\n    public static User getLoggedInUser(Request req) {\n        // Get email address from cookie\n        Cookie emailCookie = req.getCookie(Cookie.EMAIL_COOKIE_NAME);\n        if (emailCookie != null && !emailCookie.hasExpired()) {\n            String email = emailCookie.getValue();\n\n            // Check user against login whitelist, if it exists (in case whitelist has changed)\n            if (GribbitServer.loginWhitelistChecker == null\n                    || GribbitServer.loginWhitelistChecker.allowUserToLogin(email)) {\n\n                // Get session cookie\n                Cookie sessionCookie = req.getCookie(Cookie.SESSION_COOKIE_NAME);\n                if (sessionCookie != null && !sessionCookie.hasExpired()) {\n                    try {\n                        // Look up email address in database, and check session cookie against session token stored in\n                        // the database for that email address\n                        User user = validateTok(email, sessionCookie.getValue(), TokenType.SESSION);\n                        // If no exception thrown, user is logged in and auth token is valid\n                        return user;\n\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /** Delete session cookies */\n    public static void removeLoginCookies(Response response) {\n        response.deleteCookie(Cookie.SESSION_COOKIE_NAME);\n        response.deleteCookie(Cookie.EMAIL_COOKIE_NAME);\n    }\n\n    /**\n     * Invalidate all current login sessions for this user.\n     */\n    public void logOut(Response response) {\n        clearSessionTok();\n        removeLoginCookies(response);\n    }\n\n    /**\n     * See if there is a logged in user, and log them out if they are logged in.\n     */\n    public static void logOutUser(Request request, Response response) {\n        User user = getLoggedInUser(request);\n        if (user != null) {\n            user.logOut(response);\n        } else {\n            // If no logged in user, just delete the session cookies\n            removeLoginCookies(response);\n        }\n    }\n\n    /**\n     * Create a new authentication token for user and save session cookie.\n     * \n     * @throws UnauthorizedException\n     *             if the user is not whitelisted for login, or their login session has expired.\n     */\n    public void logIn(Response response) throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(id)) {\n\n            // Create new session token\n            sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n            csrfTok = CSRF.generateRandomCSRFToken();\n            save();\n            if (sessionTokHasExpired()) {\n                // Shouldn't happen, since we just created session tok, but just in case\n                clearSessionTok();\n                throw new UnauthorizedException(\"Couldn't create auth session\");\n            }\n\n            // Save login cookies in result\n            response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \"/\", sessionTok.token,\n                    Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n            response.setCookie(new Cookie(Cookie.EMAIL_COOKIE_NAME, \"/\", id, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\"User is not whitelisted for login: \" + id);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Create a user and log them in.\n     * \n     * @throws UnauthorizedException\n     *             if a user with this email addr already exists.\n     */\n    private static User create(String email, String passwordHash, boolean validateEmail, Response response)\n            throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(email)) {\n\n            // Check if a user of this name already exists, and if not, create user record in database.\n            // Should probably be a transaction, although if the record is created twice within a\n            // short period of time, one of the two account creation operations will simply have its\n            // authorization cookie overwritten by the other, so the first session will be logged out.\n            // Either way, users creating an account with the given email address must be in control\n            // of that email account, so this is still secure.\n            if (findByEmail(email) != null) {\n                throw new UnauthorizedException(\"Could not create new user: user \\\"\" + email + \"\\\" already exists\");\n            }\n\n            User user = new User(email);\n\n            user.passwordHash = passwordHash;\n\n            user.createdDate = ZonedDateTime.now().format(DateTimeFormatter.ISO_ZONED_DATE_TIME);\n            user.emailValidated = validateEmail;\n\n            // Log in and save user \n            user.logIn(response);\n\n            return user;\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\"User is not whitelisted for account creation: \" + email);\n        }\n    }\n\n    /**\n     * Create a user from email and password hash, and log them in.\n     * \n     * @throws UnauthorizedException\n     *             if a user with this email addr already exists.\n     */\n    public static User create(String email, String passwordHash, Response response) throws UnauthorizedException {\n        return create(email, passwordHash, /* validateEmail = */false, response);\n    }\n\n    /**\n     * Create a user from a Persona login, and log them in.\n     *\n     * @throws UnauthorizedException\n     *             if a user with this email addr already exists.\n     */\n    public static User createFederatedLoginUser(String email, Response response) throws UnauthorizedException {\n        return create(email, FEDERATED_LOGIN_PASSWORD_HASH_PLACEHOLDER, /* validateEmail = */true, response);\n    }\n}\n", "/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.request;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.CACHE_CONTROL;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderNames.SERVER;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.DATE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ETAG;\nimport static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;\nimport static io.netty.handler.codec.http.HttpHeaderNames.EXPIRES;\nimport static io.netty.handler.codec.http.HttpHeaderNames.LAST_MODIFIED;\nimport static io.netty.handler.codec.http.HttpHeaderNames.PRAGMA;\nimport static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;\nimport static io.netty.handler.codec.http.HttpHeaderValues.GZIP;\nimport static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\nimport gribbit.auth.Cookie;\nimport gribbit.auth.User;\nimport gribbit.response.ErrorResponse;\nimport gribbit.response.HTMLPageResponse;\nimport gribbit.response.HTMLResponse;\nimport gribbit.response.NotModifiedResponse;\nimport gribbit.response.Response;\nimport gribbit.response.flashmsg.FlashMessage;\nimport gribbit.route.RouteHandler;\nimport gribbit.route.RouteHandlerAuthAndValidatedEmailRequired;\nimport gribbit.route.RouteHandlerAuthRequired;\nimport gribbit.route.RouteInfo;\nimport gribbit.server.GribbitServer;\nimport gribbit.server.config.GribbitProperties;\nimport gribbit.server.siteresources.CacheExtension;\nimport gribbit.server.siteresources.CacheExtension.HashInfo;\nimport gribbit.util.Log;\nimport gribbit.util.WebUtils;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufOutputStream;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpResponse;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpChunkedInput;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpHeaderUtil;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.codec.http.ServerCookieEncoder;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.DiskAttribute;\nimport io.netty.handler.codec.http.multipart.DiskFileUpload;\nimport io.netty.handler.codec.http.multipart.FileUpload;\nimport io.netty.handler.codec.http.multipart.HttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.PingWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.PongWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;\nimport io.netty.handler.ssl.NotSslRecordException;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedFile;\nimport io.netty.util.CharsetUtil;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.Charset;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.zip.GZIPOutputStream;\n\npublic class HttpRequestHandler extends SimpleChannelInboundHandler<Object> {\n\n    private Request request;\n\n    private boolean closeAfterWrite = false;\n    private boolean addKeepAliveHeader = false;\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    // Use disk for HTTP data if size >16kB \n    private static final HttpDataFactory factory = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);\n\n    static {\n        // Delete temporary files on exit\n        DiskFileUpload.deleteOnExitTemporaryFile = true;\n        DiskAttribute.deleteOnExitTemporaryFile = true;\n        // Use system temp directory\n        DiskFileUpload.baseDirectory = null;\n        DiskAttribute.baseDirectory = null;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    private HttpPostRequestDecoder decoder;\n\n    private void destroyDecoder() {\n        if (request != null) {\n            try {\n                // Release any temporary files\n                request.releasePostFileUploadParams();\n            } catch (Exception e) {\n            }\n        }\n        if (decoder != null) {\n            try {\n                decoder.cleanFiles();\n                decoder.destroy();\n                decoder = null;\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Set Date and cache-related headers.\n     * \n     * TODO: read http://www.mobify.com/blog/beginners-guide-to-http-cache-headers/ TODO: read\n     * https://www.mnot.net/cache_docs/\n     */\n    private void setDateAndCacheHeaders(HttpHeaders httpHeaders, ZonedDateTime timeNow, long lastModifiedEpochSeconds,\n            long hashKeyMaxRemainingAgeSeconds, String hashKey) {\n        // Date header uses server time, and should use the same clock as Expires and Last-Modified\n        httpHeaders.set(DATE, timeNow.format(DateTimeFormatter.RFC_1123_DATE_TIME));\n\n        // Last-Modified is used to determine whether a Not Modified response should be returned on the next request\n        if (lastModifiedEpochSeconds > 0) {\n            // Add last modified header to cacheable resources. This is needed because Chrome sends\n            // \"Cache-Control: max-age=0\" when the user types in a URL and hits enter, or hits refresh.\n            // In these circumstances, sending back \"Cache-Control: public, max-age=31536000\" does\n            // no good, because the browser has already requested the resource rather than relying on\n            // its cache. By setting the last modified header for all cacheable resources, we can\n            // at least send \"Not Modified\" as a response if the resource has not been modified,\n            // which doesn't save on roundtrips, but at least saves on re-transferring the resources\n            // to the browser when they're already in the browser's cache.\n            httpHeaders.set(\n                    LAST_MODIFIED,\n                    ZonedDateTime.ofInstant(Instant.ofEpochSecond(lastModifiedEpochSeconds), ZoneId.of(\"UTC\")).format(\n                            DateTimeFormatter.RFC_1123_DATE_TIME));\n        }\n\n        // Cache hashed URIs forever (or for the specified amount of time)\n        if (hashKey != null) {\n            // Negative max age => cache indefinitely (although the spec only allows for one year, or 31536000 seconds)\n            long maxAgeSeconds = hashKeyMaxRemainingAgeSeconds < 0 ? 31536000 : hashKeyMaxRemainingAgeSeconds;\n\n            // Cache hash URIs for one year\n            httpHeaders.set(CACHE_CONTROL, \"public, max-age=\" + maxAgeSeconds);\n            httpHeaders.set(EXPIRES, timeNow.plusSeconds(maxAgeSeconds).format(DateTimeFormatter.RFC_1123_DATE_TIME));\n            httpHeaders.set(ETAG, hashKey);\n        }\n\n        if (hashKey == null && lastModifiedEpochSeconds == 0) {\n            // Disable caching for all resources that don't have a last modified time (all static file\n            // resources have a last modified time, so these headers will never be set for files, and \n            // they won't be set for dynamic resources that don't manually set a last modified time).\n            // Without these headers, the server will not have a last modified timestamp to check\n            // against its own timestamp on subsequent requests, so cannot return Not Modified.\n            // This is the minimum necessary set of headers for disabling caching, see http://goo.gl/yXGd2x\n            httpHeaders.add(CACHE_CONTROL, \"no-cache, no-store, must-revalidate\"); // HTTP 1.1\n            httpHeaders.add(PRAGMA, \"no-cache\"); // HTTP 1.0\n            httpHeaders.add(EXPIRES, \"0\"); // Proxies\n        }\n\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Call the route handler for the given route. */\n    private static Response getResponseForRoute(RouteInfo route, Request req, User user) throws Exception {\n        Response response;\n        try {\n            // Call the RestHandler for the route\n            response = route.callHandler(req, user);\n\n        } catch (Exception e) {\n            Log.exception(\"Exception while handling URI \" + req.getURI(), e);\n            try {\n                // Call Internal Server Error handler on exception\n                response = GribbitServer.siteResources.getInternalServerErrorRoute().callHandler(req, user);\n            } catch (Exception e1) {\n                // Fallback in case there's an exception in the Internal Server Error handler\n                Log.exception(\"Error in internal server error handler while handling URI \" + req.getURI(), e1);\n                response = new ErrorResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR, \"Internal Server Error\");\n            }\n        }\n        return response;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Call the given error handler route. */\n    private static Response getResponseForErrorHandlerRoute(RouteInfo route, Request req, User user) throws Exception {\n        // Temporarily replace the method on the original route with a GET request on the error handler's route\n        String origURI = req.getURI();\n        HttpMethod origMethod = req.getMethod();\n        req.setURI(route.getRoutePath());\n        req.setMethod(HttpMethod.GET);\n        // Call the error handler\n        Response response = getResponseForRoute(route, req, user);\n        req.setURI(origURI);\n        req.setMethod(origMethod);\n        return response;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Serve a static file. */\n    private void serveStaticFile(String reqURI, String hashKey, File staticResourceFile, long lastModifiedEpochSeconds,\n            ChannelHandlerContext ctx) throws Exception {\n\n        RandomAccessFile fileToServe = null;\n        try {\n            // Create new RandomAccessFile (which allows us to find file length etc.)\n            fileToServe = new RandomAccessFile(staticResourceFile, \"r\");\n\n            // -----------------------------------------\n            // Serve a static file (not authenticated)\n            // -----------------------------------------\n\n            DefaultHttpResponse httpRes = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            httpRes.headers().add(\"Server\", GribbitServer.SERVER_IDENTIFIER);\n\n            long fileLength = fileToServe.length();\n            httpRes.headers().set(CONTENT_LENGTH, Long.toString(fileLength));\n            WebUtils.setContentTypeHeaders(httpRes.headers(), staticResourceFile.getPath());\n\n            // If the file contents have changed since the last time the file was hashed,\n            // schedule the file to be hashed in the background so that future references to the\n            // file's URI in a src/href attribute of served HTML templates will include a hash\n            // URI rather than the original URI for the file, allowing the browser to cache the\n            // file indefinitely until it changes.\n            CacheExtension.updateHashURI(reqURI, staticResourceFile);\n\n            // If file was already cached, and the request URI included the hash key, then this is\n            // the first time this client has fetched this file since the browser cache was last\n            // cleared. Mark this resource as indefinitely cached. If the file is not being served\n            // on a hash URI, then at least set the Last-Modified header, so that if the client\n            // requests the same unmodified resource again on the same non-hash URI, the server can\n            // return Not Modified instead of serving the contents of the file.\n            setDateAndCacheHeaders(httpRes.headers(), ZonedDateTime.now(), lastModifiedEpochSeconds, //\n                    hashKey != null ? /* cache indefinitely: */-1 : /* ignored if hashKey == null: */0, hashKey);\n\n            if (addKeepAliveHeader) {\n                httpRes.headers().add(CONNECTION, KEEP_ALIVE);\n            }\n\n            // Write HTTP headers to channel\n            ctx.write(httpRes);\n\n            // Write file content to channel.\n            // Can add ChannelProgressiveFutureListener to sendFileFuture if we need to track\n            // progress (e.g. to update user's UI over a web socket to show download progress.)\n            ChannelFuture sendFileFuture;\n            ChannelFuture lastContentFuture;\n            if (ctx.pipeline().get(SslHandler.class) == null) {\n                // Use FileRegions if possible, which supports zero-copy / mmio\n                sendFileFuture =\n                        ctx.write(new DefaultFileRegion(fileToServe.getChannel(), 0, fileLength),\n                                ctx.newProgressivePromise());\n                // Write the end marker\n                lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                // Can't use FileRegions / zero-copy with SSL\n                sendFileFuture =\n                        ctx.write(new HttpChunkedInput(new ChunkedFile(fileToServe, 0, fileLength, 1)),\n                                ctx.newProgressivePromise());\n                // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n                // See https://github.com/netty/netty/commit/4ba2ce3cbbc55391520cfc98a7d4227630fbf978\n                lastContentFuture = sendFileFuture;\n            }\n\n            //            sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n            //                @Override\n            //                public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n            //                    if (total < 0) { // total unknown\n            //                        System.err.println(future.channel() + \" Transfer progress: \" + progress);\n            //                    } else {\n            //                        System.err.println(future.channel() + \" Transfer progress: \" + progress + \" / \" + total);\n            //                    }\n            //                }\n            //\n            //                @Override\n            //                public void operationComplete(ChannelProgressiveFuture future) {\n            //                    System.err.println(future.channel() + \" Transfer complete.\");\n            //                }\n            //            });\n\n            // Close connection after flush if needed, and close file after flush \n            final RandomAccessFile fileToClose = fileToServe;\n            lastContentFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    if (closeAfterWrite) {\n                        future.channel().close();\n                    }\n                    try {\n                        fileToClose.close();\n                    } catch (IOException e) {\n                    }\n                }\n            });\n\n        } catch (Exception e) {\n            if (fileToServe != null) {\n                try {\n                    fileToServe.close();\n                } catch (IOException e1) {\n                }\n            }\n            throw new RuntimeException(\"Exception serving static file\", e);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Serve an HTTP response (anything other than a static file). */\n    private void serveHttpResponse(String reqURI, Response response, boolean isHEAD, boolean acceptEncodingGzip,\n            ZonedDateTime timeNow, boolean hashTheResponse, long hashKeyMaxRemainingAgeSeconds, String hashKey,\n            ChannelHandlerContext ctx) throws Exception {\n\n        // Add any pending flash messages to the response, if the response is an HTML page\n        if (response instanceof HTMLPageResponse) {\n            // Add flash messages to response template, if any\n            ArrayList<FlashMessage> flashMessages = request.getFlashMessages();\n            if (flashMessages != null) {\n                // Render pending flash messages into the HTML page\n                ((HTMLPageResponse) response).setFlashMessages(flashMessages);\n                // Clear the flash message cookie\n                response.deleteCookie(Cookie.FLASH_COOKIE_NAME);\n            }\n        } else {\n            // Store any un-displayed flash messages back in the cookie\n            ArrayList<FlashMessage> flashMessages = request.getFlashMessages();\n            if (flashMessages != null) {\n                response.setCookie(new Cookie(Cookie.FLASH_COOKIE_NAME, \"/\",\n                        FlashMessage.toCookieString(flashMessages), 60));\n            }\n        }\n\n        // Get the content of the response as a byte buffer.\n        ByteBuf content;\n        String contentType;\n        if (response instanceof HTMLResponse) {\n            // If \"?_getmodel=1\" is appended to the request URL of a request that returns an HTML response,\n            // then the data model backing the response will be returned as JSON instead of rendered HTML.\n            boolean isGetModelRequest = GribbitProperties.ALLOW_GET_MODEL && request.isGetModelRequest();\n            content = ((HTMLResponse) response).getContent(isGetModelRequest);\n            contentType = isGetModelRequest ? \"application/json;charset=utf-8\" : response.getContentType();\n        } else {\n            // Not a \"getmodel\" request, just get the content from the response\n            content = response.getContent();\n            contentType = response.getContentType();\n        }\n        byte[] contentBytes = content.array();\n\n        // Gzip content if the configuration property is set to allow gzip, and the client supports gzip encoding,\n        // and the content size is larger than 1kb, and the content type is compressible \n        ByteBuf gzippedContent = null;\n        if (GribbitProperties.CONTENT_GZIP && //\n                acceptEncodingGzip //\n                && content.readableBytes() > 1024 //\n                && WebUtils.isCompressibleContentType(contentType)) {\n            gzippedContent = Unpooled.buffer(/* initialCapacity = */content.readableBytes());\n            // TODO: compare speed to using JZlib.GZIPOutputStream\n            GZIPOutputStream gzipStream = new GZIPOutputStream(new ByteBufOutputStream(gzippedContent));\n            gzipStream.write(contentBytes);\n            gzipStream.close();\n        }\n\n        // Create a FullHttpResponse object that wraps the response status and content\n        HttpResponseStatus status = response.getStatus();\n        DefaultFullHttpResponse httpRes = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, //\n                gzippedContent != null ? gzippedContent : content);\n        httpRes.headers().set(CONTENT_TYPE, contentType);\n        httpRes.headers().set(CONTENT_LENGTH,\n                Integer.toString(gzippedContent != null ? gzippedContent.readableBytes() : content.readableBytes()));\n        if (gzippedContent != null) {\n            httpRes.headers().set(CONTENT_ENCODING, GZIP);\n        }\n\n        httpRes.headers().add(SERVER, GribbitServer.SERVER_IDENTIFIER);\n\n        // Add an Accept-Encoding: gzip header to the response to let the client know that in future\n        // it can send compressed requests. (This header is probably ignored by most clients, because\n        // on initial request they don't know yet if the server can accept compressed content, but\n        // there must be clients out there that look for this header and compress content on the\n        // second and subsequent requests? See http://stackoverflow.com/a/1450163/3950982 )\n        httpRes.headers().add(ACCEPT_ENCODING, \"gzip\");\n\n        // Set date and cache headers\n        setDateAndCacheHeaders(httpRes.headers(), timeNow, response.getLastModifiedEpochSeconds(),\n                hashKeyMaxRemainingAgeSeconds, hashKey);\n\n        // If the response needs hashing, and the response does not have an error status, then schedule the\n        // content of the response for hashing, and store a mapping from the original request URI to the\n        // hash URI so that future HTML responses that have src/href attributes that contain this request\n        // URI will replace this request URI with the hash URI instead. This will mean the client will\n        // fetch that hash URI only once until it expires in the cache, so that on subsequent requests,\n        // the linked resource won't even be requested from the server.\n        if (hashTheResponse && status == HttpResponseStatus.OK) {\n            CacheExtension.updateHashURI(reqURI, content, response.getLastModifiedEpochSeconds());\n        }\n\n        // Release the content ByteBuf after last usage if gzippedContent is being used instead\n        if (gzippedContent != null) {\n            content.release();\n        }\n\n        if (isHEAD) {\n            // Don't return a body for HEAD requests (but still return the content length,\n            // set in the header above)\n            httpRes.content().clear();\n        }\n\n        // Delete requested cookies in the response\n        HashSet<String> cookiesToDelete = response.getCookiesToDelete();\n        if (cookiesToDelete != null) {\n            for (String cookieName : cookiesToDelete) {\n                // Log.fine(\"Cookie to delete for req \" + reqURI + \" : \" + cookieName);\n                ArrayList<Cookie> allCookiesWithName = request.getAllCookiesWithName(cookieName);\n                if (allCookiesWithName != null) {\n                    for (Cookie cookie : allCookiesWithName) {\n                        // Delete all cookies with the requested name (there may be multiple cookies\n                        // with this name but with different paths)\n                        String deleteCookieStr =\n                                ServerCookieEncoder.encode(Cookie.deleteCookie(cookie).toNettyCookie());\n                        httpRes.headers().add(SET_COOKIE, deleteCookieStr);\n                    }\n                }\n            }\n        }\n\n        // Set requested cookies in the response\n        ArrayList<Cookie> cookiesToSet = response.getCookiesToSet();\n        if (cookiesToSet != null) {\n            for (Cookie cookie : cookiesToSet) {\n                if (cookiesToDelete != null && cookiesToDelete.contains(cookie.getName())) {\n                    Log.warning(\"Tried to delete and set the cookie \\\"\" + cookie.getName()\n                            + \"\\\" in the same response -- ignoring the set request\");\n                } else {\n                    String setCookieStr = ServerCookieEncoder.encode(cookie.toNettyCookie());\n                    httpRes.headers().add(SET_COOKIE, setCookieStr);\n                }\n            }\n        }\n\n        // Add any custom headers from the Response object\n        if (response.getCustomHeaders() != null) {\n            for (Entry<String, String> header : response.getCustomHeaders().entrySet()) {\n                httpRes.headers().add(header.getKey(), header.getValue());\n            }\n        }\n\n        // Close the connection after serving the response if the response status is anything other than OK\n        if (addKeepAliveHeader && status == HttpResponseStatus.OK) {\n            httpRes.headers().add(CONNECTION, KEEP_ALIVE);\n        }\n\n        // closeAfterWrite = true;  // FIXME: test this, it doesn't seem to work ====================================================================\n\n        if (ctx.channel().isOpen()) {\n            // Check Channel.isWritable() to prevent OutOfMemoryError,\n            // see http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#10.0\n            long startTime = System.currentTimeMillis();\n            while (!ctx.channel().isWritable() && (System.currentTimeMillis() - startTime < 5000)) {\n                // TODO: replace this spinlock (usually channel is immediately writeable;\n                // is this even needed?)\n            }\n            if (ctx.channel().isWritable()) {\n                // Write the ByteBuffer returned by httpRes.content() back into the pipeline\n                // See http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#4.0\n                ChannelFuture future = ctx.channel().writeAndFlush(httpRes);\n\n                // Close the connection after the write operation is done if necessary.\n                // TODO: Apache closes KeepAlive connections after a few seconds,\n                // see http://en.wikipedia.org/wiki/HTTP_persistent_connection\n                // TODO: implement a stale connection tracker\n                if (closeAfterWrite || status != HttpResponseStatus.OK) { // FIXME: should I close the channel for redirects? (probably not...)\n                    future.addListener(ChannelFutureListener.CLOSE);\n                }\n\n            } else {\n                // Tried for a period of time but could not send response; close channel\n                ctx.channel().close();\n                throw new RuntimeException(\"Could not send response after repeated attempts\");\n            }\n        } else {\n            // Client already closed the connection, nothing can be sent\n            // Log.info(\"Channel closed by client before response sent\");\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Websocket handshaker. */\n    private WebSocketServerHandshaker handshaker;\n\n    /** The user that was authenticated when the websocket upgrade was requested. */\n    private User wsAuthenticatedUser;\n\n    /** Handle a websocket frame. */\n    private void handleWebsocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        // Check for closing frame\n        if (frame instanceof CloseWebSocketFrame) {\n            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());\n            return;\n        }\n        if (frame instanceof PingWebSocketFrame) {\n            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));\n            return;\n        }\n        if (!(frame instanceof TextWebSocketFrame)) {\n            throw new UnsupportedOperationException(String.format(\"%s frame types not supported\", frame.getClass()\n                    .getName()));\n        }\n\n        // TODO: placeholder\n        String requestText = ((TextWebSocketFrame) frame).text();\n        String responseText =\n                requestText.toUpperCase() + \" -- \"\n                        + (wsAuthenticatedUser == null ? \"not logged in\" : wsAuthenticatedUser.id);\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseText));\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    private static void sendHttpErrorResponse(ChannelHandlerContext ctx, HttpRequest req, FullHttpResponse res) {\n        // Generate an error page if response getStatus code is not OK (200).\n        if (res.status().code() != 200) {\n            ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8);\n            res.content().writeBytes(buf);\n            buf.release();\n            res.headers().set(CONTENT_TYPE, \"text/plain;charset=utf-8\");\n            HttpHeaderUtil.setContentLength(res, res.content().readableBytes());\n        }\n        ChannelFuture f = ctx.channel().writeAndFlush(res);\n        if (req == null || !HttpHeaderUtil.isKeepAlive(req) || res.status().code() != 200) {\n            f.addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Decode an HTTP message. */\n    @Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\"REQUEST: \" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\"100-continue\")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\"UTF-8\") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\"Got unknown data chunk type: \" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\"Unsupported HTTP method \" + request.getMethod().name() + \" for path \" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\"HTTP method \" + request.getMethod().name() + \" not implemented in handler \"\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \"/\", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\"/websocket\")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n                // TODO: Also provide a means for revoking WS login.\n                wsAuthenticatedUser = User.getLoggedInUser(request);\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI + \"\\tfile://\"\n                                + staticResourceFile.getPath() + \"\\t\" + HttpResponseStatus.OK + \"\\t\"\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \"Not Modified\" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\"Didn't generate a response\");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\"Didn't generate a response\");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI\n                            + (request.getMethod() == origReqMethod ? \"\" : \"\\t\" + request.getMethod()) + \"\\t\" + status\n                            + \"\\t\" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\"favicon.ico\") || reqURI.endsWith(\"/favicon.ico\")))) {\n                // Log at level \"fine\" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \"warning\" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        // Release HTTP decoder resources, including any file uploads that were received in a POST\n        // request and stored in /tmp\n        destroyDecoder();\n\n        if (cause instanceof NotSslRecordException) {\n            ctx.channel().close();\n            return;\n        }\n        if (\"Connection reset by peer\".equals(cause.getMessage())) {\n            // (No need to log the backtrace in this case)\n            // Log.info(cause.getMessage());            \n        } else {\n            // Log exception with backtrace\n            Log.exception(\"Uncaught exception\", cause);\n        }\n        if (ctx.channel().isActive()) {\n            sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR));\n        }\n    }\n}\n", "/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.request;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_CHARSET;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_LANGUAGE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.COOKIE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.HOST;\nimport static io.netty.handler.codec.http.HttpHeaderNames.IF_MODIFIED_SINCE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ORIGIN;\nimport static io.netty.handler.codec.http.HttpHeaderNames.REFERER;\nimport static io.netty.handler.codec.http.HttpHeaderNames.USER_AGENT;\nimport gribbit.auth.Cookie;\nimport gribbit.response.flashmsg.FlashMessage;\nimport io.netty.handler.codec.http.CookieDecoder;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.QueryStringDecoder;\nimport io.netty.handler.codec.http.multipart.FileUpload;\n\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Request {\n    private long reqReceivedTimeEpochMillis;\n    private HttpMethod method;\n    private String requestor;\n    private String host;\n    private String path;\n    private CharSequence accept;\n    private CharSequence acceptCharset;\n    private CharSequence acceptLanguage;\n    private boolean acceptEncodingGzip;\n    private CharSequence referer;\n    private CharSequence userAgent;\n    private long ifModifiedSinceEpochSecond = 0;\n\n    private HashMap<String, ArrayList<Cookie>> cookieNameToCookies;\n    private HashMap<String, String> postParamToValue;\n    private HashMap<String, FileUpload> postParamToFileUpload;\n    private Map<String, List<String>> queryParamToVals;\n\n    /**\n     * Header for CORS.\n     * \n     * See http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n     **/\n    private CharSequence origin;\n\n    /**\n     * Header for CSRF protection of AJAX requests (regular GETs and POSTs don't allow for header manipulation.)\n     * \n     * See https://nealpoole.com/blog/2010/11/preventing-csrf-attacks-with-ajax-and-http-headers/\n     */\n    private CharSequence xRequestedWith;\n\n    /**\n     * If set to true by appending \"?_getmodel=1\" to the URL, then return the data model backing an HTML page, not the\n     * rendered page itself.\n     */\n    private boolean isGetModelRequest;\n\n    /** Flash messages. */\n    private ArrayList<FlashMessage> flashMessages;\n\n    // -----------------------------------------------------------------------------------------------------\n\n    public Request(HttpRequest httpReq) {\n        this.reqReceivedTimeEpochMillis = System.currentTimeMillis();\n        HttpHeaders headers = httpReq.headers();\n\n        // Parse and decode/decrypt cookies\n        for (CharSequence cookieHeader : headers.getAll(COOKIE)) {\n            for (io.netty.handler.codec.http.Cookie nettyCookie : CookieDecoder.decode(cookieHeader.toString())) {\n                // Log.fine(\"Cookie in request: \" + nettyCookie);\n                if (this.cookieNameToCookies == null) {\n                    this.cookieNameToCookies = new HashMap<>();\n                }\n                String cookieName = nettyCookie.name();\n                Cookie cookie = new Cookie(nettyCookie);\n\n                // Multiple cookies may be present in the request with the same name but with different paths\n                ArrayList<Cookie> cookiesWithThisName = this.cookieNameToCookies.get(cookieName);\n                if (cookiesWithThisName == null) {\n                    this.cookieNameToCookies.put(cookieName, cookiesWithThisName = new ArrayList<>());\n                }\n                cookiesWithThisName.add(cookie);\n            }\n        }\n\n        this.method = httpReq.method();\n\n        CharSequence host = headers.get(HOST);\n        this.host = host == null ? null : host.toString();\n\n        this.xRequestedWith = headers.get(\"X-Requested-With\");\n        this.accept = headers.get(ACCEPT);\n        this.acceptCharset = headers.get(ACCEPT_CHARSET);\n        this.acceptLanguage = headers.get(ACCEPT_LANGUAGE);\n        this.origin = headers.get(ORIGIN);\n        this.referer = headers.get(REFERER);\n        this.userAgent = headers.get(USER_AGENT);\n\n        CharSequence acceptEncoding = headers.get(ACCEPT_ENCODING);\n        this.acceptEncodingGzip = acceptEncoding != null && acceptEncoding.toString().toLowerCase().contains(\"gzip\");\n\n        CharSequence cacheDateHeader = headers.get(IF_MODIFIED_SINCE);\n        if (cacheDateHeader != null && cacheDateHeader.length() > 0) {\n            this.ifModifiedSinceEpochSecond =\n                    ZonedDateTime.parse(cacheDateHeader, DateTimeFormatter.RFC_1123_DATE_TIME).toEpochSecond();\n        }\n\n        // Decode the path.\n        QueryStringDecoder decoder = new QueryStringDecoder(httpReq.uri());\n        this.path = decoder.path();\n        this.queryParamToVals = decoder.parameters();\n\n        // Look for _getmodel=1 query parameter setting\n        String getModel = this.getQueryParam(\"_getmodel\");\n        if (getModel != null) {\n            this.isGetModelRequest = getModel.equals(\"1\");\n            // Remove _getmodel param so that user doesn't see it\n            this.queryParamToVals.remove(\"_getmodel\");\n        }\n\n        // Get flash messages from cookie, if any\n        this.flashMessages = FlashMessage.fromCookieString(getCookieValue(Cookie.FLASH_COOKIE_NAME));\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public String getPostParam(String paramName) {\n        if (postParamToValue == null) {\n            return null;\n        } else {\n            return postParamToValue.get(paramName);\n        }\n    }\n\n    public void setPostParam(String name, String value) {\n        if (postParamToValue == null) {\n            postParamToValue = new HashMap<>();\n        }\n        postParamToValue.put(name, value);\n    }\n\n    public Set<String> getPostParamNames() {\n        if (postParamToValue == null) {\n            return null;\n        } else {\n            return postParamToValue.keySet();\n        }\n    }\n\n    public void setPostFileUploadParam(String name, FileUpload fileUpload) {\n        if (postParamToFileUpload == null) {\n            postParamToFileUpload = new HashMap<>();\n        }\n        FileUpload old = postParamToFileUpload.put(name, fileUpload);\n        if (old != null) {\n            // Shouldn't happen, but just in case there are two file upload params with the same\n            // param name, free the first, since we're overwriting it\n            old.release();\n        }\n    }\n\n    public FileUpload getPostFileUploadParam(String name) {\n        if (postParamToFileUpload == null) {\n            return null;\n        }\n        return postParamToFileUpload.get(name);\n    }\n\n    public void releasePostFileUploadParams() {\n        if (postParamToFileUpload != null) {\n            for (FileUpload fileUpload : postParamToFileUpload.values()) {\n                fileUpload.release();\n            }\n            postParamToFileUpload = null;\n        }\n    }\n\n    void setPostParams(HashMap<String, String> postParamToValue) {\n        this.postParamToValue = postParamToValue;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Return all URL parameters matching the given name, or null if none. */\n    public List<String> getQueryParams(String paramName) {\n        if (queryParamToVals == null) {\n            return null;\n        } else {\n            return queryParamToVals.get(paramName);\n        }\n    }\n\n    /** Return the first URL parameter matching the given name, or null if none. */\n    public String getQueryParam(String paramName) {\n        List<String> list = getQueryParams(paramName);\n        if (list == null || list.isEmpty()) {\n            return null;\n        } else {\n            return list.get(0);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Used for sorting cookies into decreasing order of path length */\n    private static final Comparator<Cookie> cookiePathLengthComparator = new Comparator<Cookie>() {\n        @Override\n        public int compare(Cookie o1, Cookie o2) {\n            return o2.getPath().length() - o1.getPath().length();\n        }\n    };\n\n    /**\n     * Get a collection of lists of cookies -- each list in the collection consists of one or more cookies, where all\n     * cookies in a list have the same name but different paths. (It is possible to receive multiple cookies with the\n     * same name in a request.) Cookie lists are ordered into decreasing order of path length to conform to a \"SHOULD\"\n     * clause in the HTTP header spec.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public Collection<ArrayList<Cookie>> getAllCookies() {\n        if (cookieNameToCookies == null) {\n            return null;\n        } else {\n            Collection<ArrayList<Cookie>> cookieLists = cookieNameToCookies.values();\n            for (ArrayList<Cookie> cookieList : cookieLists) {\n                Collections.sort(cookieList, cookiePathLengthComparator);\n            }\n            return cookieLists;\n        }\n    }\n\n    /**\n     * Get all cookies with the given name, or null if there are no cookies with this name. (There may be multiple\n     * cookies with the same name but with different paths.) The returned list is ordered into decreasing order of path\n     * length to conform to a \"SHOULD\" clause in the HTTP header spec.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public ArrayList<Cookie> getAllCookiesWithName(String cookieName) {\n        if (cookieNameToCookies == null) {\n            return null;\n        } else {\n            ArrayList<Cookie> cookieList = cookieNameToCookies.get(cookieName);\n            if (cookieList != null) {\n                Collections.sort(cookieList, cookiePathLengthComparator);\n            }\n            return cookieList;\n        }\n    }\n\n    /**\n     * Get a cookie by name, or null if there are no cookies with this name. If there is more than one cookie with the\n     * same name, return the cookie with the longest path.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public Cookie getCookie(String cookieName) {\n        ArrayList<Cookie> cookieList = getAllCookiesWithName(cookieName);\n        if (cookieList == null) {\n            return null;\n        } else {\n            return cookieList.get(0);\n        }\n    }\n\n    /**\n     * Get the string value of a named cookie, or null if there are no cookies with this name. If there is more than one\n     * cookie with the same name, return the value of the one with the longest path.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public String getCookieValue(String cookieName) {\n        Cookie cookie = getCookie(cookieName);\n        if (cookie == null) {\n            return null;\n        } else {\n            return cookie.getValue();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Compare timestamp in the If-Modified-Since request header, if present, to the given resource timestamp to see if\n     * the resource is newer than any cached version. If the If-Modified-Since header is not set, the timestamp of the\n     * cached version is assumed to be zero (the beginning of the Epoch), so this method will return true. If the passed\n     * resource timestamp is zero, the resource timestamp is assumed to be invalid or unavailable, so we assume the\n     * resource is not cached and return true, indicating that the cached version is out of date and should be served\n     * (or served again).\n     */\n    public boolean cachedVersionIsOlderThan(long resourceTimestampEpochSeconds) {\n        if (resourceTimestampEpochSeconds == 0) {\n            // If the resource timestamp is zero, it's not valid, so don't assume this resource is cached,\n            // by returning true indicating that the cached version is out of date. \n            return true;\n        } else {\n            // Otherwise return true if the resource timestamp is later than the cached version timestamp\n            // (including when the cached version timestamp is zero.)\n            // Note that the HTTP If-Modified-Since header only has single-second granularity.\n            return resourceTimestampEpochSeconds > ifModifiedSinceEpochSecond;\n        }\n    }\n\n    public long getReqReceivedTimeEpochMillis() {\n        return reqReceivedTimeEpochMillis;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Add a flash message (a message that will be popped up at the top of a webpage the next time a page is served. */\n    public void addFlashMessage(FlashMessage flashMessage) {\n        if (flashMessages == null) {\n            flashMessages = new ArrayList<>();\n        }\n        flashMessages.add(flashMessage);\n    }\n\n    /** Clear the flash messages. */\n    public void clearFlashMessage() {\n        flashMessages = null;\n    }\n\n    public ArrayList<FlashMessage> getFlashMessages() {\n        return flashMessages;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public String getURI() {\n        return path.toString();\n    }\n\n    public String getRequestor() {\n        return requestor == null ? \"\" : requestor;\n    }\n\n    public void setRequestor(String requestor) {\n        this.requestor = requestor;\n    }\n\n    public HttpMethod getMethod() {\n        return method;\n    }\n\n    public void setMethod(HttpMethod method) {\n        this.method = method;\n    }\n\n    public void setURI(String uri) {\n        this.path = uri;\n    }\n\n    public CharSequence getHost() {\n        return host;\n    }\n\n    public CharSequence getAccept() {\n        return accept;\n    }\n\n    public CharSequence getAcceptCharset() {\n        return acceptCharset;\n    }\n\n    public CharSequence getAcceptLanguage() {\n        return acceptLanguage;\n    }\n\n    public boolean acceptEncodingGzip() {\n        return acceptEncodingGzip;\n    }\n\n    public CharSequence getReferer() {\n        return referer;\n    }\n\n    public CharSequence getUserAgent() {\n        return userAgent;\n    }\n\n    public CharSequence getOrigin() {\n        return origin;\n    }\n\n    public CharSequence getXRequestedWith() {\n        return xRequestedWith;\n    }\n\n    /**\n     * True if the request URL contained the query parameter \"?_getmodel=1\", in which case return the DataModel backing\n     * an HTML page, and not the rendered page itself.\n     */\n    public boolean isGetModelRequest() {\n        return isGetModelRequest;\n    }\n}\n"], "fixing_code": ["/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.auth;\n\nimport gribbit.server.config.GribbitProperties;\nimport gribbit.util.RandomTokenGenerator;\nimport gribbit.util.WebUtils;\nimport io.netty.handler.codec.http.DefaultCookie;\nimport io.netty.handler.codec.http.ServerCookieEncoder;\n\n/**\n * Cookies!\n */\npublic class Cookie {\n\n    private final String name;\n\n    private final String path;\n\n    /** The unencoded cookie value. */\n    private String value;\n\n    private long maxAgeSeconds;\n\n    private boolean discardAtEndOfBrowserSession;\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /** The name of the email address cookie. Used to notify the Persona client as to who is logged in. */\n    public static final String EMAIL_COOKIE_NAME = \"_email\";\n\n    /** The name of the flash cookie. */\n    public static final String FLASH_COOKIE_NAME = \"_flash\";\n\n    /** The name of the cookie that indicates the auth-required URI the user was trying to visit before logging in. */\n    public static final String REDIRECT_AFTER_LOGIN_COOKIE_NAME = \"_redir\";\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /** The name of the session cookie. */\n    public static final String SESSION_COOKIE_NAME = \"_session\";\n\n    /** How long a session cookie lasts for. */\n    public static final int SESSION_COOKIE_MAX_AGE_SECONDS = 30 * 24 * 60 * 60;\n\n    /** Session cookie length (number of random bytes generated before base 64 encoding) */\n    public static final int SESSION_COOKIE_LENGTH = 20;\n\n    public static String generateRandomSessionToken() {\n        return RandomTokenGenerator.generateRandomTokenBase64(Cookie.SESSION_COOKIE_LENGTH);\n    }\n\n    // ------------------------------------------------------------------------------------------------------\n\n    // Valid characters for cookie fields and values\n    private static final boolean[] VALID_CHAR = new boolean[256];\n    static {\n        for (int i = 33; i <= 126; i++)\n            VALID_CHAR[i] = true;\n        for (char c : new char[] { '\\'', '\"', ',', ';', '\\\\' })\n            VALID_CHAR[c] = false;\n    }\n\n    // Check the chars in a cookie's name and path are valid\n    private static void checkValidCookieFieldStr(String str) {\n        if (str.length() > 3500) {\n            throw new RuntimeException(\"Cookie value too long: \" + str);\n        }\n        for (int i = 0, n = str.length(); i < n; i++) {\n            char c = str.charAt(i);\n            if (c > 255 || !VALID_CHAR[c]) {\n                throw new RuntimeException(\"Invalid cookie field: \" + str);\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Create a cookie.\n     */\n    public Cookie(String name, String path, String cookieValue, long maxAgeSeconds, boolean discardAtEndOfBrowserSession) {\n        this.name = name;\n        checkValidCookieFieldStr(name);\n        this.path = path;\n        if (path != null) {\n            checkValidCookieFieldStr(path);\n        }\n        this.value = cookieValue;\n        this.maxAgeSeconds = maxAgeSeconds;\n        this.discardAtEndOfBrowserSession = discardAtEndOfBrowserSession;\n\n        if (this.maxAgeSeconds <= 0 && this.maxAgeSeconds != Long.MIN_VALUE) {\n            // If maxAge <= 0, cookie is expired immediately (so there is nothing to encode)\n            this.value = \"\";\n            this.maxAgeSeconds = 0;\n        } else {\n            // if maxAge == Long.MIN_VALUE or discardAtEndOfBrowserSession is true, cookie expires at end of session\n            if (maxAgeSeconds == Long.MIN_VALUE) {\n                this.discardAtEndOfBrowserSession = true;\n            } else if (this.discardAtEndOfBrowserSession) {\n                this.maxAgeSeconds = Long.MIN_VALUE;\n            }\n        }\n    }\n\n    /**\n     * Create a cookie with the discard flag set to false (cookie is not discarded when browser session closes).\n     */\n    public Cookie(String name, String path, String cookieValue, long maxAgeInSeconds) {\n        this(name, path, cookieValue, maxAgeInSeconds, false);\n    }\n\n    /**\n     * Create a cookie with path unset (meaning, according to the HTTP spec, it will default to the path of the object\n     * currently being requested), and the discard flag set to false (cookie is not discarded when browser session\n     * closes).\n     */\n    public Cookie(String name, String cookieValue, long maxAgeInSeconds) {\n        this(name, null, cookieValue, maxAgeInSeconds, false);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Parse a cookie from a Netty Cookie. Will throw an exception if cookie decoding failed for some reason (in this\n     * case, ignore the cookie).\n     */\n    public Cookie(io.netty.handler.codec.http.Cookie nettyCookie) {\n        this.name = nettyCookie.name();\n        this.path = nettyCookie.path();\n        this.value = WebUtils.unescapeCookieValue(nettyCookie.value());\n        this.maxAgeSeconds = nettyCookie.maxAge();\n        this.discardAtEndOfBrowserSession = nettyCookie.isDiscard();\n    }\n\n    /** Create a Netty cookie from this Cookie object. */\n    public io.netty.handler.codec.http.Cookie toNettyCookie() {\n        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));\n        if (path != null && !path.isEmpty()) {\n            nettyCookie.setPath(path);\n        }\n        nettyCookie.setMaxAge(maxAgeSeconds);\n        nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n        nettyCookie.setHttpOnly(true);  // TODO\n        if (GribbitProperties.SSL) {\n            // If SSL is enabled, force cookies to only be delivered over SSL, to prevent cookie hijacking\n            // on public wifi networks\n            nettyCookie.setSecure(true);\n        }\n        return nettyCookie;\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Create a cookie that, if set in response, overwrites and deletes the named cookie (by setting maxAgeSeconds to\n     * zero). Have to specify the path since there can be multiple cookies with the same name but with different paths;\n     * this will only delete the cookie with the matching path.\n     */\n    public static Cookie deleteCookie(String name, String path) {\n        return new Cookie(name, path, \"\", 0, false);\n    }\n\n    /**\n     * Create a cookie that, if set in response, overwrites and deletes the cookie with the same name and path (by\n     * setting maxAgeSeconds to zero).\n     */\n    public static Cookie deleteCookie(Cookie cookie) {\n        return new Cookie(cookie.getName(), cookie.getPath(), \"\", 0, false);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Get the cookie as an HTTP header string, including all cookie headers, with the value escaped or base64-encoded.\n     */\n    @Override\n    public String toString() {\n        return ServerCookieEncoder.encode(toNettyCookie());\n    }\n\n    /** Get the name of the cookie. */\n    public String getName() {\n        return name;\n    }\n\n    /** Get the cookie path, or \"\" if the cookie path is not set. */\n    public String getPath() {\n        return path == null ? \"\" : path;\n    }\n\n    /** Get unencoded value of cookie. */\n    public String getValue() {\n        return value;\n    }\n\n    /** Return true if the cookie has expired. */\n    public boolean hasExpired() {\n        return maxAgeSeconds <= 0 && maxAgeSeconds != Long.MIN_VALUE;\n    }\n}\n", "/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.auth;\n\nimport gribbit.auth.User.Token.TokenType;\nimport gribbit.exception.UnauthorizedException;\nimport gribbit.model.DBModelStringKey;\nimport gribbit.request.Request;\nimport gribbit.response.Response;\nimport gribbit.server.GribbitServer;\nimport gribbit.server.siteresources.Database;\nimport gribbit.util.AppException;\nimport gribbit.util.Hash;\nimport gribbit.util.WebUtils;\n\nimport java.time.Instant;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\nimport java.util.HashMap;\n\nimport org.mongojack.MongoCollection;\n\n/**\n * Used to store user identity and authentication information in the database.\n */\n@MongoCollection(name = \"users\")\npublic class User extends DBModelStringKey {\n\n    /** Key/value data for user */\n    public HashMap<String, String> data;\n\n    public String passwordHash;\n\n    public String createdDate;\n\n    public Boolean emailValidated;\n\n    /**\n     * Auth token, stored in both encrypted session-in-client cookie and server. Allows for browser cookie to be\n     * revoked.\n     */\n    public Token sessionTok;\n\n    /** Store CSRF token in User object to avoid re-calculating it where possible */\n    public String csrfTok;\n\n    /** Token used for validating email address. */\n    public Token emailValidationTok;\n\n    /** Token used for resetting password. */\n    public Token passwordResetTok;\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    // Placeholder in password field for federated logins\n    public static final String FEDERATED_LOGIN_PASSWORD_HASH_PLACEHOLDER = \"FEDERATED LOGIN\";\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public User() {\n    }\n\n    public User(String email) {\n        super(email);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** An authentication token, a password reset token or an email address verification token */\n    public static class Token {\n        public String token;\n        public Long expires;\n        public Token.TokenType tokType;\n\n        public enum TokenType {\n            SESSION, PW_RESET, EMAIL_VERIF\n        };\n\n        public Token() {\n        }\n\n        public Token(Token.TokenType tokType, Instant expires) {\n            if (expires.isBefore(Instant.now())) {\n                throw new IllegalArgumentException(\"Token already expired\");\n            }\n            this.tokType = tokType;\n            // Generate token as random base64-encoded number\n            this.token = Cookie.generateRandomSessionToken();\n            this.expires = expires.toEpochMilli();\n        }\n\n        public Token(Token.TokenType tokType, int numSecondsValid) {\n            this(tokType, Instant.now().plus(numSecondsValid, ChronoUnit.SECONDS));\n        }\n\n        public boolean hasExpired() {\n            return expires == null || expires < Instant.now().toEpochMilli();\n        }\n\n        @Override\n        public String toString() {\n            return tokType + \"\\t\" + token + \"\\t\" + expires;\n        }\n    }\n\n    /**\n     * Take an encrypted token, decrypt it, extract the username and token, look up the user, and make sure that the\n     * copy of the auth token in the user matches the copy in the encrypted token, and that the token has not expired.\n     * Throws an exception if any of this fails. Returns the user if it all succeeds.\n     */\n    // FIXME: remove this, and store tokens in user\n    public static User validateTok(String email, String suppliedToken, TokenType tokType) throws Exception {\n        if (email.isEmpty() || email.equals(\"null\") || email.indexOf('@') < 0) {\n            throw new AppException(\"Invalid email address\");\n        }\n        if (suppliedToken == null || suppliedToken.isEmpty()) {\n            throw new AppException(\"Invalid token\");\n        }\n\n        // Look up user with this email addr\n        User user = User.findByEmail(email);\n        if (user == null) {\n            throw new AppException(\"User account does not exist\");\n        }\n\n        switch (tokType) {\n\n        case SESSION:\n            if (user.sessionTok == null || user.sessionTok.hasExpired() || !user.sessionTok.token.equals(suppliedToken)) {\n                // Clear token if there is a mismatch, this will prevent users that manage to crack the cookie\n                // encryption key from doing much, because they would also have to guess the token to log in.\n                // Each attempt to guess the auth token will log them out and require them to log in successfully\n                // to generate a new token. The account cannot be accessed using any old session-in-client cookie,\n                // because there is no auth token on the server until the next successful login.\n                user.clearSessionTok();\n            } else {\n                // User exists and token is valid; return user\n                return user;\n            }\n            break;\n\n        case EMAIL_VERIF:\n            if (user.emailValidationTok == null || user.emailValidationTok.hasExpired()\n                    || !user.emailValidationTok.token.equals(suppliedToken)) {\n                // Clear token if there is a mismatch, this means that if a user uses an old email validation link,\n                // it will invalidate the most recent link.\n                user.clearEmailValidationTok();\n            } else {\n                // User exists and token is valid; return user\n                return user;\n            }\n            break;\n\n        case PW_RESET:\n            if (user.passwordResetTok == null || user.passwordResetTok.hasExpired()\n                    || !user.passwordResetTok.token.equals(suppliedToken)) {\n                // Clear token if there is a mismatch, this means that if a user uses an old password reset link,\n                // it will invalidate the most recent link.\n                user.clearPasswordResetTok();\n            } else {\n                // User exists and token is valid; return user\n                return user;\n            }\n            break;\n\n        default:\n            break;\n        }\n        throw new AppException(\"Token has expired or does not match\");\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Puts a key-value pair into the user data HashMap. N.B. does not save user, you need to do that manually once all\n     * key-value pairs have been put.\n     */\n    public void putData(String key, String val) {\n        if (this.data == null) {\n            this.data = new HashMap<>();\n        }\n        this.data.put(key, val);\n    }\n\n    /** Gets the value corresponding to a given key in the user data HashMap, or null if not found. */\n    public String getData(String key) {\n        return this.data == null ? null : this.data.get(key);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Return true if auth token is absent for user or has expired */\n    public boolean sessionTokHasExpired() {\n        return sessionTok == null || sessionTok.hasExpired();\n    }\n\n    /**\n     * Create a new email validation token, store it in the user's account, and return the token. Expires after 1 day.\n     */\n    public String generateNewEmailValidationTok() {\n        emailValidationTok = new Token(TokenType.EMAIL_VERIF, 1);\n        emailValidated = false;\n        save();\n        return emailValidationTok.token;\n    }\n\n    /**\n     * Create a new password reset token, store it in the user's account, and return the token. Expires after 1 day.\n     */\n    public String generateNewPasswordResetTok() {\n        passwordResetTok = new Token(TokenType.PW_RESET, 1);\n        save();\n        return passwordResetTok.token;\n    }\n\n    /** Clear the auth token, meaning the user will have to log in again to get another token. */\n    public void clearSessionTok() {\n        sessionTok = null;\n        csrfTok = null;\n        save();\n    }\n\n    /** Clear the password reset token, and save user account */\n    public void clearPasswordResetTok() {\n        passwordResetTok = null;\n        save();\n    }\n\n    /** Clear the email validation token, and save user account */\n    public void clearEmailValidationTok() {\n        emailValidationTok = null;\n        save();\n    }\n\n    public void markEmailValidated() {\n        emailValidated = true;\n        save();\n    }\n\n    public boolean emailIsValidated() {\n        return emailValidated != null && emailValidated;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Change a user's password, forcing other clients to be logged out, then log this client in with a new\n     * authentication token.\n     * \n     * @throws AppException\n     *             if new password is too short or invalid, or if user is not logged in, or session has expired.\n     * @throws UnauthorizedException\n     *             if user is not whitelisted for login\n     */\n    public void changePassword(String newPassword, Response response) throws UnauthorizedException, AppException {\n        if (sessionTokHasExpired()) {\n            throw new UnauthorizedException(\"Session has expired\");\n        }\n        // Re-hash user password\n        passwordHash = Hash.hashPassword(newPassword);\n        // Generate a new session token and save user.\n        // Invalidates current session, forcing other clients to be logged out.\n        logIn(response);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public static User findByEmail(String email) {\n        if (email == null || email.isEmpty())\n            return null;\n        String emailNormalized = WebUtils.validateAndNormalizeEmailAddr(email);\n        if (emailNormalized == null)\n            return null;\n        return Database.findOneById(User.class, email);\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Authenticate a user based on values of POST params \"email\" and \"password\".\n     * \n     * @return User if successfully authenticated, null otherwise\n     */\n    public static User authenticate(String email, String password, Response response) throws UnauthorizedException {\n        // FIXME: Allow only one login attempt per email address every 5 seconds. Add email addrs to a ConcurrentTreeSet\n        // or something (*if* the email addr is already in the database, to prevent DoS), and every 5s, purge old\n        // entries from the tree. If an attempt is made in less than 5s, then return an error rather than blocking for\n        // up to 5s, again to prevent DoS.   \n        User user = findByEmail(email);\n        if (user != null) {\n            // Get the hash password from the salt + clear password (N.B. It takes 80ms to run BCrypt)\n            if (!FEDERATED_LOGIN_PASSWORD_HASH_PLACEHOLDER.equals(user.passwordHash)\n                    && Hash.checkPassword(password, user.passwordHash)) {\n                // User successfully authenticated.\n                user.logIn(response);\n                return user;\n            }\n        }\n        // If user was not successfully logged in for some reason, delete cookie to be extra paranoid\n        user.logOut(response);\n        return null;\n    }\n\n    /**\n     * Decrypt the session cookie in the HttpRequest, look up the user, and return the user if the user's auth token is\n     * valid (i.e. if their session has not expired or been revoked).\n     * \n     * @return Returns null if session is invalid or user is no longer allowed to log in.\n     */\n    public static User getLoggedInUser(Request req) {\n        // Get email address from cookie\n        Cookie emailCookie = req.getCookie(Cookie.EMAIL_COOKIE_NAME);\n        if (emailCookie != null && !emailCookie.hasExpired()) {\n            String email = emailCookie.getValue();\n\n            // Check user against login whitelist, if it exists (in case whitelist has changed)\n            if (GribbitServer.loginWhitelistChecker == null\n                    || GribbitServer.loginWhitelistChecker.allowUserToLogin(email)) {\n\n                // Get session cookie\n                Cookie sessionCookie = req.getCookie(Cookie.SESSION_COOKIE_NAME);\n                if (sessionCookie != null && !sessionCookie.hasExpired()) {\n                    try {\n                        // Look up email address in database, and check session cookie against session token stored in\n                        // the database for that email address\n                        User user = validateTok(email, sessionCookie.getValue(), TokenType.SESSION);\n                        // If no exception thrown, user is logged in and auth token is valid\n                        return user;\n\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /** Delete session cookies */\n    public static void removeLoginCookies(Response response) {\n        response.deleteCookie(Cookie.SESSION_COOKIE_NAME);\n        response.deleteCookie(Cookie.EMAIL_COOKIE_NAME);\n    }\n\n    /**\n     * Invalidate all current login sessions for this user.\n     */\n    public void logOut(Response response) {\n        clearSessionTok();\n        removeLoginCookies(response);\n    }\n\n    /**\n     * See if there is a logged in user, and log them out if they are logged in.\n     */\n    public static void logOutUser(Request request, Response response) {\n        User user = getLoggedInUser(request);\n        if (user != null) {\n            user.logOut(response);\n        } else {\n            // If no logged in user, just delete the session cookies\n            removeLoginCookies(response);\n        }\n    }\n\n    /**\n     * Create a new authentication token for user and save session cookie.\n     * \n     * @throws UnauthorizedException\n     *             if the user is not whitelisted for login, or their login session has expired.\n     */\n    public void logIn(Response response) throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(id)) {\n\n            // Create new session token\n            sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n            \n            // Create new random CSRF token every time user logs in\n            csrfTok = CSRF.generateRandomCSRFToken();\n            \n            if (sessionTokHasExpired()) {\n                // Shouldn't happen, since we just created session tok, but just in case\n                clearSessionTok();\n                throw new UnauthorizedException(\"Couldn't create auth session\");\n            }\n\n            // Save tokens in database\n            save();\n\n            // Save login cookies in result\n            response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \"/\", sessionTok.token,\n                    Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n            response.setCookie(new Cookie(Cookie.EMAIL_COOKIE_NAME, \"/\", id, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\"User is not whitelisted for login: \" + id);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Create a user and log them in.\n     * \n     * @throws UnauthorizedException\n     *             if a user with this email addr already exists.\n     */\n    private static User create(String email, String passwordHash, boolean validateEmail, Response response)\n            throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(email)) {\n\n            // Check if a user of this name already exists, and if not, create user record in database.\n            // Should probably be a transaction, although if the record is created twice within a\n            // short period of time, one of the two account creation operations will simply have its\n            // authorization cookie overwritten by the other, so the first session will be logged out.\n            // Either way, users creating an account with the given email address must be in control\n            // of that email account, so this is still secure.\n            if (findByEmail(email) != null) {\n                throw new UnauthorizedException(\"Could not create new user: user \\\"\" + email + \"\\\" already exists\");\n            }\n\n            User user = new User(email);\n\n            user.passwordHash = passwordHash;\n\n            user.createdDate = ZonedDateTime.now().format(DateTimeFormatter.ISO_ZONED_DATE_TIME);\n            user.emailValidated = validateEmail;\n\n            // Log in and save user \n            user.logIn(response);\n\n            return user;\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\"User is not whitelisted for account creation: \" + email);\n        }\n    }\n\n    /**\n     * Create a user from email and password hash, and log them in.\n     * \n     * @throws UnauthorizedException\n     *             if a user with this email addr already exists.\n     */\n    public static User create(String email, String passwordHash, Response response) throws UnauthorizedException {\n        return create(email, passwordHash, /* validateEmail = */false, response);\n    }\n\n    /**\n     * Create a user from a Persona login, and log them in.\n     *\n     * @throws UnauthorizedException\n     *             if a user with this email addr already exists.\n     */\n    public static User createFederatedLoginUser(String email, Response response) throws UnauthorizedException {\n        return create(email, FEDERATED_LOGIN_PASSWORD_HASH_PLACEHOLDER, /* validateEmail = */true, response);\n    }\n}\n", "/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.request;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CACHE_CONTROL;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.DATE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ETAG;\nimport static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;\nimport static io.netty.handler.codec.http.HttpHeaderNames.EXPIRES;\nimport static io.netty.handler.codec.http.HttpHeaderNames.LAST_MODIFIED;\nimport static io.netty.handler.codec.http.HttpHeaderNames.PRAGMA;\nimport static io.netty.handler.codec.http.HttpHeaderNames.SERVER;\nimport static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;\nimport static io.netty.handler.codec.http.HttpHeaderValues.GZIP;\nimport static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\nimport gribbit.auth.CSRF;\nimport gribbit.auth.Cookie;\nimport gribbit.auth.User;\nimport gribbit.response.ErrorResponse;\nimport gribbit.response.HTMLPageResponse;\nimport gribbit.response.HTMLResponse;\nimport gribbit.response.NotModifiedResponse;\nimport gribbit.response.Response;\nimport gribbit.response.flashmsg.FlashMessage;\nimport gribbit.route.RouteHandler;\nimport gribbit.route.RouteHandlerAuthAndValidatedEmailRequired;\nimport gribbit.route.RouteHandlerAuthRequired;\nimport gribbit.route.RouteInfo;\nimport gribbit.server.GribbitServer;\nimport gribbit.server.config.GribbitProperties;\nimport gribbit.server.siteresources.CacheExtension;\nimport gribbit.server.siteresources.CacheExtension.HashInfo;\nimport gribbit.util.Log;\nimport gribbit.util.WebUtils;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufOutputStream;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpResponse;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpChunkedInput;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpHeaderUtil;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.codec.http.ServerCookieEncoder;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.DiskAttribute;\nimport io.netty.handler.codec.http.multipart.DiskFileUpload;\nimport io.netty.handler.codec.http.multipart.FileUpload;\nimport io.netty.handler.codec.http.multipart.HttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.PingWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.PongWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;\nimport io.netty.handler.ssl.NotSslRecordException;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedFile;\nimport io.netty.util.CharsetUtil;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.zip.GZIPOutputStream;\n\npublic class HttpRequestHandler extends SimpleChannelInboundHandler<Object> {\n\n    private Request request;\n\n    private boolean closeAfterWrite = false;\n    private boolean addKeepAliveHeader = false;\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    // Use disk for HTTP data if size >16kB \n    private static final HttpDataFactory factory = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);\n\n    static {\n        // Delete temporary files on exit\n        DiskFileUpload.deleteOnExitTemporaryFile = true;\n        DiskAttribute.deleteOnExitTemporaryFile = true;\n        // Use system temp directory\n        DiskFileUpload.baseDirectory = null;\n        DiskAttribute.baseDirectory = null;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    private HttpPostRequestDecoder decoder;\n\n    private void destroyDecoder() {\n        if (request != null) {\n            try {\n                // Release any temporary files\n                request.releasePostFileUploadParams();\n            } catch (Exception e) {\n            }\n        }\n        if (decoder != null) {\n            try {\n                decoder.cleanFiles();\n                decoder.destroy();\n                decoder = null;\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Set Date and cache-related headers.\n     * \n     * TODO: read http://www.mobify.com/blog/beginners-guide-to-http-cache-headers/ TODO: read\n     * https://www.mnot.net/cache_docs/\n     */\n    private void setDateAndCacheHeaders(HttpHeaders httpHeaders, ZonedDateTime timeNow, long lastModifiedEpochSeconds,\n            long hashKeyMaxRemainingAgeSeconds, String hashKey) {\n        // Date header uses server time, and should use the same clock as Expires and Last-Modified\n        httpHeaders.set(DATE, timeNow.format(DateTimeFormatter.RFC_1123_DATE_TIME));\n\n        // Last-Modified is used to determine whether a Not Modified response should be returned on the next request\n        if (lastModifiedEpochSeconds > 0) {\n            // Add last modified header to cacheable resources. This is needed because Chrome sends\n            // \"Cache-Control: max-age=0\" when the user types in a URL and hits enter, or hits refresh.\n            // In these circumstances, sending back \"Cache-Control: public, max-age=31536000\" does\n            // no good, because the browser has already requested the resource rather than relying on\n            // its cache. By setting the last modified header for all cacheable resources, we can\n            // at least send \"Not Modified\" as a response if the resource has not been modified,\n            // which doesn't save on roundtrips, but at least saves on re-transferring the resources\n            // to the browser when they're already in the browser's cache.\n            httpHeaders.set(\n                    LAST_MODIFIED,\n                    ZonedDateTime.ofInstant(Instant.ofEpochSecond(lastModifiedEpochSeconds), ZoneId.of(\"UTC\")).format(\n                            DateTimeFormatter.RFC_1123_DATE_TIME));\n        }\n\n        // Cache hashed URIs forever (or for the specified amount of time)\n        if (hashKey != null) {\n            // Negative max age => cache indefinitely (although the spec only allows for one year, or 31536000 seconds)\n            long maxAgeSeconds = hashKeyMaxRemainingAgeSeconds < 0 ? 31536000 : hashKeyMaxRemainingAgeSeconds;\n\n            // Cache hash URIs for one year\n            httpHeaders.set(CACHE_CONTROL, \"public, max-age=\" + maxAgeSeconds);\n            httpHeaders.set(EXPIRES, timeNow.plusSeconds(maxAgeSeconds).format(DateTimeFormatter.RFC_1123_DATE_TIME));\n            httpHeaders.set(ETAG, hashKey);\n        }\n\n        if (hashKey == null && lastModifiedEpochSeconds == 0) {\n            // Disable caching for all resources that don't have a last modified time (all static file\n            // resources have a last modified time, so these headers will never be set for files, and \n            // they won't be set for dynamic resources that don't manually set a last modified time).\n            // Without these headers, the server will not have a last modified timestamp to check\n            // against its own timestamp on subsequent requests, so cannot return Not Modified.\n            // This is the minimum necessary set of headers for disabling caching, see http://goo.gl/yXGd2x\n            httpHeaders.add(CACHE_CONTROL, \"no-cache, no-store, must-revalidate\"); // HTTP 1.1\n            httpHeaders.add(PRAGMA, \"no-cache\"); // HTTP 1.0\n            httpHeaders.add(EXPIRES, \"0\"); // Proxies\n        }\n\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Call the route handler for the given route. */\n    private static Response getResponseForRoute(RouteInfo route, Request req, User user) throws Exception {\n        Response response;\n        try {\n            // Call the RestHandler for the route\n            response = route.callHandler(req, user);\n\n        } catch (Exception e) {\n            Log.exception(\"Exception while handling URI \" + req.getURI(), e);\n            try {\n                // Call Internal Server Error handler on exception\n                response = GribbitServer.siteResources.getInternalServerErrorRoute().callHandler(req, user);\n            } catch (Exception e1) {\n                // Fallback in case there's an exception in the Internal Server Error handler\n                Log.exception(\"Error in internal server error handler while handling URI \" + req.getURI(), e1);\n                response = new ErrorResponse(HttpResponseStatus.INTERNAL_SERVER_ERROR, \"Internal Server Error\");\n            }\n        }\n        return response;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Call the given error handler route. */\n    private static Response getResponseForErrorHandlerRoute(RouteInfo route, Request req, User user) throws Exception {\n        // Temporarily replace the method on the original route with a GET request on the error handler's route\n        String origURI = req.getURI();\n        HttpMethod origMethod = req.getMethod();\n        req.setURI(route.getRoutePath());\n        req.setMethod(HttpMethod.GET);\n        // Call the error handler\n        Response response = getResponseForRoute(route, req, user);\n        req.setURI(origURI);\n        req.setMethod(origMethod);\n        return response;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Serve a static file. */\n    private void serveStaticFile(String reqURI, String hashKey, File staticResourceFile, long lastModifiedEpochSeconds,\n            ChannelHandlerContext ctx) throws Exception {\n\n        RandomAccessFile fileToServe = null;\n        try {\n            // Create new RandomAccessFile (which allows us to find file length etc.)\n            fileToServe = new RandomAccessFile(staticResourceFile, \"r\");\n\n            // -----------------------------------------\n            // Serve a static file (not authenticated)\n            // -----------------------------------------\n\n            DefaultHttpResponse httpRes = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            httpRes.headers().add(\"Server\", GribbitServer.SERVER_IDENTIFIER);\n\n            long fileLength = fileToServe.length();\n            httpRes.headers().set(CONTENT_LENGTH, Long.toString(fileLength));\n            WebUtils.setContentTypeHeaders(httpRes.headers(), staticResourceFile.getPath());\n\n            // If the file contents have changed since the last time the file was hashed,\n            // schedule the file to be hashed in the background so that future references to the\n            // file's URI in a src/href attribute of served HTML templates will include a hash\n            // URI rather than the original URI for the file, allowing the browser to cache the\n            // file indefinitely until it changes.\n            CacheExtension.updateHashURI(reqURI, staticResourceFile);\n\n            // If file was already cached, and the request URI included the hash key, then this is\n            // the first time this client has fetched this file since the browser cache was last\n            // cleared. Mark this resource as indefinitely cached. If the file is not being served\n            // on a hash URI, then at least set the Last-Modified header, so that if the client\n            // requests the same unmodified resource again on the same non-hash URI, the server can\n            // return Not Modified instead of serving the contents of the file.\n            setDateAndCacheHeaders(httpRes.headers(), ZonedDateTime.now(), lastModifiedEpochSeconds, //\n                    hashKey != null ? /* cache indefinitely: */-1 : /* ignored if hashKey == null: */0, hashKey);\n\n            if (addKeepAliveHeader) {\n                httpRes.headers().add(CONNECTION, KEEP_ALIVE);\n            }\n\n            // Write HTTP headers to channel\n            ctx.write(httpRes);\n\n            // Write file content to channel.\n            // Can add ChannelProgressiveFutureListener to sendFileFuture if we need to track\n            // progress (e.g. to update user's UI over a web socket to show download progress.)\n            ChannelFuture sendFileFuture;\n            ChannelFuture lastContentFuture;\n            if (ctx.pipeline().get(SslHandler.class) == null) {\n                // Use FileRegions if possible, which supports zero-copy / mmio\n                sendFileFuture =\n                        ctx.write(new DefaultFileRegion(fileToServe.getChannel(), 0, fileLength),\n                                ctx.newProgressivePromise());\n                // Write the end marker\n                lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                // Can't use FileRegions / zero-copy with SSL\n                sendFileFuture =\n                        ctx.write(new HttpChunkedInput(new ChunkedFile(fileToServe, 0, fileLength, 1)),\n                                ctx.newProgressivePromise());\n                // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n                // See https://github.com/netty/netty/commit/4ba2ce3cbbc55391520cfc98a7d4227630fbf978\n                lastContentFuture = sendFileFuture;\n            }\n\n            //            sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n            //                @Override\n            //                public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n            //                    if (total < 0) { // total unknown\n            //                        System.err.println(future.channel() + \" Transfer progress: \" + progress);\n            //                    } else {\n            //                        System.err.println(future.channel() + \" Transfer progress: \" + progress + \" / \" + total);\n            //                    }\n            //                }\n            //\n            //                @Override\n            //                public void operationComplete(ChannelProgressiveFuture future) {\n            //                    System.err.println(future.channel() + \" Transfer complete.\");\n            //                }\n            //            });\n\n            // Close connection after flush if needed, and close file after flush \n            final RandomAccessFile fileToClose = fileToServe;\n            lastContentFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    if (closeAfterWrite) {\n                        future.channel().close();\n                    }\n                    try {\n                        fileToClose.close();\n                    } catch (IOException e) {\n                    }\n                }\n            });\n\n        } catch (Exception e) {\n            if (fileToServe != null) {\n                try {\n                    fileToServe.close();\n                } catch (IOException e1) {\n                }\n            }\n            throw new RuntimeException(\"Exception serving static file\", e);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Serve an HTTP response (anything other than a static file). */\n    private void serveHttpResponse(String reqURI, Response response, boolean isHEAD, boolean acceptEncodingGzip,\n            ZonedDateTime timeNow, boolean hashTheResponse, long hashKeyMaxRemainingAgeSeconds, String hashKey,\n            ChannelHandlerContext ctx) throws Exception {\n\n        // Add any pending flash messages to the response, if the response is an HTML page\n        if (response instanceof HTMLPageResponse) {\n            // Add flash messages to response template, if any\n            ArrayList<FlashMessage> flashMessages = request.getFlashMessages();\n            if (flashMessages != null) {\n                // Render pending flash messages into the HTML page\n                ((HTMLPageResponse) response).setFlashMessages(flashMessages);\n                // Clear the flash message cookie\n                response.deleteCookie(Cookie.FLASH_COOKIE_NAME);\n            }\n        } else {\n            // Store any un-displayed flash messages back in the cookie\n            ArrayList<FlashMessage> flashMessages = request.getFlashMessages();\n            if (flashMessages != null) {\n                response.setCookie(new Cookie(Cookie.FLASH_COOKIE_NAME, \"/\",\n                        FlashMessage.toCookieString(flashMessages), 60));\n            }\n        }\n\n        // Get the content of the response as a byte buffer.\n        ByteBuf content;\n        String contentType;\n        if (response instanceof HTMLResponse) {\n            // If \"?_getmodel=1\" is appended to the request URL of a request that returns an HTML response,\n            // then the data model backing the response will be returned as JSON instead of rendered HTML.\n            boolean isGetModelRequest = GribbitProperties.ALLOW_GET_MODEL && request.isGetModelRequest();\n            content = ((HTMLResponse) response).getContent(isGetModelRequest);\n            contentType = isGetModelRequest ? \"application/json;charset=utf-8\" : response.getContentType();\n        } else {\n            // Not a \"getmodel\" request, just get the content from the response\n            content = response.getContent();\n            contentType = response.getContentType();\n        }\n        byte[] contentBytes = content.array();\n\n        // Gzip content if the configuration property is set to allow gzip, and the client supports gzip encoding,\n        // and the content size is larger than 1kb, and the content type is compressible \n        ByteBuf gzippedContent = null;\n        if (GribbitProperties.CONTENT_GZIP && //\n                acceptEncodingGzip //\n                && content.readableBytes() > 1024 //\n                && WebUtils.isCompressibleContentType(contentType)) {\n            gzippedContent = Unpooled.buffer(/* initialCapacity = */content.readableBytes());\n            // TODO: compare speed to using JZlib.GZIPOutputStream\n            GZIPOutputStream gzipStream = new GZIPOutputStream(new ByteBufOutputStream(gzippedContent));\n            gzipStream.write(contentBytes);\n            gzipStream.close();\n        }\n\n        // Create a FullHttpResponse object that wraps the response status and content\n        HttpResponseStatus status = response.getStatus();\n        DefaultFullHttpResponse httpRes = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, //\n                gzippedContent != null ? gzippedContent : content);\n        httpRes.headers().set(CONTENT_TYPE, contentType);\n        httpRes.headers().set(CONTENT_LENGTH,\n                Integer.toString(gzippedContent != null ? gzippedContent.readableBytes() : content.readableBytes()));\n        if (gzippedContent != null) {\n            httpRes.headers().set(CONTENT_ENCODING, GZIP);\n        }\n\n        httpRes.headers().add(SERVER, GribbitServer.SERVER_IDENTIFIER);\n\n        // Add an Accept-Encoding: gzip header to the response to let the client know that in future\n        // it can send compressed requests. (This header is probably ignored by most clients, because\n        // on initial request they don't know yet if the server can accept compressed content, but\n        // there must be clients out there that look for this header and compress content on the\n        // second and subsequent requests? See http://stackoverflow.com/a/1450163/3950982 )\n        httpRes.headers().add(ACCEPT_ENCODING, \"gzip\");\n\n        // Set date and cache headers\n        setDateAndCacheHeaders(httpRes.headers(), timeNow, response.getLastModifiedEpochSeconds(),\n                hashKeyMaxRemainingAgeSeconds, hashKey);\n\n        // If the response needs hashing, and the response does not have an error status, then schedule the\n        // content of the response for hashing, and store a mapping from the original request URI to the\n        // hash URI so that future HTML responses that have src/href attributes that contain this request\n        // URI will replace this request URI with the hash URI instead. This will mean the client will\n        // fetch that hash URI only once until it expires in the cache, so that on subsequent requests,\n        // the linked resource won't even be requested from the server.\n        if (hashTheResponse && status == HttpResponseStatus.OK) {\n            CacheExtension.updateHashURI(reqURI, content, response.getLastModifiedEpochSeconds());\n        }\n\n        // Release the content ByteBuf after last usage if gzippedContent is being used instead\n        if (gzippedContent != null) {\n            content.release();\n        }\n\n        if (isHEAD) {\n            // Don't return a body for HEAD requests (but still return the content length,\n            // set in the header above)\n            httpRes.content().clear();\n        }\n\n        // Delete requested cookies in the response\n        HashSet<String> cookiesToDelete = response.getCookiesToDelete();\n        if (cookiesToDelete != null) {\n            for (String cookieName : cookiesToDelete) {\n                // Log.fine(\"Cookie to delete for req \" + reqURI + \" : \" + cookieName);\n                ArrayList<Cookie> allCookiesWithName = request.getAllCookiesWithName(cookieName);\n                if (allCookiesWithName != null) {\n                    for (Cookie cookie : allCookiesWithName) {\n                        // Delete all cookies with the requested name (there may be multiple cookies\n                        // with this name but with different paths)\n                        String deleteCookieStr =\n                                ServerCookieEncoder.encode(Cookie.deleteCookie(cookie).toNettyCookie());\n                        httpRes.headers().add(SET_COOKIE, deleteCookieStr);\n                    }\n                }\n            }\n        }\n\n        // Set requested cookies in the response\n        ArrayList<Cookie> cookiesToSet = response.getCookiesToSet();\n        if (cookiesToSet != null) {\n            for (Cookie cookie : cookiesToSet) {\n                if (cookiesToDelete != null && cookiesToDelete.contains(cookie.getName())) {\n                    Log.warning(\"Tried to delete and set the cookie \\\"\" + cookie.getName()\n                            + \"\\\" in the same response -- ignoring the set request\");\n                } else {\n                    String setCookieStr = ServerCookieEncoder.encode(cookie.toNettyCookie());\n                    httpRes.headers().add(SET_COOKIE, setCookieStr);\n                }\n            }\n        }\n\n        // Add any custom headers from the Response object\n        if (response.getCustomHeaders() != null) {\n            for (Entry<String, String> header : response.getCustomHeaders().entrySet()) {\n                httpRes.headers().add(header.getKey(), header.getValue());\n            }\n        }\n\n        // Close the connection after serving the response if the response status is anything other than OK\n        if (addKeepAliveHeader && status == HttpResponseStatus.OK) {\n            httpRes.headers().add(CONNECTION, KEEP_ALIVE);\n        }\n\n        // closeAfterWrite = true;  // FIXME: test this, it doesn't seem to work ====================================================================\n\n        if (ctx.channel().isOpen()) {\n            // Check Channel.isWritable() to prevent OutOfMemoryError,\n            // see http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#10.0\n            long startTime = System.currentTimeMillis();\n            while (!ctx.channel().isWritable() && (System.currentTimeMillis() - startTime < 5000)) {\n                // TODO: replace this spinlock (usually channel is immediately writeable;\n                // is this even needed?)\n            }\n            if (ctx.channel().isWritable()) {\n                // Write the ByteBuffer returned by httpRes.content() back into the pipeline\n                // See http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#4.0\n                ChannelFuture future = ctx.channel().writeAndFlush(httpRes);\n\n                // Close the connection after the write operation is done if necessary.\n                // TODO: Apache closes KeepAlive connections after a few seconds,\n                // see http://en.wikipedia.org/wiki/HTTP_persistent_connection\n                // TODO: implement a stale connection tracker\n                if (closeAfterWrite || status != HttpResponseStatus.OK) { // FIXME: should I close the channel for redirects? (probably not...)\n                    future.addListener(ChannelFutureListener.CLOSE);\n                }\n\n            } else {\n                // Tried for a period of time but could not send response; close channel\n                ctx.channel().close();\n                throw new RuntimeException(\"Could not send response after repeated attempts\");\n            }\n        } else {\n            // Client already closed the connection, nothing can be sent\n            // Log.info(\"Channel closed by client before response sent\");\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Websocket handshaker. */\n    private WebSocketServerHandshaker handshaker;\n\n    /** The user that was authenticated when the websocket upgrade was requested. */\n    private User wsAuthenticatedUser;\n\n    /** Handle a websocket frame. */\n    private void handleWebsocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        // Check for closing frame\n        if (frame instanceof CloseWebSocketFrame) {\n            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());\n            return;\n        }\n        if (frame instanceof PingWebSocketFrame) {\n            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));\n            return;\n        }\n        if (!(frame instanceof TextWebSocketFrame)) {\n            throw new UnsupportedOperationException(String.format(\"%s frame types not supported\", frame.getClass()\n                    .getName()));\n        }\n\n        // TODO: placeholder\n        String requestText = ((TextWebSocketFrame) frame).text();\n        String responseText =\n                requestText.toUpperCase() + \" -- \"\n                        + (wsAuthenticatedUser == null ? \"not logged in\" : wsAuthenticatedUser.id);\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseText));\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    private static void sendHttpErrorResponse(ChannelHandlerContext ctx, HttpRequest req, FullHttpResponse res) {\n        // Generate an error page if response getStatus code is not OK (200).\n        if (res.status().code() != 200) {\n            ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8);\n            res.content().writeBytes(buf);\n            buf.release();\n            res.headers().set(CONTENT_TYPE, \"text/plain;charset=utf-8\");\n            HttpHeaderUtil.setContentLength(res, res.content().readableBytes());\n        }\n        ChannelFuture f = ctx.channel().writeAndFlush(res);\n        if (req == null || !HttpHeaderUtil.isKeepAlive(req) || res.status().code() != 200) {\n            f.addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Decode an HTTP message. */\n    @Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\"REQUEST: \" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\"100-continue\")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\"UTF-8\") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\"Got unknown data chunk type: \" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\"Unsupported HTTP method \" + request.getMethod().name() + \" for path \" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\"HTTP method \" + request.getMethod().name() + \" not implemented in handler \"\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \"/\", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            // FIXME: Make these into class annotations\n            String websocketPath = \"/websocket\";\n            boolean isAuthenticatedWebsocket = true;\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations, rather than using hardcoded \"/websocket\"\n                    && reqURI.endsWith(websocketPath)) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)\n                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n                // http://tools.ietf.org/html/rfc6455#page-7\n                CharSequence origin = request.getOrigin();\n                URI originUri = null;\n                if (origin != null && origin.length() > 0) {\n                    try {\n                        // Try parsing origin URI\n                        originUri = new URI(origin.toString());\n                    } catch (Exception e) {\n                    }\n                }\n                // If port number is set but it is the default for the URI scheme, revert the port number\n                // back to -1 (which means unspecified), so that it matches the server port number, \n                // which is unspecified when serving http on port 80 and https on port 443\n                int originPort = originUri == null ? -1 //\n                        : originUri.getPort() == 80 && \"http\".equals(originUri.getScheme()) ? -1 //\n                                : originUri.getPort() == 443 && \"https\".equals(originUri.getScheme()) ? -1 //\n                                        : originUri.getPort();\n                // Scheme, host and port all must match to forbid cross-origin requests\n                if (originUri == null //\n                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //\n                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //\n                        || GribbitServer.uri.getPort() != originPort) { //\n                    // Reject scripted requests to open this websocket from a different domain\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n                // Log.info(\"Origin: \" + origin.toString());\n\n                if (isAuthenticatedWebsocket) {\n                    // For authenticated websockets, check if the user is logged in\n                    User loggedInUser = User.getLoggedInUser(request);\n                    if (loggedInUser == null) {\n                        // Not logged in, so can't connect to this websocket\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n\n                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \"_csrf\";\n                    // the passed token must match the user's CSRF token. This means the websocket URL has to\n                    // be dynamically generated and inserted into the webpage that opened the websocket.\n                    // TODO: generate this URL an insert into the page somehow\n                    String csrfTok = loggedInUser.csrfTok;\n                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)\n                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {\n                        // No valid CSRF token in User object\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n                    String csrfParam = request.getQueryParam(\"_csrf\");\n                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {\n                        // The CSRF URL query parameter is missing, or doesn't match the user's token \n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;                        \n                    }\n\n                    // Record which user was authenticated when the websocket upgrade request was made.\n                    // TODO: Also provide a means for revoking user's session while WS is still open,\n                    // e.g. poll the user table every few seconds to see if user's session token has\n                    // changed in the database? (Although this would mean that logging in on a new\n                    // device would log you out of all other sessions...)\n                    wsAuthenticatedUser = loggedInUser;\n                }\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI + \"\\tfile://\"\n                                + staticResourceFile.getPath() + \"\\t\" + HttpResponseStatus.OK + \"\\t\"\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \"Not Modified\" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\"Didn't generate a response\");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\"Didn't generate a response\");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI\n                            + (request.getMethod() == origReqMethod ? \"\" : \"\\t\" + request.getMethod()) + \"\\t\" + status\n                            + \"\\t\" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\"favicon.ico\") || reqURI.endsWith(\"/favicon.ico\")))) {\n                // Log at level \"fine\" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \"warning\" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        // Release HTTP decoder resources, including any file uploads that were received in a POST\n        // request and stored in /tmp\n        destroyDecoder();\n\n        if (cause instanceof NotSslRecordException) {\n            ctx.channel().close();\n            return;\n        }\n        if (\"Connection reset by peer\".equals(cause.getMessage())) {\n            // (No need to log the backtrace in this case)\n            // Log.info(cause.getMessage());            \n        } else {\n            // Log exception with backtrace\n            Log.exception(\"Uncaught exception\", cause);\n        }\n        if (ctx.channel().isActive()) {\n            sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR));\n        }\n    }\n}\n", "/**\n * This file is part of the Gribbit Web Framework.\n * \n *     https://github.com/lukehutch/gribbit\n * \n * @author Luke Hutchison\n * \n * --\n * \n * @license Apache 2.0 \n * \n * Copyright 2015 Luke Hutchison\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage gribbit.request;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_CHARSET;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_LANGUAGE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.COOKIE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.HOST;\nimport static io.netty.handler.codec.http.HttpHeaderNames.IF_MODIFIED_SINCE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.ORIGIN;\nimport static io.netty.handler.codec.http.HttpHeaderNames.REFERER;\nimport static io.netty.handler.codec.http.HttpHeaderNames.USER_AGENT;\nimport gribbit.auth.Cookie;\nimport gribbit.response.flashmsg.FlashMessage;\nimport io.netty.handler.codec.http.CookieDecoder;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.QueryStringDecoder;\nimport io.netty.handler.codec.http.multipart.FileUpload;\n\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Request {\n    private long reqReceivedTimeEpochMillis;\n    private HttpMethod method;\n    private String requestor;\n    private String host;\n    private String path;\n    private CharSequence accept;\n    private CharSequence acceptCharset;\n    private CharSequence acceptLanguage;\n    private boolean acceptEncodingGzip;\n    private CharSequence referer;\n    private CharSequence userAgent;\n    private long ifModifiedSinceEpochSecond = 0;\n\n    private HashMap<String, ArrayList<Cookie>> cookieNameToCookies;\n    private HashMap<String, String> postParamToValue;\n    private HashMap<String, FileUpload> postParamToFileUpload;\n    private Map<String, List<String>> queryParamToVals;\n\n    /**\n     * Header for CORS, and for protecting against CSWSH. See:\n     * \n     * http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n     * \n     * http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n     **/\n    private CharSequence origin;\n\n    /**\n     * Header for CSRF protection of AJAX requests (regular GETs and POSTs don't allow for header manipulation.)\n     * \n     * See https://nealpoole.com/blog/2010/11/preventing-csrf-attacks-with-ajax-and-http-headers/\n     */\n    private CharSequence xRequestedWith;\n\n    /**\n     * If set to true by appending \"?_getmodel=1\" to the URL, then return the data model backing an HTML page, not the\n     * rendered page itself.\n     */\n    private boolean isGetModelRequest;\n\n    /** Flash messages. */\n    private ArrayList<FlashMessage> flashMessages;\n\n    // -----------------------------------------------------------------------------------------------------\n\n    public Request(HttpRequest httpReq) {\n        this.reqReceivedTimeEpochMillis = System.currentTimeMillis();\n        HttpHeaders headers = httpReq.headers();\n\n        // Parse and decode/decrypt cookies\n        for (CharSequence cookieHeader : headers.getAll(COOKIE)) {\n            for (io.netty.handler.codec.http.Cookie nettyCookie : CookieDecoder.decode(cookieHeader.toString())) {\n                // Log.fine(\"Cookie in request: \" + nettyCookie);\n                if (this.cookieNameToCookies == null) {\n                    this.cookieNameToCookies = new HashMap<>();\n                }\n                String cookieName = nettyCookie.name();\n                Cookie cookie = new Cookie(nettyCookie);\n\n                // Multiple cookies may be present in the request with the same name but with different paths\n                ArrayList<Cookie> cookiesWithThisName = this.cookieNameToCookies.get(cookieName);\n                if (cookiesWithThisName == null) {\n                    this.cookieNameToCookies.put(cookieName, cookiesWithThisName = new ArrayList<>());\n                }\n                cookiesWithThisName.add(cookie);\n            }\n        }\n\n        this.method = httpReq.method();\n\n        CharSequence host = headers.get(HOST);\n        this.host = host == null ? null : host.toString();\n\n        this.xRequestedWith = headers.get(\"X-Requested-With\");\n        this.accept = headers.get(ACCEPT);\n        this.acceptCharset = headers.get(ACCEPT_CHARSET);\n        this.acceptLanguage = headers.get(ACCEPT_LANGUAGE);\n        this.origin = headers.get(ORIGIN);\n        this.referer = headers.get(REFERER);\n        this.userAgent = headers.get(USER_AGENT);\n\n        CharSequence acceptEncoding = headers.get(ACCEPT_ENCODING);\n        this.acceptEncodingGzip = acceptEncoding != null && acceptEncoding.toString().toLowerCase().contains(\"gzip\");\n\n        CharSequence cacheDateHeader = headers.get(IF_MODIFIED_SINCE);\n        if (cacheDateHeader != null && cacheDateHeader.length() > 0) {\n            this.ifModifiedSinceEpochSecond =\n                    ZonedDateTime.parse(cacheDateHeader, DateTimeFormatter.RFC_1123_DATE_TIME).toEpochSecond();\n        }\n\n        // Decode the path.\n        QueryStringDecoder decoder = new QueryStringDecoder(httpReq.uri());\n        this.path = decoder.path();\n        this.queryParamToVals = decoder.parameters();\n\n        // Look for _getmodel=1 query parameter setting\n        String getModel = this.getQueryParam(\"_getmodel\");\n        if (getModel != null) {\n            this.isGetModelRequest = getModel.equals(\"1\");\n            // Remove _getmodel param so that user doesn't see it\n            this.queryParamToVals.remove(\"_getmodel\");\n        }\n\n        // Get flash messages from cookie, if any\n        this.flashMessages = FlashMessage.fromCookieString(getCookieValue(Cookie.FLASH_COOKIE_NAME));\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public String getPostParam(String paramName) {\n        if (postParamToValue == null) {\n            return null;\n        } else {\n            return postParamToValue.get(paramName);\n        }\n    }\n\n    public void setPostParam(String name, String value) {\n        if (postParamToValue == null) {\n            postParamToValue = new HashMap<>();\n        }\n        postParamToValue.put(name, value);\n    }\n\n    public Set<String> getPostParamNames() {\n        if (postParamToValue == null) {\n            return null;\n        } else {\n            return postParamToValue.keySet();\n        }\n    }\n\n    public void setPostFileUploadParam(String name, FileUpload fileUpload) {\n        if (postParamToFileUpload == null) {\n            postParamToFileUpload = new HashMap<>();\n        }\n        FileUpload old = postParamToFileUpload.put(name, fileUpload);\n        if (old != null) {\n            // Shouldn't happen, but just in case there are two file upload params with the same\n            // param name, free the first, since we're overwriting it\n            old.release();\n        }\n    }\n\n    public FileUpload getPostFileUploadParam(String name) {\n        if (postParamToFileUpload == null) {\n            return null;\n        }\n        return postParamToFileUpload.get(name);\n    }\n\n    public void releasePostFileUploadParams() {\n        if (postParamToFileUpload != null) {\n            for (FileUpload fileUpload : postParamToFileUpload.values()) {\n                fileUpload.release();\n            }\n            postParamToFileUpload = null;\n        }\n    }\n\n    void setPostParams(HashMap<String, String> postParamToValue) {\n        this.postParamToValue = postParamToValue;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Return all URL parameters matching the given name, or null if none. */\n    public List<String> getQueryParams(String paramName) {\n        if (queryParamToVals == null) {\n            return null;\n        } else {\n            return queryParamToVals.get(paramName);\n        }\n    }\n\n    /** Return the first URL parameter matching the given name, or null if none. */\n    public String getQueryParam(String paramName) {\n        List<String> list = getQueryParams(paramName);\n        if (list == null || list.isEmpty()) {\n            return null;\n        } else {\n            return list.get(0);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Used for sorting cookies into decreasing order of path length */\n    private static final Comparator<Cookie> cookiePathLengthComparator = new Comparator<Cookie>() {\n        @Override\n        public int compare(Cookie o1, Cookie o2) {\n            return o2.getPath().length() - o1.getPath().length();\n        }\n    };\n\n    /**\n     * Get a collection of lists of cookies -- each list in the collection consists of one or more cookies, where all\n     * cookies in a list have the same name but different paths. (It is possible to receive multiple cookies with the\n     * same name in a request.) Cookie lists are ordered into decreasing order of path length to conform to a \"SHOULD\"\n     * clause in the HTTP header spec.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public Collection<ArrayList<Cookie>> getAllCookies() {\n        if (cookieNameToCookies == null) {\n            return null;\n        } else {\n            Collection<ArrayList<Cookie>> cookieLists = cookieNameToCookies.values();\n            for (ArrayList<Cookie> cookieList : cookieLists) {\n                Collections.sort(cookieList, cookiePathLengthComparator);\n            }\n            return cookieLists;\n        }\n    }\n\n    /**\n     * Get all cookies with the given name, or null if there are no cookies with this name. (There may be multiple\n     * cookies with the same name but with different paths.) The returned list is ordered into decreasing order of path\n     * length to conform to a \"SHOULD\" clause in the HTTP header spec.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public ArrayList<Cookie> getAllCookiesWithName(String cookieName) {\n        if (cookieNameToCookies == null) {\n            return null;\n        } else {\n            ArrayList<Cookie> cookieList = cookieNameToCookies.get(cookieName);\n            if (cookieList != null) {\n                Collections.sort(cookieList, cookiePathLengthComparator);\n            }\n            return cookieList;\n        }\n    }\n\n    /**\n     * Get a cookie by name, or null if there are no cookies with this name. If there is more than one cookie with the\n     * same name, return the cookie with the longest path.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public Cookie getCookie(String cookieName) {\n        ArrayList<Cookie> cookieList = getAllCookiesWithName(cookieName);\n        if (cookieList == null) {\n            return null;\n        } else {\n            return cookieList.get(0);\n        }\n    }\n\n    /**\n     * Get the string value of a named cookie, or null if there are no cookies with this name. If there is more than one\n     * cookie with the same name, return the value of the one with the longest path.\n     * \n     * See http://stackoverflow.com/questions/4056306/how-to-handle-multiple-cookies-with-the-same-name\n     */\n    public String getCookieValue(String cookieName) {\n        Cookie cookie = getCookie(cookieName);\n        if (cookie == null) {\n            return null;\n        } else {\n            return cookie.getValue();\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Compare timestamp in the If-Modified-Since request header, if present, to the given resource timestamp to see if\n     * the resource is newer than any cached version. If the If-Modified-Since header is not set, the timestamp of the\n     * cached version is assumed to be zero (the beginning of the Epoch), so this method will return true. If the passed\n     * resource timestamp is zero, the resource timestamp is assumed to be invalid or unavailable, so we assume the\n     * resource is not cached and return true, indicating that the cached version is out of date and should be served\n     * (or served again).\n     */\n    public boolean cachedVersionIsOlderThan(long resourceTimestampEpochSeconds) {\n        if (resourceTimestampEpochSeconds == 0) {\n            // If the resource timestamp is zero, it's not valid, so don't assume this resource is cached,\n            // by returning true indicating that the cached version is out of date. \n            return true;\n        } else {\n            // Otherwise return true if the resource timestamp is later than the cached version timestamp\n            // (including when the cached version timestamp is zero.)\n            // Note that the HTTP If-Modified-Since header only has single-second granularity.\n            return resourceTimestampEpochSeconds > ifModifiedSinceEpochSecond;\n        }\n    }\n\n    public long getReqReceivedTimeEpochMillis() {\n        return reqReceivedTimeEpochMillis;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /** Add a flash message (a message that will be popped up at the top of a webpage the next time a page is served. */\n    public void addFlashMessage(FlashMessage flashMessage) {\n        if (flashMessages == null) {\n            flashMessages = new ArrayList<>();\n        }\n        flashMessages.add(flashMessage);\n    }\n\n    /** Clear the flash messages. */\n    public void clearFlashMessage() {\n        flashMessages = null;\n    }\n\n    public ArrayList<FlashMessage> getFlashMessages() {\n        return flashMessages;\n    }\n\n    // -----------------------------------------------------------------------------------------------------------------\n\n    public String getURI() {\n        return path.toString();\n    }\n\n    public String getRequestor() {\n        return requestor == null ? \"\" : requestor;\n    }\n\n    public void setRequestor(String requestor) {\n        this.requestor = requestor;\n    }\n\n    public HttpMethod getMethod() {\n        return method;\n    }\n\n    public void setMethod(HttpMethod method) {\n        this.method = method;\n    }\n\n    public void setURI(String uri) {\n        this.path = uri;\n    }\n\n    public CharSequence getHost() {\n        return host;\n    }\n\n    public CharSequence getAccept() {\n        return accept;\n    }\n\n    public CharSequence getAcceptCharset() {\n        return acceptCharset;\n    }\n\n    public CharSequence getAcceptLanguage() {\n        return acceptLanguage;\n    }\n\n    public boolean acceptEncodingGzip() {\n        return acceptEncodingGzip;\n    }\n\n    public CharSequence getReferer() {\n        return referer;\n    }\n\n    public CharSequence getUserAgent() {\n        return userAgent;\n    }\n\n    public CharSequence getOrigin() {\n        return origin;\n    }\n\n    public CharSequence getXRequestedWith() {\n        return xRequestedWith;\n    }\n\n    /**\n     * True if the request URL contained the query parameter \"?_getmodel=1\", in which case return the DataModel backing\n     * an HTML page, and not the rendered page itself.\n     */\n    public boolean isGetModelRequest() {\n        return isGetModelRequest;\n    }\n}\n"], "filenames": ["src/gribbit/auth/Cookie.java", "src/gribbit/auth/User.java", "src/gribbit/request/HttpRequestHandler.java", "src/gribbit/request/Request.java"], "buggy_code_start_loc": [170, 400, 27, 78], "buggy_code_end_loc": [171, 407, 838, 81], "fixing_code_start_loc": [170, 401, 28, 78], "fixing_code_end_loc": [173, 413, 908, 83], "type": "CWE-346", "message": "A vulnerability was found in lukehutch Gribbit. It has been classified as problematic. Affected is the function messageReceived of the file src/gribbit/request/HttpRequestHandler.java. The manipulation leads to missing origin validation in websockets. The name of the patch is 620418df247aebda3dd4be1dda10fe229ea505dd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217716.", "other": {"cve": {"id": "CVE-2014-125071", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-09T21:15:10.093", "lastModified": "2023-01-13T18:31:37.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in lukehutch Gribbit. It has been classified as problematic. Affected is the function messageReceived of the file src/gribbit/request/HttpRequestHandler.java. The manipulation leads to missing origin validation in websockets. The name of the patch is 620418df247aebda3dd4be1dda10fe229ea505dd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217716."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1385"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gribbit_project:gribbit:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-12-31", "matchCriteriaId": "46BCE397-721E-4F80-AACD-C9A8418CDAF9"}]}]}], "references": [{"url": "https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217716", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217716", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd"}}