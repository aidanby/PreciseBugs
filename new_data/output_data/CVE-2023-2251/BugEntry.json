{"buggy_code": ["import type { LineCounter } from './parse/line-counter'\n\nexport type ErrorCode =\n  | 'ALIAS_PROPS'\n  | 'BAD_ALIAS'\n  | 'BAD_DIRECTIVE'\n  | 'BAD_DQ_ESCAPE'\n  | 'BAD_INDENT'\n  | 'BAD_PROP_ORDER'\n  | 'BAD_SCALAR_START'\n  | 'BLOCK_AS_IMPLICIT_KEY'\n  | 'BLOCK_IN_FLOW'\n  | 'DUPLICATE_KEY'\n  | 'IMPOSSIBLE'\n  | 'KEY_OVER_1024_CHARS'\n  | 'MISSING_CHAR'\n  | 'MULTILINE_IMPLICIT_KEY'\n  | 'MULTIPLE_ANCHORS'\n  | 'MULTIPLE_DOCS'\n  | 'MULTIPLE_TAGS'\n  | 'TAB_AS_INDENT'\n  | 'TAG_RESOLVE_FAILED'\n  | 'UNEXPECTED_TOKEN'\n\nexport type LinePos = { line: number; col: number }\n\nexport class YAMLError extends Error {\n  name: 'YAMLParseError' | 'YAMLWarning'\n  code: ErrorCode\n  message: string\n  pos: [number, number]\n  linePos?: [LinePos] | [LinePos, LinePos]\n\n  constructor(\n    name: YAMLError['name'],\n    pos: [number, number],\n    code: ErrorCode,\n    message: string\n  ) {\n    super()\n    this.name = name\n    this.code = code\n    this.message = message\n    this.pos = pos\n  }\n}\n\nexport class YAMLParseError extends YAMLError {\n  constructor(pos: [number, number], code: ErrorCode, message: string) {\n    super('YAMLParseError', pos, code, message)\n  }\n}\n\nexport class YAMLWarning extends YAMLError {\n  constructor(pos: [number, number], code: ErrorCode, message: string) {\n    super('YAMLWarning', pos, code, message)\n  }\n}\n\nexport const prettifyError =\n  (src: string, lc: LineCounter) => (error: YAMLError) => {\n    if (error.pos[0] === -1) return\n    error.linePos = error.pos.map(pos => lc.linePos(pos)) as\n      | [LinePos]\n      | [LinePos, LinePos]\n    const { line, col } = error.linePos[0]\n    error.message += ` at line ${line}, column ${col}`\n\n    let ci = col - 1\n    let lineStr = src\n      .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n      .replace(/[\\n\\r]+$/, '')\n\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n      const trimStart = Math.min(ci - 39, lineStr.length - 79)\n      lineStr = '\u2026' + lineStr.substring(trimStart)\n      ci -= trimStart - 1\n    }\n    if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + '\u2026'\n\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n      // Regexp won't match if start is trimmed\n      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1])\n      if (prev.length > 80) prev = prev.substring(0, 79) + '\u2026\\n'\n      lineStr = prev + lineStr\n    }\n\n    if (/[^ ]/.test(lineStr)) {\n      let count = 1\n      const end = error.linePos[1]\n      if (end && end.line === line && end.col > col) {\n        count = Math.min(end.col - col, 80 - ci)\n      }\n      const pointer = ' '.repeat(ci) + '^'.repeat(count)\n      error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`\n    }\n  }\n", "import * as YAML from 'yaml'\nimport { source } from '../_utils'\n\ntest('fail on map value indented with tab', () => {\n  const src = 'a:\\n\\t1\\nb:\\n\\t2\\n'\n  const doc = YAML.parseDocument(src)\n  expect(doc.errors).not.toHaveLength(0)\n  expect(() => String(doc)).toThrow(\n    'Document with errors cannot be stringified'\n  )\n})\n\ntest('eemeli/yaml#6', () => {\n  const src = 'abc: 123\\ndef'\n  const doc = YAML.parseDocument(src)\n  expect(doc.errors).toMatchObject([{ pos: [9, 12] }])\n})\n\ndescribe('eemeli/yaml#7', () => {\n  test('map', () => {\n    const src = '{ , }\\n---\\n{ 123,,, }\\n'\n    const docs = YAML.parseAllDocuments(src)\n    expect(docs[0].errors).toMatchObject([{ pos: [2, 3] }])\n    expect(docs[1].errors).toMatchObject([{ pos: [16, 17] }, { pos: [17, 18] }])\n  })\n\n  test('seq', () => {\n    const src = '[ , ]\\n---\\n[ 123,,, ]\\n'\n    const docs = YAML.parseAllDocuments(src)\n    expect(docs[0].errors).toMatchObject([{ pos: [2, 3] }])\n    expect(docs[1].errors).toMatchObject([{ pos: [16, 17] }, { pos: [17, 18] }])\n  })\n})\n\ndescribe('block scalars', () => {\n  test('invalid header', () => {\n    const doc = YAML.parseDocument('>99\\n foo\\n')\n    expect(doc.errors).toMatchObject(\n      [\n        'Block scalar header includes extra characters: >99',\n        'Unexpected scalar at node end'\n      ].map(msg => ({ message: expect.stringContaining(msg) }))\n    )\n  })\n  test('missing newline at header end', () => {\n    const doc = YAML.parseDocument('> foo\\n')\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch('Not a YAML token: foo')\n  })\n})\n\ndescribe('block collections', () => {\n  test('mapping with bad indentation', () => {\n    const src = 'foo: \"1\"\\n bar: 2\\n'\n    const doc = YAML.parseDocument(src)\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'All mapping items must start at the same column'\n    )\n    expect(doc.contents).toMatchObject({\n      items: [\n        { key: { value: 'foo' }, value: { value: '1' } },\n        { key: { value: 'bar' }, value: { value: 2 } }\n      ]\n    })\n  })\n\n  test('sequence with bad indentation', () => {\n    const src = '- \"foo\"\\n - bar\\n'\n    const doc = YAML.parseDocument(src)\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'All sequence items must start at the same column'\n    )\n    expect(doc.contents).toMatchObject({\n      items: [{ value: 'foo' }, { items: [{ value: 'bar' }] }]\n    })\n  })\n\n  test('seq item in mapping', () => {\n    const src = 'foo: \"1\"\\n- bar\\n'\n    const doc = YAML.parseDocument(src)\n    expect(doc.errors).toMatchObject(\n      [\n        'A block sequence may not be used as an implicit map key',\n        'Implicit keys need to be on a single line',\n        'Implicit map keys need to be followed by map values'\n      ].map(msg => ({ message: expect.stringContaining(msg) }))\n    )\n    expect(doc.contents).toMatchObject({\n      items: [\n        { key: { value: 'foo' }, value: { value: '1' } },\n        { key: { items: [{ value: 'bar' }] }, value: null }\n      ]\n    })\n  })\n\n  test('doubled value indicator', () => {\n    const doc = YAML.parseDocument('foo : : bar\\n')\n    expect(doc.errors).toMatchObject([\n      {\n        message: source`\n          Nested mappings are not allowed in compact mappings at line 1, column 7:\n\n          foo : : bar\n                ^\n        `\n      }\n    ])\n  })\n\n  test('excessively long key', () => {\n    const doc = YAML.parseDocument(`foo ${'x'.repeat(1024)} : bar\\n`)\n    expect(doc.errors).toMatchObject([\n      {\n        message: source`\n          The : indicator must be at most 1024 chars after the start of an implicit block mapping key at line 1, column 1:\n\n          foo xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u2026\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        `\n      }\n    ])\n  })\n\n  test('key after long comment on empty value (eemeli/yaml#413)', () => {\n    const doc = YAML.parseDocument(source`\n      one:\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n      two: b\n    `)\n    expect(doc.errors).toMatchObject([])\n  })\n\n  test('key after long comment on block map (eemeli/yaml#413)', () => {\n    const doc = YAML.parseDocument(source`\n      one:\n        sub: a\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n      two: b\n    `)\n    expect(doc.errors).toMatchObject([])\n  })\n\n  test('key after long comment on block seq (eemeli/yaml#413)', () => {\n    const doc = YAML.parseDocument(source`\n      one:\n        - a\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n      two: b\n    `)\n    expect(doc.errors).toMatchObject([])\n  })\n})\n\ndescribe('flow collections', () => {\n  test('start only of flow map (eemeli/yaml#8)', () => {\n    const doc = YAML.parseDocument('{')\n    expect(doc.errors).toMatchObject([{ code: 'MISSING_CHAR', pos: [1, 2] }])\n  })\n\n  test('start only of flow sequence (eemeli/yaml#8)', () => {\n    const doc = YAML.parseDocument('[')\n    expect(doc.errors).toMatchObject([{ code: 'MISSING_CHAR', pos: [1, 2] }])\n  })\n\n  test('flow sequence without end', () => {\n    const doc = YAML.parseDocument('[ foo, bar,')\n    expect(doc.errors).toMatchObject([{ code: 'MISSING_CHAR', pos: [11, 12] }])\n  })\n\n  test('doc-end within flow sequence', () => {\n    const doc = YAML.parseDocument('[ foo, bar,\\n...\\n]', {\n      prettyErrors: false\n    })\n    expect(doc.errors).toMatchObject([\n      { code: 'MISSING_CHAR' },\n      { message: 'Unexpected flow-seq-end token in YAML document: \"]\"' },\n      {\n        message:\n          'Source contains multiple documents; please use YAML.parseAllDocuments()'\n      }\n    ])\n  })\n\n  test('block scalar in flow collection', () => {\n    const doc = YAML.parseDocument('{ |\\n foo\\n}')\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'Plain value cannot start with block scalar indicator |'\n    )\n  })\n\n  test('block seq in flow collection', () => {\n    const doc = YAML.parseDocument('{\\n- foo\\n}')\n    expect(doc.errors).toMatchObject([{ code: 'BLOCK_IN_FLOW' }])\n  })\n\n  test('anchor before explicit key indicator in block map', () => {\n    const doc = YAML.parseDocument('&a ? A')\n    expect(doc.errors).toMatchObject([{ code: 'BAD_PROP_ORDER' }])\n  })\n\n  test('anchor before explicit key indicator in flow map', () => {\n    const doc = YAML.parseDocument('{ &a ? A }')\n    expect(doc.errors).toMatchObject([{ code: 'BAD_PROP_ORDER' }])\n  })\n\n  test('flow map with doubled indicator', () => {\n    const doc = YAML.parseDocument('{ foo: : bar }')\n    expect(doc.errors).toMatchObject([{ code: 'UNEXPECTED_TOKEN' }])\n  })\n})\n\ndescribe('comments', () => {\n  test('comment without whitespace after tag', () => {\n    const doc = YAML.parseDocument('!<a>#cc\\nA')\n    expect(doc.errors).toHaveLength(2)\n    expect(doc.errors[0].message).toMatch(\n      'Tags and anchors must be separated from the next token by white space'\n    )\n    expect(doc.errors[1].message).toMatch(\n      'Comments must be separated from other tokens by white space characters'\n    )\n  })\n\n  test('comment without whitespace after value', () => {\n    const doc = YAML.parseDocument('foo: \"bar\"#cc')\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'Comments must be separated from other tokens by white space characters'\n    )\n  })\n})\n\ndescribe('pretty errors', () => {\n  test('eemeli/yaml#6', () => {\n    const src = 'abc: 123\\ndef'\n    const doc = YAML.parseDocument(src, { prettyErrors: true })\n    expect(doc.errors).toMatchObject([\n      {\n        message: source`\n          Implicit map keys need to be followed by map values at line 2, column 1:\n\n          abc: 123\n          def\n          ^^^\n        `,\n        pos: [9, 12],\n        linePos: [\n          { line: 2, col: 1 },\n          { line: 2, col: 4 }\n        ]\n      }\n    ])\n    expect(doc.errors[0]).not.toHaveProperty('source')\n  })\n\n  test('eemeli/yaml#7 maps', () => {\n    const src = '{ , }\\n---\\n{ 123,,, }\\n'\n    const docs = YAML.parseAllDocuments(src, { prettyErrors: true })\n    expect(docs[0].errors).toMatchObject([\n      {\n        message: source`\n          Unexpected , in flow map at line 1, column 3:\n\n          { , }\n            ^\n        `,\n        pos: [2, 3],\n        linePos: [\n          { line: 1, col: 3 },\n          { line: 1, col: 4 }\n        ]\n      }\n    ])\n    expect(docs[0].errors[0]).not.toHaveProperty('source')\n    expect(docs[1].errors).toMatchObject([\n      {\n        code: 'UNEXPECTED_TOKEN',\n        message: source`\n          Unexpected , in flow map at line 3, column 7:\n\n          { 123,,, }\n                ^\n        `,\n        pos: [16, 17],\n        linePos: [\n          { line: 3, col: 7 },\n          { line: 3, col: 8 }\n        ]\n      },\n      {\n        code: 'UNEXPECTED_TOKEN',\n        message: source`\n          Unexpected , in flow map at line 3, column 8:\n\n          { 123,,, }\n                 ^\n        `,\n        pos: [17, 18],\n        linePos: [\n          { line: 3, col: 8 },\n          { line: 3, col: 9 }\n        ]\n      }\n    ])\n    expect(docs[1].errors[0]).not.toHaveProperty('source')\n    expect(docs[1].errors[1]).not.toHaveProperty('source')\n  })\n\n  test('pretty warnings', () => {\n    const src = '%FOO\\n---bar\\n'\n    const doc = YAML.parseDocument(src, { prettyErrors: true })\n    expect(doc.warnings).toMatchObject([{ name: 'YAMLWarning' }])\n  })\n})\n\ndescribe('tags on invalid nodes', () => {\n  test('!!map on scalar', () => {\n    const doc = YAML.parseDocument('!!map foo')\n    expect(doc.warnings).toHaveLength(1)\n    expect(doc.warnings[0].message).toMatch(\n      'Unresolved tag: tag:yaml.org,2002:map'\n    )\n    expect(doc.toJS()).toBe('foo')\n  })\n\n  test('!!str on map', () => {\n    const doc = YAML.parseDocument('!!str { answer: 42 }')\n    expect(doc.warnings).toHaveLength(1)\n    expect(doc.warnings[0].message).toMatch(\n      'Unresolved tag: tag:yaml.org,2002:str'\n    )\n    expect(doc.toJS()).toMatchObject({ answer: 42 })\n  })\n})\n\ndescribe('invalid options', () => {\n  test('unknown schema', () => {\n    expect(() => new YAML.Document(undefined, { schema: 'foo' })).toThrow(\n      /Unknown schema/\n    )\n  })\n\n  test('unknown custom tag', () => {\n    expect(() => new YAML.Document(undefined, { customTags: ['foo'] })).toThrow(\n      /Unknown custom tag/\n    )\n  })\n})\n\ntest('broken document with comment before first node', () => {\n  const doc = YAML.parseDocument('#c\\n*x\\nfoo\\n', { prettyErrors: false })\n  expect(doc.errors).toMatchObject([\n    { message: 'Unexpected scalar at node end' }\n  ])\n})\n\ntest('multiple tags on one node', () => {\n  const doc = YAML.parseDocument('!foo !bar baz\\n')\n  expect(doc.contents).toMatchObject({ value: 'baz', type: 'PLAIN' })\n  expect(doc.errors).toHaveLength(1)\n  expect(doc.warnings).toHaveLength(1)\n})\n\ndescribe('logLevel', () => {\n  // process.emitWarning will throw in Jest if `warning` is an Error instance\n  // due to https://github.com/facebook/jest/issues/2549\n\n  const mock = jest.spyOn(global.process, 'emitWarning').mockImplementation()\n  beforeEach(() => mock.mockClear())\n  afterEach(() => mock.mockRestore())\n\n  test('by default, warn for tag fallback', () => {\n    YAML.parse('!foo bar')\n    const message = source`\n      Unresolved tag: !foo at line 1, column 1:\n\n      !foo bar\n      ^^^^\n    `\n    expect(mock.mock.calls).toMatchObject([[{ message }]])\n  })\n\n  test(\"silence warnings with logLevel: 'error'\", () => {\n    YAML.parse('!foo bar', { logLevel: 'error' })\n    expect(mock).toHaveBeenCalledTimes(0)\n  })\n\n  test(\"silence warnings with logLevel: 'silent'\", () => {\n    YAML.parse('!foo bar', { logLevel: 'silent' })\n    expect(mock).toHaveBeenCalledTimes(0)\n  })\n\n  test(\"silence errors with logLevel: 'silent'\", () => {\n    const res = YAML.parse('foo: bar: baz\\n---\\ndoc2\\n', { logLevel: 'silent' })\n    expect(res).toMatchObject({ foo: { bar: 'baz' } })\n  })\n})\n\ndescribe('Invalid plain first characters', () => {\n  for (const ch of [',', '%', '@', '`'])\n    test(ch, () => {\n      const doc = YAML.parseDocument(`- ${ch}foo`)\n      expect(doc.errors).toMatchObject([{ code: 'BAD_SCALAR_START' }])\n    })\n})\n"], "fixing_code": ["import type { LineCounter } from './parse/line-counter'\n\nexport type ErrorCode =\n  | 'ALIAS_PROPS'\n  | 'BAD_ALIAS'\n  | 'BAD_DIRECTIVE'\n  | 'BAD_DQ_ESCAPE'\n  | 'BAD_INDENT'\n  | 'BAD_PROP_ORDER'\n  | 'BAD_SCALAR_START'\n  | 'BLOCK_AS_IMPLICIT_KEY'\n  | 'BLOCK_IN_FLOW'\n  | 'DUPLICATE_KEY'\n  | 'IMPOSSIBLE'\n  | 'KEY_OVER_1024_CHARS'\n  | 'MISSING_CHAR'\n  | 'MULTILINE_IMPLICIT_KEY'\n  | 'MULTIPLE_ANCHORS'\n  | 'MULTIPLE_DOCS'\n  | 'MULTIPLE_TAGS'\n  | 'TAB_AS_INDENT'\n  | 'TAG_RESOLVE_FAILED'\n  | 'UNEXPECTED_TOKEN'\n\nexport type LinePos = { line: number; col: number }\n\nexport class YAMLError extends Error {\n  name: 'YAMLParseError' | 'YAMLWarning'\n  code: ErrorCode\n  message: string\n  pos: [number, number]\n  linePos?: [LinePos] | [LinePos, LinePos]\n\n  constructor(\n    name: YAMLError['name'],\n    pos: [number, number],\n    code: ErrorCode,\n    message: string\n  ) {\n    super()\n    this.name = name\n    this.code = code\n    this.message = message\n    this.pos = pos\n  }\n}\n\nexport class YAMLParseError extends YAMLError {\n  constructor(pos: [number, number], code: ErrorCode, message: string) {\n    super('YAMLParseError', pos, code, message)\n  }\n}\n\nexport class YAMLWarning extends YAMLError {\n  constructor(pos: [number, number], code: ErrorCode, message: string) {\n    super('YAMLWarning', pos, code, message)\n  }\n}\n\nexport const prettifyError =\n  (src: string, lc: LineCounter) => (error: YAMLError) => {\n    if (error.pos[0] === -1) return\n    error.linePos = error.pos.map(pos => lc.linePos(pos)) as\n      | [LinePos]\n      | [LinePos, LinePos]\n    const { line, col } = error.linePos[0]\n    error.message += ` at line ${line}, column ${col}`\n\n    let ci = col - 1\n    let lineStr = src\n      .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n      .replace(/[\\n\\r]+$/, '')\n\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n      const trimStart = Math.min(ci - 39, lineStr.length - 79)\n      lineStr = '\u2026' + lineStr.substring(trimStart)\n      ci -= trimStart - 1\n    }\n    if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + '\u2026'\n\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n      // Regexp won't match if start is trimmed\n      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1])\n      if (prev.length > 80) prev = prev.substring(0, 79) + '\u2026\\n'\n      lineStr = prev + lineStr\n    }\n\n    if (/[^ ]/.test(lineStr)) {\n      let count = 1\n      const end = error.linePos[1]\n      if (end && end.line === line && end.col > col) {\n        count = Math.max(1, Math.min(end.col - col, 80 - ci))\n      }\n      const pointer = ' '.repeat(ci) + '^'.repeat(count)\n      error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`\n    }\n  }\n", "import * as YAML from 'yaml'\nimport { source } from '../_utils'\n\ntest('fail on map value indented with tab', () => {\n  const src = 'a:\\n\\t1\\nb:\\n\\t2\\n'\n  const doc = YAML.parseDocument(src)\n  expect(doc.errors).not.toHaveLength(0)\n  expect(() => String(doc)).toThrow(\n    'Document with errors cannot be stringified'\n  )\n})\n\ntest('eemeli/yaml#6', () => {\n  const src = 'abc: 123\\ndef'\n  const doc = YAML.parseDocument(src)\n  expect(doc.errors).toMatchObject([{ pos: [9, 12] }])\n})\n\ndescribe('eemeli/yaml#7', () => {\n  test('map', () => {\n    const src = '{ , }\\n---\\n{ 123,,, }\\n'\n    const docs = YAML.parseAllDocuments(src)\n    expect(docs[0].errors).toMatchObject([{ pos: [2, 3] }])\n    expect(docs[1].errors).toMatchObject([{ pos: [16, 17] }, { pos: [17, 18] }])\n  })\n\n  test('seq', () => {\n    const src = '[ , ]\\n---\\n[ 123,,, ]\\n'\n    const docs = YAML.parseAllDocuments(src)\n    expect(docs[0].errors).toMatchObject([{ pos: [2, 3] }])\n    expect(docs[1].errors).toMatchObject([{ pos: [16, 17] }, { pos: [17, 18] }])\n  })\n})\n\ndescribe('block scalars', () => {\n  test('invalid header', () => {\n    const doc = YAML.parseDocument('>99\\n foo\\n')\n    expect(doc.errors).toMatchObject(\n      [\n        'Block scalar header includes extra characters: >99',\n        'Unexpected scalar at node end'\n      ].map(msg => ({ message: expect.stringContaining(msg) }))\n    )\n  })\n  test('missing newline at header end', () => {\n    const doc = YAML.parseDocument('> foo\\n')\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch('Not a YAML token: foo')\n  })\n})\n\ndescribe('block collections', () => {\n  test('mapping with bad indentation', () => {\n    const src = 'foo: \"1\"\\n bar: 2\\n'\n    const doc = YAML.parseDocument(src)\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'All mapping items must start at the same column'\n    )\n    expect(doc.contents).toMatchObject({\n      items: [\n        { key: { value: 'foo' }, value: { value: '1' } },\n        { key: { value: 'bar' }, value: { value: 2 } }\n      ]\n    })\n  })\n\n  test('sequence with bad indentation', () => {\n    const src = '- \"foo\"\\n - bar\\n'\n    const doc = YAML.parseDocument(src)\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'All sequence items must start at the same column'\n    )\n    expect(doc.contents).toMatchObject({\n      items: [{ value: 'foo' }, { items: [{ value: 'bar' }] }]\n    })\n  })\n\n  test('seq item in mapping', () => {\n    const src = 'foo: \"1\"\\n- bar\\n'\n    const doc = YAML.parseDocument(src)\n    expect(doc.errors).toMatchObject(\n      [\n        'A block sequence may not be used as an implicit map key',\n        'Implicit keys need to be on a single line',\n        'Implicit map keys need to be followed by map values'\n      ].map(msg => ({ message: expect.stringContaining(msg) }))\n    )\n    expect(doc.contents).toMatchObject({\n      items: [\n        { key: { value: 'foo' }, value: { value: '1' } },\n        { key: { items: [{ value: 'bar' }] }, value: null }\n      ]\n    })\n  })\n\n  test('doubled value indicator', () => {\n    const doc = YAML.parseDocument('foo : : bar\\n')\n    expect(doc.errors).toMatchObject([\n      {\n        message: source`\n          Nested mappings are not allowed in compact mappings at line 1, column 7:\n\n          foo : : bar\n                ^\n        `\n      }\n    ])\n  })\n\n  test('excessively long key', () => {\n    const doc = YAML.parseDocument(`foo ${'x'.repeat(1024)} : bar\\n`)\n    expect(doc.errors).toMatchObject([\n      {\n        message: source`\n          The : indicator must be at most 1024 chars after the start of an implicit block mapping key at line 1, column 1:\n\n          foo xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u2026\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        `\n      }\n    ])\n  })\n\n  test('key after long comment on empty value (eemeli/yaml#413)', () => {\n    const doc = YAML.parseDocument(source`\n      one:\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n      two: b\n    `)\n    expect(doc.errors).toMatchObject([])\n  })\n\n  test('key after long comment on block map (eemeli/yaml#413)', () => {\n    const doc = YAML.parseDocument(source`\n      one:\n        sub: a\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n      two: b\n    `)\n    expect(doc.errors).toMatchObject([])\n  })\n\n  test('key after long comment on block seq (eemeli/yaml#413)', () => {\n    const doc = YAML.parseDocument(source`\n      one:\n        - a\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n        # large block of text, large block of text, large block of text, large block of text, large block of text,\n      two: b\n    `)\n    expect(doc.errors).toMatchObject([])\n  })\n})\n\ndescribe('flow collections', () => {\n  test('start only of flow map (eemeli/yaml#8)', () => {\n    const doc = YAML.parseDocument('{')\n    expect(doc.errors).toMatchObject([{ code: 'MISSING_CHAR', pos: [1, 2] }])\n  })\n\n  test('start only of flow sequence (eemeli/yaml#8)', () => {\n    const doc = YAML.parseDocument('[')\n    expect(doc.errors).toMatchObject([{ code: 'MISSING_CHAR', pos: [1, 2] }])\n  })\n\n  test('flow sequence without end', () => {\n    const doc = YAML.parseDocument('[ foo, bar,')\n    expect(doc.errors).toMatchObject([{ code: 'MISSING_CHAR', pos: [11, 12] }])\n  })\n\n  test('doc-end within flow sequence', () => {\n    const doc = YAML.parseDocument('[ foo, bar,\\n...\\n]', {\n      prettyErrors: false\n    })\n    expect(doc.errors).toMatchObject([\n      { code: 'MISSING_CHAR' },\n      { message: 'Unexpected flow-seq-end token in YAML document: \"]\"' },\n      {\n        message:\n          'Source contains multiple documents; please use YAML.parseAllDocuments()'\n      }\n    ])\n  })\n\n  test('block scalar in flow collection', () => {\n    const doc = YAML.parseDocument('{ |\\n foo\\n}')\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'Plain value cannot start with block scalar indicator |'\n    )\n  })\n\n  test('block seq in flow collection', () => {\n    const doc = YAML.parseDocument('{\\n- foo\\n}')\n    expect(doc.errors).toMatchObject([{ code: 'BLOCK_IN_FLOW' }])\n  })\n\n  test('anchor before explicit key indicator in block map', () => {\n    const doc = YAML.parseDocument('&a ? A')\n    expect(doc.errors).toMatchObject([{ code: 'BAD_PROP_ORDER' }])\n  })\n\n  test('anchor before explicit key indicator in flow map', () => {\n    const doc = YAML.parseDocument('{ &a ? A }')\n    expect(doc.errors).toMatchObject([{ code: 'BAD_PROP_ORDER' }])\n  })\n\n  test('flow map with doubled indicator', () => {\n    const doc = YAML.parseDocument('{ foo: : bar }')\n    expect(doc.errors).toMatchObject([{ code: 'UNEXPECTED_TOKEN' }])\n  })\n})\n\ndescribe('comments', () => {\n  test('comment without whitespace after tag', () => {\n    const doc = YAML.parseDocument('!<a>#cc\\nA')\n    expect(doc.errors).toHaveLength(2)\n    expect(doc.errors[0].message).toMatch(\n      'Tags and anchors must be separated from the next token by white space'\n    )\n    expect(doc.errors[1].message).toMatch(\n      'Comments must be separated from other tokens by white space characters'\n    )\n  })\n\n  test('comment without whitespace after value', () => {\n    const doc = YAML.parseDocument('foo: \"bar\"#cc')\n    expect(doc.errors).toHaveLength(1)\n    expect(doc.errors[0].message).toMatch(\n      'Comments must be separated from other tokens by white space characters'\n    )\n  })\n})\n\ndescribe('pretty errors', () => {\n  test('eemeli/yaml#6', () => {\n    const src = 'abc: 123\\ndef'\n    const doc = YAML.parseDocument(src, { prettyErrors: true })\n    expect(doc.errors).toMatchObject([\n      {\n        message: source`\n          Implicit map keys need to be followed by map values at line 2, column 1:\n\n          abc: 123\n          def\n          ^^^\n        `,\n        pos: [9, 12],\n        linePos: [\n          { line: 2, col: 1 },\n          { line: 2, col: 4 }\n        ]\n      }\n    ])\n    expect(doc.errors[0]).not.toHaveProperty('source')\n  })\n\n  test('eemeli/yaml#7 maps', () => {\n    const src = '{ , }\\n---\\n{ 123,,, }\\n'\n    const docs = YAML.parseAllDocuments(src, { prettyErrors: true })\n    expect(docs[0].errors).toMatchObject([\n      {\n        message: source`\n          Unexpected , in flow map at line 1, column 3:\n\n          { , }\n            ^\n        `,\n        pos: [2, 3],\n        linePos: [\n          { line: 1, col: 3 },\n          { line: 1, col: 4 }\n        ]\n      }\n    ])\n    expect(docs[0].errors[0]).not.toHaveProperty('source')\n    expect(docs[1].errors).toMatchObject([\n      {\n        code: 'UNEXPECTED_TOKEN',\n        message: source`\n          Unexpected , in flow map at line 3, column 7:\n\n          { 123,,, }\n                ^\n        `,\n        pos: [16, 17],\n        linePos: [\n          { line: 3, col: 7 },\n          { line: 3, col: 8 }\n        ]\n      },\n      {\n        code: 'UNEXPECTED_TOKEN',\n        message: source`\n          Unexpected , in flow map at line 3, column 8:\n\n          { 123,,, }\n                 ^\n        `,\n        pos: [17, 18],\n        linePos: [\n          { line: 3, col: 8 },\n          { line: 3, col: 9 }\n        ]\n      }\n    ])\n    expect(docs[1].errors[0]).not.toHaveProperty('source')\n    expect(docs[1].errors[1]).not.toHaveProperty('source')\n  })\n\n  test('pretty warnings', () => {\n    const src = '%FOO\\n---bar\\n'\n    const doc = YAML.parseDocument(src, { prettyErrors: true })\n    expect(doc.warnings).toMatchObject([{ name: 'YAMLWarning' }])\n  })\n\n  test('repeated CR', () => {\n    const src = '[' + '\\r'.repeat(80)\n    const doc = YAML.parseDocument(src, { prettyErrors: true })\n    expect(doc.errors[0]).not.toHaveProperty('source')\n  })\n})\n\ndescribe('tags on invalid nodes', () => {\n  test('!!map on scalar', () => {\n    const doc = YAML.parseDocument('!!map foo')\n    expect(doc.warnings).toHaveLength(1)\n    expect(doc.warnings[0].message).toMatch(\n      'Unresolved tag: tag:yaml.org,2002:map'\n    )\n    expect(doc.toJS()).toBe('foo')\n  })\n\n  test('!!str on map', () => {\n    const doc = YAML.parseDocument('!!str { answer: 42 }')\n    expect(doc.warnings).toHaveLength(1)\n    expect(doc.warnings[0].message).toMatch(\n      'Unresolved tag: tag:yaml.org,2002:str'\n    )\n    expect(doc.toJS()).toMatchObject({ answer: 42 })\n  })\n})\n\ndescribe('invalid options', () => {\n  test('unknown schema', () => {\n    expect(() => new YAML.Document(undefined, { schema: 'foo' })).toThrow(\n      /Unknown schema/\n    )\n  })\n\n  test('unknown custom tag', () => {\n    expect(() => new YAML.Document(undefined, { customTags: ['foo'] })).toThrow(\n      /Unknown custom tag/\n    )\n  })\n})\n\ntest('broken document with comment before first node', () => {\n  const doc = YAML.parseDocument('#c\\n*x\\nfoo\\n', { prettyErrors: false })\n  expect(doc.errors).toMatchObject([\n    { message: 'Unexpected scalar at node end' }\n  ])\n})\n\ntest('multiple tags on one node', () => {\n  const doc = YAML.parseDocument('!foo !bar baz\\n')\n  expect(doc.contents).toMatchObject({ value: 'baz', type: 'PLAIN' })\n  expect(doc.errors).toHaveLength(1)\n  expect(doc.warnings).toHaveLength(1)\n})\n\ndescribe('logLevel', () => {\n  // process.emitWarning will throw in Jest if `warning` is an Error instance\n  // due to https://github.com/facebook/jest/issues/2549\n\n  const mock = jest.spyOn(global.process, 'emitWarning').mockImplementation()\n  beforeEach(() => mock.mockClear())\n  afterEach(() => mock.mockRestore())\n\n  test('by default, warn for tag fallback', () => {\n    YAML.parse('!foo bar')\n    const message = source`\n      Unresolved tag: !foo at line 1, column 1:\n\n      !foo bar\n      ^^^^\n    `\n    expect(mock.mock.calls).toMatchObject([[{ message }]])\n  })\n\n  test(\"silence warnings with logLevel: 'error'\", () => {\n    YAML.parse('!foo bar', { logLevel: 'error' })\n    expect(mock).toHaveBeenCalledTimes(0)\n  })\n\n  test(\"silence warnings with logLevel: 'silent'\", () => {\n    YAML.parse('!foo bar', { logLevel: 'silent' })\n    expect(mock).toHaveBeenCalledTimes(0)\n  })\n\n  test(\"silence errors with logLevel: 'silent'\", () => {\n    const res = YAML.parse('foo: bar: baz\\n---\\ndoc2\\n', { logLevel: 'silent' })\n    expect(res).toMatchObject({ foo: { bar: 'baz' } })\n  })\n})\n\ndescribe('Invalid plain first characters', () => {\n  for (const ch of [',', '%', '@', '`'])\n    test(ch, () => {\n      const doc = YAML.parseDocument(`- ${ch}foo`)\n      expect(doc.errors).toMatchObject([{ code: 'BAD_SCALAR_START' }])\n    })\n})\n"], "filenames": ["src/errors.ts", "tests/doc/errors.js"], "buggy_code_start_loc": [94, 343], "buggy_code_end_loc": [95, 343], "fixing_code_start_loc": [94, 344], "fixing_code_end_loc": [95, 350], "type": "CWE-248", "message": "Uncaught Exception in GitHub repository eemeli/yaml prior to 2.0.0-5.", "other": {"cve": {"id": "CVE-2023-2251", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-24T15:15:08.897", "lastModified": "2023-05-08T10:15:09.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Uncaught Exception in GitHub repository eemeli/yaml prior to 2.0.0-5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-248"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yaml_project:yaml:*:*:*:*:*:go:*:*", "versionEndExcluding": "2.0.0-4", "matchCriteriaId": "33E17CA5-8A74-4BE7-ACC1-CD1DBE0695BD"}]}]}], "references": [{"url": "https://github.com/eemeli/yaml/commit/984f5781ffd807e58cad3b5c8da1f940dab75fba", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/4b494e99-5a3e-40d9-8678-277f3060e96c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eemeli/yaml/commit/984f5781ffd807e58cad3b5c8da1f940dab75fba"}}