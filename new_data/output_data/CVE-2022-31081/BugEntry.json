{"buggy_code": ["package HTTP::Daemon;\n\n# ABSTRACT: A simple http server class\n\nuse strict;\nuse warnings;\n\nour $VERSION = '6.15';\n\nuse Socket ();\nuse IO::Socket::IP;\nour @ISA = qw(IO::Socket::IP);\n\nour $PROTO = \"HTTP/1.1\";\n\nour $DEBUG;\n\nsub new {\n    my ($class, %args) = @_;\n    $args{Listen} ||= 5;\n    $args{Proto}  ||= 'tcp';\n\n    # Handle undefined or empty local address the same way as\n    # IO::Socket::INET -- use unspecified address\n    for my $key (qw(LocalAddr LocalHost)) {\n        if (exists $args{$key} && (!defined $args{$key} || $args{$key} eq '')) {\n            delete $args{$key};\n        }\n    }\n    return $class->SUPER::new(%args);\n}\n\nsub accept {\n    my $self = shift;\n    my $pkg  = shift || \"HTTP::Daemon::ClientConn\";\n    my ($sock, $peer) = $self->SUPER::accept($pkg);\n    if ($sock) {\n        ${*$sock}{'httpd_daemon'} = $self;\n        return wantarray ? ($sock, $peer) : $sock;\n    }\n    else {\n        return;\n    }\n}\n\nsub url {\n    my $self = shift;\n\n    my $host = $self->sockhost;\n    $host =~ s/%/%25/g;\n    $host = \"127.0.0.1\" if $host eq \"0.0.0.0\";\n    $host = \"::1\"       if $host eq \"::\";\n    $host = \"[$host]\"   if $self->sockdomain == Socket::AF_INET6;\n\n    my $url = $self->_default_scheme . \"://\" . $host;\n    my $port = $self->sockport;\n    $url .= \":$port\" if $port != $self->_default_port;\n    $url .= \"/\";\n    $url;\n}\n\nsub _default_port {\n    80;\n}\n\nsub _default_scheme {\n    \"http\";\n}\n\nsub product_tokens {\n    \"libwww-perl-daemon/$HTTP::Daemon::VERSION\";\n}\n\npackage    # hide from PAUSE\n    HTTP::Daemon::ClientConn;\n\nuse strict;\nuse warnings;\n\nuse IO::Socket::IP ();\nour @ISA = qw(IO::Socket::IP);\nour $DEBUG;\n*DEBUG = \\$HTTP::Daemon::DEBUG;\n\nuse HTTP::Request  ();\nuse HTTP::Response ();\nuse HTTP::Status;\nuse HTTP::Date qw(time2str);\nuse LWP::MediaTypes qw(guess_media_type);\nuse Carp ();\n\n# \"\\r\\n\" is not portable\nmy $CRLF     = \"\\015\\012\";\nmy $HTTP_1_0 = _http_version(\"HTTP/1.0\");\nmy $HTTP_1_1 = _http_version(\"HTTP/1.1\");\n\n\nsub get_request {\n    my ($self, $only_headers) = @_;\n    if (${*$self}{'httpd_nomore'}) {\n        $self->reason(\"No more requests from this connection\");\n        return;\n    }\n\n    $self->reason(\"\");\n    my $buf = ${*$self}{'httpd_rbuf'};\n    $buf = \"\" unless defined $buf;\n\n    my $timeout = ${*$self}{'io_socket_timeout'};\n    my $fdset   = \"\";\n    vec($fdset, $self->fileno, 1) = 1;\n    local ($_);\n\nREAD_HEADER:\n    while (1) {\n\n        # loop until we have the whole header in $buf\n        $buf =~ s/^(?:\\015?\\012)+//;    # ignore leading blank lines\n        if ($buf =~ /\\012/) {           # potential, has at least one line\n            if ($buf =~ /^\\w+[^\\012]+HTTP\\/\\d+\\.\\d+\\015?\\012/) {\n                if ($buf =~ /\\015?\\012\\015?\\012/) {\n                    last READ_HEADER;    # we have it\n                }\n                elsif (length($buf) > 16 * 1024) {\n                    $self->send_error(413);    # REQUEST_ENTITY_TOO_LARGE\n                    $self->reason(\"Very long header\");\n                    return;\n                }\n            }\n            else {\n                last READ_HEADER;              # HTTP/0.9 client\n            }\n        }\n        elsif (length($buf) > 16 * 1024) {\n            $self->send_error(414);            # REQUEST_URI_TOO_LARGE\n            $self->reason(\"Very long first line\");\n            return;\n        }\n        print STDERR \"Need more data for complete header\\n\" if $DEBUG;\n        return unless $self->_need_more($buf, $timeout, $fdset);\n    }\n    if ($buf !~ s/^(\\S+)[ \\t]+(\\S+)(?:[ \\t]+(HTTP\\/\\d+\\.\\d+))?[^\\012]*\\012//) {\n        ${*$self}{'httpd_client_proto'} = _http_version(\"HTTP/1.0\");\n        $self->send_error(400);                # BAD_REQUEST\n        $self->reason(\"Bad request line: $buf\");\n        return;\n    }\n    my $method = $1;\n    my $uri    = $2;\n    my $proto  = $3 || \"HTTP/0.9\";\n    $uri = \"http://$uri\" if $method eq \"CONNECT\";\n    $uri = $HTTP::URI_CLASS->new($uri, $self->daemon->url);\n    my $r = HTTP::Request->new($method, $uri);\n    $r->protocol($proto);\n    ${*$self}{'httpd_client_proto'} = $proto = _http_version($proto);\n    ${*$self}{'httpd_head'} = ($method eq \"HEAD\");\n\n    if ($proto >= $HTTP_1_0) {\n\n        # we expect to find some headers\n        my ($key, $val);\n    HEADER:\n        while ($buf =~ s/^([^\\012]*)\\012//) {\n            $_ = $1;\n            s/\\015$//;\n            if (/^([^:\\s]+)\\s*:\\s*(.*)/) {\n                $r->push_header($key, $val) if $key;\n                ($key, $val) = ($1, $2);\n            }\n            elsif (/^\\s+(.*)/) {\n                $val .= \" $1\";\n            }\n            else {\n                last HEADER;\n            }\n        }\n        $r->push_header($key, $val) if $key;\n    }\n\n    my $conn = $r->header('Connection');\n    if ($proto >= $HTTP_1_1) {\n        ${*$self}{'httpd_nomore'}++ if $conn && lc($conn) =~ /\\bclose\\b/;\n    }\n    else {\n        ${*$self}{'httpd_nomore'}++\n            unless $conn && lc($conn) =~ /\\bkeep-alive\\b/;\n    }\n\n    if ($only_headers) {\n        ${*$self}{'httpd_rbuf'} = $buf;\n        return $r;\n    }\n\n    # Find out how much content to read\n    my $tr_enc  = $r->header('Transfer-Encoding');\n    my $ct_type = $r->header('Content-Type');\n    my $ct_len  = $r->header('Content-Length');\n\n    # Act on the Expect header, if it's there\n    for my $e ($r->header('Expect')) {\n        if (lc($e) eq '100-continue') {\n            $self->send_status_line(100);\n            $self->send_crlf;\n        }\n        else {\n            $self->send_error(417);\n            $self->reason(\"Unsupported Expect header value\");\n            return;\n        }\n    }\n\n    if ($tr_enc && lc($tr_enc) eq 'chunked') {\n\n        # Handle chunked transfer encoding\n        my $body = \"\";\n    CHUNK:\n        while (1) {\n            print STDERR \"Chunked\\n\" if $DEBUG;\n            if ($buf =~ s/^([^\\012]*)\\012//) {\n                my $chunk_head = $1;\n                unless ($chunk_head =~ /^([0-9A-Fa-f]+)/) {\n                    $self->send_error(400);\n                    $self->reason(\"Bad chunk header $chunk_head\");\n                    return;\n                }\n                my $size = hex($1);\n                last CHUNK if $size == 0;\n\n                my $missing = $size - length($buf) + 2;    # 2=CRLF at chunk end\n                     # must read until we have a complete chunk\n                while ($missing > 0) {\n                    print STDERR \"Need $missing more bytes\\n\" if $DEBUG;\n                    my $n = $self->_need_more($buf, $timeout, $fdset);\n                    return unless $n;\n                    $missing -= $n;\n                }\n                $body .= substr($buf, 0, $size);\n                substr($buf, 0, $size + 2) = '';\n\n            }\n            else {\n                # need more data in order to have a complete chunk header\n                return unless $self->_need_more($buf, $timeout, $fdset);\n            }\n        }\n        $r->content($body);\n\n        # pretend it was a normal entity body\n        $r->remove_header('Transfer-Encoding');\n        $r->header('Content-Length', length($body));\n\n        my ($key, $val);\n    FOOTER:\n        while (1) {\n            if ($buf !~ /\\012/) {\n\n                # need at least one line to look at\n                return unless $self->_need_more($buf, $timeout, $fdset);\n            }\n            else {\n                $buf =~ s/^([^\\012]*)\\012//;\n                $_ = $1;\n                s/\\015$//;\n                if (/^([\\w\\-]+)\\s*:\\s*(.*)/) {\n                    $r->push_header($key, $val) if $key;\n                    ($key, $val) = ($1, $2);\n                }\n                elsif (/^\\s+(.*)/) {\n                    $val .= \" $1\";\n                }\n                elsif (!length) {\n                    last FOOTER;\n                }\n                else {\n                    $self->reason(\"Bad footer syntax\");\n                    return;\n                }\n            }\n        }\n        $r->push_header($key, $val) if $key;\n\n    }\n    elsif ($tr_enc) {\n        $self->send_error(501);    # Unknown transfer encoding\n        $self->reason(\"Unknown transfer encoding '$tr_enc'\");\n        return;\n\n    }\n    elsif ($ct_len) {\n\n        # After a security issue, we ensure we comply to\n        # RFC-7230 -- HTTP/1.1 Message Syntax and Routing\n        # section 3.3.2 -- Content-Length\n        # section 3.3.3 -- Message Body Length\n\n        # split and clean up Content-Length ', ' separated string\n        my @vals = map {my $str = $_; $str =~ s/^\\s+//; $str =~ s/\\s+$//; $str }\n            split ',', $ct_len;\n        # check that they are all numbers (RFC: Content-Length = 1*DIGIT)\n        my @nums = grep { /^[0-9]+$/} @vals;\n        unless (@vals == @nums) {\n            $self->send_error(400);\n            $self->reason(\"Content-Length value must be a unsigned integer\");\n            return;\n        }\n        # check they are all the same\n        my $ct_len = shift @nums;\n        foreach (@nums) {\n            next if $_ == $ct_len;\n            $self->send_error(400);\n            $self->reason(\"Content-Length values are not the same\");\n            return;\n        }\n        # ensure we have now a fixed header, with only 1 value\n        $r->header('Content-Length' => $ct_len);\n\n        # Plain body specified by \"Content-Length\"\n        my $missing = $ct_len - length($buf);\n        while ($missing > 0) {\n            print \"Need $missing more bytes of content\\n\" if $DEBUG;\n            my $n = $self->_need_more($buf, $timeout, $fdset);\n            return unless $n;\n            $missing -= $n;\n        }\n        if (length($buf) > $ct_len) {\n            $r->content(substr($buf, 0, $ct_len));\n            substr($buf, 0, $ct_len) = '';\n        }\n        else {\n            $r->content($buf);\n            $buf = '';\n        }\n    }\n    elsif ($ct_type && $ct_type =~ m/^multipart\\/\\w+\\s*;.*boundary\\s*=\\s*(\"?)(\\w+)\\1/i) {\n\n        # Handle multipart content type\n        my $boundary = \"$CRLF--$2--\";\n        my $index;\n        while (1) {\n            $index = index($buf, $boundary);\n            last if $index >= 0;\n\n            # end marker not yet found\n            return unless $self->_need_more($buf, $timeout, $fdset);\n        }\n        $index += length($boundary);\n        $r->content(substr($buf, 0, $index));\n        substr($buf, 0, $index) = '';\n\n    }\n    ${*$self}{'httpd_rbuf'} = $buf;\n\n    $r;\n}\n\nsub _need_more {\n    my $self = shift;\n\n    #my($buf,$timeout,$fdset) = @_;\n    if ($_[1]) {\n        my ($timeout, $fdset) = @_[1, 2];\n        print STDERR \"select(,,,$timeout)\\n\" if $DEBUG;\n        my $n = select($fdset, undef, undef, $timeout);\n        unless ($n) {\n            $self->reason(defined($n) ? \"Timeout\" : \"select: $!\");\n            return;\n        }\n    }\n    print STDERR \"sysread()\\n\" if $DEBUG;\n    my $n = sysread($self, $_[0], 2048, length($_[0]));\n    $self->reason(defined($n) ? \"Client closed\" : \"sysread: $!\") unless $n;\n    $n;\n}\n\nsub read_buffer {\n    my $self = shift;\n    my $old  = ${*$self}{'httpd_rbuf'};\n    if (@_) {\n        ${*$self}{'httpd_rbuf'} = shift;\n    }\n    $old;\n}\n\nsub reason {\n    my $self = shift;\n    my $old  = ${*$self}{'httpd_reason'};\n    if (@_) {\n        ${*$self}{'httpd_reason'} = shift;\n    }\n    $old;\n}\n\nsub proto_ge {\n    my $self = shift;\n    ${*$self}{'httpd_client_proto'} >= _http_version(shift);\n}\n\nsub _http_version {\n    local ($_) = shift;\n    return 0 unless m,^(?:HTTP/)?(\\d+)\\.(\\d+)$,i;\n    $1 * 1000 + $2;\n}\n\nsub antique_client {\n    my $self = shift;\n    ${*$self}{'httpd_client_proto'} < $HTTP_1_0;\n}\n\nsub force_last_request {\n    my $self = shift;\n    ${*$self}{'httpd_nomore'}++;\n}\n\nsub head_request {\n    my $self = shift;\n    ${*$self}{'httpd_head'};\n}\n\n\nsub send_status_line {\n    my ($self, $status, $message, $proto) = @_;\n    return if $self->antique_client;\n    $status  ||= RC_OK;\n    $message ||= status_message($status) || \"\";\n    $proto   ||= $HTTP::Daemon::PROTO || \"HTTP/1.1\";\n    print $self \"$proto $status $message$CRLF\";\n}\n\nsub send_crlf {\n    my $self = shift;\n    print $self $CRLF;\n}\n\nsub send_basic_header {\n    my $self = shift;\n    return if $self->antique_client;\n    $self->send_status_line(@_);\n    print $self \"Date: \", time2str(time), $CRLF;\n    my $product = $self->daemon->product_tokens;\n    print $self \"Server: $product$CRLF\" if $product;\n}\n\nsub send_header {\n    my $self = shift;\n    while (@_) {\n        my ($k, $v) = splice(@_, 0, 2);\n        $v = \"\" unless defined($v);\n        print $self \"$k: $v$CRLF\";\n    }\n}\n\nsub send_response {\n    my $self = shift;\n    my $res  = shift;\n    if (!ref $res) {\n        $res ||= RC_OK;\n        $res = HTTP::Response->new($res, @_);\n    }\n    my $content = $res->content;\n    my $chunked;\n    unless ($self->antique_client) {\n        my $code = $res->code;\n        $self->send_basic_header($code, $res->message, $res->protocol);\n        if ($code =~ /^(1\\d\\d|[23]04)$/) {\n\n            # make sure content is empty\n            $res->remove_header(\"Content-Length\");\n            $content = \"\";\n        }\n        elsif ($res->request && $res->request->method eq \"HEAD\") {\n\n            # probably OK\n        }\n        elsif (ref($content) eq \"CODE\") {\n            if ($self->proto_ge(\"HTTP/1.1\")) {\n                $res->push_header(\"Transfer-Encoding\" => \"chunked\");\n                $chunked++;\n            }\n            else {\n                $self->force_last_request;\n            }\n        }\n        elsif (length($content)) {\n            $res->header(\"Content-Length\" => length($content));\n        }\n        else {\n            $self->force_last_request;\n            $res->header('connection', 'close');\n        }\n        print $self $res->headers_as_string($CRLF);\n        print $self $CRLF;    # separates headers and content\n    }\n    if ($self->head_request) {\n\n        # no content\n    }\n    elsif (ref($content) eq \"CODE\") {\n        while (1) {\n            my $chunk = &$content();\n            last unless defined($chunk) && length($chunk);\n            if ($chunked) {\n                printf $self \"%x%s%s%s\", length($chunk), $CRLF, $chunk, $CRLF;\n            }\n            else {\n                print $self $chunk;\n            }\n        }\n        print $self \"0$CRLF$CRLF\" if $chunked;    # no trailers either\n    }\n    elsif (length $content) {\n        print $self $content;\n    }\n}\n\nsub send_redirect {\n    my ($self, $loc, $status, $content) = @_;\n    $status ||= RC_MOVED_PERMANENTLY;\n    Carp::croak(\"Status '$status' is not redirect\") unless is_redirect($status);\n    $self->send_basic_header($status);\n    my $base = $self->daemon->url;\n    $loc = $HTTP::URI_CLASS->new($loc, $base) unless ref($loc);\n    $loc = $loc->abs($base);\n    print $self \"Location: $loc$CRLF\";\n\n    if ($content) {\n        my $ct_type = $content =~ /^\\s*</ ? \"text/html\" : \"text/plain\";\n        print $self \"Content-Type: $ct_type$CRLF\";\n    }\n    print $self $CRLF;\n    print $self $content if $content && !$self->head_request;\n    $self->force_last_request;    # no use keeping the connection open\n}\n\nsub send_error {\n    my ($self, $status, $error) = @_;\n    $status ||= RC_BAD_REQUEST;\n    Carp::croak(\"Status '$status' is not an error\") unless is_error($status);\n    my $mess = status_message($status);\n    $error ||= \"\";\n    $mess = <<EOT;\n<title>$status $mess</title>\n<h1>$status $mess</h1>\n$error\nEOT\n    unless ($self->antique_client) {\n        $self->send_basic_header($status);\n        print $self \"Content-Type: text/html$CRLF\";\n        print $self \"Content-Length: \" . length($mess) . $CRLF;\n        print $self $CRLF;\n    }\n    print $self $mess unless $self->head_request;\n    $status;\n}\n\nsub send_file_response {\n    my ($self, $file) = @_;\n    if (-d $file) {\n        $self->send_dir($file);\n    }\n    elsif (-f _) {\n\n        # plain file\n        local (*F);\n        sysopen(F, $file, 0) or return $self->send_error(RC_FORBIDDEN);\n        binmode(F);\n        my ($mime_type, $file_enc) = guess_media_type($file);\n        my ($size, $mtime) = (stat _)[7, 9];\n        unless ($self->antique_client) {\n            $self->send_basic_header;\n            print $self \"Content-Type: $mime_type$CRLF\";\n            print $self \"Content-Encoding: $file_enc$CRLF\" if $file_enc;\n            print $self \"Content-Length: $size$CRLF\" if $size;\n            print $self \"Last-Modified: \", time2str($mtime), \"$CRLF\" if $mtime;\n            print $self $CRLF;\n        }\n        $self->send_file(\\*F) unless $self->head_request;\n        return RC_OK;\n    }\n    else {\n        $self->send_error(RC_NOT_FOUND);\n    }\n}\n\nsub send_dir {\n    my ($self, $dir) = @_;\n    $self->send_error(RC_NOT_FOUND) unless -d $dir;\n    $self->send_error(RC_NOT_IMPLEMENTED);\n}\n\nsub send_file {\n    my ($self, $file) = @_;\n    my $opened = 0;\n    local (*FILE);\n    if (!ref($file)) {\n        open(FILE, $file) || return undef;\n        binmode(FILE);\n        $file = \\*FILE;\n        $opened++;\n    }\n    my $cnt = 0;\n    my $buf = \"\";\n    my $n;\n    while ($n = sysread($file, $buf, 8 * 1024)) {\n        last if !$n;\n        $cnt += $n;\n        print $self $buf;\n    }\n    close($file) if $opened;\n    $cnt;\n}\n\nsub daemon {\n    my $self = shift;\n    ${*$self}{'httpd_daemon'};\n}\n\n\n1;\n\n__END__\n\n=head1 SYNOPSIS\n\n  use HTTP::Daemon;\n  use HTTP::Status;\n\n  my $d = HTTP::Daemon->new || die;\n  print \"Please contact me at: <URL:\", $d->url, \">\\n\";\n  while (my $c = $d->accept) {\n      while (my $r = $c->get_request) {\n      if ($r->method eq 'GET' and $r->uri->path eq \"/xyzzy\") {\n              # remember, this is *not* recommended practice :-)\n          $c->send_file_response(\"/etc/passwd\");\n      }\n      else {\n          $c->send_error(RC_FORBIDDEN)\n      }\n      }\n      $c->close;\n      undef($c);\n  }\n\n=head1 DESCRIPTION\n\nInstances of the C<HTTP::Daemon> class are HTTP/1.1 servers that\nlisten on a socket for incoming requests. The C<HTTP::Daemon> is a\nsubclass of C<IO::Socket::IP>, so you can perform socket operations\ndirectly on it too.\n\nPlease note that C<HTTP::Daemon> used to be a subclass of C<IO::Socket::INET>.\nTo support IPv6, it switched the parent class to C<IO::Socket::IP> at version 6.05.\nSee L</IPv6 SUPPORT> for details.\n\nThe accept() method will return when a connection from a client is\navailable.  The returned value will be an C<HTTP::Daemon::ClientConn>\nobject which is another C<IO::Socket::IP> subclass.  Calling the\nget_request() method on this object will read data from the client and\nreturn an C<HTTP::Request> object.  The ClientConn object also provide\nmethods to send back various responses.\n\nThis HTTP daemon does not fork(2) for you.  Your application, i.e. the\nuser of the C<HTTP::Daemon> is responsible for forking if that is\ndesirable.  Also note that the user is responsible for generating\nresponses that conform to the HTTP/1.1 protocol.\n\nThe following methods of C<HTTP::Daemon> are new (or enhanced) relative\nto the C<IO::Socket::IP> base class:\n\n=over 4\n\n=item $d = HTTP::Daemon->new\n\n=item $d = HTTP::Daemon->new( %opts )\n\nThe constructor method takes the same arguments as the\nC<IO::Socket::IP> constructor, but unlike its base class it can also\nbe called without any arguments.  The daemon will then set up a listen\nqueue of 5 connections and allocate some random port number.\n\nA server that wants to bind to some specific address on the standard\nHTTP port will be constructed like this:\n\n  $d = HTTP::Daemon->new(\n           LocalAddr => 'www.thisplace.com',\n           LocalPort => 80,\n       );\n\nSee L<IO::Socket::IP> for a description of other arguments that can\nbe used to configure the daemon during construction.\n\n=item $c = $d->accept\n\n=item $c = $d->accept( $pkg )\n\n=item ($c, $peer_addr) = $d->accept\n\nThis method works the same as the one provided by the base class, but it\nreturns an C<HTTP::Daemon::ClientConn> reference by default.  If a\npackage name is provided as argument, then the returned object will be\nblessed into the given class.  It is probably a good idea to make that\nclass a subclass of C<HTTP::Daemon::ClientConn>.\n\nThe accept method will return C<undef> if timeouts have been enabled\nand no connection is made within the given time.  The timeout() method\nis described in L<IO::Socket::IP>.\n\nIn list context both the client object and the peer address will be\nreturned; see the description of the accept method of L<IO::Socket> for\ndetails.\n\n=item $d->url\n\nReturns a URL string that can be used to access the server root.\n\n=item $d->product_tokens\n\nReturns the name that this server will use to identify itself.  This\nis the string that is sent with the C<Server> response header.  The\nmain reason to have this method is that subclasses can override it if\nthey want to use another product name.\n\nThe default is the string \"libwww-perl-daemon/#.##\" where \"#.##\" is\nreplaced with the version number of this module.\n\n=back\n\nThe C<HTTP::Daemon::ClientConn> is a subclass of C<IO::Socket::IP>.\nInstances of this class are returned by the accept() method\nof C<HTTP::Daemon>.  The following methods are provided:\n\n=over 4\n\n=item $c->get_request\n\n=item $c->get_request( $headers_only )\n\nThis method reads data from the client and turns it into an\nC<HTTP::Request> object which is returned.  It returns C<undef>\nif reading fails.  If it fails, then the C<HTTP::Daemon::ClientConn>\nobject ($c) should be discarded, and you should not try to call this\nmethod again on it.  The $c->reason method might give you some\ninformation about why $c->get_request failed.\n\nThe get_request() method will normally not return until the whole\nrequest has been received from the client.  This might not be what you\nwant if the request is an upload of a large file (and with chunked\ntransfer encoding HTTP can even support infinite request messages -\nuploading live audio for instance).  If you pass a TRUE value as the\n$headers_only argument, then get_request() will return immediately\nafter parsing the request headers and you are responsible for reading\nthe rest of the request content.  If you are going to call\n$c->get_request again on the same connection you better read the\ncorrect number of bytes.\n\n=item $c->read_buffer\n\n=item $c->read_buffer( $new_value )\n\nBytes read by $c->get_request, but not used are placed in the I<read\nbuffer>.  The next time $c->get_request is called it will consume the\nbytes in this buffer before reading more data from the network\nconnection itself.  The read buffer is invalid after $c->get_request\nhas failed.\n\nIf you handle the reading of the request content yourself you need to\nempty this buffer before you read more and you need to place\nunconsumed bytes here.  You also need this buffer if you implement\nservices like I<101 Switching Protocols>.\n\nThis method always returns the old buffer content and can optionally\nreplace the buffer content if you pass it an argument.\n\n=item $c->reason\n\nWhen $c->get_request returns C<undef> you can obtain a short string\ndescribing why it happened by calling $c->reason.\n\n=item $c->proto_ge( $proto )\n\nReturn TRUE if the client announced a protocol with version number\ngreater or equal to the given argument.  The $proto argument can be a\nstring like \"HTTP/1.1\" or just \"1.1\".\n\n=item $c->antique_client\n\nReturn TRUE if the client speaks the HTTP/0.9 protocol.  No status\ncode and no headers should be returned to such a client.  This should\nbe the same as !$c->proto_ge(\"HTTP/1.0\").\n\n=item $c->head_request\n\nReturn TRUE if the last request was a C<HEAD> request.  No content\nbody must be generated for these requests.\n\n=item $c->force_last_request\n\nMake sure that $c->get_request will not try to read more requests off\nthis connection.  If you generate a response that is not self-delimiting,\nthen you should signal this fact by calling this method.\n\nThis attribute is turned on automatically if the client announces\nprotocol HTTP/1.0 or worse and does not include a \"Connection:\nKeep-Alive\" header.  It is also turned on automatically when HTTP/1.1\nor better clients send the \"Connection: close\" request header.\n\n=item $c->send_status_line\n\n=item $c->send_status_line( $code )\n\n=item $c->send_status_line( $code, $mess )\n\n=item $c->send_status_line( $code, $mess, $proto )\n\nSend the status line back to the client.  If $code is omitted 200 is\nassumed.  If $mess is omitted, then a message corresponding to $code\nis inserted.  If $proto is missing the content of the\n$HTTP::Daemon::PROTO variable is used.\n\n=item $c->send_crlf\n\nSend the CRLF sequence to the client.\n\n=item $c->send_basic_header\n\n=item $c->send_basic_header( $code )\n\n=item $c->send_basic_header( $code, $mess )\n\n=item $c->send_basic_header( $code, $mess, $proto )\n\nSend the status line and the \"Date:\" and \"Server:\" headers back to\nthe client.  This header is assumed to be continued and does not end\nwith an empty CRLF line.\n\nSee the description of send_status_line() for the description of the\naccepted arguments.\n\n=item $c->send_header( $field, $value )\n\n=item $c->send_header( $field1, $value1, $field2, $value2, ... )\n\nSend one or more header lines.\n\n=item $c->send_response( $res )\n\nWrite an C<HTTP::Response> object to the\nclient as a response.  We try hard to make sure that the response is\nself-delimiting so that the connection can stay persistent for further\nrequest/response exchanges.\n\nThe content attribute of the C<HTTP::Response> object can be a normal\nstring or a subroutine reference.  If it is a subroutine, then\nwhatever this callback routine returns is written back to the\nclient as the response content.  The routine will be called until it\nreturns an undefined or empty value.  If the client is HTTP/1.1 aware\nthen we will use chunked transfer encoding for the response.\n\n=item $c->send_redirect( $loc )\n\n=item $c->send_redirect( $loc, $code )\n\n=item $c->send_redirect( $loc, $code, $entity_body )\n\nSend a redirect response back to the client.  The location ($loc) can\nbe an absolute or relative URL. The $code must be one of the redirect\nstatus codes, and defaults to \"301 Moved Permanently\"\n\n=item $c->send_error\n\n=item $c->send_error( $code )\n\n=item $c->send_error( $code, $error_message )\n\nSend an error response back to the client.  If the $code is missing a\n\"Bad Request\" error is reported.  The $error_message is a string that\nis incorporated in the body of the HTML entity.\n\n=item $c->send_file_response( $filename )\n\nSend back a response with the specified $filename as content.  If the\nfile is a directory we try to generate an HTML index of it.\n\n=item $c->send_file( $filename )\n\n=item $c->send_file( $fd )\n\nCopy the file to the client.  The file can be a string (which\nwill be interpreted as a filename) or a reference to an C<IO::Handle>\nor glob.\n\n=item $c->daemon\n\nReturn a reference to the corresponding C<HTTP::Daemon> object.\n\n=back\n\n=head1 IPv6 SUPPORT\n\nSince version 6.05, C<HTTP::Daemon> is a subclass of C<IO::Socket::IP>\nrather than C<IO::Socket::INET>, so that it supports IPv6.\n\nFor some reasons, you may want to force C<HTTP::Daemon> to listen on IPv4 addresses only.\nThen pass C<Family> argument to C<< HTTP::Daemon->new >>:\n\n  use HTTP::Daemon;\n  use Socket 'AF_INET';\n\n  my $d = HTTP::Daemon->new(Family => AF_INET);\n\n=head1 SEE ALSO\n\nRFC 2616\n\nL<IO::Socket::IP>, L<IO::Socket>\n\n=cut\n"], "fixing_code": ["package HTTP::Daemon;\n\n# ABSTRACT: A simple http server class\n\nuse strict;\nuse warnings;\n\nour $VERSION = '6.15';\n\nuse Socket ();\nuse IO::Socket::IP;\nour @ISA = qw(IO::Socket::IP);\n\nour $PROTO = \"HTTP/1.1\";\n\nour $DEBUG;\n\nsub new {\n    my ($class, %args) = @_;\n    $args{Listen} ||= 5;\n    $args{Proto}  ||= 'tcp';\n\n    # Handle undefined or empty local address the same way as\n    # IO::Socket::INET -- use unspecified address\n    for my $key (qw(LocalAddr LocalHost)) {\n        if (exists $args{$key} && (!defined $args{$key} || $args{$key} eq '')) {\n            delete $args{$key};\n        }\n    }\n    return $class->SUPER::new(%args);\n}\n\nsub accept {\n    my $self = shift;\n    my $pkg  = shift || \"HTTP::Daemon::ClientConn\";\n    my ($sock, $peer) = $self->SUPER::accept($pkg);\n    if ($sock) {\n        ${*$sock}{'httpd_daemon'} = $self;\n        return wantarray ? ($sock, $peer) : $sock;\n    }\n    else {\n        return;\n    }\n}\n\nsub url {\n    my $self = shift;\n\n    my $host = $self->sockhost;\n    $host =~ s/%/%25/g;\n    $host = \"127.0.0.1\" if $host eq \"0.0.0.0\";\n    $host = \"::1\"       if $host eq \"::\";\n    $host = \"[$host]\"   if $self->sockdomain == Socket::AF_INET6;\n\n    my $url = $self->_default_scheme . \"://\" . $host;\n    my $port = $self->sockport;\n    $url .= \":$port\" if $port != $self->_default_port;\n    $url .= \"/\";\n    $url;\n}\n\nsub _default_port {\n    80;\n}\n\nsub _default_scheme {\n    \"http\";\n}\n\nsub product_tokens {\n    \"libwww-perl-daemon/$HTTP::Daemon::VERSION\";\n}\n\npackage    # hide from PAUSE\n    HTTP::Daemon::ClientConn;\n\nuse strict;\nuse warnings;\n\nuse IO::Socket::IP ();\nour @ISA = qw(IO::Socket::IP);\nour $DEBUG;\n*DEBUG = \\$HTTP::Daemon::DEBUG;\n\nuse HTTP::Request  ();\nuse HTTP::Response ();\nuse HTTP::Status;\nuse HTTP::Date qw(time2str);\nuse LWP::MediaTypes qw(guess_media_type);\nuse Carp ();\n\n# \"\\r\\n\" is not portable\nmy $CRLF     = \"\\015\\012\";\nmy $HTTP_1_0 = _http_version(\"HTTP/1.0\");\nmy $HTTP_1_1 = _http_version(\"HTTP/1.1\");\n\n\nsub get_request {\n    my ($self, $only_headers) = @_;\n    if (${*$self}{'httpd_nomore'}) {\n        $self->reason(\"No more requests from this connection\");\n        return;\n    }\n\n    $self->reason(\"\");\n    my $buf = ${*$self}{'httpd_rbuf'};\n    $buf = \"\" unless defined $buf;\n\n    my $timeout = ${*$self}{'io_socket_timeout'};\n    my $fdset   = \"\";\n    vec($fdset, $self->fileno, 1) = 1;\n    local ($_);\n\nREAD_HEADER:\n    while (1) {\n\n        # loop until we have the whole header in $buf\n        $buf =~ s/^(?:\\015?\\012)+//;    # ignore leading blank lines\n        if ($buf =~ /\\012/) {           # potential, has at least one line\n            if ($buf =~ /^\\w+[^\\012]+HTTP\\/\\d+\\.\\d+\\015?\\012/) {\n                if ($buf =~ /\\015?\\012\\015?\\012/) {\n                    last READ_HEADER;    # we have it\n                }\n                elsif (length($buf) > 16 * 1024) {\n                    $self->send_error(413);    # REQUEST_ENTITY_TOO_LARGE\n                    $self->reason(\"Very long header\");\n                    return;\n                }\n            }\n            else {\n                last READ_HEADER;              # HTTP/0.9 client\n            }\n        }\n        elsif (length($buf) > 16 * 1024) {\n            $self->send_error(414);            # REQUEST_URI_TOO_LARGE\n            $self->reason(\"Very long first line\");\n            return;\n        }\n        print STDERR \"Need more data for complete header\\n\" if $DEBUG;\n        return unless $self->_need_more($buf, $timeout, $fdset);\n    }\n    if ($buf !~ s/^(\\S+)[ \\t]+(\\S+)(?:[ \\t]+(HTTP\\/\\d+\\.\\d+))?[^\\012]*\\012//) {\n        ${*$self}{'httpd_client_proto'} = _http_version(\"HTTP/1.0\");\n        $self->send_error(400);                # BAD_REQUEST\n        $self->reason(\"Bad request line: $buf\");\n        return;\n    }\n    my $method = $1;\n    my $uri    = $2;\n    my $proto  = $3 || \"HTTP/0.9\";\n    $uri = \"http://$uri\" if $method eq \"CONNECT\";\n    $uri = $HTTP::URI_CLASS->new($uri, $self->daemon->url);\n    my $r = HTTP::Request->new($method, $uri);\n    $r->protocol($proto);\n    ${*$self}{'httpd_client_proto'} = $proto = _http_version($proto);\n    ${*$self}{'httpd_head'} = ($method eq \"HEAD\");\n\n    if ($proto >= $HTTP_1_0) {\n\n        # we expect to find some headers\n        my ($key, $val);\n    HEADER:\n        while ($buf =~ s/^([^\\012]*)\\012//) {\n            $_ = $1;\n            s/\\015$//;\n            if (/^([^:\\s]+)\\s*:\\s*(.*)/) {\n                $r->push_header($key, $val) if $key;\n                ($key, $val) = ($1, $2);\n            }\n            elsif (/^\\s+(.*)/) {\n                $val .= \" $1\";\n            }\n            else {\n                last HEADER;\n            }\n        }\n        $r->push_header($key, $val) if $key;\n    }\n\n    my $conn = $r->header('Connection');\n    if ($proto >= $HTTP_1_1) {\n        ${*$self}{'httpd_nomore'}++ if $conn && lc($conn) =~ /\\bclose\\b/;\n    }\n    else {\n        ${*$self}{'httpd_nomore'}++\n            unless $conn && lc($conn) =~ /\\bkeep-alive\\b/;\n    }\n\n    if ($only_headers) {\n        ${*$self}{'httpd_rbuf'} = $buf;\n        return $r;\n    }\n\n    # Find out how much content to read\n    my $tr_enc  = $r->header('Transfer-Encoding');\n    my $ct_type = $r->header('Content-Type');\n    my $ct_len  = $r->header('Content-Length');\n\n    # Act on the Expect header, if it's there\n    for my $e ($r->header('Expect')) {\n        if (lc($e) eq '100-continue') {\n            $self->send_status_line(100);\n            $self->send_crlf;\n        }\n        else {\n            $self->send_error(417);\n            $self->reason(\"Unsupported Expect header value\");\n            return;\n        }\n    }\n\n    if ($tr_enc && lc($tr_enc) eq 'chunked') {\n\n        # Handle chunked transfer encoding\n        my $body = \"\";\n    CHUNK:\n        while (1) {\n            print STDERR \"Chunked\\n\" if $DEBUG;\n            if ($buf =~ s/^([^\\012]*)\\012//) {\n                my $chunk_head = $1;\n                unless ($chunk_head =~ /^([0-9A-Fa-f]+)/) {\n                    $self->send_error(400);\n                    $self->reason(\"Bad chunk header $chunk_head\");\n                    return;\n                }\n                my $size = hex($1);\n                last CHUNK if $size == 0;\n\n                my $missing = $size - length($buf) + 2;    # 2=CRLF at chunk end\n                     # must read until we have a complete chunk\n                while ($missing > 0) {\n                    print STDERR \"Need $missing more bytes\\n\" if $DEBUG;\n                    my $n = $self->_need_more($buf, $timeout, $fdset);\n                    return unless $n;\n                    $missing -= $n;\n                }\n                $body .= substr($buf, 0, $size);\n                substr($buf, 0, $size + 2) = '';\n\n            }\n            else {\n                # need more data in order to have a complete chunk header\n                return unless $self->_need_more($buf, $timeout, $fdset);\n            }\n        }\n        $r->content($body);\n\n        # pretend it was a normal entity body\n        $r->remove_header('Transfer-Encoding');\n        $r->header('Content-Length', length($body));\n\n        my ($key, $val);\n    FOOTER:\n        while (1) {\n            if ($buf !~ /\\012/) {\n\n                # need at least one line to look at\n                return unless $self->_need_more($buf, $timeout, $fdset);\n            }\n            else {\n                $buf =~ s/^([^\\012]*)\\012//;\n                $_ = $1;\n                s/\\015$//;\n                if (/^([\\w\\-]+)\\s*:\\s*(.*)/) {\n                    $r->push_header($key, $val) if $key;\n                    ($key, $val) = ($1, $2);\n                }\n                elsif (/^\\s+(.*)/) {\n                    $val .= \" $1\";\n                }\n                elsif (!length) {\n                    last FOOTER;\n                }\n                else {\n                    $self->reason(\"Bad footer syntax\");\n                    return;\n                }\n            }\n        }\n        $r->push_header($key, $val) if $key;\n\n    }\n    elsif ($tr_enc) {\n        $self->send_error(501);    # Unknown transfer encoding\n        $self->reason(\"Unknown transfer encoding '$tr_enc'\");\n        return;\n\n    }\n    elsif ($ct_len) {\n\n        # After a security issue, we ensure we comply to\n        # RFC-7230 -- HTTP/1.1 Message Syntax and Routing\n        # section 3.3.2 -- Content-Length\n        # section 3.3.3 -- Message Body Length\n\n        # split and clean up Content-Length ', ' separated string\n        my @vals = map {my $str = $_; $str =~ s/^\\s+//; $str =~ s/\\s+$//; $str }\n            split ',', $ct_len;\n        # check that they are all numbers (RFC: Content-Length = 1*DIGIT)\n        my @nums = grep { /^[0-9]+$/} @vals;\n        unless (@vals == @nums) {\n            my $reason = \"Content-Length value must be an unsigned integer\";\n            $self->send_error(400, $reason);\n            $self->reason($reason);\n            return;\n        }\n        # check they are all the same\n        my $ct_len = shift @nums;\n        foreach (@nums) {\n            next if $_ == $ct_len;\n            my $reason = \"Content-Length values are not the same\";\n            $self->send_error(400, $reason);\n            $self->reason($reason);\n            return;\n        }\n        # ensure we have now a fixed header, with only 1 value\n        $r->header('Content-Length' => $ct_len);\n\n        # Plain body specified by \"Content-Length\"\n        my $missing = $ct_len - length($buf);\n        while ($missing > 0) {\n            print \"Need $missing more bytes of content\\n\" if $DEBUG;\n            my $n = $self->_need_more($buf, $timeout, $fdset);\n            return unless $n;\n            $missing -= $n;\n        }\n        if (length($buf) > $ct_len) {\n            $r->content(substr($buf, 0, $ct_len));\n            substr($buf, 0, $ct_len) = '';\n        }\n        else {\n            $r->content($buf);\n            $buf = '';\n        }\n    }\n    elsif ($ct_type && $ct_type =~ m/^multipart\\/\\w+\\s*;.*boundary\\s*=\\s*(\"?)(\\w+)\\1/i) {\n\n        # Handle multipart content type\n        my $boundary = \"$CRLF--$2--\";\n        my $index;\n        while (1) {\n            $index = index($buf, $boundary);\n            last if $index >= 0;\n\n            # end marker not yet found\n            return unless $self->_need_more($buf, $timeout, $fdset);\n        }\n        $index += length($boundary);\n        $r->content(substr($buf, 0, $index));\n        substr($buf, 0, $index) = '';\n\n    }\n    ${*$self}{'httpd_rbuf'} = $buf;\n\n    $r;\n}\n\nsub _need_more {\n    my $self = shift;\n\n    #my($buf,$timeout,$fdset) = @_;\n    if ($_[1]) {\n        my ($timeout, $fdset) = @_[1, 2];\n        print STDERR \"select(,,,$timeout)\\n\" if $DEBUG;\n        my $n = select($fdset, undef, undef, $timeout);\n        unless ($n) {\n            $self->reason(defined($n) ? \"Timeout\" : \"select: $!\");\n            return;\n        }\n    }\n    print STDERR \"sysread()\\n\" if $DEBUG;\n    my $n = sysread($self, $_[0], 2048, length($_[0]));\n    $self->reason(defined($n) ? \"Client closed\" : \"sysread: $!\") unless $n;\n    $n;\n}\n\nsub read_buffer {\n    my $self = shift;\n    my $old  = ${*$self}{'httpd_rbuf'};\n    if (@_) {\n        ${*$self}{'httpd_rbuf'} = shift;\n    }\n    $old;\n}\n\nsub reason {\n    my $self = shift;\n    my $old  = ${*$self}{'httpd_reason'};\n    if (@_) {\n        ${*$self}{'httpd_reason'} = shift;\n    }\n    $old;\n}\n\nsub proto_ge {\n    my $self = shift;\n    ${*$self}{'httpd_client_proto'} >= _http_version(shift);\n}\n\nsub _http_version {\n    local ($_) = shift;\n    return 0 unless m,^(?:HTTP/)?(\\d+)\\.(\\d+)$,i;\n    $1 * 1000 + $2;\n}\n\nsub antique_client {\n    my $self = shift;\n    ${*$self}{'httpd_client_proto'} < $HTTP_1_0;\n}\n\nsub force_last_request {\n    my $self = shift;\n    ${*$self}{'httpd_nomore'}++;\n}\n\nsub head_request {\n    my $self = shift;\n    ${*$self}{'httpd_head'};\n}\n\n\nsub send_status_line {\n    my ($self, $status, $message, $proto) = @_;\n    return if $self->antique_client;\n    $status  ||= RC_OK;\n    $message ||= status_message($status) || \"\";\n    $proto   ||= $HTTP::Daemon::PROTO || \"HTTP/1.1\";\n    print $self \"$proto $status $message$CRLF\";\n}\n\nsub send_crlf {\n    my $self = shift;\n    print $self $CRLF;\n}\n\nsub send_basic_header {\n    my $self = shift;\n    return if $self->antique_client;\n    $self->send_status_line(@_);\n    print $self \"Date: \", time2str(time), $CRLF;\n    my $product = $self->daemon->product_tokens;\n    print $self \"Server: $product$CRLF\" if $product;\n}\n\nsub send_header {\n    my $self = shift;\n    while (@_) {\n        my ($k, $v) = splice(@_, 0, 2);\n        $v = \"\" unless defined($v);\n        print $self \"$k: $v$CRLF\";\n    }\n}\n\nsub send_response {\n    my $self = shift;\n    my $res  = shift;\n    if (!ref $res) {\n        $res ||= RC_OK;\n        $res = HTTP::Response->new($res, @_);\n    }\n    my $content = $res->content;\n    my $chunked;\n    unless ($self->antique_client) {\n        my $code = $res->code;\n        $self->send_basic_header($code, $res->message, $res->protocol);\n        if ($code =~ /^(1\\d\\d|[23]04)$/) {\n\n            # make sure content is empty\n            $res->remove_header(\"Content-Length\");\n            $content = \"\";\n        }\n        elsif ($res->request && $res->request->method eq \"HEAD\") {\n\n            # probably OK\n        }\n        elsif (ref($content) eq \"CODE\") {\n            if ($self->proto_ge(\"HTTP/1.1\")) {\n                $res->push_header(\"Transfer-Encoding\" => \"chunked\");\n                $chunked++;\n            }\n            else {\n                $self->force_last_request;\n            }\n        }\n        elsif (length($content)) {\n            $res->header(\"Content-Length\" => length($content));\n        }\n        else {\n            $self->force_last_request;\n            $res->header('connection', 'close');\n        }\n        print $self $res->headers_as_string($CRLF);\n        print $self $CRLF;    # separates headers and content\n    }\n    if ($self->head_request) {\n\n        # no content\n    }\n    elsif (ref($content) eq \"CODE\") {\n        while (1) {\n            my $chunk = &$content();\n            last unless defined($chunk) && length($chunk);\n            if ($chunked) {\n                printf $self \"%x%s%s%s\", length($chunk), $CRLF, $chunk, $CRLF;\n            }\n            else {\n                print $self $chunk;\n            }\n        }\n        print $self \"0$CRLF$CRLF\" if $chunked;    # no trailers either\n    }\n    elsif (length $content) {\n        print $self $content;\n    }\n}\n\nsub send_redirect {\n    my ($self, $loc, $status, $content) = @_;\n    $status ||= RC_MOVED_PERMANENTLY;\n    Carp::croak(\"Status '$status' is not redirect\") unless is_redirect($status);\n    $self->send_basic_header($status);\n    my $base = $self->daemon->url;\n    $loc = $HTTP::URI_CLASS->new($loc, $base) unless ref($loc);\n    $loc = $loc->abs($base);\n    print $self \"Location: $loc$CRLF\";\n\n    if ($content) {\n        my $ct_type = $content =~ /^\\s*</ ? \"text/html\" : \"text/plain\";\n        print $self \"Content-Type: $ct_type$CRLF\";\n    }\n    print $self $CRLF;\n    print $self $content if $content && !$self->head_request;\n    $self->force_last_request;    # no use keeping the connection open\n}\n\nsub send_error {\n    my ($self, $status, $error) = @_;\n    $status ||= RC_BAD_REQUEST;\n    Carp::croak(\"Status '$status' is not an error\") unless is_error($status);\n    my $mess = status_message($status);\n    $error ||= \"\";\n    $mess = <<EOT;\n<title>$status $mess</title>\n<h1>$status $mess</h1>\n$error\nEOT\n    unless ($self->antique_client) {\n        $self->send_basic_header($status);\n        print $self \"Content-Type: text/html$CRLF\";\n        print $self \"Content-Length: \" . length($mess) . $CRLF;\n        print $self $CRLF;\n    }\n    print $self $mess unless $self->head_request;\n    $status;\n}\n\nsub send_file_response {\n    my ($self, $file) = @_;\n    if (-d $file) {\n        $self->send_dir($file);\n    }\n    elsif (-f _) {\n\n        # plain file\n        local (*F);\n        sysopen(F, $file, 0) or return $self->send_error(RC_FORBIDDEN);\n        binmode(F);\n        my ($mime_type, $file_enc) = guess_media_type($file);\n        my ($size, $mtime) = (stat _)[7, 9];\n        unless ($self->antique_client) {\n            $self->send_basic_header;\n            print $self \"Content-Type: $mime_type$CRLF\";\n            print $self \"Content-Encoding: $file_enc$CRLF\" if $file_enc;\n            print $self \"Content-Length: $size$CRLF\" if $size;\n            print $self \"Last-Modified: \", time2str($mtime), \"$CRLF\" if $mtime;\n            print $self $CRLF;\n        }\n        $self->send_file(\\*F) unless $self->head_request;\n        return RC_OK;\n    }\n    else {\n        $self->send_error(RC_NOT_FOUND);\n    }\n}\n\nsub send_dir {\n    my ($self, $dir) = @_;\n    $self->send_error(RC_NOT_FOUND) unless -d $dir;\n    $self->send_error(RC_NOT_IMPLEMENTED);\n}\n\nsub send_file {\n    my ($self, $file) = @_;\n    my $opened = 0;\n    local (*FILE);\n    if (!ref($file)) {\n        open(FILE, $file) || return undef;\n        binmode(FILE);\n        $file = \\*FILE;\n        $opened++;\n    }\n    my $cnt = 0;\n    my $buf = \"\";\n    my $n;\n    while ($n = sysread($file, $buf, 8 * 1024)) {\n        last if !$n;\n        $cnt += $n;\n        print $self $buf;\n    }\n    close($file) if $opened;\n    $cnt;\n}\n\nsub daemon {\n    my $self = shift;\n    ${*$self}{'httpd_daemon'};\n}\n\n\n1;\n\n__END__\n\n=head1 SYNOPSIS\n\n  use HTTP::Daemon;\n  use HTTP::Status;\n\n  my $d = HTTP::Daemon->new || die;\n  print \"Please contact me at: <URL:\", $d->url, \">\\n\";\n  while (my $c = $d->accept) {\n      while (my $r = $c->get_request) {\n      if ($r->method eq 'GET' and $r->uri->path eq \"/xyzzy\") {\n              # remember, this is *not* recommended practice :-)\n          $c->send_file_response(\"/etc/passwd\");\n      }\n      else {\n          $c->send_error(RC_FORBIDDEN)\n      }\n      }\n      $c->close;\n      undef($c);\n  }\n\n=head1 DESCRIPTION\n\nInstances of the C<HTTP::Daemon> class are HTTP/1.1 servers that\nlisten on a socket for incoming requests. The C<HTTP::Daemon> is a\nsubclass of C<IO::Socket::IP>, so you can perform socket operations\ndirectly on it too.\n\nPlease note that C<HTTP::Daemon> used to be a subclass of C<IO::Socket::INET>.\nTo support IPv6, it switched the parent class to C<IO::Socket::IP> at version 6.05.\nSee L</IPv6 SUPPORT> for details.\n\nThe accept() method will return when a connection from a client is\navailable.  The returned value will be an C<HTTP::Daemon::ClientConn>\nobject which is another C<IO::Socket::IP> subclass.  Calling the\nget_request() method on this object will read data from the client and\nreturn an C<HTTP::Request> object.  The ClientConn object also provide\nmethods to send back various responses.\n\nThis HTTP daemon does not fork(2) for you.  Your application, i.e. the\nuser of the C<HTTP::Daemon> is responsible for forking if that is\ndesirable.  Also note that the user is responsible for generating\nresponses that conform to the HTTP/1.1 protocol.\n\nThe following methods of C<HTTP::Daemon> are new (or enhanced) relative\nto the C<IO::Socket::IP> base class:\n\n=over 4\n\n=item $d = HTTP::Daemon->new\n\n=item $d = HTTP::Daemon->new( %opts )\n\nThe constructor method takes the same arguments as the\nC<IO::Socket::IP> constructor, but unlike its base class it can also\nbe called without any arguments.  The daemon will then set up a listen\nqueue of 5 connections and allocate some random port number.\n\nA server that wants to bind to some specific address on the standard\nHTTP port will be constructed like this:\n\n  $d = HTTP::Daemon->new(\n           LocalAddr => 'www.thisplace.com',\n           LocalPort => 80,\n       );\n\nSee L<IO::Socket::IP> for a description of other arguments that can\nbe used to configure the daemon during construction.\n\n=item $c = $d->accept\n\n=item $c = $d->accept( $pkg )\n\n=item ($c, $peer_addr) = $d->accept\n\nThis method works the same as the one provided by the base class, but it\nreturns an C<HTTP::Daemon::ClientConn> reference by default.  If a\npackage name is provided as argument, then the returned object will be\nblessed into the given class.  It is probably a good idea to make that\nclass a subclass of C<HTTP::Daemon::ClientConn>.\n\nThe accept method will return C<undef> if timeouts have been enabled\nand no connection is made within the given time.  The timeout() method\nis described in L<IO::Socket::IP>.\n\nIn list context both the client object and the peer address will be\nreturned; see the description of the accept method of L<IO::Socket> for\ndetails.\n\n=item $d->url\n\nReturns a URL string that can be used to access the server root.\n\n=item $d->product_tokens\n\nReturns the name that this server will use to identify itself.  This\nis the string that is sent with the C<Server> response header.  The\nmain reason to have this method is that subclasses can override it if\nthey want to use another product name.\n\nThe default is the string \"libwww-perl-daemon/#.##\" where \"#.##\" is\nreplaced with the version number of this module.\n\n=back\n\nThe C<HTTP::Daemon::ClientConn> is a subclass of C<IO::Socket::IP>.\nInstances of this class are returned by the accept() method\nof C<HTTP::Daemon>.  The following methods are provided:\n\n=over 4\n\n=item $c->get_request\n\n=item $c->get_request( $headers_only )\n\nThis method reads data from the client and turns it into an\nC<HTTP::Request> object which is returned.  It returns C<undef>\nif reading fails.  If it fails, then the C<HTTP::Daemon::ClientConn>\nobject ($c) should be discarded, and you should not try to call this\nmethod again on it.  The $c->reason method might give you some\ninformation about why $c->get_request failed.\n\nThe get_request() method will normally not return until the whole\nrequest has been received from the client.  This might not be what you\nwant if the request is an upload of a large file (and with chunked\ntransfer encoding HTTP can even support infinite request messages -\nuploading live audio for instance).  If you pass a TRUE value as the\n$headers_only argument, then get_request() will return immediately\nafter parsing the request headers and you are responsible for reading\nthe rest of the request content.  If you are going to call\n$c->get_request again on the same connection you better read the\ncorrect number of bytes.\n\n=item $c->read_buffer\n\n=item $c->read_buffer( $new_value )\n\nBytes read by $c->get_request, but not used are placed in the I<read\nbuffer>.  The next time $c->get_request is called it will consume the\nbytes in this buffer before reading more data from the network\nconnection itself.  The read buffer is invalid after $c->get_request\nhas failed.\n\nIf you handle the reading of the request content yourself you need to\nempty this buffer before you read more and you need to place\nunconsumed bytes here.  You also need this buffer if you implement\nservices like I<101 Switching Protocols>.\n\nThis method always returns the old buffer content and can optionally\nreplace the buffer content if you pass it an argument.\n\n=item $c->reason\n\nWhen $c->get_request returns C<undef> you can obtain a short string\ndescribing why it happened by calling $c->reason.\n\n=item $c->proto_ge( $proto )\n\nReturn TRUE if the client announced a protocol with version number\ngreater or equal to the given argument.  The $proto argument can be a\nstring like \"HTTP/1.1\" or just \"1.1\".\n\n=item $c->antique_client\n\nReturn TRUE if the client speaks the HTTP/0.9 protocol.  No status\ncode and no headers should be returned to such a client.  This should\nbe the same as !$c->proto_ge(\"HTTP/1.0\").\n\n=item $c->head_request\n\nReturn TRUE if the last request was a C<HEAD> request.  No content\nbody must be generated for these requests.\n\n=item $c->force_last_request\n\nMake sure that $c->get_request will not try to read more requests off\nthis connection.  If you generate a response that is not self-delimiting,\nthen you should signal this fact by calling this method.\n\nThis attribute is turned on automatically if the client announces\nprotocol HTTP/1.0 or worse and does not include a \"Connection:\nKeep-Alive\" header.  It is also turned on automatically when HTTP/1.1\nor better clients send the \"Connection: close\" request header.\n\n=item $c->send_status_line\n\n=item $c->send_status_line( $code )\n\n=item $c->send_status_line( $code, $mess )\n\n=item $c->send_status_line( $code, $mess, $proto )\n\nSend the status line back to the client.  If $code is omitted 200 is\nassumed.  If $mess is omitted, then a message corresponding to $code\nis inserted.  If $proto is missing the content of the\n$HTTP::Daemon::PROTO variable is used.\n\n=item $c->send_crlf\n\nSend the CRLF sequence to the client.\n\n=item $c->send_basic_header\n\n=item $c->send_basic_header( $code )\n\n=item $c->send_basic_header( $code, $mess )\n\n=item $c->send_basic_header( $code, $mess, $proto )\n\nSend the status line and the \"Date:\" and \"Server:\" headers back to\nthe client.  This header is assumed to be continued and does not end\nwith an empty CRLF line.\n\nSee the description of send_status_line() for the description of the\naccepted arguments.\n\n=item $c->send_header( $field, $value )\n\n=item $c->send_header( $field1, $value1, $field2, $value2, ... )\n\nSend one or more header lines.\n\n=item $c->send_response( $res )\n\nWrite an C<HTTP::Response> object to the\nclient as a response.  We try hard to make sure that the response is\nself-delimiting so that the connection can stay persistent for further\nrequest/response exchanges.\n\nThe content attribute of the C<HTTP::Response> object can be a normal\nstring or a subroutine reference.  If it is a subroutine, then\nwhatever this callback routine returns is written back to the\nclient as the response content.  The routine will be called until it\nreturns an undefined or empty value.  If the client is HTTP/1.1 aware\nthen we will use chunked transfer encoding for the response.\n\n=item $c->send_redirect( $loc )\n\n=item $c->send_redirect( $loc, $code )\n\n=item $c->send_redirect( $loc, $code, $entity_body )\n\nSend a redirect response back to the client.  The location ($loc) can\nbe an absolute or relative URL. The $code must be one of the redirect\nstatus codes, and defaults to \"301 Moved Permanently\"\n\n=item $c->send_error\n\n=item $c->send_error( $code )\n\n=item $c->send_error( $code, $error_message )\n\nSend an error response back to the client.  If the $code is missing a\n\"Bad Request\" error is reported.  The $error_message is a string that\nis incorporated in the body of the HTML entity.\n\n=item $c->send_file_response( $filename )\n\nSend back a response with the specified $filename as content.  If the\nfile is a directory we try to generate an HTML index of it.\n\n=item $c->send_file( $filename )\n\n=item $c->send_file( $fd )\n\nCopy the file to the client.  The file can be a string (which\nwill be interpreted as a filename) or a reference to an C<IO::Handle>\nor glob.\n\n=item $c->daemon\n\nReturn a reference to the corresponding C<HTTP::Daemon> object.\n\n=back\n\n=head1 IPv6 SUPPORT\n\nSince version 6.05, C<HTTP::Daemon> is a subclass of C<IO::Socket::IP>\nrather than C<IO::Socket::INET>, so that it supports IPv6.\n\nFor some reasons, you may want to force C<HTTP::Daemon> to listen on IPv4 addresses only.\nThen pass C<Family> argument to C<< HTTP::Daemon->new >>:\n\n  use HTTP::Daemon;\n  use Socket 'AF_INET';\n\n  my $d = HTTP::Daemon->new(Family => AF_INET);\n\n=head1 SEE ALSO\n\nRFC 2616\n\nL<IO::Socket::IP>, L<IO::Socket>\n\n=cut\n"], "filenames": ["lib/HTTP/Daemon.pm"], "buggy_code_start_loc": [302], "buggy_code_end_loc": [312], "fixing_code_start_loc": [302], "fixing_code_end_loc": [314], "type": "CWE-444", "message": "HTTP::Daemon is a simple http server class written in perl. Versions prior to 6.15 are subject to a vulnerability which could potentially be exploited to gain privileged access to APIs or poison intermediate caches. It is uncertain how large the risks are, most Perl based applications are served on top of Nginx or Apache, not on the `HTTP::Daemon`. This library is commonly used for local development and tests. Users are advised to update to resolve this issue. Users unable to upgrade may add additional request handling logic as a mitigation. After calling `my $rqst = $conn->get_request()` one could inspect the returned `HTTP::Request` object. Querying the 'Content-Length' (`my $cl = $rqst->header('Content-Length')`) will show any abnormalities that should be dealt with by a `400` response. Expected strings of 'Content-Length' SHOULD consist of either a single non-negative integer, or, a comma separated repetition of that number. (that is `42` or `42, 42, 42`). Anything else MUST be rejected.", "other": {"cve": {"id": "CVE-2022-31081", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-27T21:15:08.020", "lastModified": "2023-03-11T06:15:52.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "HTTP::Daemon is a simple http server class written in perl. Versions prior to 6.15 are subject to a vulnerability which could potentially be exploited to gain privileged access to APIs or poison intermediate caches. It is uncertain how large the risks are, most Perl based applications are served on top of Nginx or Apache, not on the `HTTP::Daemon`. This library is commonly used for local development and tests. Users are advised to update to resolve this issue. Users unable to upgrade may add additional request handling logic as a mitigation. After calling `my $rqst = $conn->get_request()` one could inspect the returned `HTTP::Request` object. Querying the 'Content-Length' (`my $cl = $rqst->header('Content-Length')`) will show any abnormalities that should be dealt with by a `400` response. Expected strings of 'Content-Length' SHOULD consist of either a single non-negative integer, or, a comma separated repetition of that number. (that is `42` or `42, 42, 42`). Anything else MUST be rejected."}, {"lang": "es", "value": "HTTP::Daemon es una clase simple de servidor http escrita en perl. Las versiones anteriores a 6.15 est\u00e1n sujetas a una vulnerabilidad que podr\u00eda ser explotada para conseguir acceso privilegiado a las API o envenenar las cach\u00e9s intermedias. No es sabido con certeza la magnitud de los riesgos, la mayor\u00eda de las aplicaciones basadas en Perl son servidas sobre Nginx o Apache, no sobre el \"HTTP::Daemon\". Esta biblioteca es usada habitualmente para el desarrollo local y las pruebas. Es recomendado a usuarios actualizar para resolver este problema. Los usuarios que no puedan actualizar pueden a\u00f1adir una l\u00f3gica de administraci\u00f3n de peticiones adicional como mitigaci\u00f3n. Tras llamar a \"my $rqst = $conn-)get_request()\" pod\u00eda inspeccionarse el objeto \"HTTP::Request\" devuelto. Consultando el \"Content-Length\" (\"my $cl = $rqst-)header(\"Content-Length\")\") mostrar\u00e1 cualquier anormalidad que deba ser tratada con una respuesta \"400\". Las cadenas esperadas de \"Content-Length\" DEBER\u00cdAN consistir en un \u00fanico n\u00famero entero no negativo, o bien, una repetici\u00f3n separada por comas de ese n\u00famero. (es decir, \"42\" o \"42, 42, 42\"). Cualquier otra cosa DEBE ser rechazada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:http\\:\\:daemon_project:http\\:\\:daemon:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.15", "matchCriteriaId": "1538B10A-7B5E-45CC-9885-A4AC59B7A5E4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://metacpan.org/release/HTTP-Daemon/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://cwe.mitre.org/data/definitions/444.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://datatracker.ietf.org/doc/html/rfc7230#section-9.5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libwww-perl/HTTP-Daemon/commit/8dc5269d59e2d5d9eb1647d82c449ccd880f7fd0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libwww-perl/HTTP-Daemon/commit/e84475de51d6fd7b29354a997413472a99db70b2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libwww-perl/HTTP-Daemon/security/advisories/GHSA-cg8c-pxmv-w7cf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00038.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7U4XEPZ5Q3LNOQF3E6EXFWVSEXU5IZ6T/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ECJ4ZPBQWD3B2CD6RRIVMENB5KUOJ3LC/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XQBW2D43TDNYX4R2YBTNNZDBNZ45DINN/", "source": "security-advisories@github.com"}, {"url": "https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libwww-perl/HTTP-Daemon/commit/8dc5269d59e2d5d9eb1647d82c449ccd880f7fd0"}}