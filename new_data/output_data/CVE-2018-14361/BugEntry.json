{"buggy_code": ["/**\n * @file\n * Usenet network mailbox type; talk to an NNTP server\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page nntp Usenet network mailbox type; talk to an NNTP server\n *\n * Usenet network mailbox type; talk to an NNTP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <string.h>\n#include <strings.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"nntp.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"thread.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n#ifdef USE_SASL\n#include <sasl/sasl.h>\n#include <sasl/saslutil.h>\n#endif\n\nstruct NntpServer *CurrentNewsSrv;\n\n/**\n * nntp_connect_error - Signal a failed connection\n * @param nserv NNTP server\n * @retval -1 Always\n */\nstatic int nntp_connect_error(struct NntpServer *nserv)\n{\n  nserv->status = NNTP_NONE;\n  mutt_error(_(\"Server closed connection!\"));\n  return -1;\n}\n\n/**\n * nntp_capabilities - Get capabilities\n * @param nserv NNTP server\n * @retval -1 Error, connection is closed\n * @retval  0 Mode is reader, capabilities set up\n * @retval  1 Need to switch to reader mode\n */\nstatic int nntp_capabilities(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  bool mode_reader = false;\n  char buf[LONG_STRING];\n  char authinfo[LONG_STRING] = \"\";\n\n  nserv->hasCAPABILITIES = false;\n  nserv->hasSTARTTLS = false;\n  nserv->hasDATE = false;\n  nserv->hasLIST_NEWSGROUPS = false;\n  nserv->hasLISTGROUP = false;\n  nserv->hasLISTGROUPrange = false;\n  nserv->hasOVER = false;\n  FREE(&nserv->authenticators);\n\n  if (mutt_socket_send(conn, \"CAPABILITIES\\r\\n\") < 0 ||\n      mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n  {\n    return nntp_connect_error(nserv);\n  }\n\n  /* no capabilities */\n  if (mutt_str_strncmp(\"101\", buf, 3) != 0)\n    return 1;\n  nserv->hasCAPABILITIES = true;\n\n  /* parse capabilities */\n  do\n  {\n    if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n      return nntp_connect_error(nserv);\n    if (mutt_str_strcmp(\"STARTTLS\", buf) == 0)\n      nserv->hasSTARTTLS = true;\n    else if (mutt_str_strcmp(\"MODE-READER\", buf) == 0)\n      mode_reader = true;\n    else if (mutt_str_strcmp(\"READER\", buf) == 0)\n    {\n      nserv->hasDATE = true;\n      nserv->hasLISTGROUP = true;\n      nserv->hasLISTGROUPrange = true;\n    }\n    else if (mutt_str_strncmp(\"AUTHINFO \", buf, 9) == 0)\n    {\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n      mutt_str_strfcpy(authinfo, buf + 8, sizeof(authinfo));\n    }\n#ifdef USE_SASL\n    else if (mutt_str_strncmp(\"SASL \", buf, 5) == 0)\n    {\n      char *p = buf + 5;\n      while (*p == ' ')\n        p++;\n      nserv->authenticators = mutt_str_strdup(p);\n    }\n#endif\n    else if (mutt_str_strcmp(\"OVER\", buf) == 0)\n      nserv->hasOVER = true;\n    else if (mutt_str_strncmp(\"LIST \", buf, 5) == 0)\n    {\n      char *p = strstr(buf, \" NEWSGROUPS\");\n      if (p)\n      {\n        p += 11;\n        if (*p == '\\0' || *p == ' ')\n          nserv->hasLIST_NEWSGROUPS = true;\n      }\n    }\n  } while (mutt_str_strcmp(\".\", buf) != 0);\n  *buf = '\\0';\n#ifdef USE_SASL\n  if (nserv->authenticators && strcasestr(authinfo, \" SASL \"))\n    mutt_str_strfcpy(buf, nserv->authenticators, sizeof(buf));\n#endif\n  if (strcasestr(authinfo, \" USER \"))\n  {\n    if (*buf)\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n    mutt_str_strcat(buf, sizeof(buf), \"USER\");\n  }\n  mutt_str_replace(&nserv->authenticators, buf);\n\n  /* current mode is reader */\n  if (nserv->hasDATE)\n    return 0;\n\n  /* server is mode-switching, need to switch to reader mode */\n  if (mode_reader)\n    return 1;\n\n  mutt_socket_close(conn);\n  nserv->status = NNTP_BYE;\n  mutt_error(_(\"Server doesn't support reader mode.\"));\n  return -1;\n}\n\nchar *OverviewFmt = \"Subject:\\0\"\n                    \"From:\\0\"\n                    \"Date:\\0\"\n                    \"Message-ID:\\0\"\n                    \"References:\\0\"\n                    \"Content-Length:\\0\"\n                    \"Lines:\\0\"\n                    \"\\0\";\n\n/**\n * nntp_attempt_features - Detect supported commands\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_attempt_features(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  char buf[LONG_STRING];\n\n  /* no CAPABILITIES, trying DATE, LISTGROUP, LIST NEWSGROUPS */\n  if (!nserv->hasCAPABILITIES)\n  {\n    if (mutt_socket_send(conn, \"DATE\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasDATE = true;\n\n    if (mutt_socket_send(conn, \"LISTGROUP\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasLISTGROUP = true;\n\n    if (mutt_socket_send(conn, \"LIST NEWSGROUPS +\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasLIST_NEWSGROUPS = true;\n    if (mutt_str_strncmp(\"215\", buf, 3) == 0)\n    {\n      do\n      {\n        if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n          return nntp_connect_error(nserv);\n      } while (mutt_str_strcmp(\".\", buf) != 0);\n    }\n  }\n\n  /* no LIST NEWSGROUPS, trying XGTITLE */\n  if (!nserv->hasLIST_NEWSGROUPS)\n  {\n    if (mutt_socket_send(conn, \"XGTITLE\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasXGTITLE = true;\n  }\n\n  /* no OVER, trying XOVER */\n  if (!nserv->hasOVER)\n  {\n    if (mutt_socket_send(conn, \"XOVER\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasXOVER = true;\n  }\n\n  /* trying LIST OVERVIEW.FMT */\n  if (nserv->hasOVER || nserv->hasXOVER)\n  {\n    if (mutt_socket_send(conn, \"LIST OVERVIEW.FMT\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"215\", buf, 3) != 0)\n      nserv->overview_fmt = OverviewFmt;\n    else\n    {\n      int cont = 0;\n      size_t buflen = 2 * LONG_STRING, off = 0, b = 0;\n\n      if (nserv->overview_fmt)\n        FREE(&nserv->overview_fmt);\n      nserv->overview_fmt = mutt_mem_malloc(buflen);\n\n      while (true)\n      {\n        if (buflen - off < LONG_STRING)\n        {\n          buflen *= 2;\n          mutt_mem_realloc(&nserv->overview_fmt, buflen);\n        }\n\n        const int chunk =\n            mutt_socket_readln(nserv->overview_fmt + off, buflen - off, conn);\n        if (chunk < 0)\n        {\n          FREE(&nserv->overview_fmt);\n          return nntp_connect_error(nserv);\n        }\n\n        if (!cont && (mutt_str_strcmp(\".\", nserv->overview_fmt + off) == 0))\n          break;\n\n        cont = chunk >= buflen - off ? 1 : 0;\n        off += strlen(nserv->overview_fmt + off);\n        if (!cont)\n        {\n          char *colon = NULL;\n\n          if (nserv->overview_fmt[b] == ':')\n          {\n            memmove(nserv->overview_fmt + b, nserv->overview_fmt + b + 1, off - b - 1);\n            nserv->overview_fmt[off - 1] = ':';\n          }\n          colon = strchr(nserv->overview_fmt + b, ':');\n          if (!colon)\n            nserv->overview_fmt[off++] = ':';\n          else if (strcmp(colon + 1, \"full\") != 0)\n            off = colon + 1 - nserv->overview_fmt;\n          if (strcasecmp(nserv->overview_fmt + b, \"Bytes:\") == 0)\n          {\n            size_t len = strlen(nserv->overview_fmt + b);\n            mutt_str_strfcpy(nserv->overview_fmt + b, \"Content-Length:\", len + 1);\n            off = b + len;\n          }\n          nserv->overview_fmt[off++] = '\\0';\n          b = off;\n        }\n      }\n      nserv->overview_fmt[off++] = '\\0';\n      mutt_mem_realloc(&nserv->overview_fmt, off);\n    }\n  }\n  return 0;\n}\n\n/**\n * nntp_auth - Get login, password and authenticate\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_auth(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  char buf[LONG_STRING];\n  char authenticators[LONG_STRING] = \"USER\";\n  char *method = NULL, *a = NULL, *p = NULL;\n  unsigned char flags = conn->account.flags;\n\n  while (true)\n  {\n    /* get login and password */\n    if ((mutt_account_getuser(&conn->account) < 0) || (conn->account.user[0] == '\\0') ||\n        (mutt_account_getpass(&conn->account) < 0) || (conn->account.pass[0] == '\\0'))\n    {\n      break;\n    }\n\n    /* get list of authenticators */\n    if (NntpAuthenticators && *NntpAuthenticators)\n      mutt_str_strfcpy(authenticators, NntpAuthenticators, sizeof(authenticators));\n    else if (nserv->hasCAPABILITIES)\n    {\n      mutt_str_strfcpy(authenticators, NONULL(nserv->authenticators), sizeof(authenticators));\n      p = authenticators;\n      while (*p)\n      {\n        if (*p == ' ')\n          *p = ':';\n        p++;\n      }\n    }\n    p = authenticators;\n    while (*p)\n    {\n      *p = toupper(*p);\n      p++;\n    }\n\n    mutt_debug(1, \"available methods: %s\\n\", nserv->authenticators);\n    a = authenticators;\n    while (true)\n    {\n      if (!a)\n      {\n        mutt_error(_(\"No authenticators available\"));\n        break;\n      }\n\n      method = a;\n      a = strchr(a, ':');\n      if (a)\n        *a++ = '\\0';\n\n      /* check authenticator */\n      if (nserv->hasCAPABILITIES)\n      {\n        char *m = NULL;\n\n        if (!nserv->authenticators)\n          continue;\n        m = strcasestr(nserv->authenticators, method);\n        if (!m)\n          continue;\n        if (m > nserv->authenticators && *(m - 1) != ' ')\n          continue;\n        m += strlen(method);\n        if (*m != '\\0' && *m != ' ')\n          continue;\n      }\n      mutt_debug(1, \"trying method %s\\n\", method);\n\n      /* AUTHINFO USER authentication */\n      if (strcmp(method, \"USER\") == 0)\n      {\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO USER %s\\r\\n\", conn->account.user);\n        if (mutt_socket_send(conn, buf) < 0 ||\n            mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n        {\n          break;\n        }\n\n        /* authenticated, password is not required */\n        if (mutt_str_strncmp(\"281\", buf, 3) == 0)\n          return 0;\n\n        /* username accepted, sending password */\n        if (mutt_str_strncmp(\"381\", buf, 3) == 0)\n        {\n          if (DebugLevel < MUTT_SOCK_LOG_FULL)\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> AUTHINFO PASS *\\n\", conn->fd);\n          snprintf(buf, sizeof(buf), \"AUTHINFO PASS %s\\r\\n\", conn->account.pass);\n          if (mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0 ||\n              mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n          {\n            break;\n          }\n\n          /* authenticated */\n          if (mutt_str_strncmp(\"281\", buf, 3) == 0)\n            return 0;\n        }\n\n        /* server doesn't support AUTHINFO USER, trying next method */\n        if (*buf == '5')\n          continue;\n      }\n\n      else\n      {\n#ifdef USE_SASL\n        sasl_conn_t *saslconn = NULL;\n        sasl_interact_t *interaction = NULL;\n        int rc;\n        char inbuf[LONG_STRING] = \"\";\n        const char *mech = NULL;\n        const char *client_out = NULL;\n        unsigned int client_len, len;\n\n        if (mutt_sasl_client_new(conn, &saslconn) < 0)\n        {\n          mutt_debug(1, \"error allocating SASL connection.\\n\");\n          continue;\n        }\n\n        while (true)\n        {\n          rc = sasl_client_start(saslconn, method, &interaction, &client_out,\n                                 &client_len, &mech);\n          if (rc != SASL_INTERACT)\n            break;\n          mutt_sasl_interact(interaction);\n        }\n        if (rc != SASL_OK && rc != SASL_CONTINUE)\n        {\n          sasl_dispose(&saslconn);\n          mutt_debug(1, \"error starting SASL authentication exchange.\\n\");\n          continue;\n        }\n\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO SASL %s\", method);\n\n        /* looping protocol */\n        while (rc == SASL_CONTINUE || (rc == SASL_OK && client_len))\n        {\n          /* send out client response */\n          if (client_len)\n          {\n            if (DebugLevel >= MUTT_SOCK_LOG_FULL)\n            {\n              char tmp[LONG_STRING];\n              memcpy(tmp, client_out, client_len);\n              for (p = tmp; p < tmp + client_len; p++)\n              {\n                if (*p == '\\0')\n                  *p = '.';\n              }\n              *p = '\\0';\n              mutt_debug(1, \"SASL> %s\\n\", tmp);\n            }\n\n            if (*buf)\n              mutt_str_strcat(buf, sizeof(buf), \" \");\n            len = strlen(buf);\n            if (sasl_encode64(client_out, client_len, buf + len,\n                              sizeof(buf) - len, &len) != SASL_OK)\n            {\n              mutt_debug(1, \"error base64-encoding client response.\\n\");\n              break;\n            }\n          }\n\n          mutt_str_strcat(buf, sizeof(buf), \"\\r\\n\");\n          if (DebugLevel < MUTT_SOCK_LOG_FULL)\n          {\n            if (strchr(buf, ' '))\n            {\n              mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> AUTHINFO SASL %s%s\\n\",\n                         conn->fd, method, client_len ? \" sasl_data\" : \"\");\n            }\n            else\n              mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> sasl_data\\n\", conn->fd);\n          }\n          client_len = 0;\n          if (mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0 ||\n              mutt_socket_readln_d(inbuf, sizeof(inbuf), conn, MUTT_SOCK_LOG_FULL) < 0)\n          {\n            break;\n          }\n          if ((mutt_str_strncmp(inbuf, \"283 \", 4) != 0) &&\n              (mutt_str_strncmp(inbuf, \"383 \", 4) != 0))\n          {\n            if (DebugLevel < MUTT_SOCK_LOG_FULL)\n              mutt_debug(MUTT_SOCK_LOG_CMD, \"%d< %s\\n\", conn->fd, inbuf);\n            break;\n          }\n          if (DebugLevel < MUTT_SOCK_LOG_FULL)\n          {\n            inbuf[3] = '\\0';\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d< %s sasl_data\\n\", conn->fd, inbuf);\n          }\n\n          if (strcmp(\"=\", inbuf + 4) == 0)\n            len = 0;\n          else if (sasl_decode64(inbuf + 4, strlen(inbuf + 4), buf,\n                                 sizeof(buf) - 1, &len) != SASL_OK)\n          {\n            mutt_debug(1, \"error base64-decoding server response.\\n\");\n            break;\n          }\n          else if (DebugLevel >= MUTT_SOCK_LOG_FULL)\n          {\n            char tmp[LONG_STRING];\n            memcpy(tmp, buf, len);\n            for (p = tmp; p < tmp + len; p++)\n            {\n              if (*p == '\\0')\n                *p = '.';\n            }\n            *p = '\\0';\n            mutt_debug(1, \"SASL< %s\\n\", tmp);\n          }\n\n          while (true)\n          {\n            rc = sasl_client_step(saslconn, buf, len, &interaction, &client_out, &client_len);\n            if (rc != SASL_INTERACT)\n              break;\n            mutt_sasl_interact(interaction);\n          }\n          if (*inbuf != '3')\n            break;\n\n          *buf = '\\0';\n        } /* looping protocol */\n\n        if (rc == SASL_OK && client_len == 0 && *inbuf == '2')\n        {\n          mutt_sasl_setup_conn(conn, saslconn);\n          return 0;\n        }\n\n        /* terminate SASL session */\n        sasl_dispose(&saslconn);\n        if (conn->fd < 0)\n          break;\n        if (mutt_str_strncmp(inbuf, \"383 \", 4) == 0)\n        {\n          if (mutt_socket_send(conn, \"*\\r\\n\") < 0 ||\n              mutt_socket_readln(inbuf, sizeof(inbuf), conn) < 0)\n          {\n            break;\n          }\n        }\n\n        /* server doesn't support AUTHINFO SASL, trying next method */\n        if (*inbuf == '5')\n          continue;\n#else\n        continue;\n#endif /* USE_SASL */\n      }\n\n      mutt_error(_(\"%s authentication failed.\"), method);\n      break;\n    }\n    break;\n  }\n\n  /* error */\n  nserv->status = NNTP_BYE;\n  conn->account.flags = flags;\n  if (conn->fd < 0)\n  {\n    mutt_error(_(\"Server closed connection!\"));\n  }\n  else\n    mutt_socket_close(conn);\n  return -1;\n}\n\n/**\n * nntp_open_connection - Connect to server, authenticate and get capabilities\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_open_connection(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  char buf[STRING];\n  int cap;\n  bool posting = false, auth = true;\n\n  if (nserv->status == NNTP_OK)\n    return 0;\n  if (nserv->status == NNTP_BYE)\n    return -1;\n  nserv->status = NNTP_NONE;\n\n  if (mutt_socket_open(conn) < 0)\n    return -1;\n\n  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    return nntp_connect_error(nserv);\n\n  if (mutt_str_strncmp(\"200\", buf, 3) == 0)\n    posting = true;\n  else if (mutt_str_strncmp(\"201\", buf, 3) != 0)\n  {\n    mutt_socket_close(conn);\n    mutt_str_remove_trailing_ws(buf);\n    mutt_error(\"%s\", buf);\n    return -1;\n  }\n\n  /* get initial capabilities */\n  cap = nntp_capabilities(nserv);\n  if (cap < 0)\n    return -1;\n\n  /* tell news server to switch to mode reader if it isn't so */\n  if (cap > 0)\n  {\n    if (mutt_socket_send(conn, \"MODE READER\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n\n    if (mutt_str_strncmp(\"200\", buf, 3) == 0)\n      posting = true;\n    else if (mutt_str_strncmp(\"201\", buf, 3) == 0)\n      posting = false;\n    /* error if has capabilities, ignore result if no capabilities */\n    else if (nserv->hasCAPABILITIES)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode.\"));\n      return -1;\n    }\n\n    /* recheck capabilities after MODE READER */\n    if (nserv->hasCAPABILITIES)\n    {\n      cap = nntp_capabilities(nserv);\n      if (cap < 0)\n        return -1;\n    }\n  }\n\n  mutt_message(_(\"Connected to %s. %s\"), conn->account.host,\n               posting ? _(\"Posting is ok.\") : _(\"Posting is NOT ok.\"));\n  mutt_sleep(1);\n\n#ifdef USE_SSL\n  /* Attempt STARTTLS if available and desired. */\n  if (nserv->use_tls != 1 && (nserv->hasSTARTTLS || SslForceTls))\n  {\n    if (nserv->use_tls == 0)\n    {\n      nserv->use_tls =\n          SslForceTls || query_quadoption(SslStarttls,\n                                          _(\"Secure connection with TLS?\")) == MUTT_YES ?\n              2 :\n              1;\n    }\n    if (nserv->use_tls == 2)\n    {\n      if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0 ||\n          mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n      {\n        return nntp_connect_error(nserv);\n      }\n      if (mutt_str_strncmp(\"382\", buf, 3) != 0)\n      {\n        nserv->use_tls = 0;\n        mutt_error(\"STARTTLS: %s\", buf);\n      }\n      else if (mutt_ssl_starttls(conn))\n      {\n        nserv->use_tls = 0;\n        nserv->status = NNTP_NONE;\n        mutt_socket_close(nserv->conn);\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -1;\n      }\n      else\n      {\n        /* recheck capabilities after STARTTLS */\n        cap = nntp_capabilities(nserv);\n        if (cap < 0)\n          return -1;\n      }\n    }\n  }\n#endif\n\n  /* authentication required? */\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!conn->account.user[0])\n      auth = false;\n  }\n  else\n  {\n    if (mutt_socket_send(conn, \"STAT\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"480\", buf, 3) != 0)\n      auth = false;\n  }\n\n  /* authenticate */\n  if (auth && nntp_auth(nserv) < 0)\n    return -1;\n\n  /* get final capabilities after authentication */\n  if (nserv->hasCAPABILITIES && (auth || cap > 0))\n  {\n    cap = nntp_capabilities(nserv);\n    if (cap < 0)\n      return -1;\n    if (cap > 0)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode.\"));\n      return -1;\n    }\n  }\n\n  /* attempt features */\n  if (nntp_attempt_features(nserv) < 0)\n    return -1;\n\n  nserv->status = NNTP_OK;\n  return 0;\n}\n\n/**\n * nntp_query - Send data from buffer and receive answer to same buffer\n * @param nntp_data NNTP server data\n * @param line      Buffer containing data\n * @param linelen   Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_query(struct NntpData *nntp_data, char *line, size_t linelen)\n{\n  struct NntpServer *nserv = nntp_data->nserv;\n  char buf[LONG_STRING] = { 0 };\n\n  if (nserv->status == NNTP_BYE)\n    return -1;\n\n  while (true)\n  {\n    if (nserv->status == NNTP_OK)\n    {\n      int rc = 0;\n\n      if (*line)\n        rc = mutt_socket_send(nserv->conn, line);\n      else if (nntp_data->group)\n      {\n        snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", nntp_data->group);\n        rc = mutt_socket_send(nserv->conn, buf);\n      }\n      if (rc >= 0)\n        rc = mutt_socket_readln(buf, sizeof(buf), nserv->conn);\n      if (rc >= 0)\n        break;\n    }\n\n    /* reconnect */\n    while (true)\n    {\n      nserv->status = NNTP_NONE;\n      if (nntp_open_connection(nserv) == 0)\n        break;\n\n      snprintf(buf, sizeof(buf), _(\"Connection to %s lost. Reconnect?\"),\n               nserv->conn->account.host);\n      if (mutt_yesorno(buf, MUTT_YES) != MUTT_YES)\n      {\n        nserv->status = NNTP_BYE;\n        return -1;\n      }\n    }\n\n    /* select newsgroup after reconnection */\n    if (nntp_data->group)\n    {\n      snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", nntp_data->group);\n      if (mutt_socket_send(nserv->conn, buf) < 0 ||\n          mutt_socket_readln(buf, sizeof(buf), nserv->conn) < 0)\n      {\n        return nntp_connect_error(nserv);\n      }\n    }\n    if (!*line)\n      break;\n  }\n\n  mutt_str_strfcpy(line, buf, linelen);\n  return 0;\n}\n\n/**\n * nntp_fetch_lines - Read lines, calling a callback function for each\n * @param nntp_data NNTP server data\n * @param query     Query to match\n * @param qlen      Length of query\n * @param msg       Progess message (OPTIONAL)\n * @param funct     Callback function\n * @param data      Data for callback function\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error in funct(*line, *data)\n *\n * This function calls funct(*line, *data) for each received line,\n * funct(NULL, *data) if rewind(*data) needs, exits when fail or done:\n */\nstatic int nntp_fetch_lines(struct NntpData *nntp_data, char *query, size_t qlen,\n                            const char *msg, int (*funct)(char *, void *), void *data)\n{\n  int done = false;\n  int rc;\n\n  while (!done)\n  {\n    char buf[LONG_STRING];\n    char *line = NULL;\n    unsigned int lines = 0;\n    size_t off = 0;\n    struct Progress progress;\n\n    if (msg)\n      mutt_progress_init(&progress, msg, MUTT_PROGRESS_MSG, ReadInc, 0);\n\n    mutt_str_strfcpy(buf, query, sizeof(buf));\n    if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n      return -1;\n    if (buf[0] != '2')\n    {\n      mutt_str_strfcpy(query, buf, qlen);\n      return 1;\n    }\n\n    line = mutt_mem_malloc(sizeof(buf));\n    rc = 0;\n\n    while (true)\n    {\n      char *p = NULL;\n      int chunk = mutt_socket_readln_d(buf, sizeof(buf), nntp_data->nserv->conn,\n                                       MUTT_SOCK_LOG_HDR);\n      if (chunk < 0)\n      {\n        nntp_data->nserv->status = NNTP_NONE;\n        break;\n      }\n\n      p = buf;\n      if (!off && buf[0] == '.')\n      {\n        if (buf[1] == '\\0')\n        {\n          done = true;\n          break;\n        }\n        if (buf[1] == '.')\n          p++;\n      }\n\n      mutt_str_strfcpy(line + off, p, sizeof(buf));\n\n      if (chunk >= sizeof(buf))\n        off += strlen(p);\n      else\n      {\n        if (msg)\n          mutt_progress_update(&progress, ++lines, -1);\n\n        if (rc == 0 && funct(line, data) < 0)\n          rc = -2;\n        off = 0;\n      }\n\n      mutt_mem_realloc(&line, off + sizeof(buf));\n    }\n    FREE(&line);\n    funct(NULL, data);\n  }\n  return rc;\n}\n\n/**\n * fetch_description - Parse newsgroup description\n * @param line String to parse\n * @param data NNTP Server\n * @retval 0 Always\n */\nstatic int fetch_description(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char *desc = NULL;\n\n  if (!line)\n    return 0;\n\n  desc = strpbrk(line, \" \\t\");\n  if (desc)\n  {\n    *desc++ = '\\0';\n    desc += strspn(desc, \" \\t\");\n  }\n  else\n    desc = strchr(line, '\\0');\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, line);\n  if (nntp_data && (mutt_str_strcmp(desc, nntp_data->desc) != 0))\n  {\n    mutt_str_replace(&nntp_data->desc, desc);\n    mutt_debug(2, \"group: %s, desc: %s\\n\", line, desc);\n  }\n  return 0;\n}\n\n/**\n * get_description - Fetch newsgroups descriptions\n * @param nntp_data NNTP data\n * @param wildmat   String to match\n * @param msg       Progress message\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error\n */\nstatic int get_description(struct NntpData *nntp_data, char *wildmat, char *msg)\n{\n  char buf[STRING];\n  char *cmd = NULL;\n\n  /* get newsgroup description, if possible */\n  struct NntpServer *nserv = nntp_data->nserv;\n  if (!wildmat)\n    wildmat = nntp_data->group;\n  if (nserv->hasLIST_NEWSGROUPS)\n    cmd = \"LIST NEWSGROUPS\";\n  else if (nserv->hasXGTITLE)\n    cmd = \"XGTITLE\";\n  else\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"%s %s\\r\\n\", cmd, wildmat);\n  int rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), msg, fetch_description, nserv);\n  if (rc > 0)\n  {\n    mutt_error(\"%s: %s\", cmd, buf);\n  }\n  return rc;\n}\n\n/**\n * nntp_parse_xref - Parse cross-reference\n * @param ctx Mailbox\n * @param hdr Email header\n *\n * Update read flag and set article number if empty\n */\nstatic void nntp_parse_xref(struct Context *ctx, struct Header *hdr)\n{\n  struct NntpData *nntp_data = ctx->data;\n\n  char *buf = mutt_str_strdup(hdr->env->xref);\n  char *p = buf;\n  while (p)\n  {\n    anum_t anum;\n\n    /* skip to next word */\n    p += strspn(p, \" \\t\");\n    char *grp = p;\n\n    /* skip to end of word */\n    p = strpbrk(p, \" \\t\");\n    if (p)\n      *p++ = '\\0';\n\n    /* find colon */\n    char *colon = strchr(grp, ':');\n    if (!colon)\n      continue;\n    *colon++ = '\\0';\n    if (sscanf(colon, ANUM, &anum) != 1)\n      continue;\n\n    nntp_article_status(ctx, hdr, grp, anum);\n    if (!NHDR(hdr)->article_num && (mutt_str_strcmp(nntp_data->group, grp) == 0))\n      NHDR(hdr)->article_num = anum;\n  }\n  FREE(&buf);\n}\n\n/**\n * fetch_tempfile - Write line to temporary file\n * @param line Text to write\n * @param data FILE pointer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_tempfile(char *line, void *data)\n{\n  FILE *fp = data;\n\n  if (!line)\n    rewind(fp);\n  else if (fputs(line, fp) == EOF || fputc('\\n', fp) == EOF)\n    return -1;\n  return 0;\n}\n\n/**\n * struct FetchCtx - Keep track when getting data from a server\n */\nstruct FetchCtx\n{\n  struct Context *ctx;\n  anum_t first;\n  anum_t last;\n  int restore;\n  unsigned char *messages;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc;\n#endif\n};\n\n/**\n * fetch_numbers - Parse article number\n * @param line Article number\n * @param data FetchCtx\n * @retval 0 Always\n */\nstatic int fetch_numbers(char *line, void *data)\n{\n  struct FetchCtx *fc = data;\n  anum_t anum;\n\n  if (!line)\n    return 0;\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  if (anum < fc->first || anum > fc->last)\n    return 0;\n  fc->messages[anum - fc->first] = 1;\n  return 0;\n}\n\n/**\n * parse_overview_line - Parse overview line\n * @param line String to parse\n * @param data FetchCtx\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int parse_overview_line(char *line, void *data)\n{\n  struct FetchCtx *fc = data;\n  struct Context *ctx = fc->ctx;\n  struct NntpData *nntp_data = ctx->data;\n  struct Header *hdr = NULL;\n  char *header = NULL, *field = NULL;\n  bool save = true;\n  anum_t anum;\n\n  if (!line)\n    return 0;\n\n  /* parse article number */\n  field = strchr(line, '\\t');\n  if (field)\n    *field++ = '\\0';\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  mutt_debug(2, \"\" ANUM \"\\n\", anum);\n\n  /* out of bounds */\n  if (anum < fc->first || anum > fc->last)\n    return 0;\n\n  /* not in LISTGROUP */\n  if (!fc->messages[anum - fc->first])\n  {\n    /* progress */\n    if (!ctx->quiet)\n      mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n    return 0;\n  }\n\n  /* convert overview line to header */\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n    return -1;\n\n  header = nntp_data->nserv->overview_fmt;\n  while (field)\n  {\n    char *b = field;\n\n    if (*header)\n    {\n      if (strstr(header, \":full\") == NULL && fputs(header, fp) == EOF)\n      {\n        mutt_file_fclose(&fp);\n        return -1;\n      }\n      header = strchr(header, '\\0') + 1;\n    }\n\n    field = strchr(field, '\\t');\n    if (field)\n      *field++ = '\\0';\n    if (fputs(b, fp) == EOF || fputc('\\n', fp) == EOF)\n    {\n      mutt_file_fclose(&fp);\n      return -1;\n    }\n  }\n  rewind(fp);\n\n  /* allocate memory for headers */\n  if (ctx->msgcount >= ctx->hdrmax)\n    mx_alloc_memory(ctx);\n\n  /* parse header */\n  hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n  hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n  hdr->env->newsgroups = mutt_str_strdup(nntp_data->group);\n  hdr->received = hdr->date_sent;\n  mutt_file_fclose(&fp);\n\n#ifdef USE_HCACHE\n  if (fc->hc)\n  {\n    char buf[16];\n\n    /* try to replace with header from cache */\n    snprintf(buf, sizeof(buf), \"%u\", anum);\n    void *hdata = mutt_hcache_fetch(fc->hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      mutt_header_free(&hdr);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc->hc, &hdata);\n      hdr->data = 0;\n      hdr->read = false;\n      hdr->old = false;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !fc->restore)\n      {\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        save = false;\n      }\n    }\n\n    /* not cached yet, store header */\n    else\n    {\n      mutt_debug(2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(fc->hc, buf, strlen(buf), hdr, 0);\n    }\n  }\n#endif\n\n  if (save)\n  {\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = anum;\n    if (fc->restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, anum);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (anum > nntp_data->last_loaded)\n      nntp_data->last_loaded = anum;\n  }\n  else\n    mutt_header_free(&hdr);\n\n  /* progress */\n  if (!ctx->quiet)\n    mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n  return 0;\n}\n\n/**\n * nntp_fetch_headers - Fetch headers\n * @param ctx     Mailbox\n * @param hc      Header cache\n * @param first   Number of first header to fetch\n * @param last    Number of last header to fetch\n * @param restore Restore message listed as deleted\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n  fc.last = last;\n  fc.restore = restore;\n  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n#ifdef USE_HCACHE\n  fc.hc = hc;\n#endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_mbox_open - Implements MxOps::mbox_open()\n */\nstatic int nntp_mbox_open(struct Context *ctx)\n{\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  char buf[HUGE_STRING];\n  char server[LONG_STRING];\n  char *group = NULL;\n  int rc;\n  void *hc = NULL;\n  anum_t first, last, count = 0;\n  struct Url url;\n\n  mutt_str_strfcpy(buf, ctx->path, sizeof(buf));\n  if (url_parse(&url, buf) < 0 || !url.host || !url.path ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS))\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid newsgroup specification!\"), ctx->path);\n    return -1;\n  }\n\n  group = url.path;\n  url.path = strchr(url.path, '\\0');\n  url_tostring(&url, server, sizeof(server), 0);\n  nserv = nntp_select_server(server, true);\n  url_free(&url);\n  if (!nserv)\n    return -1;\n  CurrentNewsSrv = nserv;\n\n  /* find news group data structure */\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n  {\n    nntp_newsrc_close(nserv);\n    mutt_error(_(\"Newsgroup %s not found on the server.\"), group);\n    return -1;\n  }\n\n  mutt_bit_unset(ctx->rights, MUTT_ACL_INSERT);\n  if (!nntp_data->newsrc_ent && !nntp_data->subscribed && !SaveUnsubscribed)\n    ctx->readonly = true;\n\n  /* select newsgroup */\n  mutt_message(_(\"Selecting %s...\"), group);\n  buf[0] = '\\0';\n  if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n  {\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n\n  /* newsgroup not found, remove it */\n  if (mutt_str_strncmp(\"411\", buf, 3) == 0)\n  {\n    mutt_error(_(\"Newsgroup %s has been removed from the server.\"), nntp_data->group);\n    if (!nntp_data->deleted)\n    {\n      nntp_data->deleted = true;\n      nntp_active_save_cache(nserv);\n    }\n    if (nntp_data->newsrc_ent && !nntp_data->subscribed && !SaveUnsubscribed)\n    {\n      FREE(&nntp_data->newsrc_ent);\n      nntp_data->newsrc_len = 0;\n      nntp_delete_group_cache(nntp_data);\n      nntp_newsrc_update(nserv);\n    }\n  }\n\n  /* parse newsgroup info */\n  else\n  {\n    if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    {\n      nntp_newsrc_close(nserv);\n      mutt_error(\"GROUP: %s\", buf);\n      return -1;\n    }\n    nntp_data->first_message = first;\n    nntp_data->last_message = last;\n    nntp_data->deleted = false;\n\n    /* get description if empty */\n    if (NntpLoadDescription && !nntp_data->desc)\n    {\n      if (get_description(nntp_data, NULL, NULL) < 0)\n      {\n        nntp_newsrc_close(nserv);\n        return -1;\n      }\n      if (nntp_data->desc)\n        nntp_active_save_cache(nserv);\n    }\n  }\n\n  time(&nserv->check_time);\n  ctx->data = nntp_data;\n  if (!nntp_data->bcache && (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n    nntp_data->bcache = mutt_bcache_open(&nserv->conn->account, nntp_data->group);\n\n  /* strip off extra articles if adding context is greater than $nntp_context */\n  first = nntp_data->first_message;\n  if (NntpContext && nntp_data->last_message - first + 1 > NntpContext)\n    first = nntp_data->last_message - NntpContext + 1;\n  nntp_data->last_loaded = first ? first - 1 : 0;\n  count = nntp_data->first_message;\n  nntp_data->first_message = first;\n  nntp_bcache_update(nntp_data);\n  nntp_data->first_message = count;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(nntp_data);\n  nntp_hcache_update(nntp_data, hc);\n#endif\n  if (!hc)\n  {\n    mutt_bit_unset(ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_unset(ctx->rights, MUTT_ACL_DELETE);\n  }\n  nntp_newsrc_close(nserv);\n  rc = nntp_fetch_headers(ctx, hc, first, nntp_data->last_message, 0);\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (rc < 0)\n    return -1;\n  nntp_data->last_loaded = nntp_data->last_message;\n  nserv->newsrc_modified = false;\n  return 0;\n}\n\n/**\n * nntp_msg_open - Implements MxOps::msg_open()\n */\nstatic int nntp_msg_open(struct Context *ctx, struct Message *msg, int msgno)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct Header *hdr = ctx->hdrs[msgno];\n  char article[16];\n\n  /* try to get article from cache */\n  struct NntpAcache *acache = &nntp_data->acache[hdr->index % NNTP_ACACHE_LEN];\n  if (acache->path)\n  {\n    if (acache->index == hdr->index)\n    {\n      msg->fp = mutt_file_fopen(acache->path, \"r\");\n      if (msg->fp)\n        return 0;\n    }\n    /* clear previous entry */\n    else\n    {\n      unlink(acache->path);\n      FREE(&acache->path);\n    }\n  }\n  snprintf(article, sizeof(article), \"%d\", NHDR(hdr)->article_num);\n  msg->fp = mutt_bcache_get(nntp_data->bcache, article);\n  if (msg->fp)\n  {\n    if (NHDR(hdr)->parsed)\n      return 0;\n  }\n  else\n  {\n    char buf[PATH_MAX];\n    /* don't try to fetch article from removed newsgroup */\n    if (nntp_data->deleted)\n      return -1;\n\n    /* create new cache file */\n    const char *fetch_msg = _(\"Fetching message...\");\n    mutt_message(fetch_msg);\n    msg->fp = mutt_bcache_put(nntp_data->bcache, article);\n    if (!msg->fp)\n    {\n      mutt_mktemp(buf, sizeof(buf));\n      acache->path = mutt_str_strdup(buf);\n      acache->index = hdr->index;\n      msg->fp = mutt_file_fopen(acache->path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(acache->path);\n        unlink(acache->path);\n        FREE(&acache->path);\n        return -1;\n      }\n    }\n\n    /* fetch message to cache file */\n    snprintf(buf, sizeof(buf), \"ARTICLE %s\\r\\n\",\n             NHDR(hdr)->article_num ? article : hdr->env->message_id);\n    const int rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), fetch_msg,\n                                    fetch_tempfile, msg->fp);\n    if (rc)\n    {\n      mutt_file_fclose(&msg->fp);\n      if (acache->path)\n      {\n        unlink(acache->path);\n        FREE(&acache->path);\n      }\n      if (rc > 0)\n      {\n        if (mutt_str_strncmp(NHDR(hdr)->article_num ? \"423\" : \"430\", buf, 3) == 0)\n        {\n          mutt_error(_(\"Article %d not found on the server.\"),\n                     NHDR(hdr)->article_num ? article : hdr->env->message_id);\n        }\n        else\n          mutt_error(\"ARTICLE: %s\", buf);\n      }\n      return -1;\n    }\n\n    if (!acache->path)\n      mutt_bcache_commit(nntp_data->bcache, article);\n  }\n\n  /* replace envelope with new one\n   * hash elements must be updated because pointers will be changed */\n  if (ctx->id_hash && hdr->env->message_id)\n    mutt_hash_delete(ctx->id_hash, hdr->env->message_id, hdr);\n  if (ctx->subj_hash && hdr->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, hdr->env->real_subj, hdr);\n\n  mutt_env_free(&hdr->env);\n  hdr->env = mutt_rfc822_read_header(msg->fp, hdr, 0, 0);\n\n  if (ctx->id_hash && hdr->env->message_id)\n    mutt_hash_insert(ctx->id_hash, hdr->env->message_id, hdr);\n  if (ctx->subj_hash && hdr->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, hdr->env->real_subj, hdr);\n\n  /* fix content length */\n  fseek(msg->fp, 0, SEEK_END);\n  hdr->content->length = ftell(msg->fp) - hdr->content->offset;\n\n  /* this is called in neomutt before the open which fetches the message,\n   * which is probably wrong, but we just call it again here to handle\n   * the problem instead of fixing it */\n  NHDR(hdr)->parsed = true;\n  mutt_parse_mime_message(ctx, hdr);\n\n  /* these would normally be updated in mx_update_context(), but the\n   * full headers aren't parsed with overview, so the information wasn't\n   * available then */\n  if (WithCrypto)\n    hdr->security = crypt_query(hdr->content);\n\n  rewind(msg->fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_msg_close - Implements MxOps::msg_close()\n *\n * @note May also return EOF Failure, see errno\n */\nstatic int nntp_msg_close(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * nntp_post - Post article\n * @param msg Message to post\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_post(const char *msg)\n{\n  struct NntpData *nntp_data, nntp_tmp;\n  char buf[LONG_STRING];\n\n  if (Context && Context->magic == MUTT_NNTP)\n    nntp_data = Context->data;\n  else\n  {\n    CurrentNewsSrv = nntp_select_server(NewsServer, false);\n    if (!CurrentNewsSrv)\n      return -1;\n\n    nntp_data = &nntp_tmp;\n    nntp_data->nserv = CurrentNewsSrv;\n    nntp_data->group = NULL;\n  }\n\n  FILE *fp = mutt_file_fopen(msg, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg);\n    return -1;\n  }\n\n  mutt_str_strfcpy(buf, \"POST\\r\\n\", sizeof(buf));\n  if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  if (buf[0] != '3')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n\n  buf[0] = '.';\n  buf[1] = '\\0';\n  while (fgets(buf + 1, sizeof(buf) - 2, fp))\n  {\n    size_t len = strlen(buf);\n    if (buf[len - 1] == '\\n')\n    {\n      buf[len - 1] = '\\r';\n      buf[len] = '\\n';\n      len++;\n      buf[len] = '\\0';\n    }\n    if (mutt_socket_send_d(nntp_data->nserv->conn,\n                           buf[1] == '.' ? buf : buf + 1, MUTT_SOCK_LOG_HDR) < 0)\n    {\n      mutt_file_fclose(&fp);\n      return nntp_connect_error(nntp_data->nserv);\n    }\n  }\n  mutt_file_fclose(&fp);\n\n  if ((buf[strlen(buf) - 1] != '\\n' &&\n       mutt_socket_send_d(nntp_data->nserv->conn, \"\\r\\n\", MUTT_SOCK_LOG_HDR) < 0) ||\n      mutt_socket_send_d(nntp_data->nserv->conn, \".\\r\\n\", MUTT_SOCK_LOG_HDR) < 0 ||\n      mutt_socket_readln(buf, sizeof(buf), nntp_data->nserv->conn) < 0)\n  {\n    return nntp_connect_error(nntp_data->nserv);\n  }\n  if (buf[0] != '2')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * nntp_group_poll - Check newsgroup for new articles\n * @param nntp_data   NNTP server data\n * @param update_stat Update the stats?\n * @retval  1 New articles found\n * @retval  0 No change\n * @retval -1 Lost connection\n */\nstatic int nntp_group_poll(struct NntpData *nntp_data, int update_stat)\n{\n  char buf[LONG_STRING] = \"\";\n  anum_t count, first, last;\n\n  /* use GROUP command to poll newsgroup */\n  if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n    return -1;\n  if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    return 0;\n  if (first == nntp_data->first_message && last == nntp_data->last_message)\n    return 0;\n\n  /* articles have been renumbered */\n  if (last < nntp_data->last_message)\n  {\n    nntp_data->last_cached = 0;\n    if (nntp_data->newsrc_len)\n    {\n      mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n      nntp_data->newsrc_len = 1;\n      nntp_data->newsrc_ent[0].first = 1;\n      nntp_data->newsrc_ent[0].last = 0;\n    }\n  }\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  if (!update_stat)\n    return 1;\n\n  /* update counters */\n  else if (!last || (!nntp_data->newsrc_ent && !nntp_data->last_cached))\n    nntp_data->unread = count;\n  else\n    nntp_group_unread_stat(nntp_data);\n  return 1;\n}\n\n/**\n * check_mailbox - Check current newsgroup for new articles\n * @param ctx Mailbox\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n *\n * Leave newsrc locked\n */\nstatic int check_mailbox(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct NntpServer *nserv = nntp_data->nserv;\n  time_t now = time(NULL);\n  int rc, ret = 0;\n  void *hc = NULL;\n\n  if (nserv->check_time + NntpPoll > now)\n    return 0;\n\n  mutt_message(_(\"Checking for new messages...\"));\n  if (nntp_newsrc_parse(nserv) < 0)\n    return -1;\n\n  nserv->check_time = now;\n  rc = nntp_group_poll(nntp_data, 0);\n  if (rc < 0)\n  {\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n  if (rc)\n    nntp_active_save_cache(nserv);\n\n  /* articles have been renumbered, remove all headers */\n  if (nntp_data->last_message < nntp_data->last_loaded)\n  {\n    for (int i = 0; i < ctx->msgcount; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    ctx->msgcount = 0;\n    ctx->tagged = 0;\n\n    if (nntp_data->last_message < nntp_data->last_loaded)\n    {\n      nntp_data->last_loaded = nntp_data->first_message - 1;\n      if (NntpContext && nntp_data->last_message - nntp_data->last_loaded > NntpContext)\n        nntp_data->last_loaded = nntp_data->last_message - NntpContext;\n    }\n    ret = MUTT_REOPENED;\n  }\n\n  /* .newsrc has been externally modified */\n  if (nserv->newsrc_modified)\n  {\n#ifdef USE_HCACHE\n    unsigned char *messages = NULL;\n    char buf[16];\n    void *hdata = NULL;\n    struct Header *hdr = NULL;\n    anum_t first = nntp_data->first_message;\n\n    if (NntpContext && nntp_data->last_message - first + 1 > NntpContext)\n      first = nntp_data->last_message - NntpContext + 1;\n    messages = mutt_mem_calloc(nntp_data->last_loaded - first + 1, sizeof(unsigned char));\n    hc = nntp_hcache_open(nntp_data);\n    nntp_hcache_update(nntp_data, hc);\n#endif\n\n    /* update flags according to .newsrc */\n    int j = 0;\n    anum_t anum;\n    for (int i = 0; i < ctx->msgcount; i++)\n    {\n      bool flagged = false;\n      anum = NHDR(ctx->hdrs[i])->article_num;\n\n#ifdef USE_HCACHE\n      /* check hcache for flagged and deleted flags */\n      if (hc)\n      {\n        if (anum >= first && anum <= nntp_data->last_loaded)\n          messages[anum - first] = 1;\n\n        snprintf(buf, sizeof(buf), \"%u\", anum);\n        hdata = mutt_hcache_fetch(hc, buf, strlen(buf));\n        if (hdata)\n        {\n          bool deleted;\n\n          mutt_debug(2, \"#1 mutt_hcache_fetch %s\\n\", buf);\n          hdr = mutt_hcache_restore(hdata);\n          mutt_hcache_free(hc, &hdata);\n          hdr->data = 0;\n          deleted = hdr->deleted;\n          flagged = hdr->flagged;\n          mutt_header_free(&hdr);\n\n          /* header marked as deleted, removing from context */\n          if (deleted)\n          {\n            mutt_set_flag(ctx, ctx->hdrs[i], MUTT_TAG, 0);\n            mutt_header_free(&ctx->hdrs[i]);\n            continue;\n          }\n        }\n      }\n#endif\n\n      if (!ctx->hdrs[i]->changed)\n      {\n        ctx->hdrs[i]->flagged = flagged;\n        ctx->hdrs[i]->read = false;\n        ctx->hdrs[i]->old = false;\n        nntp_article_status(ctx, ctx->hdrs[i], NULL, anum);\n        if (!ctx->hdrs[i]->read)\n          nntp_parse_xref(ctx, ctx->hdrs[i]);\n      }\n      ctx->hdrs[j++] = ctx->hdrs[i];\n    }\n\n#ifdef USE_HCACHE\n    ctx->msgcount = j;\n\n    /* restore headers without \"deleted\" flag */\n    for (anum = first; anum <= nntp_data->last_loaded; anum++)\n    {\n      if (messages[anum - first])\n        continue;\n\n      snprintf(buf, sizeof(buf), \"%u\", anum);\n      hdata = mutt_hcache_fetch(hc, buf, strlen(buf));\n      if (hdata)\n      {\n        mutt_debug(2, \"#2 mutt_hcache_fetch %s\\n\", buf);\n        if (ctx->msgcount >= ctx->hdrmax)\n          mx_alloc_memory(ctx);\n\n        ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n        mutt_hcache_free(hc, &hdata);\n        hdr->data = 0;\n        if (hdr->deleted)\n        {\n          mutt_header_free(&hdr);\n          if (nntp_data->bcache)\n          {\n            mutt_debug(2, \"mutt_bcache_del %s\\n\", buf);\n            mutt_bcache_del(nntp_data->bcache, buf);\n          }\n          continue;\n        }\n\n        ctx->msgcount++;\n        hdr->read = false;\n        hdr->old = false;\n        hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n        NHDR(hdr)->article_num = anum;\n        nntp_article_status(ctx, hdr, NULL, anum);\n        if (!hdr->read)\n          nntp_parse_xref(ctx, hdr);\n      }\n    }\n    FREE(&messages);\n#endif\n\n    nserv->newsrc_modified = false;\n    ret = MUTT_REOPENED;\n  }\n\n  /* some headers were removed, context must be updated */\n  if (ret == MUTT_REOPENED)\n  {\n    if (ctx->subj_hash)\n      mutt_hash_destroy(&ctx->subj_hash);\n    if (ctx->id_hash)\n      mutt_hash_destroy(&ctx->id_hash);\n    mutt_clear_threads(ctx);\n\n    ctx->vcount = 0;\n    ctx->deleted = 0;\n    ctx->new = 0;\n    ctx->unread = 0;\n    ctx->flagged = 0;\n    ctx->changed = false;\n    ctx->id_hash = NULL;\n    ctx->subj_hash = NULL;\n    mx_update_context(ctx, ctx->msgcount);\n  }\n\n  /* fetch headers of new articles */\n  if (nntp_data->last_message > nntp_data->last_loaded)\n  {\n    int oldmsgcount = ctx->msgcount;\n    bool quiet = ctx->quiet;\n    ctx->quiet = true;\n#ifdef USE_HCACHE\n    if (!hc)\n    {\n      hc = nntp_hcache_open(nntp_data);\n      nntp_hcache_update(nntp_data, hc);\n    }\n#endif\n    rc = nntp_fetch_headers(ctx, hc, nntp_data->last_loaded + 1, nntp_data->last_message, 0);\n    ctx->quiet = quiet;\n    if (rc >= 0)\n      nntp_data->last_loaded = nntp_data->last_message;\n    if (ret == 0 && ctx->msgcount > oldmsgcount)\n      ret = MUTT_NEW_MAIL;\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (ret)\n    nntp_newsrc_close(nserv);\n  mutt_clear_error();\n  return ret;\n}\n\n/**\n * nntp_mbox_check - Implements MxOps::mbox_check()\n * @param ctx        Mailbox\n * @param index_hint Current message (UNUSED)\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n */\nstatic int nntp_mbox_check(struct Context *ctx, int *index_hint)\n{\n  int ret = check_mailbox(ctx);\n  if (ret == 0)\n  {\n    struct NntpData *nntp_data = ctx->data;\n    struct NntpServer *nserv = nntp_data->nserv;\n    nntp_newsrc_close(nserv);\n  }\n  return ret;\n}\n\n/**\n * nntp_mbox_sync - Implements MxOps::mbox_sync()\n *\n * @note May also return values from check_mailbox()\n */\nstatic int nntp_mbox_sync(struct Context *ctx, int *index_hint)\n{\n  struct NntpData *nntp_data = ctx->data;\n  int rc;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  /* check for new articles */\n  nntp_data->nserv->check_time = 0;\n  rc = check_mailbox(ctx);\n  if (rc)\n    return rc;\n\n#ifdef USE_HCACHE\n  nntp_data->last_cached = 0;\n  hc = nntp_hcache_open(nntp_data);\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    struct Header *hdr = ctx->hdrs[i];\n    char buf[16];\n\n    snprintf(buf, sizeof(buf), \"%d\", NHDR(hdr)->article_num);\n    if (nntp_data->bcache && hdr->deleted)\n    {\n      mutt_debug(2, \"mutt_bcache_del %s\\n\", buf);\n      mutt_bcache_del(nntp_data->bcache, buf);\n    }\n\n#ifdef USE_HCACHE\n    if (hc && (hdr->changed || hdr->deleted))\n    {\n      if (hdr->deleted && !hdr->read)\n        nntp_data->unread--;\n      mutt_debug(2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(hc, buf, strlen(buf), hdr, 0);\n    }\n#endif\n  }\n\n#ifdef USE_HCACHE\n  if (hc)\n  {\n    mutt_hcache_close(hc);\n    nntp_data->last_cached = nntp_data->last_loaded;\n  }\n#endif\n\n  /* save .newsrc entries */\n  nntp_newsrc_gen_entries(ctx);\n  nntp_newsrc_update(nntp_data->nserv);\n  nntp_newsrc_close(nntp_data->nserv);\n  return 0;\n}\n\n/**\n * nntp_mbox_close - Implements MxOps::mbox_close()\n * @retval 0 Always\n */\nstatic int nntp_mbox_close(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data, *nntp_tmp = NULL;\n\n  if (!nntp_data)\n    return 0;\n\n  nntp_data->unread = ctx->unread;\n\n  nntp_acache_free(nntp_data);\n  if (!nntp_data->nserv || !nntp_data->nserv->groups_hash || !nntp_data->group)\n    return 0;\n\n  nntp_tmp = mutt_hash_find(nntp_data->nserv->groups_hash, nntp_data->group);\n  if (nntp_tmp == NULL || nntp_tmp != nntp_data)\n    nntp_data_free(nntp_data);\n  return 0;\n}\n\n/**\n * nntp_date - Get date and time from server\n * @param nserv NNTP server\n * @param now   Server time\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_date(struct NntpServer *nserv, time_t *now)\n{\n  if (nserv->hasDATE)\n  {\n    struct NntpData nntp_data;\n    char buf[LONG_STRING];\n    struct tm tm;\n    memset(&tm, 0, sizeof(tm));\n\n    nntp_data.nserv = nserv;\n    nntp_data.group = NULL;\n    mutt_str_strfcpy(buf, \"DATE\\r\\n\", sizeof(buf));\n    if (nntp_query(&nntp_data, buf, sizeof(buf)) < 0)\n      return -1;\n\n    if (sscanf(buf, \"111 %4d%2d%2d%2d%2d%2d%*s\", &tm.tm_year, &tm.tm_mon,\n               &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)\n    {\n      tm.tm_year -= 1900;\n      tm.tm_mon--;\n      *now = timegm(&tm);\n      if (*now >= 0)\n      {\n        mutt_debug(1, \"server time is %lu\\n\", *now);\n        return 0;\n      }\n    }\n  }\n  time(now);\n  return 0;\n}\n\n/**\n * nntp_active_fetch - Fetch list of all newsgroups from server\n * @param nserv NNTP server\n * @param new   Mark the groups as new\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_fetch(struct NntpServer *nserv, bool new)\n{\n  struct NntpData nntp_data;\n  char msg[STRING];\n  char buf[LONG_STRING];\n  unsigned int i;\n  int rc;\n\n  snprintf(msg, sizeof(msg), _(\"Loading list of groups from server %s...\"),\n           nserv->conn->account.host);\n  mutt_message(msg);\n  if (nntp_date(nserv, &nserv->newgroups_time) < 0)\n    return -1;\n\n  nntp_data.nserv = nserv;\n  nntp_data.group = NULL;\n  i = nserv->groups_num;\n  mutt_str_strfcpy(buf, \"LIST\\r\\n\", sizeof(buf));\n  rc = nntp_fetch_lines(&nntp_data, buf, sizeof(buf), msg, nntp_add_group, nserv);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"LIST: %s\", buf);\n    }\n    return -1;\n  }\n\n  if (new)\n  {\n    for (; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n      data->new = true;\n    }\n  }\n\n  for (i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *data = nserv->groups_list[i];\n\n    if (data && data->deleted && !data->newsrc_ent)\n    {\n      nntp_delete_group_cache(data);\n      mutt_hash_delete(nserv->groups_hash, data->group, NULL);\n      nserv->groups_list[i] = NULL;\n    }\n  }\n\n  if (NntpLoadDescription)\n    rc = get_description(&nntp_data, \"*\", _(\"Loading descriptions...\"));\n\n  nntp_active_save_cache(nserv);\n  if (rc < 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_check_new_groups - Check for new groups/articles in subscribed groups\n * @param nserv NNTP server\n * @retval  1 New groups found\n * @retval  0 No new groups\n * @retval -1 Error\n */\nint nntp_check_new_groups(struct NntpServer *nserv)\n{\n  struct NntpData nntp_data;\n  time_t now;\n  struct tm *tm = NULL;\n  char buf[LONG_STRING];\n  char *msg = _(\"Checking for new newsgroups...\");\n  unsigned int i;\n  int rc, update_active = false;\n\n  if (!nserv || !nserv->newgroups_time)\n    return -1;\n\n  /* check subscribed newsgroups for new articles */\n  if (ShowNewNews)\n  {\n    mutt_message(_(\"Checking for new messages...\"));\n    for (i = 0; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n\n      if (data && data->subscribed)\n      {\n        rc = nntp_group_poll(data, 1);\n        if (rc < 0)\n          return -1;\n        if (rc > 0)\n          update_active = true;\n      }\n    }\n    /* select current newsgroup */\n    if (Context && Context->magic == MUTT_NNTP)\n    {\n      buf[0] = '\\0';\n      if (nntp_query((struct NntpData *) Context->data, buf, sizeof(buf)) < 0)\n        return -1;\n    }\n  }\n  else if (nserv->newgroups_time)\n    return 0;\n\n  /* get list of new groups */\n  mutt_message(msg);\n  if (nntp_date(nserv, &now) < 0)\n    return -1;\n  nntp_data.nserv = nserv;\n  if (Context && Context->magic == MUTT_NNTP)\n    nntp_data.group = ((struct NntpData *) Context->data)->group;\n  else\n    nntp_data.group = NULL;\n  i = nserv->groups_num;\n  tm = gmtime(&nserv->newgroups_time);\n  snprintf(buf, sizeof(buf), \"NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\\r\\n\",\n           tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,\n           tm->tm_min, tm->tm_sec);\n  rc = nntp_fetch_lines(&nntp_data, buf, sizeof(buf), msg, nntp_add_group, nserv);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"NEWGROUPS: %s\", buf);\n    }\n    return -1;\n  }\n\n  /* new groups found */\n  rc = 0;\n  if (nserv->groups_num != i)\n  {\n    int groups_num = i;\n\n    nserv->newgroups_time = now;\n    for (; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n      data->new = true;\n    }\n\n    /* loading descriptions */\n    if (NntpLoadDescription)\n    {\n      unsigned int count = 0;\n      struct Progress progress;\n\n      mutt_progress_init(&progress, _(\"Loading descriptions...\"),\n                         MUTT_PROGRESS_MSG, ReadInc, nserv->groups_num - i);\n      for (i = groups_num; i < nserv->groups_num; i++)\n      {\n        struct NntpData *data = nserv->groups_list[i];\n\n        if (get_description(data, NULL, NULL) < 0)\n          return -1;\n        mutt_progress_update(&progress, ++count, -1);\n      }\n    }\n    update_active = true;\n    rc = 1;\n  }\n  if (update_active)\n    nntp_active_save_cache(nserv);\n  mutt_clear_error();\n  return rc;\n}\n\n/**\n * nntp_check_msgid - Fetch article by Message-ID\n * @param ctx   Mailbox\n * @param msgid Message ID\n * @retval  0 Success\n * @retval  1 No such article\n * @retval -1 Error\n */\nint nntp_check_msgid(struct Context *ctx, const char *msgid)\n{\n  struct NntpData *nntp_data = ctx->data;\n  char buf[LONG_STRING];\n\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n  {\n    mutt_perror(\"mutt_file_mkstemp() failed!\");\n    return -1;\n  }\n\n  snprintf(buf, sizeof(buf), \"HEAD %s\\r\\n\", msgid);\n  int rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n  if (rc)\n  {\n    mutt_file_fclose(&fp);\n    if (rc < 0)\n      return -1;\n    if (mutt_str_strncmp(\"430\", buf, 3) == 0)\n      return 1;\n    mutt_error(\"HEAD: %s\", buf);\n    return -1;\n  }\n\n  /* parse header */\n  if (ctx->msgcount == ctx->hdrmax)\n    mx_alloc_memory(ctx);\n  struct Header *hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n  hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n  hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n  mutt_file_fclose(&fp);\n\n  /* get article number */\n  if (hdr->env->xref)\n    nntp_parse_xref(ctx, hdr);\n  else\n  {\n    snprintf(buf, sizeof(buf), \"STAT %s\\r\\n\", msgid);\n    if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n    {\n      mutt_header_free(&hdr);\n      return -1;\n    }\n    sscanf(buf + 4, ANUM, &NHDR(hdr)->article_num);\n  }\n\n  /* reset flags */\n  hdr->read = false;\n  hdr->old = false;\n  hdr->deleted = false;\n  hdr->changed = true;\n  hdr->received = hdr->date_sent;\n  hdr->index = ctx->msgcount++;\n  mx_update_context(ctx, 1);\n  return 0;\n}\n\n/**\n * struct ChildCtx - Keep track of the children of an article\n */\nstruct ChildCtx\n{\n  struct Context *ctx;\n  unsigned int num;\n  unsigned int max;\n  anum_t *child;\n};\n\n/**\n * fetch_children - Parse XPAT line\n * @param line String to parse\n * @param data ChildCtx\n * @retval 0 Always\n */\nstatic int fetch_children(char *line, void *data)\n{\n  struct ChildCtx *cc = data;\n  anum_t anum;\n\n  if (!line || sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  for (unsigned int i = 0; i < cc->ctx->msgcount; i++)\n    if (NHDR(cc->ctx->hdrs[i])->article_num == anum)\n      return 0;\n  if (cc->num >= cc->max)\n  {\n    cc->max *= 2;\n    mutt_mem_realloc(&cc->child, sizeof(anum_t) * cc->max);\n  }\n  cc->child[cc->num++] = anum;\n  return 0;\n}\n\n/**\n * nntp_check_children - Fetch children of article with the Message-ID\n * @param ctx   Mailbox\n * @param msgid Message ID to find\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_check_children(struct Context *ctx, const char *msgid)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct ChildCtx cc;\n  char buf[STRING];\n  int rc;\n  bool quiet;\n  void *hc = NULL;\n\n  if (!nntp_data || !nntp_data->nserv)\n    return -1;\n  if (nntp_data->first_message > nntp_data->last_loaded)\n    return 0;\n\n  /* init context */\n  cc.ctx = ctx;\n  cc.num = 0;\n  cc.max = 10;\n  cc.child = mutt_mem_malloc(sizeof(anum_t) * cc.max);\n\n  /* fetch numbers of child messages */\n  snprintf(buf, sizeof(buf), \"XPAT References %u-%u *%s*\\r\\n\",\n           nntp_data->first_message, nntp_data->last_loaded, msgid);\n  rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_children, &cc);\n  if (rc)\n  {\n    FREE(&cc.child);\n    if (rc > 0)\n    {\n      if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n        mutt_error(\"XPAT: %s\", buf);\n      else\n      {\n        mutt_error(_(\"Unable to find child articles because server does not \"\n                     \"support XPAT command.\"));\n      }\n    }\n    return -1;\n  }\n\n  /* fetch all found messages */\n  quiet = ctx->quiet;\n  ctx->quiet = true;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(nntp_data);\n#endif\n  for (int i = 0; i < cc.num; i++)\n  {\n    rc = nntp_fetch_headers(ctx, hc, cc.child[i], cc.child[i], 1);\n    if (rc < 0)\n      break;\n  }\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  ctx->quiet = quiet;\n  FREE(&cc.child);\n  return (rc < 0) ? -1 : 0;\n}\n\n// clang-format off\n/**\n * struct mx_nntp_ops - Mailbox callback functions for NNTP mailboxes\n */\nstruct MxOps mx_nntp_ops = {\n  .mbox_open        = nntp_mbox_open,\n  .mbox_open_append = NULL,\n  .mbox_check       = nntp_mbox_check,\n  .mbox_sync        = nntp_mbox_sync,\n  .mbox_close       = nntp_mbox_close,\n  .msg_open         = nntp_msg_open,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = nntp_msg_close,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n// clang-format on\n"], "fixing_code": ["/**\n * @file\n * Usenet network mailbox type; talk to an NNTP server\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page nntp Usenet network mailbox type; talk to an NNTP server\n *\n * Usenet network mailbox type; talk to an NNTP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <string.h>\n#include <strings.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"nntp.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"thread.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n#ifdef USE_SASL\n#include <sasl/sasl.h>\n#include <sasl/saslutil.h>\n#endif\n\nstruct NntpServer *CurrentNewsSrv;\n\n/**\n * nntp_connect_error - Signal a failed connection\n * @param nserv NNTP server\n * @retval -1 Always\n */\nstatic int nntp_connect_error(struct NntpServer *nserv)\n{\n  nserv->status = NNTP_NONE;\n  mutt_error(_(\"Server closed connection!\"));\n  return -1;\n}\n\n/**\n * nntp_capabilities - Get capabilities\n * @param nserv NNTP server\n * @retval -1 Error, connection is closed\n * @retval  0 Mode is reader, capabilities set up\n * @retval  1 Need to switch to reader mode\n */\nstatic int nntp_capabilities(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  bool mode_reader = false;\n  char buf[LONG_STRING];\n  char authinfo[LONG_STRING] = \"\";\n\n  nserv->hasCAPABILITIES = false;\n  nserv->hasSTARTTLS = false;\n  nserv->hasDATE = false;\n  nserv->hasLIST_NEWSGROUPS = false;\n  nserv->hasLISTGROUP = false;\n  nserv->hasLISTGROUPrange = false;\n  nserv->hasOVER = false;\n  FREE(&nserv->authenticators);\n\n  if (mutt_socket_send(conn, \"CAPABILITIES\\r\\n\") < 0 ||\n      mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n  {\n    return nntp_connect_error(nserv);\n  }\n\n  /* no capabilities */\n  if (mutt_str_strncmp(\"101\", buf, 3) != 0)\n    return 1;\n  nserv->hasCAPABILITIES = true;\n\n  /* parse capabilities */\n  do\n  {\n    if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n      return nntp_connect_error(nserv);\n    if (mutt_str_strcmp(\"STARTTLS\", buf) == 0)\n      nserv->hasSTARTTLS = true;\n    else if (mutt_str_strcmp(\"MODE-READER\", buf) == 0)\n      mode_reader = true;\n    else if (mutt_str_strcmp(\"READER\", buf) == 0)\n    {\n      nserv->hasDATE = true;\n      nserv->hasLISTGROUP = true;\n      nserv->hasLISTGROUPrange = true;\n    }\n    else if (mutt_str_strncmp(\"AUTHINFO \", buf, 9) == 0)\n    {\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n      mutt_str_strfcpy(authinfo, buf + 8, sizeof(authinfo));\n    }\n#ifdef USE_SASL\n    else if (mutt_str_strncmp(\"SASL \", buf, 5) == 0)\n    {\n      char *p = buf + 5;\n      while (*p == ' ')\n        p++;\n      nserv->authenticators = mutt_str_strdup(p);\n    }\n#endif\n    else if (mutt_str_strcmp(\"OVER\", buf) == 0)\n      nserv->hasOVER = true;\n    else if (mutt_str_strncmp(\"LIST \", buf, 5) == 0)\n    {\n      char *p = strstr(buf, \" NEWSGROUPS\");\n      if (p)\n      {\n        p += 11;\n        if (*p == '\\0' || *p == ' ')\n          nserv->hasLIST_NEWSGROUPS = true;\n      }\n    }\n  } while (mutt_str_strcmp(\".\", buf) != 0);\n  *buf = '\\0';\n#ifdef USE_SASL\n  if (nserv->authenticators && strcasestr(authinfo, \" SASL \"))\n    mutt_str_strfcpy(buf, nserv->authenticators, sizeof(buf));\n#endif\n  if (strcasestr(authinfo, \" USER \"))\n  {\n    if (*buf)\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n    mutt_str_strcat(buf, sizeof(buf), \"USER\");\n  }\n  mutt_str_replace(&nserv->authenticators, buf);\n\n  /* current mode is reader */\n  if (nserv->hasDATE)\n    return 0;\n\n  /* server is mode-switching, need to switch to reader mode */\n  if (mode_reader)\n    return 1;\n\n  mutt_socket_close(conn);\n  nserv->status = NNTP_BYE;\n  mutt_error(_(\"Server doesn't support reader mode.\"));\n  return -1;\n}\n\nchar *OverviewFmt = \"Subject:\\0\"\n                    \"From:\\0\"\n                    \"Date:\\0\"\n                    \"Message-ID:\\0\"\n                    \"References:\\0\"\n                    \"Content-Length:\\0\"\n                    \"Lines:\\0\"\n                    \"\\0\";\n\n/**\n * nntp_attempt_features - Detect supported commands\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_attempt_features(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  char buf[LONG_STRING];\n\n  /* no CAPABILITIES, trying DATE, LISTGROUP, LIST NEWSGROUPS */\n  if (!nserv->hasCAPABILITIES)\n  {\n    if (mutt_socket_send(conn, \"DATE\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasDATE = true;\n\n    if (mutt_socket_send(conn, \"LISTGROUP\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasLISTGROUP = true;\n\n    if (mutt_socket_send(conn, \"LIST NEWSGROUPS +\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasLIST_NEWSGROUPS = true;\n    if (mutt_str_strncmp(\"215\", buf, 3) == 0)\n    {\n      do\n      {\n        if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n          return nntp_connect_error(nserv);\n      } while (mutt_str_strcmp(\".\", buf) != 0);\n    }\n  }\n\n  /* no LIST NEWSGROUPS, trying XGTITLE */\n  if (!nserv->hasLIST_NEWSGROUPS)\n  {\n    if (mutt_socket_send(conn, \"XGTITLE\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasXGTITLE = true;\n  }\n\n  /* no OVER, trying XOVER */\n  if (!nserv->hasOVER)\n  {\n    if (mutt_socket_send(conn, \"XOVER\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n      nserv->hasXOVER = true;\n  }\n\n  /* trying LIST OVERVIEW.FMT */\n  if (nserv->hasOVER || nserv->hasXOVER)\n  {\n    if (mutt_socket_send(conn, \"LIST OVERVIEW.FMT\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"215\", buf, 3) != 0)\n      nserv->overview_fmt = OverviewFmt;\n    else\n    {\n      int cont = 0;\n      size_t buflen = 2 * LONG_STRING, off = 0, b = 0;\n\n      if (nserv->overview_fmt)\n        FREE(&nserv->overview_fmt);\n      nserv->overview_fmt = mutt_mem_malloc(buflen);\n\n      while (true)\n      {\n        if (buflen - off < LONG_STRING)\n        {\n          buflen *= 2;\n          mutt_mem_realloc(&nserv->overview_fmt, buflen);\n        }\n\n        const int chunk =\n            mutt_socket_readln(nserv->overview_fmt + off, buflen - off, conn);\n        if (chunk < 0)\n        {\n          FREE(&nserv->overview_fmt);\n          return nntp_connect_error(nserv);\n        }\n\n        if (!cont && (mutt_str_strcmp(\".\", nserv->overview_fmt + off) == 0))\n          break;\n\n        cont = chunk >= buflen - off ? 1 : 0;\n        off += strlen(nserv->overview_fmt + off);\n        if (!cont)\n        {\n          char *colon = NULL;\n\n          if (nserv->overview_fmt[b] == ':')\n          {\n            memmove(nserv->overview_fmt + b, nserv->overview_fmt + b + 1, off - b - 1);\n            nserv->overview_fmt[off - 1] = ':';\n          }\n          colon = strchr(nserv->overview_fmt + b, ':');\n          if (!colon)\n            nserv->overview_fmt[off++] = ':';\n          else if (strcmp(colon + 1, \"full\") != 0)\n            off = colon + 1 - nserv->overview_fmt;\n          if (strcasecmp(nserv->overview_fmt + b, \"Bytes:\") == 0)\n          {\n            size_t len = strlen(nserv->overview_fmt + b);\n            mutt_str_strfcpy(nserv->overview_fmt + b, \"Content-Length:\", len + 1);\n            off = b + len;\n          }\n          nserv->overview_fmt[off++] = '\\0';\n          b = off;\n        }\n      }\n      nserv->overview_fmt[off++] = '\\0';\n      mutt_mem_realloc(&nserv->overview_fmt, off);\n    }\n  }\n  return 0;\n}\n\n/**\n * nntp_auth - Get login, password and authenticate\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_auth(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  char buf[LONG_STRING];\n  char authenticators[LONG_STRING] = \"USER\";\n  char *method = NULL, *a = NULL, *p = NULL;\n  unsigned char flags = conn->account.flags;\n\n  while (true)\n  {\n    /* get login and password */\n    if ((mutt_account_getuser(&conn->account) < 0) || (conn->account.user[0] == '\\0') ||\n        (mutt_account_getpass(&conn->account) < 0) || (conn->account.pass[0] == '\\0'))\n    {\n      break;\n    }\n\n    /* get list of authenticators */\n    if (NntpAuthenticators && *NntpAuthenticators)\n      mutt_str_strfcpy(authenticators, NntpAuthenticators, sizeof(authenticators));\n    else if (nserv->hasCAPABILITIES)\n    {\n      mutt_str_strfcpy(authenticators, NONULL(nserv->authenticators), sizeof(authenticators));\n      p = authenticators;\n      while (*p)\n      {\n        if (*p == ' ')\n          *p = ':';\n        p++;\n      }\n    }\n    p = authenticators;\n    while (*p)\n    {\n      *p = toupper(*p);\n      p++;\n    }\n\n    mutt_debug(1, \"available methods: %s\\n\", nserv->authenticators);\n    a = authenticators;\n    while (true)\n    {\n      if (!a)\n      {\n        mutt_error(_(\"No authenticators available\"));\n        break;\n      }\n\n      method = a;\n      a = strchr(a, ':');\n      if (a)\n        *a++ = '\\0';\n\n      /* check authenticator */\n      if (nserv->hasCAPABILITIES)\n      {\n        char *m = NULL;\n\n        if (!nserv->authenticators)\n          continue;\n        m = strcasestr(nserv->authenticators, method);\n        if (!m)\n          continue;\n        if (m > nserv->authenticators && *(m - 1) != ' ')\n          continue;\n        m += strlen(method);\n        if (*m != '\\0' && *m != ' ')\n          continue;\n      }\n      mutt_debug(1, \"trying method %s\\n\", method);\n\n      /* AUTHINFO USER authentication */\n      if (strcmp(method, \"USER\") == 0)\n      {\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO USER %s\\r\\n\", conn->account.user);\n        if (mutt_socket_send(conn, buf) < 0 ||\n            mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n        {\n          break;\n        }\n\n        /* authenticated, password is not required */\n        if (mutt_str_strncmp(\"281\", buf, 3) == 0)\n          return 0;\n\n        /* username accepted, sending password */\n        if (mutt_str_strncmp(\"381\", buf, 3) == 0)\n        {\n          if (DebugLevel < MUTT_SOCK_LOG_FULL)\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> AUTHINFO PASS *\\n\", conn->fd);\n          snprintf(buf, sizeof(buf), \"AUTHINFO PASS %s\\r\\n\", conn->account.pass);\n          if (mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0 ||\n              mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n          {\n            break;\n          }\n\n          /* authenticated */\n          if (mutt_str_strncmp(\"281\", buf, 3) == 0)\n            return 0;\n        }\n\n        /* server doesn't support AUTHINFO USER, trying next method */\n        if (*buf == '5')\n          continue;\n      }\n\n      else\n      {\n#ifdef USE_SASL\n        sasl_conn_t *saslconn = NULL;\n        sasl_interact_t *interaction = NULL;\n        int rc;\n        char inbuf[LONG_STRING] = \"\";\n        const char *mech = NULL;\n        const char *client_out = NULL;\n        unsigned int client_len, len;\n\n        if (mutt_sasl_client_new(conn, &saslconn) < 0)\n        {\n          mutt_debug(1, \"error allocating SASL connection.\\n\");\n          continue;\n        }\n\n        while (true)\n        {\n          rc = sasl_client_start(saslconn, method, &interaction, &client_out,\n                                 &client_len, &mech);\n          if (rc != SASL_INTERACT)\n            break;\n          mutt_sasl_interact(interaction);\n        }\n        if (rc != SASL_OK && rc != SASL_CONTINUE)\n        {\n          sasl_dispose(&saslconn);\n          mutt_debug(1, \"error starting SASL authentication exchange.\\n\");\n          continue;\n        }\n\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO SASL %s\", method);\n\n        /* looping protocol */\n        while (rc == SASL_CONTINUE || (rc == SASL_OK && client_len))\n        {\n          /* send out client response */\n          if (client_len)\n          {\n            if (DebugLevel >= MUTT_SOCK_LOG_FULL)\n            {\n              char tmp[LONG_STRING];\n              memcpy(tmp, client_out, client_len);\n              for (p = tmp; p < tmp + client_len; p++)\n              {\n                if (*p == '\\0')\n                  *p = '.';\n              }\n              *p = '\\0';\n              mutt_debug(1, \"SASL> %s\\n\", tmp);\n            }\n\n            if (*buf)\n              mutt_str_strcat(buf, sizeof(buf), \" \");\n            len = strlen(buf);\n            if (sasl_encode64(client_out, client_len, buf + len,\n                              sizeof(buf) - len, &len) != SASL_OK)\n            {\n              mutt_debug(1, \"error base64-encoding client response.\\n\");\n              break;\n            }\n          }\n\n          mutt_str_strcat(buf, sizeof(buf), \"\\r\\n\");\n          if (DebugLevel < MUTT_SOCK_LOG_FULL)\n          {\n            if (strchr(buf, ' '))\n            {\n              mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> AUTHINFO SASL %s%s\\n\",\n                         conn->fd, method, client_len ? \" sasl_data\" : \"\");\n            }\n            else\n              mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> sasl_data\\n\", conn->fd);\n          }\n          client_len = 0;\n          if (mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0 ||\n              mutt_socket_readln_d(inbuf, sizeof(inbuf), conn, MUTT_SOCK_LOG_FULL) < 0)\n          {\n            break;\n          }\n          if ((mutt_str_strncmp(inbuf, \"283 \", 4) != 0) &&\n              (mutt_str_strncmp(inbuf, \"383 \", 4) != 0))\n          {\n            if (DebugLevel < MUTT_SOCK_LOG_FULL)\n              mutt_debug(MUTT_SOCK_LOG_CMD, \"%d< %s\\n\", conn->fd, inbuf);\n            break;\n          }\n          if (DebugLevel < MUTT_SOCK_LOG_FULL)\n          {\n            inbuf[3] = '\\0';\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d< %s sasl_data\\n\", conn->fd, inbuf);\n          }\n\n          if (strcmp(\"=\", inbuf + 4) == 0)\n            len = 0;\n          else if (sasl_decode64(inbuf + 4, strlen(inbuf + 4), buf,\n                                 sizeof(buf) - 1, &len) != SASL_OK)\n          {\n            mutt_debug(1, \"error base64-decoding server response.\\n\");\n            break;\n          }\n          else if (DebugLevel >= MUTT_SOCK_LOG_FULL)\n          {\n            char tmp[LONG_STRING];\n            memcpy(tmp, buf, len);\n            for (p = tmp; p < tmp + len; p++)\n            {\n              if (*p == '\\0')\n                *p = '.';\n            }\n            *p = '\\0';\n            mutt_debug(1, \"SASL< %s\\n\", tmp);\n          }\n\n          while (true)\n          {\n            rc = sasl_client_step(saslconn, buf, len, &interaction, &client_out, &client_len);\n            if (rc != SASL_INTERACT)\n              break;\n            mutt_sasl_interact(interaction);\n          }\n          if (*inbuf != '3')\n            break;\n\n          *buf = '\\0';\n        } /* looping protocol */\n\n        if (rc == SASL_OK && client_len == 0 && *inbuf == '2')\n        {\n          mutt_sasl_setup_conn(conn, saslconn);\n          return 0;\n        }\n\n        /* terminate SASL session */\n        sasl_dispose(&saslconn);\n        if (conn->fd < 0)\n          break;\n        if (mutt_str_strncmp(inbuf, \"383 \", 4) == 0)\n        {\n          if (mutt_socket_send(conn, \"*\\r\\n\") < 0 ||\n              mutt_socket_readln(inbuf, sizeof(inbuf), conn) < 0)\n          {\n            break;\n          }\n        }\n\n        /* server doesn't support AUTHINFO SASL, trying next method */\n        if (*inbuf == '5')\n          continue;\n#else\n        continue;\n#endif /* USE_SASL */\n      }\n\n      mutt_error(_(\"%s authentication failed.\"), method);\n      break;\n    }\n    break;\n  }\n\n  /* error */\n  nserv->status = NNTP_BYE;\n  conn->account.flags = flags;\n  if (conn->fd < 0)\n  {\n    mutt_error(_(\"Server closed connection!\"));\n  }\n  else\n    mutt_socket_close(conn);\n  return -1;\n}\n\n/**\n * nntp_open_connection - Connect to server, authenticate and get capabilities\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_open_connection(struct NntpServer *nserv)\n{\n  struct Connection *conn = nserv->conn;\n  char buf[STRING];\n  int cap;\n  bool posting = false, auth = true;\n\n  if (nserv->status == NNTP_OK)\n    return 0;\n  if (nserv->status == NNTP_BYE)\n    return -1;\n  nserv->status = NNTP_NONE;\n\n  if (mutt_socket_open(conn) < 0)\n    return -1;\n\n  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    return nntp_connect_error(nserv);\n\n  if (mutt_str_strncmp(\"200\", buf, 3) == 0)\n    posting = true;\n  else if (mutt_str_strncmp(\"201\", buf, 3) != 0)\n  {\n    mutt_socket_close(conn);\n    mutt_str_remove_trailing_ws(buf);\n    mutt_error(\"%s\", buf);\n    return -1;\n  }\n\n  /* get initial capabilities */\n  cap = nntp_capabilities(nserv);\n  if (cap < 0)\n    return -1;\n\n  /* tell news server to switch to mode reader if it isn't so */\n  if (cap > 0)\n  {\n    if (mutt_socket_send(conn, \"MODE READER\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n\n    if (mutt_str_strncmp(\"200\", buf, 3) == 0)\n      posting = true;\n    else if (mutt_str_strncmp(\"201\", buf, 3) == 0)\n      posting = false;\n    /* error if has capabilities, ignore result if no capabilities */\n    else if (nserv->hasCAPABILITIES)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode.\"));\n      return -1;\n    }\n\n    /* recheck capabilities after MODE READER */\n    if (nserv->hasCAPABILITIES)\n    {\n      cap = nntp_capabilities(nserv);\n      if (cap < 0)\n        return -1;\n    }\n  }\n\n  mutt_message(_(\"Connected to %s. %s\"), conn->account.host,\n               posting ? _(\"Posting is ok.\") : _(\"Posting is NOT ok.\"));\n  mutt_sleep(1);\n\n#ifdef USE_SSL\n  /* Attempt STARTTLS if available and desired. */\n  if (nserv->use_tls != 1 && (nserv->hasSTARTTLS || SslForceTls))\n  {\n    if (nserv->use_tls == 0)\n    {\n      nserv->use_tls =\n          SslForceTls || query_quadoption(SslStarttls,\n                                          _(\"Secure connection with TLS?\")) == MUTT_YES ?\n              2 :\n              1;\n    }\n    if (nserv->use_tls == 2)\n    {\n      if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0 ||\n          mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n      {\n        return nntp_connect_error(nserv);\n      }\n      if (mutt_str_strncmp(\"382\", buf, 3) != 0)\n      {\n        nserv->use_tls = 0;\n        mutt_error(\"STARTTLS: %s\", buf);\n      }\n      else if (mutt_ssl_starttls(conn))\n      {\n        nserv->use_tls = 0;\n        nserv->status = NNTP_NONE;\n        mutt_socket_close(nserv->conn);\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -1;\n      }\n      else\n      {\n        /* recheck capabilities after STARTTLS */\n        cap = nntp_capabilities(nserv);\n        if (cap < 0)\n          return -1;\n      }\n    }\n  }\n#endif\n\n  /* authentication required? */\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!conn->account.user[0])\n      auth = false;\n  }\n  else\n  {\n    if (mutt_socket_send(conn, \"STAT\\r\\n\") < 0 ||\n        mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    {\n      return nntp_connect_error(nserv);\n    }\n    if (mutt_str_strncmp(\"480\", buf, 3) != 0)\n      auth = false;\n  }\n\n  /* authenticate */\n  if (auth && nntp_auth(nserv) < 0)\n    return -1;\n\n  /* get final capabilities after authentication */\n  if (nserv->hasCAPABILITIES && (auth || cap > 0))\n  {\n    cap = nntp_capabilities(nserv);\n    if (cap < 0)\n      return -1;\n    if (cap > 0)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode.\"));\n      return -1;\n    }\n  }\n\n  /* attempt features */\n  if (nntp_attempt_features(nserv) < 0)\n    return -1;\n\n  nserv->status = NNTP_OK;\n  return 0;\n}\n\n/**\n * nntp_query - Send data from buffer and receive answer to same buffer\n * @param nntp_data NNTP server data\n * @param line      Buffer containing data\n * @param linelen   Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_query(struct NntpData *nntp_data, char *line, size_t linelen)\n{\n  struct NntpServer *nserv = nntp_data->nserv;\n  char buf[LONG_STRING] = { 0 };\n\n  if (nserv->status == NNTP_BYE)\n    return -1;\n\n  while (true)\n  {\n    if (nserv->status == NNTP_OK)\n    {\n      int rc = 0;\n\n      if (*line)\n        rc = mutt_socket_send(nserv->conn, line);\n      else if (nntp_data->group)\n      {\n        snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", nntp_data->group);\n        rc = mutt_socket_send(nserv->conn, buf);\n      }\n      if (rc >= 0)\n        rc = mutt_socket_readln(buf, sizeof(buf), nserv->conn);\n      if (rc >= 0)\n        break;\n    }\n\n    /* reconnect */\n    while (true)\n    {\n      nserv->status = NNTP_NONE;\n      if (nntp_open_connection(nserv) == 0)\n        break;\n\n      snprintf(buf, sizeof(buf), _(\"Connection to %s lost. Reconnect?\"),\n               nserv->conn->account.host);\n      if (mutt_yesorno(buf, MUTT_YES) != MUTT_YES)\n      {\n        nserv->status = NNTP_BYE;\n        return -1;\n      }\n    }\n\n    /* select newsgroup after reconnection */\n    if (nntp_data->group)\n    {\n      snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", nntp_data->group);\n      if (mutt_socket_send(nserv->conn, buf) < 0 ||\n          mutt_socket_readln(buf, sizeof(buf), nserv->conn) < 0)\n      {\n        return nntp_connect_error(nserv);\n      }\n    }\n    if (!*line)\n      break;\n  }\n\n  mutt_str_strfcpy(line, buf, linelen);\n  return 0;\n}\n\n/**\n * nntp_fetch_lines - Read lines, calling a callback function for each\n * @param nntp_data NNTP server data\n * @param query     Query to match\n * @param qlen      Length of query\n * @param msg       Progess message (OPTIONAL)\n * @param funct     Callback function\n * @param data      Data for callback function\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error in funct(*line, *data)\n *\n * This function calls funct(*line, *data) for each received line,\n * funct(NULL, *data) if rewind(*data) needs, exits when fail or done:\n */\nstatic int nntp_fetch_lines(struct NntpData *nntp_data, char *query, size_t qlen,\n                            const char *msg, int (*funct)(char *, void *), void *data)\n{\n  int done = false;\n  int rc;\n\n  while (!done)\n  {\n    char buf[LONG_STRING];\n    char *line = NULL;\n    unsigned int lines = 0;\n    size_t off = 0;\n    struct Progress progress;\n\n    if (msg)\n      mutt_progress_init(&progress, msg, MUTT_PROGRESS_MSG, ReadInc, 0);\n\n    mutt_str_strfcpy(buf, query, sizeof(buf));\n    if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n      return -1;\n    if (buf[0] != '2')\n    {\n      mutt_str_strfcpy(query, buf, qlen);\n      return 1;\n    }\n\n    line = mutt_mem_malloc(sizeof(buf));\n    rc = 0;\n\n    while (true)\n    {\n      char *p = NULL;\n      int chunk = mutt_socket_readln_d(buf, sizeof(buf), nntp_data->nserv->conn,\n                                       MUTT_SOCK_LOG_HDR);\n      if (chunk < 0)\n      {\n        nntp_data->nserv->status = NNTP_NONE;\n        break;\n      }\n\n      p = buf;\n      if (!off && buf[0] == '.')\n      {\n        if (buf[1] == '\\0')\n        {\n          done = true;\n          break;\n        }\n        if (buf[1] == '.')\n          p++;\n      }\n\n      mutt_str_strfcpy(line + off, p, sizeof(buf));\n\n      if (chunk >= sizeof(buf))\n        off += strlen(p);\n      else\n      {\n        if (msg)\n          mutt_progress_update(&progress, ++lines, -1);\n\n        if (rc == 0 && funct(line, data) < 0)\n          rc = -2;\n        off = 0;\n      }\n\n      mutt_mem_realloc(&line, off + sizeof(buf));\n    }\n    FREE(&line);\n    funct(NULL, data);\n  }\n  return rc;\n}\n\n/**\n * fetch_description - Parse newsgroup description\n * @param line String to parse\n * @param data NNTP Server\n * @retval 0 Always\n */\nstatic int fetch_description(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char *desc = NULL;\n\n  if (!line)\n    return 0;\n\n  desc = strpbrk(line, \" \\t\");\n  if (desc)\n  {\n    *desc++ = '\\0';\n    desc += strspn(desc, \" \\t\");\n  }\n  else\n    desc = strchr(line, '\\0');\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, line);\n  if (nntp_data && (mutt_str_strcmp(desc, nntp_data->desc) != 0))\n  {\n    mutt_str_replace(&nntp_data->desc, desc);\n    mutt_debug(2, \"group: %s, desc: %s\\n\", line, desc);\n  }\n  return 0;\n}\n\n/**\n * get_description - Fetch newsgroups descriptions\n * @param nntp_data NNTP data\n * @param wildmat   String to match\n * @param msg       Progress message\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error\n */\nstatic int get_description(struct NntpData *nntp_data, char *wildmat, char *msg)\n{\n  char buf[STRING];\n  char *cmd = NULL;\n\n  /* get newsgroup description, if possible */\n  struct NntpServer *nserv = nntp_data->nserv;\n  if (!wildmat)\n    wildmat = nntp_data->group;\n  if (nserv->hasLIST_NEWSGROUPS)\n    cmd = \"LIST NEWSGROUPS\";\n  else if (nserv->hasXGTITLE)\n    cmd = \"XGTITLE\";\n  else\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"%s %s\\r\\n\", cmd, wildmat);\n  int rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), msg, fetch_description, nserv);\n  if (rc > 0)\n  {\n    mutt_error(\"%s: %s\", cmd, buf);\n  }\n  return rc;\n}\n\n/**\n * nntp_parse_xref - Parse cross-reference\n * @param ctx Mailbox\n * @param hdr Email header\n *\n * Update read flag and set article number if empty\n */\nstatic void nntp_parse_xref(struct Context *ctx, struct Header *hdr)\n{\n  struct NntpData *nntp_data = ctx->data;\n\n  char *buf = mutt_str_strdup(hdr->env->xref);\n  char *p = buf;\n  while (p)\n  {\n    anum_t anum;\n\n    /* skip to next word */\n    p += strspn(p, \" \\t\");\n    char *grp = p;\n\n    /* skip to end of word */\n    p = strpbrk(p, \" \\t\");\n    if (p)\n      *p++ = '\\0';\n\n    /* find colon */\n    char *colon = strchr(grp, ':');\n    if (!colon)\n      continue;\n    *colon++ = '\\0';\n    if (sscanf(colon, ANUM, &anum) != 1)\n      continue;\n\n    nntp_article_status(ctx, hdr, grp, anum);\n    if (!NHDR(hdr)->article_num && (mutt_str_strcmp(nntp_data->group, grp) == 0))\n      NHDR(hdr)->article_num = anum;\n  }\n  FREE(&buf);\n}\n\n/**\n * fetch_tempfile - Write line to temporary file\n * @param line Text to write\n * @param data FILE pointer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_tempfile(char *line, void *data)\n{\n  FILE *fp = data;\n\n  if (!line)\n    rewind(fp);\n  else if (fputs(line, fp) == EOF || fputc('\\n', fp) == EOF)\n    return -1;\n  return 0;\n}\n\n/**\n * struct FetchCtx - Keep track when getting data from a server\n */\nstruct FetchCtx\n{\n  struct Context *ctx;\n  anum_t first;\n  anum_t last;\n  int restore;\n  unsigned char *messages;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc;\n#endif\n};\n\n/**\n * fetch_numbers - Parse article number\n * @param line Article number\n * @param data FetchCtx\n * @retval 0 Always\n */\nstatic int fetch_numbers(char *line, void *data)\n{\n  struct FetchCtx *fc = data;\n  anum_t anum;\n\n  if (!line)\n    return 0;\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  if (anum < fc->first || anum > fc->last)\n    return 0;\n  fc->messages[anum - fc->first] = 1;\n  return 0;\n}\n\n/**\n * parse_overview_line - Parse overview line\n * @param line String to parse\n * @param data FetchCtx\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int parse_overview_line(char *line, void *data)\n{\n  struct FetchCtx *fc = data;\n  struct Context *ctx = fc->ctx;\n  struct NntpData *nntp_data = ctx->data;\n  struct Header *hdr = NULL;\n  char *header = NULL, *field = NULL;\n  bool save = true;\n  anum_t anum;\n\n  if (!line)\n    return 0;\n\n  /* parse article number */\n  field = strchr(line, '\\t');\n  if (field)\n    *field++ = '\\0';\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  mutt_debug(2, \"\" ANUM \"\\n\", anum);\n\n  /* out of bounds */\n  if (anum < fc->first || anum > fc->last)\n    return 0;\n\n  /* not in LISTGROUP */\n  if (!fc->messages[anum - fc->first])\n  {\n    /* progress */\n    if (!ctx->quiet)\n      mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n    return 0;\n  }\n\n  /* convert overview line to header */\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n    return -1;\n\n  header = nntp_data->nserv->overview_fmt;\n  while (field)\n  {\n    char *b = field;\n\n    if (*header)\n    {\n      if (strstr(header, \":full\") == NULL && fputs(header, fp) == EOF)\n      {\n        mutt_file_fclose(&fp);\n        return -1;\n      }\n      header = strchr(header, '\\0') + 1;\n    }\n\n    field = strchr(field, '\\t');\n    if (field)\n      *field++ = '\\0';\n    if (fputs(b, fp) == EOF || fputc('\\n', fp) == EOF)\n    {\n      mutt_file_fclose(&fp);\n      return -1;\n    }\n  }\n  rewind(fp);\n\n  /* allocate memory for headers */\n  if (ctx->msgcount >= ctx->hdrmax)\n    mx_alloc_memory(ctx);\n\n  /* parse header */\n  hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n  hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n  hdr->env->newsgroups = mutt_str_strdup(nntp_data->group);\n  hdr->received = hdr->date_sent;\n  mutt_file_fclose(&fp);\n\n#ifdef USE_HCACHE\n  if (fc->hc)\n  {\n    char buf[16];\n\n    /* try to replace with header from cache */\n    snprintf(buf, sizeof(buf), \"%u\", anum);\n    void *hdata = mutt_hcache_fetch(fc->hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      mutt_header_free(&hdr);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc->hc, &hdata);\n      hdr->data = 0;\n      hdr->read = false;\n      hdr->old = false;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !fc->restore)\n      {\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        save = false;\n      }\n    }\n\n    /* not cached yet, store header */\n    else\n    {\n      mutt_debug(2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(fc->hc, buf, strlen(buf), hdr, 0);\n    }\n  }\n#endif\n\n  if (save)\n  {\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = anum;\n    if (fc->restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, anum);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (anum > nntp_data->last_loaded)\n      nntp_data->last_loaded = anum;\n  }\n  else\n    mutt_header_free(&hdr);\n\n  /* progress */\n  if (!ctx->quiet)\n    mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n  return 0;\n}\n\n/**\n * nntp_fetch_headers - Fetch headers\n * @param ctx     Mailbox\n * @param hc      Header cache\n * @param first   Number of first header to fetch\n * @param last    Number of last header to fetch\n * @param restore Restore message listed as deleted\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n  fc.last = last;\n  fc.restore = restore;\n  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n  if (fc.messages == NULL)\n\t  return -1;\n#ifdef USE_HCACHE\n  fc.hc = hc;\n#endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_mbox_open - Implements MxOps::mbox_open()\n */\nstatic int nntp_mbox_open(struct Context *ctx)\n{\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  char buf[HUGE_STRING];\n  char server[LONG_STRING];\n  char *group = NULL;\n  int rc;\n  void *hc = NULL;\n  anum_t first, last, count = 0;\n  struct Url url;\n\n  mutt_str_strfcpy(buf, ctx->path, sizeof(buf));\n  if (url_parse(&url, buf) < 0 || !url.host || !url.path ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS))\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid newsgroup specification!\"), ctx->path);\n    return -1;\n  }\n\n  group = url.path;\n  url.path = strchr(url.path, '\\0');\n  url_tostring(&url, server, sizeof(server), 0);\n  nserv = nntp_select_server(server, true);\n  url_free(&url);\n  if (!nserv)\n    return -1;\n  CurrentNewsSrv = nserv;\n\n  /* find news group data structure */\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n  {\n    nntp_newsrc_close(nserv);\n    mutt_error(_(\"Newsgroup %s not found on the server.\"), group);\n    return -1;\n  }\n\n  mutt_bit_unset(ctx->rights, MUTT_ACL_INSERT);\n  if (!nntp_data->newsrc_ent && !nntp_data->subscribed && !SaveUnsubscribed)\n    ctx->readonly = true;\n\n  /* select newsgroup */\n  mutt_message(_(\"Selecting %s...\"), group);\n  buf[0] = '\\0';\n  if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n  {\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n\n  /* newsgroup not found, remove it */\n  if (mutt_str_strncmp(\"411\", buf, 3) == 0)\n  {\n    mutt_error(_(\"Newsgroup %s has been removed from the server.\"), nntp_data->group);\n    if (!nntp_data->deleted)\n    {\n      nntp_data->deleted = true;\n      nntp_active_save_cache(nserv);\n    }\n    if (nntp_data->newsrc_ent && !nntp_data->subscribed && !SaveUnsubscribed)\n    {\n      FREE(&nntp_data->newsrc_ent);\n      nntp_data->newsrc_len = 0;\n      nntp_delete_group_cache(nntp_data);\n      nntp_newsrc_update(nserv);\n    }\n  }\n\n  /* parse newsgroup info */\n  else\n  {\n    if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    {\n      nntp_newsrc_close(nserv);\n      mutt_error(\"GROUP: %s\", buf);\n      return -1;\n    }\n    nntp_data->first_message = first;\n    nntp_data->last_message = last;\n    nntp_data->deleted = false;\n\n    /* get description if empty */\n    if (NntpLoadDescription && !nntp_data->desc)\n    {\n      if (get_description(nntp_data, NULL, NULL) < 0)\n      {\n        nntp_newsrc_close(nserv);\n        return -1;\n      }\n      if (nntp_data->desc)\n        nntp_active_save_cache(nserv);\n    }\n  }\n\n  time(&nserv->check_time);\n  ctx->data = nntp_data;\n  if (!nntp_data->bcache && (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n    nntp_data->bcache = mutt_bcache_open(&nserv->conn->account, nntp_data->group);\n\n  /* strip off extra articles if adding context is greater than $nntp_context */\n  first = nntp_data->first_message;\n  if (NntpContext && nntp_data->last_message - first + 1 > NntpContext)\n    first = nntp_data->last_message - NntpContext + 1;\n  nntp_data->last_loaded = first ? first - 1 : 0;\n  count = nntp_data->first_message;\n  nntp_data->first_message = first;\n  nntp_bcache_update(nntp_data);\n  nntp_data->first_message = count;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(nntp_data);\n  nntp_hcache_update(nntp_data, hc);\n#endif\n  if (!hc)\n  {\n    mutt_bit_unset(ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_unset(ctx->rights, MUTT_ACL_DELETE);\n  }\n  nntp_newsrc_close(nserv);\n  rc = nntp_fetch_headers(ctx, hc, first, nntp_data->last_message, 0);\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (rc < 0)\n    return -1;\n  nntp_data->last_loaded = nntp_data->last_message;\n  nserv->newsrc_modified = false;\n  return 0;\n}\n\n/**\n * nntp_msg_open - Implements MxOps::msg_open()\n */\nstatic int nntp_msg_open(struct Context *ctx, struct Message *msg, int msgno)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct Header *hdr = ctx->hdrs[msgno];\n  char article[16];\n\n  /* try to get article from cache */\n  struct NntpAcache *acache = &nntp_data->acache[hdr->index % NNTP_ACACHE_LEN];\n  if (acache->path)\n  {\n    if (acache->index == hdr->index)\n    {\n      msg->fp = mutt_file_fopen(acache->path, \"r\");\n      if (msg->fp)\n        return 0;\n    }\n    /* clear previous entry */\n    else\n    {\n      unlink(acache->path);\n      FREE(&acache->path);\n    }\n  }\n  snprintf(article, sizeof(article), \"%d\", NHDR(hdr)->article_num);\n  msg->fp = mutt_bcache_get(nntp_data->bcache, article);\n  if (msg->fp)\n  {\n    if (NHDR(hdr)->parsed)\n      return 0;\n  }\n  else\n  {\n    char buf[PATH_MAX];\n    /* don't try to fetch article from removed newsgroup */\n    if (nntp_data->deleted)\n      return -1;\n\n    /* create new cache file */\n    const char *fetch_msg = _(\"Fetching message...\");\n    mutt_message(fetch_msg);\n    msg->fp = mutt_bcache_put(nntp_data->bcache, article);\n    if (!msg->fp)\n    {\n      mutt_mktemp(buf, sizeof(buf));\n      acache->path = mutt_str_strdup(buf);\n      acache->index = hdr->index;\n      msg->fp = mutt_file_fopen(acache->path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(acache->path);\n        unlink(acache->path);\n        FREE(&acache->path);\n        return -1;\n      }\n    }\n\n    /* fetch message to cache file */\n    snprintf(buf, sizeof(buf), \"ARTICLE %s\\r\\n\",\n             NHDR(hdr)->article_num ? article : hdr->env->message_id);\n    const int rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), fetch_msg,\n                                    fetch_tempfile, msg->fp);\n    if (rc)\n    {\n      mutt_file_fclose(&msg->fp);\n      if (acache->path)\n      {\n        unlink(acache->path);\n        FREE(&acache->path);\n      }\n      if (rc > 0)\n      {\n        if (mutt_str_strncmp(NHDR(hdr)->article_num ? \"423\" : \"430\", buf, 3) == 0)\n        {\n          mutt_error(_(\"Article %d not found on the server.\"),\n                     NHDR(hdr)->article_num ? article : hdr->env->message_id);\n        }\n        else\n          mutt_error(\"ARTICLE: %s\", buf);\n      }\n      return -1;\n    }\n\n    if (!acache->path)\n      mutt_bcache_commit(nntp_data->bcache, article);\n  }\n\n  /* replace envelope with new one\n   * hash elements must be updated because pointers will be changed */\n  if (ctx->id_hash && hdr->env->message_id)\n    mutt_hash_delete(ctx->id_hash, hdr->env->message_id, hdr);\n  if (ctx->subj_hash && hdr->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, hdr->env->real_subj, hdr);\n\n  mutt_env_free(&hdr->env);\n  hdr->env = mutt_rfc822_read_header(msg->fp, hdr, 0, 0);\n\n  if (ctx->id_hash && hdr->env->message_id)\n    mutt_hash_insert(ctx->id_hash, hdr->env->message_id, hdr);\n  if (ctx->subj_hash && hdr->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, hdr->env->real_subj, hdr);\n\n  /* fix content length */\n  fseek(msg->fp, 0, SEEK_END);\n  hdr->content->length = ftell(msg->fp) - hdr->content->offset;\n\n  /* this is called in neomutt before the open which fetches the message,\n   * which is probably wrong, but we just call it again here to handle\n   * the problem instead of fixing it */\n  NHDR(hdr)->parsed = true;\n  mutt_parse_mime_message(ctx, hdr);\n\n  /* these would normally be updated in mx_update_context(), but the\n   * full headers aren't parsed with overview, so the information wasn't\n   * available then */\n  if (WithCrypto)\n    hdr->security = crypt_query(hdr->content);\n\n  rewind(msg->fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_msg_close - Implements MxOps::msg_close()\n *\n * @note May also return EOF Failure, see errno\n */\nstatic int nntp_msg_close(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * nntp_post - Post article\n * @param msg Message to post\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_post(const char *msg)\n{\n  struct NntpData *nntp_data, nntp_tmp;\n  char buf[LONG_STRING];\n\n  if (Context && Context->magic == MUTT_NNTP)\n    nntp_data = Context->data;\n  else\n  {\n    CurrentNewsSrv = nntp_select_server(NewsServer, false);\n    if (!CurrentNewsSrv)\n      return -1;\n\n    nntp_data = &nntp_tmp;\n    nntp_data->nserv = CurrentNewsSrv;\n    nntp_data->group = NULL;\n  }\n\n  FILE *fp = mutt_file_fopen(msg, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg);\n    return -1;\n  }\n\n  mutt_str_strfcpy(buf, \"POST\\r\\n\", sizeof(buf));\n  if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  if (buf[0] != '3')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n\n  buf[0] = '.';\n  buf[1] = '\\0';\n  while (fgets(buf + 1, sizeof(buf) - 2, fp))\n  {\n    size_t len = strlen(buf);\n    if (buf[len - 1] == '\\n')\n    {\n      buf[len - 1] = '\\r';\n      buf[len] = '\\n';\n      len++;\n      buf[len] = '\\0';\n    }\n    if (mutt_socket_send_d(nntp_data->nserv->conn,\n                           buf[1] == '.' ? buf : buf + 1, MUTT_SOCK_LOG_HDR) < 0)\n    {\n      mutt_file_fclose(&fp);\n      return nntp_connect_error(nntp_data->nserv);\n    }\n  }\n  mutt_file_fclose(&fp);\n\n  if ((buf[strlen(buf) - 1] != '\\n' &&\n       mutt_socket_send_d(nntp_data->nserv->conn, \"\\r\\n\", MUTT_SOCK_LOG_HDR) < 0) ||\n      mutt_socket_send_d(nntp_data->nserv->conn, \".\\r\\n\", MUTT_SOCK_LOG_HDR) < 0 ||\n      mutt_socket_readln(buf, sizeof(buf), nntp_data->nserv->conn) < 0)\n  {\n    return nntp_connect_error(nntp_data->nserv);\n  }\n  if (buf[0] != '2')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * nntp_group_poll - Check newsgroup for new articles\n * @param nntp_data   NNTP server data\n * @param update_stat Update the stats?\n * @retval  1 New articles found\n * @retval  0 No change\n * @retval -1 Lost connection\n */\nstatic int nntp_group_poll(struct NntpData *nntp_data, int update_stat)\n{\n  char buf[LONG_STRING] = \"\";\n  anum_t count, first, last;\n\n  /* use GROUP command to poll newsgroup */\n  if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n    return -1;\n  if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    return 0;\n  if (first == nntp_data->first_message && last == nntp_data->last_message)\n    return 0;\n\n  /* articles have been renumbered */\n  if (last < nntp_data->last_message)\n  {\n    nntp_data->last_cached = 0;\n    if (nntp_data->newsrc_len)\n    {\n      mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n      nntp_data->newsrc_len = 1;\n      nntp_data->newsrc_ent[0].first = 1;\n      nntp_data->newsrc_ent[0].last = 0;\n    }\n  }\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  if (!update_stat)\n    return 1;\n\n  /* update counters */\n  else if (!last || (!nntp_data->newsrc_ent && !nntp_data->last_cached))\n    nntp_data->unread = count;\n  else\n    nntp_group_unread_stat(nntp_data);\n  return 1;\n}\n\n/**\n * check_mailbox - Check current newsgroup for new articles\n * @param ctx Mailbox\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n *\n * Leave newsrc locked\n */\nstatic int check_mailbox(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct NntpServer *nserv = nntp_data->nserv;\n  time_t now = time(NULL);\n  int rc, ret = 0;\n  void *hc = NULL;\n\n  if (nserv->check_time + NntpPoll > now)\n    return 0;\n\n  mutt_message(_(\"Checking for new messages...\"));\n  if (nntp_newsrc_parse(nserv) < 0)\n    return -1;\n\n  nserv->check_time = now;\n  rc = nntp_group_poll(nntp_data, 0);\n  if (rc < 0)\n  {\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n  if (rc)\n    nntp_active_save_cache(nserv);\n\n  /* articles have been renumbered, remove all headers */\n  if (nntp_data->last_message < nntp_data->last_loaded)\n  {\n    for (int i = 0; i < ctx->msgcount; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    ctx->msgcount = 0;\n    ctx->tagged = 0;\n\n    if (nntp_data->last_message < nntp_data->last_loaded)\n    {\n      nntp_data->last_loaded = nntp_data->first_message - 1;\n      if (NntpContext && nntp_data->last_message - nntp_data->last_loaded > NntpContext)\n        nntp_data->last_loaded = nntp_data->last_message - NntpContext;\n    }\n    ret = MUTT_REOPENED;\n  }\n\n  /* .newsrc has been externally modified */\n  if (nserv->newsrc_modified)\n  {\n#ifdef USE_HCACHE\n    unsigned char *messages = NULL;\n    char buf[16];\n    void *hdata = NULL;\n    struct Header *hdr = NULL;\n    anum_t first = nntp_data->first_message;\n\n    if (NntpContext && nntp_data->last_message - first + 1 > NntpContext)\n      first = nntp_data->last_message - NntpContext + 1;\n    messages = mutt_mem_calloc(nntp_data->last_loaded - first + 1, sizeof(unsigned char));\n    hc = nntp_hcache_open(nntp_data);\n    nntp_hcache_update(nntp_data, hc);\n#endif\n\n    /* update flags according to .newsrc */\n    int j = 0;\n    anum_t anum;\n    for (int i = 0; i < ctx->msgcount; i++)\n    {\n      bool flagged = false;\n      anum = NHDR(ctx->hdrs[i])->article_num;\n\n#ifdef USE_HCACHE\n      /* check hcache for flagged and deleted flags */\n      if (hc)\n      {\n        if (anum >= first && anum <= nntp_data->last_loaded)\n          messages[anum - first] = 1;\n\n        snprintf(buf, sizeof(buf), \"%u\", anum);\n        hdata = mutt_hcache_fetch(hc, buf, strlen(buf));\n        if (hdata)\n        {\n          bool deleted;\n\n          mutt_debug(2, \"#1 mutt_hcache_fetch %s\\n\", buf);\n          hdr = mutt_hcache_restore(hdata);\n          mutt_hcache_free(hc, &hdata);\n          hdr->data = 0;\n          deleted = hdr->deleted;\n          flagged = hdr->flagged;\n          mutt_header_free(&hdr);\n\n          /* header marked as deleted, removing from context */\n          if (deleted)\n          {\n            mutt_set_flag(ctx, ctx->hdrs[i], MUTT_TAG, 0);\n            mutt_header_free(&ctx->hdrs[i]);\n            continue;\n          }\n        }\n      }\n#endif\n\n      if (!ctx->hdrs[i]->changed)\n      {\n        ctx->hdrs[i]->flagged = flagged;\n        ctx->hdrs[i]->read = false;\n        ctx->hdrs[i]->old = false;\n        nntp_article_status(ctx, ctx->hdrs[i], NULL, anum);\n        if (!ctx->hdrs[i]->read)\n          nntp_parse_xref(ctx, ctx->hdrs[i]);\n      }\n      ctx->hdrs[j++] = ctx->hdrs[i];\n    }\n\n#ifdef USE_HCACHE\n    ctx->msgcount = j;\n\n    /* restore headers without \"deleted\" flag */\n    for (anum = first; anum <= nntp_data->last_loaded; anum++)\n    {\n      if (messages[anum - first])\n        continue;\n\n      snprintf(buf, sizeof(buf), \"%u\", anum);\n      hdata = mutt_hcache_fetch(hc, buf, strlen(buf));\n      if (hdata)\n      {\n        mutt_debug(2, \"#2 mutt_hcache_fetch %s\\n\", buf);\n        if (ctx->msgcount >= ctx->hdrmax)\n          mx_alloc_memory(ctx);\n\n        ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n        mutt_hcache_free(hc, &hdata);\n        hdr->data = 0;\n        if (hdr->deleted)\n        {\n          mutt_header_free(&hdr);\n          if (nntp_data->bcache)\n          {\n            mutt_debug(2, \"mutt_bcache_del %s\\n\", buf);\n            mutt_bcache_del(nntp_data->bcache, buf);\n          }\n          continue;\n        }\n\n        ctx->msgcount++;\n        hdr->read = false;\n        hdr->old = false;\n        hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n        NHDR(hdr)->article_num = anum;\n        nntp_article_status(ctx, hdr, NULL, anum);\n        if (!hdr->read)\n          nntp_parse_xref(ctx, hdr);\n      }\n    }\n    FREE(&messages);\n#endif\n\n    nserv->newsrc_modified = false;\n    ret = MUTT_REOPENED;\n  }\n\n  /* some headers were removed, context must be updated */\n  if (ret == MUTT_REOPENED)\n  {\n    if (ctx->subj_hash)\n      mutt_hash_destroy(&ctx->subj_hash);\n    if (ctx->id_hash)\n      mutt_hash_destroy(&ctx->id_hash);\n    mutt_clear_threads(ctx);\n\n    ctx->vcount = 0;\n    ctx->deleted = 0;\n    ctx->new = 0;\n    ctx->unread = 0;\n    ctx->flagged = 0;\n    ctx->changed = false;\n    ctx->id_hash = NULL;\n    ctx->subj_hash = NULL;\n    mx_update_context(ctx, ctx->msgcount);\n  }\n\n  /* fetch headers of new articles */\n  if (nntp_data->last_message > nntp_data->last_loaded)\n  {\n    int oldmsgcount = ctx->msgcount;\n    bool quiet = ctx->quiet;\n    ctx->quiet = true;\n#ifdef USE_HCACHE\n    if (!hc)\n    {\n      hc = nntp_hcache_open(nntp_data);\n      nntp_hcache_update(nntp_data, hc);\n    }\n#endif\n    rc = nntp_fetch_headers(ctx, hc, nntp_data->last_loaded + 1, nntp_data->last_message, 0);\n    ctx->quiet = quiet;\n    if (rc >= 0)\n      nntp_data->last_loaded = nntp_data->last_message;\n    if (ret == 0 && ctx->msgcount > oldmsgcount)\n      ret = MUTT_NEW_MAIL;\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (ret)\n    nntp_newsrc_close(nserv);\n  mutt_clear_error();\n  return ret;\n}\n\n/**\n * nntp_mbox_check - Implements MxOps::mbox_check()\n * @param ctx        Mailbox\n * @param index_hint Current message (UNUSED)\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n */\nstatic int nntp_mbox_check(struct Context *ctx, int *index_hint)\n{\n  int ret = check_mailbox(ctx);\n  if (ret == 0)\n  {\n    struct NntpData *nntp_data = ctx->data;\n    struct NntpServer *nserv = nntp_data->nserv;\n    nntp_newsrc_close(nserv);\n  }\n  return ret;\n}\n\n/**\n * nntp_mbox_sync - Implements MxOps::mbox_sync()\n *\n * @note May also return values from check_mailbox()\n */\nstatic int nntp_mbox_sync(struct Context *ctx, int *index_hint)\n{\n  struct NntpData *nntp_data = ctx->data;\n  int rc;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  /* check for new articles */\n  nntp_data->nserv->check_time = 0;\n  rc = check_mailbox(ctx);\n  if (rc)\n    return rc;\n\n#ifdef USE_HCACHE\n  nntp_data->last_cached = 0;\n  hc = nntp_hcache_open(nntp_data);\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    struct Header *hdr = ctx->hdrs[i];\n    char buf[16];\n\n    snprintf(buf, sizeof(buf), \"%d\", NHDR(hdr)->article_num);\n    if (nntp_data->bcache && hdr->deleted)\n    {\n      mutt_debug(2, \"mutt_bcache_del %s\\n\", buf);\n      mutt_bcache_del(nntp_data->bcache, buf);\n    }\n\n#ifdef USE_HCACHE\n    if (hc && (hdr->changed || hdr->deleted))\n    {\n      if (hdr->deleted && !hdr->read)\n        nntp_data->unread--;\n      mutt_debug(2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(hc, buf, strlen(buf), hdr, 0);\n    }\n#endif\n  }\n\n#ifdef USE_HCACHE\n  if (hc)\n  {\n    mutt_hcache_close(hc);\n    nntp_data->last_cached = nntp_data->last_loaded;\n  }\n#endif\n\n  /* save .newsrc entries */\n  nntp_newsrc_gen_entries(ctx);\n  nntp_newsrc_update(nntp_data->nserv);\n  nntp_newsrc_close(nntp_data->nserv);\n  return 0;\n}\n\n/**\n * nntp_mbox_close - Implements MxOps::mbox_close()\n * @retval 0 Always\n */\nstatic int nntp_mbox_close(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data, *nntp_tmp = NULL;\n\n  if (!nntp_data)\n    return 0;\n\n  nntp_data->unread = ctx->unread;\n\n  nntp_acache_free(nntp_data);\n  if (!nntp_data->nserv || !nntp_data->nserv->groups_hash || !nntp_data->group)\n    return 0;\n\n  nntp_tmp = mutt_hash_find(nntp_data->nserv->groups_hash, nntp_data->group);\n  if (nntp_tmp == NULL || nntp_tmp != nntp_data)\n    nntp_data_free(nntp_data);\n  return 0;\n}\n\n/**\n * nntp_date - Get date and time from server\n * @param nserv NNTP server\n * @param now   Server time\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_date(struct NntpServer *nserv, time_t *now)\n{\n  if (nserv->hasDATE)\n  {\n    struct NntpData nntp_data;\n    char buf[LONG_STRING];\n    struct tm tm;\n    memset(&tm, 0, sizeof(tm));\n\n    nntp_data.nserv = nserv;\n    nntp_data.group = NULL;\n    mutt_str_strfcpy(buf, \"DATE\\r\\n\", sizeof(buf));\n    if (nntp_query(&nntp_data, buf, sizeof(buf)) < 0)\n      return -1;\n\n    if (sscanf(buf, \"111 %4d%2d%2d%2d%2d%2d%*s\", &tm.tm_year, &tm.tm_mon,\n               &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)\n    {\n      tm.tm_year -= 1900;\n      tm.tm_mon--;\n      *now = timegm(&tm);\n      if (*now >= 0)\n      {\n        mutt_debug(1, \"server time is %lu\\n\", *now);\n        return 0;\n      }\n    }\n  }\n  time(now);\n  return 0;\n}\n\n/**\n * nntp_active_fetch - Fetch list of all newsgroups from server\n * @param nserv NNTP server\n * @param new   Mark the groups as new\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_fetch(struct NntpServer *nserv, bool new)\n{\n  struct NntpData nntp_data;\n  char msg[STRING];\n  char buf[LONG_STRING];\n  unsigned int i;\n  int rc;\n\n  snprintf(msg, sizeof(msg), _(\"Loading list of groups from server %s...\"),\n           nserv->conn->account.host);\n  mutt_message(msg);\n  if (nntp_date(nserv, &nserv->newgroups_time) < 0)\n    return -1;\n\n  nntp_data.nserv = nserv;\n  nntp_data.group = NULL;\n  i = nserv->groups_num;\n  mutt_str_strfcpy(buf, \"LIST\\r\\n\", sizeof(buf));\n  rc = nntp_fetch_lines(&nntp_data, buf, sizeof(buf), msg, nntp_add_group, nserv);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"LIST: %s\", buf);\n    }\n    return -1;\n  }\n\n  if (new)\n  {\n    for (; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n      data->new = true;\n    }\n  }\n\n  for (i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *data = nserv->groups_list[i];\n\n    if (data && data->deleted && !data->newsrc_ent)\n    {\n      nntp_delete_group_cache(data);\n      mutt_hash_delete(nserv->groups_hash, data->group, NULL);\n      nserv->groups_list[i] = NULL;\n    }\n  }\n\n  if (NntpLoadDescription)\n    rc = get_description(&nntp_data, \"*\", _(\"Loading descriptions...\"));\n\n  nntp_active_save_cache(nserv);\n  if (rc < 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_check_new_groups - Check for new groups/articles in subscribed groups\n * @param nserv NNTP server\n * @retval  1 New groups found\n * @retval  0 No new groups\n * @retval -1 Error\n */\nint nntp_check_new_groups(struct NntpServer *nserv)\n{\n  struct NntpData nntp_data;\n  time_t now;\n  struct tm *tm = NULL;\n  char buf[LONG_STRING];\n  char *msg = _(\"Checking for new newsgroups...\");\n  unsigned int i;\n  int rc, update_active = false;\n\n  if (!nserv || !nserv->newgroups_time)\n    return -1;\n\n  /* check subscribed newsgroups for new articles */\n  if (ShowNewNews)\n  {\n    mutt_message(_(\"Checking for new messages...\"));\n    for (i = 0; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n\n      if (data && data->subscribed)\n      {\n        rc = nntp_group_poll(data, 1);\n        if (rc < 0)\n          return -1;\n        if (rc > 0)\n          update_active = true;\n      }\n    }\n    /* select current newsgroup */\n    if (Context && Context->magic == MUTT_NNTP)\n    {\n      buf[0] = '\\0';\n      if (nntp_query((struct NntpData *) Context->data, buf, sizeof(buf)) < 0)\n        return -1;\n    }\n  }\n  else if (nserv->newgroups_time)\n    return 0;\n\n  /* get list of new groups */\n  mutt_message(msg);\n  if (nntp_date(nserv, &now) < 0)\n    return -1;\n  nntp_data.nserv = nserv;\n  if (Context && Context->magic == MUTT_NNTP)\n    nntp_data.group = ((struct NntpData *) Context->data)->group;\n  else\n    nntp_data.group = NULL;\n  i = nserv->groups_num;\n  tm = gmtime(&nserv->newgroups_time);\n  snprintf(buf, sizeof(buf), \"NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\\r\\n\",\n           tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,\n           tm->tm_min, tm->tm_sec);\n  rc = nntp_fetch_lines(&nntp_data, buf, sizeof(buf), msg, nntp_add_group, nserv);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"NEWGROUPS: %s\", buf);\n    }\n    return -1;\n  }\n\n  /* new groups found */\n  rc = 0;\n  if (nserv->groups_num != i)\n  {\n    int groups_num = i;\n\n    nserv->newgroups_time = now;\n    for (; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n      data->new = true;\n    }\n\n    /* loading descriptions */\n    if (NntpLoadDescription)\n    {\n      unsigned int count = 0;\n      struct Progress progress;\n\n      mutt_progress_init(&progress, _(\"Loading descriptions...\"),\n                         MUTT_PROGRESS_MSG, ReadInc, nserv->groups_num - i);\n      for (i = groups_num; i < nserv->groups_num; i++)\n      {\n        struct NntpData *data = nserv->groups_list[i];\n\n        if (get_description(data, NULL, NULL) < 0)\n          return -1;\n        mutt_progress_update(&progress, ++count, -1);\n      }\n    }\n    update_active = true;\n    rc = 1;\n  }\n  if (update_active)\n    nntp_active_save_cache(nserv);\n  mutt_clear_error();\n  return rc;\n}\n\n/**\n * nntp_check_msgid - Fetch article by Message-ID\n * @param ctx   Mailbox\n * @param msgid Message ID\n * @retval  0 Success\n * @retval  1 No such article\n * @retval -1 Error\n */\nint nntp_check_msgid(struct Context *ctx, const char *msgid)\n{\n  struct NntpData *nntp_data = ctx->data;\n  char buf[LONG_STRING];\n\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n  {\n    mutt_perror(\"mutt_file_mkstemp() failed!\");\n    return -1;\n  }\n\n  snprintf(buf, sizeof(buf), \"HEAD %s\\r\\n\", msgid);\n  int rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n  if (rc)\n  {\n    mutt_file_fclose(&fp);\n    if (rc < 0)\n      return -1;\n    if (mutt_str_strncmp(\"430\", buf, 3) == 0)\n      return 1;\n    mutt_error(\"HEAD: %s\", buf);\n    return -1;\n  }\n\n  /* parse header */\n  if (ctx->msgcount == ctx->hdrmax)\n    mx_alloc_memory(ctx);\n  struct Header *hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n  hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n  hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n  mutt_file_fclose(&fp);\n\n  /* get article number */\n  if (hdr->env->xref)\n    nntp_parse_xref(ctx, hdr);\n  else\n  {\n    snprintf(buf, sizeof(buf), \"STAT %s\\r\\n\", msgid);\n    if (nntp_query(nntp_data, buf, sizeof(buf)) < 0)\n    {\n      mutt_header_free(&hdr);\n      return -1;\n    }\n    sscanf(buf + 4, ANUM, &NHDR(hdr)->article_num);\n  }\n\n  /* reset flags */\n  hdr->read = false;\n  hdr->old = false;\n  hdr->deleted = false;\n  hdr->changed = true;\n  hdr->received = hdr->date_sent;\n  hdr->index = ctx->msgcount++;\n  mx_update_context(ctx, 1);\n  return 0;\n}\n\n/**\n * struct ChildCtx - Keep track of the children of an article\n */\nstruct ChildCtx\n{\n  struct Context *ctx;\n  unsigned int num;\n  unsigned int max;\n  anum_t *child;\n};\n\n/**\n * fetch_children - Parse XPAT line\n * @param line String to parse\n * @param data ChildCtx\n * @retval 0 Always\n */\nstatic int fetch_children(char *line, void *data)\n{\n  struct ChildCtx *cc = data;\n  anum_t anum;\n\n  if (!line || sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  for (unsigned int i = 0; i < cc->ctx->msgcount; i++)\n    if (NHDR(cc->ctx->hdrs[i])->article_num == anum)\n      return 0;\n  if (cc->num >= cc->max)\n  {\n    cc->max *= 2;\n    mutt_mem_realloc(&cc->child, sizeof(anum_t) * cc->max);\n  }\n  cc->child[cc->num++] = anum;\n  return 0;\n}\n\n/**\n * nntp_check_children - Fetch children of article with the Message-ID\n * @param ctx   Mailbox\n * @param msgid Message ID to find\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_check_children(struct Context *ctx, const char *msgid)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct ChildCtx cc;\n  char buf[STRING];\n  int rc;\n  bool quiet;\n  void *hc = NULL;\n\n  if (!nntp_data || !nntp_data->nserv)\n    return -1;\n  if (nntp_data->first_message > nntp_data->last_loaded)\n    return 0;\n\n  /* init context */\n  cc.ctx = ctx;\n  cc.num = 0;\n  cc.max = 10;\n  cc.child = mutt_mem_malloc(sizeof(anum_t) * cc.max);\n\n  /* fetch numbers of child messages */\n  snprintf(buf, sizeof(buf), \"XPAT References %u-%u *%s*\\r\\n\",\n           nntp_data->first_message, nntp_data->last_loaded, msgid);\n  rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_children, &cc);\n  if (rc)\n  {\n    FREE(&cc.child);\n    if (rc > 0)\n    {\n      if (mutt_str_strncmp(\"500\", buf, 3) != 0)\n        mutt_error(\"XPAT: %s\", buf);\n      else\n      {\n        mutt_error(_(\"Unable to find child articles because server does not \"\n                     \"support XPAT command.\"));\n      }\n    }\n    return -1;\n  }\n\n  /* fetch all found messages */\n  quiet = ctx->quiet;\n  ctx->quiet = true;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(nntp_data);\n#endif\n  for (int i = 0; i < cc.num; i++)\n  {\n    rc = nntp_fetch_headers(ctx, hc, cc.child[i], cc.child[i], 1);\n    if (rc < 0)\n      break;\n  }\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  ctx->quiet = quiet;\n  FREE(&cc.child);\n  return (rc < 0) ? -1 : 0;\n}\n\n// clang-format off\n/**\n * struct mx_nntp_ops - Mailbox callback functions for NNTP mailboxes\n */\nstruct MxOps mx_nntp_ops = {\n  .mbox_open        = nntp_mbox_open,\n  .mbox_open_append = NULL,\n  .mbox_check       = nntp_mbox_check,\n  .mbox_sync        = nntp_mbox_sync,\n  .mbox_close       = nntp_mbox_close,\n  .msg_open         = nntp_msg_open,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = nntp_msg_close,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n// clang-format on\n"], "filenames": ["nntp.c"], "buggy_code_start_loc": [1290], "buggy_code_end_loc": [1290], "fixing_code_start_loc": [1291], "fixing_code_end_loc": [1293], "type": "CWE-20", "message": "An issue was discovered in NeoMutt before 2018-07-16. nntp.c proceeds even if memory allocation fails for messages data.", "other": {"cve": {"id": "CVE-2018-14361", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.933", "lastModified": "2020-05-19T17:18:39.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in NeoMutt before 2018-07-16. nntp.c proceeds even if memory allocation fails for messages data."}, {"lang": "es", "value": "Se ha descubierto un problema en NeoMutt en versiones anteriores al 2018-07-16. nntp.c contin\u00faa incluso aunque la asignaci\u00f3n de memoria fracase para los datos de mensajes."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}], "references": [{"url": "https://github.com/neomutt/neomutt/commit/9e927affe3a021175f354af5fa01d22657c20585", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/9e927affe3a021175f354af5fa01d22657c20585"}}