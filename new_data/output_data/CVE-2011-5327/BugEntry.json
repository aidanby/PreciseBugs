{"buggy_code": ["/*******************************************************************************\n *\n * This file contains the Linux/SCSI LLD virtual SCSI initiator driver\n * for emulated SAS initiator ports\n *\n * \u00a9 Copyright 2011 RisingTide Systems LLC.\n *\n * Licensed to the Linux Foundation under the General Public License (GPL) version 2.\n *\n * Author: Nicholas A. Bellinger <nab@risingtidesystems.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n ****************************************************************************/\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/configfs.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_transport.h>\n#include <target/target_core_fabric_ops.h>\n#include <target/target_core_fabric_configfs.h>\n#include <target/target_core_fabric_lib.h>\n#include <target/target_core_configfs.h>\n#include <target/target_core_device.h>\n#include <target/target_core_tpg.h>\n#include <target/target_core_tmr.h>\n\n#include \"tcm_loop.h\"\n\n#define to_tcm_loop_hba(hba)\tcontainer_of(hba, struct tcm_loop_hba, dev)\n\n/* Local pointer to allocated TCM configfs fabric module */\nstatic struct target_fabric_configfs *tcm_loop_fabric_configfs;\n\nstatic struct kmem_cache *tcm_loop_cmd_cache;\n\nstatic int tcm_loop_hba_no_cnt;\n\n/*\n * Allocate a tcm_loop cmd descriptor from target_core_mod code\n *\n * Can be called from interrupt context in tcm_loop_queuecommand() below\n */\nstatic struct se_cmd *tcm_loop_allocate_core_cmd(\n\tstruct tcm_loop_hba *tl_hba,\n\tstruct se_portal_group *se_tpg,\n\tstruct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd;\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus = tl_hba->tl_nexus;\n\tstruct tcm_loop_cmd *tl_cmd;\n\tint sam_task_attr;\n\n\tif (!tl_nexus) {\n\t\tscmd_printk(KERN_ERR, sc, \"TCM_Loop I_T Nexus\"\n\t\t\t\t\" does not exist\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\treturn NULL;\n\t}\n\tse_sess = tl_nexus->se_sess;\n\n\ttl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_ATOMIC);\n\tif (!tl_cmd) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_cmd\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\treturn NULL;\n\t}\n\tse_cmd = &tl_cmd->tl_se_cmd;\n\t/*\n\t * Save the pointer to struct scsi_cmnd *sc\n\t */\n\ttl_cmd->sc = sc;\n\t/*\n\t * Locate the SAM Task Attr from struct scsi_cmnd *\n\t */\n\tif (sc->device->tagged_supported) {\n\t\tswitch (sc->tag) {\n\t\tcase HEAD_OF_QUEUE_TAG:\n\t\t\tsam_task_attr = MSG_HEAD_TAG;\n\t\t\tbreak;\n\t\tcase ORDERED_QUEUE_TAG:\n\t\t\tsam_task_attr = MSG_ORDERED_TAG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsam_task_attr = MSG_SIMPLE_TAG;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tsam_task_attr = MSG_SIMPLE_TAG;\n\n\t/*\n\t * Initialize struct se_cmd descriptor from target_core_mod infrastructure\n\t */\n\ttransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\n\t\t\tscsi_bufflen(sc), sc->sc_data_direction, sam_task_attr,\n\t\t\t&tl_cmd->tl_sense_buf[0]);\n\n\t/*\n\t * Signal BIDI usage with T_TASK(cmd)->t_tasks_bidi\n\t */\n\tif (scsi_bidi_cmnd(sc))\n\t\tse_cmd->t_tasks_bidi = 1;\n\t/*\n\t * Locate the struct se_lun pointer and attach it to struct se_cmd\n\t */\n\tif (transport_lookup_cmd_lun(se_cmd, tl_cmd->sc->device->lun) < 0) {\n\t\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\t\tset_host_byte(sc, DID_NO_CONNECT);\n\t\treturn NULL;\n\t}\n\n\treturn se_cmd;\n}\n\n/*\n * Called by struct target_core_fabric_ops->new_cmd_map()\n *\n * Always called in process context.  A non zero return value\n * here will signal to handle an exception based on the return code.\n */\nstatic int tcm_loop_new_cmd_map(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\tstruct scatterlist *sgl_bidi = NULL;\n\tu32 sgl_bidi_count = 0;\n\tint ret;\n\t/*\n\t * Allocate the necessary tasks to complete the received CDB+data\n\t */\n\tret = transport_generic_allocate_tasks(se_cmd, sc->cmnd);\n\tif (ret == -ENOMEM) {\n\t\t/* Out of Resources */\n\t\treturn PYX_TRANSPORT_LU_COMM_FAILURE;\n\t} else if (ret == -EINVAL) {\n\t\t/*\n\t\t * Handle case for SAM_STAT_RESERVATION_CONFLICT\n\t\t */\n\t\tif (se_cmd->se_cmd_flags & SCF_SCSI_RESERVATION_CONFLICT)\n\t\t\treturn PYX_TRANSPORT_RESERVATION_CONFLICT;\n\t\t/*\n\t\t * Otherwise, return SAM_STAT_CHECK_CONDITION and return\n\t\t * sense data.\n\t\t */\n\t\treturn PYX_TRANSPORT_USE_SENSE_REASON;\n\t}\n\n\t/*\n\t * For BIDI commands, pass in the extra READ buffer\n\t * to transport_generic_map_mem_to_cmd() below..\n\t */\n\tif (se_cmd->t_tasks_bidi) {\n\t\tstruct scsi_data_buffer *sdb = scsi_in(sc);\n\n\t\tsgl_bidi = sdb->table.sgl;\n\t\tsgl_bidi_count = sdb->table.nents;\n\t}\n\n\t/*\n\t * Map the SG memory into struct se_mem->page linked list using the same\n\t * physical memory at sg->page_link.\n\t */\n\tret = transport_generic_map_mem_to_cmd(se_cmd, scsi_sglist(sc),\n\t\t\tscsi_sg_count(sc), sgl_bidi, sgl_bidi_count);\n\tif (ret < 0)\n\t\treturn PYX_TRANSPORT_LU_COMM_FAILURE;\n\n\treturn 0;\n}\n\n/*\n * Called from struct target_core_fabric_ops->check_stop_free()\n */\nstatic void tcm_loop_check_stop_free(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Do not release struct se_cmd's containing a valid TMR\n\t * pointer.  These will be released directly in tcm_loop_device_reset()\n\t * with transport_generic_free_cmd().\n\t */\n\tif (se_cmd->se_tmr_req)\n\t\treturn;\n\t/*\n\t * Release the struct se_cmd, which will make a callback to release\n\t * struct tcm_loop_cmd * in tcm_loop_deallocate_core_cmd()\n\t */\n\ttransport_generic_free_cmd(se_cmd, 0, 0);\n}\n\nstatic void tcm_loop_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\n\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n}\n\nstatic int tcm_loop_proc_info(struct Scsi_Host *host, char *buffer,\n\t\t\t\tchar **start, off_t offset,\n\t\t\t\tint length, int inout)\n{\n\treturn sprintf(buffer, \"tcm_loop_proc_info()\\n\");\n}\n\nstatic int tcm_loop_driver_probe(struct device *);\nstatic int tcm_loop_driver_remove(struct device *);\n\nstatic int pseudo_lld_bus_match(struct device *dev,\n\t\t\t\tstruct device_driver *dev_driver)\n{\n\treturn 1;\n}\n\nstatic struct bus_type tcm_loop_lld_bus = {\n\t.name\t\t\t= \"tcm_loop_bus\",\n\t.match\t\t\t= pseudo_lld_bus_match,\n\t.probe\t\t\t= tcm_loop_driver_probe,\n\t.remove\t\t\t= tcm_loop_driver_remove,\n};\n\nstatic struct device_driver tcm_loop_driverfs = {\n\t.name\t\t\t= \"tcm_loop\",\n\t.bus\t\t\t= &tcm_loop_lld_bus,\n};\n/*\n * Used with root_device_register() in tcm_loop_alloc_core_bus() below\n */\nstruct device *tcm_loop_primary;\n\n/*\n * Copied from drivers/scsi/libfc/fc_fcp.c:fc_change_queue_depth() and\n * drivers/scsi/libiscsi.c:iscsi_change_queue_depth()\n */\nstatic int tcm_loop_change_queue_depth(\n\tstruct scsi_device *sdev,\n\tint depth,\n\tint reason)\n{\n\tswitch (reason) {\n\tcase SCSI_QDEPTH_DEFAULT:\n\t\tscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\n\t\tbreak;\n\tcase SCSI_QDEPTH_QFULL:\n\t\tscsi_track_queue_full(sdev, depth);\n\t\tbreak;\n\tcase SCSI_QDEPTH_RAMP_UP:\n\t\tscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn sdev->queue_depth;\n}\n\n/*\n * Main entry point from struct scsi_host_template for incoming SCSI CDB+Data\n * from Linux/SCSI subsystem for SCSI low level device drivers (LLDs)\n */\nstatic int tcm_loop_queuecommand(\n\tstruct Scsi_Host *sh,\n\tstruct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd;\n\tstruct se_portal_group *se_tpg;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\n\tTL_CDB_DEBUG(\"tcm_loop_queuecommand() %d:%d:%d:%d got CDB: 0x%02x\"\n\t\t\" scsi_buf_len: %u\\n\", sc->device->host->host_no,\n\t\tsc->device->id, sc->device->channel, sc->device->lun,\n\t\tsc->cmnd[0], scsi_bufflen(sc));\n\t/*\n\t * Locate the tcm_loop_hba_t pointer\n\t */\n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\tse_tpg = &tl_tpg->tl_se_tpg;\n\t/*\n\t * Determine the SAM Task Attribute and allocate tl_cmd and\n\t * tl_cmd->tl_se_cmd from TCM infrastructure\n\t */\n\tse_cmd = tcm_loop_allocate_core_cmd(tl_hba, se_tpg, sc);\n\tif (!se_cmd) {\n\t\tsc->scsi_done(sc);\n\t\treturn 0;\n\t}\n\t/*\n\t * Queue up the newly allocated to be processed in TCM thread context.\n\t*/\n\ttransport_generic_handle_cdb_map(se_cmd);\n\treturn 0;\n}\n\n/*\n * Called from SCSI EH process context to issue a LUN_RESET TMR\n * to struct scsi_device\n */\nstatic int tcm_loop_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd = NULL;\n\tstruct se_portal_group *se_tpg;\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_cmd *tl_cmd = NULL;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tstruct tcm_loop_tmr *tl_tmr = NULL;\n\tstruct tcm_loop_tpg *tl_tpg;\n\tint ret = FAILED;\n\t/*\n\t * Locate the tcm_loop_hba_t pointer\n\t */\n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\t/*\n\t * Locate the tl_nexus and se_sess pointers\n\t */\n\ttl_nexus = tl_hba->tl_nexus;\n\tif (!tl_nexus) {\n\t\tprintk(KERN_ERR \"Unable to perform device reset without\"\n\t\t\t\t\" active I_T Nexus\\n\");\n\t\treturn FAILED;\n\t}\n\tse_sess = tl_nexus->se_sess;\n\t/*\n\t * Locate the tl_tpg and se_tpg pointers from TargetID in sc->device->id\n\t */\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\tse_tpg = &tl_tpg->tl_se_tpg;\n\n\ttl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);\n\tif (!tl_cmd) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory for tl_cmd\\n\");\n\t\treturn FAILED;\n\t}\n\n\ttl_tmr = kzalloc(sizeof(struct tcm_loop_tmr), GFP_KERNEL);\n\tif (!tl_tmr) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory for tl_tmr\\n\");\n\t\tgoto release;\n\t}\n\tinit_waitqueue_head(&tl_tmr->tl_tmr_wait);\n\n\tse_cmd = &tl_cmd->tl_se_cmd;\n\t/*\n\t * Initialize struct se_cmd descriptor from target_core_mod infrastructure\n\t */\n\ttransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess, 0,\n\t\t\t\tDMA_NONE, MSG_SIMPLE_TAG,\n\t\t\t\t&tl_cmd->tl_sense_buf[0]);\n\t/*\n\t * Allocate the LUN_RESET TMR\n\t */\n\tse_cmd->se_tmr_req = core_tmr_alloc_req(se_cmd, tl_tmr,\n\t\t\t\tTMR_LUN_RESET);\n\tif (IS_ERR(se_cmd->se_tmr_req))\n\t\tgoto release;\n\t/*\n\t * Locate the underlying TCM struct se_lun from sc->device->lun\n\t */\n\tif (transport_lookup_tmr_lun(se_cmd, sc->device->lun) < 0)\n\t\tgoto release;\n\t/*\n\t * Queue the TMR to TCM Core and sleep waiting for tcm_loop_queue_tm_rsp()\n\t * to wake us up.\n\t */\n\ttransport_generic_handle_tmr(se_cmd);\n\twait_event(tl_tmr->tl_tmr_wait, atomic_read(&tl_tmr->tmr_complete));\n\t/*\n\t * The TMR LUN_RESET has completed, check the response status and\n\t * then release allocations.\n\t */\n\tret = (se_cmd->se_tmr_req->response == TMR_FUNCTION_COMPLETE) ?\n\t\tSUCCESS : FAILED;\nrelease:\n\tif (se_cmd)\n\t\ttransport_generic_free_cmd(se_cmd, 1, 0);\n\telse\n\t\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\tkfree(tl_tmr);\n\treturn ret;\n}\n\nstatic int tcm_loop_slave_alloc(struct scsi_device *sd)\n{\n\tset_bit(QUEUE_FLAG_BIDI, &sd->request_queue->queue_flags);\n\treturn 0;\n}\n\nstatic int tcm_loop_slave_configure(struct scsi_device *sd)\n{\n\treturn 0;\n}\n\nstatic struct scsi_host_template tcm_loop_driver_template = {\n\t.proc_info\t\t= tcm_loop_proc_info,\n\t.proc_name\t\t= \"tcm_loopback\",\n\t.name\t\t\t= \"TCM_Loopback\",\n\t.queuecommand\t\t= tcm_loop_queuecommand,\n\t.change_queue_depth\t= tcm_loop_change_queue_depth,\n\t.eh_device_reset_handler = tcm_loop_device_reset,\n\t.can_queue\t\t= TL_SCSI_CAN_QUEUE,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= TL_SCSI_SG_TABLESIZE,\n\t.cmd_per_lun\t\t= TL_SCSI_CMD_PER_LUN,\n\t.max_sectors\t\t= TL_SCSI_MAX_SECTORS,\n\t.use_clustering\t\t= DISABLE_CLUSTERING,\n\t.slave_alloc\t\t= tcm_loop_slave_alloc,\n\t.slave_configure\t= tcm_loop_slave_configure,\n\t.module\t\t\t= THIS_MODULE,\n};\n\nstatic int tcm_loop_driver_probe(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\tint error;\n\n\ttl_hba = to_tcm_loop_hba(dev);\n\n\tsh = scsi_host_alloc(&tcm_loop_driver_template,\n\t\t\tsizeof(struct tcm_loop_hba));\n\tif (!sh) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct scsi_host\\n\");\n\t\treturn -ENODEV;\n\t}\n\ttl_hba->sh = sh;\n\n\t/*\n\t * Assign the struct tcm_loop_hba pointer to struct Scsi_Host->hostdata\n\t */\n\t*((struct tcm_loop_hba **)sh->hostdata) = tl_hba;\n\t/*\n\t * Setup single ID, Channel and LUN for now..\n\t */\n\tsh->max_id = 2;\n\tsh->max_lun = 0;\n\tsh->max_channel = 0;\n\tsh->max_cmd_len = TL_SCSI_MAX_CMD_LEN;\n\n\terror = scsi_add_host(sh, &tl_hba->dev);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s: scsi_add_host failed\\n\", __func__);\n\t\tscsi_host_put(sh);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int tcm_loop_driver_remove(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\n\ttl_hba = to_tcm_loop_hba(dev);\n\tsh = tl_hba->sh;\n\n\tscsi_remove_host(sh);\n\tscsi_host_put(sh);\n\treturn 0;\n}\n\nstatic void tcm_loop_release_adapter(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba = to_tcm_loop_hba(dev);\n\n\tkfree(tl_hba);\n}\n\n/*\n * Called from tcm_loop_make_scsi_hba() in tcm_loop_configfs.c\n */\nstatic int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\n{\n\tint ret;\n\n\ttl_hba->dev.bus = &tcm_loop_lld_bus;\n\ttl_hba->dev.parent = tcm_loop_primary;\n\ttl_hba->dev.release = &tcm_loop_release_adapter;\n\tdev_set_name(&tl_hba->dev, \"tcm_loop_adapter_%d\", tcm_loop_host_id);\n\n\tret = device_register(&tl_hba->dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"device_register() failed for\"\n\t\t\t\t\" tl_hba->dev: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Called from tcm_loop_fabric_init() in tcl_loop_fabric.c to load the emulated\n * tcm_loop SCSI bus.\n */\nstatic int tcm_loop_alloc_core_bus(void)\n{\n\tint ret;\n\n\ttcm_loop_primary = root_device_register(\"tcm_loop_0\");\n\tif (IS_ERR(tcm_loop_primary)) {\n\t\tprintk(KERN_ERR \"Unable to allocate tcm_loop_primary\\n\");\n\t\treturn PTR_ERR(tcm_loop_primary);\n\t}\n\n\tret = bus_register(&tcm_loop_lld_bus);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"bus_register() failed for tcm_loop_lld_bus\\n\");\n\t\tgoto dev_unreg;\n\t}\n\n\tret = driver_register(&tcm_loop_driverfs);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"driver_register() failed for\"\n\t\t\t\t\"tcm_loop_driverfs\\n\");\n\t\tgoto bus_unreg;\n\t}\n\n\tprintk(KERN_INFO \"Initialized TCM Loop Core Bus\\n\");\n\treturn ret;\n\nbus_unreg:\n\tbus_unregister(&tcm_loop_lld_bus);\ndev_unreg:\n\troot_device_unregister(tcm_loop_primary);\n\treturn ret;\n}\n\nstatic void tcm_loop_release_core_bus(void)\n{\n\tdriver_unregister(&tcm_loop_driverfs);\n\tbus_unregister(&tcm_loop_lld_bus);\n\troot_device_unregister(tcm_loop_primary);\n\n\tprintk(KERN_INFO \"Releasing TCM Loop Core BUS\\n\");\n}\n\nstatic char *tcm_loop_get_fabric_name(void)\n{\n\treturn \"loopback\";\n}\n\nstatic u8 tcm_loop_get_fabric_proto_ident(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\t/*\n\t * tl_proto_id is set at tcm_loop_configfs.c:tcm_loop_make_scsi_hba()\n\t * time based on the protocol dependent prefix of the passed configfs group.\n\t *\n\t * Based upon tl_proto_id, TCM_Loop emulates the requested fabric\n\t * ProtocolID using target_core_fabric_lib.c symbols.\n\t */\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_fabric_proto_ident(se_tpg);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_fabric_proto_ident(se_tpg);\n}\n\nstatic char *tcm_loop_get_endpoint_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\t/*\n\t * Return the passed NAA identifier for the SAS Target Port\n\t */\n\treturn &tl_tpg->tl_hba->tl_wwn_address[0];\n}\n\nstatic u16 tcm_loop_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\t/*\n\t * This Tag is used when forming SCSI Name identifier in EVPD=1 0x83\n\t * to represent the SCSI Target Port.\n\t */\n\treturn tl_tpg->tl_tpgt;\n}\n\nstatic u32 tcm_loop_get_default_depth(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic u32 tcm_loop_get_pr_transport_id(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tint *format_code,\n\tunsigned char *buf)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code, buf);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code, buf);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code, buf);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\tformat_code, buf);\n}\n\nstatic u32 tcm_loop_get_pr_transport_id_len(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tint *format_code)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\tformat_code);\n}\n\n/*\n * Used for handling SCSI fabric dependent TransportIDs in SPC-3 and above\n * Persistent Reservation SPEC_I_PT=1 and PROUT REGISTER_AND_MOVE operations.\n */\nstatic char *tcm_loop_parse_pr_out_transport_id(\n\tstruct se_portal_group *se_tpg,\n\tconst char *buf,\n\tu32 *out_tid_len,\n\tchar **port_nexus_ptr)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\tport_nexus_ptr);\n}\n\n/*\n * Returning (1) here allows for target_core_mod struct se_node_acl to be generated\n * based upon the incoming fabric dependent SCSI Initiator Port\n */\nstatic int tcm_loop_check_demo_mode(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_check_demo_mode_cache(struct se_portal_group *se_tpg)\n{\n\treturn 0;\n}\n\n/*\n * Allow I_T Nexus full READ-WRITE access without explict Initiator Node ACLs for\n * local virtual Linux/SCSI LLD passthrough into VM hypervisor guest\n */\nstatic int tcm_loop_check_demo_mode_write_protect(struct se_portal_group *se_tpg)\n{\n\treturn 0;\n}\n\n/*\n * Because TCM_Loop does not use explict ACLs and MappedLUNs, this will\n * never be called for TCM_Loop by target_core_fabric_configfs.c code.\n * It has been added here as a nop for target_fabric_tf_ops_check()\n */\nstatic int tcm_loop_check_prod_mode_write_protect(struct se_portal_group *se_tpg)\n{\n\treturn 0;\n}\n\nstatic struct se_node_acl *tcm_loop_tpg_alloc_fabric_acl(\n\tstruct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_nacl *tl_nacl;\n\n\ttl_nacl = kzalloc(sizeof(struct tcm_loop_nacl), GFP_KERNEL);\n\tif (!tl_nacl) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_nacl\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn &tl_nacl->se_node_acl;\n}\n\nstatic void tcm_loop_tpg_release_fabric_acl(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl)\n{\n\tstruct tcm_loop_nacl *tl_nacl = container_of(se_nacl,\n\t\t\t\tstruct tcm_loop_nacl, se_node_acl);\n\n\tkfree(tl_nacl);\n}\n\nstatic u32 tcm_loop_get_inst_index(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_is_state_remove(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Assume struct scsi_cmnd is not in remove state..\n\t */\n\treturn 0;\n}\n\nstatic int tcm_loop_sess_logged_in(struct se_session *se_sess)\n{\n\t/*\n\t * Assume that TL Nexus is always active\n\t */\n\treturn 1;\n}\n\nstatic u32 tcm_loop_sess_get_index(struct se_session *se_sess)\n{\n\treturn 1;\n}\n\nstatic void tcm_loop_set_default_node_attributes(struct se_node_acl *se_acl)\n{\n\treturn;\n}\n\nstatic u32 tcm_loop_get_task_tag(struct se_cmd *se_cmd)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_get_cmd_state(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\n\treturn tl_cmd->sc_cmd_state;\n}\n\nstatic int tcm_loop_shutdown_session(struct se_session *se_sess)\n{\n\treturn 0;\n}\n\nstatic void tcm_loop_close_session(struct se_session *se_sess)\n{\n\treturn;\n};\n\nstatic void tcm_loop_stop_session(\n\tstruct se_session *se_sess,\n\tint sess_sleep,\n\tint conn_sleep)\n{\n\treturn;\n}\n\nstatic void tcm_loop_fall_back_to_erl0(struct se_session *se_sess)\n{\n\treturn;\n}\n\nstatic int tcm_loop_write_pending(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Since Linux/SCSI has already sent down a struct scsi_cmnd\n\t * sc->sc_data_direction of DMA_TO_DEVICE with struct scatterlist array\n\t * memory, and memory has already been mapped to struct se_cmd->t_mem_list\n\t * format with transport_generic_map_mem_to_cmd().\n\t *\n\t * We now tell TCM to add this WRITE CDB directly into the TCM storage\n\t * object execution queue.\n\t */\n\ttransport_generic_process_write(se_cmd);\n\treturn 0;\n}\n\nstatic int tcm_loop_write_pending_status(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tTL_CDB_DEBUG(\"tcm_loop_queue_data_in() called for scsi_cmnd: %p\"\n\t\t     \" cdb: 0x%02x\\n\", sc, sc->cmnd[0]);\n\n\tsc->result = SAM_STAT_GOOD;\n\tset_host_byte(sc, DID_OK);\n\tsc->scsi_done(sc);\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tTL_CDB_DEBUG(\"tcm_loop_queue_status() called for scsi_cmnd: %p\"\n\t\t\t\" cdb: 0x%02x\\n\", sc, sc->cmnd[0]);\n\n\tif (se_cmd->sense_buffer &&\n\t   ((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t    (se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\n\n\t\tmemcpy(sc->sense_buffer, se_cmd->sense_buffer,\n\t\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\tsc->result = SAM_STAT_CHECK_CONDITION;\n\t\tset_driver_byte(sc, DRIVER_SENSE);\n\t} else\n\t\tsc->result = se_cmd->scsi_status;\n\n\tset_host_byte(sc, DID_OK);\n\tsc->scsi_done(sc);\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\n\tstruct tcm_loop_tmr *tl_tmr = se_tmr->fabric_tmr_ptr;\n\t/*\n\t * The SCSI EH thread will be sleeping on se_tmr->tl_tmr_wait, go ahead\n\t * and wake up the wait_queue_head_t in tcm_loop_device_reset()\n\t */\n\tatomic_set(&tl_tmr->tmr_complete, 1);\n\twake_up(&tl_tmr->tl_tmr_wait);\n\treturn 0;\n}\n\nstatic u16 tcm_loop_set_fabric_sense_len(struct se_cmd *se_cmd, u32 sense_length)\n{\n\treturn 0;\n}\n\nstatic u16 tcm_loop_get_fabric_sense_len(void)\n{\n\treturn 0;\n}\n\nstatic char *tcm_loop_dump_proto_id(struct tcm_loop_hba *tl_hba)\n{\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn \"SAS\";\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn \"FCP\";\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn \"iSCSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\n/* Start items for tcm_loop_port_cit */\n\nstatic int tcm_loop_port_link(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *lun)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tatomic_inc(&tl_tpg->tl_tpg_port_count);\n\tsmp_mb__after_atomic_inc();\n\t/*\n\t * Add Linux/SCSI struct scsi_device by HCTL\n\t */\n\tscsi_add_device(tl_hba->sh, 0, tl_tpg->tl_tpgt, lun->unpacked_lun);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Port Link Successful\\n\");\n\treturn 0;\n}\n\nstatic void tcm_loop_port_unlink(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *se_lun)\n{\n\tstruct scsi_device *sd;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\n\ttl_tpg = container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\n\ttl_hba = tl_tpg->tl_hba;\n\n\tsd = scsi_device_lookup(tl_hba->sh, 0, tl_tpg->tl_tpgt,\n\t\t\t\tse_lun->unpacked_lun);\n\tif (!sd) {\n\t\tprintk(KERN_ERR \"Unable to locate struct scsi_device for %d:%d:\"\n\t\t\t\"%d\\n\", 0, tl_tpg->tl_tpgt, se_lun->unpacked_lun);\n\t\treturn;\n\t}\n\t/*\n\t * Remove Linux/SCSI struct scsi_device by HCTL\n\t */\n\tscsi_remove_device(sd);\n\tscsi_device_put(sd);\n\n\tatomic_dec(&tl_tpg->tl_tpg_port_count);\n\tsmp_mb__after_atomic_dec();\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Port Unlink Successful\\n\");\n}\n\n/* End items for tcm_loop_port_cit */\n\n/* Start items for tcm_loop_nexus_cit */\n\nstatic int tcm_loop_make_nexus(\n\tstruct tcm_loop_tpg *tl_tpg,\n\tconst char *name)\n{\n\tstruct se_portal_group *se_tpg;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tint ret = -ENOMEM;\n\n\tif (tl_tpg->tl_hba->tl_nexus) {\n\t\tprintk(KERN_INFO \"tl_tpg->tl_hba->tl_nexus already exists\\n\");\n\t\treturn -EEXIST;\n\t}\n\tse_tpg = &tl_tpg->tl_se_tpg;\n\n\ttl_nexus = kzalloc(sizeof(struct tcm_loop_nexus), GFP_KERNEL);\n\tif (!tl_nexus) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_nexus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * Initialize the struct se_session pointer\n\t */\n\ttl_nexus->se_sess = transport_init_session();\n\tif (IS_ERR(tl_nexus->se_sess)) {\n\t\tret = PTR_ERR(tl_nexus->se_sess);\n\t\tgoto out;\n\t}\n\t/*\n\t * Since we are running in 'demo mode' this call with generate a\n\t * struct se_node_acl for the tcm_loop struct se_portal_group with the SCSI\n\t * Initiator port name of the passed configfs group 'name'.\n\t */\n\ttl_nexus->se_sess->se_node_acl = core_tpg_check_initiator_node_acl(\n\t\t\t\tse_tpg, (unsigned char *)name);\n\tif (!tl_nexus->se_sess->se_node_acl) {\n\t\ttransport_free_session(tl_nexus->se_sess);\n\t\tgoto out;\n\t}\n\t/*\n\t * Now, register the SAS I_T Nexus as active with the call to\n\t * transport_register_session()\n\t */\n\t__transport_register_session(se_tpg, tl_nexus->se_sess->se_node_acl,\n\t\t\ttl_nexus->se_sess, tl_nexus);\n\ttl_tpg->tl_hba->tl_nexus = tl_nexus;\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Established I_T Nexus to emulated\"\n\t\t\" %s Initiator Port: %s\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tname);\n\treturn 0;\n\nout:\n\tkfree(tl_nexus);\n\treturn ret;\n}\n\nstatic int tcm_loop_drop_nexus(\n\tstruct tcm_loop_tpg *tpg)\n{\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tstruct tcm_loop_hba *tl_hba = tpg->tl_hba;\n\n\ttl_nexus = tpg->tl_hba->tl_nexus;\n\tif (!tl_nexus)\n\t\treturn -ENODEV;\n\n\tse_sess = tl_nexus->se_sess;\n\tif (!se_sess)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&tpg->tl_tpg_port_count)) {\n\t\tprintk(KERN_ERR \"Unable to remove TCM_Loop I_T Nexus with\"\n\t\t\t\" active TPG port count: %d\\n\",\n\t\t\tatomic_read(&tpg->tl_tpg_port_count));\n\t\treturn -EPERM;\n\t}\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Removing I_T Nexus to emulated\"\n\t\t\" %s Initiator Port: %s\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\ttl_nexus->se_sess->se_node_acl->initiatorname);\n\t/*\n\t * Release the SCSI I_T Nexus to the emulated SAS Target Port\n\t */\n\ttransport_deregister_session(tl_nexus->se_sess);\n\ttpg->tl_hba->tl_nexus = NULL;\n\tkfree(tl_nexus);\n\treturn 0;\n}\n\n/* End items for tcm_loop_nexus_cit */\n\nstatic ssize_t tcm_loop_tpg_show_nexus(\n\tstruct se_portal_group *se_tpg,\n\tchar *page)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_nexus *tl_nexus;\n\tssize_t ret;\n\n\ttl_nexus = tl_tpg->tl_hba->tl_nexus;\n\tif (!tl_nexus)\n\t\treturn -ENODEV;\n\n\tret = snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\ttl_nexus->se_sess->se_node_acl->initiatorname);\n\n\treturn ret;\n}\n\nstatic ssize_t tcm_loop_tpg_store_nexus(\n\tstruct se_portal_group *se_tpg,\n\tconst char *page,\n\tsize_t count)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\tunsigned char i_port[TL_WWN_ADDR_LEN], *ptr, *port_ptr;\n\tint ret;\n\t/*\n\t * Shutdown the active I_T nexus if 'NULL' is passed..\n\t */\n\tif (!strncmp(page, \"NULL\", 4)) {\n\t\tret = tcm_loop_drop_nexus(tl_tpg);\n\t\treturn (!ret) ? count : ret;\n\t}\n\t/*\n\t * Otherwise make sure the passed virtual Initiator port WWN matches\n\t * the fabric protocol_id set in tcm_loop_make_scsi_hba(), and call\n\t * tcm_loop_make_nexus()\n\t */\n\tif (strlen(page) >= TL_WWN_ADDR_LEN) {\n\t\tprintk(KERN_ERR \"Emulated NAA Sas Address: %s, exceeds\"\n\t\t\t\t\" max: %d\\n\", page, TL_WWN_ADDR_LEN);\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(&i_port[0], TL_WWN_ADDR_LEN, \"%s\", page);\n\n\tptr = strstr(i_port, \"naa.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_SAS) {\n\t\t\tprintk(KERN_ERR \"Passed SAS Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\ttcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"fc.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_FCP) {\n\t\t\tprintk(KERN_ERR \"Passed FCP Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\ttcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[3]; /* Skip over \"fc.\" */\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"iqn.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_ISCSI) {\n\t\t\tprintk(KERN_ERR \"Passed iSCSI Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\ttcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tprintk(KERN_ERR \"Unable to locate prefix for emulated Initiator Port:\"\n\t\t\t\" %s\\n\", i_port);\n\treturn -EINVAL;\n\t/*\n\t * Clear any trailing newline for the NAA WWN\n\t */\ncheck_newline:\n\tif (i_port[strlen(i_port)-1] == '\\n')\n\t\ti_port[strlen(i_port)-1] = '\\0';\n\n\tret = tcm_loop_make_nexus(tl_tpg, port_ptr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nTF_TPG_BASE_ATTR(tcm_loop, nexus, S_IRUGO | S_IWUSR);\n\nstatic struct configfs_attribute *tcm_loop_tpg_attrs[] = {\n\t&tcm_loop_tpg_nexus.attr,\n\tNULL,\n};\n\n/* Start items for tcm_loop_naa_cit */\n\nstruct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; /* Skip ahead of \"tpgt_\" */\n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t/*\n\t * Register the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}\n\nvoid tcm_loop_drop_naa_tpg(\n\tstruct se_portal_group *se_tpg)\n{\n\tstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba;\n\tunsigned short tpgt;\n\n\ttl_hba = tl_tpg->tl_hba;\n\ttpgt = tl_tpg->tl_tpgt;\n\t/*\n\t * Release the I_T Nexus for the Virtual SAS link if present\n\t */\n\ttcm_loop_drop_nexus(tl_tpg);\n\t/*\n\t * Deregister the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tcore_tpg_deregister(se_tpg);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Deallocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n}\n\n/* End items for tcm_loop_naa_cit */\n\n/* Start items for tcm_loop_cit */\n\nstruct se_wwn *tcm_loop_make_scsi_hba(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\tchar *ptr;\n\tint ret, off = 0;\n\n\ttl_hba = kzalloc(sizeof(struct tcm_loop_hba), GFP_KERNEL);\n\tif (!tl_hba) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_hba\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/*\n\t * Determine the emulated Protocol Identifier and Target Port Name\n\t * based on the incoming configfs directory name.\n\t */\n\tptr = strstr(name, \"naa.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_SAS;\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"fc.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_FCP;\n\t\toff = 3; /* Skip over \"fc.\" */\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"iqn.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_ISCSI;\n\t\tgoto check_len;\n\t}\n\n\tprintk(KERN_ERR \"Unable to locate prefix for emulated Target Port:\"\n\t\t\t\" %s\\n\", name);\n\treturn ERR_PTR(-EINVAL);\n\ncheck_len:\n\tif (strlen(name) >= TL_WWN_ADDR_LEN) {\n\t\tprintk(KERN_ERR \"Emulated NAA %s Address: %s, exceeds\"\n\t\t\t\" max: %d\\n\", name, tcm_loop_dump_proto_id(tl_hba),\n\t\t\tTL_WWN_ADDR_LEN);\n\t\tkfree(tl_hba);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsnprintf(&tl_hba->tl_wwn_address[0], TL_WWN_ADDR_LEN, \"%s\", &name[off]);\n\n\t/*\n\t * Call device_register(tl_hba->dev) to register the emulated\n\t * Linux/SCSI LLD of type struct Scsi_Host at tl_hba->sh after\n\t * device_register() callbacks in tcm_loop_driver_probe()\n\t */\n\tret = tcm_loop_setup_hba_bus(tl_hba, tcm_loop_hba_no_cnt);\n\tif (ret)\n\t\tgoto out;\n\n\tsh = tl_hba->sh;\n\ttcm_loop_hba_no_cnt++;\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated emulated Target\"\n\t\t\" %s Address: %s at Linux/SCSI Host ID: %d\\n\",\n\t\ttcm_loop_dump_proto_id(tl_hba), name, sh->host_no);\n\n\treturn &tl_hba->tl_hba_wwn;\nout:\n\tkfree(tl_hba);\n\treturn ERR_PTR(ret);\n}\n\nvoid tcm_loop_drop_scsi_hba(\n\tstruct se_wwn *wwn)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tint host_no = tl_hba->sh->host_no;\n\t/*\n\t * Call device_unregister() on the original tl_hba->dev.\n\t * tcm_loop_fabric_scsi.c:tcm_loop_release_adapter() will\n\t * release *tl_hba;\n\t */\n\tdevice_unregister(&tl_hba->dev);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Deallocated emulated Target\"\n\t\t\" SAS Address: %s at Linux/SCSI Host ID: %d\\n\",\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), host_no);\n}\n\n/* Start items for tcm_loop_cit */\nstatic ssize_t tcm_loop_wwn_show_attr_version(\n\tstruct target_fabric_configfs *tf,\n\tchar *page)\n{\n\treturn sprintf(page, \"TCM Loopback Fabric module %s\\n\", TCM_LOOP_VERSION);\n}\n\nTF_WWN_ATTR_RO(tcm_loop, version);\n\nstatic struct configfs_attribute *tcm_loop_wwn_attrs[] = {\n\t&tcm_loop_wwn_version.attr,\n\tNULL,\n};\n\n/* End items for tcm_loop_cit */\n\nstatic int tcm_loop_register_configfs(void)\n{\n\tstruct target_fabric_configfs *fabric;\n\tstruct config_group *tf_cg;\n\tint ret;\n\t/*\n\t * Set the TCM Loop HBA counter to zero\n\t */\n\ttcm_loop_hba_no_cnt = 0;\n\t/*\n\t * Register the top level struct config_item_type with TCM core\n\t */\n\tfabric = target_fabric_configfs_init(THIS_MODULE, \"loopback\");\n\tif (IS_ERR(fabric)) {\n\t\tprintk(KERN_ERR \"tcm_loop_register_configfs() failed!\\n\");\n\t\treturn PTR_ERR(fabric);\n\t}\n\t/*\n\t * Setup the fabric API of function pointers used by target_core_mod\n\t */\n\tfabric->tf_ops.get_fabric_name = &tcm_loop_get_fabric_name;\n\tfabric->tf_ops.get_fabric_proto_ident = &tcm_loop_get_fabric_proto_ident;\n\tfabric->tf_ops.tpg_get_wwn = &tcm_loop_get_endpoint_wwn;\n\tfabric->tf_ops.tpg_get_tag = &tcm_loop_get_tag;\n\tfabric->tf_ops.tpg_get_default_depth = &tcm_loop_get_default_depth;\n\tfabric->tf_ops.tpg_get_pr_transport_id = &tcm_loop_get_pr_transport_id;\n\tfabric->tf_ops.tpg_get_pr_transport_id_len =\n\t\t\t\t\t&tcm_loop_get_pr_transport_id_len;\n\tfabric->tf_ops.tpg_parse_pr_out_transport_id =\n\t\t\t\t\t&tcm_loop_parse_pr_out_transport_id;\n\tfabric->tf_ops.tpg_check_demo_mode = &tcm_loop_check_demo_mode;\n\tfabric->tf_ops.tpg_check_demo_mode_cache =\n\t\t\t\t\t&tcm_loop_check_demo_mode_cache;\n\tfabric->tf_ops.tpg_check_demo_mode_write_protect =\n\t\t\t\t\t&tcm_loop_check_demo_mode_write_protect;\n\tfabric->tf_ops.tpg_check_prod_mode_write_protect =\n\t\t\t\t\t&tcm_loop_check_prod_mode_write_protect;\n\t/*\n\t * The TCM loopback fabric module runs in demo-mode to a local\n\t * virtual SCSI device, so fabric dependent initator ACLs are\n\t * not required.\n\t */\n\tfabric->tf_ops.tpg_alloc_fabric_acl = &tcm_loop_tpg_alloc_fabric_acl;\n\tfabric->tf_ops.tpg_release_fabric_acl =\n\t\t\t\t\t&tcm_loop_tpg_release_fabric_acl;\n\tfabric->tf_ops.tpg_get_inst_index = &tcm_loop_get_inst_index;\n\t/*\n\t * Used for setting up remaining TCM resources in process context\n\t */\n\tfabric->tf_ops.new_cmd_map = &tcm_loop_new_cmd_map;\n\tfabric->tf_ops.check_stop_free = &tcm_loop_check_stop_free;\n\tfabric->tf_ops.release_cmd = &tcm_loop_release_cmd;\n\tfabric->tf_ops.shutdown_session = &tcm_loop_shutdown_session;\n\tfabric->tf_ops.close_session = &tcm_loop_close_session;\n\tfabric->tf_ops.stop_session = &tcm_loop_stop_session;\n\tfabric->tf_ops.fall_back_to_erl0 = &tcm_loop_fall_back_to_erl0;\n\tfabric->tf_ops.sess_logged_in = &tcm_loop_sess_logged_in;\n\tfabric->tf_ops.sess_get_index = &tcm_loop_sess_get_index;\n\tfabric->tf_ops.sess_get_initiator_sid = NULL;\n\tfabric->tf_ops.write_pending = &tcm_loop_write_pending;\n\tfabric->tf_ops.write_pending_status = &tcm_loop_write_pending_status;\n\t/*\n\t * Not used for TCM loopback\n\t */\n\tfabric->tf_ops.set_default_node_attributes =\n\t\t\t\t\t&tcm_loop_set_default_node_attributes;\n\tfabric->tf_ops.get_task_tag = &tcm_loop_get_task_tag;\n\tfabric->tf_ops.get_cmd_state = &tcm_loop_get_cmd_state;\n\tfabric->tf_ops.queue_data_in = &tcm_loop_queue_data_in;\n\tfabric->tf_ops.queue_status = &tcm_loop_queue_status;\n\tfabric->tf_ops.queue_tm_rsp = &tcm_loop_queue_tm_rsp;\n\tfabric->tf_ops.set_fabric_sense_len = &tcm_loop_set_fabric_sense_len;\n\tfabric->tf_ops.get_fabric_sense_len = &tcm_loop_get_fabric_sense_len;\n\tfabric->tf_ops.is_state_remove = &tcm_loop_is_state_remove;\n\n\ttf_cg = &fabric->tf_group;\n\t/*\n\t * Setup function pointers for generic logic in target_core_fabric_configfs.c\n\t */\n\tfabric->tf_ops.fabric_make_wwn = &tcm_loop_make_scsi_hba;\n\tfabric->tf_ops.fabric_drop_wwn = &tcm_loop_drop_scsi_hba;\n\tfabric->tf_ops.fabric_make_tpg = &tcm_loop_make_naa_tpg;\n\tfabric->tf_ops.fabric_drop_tpg = &tcm_loop_drop_naa_tpg;\n\t/*\n\t * fabric_post_link() and fabric_pre_unlink() are used for\n\t * registration and release of TCM Loop Virtual SCSI LUNs.\n\t */\n\tfabric->tf_ops.fabric_post_link = &tcm_loop_port_link;\n\tfabric->tf_ops.fabric_pre_unlink = &tcm_loop_port_unlink;\n\tfabric->tf_ops.fabric_make_np = NULL;\n\tfabric->tf_ops.fabric_drop_np = NULL;\n\t/*\n\t * Setup default attribute lists for various fabric->tf_cit_tmpl\n\t */\n\tTF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;\n\t/*\n\t * Once fabric->tf_ops has been setup, now register the fabric for\n\t * use within TCM\n\t */\n\tret = target_fabric_configfs_register(fabric);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"target_fabric_configfs_register() for\"\n\t\t\t\t\" TCM_Loop failed!\\n\");\n\t\ttarget_fabric_configfs_free(fabric);\n\t\treturn -1;\n\t}\n\t/*\n\t * Setup our local pointer to *fabric.\n\t */\n\ttcm_loop_fabric_configfs = fabric;\n\tprintk(KERN_INFO \"TCM_LOOP[0] - Set fabric ->\"\n\t\t\t\" tcm_loop_fabric_configfs\\n\");\n\treturn 0;\n}\n\nstatic void tcm_loop_deregister_configfs(void)\n{\n\tif (!tcm_loop_fabric_configfs)\n\t\treturn;\n\n\ttarget_fabric_configfs_deregister(tcm_loop_fabric_configfs);\n\ttcm_loop_fabric_configfs = NULL;\n\tprintk(KERN_INFO \"TCM_LOOP[0] - Cleared\"\n\t\t\t\t\" tcm_loop_fabric_configfs\\n\");\n}\n\nstatic int __init tcm_loop_fabric_init(void)\n{\n\tint ret;\n\n\ttcm_loop_cmd_cache = kmem_cache_create(\"tcm_loop_cmd_cache\",\n\t\t\t\tsizeof(struct tcm_loop_cmd),\n\t\t\t\t__alignof__(struct tcm_loop_cmd),\n\t\t\t\t0, NULL);\n\tif (!tcm_loop_cmd_cache) {\n\t\tprintk(KERN_ERR \"kmem_cache_create() for\"\n\t\t\t\" tcm_loop_cmd_cache failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = tcm_loop_alloc_core_bus();\n\tif (ret)\n\t\treturn ret;\n\n\tret = tcm_loop_register_configfs();\n\tif (ret) {\n\t\ttcm_loop_release_core_bus();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit tcm_loop_fabric_exit(void)\n{\n\ttcm_loop_deregister_configfs();\n\ttcm_loop_release_core_bus();\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\n}\n\nMODULE_DESCRIPTION(\"TCM loopback virtual Linux/SCSI fabric module\");\nMODULE_AUTHOR(\"Nicholas A. Bellinger <nab@risingtidesystems.com>\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(tcm_loop_fabric_init);\nmodule_exit(tcm_loop_fabric_exit);\n"], "fixing_code": ["/*******************************************************************************\n *\n * This file contains the Linux/SCSI LLD virtual SCSI initiator driver\n * for emulated SAS initiator ports\n *\n * \u00a9 Copyright 2011 RisingTide Systems LLC.\n *\n * Licensed to the Linux Foundation under the General Public License (GPL) version 2.\n *\n * Author: Nicholas A. Bellinger <nab@risingtidesystems.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n ****************************************************************************/\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/configfs.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_transport.h>\n#include <target/target_core_fabric_ops.h>\n#include <target/target_core_fabric_configfs.h>\n#include <target/target_core_fabric_lib.h>\n#include <target/target_core_configfs.h>\n#include <target/target_core_device.h>\n#include <target/target_core_tpg.h>\n#include <target/target_core_tmr.h>\n\n#include \"tcm_loop.h\"\n\n#define to_tcm_loop_hba(hba)\tcontainer_of(hba, struct tcm_loop_hba, dev)\n\n/* Local pointer to allocated TCM configfs fabric module */\nstatic struct target_fabric_configfs *tcm_loop_fabric_configfs;\n\nstatic struct kmem_cache *tcm_loop_cmd_cache;\n\nstatic int tcm_loop_hba_no_cnt;\n\n/*\n * Allocate a tcm_loop cmd descriptor from target_core_mod code\n *\n * Can be called from interrupt context in tcm_loop_queuecommand() below\n */\nstatic struct se_cmd *tcm_loop_allocate_core_cmd(\n\tstruct tcm_loop_hba *tl_hba,\n\tstruct se_portal_group *se_tpg,\n\tstruct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd;\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus = tl_hba->tl_nexus;\n\tstruct tcm_loop_cmd *tl_cmd;\n\tint sam_task_attr;\n\n\tif (!tl_nexus) {\n\t\tscmd_printk(KERN_ERR, sc, \"TCM_Loop I_T Nexus\"\n\t\t\t\t\" does not exist\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\treturn NULL;\n\t}\n\tse_sess = tl_nexus->se_sess;\n\n\ttl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_ATOMIC);\n\tif (!tl_cmd) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_cmd\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\treturn NULL;\n\t}\n\tse_cmd = &tl_cmd->tl_se_cmd;\n\t/*\n\t * Save the pointer to struct scsi_cmnd *sc\n\t */\n\ttl_cmd->sc = sc;\n\t/*\n\t * Locate the SAM Task Attr from struct scsi_cmnd *\n\t */\n\tif (sc->device->tagged_supported) {\n\t\tswitch (sc->tag) {\n\t\tcase HEAD_OF_QUEUE_TAG:\n\t\t\tsam_task_attr = MSG_HEAD_TAG;\n\t\t\tbreak;\n\t\tcase ORDERED_QUEUE_TAG:\n\t\t\tsam_task_attr = MSG_ORDERED_TAG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsam_task_attr = MSG_SIMPLE_TAG;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tsam_task_attr = MSG_SIMPLE_TAG;\n\n\t/*\n\t * Initialize struct se_cmd descriptor from target_core_mod infrastructure\n\t */\n\ttransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\n\t\t\tscsi_bufflen(sc), sc->sc_data_direction, sam_task_attr,\n\t\t\t&tl_cmd->tl_sense_buf[0]);\n\n\t/*\n\t * Signal BIDI usage with T_TASK(cmd)->t_tasks_bidi\n\t */\n\tif (scsi_bidi_cmnd(sc))\n\t\tse_cmd->t_tasks_bidi = 1;\n\t/*\n\t * Locate the struct se_lun pointer and attach it to struct se_cmd\n\t */\n\tif (transport_lookup_cmd_lun(se_cmd, tl_cmd->sc->device->lun) < 0) {\n\t\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\t\tset_host_byte(sc, DID_NO_CONNECT);\n\t\treturn NULL;\n\t}\n\n\treturn se_cmd;\n}\n\n/*\n * Called by struct target_core_fabric_ops->new_cmd_map()\n *\n * Always called in process context.  A non zero return value\n * here will signal to handle an exception based on the return code.\n */\nstatic int tcm_loop_new_cmd_map(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\tstruct scatterlist *sgl_bidi = NULL;\n\tu32 sgl_bidi_count = 0;\n\tint ret;\n\t/*\n\t * Allocate the necessary tasks to complete the received CDB+data\n\t */\n\tret = transport_generic_allocate_tasks(se_cmd, sc->cmnd);\n\tif (ret == -ENOMEM) {\n\t\t/* Out of Resources */\n\t\treturn PYX_TRANSPORT_LU_COMM_FAILURE;\n\t} else if (ret == -EINVAL) {\n\t\t/*\n\t\t * Handle case for SAM_STAT_RESERVATION_CONFLICT\n\t\t */\n\t\tif (se_cmd->se_cmd_flags & SCF_SCSI_RESERVATION_CONFLICT)\n\t\t\treturn PYX_TRANSPORT_RESERVATION_CONFLICT;\n\t\t/*\n\t\t * Otherwise, return SAM_STAT_CHECK_CONDITION and return\n\t\t * sense data.\n\t\t */\n\t\treturn PYX_TRANSPORT_USE_SENSE_REASON;\n\t}\n\n\t/*\n\t * For BIDI commands, pass in the extra READ buffer\n\t * to transport_generic_map_mem_to_cmd() below..\n\t */\n\tif (se_cmd->t_tasks_bidi) {\n\t\tstruct scsi_data_buffer *sdb = scsi_in(sc);\n\n\t\tsgl_bidi = sdb->table.sgl;\n\t\tsgl_bidi_count = sdb->table.nents;\n\t}\n\n\t/*\n\t * Map the SG memory into struct se_mem->page linked list using the same\n\t * physical memory at sg->page_link.\n\t */\n\tret = transport_generic_map_mem_to_cmd(se_cmd, scsi_sglist(sc),\n\t\t\tscsi_sg_count(sc), sgl_bidi, sgl_bidi_count);\n\tif (ret < 0)\n\t\treturn PYX_TRANSPORT_LU_COMM_FAILURE;\n\n\treturn 0;\n}\n\n/*\n * Called from struct target_core_fabric_ops->check_stop_free()\n */\nstatic void tcm_loop_check_stop_free(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Do not release struct se_cmd's containing a valid TMR\n\t * pointer.  These will be released directly in tcm_loop_device_reset()\n\t * with transport_generic_free_cmd().\n\t */\n\tif (se_cmd->se_tmr_req)\n\t\treturn;\n\t/*\n\t * Release the struct se_cmd, which will make a callback to release\n\t * struct tcm_loop_cmd * in tcm_loop_deallocate_core_cmd()\n\t */\n\ttransport_generic_free_cmd(se_cmd, 0, 0);\n}\n\nstatic void tcm_loop_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\n\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n}\n\nstatic int tcm_loop_proc_info(struct Scsi_Host *host, char *buffer,\n\t\t\t\tchar **start, off_t offset,\n\t\t\t\tint length, int inout)\n{\n\treturn sprintf(buffer, \"tcm_loop_proc_info()\\n\");\n}\n\nstatic int tcm_loop_driver_probe(struct device *);\nstatic int tcm_loop_driver_remove(struct device *);\n\nstatic int pseudo_lld_bus_match(struct device *dev,\n\t\t\t\tstruct device_driver *dev_driver)\n{\n\treturn 1;\n}\n\nstatic struct bus_type tcm_loop_lld_bus = {\n\t.name\t\t\t= \"tcm_loop_bus\",\n\t.match\t\t\t= pseudo_lld_bus_match,\n\t.probe\t\t\t= tcm_loop_driver_probe,\n\t.remove\t\t\t= tcm_loop_driver_remove,\n};\n\nstatic struct device_driver tcm_loop_driverfs = {\n\t.name\t\t\t= \"tcm_loop\",\n\t.bus\t\t\t= &tcm_loop_lld_bus,\n};\n/*\n * Used with root_device_register() in tcm_loop_alloc_core_bus() below\n */\nstruct device *tcm_loop_primary;\n\n/*\n * Copied from drivers/scsi/libfc/fc_fcp.c:fc_change_queue_depth() and\n * drivers/scsi/libiscsi.c:iscsi_change_queue_depth()\n */\nstatic int tcm_loop_change_queue_depth(\n\tstruct scsi_device *sdev,\n\tint depth,\n\tint reason)\n{\n\tswitch (reason) {\n\tcase SCSI_QDEPTH_DEFAULT:\n\t\tscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\n\t\tbreak;\n\tcase SCSI_QDEPTH_QFULL:\n\t\tscsi_track_queue_full(sdev, depth);\n\t\tbreak;\n\tcase SCSI_QDEPTH_RAMP_UP:\n\t\tscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn sdev->queue_depth;\n}\n\n/*\n * Main entry point from struct scsi_host_template for incoming SCSI CDB+Data\n * from Linux/SCSI subsystem for SCSI low level device drivers (LLDs)\n */\nstatic int tcm_loop_queuecommand(\n\tstruct Scsi_Host *sh,\n\tstruct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd;\n\tstruct se_portal_group *se_tpg;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\n\tTL_CDB_DEBUG(\"tcm_loop_queuecommand() %d:%d:%d:%d got CDB: 0x%02x\"\n\t\t\" scsi_buf_len: %u\\n\", sc->device->host->host_no,\n\t\tsc->device->id, sc->device->channel, sc->device->lun,\n\t\tsc->cmnd[0], scsi_bufflen(sc));\n\t/*\n\t * Locate the tcm_loop_hba_t pointer\n\t */\n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\tse_tpg = &tl_tpg->tl_se_tpg;\n\t/*\n\t * Determine the SAM Task Attribute and allocate tl_cmd and\n\t * tl_cmd->tl_se_cmd from TCM infrastructure\n\t */\n\tse_cmd = tcm_loop_allocate_core_cmd(tl_hba, se_tpg, sc);\n\tif (!se_cmd) {\n\t\tsc->scsi_done(sc);\n\t\treturn 0;\n\t}\n\t/*\n\t * Queue up the newly allocated to be processed in TCM thread context.\n\t*/\n\ttransport_generic_handle_cdb_map(se_cmd);\n\treturn 0;\n}\n\n/*\n * Called from SCSI EH process context to issue a LUN_RESET TMR\n * to struct scsi_device\n */\nstatic int tcm_loop_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd = NULL;\n\tstruct se_portal_group *se_tpg;\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_cmd *tl_cmd = NULL;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tstruct tcm_loop_tmr *tl_tmr = NULL;\n\tstruct tcm_loop_tpg *tl_tpg;\n\tint ret = FAILED;\n\t/*\n\t * Locate the tcm_loop_hba_t pointer\n\t */\n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\t/*\n\t * Locate the tl_nexus and se_sess pointers\n\t */\n\ttl_nexus = tl_hba->tl_nexus;\n\tif (!tl_nexus) {\n\t\tprintk(KERN_ERR \"Unable to perform device reset without\"\n\t\t\t\t\" active I_T Nexus\\n\");\n\t\treturn FAILED;\n\t}\n\tse_sess = tl_nexus->se_sess;\n\t/*\n\t * Locate the tl_tpg and se_tpg pointers from TargetID in sc->device->id\n\t */\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\tse_tpg = &tl_tpg->tl_se_tpg;\n\n\ttl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);\n\tif (!tl_cmd) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory for tl_cmd\\n\");\n\t\treturn FAILED;\n\t}\n\n\ttl_tmr = kzalloc(sizeof(struct tcm_loop_tmr), GFP_KERNEL);\n\tif (!tl_tmr) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory for tl_tmr\\n\");\n\t\tgoto release;\n\t}\n\tinit_waitqueue_head(&tl_tmr->tl_tmr_wait);\n\n\tse_cmd = &tl_cmd->tl_se_cmd;\n\t/*\n\t * Initialize struct se_cmd descriptor from target_core_mod infrastructure\n\t */\n\ttransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess, 0,\n\t\t\t\tDMA_NONE, MSG_SIMPLE_TAG,\n\t\t\t\t&tl_cmd->tl_sense_buf[0]);\n\t/*\n\t * Allocate the LUN_RESET TMR\n\t */\n\tse_cmd->se_tmr_req = core_tmr_alloc_req(se_cmd, tl_tmr,\n\t\t\t\tTMR_LUN_RESET);\n\tif (IS_ERR(se_cmd->se_tmr_req))\n\t\tgoto release;\n\t/*\n\t * Locate the underlying TCM struct se_lun from sc->device->lun\n\t */\n\tif (transport_lookup_tmr_lun(se_cmd, sc->device->lun) < 0)\n\t\tgoto release;\n\t/*\n\t * Queue the TMR to TCM Core and sleep waiting for tcm_loop_queue_tm_rsp()\n\t * to wake us up.\n\t */\n\ttransport_generic_handle_tmr(se_cmd);\n\twait_event(tl_tmr->tl_tmr_wait, atomic_read(&tl_tmr->tmr_complete));\n\t/*\n\t * The TMR LUN_RESET has completed, check the response status and\n\t * then release allocations.\n\t */\n\tret = (se_cmd->se_tmr_req->response == TMR_FUNCTION_COMPLETE) ?\n\t\tSUCCESS : FAILED;\nrelease:\n\tif (se_cmd)\n\t\ttransport_generic_free_cmd(se_cmd, 1, 0);\n\telse\n\t\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\tkfree(tl_tmr);\n\treturn ret;\n}\n\nstatic int tcm_loop_slave_alloc(struct scsi_device *sd)\n{\n\tset_bit(QUEUE_FLAG_BIDI, &sd->request_queue->queue_flags);\n\treturn 0;\n}\n\nstatic int tcm_loop_slave_configure(struct scsi_device *sd)\n{\n\treturn 0;\n}\n\nstatic struct scsi_host_template tcm_loop_driver_template = {\n\t.proc_info\t\t= tcm_loop_proc_info,\n\t.proc_name\t\t= \"tcm_loopback\",\n\t.name\t\t\t= \"TCM_Loopback\",\n\t.queuecommand\t\t= tcm_loop_queuecommand,\n\t.change_queue_depth\t= tcm_loop_change_queue_depth,\n\t.eh_device_reset_handler = tcm_loop_device_reset,\n\t.can_queue\t\t= TL_SCSI_CAN_QUEUE,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= TL_SCSI_SG_TABLESIZE,\n\t.cmd_per_lun\t\t= TL_SCSI_CMD_PER_LUN,\n\t.max_sectors\t\t= TL_SCSI_MAX_SECTORS,\n\t.use_clustering\t\t= DISABLE_CLUSTERING,\n\t.slave_alloc\t\t= tcm_loop_slave_alloc,\n\t.slave_configure\t= tcm_loop_slave_configure,\n\t.module\t\t\t= THIS_MODULE,\n};\n\nstatic int tcm_loop_driver_probe(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\tint error;\n\n\ttl_hba = to_tcm_loop_hba(dev);\n\n\tsh = scsi_host_alloc(&tcm_loop_driver_template,\n\t\t\tsizeof(struct tcm_loop_hba));\n\tif (!sh) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct scsi_host\\n\");\n\t\treturn -ENODEV;\n\t}\n\ttl_hba->sh = sh;\n\n\t/*\n\t * Assign the struct tcm_loop_hba pointer to struct Scsi_Host->hostdata\n\t */\n\t*((struct tcm_loop_hba **)sh->hostdata) = tl_hba;\n\t/*\n\t * Setup single ID, Channel and LUN for now..\n\t */\n\tsh->max_id = 2;\n\tsh->max_lun = 0;\n\tsh->max_channel = 0;\n\tsh->max_cmd_len = TL_SCSI_MAX_CMD_LEN;\n\n\terror = scsi_add_host(sh, &tl_hba->dev);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s: scsi_add_host failed\\n\", __func__);\n\t\tscsi_host_put(sh);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int tcm_loop_driver_remove(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\n\ttl_hba = to_tcm_loop_hba(dev);\n\tsh = tl_hba->sh;\n\n\tscsi_remove_host(sh);\n\tscsi_host_put(sh);\n\treturn 0;\n}\n\nstatic void tcm_loop_release_adapter(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba = to_tcm_loop_hba(dev);\n\n\tkfree(tl_hba);\n}\n\n/*\n * Called from tcm_loop_make_scsi_hba() in tcm_loop_configfs.c\n */\nstatic int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\n{\n\tint ret;\n\n\ttl_hba->dev.bus = &tcm_loop_lld_bus;\n\ttl_hba->dev.parent = tcm_loop_primary;\n\ttl_hba->dev.release = &tcm_loop_release_adapter;\n\tdev_set_name(&tl_hba->dev, \"tcm_loop_adapter_%d\", tcm_loop_host_id);\n\n\tret = device_register(&tl_hba->dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"device_register() failed for\"\n\t\t\t\t\" tl_hba->dev: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Called from tcm_loop_fabric_init() in tcl_loop_fabric.c to load the emulated\n * tcm_loop SCSI bus.\n */\nstatic int tcm_loop_alloc_core_bus(void)\n{\n\tint ret;\n\n\ttcm_loop_primary = root_device_register(\"tcm_loop_0\");\n\tif (IS_ERR(tcm_loop_primary)) {\n\t\tprintk(KERN_ERR \"Unable to allocate tcm_loop_primary\\n\");\n\t\treturn PTR_ERR(tcm_loop_primary);\n\t}\n\n\tret = bus_register(&tcm_loop_lld_bus);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"bus_register() failed for tcm_loop_lld_bus\\n\");\n\t\tgoto dev_unreg;\n\t}\n\n\tret = driver_register(&tcm_loop_driverfs);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"driver_register() failed for\"\n\t\t\t\t\"tcm_loop_driverfs\\n\");\n\t\tgoto bus_unreg;\n\t}\n\n\tprintk(KERN_INFO \"Initialized TCM Loop Core Bus\\n\");\n\treturn ret;\n\nbus_unreg:\n\tbus_unregister(&tcm_loop_lld_bus);\ndev_unreg:\n\troot_device_unregister(tcm_loop_primary);\n\treturn ret;\n}\n\nstatic void tcm_loop_release_core_bus(void)\n{\n\tdriver_unregister(&tcm_loop_driverfs);\n\tbus_unregister(&tcm_loop_lld_bus);\n\troot_device_unregister(tcm_loop_primary);\n\n\tprintk(KERN_INFO \"Releasing TCM Loop Core BUS\\n\");\n}\n\nstatic char *tcm_loop_get_fabric_name(void)\n{\n\treturn \"loopback\";\n}\n\nstatic u8 tcm_loop_get_fabric_proto_ident(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\t/*\n\t * tl_proto_id is set at tcm_loop_configfs.c:tcm_loop_make_scsi_hba()\n\t * time based on the protocol dependent prefix of the passed configfs group.\n\t *\n\t * Based upon tl_proto_id, TCM_Loop emulates the requested fabric\n\t * ProtocolID using target_core_fabric_lib.c symbols.\n\t */\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_fabric_proto_ident(se_tpg);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_fabric_proto_ident(se_tpg);\n}\n\nstatic char *tcm_loop_get_endpoint_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\t/*\n\t * Return the passed NAA identifier for the SAS Target Port\n\t */\n\treturn &tl_tpg->tl_hba->tl_wwn_address[0];\n}\n\nstatic u16 tcm_loop_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\t/*\n\t * This Tag is used when forming SCSI Name identifier in EVPD=1 0x83\n\t * to represent the SCSI Target Port.\n\t */\n\treturn tl_tpg->tl_tpgt;\n}\n\nstatic u32 tcm_loop_get_default_depth(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic u32 tcm_loop_get_pr_transport_id(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tint *format_code,\n\tunsigned char *buf)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code, buf);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code, buf);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code, buf);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n\t\t\tformat_code, buf);\n}\n\nstatic u32 tcm_loop_get_pr_transport_id_len(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tint *format_code)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\t\t\tformat_code);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n\t\t\tformat_code);\n}\n\n/*\n * Used for handling SCSI fabric dependent TransportIDs in SPC-3 and above\n * Persistent Reservation SPEC_I_PT=1 and PROUT REGISTER_AND_MOVE operations.\n */\nstatic char *tcm_loop_parse_pr_out_transport_id(\n\tstruct se_portal_group *se_tpg,\n\tconst char *buf,\n\tu32 *out_tid_len,\n\tchar **port_nexus_ptr)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\tport_nexus_ptr);\n}\n\n/*\n * Returning (1) here allows for target_core_mod struct se_node_acl to be generated\n * based upon the incoming fabric dependent SCSI Initiator Port\n */\nstatic int tcm_loop_check_demo_mode(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_check_demo_mode_cache(struct se_portal_group *se_tpg)\n{\n\treturn 0;\n}\n\n/*\n * Allow I_T Nexus full READ-WRITE access without explict Initiator Node ACLs for\n * local virtual Linux/SCSI LLD passthrough into VM hypervisor guest\n */\nstatic int tcm_loop_check_demo_mode_write_protect(struct se_portal_group *se_tpg)\n{\n\treturn 0;\n}\n\n/*\n * Because TCM_Loop does not use explict ACLs and MappedLUNs, this will\n * never be called for TCM_Loop by target_core_fabric_configfs.c code.\n * It has been added here as a nop for target_fabric_tf_ops_check()\n */\nstatic int tcm_loop_check_prod_mode_write_protect(struct se_portal_group *se_tpg)\n{\n\treturn 0;\n}\n\nstatic struct se_node_acl *tcm_loop_tpg_alloc_fabric_acl(\n\tstruct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_nacl *tl_nacl;\n\n\ttl_nacl = kzalloc(sizeof(struct tcm_loop_nacl), GFP_KERNEL);\n\tif (!tl_nacl) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_nacl\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn &tl_nacl->se_node_acl;\n}\n\nstatic void tcm_loop_tpg_release_fabric_acl(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl)\n{\n\tstruct tcm_loop_nacl *tl_nacl = container_of(se_nacl,\n\t\t\t\tstruct tcm_loop_nacl, se_node_acl);\n\n\tkfree(tl_nacl);\n}\n\nstatic u32 tcm_loop_get_inst_index(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_is_state_remove(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Assume struct scsi_cmnd is not in remove state..\n\t */\n\treturn 0;\n}\n\nstatic int tcm_loop_sess_logged_in(struct se_session *se_sess)\n{\n\t/*\n\t * Assume that TL Nexus is always active\n\t */\n\treturn 1;\n}\n\nstatic u32 tcm_loop_sess_get_index(struct se_session *se_sess)\n{\n\treturn 1;\n}\n\nstatic void tcm_loop_set_default_node_attributes(struct se_node_acl *se_acl)\n{\n\treturn;\n}\n\nstatic u32 tcm_loop_get_task_tag(struct se_cmd *se_cmd)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_get_cmd_state(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\n\treturn tl_cmd->sc_cmd_state;\n}\n\nstatic int tcm_loop_shutdown_session(struct se_session *se_sess)\n{\n\treturn 0;\n}\n\nstatic void tcm_loop_close_session(struct se_session *se_sess)\n{\n\treturn;\n};\n\nstatic void tcm_loop_stop_session(\n\tstruct se_session *se_sess,\n\tint sess_sleep,\n\tint conn_sleep)\n{\n\treturn;\n}\n\nstatic void tcm_loop_fall_back_to_erl0(struct se_session *se_sess)\n{\n\treturn;\n}\n\nstatic int tcm_loop_write_pending(struct se_cmd *se_cmd)\n{\n\t/*\n\t * Since Linux/SCSI has already sent down a struct scsi_cmnd\n\t * sc->sc_data_direction of DMA_TO_DEVICE with struct scatterlist array\n\t * memory, and memory has already been mapped to struct se_cmd->t_mem_list\n\t * format with transport_generic_map_mem_to_cmd().\n\t *\n\t * We now tell TCM to add this WRITE CDB directly into the TCM storage\n\t * object execution queue.\n\t */\n\ttransport_generic_process_write(se_cmd);\n\treturn 0;\n}\n\nstatic int tcm_loop_write_pending_status(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tTL_CDB_DEBUG(\"tcm_loop_queue_data_in() called for scsi_cmnd: %p\"\n\t\t     \" cdb: 0x%02x\\n\", sc, sc->cmnd[0]);\n\n\tsc->result = SAM_STAT_GOOD;\n\tset_host_byte(sc, DID_OK);\n\tsc->scsi_done(sc);\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tTL_CDB_DEBUG(\"tcm_loop_queue_status() called for scsi_cmnd: %p\"\n\t\t\t\" cdb: 0x%02x\\n\", sc, sc->cmnd[0]);\n\n\tif (se_cmd->sense_buffer &&\n\t   ((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t    (se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\n\n\t\tmemcpy(sc->sense_buffer, se_cmd->sense_buffer,\n\t\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\tsc->result = SAM_STAT_CHECK_CONDITION;\n\t\tset_driver_byte(sc, DRIVER_SENSE);\n\t} else\n\t\tsc->result = se_cmd->scsi_status;\n\n\tset_host_byte(sc, DID_OK);\n\tsc->scsi_done(sc);\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\n\tstruct tcm_loop_tmr *tl_tmr = se_tmr->fabric_tmr_ptr;\n\t/*\n\t * The SCSI EH thread will be sleeping on se_tmr->tl_tmr_wait, go ahead\n\t * and wake up the wait_queue_head_t in tcm_loop_device_reset()\n\t */\n\tatomic_set(&tl_tmr->tmr_complete, 1);\n\twake_up(&tl_tmr->tl_tmr_wait);\n\treturn 0;\n}\n\nstatic u16 tcm_loop_set_fabric_sense_len(struct se_cmd *se_cmd, u32 sense_length)\n{\n\treturn 0;\n}\n\nstatic u16 tcm_loop_get_fabric_sense_len(void)\n{\n\treturn 0;\n}\n\nstatic char *tcm_loop_dump_proto_id(struct tcm_loop_hba *tl_hba)\n{\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn \"SAS\";\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn \"FCP\";\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn \"iSCSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\n/* Start items for tcm_loop_port_cit */\n\nstatic int tcm_loop_port_link(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *lun)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tatomic_inc(&tl_tpg->tl_tpg_port_count);\n\tsmp_mb__after_atomic_inc();\n\t/*\n\t * Add Linux/SCSI struct scsi_device by HCTL\n\t */\n\tscsi_add_device(tl_hba->sh, 0, tl_tpg->tl_tpgt, lun->unpacked_lun);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Port Link Successful\\n\");\n\treturn 0;\n}\n\nstatic void tcm_loop_port_unlink(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *se_lun)\n{\n\tstruct scsi_device *sd;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\n\ttl_tpg = container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\n\ttl_hba = tl_tpg->tl_hba;\n\n\tsd = scsi_device_lookup(tl_hba->sh, 0, tl_tpg->tl_tpgt,\n\t\t\t\tse_lun->unpacked_lun);\n\tif (!sd) {\n\t\tprintk(KERN_ERR \"Unable to locate struct scsi_device for %d:%d:\"\n\t\t\t\"%d\\n\", 0, tl_tpg->tl_tpgt, se_lun->unpacked_lun);\n\t\treturn;\n\t}\n\t/*\n\t * Remove Linux/SCSI struct scsi_device by HCTL\n\t */\n\tscsi_remove_device(sd);\n\tscsi_device_put(sd);\n\n\tatomic_dec(&tl_tpg->tl_tpg_port_count);\n\tsmp_mb__after_atomic_dec();\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Port Unlink Successful\\n\");\n}\n\n/* End items for tcm_loop_port_cit */\n\n/* Start items for tcm_loop_nexus_cit */\n\nstatic int tcm_loop_make_nexus(\n\tstruct tcm_loop_tpg *tl_tpg,\n\tconst char *name)\n{\n\tstruct se_portal_group *se_tpg;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tint ret = -ENOMEM;\n\n\tif (tl_tpg->tl_hba->tl_nexus) {\n\t\tprintk(KERN_INFO \"tl_tpg->tl_hba->tl_nexus already exists\\n\");\n\t\treturn -EEXIST;\n\t}\n\tse_tpg = &tl_tpg->tl_se_tpg;\n\n\ttl_nexus = kzalloc(sizeof(struct tcm_loop_nexus), GFP_KERNEL);\n\tif (!tl_nexus) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_nexus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * Initialize the struct se_session pointer\n\t */\n\ttl_nexus->se_sess = transport_init_session();\n\tif (IS_ERR(tl_nexus->se_sess)) {\n\t\tret = PTR_ERR(tl_nexus->se_sess);\n\t\tgoto out;\n\t}\n\t/*\n\t * Since we are running in 'demo mode' this call with generate a\n\t * struct se_node_acl for the tcm_loop struct se_portal_group with the SCSI\n\t * Initiator port name of the passed configfs group 'name'.\n\t */\n\ttl_nexus->se_sess->se_node_acl = core_tpg_check_initiator_node_acl(\n\t\t\t\tse_tpg, (unsigned char *)name);\n\tif (!tl_nexus->se_sess->se_node_acl) {\n\t\ttransport_free_session(tl_nexus->se_sess);\n\t\tgoto out;\n\t}\n\t/*\n\t * Now, register the SAS I_T Nexus as active with the call to\n\t * transport_register_session()\n\t */\n\t__transport_register_session(se_tpg, tl_nexus->se_sess->se_node_acl,\n\t\t\ttl_nexus->se_sess, tl_nexus);\n\ttl_tpg->tl_hba->tl_nexus = tl_nexus;\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Established I_T Nexus to emulated\"\n\t\t\" %s Initiator Port: %s\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tname);\n\treturn 0;\n\nout:\n\tkfree(tl_nexus);\n\treturn ret;\n}\n\nstatic int tcm_loop_drop_nexus(\n\tstruct tcm_loop_tpg *tpg)\n{\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tstruct tcm_loop_hba *tl_hba = tpg->tl_hba;\n\n\ttl_nexus = tpg->tl_hba->tl_nexus;\n\tif (!tl_nexus)\n\t\treturn -ENODEV;\n\n\tse_sess = tl_nexus->se_sess;\n\tif (!se_sess)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&tpg->tl_tpg_port_count)) {\n\t\tprintk(KERN_ERR \"Unable to remove TCM_Loop I_T Nexus with\"\n\t\t\t\" active TPG port count: %d\\n\",\n\t\t\tatomic_read(&tpg->tl_tpg_port_count));\n\t\treturn -EPERM;\n\t}\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Removing I_T Nexus to emulated\"\n\t\t\" %s Initiator Port: %s\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\ttl_nexus->se_sess->se_node_acl->initiatorname);\n\t/*\n\t * Release the SCSI I_T Nexus to the emulated SAS Target Port\n\t */\n\ttransport_deregister_session(tl_nexus->se_sess);\n\ttpg->tl_hba->tl_nexus = NULL;\n\tkfree(tl_nexus);\n\treturn 0;\n}\n\n/* End items for tcm_loop_nexus_cit */\n\nstatic ssize_t tcm_loop_tpg_show_nexus(\n\tstruct se_portal_group *se_tpg,\n\tchar *page)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_nexus *tl_nexus;\n\tssize_t ret;\n\n\ttl_nexus = tl_tpg->tl_hba->tl_nexus;\n\tif (!tl_nexus)\n\t\treturn -ENODEV;\n\n\tret = snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\ttl_nexus->se_sess->se_node_acl->initiatorname);\n\n\treturn ret;\n}\n\nstatic ssize_t tcm_loop_tpg_store_nexus(\n\tstruct se_portal_group *se_tpg,\n\tconst char *page,\n\tsize_t count)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\tunsigned char i_port[TL_WWN_ADDR_LEN], *ptr, *port_ptr;\n\tint ret;\n\t/*\n\t * Shutdown the active I_T nexus if 'NULL' is passed..\n\t */\n\tif (!strncmp(page, \"NULL\", 4)) {\n\t\tret = tcm_loop_drop_nexus(tl_tpg);\n\t\treturn (!ret) ? count : ret;\n\t}\n\t/*\n\t * Otherwise make sure the passed virtual Initiator port WWN matches\n\t * the fabric protocol_id set in tcm_loop_make_scsi_hba(), and call\n\t * tcm_loop_make_nexus()\n\t */\n\tif (strlen(page) >= TL_WWN_ADDR_LEN) {\n\t\tprintk(KERN_ERR \"Emulated NAA Sas Address: %s, exceeds\"\n\t\t\t\t\" max: %d\\n\", page, TL_WWN_ADDR_LEN);\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(&i_port[0], TL_WWN_ADDR_LEN, \"%s\", page);\n\n\tptr = strstr(i_port, \"naa.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_SAS) {\n\t\t\tprintk(KERN_ERR \"Passed SAS Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\ttcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"fc.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_FCP) {\n\t\t\tprintk(KERN_ERR \"Passed FCP Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\ttcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[3]; /* Skip over \"fc.\" */\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"iqn.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_ISCSI) {\n\t\t\tprintk(KERN_ERR \"Passed iSCSI Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\ttcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tprintk(KERN_ERR \"Unable to locate prefix for emulated Initiator Port:\"\n\t\t\t\" %s\\n\", i_port);\n\treturn -EINVAL;\n\t/*\n\t * Clear any trailing newline for the NAA WWN\n\t */\ncheck_newline:\n\tif (i_port[strlen(i_port)-1] == '\\n')\n\t\ti_port[strlen(i_port)-1] = '\\0';\n\n\tret = tcm_loop_make_nexus(tl_tpg, port_ptr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nTF_TPG_BASE_ATTR(tcm_loop, nexus, S_IRUGO | S_IWUSR);\n\nstatic struct configfs_attribute *tcm_loop_tpg_attrs[] = {\n\t&tcm_loop_tpg_nexus.attr,\n\tNULL,\n};\n\n/* Start items for tcm_loop_naa_cit */\n\nstruct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; /* Skip ahead of \"tpgt_\" */\n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\n\tif (tpgt >= TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t/*\n\t * Register the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}\n\nvoid tcm_loop_drop_naa_tpg(\n\tstruct se_portal_group *se_tpg)\n{\n\tstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba;\n\tunsigned short tpgt;\n\n\ttl_hba = tl_tpg->tl_hba;\n\ttpgt = tl_tpg->tl_tpgt;\n\t/*\n\t * Release the I_T Nexus for the Virtual SAS link if present\n\t */\n\ttcm_loop_drop_nexus(tl_tpg);\n\t/*\n\t * Deregister the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tcore_tpg_deregister(se_tpg);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Deallocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n}\n\n/* End items for tcm_loop_naa_cit */\n\n/* Start items for tcm_loop_cit */\n\nstruct se_wwn *tcm_loop_make_scsi_hba(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\tchar *ptr;\n\tint ret, off = 0;\n\n\ttl_hba = kzalloc(sizeof(struct tcm_loop_hba), GFP_KERNEL);\n\tif (!tl_hba) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_hba\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/*\n\t * Determine the emulated Protocol Identifier and Target Port Name\n\t * based on the incoming configfs directory name.\n\t */\n\tptr = strstr(name, \"naa.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_SAS;\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"fc.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_FCP;\n\t\toff = 3; /* Skip over \"fc.\" */\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"iqn.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_ISCSI;\n\t\tgoto check_len;\n\t}\n\n\tprintk(KERN_ERR \"Unable to locate prefix for emulated Target Port:\"\n\t\t\t\" %s\\n\", name);\n\treturn ERR_PTR(-EINVAL);\n\ncheck_len:\n\tif (strlen(name) >= TL_WWN_ADDR_LEN) {\n\t\tprintk(KERN_ERR \"Emulated NAA %s Address: %s, exceeds\"\n\t\t\t\" max: %d\\n\", name, tcm_loop_dump_proto_id(tl_hba),\n\t\t\tTL_WWN_ADDR_LEN);\n\t\tkfree(tl_hba);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsnprintf(&tl_hba->tl_wwn_address[0], TL_WWN_ADDR_LEN, \"%s\", &name[off]);\n\n\t/*\n\t * Call device_register(tl_hba->dev) to register the emulated\n\t * Linux/SCSI LLD of type struct Scsi_Host at tl_hba->sh after\n\t * device_register() callbacks in tcm_loop_driver_probe()\n\t */\n\tret = tcm_loop_setup_hba_bus(tl_hba, tcm_loop_hba_no_cnt);\n\tif (ret)\n\t\tgoto out;\n\n\tsh = tl_hba->sh;\n\ttcm_loop_hba_no_cnt++;\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated emulated Target\"\n\t\t\" %s Address: %s at Linux/SCSI Host ID: %d\\n\",\n\t\ttcm_loop_dump_proto_id(tl_hba), name, sh->host_no);\n\n\treturn &tl_hba->tl_hba_wwn;\nout:\n\tkfree(tl_hba);\n\treturn ERR_PTR(ret);\n}\n\nvoid tcm_loop_drop_scsi_hba(\n\tstruct se_wwn *wwn)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tint host_no = tl_hba->sh->host_no;\n\t/*\n\t * Call device_unregister() on the original tl_hba->dev.\n\t * tcm_loop_fabric_scsi.c:tcm_loop_release_adapter() will\n\t * release *tl_hba;\n\t */\n\tdevice_unregister(&tl_hba->dev);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Deallocated emulated Target\"\n\t\t\" SAS Address: %s at Linux/SCSI Host ID: %d\\n\",\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), host_no);\n}\n\n/* Start items for tcm_loop_cit */\nstatic ssize_t tcm_loop_wwn_show_attr_version(\n\tstruct target_fabric_configfs *tf,\n\tchar *page)\n{\n\treturn sprintf(page, \"TCM Loopback Fabric module %s\\n\", TCM_LOOP_VERSION);\n}\n\nTF_WWN_ATTR_RO(tcm_loop, version);\n\nstatic struct configfs_attribute *tcm_loop_wwn_attrs[] = {\n\t&tcm_loop_wwn_version.attr,\n\tNULL,\n};\n\n/* End items for tcm_loop_cit */\n\nstatic int tcm_loop_register_configfs(void)\n{\n\tstruct target_fabric_configfs *fabric;\n\tstruct config_group *tf_cg;\n\tint ret;\n\t/*\n\t * Set the TCM Loop HBA counter to zero\n\t */\n\ttcm_loop_hba_no_cnt = 0;\n\t/*\n\t * Register the top level struct config_item_type with TCM core\n\t */\n\tfabric = target_fabric_configfs_init(THIS_MODULE, \"loopback\");\n\tif (IS_ERR(fabric)) {\n\t\tprintk(KERN_ERR \"tcm_loop_register_configfs() failed!\\n\");\n\t\treturn PTR_ERR(fabric);\n\t}\n\t/*\n\t * Setup the fabric API of function pointers used by target_core_mod\n\t */\n\tfabric->tf_ops.get_fabric_name = &tcm_loop_get_fabric_name;\n\tfabric->tf_ops.get_fabric_proto_ident = &tcm_loop_get_fabric_proto_ident;\n\tfabric->tf_ops.tpg_get_wwn = &tcm_loop_get_endpoint_wwn;\n\tfabric->tf_ops.tpg_get_tag = &tcm_loop_get_tag;\n\tfabric->tf_ops.tpg_get_default_depth = &tcm_loop_get_default_depth;\n\tfabric->tf_ops.tpg_get_pr_transport_id = &tcm_loop_get_pr_transport_id;\n\tfabric->tf_ops.tpg_get_pr_transport_id_len =\n\t\t\t\t\t&tcm_loop_get_pr_transport_id_len;\n\tfabric->tf_ops.tpg_parse_pr_out_transport_id =\n\t\t\t\t\t&tcm_loop_parse_pr_out_transport_id;\n\tfabric->tf_ops.tpg_check_demo_mode = &tcm_loop_check_demo_mode;\n\tfabric->tf_ops.tpg_check_demo_mode_cache =\n\t\t\t\t\t&tcm_loop_check_demo_mode_cache;\n\tfabric->tf_ops.tpg_check_demo_mode_write_protect =\n\t\t\t\t\t&tcm_loop_check_demo_mode_write_protect;\n\tfabric->tf_ops.tpg_check_prod_mode_write_protect =\n\t\t\t\t\t&tcm_loop_check_prod_mode_write_protect;\n\t/*\n\t * The TCM loopback fabric module runs in demo-mode to a local\n\t * virtual SCSI device, so fabric dependent initator ACLs are\n\t * not required.\n\t */\n\tfabric->tf_ops.tpg_alloc_fabric_acl = &tcm_loop_tpg_alloc_fabric_acl;\n\tfabric->tf_ops.tpg_release_fabric_acl =\n\t\t\t\t\t&tcm_loop_tpg_release_fabric_acl;\n\tfabric->tf_ops.tpg_get_inst_index = &tcm_loop_get_inst_index;\n\t/*\n\t * Used for setting up remaining TCM resources in process context\n\t */\n\tfabric->tf_ops.new_cmd_map = &tcm_loop_new_cmd_map;\n\tfabric->tf_ops.check_stop_free = &tcm_loop_check_stop_free;\n\tfabric->tf_ops.release_cmd = &tcm_loop_release_cmd;\n\tfabric->tf_ops.shutdown_session = &tcm_loop_shutdown_session;\n\tfabric->tf_ops.close_session = &tcm_loop_close_session;\n\tfabric->tf_ops.stop_session = &tcm_loop_stop_session;\n\tfabric->tf_ops.fall_back_to_erl0 = &tcm_loop_fall_back_to_erl0;\n\tfabric->tf_ops.sess_logged_in = &tcm_loop_sess_logged_in;\n\tfabric->tf_ops.sess_get_index = &tcm_loop_sess_get_index;\n\tfabric->tf_ops.sess_get_initiator_sid = NULL;\n\tfabric->tf_ops.write_pending = &tcm_loop_write_pending;\n\tfabric->tf_ops.write_pending_status = &tcm_loop_write_pending_status;\n\t/*\n\t * Not used for TCM loopback\n\t */\n\tfabric->tf_ops.set_default_node_attributes =\n\t\t\t\t\t&tcm_loop_set_default_node_attributes;\n\tfabric->tf_ops.get_task_tag = &tcm_loop_get_task_tag;\n\tfabric->tf_ops.get_cmd_state = &tcm_loop_get_cmd_state;\n\tfabric->tf_ops.queue_data_in = &tcm_loop_queue_data_in;\n\tfabric->tf_ops.queue_status = &tcm_loop_queue_status;\n\tfabric->tf_ops.queue_tm_rsp = &tcm_loop_queue_tm_rsp;\n\tfabric->tf_ops.set_fabric_sense_len = &tcm_loop_set_fabric_sense_len;\n\tfabric->tf_ops.get_fabric_sense_len = &tcm_loop_get_fabric_sense_len;\n\tfabric->tf_ops.is_state_remove = &tcm_loop_is_state_remove;\n\n\ttf_cg = &fabric->tf_group;\n\t/*\n\t * Setup function pointers for generic logic in target_core_fabric_configfs.c\n\t */\n\tfabric->tf_ops.fabric_make_wwn = &tcm_loop_make_scsi_hba;\n\tfabric->tf_ops.fabric_drop_wwn = &tcm_loop_drop_scsi_hba;\n\tfabric->tf_ops.fabric_make_tpg = &tcm_loop_make_naa_tpg;\n\tfabric->tf_ops.fabric_drop_tpg = &tcm_loop_drop_naa_tpg;\n\t/*\n\t * fabric_post_link() and fabric_pre_unlink() are used for\n\t * registration and release of TCM Loop Virtual SCSI LUNs.\n\t */\n\tfabric->tf_ops.fabric_post_link = &tcm_loop_port_link;\n\tfabric->tf_ops.fabric_pre_unlink = &tcm_loop_port_unlink;\n\tfabric->tf_ops.fabric_make_np = NULL;\n\tfabric->tf_ops.fabric_drop_np = NULL;\n\t/*\n\t * Setup default attribute lists for various fabric->tf_cit_tmpl\n\t */\n\tTF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;\n\tTF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;\n\t/*\n\t * Once fabric->tf_ops has been setup, now register the fabric for\n\t * use within TCM\n\t */\n\tret = target_fabric_configfs_register(fabric);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"target_fabric_configfs_register() for\"\n\t\t\t\t\" TCM_Loop failed!\\n\");\n\t\ttarget_fabric_configfs_free(fabric);\n\t\treturn -1;\n\t}\n\t/*\n\t * Setup our local pointer to *fabric.\n\t */\n\ttcm_loop_fabric_configfs = fabric;\n\tprintk(KERN_INFO \"TCM_LOOP[0] - Set fabric ->\"\n\t\t\t\" tcm_loop_fabric_configfs\\n\");\n\treturn 0;\n}\n\nstatic void tcm_loop_deregister_configfs(void)\n{\n\tif (!tcm_loop_fabric_configfs)\n\t\treturn;\n\n\ttarget_fabric_configfs_deregister(tcm_loop_fabric_configfs);\n\ttcm_loop_fabric_configfs = NULL;\n\tprintk(KERN_INFO \"TCM_LOOP[0] - Cleared\"\n\t\t\t\t\" tcm_loop_fabric_configfs\\n\");\n}\n\nstatic int __init tcm_loop_fabric_init(void)\n{\n\tint ret;\n\n\ttcm_loop_cmd_cache = kmem_cache_create(\"tcm_loop_cmd_cache\",\n\t\t\t\tsizeof(struct tcm_loop_cmd),\n\t\t\t\t__alignof__(struct tcm_loop_cmd),\n\t\t\t\t0, NULL);\n\tif (!tcm_loop_cmd_cache) {\n\t\tprintk(KERN_ERR \"kmem_cache_create() for\"\n\t\t\t\" tcm_loop_cmd_cache failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = tcm_loop_alloc_core_bus();\n\tif (ret)\n\t\treturn ret;\n\n\tret = tcm_loop_register_configfs();\n\tif (ret) {\n\t\ttcm_loop_release_core_bus();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit tcm_loop_fabric_exit(void)\n{\n\ttcm_loop_deregister_configfs();\n\ttcm_loop_release_core_bus();\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\n}\n\nMODULE_DESCRIPTION(\"TCM loopback virtual Linux/SCSI fabric module\");\nMODULE_AUTHOR(\"Nicholas A. Bellinger <nab@risingtidesystems.com>\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(tcm_loop_fabric_init);\nmodule_exit(tcm_loop_fabric_exit);\n"], "filenames": ["drivers/target/loopback/tcm_loop.c"], "buggy_code_start_loc": [1208], "buggy_code_end_loc": [1209], "fixing_code_start_loc": [1208], "fixing_code_end_loc": [1209], "type": "CWE-119", "message": "In the Linux kernel before 3.1, an off by one in the drivers/target/loopback/tcm_loop.c tcm_loop_make_naa_tpg() function could result in at least memory corruption.", "other": {"cve": {"id": "CVE-2011-5327", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T22:15:11.230", "lastModified": "2022-11-03T02:10:44.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 3.1, an off by one in the drivers/target/loopback/tcm_loop.c tcm_loop_make_naa_tpg() function could result in at least memory corruption."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 3.1, un problema por un paso en el archivo drivers/target/loopback/tcm_loop.c en la funci\u00f3n tcm_loop_make_naa_tpg() podr\u00eda causar, como m\u00ednimo, una corrupci\u00f3n de memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.39", "versionEndExcluding": "3.1", "matchCriteriaId": "ABEF4D67-DEC2-4158-AB21-D20A2846D3D9"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=12f09ccb4612734a53e47ed5302e0479c10a50f8", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://support.f5.com/csp/article/K42315210", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K42315210?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8"}}