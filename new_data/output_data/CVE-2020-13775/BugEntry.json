{"buggy_code": ["/*\n * Copyright (C) 2004-2020 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/Client.h>\n#include <znc/Chan.h>\n#include <znc/IRCSock.h>\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/Query.h>\n\nusing std::set;\nusing std::map;\nusing std::vector;\n\n#define CALLMOD(MOD, CLIENT, USER, NETWORK, FUNC)                             \\\n    {                                                                         \\\n        CModule* pModule = nullptr;                                           \\\n        if (NETWORK && (pModule = (NETWORK)->GetModules().FindModule(MOD))) { \\\n            try {                                                             \\\n                CClient* pOldClient = pModule->GetClient();                   \\\n                pModule->SetClient(CLIENT);                                   \\\n                pModule->FUNC;                                                \\\n                pModule->SetClient(pOldClient);                               \\\n            } catch (const CModule::EModException& e) {                       \\\n                if (e == CModule::UNLOAD) {                                   \\\n                    (NETWORK)->GetModules().UnloadModule(MOD);                \\\n                }                                                             \\\n            }                                                                 \\\n        } else if ((pModule = (USER)->GetModules().FindModule(MOD))) {        \\\n            try {                                                             \\\n                CClient* pOldClient = pModule->GetClient();                   \\\n                CIRCNetwork* pOldNetwork = pModule->GetNetwork();             \\\n                pModule->SetClient(CLIENT);                                   \\\n                pModule->SetNetwork(NETWORK);                                 \\\n                pModule->FUNC;                                                \\\n                pModule->SetClient(pOldClient);                               \\\n                pModule->SetNetwork(pOldNetwork);                             \\\n            } catch (const CModule::EModException& e) {                       \\\n                if (e == CModule::UNLOAD) {                                   \\\n                    (USER)->GetModules().UnloadModule(MOD);                   \\\n                }                                                             \\\n            }                                                                 \\\n        } else if ((pModule = CZNC::Get().GetModules().FindModule(MOD))) {    \\\n            try {                                                             \\\n                CClient* pOldClient = pModule->GetClient();                   \\\n                CIRCNetwork* pOldNetwork = pModule->GetNetwork();             \\\n                CUser* pOldUser = pModule->GetUser();                         \\\n                pModule->SetClient(CLIENT);                                   \\\n                pModule->SetNetwork(NETWORK);                                 \\\n                pModule->SetUser(USER);                                       \\\n                pModule->FUNC;                                                \\\n                pModule->SetClient(pOldClient);                               \\\n                pModule->SetNetwork(pOldNetwork);                             \\\n                pModule->SetUser(pOldUser);                                   \\\n            } catch (const CModule::EModException& e) {                       \\\n                if (e == CModule::UNLOAD) {                                   \\\n                    CZNC::Get().GetModules().UnloadModule(MOD);               \\\n                }                                                             \\\n            }                                                                 \\\n        } else {                                                              \\\n            PutStatus(t_f(\"No such module {1}\")(MOD));                        \\\n        }                                                                     \\\n    }\n\nCClient::~CClient() {\n    if (m_spAuth) {\n        CClientAuth* pAuth = (CClientAuth*)&(*m_spAuth);\n        pAuth->Invalidate();\n    }\n    if (m_pUser != nullptr) {\n        m_pUser->AddBytesRead(GetBytesRead());\n        m_pUser->AddBytesWritten(GetBytesWritten());\n    }\n}\n\nvoid CClient::SendRequiredPasswordNotice() {\n    PutClient(\":irc.znc.in 464 \" + GetNick() + \" :Password required\");\n    PutClient(\n        \":irc.znc.in NOTICE \" + GetNick() + \" :*** \"\n        \"You need to send your password. \"\n        \"Configure your client to send a server password.\");\n    PutClient(\n        \":irc.znc.in NOTICE \" + GetNick() + \" :*** \"\n        \"To connect now, you can use /quote PASS <username>:<password>, \"\n        \"or /quote PASS <username>/<network>:<password> to connect to a \"\n        \"specific network.\");\n}\n\nvoid CClient::ReadLine(const CString& sData) {\n    CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : \"\");\n    CString sLine = sData;\n\n    sLine.Replace(\"\\n\", \"\");\n    sLine.Replace(\"\\r\", \"\");\n\n    DEBUG(\"(\" << GetFullName() << \") CLI -> ZNC [\"\n        << CDebug::Filter(sLine) << \"]\");\n\n    bool bReturn = false;\n    if (IsAttached()) {\n        NETWORKMODULECALL(OnUserRaw(sLine), m_pUser, m_pNetwork, this,\n                          &bReturn);\n    } else {\n        GLOBALMODULECALL(OnUnknownUserRaw(this, sLine), &bReturn);\n    }\n    if (bReturn) return;\n\n    CMessage Message(sLine);\n    Message.SetClient(this);\n\n    if (IsAttached()) {\n        NETWORKMODULECALL(OnUserRawMessage(Message), m_pUser, m_pNetwork, this,\n                          &bReturn);\n    } else {\n        GLOBALMODULECALL(OnUnknownUserRawMessage(Message), &bReturn);\n    }\n    if (bReturn) return;\n\n    CString sCommand = Message.GetCommand();\n\n    if (!IsAttached()) {\n        // The following commands happen before authentication with ZNC\n        if (sCommand.Equals(\"PASS\")) {\n            m_bGotPass = true;\n\n            CString sAuthLine = Message.GetParam(0);\n            ParsePass(sAuthLine);\n\n            AuthUser();\n            // Don't forward this msg.  ZNC has already registered us.\n            return;\n        } else if (sCommand.Equals(\"NICK\")) {\n            CString sNick = Message.GetParam(0);\n\n            m_sNick = sNick;\n            m_bGotNick = true;\n\n            AuthUser();\n            // Don't forward this msg.  ZNC will handle nick changes until auth\n            // is complete\n            return;\n        } else if (sCommand.Equals(\"USER\")) {\n            CString sAuthLine = Message.GetParam(0);\n\n            if (m_sUser.empty() && !sAuthLine.empty()) {\n                ParseUser(sAuthLine);\n            }\n\n            m_bGotUser = true;\n            if (m_bGotPass) {\n                AuthUser();\n            } else if (!m_bInCap) {\n                SendRequiredPasswordNotice();\n            }\n\n            // Don't forward this msg.  ZNC has already registered us.\n            return;\n        }\n    }\n\n    if (Message.GetType() == CMessage::Type::Capability) {\n        HandleCap(Message);\n\n        // Don't let the client talk to the server directly about CAP,\n        // we don't want anything enabled that ZNC does not support.\n        return;\n    }\n\n    if (!m_pUser) {\n        // Only CAP, NICK, USER and PASS are allowed before login\n        return;\n    }\n\n    switch (Message.GetType()) {\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        default:\n            bReturn = OnOtherMessage(Message);\n            break;\n    }\n\n    if (bReturn) return;\n\n    PutIRC(Message.ToString(CMessage::ExcludePrefix | CMessage::ExcludeTags));\n}\n\nvoid CClient::SetNick(const CString& s) { m_sNick = s; }\n\nvoid CClient::SetNetwork(CIRCNetwork* pNetwork, bool bDisconnect,\n                         bool bReconnect) {\n    if (m_pNetwork) {\n        m_pNetwork->ClientDisconnected(this);\n\n        if (bDisconnect) {\n            ClearServerDependentCaps();\n            // Tell the client they are no longer in these channels.\n            const vector<CChan*>& vChans = m_pNetwork->GetChans();\n            for (const CChan* pChan : vChans) {\n                if (!(pChan->IsDetached())) {\n                    PutClient(\":\" + m_pNetwork->GetIRCNick().GetNickMask() +\n                              \" PART \" + pChan->GetName());\n                }\n            }\n        }\n    } else if (m_pUser) {\n        m_pUser->UserDisconnected(this);\n    }\n\n    m_pNetwork = pNetwork;\n\n    if (bReconnect) {\n        if (m_pNetwork) {\n            m_pNetwork->ClientConnected(this);\n        } else if (m_pUser) {\n            m_pUser->UserConnected(this);\n        }\n    }\n}\n\nconst vector<CClient*>& CClient::GetClients() const {\n    if (m_pNetwork) {\n        return m_pNetwork->GetClients();\n    }\n\n    return m_pUser->GetUserClients();\n}\n\nconst CIRCSock* CClient::GetIRCSock() const {\n    if (m_pNetwork) {\n        return m_pNetwork->GetIRCSock();\n    }\n\n    return nullptr;\n}\n\nCIRCSock* CClient::GetIRCSock() {\n    if (m_pNetwork) {\n        return m_pNetwork->GetIRCSock();\n    }\n\n    return nullptr;\n}\n\nvoid CClient::StatusCTCP(const CString& sLine) {\n    CString sCommand = sLine.Token(0);\n\n    if (sCommand.Equals(\"PING\")) {\n        PutStatusNotice(\"\\001PING \" + sLine.Token(1, true) + \"\\001\");\n    } else if (sCommand.Equals(\"VERSION\")) {\n        PutStatusNotice(\"\\001VERSION \" + CZNC::GetTag() + \"\\001\");\n    }\n}\n\nbool CClient::SendMotd() {\n    const VCString& vsMotd = CZNC::Get().GetMotd();\n\n    if (!vsMotd.size()) {\n        return false;\n    }\n\n    for (const CString& sLine : vsMotd) {\n        if (m_pNetwork) {\n            PutStatusNotice(m_pNetwork->ExpandString(sLine));\n        } else {\n            PutStatusNotice(m_pUser->ExpandString(sLine));\n        }\n    }\n\n    return true;\n}\n\nvoid CClient::AuthUser() {\n    if (!m_bGotNick || !m_bGotUser || !m_bGotPass || m_bInCap || IsAttached())\n        return;\n\n    m_spAuth = std::make_shared<CClientAuth>(this, m_sUser, m_sPass);\n\n    CZNC::Get().AuthUser(m_spAuth);\n}\n\nCClientAuth::CClientAuth(CClient* pClient, const CString& sUsername,\n                         const CString& sPassword)\n    : CAuthBase(sUsername, sPassword, pClient), m_pClient(pClient) {}\n\nvoid CClientAuth::RefusedLogin(const CString& sReason) {\n    if (m_pClient) {\n        m_pClient->RefuseLogin(sReason);\n    }\n}\n\nCString CAuthBase::GetRemoteIP() const {\n    if (m_pSock) return m_pSock->GetRemoteIP();\n    return \"\";\n}\n\nvoid CAuthBase::Invalidate() { m_pSock = nullptr; }\n\nvoid CAuthBase::AcceptLogin(CUser& User) {\n    if (m_pSock) {\n        AcceptedLogin(User);\n        Invalidate();\n    }\n}\n\nvoid CAuthBase::RefuseLogin(const CString& sReason) {\n    if (!m_pSock) return;\n\n    CUser* pUser = CZNC::Get().FindUser(GetUsername());\n\n    // If the username is valid, notify that user that someone tried to\n    // login. Use sReason because there are other reasons than \"wrong\n    // password\" for a login to be rejected (e.g. fail2ban).\n    if (pUser) {\n        pUser->PutStatusNotice(t_f(\n            \"A client from {1} attempted to login as you, but was rejected: \"\n            \"{2}\")(GetRemoteIP(), sReason));\n    }\n\n    GLOBALMODULECALL(OnFailedLogin(GetUsername(), GetRemoteIP()), NOTHING);\n    RefusedLogin(sReason);\n    Invalidate();\n}\n\nvoid CClient::RefuseLogin(const CString& sReason) {\n    PutStatus(\"Bad username and/or password.\");\n    PutClient(\":irc.znc.in 464 \" + GetNick() + \" :\" + sReason);\n    Close(Csock::CLT_AFTERWRITE);\n}\n\nvoid CClientAuth::AcceptedLogin(CUser& User) {\n    if (m_pClient) {\n        m_pClient->AcceptLogin(User);\n    }\n}\n\nvoid CClient::AcceptLogin(CUser& User) {\n    m_sPass = \"\";\n    m_pUser = &User;\n\n    // Set our proper timeout and set back our proper timeout mode\n    // (constructor set a different timeout and mode)\n    SetTimeout(User.GetNoTrafficTimeout(), TMO_READ);\n\n    SetSockName(\"USR::\" + m_pUser->GetUsername());\n    SetEncoding(m_pUser->GetClientEncoding());\n\n    if (!m_sNetwork.empty()) {\n        m_pNetwork = m_pUser->FindNetwork(m_sNetwork);\n        if (!m_pNetwork) {\n            PutStatus(t_f(\"Network {1} doesn't exist.\")(m_sNetwork));\n        }\n    } else if (!m_pUser->GetNetworks().empty()) {\n        // If a user didn't supply a network, and they have a network called\n        // \"default\" then automatically use this network.\n        m_pNetwork = m_pUser->FindNetwork(\"default\");\n        // If no \"default\" network, try \"user\" network. It's for compatibility\n        // with early network stuff in ZNC, which converted old configs to\n        // \"user\" network.\n        if (!m_pNetwork) m_pNetwork = m_pUser->FindNetwork(\"user\");\n        // Otherwise, just try any network of the user.\n        if (!m_pNetwork) m_pNetwork = *m_pUser->GetNetworks().begin();\n        if (m_pNetwork && m_pUser->GetNetworks().size() > 1) {\n            PutStatusNotice(\n                t_s(\"You have several networks configured, but no network was \"\n                    \"specified for the connection.\"));\n            PutStatusNotice(\n                t_f(\"Selecting network {1}. To see list of all configured \"\n                    \"networks, use /znc ListNetworks\")(m_pNetwork->GetName()));\n            PutStatusNotice(t_f(\n                \"If you want to choose another network, use /znc JumpNetwork \"\n                \"<network>, or connect to ZNC with username {1}/<network> \"\n                \"(instead of just {1})\")(m_pUser->GetUsername()));\n        }\n    } else {\n        PutStatusNotice(\n            t_s(\"You have no networks configured. Use /znc AddNetwork \"\n                \"<network> to add one.\"));\n    }\n\n    SetNetwork(m_pNetwork, false);\n\n    SendMotd();\n\n    NETWORKMODULECALL(OnClientLogin(), m_pUser, m_pNetwork, this, NOTHING);\n}\n\nvoid CClient::Timeout() { PutClient(\"ERROR :\" + t_s(\"Closing link: Timeout\")); }\n\nvoid CClient::Connected() { DEBUG(GetSockName() << \" == Connected();\"); }\n\nvoid CClient::ConnectionRefused() {\n    DEBUG(GetSockName() << \" == ConnectionRefused()\");\n}\n\nvoid CClient::Disconnected() {\n    DEBUG(GetSockName() << \" == Disconnected()\");\n    CIRCNetwork* pNetwork = m_pNetwork;\n    SetNetwork(nullptr, false, false);\n\n    if (m_pUser) {\n        NETWORKMODULECALL(OnClientDisconnect(), m_pUser, pNetwork, this,\n                          NOTHING);\n    }\n}\n\nvoid CClient::ReachedMaxBuffer() {\n    DEBUG(GetSockName() << \" == ReachedMaxBuffer()\");\n    if (IsAttached()) {\n        PutClient(\"ERROR :\" + t_s(\"Closing link: Too long raw line\"));\n    }\n    Close();\n}\n\nvoid CClient::BouncedOff() {\n    PutStatusNotice(\n        t_s(\"You are being disconnected because another user just \"\n            \"authenticated as you.\"));\n    Close(Csock::CLT_AFTERWRITE);\n}\n\nvoid CClient::PutIRC(const CString& sLine) {\n    if (m_pNetwork) {\n        m_pNetwork->PutIRC(sLine);\n    }\n}\n\nCString CClient::GetFullName() const {\n    if (!m_pUser) return GetRemoteIP();\n    CString sFullName = m_pUser->GetUsername();\n    if (!m_sIdentifier.empty()) sFullName += \"@\" + m_sIdentifier;\n    if (m_pNetwork) sFullName += \"/\" + m_pNetwork->GetName();\n    return sFullName;\n}\n\nvoid CClient::PutClient(const CString& sLine) {\n    PutClient(CMessage(sLine));\n}\n\nbool CClient::PutClient(const CMessage& Message) {\n    if (!m_bAwayNotify && Message.GetType() == CMessage::Type::Away) {\n        return false;\n    } else if (!m_bAccountNotify &&\n               Message.GetType() == CMessage::Type::Account) {\n        return false;\n    }\n\n    CMessage Msg(Message);\n\n    const CIRCSock* pIRCSock = GetIRCSock();\n    if (pIRCSock) {\n        if (Msg.GetType() == CMessage::Type::Numeric) {\n            unsigned int uCode = Msg.As<CNumericMessage>().GetCode();\n\n            if (uCode == 352) {  // RPL_WHOREPLY\n                if (!m_bNamesx && pIRCSock->HasNamesx()) {\n                    // The server has NAMESX, but the client doesn't, so we need\n                    // to remove extra prefixes\n                    CString sNick = Msg.GetParam(6);\n                    if (sNick.size() > 1 && pIRCSock->IsPermChar(sNick[1])) {\n                        CString sNewNick = sNick;\n                        size_t pos =\n                            sNick.find_first_not_of(pIRCSock->GetPerms());\n                        if (pos >= 2 && pos != CString::npos) {\n                            sNewNick = sNick[0] + sNick.substr(pos);\n                        }\n                        Msg.SetParam(6, sNewNick);\n                    }\n                }\n            } else if (uCode == 353) {  // RPL_NAMES\n                if ((!m_bNamesx && pIRCSock->HasNamesx()) ||\n                    (!m_bUHNames && pIRCSock->HasUHNames())) {\n                    // The server has either UHNAMES or NAMESX, but the client\n                    // is missing either or both\n                    CString sNicks = Msg.GetParam(3);\n                    VCString vsNicks;\n                    sNicks.Split(\" \", vsNicks, false);\n\n                    for (CString& sNick : vsNicks) {\n                        if (sNick.empty()) break;\n\n                        if (!m_bNamesx && pIRCSock->HasNamesx() &&\n                            pIRCSock->IsPermChar(sNick[0])) {\n                            // The server has NAMESX, but the client doesn't, so\n                            // we just use the first perm char\n                            size_t pos =\n                                sNick.find_first_not_of(pIRCSock->GetPerms());\n                            if (pos >= 2 && pos != CString::npos) {\n                                sNick = sNick[0] + sNick.substr(pos);\n                            }\n                        }\n\n                        if (!m_bUHNames && pIRCSock->HasUHNames()) {\n                            // The server has UHNAMES, but the client doesn't,\n                            // so we strip away ident and host\n                            sNick = sNick.Token(0, false, \"!\");\n                        }\n                    }\n\n                    Msg.SetParam(\n                        3, CString(\" \").Join(vsNicks.begin(), vsNicks.end()));\n                }\n            }\n        } else if (Msg.GetType() == CMessage::Type::Join) {\n            if (!m_bExtendedJoin && pIRCSock->HasExtendedJoin()) {\n                Msg.SetParams({Msg.As<CJoinMessage>().GetTarget()});\n            }\n        }\n    }\n\n    MCString mssTags;\n\n    for (const auto& it : Msg.GetTags()) {\n        if (IsTagEnabled(it.first)) {\n            mssTags[it.first] = it.second;\n        }\n    }\n\n    if (HasServerTime()) {\n        // If the server didn't set the time tag, manually set it\n        mssTags.emplace(\"time\", CUtils::FormatServerTime(Msg.GetTime()));\n    }\n\n    Msg.SetTags(mssTags);\n    Msg.SetClient(this);\n    Msg.SetNetwork(m_pNetwork);\n\n    bool bReturn = false;\n    NETWORKMODULECALL(OnSendToClientMessage(Msg), m_pUser, m_pNetwork, this,\n                      &bReturn);\n    if (bReturn) return false;\n\n    return PutClientRaw(Msg.ToString());\n}\n\nbool CClient::PutClientRaw(const CString& sLine) {\n    CString sCopy = sLine;\n    bool bReturn = false;\n    NETWORKMODULECALL(OnSendToClient(sCopy, *this), m_pUser, m_pNetwork, this,\n                      &bReturn);\n    if (bReturn) return false;\n\n    DEBUG(\"(\" << GetFullName() << \") ZNC -> CLI [\"\n        << CDebug::Filter(sCopy) << \"]\");\n    Write(sCopy + \"\\r\\n\");\n    return true;\n}\n\nvoid CClient::PutStatusNotice(const CString& sLine) {\n    PutModNotice(\"status\", sLine);\n}\n\nunsigned int CClient::PutStatus(const CTable& table) {\n    unsigned int idx = 0;\n    CString sLine;\n    while (table.GetLine(idx++, sLine)) PutStatus(sLine);\n    return idx - 1;\n}\n\nvoid CClient::PutStatus(const CString& sLine) { PutModule(\"status\", sLine); }\n\nvoid CClient::PutModNotice(const CString& sModule, const CString& sLine) {\n    if (!m_pUser) {\n        return;\n    }\n\n    DEBUG(\"(\" << GetFullName()\n              << \") ZNC -> CLI [:\" + m_pUser->GetStatusPrefix() +\n                     ((sModule.empty()) ? \"status\" : sModule) +\n                     \"!znc@znc.in NOTICE \" << GetNick() << \" :\" << sLine\n              << \"]\");\n    Write(\":\" + m_pUser->GetStatusPrefix() +\n          ((sModule.empty()) ? \"status\" : sModule) + \"!znc@znc.in NOTICE \" +\n          GetNick() + \" :\" + sLine + \"\\r\\n\");\n}\n\nvoid CClient::PutModule(const CString& sModule, const CString& sLine) {\n    if (!m_pUser) {\n        return;\n    }\n\n    DEBUG(\"(\" << GetFullName()\n              << \") ZNC -> CLI [:\" + m_pUser->GetStatusPrefix() +\n                     ((sModule.empty()) ? \"status\" : sModule) +\n                     \"!znc@znc.in PRIVMSG \" << GetNick() << \" :\" << sLine\n              << \"]\");\n\n    VCString vsLines;\n    sLine.Split(\"\\n\", vsLines);\n    for (const CString& s : vsLines) {\n        Write(\":\" + m_pUser->GetStatusPrefix() +\n              ((sModule.empty()) ? \"status\" : sModule) +\n              \"!znc@znc.in PRIVMSG \" + GetNick() + \" :\" + s + \"\\r\\n\");\n    }\n}\n\nCString CClient::GetNick(bool bAllowIRCNick) const {\n    CString sRet;\n\n    const CIRCSock* pSock = GetIRCSock();\n    if (bAllowIRCNick && pSock && pSock->IsAuthed()) {\n        sRet = pSock->GetNick();\n    }\n\n    return (sRet.empty()) ? m_sNick : sRet;\n}\n\nCString CClient::GetNickMask() const {\n    if (GetIRCSock() && GetIRCSock()->IsAuthed()) {\n        return GetIRCSock()->GetNickMask();\n    }\n\n    CString sHost =\n        m_pNetwork ? m_pNetwork->GetBindHost() : m_pUser->GetBindHost();\n    if (sHost.empty()) {\n        sHost = \"irc.znc.in\";\n    }\n\n    return GetNick() + \"!\" +\n           (m_pNetwork ? m_pNetwork->GetIdent() : m_pUser->GetIdent()) + \"@\" +\n           sHost;\n}\n\nbool CClient::IsValidIdentifier(const CString& sIdentifier) {\n    // ^[-\\w]+$\n\n    if (sIdentifier.empty()) {\n        return false;\n    }\n\n    const char* p = sIdentifier.c_str();\n    while (*p) {\n        if (*p != '_' && *p != '-' && !isalnum(*p)) {\n            return false;\n        }\n\n        p++;\n    }\n\n    return true;\n}\n\nvoid CClient::RespondCap(const CString& sResponse) {\n    PutClient(\":irc.znc.in CAP \" + GetNick() + \" \" + sResponse);\n}\n\nvoid CClient::HandleCap(const CMessage& Message) {\n    CString sSubCmd = Message.GetParam(0);\n\n    if (sSubCmd.Equals(\"LS\")) {\n        SCString ssOfferCaps;\n        for (const auto& it : m_mCoreCaps) {\n            bool bServerDependent = std::get<0>(it.second);\n            if (!bServerDependent ||\n                m_ssServerDependentCaps.count(it.first) > 0)\n                ssOfferCaps.insert(it.first);\n        }\n        GLOBALMODULECALL(OnClientCapLs(this, ssOfferCaps), NOTHING);\n        CString sRes =\n            CString(\" \").Join(ssOfferCaps.begin(), ssOfferCaps.end());\n        RespondCap(\"LS :\" + sRes);\n        m_bInCap = true;\n        if (Message.GetParam(1).ToInt() >= 302) {\n            m_bCapNotify = true;\n        }\n    } else if (sSubCmd.Equals(\"END\")) {\n        m_bInCap = false;\n        if (!IsAttached()) {\n            if (!m_pUser && m_bGotUser && !m_bGotPass) {\n                SendRequiredPasswordNotice();\n            } else {\n                AuthUser();\n            }\n        }\n    } else if (sSubCmd.Equals(\"REQ\")) {\n        VCString vsTokens;\n        Message.GetParam(1).Split(\" \", vsTokens, false);\n\n        for (const CString& sToken : vsTokens) {\n            bool bVal = true;\n            CString sCap = sToken;\n            if (sCap.TrimPrefix(\"-\")) bVal = false;\n\n            bool bAccepted = false;\n            const auto& it = m_mCoreCaps.find(sCap);\n            if (m_mCoreCaps.end() != it) {\n                bool bServerDependent = std::get<0>(it->second);\n                bAccepted = !bServerDependent ||\n                            m_ssServerDependentCaps.count(sCap) > 0;\n            }\n            GLOBALMODULECALL(IsClientCapSupported(this, sCap, bVal),\n                             &bAccepted);\n\n            if (!bAccepted) {\n                // Some unsupported capability is requested\n                RespondCap(\"NAK :\" + Message.GetParam(1));\n                return;\n            }\n        }\n\n        // All is fine, we support what was requested\n        for (const CString& sToken : vsTokens) {\n            bool bVal = true;\n            CString sCap = sToken;\n            if (sCap.TrimPrefix(\"-\")) bVal = false;\n\n            auto handler_it = m_mCoreCaps.find(sCap);\n            if (m_mCoreCaps.end() != handler_it) {\n                const auto& handler = std::get<1>(handler_it->second);\n                handler(bVal);\n            }\n            GLOBALMODULECALL(OnClientCapRequest(this, sCap, bVal), NOTHING);\n\n            if (bVal) {\n                m_ssAcceptedCaps.insert(sCap);\n            } else {\n                m_ssAcceptedCaps.erase(sCap);\n            }\n        }\n\n        RespondCap(\"ACK :\" + Message.GetParam(1));\n    } else if (sSubCmd.Equals(\"LIST\")) {\n        CString sList =\n            CString(\" \").Join(m_ssAcceptedCaps.begin(), m_ssAcceptedCaps.end());\n        RespondCap(\"LIST :\" + sList);\n    } else {\n        PutClient(\":irc.znc.in 410 \" + GetNick() + \" \" + sSubCmd +\n                  \" :Invalid CAP subcommand\");\n    }\n}\n\nvoid CClient::ParsePass(const CString& sAuthLine) {\n    // [user[@identifier][/network]:]password\n\n    const size_t uColon = sAuthLine.find(\":\");\n    if (uColon != CString::npos) {\n        m_sPass = sAuthLine.substr(uColon + 1);\n\n        ParseUser(sAuthLine.substr(0, uColon));\n    } else {\n        m_sPass = sAuthLine;\n    }\n}\n\nvoid CClient::ParseUser(const CString& sAuthLine) {\n    // user[@identifier][/network]\n\n    const size_t uSlash = sAuthLine.rfind(\"/\");\n    if (uSlash != CString::npos) {\n        m_sNetwork = sAuthLine.substr(uSlash + 1);\n\n        ParseIdentifier(sAuthLine.substr(0, uSlash));\n    } else {\n        ParseIdentifier(sAuthLine);\n    }\n}\n\nvoid CClient::ParseIdentifier(const CString& sAuthLine) {\n    // user[@identifier]\n\n    const size_t uAt = sAuthLine.rfind(\"@\");\n    if (uAt != CString::npos) {\n        const CString sId = sAuthLine.substr(uAt + 1);\n\n        if (IsValidIdentifier(sId)) {\n            m_sIdentifier = sId;\n            m_sUser = sAuthLine.substr(0, uAt);\n        } else {\n            m_sUser = sAuthLine;\n        }\n    } else {\n        m_sUser = sAuthLine;\n    }\n}\n\nvoid CClient::SetTagSupport(const CString& sTag, bool bState) {\n    if (bState) {\n        m_ssSupportedTags.insert(sTag);\n    } else {\n        m_ssSupportedTags.erase(sTag);\n    }\n}\n\nvoid CClient::NotifyServerDependentCaps(const SCString& ssCaps) {\n    for (const CString& sCap : ssCaps) {\n        const auto& it = m_mCoreCaps.find(sCap);\n        if (m_mCoreCaps.end() != it) {\n            bool bServerDependent = std::get<0>(it->second);\n            if (bServerDependent) {\n                m_ssServerDependentCaps.insert(sCap);\n            }\n        }\n    }\n\n    if (HasCapNotify() && !m_ssServerDependentCaps.empty()) {\n        CString sCaps = CString(\" \").Join(m_ssServerDependentCaps.begin(),\n                                          m_ssServerDependentCaps.end());\n        PutClient(\":irc.znc.in CAP \" + GetNick() + \" NEW :\" + sCaps);\n    }\n}\n\nvoid CClient::ClearServerDependentCaps() {\n    if (HasCapNotify() && !m_ssServerDependentCaps.empty()) {\n        CString sCaps = CString(\" \").Join(m_ssServerDependentCaps.begin(),\n                                          m_ssServerDependentCaps.end());\n        PutClient(\":irc.znc.in CAP \" + GetNick() + \" DEL :\" + sCaps);\n\n        for (const CString& sCap : m_ssServerDependentCaps) {\n            const auto& it = m_mCoreCaps.find(sCap);\n            if (m_mCoreCaps.end() != it) {\n                const auto& handler = std::get<1>(it->second);\n                handler(false);\n            }\n        }\n    }\n\n    m_ssServerDependentCaps.clear();\n}\n\ntemplate <typename T>\nvoid CClient::AddBuffer(const T& Message) {\n    const CString sTarget = Message.GetTarget();\n\n    T Format;\n    Format.Clone(Message);\n    Format.SetNick(CNick(_NAMEDFMT(GetNickMask())));\n    Format.SetTarget(_NAMEDFMT(sTarget));\n    Format.SetText(\"{text}\");\n\n    CChan* pChan = m_pNetwork->FindChan(sTarget);\n    if (pChan) {\n        if (!pChan->AutoClearChanBuffer() || !m_pNetwork->IsUserOnline()) {\n            pChan->AddBuffer(Format, Message.GetText());\n        }\n    } else if (Message.GetType() != CMessage::Type::Notice) {\n        if (!m_pUser->AutoClearQueryBuffer() || !m_pNetwork->IsUserOnline()) {\n            CQuery* pQuery = m_pNetwork->AddQuery(sTarget);\n            if (pQuery) {\n                pQuery->AddBuffer(Format, Message.GetText());\n            }\n        }\n    }\n}\n\nvoid CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n\nset<CChan*> CClient::MatchChans(const CString& sPatterns) const {\n    VCString vsPatterns;\n    sPatterns.Replace_n(\",\", \" \")\n        .Split(\" \", vsPatterns, false, \"\", \"\", true, true);\n\n    set<CChan*> sChans;\n    for (const CString& sPattern : vsPatterns) {\n        vector<CChan*> vChans = m_pNetwork->FindChans(sPattern);\n        sChans.insert(vChans.begin(), vChans.end());\n    }\n    return sChans;\n}\n\nunsigned int CClient::AttachChans(const std::set<CChan*>& sChans) {\n    unsigned int uAttached = 0;\n    for (CChan* pChan : sChans) {\n        if (!pChan->IsDetached()) continue;\n        uAttached++;\n        pChan->AttachUser();\n    }\n    return uAttached;\n}\n\nunsigned int CClient::DetachChans(const std::set<CChan*>& sChans) {\n    unsigned int uDetached = 0;\n    for (CChan* pChan : sChans) {\n        if (pChan->IsDetached()) continue;\n        uDetached++;\n        pChan->DetachUser();\n    }\n    return uDetached;\n}\n\nbool CClient::OnActionMessage(CActionMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserActionMessage(Message), m_pUser, m_pNetwork,\n                          this, &bContinue);\n        if (bContinue) continue;\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnCTCPMessage(CCTCPMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    if (Message.IsReply()) {\n        CString sCTCP = Message.GetText();\n        if (sCTCP.Token(0) == \"VERSION\") {\n            // There are 2 different scenarios:\n            //\n            // a) CTCP reply for VERSION is not set.\n            // 1. ZNC receives CTCP VERSION from someone\n            // 2. ZNC forwards CTCP VERSION to client\n            // 3. Client replies with something\n            // 4. ZNC adds itself to the reply\n            // 5. ZNC sends the modified reply to whoever asked\n            //\n            // b) CTCP reply for VERSION is set.\n            // 1. ZNC receives CTCP VERSION from someone\n            // 2. ZNC replies with the configured reply (or just drops it if\n            //    empty), without forwarding anything to client\n            // 3. Client does not see any CTCP request, and does not reply\n            //\n            // So, if user doesn't want \"via ZNC\" in CTCP VERSION reply, they\n            // can set custom reply.\n            //\n            // See more bikeshedding at github issues #820 and #1012\n            Message.SetText(sCTCP + \" via \" + CZNC::GetTag(false));\n        }\n    }\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        bool bContinue = false;\n        if (Message.IsReply()) {\n            NETWORKMODULECALL(OnUserCTCPReplyMessage(Message), m_pUser,\n                              m_pNetwork, this, &bContinue);\n        } else {\n            NETWORKMODULECALL(OnUserCTCPMessage(Message), m_pUser, m_pNetwork,\n                              this, &bContinue);\n        }\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a NOTICE to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(t_f(\n                    \"Your CTCP to {1} got lost, you are not connected to IRC!\")(\n                    Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnJoinMessage(CJoinMessage& Message) {\n    CString sChans = Message.GetTarget();\n    CString sKeys = Message.GetKey();\n\n    VCString vsChans;\n    sChans.Split(\",\", vsChans, false);\n    sChans.clear();\n\n    VCString vsKeys;\n    sKeys.Split(\",\", vsKeys, true);\n    sKeys.clear();\n\n    for (unsigned int a = 0; a < vsChans.size(); a++) {\n        Message.SetTarget(vsChans[a]);\n        Message.SetKey((a < vsKeys.size()) ? vsKeys[a] : \"\");\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(vsChans[a]));\n        }\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserJoinMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        CString sChannel = Message.GetTarget();\n        CString sKey = Message.GetKey();\n\n        if (m_pNetwork) {\n            CChan* pChan = m_pNetwork->FindChan(sChannel);\n            if (pChan) {\n                if (pChan->IsDetached())\n                    pChan->AttachUser(this);\n                else\n                    pChan->JoinUser(sKey);\n                continue;\n            } else if (!sChannel.empty()) {\n                pChan = new CChan(sChannel, m_pNetwork, false);\n                if (m_pNetwork->AddChan(pChan)) {\n                    pChan->SetKey(sKey);\n                }\n            }\n        }\n\n        if (!sChannel.empty()) {\n            sChans += (sChans.empty()) ? sChannel : CString(\",\" + sChannel);\n\n            if (!vsKeys.empty()) {\n                sKeys += (sKeys.empty()) ? sKey : CString(\",\" + sKey);\n            }\n        }\n    }\n\n    Message.SetTarget(sChans);\n    Message.SetKey(sKeys);\n\n    return sChans.empty();\n}\n\nbool CClient::OnModeMessage(CModeMessage& Message) {\n    CString sTarget = Message.GetTarget();\n\n    if (m_pNetwork && m_pNetwork->IsChan(sTarget) && !Message.HasModes()) {\n        // If we are on that channel and already received a\n        // /mode reply from the server, we can answer this\n        // request ourself.\n\n        CChan* pChan = m_pNetwork->FindChan(sTarget);\n        if (pChan && pChan->IsOn() && !pChan->GetModeString().empty()) {\n            PutClient(\":\" + m_pNetwork->GetIRCServer() + \" 324 \" + GetNick() +\n                      \" \" + sTarget + \" \" + pChan->GetModeString());\n            if (pChan->GetCreationDate() > 0) {\n                PutClient(\":\" + m_pNetwork->GetIRCServer() + \" 329 \" +\n                          GetNick() + \" \" + sTarget + \" \" +\n                          CString(pChan->GetCreationDate()));\n            }\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CClient::OnNoticeMessage(CNoticeMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (!sTarget.Equals(\"status\")) {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModNotice(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserNoticeMessage(Message), m_pUser, m_pNetwork,\n                          this, &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a NOTICE to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your notice to {1} got lost, you are not connected to \"\n                        \"IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnPartMessage(CPartMessage& Message) {\n    CString sChans = Message.GetTarget();\n\n    VCString vsChans;\n    sChans.Split(\",\", vsChans, false);\n    sChans.clear();\n\n    for (CString& sChan : vsChans) {\n        bool bContinue = false;\n        Message.SetTarget(sChan);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sChan));\n        }\n        NETWORKMODULECALL(OnUserPartMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        sChan = Message.GetTarget();\n\n        CChan* pChan = m_pNetwork ? m_pNetwork->FindChan(sChan) : nullptr;\n\n        if (pChan && !pChan->IsOn()) {\n            PutStatusNotice(t_f(\"Removing channel {1}\")(sChan));\n            m_pNetwork->DelChan(sChan);\n        } else {\n            sChans += (sChans.empty()) ? sChan : CString(\",\" + sChan);\n        }\n    }\n\n    if (sChans.empty()) {\n        return true;\n    }\n\n    Message.SetTarget(sChans);\n\n    return false;\n}\n\nbool CClient::OnPingMessage(CMessage& Message) {\n    // All PONGs are generated by ZNC. We will still forward this to\n    // the ircd, but all PONGs from irc will be blocked.\n    if (!Message.GetParams().empty())\n        PutClient(\":irc.znc.in PONG irc.znc.in \" + Message.GetParamsColon(0));\n    else\n        PutClient(\":irc.znc.in PONG irc.znc.in\");\n    return false;\n}\n\nbool CClient::OnPongMessage(CMessage& Message) {\n    // Block PONGs, we already responded to the pings\n    return true;\n}\n\nbool CClient::OnQuitMessage(CQuitMessage& Message) {\n    bool bReturn = false;\n    NETWORKMODULECALL(OnUserQuitMessage(Message), m_pUser, m_pNetwork, this,\n                      &bReturn);\n    if (!bReturn) {\n        Close(Csock::CLT_AFTERWRITE);  // Treat a client quit as a detach\n    }\n    // Don't forward this msg.  We don't want the client getting us\n    // disconnected.\n    return true;\n}\n\nbool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            EchoMessage(Message);\n\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnTopicMessage(CTopicMessage& Message) {\n    bool bReturn = false;\n    CString sChan = Message.GetTarget();\n    CString sTopic = Message.GetTopic();\n    if (m_pNetwork) {\n        // May be nullptr.\n        Message.SetChan(m_pNetwork->FindChan(sChan));\n    }\n\n    if (!sTopic.empty()) {\n        NETWORKMODULECALL(OnUserTopicMessage(Message), m_pUser, m_pNetwork,\n                          this, &bReturn);\n    } else {\n        NETWORKMODULECALL(OnUserTopicRequest(sChan), m_pUser, m_pNetwork, this,\n                          &bReturn);\n        Message.SetTarget(sChan);\n    }\n\n    return bReturn;\n}\n\nbool CClient::OnOtherMessage(CMessage& Message) {\n    const CString& sCommand = Message.GetCommand();\n\n    if (sCommand.Equals(\"ZNC\")) {\n        CString sTarget = Message.GetParam(0);\n        CString sModCommand;\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            sModCommand = Message.GetParamsColon(1);\n        } else {\n            sTarget = \"status\";\n            sModCommand = Message.GetParamsColon(0);\n        }\n\n        if (sTarget.Equals(\"status\")) {\n            if (sModCommand.empty())\n                PutStatus(t_s(\"Hello. How may I help you?\"));\n            else\n                UserCommand(sModCommand);\n        } else {\n            if (sModCommand.empty())\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        PutModule(t_s(\"Hello. How may I help you?\")))\n            else\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(sModCommand))\n        }\n        return true;\n    } else if (sCommand.Equals(\"ATTACH\")) {\n        if (!m_pNetwork) {\n            return true;\n        }\n\n        CString sPatterns = Message.GetParamsColon(0);\n\n        if (sPatterns.empty()) {\n            PutStatusNotice(t_s(\"Usage: /attach <#chans>\"));\n            return true;\n        }\n\n        set<CChan*> sChans = MatchChans(sPatterns);\n        unsigned int uAttachedChans = AttachChans(sChans);\n\n        PutStatusNotice(t_p(\"There was {1} channel matching [{2}]\",\n                            \"There were {1} channels matching [{2}]\",\n                            sChans.size())(sChans.size(), sPatterns));\n        PutStatusNotice(t_p(\"Attached {1} channel\", \"Attached {1} channels\",\n                            uAttachedChans)(uAttachedChans));\n\n        return true;\n    } else if (sCommand.Equals(\"DETACH\")) {\n        if (!m_pNetwork) {\n            return true;\n        }\n\n        CString sPatterns = Message.GetParamsColon(0);\n\n        if (sPatterns.empty()) {\n            PutStatusNotice(t_s(\"Usage: /detach <#chans>\"));\n            return true;\n        }\n\n        set<CChan*> sChans = MatchChans(sPatterns);\n        unsigned int uDetached = DetachChans(sChans);\n\n        PutStatusNotice(t_p(\"There was {1} channel matching [{2}]\",\n                            \"There were {1} channels matching [{2}]\",\n                            sChans.size())(sChans.size(), sPatterns));\n        PutStatusNotice(t_p(\"Detached {1} channel\", \"Detached {1} channels\",\n                            uDetached)(uDetached));\n\n        return true;\n    } else if (sCommand.Equals(\"PROTOCTL\")) {\n        for (const CString& sParam : Message.GetParams()) {\n            if (sParam == \"NAMESX\") {\n                m_bNamesx = true;\n            } else if (sParam == \"UHNAMES\") {\n                m_bUHNames = true;\n            }\n        }\n        return true;  // If the server understands it, we already enabled namesx\n                      // / uhnames\n    }\n\n    return false;\n}\n", "/*\n * Copyright (C) 2004-2020 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <gmock/gmock.h>\n\n#include \"znctest.h\"\n\nusing testing::HasSubstr;\n\nnamespace znc_inttest {\nnamespace {\n\nTEST(Config, AlreadyExists) {\n    QTemporaryDir dir;\n    WriteConfig(dir.path());\n    Process p(ZNC_BIN_DIR \"/znc\", QStringList() << \"--debug\"\n                                                << \"--datadir\" << dir.path()\n                                                << \"--makeconf\");\n    p.ReadUntil(\"already exists\");\n    p.CanDie();\n}\n\nTEST_F(ZNCTest, Connect) {\n    auto znc = Run();\n\n    auto ircd = ConnectIRCd();\n    ircd.ReadUntil(\"CAP LS\");\n\n    auto client = ConnectClient();\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user/test x x :x\");\n    client.ReadUntil(\"Welcome\");\n    client.Close();\n\n    client = ConnectClient();\n    client.Write(\"PASS :user:hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER u x x x\");\n    client.ReadUntil(\"Welcome\");\n    client.Close();\n\n    client = ConnectClient();\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user x x x\");\n    client.ReadUntil(\"Configure your client to send a server password\");\n    client.Close();\n\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.ReadUntil(\"WHO\");\n}\n\nTEST_F(ZNCTest, Channel) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n\n    auto client = LoginClient();\n    client.ReadUntil(\"Welcome\");\n    client.Write(\"JOIN #znc\");\n    client.Close();\n\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.ReadUntil(\"JOIN #znc\");\n    ircd.Write(\":nick JOIN :#znc\");\n    ircd.Write(\":server 353 nick #znc :nick\");\n    ircd.Write(\":server 366 nick #znc :End of /NAMES list\");\n    ircd.Write(\":server PING :1\");\n    ircd.ReadUntil(\"PONG 1\");\n\n    client = LoginClient();\n    client.ReadUntil(\":nick JOIN :#znc\");\n}\n\nTEST_F(ZNCTest, HTTP) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto reply = HttpGet(QNetworkRequest(QUrl(\"http://127.0.0.1:12345/\")));\n    EXPECT_THAT(reply->rawHeader(\"Server\").toStdString(), HasSubstr(\"ZNC\"));\n}\n\nTEST_F(ZNCTest, FixCVE20149403) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":server 005 nick CHANTYPES=# :supports\");\n    ircd.Write(\":server PING :1\");\n    ircd.ReadUntil(\"PONG 1\");\n\n    QNetworkRequest request;\n    request.setRawHeader(\"Authorization\",\n                         \"Basic \" + QByteArray(\"user:hunter2\").toBase64());\n    request.setUrl(QUrl(\"http://127.0.0.1:12345/mods/global/webadmin/addchan\"));\n    HttpPost(request, {\n                          {\"user\", \"user\"},\n                          {\"network\", \"test\"},\n                          {\"submitted\", \"1\"},\n                          {\"name\", \"znc\"},\n                          {\"enabled\", \"1\"},\n                      });\n    EXPECT_THAT(HttpPost(request,\n                         {\n                             {\"user\", \"user\"},\n                             {\"network\", \"test\"},\n                             {\"submitted\", \"1\"},\n                             {\"name\", \"znc\"},\n                             {\"enabled\", \"1\"},\n                         })\n                    ->readAll()\n                    .toStdString(),\n                HasSubstr(\"Channel [#znc] already exists\"));\n}\n\nTEST_F(ZNCTest, FixFixOfCVE20149403) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":nick JOIN @#znc\");\n    ircd.ReadUntil(\"MODE @#znc\");\n    ircd.Write(\":server 005 nick STATUSMSG=@ :supports\");\n    ircd.Write(\":server PING :12345\");\n    ircd.ReadUntil(\"PONG 12345\");\n\n    QNetworkRequest request;\n    request.setRawHeader(\"Authorization\",\n                         \"Basic \" + QByteArray(\"user:hunter2\").toBase64());\n    request.setUrl(QUrl(\"http://127.0.0.1:12345/mods/global/webadmin/addchan\"));\n    auto reply = HttpPost(request, {\n                                       {\"user\", \"user\"},\n                                       {\"network\", \"test\"},\n                                       {\"submitted\", \"1\"},\n                                       {\"name\", \"@#znc\"},\n                                       {\"enabled\", \"1\"},\n                                   });\n    EXPECT_THAT(reply->readAll().toStdString(),\n                HasSubstr(\"Could not add channel [@#znc]\"));\n}\n\nTEST_F(ZNCTest, InvalidConfigInChan) {\n    QFile conf(m_dir.path() + \"/configs/znc.conf\");\n    ASSERT_TRUE(conf.open(QIODevice::Append | QIODevice::Text));\n    QTextStream out(&conf);\n    out << R\"(\n        <User foo>\n            <Network bar>\n                <Chan #baz>\n                    Invalid = Line\n                </Chan>\n            </Network>\n        </User>\n    )\";\n    out.flush();\n    auto znc = Run();\n    znc->ShouldFinishItself(1);\n}\nTEST_F(ZNCTest, Encoding) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    ircd.Write(\":server 001 nick :hello\");\n    // legacy\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xE6world\");\n    client.ReadUntil(\"Hello\\xE6world\");\n    client.Write(\"PRIVMSG *controlpanel :SetNetwork Encoding $me $net UTF-8\");\n    client.ReadUntil(\"Encoding = UTF-8\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xE6world\");\n    client.ReadUntil(\"Hello\\xEF\\xBF\\xBDworld\");\n    client.Write(\n        \"PRIVMSG *controlpanel :SetNetwork Encoding $me $net ^CP-1251\");\n    client.ReadUntil(\"Encoding = ^CP-1251\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xE6world\");\n    client.ReadUntil(\"Hello\\xD0\\xB6world\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xD0\\xB6world\");\n    client.ReadUntil(\"Hello\\xD0\\xB6world\");\n}\n\nTEST_F(ZNCTest, BuildMod) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    QTemporaryDir srcd;\n    QDir srcdir(srcd.path());\n    QFile file(srcdir.filePath(\"testmod.cpp\"));\n    ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));\n    QTextStream out(&file);\n    out << R\"(\n        #include <znc/Modules.h>\n        class TestModule : public CModule {\n          public:\n            MODCONSTRUCTOR(TestModule) {}\n            void OnModCommand(const CString& sLine) override {\n                PutModule(\"Lorem ipsum\");\n            }\n        };\n        MODULEDEFS(TestModule, \"Test\")\n    )\";\n    file.close();\n    QDir dir(m_dir.path());\n    EXPECT_TRUE(dir.mkdir(\"modules\"));\n    EXPECT_TRUE(dir.cd(\"modules\"));\n    {\n        Process p(ZNC_BIN_DIR \"/znc-buildmod\",\n                  QStringList() << srcdir.filePath(\"file-not-found.cpp\"),\n                  [&](QProcess* proc) {\n                      proc->setWorkingDirectory(dir.absolutePath());\n                      proc->setProcessChannelMode(QProcess::ForwardedChannels);\n                  });\n        p.ShouldFinishItself(1);\n        p.ShouldFinishInSec(300);\n    }\n    {\n        Process p(ZNC_BIN_DIR \"/znc-buildmod\",\n                  QStringList() << srcdir.filePath(\"testmod.cpp\"),\n                  [&](QProcess* proc) {\n                      proc->setWorkingDirectory(dir.absolutePath());\n                      proc->setProcessChannelMode(QProcess::ForwardedChannels);\n                  });\n        p.ShouldFinishItself();\n        p.ShouldFinishInSec(300);\n    }\n    client.Write(\"znc loadmod testmod\");\n    client.Write(\"PRIVMSG *testmod :hi\");\n    client.ReadUntil(\"Lorem ipsum\");\n}\n\nTEST_F(ZNCTest, AwayNotify) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = ConnectClient();\n    client.Write(\"CAP LS\");\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user/test x x :x\");\n    QByteArray cap_ls;\n    client.ReadUntilAndGet(\" LS :\", cap_ls);\n    ASSERT_THAT(cap_ls.toStdString(),\n                AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n    client.Write(\"CAP REQ :cap-notify\");\n    client.ReadUntil(\"ACK :cap-notify\");\n    client.Write(\"CAP END\");\n    client.ReadUntil(\" 001 \");\n    ircd.ReadUntil(\"USER\");\n    ircd.Write(\"CAP user LS :away-notify\");\n    ircd.ReadUntil(\"CAP REQ :away-notify\");\n    ircd.Write(\"CAP user ACK :away-notify\");\n    ircd.ReadUntil(\"CAP END\");\n    ircd.Write(\":server 001 user :welcome\");\n    client.ReadUntil(\"CAP user NEW :away-notify\");\n    client.Write(\"CAP REQ :away-notify\");\n    client.ReadUntil(\"ACK :away-notify\");\n    ircd.Write(\":x!y@z AWAY :reason\");\n    client.ReadUntil(\":x!y@z AWAY :reason\");\n    ircd.Close();\n    client.ReadUntil(\"DEL :away-notify\");\n    // This test often fails on macos due to ZNC process not finishing.\n    // No idea why. Let's try to shutdown it more explicitly...\n    client.Write(\"znc shutdown\");\n}\n\nTEST_F(ZNCTest, JoinKey) {\n    QFile conf(m_dir.path() + \"/configs/znc.conf\");\n    ASSERT_TRUE(conf.open(QIODevice::Append | QIODevice::Text));\n    QTextStream(&conf) << \"ServerThrottle = 1\\n\";\n    auto znc = Run();\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    ircd.Write(\":server 001 nick :Hello\");\n    client.Write(\"JOIN #znc secret\");\n    ircd.ReadUntil(\"JOIN #znc secret\");\n    ircd.Write(\":nick JOIN :#znc\");\n    client.ReadUntil(\"JOIN :#znc\");\n    ircd.Close();\n\n    ircd = ConnectIRCd();\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.ReadUntil(\"JOIN #znc secret\");\n}\n\nTEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}\n\n}  // namespace\n}  // namespace znc_inttest\n"], "fixing_code": ["/*\n * Copyright (C) 2004-2020 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/Client.h>\n#include <znc/Chan.h>\n#include <znc/IRCSock.h>\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/Query.h>\n\nusing std::set;\nusing std::map;\nusing std::vector;\n\n#define CALLMOD(MOD, CLIENT, USER, NETWORK, FUNC)                             \\\n    {                                                                         \\\n        CModule* pModule = nullptr;                                           \\\n        if (NETWORK && (pModule = (NETWORK)->GetModules().FindModule(MOD))) { \\\n            try {                                                             \\\n                CClient* pOldClient = pModule->GetClient();                   \\\n                pModule->SetClient(CLIENT);                                   \\\n                pModule->FUNC;                                                \\\n                pModule->SetClient(pOldClient);                               \\\n            } catch (const CModule::EModException& e) {                       \\\n                if (e == CModule::UNLOAD) {                                   \\\n                    (NETWORK)->GetModules().UnloadModule(MOD);                \\\n                }                                                             \\\n            }                                                                 \\\n        } else if ((pModule = (USER)->GetModules().FindModule(MOD))) {        \\\n            try {                                                             \\\n                CClient* pOldClient = pModule->GetClient();                   \\\n                CIRCNetwork* pOldNetwork = pModule->GetNetwork();             \\\n                pModule->SetClient(CLIENT);                                   \\\n                pModule->SetNetwork(NETWORK);                                 \\\n                pModule->FUNC;                                                \\\n                pModule->SetClient(pOldClient);                               \\\n                pModule->SetNetwork(pOldNetwork);                             \\\n            } catch (const CModule::EModException& e) {                       \\\n                if (e == CModule::UNLOAD) {                                   \\\n                    (USER)->GetModules().UnloadModule(MOD);                   \\\n                }                                                             \\\n            }                                                                 \\\n        } else if ((pModule = CZNC::Get().GetModules().FindModule(MOD))) {    \\\n            try {                                                             \\\n                CClient* pOldClient = pModule->GetClient();                   \\\n                CIRCNetwork* pOldNetwork = pModule->GetNetwork();             \\\n                CUser* pOldUser = pModule->GetUser();                         \\\n                pModule->SetClient(CLIENT);                                   \\\n                pModule->SetNetwork(NETWORK);                                 \\\n                pModule->SetUser(USER);                                       \\\n                pModule->FUNC;                                                \\\n                pModule->SetClient(pOldClient);                               \\\n                pModule->SetNetwork(pOldNetwork);                             \\\n                pModule->SetUser(pOldUser);                                   \\\n            } catch (const CModule::EModException& e) {                       \\\n                if (e == CModule::UNLOAD) {                                   \\\n                    CZNC::Get().GetModules().UnloadModule(MOD);               \\\n                }                                                             \\\n            }                                                                 \\\n        } else {                                                              \\\n            PutStatus(t_f(\"No such module {1}\")(MOD));                        \\\n        }                                                                     \\\n    }\n\nCClient::~CClient() {\n    if (m_spAuth) {\n        CClientAuth* pAuth = (CClientAuth*)&(*m_spAuth);\n        pAuth->Invalidate();\n    }\n    if (m_pUser != nullptr) {\n        m_pUser->AddBytesRead(GetBytesRead());\n        m_pUser->AddBytesWritten(GetBytesWritten());\n    }\n}\n\nvoid CClient::SendRequiredPasswordNotice() {\n    PutClient(\":irc.znc.in 464 \" + GetNick() + \" :Password required\");\n    PutClient(\n        \":irc.znc.in NOTICE \" + GetNick() + \" :*** \"\n        \"You need to send your password. \"\n        \"Configure your client to send a server password.\");\n    PutClient(\n        \":irc.znc.in NOTICE \" + GetNick() + \" :*** \"\n        \"To connect now, you can use /quote PASS <username>:<password>, \"\n        \"or /quote PASS <username>/<network>:<password> to connect to a \"\n        \"specific network.\");\n}\n\nvoid CClient::ReadLine(const CString& sData) {\n    CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : \"\");\n    CString sLine = sData;\n\n    sLine.Replace(\"\\n\", \"\");\n    sLine.Replace(\"\\r\", \"\");\n\n    DEBUG(\"(\" << GetFullName() << \") CLI -> ZNC [\"\n        << CDebug::Filter(sLine) << \"]\");\n\n    bool bReturn = false;\n    if (IsAttached()) {\n        NETWORKMODULECALL(OnUserRaw(sLine), m_pUser, m_pNetwork, this,\n                          &bReturn);\n    } else {\n        GLOBALMODULECALL(OnUnknownUserRaw(this, sLine), &bReturn);\n    }\n    if (bReturn) return;\n\n    CMessage Message(sLine);\n    Message.SetClient(this);\n\n    if (IsAttached()) {\n        NETWORKMODULECALL(OnUserRawMessage(Message), m_pUser, m_pNetwork, this,\n                          &bReturn);\n    } else {\n        GLOBALMODULECALL(OnUnknownUserRawMessage(Message), &bReturn);\n    }\n    if (bReturn) return;\n\n    CString sCommand = Message.GetCommand();\n\n    if (!IsAttached()) {\n        // The following commands happen before authentication with ZNC\n        if (sCommand.Equals(\"PASS\")) {\n            m_bGotPass = true;\n\n            CString sAuthLine = Message.GetParam(0);\n            ParsePass(sAuthLine);\n\n            AuthUser();\n            // Don't forward this msg.  ZNC has already registered us.\n            return;\n        } else if (sCommand.Equals(\"NICK\")) {\n            CString sNick = Message.GetParam(0);\n\n            m_sNick = sNick;\n            m_bGotNick = true;\n\n            AuthUser();\n            // Don't forward this msg.  ZNC will handle nick changes until auth\n            // is complete\n            return;\n        } else if (sCommand.Equals(\"USER\")) {\n            CString sAuthLine = Message.GetParam(0);\n\n            if (m_sUser.empty() && !sAuthLine.empty()) {\n                ParseUser(sAuthLine);\n            }\n\n            m_bGotUser = true;\n            if (m_bGotPass) {\n                AuthUser();\n            } else if (!m_bInCap) {\n                SendRequiredPasswordNotice();\n            }\n\n            // Don't forward this msg.  ZNC has already registered us.\n            return;\n        }\n    }\n\n    if (Message.GetType() == CMessage::Type::Capability) {\n        HandleCap(Message);\n\n        // Don't let the client talk to the server directly about CAP,\n        // we don't want anything enabled that ZNC does not support.\n        return;\n    }\n\n    if (!m_pUser) {\n        // Only CAP, NICK, USER and PASS are allowed before login\n        return;\n    }\n\n    switch (Message.GetType()) {\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        default:\n            bReturn = OnOtherMessage(Message);\n            break;\n    }\n\n    if (bReturn) return;\n\n    PutIRC(Message.ToString(CMessage::ExcludePrefix | CMessage::ExcludeTags));\n}\n\nvoid CClient::SetNick(const CString& s) { m_sNick = s; }\n\nvoid CClient::SetNetwork(CIRCNetwork* pNetwork, bool bDisconnect,\n                         bool bReconnect) {\n    if (m_pNetwork) {\n        m_pNetwork->ClientDisconnected(this);\n\n        if (bDisconnect) {\n            ClearServerDependentCaps();\n            // Tell the client they are no longer in these channels.\n            const vector<CChan*>& vChans = m_pNetwork->GetChans();\n            for (const CChan* pChan : vChans) {\n                if (!(pChan->IsDetached())) {\n                    PutClient(\":\" + m_pNetwork->GetIRCNick().GetNickMask() +\n                              \" PART \" + pChan->GetName());\n                }\n            }\n        }\n    } else if (m_pUser) {\n        m_pUser->UserDisconnected(this);\n    }\n\n    m_pNetwork = pNetwork;\n\n    if (bReconnect) {\n        if (m_pNetwork) {\n            m_pNetwork->ClientConnected(this);\n        } else if (m_pUser) {\n            m_pUser->UserConnected(this);\n        }\n    }\n}\n\nconst vector<CClient*>& CClient::GetClients() const {\n    if (m_pNetwork) {\n        return m_pNetwork->GetClients();\n    }\n\n    return m_pUser->GetUserClients();\n}\n\nconst CIRCSock* CClient::GetIRCSock() const {\n    if (m_pNetwork) {\n        return m_pNetwork->GetIRCSock();\n    }\n\n    return nullptr;\n}\n\nCIRCSock* CClient::GetIRCSock() {\n    if (m_pNetwork) {\n        return m_pNetwork->GetIRCSock();\n    }\n\n    return nullptr;\n}\n\nvoid CClient::StatusCTCP(const CString& sLine) {\n    CString sCommand = sLine.Token(0);\n\n    if (sCommand.Equals(\"PING\")) {\n        PutStatusNotice(\"\\001PING \" + sLine.Token(1, true) + \"\\001\");\n    } else if (sCommand.Equals(\"VERSION\")) {\n        PutStatusNotice(\"\\001VERSION \" + CZNC::GetTag() + \"\\001\");\n    }\n}\n\nbool CClient::SendMotd() {\n    const VCString& vsMotd = CZNC::Get().GetMotd();\n\n    if (!vsMotd.size()) {\n        return false;\n    }\n\n    for (const CString& sLine : vsMotd) {\n        if (m_pNetwork) {\n            PutStatusNotice(m_pNetwork->ExpandString(sLine));\n        } else {\n            PutStatusNotice(m_pUser->ExpandString(sLine));\n        }\n    }\n\n    return true;\n}\n\nvoid CClient::AuthUser() {\n    if (!m_bGotNick || !m_bGotUser || !m_bGotPass || m_bInCap || IsAttached())\n        return;\n\n    m_spAuth = std::make_shared<CClientAuth>(this, m_sUser, m_sPass);\n\n    CZNC::Get().AuthUser(m_spAuth);\n}\n\nCClientAuth::CClientAuth(CClient* pClient, const CString& sUsername,\n                         const CString& sPassword)\n    : CAuthBase(sUsername, sPassword, pClient), m_pClient(pClient) {}\n\nvoid CClientAuth::RefusedLogin(const CString& sReason) {\n    if (m_pClient) {\n        m_pClient->RefuseLogin(sReason);\n    }\n}\n\nCString CAuthBase::GetRemoteIP() const {\n    if (m_pSock) return m_pSock->GetRemoteIP();\n    return \"\";\n}\n\nvoid CAuthBase::Invalidate() { m_pSock = nullptr; }\n\nvoid CAuthBase::AcceptLogin(CUser& User) {\n    if (m_pSock) {\n        AcceptedLogin(User);\n        Invalidate();\n    }\n}\n\nvoid CAuthBase::RefuseLogin(const CString& sReason) {\n    if (!m_pSock) return;\n\n    CUser* pUser = CZNC::Get().FindUser(GetUsername());\n\n    // If the username is valid, notify that user that someone tried to\n    // login. Use sReason because there are other reasons than \"wrong\n    // password\" for a login to be rejected (e.g. fail2ban).\n    if (pUser) {\n        pUser->PutStatusNotice(t_f(\n            \"A client from {1} attempted to login as you, but was rejected: \"\n            \"{2}\")(GetRemoteIP(), sReason));\n    }\n\n    GLOBALMODULECALL(OnFailedLogin(GetUsername(), GetRemoteIP()), NOTHING);\n    RefusedLogin(sReason);\n    Invalidate();\n}\n\nvoid CClient::RefuseLogin(const CString& sReason) {\n    PutStatus(\"Bad username and/or password.\");\n    PutClient(\":irc.znc.in 464 \" + GetNick() + \" :\" + sReason);\n    Close(Csock::CLT_AFTERWRITE);\n}\n\nvoid CClientAuth::AcceptedLogin(CUser& User) {\n    if (m_pClient) {\n        m_pClient->AcceptLogin(User);\n    }\n}\n\nvoid CClient::AcceptLogin(CUser& User) {\n    m_sPass = \"\";\n    m_pUser = &User;\n\n    // Set our proper timeout and set back our proper timeout mode\n    // (constructor set a different timeout and mode)\n    SetTimeout(User.GetNoTrafficTimeout(), TMO_READ);\n\n    SetSockName(\"USR::\" + m_pUser->GetUsername());\n    SetEncoding(m_pUser->GetClientEncoding());\n\n    if (!m_sNetwork.empty()) {\n        m_pNetwork = m_pUser->FindNetwork(m_sNetwork);\n        if (!m_pNetwork) {\n            PutStatus(t_f(\"Network {1} doesn't exist.\")(m_sNetwork));\n        }\n    } else if (!m_pUser->GetNetworks().empty()) {\n        // If a user didn't supply a network, and they have a network called\n        // \"default\" then automatically use this network.\n        m_pNetwork = m_pUser->FindNetwork(\"default\");\n        // If no \"default\" network, try \"user\" network. It's for compatibility\n        // with early network stuff in ZNC, which converted old configs to\n        // \"user\" network.\n        if (!m_pNetwork) m_pNetwork = m_pUser->FindNetwork(\"user\");\n        // Otherwise, just try any network of the user.\n        if (!m_pNetwork) m_pNetwork = *m_pUser->GetNetworks().begin();\n        if (m_pNetwork && m_pUser->GetNetworks().size() > 1) {\n            PutStatusNotice(\n                t_s(\"You have several networks configured, but no network was \"\n                    \"specified for the connection.\"));\n            PutStatusNotice(\n                t_f(\"Selecting network {1}. To see list of all configured \"\n                    \"networks, use /znc ListNetworks\")(m_pNetwork->GetName()));\n            PutStatusNotice(t_f(\n                \"If you want to choose another network, use /znc JumpNetwork \"\n                \"<network>, or connect to ZNC with username {1}/<network> \"\n                \"(instead of just {1})\")(m_pUser->GetUsername()));\n        }\n    } else {\n        PutStatusNotice(\n            t_s(\"You have no networks configured. Use /znc AddNetwork \"\n                \"<network> to add one.\"));\n    }\n\n    SetNetwork(m_pNetwork, false);\n\n    SendMotd();\n\n    NETWORKMODULECALL(OnClientLogin(), m_pUser, m_pNetwork, this, NOTHING);\n}\n\nvoid CClient::Timeout() { PutClient(\"ERROR :\" + t_s(\"Closing link: Timeout\")); }\n\nvoid CClient::Connected() { DEBUG(GetSockName() << \" == Connected();\"); }\n\nvoid CClient::ConnectionRefused() {\n    DEBUG(GetSockName() << \" == ConnectionRefused()\");\n}\n\nvoid CClient::Disconnected() {\n    DEBUG(GetSockName() << \" == Disconnected()\");\n    CIRCNetwork* pNetwork = m_pNetwork;\n    SetNetwork(nullptr, false, false);\n\n    if (m_pUser) {\n        NETWORKMODULECALL(OnClientDisconnect(), m_pUser, pNetwork, this,\n                          NOTHING);\n    }\n}\n\nvoid CClient::ReachedMaxBuffer() {\n    DEBUG(GetSockName() << \" == ReachedMaxBuffer()\");\n    if (IsAttached()) {\n        PutClient(\"ERROR :\" + t_s(\"Closing link: Too long raw line\"));\n    }\n    Close();\n}\n\nvoid CClient::BouncedOff() {\n    PutStatusNotice(\n        t_s(\"You are being disconnected because another user just \"\n            \"authenticated as you.\"));\n    Close(Csock::CLT_AFTERWRITE);\n}\n\nvoid CClient::PutIRC(const CString& sLine) {\n    if (m_pNetwork) {\n        m_pNetwork->PutIRC(sLine);\n    }\n}\n\nCString CClient::GetFullName() const {\n    if (!m_pUser) return GetRemoteIP();\n    CString sFullName = m_pUser->GetUsername();\n    if (!m_sIdentifier.empty()) sFullName += \"@\" + m_sIdentifier;\n    if (m_pNetwork) sFullName += \"/\" + m_pNetwork->GetName();\n    return sFullName;\n}\n\nvoid CClient::PutClient(const CString& sLine) {\n    PutClient(CMessage(sLine));\n}\n\nbool CClient::PutClient(const CMessage& Message) {\n    if (!m_bAwayNotify && Message.GetType() == CMessage::Type::Away) {\n        return false;\n    } else if (!m_bAccountNotify &&\n               Message.GetType() == CMessage::Type::Account) {\n        return false;\n    }\n\n    CMessage Msg(Message);\n\n    const CIRCSock* pIRCSock = GetIRCSock();\n    if (pIRCSock) {\n        if (Msg.GetType() == CMessage::Type::Numeric) {\n            unsigned int uCode = Msg.As<CNumericMessage>().GetCode();\n\n            if (uCode == 352) {  // RPL_WHOREPLY\n                if (!m_bNamesx && pIRCSock->HasNamesx()) {\n                    // The server has NAMESX, but the client doesn't, so we need\n                    // to remove extra prefixes\n                    CString sNick = Msg.GetParam(6);\n                    if (sNick.size() > 1 && pIRCSock->IsPermChar(sNick[1])) {\n                        CString sNewNick = sNick;\n                        size_t pos =\n                            sNick.find_first_not_of(pIRCSock->GetPerms());\n                        if (pos >= 2 && pos != CString::npos) {\n                            sNewNick = sNick[0] + sNick.substr(pos);\n                        }\n                        Msg.SetParam(6, sNewNick);\n                    }\n                }\n            } else if (uCode == 353) {  // RPL_NAMES\n                if ((!m_bNamesx && pIRCSock->HasNamesx()) ||\n                    (!m_bUHNames && pIRCSock->HasUHNames())) {\n                    // The server has either UHNAMES or NAMESX, but the client\n                    // is missing either or both\n                    CString sNicks = Msg.GetParam(3);\n                    VCString vsNicks;\n                    sNicks.Split(\" \", vsNicks, false);\n\n                    for (CString& sNick : vsNicks) {\n                        if (sNick.empty()) break;\n\n                        if (!m_bNamesx && pIRCSock->HasNamesx() &&\n                            pIRCSock->IsPermChar(sNick[0])) {\n                            // The server has NAMESX, but the client doesn't, so\n                            // we just use the first perm char\n                            size_t pos =\n                                sNick.find_first_not_of(pIRCSock->GetPerms());\n                            if (pos >= 2 && pos != CString::npos) {\n                                sNick = sNick[0] + sNick.substr(pos);\n                            }\n                        }\n\n                        if (!m_bUHNames && pIRCSock->HasUHNames()) {\n                            // The server has UHNAMES, but the client doesn't,\n                            // so we strip away ident and host\n                            sNick = sNick.Token(0, false, \"!\");\n                        }\n                    }\n\n                    Msg.SetParam(\n                        3, CString(\" \").Join(vsNicks.begin(), vsNicks.end()));\n                }\n            }\n        } else if (Msg.GetType() == CMessage::Type::Join) {\n            if (!m_bExtendedJoin && pIRCSock->HasExtendedJoin()) {\n                Msg.SetParams({Msg.As<CJoinMessage>().GetTarget()});\n            }\n        }\n    }\n\n    MCString mssTags;\n\n    for (const auto& it : Msg.GetTags()) {\n        if (IsTagEnabled(it.first)) {\n            mssTags[it.first] = it.second;\n        }\n    }\n\n    if (HasServerTime()) {\n        // If the server didn't set the time tag, manually set it\n        mssTags.emplace(\"time\", CUtils::FormatServerTime(Msg.GetTime()));\n    }\n\n    Msg.SetTags(mssTags);\n    Msg.SetClient(this);\n    Msg.SetNetwork(m_pNetwork);\n\n    bool bReturn = false;\n    NETWORKMODULECALL(OnSendToClientMessage(Msg), m_pUser, m_pNetwork, this,\n                      &bReturn);\n    if (bReturn) return false;\n\n    return PutClientRaw(Msg.ToString());\n}\n\nbool CClient::PutClientRaw(const CString& sLine) {\n    CString sCopy = sLine;\n    bool bReturn = false;\n    NETWORKMODULECALL(OnSendToClient(sCopy, *this), m_pUser, m_pNetwork, this,\n                      &bReturn);\n    if (bReturn) return false;\n\n    DEBUG(\"(\" << GetFullName() << \") ZNC -> CLI [\"\n        << CDebug::Filter(sCopy) << \"]\");\n    Write(sCopy + \"\\r\\n\");\n    return true;\n}\n\nvoid CClient::PutStatusNotice(const CString& sLine) {\n    PutModNotice(\"status\", sLine);\n}\n\nunsigned int CClient::PutStatus(const CTable& table) {\n    unsigned int idx = 0;\n    CString sLine;\n    while (table.GetLine(idx++, sLine)) PutStatus(sLine);\n    return idx - 1;\n}\n\nvoid CClient::PutStatus(const CString& sLine) { PutModule(\"status\", sLine); }\n\nvoid CClient::PutModNotice(const CString& sModule, const CString& sLine) {\n    if (!m_pUser) {\n        return;\n    }\n\n    DEBUG(\"(\" << GetFullName()\n              << \") ZNC -> CLI [:\" + m_pUser->GetStatusPrefix() +\n                     ((sModule.empty()) ? \"status\" : sModule) +\n                     \"!znc@znc.in NOTICE \" << GetNick() << \" :\" << sLine\n              << \"]\");\n    Write(\":\" + m_pUser->GetStatusPrefix() +\n          ((sModule.empty()) ? \"status\" : sModule) + \"!znc@znc.in NOTICE \" +\n          GetNick() + \" :\" + sLine + \"\\r\\n\");\n}\n\nvoid CClient::PutModule(const CString& sModule, const CString& sLine) {\n    if (!m_pUser) {\n        return;\n    }\n\n    DEBUG(\"(\" << GetFullName()\n              << \") ZNC -> CLI [:\" + m_pUser->GetStatusPrefix() +\n                     ((sModule.empty()) ? \"status\" : sModule) +\n                     \"!znc@znc.in PRIVMSG \" << GetNick() << \" :\" << sLine\n              << \"]\");\n\n    VCString vsLines;\n    sLine.Split(\"\\n\", vsLines);\n    for (const CString& s : vsLines) {\n        Write(\":\" + m_pUser->GetStatusPrefix() +\n              ((sModule.empty()) ? \"status\" : sModule) +\n              \"!znc@znc.in PRIVMSG \" + GetNick() + \" :\" + s + \"\\r\\n\");\n    }\n}\n\nCString CClient::GetNick(bool bAllowIRCNick) const {\n    CString sRet;\n\n    const CIRCSock* pSock = GetIRCSock();\n    if (bAllowIRCNick && pSock && pSock->IsAuthed()) {\n        sRet = pSock->GetNick();\n    }\n\n    return (sRet.empty()) ? m_sNick : sRet;\n}\n\nCString CClient::GetNickMask() const {\n    if (GetIRCSock() && GetIRCSock()->IsAuthed()) {\n        return GetIRCSock()->GetNickMask();\n    }\n\n    CString sHost =\n        m_pNetwork ? m_pNetwork->GetBindHost() : m_pUser->GetBindHost();\n    if (sHost.empty()) {\n        sHost = \"irc.znc.in\";\n    }\n\n    return GetNick() + \"!\" +\n           (m_pNetwork ? m_pNetwork->GetIdent() : m_pUser->GetIdent()) + \"@\" +\n           sHost;\n}\n\nbool CClient::IsValidIdentifier(const CString& sIdentifier) {\n    // ^[-\\w]+$\n\n    if (sIdentifier.empty()) {\n        return false;\n    }\n\n    const char* p = sIdentifier.c_str();\n    while (*p) {\n        if (*p != '_' && *p != '-' && !isalnum(*p)) {\n            return false;\n        }\n\n        p++;\n    }\n\n    return true;\n}\n\nvoid CClient::RespondCap(const CString& sResponse) {\n    PutClient(\":irc.znc.in CAP \" + GetNick() + \" \" + sResponse);\n}\n\nvoid CClient::HandleCap(const CMessage& Message) {\n    CString sSubCmd = Message.GetParam(0);\n\n    if (sSubCmd.Equals(\"LS\")) {\n        SCString ssOfferCaps;\n        for (const auto& it : m_mCoreCaps) {\n            bool bServerDependent = std::get<0>(it.second);\n            if (!bServerDependent ||\n                m_ssServerDependentCaps.count(it.first) > 0)\n                ssOfferCaps.insert(it.first);\n        }\n        GLOBALMODULECALL(OnClientCapLs(this, ssOfferCaps), NOTHING);\n        CString sRes =\n            CString(\" \").Join(ssOfferCaps.begin(), ssOfferCaps.end());\n        RespondCap(\"LS :\" + sRes);\n        m_bInCap = true;\n        if (Message.GetParam(1).ToInt() >= 302) {\n            m_bCapNotify = true;\n        }\n    } else if (sSubCmd.Equals(\"END\")) {\n        m_bInCap = false;\n        if (!IsAttached()) {\n            if (!m_pUser && m_bGotUser && !m_bGotPass) {\n                SendRequiredPasswordNotice();\n            } else {\n                AuthUser();\n            }\n        }\n    } else if (sSubCmd.Equals(\"REQ\")) {\n        VCString vsTokens;\n        Message.GetParam(1).Split(\" \", vsTokens, false);\n\n        for (const CString& sToken : vsTokens) {\n            bool bVal = true;\n            CString sCap = sToken;\n            if (sCap.TrimPrefix(\"-\")) bVal = false;\n\n            bool bAccepted = false;\n            const auto& it = m_mCoreCaps.find(sCap);\n            if (m_mCoreCaps.end() != it) {\n                bool bServerDependent = std::get<0>(it->second);\n                bAccepted = !bServerDependent ||\n                            m_ssServerDependentCaps.count(sCap) > 0;\n            }\n            GLOBALMODULECALL(IsClientCapSupported(this, sCap, bVal),\n                             &bAccepted);\n\n            if (!bAccepted) {\n                // Some unsupported capability is requested\n                RespondCap(\"NAK :\" + Message.GetParam(1));\n                return;\n            }\n        }\n\n        // All is fine, we support what was requested\n        for (const CString& sToken : vsTokens) {\n            bool bVal = true;\n            CString sCap = sToken;\n            if (sCap.TrimPrefix(\"-\")) bVal = false;\n\n            auto handler_it = m_mCoreCaps.find(sCap);\n            if (m_mCoreCaps.end() != handler_it) {\n                const auto& handler = std::get<1>(handler_it->second);\n                handler(bVal);\n            }\n            GLOBALMODULECALL(OnClientCapRequest(this, sCap, bVal), NOTHING);\n\n            if (bVal) {\n                m_ssAcceptedCaps.insert(sCap);\n            } else {\n                m_ssAcceptedCaps.erase(sCap);\n            }\n        }\n\n        RespondCap(\"ACK :\" + Message.GetParam(1));\n    } else if (sSubCmd.Equals(\"LIST\")) {\n        CString sList =\n            CString(\" \").Join(m_ssAcceptedCaps.begin(), m_ssAcceptedCaps.end());\n        RespondCap(\"LIST :\" + sList);\n    } else {\n        PutClient(\":irc.znc.in 410 \" + GetNick() + \" \" + sSubCmd +\n                  \" :Invalid CAP subcommand\");\n    }\n}\n\nvoid CClient::ParsePass(const CString& sAuthLine) {\n    // [user[@identifier][/network]:]password\n\n    const size_t uColon = sAuthLine.find(\":\");\n    if (uColon != CString::npos) {\n        m_sPass = sAuthLine.substr(uColon + 1);\n\n        ParseUser(sAuthLine.substr(0, uColon));\n    } else {\n        m_sPass = sAuthLine;\n    }\n}\n\nvoid CClient::ParseUser(const CString& sAuthLine) {\n    // user[@identifier][/network]\n\n    const size_t uSlash = sAuthLine.rfind(\"/\");\n    if (uSlash != CString::npos) {\n        m_sNetwork = sAuthLine.substr(uSlash + 1);\n\n        ParseIdentifier(sAuthLine.substr(0, uSlash));\n    } else {\n        ParseIdentifier(sAuthLine);\n    }\n}\n\nvoid CClient::ParseIdentifier(const CString& sAuthLine) {\n    // user[@identifier]\n\n    const size_t uAt = sAuthLine.rfind(\"@\");\n    if (uAt != CString::npos) {\n        const CString sId = sAuthLine.substr(uAt + 1);\n\n        if (IsValidIdentifier(sId)) {\n            m_sIdentifier = sId;\n            m_sUser = sAuthLine.substr(0, uAt);\n        } else {\n            m_sUser = sAuthLine;\n        }\n    } else {\n        m_sUser = sAuthLine;\n    }\n}\n\nvoid CClient::SetTagSupport(const CString& sTag, bool bState) {\n    if (bState) {\n        m_ssSupportedTags.insert(sTag);\n    } else {\n        m_ssSupportedTags.erase(sTag);\n    }\n}\n\nvoid CClient::NotifyServerDependentCaps(const SCString& ssCaps) {\n    for (const CString& sCap : ssCaps) {\n        const auto& it = m_mCoreCaps.find(sCap);\n        if (m_mCoreCaps.end() != it) {\n            bool bServerDependent = std::get<0>(it->second);\n            if (bServerDependent) {\n                m_ssServerDependentCaps.insert(sCap);\n            }\n        }\n    }\n\n    if (HasCapNotify() && !m_ssServerDependentCaps.empty()) {\n        CString sCaps = CString(\" \").Join(m_ssServerDependentCaps.begin(),\n                                          m_ssServerDependentCaps.end());\n        PutClient(\":irc.znc.in CAP \" + GetNick() + \" NEW :\" + sCaps);\n    }\n}\n\nvoid CClient::ClearServerDependentCaps() {\n    if (HasCapNotify() && !m_ssServerDependentCaps.empty()) {\n        CString sCaps = CString(\" \").Join(m_ssServerDependentCaps.begin(),\n                                          m_ssServerDependentCaps.end());\n        PutClient(\":irc.znc.in CAP \" + GetNick() + \" DEL :\" + sCaps);\n\n        for (const CString& sCap : m_ssServerDependentCaps) {\n            const auto& it = m_mCoreCaps.find(sCap);\n            if (m_mCoreCaps.end() != it) {\n                const auto& handler = std::get<1>(it->second);\n                handler(false);\n            }\n        }\n    }\n\n    m_ssServerDependentCaps.clear();\n}\n\ntemplate <typename T>\nvoid CClient::AddBuffer(const T& Message) {\n    const CString sTarget = Message.GetTarget();\n\n    T Format;\n    Format.Clone(Message);\n    Format.SetNick(CNick(_NAMEDFMT(GetNickMask())));\n    Format.SetTarget(_NAMEDFMT(sTarget));\n    Format.SetText(\"{text}\");\n\n    CChan* pChan = m_pNetwork->FindChan(sTarget);\n    if (pChan) {\n        if (!pChan->AutoClearChanBuffer() || !m_pNetwork->IsUserOnline()) {\n            pChan->AddBuffer(Format, Message.GetText());\n        }\n    } else if (Message.GetType() != CMessage::Type::Notice) {\n        if (!m_pUser->AutoClearQueryBuffer() || !m_pNetwork->IsUserOnline()) {\n            CQuery* pQuery = m_pNetwork->AddQuery(sTarget);\n            if (pQuery) {\n                pQuery->AddBuffer(Format, Message.GetText());\n            }\n        }\n    }\n}\n\nvoid CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && ((m_pNetwork && m_pNetwork->IsChan(Message.GetParam(0))) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n\nset<CChan*> CClient::MatchChans(const CString& sPatterns) const {\n    VCString vsPatterns;\n    sPatterns.Replace_n(\",\", \" \")\n        .Split(\" \", vsPatterns, false, \"\", \"\", true, true);\n\n    set<CChan*> sChans;\n    for (const CString& sPattern : vsPatterns) {\n        vector<CChan*> vChans = m_pNetwork->FindChans(sPattern);\n        sChans.insert(vChans.begin(), vChans.end());\n    }\n    return sChans;\n}\n\nunsigned int CClient::AttachChans(const std::set<CChan*>& sChans) {\n    unsigned int uAttached = 0;\n    for (CChan* pChan : sChans) {\n        if (!pChan->IsDetached()) continue;\n        uAttached++;\n        pChan->AttachUser();\n    }\n    return uAttached;\n}\n\nunsigned int CClient::DetachChans(const std::set<CChan*>& sChans) {\n    unsigned int uDetached = 0;\n    for (CChan* pChan : sChans) {\n        if (pChan->IsDetached()) continue;\n        uDetached++;\n        pChan->DetachUser();\n    }\n    return uDetached;\n}\n\nbool CClient::OnActionMessage(CActionMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserActionMessage(Message), m_pUser, m_pNetwork,\n                          this, &bContinue);\n        if (bContinue) continue;\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnCTCPMessage(CCTCPMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    if (Message.IsReply()) {\n        CString sCTCP = Message.GetText();\n        if (sCTCP.Token(0) == \"VERSION\") {\n            // There are 2 different scenarios:\n            //\n            // a) CTCP reply for VERSION is not set.\n            // 1. ZNC receives CTCP VERSION from someone\n            // 2. ZNC forwards CTCP VERSION to client\n            // 3. Client replies with something\n            // 4. ZNC adds itself to the reply\n            // 5. ZNC sends the modified reply to whoever asked\n            //\n            // b) CTCP reply for VERSION is set.\n            // 1. ZNC receives CTCP VERSION from someone\n            // 2. ZNC replies with the configured reply (or just drops it if\n            //    empty), without forwarding anything to client\n            // 3. Client does not see any CTCP request, and does not reply\n            //\n            // So, if user doesn't want \"via ZNC\" in CTCP VERSION reply, they\n            // can set custom reply.\n            //\n            // See more bikeshedding at github issues #820 and #1012\n            Message.SetText(sCTCP + \" via \" + CZNC::GetTag(false));\n        }\n    }\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        bool bContinue = false;\n        if (Message.IsReply()) {\n            NETWORKMODULECALL(OnUserCTCPReplyMessage(Message), m_pUser,\n                              m_pNetwork, this, &bContinue);\n        } else {\n            NETWORKMODULECALL(OnUserCTCPMessage(Message), m_pUser, m_pNetwork,\n                              this, &bContinue);\n        }\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a NOTICE to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(t_f(\n                    \"Your CTCP to {1} got lost, you are not connected to IRC!\")(\n                    Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnJoinMessage(CJoinMessage& Message) {\n    CString sChans = Message.GetTarget();\n    CString sKeys = Message.GetKey();\n\n    VCString vsChans;\n    sChans.Split(\",\", vsChans, false);\n    sChans.clear();\n\n    VCString vsKeys;\n    sKeys.Split(\",\", vsKeys, true);\n    sKeys.clear();\n\n    for (unsigned int a = 0; a < vsChans.size(); a++) {\n        Message.SetTarget(vsChans[a]);\n        Message.SetKey((a < vsKeys.size()) ? vsKeys[a] : \"\");\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(vsChans[a]));\n        }\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserJoinMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        CString sChannel = Message.GetTarget();\n        CString sKey = Message.GetKey();\n\n        if (m_pNetwork) {\n            CChan* pChan = m_pNetwork->FindChan(sChannel);\n            if (pChan) {\n                if (pChan->IsDetached())\n                    pChan->AttachUser(this);\n                else\n                    pChan->JoinUser(sKey);\n                continue;\n            } else if (!sChannel.empty()) {\n                pChan = new CChan(sChannel, m_pNetwork, false);\n                if (m_pNetwork->AddChan(pChan)) {\n                    pChan->SetKey(sKey);\n                }\n            }\n        }\n\n        if (!sChannel.empty()) {\n            sChans += (sChans.empty()) ? sChannel : CString(\",\" + sChannel);\n\n            if (!vsKeys.empty()) {\n                sKeys += (sKeys.empty()) ? sKey : CString(\",\" + sKey);\n            }\n        }\n    }\n\n    Message.SetTarget(sChans);\n    Message.SetKey(sKeys);\n\n    return sChans.empty();\n}\n\nbool CClient::OnModeMessage(CModeMessage& Message) {\n    CString sTarget = Message.GetTarget();\n\n    if (m_pNetwork && m_pNetwork->IsChan(sTarget) && !Message.HasModes()) {\n        // If we are on that channel and already received a\n        // /mode reply from the server, we can answer this\n        // request ourself.\n\n        CChan* pChan = m_pNetwork->FindChan(sTarget);\n        if (pChan && pChan->IsOn() && !pChan->GetModeString().empty()) {\n            PutClient(\":\" + m_pNetwork->GetIRCServer() + \" 324 \" + GetNick() +\n                      \" \" + sTarget + \" \" + pChan->GetModeString());\n            if (pChan->GetCreationDate() > 0) {\n                PutClient(\":\" + m_pNetwork->GetIRCServer() + \" 329 \" +\n                          GetNick() + \" \" + sTarget + \" \" +\n                          CString(pChan->GetCreationDate()));\n            }\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CClient::OnNoticeMessage(CNoticeMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (!sTarget.Equals(\"status\")) {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModNotice(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserNoticeMessage(Message), m_pUser, m_pNetwork,\n                          this, &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a NOTICE to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your notice to {1} got lost, you are not connected to \"\n                        \"IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnPartMessage(CPartMessage& Message) {\n    CString sChans = Message.GetTarget();\n\n    VCString vsChans;\n    sChans.Split(\",\", vsChans, false);\n    sChans.clear();\n\n    for (CString& sChan : vsChans) {\n        bool bContinue = false;\n        Message.SetTarget(sChan);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sChan));\n        }\n        NETWORKMODULECALL(OnUserPartMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        sChan = Message.GetTarget();\n\n        CChan* pChan = m_pNetwork ? m_pNetwork->FindChan(sChan) : nullptr;\n\n        if (pChan && !pChan->IsOn()) {\n            PutStatusNotice(t_f(\"Removing channel {1}\")(sChan));\n            m_pNetwork->DelChan(sChan);\n        } else {\n            sChans += (sChans.empty()) ? sChan : CString(\",\" + sChan);\n        }\n    }\n\n    if (sChans.empty()) {\n        return true;\n    }\n\n    Message.SetTarget(sChans);\n\n    return false;\n}\n\nbool CClient::OnPingMessage(CMessage& Message) {\n    // All PONGs are generated by ZNC. We will still forward this to\n    // the ircd, but all PONGs from irc will be blocked.\n    if (!Message.GetParams().empty())\n        PutClient(\":irc.znc.in PONG irc.znc.in \" + Message.GetParamsColon(0));\n    else\n        PutClient(\":irc.znc.in PONG irc.znc.in\");\n    return false;\n}\n\nbool CClient::OnPongMessage(CMessage& Message) {\n    // Block PONGs, we already responded to the pings\n    return true;\n}\n\nbool CClient::OnQuitMessage(CQuitMessage& Message) {\n    bool bReturn = false;\n    NETWORKMODULECALL(OnUserQuitMessage(Message), m_pUser, m_pNetwork, this,\n                      &bReturn);\n    if (!bReturn) {\n        Close(Csock::CLT_AFTERWRITE);  // Treat a client quit as a detach\n    }\n    // Don't forward this msg.  We don't want the client getting us\n    // disconnected.\n    return true;\n}\n\nbool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            EchoMessage(Message);\n\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\nbool CClient::OnTopicMessage(CTopicMessage& Message) {\n    bool bReturn = false;\n    CString sChan = Message.GetTarget();\n    CString sTopic = Message.GetTopic();\n    if (m_pNetwork) {\n        // May be nullptr.\n        Message.SetChan(m_pNetwork->FindChan(sChan));\n    }\n\n    if (!sTopic.empty()) {\n        NETWORKMODULECALL(OnUserTopicMessage(Message), m_pUser, m_pNetwork,\n                          this, &bReturn);\n    } else {\n        NETWORKMODULECALL(OnUserTopicRequest(sChan), m_pUser, m_pNetwork, this,\n                          &bReturn);\n        Message.SetTarget(sChan);\n    }\n\n    return bReturn;\n}\n\nbool CClient::OnOtherMessage(CMessage& Message) {\n    const CString& sCommand = Message.GetCommand();\n\n    if (sCommand.Equals(\"ZNC\")) {\n        CString sTarget = Message.GetParam(0);\n        CString sModCommand;\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            sModCommand = Message.GetParamsColon(1);\n        } else {\n            sTarget = \"status\";\n            sModCommand = Message.GetParamsColon(0);\n        }\n\n        if (sTarget.Equals(\"status\")) {\n            if (sModCommand.empty())\n                PutStatus(t_s(\"Hello. How may I help you?\"));\n            else\n                UserCommand(sModCommand);\n        } else {\n            if (sModCommand.empty())\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        PutModule(t_s(\"Hello. How may I help you?\")))\n            else\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(sModCommand))\n        }\n        return true;\n    } else if (sCommand.Equals(\"ATTACH\")) {\n        if (!m_pNetwork) {\n            return true;\n        }\n\n        CString sPatterns = Message.GetParamsColon(0);\n\n        if (sPatterns.empty()) {\n            PutStatusNotice(t_s(\"Usage: /attach <#chans>\"));\n            return true;\n        }\n\n        set<CChan*> sChans = MatchChans(sPatterns);\n        unsigned int uAttachedChans = AttachChans(sChans);\n\n        PutStatusNotice(t_p(\"There was {1} channel matching [{2}]\",\n                            \"There were {1} channels matching [{2}]\",\n                            sChans.size())(sChans.size(), sPatterns));\n        PutStatusNotice(t_p(\"Attached {1} channel\", \"Attached {1} channels\",\n                            uAttachedChans)(uAttachedChans));\n\n        return true;\n    } else if (sCommand.Equals(\"DETACH\")) {\n        if (!m_pNetwork) {\n            return true;\n        }\n\n        CString sPatterns = Message.GetParamsColon(0);\n\n        if (sPatterns.empty()) {\n            PutStatusNotice(t_s(\"Usage: /detach <#chans>\"));\n            return true;\n        }\n\n        set<CChan*> sChans = MatchChans(sPatterns);\n        unsigned int uDetached = DetachChans(sChans);\n\n        PutStatusNotice(t_p(\"There was {1} channel matching [{2}]\",\n                            \"There were {1} channels matching [{2}]\",\n                            sChans.size())(sChans.size(), sPatterns));\n        PutStatusNotice(t_p(\"Detached {1} channel\", \"Detached {1} channels\",\n                            uDetached)(uDetached));\n\n        return true;\n    } else if (sCommand.Equals(\"PROTOCTL\")) {\n        for (const CString& sParam : Message.GetParams()) {\n            if (sParam == \"NAMESX\") {\n                m_bNamesx = true;\n            } else if (sParam == \"UHNAMES\") {\n                m_bUHNames = true;\n            }\n        }\n        return true;  // If the server understands it, we already enabled namesx\n                      // / uhnames\n    }\n\n    return false;\n}\n", "/*\n * Copyright (C) 2004-2020 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <gmock/gmock.h>\n\n#include \"znctest.h\"\n\nusing testing::HasSubstr;\n\nnamespace znc_inttest {\nnamespace {\n\nTEST(Config, AlreadyExists) {\n    QTemporaryDir dir;\n    WriteConfig(dir.path());\n    Process p(ZNC_BIN_DIR \"/znc\", QStringList() << \"--debug\"\n                                                << \"--datadir\" << dir.path()\n                                                << \"--makeconf\");\n    p.ReadUntil(\"already exists\");\n    p.CanDie();\n}\n\nTEST_F(ZNCTest, Connect) {\n    auto znc = Run();\n\n    auto ircd = ConnectIRCd();\n    ircd.ReadUntil(\"CAP LS\");\n\n    auto client = ConnectClient();\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user/test x x :x\");\n    client.ReadUntil(\"Welcome\");\n    client.Close();\n\n    client = ConnectClient();\n    client.Write(\"PASS :user:hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER u x x x\");\n    client.ReadUntil(\"Welcome\");\n    client.Close();\n\n    client = ConnectClient();\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user x x x\");\n    client.ReadUntil(\"Configure your client to send a server password\");\n    client.Close();\n\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.ReadUntil(\"WHO\");\n}\n\nTEST_F(ZNCTest, Channel) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n\n    auto client = LoginClient();\n    client.ReadUntil(\"Welcome\");\n    client.Write(\"JOIN #znc\");\n    client.Close();\n\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.ReadUntil(\"JOIN #znc\");\n    ircd.Write(\":nick JOIN :#znc\");\n    ircd.Write(\":server 353 nick #znc :nick\");\n    ircd.Write(\":server 366 nick #znc :End of /NAMES list\");\n    ircd.Write(\":server PING :1\");\n    ircd.ReadUntil(\"PONG 1\");\n\n    client = LoginClient();\n    client.ReadUntil(\":nick JOIN :#znc\");\n}\n\nTEST_F(ZNCTest, HTTP) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto reply = HttpGet(QNetworkRequest(QUrl(\"http://127.0.0.1:12345/\")));\n    EXPECT_THAT(reply->rawHeader(\"Server\").toStdString(), HasSubstr(\"ZNC\"));\n}\n\nTEST_F(ZNCTest, FixCVE20149403) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":server 005 nick CHANTYPES=# :supports\");\n    ircd.Write(\":server PING :1\");\n    ircd.ReadUntil(\"PONG 1\");\n\n    QNetworkRequest request;\n    request.setRawHeader(\"Authorization\",\n                         \"Basic \" + QByteArray(\"user:hunter2\").toBase64());\n    request.setUrl(QUrl(\"http://127.0.0.1:12345/mods/global/webadmin/addchan\"));\n    HttpPost(request, {\n                          {\"user\", \"user\"},\n                          {\"network\", \"test\"},\n                          {\"submitted\", \"1\"},\n                          {\"name\", \"znc\"},\n                          {\"enabled\", \"1\"},\n                      });\n    EXPECT_THAT(HttpPost(request,\n                         {\n                             {\"user\", \"user\"},\n                             {\"network\", \"test\"},\n                             {\"submitted\", \"1\"},\n                             {\"name\", \"znc\"},\n                             {\"enabled\", \"1\"},\n                         })\n                    ->readAll()\n                    .toStdString(),\n                HasSubstr(\"Channel [#znc] already exists\"));\n}\n\nTEST_F(ZNCTest, FixFixOfCVE20149403) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":nick JOIN @#znc\");\n    ircd.ReadUntil(\"MODE @#znc\");\n    ircd.Write(\":server 005 nick STATUSMSG=@ :supports\");\n    ircd.Write(\":server PING :12345\");\n    ircd.ReadUntil(\"PONG 12345\");\n\n    QNetworkRequest request;\n    request.setRawHeader(\"Authorization\",\n                         \"Basic \" + QByteArray(\"user:hunter2\").toBase64());\n    request.setUrl(QUrl(\"http://127.0.0.1:12345/mods/global/webadmin/addchan\"));\n    auto reply = HttpPost(request, {\n                                       {\"user\", \"user\"},\n                                       {\"network\", \"test\"},\n                                       {\"submitted\", \"1\"},\n                                       {\"name\", \"@#znc\"},\n                                       {\"enabled\", \"1\"},\n                                   });\n    EXPECT_THAT(reply->readAll().toStdString(),\n                HasSubstr(\"Could not add channel [@#znc]\"));\n}\n\nTEST_F(ZNCTest, InvalidConfigInChan) {\n    QFile conf(m_dir.path() + \"/configs/znc.conf\");\n    ASSERT_TRUE(conf.open(QIODevice::Append | QIODevice::Text));\n    QTextStream out(&conf);\n    out << R\"(\n        <User foo>\n            <Network bar>\n                <Chan #baz>\n                    Invalid = Line\n                </Chan>\n            </Network>\n        </User>\n    )\";\n    out.flush();\n    auto znc = Run();\n    znc->ShouldFinishItself(1);\n}\nTEST_F(ZNCTest, Encoding) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    ircd.Write(\":server 001 nick :hello\");\n    // legacy\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xE6world\");\n    client.ReadUntil(\"Hello\\xE6world\");\n    client.Write(\"PRIVMSG *controlpanel :SetNetwork Encoding $me $net UTF-8\");\n    client.ReadUntil(\"Encoding = UTF-8\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xE6world\");\n    client.ReadUntil(\"Hello\\xEF\\xBF\\xBDworld\");\n    client.Write(\n        \"PRIVMSG *controlpanel :SetNetwork Encoding $me $net ^CP-1251\");\n    client.ReadUntil(\"Encoding = ^CP-1251\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xE6world\");\n    client.ReadUntil(\"Hello\\xD0\\xB6world\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hello\\xD0\\xB6world\");\n    client.ReadUntil(\"Hello\\xD0\\xB6world\");\n}\n\nTEST_F(ZNCTest, BuildMod) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    QTemporaryDir srcd;\n    QDir srcdir(srcd.path());\n    QFile file(srcdir.filePath(\"testmod.cpp\"));\n    ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));\n    QTextStream out(&file);\n    out << R\"(\n        #include <znc/Modules.h>\n        class TestModule : public CModule {\n          public:\n            MODCONSTRUCTOR(TestModule) {}\n            void OnModCommand(const CString& sLine) override {\n                PutModule(\"Lorem ipsum\");\n            }\n        };\n        MODULEDEFS(TestModule, \"Test\")\n    )\";\n    file.close();\n    QDir dir(m_dir.path());\n    EXPECT_TRUE(dir.mkdir(\"modules\"));\n    EXPECT_TRUE(dir.cd(\"modules\"));\n    {\n        Process p(ZNC_BIN_DIR \"/znc-buildmod\",\n                  QStringList() << srcdir.filePath(\"file-not-found.cpp\"),\n                  [&](QProcess* proc) {\n                      proc->setWorkingDirectory(dir.absolutePath());\n                      proc->setProcessChannelMode(QProcess::ForwardedChannels);\n                  });\n        p.ShouldFinishItself(1);\n        p.ShouldFinishInSec(300);\n    }\n    {\n        Process p(ZNC_BIN_DIR \"/znc-buildmod\",\n                  QStringList() << srcdir.filePath(\"testmod.cpp\"),\n                  [&](QProcess* proc) {\n                      proc->setWorkingDirectory(dir.absolutePath());\n                      proc->setProcessChannelMode(QProcess::ForwardedChannels);\n                  });\n        p.ShouldFinishItself();\n        p.ShouldFinishInSec(300);\n    }\n    client.Write(\"znc loadmod testmod\");\n    client.Write(\"PRIVMSG *testmod :hi\");\n    client.ReadUntil(\"Lorem ipsum\");\n}\n\nTEST_F(ZNCTest, AwayNotify) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = ConnectClient();\n    client.Write(\"CAP LS\");\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user/test x x :x\");\n    QByteArray cap_ls;\n    client.ReadUntilAndGet(\" LS :\", cap_ls);\n    ASSERT_THAT(cap_ls.toStdString(),\n                AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n    client.Write(\"CAP REQ :cap-notify\");\n    client.ReadUntil(\"ACK :cap-notify\");\n    client.Write(\"CAP END\");\n    client.ReadUntil(\" 001 \");\n    ircd.ReadUntil(\"USER\");\n    ircd.Write(\"CAP user LS :away-notify\");\n    ircd.ReadUntil(\"CAP REQ :away-notify\");\n    ircd.Write(\"CAP user ACK :away-notify\");\n    ircd.ReadUntil(\"CAP END\");\n    ircd.Write(\":server 001 user :welcome\");\n    client.ReadUntil(\"CAP user NEW :away-notify\");\n    client.Write(\"CAP REQ :away-notify\");\n    client.ReadUntil(\"ACK :away-notify\");\n    ircd.Write(\":x!y@z AWAY :reason\");\n    client.ReadUntil(\":x!y@z AWAY :reason\");\n    ircd.Close();\n    client.ReadUntil(\"DEL :away-notify\");\n    // This test often fails on macos due to ZNC process not finishing.\n    // No idea why. Let's try to shutdown it more explicitly...\n    client.Write(\"znc shutdown\");\n}\n\nTEST_F(ZNCTest, JoinKey) {\n    QFile conf(m_dir.path() + \"/configs/znc.conf\");\n    ASSERT_TRUE(conf.open(QIODevice::Append | QIODevice::Text));\n    QTextStream(&conf) << \"ServerThrottle = 1\\n\";\n    auto znc = Run();\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    ircd.Write(\":server 001 nick :Hello\");\n    client.Write(\"JOIN #znc secret\");\n    ircd.ReadUntil(\"JOIN #znc secret\");\n    ircd.Write(\":nick JOIN :#znc\");\n    client.ReadUntil(\"JOIN :#znc\");\n    ircd.Close();\n\n    ircd = ConnectIRCd();\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.ReadUntil(\"JOIN #znc secret\");\n}\n\nTEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    client.Write(\"znc delnetwork test\");\n    client.ReadUntil(\"Network deleted\");\n    auto client2 = LoginClient();\n    client2.Write(\"PRIVMSG *status :blah2\");\n    client2.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    auto client3 = LoginClient();\n    client3.Write(\"PRIVMSG *status :blah3\");\n    client3.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}\n\n}  // namespace\n}  // namespace znc_inttest\n"], "filenames": ["src/Client.cpp", "test/integration/tests/core.cpp"], "buggy_code_start_loc": [892, 299], "buggy_code_end_loc": [893, 299], "fixing_code_start_loc": [892, 300], "fixing_code_end_loc": [893, 308], "type": "CWE-476", "message": "ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network.", "other": {"cve": {"id": "CVE-2020-13775", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-02T23:15:10.567", "lastModified": "2023-01-27T18:53:26.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network."}, {"lang": "es", "value": "ZNC 1.8.0 hasta 1.8.1-rc1 permite a los usuarios autentificados activar un bloqueo de la aplicaci\u00f3n (con una desreferencia del puntero NULL) si el mensaje eco no est\u00e1 habilitado y no hay red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:znc:znc:1.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "9DF4DE9D-624E-4B41-A98A-0A0156EEA40C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "https://github.com/znc/znc/commit/2390ad111bde16a78c98ac44572090b33c3bd2d8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/znc/znc/commit/d229761821da38d984a9e4098ad96842490dc001", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DNVBE4T2DRJRQHFRMHYBTN4OSOL6DBHR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HS3DWGXLVRROQQA57UIPMDM6XMVEMBRA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/znc/znc/commit/2390ad111bde16a78c98ac44572090b33c3bd2d8"}}