{"buggy_code": ["# Vx.x.x (Pre-release)\n\n## Release Hightlights\n\n## Important Notes\n\n## Breaking Changes\n\n## Changes since v5.0.0\n\n# v5.0.0\n\n## Release Hightlights\n- Disabled CGO (binaries will work regardless og glibc/musl)\n- Allow whitelisted redirect ports\n- Nextcloud provider support added\n- DigitalOcean provider support added\n\n## Important Notes\nN/A\n\n## Breaking Changes\n\n- [#321](https://github.com/pusher/oauth2_proxy/pull/331) Add reverse proxy boolean flag to control whether headers like `X-Real-Ip` are accepted.\n  This defaults to false. **Usage behind a reverse proxy will require this flag to be set to avoid logging the reverse proxy IP address**.\n\n## Changes since v4.1.0\n\n- [#331](https://github.com/pusher/oauth2_proxy/pull/331) Add reverse proxy setting (@martin-css)\n- [#365](https://github.com/pusher/oauth2_proxy/pull/365) Build with CGO=0 (@tomelliff)\n- [#339](https://github.com/pusher/oauth2_proxy/pull/339) Add configuration for cookie 'SameSite' value. (@pgroudas)\n- [#347](https://github.com/pusher/oauth2_proxy/pull/347) Update keycloak provider configuration documentation. (@sushiMix)\n- [#325](https://github.com/pusher/oauth2_proxy/pull/325) dist.sh: use sha256sum (@syscll)\n- [#179](https://github.com/pusher/oauth2_proxy/pull/179) Add Nextcloud provider (@Ramblurr)\n- [#280](https://github.com/pusher/oauth2_proxy/pull/280) whitelisted redirect domains: add support for whitelisting specific ports or allowing wildcard ports (@kamaln7)\n- [#351](https://github.com/pusher/oauth2_proxy/pull/351) Add DigitalOcean Auth provider (@kamaln7)\n\n# v4.1.0\n\n## Release Highlights\n- Added Keycloak provider\n- Build on Go 1.13\n- Upgrade Docker image to use Debian Buster\n- Added support for FreeBSD builds\n- Added new logo\n- Added support for GitHub teams\n\n## Important Notes\nN/A\n\n## Breaking Changes\nN/A\n\n## Changes since v4.0.0\n- [#292](https://github.com/pusher/oauth2_proxy/pull/292) Added bash >= 4.0 dependency to configure script (@jmfrank63)\n- [#227](https://github.com/pusher/oauth2_proxy/pull/227) Add Keycloak provider (@Ofinka)\n- [#259](https://github.com/pusher/oauth2_proxy/pull/259) Redirect to HTTPS (@jmickey)\n- [#273](https://github.com/pusher/oauth2_proxy/pull/273) Support Go 1.13 (@dio)\n- [#275](https://github.com/pusher/oauth2_proxy/pull/275) docker: build from debian buster (@syscll)\n- [#258](https://github.com/pusher/oauth2_proxy/pull/258) Add IDToken for Azure provider (@leyshon)\n  - This PR adds the IDToken into the session for the Azure provider allowing requests to a backend to be identified as a specific user. As a consequence, if you are using a cookie to store the session the cookie will now exceed the 4kb size limit and be split into multiple cookies. This can cause problems when using nginx as a proxy, resulting in no cookie being passed at all. Either increase the proxy_buffer_size in nginx or implement the redis session storage (see https://pusher.github.io/oauth2_proxy/configuration#redis-storage)\n- [#286](https://github.com/pusher/oauth2_proxy/pull/286) Requests.go updated with useful error messages (@biotom)\n- [#274](https://github.com/pusher/oauth2_proxy/pull/274) Supports many github teams with api pagination support (@toshi-miura, @apratina)\n- [#302](https://github.com/pusher/oauth2_proxy/pull/302) Rewrite dist script (@syscll)\n- [#304](https://github.com/pusher/oauth2_proxy/pull/304) Add new Logo! :tada: (@JoelSpeed)\n- [#300](https://github.com/pusher/oauth2_proxy/pull/300) Added userinfo endpoint (@kbabuadze)\n- [#309](https://github.com/pusher/oauth2_proxy/pull/309) Added support for custom CA when connecting to Redis cache (@lleszczu)\n- [#248](https://github.com/pusher/oauth2_proxy/pull/248) Fix issue with X-Auth-Request-Redirect header being ignored (@webnard)\n- [#314](https://github.com/pusher/oauth2_proxy/pull/314) Add redirect capability to sign_out (@costelmoraru)\n- [#265](https://github.com/pusher/oauth2_proxy/pull/265) Add upstream with static response (@cgroschupp)\n- [#317](https://github.com/pusher/oauth2_proxy/pull/317) Add build for FreeBSD (@fnkr)\n- [#296](https://github.com/pusher/oauth2_proxy/pull/296) Allow to override provider's name for sign-in page (@ffdybuster)\n\n# v4.0.0\n\n## Release Highlights\n- Documentation is now on a [microsite](https://pusher.github.io/oauth2_proxy/)\n- Health check logging can now be disabled for quieter logs\n- Authorization Header JWTs can now be verified by the proxy to skip authentication for machine users\n- Sessions can now be stored in Redis. This reduces refresh failures and uses smaller cookies (Recommended for those using OIDC refreshing)\n- Logging overhaul allows customisable logging formats\n\n## Important Notes\n- This release includes a number of breaking changes that will require users to\nreconfigure their proxies. Please read the Breaking Changes below thoroughly.\n\n## Breaking Changes\n\n- [#231](https://github.com/pusher/oauth2_proxy/pull/231) Rework GitLab provider\n  - This PR changes the configuration options for the GitLab provider to use\n  a self-hosted instance. You now need to specify a `-oidc-issuer-url` rather than\n  explicit `-login-url`, `-redeem-url` and `-validate-url` parameters.\n- [#186](https://github.com/pusher/oauth2_proxy/pull/186) Make config consistent\n  - This PR changes configuration options so that all flags have a config counterpart\n  of the same name but with underscores (`_`) in place of hyphens (`-`).\n  This change affects the following flags:\n  - The `--tls-key` flag is now `--tls-key-file` to be consistent with existing\n  file flags and the existing config and environment settings\n  - The `--tls-cert` flag is now `--tls-cert-file` to be consistent with existing\n  file flags and the existing config and environment settings\n  This change affects the following existing configuration options:\n  - The `proxy-prefix` option is now `proxy_prefix`.\n  This PR changes environment variables so that all flags have an environment\n  counterpart of the same name but capitalised, with underscores (`_`) in place\n  of hyphens (`-`) and with the prefix `OAUTH2_PROXY_`.\n  This change affects the following existing environment variables:\n  - The `OAUTH2_SKIP_OIDC_DISCOVERY` environment variable is now `OAUTH2_PROXY_SKIP_OIDC_DISCOVERY`.\n  - The `OAUTH2_OIDC_JWKS_URL` environment variable is now `OAUTH2_PROXY_OIDC_JWKS_URL`.\n- [#146](https://github.com/pusher/oauth2_proxy/pull/146) Use full email address as `User` if the auth response did not contain a `User` field\n  - This change modifies the contents of the `X-Forwarded-User` header supplied by the proxy for users where the auth response from the IdP did not contain\n    a username.\n    In that case, this header used to only contain the local part of the user's email address (e.g. `john.doe` for `john.doe@example.com`) but now contains\n    the user's full email address instead.\n- [#170](https://github.com/pusher/oauth2_proxy/pull/170) Pre-built binary tarballs changed format\n  - The pre-built binary tarballs again match the format of the [bitly](https://github.com/bitly/oauth2_proxy) repository, where the unpacked directory\n    has the same name as the tarball and the binary is always named `oauth2_proxy`. This was done to restore compatibility with third-party automation\n    recipes like https://github.com/jhoblitt/puppet-oauth2_proxy.\n\n## Changes since v3.2.0\n\n- [#234](https://github.com/pusher/oauth2_proxy/pull/234) Added option `-ssl-upstream-insecure-skip-validation` to skip validation of upstream SSL certificates (@jansinger)\n- [#224](https://github.com/pusher/oauth2_proxy/pull/224) Check Google group membership using hasMember to support nested groups and external users (@jpalpant)\n- [#231](https://github.com/pusher/oauth2_proxy/pull/231) Add optional group membership and email domain checks to the GitLab provider (@Overv)\n- [#226](https://github.com/pusher/oauth2_proxy/pull/226) Made setting of proxied headers deterministic based on configuration alone (@aeijdenberg)\n- [#178](https://github.com/pusher/oauth2_proxy/pull/178) Add Silence Ping Logging and Exclude Logging Paths flags (@kskewes)\n- [#209](https://github.com/pusher/oauth2_proxy/pull/209) Improve docker build caching of layers (@dekimsey)\n- [#186](https://github.com/pusher/oauth2_proxy/pull/186) Make config consistent (@JoelSpeed)\n- [#187](https://github.com/pusher/oauth2_proxy/pull/187) Move root packages to pkg folder (@JoelSpeed)\n- [#65](https://github.com/pusher/oauth2_proxy/pull/65) Improvements to authenticate requests with a JWT bearer token in the `Authorization` header via\n  the `-skip-jwt-bearer-token` options. (@brianv0)\n  - Additional verifiers can be configured via the `-extra-jwt-issuers` flag if the JWT issuers is either an OpenID provider or has a JWKS URL\n  (e.g. `https://example.com/.well-known/jwks.json`).\n- [#180](https://github.com/pusher/oauth2_proxy/pull/180) Minor refactor of core proxying path (@aeijdenberg).\n- [#175](https://github.com/pusher/oauth2_proxy/pull/175) Bump go-oidc to v2.0.0 (@aeijdenberg).\n  - Includes fix for potential signature checking issue when OIDC discovery is skipped.\n- [#155](https://github.com/pusher/oauth2_proxy/pull/155) Add RedisSessionStore implementation (@brianv0, @JoelSpeed)\n  - Implement flags to configure the redis session store\n    - `-session-store-type=redis` Sets the store type to redis\n    - `-redis-connection-url` Sets the Redis connection URL\n    - `-redis-use-sentinel=true` Enables Redis Sentinel support\n    - `-redis-sentinel-master-name` Sets the Sentinel master name, if sentinel is enabled\n    - `-redis-sentinel-connection-urls` Defines the Redis Sentinel Connection URLs, if sentinel is enabled\n  - Introduces the concept of a session ticket. Tickets are composed of the cookie name, a session ID, and a secret.\n  - Redis Sessions are stored encrypted with a per-session secret\n  - Added tests for server based session stores\n- [#168](https://github.com/pusher/oauth2_proxy/pull/168) Drop Go 1.11 support in Travis (@JoelSpeed)\n- [#169](https://github.com/pusher/oauth2_proxy/pull/169) Update Alpine to 3.9 (@kskewes)\n- [#148](https://github.com/pusher/oauth2_proxy/pull/148) Implement SessionStore interface within proxy (@JoelSpeed)\n- [#147](https://github.com/pusher/oauth2_proxy/pull/147) Add SessionStore interfaces and initial implementation (@JoelSpeed)\n  - Allows for multiple different session storage implementations including client and server side\n  - Adds tests suite for interface to ensure consistency across implementations\n  - Refactor some configuration options (around cookies) into packages\n- [#114](https://github.com/pusher/oauth2_proxy/pull/114), [#154](https://github.com/pusher/oauth2_proxy/pull/154) Documentation is now available live at our [docs website](https://pusher.github.io/oauth2_proxy/) (@JoelSpeed, @icelynjennings)\n- [#146](https://github.com/pusher/oauth2_proxy/pull/146) Use full email address as `User` if the auth response did not contain a `User` field (@gargath)\n- [#144](https://github.com/pusher/oauth2_proxy/pull/144) Use GO 1.12 for ARM builds (@kskewes)\n- [#142](https://github.com/pusher/oauth2_proxy/pull/142) ARM Docker USER fix (@kskewes)\n- [#52](https://github.com/pusher/oauth2_proxy/pull/52) Logging Improvements (@MisterWil)\n  - Implement flags to configure file logging\n    - `-logging-filename` Defines the filename to log to\n    - `-logging-max-size` Defines the maximum\n    - `-logging-max-age` Defines the maximum age of backups to retain\n    - `-logging-max-backups` Defines the maximum number of rollover log files to retain\n    - `-logging-compress` Defines if rollover log files should be compressed\n    - `-logging-local-time` Defines if logging date and time should be local or UTC\n  - Implement two new flags to enable or disable specific logging types\n    - `-standard-logging` Enables or disables standard (not request or auth) logging\n    - `-auth-logging` Enables or disables auth logging\n  - Implement two new flags to customize the logging format\n    - `-standard-logging-format` Sets the format for standard logging\n    - `-auth-logging-format` Sets the format for auth logging\n- [#111](https://github.com/pusher/oauth2_proxy/pull/111) Add option for telling where to find a login.gov JWT key file (@timothy-spencer)\n- [#170](https://github.com/pusher/oauth2_proxy/pull/170) Restore binary tarball contents to be compatible with bitlys original tarballs (@zeha)\n- [#185](https://github.com/pusher/oauth2_proxy/pull/185) Fix an unsupported protocol scheme error during token validation when using the Azure provider (@jonas)\n- [#141](https://github.com/pusher/oauth2_proxy/pull/141) Check google group membership based on email address (@bchess)\n  - Google Group membership is additionally checked via email address, allowing users outside a GSuite domain to be authorized.\n- [#195](https://github.com/pusher/oauth2_proxy/pull/195) Add `-banner` flag for overriding the banner line that is displayed (@steakunderscore)\n- [#198](https://github.com/pusher/oauth2_proxy/pull/198) Switch from gometalinter to golangci-lint (@steakunderscore)\n- [#159](https://github.com/pusher/oauth2_proxy/pull/159) Add option to skip the OIDC provider verified email check: `--insecure-oidc-allow-unverified-email` (@djfinlay)\n- [#210](https://github.com/pusher/oauth2_proxy/pull/210) Update base image from Alpine 3.9 to 3.10 (@steakunderscore)\n- [#201](https://github.com/pusher/oauth2_proxy/pull/201) Add Bitbucket as new OAuth2 provider, accepts email, team and repository permissions to determine authorization (@aledeganopix4d)\n  - Implement flags to enable Bitbucket authentication:\n    - `-bitbucket-repository` Restrict authorization to users that can access this repository\n    - `-bitbucket-team` Restrict authorization to users that are part of this Bitbucket team\n- [#211](https://github.com/pusher/oauth2_proxy/pull/211) Switch from dep to go modules (@steakunderscore)\n- [#145](https://github.com/pusher/oauth2_proxy/pull/145) Add support for OIDC UserInfo endpoint email verification (@rtluckie)\n\n# v3.2.0\n\n## Release highlights\n- Internal restructure of session state storage to use JSON rather than proprietary scheme\n- Added health check options for running on GCP behind a load balancer\n- Improved support for protecting websockets\n- Added provider for login.gov\n- Allow manual configuration of OIDC providers\n\n## Important notes\n- Dockerfile user is now non-root, this may break your existing deployment\n- In the OIDC provider, when no email is returned, the ID Token subject will be used\ninstead of returning an error\n- GitHub user emails must now be primary and verified before authenticating\n\n## Changes since v3.1.0\n\n- [#96](https://github.com/bitly/oauth2_proxy/pull/96) Check if email is verified on GitHub (@caarlos0)\n- [#110](https://github.com/pusher/oauth2_proxy/pull/110) Added GCP healthcheck option (@timothy-spencer)\n- [#112](https://github.com/pusher/oauth2_proxy/pull/112) Improve websocket support (@gyson)\n- [#63](https://github.com/pusher/oauth2_proxy/pull/63) Use encoding/json for SessionState serialization (@yaegashi)\n  - Use JSON to encode session state to be stored in browser cookies\n  - Implement legacy decode function to support existing cookies generated by older versions\n  - Add detailed table driven tests in session_state_test.go\n- [#120](https://github.com/pusher/oauth2_proxy/pull/120) Encrypting user/email from cookie (@costelmoraru)\n- [#55](https://github.com/pusher/oauth2_proxy/pull/55) Added login.gov provider (@timothy-spencer)\n- [#55](https://github.com/pusher/oauth2_proxy/pull/55) Added environment variables for all config options (@timothy-spencer)\n- [#70](https://github.com/pusher/oauth2_proxy/pull/70) Fix handling of splitted cookies (@einfachchr)\n- [#92](https://github.com/pusher/oauth2_proxy/pull/92) Merge websocket proxy feature from openshift/oauth-proxy (@butzist)\n- [#57](https://github.com/pusher/oauth2_proxy/pull/57) Fall back to using OIDC Subject instead of Email (@aigarius)\n- [#85](https://github.com/pusher/oauth2_proxy/pull/85) Use non-root user in docker images (@kskewes)\n- [#68](https://github.com/pusher/oauth2_proxy/pull/68) forward X-Auth-Access-Token header (@davidholsgrove)\n- [#41](https://github.com/pusher/oauth2_proxy/pull/41) Added option to manually specify OIDC endpoints instead of relying on discovery\n- [#83](https://github.com/pusher/oauth2_proxy/pull/83) Add `id_token` refresh to Google provider (@leki75)\n- [#10](https://github.com/pusher/oauth2_proxy/pull/10) fix redirect url param handling (@dt-rush)\n- [#122](https://github.com/pusher/oauth2_proxy/pull/122) Expose -cookie-path as configuration parameter (@costelmoraru)\n- [#124](https://github.com/pusher/oauth2_proxy/pull/124) Use Go 1.12 for testing and build environments (@syscll)\n\n# v3.1.0\n\n## Release highlights\n\n- Introduction of ARM releases and and general improvements to Docker builds\n- Improvements to OIDC provider allowing pass-through of ID Tokens\n- Multiple redirect domains can now be whitelisted\n- Streamed responses are now flushed periodically\n\n## Important notes\n\n- If you have been using [#bitly/621](https://github.com/bitly/oauth2_proxy/pull/621)\n  and have cookies larger than the 4kb limit,\n  the cookie splitting pattern has changed and now uses `_` in place of `-` when\n  indexing cookies.\n  This will force users to reauthenticate the first time they use `v3.1.0`.\n- Streamed responses will now be flushed every 1 second by default.\n  Previously streamed responses were flushed only when the buffer was full.\n  To retain the old behaviour set `--flush-interval=0`.\n  See [#23](https://github.com/pusher/oauth2_proxy/pull/23) for further details.\n\n## Changes since v3.0.0\n\n- [#14](https://github.com/pusher/oauth2_proxy/pull/14) OIDC ID Token, Authorization Headers, Refreshing and Verification (@joelspeed)\n  - Implement `pass-authorization-header` and `set-authorization-header` flags\n  - Implement token refreshing in OIDC provider\n  - Split cookies larger than 4k limit into multiple cookies\n  - Implement token validation in OIDC provider\n- [#15](https://github.com/pusher/oauth2_proxy/pull/15) WhitelistDomains (@joelspeed)\n  - Add `--whitelist-domain` flag to allow redirection to approved domains after OAuth flow\n- [#21](https://github.com/pusher/oauth2_proxy/pull/21) Docker Improvement (@yaegashi)\n  - Move Docker base image from debian to alpine\n  - Install ca-certificates in docker image\n- [#23](https://github.com/pusher/oauth2_proxy/pull/23) Flushed streaming responses\n  - Long-running upstream responses will get flushed every <timeperiod> (1 second by default)\n- [#24](https://github.com/pusher/oauth2_proxy/pull/24) Redirect fix (@agentgonzo)\n  - After a successful login, you will be redirected to your original URL rather than /\n- [#35](https://github.com/pusher/oauth2_proxy/pull/35) arm and arm64 binary releases (@kskewes)\n  - Add armv6 and arm64 to Makefile `release` target\n- [#37](https://github.com/pusher/oauth2_proxy/pull/37) cross build arm and arm64 docker images (@kskewes)\n\n# v3.0.0\n\nAdoption of OAuth2_Proxy by Pusher.\nProject was hard forked and tidied however no logical changes have occurred since\nv2.2 as released by Bitly.\n\n## Changes since v2.2:\n\n- [#7](https://github.com/pusher/oauth2_proxy/pull/7) Migration to Pusher (@joelspeed)\n  - Move automated build to debian base image\n  - Add Makefile\n    - Update CI to run `make test`\n    - Update Dockerfile to use `make clean oauth2_proxy`\n    - Update `VERSION` parameter to be set by `ldflags` from Git Status\n    - Remove lint and test scripts\n  - Remove Go v1.8.x from Travis CI testing\n  - Add CODEOWNERS file\n  - Add CONTRIBUTING guide\n  - Add Issue and Pull Request templates\n  - Add Dockerfile\n  - Fix fsnotify import\n  - Update README to reflect new repository ownership\n  - Update CI scripts to separate linting and testing\n    - Now using `gometalinter` for linting\n  - Move Go import path from `github.com/bitly/oauth2_proxy` to `github.com/pusher/oauth2_proxy`\n  - Repository forked on 27/11/18\n    - README updated to include note that this repository is forked\n    - CHANGLOG created to track changes to repository from original fork\n", "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\tb64 \"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/mbland/hmacauth\"\n\tsessionsapi \"github.com/pusher/oauth2_proxy/pkg/apis/sessions\"\n\t\"github.com/pusher/oauth2_proxy/pkg/cookies\"\n\t\"github.com/pusher/oauth2_proxy/pkg/encryption\"\n\t\"github.com/pusher/oauth2_proxy/pkg/logger\"\n\t\"github.com/pusher/oauth2_proxy/providers\"\n\t\"github.com/yhat/wsutil\"\n)\n\nconst (\n\t// SignatureHeader is the name of the request header containing the GAP Signature\n\t// Part of hmacauth\n\tSignatureHeader = \"GAP-Signature\"\n\n\thttpScheme  = \"http\"\n\thttpsScheme = \"https\"\n\n\tapplicationJSON = \"application/json\"\n)\n\n// SignatureHeaders contains the headers to be signed by the hmac algorithm\n// Part of hmacauth\nvar SignatureHeaders = []string{\n\t\"Content-Length\",\n\t\"Content-Md5\",\n\t\"Content-Type\",\n\t\"Date\",\n\t\"Authorization\",\n\t\"X-Forwarded-User\",\n\t\"X-Forwarded-Email\",\n\t\"X-Forwarded-Access-Token\",\n\t\"Cookie\",\n\t\"Gap-Auth\",\n}\n\nvar (\n\t// ErrNeedsLogin means the user should be redirected to the login page\n\tErrNeedsLogin = errors.New(\"redirect to login page\")\n)\n\n// OAuthProxy is the main authentication proxy\ntype OAuthProxy struct {\n\tCookieSeed     string\n\tCookieName     string\n\tCSRFCookieName string\n\tCookieDomain   string\n\tCookiePath     string\n\tCookieSecure   bool\n\tCookieHTTPOnly bool\n\tCookieExpire   time.Duration\n\tCookieRefresh  time.Duration\n\tCookieSameSite string\n\tValidator      func(string) bool\n\n\tRobotsPath        string\n\tPingPath          string\n\tSignInPath        string\n\tSignOutPath       string\n\tOAuthStartPath    string\n\tOAuthCallbackPath string\n\tAuthOnlyPath      string\n\tUserInfoPath      string\n\n\tredirectURL          *url.URL // the url to receive requests at\n\twhitelistDomains     []string\n\tprovider             providers.Provider\n\tproviderNameOverride string\n\tsessionStore         sessionsapi.SessionStore\n\tProxyPrefix          string\n\tSignInMessage        string\n\tHtpasswdFile         *HtpasswdFile\n\tDisplayHtpasswdForm  bool\n\tserveMux             http.Handler\n\tSetXAuthRequest      bool\n\tPassBasicAuth        bool\n\tSkipProviderButton   bool\n\tPassUserHeaders      bool\n\tBasicAuthPassword    string\n\tPassAccessToken      bool\n\tSetAuthorization     bool\n\tPassAuthorization    bool\n\tskipAuthRegex        []string\n\tskipAuthPreflight    bool\n\tskipJwtBearerTokens  bool\n\tjwtBearerVerifiers   []*oidc.IDTokenVerifier\n\tcompiledRegex        []*regexp.Regexp\n\ttemplates            *template.Template\n\tBanner               string\n\tFooter               string\n}\n\n// UpstreamProxy represents an upstream server to proxy to\ntype UpstreamProxy struct {\n\tupstream  string\n\thandler   http.Handler\n\twsHandler http.Handler\n\tauth      hmacauth.HmacAuth\n}\n\n// ServeHTTP proxies requests to the upstream provider while signing the\n// request headers\nfunc (u *UpstreamProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"GAP-Upstream-Address\", u.upstream)\n\tif u.auth != nil {\n\t\tr.Header.Set(\"GAP-Auth\", w.Header().Get(\"GAP-Auth\"))\n\t\tu.auth.SignRequest(r)\n\t}\n\tif u.wsHandler != nil && strings.EqualFold(r.Header.Get(\"Connection\"), \"upgrade\") && r.Header.Get(\"Upgrade\") == \"websocket\" {\n\t\tu.wsHandler.ServeHTTP(w, r)\n\t} else {\n\t\tu.handler.ServeHTTP(w, r)\n\t}\n\n}\n\n// NewReverseProxy creates a new reverse proxy for proxying requests to upstream\n// servers\nfunc NewReverseProxy(target *url.URL, opts *Options) (proxy *httputil.ReverseProxy) {\n\tproxy = httputil.NewSingleHostReverseProxy(target)\n\tproxy.FlushInterval = opts.FlushInterval\n\tif opts.SSLUpstreamInsecureSkipVerify {\n\t\tproxy.Transport = &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t}\n\t}\n\treturn proxy\n}\n\nfunc setProxyUpstreamHostHeader(proxy *httputil.ReverseProxy, target *url.URL) {\n\tdirector := proxy.Director\n\tproxy.Director = func(req *http.Request) {\n\t\tdirector(req)\n\t\t// use RequestURI so that we aren't unescaping encoded slashes in the request path\n\t\treq.Host = target.Host\n\t\treq.URL.Opaque = req.RequestURI\n\t\treq.URL.RawQuery = \"\"\n\t}\n}\n\nfunc setProxyDirector(proxy *httputil.ReverseProxy) {\n\tdirector := proxy.Director\n\tproxy.Director = func(req *http.Request) {\n\t\tdirector(req)\n\t\t// use RequestURI so that we aren't unescaping encoded slashes in the request path\n\t\treq.URL.Opaque = req.RequestURI\n\t\treq.URL.RawQuery = \"\"\n\t}\n}\n\n// NewFileServer creates a http.Handler to serve files from the filesystem\nfunc NewFileServer(path string, filesystemPath string) (proxy http.Handler) {\n\treturn http.StripPrefix(path, http.FileServer(http.Dir(filesystemPath)))\n}\n\n// NewWebSocketOrRestReverseProxy creates a reverse proxy for REST or websocket based on url\nfunc NewWebSocketOrRestReverseProxy(u *url.URL, opts *Options, auth hmacauth.HmacAuth) http.Handler {\n\tu.Path = \"\"\n\tproxy := NewReverseProxy(u, opts)\n\tif !opts.PassHostHeader {\n\t\tsetProxyUpstreamHostHeader(proxy, u)\n\t} else {\n\t\tsetProxyDirector(proxy)\n\t}\n\n\t// this should give us a wss:// scheme if the url is https:// based.\n\tvar wsProxy *wsutil.ReverseProxy\n\tif opts.ProxyWebSockets {\n\t\twsScheme := \"ws\" + strings.TrimPrefix(u.Scheme, \"http\")\n\t\twsURL := &url.URL{Scheme: wsScheme, Host: u.Host}\n\t\twsProxy = wsutil.NewSingleHostReverseProxy(wsURL)\n\t}\n\treturn &UpstreamProxy{\n\t\tupstream:  u.Host,\n\t\thandler:   proxy,\n\t\twsHandler: wsProxy,\n\t\tauth:      auth,\n\t}\n}\n\n// NewOAuthProxy creates a new instance of OAuthProxy from the options provided\nfunc NewOAuthProxy(opts *Options, validator func(string) bool) *OAuthProxy {\n\tserveMux := http.NewServeMux()\n\tvar auth hmacauth.HmacAuth\n\tif sigData := opts.signatureData; sigData != nil {\n\t\tauth = hmacauth.NewHmacAuth(sigData.hash, []byte(sigData.key),\n\t\t\tSignatureHeader, SignatureHeaders)\n\t}\n\tfor _, u := range opts.proxyURLs {\n\t\tpath := u.Path\n\t\thost := u.Host\n\t\tswitch u.Scheme {\n\t\tcase httpScheme, httpsScheme:\n\t\t\tlogger.Printf(\"mapping path %q => upstream %q\", path, u)\n\t\t\tproxy := NewWebSocketOrRestReverseProxy(u, opts, auth)\n\t\t\tserveMux.Handle(path, proxy)\n\t\tcase \"static\":\n\t\t\tresponseCode, err := strconv.Atoi(host)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Printf(\"unable to convert %q to int, use default \\\"200\\\"\", host)\n\t\t\t\tresponseCode = 200\n\t\t\t}\n\n\t\t\tserveMux.HandleFunc(path, func(rw http.ResponseWriter, req *http.Request) {\n\t\t\t\trw.WriteHeader(responseCode)\n\t\t\t\tfmt.Fprintf(rw, \"Authenticated\")\n\t\t\t})\n\t\tcase \"file\":\n\t\t\tif u.Fragment != \"\" {\n\t\t\t\tpath = u.Fragment\n\t\t\t}\n\t\t\tlogger.Printf(\"mapping path %q => file system %q\", path, u.Path)\n\t\t\tproxy := NewFileServer(path, u.Path)\n\t\t\tuProxy := UpstreamProxy{\n\t\t\t\tupstream:  path,\n\t\t\t\thandler:   proxy,\n\t\t\t\twsHandler: nil,\n\t\t\t\tauth:      nil,\n\t\t\t}\n\t\t\tserveMux.Handle(path, &uProxy)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unknown upstream protocol %s\", u.Scheme))\n\t\t}\n\t}\n\tfor _, u := range opts.CompiledRegex {\n\t\tlogger.Printf(\"compiled skip-auth-regex => %q\", u)\n\t}\n\n\tif opts.SkipJwtBearerTokens {\n\t\tlogger.Printf(\"Skipping JWT tokens from configured OIDC issuer: %q\", opts.OIDCIssuerURL)\n\t\tfor _, issuer := range opts.ExtraJwtIssuers {\n\t\t\tlogger.Printf(\"Skipping JWT tokens from extra JWT issuer: %q\", issuer)\n\t\t}\n\t}\n\tredirectURL := opts.redirectURL\n\tif redirectURL.Path == \"\" {\n\t\tredirectURL.Path = fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix)\n\t}\n\n\tlogger.Printf(\"OAuthProxy configured for %s Client ID: %s\", opts.provider.Data().ProviderName, opts.ClientID)\n\trefresh := \"disabled\"\n\tif opts.CookieRefresh != time.Duration(0) {\n\t\trefresh = fmt.Sprintf(\"after %s\", opts.CookieRefresh)\n\t}\n\n\tlogger.Printf(\"Cookie settings: name:%s secure(https):%v httponly:%v expiry:%s domain:%s path:%s samesite:%s refresh:%s\", opts.CookieName, opts.CookieSecure, opts.CookieHTTPOnly, opts.CookieExpire, opts.CookieDomain, opts.CookiePath, opts.CookieSameSite, refresh)\n\n\treturn &OAuthProxy{\n\t\tCookieName:     opts.CookieName,\n\t\tCSRFCookieName: fmt.Sprintf(\"%v_%v\", opts.CookieName, \"csrf\"),\n\t\tCookieSeed:     opts.CookieSecret,\n\t\tCookieDomain:   opts.CookieDomain,\n\t\tCookiePath:     opts.CookiePath,\n\t\tCookieSecure:   opts.CookieSecure,\n\t\tCookieHTTPOnly: opts.CookieHTTPOnly,\n\t\tCookieExpire:   opts.CookieExpire,\n\t\tCookieRefresh:  opts.CookieRefresh,\n\t\tCookieSameSite: opts.CookieSameSite,\n\t\tValidator:      validator,\n\n\t\tRobotsPath:        \"/robots.txt\",\n\t\tPingPath:          opts.PingPath,\n\t\tSignInPath:        fmt.Sprintf(\"%s/sign_in\", opts.ProxyPrefix),\n\t\tSignOutPath:       fmt.Sprintf(\"%s/sign_out\", opts.ProxyPrefix),\n\t\tOAuthStartPath:    fmt.Sprintf(\"%s/start\", opts.ProxyPrefix),\n\t\tOAuthCallbackPath: fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix),\n\t\tAuthOnlyPath:      fmt.Sprintf(\"%s/auth\", opts.ProxyPrefix),\n\t\tUserInfoPath:      fmt.Sprintf(\"%s/userinfo\", opts.ProxyPrefix),\n\n\t\tProxyPrefix:          opts.ProxyPrefix,\n\t\tprovider:             opts.provider,\n\t\tproviderNameOverride: opts.ProviderName,\n\t\tsessionStore:         opts.sessionStore,\n\t\tserveMux:             serveMux,\n\t\tredirectURL:          redirectURL,\n\t\twhitelistDomains:     opts.WhitelistDomains,\n\t\tskipAuthRegex:        opts.SkipAuthRegex,\n\t\tskipAuthPreflight:    opts.SkipAuthPreflight,\n\t\tskipJwtBearerTokens:  opts.SkipJwtBearerTokens,\n\t\tjwtBearerVerifiers:   opts.jwtBearerVerifiers,\n\t\tcompiledRegex:        opts.CompiledRegex,\n\t\tSetXAuthRequest:      opts.SetXAuthRequest,\n\t\tPassBasicAuth:        opts.PassBasicAuth,\n\t\tPassUserHeaders:      opts.PassUserHeaders,\n\t\tBasicAuthPassword:    opts.BasicAuthPassword,\n\t\tPassAccessToken:      opts.PassAccessToken,\n\t\tSetAuthorization:     opts.SetAuthorization,\n\t\tPassAuthorization:    opts.PassAuthorization,\n\t\tSkipProviderButton:   opts.SkipProviderButton,\n\t\ttemplates:            loadTemplates(opts.CustomTemplatesDir),\n\t\tBanner:               opts.Banner,\n\t\tFooter:               opts.Footer,\n\t}\n}\n\n// GetRedirectURI returns the redirectURL that the upstream OAuth Provider will\n// redirect clients to once authenticated\nfunc (p *OAuthProxy) GetRedirectURI(host string) string {\n\t// default to the request Host if not set\n\tif p.redirectURL.Host != \"\" {\n\t\treturn p.redirectURL.String()\n\t}\n\tvar u url.URL\n\tu = *p.redirectURL\n\tif u.Scheme == \"\" {\n\t\tif p.CookieSecure {\n\t\t\tu.Scheme = httpsScheme\n\t\t} else {\n\t\t\tu.Scheme = httpScheme\n\t\t}\n\t}\n\tu.Host = host\n\treturn u.String()\n}\n\nfunc (p *OAuthProxy) displayCustomLoginForm() bool {\n\treturn p.HtpasswdFile != nil && p.DisplayHtpasswdForm\n}\n\nfunc (p *OAuthProxy) redeemCode(host, code string) (s *sessionsapi.SessionState, err error) {\n\tif code == \"\" {\n\t\treturn nil, errors.New(\"missing code\")\n\t}\n\tredirectURI := p.GetRedirectURI(host)\n\ts, err = p.provider.Redeem(redirectURI, code)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif s.Email == \"\" {\n\t\ts.Email, err = p.provider.GetEmailAddress(s)\n\t}\n\n\tif s.User == \"\" {\n\t\ts.User, err = p.provider.GetUserName(s)\n\t\tif err != nil && err.Error() == \"not implemented\" {\n\t\t\terr = nil\n\t\t}\n\t}\n\treturn\n}\n\n// MakeCSRFCookie creates a cookie for CSRF\nfunc (p *OAuthProxy) MakeCSRFCookie(req *http.Request, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\treturn p.makeCookie(req, p.CSRFCookieName, value, expiration, now)\n}\n\nfunc (p *OAuthProxy) makeCookie(req *http.Request, name string, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\tif p.CookieDomain != \"\" {\n\t\tdomain := req.Host\n\t\tif h, _, err := net.SplitHostPort(domain); err == nil {\n\t\t\tdomain = h\n\t\t}\n\t\tif !strings.HasSuffix(domain, p.CookieDomain) {\n\t\t\tlogger.Printf(\"Warning: request host is %q but using configured cookie domain of %q\", domain, p.CookieDomain)\n\t\t}\n\t}\n\n\treturn &http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tPath:     p.CookiePath,\n\t\tDomain:   p.CookieDomain,\n\t\tHttpOnly: p.CookieHTTPOnly,\n\t\tSecure:   p.CookieSecure,\n\t\tExpires:  now.Add(expiration),\n\t\tSameSite: cookies.ParseSameSite(p.CookieSameSite),\n\t}\n}\n\n// ClearCSRFCookie creates a cookie to unset the CSRF cookie stored in the user's\n// session\nfunc (p *OAuthProxy) ClearCSRFCookie(rw http.ResponseWriter, req *http.Request) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, \"\", time.Hour*-1, time.Now()))\n}\n\n// SetCSRFCookie adds a CSRF cookie to the response\nfunc (p *OAuthProxy) SetCSRFCookie(rw http.ResponseWriter, req *http.Request, val string) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, val, p.CookieExpire, time.Now()))\n}\n\n// ClearSessionCookie creates a cookie to unset the user's authentication cookie\n// stored in the user's session\nfunc (p *OAuthProxy) ClearSessionCookie(rw http.ResponseWriter, req *http.Request) error {\n\treturn p.sessionStore.Clear(rw, req)\n}\n\n// LoadCookiedSession reads the user's authentication details from the request\nfunc (p *OAuthProxy) LoadCookiedSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\treturn p.sessionStore.Load(req)\n}\n\n// SaveSession creates a new session cookie value and sets this on the response\nfunc (p *OAuthProxy) SaveSession(rw http.ResponseWriter, req *http.Request, s *sessionsapi.SessionState) error {\n\treturn p.sessionStore.Save(rw, req, s)\n}\n\n// RobotsTxt disallows scraping pages from the OAuthProxy\nfunc (p *OAuthProxy) RobotsTxt(rw http.ResponseWriter) {\n\trw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")\n}\n\n// PingPage responds 200 OK to requests\nfunc (p *OAuthProxy) PingPage(rw http.ResponseWriter) {\n\trw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(rw, \"OK\")\n}\n\n// ErrorPage writes an error response\nfunc (p *OAuthProxy) ErrorPage(rw http.ResponseWriter, code int, title string, message string) {\n\trw.WriteHeader(code)\n\tt := struct {\n\t\tTitle       string\n\t\tMessage     string\n\t\tProxyPrefix string\n\t}{\n\t\tTitle:       fmt.Sprintf(\"%d %s\", code, title),\n\t\tMessage:     message,\n\t\tProxyPrefix: p.ProxyPrefix,\n\t}\n\tp.templates.ExecuteTemplate(rw, \"error.html\", t)\n}\n\n// SignInPage writes the sing in template to the response\nfunc (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {\n\tp.ClearSessionCookie(rw, req)\n\trw.WriteHeader(code)\n\n\tredirecURL := req.URL.RequestURI()\n\tif req.Header.Get(\"X-Auth-Request-Redirect\") != \"\" {\n\t\tredirecURL = req.Header.Get(\"X-Auth-Request-Redirect\")\n\t}\n\tif redirecURL == p.SignInPath {\n\t\tredirecURL = \"/\"\n\t}\n\n\tt := struct {\n\t\tProviderName  string\n\t\tSignInMessage string\n\t\tCustomLogin   bool\n\t\tRedirect      string\n\t\tVersion       string\n\t\tProxyPrefix   string\n\t\tFooter        template.HTML\n\t}{\n\t\tProviderName:  p.provider.Data().ProviderName,\n\t\tSignInMessage: p.SignInMessage,\n\t\tCustomLogin:   p.displayCustomLoginForm(),\n\t\tRedirect:      redirecURL,\n\t\tVersion:       VERSION,\n\t\tProxyPrefix:   p.ProxyPrefix,\n\t\tFooter:        template.HTML(p.Footer),\n\t}\n\tif p.providerNameOverride != \"\" {\n\t\tt.ProviderName = p.providerNameOverride\n\t}\n\tp.templates.ExecuteTemplate(rw, \"sign_in.html\", t)\n}\n\n// ManualSignIn handles basic auth logins to the proxy\nfunc (p *OAuthProxy) ManualSignIn(rw http.ResponseWriter, req *http.Request) (string, bool) {\n\tif req.Method != \"POST\" || p.HtpasswdFile == nil {\n\t\treturn \"\", false\n\t}\n\tuser := req.FormValue(\"username\")\n\tpasswd := req.FormValue(\"password\")\n\tif user == \"\" {\n\t\treturn \"\", false\n\t}\n\t// check auth\n\tif p.HtpasswdFile.Validate(user, passwd) {\n\t\tlogger.PrintAuthf(user, req, logger.AuthSuccess, \"Authenticated via HtpasswdFile\")\n\t\treturn user, true\n\t}\n\tlogger.PrintAuthf(user, req, logger.AuthFailure, \"Invalid authentication via HtpasswdFile\")\n\treturn \"\", false\n}\n\n// GetRedirect reads the query parameter to get the URL to redirect clients to\n// once authenticated with the OAuthProxy\nfunc (p *OAuthProxy) GetRedirect(req *http.Request) (redirect string, err error) {\n\terr = req.ParseForm()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tredirect = req.Header.Get(\"X-Auth-Request-Redirect\")\n\tif req.Form.Get(\"rd\") != \"\" {\n\t\tredirect = req.Form.Get(\"rd\")\n\t}\n\tif !p.IsValidRedirect(redirect) {\n\t\tredirect = req.URL.Path\n\t\tif strings.HasPrefix(redirect, p.ProxyPrefix) {\n\t\t\tredirect = \"/\"\n\t\t}\n\t}\n\n\treturn\n}\n\n// splitHostPort separates host and port. If the port is not valid, it returns\n// the entire input as host, and it doesn't check the validity of the host.\n// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.\n// *** taken from net/url, modified validOptionalPort() to accept \":*\"\nfunc splitHostPort(hostport string) (host, port string) {\n\thost = hostport\n\n\tcolon := strings.LastIndexByte(host, ':')\n\tif colon != -1 && validOptionalPort(host[colon:]) {\n\t\thost, port = host[:colon], host[colon+1:]\n\t}\n\n\tif strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {\n\t\thost = host[1 : len(host)-1]\n\t}\n\n\treturn\n}\n\n// validOptionalPort reports whether port is either an empty string\n// or matches /^:\\d*$/\n// *** taken from net/url, modified to accept \":*\"\nfunc validOptionalPort(port string) bool {\n\tif port == \"\" || port == \":*\" {\n\t\treturn true\n\t}\n\tif port[0] != ':' {\n\t\treturn false\n\t}\n\tfor _, b := range port[1:] {\n\t\tif b < '0' || b > '9' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// IsValidRedirect checks whether the redirect URL is whitelisted\nfunc (p *OAuthProxy) IsValidRedirect(redirect string) bool {\n\tswitch {\n\tcase strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\"):\n\t\treturn true\n\tcase strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):\n\t\tredirectURL, err := url.Parse(redirect)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tredirectHostname := redirectURL.Hostname()\n\n\t\tfor _, domain := range p.whitelistDomains {\n\t\t\tdomainHostname, domainPort := splitHostPort(strings.TrimLeft(domain, \".\"))\n\t\t\tif domainHostname == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, domainHostname)) {\n\t\t\t\t// the domain names match, now validate the ports\n\t\t\t\t// if the whitelisted domain's port is '*', allow all ports\n\t\t\t\t// if the whitelisted domain contains a specific port, only allow that port\n\t\t\t\t// if the whitelisted domain doesn't contain a port at all, only allow empty redirect ports ie http and https\n\t\t\t\tredirectPort := redirectURL.Port()\n\t\t\t\tif (domainPort == \"*\") ||\n\t\t\t\t\t(domainPort == redirectPort) ||\n\t\t\t\t\t(domainPort == \"\" && redirectPort == \"\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// IsWhitelistedRequest is used to check if auth should be skipped for this request\nfunc (p *OAuthProxy) IsWhitelistedRequest(req *http.Request) bool {\n\tisPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"\n\treturn isPreflightRequestAllowed || p.IsWhitelistedPath(req.URL.Path)\n}\n\n// IsWhitelistedPath is used to check if the request path is allowed without auth\nfunc (p *OAuthProxy) IsWhitelistedPath(path string) bool {\n\tfor _, u := range p.compiledRegex {\n\t\tif u.MatchString(path) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc getRemoteAddr(req *http.Request) (s string) {\n\ts = req.RemoteAddr\n\tif req.Header.Get(\"X-Real-IP\") != \"\" {\n\t\ts += fmt.Sprintf(\" (%q)\", req.Header.Get(\"X-Real-IP\"))\n\t}\n\treturn\n}\n\nfunc (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tswitch path := req.URL.Path; {\n\tcase path == p.RobotsPath:\n\t\tp.RobotsTxt(rw)\n\tcase path == p.PingPath:\n\t\tp.PingPage(rw)\n\tcase p.IsWhitelistedRequest(req):\n\t\tp.serveMux.ServeHTTP(rw, req)\n\tcase path == p.SignInPath:\n\t\tp.SignIn(rw, req)\n\tcase path == p.SignOutPath:\n\t\tp.SignOut(rw, req)\n\tcase path == p.OAuthStartPath:\n\t\tp.OAuthStart(rw, req)\n\tcase path == p.OAuthCallbackPath:\n\t\tp.OAuthCallback(rw, req)\n\tcase path == p.AuthOnlyPath:\n\t\tp.AuthenticateOnly(rw, req)\n\tcase path == p.UserInfoPath:\n\t\tp.UserInfo(rw, req)\n\tdefault:\n\t\tp.Proxy(rw, req)\n\t}\n}\n\n// SignIn serves a page prompting users to sign in\nfunc (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining redirect: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\n\tuser, ok := p.ManualSignIn(rw, req)\n\tif ok {\n\t\tsession := &sessionsapi.SessionState{User: user}\n\t\tp.SaveSession(rw, req, session)\n\t\thttp.Redirect(rw, req, redirect, 302)\n\t} else {\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusOK)\n\t\t}\n\t}\n}\n\n//UserInfo endpoint outputs session email in JSON format\nfunc (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {\n\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\tuserInfo := struct {\n\t\tEmail string `json:\"email\"`\n\t}{session.Email}\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\trw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(rw).Encode(userInfo)\n}\n\n// SignOut sends a response to clear the authentication cookie\nfunc (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining redirect: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\tp.ClearSessionCookie(rw, req)\n\thttp.Redirect(rw, req, redirect, 302)\n}\n\n// OAuthStart starts the OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthStart(rw http.ResponseWriter, req *http.Request) {\n\tnonce, err := encryption.Nonce()\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining nonce: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\tp.SetCSRFCookie(rw, req, nonce)\n\tredirect, err := p.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining redirect: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\tredirectURI := p.GetRedirectURI(req.Host)\n\thttp.Redirect(rw, req, p.provider.GetLoginURL(redirectURI, fmt.Sprintf(\"%v:%v\", nonce, redirect)), 302)\n}\n\n// OAuthCallback is the OAuth2 authentication flow callback that finishes the\n// OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthCallback(rw http.ResponseWriter, req *http.Request) {\n\tremoteAddr := getRemoteAddr(req)\n\n\t// finish the oauth cycle\n\terr := req.ParseForm()\n\tif err != nil {\n\t\tlogger.Printf(\"Error while parsing OAuth2 callback: %s\" + err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\terrorString := req.Form.Get(\"error\")\n\tif errorString != \"\" {\n\t\tlogger.Printf(\"Error while parsing OAuth2 callback: %s \", errorString)\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", errorString)\n\t\treturn\n\t}\n\n\tsession, err := p.redeemCode(req.Host, req.Form.Get(\"code\"))\n\tif err != nil {\n\t\tlogger.Printf(\"Error redeeming code during OAuth2 callback: %s \", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", \"Internal Error\")\n\t\treturn\n\t}\n\n\ts := strings.SplitN(req.Form.Get(\"state\"), \":\", 2)\n\tif len(s) != 2 {\n\t\tlogger.Printf(\"Error while parsing OAuth2 state: invalid length\")\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", \"Invalid State\")\n\t\treturn\n\t}\n\tnonce := s[0]\n\tredirect := s[1]\n\tc, err := req.Cookie(p.CSRFCookieName)\n\tif err != nil {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unable too obtain CSRF cookie\")\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", err.Error())\n\t\treturn\n\t}\n\tp.ClearCSRFCookie(rw, req)\n\tif c.Value != nonce {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: csrf token mismatch, potential attack\")\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", \"csrf failed\")\n\t\treturn\n\t}\n\n\tif !p.IsValidRedirect(redirect) {\n\t\tredirect = \"/\"\n\t}\n\n\t// set cookie, or deny\n\tif p.Validator(session.Email) && p.provider.ValidateGroup(session.Email) {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthSuccess, \"Authenticated via OAuth2: %s\", session)\n\t\terr := p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"%s %s\", remoteAddr, err)\n\t\t\tp.ErrorPage(rw, 500, \"Internal Error\", \"Internal Error\")\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, 302)\n\t} else {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unauthorized\")\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", \"Invalid Account\")\n\t}\n}\n\n// AuthenticateOnly checks whether the user is currently logged in\nfunc (p *OAuthProxy) AuthenticateOnly(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, \"unauthorized request\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// we are authenticated\n\tp.addHeadersForProxying(rw, req, session)\n\trw.WriteHeader(http.StatusAccepted)\n}\n\n// Proxy proxies the user request if the user is authenticated else it prompts\n// them to authenticate\nfunc (p *OAuthProxy) Proxy(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tswitch err {\n\tcase nil:\n\t\t// we are authenticated\n\t\tp.addHeadersForProxying(rw, req, session)\n\t\tp.serveMux.ServeHTTP(rw, req)\n\n\tcase ErrNeedsLogin:\n\t\t// we need to send the user to a login screen\n\t\tif isAjax(req) {\n\t\t\t// no point redirecting an AJAX request\n\t\t\tp.ErrorJSON(rw, http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusForbidden)\n\t\t}\n\n\tdefault:\n\t\t// unknown error\n\t\tlogger.Printf(\"Unexpected internal error: %s\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError,\n\t\t\t\"Internal Error\", \"Internal Error\")\n\t}\n\n}\n\n// getAuthenticatedSession checks whether a user is authenticated and returns a session object and nil error if so\n// Returns nil, ErrNeedsLogin if user needs to login.\n// Set-Cookie headers may be set on the response as a side-effect of calling this method.\nfunc (p *OAuthProxy) getAuthenticatedSession(rw http.ResponseWriter, req *http.Request) (*sessionsapi.SessionState, error) {\n\tvar session *sessionsapi.SessionState\n\tvar err error\n\tvar saveSession, clearSession, revalidated bool\n\n\tif p.skipJwtBearerTokens && req.Header.Get(\"Authorization\") != \"\" {\n\t\tsession, err = p.GetJwtSession(req)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error retrieving session from token in Authorization header: %s\", err)\n\t\t}\n\t\tif session != nil {\n\t\t\tsaveSession = false\n\t\t}\n\t}\n\n\tremoteAddr := getRemoteAddr(req)\n\tif session == nil {\n\t\tsession, err = p.LoadCookiedSession(req)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error loading cookied session: %s\", err)\n\t\t}\n\n\t\tif session != nil {\n\t\t\tif session.Age() > p.CookieRefresh && p.CookieRefresh != time.Duration(0) {\n\t\t\t\tlogger.Printf(\"Refreshing %s old session cookie for %s (refresh after %s)\", session.Age(), session, p.CookieRefresh)\n\t\t\t\tsaveSession = true\n\t\t\t}\n\n\t\t\tif ok, err := p.provider.RefreshSessionIfNeeded(session); err != nil {\n\t\t\t\tlogger.Printf(\"%s removing session. error refreshing access token %s %s\", remoteAddr, err, session)\n\t\t\t\tclearSession = true\n\t\t\t\tsession = nil\n\t\t\t} else if ok {\n\t\t\t\tsaveSession = true\n\t\t\t\trevalidated = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif session != nil && session.IsExpired() {\n\t\tlogger.Printf(\"Removing session: token expired %s\", session)\n\t\tsession = nil\n\t\tsaveSession = false\n\t\tclearSession = true\n\t}\n\n\tif saveSession && !revalidated && session != nil && session.AccessToken != \"\" {\n\t\tif !p.provider.ValidateSessionState(session) {\n\t\t\tlogger.Printf(\"Removing session: error validating %s\", session)\n\t\t\tsaveSession = false\n\t\t\tsession = nil\n\t\t\tclearSession = true\n\t\t}\n\t}\n\n\tif session != nil && session.Email != \"\" {\n\t\tif !p.Validator(session.Email) || !p.provider.ValidateGroup(session.Email) {\n\t\t\tlogger.Printf(session.Email, req, logger.AuthFailure, \"Invalid authentication via session: removing session %s\", session)\n\t\t\tsession = nil\n\t\t\tsaveSession = false\n\t\t\tclearSession = true\n\t\t}\n\t}\n\n\tif saveSession && session != nil {\n\t\terr = p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.PrintAuthf(session.Email, req, logger.AuthError, \"Save session error %s\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif clearSession {\n\t\tp.ClearSessionCookie(rw, req)\n\t}\n\n\tif session == nil {\n\t\tsession, err = p.CheckBasicAuth(req)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error during basic auth validation: %s\", err)\n\t\t}\n\t}\n\n\tif session == nil {\n\t\treturn nil, ErrNeedsLogin\n\t}\n\n\treturn session, nil\n}\n\n// addHeadersForProxying adds the appropriate headers the request / response for proxying\nfunc (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, req *http.Request, session *sessionsapi.SessionState) {\n\tif p.PassBasicAuth {\n\t\treq.SetBasicAuth(session.User, p.BasicAuthPassword)\n\t\treq.Header[\"X-Forwarded-User\"] = []string{session.User}\n\t\tif session.Email != \"\" {\n\t\t\treq.Header[\"X-Forwarded-Email\"] = []string{session.Email}\n\t\t} else {\n\t\t\treq.Header.Del(\"X-Forwarded-Email\")\n\t\t}\n\t}\n\n\tif p.PassUserHeaders {\n\t\treq.Header[\"X-Forwarded-User\"] = []string{session.User}\n\t\tif session.Email != \"\" {\n\t\t\treq.Header[\"X-Forwarded-Email\"] = []string{session.Email}\n\t\t} else {\n\t\t\treq.Header.Del(\"X-Forwarded-Email\")\n\t\t}\n\t}\n\n\tif p.SetXAuthRequest {\n\t\trw.Header().Set(\"X-Auth-Request-User\", session.User)\n\t\tif session.Email != \"\" {\n\t\t\trw.Header().Set(\"X-Auth-Request-Email\", session.Email)\n\t\t} else {\n\t\t\trw.Header().Del(\"X-Auth-Request-Email\")\n\t\t}\n\n\t\tif p.PassAccessToken {\n\t\t\tif session.AccessToken != \"\" {\n\t\t\t\trw.Header().Set(\"X-Auth-Request-Access-Token\", session.AccessToken)\n\t\t\t} else {\n\t\t\t\trw.Header().Del(\"X-Auth-Request-Access-Token\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif p.PassAccessToken {\n\t\tif session.AccessToken != \"\" {\n\t\t\treq.Header[\"X-Forwarded-Access-Token\"] = []string{session.AccessToken}\n\t\t} else {\n\t\t\treq.Header.Del(\"X-Forwarded-Access-Token\")\n\t\t}\n\t}\n\n\tif p.PassAuthorization {\n\t\tif session.IDToken != \"\" {\n\t\t\treq.Header[\"Authorization\"] = []string{fmt.Sprintf(\"Bearer %s\", session.IDToken)}\n\t\t} else {\n\t\t\treq.Header.Del(\"Authorization\")\n\t\t}\n\t}\n\tif p.SetAuthorization {\n\t\tif session.IDToken != \"\" {\n\t\t\trw.Header().Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", session.IDToken))\n\t\t} else {\n\t\t\trw.Header().Del(\"Authorization\")\n\t\t}\n\t}\n\n\tif session.Email == \"\" {\n\t\trw.Header().Set(\"GAP-Auth\", session.User)\n\t} else {\n\t\trw.Header().Set(\"GAP-Auth\", session.Email)\n\t}\n}\n\n// CheckBasicAuth checks the requests Authorization header for basic auth\n// credentials and authenticates these against the proxies HtpasswdFile\nfunc (p *OAuthProxy) CheckBasicAuth(req *http.Request) (*sessionsapi.SessionState, error) {\n\tif p.HtpasswdFile == nil {\n\t\treturn nil, nil\n\t}\n\tauth := req.Header.Get(\"Authorization\")\n\tif auth == \"\" {\n\t\treturn nil, nil\n\t}\n\ts := strings.SplitN(auth, \" \", 2)\n\tif len(s) != 2 || s[0] != \"Basic\" {\n\t\treturn nil, fmt.Errorf(\"invalid Authorization header %s\", req.Header.Get(\"Authorization\"))\n\t}\n\tb, err := b64.StdEncoding.DecodeString(s[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpair := strings.SplitN(string(b), \":\", 2)\n\tif len(pair) != 2 {\n\t\treturn nil, fmt.Errorf(\"invalid format %s\", b)\n\t}\n\tif p.HtpasswdFile.Validate(pair[0], pair[1]) {\n\t\tlogger.PrintAuthf(pair[0], req, logger.AuthSuccess, \"Authenticated via basic auth and HTpasswd File\")\n\t\treturn &sessionsapi.SessionState{User: pair[0]}, nil\n\t}\n\tlogger.PrintAuthf(pair[0], req, logger.AuthFailure, \"Invalid authentication via basic auth: not in Htpasswd File\")\n\treturn nil, nil\n}\n\n// isAjax checks if a request is an ajax request\nfunc isAjax(req *http.Request) bool {\n\tacceptValues, ok := req.Header[\"accept\"]\n\tif !ok {\n\t\tacceptValues = req.Header[\"Accept\"]\n\t}\n\tconst ajaxReq = applicationJSON\n\tfor _, v := range acceptValues {\n\t\tif v == ajaxReq {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ErrorJSON returns the error code with an application/json mime type\nfunc (p *OAuthProxy) ErrorJSON(rw http.ResponseWriter, code int) {\n\trw.Header().Set(\"Content-Type\", applicationJSON)\n\trw.WriteHeader(code)\n}\n\n// GetJwtSession loads a session based on a JWT token in the authorization header.\nfunc (p *OAuthProxy) GetJwtSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\trawBearerToken, err := p.findBearerToken(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx := context.Background()\n\tvar session *sessionsapi.SessionState\n\tfor _, verifier := range p.jwtBearerVerifiers {\n\t\tbearerToken, err := verifier.Verify(ctx, rawBearerToken)\n\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"failed to verify bearer token: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar claims struct {\n\t\t\tSubject  string `json:\"sub\"`\n\t\t\tEmail    string `json:\"email\"`\n\t\t\tVerified *bool  `json:\"email_verified\"`\n\t\t}\n\n\t\tif err := bearerToken.Claims(&claims); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse bearer token claims: %v\", err)\n\t\t}\n\n\t\tif claims.Email == \"\" {\n\t\t\tclaims.Email = claims.Subject\n\t\t}\n\n\t\tif claims.Verified != nil && !*claims.Verified {\n\t\t\treturn nil, fmt.Errorf(\"email in id_token (%s) isn't verified\", claims.Email)\n\t\t}\n\n\t\tsession = &sessionsapi.SessionState{\n\t\t\tAccessToken:  rawBearerToken,\n\t\t\tIDToken:      rawBearerToken,\n\t\t\tRefreshToken: \"\",\n\t\t\tExpiresOn:    bearerToken.Expiry,\n\t\t\tEmail:        claims.Email,\n\t\t\tUser:         claims.Email,\n\t\t}\n\t\treturn session, nil\n\t}\n\treturn nil, fmt.Errorf(\"unable to verify jwt token %s\", req.Header.Get(\"Authorization\"))\n}\n\n// findBearerToken finds a valid JWT token from the Authorization header of a given request.\nfunc (p *OAuthProxy) findBearerToken(req *http.Request) (string, error) {\n\tauth := req.Header.Get(\"Authorization\")\n\ts := strings.SplitN(auth, \" \", 2)\n\tif len(s) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid authorization header %s\", auth)\n\t}\n\tjwtRegex := regexp.MustCompile(`^eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]+$`)\n\tvar rawBearerToken string\n\tif s[0] == \"Bearer\" && jwtRegex.MatchString(s[1]) {\n\t\trawBearerToken = s[1]\n\t} else if s[0] == \"Basic\" {\n\t\t// Check if we have a Bearer token masquerading in Basic\n\t\tb, err := b64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\treturn \"\", fmt.Errorf(\"invalid format %s\", b)\n\t\t}\n\t\tuser, password := pair[0], pair[1]\n\n\t\t// check user, user+password, or just password for a token\n\t\tif jwtRegex.MatchString(user) {\n\t\t\t// Support blank passwords or magic `x-oauth-basic` passwords - nothing else\n\t\t\tif password == \"\" || password == \"x-oauth-basic\" {\n\t\t\t\trawBearerToken = user\n\t\t\t}\n\t\t} else if jwtRegex.MatchString(password) {\n\t\t\t// support passwords and ignore user\n\t\t\trawBearerToken = password\n\t\t}\n\t}\n\tif rawBearerToken == \"\" {\n\t\treturn \"\", fmt.Errorf(\"no valid bearer token found in authorization header\")\n\t}\n\n\treturn rawBearerToken, nil\n}\n"], "fixing_code": ["# Vx.x.x (Pre-release)\n\n## Release Hightlights\n\n## Important Notes\n\n## Breaking Changes\n\n## Changes since v5.0.0\n\n# v5.0.0\n\n## Release Hightlights\n- Disabled CGO (binaries will work regardless og glibc/musl)\n- Allow whitelisted redirect ports\n- Nextcloud provider support added\n- DigitalOcean provider support added\n\n## Important Notes\n- (Security) Fix for open redirect vulnerability..  a bad actor using `/\\` in redirect URIs can redirect a session to another domain\n\n## Breaking Changes\n\n- [#321](https://github.com/pusher/oauth2_proxy/pull/331) Add reverse proxy boolean flag to control whether headers like `X-Real-Ip` are accepted.\n  This defaults to false. **Usage behind a reverse proxy will require this flag to be set to avoid logging the reverse proxy IP address**.\n\n## Changes since v4.1.0\n\n- [#331](https://github.com/pusher/oauth2_proxy/pull/331) Add reverse proxy setting (@martin-css)\n- [#365](https://github.com/pusher/oauth2_proxy/pull/365) Build with CGO=0 (@tomelliff)\n- [#339](https://github.com/pusher/oauth2_proxy/pull/339) Add configuration for cookie 'SameSite' value. (@pgroudas)\n- [#347](https://github.com/pusher/oauth2_proxy/pull/347) Update keycloak provider configuration documentation. (@sushiMix)\n- [#325](https://github.com/pusher/oauth2_proxy/pull/325) dist.sh: use sha256sum (@syscll)\n- [#179](https://github.com/pusher/oauth2_proxy/pull/179) Add Nextcloud provider (@Ramblurr)\n- [#280](https://github.com/pusher/oauth2_proxy/pull/280) whitelisted redirect domains: add support for whitelisting specific ports or allowing wildcard ports (@kamaln7)\n- [#351](https://github.com/pusher/oauth2_proxy/pull/351) Add DigitalOcean Auth provider (@kamaln7)\n\n# v4.1.0\n\n## Release Highlights\n- Added Keycloak provider\n- Build on Go 1.13\n- Upgrade Docker image to use Debian Buster\n- Added support for FreeBSD builds\n- Added new logo\n- Added support for GitHub teams\n\n## Important Notes\nN/A\n\n## Breaking Changes\nN/A\n\n## Changes since v4.0.0\n- [#292](https://github.com/pusher/oauth2_proxy/pull/292) Added bash >= 4.0 dependency to configure script (@jmfrank63)\n- [#227](https://github.com/pusher/oauth2_proxy/pull/227) Add Keycloak provider (@Ofinka)\n- [#259](https://github.com/pusher/oauth2_proxy/pull/259) Redirect to HTTPS (@jmickey)\n- [#273](https://github.com/pusher/oauth2_proxy/pull/273) Support Go 1.13 (@dio)\n- [#275](https://github.com/pusher/oauth2_proxy/pull/275) docker: build from debian buster (@syscll)\n- [#258](https://github.com/pusher/oauth2_proxy/pull/258) Add IDToken for Azure provider (@leyshon)\n  - This PR adds the IDToken into the session for the Azure provider allowing requests to a backend to be identified as a specific user. As a consequence, if you are using a cookie to store the session the cookie will now exceed the 4kb size limit and be split into multiple cookies. This can cause problems when using nginx as a proxy, resulting in no cookie being passed at all. Either increase the proxy_buffer_size in nginx or implement the redis session storage (see https://pusher.github.io/oauth2_proxy/configuration#redis-storage)\n- [#286](https://github.com/pusher/oauth2_proxy/pull/286) Requests.go updated with useful error messages (@biotom)\n- [#274](https://github.com/pusher/oauth2_proxy/pull/274) Supports many github teams with api pagination support (@toshi-miura, @apratina)\n- [#302](https://github.com/pusher/oauth2_proxy/pull/302) Rewrite dist script (@syscll)\n- [#304](https://github.com/pusher/oauth2_proxy/pull/304) Add new Logo! :tada: (@JoelSpeed)\n- [#300](https://github.com/pusher/oauth2_proxy/pull/300) Added userinfo endpoint (@kbabuadze)\n- [#309](https://github.com/pusher/oauth2_proxy/pull/309) Added support for custom CA when connecting to Redis cache (@lleszczu)\n- [#248](https://github.com/pusher/oauth2_proxy/pull/248) Fix issue with X-Auth-Request-Redirect header being ignored (@webnard)\n- [#314](https://github.com/pusher/oauth2_proxy/pull/314) Add redirect capability to sign_out (@costelmoraru)\n- [#265](https://github.com/pusher/oauth2_proxy/pull/265) Add upstream with static response (@cgroschupp)\n- [#317](https://github.com/pusher/oauth2_proxy/pull/317) Add build for FreeBSD (@fnkr)\n- [#296](https://github.com/pusher/oauth2_proxy/pull/296) Allow to override provider's name for sign-in page (@ffdybuster)\n\n# v4.0.0\n\n## Release Highlights\n- Documentation is now on a [microsite](https://pusher.github.io/oauth2_proxy/)\n- Health check logging can now be disabled for quieter logs\n- Authorization Header JWTs can now be verified by the proxy to skip authentication for machine users\n- Sessions can now be stored in Redis. This reduces refresh failures and uses smaller cookies (Recommended for those using OIDC refreshing)\n- Logging overhaul allows customisable logging formats\n\n## Important Notes\n- This release includes a number of breaking changes that will require users to\nreconfigure their proxies. Please read the Breaking Changes below thoroughly.\n\n## Breaking Changes\n\n- [#231](https://github.com/pusher/oauth2_proxy/pull/231) Rework GitLab provider\n  - This PR changes the configuration options for the GitLab provider to use\n  a self-hosted instance. You now need to specify a `-oidc-issuer-url` rather than\n  explicit `-login-url`, `-redeem-url` and `-validate-url` parameters.\n- [#186](https://github.com/pusher/oauth2_proxy/pull/186) Make config consistent\n  - This PR changes configuration options so that all flags have a config counterpart\n  of the same name but with underscores (`_`) in place of hyphens (`-`).\n  This change affects the following flags:\n  - The `--tls-key` flag is now `--tls-key-file` to be consistent with existing\n  file flags and the existing config and environment settings\n  - The `--tls-cert` flag is now `--tls-cert-file` to be consistent with existing\n  file flags and the existing config and environment settings\n  This change affects the following existing configuration options:\n  - The `proxy-prefix` option is now `proxy_prefix`.\n  This PR changes environment variables so that all flags have an environment\n  counterpart of the same name but capitalised, with underscores (`_`) in place\n  of hyphens (`-`) and with the prefix `OAUTH2_PROXY_`.\n  This change affects the following existing environment variables:\n  - The `OAUTH2_SKIP_OIDC_DISCOVERY` environment variable is now `OAUTH2_PROXY_SKIP_OIDC_DISCOVERY`.\n  - The `OAUTH2_OIDC_JWKS_URL` environment variable is now `OAUTH2_PROXY_OIDC_JWKS_URL`.\n- [#146](https://github.com/pusher/oauth2_proxy/pull/146) Use full email address as `User` if the auth response did not contain a `User` field\n  - This change modifies the contents of the `X-Forwarded-User` header supplied by the proxy for users where the auth response from the IdP did not contain\n    a username.\n    In that case, this header used to only contain the local part of the user's email address (e.g. `john.doe` for `john.doe@example.com`) but now contains\n    the user's full email address instead.\n- [#170](https://github.com/pusher/oauth2_proxy/pull/170) Pre-built binary tarballs changed format\n  - The pre-built binary tarballs again match the format of the [bitly](https://github.com/bitly/oauth2_proxy) repository, where the unpacked directory\n    has the same name as the tarball and the binary is always named `oauth2_proxy`. This was done to restore compatibility with third-party automation\n    recipes like https://github.com/jhoblitt/puppet-oauth2_proxy.\n\n## Changes since v3.2.0\n\n- [#234](https://github.com/pusher/oauth2_proxy/pull/234) Added option `-ssl-upstream-insecure-skip-validation` to skip validation of upstream SSL certificates (@jansinger)\n- [#224](https://github.com/pusher/oauth2_proxy/pull/224) Check Google group membership using hasMember to support nested groups and external users (@jpalpant)\n- [#231](https://github.com/pusher/oauth2_proxy/pull/231) Add optional group membership and email domain checks to the GitLab provider (@Overv)\n- [#226](https://github.com/pusher/oauth2_proxy/pull/226) Made setting of proxied headers deterministic based on configuration alone (@aeijdenberg)\n- [#178](https://github.com/pusher/oauth2_proxy/pull/178) Add Silence Ping Logging and Exclude Logging Paths flags (@kskewes)\n- [#209](https://github.com/pusher/oauth2_proxy/pull/209) Improve docker build caching of layers (@dekimsey)\n- [#186](https://github.com/pusher/oauth2_proxy/pull/186) Make config consistent (@JoelSpeed)\n- [#187](https://github.com/pusher/oauth2_proxy/pull/187) Move root packages to pkg folder (@JoelSpeed)\n- [#65](https://github.com/pusher/oauth2_proxy/pull/65) Improvements to authenticate requests with a JWT bearer token in the `Authorization` header via\n  the `-skip-jwt-bearer-token` options. (@brianv0)\n  - Additional verifiers can be configured via the `-extra-jwt-issuers` flag if the JWT issuers is either an OpenID provider or has a JWKS URL\n  (e.g. `https://example.com/.well-known/jwks.json`).\n- [#180](https://github.com/pusher/oauth2_proxy/pull/180) Minor refactor of core proxying path (@aeijdenberg).\n- [#175](https://github.com/pusher/oauth2_proxy/pull/175) Bump go-oidc to v2.0.0 (@aeijdenberg).\n  - Includes fix for potential signature checking issue when OIDC discovery is skipped.\n- [#155](https://github.com/pusher/oauth2_proxy/pull/155) Add RedisSessionStore implementation (@brianv0, @JoelSpeed)\n  - Implement flags to configure the redis session store\n    - `-session-store-type=redis` Sets the store type to redis\n    - `-redis-connection-url` Sets the Redis connection URL\n    - `-redis-use-sentinel=true` Enables Redis Sentinel support\n    - `-redis-sentinel-master-name` Sets the Sentinel master name, if sentinel is enabled\n    - `-redis-sentinel-connection-urls` Defines the Redis Sentinel Connection URLs, if sentinel is enabled\n  - Introduces the concept of a session ticket. Tickets are composed of the cookie name, a session ID, and a secret.\n  - Redis Sessions are stored encrypted with a per-session secret\n  - Added tests for server based session stores\n- [#168](https://github.com/pusher/oauth2_proxy/pull/168) Drop Go 1.11 support in Travis (@JoelSpeed)\n- [#169](https://github.com/pusher/oauth2_proxy/pull/169) Update Alpine to 3.9 (@kskewes)\n- [#148](https://github.com/pusher/oauth2_proxy/pull/148) Implement SessionStore interface within proxy (@JoelSpeed)\n- [#147](https://github.com/pusher/oauth2_proxy/pull/147) Add SessionStore interfaces and initial implementation (@JoelSpeed)\n  - Allows for multiple different session storage implementations including client and server side\n  - Adds tests suite for interface to ensure consistency across implementations\n  - Refactor some configuration options (around cookies) into packages\n- [#114](https://github.com/pusher/oauth2_proxy/pull/114), [#154](https://github.com/pusher/oauth2_proxy/pull/154) Documentation is now available live at our [docs website](https://pusher.github.io/oauth2_proxy/) (@JoelSpeed, @icelynjennings)\n- [#146](https://github.com/pusher/oauth2_proxy/pull/146) Use full email address as `User` if the auth response did not contain a `User` field (@gargath)\n- [#144](https://github.com/pusher/oauth2_proxy/pull/144) Use GO 1.12 for ARM builds (@kskewes)\n- [#142](https://github.com/pusher/oauth2_proxy/pull/142) ARM Docker USER fix (@kskewes)\n- [#52](https://github.com/pusher/oauth2_proxy/pull/52) Logging Improvements (@MisterWil)\n  - Implement flags to configure file logging\n    - `-logging-filename` Defines the filename to log to\n    - `-logging-max-size` Defines the maximum\n    - `-logging-max-age` Defines the maximum age of backups to retain\n    - `-logging-max-backups` Defines the maximum number of rollover log files to retain\n    - `-logging-compress` Defines if rollover log files should be compressed\n    - `-logging-local-time` Defines if logging date and time should be local or UTC\n  - Implement two new flags to enable or disable specific logging types\n    - `-standard-logging` Enables or disables standard (not request or auth) logging\n    - `-auth-logging` Enables or disables auth logging\n  - Implement two new flags to customize the logging format\n    - `-standard-logging-format` Sets the format for standard logging\n    - `-auth-logging-format` Sets the format for auth logging\n- [#111](https://github.com/pusher/oauth2_proxy/pull/111) Add option for telling where to find a login.gov JWT key file (@timothy-spencer)\n- [#170](https://github.com/pusher/oauth2_proxy/pull/170) Restore binary tarball contents to be compatible with bitlys original tarballs (@zeha)\n- [#185](https://github.com/pusher/oauth2_proxy/pull/185) Fix an unsupported protocol scheme error during token validation when using the Azure provider (@jonas)\n- [#141](https://github.com/pusher/oauth2_proxy/pull/141) Check google group membership based on email address (@bchess)\n  - Google Group membership is additionally checked via email address, allowing users outside a GSuite domain to be authorized.\n- [#195](https://github.com/pusher/oauth2_proxy/pull/195) Add `-banner` flag for overriding the banner line that is displayed (@steakunderscore)\n- [#198](https://github.com/pusher/oauth2_proxy/pull/198) Switch from gometalinter to golangci-lint (@steakunderscore)\n- [#159](https://github.com/pusher/oauth2_proxy/pull/159) Add option to skip the OIDC provider verified email check: `--insecure-oidc-allow-unverified-email` (@djfinlay)\n- [#210](https://github.com/pusher/oauth2_proxy/pull/210) Update base image from Alpine 3.9 to 3.10 (@steakunderscore)\n- [#201](https://github.com/pusher/oauth2_proxy/pull/201) Add Bitbucket as new OAuth2 provider, accepts email, team and repository permissions to determine authorization (@aledeganopix4d)\n  - Implement flags to enable Bitbucket authentication:\n    - `-bitbucket-repository` Restrict authorization to users that can access this repository\n    - `-bitbucket-team` Restrict authorization to users that are part of this Bitbucket team\n- [#211](https://github.com/pusher/oauth2_proxy/pull/211) Switch from dep to go modules (@steakunderscore)\n- [#145](https://github.com/pusher/oauth2_proxy/pull/145) Add support for OIDC UserInfo endpoint email verification (@rtluckie)\n\n# v3.2.0\n\n## Release highlights\n- Internal restructure of session state storage to use JSON rather than proprietary scheme\n- Added health check options for running on GCP behind a load balancer\n- Improved support for protecting websockets\n- Added provider for login.gov\n- Allow manual configuration of OIDC providers\n\n## Important notes\n- Dockerfile user is now non-root, this may break your existing deployment\n- In the OIDC provider, when no email is returned, the ID Token subject will be used\ninstead of returning an error\n- GitHub user emails must now be primary and verified before authenticating\n\n## Changes since v3.1.0\n\n- [#96](https://github.com/bitly/oauth2_proxy/pull/96) Check if email is verified on GitHub (@caarlos0)\n- [#110](https://github.com/pusher/oauth2_proxy/pull/110) Added GCP healthcheck option (@timothy-spencer)\n- [#112](https://github.com/pusher/oauth2_proxy/pull/112) Improve websocket support (@gyson)\n- [#63](https://github.com/pusher/oauth2_proxy/pull/63) Use encoding/json for SessionState serialization (@yaegashi)\n  - Use JSON to encode session state to be stored in browser cookies\n  - Implement legacy decode function to support existing cookies generated by older versions\n  - Add detailed table driven tests in session_state_test.go\n- [#120](https://github.com/pusher/oauth2_proxy/pull/120) Encrypting user/email from cookie (@costelmoraru)\n- [#55](https://github.com/pusher/oauth2_proxy/pull/55) Added login.gov provider (@timothy-spencer)\n- [#55](https://github.com/pusher/oauth2_proxy/pull/55) Added environment variables for all config options (@timothy-spencer)\n- [#70](https://github.com/pusher/oauth2_proxy/pull/70) Fix handling of splitted cookies (@einfachchr)\n- [#92](https://github.com/pusher/oauth2_proxy/pull/92) Merge websocket proxy feature from openshift/oauth-proxy (@butzist)\n- [#57](https://github.com/pusher/oauth2_proxy/pull/57) Fall back to using OIDC Subject instead of Email (@aigarius)\n- [#85](https://github.com/pusher/oauth2_proxy/pull/85) Use non-root user in docker images (@kskewes)\n- [#68](https://github.com/pusher/oauth2_proxy/pull/68) forward X-Auth-Access-Token header (@davidholsgrove)\n- [#41](https://github.com/pusher/oauth2_proxy/pull/41) Added option to manually specify OIDC endpoints instead of relying on discovery\n- [#83](https://github.com/pusher/oauth2_proxy/pull/83) Add `id_token` refresh to Google provider (@leki75)\n- [#10](https://github.com/pusher/oauth2_proxy/pull/10) fix redirect url param handling (@dt-rush)\n- [#122](https://github.com/pusher/oauth2_proxy/pull/122) Expose -cookie-path as configuration parameter (@costelmoraru)\n- [#124](https://github.com/pusher/oauth2_proxy/pull/124) Use Go 1.12 for testing and build environments (@syscll)\n\n# v3.1.0\n\n## Release highlights\n\n- Introduction of ARM releases and and general improvements to Docker builds\n- Improvements to OIDC provider allowing pass-through of ID Tokens\n- Multiple redirect domains can now be whitelisted\n- Streamed responses are now flushed periodically\n\n## Important notes\n\n- If you have been using [#bitly/621](https://github.com/bitly/oauth2_proxy/pull/621)\n  and have cookies larger than the 4kb limit,\n  the cookie splitting pattern has changed and now uses `_` in place of `-` when\n  indexing cookies.\n  This will force users to reauthenticate the first time they use `v3.1.0`.\n- Streamed responses will now be flushed every 1 second by default.\n  Previously streamed responses were flushed only when the buffer was full.\n  To retain the old behaviour set `--flush-interval=0`.\n  See [#23](https://github.com/pusher/oauth2_proxy/pull/23) for further details.\n\n## Changes since v3.0.0\n\n- [#14](https://github.com/pusher/oauth2_proxy/pull/14) OIDC ID Token, Authorization Headers, Refreshing and Verification (@joelspeed)\n  - Implement `pass-authorization-header` and `set-authorization-header` flags\n  - Implement token refreshing in OIDC provider\n  - Split cookies larger than 4k limit into multiple cookies\n  - Implement token validation in OIDC provider\n- [#15](https://github.com/pusher/oauth2_proxy/pull/15) WhitelistDomains (@joelspeed)\n  - Add `--whitelist-domain` flag to allow redirection to approved domains after OAuth flow\n- [#21](https://github.com/pusher/oauth2_proxy/pull/21) Docker Improvement (@yaegashi)\n  - Move Docker base image from debian to alpine\n  - Install ca-certificates in docker image\n- [#23](https://github.com/pusher/oauth2_proxy/pull/23) Flushed streaming responses\n  - Long-running upstream responses will get flushed every <timeperiod> (1 second by default)\n- [#24](https://github.com/pusher/oauth2_proxy/pull/24) Redirect fix (@agentgonzo)\n  - After a successful login, you will be redirected to your original URL rather than /\n- [#35](https://github.com/pusher/oauth2_proxy/pull/35) arm and arm64 binary releases (@kskewes)\n  - Add armv6 and arm64 to Makefile `release` target\n- [#37](https://github.com/pusher/oauth2_proxy/pull/37) cross build arm and arm64 docker images (@kskewes)\n\n# v3.0.0\n\nAdoption of OAuth2_Proxy by Pusher.\nProject was hard forked and tidied however no logical changes have occurred since\nv2.2 as released by Bitly.\n\n## Changes since v2.2:\n\n- [#7](https://github.com/pusher/oauth2_proxy/pull/7) Migration to Pusher (@joelspeed)\n  - Move automated build to debian base image\n  - Add Makefile\n    - Update CI to run `make test`\n    - Update Dockerfile to use `make clean oauth2_proxy`\n    - Update `VERSION` parameter to be set by `ldflags` from Git Status\n    - Remove lint and test scripts\n  - Remove Go v1.8.x from Travis CI testing\n  - Add CODEOWNERS file\n  - Add CONTRIBUTING guide\n  - Add Issue and Pull Request templates\n  - Add Dockerfile\n  - Fix fsnotify import\n  - Update README to reflect new repository ownership\n  - Update CI scripts to separate linting and testing\n    - Now using `gometalinter` for linting\n  - Move Go import path from `github.com/bitly/oauth2_proxy` to `github.com/pusher/oauth2_proxy`\n  - Repository forked on 27/11/18\n    - README updated to include note that this repository is forked\n    - CHANGLOG created to track changes to repository from original fork\n", "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\tb64 \"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/mbland/hmacauth\"\n\tsessionsapi \"github.com/pusher/oauth2_proxy/pkg/apis/sessions\"\n\t\"github.com/pusher/oauth2_proxy/pkg/cookies\"\n\t\"github.com/pusher/oauth2_proxy/pkg/encryption\"\n\t\"github.com/pusher/oauth2_proxy/pkg/logger\"\n\t\"github.com/pusher/oauth2_proxy/providers\"\n\t\"github.com/yhat/wsutil\"\n)\n\nconst (\n\t// SignatureHeader is the name of the request header containing the GAP Signature\n\t// Part of hmacauth\n\tSignatureHeader = \"GAP-Signature\"\n\n\thttpScheme  = \"http\"\n\thttpsScheme = \"https\"\n\n\tapplicationJSON = \"application/json\"\n)\n\n// SignatureHeaders contains the headers to be signed by the hmac algorithm\n// Part of hmacauth\nvar SignatureHeaders = []string{\n\t\"Content-Length\",\n\t\"Content-Md5\",\n\t\"Content-Type\",\n\t\"Date\",\n\t\"Authorization\",\n\t\"X-Forwarded-User\",\n\t\"X-Forwarded-Email\",\n\t\"X-Forwarded-Access-Token\",\n\t\"Cookie\",\n\t\"Gap-Auth\",\n}\n\nvar (\n\t// ErrNeedsLogin means the user should be redirected to the login page\n\tErrNeedsLogin = errors.New(\"redirect to login page\")\n)\n\n// OAuthProxy is the main authentication proxy\ntype OAuthProxy struct {\n\tCookieSeed     string\n\tCookieName     string\n\tCSRFCookieName string\n\tCookieDomain   string\n\tCookiePath     string\n\tCookieSecure   bool\n\tCookieHTTPOnly bool\n\tCookieExpire   time.Duration\n\tCookieRefresh  time.Duration\n\tCookieSameSite string\n\tValidator      func(string) bool\n\n\tRobotsPath        string\n\tPingPath          string\n\tSignInPath        string\n\tSignOutPath       string\n\tOAuthStartPath    string\n\tOAuthCallbackPath string\n\tAuthOnlyPath      string\n\tUserInfoPath      string\n\n\tredirectURL          *url.URL // the url to receive requests at\n\twhitelistDomains     []string\n\tprovider             providers.Provider\n\tproviderNameOverride string\n\tsessionStore         sessionsapi.SessionStore\n\tProxyPrefix          string\n\tSignInMessage        string\n\tHtpasswdFile         *HtpasswdFile\n\tDisplayHtpasswdForm  bool\n\tserveMux             http.Handler\n\tSetXAuthRequest      bool\n\tPassBasicAuth        bool\n\tSkipProviderButton   bool\n\tPassUserHeaders      bool\n\tBasicAuthPassword    string\n\tPassAccessToken      bool\n\tSetAuthorization     bool\n\tPassAuthorization    bool\n\tskipAuthRegex        []string\n\tskipAuthPreflight    bool\n\tskipJwtBearerTokens  bool\n\tjwtBearerVerifiers   []*oidc.IDTokenVerifier\n\tcompiledRegex        []*regexp.Regexp\n\ttemplates            *template.Template\n\tBanner               string\n\tFooter               string\n}\n\n// UpstreamProxy represents an upstream server to proxy to\ntype UpstreamProxy struct {\n\tupstream  string\n\thandler   http.Handler\n\twsHandler http.Handler\n\tauth      hmacauth.HmacAuth\n}\n\n// ServeHTTP proxies requests to the upstream provider while signing the\n// request headers\nfunc (u *UpstreamProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"GAP-Upstream-Address\", u.upstream)\n\tif u.auth != nil {\n\t\tr.Header.Set(\"GAP-Auth\", w.Header().Get(\"GAP-Auth\"))\n\t\tu.auth.SignRequest(r)\n\t}\n\tif u.wsHandler != nil && strings.EqualFold(r.Header.Get(\"Connection\"), \"upgrade\") && r.Header.Get(\"Upgrade\") == \"websocket\" {\n\t\tu.wsHandler.ServeHTTP(w, r)\n\t} else {\n\t\tu.handler.ServeHTTP(w, r)\n\t}\n\n}\n\n// NewReverseProxy creates a new reverse proxy for proxying requests to upstream\n// servers\nfunc NewReverseProxy(target *url.URL, opts *Options) (proxy *httputil.ReverseProxy) {\n\tproxy = httputil.NewSingleHostReverseProxy(target)\n\tproxy.FlushInterval = opts.FlushInterval\n\tif opts.SSLUpstreamInsecureSkipVerify {\n\t\tproxy.Transport = &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t}\n\t}\n\treturn proxy\n}\n\nfunc setProxyUpstreamHostHeader(proxy *httputil.ReverseProxy, target *url.URL) {\n\tdirector := proxy.Director\n\tproxy.Director = func(req *http.Request) {\n\t\tdirector(req)\n\t\t// use RequestURI so that we aren't unescaping encoded slashes in the request path\n\t\treq.Host = target.Host\n\t\treq.URL.Opaque = req.RequestURI\n\t\treq.URL.RawQuery = \"\"\n\t}\n}\n\nfunc setProxyDirector(proxy *httputil.ReverseProxy) {\n\tdirector := proxy.Director\n\tproxy.Director = func(req *http.Request) {\n\t\tdirector(req)\n\t\t// use RequestURI so that we aren't unescaping encoded slashes in the request path\n\t\treq.URL.Opaque = req.RequestURI\n\t\treq.URL.RawQuery = \"\"\n\t}\n}\n\n// NewFileServer creates a http.Handler to serve files from the filesystem\nfunc NewFileServer(path string, filesystemPath string) (proxy http.Handler) {\n\treturn http.StripPrefix(path, http.FileServer(http.Dir(filesystemPath)))\n}\n\n// NewWebSocketOrRestReverseProxy creates a reverse proxy for REST or websocket based on url\nfunc NewWebSocketOrRestReverseProxy(u *url.URL, opts *Options, auth hmacauth.HmacAuth) http.Handler {\n\tu.Path = \"\"\n\tproxy := NewReverseProxy(u, opts)\n\tif !opts.PassHostHeader {\n\t\tsetProxyUpstreamHostHeader(proxy, u)\n\t} else {\n\t\tsetProxyDirector(proxy)\n\t}\n\n\t// this should give us a wss:// scheme if the url is https:// based.\n\tvar wsProxy *wsutil.ReverseProxy\n\tif opts.ProxyWebSockets {\n\t\twsScheme := \"ws\" + strings.TrimPrefix(u.Scheme, \"http\")\n\t\twsURL := &url.URL{Scheme: wsScheme, Host: u.Host}\n\t\twsProxy = wsutil.NewSingleHostReverseProxy(wsURL)\n\t}\n\treturn &UpstreamProxy{\n\t\tupstream:  u.Host,\n\t\thandler:   proxy,\n\t\twsHandler: wsProxy,\n\t\tauth:      auth,\n\t}\n}\n\n// NewOAuthProxy creates a new instance of OAuthProxy from the options provided\nfunc NewOAuthProxy(opts *Options, validator func(string) bool) *OAuthProxy {\n\tserveMux := http.NewServeMux()\n\tvar auth hmacauth.HmacAuth\n\tif sigData := opts.signatureData; sigData != nil {\n\t\tauth = hmacauth.NewHmacAuth(sigData.hash, []byte(sigData.key),\n\t\t\tSignatureHeader, SignatureHeaders)\n\t}\n\tfor _, u := range opts.proxyURLs {\n\t\tpath := u.Path\n\t\thost := u.Host\n\t\tswitch u.Scheme {\n\t\tcase httpScheme, httpsScheme:\n\t\t\tlogger.Printf(\"mapping path %q => upstream %q\", path, u)\n\t\t\tproxy := NewWebSocketOrRestReverseProxy(u, opts, auth)\n\t\t\tserveMux.Handle(path, proxy)\n\t\tcase \"static\":\n\t\t\tresponseCode, err := strconv.Atoi(host)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Printf(\"unable to convert %q to int, use default \\\"200\\\"\", host)\n\t\t\t\tresponseCode = 200\n\t\t\t}\n\n\t\t\tserveMux.HandleFunc(path, func(rw http.ResponseWriter, req *http.Request) {\n\t\t\t\trw.WriteHeader(responseCode)\n\t\t\t\tfmt.Fprintf(rw, \"Authenticated\")\n\t\t\t})\n\t\tcase \"file\":\n\t\t\tif u.Fragment != \"\" {\n\t\t\t\tpath = u.Fragment\n\t\t\t}\n\t\t\tlogger.Printf(\"mapping path %q => file system %q\", path, u.Path)\n\t\t\tproxy := NewFileServer(path, u.Path)\n\t\t\tuProxy := UpstreamProxy{\n\t\t\t\tupstream:  path,\n\t\t\t\thandler:   proxy,\n\t\t\t\twsHandler: nil,\n\t\t\t\tauth:      nil,\n\t\t\t}\n\t\t\tserveMux.Handle(path, &uProxy)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unknown upstream protocol %s\", u.Scheme))\n\t\t}\n\t}\n\tfor _, u := range opts.CompiledRegex {\n\t\tlogger.Printf(\"compiled skip-auth-regex => %q\", u)\n\t}\n\n\tif opts.SkipJwtBearerTokens {\n\t\tlogger.Printf(\"Skipping JWT tokens from configured OIDC issuer: %q\", opts.OIDCIssuerURL)\n\t\tfor _, issuer := range opts.ExtraJwtIssuers {\n\t\t\tlogger.Printf(\"Skipping JWT tokens from extra JWT issuer: %q\", issuer)\n\t\t}\n\t}\n\tredirectURL := opts.redirectURL\n\tif redirectURL.Path == \"\" {\n\t\tredirectURL.Path = fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix)\n\t}\n\n\tlogger.Printf(\"OAuthProxy configured for %s Client ID: %s\", opts.provider.Data().ProviderName, opts.ClientID)\n\trefresh := \"disabled\"\n\tif opts.CookieRefresh != time.Duration(0) {\n\t\trefresh = fmt.Sprintf(\"after %s\", opts.CookieRefresh)\n\t}\n\n\tlogger.Printf(\"Cookie settings: name:%s secure(https):%v httponly:%v expiry:%s domain:%s path:%s samesite:%s refresh:%s\", opts.CookieName, opts.CookieSecure, opts.CookieHTTPOnly, opts.CookieExpire, opts.CookieDomain, opts.CookiePath, opts.CookieSameSite, refresh)\n\n\treturn &OAuthProxy{\n\t\tCookieName:     opts.CookieName,\n\t\tCSRFCookieName: fmt.Sprintf(\"%v_%v\", opts.CookieName, \"csrf\"),\n\t\tCookieSeed:     opts.CookieSecret,\n\t\tCookieDomain:   opts.CookieDomain,\n\t\tCookiePath:     opts.CookiePath,\n\t\tCookieSecure:   opts.CookieSecure,\n\t\tCookieHTTPOnly: opts.CookieHTTPOnly,\n\t\tCookieExpire:   opts.CookieExpire,\n\t\tCookieRefresh:  opts.CookieRefresh,\n\t\tCookieSameSite: opts.CookieSameSite,\n\t\tValidator:      validator,\n\n\t\tRobotsPath:        \"/robots.txt\",\n\t\tPingPath:          opts.PingPath,\n\t\tSignInPath:        fmt.Sprintf(\"%s/sign_in\", opts.ProxyPrefix),\n\t\tSignOutPath:       fmt.Sprintf(\"%s/sign_out\", opts.ProxyPrefix),\n\t\tOAuthStartPath:    fmt.Sprintf(\"%s/start\", opts.ProxyPrefix),\n\t\tOAuthCallbackPath: fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix),\n\t\tAuthOnlyPath:      fmt.Sprintf(\"%s/auth\", opts.ProxyPrefix),\n\t\tUserInfoPath:      fmt.Sprintf(\"%s/userinfo\", opts.ProxyPrefix),\n\n\t\tProxyPrefix:          opts.ProxyPrefix,\n\t\tprovider:             opts.provider,\n\t\tproviderNameOverride: opts.ProviderName,\n\t\tsessionStore:         opts.sessionStore,\n\t\tserveMux:             serveMux,\n\t\tredirectURL:          redirectURL,\n\t\twhitelistDomains:     opts.WhitelistDomains,\n\t\tskipAuthRegex:        opts.SkipAuthRegex,\n\t\tskipAuthPreflight:    opts.SkipAuthPreflight,\n\t\tskipJwtBearerTokens:  opts.SkipJwtBearerTokens,\n\t\tjwtBearerVerifiers:   opts.jwtBearerVerifiers,\n\t\tcompiledRegex:        opts.CompiledRegex,\n\t\tSetXAuthRequest:      opts.SetXAuthRequest,\n\t\tPassBasicAuth:        opts.PassBasicAuth,\n\t\tPassUserHeaders:      opts.PassUserHeaders,\n\t\tBasicAuthPassword:    opts.BasicAuthPassword,\n\t\tPassAccessToken:      opts.PassAccessToken,\n\t\tSetAuthorization:     opts.SetAuthorization,\n\t\tPassAuthorization:    opts.PassAuthorization,\n\t\tSkipProviderButton:   opts.SkipProviderButton,\n\t\ttemplates:            loadTemplates(opts.CustomTemplatesDir),\n\t\tBanner:               opts.Banner,\n\t\tFooter:               opts.Footer,\n\t}\n}\n\n// GetRedirectURI returns the redirectURL that the upstream OAuth Provider will\n// redirect clients to once authenticated\nfunc (p *OAuthProxy) GetRedirectURI(host string) string {\n\t// default to the request Host if not set\n\tif p.redirectURL.Host != \"\" {\n\t\treturn p.redirectURL.String()\n\t}\n\tvar u url.URL\n\tu = *p.redirectURL\n\tif u.Scheme == \"\" {\n\t\tif p.CookieSecure {\n\t\t\tu.Scheme = httpsScheme\n\t\t} else {\n\t\t\tu.Scheme = httpScheme\n\t\t}\n\t}\n\tu.Host = host\n\treturn u.String()\n}\n\nfunc (p *OAuthProxy) displayCustomLoginForm() bool {\n\treturn p.HtpasswdFile != nil && p.DisplayHtpasswdForm\n}\n\nfunc (p *OAuthProxy) redeemCode(host, code string) (s *sessionsapi.SessionState, err error) {\n\tif code == \"\" {\n\t\treturn nil, errors.New(\"missing code\")\n\t}\n\tredirectURI := p.GetRedirectURI(host)\n\ts, err = p.provider.Redeem(redirectURI, code)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif s.Email == \"\" {\n\t\ts.Email, err = p.provider.GetEmailAddress(s)\n\t}\n\n\tif s.User == \"\" {\n\t\ts.User, err = p.provider.GetUserName(s)\n\t\tif err != nil && err.Error() == \"not implemented\" {\n\t\t\terr = nil\n\t\t}\n\t}\n\treturn\n}\n\n// MakeCSRFCookie creates a cookie for CSRF\nfunc (p *OAuthProxy) MakeCSRFCookie(req *http.Request, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\treturn p.makeCookie(req, p.CSRFCookieName, value, expiration, now)\n}\n\nfunc (p *OAuthProxy) makeCookie(req *http.Request, name string, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\tif p.CookieDomain != \"\" {\n\t\tdomain := req.Host\n\t\tif h, _, err := net.SplitHostPort(domain); err == nil {\n\t\t\tdomain = h\n\t\t}\n\t\tif !strings.HasSuffix(domain, p.CookieDomain) {\n\t\t\tlogger.Printf(\"Warning: request host is %q but using configured cookie domain of %q\", domain, p.CookieDomain)\n\t\t}\n\t}\n\n\treturn &http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tPath:     p.CookiePath,\n\t\tDomain:   p.CookieDomain,\n\t\tHttpOnly: p.CookieHTTPOnly,\n\t\tSecure:   p.CookieSecure,\n\t\tExpires:  now.Add(expiration),\n\t\tSameSite: cookies.ParseSameSite(p.CookieSameSite),\n\t}\n}\n\n// ClearCSRFCookie creates a cookie to unset the CSRF cookie stored in the user's\n// session\nfunc (p *OAuthProxy) ClearCSRFCookie(rw http.ResponseWriter, req *http.Request) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, \"\", time.Hour*-1, time.Now()))\n}\n\n// SetCSRFCookie adds a CSRF cookie to the response\nfunc (p *OAuthProxy) SetCSRFCookie(rw http.ResponseWriter, req *http.Request, val string) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, val, p.CookieExpire, time.Now()))\n}\n\n// ClearSessionCookie creates a cookie to unset the user's authentication cookie\n// stored in the user's session\nfunc (p *OAuthProxy) ClearSessionCookie(rw http.ResponseWriter, req *http.Request) error {\n\treturn p.sessionStore.Clear(rw, req)\n}\n\n// LoadCookiedSession reads the user's authentication details from the request\nfunc (p *OAuthProxy) LoadCookiedSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\treturn p.sessionStore.Load(req)\n}\n\n// SaveSession creates a new session cookie value and sets this on the response\nfunc (p *OAuthProxy) SaveSession(rw http.ResponseWriter, req *http.Request, s *sessionsapi.SessionState) error {\n\treturn p.sessionStore.Save(rw, req, s)\n}\n\n// RobotsTxt disallows scraping pages from the OAuthProxy\nfunc (p *OAuthProxy) RobotsTxt(rw http.ResponseWriter) {\n\trw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")\n}\n\n// PingPage responds 200 OK to requests\nfunc (p *OAuthProxy) PingPage(rw http.ResponseWriter) {\n\trw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(rw, \"OK\")\n}\n\n// ErrorPage writes an error response\nfunc (p *OAuthProxy) ErrorPage(rw http.ResponseWriter, code int, title string, message string) {\n\trw.WriteHeader(code)\n\tt := struct {\n\t\tTitle       string\n\t\tMessage     string\n\t\tProxyPrefix string\n\t}{\n\t\tTitle:       fmt.Sprintf(\"%d %s\", code, title),\n\t\tMessage:     message,\n\t\tProxyPrefix: p.ProxyPrefix,\n\t}\n\tp.templates.ExecuteTemplate(rw, \"error.html\", t)\n}\n\n// SignInPage writes the sing in template to the response\nfunc (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {\n\tp.ClearSessionCookie(rw, req)\n\trw.WriteHeader(code)\n\n\tredirecURL := req.URL.RequestURI()\n\tif req.Header.Get(\"X-Auth-Request-Redirect\") != \"\" {\n\t\tredirecURL = req.Header.Get(\"X-Auth-Request-Redirect\")\n\t}\n\tif redirecURL == p.SignInPath {\n\t\tredirecURL = \"/\"\n\t}\n\n\tt := struct {\n\t\tProviderName  string\n\t\tSignInMessage string\n\t\tCustomLogin   bool\n\t\tRedirect      string\n\t\tVersion       string\n\t\tProxyPrefix   string\n\t\tFooter        template.HTML\n\t}{\n\t\tProviderName:  p.provider.Data().ProviderName,\n\t\tSignInMessage: p.SignInMessage,\n\t\tCustomLogin:   p.displayCustomLoginForm(),\n\t\tRedirect:      redirecURL,\n\t\tVersion:       VERSION,\n\t\tProxyPrefix:   p.ProxyPrefix,\n\t\tFooter:        template.HTML(p.Footer),\n\t}\n\tif p.providerNameOverride != \"\" {\n\t\tt.ProviderName = p.providerNameOverride\n\t}\n\tp.templates.ExecuteTemplate(rw, \"sign_in.html\", t)\n}\n\n// ManualSignIn handles basic auth logins to the proxy\nfunc (p *OAuthProxy) ManualSignIn(rw http.ResponseWriter, req *http.Request) (string, bool) {\n\tif req.Method != \"POST\" || p.HtpasswdFile == nil {\n\t\treturn \"\", false\n\t}\n\tuser := req.FormValue(\"username\")\n\tpasswd := req.FormValue(\"password\")\n\tif user == \"\" {\n\t\treturn \"\", false\n\t}\n\t// check auth\n\tif p.HtpasswdFile.Validate(user, passwd) {\n\t\tlogger.PrintAuthf(user, req, logger.AuthSuccess, \"Authenticated via HtpasswdFile\")\n\t\treturn user, true\n\t}\n\tlogger.PrintAuthf(user, req, logger.AuthFailure, \"Invalid authentication via HtpasswdFile\")\n\treturn \"\", false\n}\n\n// GetRedirect reads the query parameter to get the URL to redirect clients to\n// once authenticated with the OAuthProxy\nfunc (p *OAuthProxy) GetRedirect(req *http.Request) (redirect string, err error) {\n\terr = req.ParseForm()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tredirect = req.Header.Get(\"X-Auth-Request-Redirect\")\n\tif req.Form.Get(\"rd\") != \"\" {\n\t\tredirect = req.Form.Get(\"rd\")\n\t}\n\tif !p.IsValidRedirect(redirect) {\n\t\tredirect = req.URL.Path\n\t\tif strings.HasPrefix(redirect, p.ProxyPrefix) {\n\t\t\tredirect = \"/\"\n\t\t}\n\t}\n\n\treturn\n}\n\n// splitHostPort separates host and port. If the port is not valid, it returns\n// the entire input as host, and it doesn't check the validity of the host.\n// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.\n// *** taken from net/url, modified validOptionalPort() to accept \":*\"\nfunc splitHostPort(hostport string) (host, port string) {\n\thost = hostport\n\n\tcolon := strings.LastIndexByte(host, ':')\n\tif colon != -1 && validOptionalPort(host[colon:]) {\n\t\thost, port = host[:colon], host[colon+1:]\n\t}\n\n\tif strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {\n\t\thost = host[1 : len(host)-1]\n\t}\n\n\treturn\n}\n\n// validOptionalPort reports whether port is either an empty string\n// or matches /^:\\d*$/\n// *** taken from net/url, modified to accept \":*\"\nfunc validOptionalPort(port string) bool {\n\tif port == \"\" || port == \":*\" {\n\t\treturn true\n\t}\n\tif port[0] != ':' {\n\t\treturn false\n\t}\n\tfor _, b := range port[1:] {\n\t\tif b < '0' || b > '9' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// IsValidRedirect checks whether the redirect URL is whitelisted\nfunc (p *OAuthProxy) IsValidRedirect(redirect string) bool {\n\tswitch {\n\tcase strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !strings.HasPrefix(redirect, \"/\\\\\"):\n\t\treturn true\n\tcase strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):\n\t\tredirectURL, err := url.Parse(redirect)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tredirectHostname := redirectURL.Hostname()\n\n\t\tfor _, domain := range p.whitelistDomains {\n\t\t\tdomainHostname, domainPort := splitHostPort(strings.TrimLeft(domain, \".\"))\n\t\t\tif domainHostname == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, domainHostname)) {\n\t\t\t\t// the domain names match, now validate the ports\n\t\t\t\t// if the whitelisted domain's port is '*', allow all ports\n\t\t\t\t// if the whitelisted domain contains a specific port, only allow that port\n\t\t\t\t// if the whitelisted domain doesn't contain a port at all, only allow empty redirect ports ie http and https\n\t\t\t\tredirectPort := redirectURL.Port()\n\t\t\t\tif (domainPort == \"*\") ||\n\t\t\t\t\t(domainPort == redirectPort) ||\n\t\t\t\t\t(domainPort == \"\" && redirectPort == \"\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// IsWhitelistedRequest is used to check if auth should be skipped for this request\nfunc (p *OAuthProxy) IsWhitelistedRequest(req *http.Request) bool {\n\tisPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"\n\treturn isPreflightRequestAllowed || p.IsWhitelistedPath(req.URL.Path)\n}\n\n// IsWhitelistedPath is used to check if the request path is allowed without auth\nfunc (p *OAuthProxy) IsWhitelistedPath(path string) bool {\n\tfor _, u := range p.compiledRegex {\n\t\tif u.MatchString(path) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc getRemoteAddr(req *http.Request) (s string) {\n\ts = req.RemoteAddr\n\tif req.Header.Get(\"X-Real-IP\") != \"\" {\n\t\ts += fmt.Sprintf(\" (%q)\", req.Header.Get(\"X-Real-IP\"))\n\t}\n\treturn\n}\n\nfunc (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tswitch path := req.URL.Path; {\n\tcase path == p.RobotsPath:\n\t\tp.RobotsTxt(rw)\n\tcase path == p.PingPath:\n\t\tp.PingPage(rw)\n\tcase p.IsWhitelistedRequest(req):\n\t\tp.serveMux.ServeHTTP(rw, req)\n\tcase path == p.SignInPath:\n\t\tp.SignIn(rw, req)\n\tcase path == p.SignOutPath:\n\t\tp.SignOut(rw, req)\n\tcase path == p.OAuthStartPath:\n\t\tp.OAuthStart(rw, req)\n\tcase path == p.OAuthCallbackPath:\n\t\tp.OAuthCallback(rw, req)\n\tcase path == p.AuthOnlyPath:\n\t\tp.AuthenticateOnly(rw, req)\n\tcase path == p.UserInfoPath:\n\t\tp.UserInfo(rw, req)\n\tdefault:\n\t\tp.Proxy(rw, req)\n\t}\n}\n\n// SignIn serves a page prompting users to sign in\nfunc (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining redirect: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\n\tuser, ok := p.ManualSignIn(rw, req)\n\tif ok {\n\t\tsession := &sessionsapi.SessionState{User: user}\n\t\tp.SaveSession(rw, req, session)\n\t\thttp.Redirect(rw, req, redirect, 302)\n\t} else {\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusOK)\n\t\t}\n\t}\n}\n\n//UserInfo endpoint outputs session email in JSON format\nfunc (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {\n\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\tuserInfo := struct {\n\t\tEmail string `json:\"email\"`\n\t}{session.Email}\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\trw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(rw).Encode(userInfo)\n}\n\n// SignOut sends a response to clear the authentication cookie\nfunc (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining redirect: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\tp.ClearSessionCookie(rw, req)\n\thttp.Redirect(rw, req, redirect, 302)\n}\n\n// OAuthStart starts the OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthStart(rw http.ResponseWriter, req *http.Request) {\n\tnonce, err := encryption.Nonce()\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining nonce: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\tp.SetCSRFCookie(rw, req, nonce)\n\tredirect, err := p.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error obtaining redirect: %s\", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\tredirectURI := p.GetRedirectURI(req.Host)\n\thttp.Redirect(rw, req, p.provider.GetLoginURL(redirectURI, fmt.Sprintf(\"%v:%v\", nonce, redirect)), 302)\n}\n\n// OAuthCallback is the OAuth2 authentication flow callback that finishes the\n// OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthCallback(rw http.ResponseWriter, req *http.Request) {\n\tremoteAddr := getRemoteAddr(req)\n\n\t// finish the oauth cycle\n\terr := req.ParseForm()\n\tif err != nil {\n\t\tlogger.Printf(\"Error while parsing OAuth2 callback: %s\" + err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", err.Error())\n\t\treturn\n\t}\n\terrorString := req.Form.Get(\"error\")\n\tif errorString != \"\" {\n\t\tlogger.Printf(\"Error while parsing OAuth2 callback: %s \", errorString)\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", errorString)\n\t\treturn\n\t}\n\n\tsession, err := p.redeemCode(req.Host, req.Form.Get(\"code\"))\n\tif err != nil {\n\t\tlogger.Printf(\"Error redeeming code during OAuth2 callback: %s \", err.Error())\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", \"Internal Error\")\n\t\treturn\n\t}\n\n\ts := strings.SplitN(req.Form.Get(\"state\"), \":\", 2)\n\tif len(s) != 2 {\n\t\tlogger.Printf(\"Error while parsing OAuth2 state: invalid length\")\n\t\tp.ErrorPage(rw, 500, \"Internal Error\", \"Invalid State\")\n\t\treturn\n\t}\n\tnonce := s[0]\n\tredirect := s[1]\n\tc, err := req.Cookie(p.CSRFCookieName)\n\tif err != nil {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unable too obtain CSRF cookie\")\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", err.Error())\n\t\treturn\n\t}\n\tp.ClearCSRFCookie(rw, req)\n\tif c.Value != nonce {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: csrf token mismatch, potential attack\")\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", \"csrf failed\")\n\t\treturn\n\t}\n\n\tif !p.IsValidRedirect(redirect) {\n\t\tredirect = \"/\"\n\t}\n\n\t// set cookie, or deny\n\tif p.Validator(session.Email) && p.provider.ValidateGroup(session.Email) {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthSuccess, \"Authenticated via OAuth2: %s\", session)\n\t\terr := p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"%s %s\", remoteAddr, err)\n\t\t\tp.ErrorPage(rw, 500, \"Internal Error\", \"Internal Error\")\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, 302)\n\t} else {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unauthorized\")\n\t\tp.ErrorPage(rw, 403, \"Permission Denied\", \"Invalid Account\")\n\t}\n}\n\n// AuthenticateOnly checks whether the user is currently logged in\nfunc (p *OAuthProxy) AuthenticateOnly(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, \"unauthorized request\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// we are authenticated\n\tp.addHeadersForProxying(rw, req, session)\n\trw.WriteHeader(http.StatusAccepted)\n}\n\n// Proxy proxies the user request if the user is authenticated else it prompts\n// them to authenticate\nfunc (p *OAuthProxy) Proxy(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tswitch err {\n\tcase nil:\n\t\t// we are authenticated\n\t\tp.addHeadersForProxying(rw, req, session)\n\t\tp.serveMux.ServeHTTP(rw, req)\n\n\tcase ErrNeedsLogin:\n\t\t// we need to send the user to a login screen\n\t\tif isAjax(req) {\n\t\t\t// no point redirecting an AJAX request\n\t\t\tp.ErrorJSON(rw, http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusForbidden)\n\t\t}\n\n\tdefault:\n\t\t// unknown error\n\t\tlogger.Printf(\"Unexpected internal error: %s\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError,\n\t\t\t\"Internal Error\", \"Internal Error\")\n\t}\n\n}\n\n// getAuthenticatedSession checks whether a user is authenticated and returns a session object and nil error if so\n// Returns nil, ErrNeedsLogin if user needs to login.\n// Set-Cookie headers may be set on the response as a side-effect of calling this method.\nfunc (p *OAuthProxy) getAuthenticatedSession(rw http.ResponseWriter, req *http.Request) (*sessionsapi.SessionState, error) {\n\tvar session *sessionsapi.SessionState\n\tvar err error\n\tvar saveSession, clearSession, revalidated bool\n\n\tif p.skipJwtBearerTokens && req.Header.Get(\"Authorization\") != \"\" {\n\t\tsession, err = p.GetJwtSession(req)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error retrieving session from token in Authorization header: %s\", err)\n\t\t}\n\t\tif session != nil {\n\t\t\tsaveSession = false\n\t\t}\n\t}\n\n\tremoteAddr := getRemoteAddr(req)\n\tif session == nil {\n\t\tsession, err = p.LoadCookiedSession(req)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error loading cookied session: %s\", err)\n\t\t}\n\n\t\tif session != nil {\n\t\t\tif session.Age() > p.CookieRefresh && p.CookieRefresh != time.Duration(0) {\n\t\t\t\tlogger.Printf(\"Refreshing %s old session cookie for %s (refresh after %s)\", session.Age(), session, p.CookieRefresh)\n\t\t\t\tsaveSession = true\n\t\t\t}\n\n\t\t\tif ok, err := p.provider.RefreshSessionIfNeeded(session); err != nil {\n\t\t\t\tlogger.Printf(\"%s removing session. error refreshing access token %s %s\", remoteAddr, err, session)\n\t\t\t\tclearSession = true\n\t\t\t\tsession = nil\n\t\t\t} else if ok {\n\t\t\t\tsaveSession = true\n\t\t\t\trevalidated = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif session != nil && session.IsExpired() {\n\t\tlogger.Printf(\"Removing session: token expired %s\", session)\n\t\tsession = nil\n\t\tsaveSession = false\n\t\tclearSession = true\n\t}\n\n\tif saveSession && !revalidated && session != nil && session.AccessToken != \"\" {\n\t\tif !p.provider.ValidateSessionState(session) {\n\t\t\tlogger.Printf(\"Removing session: error validating %s\", session)\n\t\t\tsaveSession = false\n\t\t\tsession = nil\n\t\t\tclearSession = true\n\t\t}\n\t}\n\n\tif session != nil && session.Email != \"\" {\n\t\tif !p.Validator(session.Email) || !p.provider.ValidateGroup(session.Email) {\n\t\t\tlogger.Printf(session.Email, req, logger.AuthFailure, \"Invalid authentication via session: removing session %s\", session)\n\t\t\tsession = nil\n\t\t\tsaveSession = false\n\t\t\tclearSession = true\n\t\t}\n\t}\n\n\tif saveSession && session != nil {\n\t\terr = p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.PrintAuthf(session.Email, req, logger.AuthError, \"Save session error %s\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif clearSession {\n\t\tp.ClearSessionCookie(rw, req)\n\t}\n\n\tif session == nil {\n\t\tsession, err = p.CheckBasicAuth(req)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error during basic auth validation: %s\", err)\n\t\t}\n\t}\n\n\tif session == nil {\n\t\treturn nil, ErrNeedsLogin\n\t}\n\n\treturn session, nil\n}\n\n// addHeadersForProxying adds the appropriate headers the request / response for proxying\nfunc (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, req *http.Request, session *sessionsapi.SessionState) {\n\tif p.PassBasicAuth {\n\t\treq.SetBasicAuth(session.User, p.BasicAuthPassword)\n\t\treq.Header[\"X-Forwarded-User\"] = []string{session.User}\n\t\tif session.Email != \"\" {\n\t\t\treq.Header[\"X-Forwarded-Email\"] = []string{session.Email}\n\t\t} else {\n\t\t\treq.Header.Del(\"X-Forwarded-Email\")\n\t\t}\n\t}\n\n\tif p.PassUserHeaders {\n\t\treq.Header[\"X-Forwarded-User\"] = []string{session.User}\n\t\tif session.Email != \"\" {\n\t\t\treq.Header[\"X-Forwarded-Email\"] = []string{session.Email}\n\t\t} else {\n\t\t\treq.Header.Del(\"X-Forwarded-Email\")\n\t\t}\n\t}\n\n\tif p.SetXAuthRequest {\n\t\trw.Header().Set(\"X-Auth-Request-User\", session.User)\n\t\tif session.Email != \"\" {\n\t\t\trw.Header().Set(\"X-Auth-Request-Email\", session.Email)\n\t\t} else {\n\t\t\trw.Header().Del(\"X-Auth-Request-Email\")\n\t\t}\n\n\t\tif p.PassAccessToken {\n\t\t\tif session.AccessToken != \"\" {\n\t\t\t\trw.Header().Set(\"X-Auth-Request-Access-Token\", session.AccessToken)\n\t\t\t} else {\n\t\t\t\trw.Header().Del(\"X-Auth-Request-Access-Token\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif p.PassAccessToken {\n\t\tif session.AccessToken != \"\" {\n\t\t\treq.Header[\"X-Forwarded-Access-Token\"] = []string{session.AccessToken}\n\t\t} else {\n\t\t\treq.Header.Del(\"X-Forwarded-Access-Token\")\n\t\t}\n\t}\n\n\tif p.PassAuthorization {\n\t\tif session.IDToken != \"\" {\n\t\t\treq.Header[\"Authorization\"] = []string{fmt.Sprintf(\"Bearer %s\", session.IDToken)}\n\t\t} else {\n\t\t\treq.Header.Del(\"Authorization\")\n\t\t}\n\t}\n\tif p.SetAuthorization {\n\t\tif session.IDToken != \"\" {\n\t\t\trw.Header().Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", session.IDToken))\n\t\t} else {\n\t\t\trw.Header().Del(\"Authorization\")\n\t\t}\n\t}\n\n\tif session.Email == \"\" {\n\t\trw.Header().Set(\"GAP-Auth\", session.User)\n\t} else {\n\t\trw.Header().Set(\"GAP-Auth\", session.Email)\n\t}\n}\n\n// CheckBasicAuth checks the requests Authorization header for basic auth\n// credentials and authenticates these against the proxies HtpasswdFile\nfunc (p *OAuthProxy) CheckBasicAuth(req *http.Request) (*sessionsapi.SessionState, error) {\n\tif p.HtpasswdFile == nil {\n\t\treturn nil, nil\n\t}\n\tauth := req.Header.Get(\"Authorization\")\n\tif auth == \"\" {\n\t\treturn nil, nil\n\t}\n\ts := strings.SplitN(auth, \" \", 2)\n\tif len(s) != 2 || s[0] != \"Basic\" {\n\t\treturn nil, fmt.Errorf(\"invalid Authorization header %s\", req.Header.Get(\"Authorization\"))\n\t}\n\tb, err := b64.StdEncoding.DecodeString(s[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpair := strings.SplitN(string(b), \":\", 2)\n\tif len(pair) != 2 {\n\t\treturn nil, fmt.Errorf(\"invalid format %s\", b)\n\t}\n\tif p.HtpasswdFile.Validate(pair[0], pair[1]) {\n\t\tlogger.PrintAuthf(pair[0], req, logger.AuthSuccess, \"Authenticated via basic auth and HTpasswd File\")\n\t\treturn &sessionsapi.SessionState{User: pair[0]}, nil\n\t}\n\tlogger.PrintAuthf(pair[0], req, logger.AuthFailure, \"Invalid authentication via basic auth: not in Htpasswd File\")\n\treturn nil, nil\n}\n\n// isAjax checks if a request is an ajax request\nfunc isAjax(req *http.Request) bool {\n\tacceptValues, ok := req.Header[\"accept\"]\n\tif !ok {\n\t\tacceptValues = req.Header[\"Accept\"]\n\t}\n\tconst ajaxReq = applicationJSON\n\tfor _, v := range acceptValues {\n\t\tif v == ajaxReq {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ErrorJSON returns the error code with an application/json mime type\nfunc (p *OAuthProxy) ErrorJSON(rw http.ResponseWriter, code int) {\n\trw.Header().Set(\"Content-Type\", applicationJSON)\n\trw.WriteHeader(code)\n}\n\n// GetJwtSession loads a session based on a JWT token in the authorization header.\nfunc (p *OAuthProxy) GetJwtSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\trawBearerToken, err := p.findBearerToken(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx := context.Background()\n\tvar session *sessionsapi.SessionState\n\tfor _, verifier := range p.jwtBearerVerifiers {\n\t\tbearerToken, err := verifier.Verify(ctx, rawBearerToken)\n\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"failed to verify bearer token: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar claims struct {\n\t\t\tSubject  string `json:\"sub\"`\n\t\t\tEmail    string `json:\"email\"`\n\t\t\tVerified *bool  `json:\"email_verified\"`\n\t\t}\n\n\t\tif err := bearerToken.Claims(&claims); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse bearer token claims: %v\", err)\n\t\t}\n\n\t\tif claims.Email == \"\" {\n\t\t\tclaims.Email = claims.Subject\n\t\t}\n\n\t\tif claims.Verified != nil && !*claims.Verified {\n\t\t\treturn nil, fmt.Errorf(\"email in id_token (%s) isn't verified\", claims.Email)\n\t\t}\n\n\t\tsession = &sessionsapi.SessionState{\n\t\t\tAccessToken:  rawBearerToken,\n\t\t\tIDToken:      rawBearerToken,\n\t\t\tRefreshToken: \"\",\n\t\t\tExpiresOn:    bearerToken.Expiry,\n\t\t\tEmail:        claims.Email,\n\t\t\tUser:         claims.Email,\n\t\t}\n\t\treturn session, nil\n\t}\n\treturn nil, fmt.Errorf(\"unable to verify jwt token %s\", req.Header.Get(\"Authorization\"))\n}\n\n// findBearerToken finds a valid JWT token from the Authorization header of a given request.\nfunc (p *OAuthProxy) findBearerToken(req *http.Request) (string, error) {\n\tauth := req.Header.Get(\"Authorization\")\n\ts := strings.SplitN(auth, \" \", 2)\n\tif len(s) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid authorization header %s\", auth)\n\t}\n\tjwtRegex := regexp.MustCompile(`^eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]+$`)\n\tvar rawBearerToken string\n\tif s[0] == \"Bearer\" && jwtRegex.MatchString(s[1]) {\n\t\trawBearerToken = s[1]\n\t} else if s[0] == \"Basic\" {\n\t\t// Check if we have a Bearer token masquerading in Basic\n\t\tb, err := b64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\treturn \"\", fmt.Errorf(\"invalid format %s\", b)\n\t\t}\n\t\tuser, password := pair[0], pair[1]\n\n\t\t// check user, user+password, or just password for a token\n\t\tif jwtRegex.MatchString(user) {\n\t\t\t// Support blank passwords or magic `x-oauth-basic` passwords - nothing else\n\t\t\tif password == \"\" || password == \"x-oauth-basic\" {\n\t\t\t\trawBearerToken = user\n\t\t\t}\n\t\t} else if jwtRegex.MatchString(password) {\n\t\t\t// support passwords and ignore user\n\t\t\trawBearerToken = password\n\t\t}\n\t}\n\tif rawBearerToken == \"\" {\n\t\treturn \"\", fmt.Errorf(\"no valid bearer token found in authorization header\")\n\t}\n\n\treturn rawBearerToken, nil\n}\n"], "filenames": ["CHANGELOG.md", "oauthproxy.go"], "buggy_code_start_loc": [20, 561], "buggy_code_end_loc": [21, 562], "fixing_code_start_loc": [20, 561], "fixing_code_end_loc": [21, 562], "type": "CWE-601", "message": "OAuth2 Proxy before 5.0 has an open redirect vulnerability. Authentication tokens could be silently harvested by an attacker. This has been patched in version 5.0.", "other": {"cve": {"id": "CVE-2020-5233", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-30T19:15:11.883", "lastModified": "2020-04-09T14:33:44.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OAuth2 Proxy before 5.0 has an open redirect vulnerability. Authentication tokens could be silently harvested by an attacker. This has been patched in version 5.0."}, {"lang": "es", "value": "OAuth2 Proxy versiones anteriores a 5.0, presenta una vulnerabilidad de redireccionamiento abierto. Los tokens de autenticaci\u00f3n pueden ser recolectados silenciosamente por parte de un atacante. Esto ha sido parcheado en la versi\u00f3n 5.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oauth2_proxy_project:oauth2_proxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.0", "matchCriteriaId": "52159988-32E2-45ED-9A9D-F454778AFBAC"}]}]}], "references": [{"url": "https://github.com/pusher/oauth2_proxy/commit/a316f8a06f3c0ca2b5fc5fa18a91781b313607b2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pusher/oauth2_proxy/releases/tag/v5.0.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pusher/oauth2_proxy/security/advisories/GHSA-qqxw-m5fj-f7gv", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pusher/oauth2_proxy/commit/a316f8a06f3c0ca2b5fc5fa18a91781b313607b2"}}