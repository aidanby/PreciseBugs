{"buggy_code": ["require 'rack/protection'\n\nmodule Rack\n  module Protection\n    ##\n    # Prevented attack::   CSRF\n    # Supported browsers:: all\n    # More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery\n    #\n    # Only accepts unsafe HTTP requests if a given access token matches the token\n    # included in the session.\n    #\n    # Compatible with Rails and rack-csrf.\n    #\n    # Options:\n    #\n    # authenticity_param: Defines the param's name that should contain the token on a request.\n    #\n    class AuthenticityToken < Base\n      default_options :authenticity_param => 'authenticity_token'\n\n      def accepts?(env)\n        session = session env\n        token   = session[:csrf] ||= session['_csrf_token'] || random_string\n        safe?(env) ||\n          env['HTTP_X_CSRF_TOKEN'] == token ||\n          Request.new(env).params[options[:authenticity_param]] == token\n      end\n    end\n  end\nend\n", "require 'rack/protection'\nrequire 'digest'\nrequire 'logger'\nrequire 'uri'\n\nmodule Rack\n  module Protection\n    class Base\n      DEFAULT_OPTIONS = {\n        :reaction    => :default_reaction, :logging   => true,\n        :message     => 'Forbidden',       :encryptor => Digest::SHA1,\n        :session_key => 'rack.session',    :status    => 403,\n        :allow_empty_referrer => true,\n        :report_key           => \"protection.failed\",\n        :html_types           => %w[text/html application/xhtml]\n      }\n\n      attr_reader :app, :options\n\n      def self.default_options(options)\n        define_method(:default_options) { super().merge(options) }\n      end\n\n      def self.default_reaction(reaction)\n        alias_method(:default_reaction, reaction)\n      end\n\n      def default_options\n        DEFAULT_OPTIONS\n      end\n\n      def initialize(app, options = {})\n        @app, @options = app, default_options.merge(options)\n      end\n\n      def safe?(env)\n        %w[GET HEAD OPTIONS TRACE].include? env['REQUEST_METHOD']\n      end\n\n      def accepts?(env)\n        raise NotImplementedError, \"#{self.class} implementation pending\"\n      end\n\n      def call(env)\n        unless accepts? env\n          instrument env\n          result = react env\n        end\n        result or app.call(env)\n      end\n\n      def react(env)\n        result = send(options[:reaction], env)\n        result if Array === result and result.size == 3\n      end\n\n      def warn(env, message)\n        return unless options[:logging]\n        l = options[:logger] || env['rack.logger'] || ::Logger.new(env['rack.errors'])\n        l.warn(message)\n      end\n\n      def instrument(env)\n        return unless i = options[:instrumenter]\n        env['rack.protection.attack'] = self.class.name.split('::').last.downcase\n        i.instrument('rack.protection', env)\n      end\n\n      def deny(env)\n        warn env, \"attack prevented by #{self.class}\"\n        [options[:status], {'Content-Type' => 'text/plain'}, [options[:message]]]\n      end\n\n      def report(env)\n        warn env, \"attack reported by #{self.class}\"\n        env[options[:report_key]] = true\n      end\n\n      def session?(env)\n        env.include? options[:session_key]\n      end\n\n      def session(env)\n        return env[options[:session_key]] if session? env\n        fail \"you need to set up a session middleware *before* #{self.class}\"\n      end\n\n      def drop_session(env)\n        session(env).clear if session? env\n      end\n\n      def referrer(env)\n        ref = env['HTTP_REFERER'].to_s\n        return if !options[:allow_empty_referrer] and ref.empty?\n        URI.parse(ref).host || Request.new(env).host\n      rescue URI::InvalidURIError\n      end\n\n      def origin(env)\n        env['HTTP_ORIGIN'] || env['HTTP_X_ORIGIN']\n      end\n\n      def random_string(secure = defined? SecureRandom)\n        secure ? SecureRandom.hex(16) : \"%032x\" % rand(2**128-1)\n      rescue NotImplementedError\n        random_string false\n      end\n\n      def encrypt(value)\n        options[:encryptor].hexdigest value.to_s\n      end\n\n      alias default_reaction deny\n\n      def html?(headers)\n        return false unless header = headers.detect { |k,v| k.downcase == 'content-type' }\n        options[:html_types].include? header.last[/^\\w+\\/\\w+/]\n      end\n    end\n  end\nend\n"], "fixing_code": ["require 'rack/protection'\n\nmodule Rack\n  module Protection\n    ##\n    # Prevented attack::   CSRF\n    # Supported browsers:: all\n    # More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery\n    #\n    # Only accepts unsafe HTTP requests if a given access token matches the token\n    # included in the session.\n    #\n    # Compatible with Rails and rack-csrf.\n    #\n    # Options:\n    #\n    # authenticity_param: Defines the param's name that should contain the token on a request.\n    #\n    class AuthenticityToken < Base\n      default_options :authenticity_param => 'authenticity_token'\n\n      def accepts?(env)\n        session = session env\n        token   = session[:csrf] ||= session['_csrf_token'] || random_string\n        safe?(env) ||\n          secure_compare(env['HTTP_X_CSRF_TOKEN'], token) ||\n          secure_compare(Request.new(env).params[options[:authenticity_param]], token)\n      end\n    end\n  end\nend\n", "require 'rack/protection'\nrequire 'rack/utils'\nrequire 'digest'\nrequire 'logger'\nrequire 'uri'\n\nmodule Rack\n  module Protection\n    class Base\n      DEFAULT_OPTIONS = {\n        :reaction    => :default_reaction, :logging   => true,\n        :message     => 'Forbidden',       :encryptor => Digest::SHA1,\n        :session_key => 'rack.session',    :status    => 403,\n        :allow_empty_referrer => true,\n        :report_key           => \"protection.failed\",\n        :html_types           => %w[text/html application/xhtml]\n      }\n\n      attr_reader :app, :options\n\n      def self.default_options(options)\n        define_method(:default_options) { super().merge(options) }\n      end\n\n      def self.default_reaction(reaction)\n        alias_method(:default_reaction, reaction)\n      end\n\n      def default_options\n        DEFAULT_OPTIONS\n      end\n\n      def initialize(app, options = {})\n        @app, @options = app, default_options.merge(options)\n      end\n\n      def safe?(env)\n        %w[GET HEAD OPTIONS TRACE].include? env['REQUEST_METHOD']\n      end\n\n      def accepts?(env)\n        raise NotImplementedError, \"#{self.class} implementation pending\"\n      end\n\n      def call(env)\n        unless accepts? env\n          instrument env\n          result = react env\n        end\n        result or app.call(env)\n      end\n\n      def react(env)\n        result = send(options[:reaction], env)\n        result if Array === result and result.size == 3\n      end\n\n      def warn(env, message)\n        return unless options[:logging]\n        l = options[:logger] || env['rack.logger'] || ::Logger.new(env['rack.errors'])\n        l.warn(message)\n      end\n\n      def instrument(env)\n        return unless i = options[:instrumenter]\n        env['rack.protection.attack'] = self.class.name.split('::').last.downcase\n        i.instrument('rack.protection', env)\n      end\n\n      def deny(env)\n        warn env, \"attack prevented by #{self.class}\"\n        [options[:status], {'Content-Type' => 'text/plain'}, [options[:message]]]\n      end\n\n      def report(env)\n        warn env, \"attack reported by #{self.class}\"\n        env[options[:report_key]] = true\n      end\n\n      def session?(env)\n        env.include? options[:session_key]\n      end\n\n      def session(env)\n        return env[options[:session_key]] if session? env\n        fail \"you need to set up a session middleware *before* #{self.class}\"\n      end\n\n      def drop_session(env)\n        session(env).clear if session? env\n      end\n\n      def referrer(env)\n        ref = env['HTTP_REFERER'].to_s\n        return if !options[:allow_empty_referrer] and ref.empty?\n        URI.parse(ref).host || Request.new(env).host\n      rescue URI::InvalidURIError\n      end\n\n      def origin(env)\n        env['HTTP_ORIGIN'] || env['HTTP_X_ORIGIN']\n      end\n\n      def random_string(secure = defined? SecureRandom)\n        secure ? SecureRandom.hex(16) : \"%032x\" % rand(2**128-1)\n      rescue NotImplementedError\n        random_string false\n      end\n\n      def encrypt(value)\n        options[:encryptor].hexdigest value.to_s\n      end\n\n      def secure_compare(a, b)\n        Rack::Utils.secure_compare(a.to_s, b.to_s)\n      end\n\n      alias default_reaction deny\n\n      def html?(headers)\n        return false unless header = headers.detect { |k,v| k.downcase == 'content-type' }\n        options[:html_types].include? header.last[/^\\w+\\/\\w+/]\n      end\n    end\n  end\nend\n"], "filenames": ["rack-protection/lib/rack/protection/authenticity_token.rb", "rack-protection/lib/rack/protection/base.rb"], "buggy_code_start_loc": [26, 1], "buggy_code_end_loc": [28, 112], "fixing_code_start_loc": [26, 2], "fixing_code_end_loc": [28, 118], "type": "CWE-203", "message": "Sinatra rack-protection versions 1.5.4 and 2.0.0.rc3 and earlier contains a timing attack vulnerability in the CSRF token checking that can result in signatures can be exposed. This attack appear to be exploitable via network connectivity to the ruby application. This vulnerability appears to have been fixed in 1.5.5 and 2.0.0.", "other": {"cve": {"id": "CVE-2018-1000119", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-07T14:29:00.390", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sinatra rack-protection versions 1.5.4 and 2.0.0.rc3 and earlier contains a timing attack vulnerability in the CSRF token checking that can result in signatures can be exposed. This attack appear to be exploitable via network connectivity to the ruby application. This vulnerability appears to have been fixed in 1.5.5 and 2.0.0."}, {"lang": "es", "value": "Sinatra rack-protection, en versiones 1.5.4, 2.0.0.rc3 y anteriores, contiene una vulnerabilidad de ataque de sincronizaci\u00f3n en la comprobaci\u00f3n de token CSRF que puede resultar en que las firmas queden expuestas. Este ataque parece ser explotable mediante conectividad de red en la aplicaci\u00f3n Ruby. La vulnerabilidad parece haber sido solucionada en las versiones 1.5.5 y 2.0.0."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:rack-protection:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.5", "matchCriteriaId": "AF14FDB6-1F06-40E9-8F0B-8683865A97D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:rack-protection:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "FF103D03-A341-40A0-A4A7-A79E0A2F6E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:rack-protection:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "FB3A8773-F11D-408C-8E75-7D8102212138"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:rack-protection:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "B98EB8D6-5942-4A49-AA49-BF9C3FA83E87"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:1060", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sinatra/rack-protection/pull/98", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/sinatra/sinatra/commit/8aa6c42ef724f93ae309fb7c5668e19ad547eceb#commitcomment-27964109", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4247", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/sinatra/sinatra/commit/8aa6c42ef724f93ae309fb7c5668e19ad547eceb#commitcomment-27964109"}}