{"buggy_code": ["{-# LANGUAGE BangPatterns               #-}\n{-# LANGUAGE CPP                        #-}\n{-# LANGUAGE DeriveDataTypeable         #-}\n{-# LANGUAGE DeriveFunctor              #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE FlexibleInstances          #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE PatternGuards              #-}\n{-# LANGUAGE RankNTypes                 #-}\n{-# LANGUAGE StandaloneDeriving         #-}\n{-# LANGUAGE TypeFamilies               #-}\n-- | This module provides both a native Haskell solution for parsing XML\n-- documents into a stream of events, and a set of parser combinators for\n-- dealing with a stream of events.\n--\n-- As a simple example:\n--\n-- >>> :set -XOverloadedStrings\n-- >>> import Conduit (runConduit, (.|))\n-- >>> import Data.Text (Text, unpack)\n-- >>> import Data.XML.Types (Event)\n-- >>> data Person = Person Int Text Text deriving Show\n-- >>> :{\n-- let parsePerson :: MonadThrow m => ConduitT Event o m (Maybe Person)\n--     parsePerson = tag' \"person\" parseAttributes $ \\(age, goodAtHaskell) -> do\n--       name <- content\n--       return $ Person (read $ unpack age) name goodAtHaskell\n--       where parseAttributes = (,) <$> requireAttr \"age\" <*> requireAttr \"goodAtHaskell\" <* ignoreAttrs\n--     parsePeople :: MonadThrow m => ConduitT Event o m (Maybe [Person])\n--     parsePeople = tagNoAttr \"people\" $ many parsePerson\n--     inputXml = mconcat\n--       [ \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n--       , \"<people>\"\n--       , \"  <person age=\\\"25\\\" goodAtHaskell=\\\"yes\\\">Michael</person>\"\n--       , \"  <person age=\\\"2\\\" goodAtHaskell=\\\"might become\\\">Eliezer</person>\"\n--       , \"</people>\"\n--       ]\n-- :}\n--\n-- >>> runConduit $ parseLBS def inputXml .| force \"people required\" parsePeople\n-- [Person 25 \"Michael\" \"yes\",Person 2 \"Eliezer\" \"might become\"]\n--\n--\n-- This module also supports streaming results using 'yield'.\n-- This allows parser results to be processed using conduits\n-- while a particular parser (e.g. 'many') is still running.\n-- Without using streaming results, you have to wait until the parser finished\n-- before you can process the result list. Large XML files might be easier\n-- to process by using streaming results.\n-- See http://stackoverflow.com/q/21367423/2597135 for a related discussion.\n--\n-- >>> import Data.Conduit.List as CL\n-- >>> :{\n-- let parsePeople' :: MonadThrow m => ConduitT Event Person m (Maybe ())\n--     parsePeople' = tagNoAttr \"people\" $ manyYield parsePerson\n-- :}\n--\n-- >>> runConduit $ parseLBS def inputXml .| force \"people required\" parsePeople' .| CL.mapM_ print\n-- Person 25 \"Michael\" \"yes\"\n-- Person 2 \"Eliezer\" \"might become\"\n--\n-- Previous versions of this module contained a number of more sophisticated\n-- functions written by Aristid Breitkreuz and Dmitry Olshansky. To keep this\n-- package simpler, those functions are being moved to a separate package. This\n-- note will be updated with the name of the package(s) when available.\nmodule Text.XML.Stream.Parse\n    ( -- * Parsing XML files\n      parseBytes\n    , parseBytesPos\n    , parseText\n    , parseTextPos\n    , detectUtf\n    , parseFile\n    , parseLBS\n      -- ** Parser settings\n    , ParseSettings\n    , def\n    , DecodeEntities\n    , DecodeIllegalCharacters\n    , psDecodeEntities\n    , psDecodeIllegalCharacters\n    , psRetainNamespaces\n      -- *** Entity decoding\n    , decodeXmlEntities\n    , decodeHtmlEntities\n      -- * Event parsing\n    , tag\n    , tag'\n    , tagNoAttr\n    , tagIgnoreAttrs\n    , content\n    , contentMaybe\n      -- * Ignoring tags/trees\n    , ignoreEmptyTag\n    , ignoreTree\n    , ignoreContent\n    , ignoreTreeContent\n    , ignoreAnyTreeContent\n      -- * Streaming events\n    , takeContent\n    , takeTree\n    , takeTreeContent\n    , takeAnyTreeContent\n      -- * Tag name matching\n    , NameMatcher(..)\n    , matching\n    , anyOf\n    , anyName\n      -- * Attribute parsing\n    , AttrParser\n    , attr\n    , requireAttr\n    , optionalAttr\n    , requireAttrRaw\n    , optionalAttrRaw\n    , ignoreAttrs\n      -- * Combinators\n    , orE\n    , choose\n    , many\n    , many_\n    , manyIgnore\n    , many'\n    , force\n      -- * Streaming combinators\n    , manyYield\n    , manyYield'\n    , manyIgnoreYield\n      -- * Exceptions\n    , XmlException (..)\n      -- * Other types\n    , PositionRange\n    , EventPos\n    ) where\nimport           Conduit\nimport           Control.Applicative          (Alternative (empty, (<|>)),\n                                               Applicative (..), (<$>))\nimport qualified Control.Applicative          as A\nimport           Control.Arrow                ((***))\nimport           Control.Exception            (Exception (..), SomeException)\nimport           Control.Monad                (ap, liftM, void)\nimport           Control.Monad.Fix            (fix)\nimport           Control.Monad.IO.Class       (liftIO)\nimport           Control.Monad.Trans.Class    (lift)\nimport           Control.Monad.Trans.Maybe    (MaybeT (..))\nimport           Control.Monad.Trans.Resource (MonadResource, MonadThrow (..),\n                                               throwM)\nimport           Data.Attoparsec.Text         (Parser, anyChar, char, manyTill,\n                                               skipWhile, string, takeWhile,\n                                               takeWhile1, try)\nimport qualified Data.Attoparsec.Text         as AT\nimport qualified Data.ByteString              as S\nimport qualified Data.ByteString.Lazy         as L\nimport           Data.Char                    (isSpace)\nimport           Data.Conduit.Attoparsec      (PositionRange, conduitParser)\nimport qualified Data.Conduit.Text            as CT\nimport           Data.Default.Class           (Default (..))\nimport           Data.List                    (foldl', intercalate)\nimport qualified Data.Map                     as Map\nimport           Data.Maybe                   (fromMaybe, isNothing)\nimport           Data.String                  (IsString (..))\nimport           Data.Text                    (Text, pack)\nimport qualified Data.Text                    as T\nimport           Data.Text.Encoding           (decodeUtf8With)\nimport           Data.Text.Encoding.Error     (lenientDecode)\nimport           Data.Typeable                (Typeable)\nimport           Data.XML.Types               (Content (..), Event (..),\n                                               ExternalID (..),\n                                               Instruction (..), Name (..))\nimport           Prelude                      hiding (takeWhile)\nimport           Text.XML.Stream.Token\n\n-- $setup\n-- >>> :set -XOverloadedStrings\n-- >>> import Conduit\n-- >>> import Control.Monad (void, join)\n\ntype Ents = [(Text, Text)]\n\ntokenToEvent :: ParseSettings -> Ents -> [NSLevel] -> Token -> (Ents, [NSLevel], [Event])\ntokenToEvent _ es n (TokenXMLDeclaration _) = (es, n, [])\ntokenToEvent _ es n (TokenInstruction i) = (es, n, [EventInstruction i])\ntokenToEvent ps es n (TokenBeginElement name as isClosed _) =\n    (es, n', if isClosed then [begin, end] else [begin])\n  where\n    l0 = case n of\n            []  -> NSLevel Nothing Map.empty\n            x:_ -> x\n    (as', l') = foldl' go (id, l0) as\n    go (front, l) (TName kpref kname, val) =\n        (addNS front, l'')\n      where\n        isPrefixed = kpref == Just \"xmlns\"\n        isUnprefixed = isNothing kpref && kname == \"xmlns\"\n\n        addNS\n            | not (psRetainNamespaces ps) && (isPrefixed || isUnprefixed) = id\n            | otherwise = (((tname, map resolve val):) .)\n          where\n            tname\n                | isPrefixed = TName Nothing (\"xmlns:\" `T.append` kname)\n                | otherwise = TName kpref kname\n\n        l''\n            | isPrefixed =\n                l { prefixes = Map.insert kname (contentsToText val)\n                                     $ prefixes l }\n            | isUnprefixed =\n                l { defaultNS = if T.null $ contentsToText val\n                                            then Nothing\n                                            else Just $ contentsToText val }\n            | otherwise = l\n\n    resolve (ContentEntity e)\n        | Just t <- lookup e es = ContentText t\n    resolve c = c\n    n' = if isClosed then n else l' : n\n    fixAttName (name', val) = (tnameToName True l' name', val)\n    elementName = tnameToName False l' name\n    begin = EventBeginElement elementName $ map fixAttName $ as' []\n    end = EventEndElement elementName\ntokenToEvent _ es n (TokenEndElement name) =\n    (es, n', [EventEndElement $ tnameToName False l name])\n  where\n    (l, n') =\n        case n of\n            []   -> (NSLevel Nothing Map.empty, [])\n            x:xs -> (x, xs)\ntokenToEvent _ es n (TokenContent (ContentEntity e))\n    | Just t <- lookup e es = (es, n, [EventContent $ ContentText t])\ntokenToEvent _ es n (TokenContent c) = (es, n, [EventContent c])\ntokenToEvent _ es n (TokenComment c) = (es, n, [EventComment c])\ntokenToEvent _ es n (TokenDoctype t eid es') = (es ++ es', n, [EventBeginDoctype t eid, EventEndDoctype])\ntokenToEvent _ es n (TokenCDATA t) = (es, n, [EventCDATA t])\n\ntnameToName :: Bool -> NSLevel -> TName -> Name\ntnameToName _ _ (TName (Just \"xml\") name) =\n    Name name (Just \"http://www.w3.org/XML/1998/namespace\") (Just \"xml\")\ntnameToName isAttr (NSLevel def' _) (TName Nothing name) =\n    Name name (if isAttr then Nothing else def') Nothing\ntnameToName _ (NSLevel _ m) (TName (Just pref) name) =\n    case Map.lookup pref m of\n        Just ns -> Name name (Just ns) (Just pref)\n        Nothing -> Name name Nothing (Just pref) -- FIXME is this correct?\n\n-- | Automatically determine which UTF variant is being used. This function\n-- first checks for BOMs, removing them as necessary, and then check for the\n-- equivalent of <?xml for each of UTF-8, UTF-16LE/BE, and UTF-32LE/BE. It\n-- defaults to assuming UTF-8.\ndetectUtf :: MonadThrow m => ConduitT S.ByteString T.Text m ()\ndetectUtf =\n    conduit id\n  where\n    conduit front = await >>= maybe (return ()) (push front)\n\n    push front bss =\n        either conduit\n               (uncurry checkXMLDecl)\n               (getEncoding front bss)\n\n    getEncoding front bs'\n        | S.length bs < 4 =\n            Left (bs `S.append`)\n        | otherwise =\n            Right (bsOut, mcodec)\n      where\n        bs = front bs'\n        bsOut = S.append (S.drop toDrop x) y\n        (x, y) = S.splitAt 4 bs\n        (toDrop, mcodec) =\n            case S.unpack x of\n                [0x00, 0x00, 0xFE, 0xFF] -> (4, Just CT.utf32_be)\n                [0xFF, 0xFE, 0x00, 0x00] -> (4, Just CT.utf32_le)\n                0xFE : 0xFF: _           -> (2, Just CT.utf16_be)\n                0xFF : 0xFE: _           -> (2, Just CT.utf16_le)\n                0xEF : 0xBB: 0xBF : _    -> (3, Just CT.utf8)\n                [0x00, 0x00, 0x00, 0x3C] -> (0, Just CT.utf32_be)\n                [0x3C, 0x00, 0x00, 0x00] -> (0, Just CT.utf32_le)\n                [0x00, 0x3C, 0x00, 0x3F] -> (0, Just CT.utf16_be)\n                [0x3C, 0x00, 0x3F, 0x00] -> (0, Just CT.utf16_le)\n                _                        -> (0, Nothing) -- Assuming UTF-8\n\ncheckXMLDecl :: MonadThrow m\n             => S.ByteString\n             -> Maybe CT.Codec\n             -> ConduitT S.ByteString T.Text m ()\ncheckXMLDecl bs (Just codec) = leftover bs >> CT.decode codec\ncheckXMLDecl bs0 Nothing =\n    loop [] (AT.parse (parseToken def)) bs0\n  where\n    loop chunks0 parser nextChunk =\n        case parser $ decodeUtf8With lenientDecode nextChunk of\n            AT.Fail{} -> fallback\n            AT.Partial f -> await >>= maybe fallback (loop chunks f)\n            AT.Done _ (TokenXMLDeclaration attrs) -> findEncoding attrs\n            AT.Done{} -> fallback\n      where\n        chunks = nextChunk : chunks0\n        fallback = complete CT.utf8\n        complete codec = mapM_ leftover chunks >> CT.decode codec\n\n        findEncoding [] = fallback\n        findEncoding ((TName _ \"encoding\", [ContentText enc]):_) =\n            case T.toLower enc of\n                \"iso-8859-1\" -> complete CT.iso8859_1\n                \"utf-8\"      -> complete CT.utf8\n                _            -> complete CT.utf8\n        findEncoding (_:xs) = findEncoding xs\n\ntype EventPos = (Maybe PositionRange, Event)\n\n-- | Parses a byte stream into 'Event's. This function is implemented fully in\n-- Haskell using attoparsec-text for parsing. The produced error messages do\n-- not give line/column information, so you may prefer to stick with the parser\n-- provided by libxml-enumerator. However, this has the advantage of not\n-- relying on any C libraries.\n--\n-- This relies on 'detectUtf' to determine character encoding, and 'parseText'\n-- to do the actual parsing.\nparseBytes :: MonadThrow m\n           => ParseSettings\n           -> ConduitT S.ByteString Event m ()\nparseBytes = mapOutput snd . parseBytesPos\n\nparseBytesPos :: MonadThrow m\n              => ParseSettings\n              -> ConduitT S.ByteString EventPos m ()\nparseBytesPos ps = detectUtf .| parseTextPos ps\n\ndropBOM :: Monad m => ConduitT T.Text T.Text m ()\ndropBOM =\n    await >>= maybe (return ()) push\n  where\n    push t =\n        case T.uncons t of\n            Nothing -> dropBOM\n            Just (c, cs) ->\n                let output\n                        | c == '\\xfeef' = cs\n                        | otherwise = t\n                 in yield output >> idConduit\n    idConduit = await >>= maybe (return ()) (\\x -> yield x >> idConduit)\n\n-- | Parses a character stream into 'Event's. This function is implemented\n-- fully in Haskell using attoparsec-text for parsing. The produced error\n-- messages do not give line/column information, so you may prefer to stick\n-- with the parser provided by libxml-enumerator. However, this has the\n-- advantage of not relying on any C libraries.\n--\n-- Since 1.2.4\nparseText :: MonadThrow m => ParseSettings -> ConduitT T.Text Event m ()\nparseText = mapOutput snd . parseTextPos\n\n\n-- | Same as 'parseText', but includes the position of each event.\n--\n-- Since 1.2.4\nparseTextPos :: MonadThrow m\n          => ParseSettings\n          -> ConduitT T.Text EventPos m ()\nparseTextPos de =\n    dropBOM\n        .| tokenize\n        .| toEventC de\n        .| addBeginEnd\n  where\n    tokenize = conduitToken de\n    addBeginEnd = yield (Nothing, EventBeginDocument) >> addEnd\n    addEnd = await >>= maybe\n        (yield (Nothing, EventEndDocument))\n        (\\e -> yield e >> addEnd)\n\ntoEventC :: Monad m => ParseSettings -> ConduitT (PositionRange, Token) EventPos m ()\ntoEventC ps =\n    go [] []\n  where\n    go !es !levels =\n        await >>= maybe (return ()) push\n      where\n        push (position, token) =\n            mapM_ (yield . (,) (Just position)) events >> go es' levels'\n          where\n            (es', levels', events) = tokenToEvent ps es levels token\n\n\ntype DecodeEntities = Text -> Content\ntype DecodeIllegalCharacters = Int -> Maybe Char\n\ndata ParseSettings = ParseSettings\n    { psDecodeEntities          :: DecodeEntities\n    , psRetainNamespaces        :: Bool\n    -- ^ Whether the original xmlns attributes should be retained in the parsed\n    -- values. For more information on motivation, see:\n    --\n    -- <https://github.com/snoyberg/xml/issues/38>\n    --\n    -- Default: False\n    --\n    -- Since 1.2.1\n    , psDecodeIllegalCharacters :: DecodeIllegalCharacters\n    -- ^ How to decode illegal character references (@&#[0-9]+;@ or @&#x[0-9a-fA-F]+;@).\n    --\n    -- Character references within the legal ranges defined by <https://www.w3.org/TR/REC-xml/#NT-Char the standard> are automatically parsed.\n    -- Others are passed to this function.\n    --\n    -- Default: @const Nothing@\n    --\n    -- Since 1.7.1\n    }\n\ninstance Default ParseSettings where\n    def = ParseSettings\n        { psDecodeEntities = decodeXmlEntities\n        , psRetainNamespaces = False\n        , psDecodeIllegalCharacters = const Nothing\n        }\n\nconduitToken :: MonadThrow m => ParseSettings -> ConduitT T.Text (PositionRange, Token) m ()\nconduitToken = conduitParser . parseToken\n\nparseToken :: ParseSettings -> Parser Token\nparseToken settings = (char '<' >> parseLt) <|> TokenContent <$> parseContent settings False False\n  where\n    parseLt =\n        (char '?' >> parseInstr) <|>\n        (char '!' >> (parseComment <|> parseCdata <|> parseDoctype)) <|>\n        parseBegin <|>\n        (char '/' >> parseEnd)\n    parseInstr = do\n        name <- parseIdent\n        if name == \"xml\"\n            then do\n                as <- A.many $ parseAttribute settings\n                skipSpace\n                char' '?'\n                char' '>'\n                newline <|> return ()\n                return $ TokenXMLDeclaration as\n            else do\n                skipSpace\n                x <- T.pack <$> manyTill anyChar (try $ string \"?>\")\n                return $ TokenInstruction $ Instruction name x\n    parseComment = do\n        char' '-'\n        char' '-'\n        c <- T.pack <$> manyTill anyChar (string \"-->\") -- FIXME use takeWhile instead\n        return $ TokenComment c\n    parseCdata = do\n        _ <- string \"[CDATA[\"\n        t <- T.pack <$> manyTill anyChar (string \"]]>\") -- FIXME use takeWhile instead\n        return $ TokenCDATA t\n    parseDoctype = do\n        _ <- string \"DOCTYPE\"\n        skipSpace\n        name <- parseName\n        let i =\n                case name of\n                    TName Nothing x  -> x\n                    TName (Just x) y -> T.concat [x, \":\", y]\n        skipSpace\n        eid <- fmap Just parsePublicID <|>\n               fmap Just parseSystemID <|>\n               return Nothing\n        skipSpace\n        ents <- (do\n            char' '['\n            ents <- parseEntities id\n            skipSpace\n            return ents) <|> return []\n        char' '>'\n        newline <|> return ()\n        return $ TokenDoctype i eid ents\n    parseEntities front =\n        (char ']' >> return (front [])) <|>\n        (parseEntity >>= \\e -> parseEntities (front . (e:))) <|>\n        (string \"<!--\" >> manyTill anyChar (string \"-->\") >>\n           parseEntities front) <|>\n         -- this clause handles directives like <!ELEMENT\n         -- and processing instructions:\n        (char '<' >> AT.skipWhile (/= '>') >> char '>'\n                  >> parseEntities front) <|>\n        (skipWhile (\\t -> t /= ']' && t /= '<') >> parseEntities front)\n    parseEntity = try $ do\n        _ <- string \"<!ENTITY\"\n        skipSpace\n        i <- parseIdent\n        t <- quotedText\n        skipSpace\n        char' '>'\n        return (i, t)\n    parsePublicID = PublicID <$> (string \"PUBLIC\" *> quotedText) <*> quotedText\n    parseSystemID = SystemID <$> (string \"SYSTEM\" *> quotedText)\n    quotedText = do\n        skipSpace\n        between '\"' <|> between '\\''\n    between c = do\n        char' c\n        x <- takeWhile (/=c)\n        char' c\n        return x\n    parseEnd = do\n        skipSpace\n        n <- parseName\n        skipSpace\n        char' '>'\n        return $ TokenEndElement n\n    parseBegin = do\n        skipSpace\n        n <- parseName\n        as <- A.many $ parseAttribute settings\n        skipSpace\n        isClose <- (char '/' >> skipSpace >> return True) <|> return False\n        char' '>'\n        return $ TokenBeginElement n as isClose 0\n\nparseAttribute :: ParseSettings -> Parser TAttribute\nparseAttribute settings = do\n    skipSpace\n    key <- parseName\n    skipSpace\n    char' '='\n    skipSpace\n    val <- squoted <|> dquoted\n    return (key, val)\n  where\n    squoted = char '\\'' *> manyTill (parseContent settings False True) (char '\\'')\n    dquoted = char  '\"' *> manyTill (parseContent settings True False) (char  '\"')\n\nparseName :: Parser TName\nparseName =\n  name <$> parseIdent <*> A.optional (char ':' >> parseIdent)\n  where\n    name i1 Nothing   = TName Nothing i1\n    name i1 (Just i2) = TName (Just i1) i2\n\nparseIdent :: Parser Text\nparseIdent =\n    takeWhile1 valid\n  where\n    valid '&'  = False\n    valid '<'  = False\n    valid '>'  = False\n    valid ':'  = False\n    valid '?'  = False\n    valid '='  = False\n    valid '\"'  = False\n    valid '\\'' = False\n    valid '/'  = False\n    valid ';'  = False\n    valid '#'  = False\n    valid c    = not $ isXMLSpace c\n\nparseContent :: ParseSettings\n             -> Bool -- break on double quote\n             -> Bool -- break on single quote\n             -> Parser Content\nparseContent (ParseSettings decodeEntities _ decodeIllegalCharacters) breakDouble breakSingle = parseReference <|> parseTextContent where\n  parseReference = do\n    char' '&'\n    t <- parseEntityRef <|> parseHexCharRef <|> parseDecCharRef\n    char' ';'\n    return t\n  parseEntityRef = do\n    TName ma b <- parseName\n    let name = maybe \"\" (`T.append` \":\") ma `T.append` b\n    return $ case name of\n      \"lt\"   -> ContentText \"<\"\n      \"gt\"   -> ContentText \">\"\n      \"amp\"  -> ContentText \"&\"\n      \"quot\" -> ContentText \"\\\"\"\n      \"apos\" -> ContentText \"'\"\n      _      -> decodeEntities name\n  parseHexCharRef = do\n    void $ string \"#x\"\n    n <- AT.hexadecimal\n    case toValidXmlChar n <|> decodeIllegalCharacters n of\n      Nothing -> fail \"Invalid character from hexadecimal character reference.\"\n      Just c -> return $ ContentText $ T.singleton c\n  parseDecCharRef = do\n    void $ string \"#\"\n    n <- AT.decimal\n    case toValidXmlChar n <|> decodeIllegalCharacters n of\n      Nothing -> fail \"Invalid character from decimal character reference.\"\n      Just c  -> return $ ContentText $ T.singleton c\n  parseTextContent = ContentText <$> takeWhile1 valid\n  valid '\"'  = not breakDouble\n  valid '\\'' = not breakSingle\n  valid '&'  = False -- amp\n  valid '<'  = False -- lt\n  valid _    = True\n\n-- | Is this codepoint a valid XML character? See\n-- <https://www.w3.org/TR/xml/#charsets>. This is proudly XML 1.0 only.\ntoValidXmlChar :: Int -> Maybe Char\ntoValidXmlChar n\n  | any checkRange ranges = Just (toEnum n)\n  | otherwise = Nothing\n  where\n    --Inclusive lower bound, inclusive upper bound.\n    ranges :: [(Int, Int)]\n    ranges =\n      [ (0x9, 0xA)\n      , (0xD, 0xD)\n      , (0x20, 0xD7FF)\n      , (0xE000, 0xFFFD)\n      , (0x10000, 0x10FFFF)\n      ]\n    checkRange (lb, ub) = lb <= n && n <= ub\n\nskipSpace :: Parser ()\nskipSpace = skipWhile isXMLSpace\n\n-- | Determines whether a character is an XML white space. The list of\n-- white spaces is given by\n--\n-- >  S ::= (#x20 | #x9 | #xD | #xA)+\n--\n-- in <http://www.w3.org/TR/2008/REC-xml-20081126/#sec-common-syn>.\nisXMLSpace :: Char -> Bool\nisXMLSpace ' '  = True\nisXMLSpace '\\t' = True\nisXMLSpace '\\r' = True\nisXMLSpace '\\n' = True\nisXMLSpace _    = False\n\nnewline :: Parser ()\nnewline = void $ (char '\\r' >> char '\\n') <|> char '\\n'\n\nchar' :: Char -> Parser ()\nchar' = void . char\n\ndata ContentType = Ignore | IsContent Text | IsError String | NotContent\n\n-- | Grabs the next piece of content if available. This function skips over any\n-- comments, instructions or entities, and concatenates all content until the next start\n-- or end tag.\ncontentMaybe :: MonadThrow m => ConduitT Event o m (Maybe Text)\ncontentMaybe = do\n    x <- peekC\n    case pc' x of\n        Ignore      -> dropC 1 >> contentMaybe\n        IsContent t -> dropC 1 >> fmap Just (takeContents (t:))\n        IsError e   -> lift $ throwM $ InvalidEntity e x\n        NotContent  -> return Nothing\n  where\n    pc' Nothing  = NotContent\n    pc' (Just x) = pc x\n    pc (EventContent (ContentText t)) = IsContent t\n    pc (EventContent (ContentEntity e)) = IsError $ \"Unknown entity: \" ++ show e\n    pc (EventCDATA t) = IsContent t\n    pc EventBeginElement{} = NotContent\n    pc EventEndElement{} = NotContent\n    pc EventBeginDocument{} = Ignore\n    pc EventEndDocument = Ignore\n    pc EventBeginDoctype{} = Ignore\n    pc EventEndDoctype = Ignore\n    pc EventInstruction{} = Ignore\n    pc EventComment{} = Ignore\n    takeContents front = do\n        x <- peekC\n        case pc' x of\n            Ignore      -> dropC 1 >> takeContents front\n            IsContent t -> dropC 1 >> takeContents (front . (:) t)\n            IsError e   -> lift $ throwM $ InvalidEntity e x\n            NotContent  -> return $ T.concat $ front []\n\n-- | Grabs the next piece of content. If none if available, returns 'T.empty'.\n-- This is simply a wrapper around 'contentMaybe'.\ncontent :: MonadThrow m => ConduitT Event o m Text\ncontent = fromMaybe T.empty <$> contentMaybe\n\n\nisWhitespace :: Event -> Bool\nisWhitespace EventBeginDocument             = True\nisWhitespace EventEndDocument               = True\nisWhitespace EventBeginDoctype{}            = True\nisWhitespace EventEndDoctype                = True\nisWhitespace EventInstruction{}             = True\nisWhitespace (EventContent (ContentText t)) = T.all isSpace t\nisWhitespace EventComment{}                 = True\nisWhitespace (EventCDATA t)                 = T.all isSpace t\nisWhitespace _                              = False\n\n\n-- | The most generic way to parse a tag. It takes a 'NameMatcher' to check whether\n-- this is a correct tag name, an 'AttrParser' to handle attributes, and\n-- then a parser to deal with content.\n--\n-- 'Events' are consumed if and only if the tag name and its attributes match.\n--\n-- This function automatically absorbs its balancing closing tag, and will\n-- throw an exception if not all of the attributes or child elements are\n-- consumed. If you want to allow extra attributes, see 'ignoreAttrs'.\n--\n-- This function automatically ignores comments, instructions and whitespace.\ntag :: MonadThrow m\n    => NameMatcher a -- ^ Check if this is a correct tag name\n                     --   and return a value that can be used to get an @AttrParser@.\n                     --   If this fails, the function will return @Nothing@\n    -> (a -> AttrParser b) -- ^ Given the value returned by the name checker, this function will\n                           --   be used to get an @AttrParser@ appropriate for the specific tag.\n                           --   If the @AttrParser@ fails, the function will also return @Nothing@\n    -> (b -> ConduitT Event o m c) -- ^ Handler function to handle the attributes and children\n                                   --   of a tag, given the value return from the @AttrParser@\n    -> ConduitT Event o m (Maybe c)\ntag nameMatcher attrParser f = do\n  (x, leftovers) <- dropWS []\n  res <- case x of\n    Just (EventBeginElement name as) -> case runNameMatcher nameMatcher name of\n      Just y -> case runAttrParser' (attrParser y) as of\n        Left _ -> return Nothing\n        Right z -> do\n          z' <- f z\n          (a, _leftovers') <- dropWS []\n          case a of\n            Just (EventEndElement name')\n              | name == name' -> return (Just z')\n            _ -> lift $ throwM $ InvalidEndElement name a\n      Nothing -> return Nothing\n    _ -> return Nothing\n\n  case res of\n    -- Did not parse, put back all of the leading whitespace events and the\n    -- final observed event generated by dropWS\n    Nothing -> mapM_ leftover leftovers\n    -- Parse succeeded, discard all of those whitespace events and the\n    -- first parsed event\n    Just _  -> return ()\n\n  return res\n  where\n    -- Drop Events until we encounter a non-whitespace element. Return all of\n    -- the events consumed here (including the first non-whitespace event) so\n    -- that the calling function can treat them as leftovers if the parse fails\n    dropWS leftovers = do\n        x <- await\n        let leftovers' = maybe id (:) x leftovers\n\n        case isWhitespace <$> x of\n          Just True -> dropWS leftovers'\n          _         -> return (x, leftovers')\n    runAttrParser' p as =\n        case runAttrParser p as of\n            Left e           -> Left e\n            Right ([], x)    -> Right x\n            Right (attr', _) -> Left $ toException $ UnparsedAttributes attr'\n\n-- | A simplified version of 'tag' where the 'NameMatcher' result isn't forwarded to the attributes parser.\n--\n-- Since 1.5.0\ntag' :: MonadThrow m\n     => NameMatcher a -> AttrParser b -> (b -> ConduitT Event o m c)\n     -> ConduitT Event o m (Maybe c)\ntag' a b = tag a (const b)\n\n-- | A further simplified tag parser, which requires that no attributes exist.\ntagNoAttr :: MonadThrow m\n          => NameMatcher a -- ^ Check if this is a correct tag name\n          -> ConduitT Event o m b -- ^ Handler function to handle the children of the matched tag\n          -> ConduitT Event o m (Maybe b)\ntagNoAttr name f = tag' name (return ()) $ const f\n\n\n-- | A further simplified tag parser, which ignores all attributes, if any exist\ntagIgnoreAttrs :: MonadThrow m\n               => NameMatcher a -- ^ Check if this is a correct tag name\n               -> ConduitT Event o m b -- ^ Handler function to handle the children of the matched tag\n               -> ConduitT Event o m (Maybe b)\ntagIgnoreAttrs name f = tag' name ignoreAttrs $ const f\n\n\n-- | Ignore an empty tag and all of its attributes.\n--   This does not ignore the tag recursively\n--   (i.e. it assumes there are no child elements).\n--   This function returns @Just ()@ if the tag matched.\n--\n-- Since 1.5.0\nignoreEmptyTag :: MonadThrow m\n          => NameMatcher a -- ^ Check if this is a correct tag name\n          -> ConduitT Event o m (Maybe ())\nignoreEmptyTag nameMatcher = tagIgnoreAttrs nameMatcher (return ())\n\n\nignored :: Monad m => ConduitT i o m ()\nignored = fix $ \\recurse -> do\n  event <- await\n  case event of\n    Just _ -> recurse\n    _      -> return ()\n\n\n-- | Same as `takeTree`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| (ignoreTree \"a\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| (ignoreTree \"b\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreTree anyName ignoreAttrs >> sinkList)\n-- [EventContent (ContentText \"content\"),EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- Since 1.9.0\nignoreTree :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event o m (Maybe ())\nignoreTree nameMatcher attrParser = fuseUpstream (takeTree nameMatcher attrParser) ignored\n\n-- | Same as `takeContent`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| (ignoreContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- Since 1.9.0\nignoreContent :: MonadThrow m => ConduitT Event o m (Maybe ())\nignoreContent = fuseUpstream takeContent ignored\n\n\n-- | Same as `takeTreeContent`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| (ignoreTreeContent \"a\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| (ignoreTreeContent \"b\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreTreeContent anyName ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- Since 1.5.0\nignoreTreeContent :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event o m (Maybe ())\nignoreTreeContent namePred attrParser = fuseUpstream (takeTreeContent namePred attrParser) ignored\n\n\n-- | Same as `takeAnyTreeContent`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| (ignoreAnyTreeContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"text<b></b>\" .| (ignoreAnyTreeContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- Since 1.5.0\nignoreAnyTreeContent :: MonadThrow m => ConduitT Event o m (Maybe ())\nignoreAnyTreeContent = fuseUpstream takeAnyTreeContent ignored\n\n\n-- | Get the value of the first parser which returns 'Just'. If no parsers\n-- succeed (i.e., return @Just@), this function returns 'Nothing'.\n--\n-- > orE a b = choose [a, b]\n--\n-- Warning: `orE` doesn't backtrack. See 'choose' for detailed explanation.\norE :: Monad m\n    => ConduitT Event o m (Maybe a) -- ^ The first (preferred) parser\n    -> ConduitT Event o m (Maybe a) -- ^ The second parser, only executed if the first parser fails\n    -> ConduitT Event o m (Maybe a)\norE a b = a >>= \\x -> maybe b (const $ return x) x\n\n-- | Get the value of the first parser which returns 'Just'. If no parsers\n-- succeed (i.e., return 'Just'), this function returns 'Nothing'.\n--\n-- Warning: 'choose' doesn't backtrack. If a parser consumed some events,\n-- subsequent parsers will continue from the following events. This can be a\n-- problem if parsers share an accepted prefix of events, so an earlier\n-- (failing) parser will discard the events that the later parser could\n-- potentially succeed on.\n--\n-- An other problematic case is using 'choose' to implement order-independent\n-- parsing using a set of parsers, with a final trailing ignore-anything-else\n-- action.  In this case, certain trees might be skipped.\n--\n-- >>> :{\n-- let parse2Tags name1 name2 = do\n--       tag1 <- tagNoAttr name1 (pure ())\n--       tag2 <- tagNoAttr name2 (pure tag1)\n--       return $ join tag2\n-- :}\n--\n-- >>> :{\n-- runConduit $ parseLBS def \"<a></a><b></b>\" .| choose\n--   [ parse2Tags \"a\" \"b\"\n--   , parse2Tags \"a\" \"c\"\n--   ]\n-- :}\n-- Just ()\n--\n-- >>> :{\n-- runConduit $ parseLBS def \"<a></a><b></b>\" .| choose\n--   [ parse2Tags \"a\" \"c\"\n--   , parse2Tags \"a\" \"b\"\n--   ]\n-- :}\n-- Nothing\nchoose :: Monad m\n       => [ConduitT Event o m (Maybe a)] -- ^ List of parsers that will be tried in order.\n       -> ConduitT Event o m (Maybe a)   -- ^ Result of the first parser to succeed, or @Nothing@\n                                         --   if no parser succeeded\nchoose []     = return Nothing\nchoose (i:is) = i >>= maybe (choose is) (return . Just)\n\n-- | Force an optional parser into a required parser. All of the 'tag'\n-- functions, 'attr', 'choose' and 'many' deal with 'Maybe' parsers. Use this when you\n-- want to finally force something to happen.\nforce :: MonadThrow m\n      => String -- ^ Error message\n      -> m (Maybe a) -- ^ Optional parser to be forced\n      -> m a\nforce msg i = i >>= maybe (throwM $ XmlException msg Nothing) return\n\n-- | A helper function which reads a file from disk using 'enumFile', detects\n-- character encoding using 'detectUtf', parses the XML using 'parseBytes', and\n-- then hands off control to your supplied parser.\nparseFile :: MonadResource m\n          => ParseSettings\n          -> FilePath\n          -> ConduitT i Event m ()\nparseFile ps fp = sourceFile fp .| transPipe liftIO (parseBytes ps)\n\n-- | Parse an event stream from a lazy 'L.ByteString'.\nparseLBS :: MonadThrow m\n         => ParseSettings\n         -> L.ByteString\n         -> ConduitT i Event m ()\nparseLBS ps lbs = sourceLazy lbs .| parseBytes ps\n\ndata XmlException = XmlException\n    { xmlErrorMessage :: String\n    , xmlBadInput     :: Maybe Event\n    }\n                  | InvalidEndElement Name (Maybe Event)\n                  | InvalidEntity String (Maybe Event)\n                  | MissingAttribute String\n                  | UnparsedAttributes [(Name, [Content])]\n    deriving (Show, Typeable)\n\ninstance Exception XmlException where\n#if MIN_VERSION_base(4, 8, 0)\n  displayException (XmlException msg (Just event)) = \"Error while parsing XML event \" ++ show event ++ \": \" ++ msg\n  displayException (XmlException msg _) = \"Error while parsing XML: \" ++ msg\n  displayException (InvalidEndElement name (Just event)) = \"Error while parsing XML event: expected </\" ++ T.unpack (nameLocalName name) ++ \">, got \" ++ show event\n  displayException (InvalidEndElement name _) = \"Error while parsing XML event: expected </\" ++ show name ++ \">, got nothing\"\n  displayException (InvalidEntity msg (Just event)) = \"Error while parsing XML entity \" ++ show event ++ \": \" ++ msg\n  displayException (InvalidEntity msg _) = \"Error while parsing XML entity: \" ++ msg\n  displayException (MissingAttribute msg) = \"Missing required attribute: \" ++ msg\n  displayException (UnparsedAttributes attrs) = show (length attrs) ++ \" remaining unparsed attributes: \\n\" ++ intercalate \"\\n\" (show <$> attrs)\n#endif\n\n\n-- | A @NameMatcher@ describes which names a tag parser is allowed to match.\n--\n-- Since 1.5.0\nnewtype NameMatcher a = NameMatcher { runNameMatcher :: Name -> Maybe a }\n\nderiving instance Functor NameMatcher\n\ninstance Applicative NameMatcher where\n  pure a = NameMatcher $ const $ pure a\n  NameMatcher f <*> NameMatcher a = NameMatcher $ \\name -> f name <*> a name\n\n-- | 'NameMatcher's can be combined with @\\<|\\>@\ninstance Alternative NameMatcher where\n  empty = NameMatcher $ const Nothing\n  NameMatcher f <|> NameMatcher g = NameMatcher (\\a -> f a <|> g a)\n\n-- | Match a single 'Name' in a concise way.\n-- Note that 'Name' is namespace sensitive: when using the 'IsString' instance,\n-- use @\"{http:\\/\\/a\\/b}c\"@ to match the tag @c@ in the XML namespace @http://a/b@\ninstance (a ~ Name) => IsString (NameMatcher a) where\n  fromString s = matching (== fromString s)\n\n-- | @matching f@ matches @name@ iff @f name@ is true. Returns the matched 'Name'.\n--\n-- Since 1.5.0\nmatching :: (Name -> Bool) -> NameMatcher Name\nmatching f = NameMatcher $ \\name -> if f name then Just name else Nothing\n\n-- | Matches any 'Name'. Returns the matched 'Name'.\n--\n-- Since 1.5.0\nanyName :: NameMatcher Name\nanyName = matching (const True)\n\n-- | Matches any 'Name' from the given list. Returns the matched 'Name'.\n--\n-- Since 1.5.0\nanyOf :: [Name] -> NameMatcher Name\nanyOf values = matching (`elem` values)\n\n\n-- | A monad for parsing attributes. By default, it requires you to deal with\n-- all attributes present on an element, and will throw an exception if there\n-- are unhandled attributes. Use the 'requireAttr', 'attr' et al\n-- functions for handling an attribute, and 'ignoreAttrs' if you would like to\n-- skip the rest of the attributes on an element.\n--\n-- 'Alternative' instance behaves like 'First' monoid: it chooses first\n-- parser which doesn't fail.\nnewtype AttrParser a = AttrParser { runAttrParser :: [(Name, [Content])] -> Either SomeException ([(Name, [Content])], a) }\n\ninstance Monad AttrParser where\n    return a = AttrParser $ \\as -> Right (as, a)\n    (AttrParser f) >>= g = AttrParser $ \\as ->\n        either Left (\\(as', f') -> runAttrParser (g f') as') (f as)\ninstance Functor AttrParser where\n    fmap = liftM\ninstance Applicative AttrParser where\n    pure = return\n    (<*>) = ap\ninstance Alternative AttrParser where\n    empty = AttrParser $ const $ Left $ toException $ XmlException \"AttrParser.empty\" Nothing\n    AttrParser f <|> AttrParser g = AttrParser $ \\x ->\n        either (const $ g x) Right (f x)\ninstance MonadThrow AttrParser where\n    throwM = AttrParser . const . throwM\n\noptionalAttrRaw :: ((Name, [Content]) -> Maybe b) -> AttrParser (Maybe b)\noptionalAttrRaw f =\n    AttrParser $ go id\n  where\n    go front [] = Right (front [], Nothing)\n    go front (a:as) =\n        maybe (go (front . (:) a) as)\n              (\\b -> Right (front as, Just b))\n              (f a)\n\nrequireAttrRaw :: String -> ((Name, [Content]) -> Maybe b) -> AttrParser b\nrequireAttrRaw msg f = optionalAttrRaw f >>=\n    maybe (AttrParser $ const $ Left $ toException $ MissingAttribute msg)\n          return\n\n-- | Return the value for an attribute if present.\nattr :: Name -> AttrParser (Maybe Text)\nattr n = optionalAttrRaw\n    (\\(x, y) -> if x == n then Just (contentsToText y) else Nothing)\n\n-- | Shortcut composition of 'force' and 'attr'.\nrequireAttr :: Name -> AttrParser Text\nrequireAttr n = force (\"Missing attribute: \" ++ show n) $ attr n\n\n\n{-# DEPRECATED optionalAttr \"Please use 'attr'.\" #-}\noptionalAttr :: Name -> AttrParser (Maybe Text)\noptionalAttr = attr\n\ncontentsToText :: [Content] -> Text\ncontentsToText = T.concat . map toText where\n  toText (ContentText t)   = t\n  toText (ContentEntity e) = T.concat [\"&\", e, \";\"]\n\n-- | Skip the remaining attributes on an element. Since this will clear the\n-- list of attributes, you must call this /after/ any calls to 'requireAttr',\n-- 'optionalAttr', etc.\nignoreAttrs :: AttrParser ()\nignoreAttrs = AttrParser $ const $ Right ([], ())\n\n-- | Keep parsing elements as long as the parser returns 'Just'.\nmany :: Monad m\n     => ConduitT Event o m (Maybe a)\n     -> ConduitT Event o m [a]\nmany i = manyIgnore i $ return Nothing\n\n-- | Like 'many' but discards the results without building an intermediate list.\n--\n-- Since 1.5.0\nmany_ :: MonadThrow m\n      => ConduitT Event o m (Maybe a)\n      -> ConduitT Event o m ()\nmany_ consumer = manyIgnoreYield (return Nothing) (void <$> consumer)\n\n-- | Keep parsing elements as long as the parser returns 'Just'\n--   or the ignore parser returns 'Just'.\nmanyIgnore :: Monad m\n           => ConduitT Event o m (Maybe a)\n           -> ConduitT Event o m (Maybe b)\n           -> ConduitT Event o m [a]\nmanyIgnore i ignored = go id where\n  go front = i >>= maybe (onFail front) (\\y -> go $ front . (:) y)\n  -- onFail is called if the main parser fails\n  onFail front = ignored >>= maybe (return $ front []) (const $ go front)\n\n-- | Like @many@, but any tags and content the consumer doesn't match on\n--   are silently ignored.\nmany' :: MonadThrow m\n      => ConduitT Event o m (Maybe a)\n      -> ConduitT Event o m [a]\nmany' consumer = manyIgnore consumer ignoreAnyTreeContent\n\n\n-- | Like 'many', but uses 'yield' so the result list can be streamed\n--   to downstream conduits without waiting for 'manyYield' to finish\nmanyYield :: Monad m\n          => ConduitT a b m (Maybe b)\n          -> ConduitT a b m ()\nmanyYield consumer = fix $ \\loop ->\n  consumer >>= maybe (return ()) (\\x -> yield x >> loop)\n\n-- | Like 'manyIgnore', but uses 'yield' so the result list can be streamed\n--   to downstream conduits without waiting for 'manyIgnoreYield' to finish\nmanyIgnoreYield :: MonadThrow m\n                => ConduitT Event b m (Maybe b) -- ^ Consuming parser that generates the result stream\n                -> ConduitT Event b m (Maybe ()) -- ^ Ignore parser that consumes elements to be ignored\n                -> ConduitT Event b m ()\nmanyIgnoreYield consumer ignoreParser = fix $ \\loop ->\n  consumer >>= maybe (onFail loop) (\\x -> yield x >> loop)\n  where onFail loop = ignoreParser >>= maybe (return ()) (const loop)\n\n-- | Like 'many'', but uses 'yield' so the result list can be streamed\n--   to downstream conduits without waiting for 'manyYield'' to finish\nmanyYield' :: MonadThrow m\n           => ConduitT Event b m (Maybe b)\n           -> ConduitT Event b m ()\nmanyYield' consumer = manyIgnoreYield consumer ignoreAnyTreeContent\n\n\n-- | Stream a single content 'Event'.\n--\n-- Returns @Just ()@ if a content 'Event' was consumed, @Nothing@ otherwise.\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| void takeContent .| sinkList\n-- [EventBeginDocument,EventContent (ContentText \"content\")]\n--\n-- If next event isn't a content, nothing is consumed.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| void takeContent .| sinkList\n-- [EventBeginDocument]\n--\n-- Since 1.5.0\ntakeContent :: MonadThrow m => ConduitT Event Event m (Maybe ())\ntakeContent = do\n  event <- await\n  case event of\n    Just e@EventContent{} -> yield e >> return (Just ())\n    Just e@EventCDATA{}   -> yield e >> return (Just ())\n    Just e -> if isWhitespace e then yield e >> takeContent else leftover e >> return Nothing\n    _ -> return Nothing\n\n-- | Stream 'Event's corresponding to a single XML element that matches given 'NameMatcher' and 'AttrParser', from the opening- to the closing-tag.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTree \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument,EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...})]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTree \"b\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument]\n--\n-- If next 'Event' isn't an element, nothing is consumed.\n--\n-- >>> runConduit $ parseLBS def \"text<a></a>\" .| void (takeTree \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument]\n--\n-- If an opening-tag is consumed but no matching closing-tag is found, an 'XmlException' is thrown.\n--\n-- >>> runConduit $ parseLBS def \"<a><b></b>\" .| void (takeTree \"a\" ignoreAttrs) .| sinkList\n-- *** Exception: InvalidEndElement (Name {nameLocalName = \"a\", nameNamespace = Nothing, namePrefix = Nothing}) Nothing\n--\n-- This function automatically ignores comments, instructions and whitespace.\n--\n-- Returns @Just ()@ if an element was consumed, 'Nothing' otherwise.\n--\n-- Since 1.5.0\ntakeTree :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event Event m (Maybe ())\ntakeTree nameMatcher attrParser = do\n  event <- await\n  case event of\n    Just e@(EventBeginElement name as) -> case runNameMatcher nameMatcher name of\n      Just _ -> case runAttrParser attrParser as of\n        Right _ -> do\n          yield e\n          whileJust takeAnyTreeContent\n          endEvent <- await\n          case endEvent of\n            Just e'@(EventEndElement name') | name == name' -> yield e' >> return (Just ())\n            _ -> lift $ throwM $ InvalidEndElement name endEvent\n        _ -> leftover e >> return Nothing\n      _ -> leftover e >> return Nothing\n\n    Just e -> if isWhitespace e then yield e >> takeTree nameMatcher attrParser else leftover e >> return Nothing\n    _ -> return Nothing\n  where\n    whileJust f = fix $ \\loop -> f >>= maybe (return ()) (const loop)\n\n-- | Like 'takeTree', but can also stream a content 'Event'.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTreeContent \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument,EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...})]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTreeContent \"b\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a><b></b>\" .| void (takeTreeContent \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument,EventContent (ContentText \"content\")]\n--\n-- Since 1.5.0\ntakeTreeContent :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event Event m (Maybe ())\ntakeTreeContent nameMatcher attrParser = runMaybeT $ MaybeT (takeTree nameMatcher attrParser) <|> MaybeT takeContent\n\n-- | Like 'takeTreeContent', without checking for tag name or attributes.\n--\n-- >>> runConduit $ parseLBS def \"text<a></a>\" .| void takeAnyTreeContent .| sinkList\n-- [EventBeginDocument,EventContent (ContentText \"text\")]\n--\n-- >>> runConduit $ parseLBS def \"</a><b></b>\" .| void takeAnyTreeContent .| sinkList\n-- [EventBeginDocument]\n--\n-- >>> runConduit $ parseLBS def \"<b><c></c></b></a>text\" .| void takeAnyTreeContent .| sinkList\n-- [EventBeginDocument,EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventBeginElement (Name {nameLocalName = \"c\", ...}) [],EventEndElement (Name {nameLocalName = \"c\", ...}),EventEndElement (Name {nameLocalName = \"b\", ...})]\n--\n-- Since 1.5.0\ntakeAnyTreeContent :: MonadThrow m\n                => ConduitT Event Event m (Maybe ())\ntakeAnyTreeContent = takeTreeContent anyName ignoreAttrs\n\n\n-- | Default implementation of 'DecodeEntities', which leaves the\n-- entity as-is. Numeric character references and the five standard\n-- entities (lt, gt, amp, quot, pos) are handled internally by the\n-- parser.\ndecodeXmlEntities :: DecodeEntities\ndecodeXmlEntities = ContentEntity\n\n-- | HTML4-compliant entity decoder. Handles the additional 248\n-- entities defined by HTML 4 and XHTML 1.\n--\n-- Note that HTML 5 introduces a drastically larger number of entities, and\n-- this code does not recognize most of them.\ndecodeHtmlEntities :: DecodeEntities\ndecodeHtmlEntities t =\n  maybe (ContentEntity t) ContentText $ Map.lookup t htmlEntities\n\nhtmlEntities :: Map.Map T.Text T.Text\nhtmlEntities = Map.fromList\n    $ map (pack *** pack) -- Work around the long-compile-time bug\n    [ (\"nbsp\", \"\\160\")\n    , (\"iexcl\", \"\\161\")\n    , (\"cent\", \"\\162\")\n    , (\"pound\", \"\\163\")\n    , (\"curren\", \"\\164\")\n    , (\"yen\", \"\\165\")\n    , (\"brvbar\", \"\\166\")\n    , (\"sect\", \"\\167\")\n    , (\"uml\", \"\\168\")\n    , (\"copy\", \"\\169\")\n    , (\"ordf\", \"\\170\")\n    , (\"laquo\", \"\\171\")\n    , (\"not\", \"\\172\")\n    , (\"shy\", \"\\173\")\n    , (\"reg\", \"\\174\")\n    , (\"macr\", \"\\175\")\n    , (\"deg\", \"\\176\")\n    , (\"plusmn\", \"\\177\")\n    , (\"sup2\", \"\\178\")\n    , (\"sup3\", \"\\179\")\n    , (\"acute\", \"\\180\")\n    , (\"micro\", \"\\181\")\n    , (\"para\", \"\\182\")\n    , (\"middot\", \"\\183\")\n    , (\"cedil\", \"\\184\")\n    , (\"sup1\", \"\\185\")\n    , (\"ordm\", \"\\186\")\n    , (\"raquo\", \"\\187\")\n    , (\"frac14\", \"\\188\")\n    , (\"frac12\", \"\\189\")\n    , (\"frac34\", \"\\190\")\n    , (\"iquest\", \"\\191\")\n    , (\"Agrave\", \"\\192\")\n    , (\"Aacute\", \"\\193\")\n    , (\"Acirc\", \"\\194\")\n    , (\"Atilde\", \"\\195\")\n    , (\"Auml\", \"\\196\")\n    , (\"Aring\", \"\\197\")\n    , (\"AElig\", \"\\198\")\n    , (\"Ccedil\", \"\\199\")\n    , (\"Egrave\", \"\\200\")\n    , (\"Eacute\", \"\\201\")\n    , (\"Ecirc\", \"\\202\")\n    , (\"Euml\", \"\\203\")\n    , (\"Igrave\", \"\\204\")\n    , (\"Iacute\", \"\\205\")\n    , (\"Icirc\", \"\\206\")\n    , (\"Iuml\", \"\\207\")\n    , (\"ETH\", \"\\208\")\n    , (\"Ntilde\", \"\\209\")\n    , (\"Ograve\", \"\\210\")\n    , (\"Oacute\", \"\\211\")\n    , (\"Ocirc\", \"\\212\")\n    , (\"Otilde\", \"\\213\")\n    , (\"Ouml\", \"\\214\")\n    , (\"times\", \"\\215\")\n    , (\"Oslash\", \"\\216\")\n    , (\"Ugrave\", \"\\217\")\n    , (\"Uacute\", \"\\218\")\n    , (\"Ucirc\", \"\\219\")\n    , (\"Uuml\", \"\\220\")\n    , (\"Yacute\", \"\\221\")\n    , (\"THORN\", \"\\222\")\n    , (\"szlig\", \"\\223\")\n    , (\"agrave\", \"\\224\")\n    , (\"aacute\", \"\\225\")\n    , (\"acirc\", \"\\226\")\n    , (\"atilde\", \"\\227\")\n    , (\"auml\", \"\\228\")\n    , (\"aring\", \"\\229\")\n    , (\"aelig\", \"\\230\")\n    , (\"ccedil\", \"\\231\")\n    , (\"egrave\", \"\\232\")\n    , (\"eacute\", \"\\233\")\n    , (\"ecirc\", \"\\234\")\n    , (\"euml\", \"\\235\")\n    , (\"igrave\", \"\\236\")\n    , (\"iacute\", \"\\237\")\n    , (\"icirc\", \"\\238\")\n    , (\"iuml\", \"\\239\")\n    , (\"eth\", \"\\240\")\n    , (\"ntilde\", \"\\241\")\n    , (\"ograve\", \"\\242\")\n    , (\"oacute\", \"\\243\")\n    , (\"ocirc\", \"\\244\")\n    , (\"otilde\", \"\\245\")\n    , (\"ouml\", \"\\246\")\n    , (\"divide\", \"\\247\")\n    , (\"oslash\", \"\\248\")\n    , (\"ugrave\", \"\\249\")\n    , (\"uacute\", \"\\250\")\n    , (\"ucirc\", \"\\251\")\n    , (\"uuml\", \"\\252\")\n    , (\"yacute\", \"\\253\")\n    , (\"thorn\", \"\\254\")\n    , (\"yuml\", \"\\255\")\n    , (\"OElig\", \"\\338\")\n    , (\"oelig\", \"\\339\")\n    , (\"Scaron\", \"\\352\")\n    , (\"scaron\", \"\\353\")\n    , (\"Yuml\", \"\\376\")\n    , (\"fnof\", \"\\402\")\n    , (\"circ\", \"\\710\")\n    , (\"tilde\", \"\\732\")\n    , (\"Alpha\", \"\\913\")\n    , (\"Beta\", \"\\914\")\n    , (\"Gamma\", \"\\915\")\n    , (\"Delta\", \"\\916\")\n    , (\"Epsilon\", \"\\917\")\n    , (\"Zeta\", \"\\918\")\n    , (\"Eta\", \"\\919\")\n    , (\"Theta\", \"\\920\")\n    , (\"Iota\", \"\\921\")\n    , (\"Kappa\", \"\\922\")\n    , (\"Lambda\", \"\\923\")\n    , (\"Mu\", \"\\924\")\n    , (\"Nu\", \"\\925\")\n    , (\"Xi\", \"\\926\")\n    , (\"Omicron\", \"\\927\")\n    , (\"Pi\", \"\\928\")\n    , (\"Rho\", \"\\929\")\n    , (\"Sigma\", \"\\931\")\n    , (\"Tau\", \"\\932\")\n    , (\"Upsilon\", \"\\933\")\n    , (\"Phi\", \"\\934\")\n    , (\"Chi\", \"\\935\")\n    , (\"Psi\", \"\\936\")\n    , (\"Omega\", \"\\937\")\n    , (\"alpha\", \"\\945\")\n    , (\"beta\", \"\\946\")\n    , (\"gamma\", \"\\947\")\n    , (\"delta\", \"\\948\")\n    , (\"epsilon\", \"\\949\")\n    , (\"zeta\", \"\\950\")\n    , (\"eta\", \"\\951\")\n    , (\"theta\", \"\\952\")\n    , (\"iota\", \"\\953\")\n    , (\"kappa\", \"\\954\")\n    , (\"lambda\", \"\\955\")\n    , (\"mu\", \"\\956\")\n    , (\"nu\", \"\\957\")\n    , (\"xi\", \"\\958\")\n    , (\"omicron\", \"\\959\")\n    , (\"pi\", \"\\960\")\n    , (\"rho\", \"\\961\")\n    , (\"sigmaf\", \"\\962\")\n    , (\"sigma\", \"\\963\")\n    , (\"tau\", \"\\964\")\n    , (\"upsilon\", \"\\965\")\n    , (\"phi\", \"\\966\")\n    , (\"chi\", \"\\967\")\n    , (\"psi\", \"\\968\")\n    , (\"omega\", \"\\969\")\n    , (\"thetasym\", \"\\977\")\n    , (\"upsih\", \"\\978\")\n    , (\"piv\", \"\\982\")\n    , (\"ensp\", \"\\8194\")\n    , (\"emsp\", \"\\8195\")\n    , (\"thinsp\", \"\\8201\")\n    , (\"zwnj\", \"\\8204\")\n    , (\"zwj\", \"\\8205\")\n    , (\"lrm\", \"\\8206\")\n    , (\"rlm\", \"\\8207\")\n    , (\"ndash\", \"\\8211\")\n    , (\"mdash\", \"\\8212\")\n    , (\"lsquo\", \"\\8216\")\n    , (\"rsquo\", \"\\8217\")\n    , (\"sbquo\", \"\\8218\")\n    , (\"ldquo\", \"\\8220\")\n    , (\"rdquo\", \"\\8221\")\n    , (\"bdquo\", \"\\8222\")\n    , (\"dagger\", \"\\8224\")\n    , (\"Dagger\", \"\\8225\")\n    , (\"bull\", \"\\8226\")\n    , (\"hellip\", \"\\8230\")\n    , (\"permil\", \"\\8240\")\n    , (\"prime\", \"\\8242\")\n    , (\"Prime\", \"\\8243\")\n    , (\"lsaquo\", \"\\8249\")\n    , (\"rsaquo\", \"\\8250\")\n    , (\"oline\", \"\\8254\")\n    , (\"frasl\", \"\\8260\")\n    , (\"euro\", \"\\8364\")\n    , (\"image\", \"\\8465\")\n    , (\"weierp\", \"\\8472\")\n    , (\"real\", \"\\8476\")\n    , (\"trade\", \"\\8482\")\n    , (\"alefsym\", \"\\8501\")\n    , (\"larr\", \"\\8592\")\n    , (\"uarr\", \"\\8593\")\n    , (\"rarr\", \"\\8594\")\n    , (\"darr\", \"\\8595\")\n    , (\"harr\", \"\\8596\")\n    , (\"crarr\", \"\\8629\")\n    , (\"lArr\", \"\\8656\")\n    , (\"uArr\", \"\\8657\")\n    , (\"rArr\", \"\\8658\")\n    , (\"dArr\", \"\\8659\")\n    , (\"hArr\", \"\\8660\")\n    , (\"forall\", \"\\8704\")\n    , (\"part\", \"\\8706\")\n    , (\"exist\", \"\\8707\")\n    , (\"empty\", \"\\8709\")\n    , (\"nabla\", \"\\8711\")\n    , (\"isin\", \"\\8712\")\n    , (\"notin\", \"\\8713\")\n    , (\"ni\", \"\\8715\")\n    , (\"prod\", \"\\8719\")\n    , (\"sum\", \"\\8721\")\n    , (\"minus\", \"\\8722\")\n    , (\"lowast\", \"\\8727\")\n    , (\"radic\", \"\\8730\")\n    , (\"prop\", \"\\8733\")\n    , (\"infin\", \"\\8734\")\n    , (\"ang\", \"\\8736\")\n    , (\"and\", \"\\8743\")\n    , (\"or\", \"\\8744\")\n    , (\"cap\", \"\\8745\")\n    , (\"cup\", \"\\8746\")\n    , (\"int\", \"\\8747\")\n    , (\"there4\", \"\\8756\")\n    , (\"sim\", \"\\8764\")\n    , (\"cong\", \"\\8773\")\n    , (\"asymp\", \"\\8776\")\n    , (\"ne\", \"\\8800\")\n    , (\"equiv\", \"\\8801\")\n    , (\"le\", \"\\8804\")\n    , (\"ge\", \"\\8805\")\n    , (\"sub\", \"\\8834\")\n    , (\"sup\", \"\\8835\")\n    , (\"nsub\", \"\\8836\")\n    , (\"sube\", \"\\8838\")\n    , (\"supe\", \"\\8839\")\n    , (\"oplus\", \"\\8853\")\n    , (\"otimes\", \"\\8855\")\n    , (\"perp\", \"\\8869\")\n    , (\"sdot\", \"\\8901\")\n    , (\"lceil\", \"\\8968\")\n    , (\"rceil\", \"\\8969\")\n    , (\"lfloor\", \"\\8970\")\n    , (\"rfloor\", \"\\8971\")\n    , (\"lang\", \"\\9001\")\n    , (\"rang\", \"\\9002\")\n    , (\"loz\", \"\\9674\")\n    , (\"spades\", \"\\9824\")\n    , (\"clubs\", \"\\9827\")\n    , (\"hearts\", \"\\9829\")\n    , (\"diams\", \"\\9830\")\n    ]\n", "{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE OverloadedStrings  #-}\n\nimport           Control.Exception            (Exception, toException)\nimport           Control.Monad.IO.Class       (liftIO)\nimport qualified Data.ByteString.Char8        as S\nimport qualified Data.ByteString.Lazy.Char8   as L\nimport           Data.Typeable                (Typeable)\nimport           Data.XML.Types\nimport           Test.Hspec\nimport           Test.HUnit                   hiding (Test)\nimport qualified Text.XML                     as Res\nimport qualified Text.XML.Cursor              as Cu\nimport           Text.XML.Stream.Parse        (def)\nimport qualified Text.XML.Stream.Parse        as P\nimport qualified Text.XML.Unresolved          as D\n\nimport           Control.Monad\nimport qualified Data.Set                     as Set\nimport           Data.Text                    (Text)\nimport qualified Data.Text                    as T\nimport           Text.XML.Cursor              (($.//), ($/), ($//), ($|),\n                                               (&.//), (&/), (&//))\n\nimport qualified Control.Monad.Trans.Resource as C\nimport           Data.Conduit                 ((.|), runConduit, runConduitRes, ConduitT)\nimport qualified Data.Conduit                 as C\nimport qualified Data.Conduit.List            as CL\nimport qualified Data.Map                     as Map\nimport           Text.Blaze                   (toMarkup)\nimport           Text.Blaze.Renderer.String   (renderMarkup)\n\nmain :: IO ()\nmain = hspec $ do\n    describe \"XML parsing and rendering\" $ do\n        it \"is idempotent to parse and render a document\" documentParseRender\n        it \"has valid parser combinators\" combinators\n        context \"has working choose function\" testChoose\n        it \"has working many function\" testMany\n        it \"has working many' function\" testMany'\n        it \"has working manyYield function\" testManyYield\n        it \"has working takeContent function\" testTakeContent\n        it \"has working takeTree function\" testTakeTree\n        it \"has working takeAnyTreeContent function\" testTakeAnyTreeContent\n        it \"has working orE\" testOrE\n        it \"is idempotent to parse and pretty render a document\" documentParsePrettyRender\n        it \"ignores the BOM\" parseIgnoreBOM\n        it \"strips duplicated attributes\" stripDuplicateAttributes\n        it \"displays comments\" testRenderComments\n        it \"conduit parser\" testConduitParser\n        it \"can omit the XML declaration\" omitXMLDeclaration\n        context \"correctly parses hexadecimal entities\" hexEntityParsing\n    describe \"XML Cursors\" $ do\n        it \"has correct parent\" cursorParent\n        it \"has correct ancestor\" cursorAncestor\n        it \"has correct orSelf\" cursorOrSelf\n        it \"has correct preceding\" cursorPreceding\n        it \"has correct following\" cursorFollowing\n        it \"has correct precedingSibling\" cursorPrecedingSib\n        it \"has correct followingSibling\" cursorFollowingSib\n        it \"has correct descendant\" cursorDescendant\n        it \"has correct check\" cursorCheck\n        it \"has correct check with lists\" cursorPredicate\n        it \"has correct checkNode\" cursorCheckNode\n        it \"has correct checkElement\" cursorCheckElement\n        it \"has correct checkName\" cursorCheckName\n        it \"has correct anyElement\" cursorAnyElement\n        it \"has correct element\" cursorElement\n        it \"has correct laxElement\" cursorLaxElement\n        it \"has correct content\" cursorContent\n        it \"has correct attribute\" cursorAttribute\n        it \"has correct laxAttribute\" cursorLaxAttribute\n        it \"has correct &* and $* operators\" cursorDeep\n        it \"has correct force\" cursorForce\n        it \"has correct forceM\" cursorForceM\n        it \"has correct hasAttribute\" cursorHasAttribute\n        it \"has correct attributeIs\" cursorAttributeIs\n    describe \"resolved\" $ do\n        it \"identifies unresolved entities\" resolvedIdentifies\n        it \"decodeHtmlEntities\" testHtmlEntities\n        it \"works for resolvable entities\" resolvedAllGood\n        it \"merges adjacent content nodes\" resolvedMergeContent\n        it \"understands inline entity declarations\" resolvedInline\n        it \"doesn't break on [] in doctype comments\" doctypeComment\n        it \"skips element declarations in doctype\" doctypeElements\n        it \"skips processing instructions in doctype\" doctypePI\n    describe \"pretty\" $ do\n        it \"works\" casePretty\n    describe \"top level namespaces\" $ do\n        it \"works\" caseTopLevelNamespace\n        it \"works with prefix\" caseTopLevelNamespacePrefix\n        it \"handles conflicts\" caseTLNConflict\n    describe \"blaze-html instances\" $ do\n        it \"works\" caseBlazeHtml\n    describe \"attribute reordering\" $ do\n        it \"works\" caseAttrReorder\n    describe \"ordering attributes explicitly\" $ do\n        it \"works\" caseOrderAttrs\n    it \"parsing CDATA\" caseParseCdata\n    it \"retains namespaces when asked\" caseRetainNamespaces\n    it \"handles iso-8859-1\" caseIso8859_1\n    it \"renders CDATA when asked\" caseRenderCDATA\n    it \"escapes CDATA closing tag in CDATA\" caseEscapesCDATA\n\ndocumentParseRender :: IO ()\ndocumentParseRender =\n    mapM_ go docs\n  where\n    go x = x @=? D.parseLBS_ def (D.renderLBS def x)\n    docs =\n        [ Document (Prologue [] Nothing [])\n                   (Element \"foo\" [] [])\n                   []\n        , D.parseLBS_ def\n            \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo>\\n<foo/>\"\n        , D.parseLBS_ def\n            \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo>\\n<foo><nested>&ignore;</nested></foo>\"\n        , D.parseLBS_ def\n            \"<foo><![CDATA[this is some<CDATA content>]]></foo>\"\n        , D.parseLBS_ def\n            \"<foo bar='baz&amp;bin'/>\"\n        , D.parseLBS_ def\n            \"<foo><?instr this is a processing instruction?></foo>\"\n        , D.parseLBS_ def\n            \"<foo><!-- this is a comment --></foo>\"\n        ]\n\ndocumentParsePrettyRender :: IO ()\ndocumentParsePrettyRender =\n    L.unpack (D.renderLBS def { D.rsPretty = True } (D.parseLBS_ def doc)) @?= L.unpack doc\n  where\n    doc = L.unlines\n        [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n        , \"<foo>\"\n        , \"    <?bar bar?>\"\n        , \"    text\"\n        , \"    <?bin bin?>\"\n        , \"</foo>\"\n        ]\n\ncombinators :: Assertion\ncombinators = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tag' \"hello\" (P.requireAttr \"world\") $ \\world -> do\n        liftIO $ world @?= \"true\"\n        P.force \"need child1\" $ P.tagNoAttr \"{mynamespace}child1\" $ return ()\n        P.force \"need child2\" $ P.tagNoAttr \"child2\" $ return ()\n        P.force \"need child3\" $ P.tagNoAttr \"child3\" $ do\n            x <- P.contentMaybe\n            liftIO $ x @?= Just \"combine <all> &content\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello world='true'>\"\n        , \"<?this should be ignored?>\"\n        , \"<child1 xmlns='mynamespace'/>\"\n        , \"<!-- this should be ignored -->\"\n        , \"<child2>   </child2>\"\n        , \"<child3>combine &lt;all&gt; <![CDATA[&content]]></child3>\\n\"\n        , \"</hello>\"\n        ]\n\ntestChoose :: Spec\ntestChoose = do\n    it \"can choose between elements\"\n        testChooseEitherElem\n    it \"can choose between elements and text, returning text\"\n        testChooseElemOrTextIsText\n    it \"can choose between elements and text, returning elements\"\n        testChooseElemOrTextIsElem\n    it \"can choose between text and elements, returning text\"\n        testChooseTextOrElemIsText\n    it \"can choose between text and elements, returning elements\"\n        testChooseTextOrElemIsElem\n    it \"can choose between text and elements, when the text is encoded\"\n        testChooseElemOrTextIsEncoded\n    it \"can choose between text and elements, when the text is encoded, NBSP\"\n        testChooseElemOrTextIsEncodedNBSP\n    it \"can choose between elements and text, when the text is whitespace\"\n        testChooseElemOrTextIsWhiteSpace\n    it \"can choose between text and elements, when the text is whitespace\"\n        testChooseTextOrElemIsWhiteSpace\n    it \"can choose between text and elements, when the whitespace is both literal and encoded\"\n        testChooseElemOrTextIsChunkedText\n    it \"can choose between text and elements, when the text is chunked the other way\"\n        testChooseElemOrTextIsChunkedText2\n\ntestChooseElemOrTextIsText :: Assertion\ntestChooseElemOrTextIsText = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \" something \"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \" something \"\n        , \"</hello>\"\n        ]\n\ntestChooseElemOrTextIsEncoded :: Assertion\ntestChooseElemOrTextIsEncoded = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20something\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"&#x20;something&#x20;\"\n        , \"</hello>\"\n        ]\n\ntestChooseElemOrTextIsEncodedNBSP :: Assertion\ntestChooseElemOrTextIsEncodedNBSP = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\160something\\160\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"&#160;something&#160;\"\n        , \"</hello>\"\n        ]\n\n\ntestChooseElemOrTextIsWhiteSpace :: Assertion\ntestChooseElemOrTextIsWhiteSpace = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>   </hello>\"\n        ]\n\ntestChooseTextOrElemIsWhiteSpace :: Assertion\ntestChooseTextOrElemIsWhiteSpace = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.contentMaybe\n            , P.tagNoAttr \"failure\" $ return \"boom\"\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>   </hello>\"\n        ]\n\ntestChooseElemOrTextIsChunkedText :: Assertion\ntestChooseElemOrTextIsChunkedText = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello> &#x20; </hello>\"\n        ]\n\ntestChooseElemOrTextIsChunkedText2 :: Assertion\ntestChooseElemOrTextIsChunkedText2 = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>&#x20; &#x20;</hello>\"\n        ]\n\ntestChooseElemOrTextIsElem :: Assertion\ntestChooseElemOrTextIsElem = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"success\" $ return \"success\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"success\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestChooseTextOrElemIsText :: Assertion\ntestChooseTextOrElemIsText = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.contentMaybe\n            , P.tagNoAttr \"failure\" $ return \"boom\"\n            ]\n        liftIO $ x @?= Just \" something \"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \" something \"\n        , \"</hello>\"\n        ]\n\ntestChooseTextOrElemIsElem :: Assertion\ntestChooseTextOrElemIsElem = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.contentMaybe\n            , P.tagNoAttr \"success\" $ return \"success\"\n            ]\n        liftIO $ x @?= Just \"success\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestChooseEitherElem :: Assertion\ntestChooseEitherElem = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return 1\n            , P.tagNoAttr \"success\" $ return 2\n            ]\n        liftIO $ x @?= Just (2 :: Int)\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestManyYield :: Assertion\ntestManyYield = do\n    -- Basically the same as testMany, but consume the streamed result\n    result <- runConduitRes $\n        P.parseLBS def input .| helloParser\n        .| CL.consume\n    length result @?= 5\n  where\n    helloParser = void $ P.tagNoAttr \"hello\" $ P.manyYield successParser\n    successParser = P.tagNoAttr \"success\" $ return ()\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestTakeContent :: Assertion\ntestTakeContent = do\n    result <- runConduitRes $ P.parseLBS def input .| rootParser\n    result @?= Just\n      [ EventContent (ContentText \"Hello world !\")\n      ]\n  where\n    rootParser = P.tagNoAttr \"root\" $ void (P.takeContent >> P.takeContent) .| CL.consume\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<root>\"\n        , \"Hello world !\"\n        , \"</root>\"\n        ]\n\ntestTakeTree :: Assertion\ntestTakeTree = do\n    result <- runConduitRes $ P.parseLBS def input .| rootParser\n    result @?=\n      [ EventBeginDocument\n      , EventBeginDoctype \"foo\" Nothing\n      , EventEndDoctype\n      , EventBeginElement \"a\" []\n      , EventBeginElement \"em\" []\n      , EventContent (ContentText \"Hello world !\")\n      , EventEndElement \"em\"\n      , EventEndElement \"a\"\n      ]\n  where\n    rootParser = void (P.takeTree \"a\" P.ignoreAttrs) .| CL.consume\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<a>\"\n        , \"<em>Hello world !</em>\"\n        , \"</a>\"\n        , \"<b>\"\n        , \"</b>\"\n        ]\n\ntestTakeAnyTreeContent :: Assertion\ntestTakeAnyTreeContent = do\n    result <- runConduitRes $ P.parseLBS def input .| rootParser\n    result @?= Just\n      [ EventBeginElement \"b\" []\n      , EventContent (ContentText \"Hello \")\n      , EventBeginElement \"em\" []\n      , EventContent (ContentText \"world\")\n      , EventEndElement \"em\"\n      , EventContent (ContentText \" !\")\n      , EventEndElement \"b\"\n      ]\n  where\n    rootParser = P.tagNoAttr \"root\" $ (P.takeAnyTreeContent >> void P.ignoreAnyTreeContent) .| CL.consume\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<root>\"\n        , \"<b>Hello <em>world</em> !</b> Welcome !\"\n        , \"</root>\"\n        ]\n\n\ntestMany :: Assertion\ntestMany = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.many $ P.tagNoAttr \"success\" $ return ()\n        liftIO $ length x @?= 5\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestMany' :: Assertion\ntestMany' = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.many' $ P.tagNoAttr \"success\" $ return ()\n        liftIO $ length x @?= 5\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<foobar/>\"\n        , \"<success/>\"\n        , \"<foo><bar attr=\\\"1\\\">some content</bar></foo>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestOrE :: IO ()\ntestOrE = runConduitRes $ runConduit $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.tagNoAttr \"failure\" (return 1) `P.orE`\n             P.tagNoAttr \"success\" (return 2)\n        y <- P.tag' \"success\" (P.requireAttr \"failure\") (const $ return 1) `P.orE`\n             P.tag' \"success\" (P.requireAttr \"success\") (const $ return 2)\n        liftIO $ x @?= Just (2 :: Int)\n        liftIO $ y @?= Just (2 :: Int)\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success success=\\\"0\\\"/>\"\n        , \"</hello>\"\n        ]\n\ntestConduitParser :: Assertion\ntestConduitParser = do\n    x <-   runConduitRes\n         $ P.parseLBS def input\n        .| (P.force \"need hello\" $ P.tagNoAttr \"hello\" f)\n        .| CL.consume\n    liftIO $ x @?= [1, 1, 1]\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<item/>\"\n        , \"<item/>\"\n        , \"<item/>\"\n        , \"</hello>\"\n        ]\n    f :: C.MonadThrow m => ConduitT Event Int m ()\n    f = do\n        ma <- P.tagNoAttr \"item\" (return 1)\n        maybe (return ()) (\\a -> C.yield a >> f) ma\n\nomitXMLDeclaration :: Assertion\nomitXMLDeclaration = Res.renderLBS settings input @?= spec\n  where\n    settings = def { Res.rsXMLDeclaration = False }\n    input = Res.Document (Prologue [] Nothing [])\n              (Res.Element \"foo\" Map.empty [Res.NodeContent \"bar\"])\n              []\n    spec = \"<foo>bar</foo>\"\n\nhexEntityParsing :: Spec\nhexEntityParsing = do\n  it \"rejects leading 0x\" $\n    go \"<foo>&#x0xff;</foo>\" @?= Nothing\n  it \"rejects leading 0X\" $\n    go \"<foo>&#x0Xff;</foo>\" @?= Nothing\n  it \"accepts lowercase hex digits\" $\n    go \"<foo>&#xff;</foo>\" @?= Just (spec \"\\xff\")\n  it \"accepts uppercase hex digits\" $\n    go \"<foo>&#xFF;</foo>\" @?= Just (spec \"\\xff\")\n  --Note: this must be rejected, because, according to the XML spec, a\n  --legal EntityRef's entity matches Name, which can't start with a\n  --hash.\n  it \"rejects trailing junk\" $\n    go \"<foo>&#xffhello;</foo>\" @?= Nothing\n  --Some of these next tests are XML 1.0 specific (i.e., they would\n  --differ for XML 1.1), but approximately no-one uses XML 1.1.\n  it \"rejects illegal character #x0\" $\n    go \"<foo>&#x0;</foo>\" @?= Nothing\n  it \"rejects illegal character #xFFFE\" $\n    go \"<foo>&#xFFFE;</foo>\" @?= Nothing\n  it \"rejects illegal character #xFFFF\" $\n    go \"<foo>&#xFFFF;</foo>\" @?= Nothing\n  it \"rejects illegal character #xD900\" $\n    go \"<foo>&#xD900;</foo>\" @?= Nothing\n  it \"rejects illegal character #xC\" $\n    go \"<foo>&#xC;</foo>\" @?= Nothing\n  it \"rejects illegal character #x1F\" $\n    go \"<foo>&#x1F;</foo>\" @?= Nothing\n  it \"accepts astral plane character\" $\n    go \"<foo>&#x1006ff;</foo>\" @?= Just (spec \"\\x1006ff\")\n  it \"accepts custom character references\" $\n    go' customSettings \"<foo>&#xC;</foo>\" @?= Just (spec \"\\xff\")\n  where\n    spec content = Document (Prologue [] Nothing [])\n                    (Element \"foo\" [] [NodeContent (ContentText content)])\n                    []\n\n    go = either (const Nothing) Just . D.parseLBS def\n    go' settings = either (const Nothing) Just . D.parseLBS settings\n    customSettings = def { P.psDecodeIllegalCharacters = customDecoder }\n    customDecoder 12 = Just '\\xff'\n    customDecoder _  = Nothing\n\nname :: [Cu.Cursor] -> [Text]\nname [] = []\nname (c:cs) = ($ name cs) $ case Cu.node c of\n                              Res.NodeElement e -> ((Res.nameLocalName $ Res.elementName e) :)\n                              _ -> id\n\ncursor :: Cu.Cursor\ncursor =\n    Cu.fromDocument $ Res.parseLBS_ def input\n  where\n    input = L.concat\n        [ \"<foo attr=\\\"x\\\">\"\n        ,    \"<bar1/>\"\n        ,    \"<bar2>\"\n        ,       \"<baz1/>\"\n        ,       \"<baz2 attr=\\\"y\\\"/>\"\n        ,       \"<baz3>a</baz3>\"\n        ,    \"</bar2>\"\n        ,    \"<bar3>\"\n        ,       \"<bin1/>\"\n        ,       \"b\"\n        ,       \"<bin2/>\"\n        ,       \"<bin3/>\"\n        ,    \"</bar3>\"\n        ,    \"<Bar1 xmlns=\\\"http://example.com\\\" Attr=\\\"q\\\"/>\"\n        , \"</foo>\"\n        ]\n\nbar2, baz2, bar3, bin2 :: Cu.Cursor\nbar2 = Cu.child cursor !! 1\nbaz2 = Cu.child bar2 !! 1\n\nbar3 = Cu.child cursor !! 2\nbin2 = Cu.child bar3 !! 1\n\ncursorParent, cursorAncestor, cursorOrSelf, cursorPreceding, cursorFollowing,\n    cursorPrecedingSib, cursorFollowingSib, cursorDescendant, cursorCheck,\n    cursorPredicate, cursorCheckNode, cursorCheckElement, cursorCheckName,\n    cursorAnyElement, cursorElement, cursorLaxElement, cursorContent,\n    cursorAttribute, cursorLaxAttribute, cursorHasAttribute,\n    cursorAttributeIs, cursorDeep, cursorForce, cursorForceM,\n    resolvedIdentifies, resolvedAllGood, resolvedMergeContent,\n    testHtmlEntities\n    :: Assertion\ncursorParent = name (Cu.parent bar2) @?= [\"foo\"]\ncursorAncestor = name (Cu.ancestor baz2) @?= [\"bar2\", \"foo\"]\ncursorOrSelf = name (Cu.orSelf Cu.ancestor baz2) @?= [\"baz2\", \"bar2\", \"foo\"]\ncursorPreceding = do\n  name (Cu.preceding baz2) @?= [\"baz1\", \"bar1\"]\n  name (Cu.preceding bin2) @?= [\"bin1\", \"baz3\", \"baz2\", \"baz1\", \"bar2\", \"bar1\"]\ncursorFollowing = do\n  name (Cu.following baz2) @?= [\"baz3\", \"bar3\", \"bin1\", \"bin2\", \"bin3\", \"Bar1\"]\n  name (Cu.following bar2) @?= [\"bar3\", \"bin1\", \"bin2\", \"bin3\", \"Bar1\"]\ncursorPrecedingSib = name (Cu.precedingSibling baz2) @?= [\"baz1\"]\ncursorFollowingSib = name (Cu.followingSibling baz2) @?= [\"baz3\"]\ncursorDescendant = (name $ Cu.descendant cursor) @?= T.words \"bar1 bar2 baz1 baz2 baz3 bar3 bin1 bin2 bin3 Bar1\"\ncursorCheck = null (cursor $.// Cu.check (const False)) @?= True\ncursorPredicate = (name $ cursor $.// Cu.check Cu.descendant) @?= T.words \"foo bar2 baz3 bar3\"\ncursorCheckNode = (name $ cursor $// Cu.checkNode f) @?= T.words \"bar1 bar2 bar3\"\n    where f (Res.NodeElement e) = \"bar\" `T.isPrefixOf` Res.nameLocalName (Res.elementName e)\n          f _               = False\ncursorCheckElement = (name $ cursor $// Cu.checkElement f) @?= T.words \"bar1 bar2 bar3\"\n    where f e = \"bar\" `T.isPrefixOf` Res.nameLocalName (Res.elementName e)\ncursorCheckName = (name $ cursor $// Cu.checkName f) @?= T.words \"bar1 bar2 bar3\"\n    where f n = \"bar\" `T.isPrefixOf` nameLocalName n\ncursorAnyElement = (name $ cursor $// Cu.anyElement) @?= T.words \"bar1 bar2 baz1 baz2 baz3 bar3 bin1 bin2 bin3 Bar1\"\ncursorElement = (name $ cursor $// Cu.element \"bar1\") @?= [\"bar1\"]\ncursorLaxElement = (name $ cursor $// Cu.laxElement \"bar1\") @?= [\"bar1\", \"Bar1\"]\ncursorContent = do\n  Cu.content cursor @?= []\n  (cursor $.// Cu.content) @?= [\"a\", \"b\"]\ncursorAttribute = Cu.attribute \"attr\" cursor @?= [\"x\"]\ncursorLaxAttribute = (cursor $.// Cu.laxAttribute \"Attr\") @?= [\"x\", \"y\", \"q\"]\n\ncursorHasAttribute = (length $ cursor $.// Cu.hasAttribute \"attr\") @?= 2\ncursorAttributeIs = (length $ cursor $.// Cu.attributeIs \"attr\" \"y\") @?= 1\n\ncursorDeep = do\n  (Cu.element \"foo\" &/ Cu.element \"bar2\" &// Cu.attribute \"attr\") cursor @?= [\"y\"]\n  (return &.// Cu.attribute \"attr\") cursor @?= [\"x\", \"y\"]\n  (cursor $.// Cu.attribute \"attr\") @?= [\"x\", \"y\"]\n  (cursor $/ Cu.element \"bar2\" &// Cu.attribute \"attr\") @?= [\"y\"]\n  (cursor $/ Cu.element \"bar2\" &/ Cu.element \"baz2\" >=> Cu.attribute \"attr\") @?= [\"y\"]\n  null (cursor $| Cu.element \"foo\") @?= False\ncursorForce = do\n  Cu.force DummyEx [] @?= (Nothing :: Maybe Integer)\n  Cu.force DummyEx [1] @?= Just (1 :: Int)\n  Cu.force DummyEx [1,2] @?= Just (1 :: Int)\ncursorForceM = do\n  Cu.forceM DummyEx [] @?= (Nothing :: Maybe Integer)\n  Cu.forceM DummyEx [Just 1, Nothing] @?= Just (1 :: Int)\n  Cu.forceM DummyEx [Nothing, Just (1 :: Int)] @?= Nothing\n\ndata DummyEx = DummyEx\n    deriving (Show, Typeable)\ninstance Exception DummyEx\n\nshowEq :: (Show a, Show b) => Either a b -> Either a b -> Assertion\nshowEq x y = show x @=? show y\n\nresolvedIdentifies =\n    Left (toException $ Res.UnresolvedEntityException $ Set.fromList [\"foo\", \"bar\", \"baz\"]) `showEq`\n    Res.parseLBS def\n    \"<root attr='&bar;'>&foo; --- &baz; &foo;</root>\"\n\ntestHtmlEntities =\n    Res.parseLBS_ def\n        { P.psDecodeEntities = P.decodeHtmlEntities\n        } xml1 @=? Res.parseLBS_ def xml2\n  where\n    xml1 = \"<root>&nbsp;</root>\"\n    xml2 = \"<root>&#160;</root>\"\n\nresolvedAllGood =\n    D.parseLBS_ def xml @=?\n    Res.toXMLDocument (Res.parseLBS_ def xml)\n  where\n    xml = \"<foo><bar/><baz/></foo>\"\n\nresolvedMergeContent =\n    Res.documentRoot (Res.parseLBS_ def xml) @=?\n    Res.Element \"foo\" Map.empty [Res.NodeContent \"bar&baz\"]\n  where\n    xml = \"<foo>bar&amp;baz</foo>\"\n\nparseIgnoreBOM :: Assertion\nparseIgnoreBOM = do\n    either (const $ Left (1 :: Int)) Right (Res.parseText Res.def \"\\xfeef<foo/>\") @?=\n        either (const $ Left (2 :: Int)) Right (Res.parseText Res.def \"<foo/>\")\n\nstripDuplicateAttributes :: Assertion\nstripDuplicateAttributes = do\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><foo bar=\\\"baz\\\"/>\" @=?\n        D.renderLBS def (Document (Prologue [] Nothing []) (Element \"foo\" [(\"bar\", [ContentText \"baz\"]), (\"bar\", [ContentText \"bin\"])] []) [])\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><foo x:bar=\\\"baz\\\" xmlns:x=\\\"namespace\\\"/>\" @=?\n        D.renderLBS def (Document (Prologue [] Nothing []) (Element \"foo\"\n            [ (\"x:bar\", [ContentText \"baz\"])\n            , (Name \"bar\" (Just \"namespace\") (Just \"x\"), [ContentText \"bin\"])\n            ] []) [])\n\ntestRenderComments :: Assertion\ntestRenderComments =do\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><foo><!--comment--></foo>\"\n        @=? D.renderLBS def (Document (Prologue [] Nothing [])\n            (Element \"foo\" [] [NodeComment \"comment\"]) [])\n\nresolvedInline :: Assertion\nresolvedInline = do\n    Res.Document _ root _ <- return $ Res.parseLBS_ Res.def \"<!DOCTYPE foo [<!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n    Res.Document _ root2 _ <- return $ Res.parseLBS_ Res.def \"<!DOCTYPE foo [<!ENTITY bar \\\"baz\\\">]><foo bar='&bar;'/>\"\n    root2 @?= Res.Element \"foo\" (Map.singleton \"bar\" \"baz\") []\n\ndoctypeComment :: Assertion\ndoctypeComment = do\n    Res.Document _ root _ <- return $ Res.parseLBS_\n       Res.def \"<!DOCTYPE foo [<!-- [comment] --> <!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n\ndoctypeElements :: Assertion\ndoctypeElements = do\n    Res.Document _ root _ <- return $ Res.parseLBS_\n       Res.def \"<!DOCTYPE foo [<!ELEMENT assessment (#PCDATA)>\\n<!ELEMENT textbooks(author,title)>\\n<!ATTLIST assessment assessment_type (exam | assignment) #IMPLIED>\\n<!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n\ndoctypePI :: Assertion\ndoctypePI = do\n    Res.Document _ root _ <- return $ Res.parseLBS_\n       Res.def \"<!DOCTYPE foo [<?foobar \\\"[baz]\\\"?><!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n\ncasePretty :: Assertion\ncasePretty = do\n    let pretty = S.unlines\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<!DOCTYPE foo>\"\n            , \"<foo bar=\\\"bar\\\" baz=\\\"baz\\\">\"\n            , \"    <foo\"\n            , \"      bar=\\\"bar\\\"\"\n            , \"      baz=\\\"baz\\\"\"\n            , \"      bin=\\\"bin\\\">\"\n            , \"        Hello World\"\n            , \"    </foo>\"\n            , \"    <foo/>\"\n            , \"    <?foo bar?>\"\n            , \"    <!-- foo bar baz bin -->\"\n            , \"    <bar>\"\n            , \"        bar content\"\n            , \"    </bar>\"\n            , \"</foo>\"\n            ]\n        doctype = Res.Doctype \"foo\" Nothing\n        doc = Res.Document (Res.Prologue [] (Just doctype) []) root []\n        root = Res.Element \"foo\" (Map.fromList [(\"bar\", \"bar\"), (\"baz\", \"baz\")])\n                [ Res.NodeElement $ Res.Element \"foo\" (Map.fromList [(\"bar\", \"bar\"), (\"baz\", \"baz\"), (\"bin\", \"bin\")])\n                    [ Res.NodeContent \"  Hello World\\n\\n\"\n                    , Res.NodeContent \"  \"\n                    ]\n                , Res.NodeElement $ Res.Element \"foo\" Map.empty []\n                , Res.NodeInstruction $ Res.Instruction \"foo\" \"bar\"\n                , Res.NodeComment \"foo bar\\n\\r\\nbaz    \\tbin \"\n                , Res.NodeElement $ Res.Element \"bar\" Map.empty [Res.NodeContent \"bar content\"]\n                ]\n    pretty @=? S.concat (L.toChunks $ Res.renderLBS def { D.rsPretty = True } doc)\n\ncaseTopLevelNamespace :: Assertion\ncaseTopLevelNamespace = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo xmlns:bar=\\\"baz\\\">\"\n            , \"<subfoo bar:bin=\\\"\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { D.rsNamespaces = [(\"bar\", \"baz\")] }\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" Map.empty\n                    [ Res.NodeElement\n                        $ Res.Element \"subfoo\" (Map.singleton \"{baz}bin\" \"\") []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseTopLevelNamespacePrefix :: Assertion\ncaseTopLevelNamespacePrefix = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo xmlns:bar=\\\"baz\\\">\"\n            , \"<subfoo bar:bin=\\\"\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { D.rsNamespaces = [(\"bar\", \"baz\")] }\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" Map.empty\n                    [ Res.NodeElement\n                        $ Res.Element \"subfoo\" (Map.fromList [(Name \"bin\" (Just \"baz\") (Just \"bar\"), \"\")]) []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseTLNConflict :: Assertion\ncaseTLNConflict = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo xmlns:bar=\\\"something\\\" bar:x=\\\"y\\\">\"\n            , \"<subfoo xmlns:bar_=\\\"baz\\\" bar_:bin=\\\"\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { D.rsNamespaces = [(\"bar\", \"baz\")] }\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" (Map.fromList [(Name \"x\" (Just \"something\") (Just \"bar\"), \"y\")])\n                    [ Res.NodeElement\n                        $ Res.Element \"subfoo\" (Map.fromList [(Name \"bin\" (Just \"baz\") (Just \"bar\"), \"\")]) []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseBlazeHtml :: Assertion\ncaseBlazeHtml =\n    expected @=? str\n  where\n    str = renderMarkup $ toMarkup $ Res.Document (Res.Prologue [] Nothing []) root []\n    root :: Res.Element\n    root = Res.Element \"html\" Map.empty\n        [ Res.NodeElement $ Res.Element \"head\" Map.empty\n            [ Res.NodeElement $ Res.Element \"title\" Map.empty [Res.NodeContent \"Test\"]\n            , Res.NodeElement $ Res.Element \"script\" Map.empty\n                [Res.NodeContent \"if (5 < 6 || 8 > 9) alert('Hello World!');\"]\n            , Res.NodeElement $ Res.Element \"{http://www.snoyman.com/xml2html}ie-cond\" (Map.singleton \"cond\" \"lt IE 7\")\n                [Res.NodeElement $ Res.Element \"link\" (Map.singleton \"href\" \"ie6.css\") []]\n            , Res.NodeElement $ Res.Element \"style\" Map.empty\n                [Res.NodeContent \"body > h1 { color: red }\"]\n            ]\n        , Res.NodeElement $ Res.Element \"body\" Map.empty\n            [ Res.NodeElement $ Res.Element \"h1\" Map.empty [Res.NodeContent \"Hello World!\"]\n            ]\n        ]\n    expected :: String\n    expected = concat\n        [ \"<!DOCTYPE HTML>\\n\"\n        , \"<html><head><title>Test</title><script>if (5 < 6 || 8 > 9) alert('Hello World!');</script>\"\n        , \"<!--[if lt IE 7]><link href=\\\"ie6.css\\\" /><![endif]-->\"\n        , \"<style>body > h1 { color: red }</style>\"\n        , \"</head>\"\n        , \"<body><h1>Hello World!</h1></body></html>\"\n        ]\n\ncaseAttrReorder :: Assertion\ncaseAttrReorder = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo c=\\\"c\\\" b=\\\"b\\\" a=\\\"a\\\">\"\n            , \"<bar a=\\\"a\\\" b=\\\"b\\\" c=\\\"c\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { Res.rsAttrOrder = \\name' m ->\n                        case name' of\n                            \"foo\" -> reverse $ Map.toAscList m\n                            _     -> Map.toAscList m\n                 }\n        attrs = Map.fromList [(\"a\", \"a\"), (\"b\", \"b\"), (\"c\", \"c\")]\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" attrs\n                    [ Res.NodeElement\n                        $ Res.Element \"bar\" attrs []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseOrderAttrs :: Assertion\ncaseOrderAttrs = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo c=\\\"c\\\" b=\\\"b\\\" a=\\\"a\\\">\"\n            , \"<bar a=\\\"a\\\" b=\\\"b\\\" c=\\\"c\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { Res.rsAttrOrder = Res.orderAttrs\n                     [(\"foo\", [\"c\", \"b\"])]\n                 }\n        attrs = Map.fromList [(\"a\", \"a\"), (\"b\", \"b\"), (\"c\", \"c\")]\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" attrs\n                    [ Res.NodeElement\n                        $ Res.Element \"bar\" attrs []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseParseCdata :: Assertion\ncaseParseCdata = do\n    let lbs = \"<a><![CDATA[www.google.com]]></a>\"\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"a\" Map.empty\n                    [ Res.NodeContent \"www.google.com\"\n                    ])\n                []\n    Res.parseLBS_ def lbs @?= doc\n\ncaseRetainNamespaces :: Assertion\ncaseRetainNamespaces = do\n    let lbs = \"<foo xmlns:bar='baz'><bar:bin/><bin3 xmlns='bin4'></bin3></foo>\"\n        doc = Res.parseLBS_ def { Res.psRetainNamespaces = True } lbs\n    doc `shouldBe` Res.Document\n        (Res.Prologue [] Nothing [])\n        (Res.Element\n            \"foo\"\n            (Map.singleton \"xmlns:bar\" \"baz\")\n            [ Res.NodeElement $ Res.Element\n                \"{baz}bin\"\n                Map.empty\n                []\n            , Res.NodeElement $ Res.Element\n                \"{bin4}bin3\"\n                (Map.singleton \"xmlns\" \"bin4\")\n                []\n            ])\n        []\n\ncaseIso8859_1 :: Assertion\ncaseIso8859_1 = do\n    let lbs = \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?><foo>\\232</foo>\"\n        doc = Res.parseLBS_ def lbs\n    doc `shouldBe` Res.Document\n        (Res.Prologue [] Nothing [])\n        (Res.Element\n            \"foo\"\n            Map.empty\n            [Res.NodeContent \"\\232\"])\n        []\n\ncaseRenderCDATA :: Assertion\ncaseRenderCDATA = do\n    let doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"a\" Map.empty\n                    [ Res.NodeContent \"www.google.com\"\n                    ])\n                []\n        withoutCDATA = Res.renderLBS def doc\n        withCDATA = Res.renderLBS (def { Res.rsUseCDATA = const True }) doc\n    withCDATA `shouldBe` \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><a><![CDATA[www.google.com]]></a>\"\n    withoutCDATA `shouldBe` \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><a>www.google.com</a>\"\n\ncaseEscapesCDATA :: Assertion\ncaseEscapesCDATA = do\n    let doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"a\" Map.empty\n                    [ Res.NodeContent \"]]>\"\n                    ])\n                []\n        result = Res.renderLBS (def { Res.rsUseCDATA = const True }) doc\n    result `shouldBe` \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><a><![CDATA[]]]]><![CDATA[>]]></a>\"\n"], "fixing_code": ["{-# LANGUAGE BangPatterns               #-}\n{-# LANGUAGE CPP                        #-}\n{-# LANGUAGE DeriveDataTypeable         #-}\n{-# LANGUAGE DeriveFunctor              #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE FlexibleInstances          #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE PatternGuards              #-}\n{-# LANGUAGE RankNTypes                 #-}\n{-# LANGUAGE StandaloneDeriving         #-}\n{-# LANGUAGE TypeFamilies               #-}\n-- | This module provides both a native Haskell solution for parsing XML\n-- documents into a stream of events, and a set of parser combinators for\n-- dealing with a stream of events.\n--\n-- As a simple example:\n--\n-- >>> :set -XOverloadedStrings\n-- >>> import Conduit (runConduit, (.|))\n-- >>> import Data.Text (Text, unpack)\n-- >>> import Data.XML.Types (Event)\n-- >>> data Person = Person Int Text Text deriving Show\n-- >>> :{\n-- let parsePerson :: MonadThrow m => ConduitT Event o m (Maybe Person)\n--     parsePerson = tag' \"person\" parseAttributes $ \\(age, goodAtHaskell) -> do\n--       name <- content\n--       return $ Person (read $ unpack age) name goodAtHaskell\n--       where parseAttributes = (,) <$> requireAttr \"age\" <*> requireAttr \"goodAtHaskell\" <* ignoreAttrs\n--     parsePeople :: MonadThrow m => ConduitT Event o m (Maybe [Person])\n--     parsePeople = tagNoAttr \"people\" $ many parsePerson\n--     inputXml = mconcat\n--       [ \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n--       , \"<people>\"\n--       , \"  <person age=\\\"25\\\" goodAtHaskell=\\\"yes\\\">Michael</person>\"\n--       , \"  <person age=\\\"2\\\" goodAtHaskell=\\\"might become\\\">Eliezer</person>\"\n--       , \"</people>\"\n--       ]\n-- :}\n--\n-- >>> runConduit $ parseLBS def inputXml .| force \"people required\" parsePeople\n-- [Person 25 \"Michael\" \"yes\",Person 2 \"Eliezer\" \"might become\"]\n--\n--\n-- This module also supports streaming results using 'yield'.\n-- This allows parser results to be processed using conduits\n-- while a particular parser (e.g. 'many') is still running.\n-- Without using streaming results, you have to wait until the parser finished\n-- before you can process the result list. Large XML files might be easier\n-- to process by using streaming results.\n-- See http://stackoverflow.com/q/21367423/2597135 for a related discussion.\n--\n-- >>> import Data.Conduit.List as CL\n-- >>> :{\n-- let parsePeople' :: MonadThrow m => ConduitT Event Person m (Maybe ())\n--     parsePeople' = tagNoAttr \"people\" $ manyYield parsePerson\n-- :}\n--\n-- >>> runConduit $ parseLBS def inputXml .| force \"people required\" parsePeople' .| CL.mapM_ print\n-- Person 25 \"Michael\" \"yes\"\n-- Person 2 \"Eliezer\" \"might become\"\n--\n-- Previous versions of this module contained a number of more sophisticated\n-- functions written by Aristid Breitkreuz and Dmitry Olshansky. To keep this\n-- package simpler, those functions are being moved to a separate package. This\n-- note will be updated with the name of the package(s) when available.\nmodule Text.XML.Stream.Parse\n    ( -- * Parsing XML files\n      parseBytes\n    , parseBytesPos\n    , parseText\n    , parseTextPos\n    , detectUtf\n    , parseFile\n    , parseLBS\n      -- ** Parser settings\n    , ParseSettings\n    , def\n    , DecodeEntities\n    , DecodeIllegalCharacters\n    , psDecodeEntities\n    , psDecodeIllegalCharacters\n    , psRetainNamespaces\n    , psEntityExpansionSizeLimit\n      -- *** Entity decoding\n    , decodeXmlEntities\n    , decodeHtmlEntities\n      -- * Event parsing\n    , tag\n    , tag'\n    , tagNoAttr\n    , tagIgnoreAttrs\n    , content\n    , contentMaybe\n      -- * Ignoring tags/trees\n    , ignoreEmptyTag\n    , ignoreTree\n    , ignoreContent\n    , ignoreTreeContent\n    , ignoreAnyTreeContent\n      -- * Streaming events\n    , takeContent\n    , takeTree\n    , takeTreeContent\n    , takeAnyTreeContent\n      -- * Tag name matching\n    , NameMatcher(..)\n    , matching\n    , anyOf\n    , anyName\n      -- * Attribute parsing\n    , AttrParser\n    , attr\n    , requireAttr\n    , optionalAttr\n    , requireAttrRaw\n    , optionalAttrRaw\n    , ignoreAttrs\n      -- * Combinators\n    , orE\n    , choose\n    , many\n    , many_\n    , manyIgnore\n    , many'\n    , force\n      -- * Streaming combinators\n    , manyYield\n    , manyYield'\n    , manyIgnoreYield\n      -- * Exceptions\n    , XmlException (..)\n      -- * Other types\n    , PositionRange\n    , EventPos\n    ) where\nimport           Conduit\nimport           Control.Applicative          (Alternative (empty, (<|>)),\n                                               Applicative (..), (<$>))\nimport qualified Control.Applicative          as A\nimport           Control.Arrow                ((***))\nimport           Control.Exception            (Exception (..), SomeException)\nimport           Control.Monad                (ap, liftM, void)\nimport           Control.Monad.Fix            (fix)\nimport           Control.Monad.IO.Class       (liftIO)\nimport           Control.Monad.Trans.Class    (lift)\nimport           Control.Monad.Trans.Maybe    (MaybeT (..))\nimport           Control.Monad.Trans.Resource (MonadResource, MonadThrow (..),\n                                               throwM)\nimport           Data.Attoparsec.Text         (Parser, anyChar, char, manyTill,\n                                               skipWhile, string, takeWhile,\n                                               takeWhile1, try)\nimport qualified Data.Attoparsec.Text         as AT\nimport qualified Data.ByteString              as S\nimport qualified Data.ByteString.Lazy         as L\nimport           Data.Char                    (isSpace)\nimport           Data.Conduit.Attoparsec      (PositionRange, conduitParser)\nimport qualified Data.Conduit.Text            as CT\nimport           Data.Default.Class           (Default (..))\nimport           Data.List                    (foldl', intercalate)\nimport qualified Data.Map                     as Map\nimport           Data.Maybe                   (fromMaybe, isNothing)\nimport           Data.String                  (IsString (..))\nimport           Data.Text                    (Text, pack)\nimport qualified Data.Text                    as T\nimport           Data.Text.Encoding           (decodeUtf8With)\nimport           Data.Text.Encoding.Error     (lenientDecode)\nimport           Data.Typeable                (Typeable)\nimport           Data.XML.Types               (Content (..), Event (..),\n                                               ExternalID (..),\n                                               Instruction (..), Name (..))\nimport           Prelude                      hiding (takeWhile)\nimport           Text.XML.Stream.Token\n\n-- $setup\n-- >>> :set -XOverloadedStrings\n-- >>> import Conduit\n-- >>> import Control.Monad (void, join)\n\ntype Ents = [(Text, Text)]\n\ntokenToEvent :: ParseSettings -> Ents -> [NSLevel] -> Token -> (Ents, [NSLevel], [Event])\ntokenToEvent _ es n (TokenXMLDeclaration _) = (es, n, [])\ntokenToEvent _ es n (TokenInstruction i) = (es, n, [EventInstruction i])\ntokenToEvent ps es n (TokenBeginElement name as isClosed _) =\n    (es, n', if isClosed then [begin, end] else [begin])\n  where\n    l0 = case n of\n            []  -> NSLevel Nothing Map.empty\n            x:_ -> x\n    (as', l') = foldl' go (id, l0) as\n    go (front, l) (TName kpref kname, val) =\n        (addNS front, l'')\n      where\n        isPrefixed = kpref == Just \"xmlns\"\n        isUnprefixed = isNothing kpref && kname == \"xmlns\"\n\n        addNS\n            | not (psRetainNamespaces ps) && (isPrefixed || isUnprefixed) = id\n            | otherwise = (((tname, resolveEntities ps es val):) .)\n          where\n            tname\n                | isPrefixed = TName Nothing (\"xmlns:\" `T.append` kname)\n                | otherwise = TName kpref kname\n\n        l''\n            | isPrefixed =\n                l { prefixes = Map.insert kname (contentsToText val)\n                                     $ prefixes l }\n            | isUnprefixed =\n                l { defaultNS = if T.null $ contentsToText val\n                                            then Nothing\n                                            else Just $ contentsToText val }\n            | otherwise = l\n\n    n' = if isClosed then n else l' : n\n    fixAttName (name', val) = (tnameToName True l' name', val)\n    elementName = tnameToName False l' name\n    begin = EventBeginElement elementName $ map fixAttName $ as' []\n    end = EventEndElement elementName\ntokenToEvent _ es n (TokenEndElement name) =\n    (es, n', [EventEndElement $ tnameToName False l name])\n  where\n    (l, n') =\n        case n of\n            []   -> (NSLevel Nothing Map.empty, [])\n            x:xs -> (x, xs)\ntokenToEvent ps es n (TokenContent (ContentEntity e))\n    = (es, n, map EventContent (resolveEntities ps es [ContentEntity e]))\ntokenToEvent _ es n (TokenContent c) = (es, n, [EventContent c])\ntokenToEvent _ es n (TokenComment c) = (es, n, [EventComment c])\ntokenToEvent _ es n (TokenDoctype t eid es') = (es ++ es', n, [EventBeginDoctype t eid, EventEndDoctype])\ntokenToEvent _ es n (TokenCDATA t) = (es, n, [EventCDATA t])\n\nresolveEntities :: ParseSettings\n                -> [(Text, Text)]  -- entity table\n                -> [Content]\n                -> [Content]\nresolveEntities ps entities = foldr go []\n where\n  go c@(ContentEntity e) cs\n    = case expandEntity entities e of\n        Just xs -> foldr go cs xs\n        Nothing ->  c : cs\n  go c cs = c:cs\n  expandEntity es e\n    | Just t <- lookup e es =\n      case AT.parseOnly (manyTill\n                          (parseContent ps False False :: Parser Content)\n                          AT.endOfInput) t of\n        Left _      -> Nothing\n        Right xs    -> let es' = filter (\\(x,_) -> x /= e) es\n                        in fst <$> foldr (goent es') (Just ([], 0)) xs\n          -- we delete e from the entity map in resolving its contents,\n          -- to avoid infinite loops in recursive expansion.\n    | otherwise     = Nothing\n  goent _ _ Nothing = Nothing\n  goent es (ContentEntity e) (Just (cs, size))\n    = expandEntity es e >>= foldr (goent es) (Just (cs, size))\n  goent _ c@(ContentText t) (Just (cs, size)) =\n    case size + T.length t of\n      n | n > psEntityExpansionSizeLimit ps -> Nothing\n        | otherwise -> Just (c:cs, size + T.length t)\n\n\ntnameToName :: Bool -> NSLevel -> TName -> Name\ntnameToName _ _ (TName (Just \"xml\") name) =\n    Name name (Just \"http://www.w3.org/XML/1998/namespace\") (Just \"xml\")\ntnameToName isAttr (NSLevel def' _) (TName Nothing name) =\n    Name name (if isAttr then Nothing else def') Nothing\ntnameToName _ (NSLevel _ m) (TName (Just pref) name) =\n    case Map.lookup pref m of\n        Just ns -> Name name (Just ns) (Just pref)\n        Nothing -> Name name Nothing (Just pref) -- FIXME is this correct?\n\n-- | Automatically determine which UTF variant is being used. This function\n-- first checks for BOMs, removing them as necessary, and then check for the\n-- equivalent of <?xml for each of UTF-8, UTF-16LE/BE, and UTF-32LE/BE. It\n-- defaults to assuming UTF-8.\ndetectUtf :: MonadThrow m => ConduitT S.ByteString T.Text m ()\ndetectUtf =\n    conduit id\n  where\n    conduit front = await >>= maybe (return ()) (push front)\n\n    push front bss =\n        either conduit\n               (uncurry checkXMLDecl)\n               (getEncoding front bss)\n\n    getEncoding front bs'\n        | S.length bs < 4 =\n            Left (bs `S.append`)\n        | otherwise =\n            Right (bsOut, mcodec)\n      where\n        bs = front bs'\n        bsOut = S.append (S.drop toDrop x) y\n        (x, y) = S.splitAt 4 bs\n        (toDrop, mcodec) =\n            case S.unpack x of\n                [0x00, 0x00, 0xFE, 0xFF] -> (4, Just CT.utf32_be)\n                [0xFF, 0xFE, 0x00, 0x00] -> (4, Just CT.utf32_le)\n                0xFE : 0xFF: _           -> (2, Just CT.utf16_be)\n                0xFF : 0xFE: _           -> (2, Just CT.utf16_le)\n                0xEF : 0xBB: 0xBF : _    -> (3, Just CT.utf8)\n                [0x00, 0x00, 0x00, 0x3C] -> (0, Just CT.utf32_be)\n                [0x3C, 0x00, 0x00, 0x00] -> (0, Just CT.utf32_le)\n                [0x00, 0x3C, 0x00, 0x3F] -> (0, Just CT.utf16_be)\n                [0x3C, 0x00, 0x3F, 0x00] -> (0, Just CT.utf16_le)\n                _                        -> (0, Nothing) -- Assuming UTF-8\n\ncheckXMLDecl :: MonadThrow m\n             => S.ByteString\n             -> Maybe CT.Codec\n             -> ConduitT S.ByteString T.Text m ()\ncheckXMLDecl bs (Just codec) = leftover bs >> CT.decode codec\ncheckXMLDecl bs0 Nothing =\n    loop [] (AT.parse (parseToken def)) bs0\n  where\n    loop chunks0 parser nextChunk =\n        case parser $ decodeUtf8With lenientDecode nextChunk of\n            AT.Fail{} -> fallback\n            AT.Partial f -> await >>= maybe fallback (loop chunks f)\n            AT.Done _ (TokenXMLDeclaration attrs) -> findEncoding attrs\n            AT.Done{} -> fallback\n      where\n        chunks = nextChunk : chunks0\n        fallback = complete CT.utf8\n        complete codec = mapM_ leftover chunks >> CT.decode codec\n\n        findEncoding [] = fallback\n        findEncoding ((TName _ \"encoding\", [ContentText enc]):_) =\n            case T.toLower enc of\n                \"iso-8859-1\" -> complete CT.iso8859_1\n                \"utf-8\"      -> complete CT.utf8\n                _            -> complete CT.utf8\n        findEncoding (_:xs) = findEncoding xs\n\ntype EventPos = (Maybe PositionRange, Event)\n\n-- | Parses a byte stream into 'Event's. This function is implemented fully in\n-- Haskell using attoparsec-text for parsing. The produced error messages do\n-- not give line/column information, so you may prefer to stick with the parser\n-- provided by libxml-enumerator. However, this has the advantage of not\n-- relying on any C libraries.\n--\n-- This relies on 'detectUtf' to determine character encoding, and 'parseText'\n-- to do the actual parsing.\nparseBytes :: MonadThrow m\n           => ParseSettings\n           -> ConduitT S.ByteString Event m ()\nparseBytes = mapOutput snd . parseBytesPos\n\nparseBytesPos :: MonadThrow m\n              => ParseSettings\n              -> ConduitT S.ByteString EventPos m ()\nparseBytesPos ps = detectUtf .| parseTextPos ps\n\ndropBOM :: Monad m => ConduitT T.Text T.Text m ()\ndropBOM =\n    await >>= maybe (return ()) push\n  where\n    push t =\n        case T.uncons t of\n            Nothing -> dropBOM\n            Just (c, cs) ->\n                let output\n                        | c == '\\xfeef' = cs\n                        | otherwise = t\n                 in yield output >> idConduit\n    idConduit = await >>= maybe (return ()) (\\x -> yield x >> idConduit)\n\n-- | Parses a character stream into 'Event's. This function is implemented\n-- fully in Haskell using attoparsec-text for parsing. The produced error\n-- messages do not give line/column information, so you may prefer to stick\n-- with the parser provided by libxml-enumerator. However, this has the\n-- advantage of not relying on any C libraries.\n--\n-- Since 1.2.4\nparseText :: MonadThrow m => ParseSettings -> ConduitT T.Text Event m ()\nparseText = mapOutput snd . parseTextPos\n\n\n-- | Same as 'parseText', but includes the position of each event.\n--\n-- Since 1.2.4\nparseTextPos :: MonadThrow m\n          => ParseSettings\n          -> ConduitT T.Text EventPos m ()\nparseTextPos de =\n    dropBOM\n        .| tokenize\n        .| toEventC de\n        .| addBeginEnd\n  where\n    tokenize = conduitToken de\n    addBeginEnd = yield (Nothing, EventBeginDocument) >> addEnd\n    addEnd = await >>= maybe\n        (yield (Nothing, EventEndDocument))\n        (\\e -> yield e >> addEnd)\n\ntoEventC :: Monad m => ParseSettings -> ConduitT (PositionRange, Token) EventPos m ()\ntoEventC ps =\n    go [] []\n  where\n    go !es !levels =\n        await >>= maybe (return ()) push\n      where\n        push (position, token) =\n            mapM_ (yield . (,) (Just position)) events >> go es' levels'\n          where\n            (es', levels', events) = tokenToEvent ps es levels token\n\n\ntype DecodeEntities = Text -> Content\ntype DecodeIllegalCharacters = Int -> Maybe Char\n\ndata ParseSettings = ParseSettings\n    { psDecodeEntities          :: DecodeEntities\n    , psRetainNamespaces        :: Bool\n    -- ^ Whether the original xmlns attributes should be retained in the parsed\n    -- values. For more information on motivation, see:\n    --\n    -- <https://github.com/snoyberg/xml/issues/38>\n    --\n    -- Default: False\n    --\n    -- Since 1.2.1\n    , psDecodeIllegalCharacters :: DecodeIllegalCharacters\n    -- ^ How to decode illegal character references (@&#[0-9]+;@ or @&#x[0-9a-fA-F]+;@).\n    --\n    -- Character references within the legal ranges defined by <https://www.w3.org/TR/REC-xml/#NT-Char the standard> are automatically parsed.\n    -- Others are passed to this function.\n    --\n    -- Default: @const Nothing@\n    --\n    -- Since 1.7.1\n    , psEntityExpansionSizeLimit :: Int\n    -- ^ Maximum number of characters allowed in expanding an\n    -- internal entity.  This is intended to protect against the\n    -- billion laughs attack.\n    --\n    -- Default: @8192@\n    --\n    -- Since 1.9.1\n    }\n\ninstance Default ParseSettings where\n    def = ParseSettings\n        { psDecodeEntities = decodeXmlEntities\n        , psRetainNamespaces = False\n        , psDecodeIllegalCharacters = const Nothing\n        , psEntityExpansionSizeLimit = 8192\n        }\n\nconduitToken :: MonadThrow m => ParseSettings -> ConduitT T.Text (PositionRange, Token) m ()\nconduitToken = conduitParser . parseToken\n\nparseToken :: ParseSettings -> Parser Token\nparseToken settings = (char '<' >> parseLt) <|> TokenContent <$> parseContent settings False False\n  where\n    parseLt =\n        (char '?' >> parseInstr) <|>\n        (char '!' >> (parseComment <|> parseCdata <|> parseDoctype)) <|>\n        parseBegin <|>\n        (char '/' >> parseEnd)\n    parseInstr = do\n        name <- parseIdent\n        if name == \"xml\"\n            then do\n                as <- A.many $ parseAttribute settings\n                skipSpace\n                char' '?'\n                char' '>'\n                newline <|> return ()\n                return $ TokenXMLDeclaration as\n            else do\n                skipSpace\n                x <- T.pack <$> manyTill anyChar (try $ string \"?>\")\n                return $ TokenInstruction $ Instruction name x\n    parseComment = do\n        char' '-'\n        char' '-'\n        c <- T.pack <$> manyTill anyChar (string \"-->\") -- FIXME use takeWhile instead\n        return $ TokenComment c\n    parseCdata = do\n        _ <- string \"[CDATA[\"\n        t <- T.pack <$> manyTill anyChar (string \"]]>\") -- FIXME use takeWhile instead\n        return $ TokenCDATA t\n    parseDoctype = do\n        _ <- string \"DOCTYPE\"\n        skipSpace\n        name <- parseName\n        let i =\n                case name of\n                    TName Nothing x  -> x\n                    TName (Just x) y -> T.concat [x, \":\", y]\n        skipSpace\n        eid <- fmap Just parsePublicID <|>\n               fmap Just parseSystemID <|>\n               return Nothing\n        skipSpace\n        ents <- (do\n            char' '['\n            ents <- parseEntities id\n            skipSpace\n            return ents) <|> return []\n        char' '>'\n        newline <|> return ()\n        return $ TokenDoctype i eid ents\n    parseEntities front =\n        (char ']' >> return (front [])) <|>\n        (parseEntity >>= \\e -> parseEntities (front . (e:))) <|>\n        (string \"<!--\" >> manyTill anyChar (string \"-->\") >>\n           parseEntities front) <|>\n         -- this clause handles directives like <!ELEMENT\n         -- and processing instructions:\n        (char '<' >> AT.skipWhile (/= '>') >> char '>'\n                  >> parseEntities front) <|>\n        (skipWhile (\\t -> t /= ']' && t /= '<') >> parseEntities front)\n    parseEntity = try $ do\n        _ <- string \"<!ENTITY\"\n        skipSpace\n        i <- parseIdent\n        t <- quotedText\n        skipSpace\n        char' '>'\n        return (i, t)\n    parsePublicID = PublicID <$> (string \"PUBLIC\" *> quotedText) <*> quotedText\n    parseSystemID = SystemID <$> (string \"SYSTEM\" *> quotedText)\n    quotedText = do\n        skipSpace\n        between '\"' <|> between '\\''\n    between c = do\n        char' c\n        x <- takeWhile (/=c)\n        char' c\n        return x\n    parseEnd = do\n        skipSpace\n        n <- parseName\n        skipSpace\n        char' '>'\n        return $ TokenEndElement n\n    parseBegin = do\n        skipSpace\n        n <- parseName\n        as <- A.many $ parseAttribute settings\n        skipSpace\n        isClose <- (char '/' >> skipSpace >> return True) <|> return False\n        char' '>'\n        return $ TokenBeginElement n as isClose 0\n\nparseAttribute :: ParseSettings -> Parser TAttribute\nparseAttribute settings = do\n    skipSpace\n    key <- parseName\n    skipSpace\n    char' '='\n    skipSpace\n    val <- squoted <|> dquoted\n    return (key, val)\n  where\n    squoted = char '\\'' *> manyTill (parseContent settings False True) (char '\\'')\n    dquoted = char  '\"' *> manyTill (parseContent settings True False) (char  '\"')\n\nparseName :: Parser TName\nparseName =\n  name <$> parseIdent <*> A.optional (char ':' >> parseIdent)\n  where\n    name i1 Nothing   = TName Nothing i1\n    name i1 (Just i2) = TName (Just i1) i2\n\nparseIdent :: Parser Text\nparseIdent =\n    takeWhile1 valid\n  where\n    valid '&'  = False\n    valid '<'  = False\n    valid '>'  = False\n    valid ':'  = False\n    valid '?'  = False\n    valid '='  = False\n    valid '\"'  = False\n    valid '\\'' = False\n    valid '/'  = False\n    valid ';'  = False\n    valid '#'  = False\n    valid c    = not $ isXMLSpace c\n\nparseContent :: ParseSettings\n             -> Bool -- break on double quote\n             -> Bool -- break on single quote\n             -> Parser Content\nparseContent (ParseSettings decodeEntities _ decodeIllegalCharacters _) breakDouble breakSingle = parseReference <|> parseTextContent where\n  parseReference = do\n    char' '&'\n    t <- parseEntityRef <|> parseHexCharRef <|> parseDecCharRef\n    char' ';'\n    return t\n  parseEntityRef = do\n    TName ma b <- parseName\n    let name = maybe \"\" (`T.append` \":\") ma `T.append` b\n    return $ case name of\n      \"lt\"   -> ContentText \"<\"\n      \"gt\"   -> ContentText \">\"\n      \"amp\"  -> ContentText \"&\"\n      \"quot\" -> ContentText \"\\\"\"\n      \"apos\" -> ContentText \"'\"\n      _      -> decodeEntities name\n  parseHexCharRef = do\n    void $ string \"#x\"\n    n <- AT.hexadecimal\n    case toValidXmlChar n <|> decodeIllegalCharacters n of\n      Nothing -> fail \"Invalid character from hexadecimal character reference.\"\n      Just c -> return $ ContentText $ T.singleton c\n  parseDecCharRef = do\n    void $ string \"#\"\n    n <- AT.decimal\n    case toValidXmlChar n <|> decodeIllegalCharacters n of\n      Nothing -> fail \"Invalid character from decimal character reference.\"\n      Just c  -> return $ ContentText $ T.singleton c\n  parseTextContent = ContentText <$> takeWhile1 valid\n  valid '\"'  = not breakDouble\n  valid '\\'' = not breakSingle\n  valid '&'  = False -- amp\n  valid '<'  = False -- lt\n  valid _    = True\n\n-- | Is this codepoint a valid XML character? See\n-- <https://www.w3.org/TR/xml/#charsets>. This is proudly XML 1.0 only.\ntoValidXmlChar :: Int -> Maybe Char\ntoValidXmlChar n\n  | any checkRange ranges = Just (toEnum n)\n  | otherwise = Nothing\n  where\n    --Inclusive lower bound, inclusive upper bound.\n    ranges :: [(Int, Int)]\n    ranges =\n      [ (0x9, 0xA)\n      , (0xD, 0xD)\n      , (0x20, 0xD7FF)\n      , (0xE000, 0xFFFD)\n      , (0x10000, 0x10FFFF)\n      ]\n    checkRange (lb, ub) = lb <= n && n <= ub\n\nskipSpace :: Parser ()\nskipSpace = skipWhile isXMLSpace\n\n-- | Determines whether a character is an XML white space. The list of\n-- white spaces is given by\n--\n-- >  S ::= (#x20 | #x9 | #xD | #xA)+\n--\n-- in <http://www.w3.org/TR/2008/REC-xml-20081126/#sec-common-syn>.\nisXMLSpace :: Char -> Bool\nisXMLSpace ' '  = True\nisXMLSpace '\\t' = True\nisXMLSpace '\\r' = True\nisXMLSpace '\\n' = True\nisXMLSpace _    = False\n\nnewline :: Parser ()\nnewline = void $ (char '\\r' >> char '\\n') <|> char '\\n'\n\nchar' :: Char -> Parser ()\nchar' = void . char\n\ndata ContentType = Ignore | IsContent Text | IsError String | NotContent\n\n-- | Grabs the next piece of content if available. This function skips over any\n-- comments, instructions or entities, and concatenates all content until the next start\n-- or end tag.\ncontentMaybe :: MonadThrow m => ConduitT Event o m (Maybe Text)\ncontentMaybe = do\n    x <- peekC\n    case pc' x of\n        Ignore      -> dropC 1 >> contentMaybe\n        IsContent t -> dropC 1 >> fmap Just (takeContents (t:))\n        IsError e   -> lift $ throwM $ InvalidEntity e x\n        NotContent  -> return Nothing\n  where\n    pc' Nothing  = NotContent\n    pc' (Just x) = pc x\n    pc (EventContent (ContentText t)) = IsContent t\n    pc (EventContent (ContentEntity e)) = IsError $ \"Unknown entity: \" ++ show e\n    pc (EventCDATA t) = IsContent t\n    pc EventBeginElement{} = NotContent\n    pc EventEndElement{} = NotContent\n    pc EventBeginDocument{} = Ignore\n    pc EventEndDocument = Ignore\n    pc EventBeginDoctype{} = Ignore\n    pc EventEndDoctype = Ignore\n    pc EventInstruction{} = Ignore\n    pc EventComment{} = Ignore\n    takeContents front = do\n        x <- peekC\n        case pc' x of\n            Ignore      -> dropC 1 >> takeContents front\n            IsContent t -> dropC 1 >> takeContents (front . (:) t)\n            IsError e   -> lift $ throwM $ InvalidEntity e x\n            NotContent  -> return $ T.concat $ front []\n\n-- | Grabs the next piece of content. If none if available, returns 'T.empty'.\n-- This is simply a wrapper around 'contentMaybe'.\ncontent :: MonadThrow m => ConduitT Event o m Text\ncontent = fromMaybe T.empty <$> contentMaybe\n\n\nisWhitespace :: Event -> Bool\nisWhitespace EventBeginDocument             = True\nisWhitespace EventEndDocument               = True\nisWhitespace EventBeginDoctype{}            = True\nisWhitespace EventEndDoctype                = True\nisWhitespace EventInstruction{}             = True\nisWhitespace (EventContent (ContentText t)) = T.all isSpace t\nisWhitespace EventComment{}                 = True\nisWhitespace (EventCDATA t)                 = T.all isSpace t\nisWhitespace _                              = False\n\n\n-- | The most generic way to parse a tag. It takes a 'NameMatcher' to check whether\n-- this is a correct tag name, an 'AttrParser' to handle attributes, and\n-- then a parser to deal with content.\n--\n-- 'Events' are consumed if and only if the tag name and its attributes match.\n--\n-- This function automatically absorbs its balancing closing tag, and will\n-- throw an exception if not all of the attributes or child elements are\n-- consumed. If you want to allow extra attributes, see 'ignoreAttrs'.\n--\n-- This function automatically ignores comments, instructions and whitespace.\ntag :: MonadThrow m\n    => NameMatcher a -- ^ Check if this is a correct tag name\n                     --   and return a value that can be used to get an @AttrParser@.\n                     --   If this fails, the function will return @Nothing@\n    -> (a -> AttrParser b) -- ^ Given the value returned by the name checker, this function will\n                           --   be used to get an @AttrParser@ appropriate for the specific tag.\n                           --   If the @AttrParser@ fails, the function will also return @Nothing@\n    -> (b -> ConduitT Event o m c) -- ^ Handler function to handle the attributes and children\n                                   --   of a tag, given the value return from the @AttrParser@\n    -> ConduitT Event o m (Maybe c)\ntag nameMatcher attrParser f = do\n  (x, leftovers) <- dropWS []\n  res <- case x of\n    Just (EventBeginElement name as) -> case runNameMatcher nameMatcher name of\n      Just y -> case runAttrParser' (attrParser y) as of\n        Left _ -> return Nothing\n        Right z -> do\n          z' <- f z\n          (a, _leftovers') <- dropWS []\n          case a of\n            Just (EventEndElement name')\n              | name == name' -> return (Just z')\n            _ -> lift $ throwM $ InvalidEndElement name a\n      Nothing -> return Nothing\n    _ -> return Nothing\n\n  case res of\n    -- Did not parse, put back all of the leading whitespace events and the\n    -- final observed event generated by dropWS\n    Nothing -> mapM_ leftover leftovers\n    -- Parse succeeded, discard all of those whitespace events and the\n    -- first parsed event\n    Just _  -> return ()\n\n  return res\n  where\n    -- Drop Events until we encounter a non-whitespace element. Return all of\n    -- the events consumed here (including the first non-whitespace event) so\n    -- that the calling function can treat them as leftovers if the parse fails\n    dropWS leftovers = do\n        x <- await\n        let leftovers' = maybe id (:) x leftovers\n\n        case isWhitespace <$> x of\n          Just True -> dropWS leftovers'\n          _         -> return (x, leftovers')\n    runAttrParser' p as =\n        case runAttrParser p as of\n            Left e           -> Left e\n            Right ([], x)    -> Right x\n            Right (attr', _) -> Left $ toException $ UnparsedAttributes attr'\n\n-- | A simplified version of 'tag' where the 'NameMatcher' result isn't forwarded to the attributes parser.\n--\n-- Since 1.5.0\ntag' :: MonadThrow m\n     => NameMatcher a -> AttrParser b -> (b -> ConduitT Event o m c)\n     -> ConduitT Event o m (Maybe c)\ntag' a b = tag a (const b)\n\n-- | A further simplified tag parser, which requires that no attributes exist.\ntagNoAttr :: MonadThrow m\n          => NameMatcher a -- ^ Check if this is a correct tag name\n          -> ConduitT Event o m b -- ^ Handler function to handle the children of the matched tag\n          -> ConduitT Event o m (Maybe b)\ntagNoAttr name f = tag' name (return ()) $ const f\n\n\n-- | A further simplified tag parser, which ignores all attributes, if any exist\ntagIgnoreAttrs :: MonadThrow m\n               => NameMatcher a -- ^ Check if this is a correct tag name\n               -> ConduitT Event o m b -- ^ Handler function to handle the children of the matched tag\n               -> ConduitT Event o m (Maybe b)\ntagIgnoreAttrs name f = tag' name ignoreAttrs $ const f\n\n\n-- | Ignore an empty tag and all of its attributes.\n--   This does not ignore the tag recursively\n--   (i.e. it assumes there are no child elements).\n--   This function returns @Just ()@ if the tag matched.\n--\n-- Since 1.5.0\nignoreEmptyTag :: MonadThrow m\n          => NameMatcher a -- ^ Check if this is a correct tag name\n          -> ConduitT Event o m (Maybe ())\nignoreEmptyTag nameMatcher = tagIgnoreAttrs nameMatcher (return ())\n\n\nignored :: Monad m => ConduitT i o m ()\nignored = fix $ \\recurse -> do\n  event <- await\n  case event of\n    Just _ -> recurse\n    _      -> return ()\n\n\n-- | Same as `takeTree`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| (ignoreTree \"a\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| (ignoreTree \"b\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreTree anyName ignoreAttrs >> sinkList)\n-- [EventContent (ContentText \"content\"),EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- Since 1.9.0\nignoreTree :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event o m (Maybe ())\nignoreTree nameMatcher attrParser = fuseUpstream (takeTree nameMatcher attrParser) ignored\n\n-- | Same as `takeContent`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| (ignoreContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- Since 1.9.0\nignoreContent :: MonadThrow m => ConduitT Event o m (Maybe ())\nignoreContent = fuseUpstream takeContent ignored\n\n\n-- | Same as `takeTreeContent`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| (ignoreTreeContent \"a\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| (ignoreTreeContent \"b\" ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| (ignoreTreeContent anyName ignoreAttrs >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventEndElement (Name {nameLocalName = \"a\", ...}),EventEndDocument]\n--\n-- Since 1.5.0\nignoreTreeContent :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event o m (Maybe ())\nignoreTreeContent namePred attrParser = fuseUpstream (takeTreeContent namePred attrParser) ignored\n\n\n-- | Same as `takeAnyTreeContent`, without yielding `Event`s.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| (ignoreAnyTreeContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- >>> runConduit $ parseLBS def \"text<b></b>\" .| (ignoreAnyTreeContent >> sinkList)\n-- [EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventEndElement (Name {nameLocalName = \"b\", ...}),EventEndDocument]\n--\n-- Since 1.5.0\nignoreAnyTreeContent :: MonadThrow m => ConduitT Event o m (Maybe ())\nignoreAnyTreeContent = fuseUpstream takeAnyTreeContent ignored\n\n\n-- | Get the value of the first parser which returns 'Just'. If no parsers\n-- succeed (i.e., return @Just@), this function returns 'Nothing'.\n--\n-- > orE a b = choose [a, b]\n--\n-- Warning: `orE` doesn't backtrack. See 'choose' for detailed explanation.\norE :: Monad m\n    => ConduitT Event o m (Maybe a) -- ^ The first (preferred) parser\n    -> ConduitT Event o m (Maybe a) -- ^ The second parser, only executed if the first parser fails\n    -> ConduitT Event o m (Maybe a)\norE a b = a >>= \\x -> maybe b (const $ return x) x\n\n-- | Get the value of the first parser which returns 'Just'. If no parsers\n-- succeed (i.e., return 'Just'), this function returns 'Nothing'.\n--\n-- Warning: 'choose' doesn't backtrack. If a parser consumed some events,\n-- subsequent parsers will continue from the following events. This can be a\n-- problem if parsers share an accepted prefix of events, so an earlier\n-- (failing) parser will discard the events that the later parser could\n-- potentially succeed on.\n--\n-- An other problematic case is using 'choose' to implement order-independent\n-- parsing using a set of parsers, with a final trailing ignore-anything-else\n-- action.  In this case, certain trees might be skipped.\n--\n-- >>> :{\n-- let parse2Tags name1 name2 = do\n--       tag1 <- tagNoAttr name1 (pure ())\n--       tag2 <- tagNoAttr name2 (pure tag1)\n--       return $ join tag2\n-- :}\n--\n-- >>> :{\n-- runConduit $ parseLBS def \"<a></a><b></b>\" .| choose\n--   [ parse2Tags \"a\" \"b\"\n--   , parse2Tags \"a\" \"c\"\n--   ]\n-- :}\n-- Just ()\n--\n-- >>> :{\n-- runConduit $ parseLBS def \"<a></a><b></b>\" .| choose\n--   [ parse2Tags \"a\" \"c\"\n--   , parse2Tags \"a\" \"b\"\n--   ]\n-- :}\n-- Nothing\nchoose :: Monad m\n       => [ConduitT Event o m (Maybe a)] -- ^ List of parsers that will be tried in order.\n       -> ConduitT Event o m (Maybe a)   -- ^ Result of the first parser to succeed, or @Nothing@\n                                         --   if no parser succeeded\nchoose []     = return Nothing\nchoose (i:is) = i >>= maybe (choose is) (return . Just)\n\n-- | Force an optional parser into a required parser. All of the 'tag'\n-- functions, 'attr', 'choose' and 'many' deal with 'Maybe' parsers. Use this when you\n-- want to finally force something to happen.\nforce :: MonadThrow m\n      => String -- ^ Error message\n      -> m (Maybe a) -- ^ Optional parser to be forced\n      -> m a\nforce msg i = i >>= maybe (throwM $ XmlException msg Nothing) return\n\n-- | A helper function which reads a file from disk using 'enumFile', detects\n-- character encoding using 'detectUtf', parses the XML using 'parseBytes', and\n-- then hands off control to your supplied parser.\nparseFile :: MonadResource m\n          => ParseSettings\n          -> FilePath\n          -> ConduitT i Event m ()\nparseFile ps fp = sourceFile fp .| transPipe liftIO (parseBytes ps)\n\n-- | Parse an event stream from a lazy 'L.ByteString'.\nparseLBS :: MonadThrow m\n         => ParseSettings\n         -> L.ByteString\n         -> ConduitT i Event m ()\nparseLBS ps lbs = sourceLazy lbs .| parseBytes ps\n\ndata XmlException = XmlException\n    { xmlErrorMessage :: String\n    , xmlBadInput     :: Maybe Event\n    }\n                  | InvalidEndElement Name (Maybe Event)\n                  | InvalidEntity String (Maybe Event)\n                  | MissingAttribute String\n                  | UnparsedAttributes [(Name, [Content])]\n    deriving (Show, Typeable)\n\ninstance Exception XmlException where\n#if MIN_VERSION_base(4, 8, 0)\n  displayException (XmlException msg (Just event)) = \"Error while parsing XML event \" ++ show event ++ \": \" ++ msg\n  displayException (XmlException msg _) = \"Error while parsing XML: \" ++ msg\n  displayException (InvalidEndElement name (Just event)) = \"Error while parsing XML event: expected </\" ++ T.unpack (nameLocalName name) ++ \">, got \" ++ show event\n  displayException (InvalidEndElement name _) = \"Error while parsing XML event: expected </\" ++ show name ++ \">, got nothing\"\n  displayException (InvalidEntity msg (Just event)) = \"Error while parsing XML entity \" ++ show event ++ \": \" ++ msg\n  displayException (InvalidEntity msg _) = \"Error while parsing XML entity: \" ++ msg\n  displayException (MissingAttribute msg) = \"Missing required attribute: \" ++ msg\n  displayException (UnparsedAttributes attrs) = show (length attrs) ++ \" remaining unparsed attributes: \\n\" ++ intercalate \"\\n\" (show <$> attrs)\n#endif\n\n\n-- | A @NameMatcher@ describes which names a tag parser is allowed to match.\n--\n-- Since 1.5.0\nnewtype NameMatcher a = NameMatcher { runNameMatcher :: Name -> Maybe a }\n\nderiving instance Functor NameMatcher\n\ninstance Applicative NameMatcher where\n  pure a = NameMatcher $ const $ pure a\n  NameMatcher f <*> NameMatcher a = NameMatcher $ \\name -> f name <*> a name\n\n-- | 'NameMatcher's can be combined with @\\<|\\>@\ninstance Alternative NameMatcher where\n  empty = NameMatcher $ const Nothing\n  NameMatcher f <|> NameMatcher g = NameMatcher (\\a -> f a <|> g a)\n\n-- | Match a single 'Name' in a concise way.\n-- Note that 'Name' is namespace sensitive: when using the 'IsString' instance,\n-- use @\"{http:\\/\\/a\\/b}c\"@ to match the tag @c@ in the XML namespace @http://a/b@\ninstance (a ~ Name) => IsString (NameMatcher a) where\n  fromString s = matching (== fromString s)\n\n-- | @matching f@ matches @name@ iff @f name@ is true. Returns the matched 'Name'.\n--\n-- Since 1.5.0\nmatching :: (Name -> Bool) -> NameMatcher Name\nmatching f = NameMatcher $ \\name -> if f name then Just name else Nothing\n\n-- | Matches any 'Name'. Returns the matched 'Name'.\n--\n-- Since 1.5.0\nanyName :: NameMatcher Name\nanyName = matching (const True)\n\n-- | Matches any 'Name' from the given list. Returns the matched 'Name'.\n--\n-- Since 1.5.0\nanyOf :: [Name] -> NameMatcher Name\nanyOf values = matching (`elem` values)\n\n\n-- | A monad for parsing attributes. By default, it requires you to deal with\n-- all attributes present on an element, and will throw an exception if there\n-- are unhandled attributes. Use the 'requireAttr', 'attr' et al\n-- functions for handling an attribute, and 'ignoreAttrs' if you would like to\n-- skip the rest of the attributes on an element.\n--\n-- 'Alternative' instance behaves like 'First' monoid: it chooses first\n-- parser which doesn't fail.\nnewtype AttrParser a = AttrParser { runAttrParser :: [(Name, [Content])] -> Either SomeException ([(Name, [Content])], a) }\n\ninstance Monad AttrParser where\n    return a = AttrParser $ \\as -> Right (as, a)\n    (AttrParser f) >>= g = AttrParser $ \\as ->\n        either Left (\\(as', f') -> runAttrParser (g f') as') (f as)\ninstance Functor AttrParser where\n    fmap = liftM\ninstance Applicative AttrParser where\n    pure = return\n    (<*>) = ap\ninstance Alternative AttrParser where\n    empty = AttrParser $ const $ Left $ toException $ XmlException \"AttrParser.empty\" Nothing\n    AttrParser f <|> AttrParser g = AttrParser $ \\x ->\n        either (const $ g x) Right (f x)\ninstance MonadThrow AttrParser where\n    throwM = AttrParser . const . throwM\n\noptionalAttrRaw :: ((Name, [Content]) -> Maybe b) -> AttrParser (Maybe b)\noptionalAttrRaw f =\n    AttrParser $ go id\n  where\n    go front [] = Right (front [], Nothing)\n    go front (a:as) =\n        maybe (go (front . (:) a) as)\n              (\\b -> Right (front as, Just b))\n              (f a)\n\nrequireAttrRaw :: String -> ((Name, [Content]) -> Maybe b) -> AttrParser b\nrequireAttrRaw msg f = optionalAttrRaw f >>=\n    maybe (AttrParser $ const $ Left $ toException $ MissingAttribute msg)\n          return\n\n-- | Return the value for an attribute if present.\nattr :: Name -> AttrParser (Maybe Text)\nattr n = optionalAttrRaw\n    (\\(x, y) -> if x == n then Just (contentsToText y) else Nothing)\n\n-- | Shortcut composition of 'force' and 'attr'.\nrequireAttr :: Name -> AttrParser Text\nrequireAttr n = force (\"Missing attribute: \" ++ show n) $ attr n\n\n\n{-# DEPRECATED optionalAttr \"Please use 'attr'.\" #-}\noptionalAttr :: Name -> AttrParser (Maybe Text)\noptionalAttr = attr\n\ncontentsToText :: [Content] -> Text\ncontentsToText = T.concat . map toText where\n  toText (ContentText t)   = t\n  toText (ContentEntity e) = T.concat [\"&\", e, \";\"]\n\n-- | Skip the remaining attributes on an element. Since this will clear the\n-- list of attributes, you must call this /after/ any calls to 'requireAttr',\n-- 'optionalAttr', etc.\nignoreAttrs :: AttrParser ()\nignoreAttrs = AttrParser $ const $ Right ([], ())\n\n-- | Keep parsing elements as long as the parser returns 'Just'.\nmany :: Monad m\n     => ConduitT Event o m (Maybe a)\n     -> ConduitT Event o m [a]\nmany i = manyIgnore i $ return Nothing\n\n-- | Like 'many' but discards the results without building an intermediate list.\n--\n-- Since 1.5.0\nmany_ :: MonadThrow m\n      => ConduitT Event o m (Maybe a)\n      -> ConduitT Event o m ()\nmany_ consumer = manyIgnoreYield (return Nothing) (void <$> consumer)\n\n-- | Keep parsing elements as long as the parser returns 'Just'\n--   or the ignore parser returns 'Just'.\nmanyIgnore :: Monad m\n           => ConduitT Event o m (Maybe a)\n           -> ConduitT Event o m (Maybe b)\n           -> ConduitT Event o m [a]\nmanyIgnore i ignored = go id where\n  go front = i >>= maybe (onFail front) (\\y -> go $ front . (:) y)\n  -- onFail is called if the main parser fails\n  onFail front = ignored >>= maybe (return $ front []) (const $ go front)\n\n-- | Like @many@, but any tags and content the consumer doesn't match on\n--   are silently ignored.\nmany' :: MonadThrow m\n      => ConduitT Event o m (Maybe a)\n      -> ConduitT Event o m [a]\nmany' consumer = manyIgnore consumer ignoreAnyTreeContent\n\n\n-- | Like 'many', but uses 'yield' so the result list can be streamed\n--   to downstream conduits without waiting for 'manyYield' to finish\nmanyYield :: Monad m\n          => ConduitT a b m (Maybe b)\n          -> ConduitT a b m ()\nmanyYield consumer = fix $ \\loop ->\n  consumer >>= maybe (return ()) (\\x -> yield x >> loop)\n\n-- | Like 'manyIgnore', but uses 'yield' so the result list can be streamed\n--   to downstream conduits without waiting for 'manyIgnoreYield' to finish\nmanyIgnoreYield :: MonadThrow m\n                => ConduitT Event b m (Maybe b) -- ^ Consuming parser that generates the result stream\n                -> ConduitT Event b m (Maybe ()) -- ^ Ignore parser that consumes elements to be ignored\n                -> ConduitT Event b m ()\nmanyIgnoreYield consumer ignoreParser = fix $ \\loop ->\n  consumer >>= maybe (onFail loop) (\\x -> yield x >> loop)\n  where onFail loop = ignoreParser >>= maybe (return ()) (const loop)\n\n-- | Like 'many'', but uses 'yield' so the result list can be streamed\n--   to downstream conduits without waiting for 'manyYield'' to finish\nmanyYield' :: MonadThrow m\n           => ConduitT Event b m (Maybe b)\n           -> ConduitT Event b m ()\nmanyYield' consumer = manyIgnoreYield consumer ignoreAnyTreeContent\n\n\n-- | Stream a single content 'Event'.\n--\n-- Returns @Just ()@ if a content 'Event' was consumed, @Nothing@ otherwise.\n--\n-- >>> runConduit $ parseLBS def \"content<a></a>\" .| void takeContent .| sinkList\n-- [EventBeginDocument,EventContent (ContentText \"content\")]\n--\n-- If next event isn't a content, nothing is consumed.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a>\" .| void takeContent .| sinkList\n-- [EventBeginDocument]\n--\n-- Since 1.5.0\ntakeContent :: MonadThrow m => ConduitT Event Event m (Maybe ())\ntakeContent = do\n  event <- await\n  case event of\n    Just e@EventContent{} -> yield e >> return (Just ())\n    Just e@EventCDATA{}   -> yield e >> return (Just ())\n    Just e -> if isWhitespace e then yield e >> takeContent else leftover e >> return Nothing\n    _ -> return Nothing\n\n-- | Stream 'Event's corresponding to a single XML element that matches given 'NameMatcher' and 'AttrParser', from the opening- to the closing-tag.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTree \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument,EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...})]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTree \"b\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument]\n--\n-- If next 'Event' isn't an element, nothing is consumed.\n--\n-- >>> runConduit $ parseLBS def \"text<a></a>\" .| void (takeTree \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument]\n--\n-- If an opening-tag is consumed but no matching closing-tag is found, an 'XmlException' is thrown.\n--\n-- >>> runConduit $ parseLBS def \"<a><b></b>\" .| void (takeTree \"a\" ignoreAttrs) .| sinkList\n-- *** Exception: InvalidEndElement (Name {nameLocalName = \"a\", nameNamespace = Nothing, namePrefix = Nothing}) Nothing\n--\n-- This function automatically ignores comments, instructions and whitespace.\n--\n-- Returns @Just ()@ if an element was consumed, 'Nothing' otherwise.\n--\n-- Since 1.5.0\ntakeTree :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event Event m (Maybe ())\ntakeTree nameMatcher attrParser = do\n  event <- await\n  case event of\n    Just e@(EventBeginElement name as) -> case runNameMatcher nameMatcher name of\n      Just _ -> case runAttrParser attrParser as of\n        Right _ -> do\n          yield e\n          whileJust takeAnyTreeContent\n          endEvent <- await\n          case endEvent of\n            Just e'@(EventEndElement name') | name == name' -> yield e' >> return (Just ())\n            _ -> lift $ throwM $ InvalidEndElement name endEvent\n        _ -> leftover e >> return Nothing\n      _ -> leftover e >> return Nothing\n\n    Just e -> if isWhitespace e then yield e >> takeTree nameMatcher attrParser else leftover e >> return Nothing\n    _ -> return Nothing\n  where\n    whileJust f = fix $ \\loop -> f >>= maybe (return ()) (const loop)\n\n-- | Like 'takeTree', but can also stream a content 'Event'.\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTreeContent \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument,EventBeginElement (Name {nameLocalName = \"a\", ...}) [],EventContent (ContentText \"content\"),EventEndElement (Name {nameLocalName = \"a\", ...})]\n--\n-- >>> runConduit $ parseLBS def \"<a>content</a><b></b>\" .| void (takeTreeContent \"b\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument]\n--\n-- >>> runConduit $ parseLBS def \"content<a></a><b></b>\" .| void (takeTreeContent \"a\" ignoreAttrs) .| sinkList\n-- [EventBeginDocument,EventContent (ContentText \"content\")]\n--\n-- Since 1.5.0\ntakeTreeContent :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event Event m (Maybe ())\ntakeTreeContent nameMatcher attrParser = runMaybeT $ MaybeT (takeTree nameMatcher attrParser) <|> MaybeT takeContent\n\n-- | Like 'takeTreeContent', without checking for tag name or attributes.\n--\n-- >>> runConduit $ parseLBS def \"text<a></a>\" .| void takeAnyTreeContent .| sinkList\n-- [EventBeginDocument,EventContent (ContentText \"text\")]\n--\n-- >>> runConduit $ parseLBS def \"</a><b></b>\" .| void takeAnyTreeContent .| sinkList\n-- [EventBeginDocument]\n--\n-- >>> runConduit $ parseLBS def \"<b><c></c></b></a>text\" .| void takeAnyTreeContent .| sinkList\n-- [EventBeginDocument,EventBeginElement (Name {nameLocalName = \"b\", ...}) [],EventBeginElement (Name {nameLocalName = \"c\", ...}) [],EventEndElement (Name {nameLocalName = \"c\", ...}),EventEndElement (Name {nameLocalName = \"b\", ...})]\n--\n-- Since 1.5.0\ntakeAnyTreeContent :: MonadThrow m\n                => ConduitT Event Event m (Maybe ())\ntakeAnyTreeContent = takeTreeContent anyName ignoreAttrs\n\n\n-- | Default implementation of 'DecodeEntities', which leaves the\n-- entity as-is. Numeric character references and the five standard\n-- entities (lt, gt, amp, quot, pos) are handled internally by the\n-- parser.\ndecodeXmlEntities :: DecodeEntities\ndecodeXmlEntities = ContentEntity\n\n-- | HTML4-compliant entity decoder. Handles the additional 248\n-- entities defined by HTML 4 and XHTML 1.\n--\n-- Note that HTML 5 introduces a drastically larger number of entities, and\n-- this code does not recognize most of them.\ndecodeHtmlEntities :: DecodeEntities\ndecodeHtmlEntities t =\n  maybe (ContentEntity t) ContentText $ Map.lookup t htmlEntities\n\nhtmlEntities :: Map.Map T.Text T.Text\nhtmlEntities = Map.fromList\n    $ map (pack *** pack) -- Work around the long-compile-time bug\n    [ (\"nbsp\", \"\\160\")\n    , (\"iexcl\", \"\\161\")\n    , (\"cent\", \"\\162\")\n    , (\"pound\", \"\\163\")\n    , (\"curren\", \"\\164\")\n    , (\"yen\", \"\\165\")\n    , (\"brvbar\", \"\\166\")\n    , (\"sect\", \"\\167\")\n    , (\"uml\", \"\\168\")\n    , (\"copy\", \"\\169\")\n    , (\"ordf\", \"\\170\")\n    , (\"laquo\", \"\\171\")\n    , (\"not\", \"\\172\")\n    , (\"shy\", \"\\173\")\n    , (\"reg\", \"\\174\")\n    , (\"macr\", \"\\175\")\n    , (\"deg\", \"\\176\")\n    , (\"plusmn\", \"\\177\")\n    , (\"sup2\", \"\\178\")\n    , (\"sup3\", \"\\179\")\n    , (\"acute\", \"\\180\")\n    , (\"micro\", \"\\181\")\n    , (\"para\", \"\\182\")\n    , (\"middot\", \"\\183\")\n    , (\"cedil\", \"\\184\")\n    , (\"sup1\", \"\\185\")\n    , (\"ordm\", \"\\186\")\n    , (\"raquo\", \"\\187\")\n    , (\"frac14\", \"\\188\")\n    , (\"frac12\", \"\\189\")\n    , (\"frac34\", \"\\190\")\n    , (\"iquest\", \"\\191\")\n    , (\"Agrave\", \"\\192\")\n    , (\"Aacute\", \"\\193\")\n    , (\"Acirc\", \"\\194\")\n    , (\"Atilde\", \"\\195\")\n    , (\"Auml\", \"\\196\")\n    , (\"Aring\", \"\\197\")\n    , (\"AElig\", \"\\198\")\n    , (\"Ccedil\", \"\\199\")\n    , (\"Egrave\", \"\\200\")\n    , (\"Eacute\", \"\\201\")\n    , (\"Ecirc\", \"\\202\")\n    , (\"Euml\", \"\\203\")\n    , (\"Igrave\", \"\\204\")\n    , (\"Iacute\", \"\\205\")\n    , (\"Icirc\", \"\\206\")\n    , (\"Iuml\", \"\\207\")\n    , (\"ETH\", \"\\208\")\n    , (\"Ntilde\", \"\\209\")\n    , (\"Ograve\", \"\\210\")\n    , (\"Oacute\", \"\\211\")\n    , (\"Ocirc\", \"\\212\")\n    , (\"Otilde\", \"\\213\")\n    , (\"Ouml\", \"\\214\")\n    , (\"times\", \"\\215\")\n    , (\"Oslash\", \"\\216\")\n    , (\"Ugrave\", \"\\217\")\n    , (\"Uacute\", \"\\218\")\n    , (\"Ucirc\", \"\\219\")\n    , (\"Uuml\", \"\\220\")\n    , (\"Yacute\", \"\\221\")\n    , (\"THORN\", \"\\222\")\n    , (\"szlig\", \"\\223\")\n    , (\"agrave\", \"\\224\")\n    , (\"aacute\", \"\\225\")\n    , (\"acirc\", \"\\226\")\n    , (\"atilde\", \"\\227\")\n    , (\"auml\", \"\\228\")\n    , (\"aring\", \"\\229\")\n    , (\"aelig\", \"\\230\")\n    , (\"ccedil\", \"\\231\")\n    , (\"egrave\", \"\\232\")\n    , (\"eacute\", \"\\233\")\n    , (\"ecirc\", \"\\234\")\n    , (\"euml\", \"\\235\")\n    , (\"igrave\", \"\\236\")\n    , (\"iacute\", \"\\237\")\n    , (\"icirc\", \"\\238\")\n    , (\"iuml\", \"\\239\")\n    , (\"eth\", \"\\240\")\n    , (\"ntilde\", \"\\241\")\n    , (\"ograve\", \"\\242\")\n    , (\"oacute\", \"\\243\")\n    , (\"ocirc\", \"\\244\")\n    , (\"otilde\", \"\\245\")\n    , (\"ouml\", \"\\246\")\n    , (\"divide\", \"\\247\")\n    , (\"oslash\", \"\\248\")\n    , (\"ugrave\", \"\\249\")\n    , (\"uacute\", \"\\250\")\n    , (\"ucirc\", \"\\251\")\n    , (\"uuml\", \"\\252\")\n    , (\"yacute\", \"\\253\")\n    , (\"thorn\", \"\\254\")\n    , (\"yuml\", \"\\255\")\n    , (\"OElig\", \"\\338\")\n    , (\"oelig\", \"\\339\")\n    , (\"Scaron\", \"\\352\")\n    , (\"scaron\", \"\\353\")\n    , (\"Yuml\", \"\\376\")\n    , (\"fnof\", \"\\402\")\n    , (\"circ\", \"\\710\")\n    , (\"tilde\", \"\\732\")\n    , (\"Alpha\", \"\\913\")\n    , (\"Beta\", \"\\914\")\n    , (\"Gamma\", \"\\915\")\n    , (\"Delta\", \"\\916\")\n    , (\"Epsilon\", \"\\917\")\n    , (\"Zeta\", \"\\918\")\n    , (\"Eta\", \"\\919\")\n    , (\"Theta\", \"\\920\")\n    , (\"Iota\", \"\\921\")\n    , (\"Kappa\", \"\\922\")\n    , (\"Lambda\", \"\\923\")\n    , (\"Mu\", \"\\924\")\n    , (\"Nu\", \"\\925\")\n    , (\"Xi\", \"\\926\")\n    , (\"Omicron\", \"\\927\")\n    , (\"Pi\", \"\\928\")\n    , (\"Rho\", \"\\929\")\n    , (\"Sigma\", \"\\931\")\n    , (\"Tau\", \"\\932\")\n    , (\"Upsilon\", \"\\933\")\n    , (\"Phi\", \"\\934\")\n    , (\"Chi\", \"\\935\")\n    , (\"Psi\", \"\\936\")\n    , (\"Omega\", \"\\937\")\n    , (\"alpha\", \"\\945\")\n    , (\"beta\", \"\\946\")\n    , (\"gamma\", \"\\947\")\n    , (\"delta\", \"\\948\")\n    , (\"epsilon\", \"\\949\")\n    , (\"zeta\", \"\\950\")\n    , (\"eta\", \"\\951\")\n    , (\"theta\", \"\\952\")\n    , (\"iota\", \"\\953\")\n    , (\"kappa\", \"\\954\")\n    , (\"lambda\", \"\\955\")\n    , (\"mu\", \"\\956\")\n    , (\"nu\", \"\\957\")\n    , (\"xi\", \"\\958\")\n    , (\"omicron\", \"\\959\")\n    , (\"pi\", \"\\960\")\n    , (\"rho\", \"\\961\")\n    , (\"sigmaf\", \"\\962\")\n    , (\"sigma\", \"\\963\")\n    , (\"tau\", \"\\964\")\n    , (\"upsilon\", \"\\965\")\n    , (\"phi\", \"\\966\")\n    , (\"chi\", \"\\967\")\n    , (\"psi\", \"\\968\")\n    , (\"omega\", \"\\969\")\n    , (\"thetasym\", \"\\977\")\n    , (\"upsih\", \"\\978\")\n    , (\"piv\", \"\\982\")\n    , (\"ensp\", \"\\8194\")\n    , (\"emsp\", \"\\8195\")\n    , (\"thinsp\", \"\\8201\")\n    , (\"zwnj\", \"\\8204\")\n    , (\"zwj\", \"\\8205\")\n    , (\"lrm\", \"\\8206\")\n    , (\"rlm\", \"\\8207\")\n    , (\"ndash\", \"\\8211\")\n    , (\"mdash\", \"\\8212\")\n    , (\"lsquo\", \"\\8216\")\n    , (\"rsquo\", \"\\8217\")\n    , (\"sbquo\", \"\\8218\")\n    , (\"ldquo\", \"\\8220\")\n    , (\"rdquo\", \"\\8221\")\n    , (\"bdquo\", \"\\8222\")\n    , (\"dagger\", \"\\8224\")\n    , (\"Dagger\", \"\\8225\")\n    , (\"bull\", \"\\8226\")\n    , (\"hellip\", \"\\8230\")\n    , (\"permil\", \"\\8240\")\n    , (\"prime\", \"\\8242\")\n    , (\"Prime\", \"\\8243\")\n    , (\"lsaquo\", \"\\8249\")\n    , (\"rsaquo\", \"\\8250\")\n    , (\"oline\", \"\\8254\")\n    , (\"frasl\", \"\\8260\")\n    , (\"euro\", \"\\8364\")\n    , (\"image\", \"\\8465\")\n    , (\"weierp\", \"\\8472\")\n    , (\"real\", \"\\8476\")\n    , (\"trade\", \"\\8482\")\n    , (\"alefsym\", \"\\8501\")\n    , (\"larr\", \"\\8592\")\n    , (\"uarr\", \"\\8593\")\n    , (\"rarr\", \"\\8594\")\n    , (\"darr\", \"\\8595\")\n    , (\"harr\", \"\\8596\")\n    , (\"crarr\", \"\\8629\")\n    , (\"lArr\", \"\\8656\")\n    , (\"uArr\", \"\\8657\")\n    , (\"rArr\", \"\\8658\")\n    , (\"dArr\", \"\\8659\")\n    , (\"hArr\", \"\\8660\")\n    , (\"forall\", \"\\8704\")\n    , (\"part\", \"\\8706\")\n    , (\"exist\", \"\\8707\")\n    , (\"empty\", \"\\8709\")\n    , (\"nabla\", \"\\8711\")\n    , (\"isin\", \"\\8712\")\n    , (\"notin\", \"\\8713\")\n    , (\"ni\", \"\\8715\")\n    , (\"prod\", \"\\8719\")\n    , (\"sum\", \"\\8721\")\n    , (\"minus\", \"\\8722\")\n    , (\"lowast\", \"\\8727\")\n    , (\"radic\", \"\\8730\")\n    , (\"prop\", \"\\8733\")\n    , (\"infin\", \"\\8734\")\n    , (\"ang\", \"\\8736\")\n    , (\"and\", \"\\8743\")\n    , (\"or\", \"\\8744\")\n    , (\"cap\", \"\\8745\")\n    , (\"cup\", \"\\8746\")\n    , (\"int\", \"\\8747\")\n    , (\"there4\", \"\\8756\")\n    , (\"sim\", \"\\8764\")\n    , (\"cong\", \"\\8773\")\n    , (\"asymp\", \"\\8776\")\n    , (\"ne\", \"\\8800\")\n    , (\"equiv\", \"\\8801\")\n    , (\"le\", \"\\8804\")\n    , (\"ge\", \"\\8805\")\n    , (\"sub\", \"\\8834\")\n    , (\"sup\", \"\\8835\")\n    , (\"nsub\", \"\\8836\")\n    , (\"sube\", \"\\8838\")\n    , (\"supe\", \"\\8839\")\n    , (\"oplus\", \"\\8853\")\n    , (\"otimes\", \"\\8855\")\n    , (\"perp\", \"\\8869\")\n    , (\"sdot\", \"\\8901\")\n    , (\"lceil\", \"\\8968\")\n    , (\"rceil\", \"\\8969\")\n    , (\"lfloor\", \"\\8970\")\n    , (\"rfloor\", \"\\8971\")\n    , (\"lang\", \"\\9001\")\n    , (\"rang\", \"\\9002\")\n    , (\"loz\", \"\\9674\")\n    , (\"spades\", \"\\9824\")\n    , (\"clubs\", \"\\9827\")\n    , (\"hearts\", \"\\9829\")\n    , (\"diams\", \"\\9830\")\n    ]\n", "{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE OverloadedStrings  #-}\n\nimport           Control.Exception            (Exception, toException)\nimport           Control.Monad.IO.Class       (liftIO)\nimport qualified Data.ByteString.Char8        as S\nimport qualified Data.ByteString.Lazy.Char8   as L\nimport           Data.Typeable                (Typeable)\nimport           Data.XML.Types\nimport           Test.Hspec\nimport           Test.HUnit                   hiding (Test)\nimport qualified Text.XML                     as Res\nimport qualified Text.XML.Cursor              as Cu\nimport           Text.XML.Stream.Parse        (def)\nimport qualified Text.XML.Stream.Parse        as P\nimport qualified Text.XML.Unresolved          as D\n\nimport           Control.Monad\nimport qualified Data.Set                     as Set\nimport           Data.Text                    (Text)\nimport qualified Data.Text                    as T\nimport           Text.XML.Cursor              (($.//), ($/), ($//), ($|),\n                                               (&.//), (&/), (&//))\n\nimport qualified Control.Monad.Trans.Resource as C\nimport           Data.Conduit                 ((.|), runConduit, runConduitRes, ConduitT)\nimport qualified Data.Conduit                 as C\nimport qualified Data.Conduit.List            as CL\nimport qualified Data.Map                     as Map\nimport           Text.Blaze                   (toMarkup)\nimport           Text.Blaze.Renderer.String   (renderMarkup)\n\nmain :: IO ()\nmain = hspec $ do\n    describe \"XML parsing and rendering\" $ do\n        it \"is idempotent to parse and render a document\" documentParseRender\n        it \"has valid parser combinators\" combinators\n        context \"has working choose function\" testChoose\n        it \"has working many function\" testMany\n        it \"has working many' function\" testMany'\n        it \"has working manyYield function\" testManyYield\n        it \"has working takeContent function\" testTakeContent\n        it \"has working takeTree function\" testTakeTree\n        it \"has working takeAnyTreeContent function\" testTakeAnyTreeContent\n        it \"has working orE\" testOrE\n        it \"is idempotent to parse and pretty render a document\" documentParsePrettyRender\n        it \"ignores the BOM\" parseIgnoreBOM\n        it \"strips duplicated attributes\" stripDuplicateAttributes\n        it \"displays comments\" testRenderComments\n        it \"conduit parser\" testConduitParser\n        it \"can omit the XML declaration\" omitXMLDeclaration\n        context \"correctly parses hexadecimal entities\" hexEntityParsing\n    describe \"XML Cursors\" $ do\n        it \"has correct parent\" cursorParent\n        it \"has correct ancestor\" cursorAncestor\n        it \"has correct orSelf\" cursorOrSelf\n        it \"has correct preceding\" cursorPreceding\n        it \"has correct following\" cursorFollowing\n        it \"has correct precedingSibling\" cursorPrecedingSib\n        it \"has correct followingSibling\" cursorFollowingSib\n        it \"has correct descendant\" cursorDescendant\n        it \"has correct check\" cursorCheck\n        it \"has correct check with lists\" cursorPredicate\n        it \"has correct checkNode\" cursorCheckNode\n        it \"has correct checkElement\" cursorCheckElement\n        it \"has correct checkName\" cursorCheckName\n        it \"has correct anyElement\" cursorAnyElement\n        it \"has correct element\" cursorElement\n        it \"has correct laxElement\" cursorLaxElement\n        it \"has correct content\" cursorContent\n        it \"has correct attribute\" cursorAttribute\n        it \"has correct laxAttribute\" cursorLaxAttribute\n        it \"has correct &* and $* operators\" cursorDeep\n        it \"has correct force\" cursorForce\n        it \"has correct forceM\" cursorForceM\n        it \"has correct hasAttribute\" cursorHasAttribute\n        it \"has correct attributeIs\" cursorAttributeIs\n    describe \"resolved\" $ do\n        it \"identifies unresolved entities\" resolvedIdentifies\n        it \"decodeHtmlEntities\" testHtmlEntities\n        it \"works for resolvable entities\" resolvedAllGood\n        it \"merges adjacent content nodes\" resolvedMergeContent\n        it \"understands inline entity declarations\" resolvedInline\n        it \"can expand inline entities recursively\" resolvedInlineRecursive\n        it \"doesn't explode with an inline entity loop\" resolvedInlineLoop\n        it \"doesn't explode with the billion laughs attack\" billionLaughs\n        it \"allows entity expansion size limit to be adjusted\" thousandLaughs\n        it \"doesn't break on [] in doctype comments\" doctypeComment\n        it \"skips element declarations in doctype\" doctypeElements\n        it \"skips processing instructions in doctype\" doctypePI\n    describe \"pretty\" $ do\n        it \"works\" casePretty\n    describe \"top level namespaces\" $ do\n        it \"works\" caseTopLevelNamespace\n        it \"works with prefix\" caseTopLevelNamespacePrefix\n        it \"handles conflicts\" caseTLNConflict\n    describe \"blaze-html instances\" $ do\n        it \"works\" caseBlazeHtml\n    describe \"attribute reordering\" $ do\n        it \"works\" caseAttrReorder\n    describe \"ordering attributes explicitly\" $ do\n        it \"works\" caseOrderAttrs\n    it \"parsing CDATA\" caseParseCdata\n    it \"retains namespaces when asked\" caseRetainNamespaces\n    it \"handles iso-8859-1\" caseIso8859_1\n    it \"renders CDATA when asked\" caseRenderCDATA\n    it \"escapes CDATA closing tag in CDATA\" caseEscapesCDATA\n\ndocumentParseRender :: IO ()\ndocumentParseRender =\n    mapM_ go docs\n  where\n    go x = x @=? D.parseLBS_ def (D.renderLBS def x)\n    docs =\n        [ Document (Prologue [] Nothing [])\n                   (Element \"foo\" [] [])\n                   []\n        , D.parseLBS_ def\n            \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo>\\n<foo/>\"\n        , D.parseLBS_ def\n            \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo>\\n<foo><nested>&ignore;</nested></foo>\"\n        , D.parseLBS_ def\n            \"<foo><![CDATA[this is some<CDATA content>]]></foo>\"\n        , D.parseLBS_ def\n            \"<foo bar='baz&amp;bin'/>\"\n        , D.parseLBS_ def\n            \"<foo><?instr this is a processing instruction?></foo>\"\n        , D.parseLBS_ def\n            \"<foo><!-- this is a comment --></foo>\"\n        ]\n\ndocumentParsePrettyRender :: IO ()\ndocumentParsePrettyRender =\n    L.unpack (D.renderLBS def { D.rsPretty = True } (D.parseLBS_ def doc)) @?= L.unpack doc\n  where\n    doc = L.unlines\n        [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n        , \"<foo>\"\n        , \"    <?bar bar?>\"\n        , \"    text\"\n        , \"    <?bin bin?>\"\n        , \"</foo>\"\n        ]\n\ncombinators :: Assertion\ncombinators = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tag' \"hello\" (P.requireAttr \"world\") $ \\world -> do\n        liftIO $ world @?= \"true\"\n        P.force \"need child1\" $ P.tagNoAttr \"{mynamespace}child1\" $ return ()\n        P.force \"need child2\" $ P.tagNoAttr \"child2\" $ return ()\n        P.force \"need child3\" $ P.tagNoAttr \"child3\" $ do\n            x <- P.contentMaybe\n            liftIO $ x @?= Just \"combine <all> &content\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello world='true'>\"\n        , \"<?this should be ignored?>\"\n        , \"<child1 xmlns='mynamespace'/>\"\n        , \"<!-- this should be ignored -->\"\n        , \"<child2>   </child2>\"\n        , \"<child3>combine &lt;all&gt; <![CDATA[&content]]></child3>\\n\"\n        , \"</hello>\"\n        ]\n\ntestChoose :: Spec\ntestChoose = do\n    it \"can choose between elements\"\n        testChooseEitherElem\n    it \"can choose between elements and text, returning text\"\n        testChooseElemOrTextIsText\n    it \"can choose between elements and text, returning elements\"\n        testChooseElemOrTextIsElem\n    it \"can choose between text and elements, returning text\"\n        testChooseTextOrElemIsText\n    it \"can choose between text and elements, returning elements\"\n        testChooseTextOrElemIsElem\n    it \"can choose between text and elements, when the text is encoded\"\n        testChooseElemOrTextIsEncoded\n    it \"can choose between text and elements, when the text is encoded, NBSP\"\n        testChooseElemOrTextIsEncodedNBSP\n    it \"can choose between elements and text, when the text is whitespace\"\n        testChooseElemOrTextIsWhiteSpace\n    it \"can choose between text and elements, when the text is whitespace\"\n        testChooseTextOrElemIsWhiteSpace\n    it \"can choose between text and elements, when the whitespace is both literal and encoded\"\n        testChooseElemOrTextIsChunkedText\n    it \"can choose between text and elements, when the text is chunked the other way\"\n        testChooseElemOrTextIsChunkedText2\n\ntestChooseElemOrTextIsText :: Assertion\ntestChooseElemOrTextIsText = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \" something \"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \" something \"\n        , \"</hello>\"\n        ]\n\ntestChooseElemOrTextIsEncoded :: Assertion\ntestChooseElemOrTextIsEncoded = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20something\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"&#x20;something&#x20;\"\n        , \"</hello>\"\n        ]\n\ntestChooseElemOrTextIsEncodedNBSP :: Assertion\ntestChooseElemOrTextIsEncodedNBSP = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\160something\\160\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"&#160;something&#160;\"\n        , \"</hello>\"\n        ]\n\n\ntestChooseElemOrTextIsWhiteSpace :: Assertion\ntestChooseElemOrTextIsWhiteSpace = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>   </hello>\"\n        ]\n\ntestChooseTextOrElemIsWhiteSpace :: Assertion\ntestChooseTextOrElemIsWhiteSpace = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.contentMaybe\n            , P.tagNoAttr \"failure\" $ return \"boom\"\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>   </hello>\"\n        ]\n\ntestChooseElemOrTextIsChunkedText :: Assertion\ntestChooseElemOrTextIsChunkedText = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello> &#x20; </hello>\"\n        ]\n\ntestChooseElemOrTextIsChunkedText2 :: Assertion\ntestChooseElemOrTextIsChunkedText2 = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return \"boom\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"\\x20\\x20\\x20\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>&#x20; &#x20;</hello>\"\n        ]\n\ntestChooseElemOrTextIsElem :: Assertion\ntestChooseElemOrTextIsElem = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"success\" $ return \"success\"\n            , P.contentMaybe\n            ]\n        liftIO $ x @?= Just \"success\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestChooseTextOrElemIsText :: Assertion\ntestChooseTextOrElemIsText = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.contentMaybe\n            , P.tagNoAttr \"failure\" $ return \"boom\"\n            ]\n        liftIO $ x @?= Just \" something \"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \" something \"\n        , \"</hello>\"\n        ]\n\ntestChooseTextOrElemIsElem :: Assertion\ntestChooseTextOrElemIsElem = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.contentMaybe\n            , P.tagNoAttr \"success\" $ return \"success\"\n            ]\n        liftIO $ x @?= Just \"success\"\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestChooseEitherElem :: Assertion\ntestChooseEitherElem = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.choose\n            [ P.tagNoAttr \"failure\" $ return 1\n            , P.tagNoAttr \"success\" $ return 2\n            ]\n        liftIO $ x @?= Just (2 :: Int)\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestManyYield :: Assertion\ntestManyYield = do\n    -- Basically the same as testMany, but consume the streamed result\n    result <- runConduitRes $\n        P.parseLBS def input .| helloParser\n        .| CL.consume\n    length result @?= 5\n  where\n    helloParser = void $ P.tagNoAttr \"hello\" $ P.manyYield successParser\n    successParser = P.tagNoAttr \"success\" $ return ()\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestTakeContent :: Assertion\ntestTakeContent = do\n    result <- runConduitRes $ P.parseLBS def input .| rootParser\n    result @?= Just\n      [ EventContent (ContentText \"Hello world !\")\n      ]\n  where\n    rootParser = P.tagNoAttr \"root\" $ void (P.takeContent >> P.takeContent) .| CL.consume\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<root>\"\n        , \"Hello world !\"\n        , \"</root>\"\n        ]\n\ntestTakeTree :: Assertion\ntestTakeTree = do\n    result <- runConduitRes $ P.parseLBS def input .| rootParser\n    result @?=\n      [ EventBeginDocument\n      , EventBeginDoctype \"foo\" Nothing\n      , EventEndDoctype\n      , EventBeginElement \"a\" []\n      , EventBeginElement \"em\" []\n      , EventContent (ContentText \"Hello world !\")\n      , EventEndElement \"em\"\n      , EventEndElement \"a\"\n      ]\n  where\n    rootParser = void (P.takeTree \"a\" P.ignoreAttrs) .| CL.consume\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<a>\"\n        , \"<em>Hello world !</em>\"\n        , \"</a>\"\n        , \"<b>\"\n        , \"</b>\"\n        ]\n\ntestTakeAnyTreeContent :: Assertion\ntestTakeAnyTreeContent = do\n    result <- runConduitRes $ P.parseLBS def input .| rootParser\n    result @?= Just\n      [ EventBeginElement \"b\" []\n      , EventContent (ContentText \"Hello \")\n      , EventBeginElement \"em\" []\n      , EventContent (ContentText \"world\")\n      , EventEndElement \"em\"\n      , EventContent (ContentText \" !\")\n      , EventEndElement \"b\"\n      ]\n  where\n    rootParser = P.tagNoAttr \"root\" $ (P.takeAnyTreeContent >> void P.ignoreAnyTreeContent) .| CL.consume\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<root>\"\n        , \"<b>Hello <em>world</em> !</b> Welcome !\"\n        , \"</root>\"\n        ]\n\n\ntestMany :: Assertion\ntestMany = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.many $ P.tagNoAttr \"success\" $ return ()\n        liftIO $ length x @?= 5\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestMany' :: Assertion\ntestMany' = runConduitRes $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.many' $ P.tagNoAttr \"success\" $ return ()\n        liftIO $ length x @?= 5\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<success/>\"\n        , \"<foobar/>\"\n        , \"<success/>\"\n        , \"<foo><bar attr=\\\"1\\\">some content</bar></foo>\"\n        , \"<success/>\"\n        , \"</hello>\"\n        ]\n\ntestOrE :: IO ()\ntestOrE = runConduitRes $ runConduit $ P.parseLBS def input .| do\n    P.force \"need hello\" $ P.tagNoAttr \"hello\" $ do\n        x <- P.tagNoAttr \"failure\" (return 1) `P.orE`\n             P.tagNoAttr \"success\" (return 2)\n        y <- P.tag' \"success\" (P.requireAttr \"failure\") (const $ return 1) `P.orE`\n             P.tag' \"success\" (P.requireAttr \"success\") (const $ return 2)\n        liftIO $ x @?= Just (2 :: Int)\n        liftIO $ y @?= Just (2 :: Int)\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<success/>\"\n        , \"<success success=\\\"0\\\"/>\"\n        , \"</hello>\"\n        ]\n\ntestConduitParser :: Assertion\ntestConduitParser = do\n    x <-   runConduitRes\n         $ P.parseLBS def input\n        .| (P.force \"need hello\" $ P.tagNoAttr \"hello\" f)\n        .| CL.consume\n    liftIO $ x @?= [1, 1, 1]\n  where\n    input = L.concat\n        [ \"<?xml version='1.0'?>\"\n        , \"<!DOCTYPE foo []>\\n\"\n        , \"<hello>\"\n        , \"<item/>\"\n        , \"<item/>\"\n        , \"<item/>\"\n        , \"</hello>\"\n        ]\n    f :: C.MonadThrow m => ConduitT Event Int m ()\n    f = do\n        ma <- P.tagNoAttr \"item\" (return 1)\n        maybe (return ()) (\\a -> C.yield a >> f) ma\n\nomitXMLDeclaration :: Assertion\nomitXMLDeclaration = Res.renderLBS settings input @?= spec\n  where\n    settings = def { Res.rsXMLDeclaration = False }\n    input = Res.Document (Prologue [] Nothing [])\n              (Res.Element \"foo\" Map.empty [Res.NodeContent \"bar\"])\n              []\n    spec = \"<foo>bar</foo>\"\n\nhexEntityParsing :: Spec\nhexEntityParsing = do\n  it \"rejects leading 0x\" $\n    go \"<foo>&#x0xff;</foo>\" @?= Nothing\n  it \"rejects leading 0X\" $\n    go \"<foo>&#x0Xff;</foo>\" @?= Nothing\n  it \"accepts lowercase hex digits\" $\n    go \"<foo>&#xff;</foo>\" @?= Just (spec \"\\xff\")\n  it \"accepts uppercase hex digits\" $\n    go \"<foo>&#xFF;</foo>\" @?= Just (spec \"\\xff\")\n  --Note: this must be rejected, because, according to the XML spec, a\n  --legal EntityRef's entity matches Name, which can't start with a\n  --hash.\n  it \"rejects trailing junk\" $\n    go \"<foo>&#xffhello;</foo>\" @?= Nothing\n  --Some of these next tests are XML 1.0 specific (i.e., they would\n  --differ for XML 1.1), but approximately no-one uses XML 1.1.\n  it \"rejects illegal character #x0\" $\n    go \"<foo>&#x0;</foo>\" @?= Nothing\n  it \"rejects illegal character #xFFFE\" $\n    go \"<foo>&#xFFFE;</foo>\" @?= Nothing\n  it \"rejects illegal character #xFFFF\" $\n    go \"<foo>&#xFFFF;</foo>\" @?= Nothing\n  it \"rejects illegal character #xD900\" $\n    go \"<foo>&#xD900;</foo>\" @?= Nothing\n  it \"rejects illegal character #xC\" $\n    go \"<foo>&#xC;</foo>\" @?= Nothing\n  it \"rejects illegal character #x1F\" $\n    go \"<foo>&#x1F;</foo>\" @?= Nothing\n  it \"accepts astral plane character\" $\n    go \"<foo>&#x1006ff;</foo>\" @?= Just (spec \"\\x1006ff\")\n  it \"accepts custom character references\" $\n    go' customSettings \"<foo>&#xC;</foo>\" @?= Just (spec \"\\xff\")\n  where\n    spec content = Document (Prologue [] Nothing [])\n                    (Element \"foo\" [] [NodeContent (ContentText content)])\n                    []\n\n    go = either (const Nothing) Just . D.parseLBS def\n    go' settings = either (const Nothing) Just . D.parseLBS settings\n    customSettings = def { P.psDecodeIllegalCharacters = customDecoder }\n    customDecoder 12 = Just '\\xff'\n    customDecoder _  = Nothing\n\nname :: [Cu.Cursor] -> [Text]\nname [] = []\nname (c:cs) = ($ name cs) $ case Cu.node c of\n                              Res.NodeElement e -> ((Res.nameLocalName $ Res.elementName e) :)\n                              _ -> id\n\ncursor :: Cu.Cursor\ncursor =\n    Cu.fromDocument $ Res.parseLBS_ def input\n  where\n    input = L.concat\n        [ \"<foo attr=\\\"x\\\">\"\n        ,    \"<bar1/>\"\n        ,    \"<bar2>\"\n        ,       \"<baz1/>\"\n        ,       \"<baz2 attr=\\\"y\\\"/>\"\n        ,       \"<baz3>a</baz3>\"\n        ,    \"</bar2>\"\n        ,    \"<bar3>\"\n        ,       \"<bin1/>\"\n        ,       \"b\"\n        ,       \"<bin2/>\"\n        ,       \"<bin3/>\"\n        ,    \"</bar3>\"\n        ,    \"<Bar1 xmlns=\\\"http://example.com\\\" Attr=\\\"q\\\"/>\"\n        , \"</foo>\"\n        ]\n\nbar2, baz2, bar3, bin2 :: Cu.Cursor\nbar2 = Cu.child cursor !! 1\nbaz2 = Cu.child bar2 !! 1\n\nbar3 = Cu.child cursor !! 2\nbin2 = Cu.child bar3 !! 1\n\ncursorParent, cursorAncestor, cursorOrSelf, cursorPreceding, cursorFollowing,\n    cursorPrecedingSib, cursorFollowingSib, cursorDescendant, cursorCheck,\n    cursorPredicate, cursorCheckNode, cursorCheckElement, cursorCheckName,\n    cursorAnyElement, cursorElement, cursorLaxElement, cursorContent,\n    cursorAttribute, cursorLaxAttribute, cursorHasAttribute,\n    cursorAttributeIs, cursorDeep, cursorForce, cursorForceM,\n    resolvedIdentifies, resolvedAllGood, resolvedMergeContent,\n    testHtmlEntities\n    :: Assertion\ncursorParent = name (Cu.parent bar2) @?= [\"foo\"]\ncursorAncestor = name (Cu.ancestor baz2) @?= [\"bar2\", \"foo\"]\ncursorOrSelf = name (Cu.orSelf Cu.ancestor baz2) @?= [\"baz2\", \"bar2\", \"foo\"]\ncursorPreceding = do\n  name (Cu.preceding baz2) @?= [\"baz1\", \"bar1\"]\n  name (Cu.preceding bin2) @?= [\"bin1\", \"baz3\", \"baz2\", \"baz1\", \"bar2\", \"bar1\"]\ncursorFollowing = do\n  name (Cu.following baz2) @?= [\"baz3\", \"bar3\", \"bin1\", \"bin2\", \"bin3\", \"Bar1\"]\n  name (Cu.following bar2) @?= [\"bar3\", \"bin1\", \"bin2\", \"bin3\", \"Bar1\"]\ncursorPrecedingSib = name (Cu.precedingSibling baz2) @?= [\"baz1\"]\ncursorFollowingSib = name (Cu.followingSibling baz2) @?= [\"baz3\"]\ncursorDescendant = (name $ Cu.descendant cursor) @?= T.words \"bar1 bar2 baz1 baz2 baz3 bar3 bin1 bin2 bin3 Bar1\"\ncursorCheck = null (cursor $.// Cu.check (const False)) @?= True\ncursorPredicate = (name $ cursor $.// Cu.check Cu.descendant) @?= T.words \"foo bar2 baz3 bar3\"\ncursorCheckNode = (name $ cursor $// Cu.checkNode f) @?= T.words \"bar1 bar2 bar3\"\n    where f (Res.NodeElement e) = \"bar\" `T.isPrefixOf` Res.nameLocalName (Res.elementName e)\n          f _               = False\ncursorCheckElement = (name $ cursor $// Cu.checkElement f) @?= T.words \"bar1 bar2 bar3\"\n    where f e = \"bar\" `T.isPrefixOf` Res.nameLocalName (Res.elementName e)\ncursorCheckName = (name $ cursor $// Cu.checkName f) @?= T.words \"bar1 bar2 bar3\"\n    where f n = \"bar\" `T.isPrefixOf` nameLocalName n\ncursorAnyElement = (name $ cursor $// Cu.anyElement) @?= T.words \"bar1 bar2 baz1 baz2 baz3 bar3 bin1 bin2 bin3 Bar1\"\ncursorElement = (name $ cursor $// Cu.element \"bar1\") @?= [\"bar1\"]\ncursorLaxElement = (name $ cursor $// Cu.laxElement \"bar1\") @?= [\"bar1\", \"Bar1\"]\ncursorContent = do\n  Cu.content cursor @?= []\n  (cursor $.// Cu.content) @?= [\"a\", \"b\"]\ncursorAttribute = Cu.attribute \"attr\" cursor @?= [\"x\"]\ncursorLaxAttribute = (cursor $.// Cu.laxAttribute \"Attr\") @?= [\"x\", \"y\", \"q\"]\n\ncursorHasAttribute = (length $ cursor $.// Cu.hasAttribute \"attr\") @?= 2\ncursorAttributeIs = (length $ cursor $.// Cu.attributeIs \"attr\" \"y\") @?= 1\n\ncursorDeep = do\n  (Cu.element \"foo\" &/ Cu.element \"bar2\" &// Cu.attribute \"attr\") cursor @?= [\"y\"]\n  (return &.// Cu.attribute \"attr\") cursor @?= [\"x\", \"y\"]\n  (cursor $.// Cu.attribute \"attr\") @?= [\"x\", \"y\"]\n  (cursor $/ Cu.element \"bar2\" &// Cu.attribute \"attr\") @?= [\"y\"]\n  (cursor $/ Cu.element \"bar2\" &/ Cu.element \"baz2\" >=> Cu.attribute \"attr\") @?= [\"y\"]\n  null (cursor $| Cu.element \"foo\") @?= False\ncursorForce = do\n  Cu.force DummyEx [] @?= (Nothing :: Maybe Integer)\n  Cu.force DummyEx [1] @?= Just (1 :: Int)\n  Cu.force DummyEx [1,2] @?= Just (1 :: Int)\ncursorForceM = do\n  Cu.forceM DummyEx [] @?= (Nothing :: Maybe Integer)\n  Cu.forceM DummyEx [Just 1, Nothing] @?= Just (1 :: Int)\n  Cu.forceM DummyEx [Nothing, Just (1 :: Int)] @?= Nothing\n\ndata DummyEx = DummyEx\n    deriving (Show, Typeable)\ninstance Exception DummyEx\n\nshowEq :: (Show a, Show b) => Either a b -> Either a b -> Assertion\nshowEq x y = show x @=? show y\n\nresolvedIdentifies =\n    Left (toException $ Res.UnresolvedEntityException $ Set.fromList [\"foo\", \"bar\", \"baz\"]) `showEq`\n    Res.parseLBS def\n    \"<root attr='&bar;'>&foo; --- &baz; &foo;</root>\"\n\ntestHtmlEntities =\n    Res.parseLBS_ def\n        { P.psDecodeEntities = P.decodeHtmlEntities\n        } xml1 @=? Res.parseLBS_ def xml2\n  where\n    xml1 = \"<root>&nbsp;</root>\"\n    xml2 = \"<root>&#160;</root>\"\n\nresolvedAllGood =\n    D.parseLBS_ def xml @=?\n    Res.toXMLDocument (Res.parseLBS_ def xml)\n  where\n    xml = \"<foo><bar/><baz/></foo>\"\n\nresolvedMergeContent =\n    Res.documentRoot (Res.parseLBS_ def xml) @=?\n    Res.Element \"foo\" Map.empty [Res.NodeContent \"bar&baz\"]\n  where\n    xml = \"<foo>bar&amp;baz</foo>\"\n\nparseIgnoreBOM :: Assertion\nparseIgnoreBOM = do\n    either (const $ Left (1 :: Int)) Right (Res.parseText Res.def \"\\xfeef<foo/>\") @?=\n        either (const $ Left (2 :: Int)) Right (Res.parseText Res.def \"<foo/>\")\n\nstripDuplicateAttributes :: Assertion\nstripDuplicateAttributes = do\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><foo bar=\\\"baz\\\"/>\" @=?\n        D.renderLBS def (Document (Prologue [] Nothing []) (Element \"foo\" [(\"bar\", [ContentText \"baz\"]), (\"bar\", [ContentText \"bin\"])] []) [])\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><foo x:bar=\\\"baz\\\" xmlns:x=\\\"namespace\\\"/>\" @=?\n        D.renderLBS def (Document (Prologue [] Nothing []) (Element \"foo\"\n            [ (\"x:bar\", [ContentText \"baz\"])\n            , (Name \"bar\" (Just \"namespace\") (Just \"x\"), [ContentText \"bin\"])\n            ] []) [])\n\ntestRenderComments :: Assertion\ntestRenderComments =do\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><foo><!--comment--></foo>\"\n        @=? D.renderLBS def (Document (Prologue [] Nothing [])\n            (Element \"foo\" [] [NodeComment \"comment\"]) [])\n\nresolvedInline :: Assertion\nresolvedInline = do\n    Res.Document _ root _ <- return $ Res.parseLBS_ Res.def \"<!DOCTYPE foo [<!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n    Res.Document _ root2 _ <- return $ Res.parseLBS_ Res.def \"<!DOCTYPE foo [<!ENTITY bar \\\"baz\\\">]><foo bar='&bar;'/>\"\n    root2 @?= Res.Element \"foo\" (Map.singleton \"bar\" \"baz\") []\n\nresolvedInlineRecursive :: Assertion\nresolvedInlineRecursive = do\n    Res.Document _ root _ <- return $ Res.parseLBS_ Res.def\n      \"<!DOCTYPE foo [<!ENTITY bim \\\"baz\\\"><!ENTITY bar \\\"&bim;&#73;&amp;\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"bazI&\"]\n\nresolvedInlineLoop :: Assertion\nresolvedInlineLoop = do\n    res <- return $ Res.parseLBS Res.def\n           \"<!DOCTYPE foo [<!ENTITY bim \\\"&bim;\\\">]><foo>&bim;</foo>\"\n    Left (toException $ Res.UnresolvedEntityException (Set.fromList [\"bim\"]))\n      `showEq` res\n\nbillionLaughs :: Assertion\nbillionLaughs = do\n    res <- return $ Res.parseLBS Res.def\n      \"<?xml version=\\\"1.0\\\"?><!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\"><!ELEMENT lolz (#PCDATA)><!ENTITY lol1 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\"><!ENTITY lol2 \\\"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\\\"><!ENTITY lol3 \\\"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\\\"><!ENTITY lol4 \\\"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\\\"><!ENTITY lol5 \\\"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\\\"><!ENTITY lol6 \\\"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\\\"><!ENTITY lol7 \\\"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\\\"><!ENTITY lol8 \\\"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\\\"><!ENTITY lol9 \\\"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\\\">]><lolz>&lol9;</lolz>\"\n    Left (toException $ Res.UnresolvedEntityException (Set.fromList [\"lol9\"]))\n      `showEq` res\n\nthousandLaughs :: Assertion\nthousandLaughs = do\n    res <- return $ Res.parseLBS Res.def{ P.psEntityExpansionSizeLimit = 2999 }\n      \"<?xml version=\\\"1.0\\\"?><!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\"><!ELEMENT lolz (#PCDATA)><!ENTITY lol1 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\"><!ENTITY lol2 \\\"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\\\"><!ENTITY lol3 \\\"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\\\">]><lolz>&lol3;</lolz>\"\n    Left (toException $ Res.UnresolvedEntityException (Set.fromList [\"lol3\"]))\n      `showEq` res\n    -- Raise the entity expansion limit and it should work:\n    Right (Res.Document {Res.documentRoot = Res.Element{ Res.elementNodes = [Res.NodeContent t] }}) <- return $ Res.parseLBS Res.def{ P.psEntityExpansionSizeLimit = 3001 } \"<?xml version=\\\"1.0\\\"?><!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\"><!ELEMENT lolz (#PCDATA)><!ENTITY lol1 \\\"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\\\"><!ENTITY lol2 \\\"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\\\"><!ENTITY lol3 \\\"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\\\">]><lolz>&lol3;</lolz>\"\n    t @?= T.replicate 1000 \"lol\"\n\n\ndoctypeComment :: Assertion\ndoctypeComment = do\n    Res.Document _ root _ <- return $ Res.parseLBS_\n       Res.def \"<!DOCTYPE foo [<!-- [comment] --> <!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n\ndoctypeElements :: Assertion\ndoctypeElements = do\n    Res.Document _ root _ <- return $ Res.parseLBS_\n       Res.def \"<!DOCTYPE foo [<!ELEMENT assessment (#PCDATA)>\\n<!ELEMENT textbooks(author,title)>\\n<!ATTLIST assessment assessment_type (exam | assignment) #IMPLIED>\\n<!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n\ndoctypePI :: Assertion\ndoctypePI = do\n    Res.Document _ root _ <- return $ Res.parseLBS_\n       Res.def \"<!DOCTYPE foo [<?foobar \\\"[baz]\\\"?><!ENTITY bar \\\"baz\\\">]><foo>&bar;</foo>\"\n    root @?= Res.Element \"foo\" Map.empty [Res.NodeContent \"baz\"]\n\ncasePretty :: Assertion\ncasePretty = do\n    let pretty = S.unlines\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<!DOCTYPE foo>\"\n            , \"<foo bar=\\\"bar\\\" baz=\\\"baz\\\">\"\n            , \"    <foo\"\n            , \"      bar=\\\"bar\\\"\"\n            , \"      baz=\\\"baz\\\"\"\n            , \"      bin=\\\"bin\\\">\"\n            , \"        Hello World\"\n            , \"    </foo>\"\n            , \"    <foo/>\"\n            , \"    <?foo bar?>\"\n            , \"    <!-- foo bar baz bin -->\"\n            , \"    <bar>\"\n            , \"        bar content\"\n            , \"    </bar>\"\n            , \"</foo>\"\n            ]\n        doctype = Res.Doctype \"foo\" Nothing\n        doc = Res.Document (Res.Prologue [] (Just doctype) []) root []\n        root = Res.Element \"foo\" (Map.fromList [(\"bar\", \"bar\"), (\"baz\", \"baz\")])\n                [ Res.NodeElement $ Res.Element \"foo\" (Map.fromList [(\"bar\", \"bar\"), (\"baz\", \"baz\"), (\"bin\", \"bin\")])\n                    [ Res.NodeContent \"  Hello World\\n\\n\"\n                    , Res.NodeContent \"  \"\n                    ]\n                , Res.NodeElement $ Res.Element \"foo\" Map.empty []\n                , Res.NodeInstruction $ Res.Instruction \"foo\" \"bar\"\n                , Res.NodeComment \"foo bar\\n\\r\\nbaz    \\tbin \"\n                , Res.NodeElement $ Res.Element \"bar\" Map.empty [Res.NodeContent \"bar content\"]\n                ]\n    pretty @=? S.concat (L.toChunks $ Res.renderLBS def { D.rsPretty = True } doc)\n\ncaseTopLevelNamespace :: Assertion\ncaseTopLevelNamespace = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo xmlns:bar=\\\"baz\\\">\"\n            , \"<subfoo bar:bin=\\\"\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { D.rsNamespaces = [(\"bar\", \"baz\")] }\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" Map.empty\n                    [ Res.NodeElement\n                        $ Res.Element \"subfoo\" (Map.singleton \"{baz}bin\" \"\") []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseTopLevelNamespacePrefix :: Assertion\ncaseTopLevelNamespacePrefix = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo xmlns:bar=\\\"baz\\\">\"\n            , \"<subfoo bar:bin=\\\"\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { D.rsNamespaces = [(\"bar\", \"baz\")] }\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" Map.empty\n                    [ Res.NodeElement\n                        $ Res.Element \"subfoo\" (Map.fromList [(Name \"bin\" (Just \"baz\") (Just \"bar\"), \"\")]) []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseTLNConflict :: Assertion\ncaseTLNConflict = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo xmlns:bar=\\\"something\\\" bar:x=\\\"y\\\">\"\n            , \"<subfoo xmlns:bar_=\\\"baz\\\" bar_:bin=\\\"\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { D.rsNamespaces = [(\"bar\", \"baz\")] }\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" (Map.fromList [(Name \"x\" (Just \"something\") (Just \"bar\"), \"y\")])\n                    [ Res.NodeElement\n                        $ Res.Element \"subfoo\" (Map.fromList [(Name \"bin\" (Just \"baz\") (Just \"bar\"), \"\")]) []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseBlazeHtml :: Assertion\ncaseBlazeHtml =\n    expected @=? str\n  where\n    str = renderMarkup $ toMarkup $ Res.Document (Res.Prologue [] Nothing []) root []\n    root :: Res.Element\n    root = Res.Element \"html\" Map.empty\n        [ Res.NodeElement $ Res.Element \"head\" Map.empty\n            [ Res.NodeElement $ Res.Element \"title\" Map.empty [Res.NodeContent \"Test\"]\n            , Res.NodeElement $ Res.Element \"script\" Map.empty\n                [Res.NodeContent \"if (5 < 6 || 8 > 9) alert('Hello World!');\"]\n            , Res.NodeElement $ Res.Element \"{http://www.snoyman.com/xml2html}ie-cond\" (Map.singleton \"cond\" \"lt IE 7\")\n                [Res.NodeElement $ Res.Element \"link\" (Map.singleton \"href\" \"ie6.css\") []]\n            , Res.NodeElement $ Res.Element \"style\" Map.empty\n                [Res.NodeContent \"body > h1 { color: red }\"]\n            ]\n        , Res.NodeElement $ Res.Element \"body\" Map.empty\n            [ Res.NodeElement $ Res.Element \"h1\" Map.empty [Res.NodeContent \"Hello World!\"]\n            ]\n        ]\n    expected :: String\n    expected = concat\n        [ \"<!DOCTYPE HTML>\\n\"\n        , \"<html><head><title>Test</title><script>if (5 < 6 || 8 > 9) alert('Hello World!');</script>\"\n        , \"<!--[if lt IE 7]><link href=\\\"ie6.css\\\" /><![endif]-->\"\n        , \"<style>body > h1 { color: red }</style>\"\n        , \"</head>\"\n        , \"<body><h1>Hello World!</h1></body></html>\"\n        ]\n\ncaseAttrReorder :: Assertion\ncaseAttrReorder = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo c=\\\"c\\\" b=\\\"b\\\" a=\\\"a\\\">\"\n            , \"<bar a=\\\"a\\\" b=\\\"b\\\" c=\\\"c\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { Res.rsAttrOrder = \\name' m ->\n                        case name' of\n                            \"foo\" -> reverse $ Map.toAscList m\n                            _     -> Map.toAscList m\n                 }\n        attrs = Map.fromList [(\"a\", \"a\"), (\"b\", \"b\"), (\"c\", \"c\")]\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" attrs\n                    [ Res.NodeElement\n                        $ Res.Element \"bar\" attrs []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseOrderAttrs :: Assertion\ncaseOrderAttrs = do\n    let lbs = S.concat\n            [ \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            , \"<foo c=\\\"c\\\" b=\\\"b\\\" a=\\\"a\\\">\"\n            , \"<bar a=\\\"a\\\" b=\\\"b\\\" c=\\\"c\\\"/>\"\n            , \"</foo>\"\n            ]\n        rs = def { Res.rsAttrOrder = Res.orderAttrs\n                     [(\"foo\", [\"c\", \"b\"])]\n                 }\n        attrs = Map.fromList [(\"a\", \"a\"), (\"b\", \"b\"), (\"c\", \"c\")]\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"foo\" attrs\n                    [ Res.NodeElement\n                        $ Res.Element \"bar\" attrs []\n                    ])\n                []\n    lbs @=? S.concat (L.toChunks $ Res.renderLBS rs doc)\n\ncaseParseCdata :: Assertion\ncaseParseCdata = do\n    let lbs = \"<a><![CDATA[www.google.com]]></a>\"\n        doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"a\" Map.empty\n                    [ Res.NodeContent \"www.google.com\"\n                    ])\n                []\n    Res.parseLBS_ def lbs @?= doc\n\ncaseRetainNamespaces :: Assertion\ncaseRetainNamespaces = do\n    let lbs = \"<foo xmlns:bar='baz'><bar:bin/><bin3 xmlns='bin4'></bin3></foo>\"\n        doc = Res.parseLBS_ def { Res.psRetainNamespaces = True } lbs\n    doc `shouldBe` Res.Document\n        (Res.Prologue [] Nothing [])\n        (Res.Element\n            \"foo\"\n            (Map.singleton \"xmlns:bar\" \"baz\")\n            [ Res.NodeElement $ Res.Element\n                \"{baz}bin\"\n                Map.empty\n                []\n            , Res.NodeElement $ Res.Element\n                \"{bin4}bin3\"\n                (Map.singleton \"xmlns\" \"bin4\")\n                []\n            ])\n        []\n\ncaseIso8859_1 :: Assertion\ncaseIso8859_1 = do\n    let lbs = \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?><foo>\\232</foo>\"\n        doc = Res.parseLBS_ def lbs\n    doc `shouldBe` Res.Document\n        (Res.Prologue [] Nothing [])\n        (Res.Element\n            \"foo\"\n            Map.empty\n            [Res.NodeContent \"\\232\"])\n        []\n\ncaseRenderCDATA :: Assertion\ncaseRenderCDATA = do\n    let doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"a\" Map.empty\n                    [ Res.NodeContent \"www.google.com\"\n                    ])\n                []\n        withoutCDATA = Res.renderLBS def doc\n        withCDATA = Res.renderLBS (def { Res.rsUseCDATA = const True }) doc\n    withCDATA `shouldBe` \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><a><![CDATA[www.google.com]]></a>\"\n    withoutCDATA `shouldBe` \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><a>www.google.com</a>\"\n\ncaseEscapesCDATA :: Assertion\ncaseEscapesCDATA = do\n    let doc = Res.Document (Res.Prologue [] Nothing [])\n                (Res.Element \"a\" Map.empty\n                    [ Res.NodeContent \"]]>\"\n                    ])\n                []\n        result = Res.renderLBS (def { Res.rsUseCDATA = const True }) doc\n    result `shouldBe` \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><a><![CDATA[]]]]><![CDATA[>]]></a>\"\n"], "filenames": ["xml-conduit/src/Text/XML/Stream/Parse.hs", "xml-conduit/test/unit.hs"], "buggy_code_start_loc": [83, 83], "buggy_code_end_loc": [559, 738], "fixing_code_start_loc": [84, 84], "fixing_code_end_loc": [597, 774], "type": "CWE-404", "message": "A vulnerability was found in xml-conduit. It has been classified as problematic. Affected is an unknown function of the file xml-conduit/src/Text/XML/Stream/Parse.hs of the component DOCTYPE Entity Expansion Handler. The manipulation leads to infinite loop. It is possible to launch the attack remotely. Upgrading to version 1.9.1.0 is able to address this issue. The name of the patch is 4be1021791dcdee8b164d239433a2043dc0939ea. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216204.", "other": {"cve": {"id": "CVE-2021-4249", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-18T15:15:10.063", "lastModified": "2022-12-22T19:07:01.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in xml-conduit. It has been classified as problematic. Affected is an unknown function of the file xml-conduit/src/Text/XML/Stream/Parse.hs of the component DOCTYPE Entity Expansion Handler. The manipulation leads to infinite loop. It is possible to launch the attack remotely. Upgrading to version 1.9.1.0 is able to address this issue. The name of the patch is 4be1021791dcdee8b164d239433a2043dc0939ea. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216204."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}, {"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haskell:xml-conduit:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.1.0", "matchCriteriaId": "2488D85F-FD7C-4C41-A242-A40FA1983833"}]}]}], "references": [{"url": "https://github.com/snoyberg/xml/commit/4be1021791dcdee8b164d239433a2043dc0939ea", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/snoyberg/xml/pull/161", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackage.haskell.org/package/xml-conduit-1.9.1.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://vuldb.com/?id.216204", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/snoyberg/xml/commit/4be1021791dcdee8b164d239433a2043dc0939ea"}}