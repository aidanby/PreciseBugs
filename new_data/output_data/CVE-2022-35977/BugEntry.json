{"buggy_code": ["/* SORT command and helper functions.\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include \"server.h\"\n#include \"pqsort.h\" /* Partial qsort for SORT+LIMIT */\n#include <math.h> /* isnan() */\n\nzskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);\n\nredisSortOperation *createSortOperation(int type, robj *pattern) {\n    redisSortOperation *so = zmalloc(sizeof(*so));\n    so->type = type;\n    so->pattern = pattern;\n    return so;\n}\n\n/* Return the value associated to the key with a name obtained using\n * the following rules:\n *\n * 1) The first occurrence of '*' in 'pattern' is substituted with 'subst'.\n *\n * 2) If 'pattern' matches the \"->\" string, everything on the left of\n *    the arrow is treated as the name of a hash field, and the part on the\n *    left as the key name containing a hash. The value of the specified\n *    field is returned.\n *\n * 3) If 'pattern' equals \"#\", the function simply returns 'subst' itself so\n *    that the SORT command can be used like: SORT key GET # to retrieve\n *    the Set/List elements directly.\n *\n * The returned object will always have its refcount increased by 1\n * when it is non-NULL. */\nrobj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {\n    char *p, *f, *k;\n    sds spat, ssub;\n    robj *keyobj, *fieldobj = NULL, *o;\n    int prefixlen, sublen, postfixlen, fieldlen;\n\n    /* If the pattern is \"#\" return the substitution object itself in order\n     * to implement the \"SORT ... GET #\" feature. */\n    spat = pattern->ptr;\n    if (spat[0] == '#' && spat[1] == '\\0') {\n        incrRefCount(subst);\n        return subst;\n    }\n\n    /* The substitution object may be specially encoded. If so we create\n     * a decoded object on the fly. Otherwise getDecodedObject will just\n     * increment the ref count, that we'll decrement later. */\n    subst = getDecodedObject(subst);\n    ssub = subst->ptr;\n\n    /* If we can't find '*' in the pattern we return NULL as to GET a\n     * fixed key does not make sense. */\n    p = strchr(spat,'*');\n    if (!p) {\n        decrRefCount(subst);\n        return NULL;\n    }\n\n    /* Find out if we're dealing with a hash dereference. */\n    if ((f = strstr(p+1, \"->\")) != NULL && *(f+2) != '\\0') {\n        fieldlen = sdslen(spat)-(f-spat)-2;\n        fieldobj = createStringObject(f+2,fieldlen);\n    } else {\n        fieldlen = 0;\n    }\n\n    /* Perform the '*' substitution. */\n    prefixlen = p-spat;\n    sublen = sdslen(ssub);\n    postfixlen = sdslen(spat)-(prefixlen+1)-(fieldlen ? fieldlen+2 : 0);\n    keyobj = createStringObject(NULL,prefixlen+sublen+postfixlen);\n    k = keyobj->ptr;\n    memcpy(k,spat,prefixlen);\n    memcpy(k+prefixlen,ssub,sublen);\n    memcpy(k+prefixlen+sublen,p+1,postfixlen);\n    decrRefCount(subst); /* Incremented by decodeObject() */\n\n    /* Lookup substituted key */\n    o = lookupKeyRead(db, keyobj);\n    if (o == NULL) goto noobj;\n\n    if (fieldobj) {\n        if (o->type != OBJ_HASH) goto noobj;\n\n        /* Retrieve value from hash by the field name. The returned object\n         * is a new object with refcount already incremented. */\n        o = hashTypeGetValueObject(o, fieldobj->ptr);\n    } else {\n        if (o->type != OBJ_STRING) goto noobj;\n\n        /* Every object that this function returns needs to have its refcount\n         * increased. sortCommand decreases it again. */\n        incrRefCount(o);\n    }\n    decrRefCount(keyobj);\n    if (fieldobj) decrRefCount(fieldobj);\n    return o;\n\nnoobj:\n    decrRefCount(keyobj);\n    if (fieldlen) decrRefCount(fieldobj);\n    return NULL;\n}\n\n/* sortCompare() is used by qsort in sortCommand(). Given that qsort_r with\n * the additional parameter is not standard but a BSD-specific we have to\n * pass sorting parameters via the global 'server' structure */\nint sortCompare(const void *s1, const void *s2) {\n    const redisSortObject *so1 = s1, *so2 = s2;\n    int cmp;\n\n    if (!server.sort_alpha) {\n        /* Numeric sorting. Here it's trivial as we precomputed scores */\n        if (so1->u.score > so2->u.score) {\n            cmp = 1;\n        } else if (so1->u.score < so2->u.score) {\n            cmp = -1;\n        } else {\n            /* Objects have the same score, but we don't want the comparison\n             * to be undefined, so we compare objects lexicographically.\n             * This way the result of SORT is deterministic. */\n            cmp = compareStringObjects(so1->obj,so2->obj);\n        }\n    } else {\n        /* Alphanumeric sorting */\n        if (server.sort_bypattern) {\n            if (!so1->u.cmpobj || !so2->u.cmpobj) {\n                /* At least one compare object is NULL */\n                if (so1->u.cmpobj == so2->u.cmpobj)\n                    cmp = 0;\n                else if (so1->u.cmpobj == NULL)\n                    cmp = -1;\n                else\n                    cmp = 1;\n            } else {\n                /* We have both the objects, compare them. */\n                if (server.sort_store) {\n                    cmp = compareStringObjects(so1->u.cmpobj,so2->u.cmpobj);\n                } else {\n                    /* Here we can use strcoll() directly as we are sure that\n                     * the objects are decoded string objects. */\n                    cmp = strcoll(so1->u.cmpobj->ptr,so2->u.cmpobj->ptr);\n                }\n            }\n        } else {\n            /* Compare elements directly. */\n            if (server.sort_store) {\n                cmp = compareStringObjects(so1->obj,so2->obj);\n            } else {\n                cmp = collateStringObjects(so1->obj,so2->obj);\n            }\n        }\n    }\n    return server.sort_desc ? -cmp : cmp;\n}\n\n/* The SORT command is the most complex command in Redis. Warning: this code\n * is optimized for speed and a bit less for readability */\nvoid sortCommandGeneric(client *c, int readonly) {\n    list *operations;\n    unsigned int outputlen = 0;\n    int desc = 0, alpha = 0;\n    long limit_start = 0, limit_count = -1, start, end;\n    int j, dontsort = 0, vectorlen;\n    int getop = 0; /* GET operation counter */\n    int int_conversion_error = 0;\n    int syntax_error = 0;\n    robj *sortval, *sortby = NULL, *storekey = NULL;\n    redisSortObject *vector; /* Resulting vector to sort */\n    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */\n    /* Create a list of operations to perform for every sorted element.\n     * Operations can be GET */\n    operations = listCreate();\n    listSetFreeMethod(operations,zfree);\n    j = 2; /* options start at argv[2] */\n\n    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);\n\n    /* The SORT command has an SQL-alike syntax, parse it */\n    while(j < c->argc) {\n        int leftargs = c->argc-j-1;\n        if (!strcasecmp(c->argv[j]->ptr,\"asc\")) {\n            desc = 0;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"desc\")) {\n            desc = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"alpha\")) {\n            alpha = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"limit\") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)\n                 != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)\n                 != C_OK))\n            {\n                syntax_error++;\n                break;\n            }\n            j+=2;\n        } else if (readonly == 0 && !strcasecmp(c->argv[j]->ptr,\"store\") && leftargs >= 1) {\n            storekey = c->argv[j+1];\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"by\") && leftargs >= 1) {\n            sortby = c->argv[j+1];\n            /* If the BY pattern does not contain '*', i.e. it is constant,\n             * we don't need to sort nor to lookup the weight keys. */\n            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {\n                dontsort = 1;\n            } else {\n                /* If BY is specified with a real pattern, we can't accept\n                 * it in cluster mode. */\n                if (server.cluster_enabled) {\n                    addReplyError(c,\"BY option of SORT denied in Cluster mode.\");\n                    syntax_error++;\n                    break;\n                }\n                /* If BY is specified with a real pattern, we can't accept\n                 * it if no full ACL key access is applied for this command. */\n                if (!user_has_full_key_access) {\n                    addReplyError(c,\"BY option of SORT denied due to insufficient ACL permissions.\");\n                    syntax_error++;\n                    break;\n                }\n            }\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"get\") && leftargs >= 1) {\n            if (server.cluster_enabled) {\n                addReplyError(c,\"GET option of SORT denied in Cluster mode.\");\n                syntax_error++;\n                break;\n            }\n            if (!user_has_full_key_access) {\n                addReplyError(c,\"GET option of SORT denied due to insufficient ACL permissions.\");\n                syntax_error++;\n                break;\n            }\n            listAddNodeTail(operations,createSortOperation(\n                SORT_OP_GET,c->argv[j+1]));\n            getop++;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            syntax_error++;\n            break;\n        }\n        j++;\n    }\n\n    /* Handle syntax errors set during options parsing. */\n    if (syntax_error) {\n        listRelease(operations);\n        return;\n    }\n\n    /* Lookup the key to sort. It must be of the right types */\n    sortval = lookupKeyRead(c->db, c->argv[1]);\n    if (sortval && sortval->type != OBJ_SET &&\n                   sortval->type != OBJ_LIST &&\n                   sortval->type != OBJ_ZSET)\n    {\n        listRelease(operations);\n        addReplyErrorObject(c,shared.wrongtypeerr);\n        return;\n    }\n\n    /* Now we need to protect sortval incrementing its count, in the future\n     * SORT may have options able to overwrite/delete keys during the sorting\n     * and the sorted key itself may get destroyed */\n    if (sortval)\n        incrRefCount(sortval);\n    else\n        sortval = createQuicklistObject();\n\n\n    /* When sorting a set with no sort specified, we must sort the output\n     * so the result is consistent across scripting and replication.\n     *\n     * The other types (list, sorted set) will retain their native order\n     * even if no sort order is requested, so they remain stable across\n     * scripting and replication. */\n    if (dontsort &&\n        sortval->type == OBJ_SET &&\n        (storekey || c->flags & CLIENT_SCRIPT))\n    {\n        /* Force ALPHA sorting */\n        dontsort = 0;\n        alpha = 1;\n        sortby = NULL;\n    }\n\n    /* Destructively convert encoded sorted sets for SORT. */\n    if (sortval->type == OBJ_ZSET)\n        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);\n\n    /* Obtain the length of the object to sort. */\n    switch(sortval->type) {\n    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;\n    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;\n    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;\n    default: vectorlen = 0; serverPanic(\"Bad SORT type\"); /* Avoid GCC warning */\n    }\n\n    /* Perform LIMIT start,count sanity checking. */\n    start = (limit_start < 0) ? 0 : limit_start;\n    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n    if (start >= vectorlen) {\n        start = vectorlen-1;\n        end = vectorlen-2;\n    }\n    if (end >= vectorlen) end = vectorlen-1;\n\n    /* Whenever possible, we load elements into the output array in a more\n     * direct way. This is possible if:\n     *\n     * 1) The object to sort is a sorted set or a list (internally sorted).\n     * 2) There is nothing to sort as dontsort is true (BY <constant string>).\n     *\n     * In this special case, if we have a LIMIT option that actually reduces\n     * the number of elements to fetch, we also optimize to just load the\n     * range we are interested in and allocating a vector that is big enough\n     * for the selected range length. */\n    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&\n        dontsort &&\n        (start != 0 || end != vectorlen-1))\n    {\n        vectorlen = end-start+1;\n    }\n\n    /* Load the sorting vector with all the objects to sort */\n    vector = zmalloc(sizeof(redisSortObject)*vectorlen);\n    j = 0;\n\n    if (sortval->type == OBJ_LIST && dontsort) {\n        /* Special handling for a list, if 'dontsort' is true.\n         * This makes sure we return elements in the list original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n        if (end >= start) {\n            listTypeIterator *li;\n            listTypeEntry entry;\n            li = listTypeInitIterator(sortval,\n                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,\n                    desc ? LIST_HEAD : LIST_TAIL);\n\n            while(j < vectorlen && listTypeNext(li,&entry)) {\n                vector[j].obj = listTypeGet(&entry);\n                vector[j].u.score = 0;\n                vector[j].u.cmpobj = NULL;\n                j++;\n            }\n            listTypeReleaseIterator(li);\n            /* Fix start/end: output code is not aware of this optimization. */\n            end -= start;\n            start = 0;\n        }\n    } else if (sortval->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            vector[j].obj = listTypeGet(&entry);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        listTypeReleaseIterator(li);\n    } else if (sortval->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(sortval);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            vector[j].obj = createObject(OBJ_STRING,sdsele);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        setTypeReleaseIterator(si);\n    } else if (sortval->type == OBJ_ZSET && dontsort) {\n        /* Special handling for a sorted set, if 'dontsort' is true.\n         * This makes sure we return elements in the sorted set original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n\n        zset *zs = sortval->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds sdsele;\n        int rangelen = vectorlen;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (desc) {\n            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);\n\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,zsetlen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,sortval,ln != NULL);\n            sdsele = ln->ele;\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n            ln = desc ? ln->backward : ln->level[0].forward;\n        }\n        /* Fix start/end: output code is not aware of this optimization. */\n        end -= start;\n        start = 0;\n    } else if (sortval->type == OBJ_ZSET) {\n        dict *set = ((zset*)sortval->ptr)->dict;\n        dictIterator *di;\n        dictEntry *setele;\n        sds sdsele;\n        di = dictGetIterator(set);\n        while((setele = dictNext(di)) != NULL) {\n            sdsele =  dictGetKey(setele);\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        dictReleaseIterator(di);\n    } else {\n        serverPanic(\"Unknown type\");\n    }\n    serverAssertWithInfo(c,sortval,j == vectorlen);\n\n    /* Now it's time to load the right scores in the sorting vector */\n    if (!dontsort) {\n        for (j = 0; j < vectorlen; j++) {\n            robj *byval;\n            if (sortby) {\n                /* lookup value to sort by */\n                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);\n                if (!byval) continue;\n            } else {\n                /* use object itself to sort by */\n                byval = vector[j].obj;\n            }\n\n            if (alpha) {\n                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);\n            } else {\n                if (sdsEncodedObject(byval)) {\n                    char *eptr;\n\n                    vector[j].u.score = strtod(byval->ptr,&eptr);\n                    if (eptr[0] != '\\0' || errno == ERANGE ||\n                        isnan(vector[j].u.score))\n                    {\n                        int_conversion_error = 1;\n                    }\n                } else if (byval->encoding == OBJ_ENCODING_INT) {\n                    /* Don't need to decode the object if it's\n                     * integer-encoded (the only encoding supported) so\n                     * far. We can just cast it */\n                    vector[j].u.score = (long)byval->ptr;\n                } else {\n                    serverAssertWithInfo(c,sortval,1 != 1);\n                }\n            }\n\n            /* when the object was retrieved using lookupKeyByPattern,\n             * its refcount needs to be decreased. */\n            if (sortby) {\n                decrRefCount(byval);\n            }\n        }\n\n        server.sort_desc = desc;\n        server.sort_alpha = alpha;\n        server.sort_bypattern = sortby ? 1 : 0;\n        server.sort_store = storekey ? 1 : 0;\n        if (sortby && (start != 0 || end != vectorlen-1))\n            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);\n        else\n            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);\n    }\n\n    /* Send command output to the output buffer, performing the specified\n     * GET/DEL/INCR/DECR operations if any. */\n    outputlen = getop ? getop*(end-start+1) : end-start+1;\n    if (int_conversion_error) {\n        addReplyError(c,\"One or more scores can't be converted into double\");\n    } else if (storekey == NULL) {\n        /* STORE option not specified, sent the sorting result to client */\n        addReplyArrayLen(c,outputlen);\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) addReplyBulk(c,vector[j].obj);\n            listRewind(operations,&li);\n            while((ln = listNext(&li))) {\n                redisSortOperation *sop = ln->value;\n                robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                               vector[j].obj);\n\n                if (sop->type == SORT_OP_GET) {\n                    if (!val) {\n                        addReplyNull(c);\n                    } else {\n                        addReplyBulk(c,val);\n                        decrRefCount(val);\n                    }\n                } else {\n                    /* Always fails */\n                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                }\n            }\n        }\n    } else {\n        /* We can't predict the size and encoding of the stored list, we\n         * assume it's a large list and then convert it at the end if needed. */\n        robj *sobj = createQuicklistObject();\n\n        /* STORE option specified, set the sorting result as a List object */\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) {\n                listTypePush(sobj,vector[j].obj,LIST_TAIL);\n            } else {\n                listRewind(operations,&li);\n                while((ln = listNext(&li))) {\n                    redisSortOperation *sop = ln->value;\n                    robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                                   vector[j].obj);\n\n                    if (sop->type == SORT_OP_GET) {\n                        if (!val) val = createStringObject(\"\",0);\n\n                        /* listTypePush does an incrRefCount, so we should take care\n                         * care of the incremented refcount caused by either\n                         * lookupKeyByPattern or createStringObject(\"\",0) */\n                        listTypePush(sobj,val,LIST_TAIL);\n                        decrRefCount(val);\n                    } else {\n                        /* Always fails */\n                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                    }\n                }\n            }\n        }\n        if (outputlen) {\n            listTypeTryConversion(sobj,LIST_CONV_AUTO,NULL,NULL);\n            setKey(c,c->db,storekey,sobj,0);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"sortstore\",storekey,\n                                c->db->id);\n            server.dirty += outputlen;\n        } else if (dbDelete(c->db,storekey)) {\n            signalModifiedKey(c,c->db,storekey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",storekey,c->db->id);\n            server.dirty++;\n        }\n        decrRefCount(sobj);\n        addReplyLongLong(c,outputlen);\n    }\n\n    /* Cleanup */\n    for (j = 0; j < vectorlen; j++)\n        decrRefCount(vector[j].obj);\n\n    decrRefCount(sortval);\n    listRelease(operations);\n    for (j = 0; j < vectorlen; j++) {\n        if (alpha && vector[j].u.cmpobj)\n            decrRefCount(vector[j].u.cmpobj);\n    }\n    zfree(vector);\n}\n\n/* SORT wrapper function for read-only mode. */\nvoid sortroCommand(client *c) {\n    sortCommandGeneric(c, 1);\n}\n\nvoid sortCommand(client *c) {\n    sortCommandGeneric(c, 0);\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h> /* isnan(), isinf() */\n\n/* Forward declarations */\nint getGenericCommand(client *c);\n\n/*-----------------------------------------------------------------------------\n * String Commands\n *----------------------------------------------------------------------------*/\n\nstatic int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}\n\n/* The setGenericCommand() function implements the SET operation with different\n * options and variants. This function is called in order to implement the\n * following commands: SET, SETEX, PSETEX, SETNX, GETSET.\n *\n * 'flags' changes the behavior of the command (NX, XX or GET, see below).\n *\n * 'expire' represents an expire to set in form of a Redis object as passed\n * by the user. It is interpreted according to the specified 'unit'.\n *\n * 'ok_reply' and 'abort_reply' is what the function will reply to the client\n * if the operation is performed, or when it is not because of NX or\n * XX flags.\n *\n * If ok_reply is NULL \"+OK\" is used.\n * If abort_reply is NULL, \"$-1\" is used. */\n\n#define OBJ_NO_FLAGS 0\n#define OBJ_SET_NX (1<<0)          /* Set if key not exists. */\n#define OBJ_SET_XX (1<<1)          /* Set if key exists. */\n#define OBJ_EX (1<<2)              /* Set if time in seconds is given */\n#define OBJ_PX (1<<3)              /* Set if time in ms in given */\n#define OBJ_KEEPTTL (1<<4)         /* Set and keep the ttl */\n#define OBJ_SET_GET (1<<5)         /* Set if want to get key before set */\n#define OBJ_EXAT (1<<6)            /* Set if timestamp in second is given */\n#define OBJ_PXAT (1<<7)            /* Set if timestamp in ms is given */\n#define OBJ_PERSIST (1<<8)         /* Set if we need to remove the ttl */\n\n/* Forward declaration */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds);\n\nvoid setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {\n    long long milliseconds = 0; /* initialized to avoid any harmness warning */\n    int found = 0;\n    int setkey_flags = 0;\n\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    if (flags & OBJ_SET_GET) {\n        if (getGenericCommand(c) == C_ERR) return;\n    }\n\n    found = (lookupKeyWrite(c->db,key) != NULL);\n\n    if ((flags & OBJ_SET_NX && found) ||\n        (flags & OBJ_SET_XX && !found))\n    {\n        if (!(flags & OBJ_SET_GET)) {\n            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);\n        }\n        return;\n    }\n\n    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */\n    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;\n    setkey_flags |= found ? SETKEY_ALREADY_EXIST : SETKEY_DOESNT_EXIST;\n\n    setKey(c,c->db,key,val,setkey_flags);\n    server.dirty++;\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",key,c->db->id);\n\n    if (expire) {\n        setExpire(c,c->db,key,milliseconds);\n        /* Propagate as SET Key Value PXAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c, 5, shared.set, key, val, shared.pxat, milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",key,c->db->id);\n    }\n\n    if (!(flags & OBJ_SET_GET)) {\n        addReply(c, ok_reply ? ok_reply : shared.ok);\n    }\n\n    /* Propagate without the GET argument (Isn't needed if we had expire since in that case we completely re-written the command argv) */\n    if ((flags & OBJ_SET_GET) && !expire) {\n        int argc = 0;\n        int j;\n        robj **argv = zmalloc((c->argc-1)*sizeof(robj*));\n        for (j=0; j < c->argc; j++) {\n            char *a = c->argv[j]->ptr;\n            /* Skip GET which may be repeated multiple times. */\n            if (j >= 3 &&\n                (a[0] == 'g' || a[0] == 'G') &&\n                (a[1] == 'e' || a[1] == 'E') &&\n                (a[2] == 't' || a[2] == 'T') && a[3] == '\\0')\n                continue;\n            argv[argc++] = c->argv[j];\n            incrRefCount(c->argv[j]);\n        }\n        replaceClientCommandVector(c, argc, argv);\n    }\n}\n\n/*\n * Extract the `expire` argument of a given GET/SET command as an absolute timestamp in milliseconds.\n *\n * \"client\" is the client that sent the `expire` argument.\n * \"expire\" is the `expire` argument to be extracted.\n * \"flags\" represents the behavior of the command (e.g. PX or EX).\n * \"unit\" is the original unit of the given `expire` argument (e.g. UNIT_SECONDS).\n * \"milliseconds\" is output argument.\n *\n * If return C_OK, \"milliseconds\" output argument will be set to the resulting absolute timestamp.\n * If return C_ERR, an error reply has been added to the given client.\n */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {\n    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);\n    if (ret != C_OK) {\n        return ret;\n    }\n\n    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {\n        /* Negative value provided or multiplication is gonna overflow. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    if (unit == UNIT_SECONDS) *milliseconds *= 1000;\n\n    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {\n        *milliseconds += commandTimeSnapshot();\n    }\n\n    if (*milliseconds <= 0) {\n        /* Overflow detected. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    return C_OK;\n}\n\n#define COMMAND_GET 0\n#define COMMAND_SET 1\n/*\n * The parseExtendedStringArgumentsOrReply() function performs the common validation for extended\n * string arguments used in SET and GET command.\n *\n * Get specific commands - PERSIST/DEL\n * Set specific commands - XX/NX/GET\n * Common commands - EX/EXAT/PX/PXAT/KEEPTTL\n *\n * Function takes pointers to client, flags, unit, pointer to pointer of expire obj if needed\n * to be determined and command_type which can be COMMAND_GET or COMMAND_SET.\n *\n * If there are any syntax violations C_ERR is returned else C_OK is returned.\n *\n * Input flags are updated upon parsing the arguments. Unit and expire are updated if there are any\n * EX/EXAT/PX/PXAT arguments. Unit is updated to millisecond if PX/PXAT is set.\n */\nint parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {\n\n    int j = command_type == COMMAND_GET ? 2 : 3;\n    for (; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];\n\n        if ((opt[0] == 'n' || opt[0] == 'N') &&\n            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_NX;\n        } else if ((opt[0] == 'x' || opt[0] == 'X') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_XX;\n        } else if ((opt[0] == 'g' || opt[0] == 'G') &&\n                   (opt[1] == 'e' || opt[1] == 'E') &&\n                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\\0' &&\n                   (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_GET;\n        } else if (!strcasecmp(opt, \"KEEPTTL\") && !(*flags & OBJ_PERSIST) &&\n            !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n            !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_KEEPTTL;\n        } else if (!strcasecmp(opt,\"PERSIST\") && (command_type == COMMAND_GET) &&\n               !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n               !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) &&\n               !(*flags & OBJ_KEEPTTL))\n        {\n            *flags |= OBJ_PERSIST;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EXAT) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EX;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_PX;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EXAT;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PX) && next)\n        {\n            *flags |= OBJ_PXAT;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* SET key value [NX] [XX] [KEEPTTL] [GET] [EX <seconds>] [PX <milliseconds>]\n *     [EXAT <seconds-timestamp>][PXAT <milliseconds-timestamp>] */\nvoid setCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {\n        return;\n    }\n\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}\n\nvoid setnxCommand(client *c) {\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);\n}\n\nvoid setexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_EX,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);\n}\n\nvoid psetexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_PX,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);\n}\n\nint getGenericCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return C_OK;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return C_ERR;\n    }\n\n    addReplyBulk(c,o);\n    return C_OK;\n}\n\nvoid getCommand(client *c) {\n    getGenericCommand(c);\n}\n\n/*\n * GETEX <key> [PERSIST][EX seconds][PX milliseconds][EXAT seconds-timestamp][PXAT milliseconds-timestamp]\n *\n * The getexCommand() function implements extended options and variants of the GET command. Unlike GET\n * command this command is not read-only.\n *\n * The default behavior when no options are specified is same as GET and does not alter any TTL.\n *\n * Only one of the below options can be used at a given time.\n *\n * 1. PERSIST removes any TTL associated with the key.\n * 2. EX Set expiry TTL in seconds.\n * 3. PX Set expiry TTL in milliseconds.\n * 4. EXAT Same like EX instead of specifying the number of seconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n * 5. PXAT Same like PX instead of specifying the number of milliseconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n *\n * Command would either return the bulk string, error or nil.\n */\nvoid getexCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_GET) != C_OK) {\n        return;\n    }\n\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return;\n    }\n\n    /* Validate the expiration time value first */\n    long long milliseconds = 0;\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    /* We need to do this before we expire the key or delete it */\n    addReplyBulk(c,o);\n\n    /* This command is never propagated as is. It is either propagated as PEXPIRE[AT],DEL,UNLINK or PERSIST.\n     * This why it doesn't need special handling in feedAppendOnlyFile to convert relative expire time to absolute one. */\n    if (((flags & OBJ_PXAT) || (flags & OBJ_EXAT)) && checkAlreadyExpired(milliseconds)) {\n        /* When PXAT/EXAT absolute timestamp is specified, there can be a chance that timestamp\n         * has already elapsed so delete the key in that case. */\n        int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c->db, c->argv[1]) :\n                      dbSyncDelete(c->db, c->argv[1]);\n        serverAssert(deleted);\n        robj *aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;\n        rewriteClientCommandVector(c,2,aux,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    } else if (expire) {\n        setExpire(c,c->db,c->argv[1],milliseconds);\n        /* Propagate as PXEXPIREAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag and the key has not expired. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c,3,shared.pexpireat,c->argv[1],milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",c->argv[1],c->db->id);\n        server.dirty++;\n    } else if (flags & OBJ_PERSIST) {\n        if (removeExpire(c->db, c->argv[1])) {\n            signalModifiedKey(c, c->db, c->argv[1]);\n            rewriteClientCommandVector(c, 2, shared.persist, c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"persist\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    }\n}\n\nvoid getdelCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    if (dbSyncDelete(c->db, c->argv[1])) {\n        /* Propagate as DEL command */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid getsetCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setKey(c,c->db,c->argv[1],c->argv[2],0);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Propagate as SET command */\n    rewriteClientCommandArgument(c,0,shared.set);\n}\n\nvoid setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}\n\nvoid getrangeCommand(client *c) {\n    robj *o;\n    long long start, end;\n    char *str, llbuf[32];\n    size_t strlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)\n        return;\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)\n        return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n\n    if (o->encoding == OBJ_ENCODING_INT) {\n        str = llbuf;\n        strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);\n    } else {\n        str = o->ptr;\n        strlen = sdslen(str);\n    }\n\n    /* Convert negative indexes */\n    if (start < 0 && end < 0 && start > end) {\n        addReply(c,shared.emptybulk);\n        return;\n    }\n    if (start < 0) start = strlen+start;\n    if (end < 0) end = strlen+end;\n    if (start < 0) start = 0;\n    if (end < 0) end = 0;\n    if ((unsigned long long)end >= strlen) end = strlen-1;\n\n    /* Precondition: end >= 0 && end < strlen, so the only condition where\n     * nothing can be returned is: start > end. */\n    if (start > end || strlen == 0) {\n        addReply(c,shared.emptybulk);\n    } else {\n        addReplyBulkCBuffer(c,(char*)str+start,end-start+1);\n    }\n}\n\nvoid mgetCommand(client *c) {\n    int j;\n\n    addReplyArrayLen(c,c->argc-1);\n    for (j = 1; j < c->argc; j++) {\n        robj *o = lookupKeyRead(c->db,c->argv[j]);\n        if (o == NULL) {\n            addReplyNull(c);\n        } else {\n            if (o->type != OBJ_STRING) {\n                addReplyNull(c);\n            } else {\n                addReplyBulk(c,o);\n            }\n        }\n    }\n}\n\nvoid msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}\n\nvoid msetCommand(client *c) {\n    msetGenericCommand(c,0);\n}\n\nvoid msetnxCommand(client *c) {\n    msetGenericCommand(c,1);\n}\n\nvoid incrDecrCommand(client *c, long long incr) {\n    long long value, oldvalue;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n\n    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&\n        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&\n        value >= LONG_MIN && value <= LONG_MAX)\n    {\n        new = o;\n        o->ptr = (void*)((long)value);\n    } else {\n        new = createStringObjectFromLongLongForValue(value);\n        if (o) {\n            dbReplaceValue(c->db,c->argv[1],new);\n        } else {\n            dbAdd(c->db,c->argv[1],new);\n        }\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrby\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c, value);\n}\n\nvoid incrCommand(client *c) {\n    incrDecrCommand(c,1);\n}\n\nvoid decrCommand(client *c) {\n    incrDecrCommand(c,-1);\n}\n\nvoid incrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    incrDecrCommand(c,incr);\n}\n\nvoid decrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    /* Overflow check: negating LLONG_MIN will cause an overflow */\n    if (incr == LLONG_MIN) {\n        addReplyError(c, \"decrement would overflow\");\n        return;\n    }\n    incrDecrCommand(c,-incr);\n}\n\nvoid incrbyfloatCommand(client *c) {\n    long double incr, value;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||\n        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)\n        return;\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    new = createStringObjectFromLongDouble(value,1);\n    if (o)\n        dbReplaceValue(c->db,c->argv[1],new);\n    else\n        dbAdd(c->db,c->argv[1],new);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyBulk(c,new);\n\n    /* Always replicate INCRBYFLOAT as a SET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    rewriteClientCommandArgument(c,0,shared.set);\n    rewriteClientCommandArgument(c,2,new);\n    rewriteClientCommandArgument(c,3,shared.keepttl);\n}\n\nvoid appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}\n\nvoid strlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n    addReplyLongLong(c,stringObjectLen(o));\n}\n\n/* LCS key1 key2 [LEN] [IDX] [MINMATCHLEN <len>] [WITHMATCHLEN] */\nvoid lcsCommand(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    obja = lookupKeyRead(c->db,c->argv[1]);\n    objb = lookupKeyRead(c->db,c->argv[2]);\n    if ((obja && obja->type != OBJ_STRING) ||\n        (objb && objb->type != OBJ_STRING))\n    {\n        addReplyError(c,\n            \"The specified keys must contain string values\");\n        /* Don't cleanup the objects, we need to do that\n         * only after calling getDecodedObject(). */\n        obja = NULL;\n        objb = NULL;\n        goto cleanup;\n    }\n    obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n    objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n    a = obja->ptr;\n    b = objb->ptr;\n\n    for (j = 3; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Detect string truncation or later overflows. */\n    if (sdslen(a) >= UINT32_MAX-1 || sdslen(b) >= UINT32_MAX-1) {\n        addReplyError(c, \"String too long for LCS\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*i] */\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Try to allocate the LCS table, and abort on overflow or insufficient memory. */\n    unsigned long long lcssize = (unsigned long long)(alen+1)*(blen+1); /* Can't overflow due to the size limits above. */\n    unsigned long long lcsalloc = lcssize * sizeof(uint32_t);\n    uint32_t *lcs = NULL;\n    if (lcsalloc < SIZE_MAX && lcsalloc / lcssize == sizeof(uint32_t)) {\n        if (lcsalloc > (size_t)server.proto_max_bulk_len) {\n            addReplyError(c, \"Insufficient memory, transient memory for LCS exceeds proto-max-bulk-len\");\n            goto cleanup;\n        }\n        lcs = ztrymalloc(lcsalloc);\n    }\n    if (!lcs) {\n        addReplyError(c, \"Insufficient memory, failed allocating transient memory for LCS\");\n        goto cleanup;\n    }\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deferred length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}\n\n", "start_server {\n    tags {\"sort\"}\n    overrides {\n        \"list-max-ziplist-size\" 16\n        \"set-max-intset-entries\" 32\n    }\n} {\n    proc create_random_dataset {num cmd} {\n        set tosort {}\n        set result {}\n        array set seenrand {}\n        r del tosort\n        for {set i 0} {$i < $num} {incr i} {\n            # Make sure all the weights are different because\n            # Redis does not use a stable sort but Tcl does.\n            while 1 {\n                randpath {\n                    set rint [expr int(rand()*1000000)]\n                } {\n                    set rint [expr rand()]\n                }\n                if {![info exists seenrand($rint)]} break\n            }\n            set seenrand($rint) x\n            r $cmd tosort $i\n            r set weight_$i $rint\n            r hset wobj_$i weight $rint\n            lappend tosort [list $i $rint]\n        }\n        set sorted [lsort -index 1 -real $tosort]\n        for {set i 0} {$i < $num} {incr i} {\n            lappend result [lindex $sorted $i 0]\n        }\n        set _ $result\n    }\n\n    proc check_sort_store_encoding {key} {\n        set listpack_max_size [lindex [r config get list-max-ziplist-size] 1]\n\n        # When the length or size of quicklist is less than the limit,\n        # it will be converted to listpack.\n        if {[r llen $key] <= $listpack_max_size} {\n            assert_encoding listpack $key\n        } else {\n            assert_encoding quicklist $key\n        }\n    }\n\n    foreach {num cmd enc title} {\n        16 lpush listpack \"Listpack\"\n        1000 lpush quicklist \"Quicklist\"\n        10000 lpush quicklist \"Big Quicklist\"\n        16 sadd intset \"Intset\"\n        1000 sadd hashtable \"Hash table\"\n        10000 sadd hashtable \"Big Hash table\"\n    } {\n        set result [create_random_dataset $num $cmd]\n        assert_encoding $enc tosort\n\n        test \"$title: SORT BY key\" {\n            assert_equal $result [r sort tosort BY weight_*]\n        } {} {cluster:skip}\n\n        test \"$title: SORT BY key with limit\" {\n            assert_equal [lrange $result 5 9] [r sort tosort BY weight_* LIMIT 5 5]\n        } {} {cluster:skip}\n\n        test \"$title: SORT BY hash field\" {\n            assert_equal $result [r sort tosort BY wobj_*->weight]\n        } {} {cluster:skip}\n    }\n\n    set result [create_random_dataset 16 lpush]\n    test \"SORT GET #\" {\n        assert_equal [lsort -integer $result] [r sort tosort GET #]\n    } {} {cluster:skip}\n\n    test \"SORT GET <const>\" {\n        r del foo\n        set res [r sort tosort GET foo]\n        assert_equal 16 [llength $res]\n        foreach item $res { assert_equal {} $item }\n    } {} {cluster:skip}\n\n    test \"SORT GET (key and hash) with sanity check\" {\n        set l1 [r sort tosort GET # GET weight_*]\n        set l2 [r sort tosort GET # GET wobj_*->weight]\n        foreach {id1 w1} $l1 {id2 w2} $l2 {\n            assert_equal $id1 $id2\n            assert_equal $w1 [r get weight_$id1]\n            assert_equal $w2 [r get weight_$id1]\n        }\n    } {} {cluster:skip}\n\n    test \"SORT BY key STORE\" {\n        r sort tosort BY weight_* store sort-res\n        assert_equal $result [r lrange sort-res 0 -1]\n        assert_equal 16 [r llen sort-res]\n        check_sort_store_encoding sort-res\n    } {} {cluster:skip}\n\n    test \"SORT BY hash field STORE\" {\n        r sort tosort BY wobj_*->weight store sort-res\n        assert_equal $result [r lrange sort-res 0 -1]\n        assert_equal 16 [r llen sort-res]\n        check_sort_store_encoding sort-res\n    } {} {cluster:skip}\n\n    test \"SORT extracts STORE correctly\" {\n        r command getkeys sort abc store def\n    } {abc def}\n\n    test \"SORT extracts multiple STORE correctly\" {\n        r command getkeys sort abc store invalid store stillbad store def\n    } {abc def}\n\n    test \"SORT DESC\" {\n        assert_equal [lsort -decreasing -integer $result] [r sort tosort DESC]\n    }\n\n    test \"SORT ALPHA against integer encoded strings\" {\n        r del mylist\n        r lpush mylist 2\n        r lpush mylist 1\n        r lpush mylist 3\n        r lpush mylist 10\n        r sort mylist alpha\n    } {1 10 2 3}\n\n    test \"SORT sorted set\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        r sort zset alpha desc\n    } {e d c b a}\n\n    test \"SORT sorted set BY nosort should retain ordering\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        r multi\n        r sort zset by nosort asc\n        r sort zset by nosort desc\n        r exec\n    } {{a c e b d} {d b e c a}}\n\n    test \"SORT sorted set BY nosort + LIMIT\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        assert_equal [r sort zset by nosort asc limit 0 1] {a}\n        assert_equal [r sort zset by nosort desc limit 0 1] {d}\n        assert_equal [r sort zset by nosort asc limit 0 2] {a c}\n        assert_equal [r sort zset by nosort desc limit 0 2] {d b}\n        assert_equal [r sort zset by nosort limit 5 10] {}\n        assert_equal [r sort zset by nosort limit -10 100] {a c e b d}\n    }\n\n    test \"SORT sorted set BY nosort works as expected from scripts\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        r eval {\n            return {redis.call('sort',KEYS[1],'by','nosort','asc'),\n                    redis.call('sort',KEYS[1],'by','nosort','desc')}\n        } 1 zset\n    } {{a c e b d} {d b e c a}}\n\n    test \"SORT sorted set: +inf and -inf handling\" {\n        r del zset\n        r zadd zset -100 a\n        r zadd zset 200 b\n        r zadd zset -300 c\n        r zadd zset 1000000 d\n        r zadd zset +inf max\n        r zadd zset -inf min\n        r zrange zset 0 -1\n    } {min c a b d max}\n\n    test \"SORT regression for issue #19, sorting floats\" {\n        r flushdb\n        set floats {1.1 5.10 3.10 7.44 2.1 5.75 6.12 0.25 1.15}\n        foreach x $floats {\n            r lpush mylist $x\n        }\n        assert_equal [lsort -real $floats] [r sort mylist]\n    }\n\n    test \"SORT with STORE returns zero if result is empty (github issue 224)\" {\n        r flushdb\n        r sort foo{t} store bar{t}\n    } {0}\n\n    test \"SORT with STORE does not create empty lists (github issue 224)\" {\n        r flushdb\n        r lpush foo{t} bar\n        r sort foo{t} alpha limit 10 10 store zap{t}\n        r exists zap{t}\n    } {0}\n\n    test \"SORT with STORE removes key if result is empty (github issue 227)\" {\n        r flushdb\n        r lpush foo{t} bar\n        r sort emptylist{t} store foo{t}\n        r exists foo{t}\n    } {0}\n\n    test \"SORT with BY <constant> and STORE should still order output\" {\n        r del myset mylist\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        r sort myset alpha by _ store mylist\n        r lrange mylist 0 -1\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z} {cluster:skip}\n\n    test \"SORT will complain with numerical sorting and bad doubles (1)\" {\n        r del myset\n        r sadd myset 1 2 3 4 not-a-double\n        set e {}\n        catch {r sort myset} e\n        set e\n    } {*ERR*double*}\n\n    test \"SORT will complain with numerical sorting and bad doubles (2)\" {\n        r del myset\n        r sadd myset 1 2 3 4\n        r mset score:1 10 score:2 20 score:3 30 score:4 not-a-double\n        set e {}\n        catch {r sort myset by score:*} e\n        set e\n    } {*ERR*double*} {cluster:skip}\n\n    test \"SORT BY sub-sorts lexicographically if score is the same\" {\n        r del myset\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        foreach ele {a aa aaa azz b c d e f g h i l m n o p q r s t u v z} {\n            set score:$ele 100\n        }\n        r sort myset by score:*\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z} {cluster:skip}\n\n    test \"SORT GET with pattern ending with just -> does not get hash field\" {\n        r del mylist\n        r lpush mylist a\n        r set x:a-> 100\n        r sort mylist by num get x:*->\n    } {100} {cluster:skip}\n\n    test \"SORT by nosort retains native order for lists\" {\n        r del testa\n        r lpush testa 2 1 4 3 5\n        r sort testa by nosort\n    } {5 3 4 1 2} {cluster:skip}\n\n    test \"SORT by nosort plus store retains native order for lists\" {\n        r del testa\n        r lpush testa 2 1 4 3 5\n        r sort testa by nosort store testb\n        r lrange testb 0 -1\n    } {5 3 4 1 2} {cluster:skip}\n\n    test \"SORT by nosort with limit returns based on original list order\" {\n        r sort testa by nosort limit 0 3 store testb\n        r lrange testb 0 -1\n    } {5 3 4} {cluster:skip}\n\n    test \"SORT_RO - Successful case\" {\n        r del mylist\n        r lpush mylist a\n        r set x:a 100\n        r sort_ro mylist by nosort get x:*->\n    } {100} {cluster:skip}\n\n    test \"SORT_RO - Cannot run with STORE arg\" {\n        catch {r sort_ro foolist STORE bar} e\n        set e\n    } {ERR syntax error}\n\n    tags {\"slow\"} {\n        set num 100\n        set res [create_random_dataset $num lpush]\n\n        test \"SORT speed, $num element list BY key, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort BY weight_* LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        } {} {cluster:skip}\n\n        test \"SORT speed, $num element list BY hash field, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort BY wobj_*->weight LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        } {} {cluster:skip}\n\n        test \"SORT speed, $num element list directly, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        }\n\n        test \"SORT speed, $num element list BY <const>, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort BY nokey LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        } {} {cluster:skip}\n    }\n}\n", "start_server {tags {\"string\"}} {\n    test {SET and GET an item} {\n        r set x foobar\n        r get x\n    } {foobar}\n\n    test {SET and GET an empty item} {\n        r set x {}\n        r get x\n    } {}\n\n    test {Very big payload in GET/SET} {\n        set buf [string repeat \"abcd\" 1000000]\n        r set foo $buf\n        r get foo\n    } [string repeat \"abcd\" 1000000]\n\n    tags {\"slow\"} {\n        test {Very big payload random access} {\n            set err {}\n            array set payload {}\n            for {set j 0} {$j < 100} {incr j} {\n                set size [expr 1+[randomInt 100000]]\n                set buf [string repeat \"pl-$j\" $size]\n                set payload($j) $buf\n                r set bigpayload_$j $buf\n            }\n            for {set j 0} {$j < 1000} {incr j} {\n                set index [randomInt 100]\n                set buf [r get bigpayload_$index]\n                if {$buf != $payload($index)} {\n                    set err \"Values differ: I set '$payload($index)' but I read back '$buf'\"\n                    break\n                }\n            }\n            unset payload\n            set _ $err\n        } {}\n\n        test {SET 10000 numeric keys and access all them in reverse order} {\n            r flushdb\n            set err {}\n            for {set x 0} {$x < 10000} {incr x} {\n                r set $x $x\n            }\n            set sum 0\n            for {set x 9999} {$x >= 0} {incr x -1} {\n                set val [r get $x]\n                if {$val ne $x} {\n                    set err \"Element at position $x is $val instead of $x\"\n                    break\n                }\n            }\n            set _ $err\n        } {}\n\n        test {DBSIZE should be 10000 now} {\n            r dbsize\n        } {10000}\n    }\n\n    test \"SETNX target key missing\" {\n        r del novar\n        assert_equal 1 [r setnx novar foobared]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX target key exists\" {\n        r set novar foobared\n        assert_equal 0 [r setnx novar blabla]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX against not-expired volatile key\" {\n        r set x 10\n        r expire x 10000\n        assert_equal 0 [r setnx x 20]\n        assert_equal 10 [r get x]\n    }\n\n    test \"SETNX against expired volatile key\" {\n        # Make it very unlikely for the key this test uses to be expired by the\n        # active expiry cycle. This is tightly coupled to the implementation of\n        # active expiry and dbAdd() but currently the only way to test that\n        # SETNX expires a key when it should have been.\n        for {set x 0} {$x < 9999} {incr x} {\n            r setex key-$x 3600 value\n        }\n\n        # This will be one of 10000 expiring keys. A cycle is executed every\n        # 100ms, sampling 10 keys for being expired or not.  This key will be\n        # expired for at most 1s when we wait 2s, resulting in a total sample\n        # of 100 keys. The probability of the success of this test being a\n        # false positive is therefore approx. 1%.\n        r set x 10\n        r expire x 1\n\n        # Wait for the key to expire\n        after 2000\n\n        assert_equal 1 [r setnx x 20]\n        assert_equal 20 [r get x]\n    }\n\n    test \"GETEX EX option\" {\n        r del foo\n        r set foo bar\n        r getex foo ex 10\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PX option\" {\n        r del foo\n        r set foo bar\n        r getex foo px 10000\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX EXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo pxat [expr [clock milliseconds] + 10000]\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX PERSIST option\" {\n        r del foo\n        r set foo bar ex 10\n        assert_range [r ttl foo] 5 10\n        r getex foo persist\n        assert_equal -1 [r ttl foo]\n    }\n\n    test \"GETEX no option\" {\n        r del foo\n        r set foo bar\n        r getex foo\n        assert_equal bar [r getex foo]\n    }\n\n    test \"GETEX syntax errors\" {\n        set ex {}\n        catch {r getex foo non-existent-option} ex\n        set ex\n    } {*syntax*}\n\n    test \"GETEX no arguments\" {\n         set ex {}\n         catch {r getex} ex\n         set ex\n     } {*wrong number of arguments for 'getex' command}\n\n    test \"GETDEL command\" {\n        r del foo\n        r set foo bar\n        assert_equal bar [r getdel foo ]\n        assert_equal {} [r getdel foo ]\n    }\n\n    test {GETDEL propagate as DEL command to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getdel foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {GETEX without argument does not propagate to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getex foo\n        r del foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {MGET} {\n        r flushdb\n        r set foo{t} BAR\n        r set bar{t} FOO\n        r mget foo{t} bar{t}\n    } {BAR FOO}\n\n    test {MGET against non existing key} {\n        r mget foo{t} baazz{t} bar{t}\n    } {BAR {} FOO}\n\n    test {MGET against non-string key} {\n        r sadd myset{t} ciao\n        r sadd myset{t} bau\n        r mget foo{t} baazz{t} bar{t} myset{t}\n    } {BAR {} FOO {}}\n\n    test {GETSET (set new value)} {\n        r del foo\n        list [r getset foo xyz] [r get foo]\n    } {{} xyz}\n\n    test {GETSET (replace old value)} {\n        r set foo bar\n        list [r getset foo xyz] [r get foo]\n    } {bar xyz}\n\n    test {MSET base case} {\n        r mset x{t} 10 y{t} \"foo bar\" z{t} \"x x x x x x x\\n\\n\\r\\n\"\n        r mget x{t} y{t} z{t}\n    } [list 10 {foo bar} \"x x x x x x x\\n\\n\\r\\n\"]\n\n    test {MSET/MSETNX wrong number of args} {\n        assert_error {*wrong number of arguments for 'mset' command} {r mset x{t} 10 y{t} \"foo bar\" z{t}}\n        assert_error {*wrong number of arguments for 'msetnx' command} {r msetnx x{t} 20 y{t} \"foo bar\" z{t}}\n    }\n\n    test {MSETNX with already existent key} {\n        list [r msetnx x1{t} xxx y2{t} yyy x{t} 20] [r exists x1{t}] [r exists y2{t}]\n    } {0 0 0}\n\n    test {MSETNX with not existing keys} {\n        list [r msetnx x1{t} xxx y2{t} yyy] [r get x1{t}] [r get y2{t}]\n    } {1 xxx yyy}\n\n    test \"STRLEN against non-existing key\" {\n        assert_equal 0 [r strlen notakey]\n    }\n\n    test \"STRLEN against integer-encoded value\" {\n        r set myinteger -555\n        assert_equal 4 [r strlen myinteger]\n    }\n\n    test \"STRLEN against plain string\" {\n        r set mystring \"foozzz0123456789 baz\"\n        assert_equal 20 [r strlen mystring]\n    }\n\n    test \"SETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r setbit mykey 1 1]\n        assert_equal [binary format B* 01000000] [r get mykey]\n    }\n\n    test \"SETBIT against string-encoded key\" {\n        # Ascii \"@\" is integer 64 = 01 00 00 00\n        r set mykey \"@\"\n\n        assert_equal 0 [r setbit mykey 2 1]\n        assert_equal [binary format B* 01100000] [r get mykey]\n        assert_equal 1 [r setbit mykey 1 0]\n        assert_equal [binary format B* 00100000] [r get mykey]\n    }\n\n    test \"SETBIT against integer-encoded key\" {\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        r set mykey 1\n        assert_encoding int mykey\n\n        assert_equal 0 [r setbit mykey 6 1]\n        assert_equal [binary format B* 00110011] [r get mykey]\n        assert_equal 1 [r setbit mykey 2 0]\n        assert_equal [binary format B* 00010011] [r get mykey]\n    }\n\n    test \"SETBIT against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setbit mykey 0 1}\n    }\n\n    test \"SETBIT with out of range bit offset\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey [expr 4*1024*1024*1024] 1}\n        assert_error \"*out of range*\" {r setbit mykey -1 1}\n    }\n\n    test \"SETBIT with non-bit argument\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey 0 -1}\n        assert_error \"*out of range*\" {r setbit mykey 0  2}\n        assert_error \"*out of range*\" {r setbit mykey 0 10}\n        assert_error \"*out of range*\" {r setbit mykey 0 20}\n    }\n\n    test \"SETBIT fuzzing\" {\n        set str \"\"\n        set len [expr 256*8]\n        r del mykey\n\n        for {set i 0} {$i < 2000} {incr i} {\n            set bitnum [randomInt $len]\n            set bitval [randomInt 2]\n            set fmt [format \"%%-%ds%%d%%-s\" $bitnum]\n            set head [string range $str 0 $bitnum-1]\n            set tail [string range $str $bitnum+1 end]\n            set str [string map {\" \" 0} [format $fmt $head $bitval $tail]]\n\n            r setbit mykey $bitnum $bitval\n            assert_equal [binary format B* $str] [r get mykey]\n        }\n    }\n\n    test \"GETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r getbit mykey 0]\n    }\n\n    test \"GETBIT against string-encoded key\" {\n        # Single byte with 2nd and 3rd bit set\n        r set mykey \"`\"\n\n        # In-range\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 1 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 0 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"GETBIT against integer-encoded key\" {\n        r set mykey 1\n        assert_encoding int mykey\n\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 0 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 1 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"SETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal 3 [r setrange mykey 0 foo]\n        assert_equal \"foo\" [r get mykey]\n\n        r del mykey\n        assert_equal 0 [r setrange mykey 0 \"\"]\n        assert_equal 0 [r exists mykey]\n\n        r del mykey\n        assert_equal 4 [r setrange mykey 1 foo]\n        assert_equal \"\\000foo\" [r get mykey]\n    }\n\n    test \"SETRANGE against string-encoded key\" {\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 b]\n        assert_equal \"boo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 \"\"]\n        assert_equal \"foo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 1 b]\n        assert_equal \"fbo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 7 [r setrange mykey 4 bar]\n        assert_equal \"foo\\000bar\" [r get mykey]\n    }\n\n    test \"SETRANGE against integer-encoded key\" {\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 2]\n        assert_encoding raw mykey\n        assert_equal 2234 [r get mykey]\n\n        # Shouldn't change encoding when nothing is set\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 \"\"]\n        assert_encoding int mykey\n        assert_equal 1234 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 1 3]\n        assert_encoding raw mykey\n        assert_equal 1334 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 6 [r setrange mykey 5 2]\n        assert_encoding raw mykey\n        assert_equal \"1234\\0002\" [r get mykey]\n    }\n\n    test \"SETRANGE against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setrange mykey 0 bar}\n    }\n\n    test \"SETRANGE with out of range offset\" {\n        r del mykey\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n\n        r set mykey \"hello\"\n        assert_error \"*out of range*\" {r setrange mykey -1 world}\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n    }\n\n    test \"GETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal \"\" [r getrange mykey 0 -1]\n    }\n\n    test \"GETRANGE against string value\" {\n        r set mykey \"Hello World\"\n        assert_equal \"Hell\" [r getrange mykey 0 3]\n        assert_equal \"Hello World\" [r getrange mykey 0 -1]\n        assert_equal \"orld\" [r getrange mykey -4 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \" World\" [r getrange mykey 5 5000]\n        assert_equal \"Hello World\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE against integer-encoded value\" {\n        r set mykey 1234\n        assert_equal \"123\" [r getrange mykey 0 2]\n        assert_equal \"1234\" [r getrange mykey 0 -1]\n        assert_equal \"234\" [r getrange mykey -3 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \"4\" [r getrange mykey 3 5000]\n        assert_equal \"1234\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE fuzzing\" {\n        for {set i 0} {$i < 1000} {incr i} {\n            r set bin [set bin [randstring 0 1024 binary]]\n            set _start [set start [randomInt 1500]]\n            set _end [set end [randomInt 1500]]\n            if {$_start < 0} {set _start \"end-[abs($_start)-1]\"}\n            if {$_end < 0} {set _end \"end-[abs($_end)-1]\"}\n            assert_equal [string range $bin $_start $_end] [r getrange bin $start $end]\n        }\n    }\n\n    test {Extended SET can detect syntax errors} {\n        set e {}\n        catch {r set foo bar non-existing-option} e\n        set e\n    } {*syntax*}\n\n    test {Extended SET NX option} {\n        r del foo\n        set v1 [r set foo 1 nx]\n        set v2 [r set foo 2 nx]\n        list $v1 $v2 [r get foo]\n    } {OK {} 1}\n\n    test {Extended SET XX option} {\n        r del foo\n        set v1 [r set foo 1 xx]\n        r set foo bar\n        set v2 [r set foo 2 xx]\n        list $v1 $v2 [r get foo]\n    } {{} OK 2}\n\n    test {Extended SET GET option} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo bar2 GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar2}\n\n    test {Extended SET GET option with no previous value} {\n        r del foo\n        set old_value [r set foo bar GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with XX} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar baz}\n\n    test {Extended SET GET option with XX and no previous value} {\n        r del foo\n        set old_value [r set foo bar GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} {}}\n\n    test {Extended SET GET option with NX} {\n        r del foo\n        set old_value [r set foo bar GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with NX and previous value} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar}\n\n    test {Extended SET GET with incorrect type should result in wrong type error} {\n      r del foo\n      r rpush foo waffle\n      catch {r set foo bar GET} err1\n      assert_equal \"waffle\" [r rpop foo]\n      set err1\n    } {*WRONGTYPE*}\n\n    test {Extended SET EX option} {\n        r del foo\n        r set foo bar ex 10\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {Extended SET PX option} {\n        r del foo\n        r set foo bar px 10000\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test \"Extended SET EXAT option\" {\n        r del foo\n        r set foo bar exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"Extended SET PXAT option\" {\n        r del foo\n        r set foo bar pxat [expr [clock milliseconds] + 10000]\n        assert_range [r ttl foo] 5 10\n    }\n    test {Extended SET using multiple options at once} {\n        r set foo val\n        assert {[r set foo bar xx px 10000] eq {OK}}\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {GETRANGE with huge ranges, Github issue #1844} {\n        r set foo bar\n        r getrange foo 0 4294967297\n    } {bar}\n\n    set rna1 {CACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTTCGTCCGGGTGTG}\n    set rna2 {ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n    set rnalcs {ACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n\n    test {LCS basic} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t}\n    } $rnalcs\n\n    test {LCS len} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t} LEN\n    } [string length $rnalcs]\n\n    test {LCS indexes} {\n        dict get [r LCS virus1{t} virus2{t} IDX] matches\n    } {{{238 238} {239 239}} {{236 236} {238 238}} {{229 230} {236 237}} {{224 224} {235 235}} {{1 222} {13 234}}}\n\n    test {LCS indexes with match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN] matches\n    } {{{238 238} {239 239} 1} {{236 236} {238 238} 1} {{229 230} {236 237} 2} {{224 224} {235 235} 1} {{1 222} {13 234} 222}}\n\n    test {LCS indexes with match len and minimum match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN MINMATCHLEN 5] matches\n    } {{{1 222} {13 234} 222}}\n}\n"], "fixing_code": ["/* SORT command and helper functions.\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include \"server.h\"\n#include \"pqsort.h\" /* Partial qsort for SORT+LIMIT */\n#include <math.h> /* isnan() */\n\nzskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);\n\nredisSortOperation *createSortOperation(int type, robj *pattern) {\n    redisSortOperation *so = zmalloc(sizeof(*so));\n    so->type = type;\n    so->pattern = pattern;\n    return so;\n}\n\n/* Return the value associated to the key with a name obtained using\n * the following rules:\n *\n * 1) The first occurrence of '*' in 'pattern' is substituted with 'subst'.\n *\n * 2) If 'pattern' matches the \"->\" string, everything on the left of\n *    the arrow is treated as the name of a hash field, and the part on the\n *    left as the key name containing a hash. The value of the specified\n *    field is returned.\n *\n * 3) If 'pattern' equals \"#\", the function simply returns 'subst' itself so\n *    that the SORT command can be used like: SORT key GET # to retrieve\n *    the Set/List elements directly.\n *\n * The returned object will always have its refcount increased by 1\n * when it is non-NULL. */\nrobj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {\n    char *p, *f, *k;\n    sds spat, ssub;\n    robj *keyobj, *fieldobj = NULL, *o;\n    int prefixlen, sublen, postfixlen, fieldlen;\n\n    /* If the pattern is \"#\" return the substitution object itself in order\n     * to implement the \"SORT ... GET #\" feature. */\n    spat = pattern->ptr;\n    if (spat[0] == '#' && spat[1] == '\\0') {\n        incrRefCount(subst);\n        return subst;\n    }\n\n    /* The substitution object may be specially encoded. If so we create\n     * a decoded object on the fly. Otherwise getDecodedObject will just\n     * increment the ref count, that we'll decrement later. */\n    subst = getDecodedObject(subst);\n    ssub = subst->ptr;\n\n    /* If we can't find '*' in the pattern we return NULL as to GET a\n     * fixed key does not make sense. */\n    p = strchr(spat,'*');\n    if (!p) {\n        decrRefCount(subst);\n        return NULL;\n    }\n\n    /* Find out if we're dealing with a hash dereference. */\n    if ((f = strstr(p+1, \"->\")) != NULL && *(f+2) != '\\0') {\n        fieldlen = sdslen(spat)-(f-spat)-2;\n        fieldobj = createStringObject(f+2,fieldlen);\n    } else {\n        fieldlen = 0;\n    }\n\n    /* Perform the '*' substitution. */\n    prefixlen = p-spat;\n    sublen = sdslen(ssub);\n    postfixlen = sdslen(spat)-(prefixlen+1)-(fieldlen ? fieldlen+2 : 0);\n    keyobj = createStringObject(NULL,prefixlen+sublen+postfixlen);\n    k = keyobj->ptr;\n    memcpy(k,spat,prefixlen);\n    memcpy(k+prefixlen,ssub,sublen);\n    memcpy(k+prefixlen+sublen,p+1,postfixlen);\n    decrRefCount(subst); /* Incremented by decodeObject() */\n\n    /* Lookup substituted key */\n    o = lookupKeyRead(db, keyobj);\n    if (o == NULL) goto noobj;\n\n    if (fieldobj) {\n        if (o->type != OBJ_HASH) goto noobj;\n\n        /* Retrieve value from hash by the field name. The returned object\n         * is a new object with refcount already incremented. */\n        o = hashTypeGetValueObject(o, fieldobj->ptr);\n    } else {\n        if (o->type != OBJ_STRING) goto noobj;\n\n        /* Every object that this function returns needs to have its refcount\n         * increased. sortCommand decreases it again. */\n        incrRefCount(o);\n    }\n    decrRefCount(keyobj);\n    if (fieldobj) decrRefCount(fieldobj);\n    return o;\n\nnoobj:\n    decrRefCount(keyobj);\n    if (fieldlen) decrRefCount(fieldobj);\n    return NULL;\n}\n\n/* sortCompare() is used by qsort in sortCommand(). Given that qsort_r with\n * the additional parameter is not standard but a BSD-specific we have to\n * pass sorting parameters via the global 'server' structure */\nint sortCompare(const void *s1, const void *s2) {\n    const redisSortObject *so1 = s1, *so2 = s2;\n    int cmp;\n\n    if (!server.sort_alpha) {\n        /* Numeric sorting. Here it's trivial as we precomputed scores */\n        if (so1->u.score > so2->u.score) {\n            cmp = 1;\n        } else if (so1->u.score < so2->u.score) {\n            cmp = -1;\n        } else {\n            /* Objects have the same score, but we don't want the comparison\n             * to be undefined, so we compare objects lexicographically.\n             * This way the result of SORT is deterministic. */\n            cmp = compareStringObjects(so1->obj,so2->obj);\n        }\n    } else {\n        /* Alphanumeric sorting */\n        if (server.sort_bypattern) {\n            if (!so1->u.cmpobj || !so2->u.cmpobj) {\n                /* At least one compare object is NULL */\n                if (so1->u.cmpobj == so2->u.cmpobj)\n                    cmp = 0;\n                else if (so1->u.cmpobj == NULL)\n                    cmp = -1;\n                else\n                    cmp = 1;\n            } else {\n                /* We have both the objects, compare them. */\n                if (server.sort_store) {\n                    cmp = compareStringObjects(so1->u.cmpobj,so2->u.cmpobj);\n                } else {\n                    /* Here we can use strcoll() directly as we are sure that\n                     * the objects are decoded string objects. */\n                    cmp = strcoll(so1->u.cmpobj->ptr,so2->u.cmpobj->ptr);\n                }\n            }\n        } else {\n            /* Compare elements directly. */\n            if (server.sort_store) {\n                cmp = compareStringObjects(so1->obj,so2->obj);\n            } else {\n                cmp = collateStringObjects(so1->obj,so2->obj);\n            }\n        }\n    }\n    return server.sort_desc ? -cmp : cmp;\n}\n\n/* The SORT command is the most complex command in Redis. Warning: this code\n * is optimized for speed and a bit less for readability */\nvoid sortCommandGeneric(client *c, int readonly) {\n    list *operations;\n    unsigned int outputlen = 0;\n    int desc = 0, alpha = 0;\n    long limit_start = 0, limit_count = -1, start, end;\n    int j, dontsort = 0, vectorlen;\n    int getop = 0; /* GET operation counter */\n    int int_conversion_error = 0;\n    int syntax_error = 0;\n    robj *sortval, *sortby = NULL, *storekey = NULL;\n    redisSortObject *vector; /* Resulting vector to sort */\n    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */\n    /* Create a list of operations to perform for every sorted element.\n     * Operations can be GET */\n    operations = listCreate();\n    listSetFreeMethod(operations,zfree);\n    j = 2; /* options start at argv[2] */\n\n    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);\n\n    /* The SORT command has an SQL-alike syntax, parse it */\n    while(j < c->argc) {\n        int leftargs = c->argc-j-1;\n        if (!strcasecmp(c->argv[j]->ptr,\"asc\")) {\n            desc = 0;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"desc\")) {\n            desc = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"alpha\")) {\n            alpha = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"limit\") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)\n                 != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)\n                 != C_OK))\n            {\n                syntax_error++;\n                break;\n            }\n            j+=2;\n        } else if (readonly == 0 && !strcasecmp(c->argv[j]->ptr,\"store\") && leftargs >= 1) {\n            storekey = c->argv[j+1];\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"by\") && leftargs >= 1) {\n            sortby = c->argv[j+1];\n            /* If the BY pattern does not contain '*', i.e. it is constant,\n             * we don't need to sort nor to lookup the weight keys. */\n            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {\n                dontsort = 1;\n            } else {\n                /* If BY is specified with a real pattern, we can't accept\n                 * it in cluster mode. */\n                if (server.cluster_enabled) {\n                    addReplyError(c,\"BY option of SORT denied in Cluster mode.\");\n                    syntax_error++;\n                    break;\n                }\n                /* If BY is specified with a real pattern, we can't accept\n                 * it if no full ACL key access is applied for this command. */\n                if (!user_has_full_key_access) {\n                    addReplyError(c,\"BY option of SORT denied due to insufficient ACL permissions.\");\n                    syntax_error++;\n                    break;\n                }\n            }\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"get\") && leftargs >= 1) {\n            if (server.cluster_enabled) {\n                addReplyError(c,\"GET option of SORT denied in Cluster mode.\");\n                syntax_error++;\n                break;\n            }\n            if (!user_has_full_key_access) {\n                addReplyError(c,\"GET option of SORT denied due to insufficient ACL permissions.\");\n                syntax_error++;\n                break;\n            }\n            listAddNodeTail(operations,createSortOperation(\n                SORT_OP_GET,c->argv[j+1]));\n            getop++;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            syntax_error++;\n            break;\n        }\n        j++;\n    }\n\n    /* Handle syntax errors set during options parsing. */\n    if (syntax_error) {\n        listRelease(operations);\n        return;\n    }\n\n    /* Lookup the key to sort. It must be of the right types */\n    sortval = lookupKeyRead(c->db, c->argv[1]);\n    if (sortval && sortval->type != OBJ_SET &&\n                   sortval->type != OBJ_LIST &&\n                   sortval->type != OBJ_ZSET)\n    {\n        listRelease(operations);\n        addReplyErrorObject(c,shared.wrongtypeerr);\n        return;\n    }\n\n    /* Now we need to protect sortval incrementing its count, in the future\n     * SORT may have options able to overwrite/delete keys during the sorting\n     * and the sorted key itself may get destroyed */\n    if (sortval)\n        incrRefCount(sortval);\n    else\n        sortval = createQuicklistObject();\n\n\n    /* When sorting a set with no sort specified, we must sort the output\n     * so the result is consistent across scripting and replication.\n     *\n     * The other types (list, sorted set) will retain their native order\n     * even if no sort order is requested, so they remain stable across\n     * scripting and replication. */\n    if (dontsort &&\n        sortval->type == OBJ_SET &&\n        (storekey || c->flags & CLIENT_SCRIPT))\n    {\n        /* Force ALPHA sorting */\n        dontsort = 0;\n        alpha = 1;\n        sortby = NULL;\n    }\n\n    /* Destructively convert encoded sorted sets for SORT. */\n    if (sortval->type == OBJ_ZSET)\n        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);\n\n    /* Obtain the length of the object to sort. */\n    switch(sortval->type) {\n    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;\n    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;\n    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;\n    default: vectorlen = 0; serverPanic(\"Bad SORT type\"); /* Avoid GCC warning */\n    }\n\n    /* Perform LIMIT start,count sanity checking.\n     * And avoid integer overflow by limiting inputs to object sizes. */\n    start = min(max(limit_start, 0), vectorlen);\n    limit_count = min(max(limit_count, -1), vectorlen);\n    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n    if (start >= vectorlen) {\n        start = vectorlen-1;\n        end = vectorlen-2;\n    }\n    if (end >= vectorlen) end = vectorlen-1;\n\n    /* Whenever possible, we load elements into the output array in a more\n     * direct way. This is possible if:\n     *\n     * 1) The object to sort is a sorted set or a list (internally sorted).\n     * 2) There is nothing to sort as dontsort is true (BY <constant string>).\n     *\n     * In this special case, if we have a LIMIT option that actually reduces\n     * the number of elements to fetch, we also optimize to just load the\n     * range we are interested in and allocating a vector that is big enough\n     * for the selected range length. */\n    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&\n        dontsort &&\n        (start != 0 || end != vectorlen-1))\n    {\n        vectorlen = end-start+1;\n    }\n\n    /* Load the sorting vector with all the objects to sort */\n    vector = zmalloc(sizeof(redisSortObject)*vectorlen);\n    j = 0;\n\n    if (sortval->type == OBJ_LIST && dontsort) {\n        /* Special handling for a list, if 'dontsort' is true.\n         * This makes sure we return elements in the list original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n        if (end >= start) {\n            listTypeIterator *li;\n            listTypeEntry entry;\n            li = listTypeInitIterator(sortval,\n                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,\n                    desc ? LIST_HEAD : LIST_TAIL);\n\n            while(j < vectorlen && listTypeNext(li,&entry)) {\n                vector[j].obj = listTypeGet(&entry);\n                vector[j].u.score = 0;\n                vector[j].u.cmpobj = NULL;\n                j++;\n            }\n            listTypeReleaseIterator(li);\n            /* Fix start/end: output code is not aware of this optimization. */\n            end -= start;\n            start = 0;\n        }\n    } else if (sortval->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            vector[j].obj = listTypeGet(&entry);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        listTypeReleaseIterator(li);\n    } else if (sortval->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(sortval);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            vector[j].obj = createObject(OBJ_STRING,sdsele);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        setTypeReleaseIterator(si);\n    } else if (sortval->type == OBJ_ZSET && dontsort) {\n        /* Special handling for a sorted set, if 'dontsort' is true.\n         * This makes sure we return elements in the sorted set original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n\n        zset *zs = sortval->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds sdsele;\n        int rangelen = vectorlen;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (desc) {\n            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);\n\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,zsetlen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,sortval,ln != NULL);\n            sdsele = ln->ele;\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n            ln = desc ? ln->backward : ln->level[0].forward;\n        }\n        /* Fix start/end: output code is not aware of this optimization. */\n        end -= start;\n        start = 0;\n    } else if (sortval->type == OBJ_ZSET) {\n        dict *set = ((zset*)sortval->ptr)->dict;\n        dictIterator *di;\n        dictEntry *setele;\n        sds sdsele;\n        di = dictGetIterator(set);\n        while((setele = dictNext(di)) != NULL) {\n            sdsele =  dictGetKey(setele);\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        dictReleaseIterator(di);\n    } else {\n        serverPanic(\"Unknown type\");\n    }\n    serverAssertWithInfo(c,sortval,j == vectorlen);\n\n    /* Now it's time to load the right scores in the sorting vector */\n    if (!dontsort) {\n        for (j = 0; j < vectorlen; j++) {\n            robj *byval;\n            if (sortby) {\n                /* lookup value to sort by */\n                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);\n                if (!byval) continue;\n            } else {\n                /* use object itself to sort by */\n                byval = vector[j].obj;\n            }\n\n            if (alpha) {\n                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);\n            } else {\n                if (sdsEncodedObject(byval)) {\n                    char *eptr;\n\n                    vector[j].u.score = strtod(byval->ptr,&eptr);\n                    if (eptr[0] != '\\0' || errno == ERANGE ||\n                        isnan(vector[j].u.score))\n                    {\n                        int_conversion_error = 1;\n                    }\n                } else if (byval->encoding == OBJ_ENCODING_INT) {\n                    /* Don't need to decode the object if it's\n                     * integer-encoded (the only encoding supported) so\n                     * far. We can just cast it */\n                    vector[j].u.score = (long)byval->ptr;\n                } else {\n                    serverAssertWithInfo(c,sortval,1 != 1);\n                }\n            }\n\n            /* when the object was retrieved using lookupKeyByPattern,\n             * its refcount needs to be decreased. */\n            if (sortby) {\n                decrRefCount(byval);\n            }\n        }\n\n        server.sort_desc = desc;\n        server.sort_alpha = alpha;\n        server.sort_bypattern = sortby ? 1 : 0;\n        server.sort_store = storekey ? 1 : 0;\n        if (sortby && (start != 0 || end != vectorlen-1))\n            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);\n        else\n            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);\n    }\n\n    /* Send command output to the output buffer, performing the specified\n     * GET/DEL/INCR/DECR operations if any. */\n    outputlen = getop ? getop*(end-start+1) : end-start+1;\n    if (int_conversion_error) {\n        addReplyError(c,\"One or more scores can't be converted into double\");\n    } else if (storekey == NULL) {\n        /* STORE option not specified, sent the sorting result to client */\n        addReplyArrayLen(c,outputlen);\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) addReplyBulk(c,vector[j].obj);\n            listRewind(operations,&li);\n            while((ln = listNext(&li))) {\n                redisSortOperation *sop = ln->value;\n                robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                               vector[j].obj);\n\n                if (sop->type == SORT_OP_GET) {\n                    if (!val) {\n                        addReplyNull(c);\n                    } else {\n                        addReplyBulk(c,val);\n                        decrRefCount(val);\n                    }\n                } else {\n                    /* Always fails */\n                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                }\n            }\n        }\n    } else {\n        /* We can't predict the size and encoding of the stored list, we\n         * assume it's a large list and then convert it at the end if needed. */\n        robj *sobj = createQuicklistObject();\n\n        /* STORE option specified, set the sorting result as a List object */\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) {\n                listTypePush(sobj,vector[j].obj,LIST_TAIL);\n            } else {\n                listRewind(operations,&li);\n                while((ln = listNext(&li))) {\n                    redisSortOperation *sop = ln->value;\n                    robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                                   vector[j].obj);\n\n                    if (sop->type == SORT_OP_GET) {\n                        if (!val) val = createStringObject(\"\",0);\n\n                        /* listTypePush does an incrRefCount, so we should take care\n                         * care of the incremented refcount caused by either\n                         * lookupKeyByPattern or createStringObject(\"\",0) */\n                        listTypePush(sobj,val,LIST_TAIL);\n                        decrRefCount(val);\n                    } else {\n                        /* Always fails */\n                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                    }\n                }\n            }\n        }\n        if (outputlen) {\n            listTypeTryConversion(sobj,LIST_CONV_AUTO,NULL,NULL);\n            setKey(c,c->db,storekey,sobj,0);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"sortstore\",storekey,\n                                c->db->id);\n            server.dirty += outputlen;\n        } else if (dbDelete(c->db,storekey)) {\n            signalModifiedKey(c,c->db,storekey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",storekey,c->db->id);\n            server.dirty++;\n        }\n        decrRefCount(sobj);\n        addReplyLongLong(c,outputlen);\n    }\n\n    /* Cleanup */\n    for (j = 0; j < vectorlen; j++)\n        decrRefCount(vector[j].obj);\n\n    decrRefCount(sortval);\n    listRelease(operations);\n    for (j = 0; j < vectorlen; j++) {\n        if (alpha && vector[j].u.cmpobj)\n            decrRefCount(vector[j].u.cmpobj);\n    }\n    zfree(vector);\n}\n\n/* SORT wrapper function for read-only mode. */\nvoid sortroCommand(client *c) {\n    sortCommandGeneric(c, 1);\n}\n\nvoid sortCommand(client *c) {\n    sortCommandGeneric(c, 0);\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h> /* isnan(), isinf() */\n\n/* Forward declarations */\nint getGenericCommand(client *c);\n\n/*-----------------------------------------------------------------------------\n * String Commands\n *----------------------------------------------------------------------------*/\n\nstatic int checkStringLength(client *c, long long size, long long append) {\n    if (mustObeyClient(c))\n        return C_OK;\n    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */\n    long long total = (uint64_t)size + append;\n    /* Test configured max-bulk-len represending a limit of the biggest string object,\n     * and also test for overflow. */\n    if (total > server.proto_max_bulk_len || total < size || total < append) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}\n\n/* The setGenericCommand() function implements the SET operation with different\n * options and variants. This function is called in order to implement the\n * following commands: SET, SETEX, PSETEX, SETNX, GETSET.\n *\n * 'flags' changes the behavior of the command (NX, XX or GET, see below).\n *\n * 'expire' represents an expire to set in form of a Redis object as passed\n * by the user. It is interpreted according to the specified 'unit'.\n *\n * 'ok_reply' and 'abort_reply' is what the function will reply to the client\n * if the operation is performed, or when it is not because of NX or\n * XX flags.\n *\n * If ok_reply is NULL \"+OK\" is used.\n * If abort_reply is NULL, \"$-1\" is used. */\n\n#define OBJ_NO_FLAGS 0\n#define OBJ_SET_NX (1<<0)          /* Set if key not exists. */\n#define OBJ_SET_XX (1<<1)          /* Set if key exists. */\n#define OBJ_EX (1<<2)              /* Set if time in seconds is given */\n#define OBJ_PX (1<<3)              /* Set if time in ms in given */\n#define OBJ_KEEPTTL (1<<4)         /* Set and keep the ttl */\n#define OBJ_SET_GET (1<<5)         /* Set if want to get key before set */\n#define OBJ_EXAT (1<<6)            /* Set if timestamp in second is given */\n#define OBJ_PXAT (1<<7)            /* Set if timestamp in ms is given */\n#define OBJ_PERSIST (1<<8)         /* Set if we need to remove the ttl */\n\n/* Forward declaration */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds);\n\nvoid setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {\n    long long milliseconds = 0; /* initialized to avoid any harmness warning */\n    int found = 0;\n    int setkey_flags = 0;\n\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    if (flags & OBJ_SET_GET) {\n        if (getGenericCommand(c) == C_ERR) return;\n    }\n\n    found = (lookupKeyWrite(c->db,key) != NULL);\n\n    if ((flags & OBJ_SET_NX && found) ||\n        (flags & OBJ_SET_XX && !found))\n    {\n        if (!(flags & OBJ_SET_GET)) {\n            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);\n        }\n        return;\n    }\n\n    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */\n    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;\n    setkey_flags |= found ? SETKEY_ALREADY_EXIST : SETKEY_DOESNT_EXIST;\n\n    setKey(c,c->db,key,val,setkey_flags);\n    server.dirty++;\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",key,c->db->id);\n\n    if (expire) {\n        setExpire(c,c->db,key,milliseconds);\n        /* Propagate as SET Key Value PXAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c, 5, shared.set, key, val, shared.pxat, milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",key,c->db->id);\n    }\n\n    if (!(flags & OBJ_SET_GET)) {\n        addReply(c, ok_reply ? ok_reply : shared.ok);\n    }\n\n    /* Propagate without the GET argument (Isn't needed if we had expire since in that case we completely re-written the command argv) */\n    if ((flags & OBJ_SET_GET) && !expire) {\n        int argc = 0;\n        int j;\n        robj **argv = zmalloc((c->argc-1)*sizeof(robj*));\n        for (j=0; j < c->argc; j++) {\n            char *a = c->argv[j]->ptr;\n            /* Skip GET which may be repeated multiple times. */\n            if (j >= 3 &&\n                (a[0] == 'g' || a[0] == 'G') &&\n                (a[1] == 'e' || a[1] == 'E') &&\n                (a[2] == 't' || a[2] == 'T') && a[3] == '\\0')\n                continue;\n            argv[argc++] = c->argv[j];\n            incrRefCount(c->argv[j]);\n        }\n        replaceClientCommandVector(c, argc, argv);\n    }\n}\n\n/*\n * Extract the `expire` argument of a given GET/SET command as an absolute timestamp in milliseconds.\n *\n * \"client\" is the client that sent the `expire` argument.\n * \"expire\" is the `expire` argument to be extracted.\n * \"flags\" represents the behavior of the command (e.g. PX or EX).\n * \"unit\" is the original unit of the given `expire` argument (e.g. UNIT_SECONDS).\n * \"milliseconds\" is output argument.\n *\n * If return C_OK, \"milliseconds\" output argument will be set to the resulting absolute timestamp.\n * If return C_ERR, an error reply has been added to the given client.\n */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {\n    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);\n    if (ret != C_OK) {\n        return ret;\n    }\n\n    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {\n        /* Negative value provided or multiplication is gonna overflow. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    if (unit == UNIT_SECONDS) *milliseconds *= 1000;\n\n    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {\n        *milliseconds += commandTimeSnapshot();\n    }\n\n    if (*milliseconds <= 0) {\n        /* Overflow detected. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    return C_OK;\n}\n\n#define COMMAND_GET 0\n#define COMMAND_SET 1\n/*\n * The parseExtendedStringArgumentsOrReply() function performs the common validation for extended\n * string arguments used in SET and GET command.\n *\n * Get specific commands - PERSIST/DEL\n * Set specific commands - XX/NX/GET\n * Common commands - EX/EXAT/PX/PXAT/KEEPTTL\n *\n * Function takes pointers to client, flags, unit, pointer to pointer of expire obj if needed\n * to be determined and command_type which can be COMMAND_GET or COMMAND_SET.\n *\n * If there are any syntax violations C_ERR is returned else C_OK is returned.\n *\n * Input flags are updated upon parsing the arguments. Unit and expire are updated if there are any\n * EX/EXAT/PX/PXAT arguments. Unit is updated to millisecond if PX/PXAT is set.\n */\nint parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {\n\n    int j = command_type == COMMAND_GET ? 2 : 3;\n    for (; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];\n\n        if ((opt[0] == 'n' || opt[0] == 'N') &&\n            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_NX;\n        } else if ((opt[0] == 'x' || opt[0] == 'X') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_XX;\n        } else if ((opt[0] == 'g' || opt[0] == 'G') &&\n                   (opt[1] == 'e' || opt[1] == 'E') &&\n                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\\0' &&\n                   (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_GET;\n        } else if (!strcasecmp(opt, \"KEEPTTL\") && !(*flags & OBJ_PERSIST) &&\n            !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n            !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_KEEPTTL;\n        } else if (!strcasecmp(opt,\"PERSIST\") && (command_type == COMMAND_GET) &&\n               !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n               !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) &&\n               !(*flags & OBJ_KEEPTTL))\n        {\n            *flags |= OBJ_PERSIST;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EXAT) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EX;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_PX;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EXAT;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PX) && next)\n        {\n            *flags |= OBJ_PXAT;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* SET key value [NX] [XX] [KEEPTTL] [GET] [EX <seconds>] [PX <milliseconds>]\n *     [EXAT <seconds-timestamp>][PXAT <milliseconds-timestamp>] */\nvoid setCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {\n        return;\n    }\n\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}\n\nvoid setnxCommand(client *c) {\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);\n}\n\nvoid setexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_EX,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);\n}\n\nvoid psetexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_PX,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);\n}\n\nint getGenericCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return C_OK;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return C_ERR;\n    }\n\n    addReplyBulk(c,o);\n    return C_OK;\n}\n\nvoid getCommand(client *c) {\n    getGenericCommand(c);\n}\n\n/*\n * GETEX <key> [PERSIST][EX seconds][PX milliseconds][EXAT seconds-timestamp][PXAT milliseconds-timestamp]\n *\n * The getexCommand() function implements extended options and variants of the GET command. Unlike GET\n * command this command is not read-only.\n *\n * The default behavior when no options are specified is same as GET and does not alter any TTL.\n *\n * Only one of the below options can be used at a given time.\n *\n * 1. PERSIST removes any TTL associated with the key.\n * 2. EX Set expiry TTL in seconds.\n * 3. PX Set expiry TTL in milliseconds.\n * 4. EXAT Same like EX instead of specifying the number of seconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n * 5. PXAT Same like PX instead of specifying the number of milliseconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n *\n * Command would either return the bulk string, error or nil.\n */\nvoid getexCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_GET) != C_OK) {\n        return;\n    }\n\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return;\n    }\n\n    /* Validate the expiration time value first */\n    long long milliseconds = 0;\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    /* We need to do this before we expire the key or delete it */\n    addReplyBulk(c,o);\n\n    /* This command is never propagated as is. It is either propagated as PEXPIRE[AT],DEL,UNLINK or PERSIST.\n     * This why it doesn't need special handling in feedAppendOnlyFile to convert relative expire time to absolute one. */\n    if (((flags & OBJ_PXAT) || (flags & OBJ_EXAT)) && checkAlreadyExpired(milliseconds)) {\n        /* When PXAT/EXAT absolute timestamp is specified, there can be a chance that timestamp\n         * has already elapsed so delete the key in that case. */\n        int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c->db, c->argv[1]) :\n                      dbSyncDelete(c->db, c->argv[1]);\n        serverAssert(deleted);\n        robj *aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;\n        rewriteClientCommandVector(c,2,aux,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    } else if (expire) {\n        setExpire(c,c->db,c->argv[1],milliseconds);\n        /* Propagate as PXEXPIREAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag and the key has not expired. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c,3,shared.pexpireat,c->argv[1],milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",c->argv[1],c->db->id);\n        server.dirty++;\n    } else if (flags & OBJ_PERSIST) {\n        if (removeExpire(c->db, c->argv[1])) {\n            signalModifiedKey(c, c->db, c->argv[1]);\n            rewriteClientCommandVector(c, 2, shared.persist, c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"persist\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    }\n}\n\nvoid getdelCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    if (dbSyncDelete(c->db, c->argv[1])) {\n        /* Propagate as DEL command */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid getsetCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setKey(c,c->db,c->argv[1],c->argv[2],0);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Propagate as SET command */\n    rewriteClientCommandArgument(c,0,shared.set);\n}\n\nvoid setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}\n\nvoid getrangeCommand(client *c) {\n    robj *o;\n    long long start, end;\n    char *str, llbuf[32];\n    size_t strlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)\n        return;\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)\n        return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n\n    if (o->encoding == OBJ_ENCODING_INT) {\n        str = llbuf;\n        strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);\n    } else {\n        str = o->ptr;\n        strlen = sdslen(str);\n    }\n\n    /* Convert negative indexes */\n    if (start < 0 && end < 0 && start > end) {\n        addReply(c,shared.emptybulk);\n        return;\n    }\n    if (start < 0) start = strlen+start;\n    if (end < 0) end = strlen+end;\n    if (start < 0) start = 0;\n    if (end < 0) end = 0;\n    if ((unsigned long long)end >= strlen) end = strlen-1;\n\n    /* Precondition: end >= 0 && end < strlen, so the only condition where\n     * nothing can be returned is: start > end. */\n    if (start > end || strlen == 0) {\n        addReply(c,shared.emptybulk);\n    } else {\n        addReplyBulkCBuffer(c,(char*)str+start,end-start+1);\n    }\n}\n\nvoid mgetCommand(client *c) {\n    int j;\n\n    addReplyArrayLen(c,c->argc-1);\n    for (j = 1; j < c->argc; j++) {\n        robj *o = lookupKeyRead(c->db,c->argv[j]);\n        if (o == NULL) {\n            addReplyNull(c);\n        } else {\n            if (o->type != OBJ_STRING) {\n                addReplyNull(c);\n            } else {\n                addReplyBulk(c,o);\n            }\n        }\n    }\n}\n\nvoid msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}\n\nvoid msetCommand(client *c) {\n    msetGenericCommand(c,0);\n}\n\nvoid msetnxCommand(client *c) {\n    msetGenericCommand(c,1);\n}\n\nvoid incrDecrCommand(client *c, long long incr) {\n    long long value, oldvalue;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n\n    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&\n        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&\n        value >= LONG_MIN && value <= LONG_MAX)\n    {\n        new = o;\n        o->ptr = (void*)((long)value);\n    } else {\n        new = createStringObjectFromLongLongForValue(value);\n        if (o) {\n            dbReplaceValue(c->db,c->argv[1],new);\n        } else {\n            dbAdd(c->db,c->argv[1],new);\n        }\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrby\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c, value);\n}\n\nvoid incrCommand(client *c) {\n    incrDecrCommand(c,1);\n}\n\nvoid decrCommand(client *c) {\n    incrDecrCommand(c,-1);\n}\n\nvoid incrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    incrDecrCommand(c,incr);\n}\n\nvoid decrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    /* Overflow check: negating LLONG_MIN will cause an overflow */\n    if (incr == LLONG_MIN) {\n        addReplyError(c, \"decrement would overflow\");\n        return;\n    }\n    incrDecrCommand(c,-incr);\n}\n\nvoid incrbyfloatCommand(client *c) {\n    long double incr, value;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||\n        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)\n        return;\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    new = createStringObjectFromLongDouble(value,1);\n    if (o)\n        dbReplaceValue(c->db,c->argv[1],new);\n    else\n        dbAdd(c->db,c->argv[1],new);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyBulk(c,new);\n\n    /* Always replicate INCRBYFLOAT as a SET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    rewriteClientCommandArgument(c,0,shared.set);\n    rewriteClientCommandArgument(c,2,new);\n    rewriteClientCommandArgument(c,3,shared.keepttl);\n}\n\nvoid appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}\n\nvoid strlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n    addReplyLongLong(c,stringObjectLen(o));\n}\n\n/* LCS key1 key2 [LEN] [IDX] [MINMATCHLEN <len>] [WITHMATCHLEN] */\nvoid lcsCommand(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    obja = lookupKeyRead(c->db,c->argv[1]);\n    objb = lookupKeyRead(c->db,c->argv[2]);\n    if ((obja && obja->type != OBJ_STRING) ||\n        (objb && objb->type != OBJ_STRING))\n    {\n        addReplyError(c,\n            \"The specified keys must contain string values\");\n        /* Don't cleanup the objects, we need to do that\n         * only after calling getDecodedObject(). */\n        obja = NULL;\n        objb = NULL;\n        goto cleanup;\n    }\n    obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n    objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n    a = obja->ptr;\n    b = objb->ptr;\n\n    for (j = 3; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Detect string truncation or later overflows. */\n    if (sdslen(a) >= UINT32_MAX-1 || sdslen(b) >= UINT32_MAX-1) {\n        addReplyError(c, \"String too long for LCS\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*i] */\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Try to allocate the LCS table, and abort on overflow or insufficient memory. */\n    unsigned long long lcssize = (unsigned long long)(alen+1)*(blen+1); /* Can't overflow due to the size limits above. */\n    unsigned long long lcsalloc = lcssize * sizeof(uint32_t);\n    uint32_t *lcs = NULL;\n    if (lcsalloc < SIZE_MAX && lcsalloc / lcssize == sizeof(uint32_t)) {\n        if (lcsalloc > (size_t)server.proto_max_bulk_len) {\n            addReplyError(c, \"Insufficient memory, transient memory for LCS exceeds proto-max-bulk-len\");\n            goto cleanup;\n        }\n        lcs = ztrymalloc(lcsalloc);\n    }\n    if (!lcs) {\n        addReplyError(c, \"Insufficient memory, failed allocating transient memory for LCS\");\n        goto cleanup;\n    }\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deferred length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}\n\n", "start_server {\n    tags {\"sort\"}\n    overrides {\n        \"list-max-ziplist-size\" 16\n        \"set-max-intset-entries\" 32\n    }\n} {\n    proc create_random_dataset {num cmd} {\n        set tosort {}\n        set result {}\n        array set seenrand {}\n        r del tosort\n        for {set i 0} {$i < $num} {incr i} {\n            # Make sure all the weights are different because\n            # Redis does not use a stable sort but Tcl does.\n            while 1 {\n                randpath {\n                    set rint [expr int(rand()*1000000)]\n                } {\n                    set rint [expr rand()]\n                }\n                if {![info exists seenrand($rint)]} break\n            }\n            set seenrand($rint) x\n            r $cmd tosort $i\n            r set weight_$i $rint\n            r hset wobj_$i weight $rint\n            lappend tosort [list $i $rint]\n        }\n        set sorted [lsort -index 1 -real $tosort]\n        for {set i 0} {$i < $num} {incr i} {\n            lappend result [lindex $sorted $i 0]\n        }\n        set _ $result\n    }\n\n    proc check_sort_store_encoding {key} {\n        set listpack_max_size [lindex [r config get list-max-ziplist-size] 1]\n\n        # When the length or size of quicklist is less than the limit,\n        # it will be converted to listpack.\n        if {[r llen $key] <= $listpack_max_size} {\n            assert_encoding listpack $key\n        } else {\n            assert_encoding quicklist $key\n        }\n    }\n\n    foreach {num cmd enc title} {\n        16 lpush listpack \"Listpack\"\n        1000 lpush quicklist \"Quicklist\"\n        10000 lpush quicklist \"Big Quicklist\"\n        16 sadd intset \"Intset\"\n        1000 sadd hashtable \"Hash table\"\n        10000 sadd hashtable \"Big Hash table\"\n    } {\n        set result [create_random_dataset $num $cmd]\n        assert_encoding $enc tosort\n\n        test \"$title: SORT BY key\" {\n            assert_equal $result [r sort tosort BY weight_*]\n        } {} {cluster:skip}\n\n        test \"$title: SORT BY key with limit\" {\n            assert_equal [lrange $result 5 9] [r sort tosort BY weight_* LIMIT 5 5]\n        } {} {cluster:skip}\n\n        test \"$title: SORT BY hash field\" {\n            assert_equal $result [r sort tosort BY wobj_*->weight]\n        } {} {cluster:skip}\n    }\n\n    set result [create_random_dataset 16 lpush]\n    test \"SORT GET #\" {\n        assert_equal [lsort -integer $result] [r sort tosort GET #]\n    } {} {cluster:skip}\n\n    test \"SORT GET <const>\" {\n        r del foo\n        set res [r sort tosort GET foo]\n        assert_equal 16 [llength $res]\n        foreach item $res { assert_equal {} $item }\n    } {} {cluster:skip}\n\n    test \"SORT GET (key and hash) with sanity check\" {\n        set l1 [r sort tosort GET # GET weight_*]\n        set l2 [r sort tosort GET # GET wobj_*->weight]\n        foreach {id1 w1} $l1 {id2 w2} $l2 {\n            assert_equal $id1 $id2\n            assert_equal $w1 [r get weight_$id1]\n            assert_equal $w2 [r get weight_$id1]\n        }\n    } {} {cluster:skip}\n\n    test \"SORT BY key STORE\" {\n        r sort tosort BY weight_* store sort-res\n        assert_equal $result [r lrange sort-res 0 -1]\n        assert_equal 16 [r llen sort-res]\n        check_sort_store_encoding sort-res\n    } {} {cluster:skip}\n\n    test \"SORT BY hash field STORE\" {\n        r sort tosort BY wobj_*->weight store sort-res\n        assert_equal $result [r lrange sort-res 0 -1]\n        assert_equal 16 [r llen sort-res]\n        check_sort_store_encoding sort-res\n    } {} {cluster:skip}\n\n    test \"SORT extracts STORE correctly\" {\n        r command getkeys sort abc store def\n    } {abc def}\n\n    test \"SORT extracts multiple STORE correctly\" {\n        r command getkeys sort abc store invalid store stillbad store def\n    } {abc def}\n\n    test \"SORT DESC\" {\n        assert_equal [lsort -decreasing -integer $result] [r sort tosort DESC]\n    }\n\n    test \"SORT ALPHA against integer encoded strings\" {\n        r del mylist\n        r lpush mylist 2\n        r lpush mylist 1\n        r lpush mylist 3\n        r lpush mylist 10\n        r sort mylist alpha\n    } {1 10 2 3}\n\n    test \"SORT sorted set\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        r sort zset alpha desc\n    } {e d c b a}\n\n    test \"SORT sorted set BY nosort should retain ordering\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        r multi\n        r sort zset by nosort asc\n        r sort zset by nosort desc\n        r exec\n    } {{a c e b d} {d b e c a}}\n\n    test \"SORT sorted set BY nosort + LIMIT\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        assert_equal [r sort zset by nosort asc limit 0 1] {a}\n        assert_equal [r sort zset by nosort desc limit 0 1] {d}\n        assert_equal [r sort zset by nosort asc limit 0 2] {a c}\n        assert_equal [r sort zset by nosort desc limit 0 2] {d b}\n        assert_equal [r sort zset by nosort limit 5 10] {}\n        assert_equal [r sort zset by nosort limit -10 100] {a c e b d}\n    }\n\n    test \"SORT sorted set BY nosort works as expected from scripts\" {\n        r del zset\n        r zadd zset 1 a\n        r zadd zset 5 b\n        r zadd zset 2 c\n        r zadd zset 10 d\n        r zadd zset 3 e\n        r eval {\n            return {redis.call('sort',KEYS[1],'by','nosort','asc'),\n                    redis.call('sort',KEYS[1],'by','nosort','desc')}\n        } 1 zset\n    } {{a c e b d} {d b e c a}}\n\n    test \"SORT sorted set: +inf and -inf handling\" {\n        r del zset\n        r zadd zset -100 a\n        r zadd zset 200 b\n        r zadd zset -300 c\n        r zadd zset 1000000 d\n        r zadd zset +inf max\n        r zadd zset -inf min\n        r zrange zset 0 -1\n    } {min c a b d max}\n\n    test \"SORT regression for issue #19, sorting floats\" {\n        r flushdb\n        set floats {1.1 5.10 3.10 7.44 2.1 5.75 6.12 0.25 1.15}\n        foreach x $floats {\n            r lpush mylist $x\n        }\n        assert_equal [lsort -real $floats] [r sort mylist]\n    }\n\n    test \"SORT with STORE returns zero if result is empty (github issue 224)\" {\n        r flushdb\n        r sort foo{t} store bar{t}\n    } {0}\n\n    test \"SORT with STORE does not create empty lists (github issue 224)\" {\n        r flushdb\n        r lpush foo{t} bar\n        r sort foo{t} alpha limit 10 10 store zap{t}\n        r exists zap{t}\n    } {0}\n\n    test \"SORT with STORE removes key if result is empty (github issue 227)\" {\n        r flushdb\n        r lpush foo{t} bar\n        r sort emptylist{t} store foo{t}\n        r exists foo{t}\n    } {0}\n\n    test \"SORT with BY <constant> and STORE should still order output\" {\n        r del myset mylist\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        r sort myset alpha by _ store mylist\n        r lrange mylist 0 -1\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z} {cluster:skip}\n\n    test \"SORT will complain with numerical sorting and bad doubles (1)\" {\n        r del myset\n        r sadd myset 1 2 3 4 not-a-double\n        set e {}\n        catch {r sort myset} e\n        set e\n    } {*ERR*double*}\n\n    test \"SORT will complain with numerical sorting and bad doubles (2)\" {\n        r del myset\n        r sadd myset 1 2 3 4\n        r mset score:1 10 score:2 20 score:3 30 score:4 not-a-double\n        set e {}\n        catch {r sort myset by score:*} e\n        set e\n    } {*ERR*double*} {cluster:skip}\n\n    test \"SORT BY sub-sorts lexicographically if score is the same\" {\n        r del myset\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        foreach ele {a aa aaa azz b c d e f g h i l m n o p q r s t u v z} {\n            set score:$ele 100\n        }\n        r sort myset by score:*\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z} {cluster:skip}\n\n    test \"SORT GET with pattern ending with just -> does not get hash field\" {\n        r del mylist\n        r lpush mylist a\n        r set x:a-> 100\n        r sort mylist by num get x:*->\n    } {100} {cluster:skip}\n\n    test \"SORT by nosort retains native order for lists\" {\n        r del testa\n        r lpush testa 2 1 4 3 5\n        r sort testa by nosort\n    } {5 3 4 1 2} {cluster:skip}\n\n    test \"SORT by nosort plus store retains native order for lists\" {\n        r del testa\n        r lpush testa 2 1 4 3 5\n        r sort testa by nosort store testb\n        r lrange testb 0 -1\n    } {5 3 4 1 2} {cluster:skip}\n\n    test \"SORT by nosort with limit returns based on original list order\" {\n        r sort testa by nosort limit 0 3 store testb\n        r lrange testb 0 -1\n    } {5 3 4} {cluster:skip}\n\n    test \"SORT_RO - Successful case\" {\n        r del mylist\n        r lpush mylist a\n        r set x:a 100\n        r sort_ro mylist by nosort get x:*->\n    } {100} {cluster:skip}\n\n    test \"SORT_RO - Cannot run with STORE arg\" {\n        catch {r sort_ro foolist STORE bar} e\n        set e\n    } {ERR syntax error}\n\n    tags {\"slow\"} {\n        set num 100\n        set res [create_random_dataset $num lpush]\n\n        test \"SORT speed, $num element list BY key, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort BY weight_* LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        } {} {cluster:skip}\n\n        test \"SORT speed, $num element list BY hash field, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort BY wobj_*->weight LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        } {} {cluster:skip}\n\n        test \"SORT speed, $num element list directly, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        }\n\n        test \"SORT speed, $num element list BY <const>, 100 times\" {\n            set start [clock clicks -milliseconds]\n            for {set i 0} {$i < 100} {incr i} {\n                set sorted [r sort tosort BY nokey LIMIT 0 10]\n            }\n            set elapsed [expr [clock clicks -milliseconds]-$start]\n            if {$::verbose} {\n                puts -nonewline \"\\n  Average time to sort: [expr double($elapsed)/100] milliseconds \"\n                flush stdout\n            }\n        } {} {cluster:skip}\n    }\n\n    test {SETRANGE with huge offset} {\n        r lpush L 2 1 0\n        # expecting a different outcome on 32 and 64 bit systems\n        foreach value {9223372036854775807 2147483647} {\n            catch {[r sort_ro L by a limit 2 $value]} res\n            if {![string match \"2\" $res] && ![string match \"*out of range*\" $res]} {\n                assert_not_equal $res \"expecting an error or 2\"\n            }\n        }\n    }\n}\n", "start_server {tags {\"string\"}} {\n    test {SET and GET an item} {\n        r set x foobar\n        r get x\n    } {foobar}\n\n    test {SET and GET an empty item} {\n        r set x {}\n        r get x\n    } {}\n\n    test {Very big payload in GET/SET} {\n        set buf [string repeat \"abcd\" 1000000]\n        r set foo $buf\n        r get foo\n    } [string repeat \"abcd\" 1000000]\n\n    tags {\"slow\"} {\n        test {Very big payload random access} {\n            set err {}\n            array set payload {}\n            for {set j 0} {$j < 100} {incr j} {\n                set size [expr 1+[randomInt 100000]]\n                set buf [string repeat \"pl-$j\" $size]\n                set payload($j) $buf\n                r set bigpayload_$j $buf\n            }\n            for {set j 0} {$j < 1000} {incr j} {\n                set index [randomInt 100]\n                set buf [r get bigpayload_$index]\n                if {$buf != $payload($index)} {\n                    set err \"Values differ: I set '$payload($index)' but I read back '$buf'\"\n                    break\n                }\n            }\n            unset payload\n            set _ $err\n        } {}\n\n        test {SET 10000 numeric keys and access all them in reverse order} {\n            r flushdb\n            set err {}\n            for {set x 0} {$x < 10000} {incr x} {\n                r set $x $x\n            }\n            set sum 0\n            for {set x 9999} {$x >= 0} {incr x -1} {\n                set val [r get $x]\n                if {$val ne $x} {\n                    set err \"Element at position $x is $val instead of $x\"\n                    break\n                }\n            }\n            set _ $err\n        } {}\n\n        test {DBSIZE should be 10000 now} {\n            r dbsize\n        } {10000}\n    }\n\n    test \"SETNX target key missing\" {\n        r del novar\n        assert_equal 1 [r setnx novar foobared]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX target key exists\" {\n        r set novar foobared\n        assert_equal 0 [r setnx novar blabla]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX against not-expired volatile key\" {\n        r set x 10\n        r expire x 10000\n        assert_equal 0 [r setnx x 20]\n        assert_equal 10 [r get x]\n    }\n\n    test \"SETNX against expired volatile key\" {\n        # Make it very unlikely for the key this test uses to be expired by the\n        # active expiry cycle. This is tightly coupled to the implementation of\n        # active expiry and dbAdd() but currently the only way to test that\n        # SETNX expires a key when it should have been.\n        for {set x 0} {$x < 9999} {incr x} {\n            r setex key-$x 3600 value\n        }\n\n        # This will be one of 10000 expiring keys. A cycle is executed every\n        # 100ms, sampling 10 keys for being expired or not.  This key will be\n        # expired for at most 1s when we wait 2s, resulting in a total sample\n        # of 100 keys. The probability of the success of this test being a\n        # false positive is therefore approx. 1%.\n        r set x 10\n        r expire x 1\n\n        # Wait for the key to expire\n        after 2000\n\n        assert_equal 1 [r setnx x 20]\n        assert_equal 20 [r get x]\n    }\n\n    test \"GETEX EX option\" {\n        r del foo\n        r set foo bar\n        r getex foo ex 10\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PX option\" {\n        r del foo\n        r set foo bar\n        r getex foo px 10000\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX EXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo pxat [expr [clock milliseconds] + 10000]\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX PERSIST option\" {\n        r del foo\n        r set foo bar ex 10\n        assert_range [r ttl foo] 5 10\n        r getex foo persist\n        assert_equal -1 [r ttl foo]\n    }\n\n    test \"GETEX no option\" {\n        r del foo\n        r set foo bar\n        r getex foo\n        assert_equal bar [r getex foo]\n    }\n\n    test \"GETEX syntax errors\" {\n        set ex {}\n        catch {r getex foo non-existent-option} ex\n        set ex\n    } {*syntax*}\n\n    test \"GETEX no arguments\" {\n         set ex {}\n         catch {r getex} ex\n         set ex\n     } {*wrong number of arguments for 'getex' command}\n\n    test \"GETDEL command\" {\n        r del foo\n        r set foo bar\n        assert_equal bar [r getdel foo ]\n        assert_equal {} [r getdel foo ]\n    }\n\n    test {GETDEL propagate as DEL command to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getdel foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {GETEX without argument does not propagate to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getex foo\n        r del foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {MGET} {\n        r flushdb\n        r set foo{t} BAR\n        r set bar{t} FOO\n        r mget foo{t} bar{t}\n    } {BAR FOO}\n\n    test {MGET against non existing key} {\n        r mget foo{t} baazz{t} bar{t}\n    } {BAR {} FOO}\n\n    test {MGET against non-string key} {\n        r sadd myset{t} ciao\n        r sadd myset{t} bau\n        r mget foo{t} baazz{t} bar{t} myset{t}\n    } {BAR {} FOO {}}\n\n    test {GETSET (set new value)} {\n        r del foo\n        list [r getset foo xyz] [r get foo]\n    } {{} xyz}\n\n    test {GETSET (replace old value)} {\n        r set foo bar\n        list [r getset foo xyz] [r get foo]\n    } {bar xyz}\n\n    test {MSET base case} {\n        r mset x{t} 10 y{t} \"foo bar\" z{t} \"x x x x x x x\\n\\n\\r\\n\"\n        r mget x{t} y{t} z{t}\n    } [list 10 {foo bar} \"x x x x x x x\\n\\n\\r\\n\"]\n\n    test {MSET/MSETNX wrong number of args} {\n        assert_error {*wrong number of arguments for 'mset' command} {r mset x{t} 10 y{t} \"foo bar\" z{t}}\n        assert_error {*wrong number of arguments for 'msetnx' command} {r msetnx x{t} 20 y{t} \"foo bar\" z{t}}\n    }\n\n    test {MSETNX with already existent key} {\n        list [r msetnx x1{t} xxx y2{t} yyy x{t} 20] [r exists x1{t}] [r exists y2{t}]\n    } {0 0 0}\n\n    test {MSETNX with not existing keys} {\n        list [r msetnx x1{t} xxx y2{t} yyy] [r get x1{t}] [r get y2{t}]\n    } {1 xxx yyy}\n\n    test \"STRLEN against non-existing key\" {\n        assert_equal 0 [r strlen notakey]\n    }\n\n    test \"STRLEN against integer-encoded value\" {\n        r set myinteger -555\n        assert_equal 4 [r strlen myinteger]\n    }\n\n    test \"STRLEN against plain string\" {\n        r set mystring \"foozzz0123456789 baz\"\n        assert_equal 20 [r strlen mystring]\n    }\n\n    test \"SETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r setbit mykey 1 1]\n        assert_equal [binary format B* 01000000] [r get mykey]\n    }\n\n    test \"SETBIT against string-encoded key\" {\n        # Ascii \"@\" is integer 64 = 01 00 00 00\n        r set mykey \"@\"\n\n        assert_equal 0 [r setbit mykey 2 1]\n        assert_equal [binary format B* 01100000] [r get mykey]\n        assert_equal 1 [r setbit mykey 1 0]\n        assert_equal [binary format B* 00100000] [r get mykey]\n    }\n\n    test \"SETBIT against integer-encoded key\" {\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        r set mykey 1\n        assert_encoding int mykey\n\n        assert_equal 0 [r setbit mykey 6 1]\n        assert_equal [binary format B* 00110011] [r get mykey]\n        assert_equal 1 [r setbit mykey 2 0]\n        assert_equal [binary format B* 00010011] [r get mykey]\n    }\n\n    test \"SETBIT against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setbit mykey 0 1}\n    }\n\n    test \"SETBIT with out of range bit offset\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey [expr 4*1024*1024*1024] 1}\n        assert_error \"*out of range*\" {r setbit mykey -1 1}\n    }\n\n    test \"SETBIT with non-bit argument\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey 0 -1}\n        assert_error \"*out of range*\" {r setbit mykey 0  2}\n        assert_error \"*out of range*\" {r setbit mykey 0 10}\n        assert_error \"*out of range*\" {r setbit mykey 0 20}\n    }\n\n    test \"SETBIT fuzzing\" {\n        set str \"\"\n        set len [expr 256*8]\n        r del mykey\n\n        for {set i 0} {$i < 2000} {incr i} {\n            set bitnum [randomInt $len]\n            set bitval [randomInt 2]\n            set fmt [format \"%%-%ds%%d%%-s\" $bitnum]\n            set head [string range $str 0 $bitnum-1]\n            set tail [string range $str $bitnum+1 end]\n            set str [string map {\" \" 0} [format $fmt $head $bitval $tail]]\n\n            r setbit mykey $bitnum $bitval\n            assert_equal [binary format B* $str] [r get mykey]\n        }\n    }\n\n    test \"GETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r getbit mykey 0]\n    }\n\n    test \"GETBIT against string-encoded key\" {\n        # Single byte with 2nd and 3rd bit set\n        r set mykey \"`\"\n\n        # In-range\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 1 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 0 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"GETBIT against integer-encoded key\" {\n        r set mykey 1\n        assert_encoding int mykey\n\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 0 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 1 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"SETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal 3 [r setrange mykey 0 foo]\n        assert_equal \"foo\" [r get mykey]\n\n        r del mykey\n        assert_equal 0 [r setrange mykey 0 \"\"]\n        assert_equal 0 [r exists mykey]\n\n        r del mykey\n        assert_equal 4 [r setrange mykey 1 foo]\n        assert_equal \"\\000foo\" [r get mykey]\n    }\n\n    test \"SETRANGE against string-encoded key\" {\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 b]\n        assert_equal \"boo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 \"\"]\n        assert_equal \"foo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 1 b]\n        assert_equal \"fbo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 7 [r setrange mykey 4 bar]\n        assert_equal \"foo\\000bar\" [r get mykey]\n    }\n\n    test \"SETRANGE against integer-encoded key\" {\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 2]\n        assert_encoding raw mykey\n        assert_equal 2234 [r get mykey]\n\n        # Shouldn't change encoding when nothing is set\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 \"\"]\n        assert_encoding int mykey\n        assert_equal 1234 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 1 3]\n        assert_encoding raw mykey\n        assert_equal 1334 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 6 [r setrange mykey 5 2]\n        assert_encoding raw mykey\n        assert_equal \"1234\\0002\" [r get mykey]\n    }\n\n    test \"SETRANGE against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setrange mykey 0 bar}\n    }\n\n    test \"SETRANGE with out of range offset\" {\n        r del mykey\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n\n        r set mykey \"hello\"\n        assert_error \"*out of range*\" {r setrange mykey -1 world}\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n    }\n\n    test \"GETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal \"\" [r getrange mykey 0 -1]\n    }\n\n    test \"GETRANGE against string value\" {\n        r set mykey \"Hello World\"\n        assert_equal \"Hell\" [r getrange mykey 0 3]\n        assert_equal \"Hello World\" [r getrange mykey 0 -1]\n        assert_equal \"orld\" [r getrange mykey -4 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \" World\" [r getrange mykey 5 5000]\n        assert_equal \"Hello World\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE against integer-encoded value\" {\n        r set mykey 1234\n        assert_equal \"123\" [r getrange mykey 0 2]\n        assert_equal \"1234\" [r getrange mykey 0 -1]\n        assert_equal \"234\" [r getrange mykey -3 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \"4\" [r getrange mykey 3 5000]\n        assert_equal \"1234\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE fuzzing\" {\n        for {set i 0} {$i < 1000} {incr i} {\n            r set bin [set bin [randstring 0 1024 binary]]\n            set _start [set start [randomInt 1500]]\n            set _end [set end [randomInt 1500]]\n            if {$_start < 0} {set _start \"end-[abs($_start)-1]\"}\n            if {$_end < 0} {set _end \"end-[abs($_end)-1]\"}\n            assert_equal [string range $bin $_start $_end] [r getrange bin $start $end]\n        }\n    }\n\n    test {Extended SET can detect syntax errors} {\n        set e {}\n        catch {r set foo bar non-existing-option} e\n        set e\n    } {*syntax*}\n\n    test {Extended SET NX option} {\n        r del foo\n        set v1 [r set foo 1 nx]\n        set v2 [r set foo 2 nx]\n        list $v1 $v2 [r get foo]\n    } {OK {} 1}\n\n    test {Extended SET XX option} {\n        r del foo\n        set v1 [r set foo 1 xx]\n        r set foo bar\n        set v2 [r set foo 2 xx]\n        list $v1 $v2 [r get foo]\n    } {{} OK 2}\n\n    test {Extended SET GET option} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo bar2 GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar2}\n\n    test {Extended SET GET option with no previous value} {\n        r del foo\n        set old_value [r set foo bar GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with XX} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar baz}\n\n    test {Extended SET GET option with XX and no previous value} {\n        r del foo\n        set old_value [r set foo bar GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} {}}\n\n    test {Extended SET GET option with NX} {\n        r del foo\n        set old_value [r set foo bar GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with NX and previous value} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar}\n\n    test {Extended SET GET with incorrect type should result in wrong type error} {\n      r del foo\n      r rpush foo waffle\n      catch {r set foo bar GET} err1\n      assert_equal \"waffle\" [r rpop foo]\n      set err1\n    } {*WRONGTYPE*}\n\n    test {Extended SET EX option} {\n        r del foo\n        r set foo bar ex 10\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {Extended SET PX option} {\n        r del foo\n        r set foo bar px 10000\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test \"Extended SET EXAT option\" {\n        r del foo\n        r set foo bar exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"Extended SET PXAT option\" {\n        r del foo\n        r set foo bar pxat [expr [clock milliseconds] + 10000]\n        assert_range [r ttl foo] 5 10\n    }\n    test {Extended SET using multiple options at once} {\n        r set foo val\n        assert {[r set foo bar xx px 10000] eq {OK}}\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {GETRANGE with huge ranges, Github issue #1844} {\n        r set foo bar\n        r getrange foo 0 4294967297\n    } {bar}\n\n    set rna1 {CACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTTCGTCCGGGTGTG}\n    set rna2 {ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n    set rnalcs {ACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n\n    test {LCS basic} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t}\n    } $rnalcs\n\n    test {LCS len} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t} LEN\n    } [string length $rnalcs]\n\n    test {LCS indexes} {\n        dict get [r LCS virus1{t} virus2{t} IDX] matches\n    } {{{238 238} {239 239}} {{236 236} {238 238}} {{229 230} {236 237}} {{224 224} {235 235}} {{1 222} {13 234}}}\n\n    test {LCS indexes with match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN] matches\n    } {{{238 238} {239 239} 1} {{236 236} {238 238} 1} {{229 230} {236 237} 2} {{224 224} {235 235} 1} {{1 222} {13 234} 222}}\n\n    test {LCS indexes with match len and minimum match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN MINMATCHLEN 5] matches\n    } {{{1 222} {13 234} 222}}\n\n    test {SETRANGE with huge offset} {\n        foreach value {9223372036854775807 2147483647} {\n            catch {[r setrange K $value A]} res\n            # expecting a different error on 32 and 64 bit systems\n            if {![string match \"*string exceeds maximum allowed size*\" $res] && ![string match \"*out of range*\" $res]} {\n                assert_equal $res \"expecting an error\"\n           }\n        }\n    }\n}\n"], "filenames": ["src/sort.c", "src/t_string.c", "tests/unit/sort.tcl", "tests/unit/type/string.tcl"], "buggy_code_start_loc": [331, 40, 341, 600], "buggy_code_end_loc": [333, 708, 341, 600], "fixing_code_start_loc": [331, 40, 342, 601], "fixing_code_end_loc": [335, 713, 353, 611], "type": "CWE-190", "message": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions 7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-35977", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-20T19:15:14.470", "lastModified": "2023-02-02T14:28:46.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions 7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.17", "matchCriteriaId": "686AC0A4-C41D-483F-AB78-F000D3177488"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.9", "matchCriteriaId": "0987D1A6-7DB8-468A-92E2-4C9F4BC41430"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.8", "matchCriteriaId": "4E8878EC-13C4-4C33-A80E-5F1D4E7A5A19"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/releases/tag/6.0.17", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/releases/tag/6.2.9", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/releases/tag/7.0.8", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-mrcw-fhw9-fj8j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7"}}