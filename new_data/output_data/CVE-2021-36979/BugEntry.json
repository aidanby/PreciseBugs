{"buggy_code": ["/* Unicorn Emulator Engine */\n/* By Nguyen Anh Quynh, 2015 */\n\n/* Sample code to demonstrate how to emulate ARM code */\n\n#include <unicorn/unicorn.h>\n#include <string.h>\n\n\n// code to be emulated\n#define ARM_CODE \"\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0\" // mov r0, #0x37; sub r1, r2, r3\n#define THUMB_CODE \"\\x83\\xb0\" // sub    sp, #0xc\n\n// memory address where emulation starts\n#define ADDRESS 0x10000\n\nstatic void hook_block(uc_engine *uc, uint64_t address, uint32_t size, void *user_data)\n{\n    printf(\">>> Tracing basic block at 0x%\"PRIx64 \", block size = 0x%x\\n\", address, size);\n}\n\nstatic void hook_code(uc_engine *uc, uint64_t address, uint32_t size, void *user_data)\n{\n    printf(\">>> Tracing instruction at 0x%\"PRIx64 \", instruction size = 0x%x\\n\", address, size);\n}\n\nstatic void test_arm(void)\n{\n    uc_engine *uc;\n    uc_err err;\n    uc_hook trace1, trace2;\n\n    int r0 = 0x1234;     // R0 register\n    int r2 = 0x6789;     // R1 register\n    int r3 = 0x3333;     // R2 register\n    int r1;     // R1 register\n\n    printf(\"Emulate ARM code\\n\");\n\n    // Initialize emulator in ARM mode\n    err = uc_open(UC_ARCH_ARM, UC_MODE_ARM, &uc);\n    if (err) {\n        printf(\"Failed on uc_open() with error returned: %u (%s)\\n\",\n                err, uc_strerror(err));\n        return;\n    }\n\n    // map 2MB memory for this emulation\n    uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL);\n\n    // write machine code to be emulated to memory\n    uc_mem_write(uc, ADDRESS, ARM_CODE, sizeof(ARM_CODE) - 1);\n\n    // initialize machine registers\n    uc_reg_write(uc, UC_ARM_REG_R0, &r0);\n    uc_reg_write(uc, UC_ARM_REG_R2, &r2);\n    uc_reg_write(uc, UC_ARM_REG_R3, &r3);\n\n    // tracing all basic blocks with customized callback\n    uc_hook_add(uc, &trace1, UC_HOOK_BLOCK, hook_block, NULL, 1, 0);\n\n    // tracing one instruction at ADDRESS with customized callback\n    uc_hook_add(uc, &trace2, UC_HOOK_CODE, hook_code, NULL, ADDRESS, ADDRESS);\n\n    // emulate machine code in infinite time (last param = 0), or when\n    // finishing all the code.\n    err = uc_emu_start(uc, ADDRESS, ADDRESS + sizeof(ARM_CODE) -1, 0, 0);\n    if (err) {\n        printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n    }\n\n    // now print out some registers\n    printf(\">>> Emulation done. Below is the CPU context\\n\");\n\n    uc_reg_read(uc, UC_ARM_REG_R0, &r0);\n    uc_reg_read(uc, UC_ARM_REG_R1, &r1);\n    printf(\">>> R0 = 0x%x\\n\", r0);\n    printf(\">>> R1 = 0x%x\\n\", r1);\n\n    uc_close(uc);\n}\n\nstatic void test_thumb(void)\n{\n    uc_engine *uc;\n    uc_err err;\n    uc_hook trace1, trace2;\n\n    int sp = 0x1234;     // R0 register\n\n    printf(\"Emulate THUMB code\\n\");\n\n    // Initialize emulator in ARM mode\n    err = uc_open(UC_ARCH_ARM, UC_MODE_THUMB, &uc);\n    if (err) {\n        printf(\"Failed on uc_open() with error returned: %u (%s)\\n\",\n                err, uc_strerror(err));\n        return;\n    }\n\n    // map 2MB memory for this emulation\n    uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL);\n\n    // write machine code to be emulated to memory\n    uc_mem_write(uc, ADDRESS, THUMB_CODE, sizeof(THUMB_CODE) - 1);\n\n    // initialize machine registers\n    uc_reg_write(uc, UC_ARM_REG_SP, &sp);\n\n    // tracing all basic blocks with customized callback\n    uc_hook_add(uc, &trace1, UC_HOOK_BLOCK, hook_block, NULL, 1, 0);\n\n    // tracing one instruction at ADDRESS with customized callback\n    uc_hook_add(uc, &trace2, UC_HOOK_CODE, hook_code, NULL, ADDRESS, ADDRESS);\n\n    // emulate machine code in infinite time (last param = 0), or when\n    // finishing all the code.\n    // Note we start at ADDRESS | 1 to indicate THUMB mode.\n    err = uc_emu_start(uc, ADDRESS | 1, ADDRESS + sizeof(THUMB_CODE) -1, 0, 0);\n    if (err) {\n        printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n    }\n\n    // now print out some registers\n    printf(\">>> Emulation done. Below is the CPU context\\n\");\n\n    uc_reg_read(uc, UC_ARM_REG_SP, &sp);\n    printf(\">>> SP = 0x%x\\n\", sp);\n\n    uc_close(uc);\n}\n\nint main(int argc, char **argv, char **envp)\n{\n    // dynamically load shared library\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}\n"], "fixing_code": ["/* Unicorn Emulator Engine */\n/* By Nguyen Anh Quynh, 2015 */\n\n/* Sample code to demonstrate how to emulate ARM code */\n\n#include <unicorn/unicorn.h>\n#include <string.h>\n\n\n// code to be emulated\n#define ARM_CODE \"\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0\" // mov r0, #0x37; sub r1, r2, r3\n#define THUMB_CODE \"\\x83\\xb0\" // sub    sp, #0xc\n\n#define ARM_THUM_COND_CODE \"\\x9a\\x42\\x14\\xbf\\x68\\x22\\x4d\\x22\" // 'cmp r2, r3\\nit ne\\nmov r2, #0x68\\nmov r2, #0x4d'\n\n// memory address where emulation starts\n#define ADDRESS 0x10000\n\nstatic void hook_block(uc_engine *uc, uint64_t address, uint32_t size, void *user_data)\n{\n    printf(\">>> Tracing basic block at 0x%\"PRIx64 \", block size = 0x%x\\n\", address, size);\n}\n\nstatic void hook_code(uc_engine *uc, uint64_t address, uint32_t size, void *user_data)\n{\n    printf(\">>> Tracing instruction at 0x%\"PRIx64 \", instruction size = 0x%x\\n\", address, size);\n}\n\nstatic void test_arm(void)\n{\n    uc_engine *uc;\n    uc_err err;\n    uc_hook trace1, trace2;\n\n    int r0 = 0x1234;     // R0 register\n    int r2 = 0x6789;     // R1 register\n    int r3 = 0x3333;     // R2 register\n    int r1;     // R1 register\n\n    printf(\"Emulate ARM code\\n\");\n\n    // Initialize emulator in ARM mode\n    err = uc_open(UC_ARCH_ARM, UC_MODE_ARM, &uc);\n    if (err) {\n        printf(\"Failed on uc_open() with error returned: %u (%s)\\n\",\n                err, uc_strerror(err));\n        return;\n    }\n\n    // map 2MB memory for this emulation\n    uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL);\n\n    // write machine code to be emulated to memory\n    uc_mem_write(uc, ADDRESS, ARM_CODE, sizeof(ARM_CODE) - 1);\n\n    // initialize machine registers\n    uc_reg_write(uc, UC_ARM_REG_R0, &r0);\n    uc_reg_write(uc, UC_ARM_REG_R2, &r2);\n    uc_reg_write(uc, UC_ARM_REG_R3, &r3);\n\n    // tracing all basic blocks with customized callback\n    uc_hook_add(uc, &trace1, UC_HOOK_BLOCK, hook_block, NULL, 1, 0);\n\n    // tracing one instruction at ADDRESS with customized callback\n    uc_hook_add(uc, &trace2, UC_HOOK_CODE, hook_code, NULL, ADDRESS, ADDRESS);\n\n    // emulate machine code in infinite time (last param = 0), or when\n    // finishing all the code.\n    err = uc_emu_start(uc, ADDRESS, ADDRESS + sizeof(ARM_CODE) -1, 0, 0);\n    if (err) {\n        printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n    }\n\n    // now print out some registers\n    printf(\">>> Emulation done. Below is the CPU context\\n\");\n\n    uc_reg_read(uc, UC_ARM_REG_R0, &r0);\n    uc_reg_read(uc, UC_ARM_REG_R1, &r1);\n    printf(\">>> R0 = 0x%x\\n\", r0);\n    printf(\">>> R1 = 0x%x\\n\", r1);\n\n    uc_close(uc);\n}\n\nstatic void test_thumb(void)\n{\n    uc_engine *uc;\n    uc_err err;\n    uc_hook trace1, trace2;\n\n    int sp = 0x1234;     // R0 register\n\n    printf(\"Emulate THUMB code\\n\");\n\n    // Initialize emulator in ARM mode\n    err = uc_open(UC_ARCH_ARM, UC_MODE_THUMB, &uc);\n    if (err) {\n        printf(\"Failed on uc_open() with error returned: %u (%s)\\n\",\n                err, uc_strerror(err));\n        return;\n    }\n\n    // map 2MB memory for this emulation\n    uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL);\n\n    // write machine code to be emulated to memory\n    uc_mem_write(uc, ADDRESS, THUMB_CODE, sizeof(THUMB_CODE) - 1);\n\n    // initialize machine registers\n    uc_reg_write(uc, UC_ARM_REG_SP, &sp);\n\n    // tracing all basic blocks with customized callback\n    uc_hook_add(uc, &trace1, UC_HOOK_BLOCK, hook_block, NULL, 1, 0);\n\n    // tracing one instruction at ADDRESS with customized callback\n    uc_hook_add(uc, &trace2, UC_HOOK_CODE, hook_code, NULL, ADDRESS, ADDRESS);\n\n    // emulate machine code in infinite time (last param = 0), or when\n    // finishing all the code.\n    // Note we start at ADDRESS | 1 to indicate THUMB mode.\n    err = uc_emu_start(uc, ADDRESS | 1, ADDRESS + sizeof(THUMB_CODE) -1, 0, 0);\n    if (err) {\n        printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n    }\n\n    // now print out some registers\n    printf(\">>> Emulation done. Below is the CPU context\\n\");\n\n    uc_reg_read(uc, UC_ARM_REG_SP, &sp);\n    printf(\">>> SP = 0x%x\\n\", sp);\n\n    uc_close(uc);\n}\n\nstatic void test_thumb_ite() {\n    uc_engine *uc;\n    uc_err err;\n\n    uint32_t sp = 0x1234;\n    uint32_t r2 = 0, r3 = 1;\n    uint32_t step_r2, step_r3;\n\n    int i, addr=ADDRESS;\n\n    printf(\"Emulate a THUMB ITE block as a whole or per instruction.\\n\");\n    err = uc_open(UC_ARCH_ARM, UC_MODE_THUMB, &uc);\n    if (err) {\n        printf(\"Failed on uc_open() with error returned: %u (%s)\\n\",\n                err, uc_strerror(err));\n        return;\n    }\n\n    uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL);\n\n    uc_mem_write(uc, ADDRESS, ARM_THUM_COND_CODE, sizeof(ARM_THUM_COND_CODE) - 1);\n\n    uc_reg_write(uc, UC_ARM_REG_SP, &sp);\n\n    uc_reg_write(uc, UC_ARM_REG_R2, &r2);\n    uc_reg_write(uc, UC_ARM_REG_R3, &r3);\n\n    // Run once.\n    printf(\"Running the entire binary.\\n\");\n    err = uc_emu_start(uc, ADDRESS | 1, ADDRESS + sizeof(ARM_THUM_COND_CODE) - 1, 0, 0);\n    if (err) {\n        printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n    }\n    uc_reg_read(uc, UC_ARM_REG_R2, &r2);\n    uc_reg_read(uc, UC_ARM_REG_R3, &r3);\n\n    printf(\">>> R2: %d\\n\", r2);\n    printf(\">>> R3: %d\\n\\n\", r3);\n\n    // Step each instruction.\n    printf(\"Running the binary one instruction at a time.\\n\");\n    for (i = 0; i < sizeof(ARM_THUM_COND_CODE) / 2; i++) {\n        err = uc_emu_start(uc, addr | 1, ADDRESS + sizeof(ARM_THUM_COND_CODE) - 1, 0, 1);\n        if (err) {\n            printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n        }\n        uc_reg_read(uc, UC_ARM_REG_PC, &addr);\n    }\n\n    uc_reg_read(uc, UC_ARM_REG_R2, &step_r2);\n    uc_reg_read(uc, UC_ARM_REG_R3, &step_r3);\n\n    printf(\">>> R2: %d\\n\", step_r2);\n    printf(\">>> R3: %d\\n\\n\", step_r3);\n\n    if (step_r2 != r2 || step_r3 != r3) {\n        printf(\"Failed with ARM ITE blocks stepping!\\n\");\n    }\n\n    uc_close(uc);\n}\n\n\nint main(int argc, char **argv, char **envp)\n{\n    // dynamically load shared library\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n    printf(\"==========================\\n\");\n    test_thumb_ite();\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}\n"], "filenames": ["samples/sample_arm.c"], "buggy_code_start_loc": [12], "buggy_code_end_loc": [150], "fixing_code_start_loc": [13], "fixing_code_end_loc": [216], "type": "CWE-787", "message": "Unicorn Engine 1.0.2 has an out-of-bounds write in tb_flush_armeb (called from cpu_arm_exec_armeb and tcg_cpu_exec_armeb).", "other": {"cve": {"id": "CVE-2021-36979", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T07:15:08.073", "lastModified": "2021-12-03T13:48:49.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unicorn Engine 1.0.2 has an out-of-bounds write in tb_flush_armeb (called from cpu_arm_exec_armeb and tcg_cpu_exec_armeb)."}, {"lang": "es", "value": "Unicorn Engine versi\u00f3n 1.0.2, presenta una escritura fuera de l\u00edmites en la funci\u00f3n tb_flush_armeb (llamada desde cpu_arm_exec_armeb y tcg_cpu_exec_armeb)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unicorn-engine:unicorn_engine:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "33135846-E398-4788-9B35-2F1B515E6BE6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=30391", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/unicorn/OSV-2020-2305.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/unicorn-engine/unicorn/commit/bf1713d9e011b55ca1f502a6779fc4722b4bb077", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MZ6LOCJXHQVU6SCJLFDJINBOVJYYENLX/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/unicorn-engine/unicorn/commit/bf1713d9e011b55ca1f502a6779fc4722b4bb077"}}