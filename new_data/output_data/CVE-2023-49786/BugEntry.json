{"buggy_code": ["/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 1999 - 2008, Digium, Inc.\n *\n * Mark Spencer <markster@digium.com>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */\n\n/*!\n * \\file\n *\n * \\brief Supports RTP and RTCP with Symmetric RTP support for NAT traversal.\n *\n * \\author Mark Spencer <markster@digium.com>\n *\n * \\note RTP is defined in RFC 3550.\n *\n * \\ingroup rtp_engines\n */\n\n/*** MODULEINFO\n\t<use type=\"external\">openssl</use>\n\t<use type=\"external\">pjproject</use>\n\t<support_level>core</support_level>\n ***/\n\n#include \"asterisk.h\"\n\n#include <arpa/nameser.h>\n#include \"asterisk/dns_core.h\"\n#include \"asterisk/dns_internal.h\"\n#include \"asterisk/dns_recurring.h\"\n\n#include <sys/time.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <math.h>\n\n#ifdef HAVE_OPENSSL\n#include <openssl/opensslconf.h>\n#include <openssl/opensslv.h>\n#if !defined(OPENSSL_NO_SRTP) && (OPENSSL_VERSION_NUMBER >= 0x10001000L)\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/bio.h>\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n#include <openssl/bn.h>\n#endif\n#ifndef OPENSSL_NO_DH\n#include <openssl/dh.h>\n#endif\n#endif\n#endif\n\n#ifdef HAVE_PJPROJECT\n#include <pjlib.h>\n#include <pjlib-util.h>\n#include <pjnath.h>\n#include <ifaddrs.h>\n#endif\n\n#include \"asterisk/conversions.h\"\n#include \"asterisk/options.h\"\n#include \"asterisk/logger_category.h\"\n#include \"asterisk/stun.h\"\n#include \"asterisk/pbx.h\"\n#include \"asterisk/frame.h\"\n#include \"asterisk/format_cache.h\"\n#include \"asterisk/channel.h\"\n#include \"asterisk/acl.h\"\n#include \"asterisk/config.h\"\n#include \"asterisk/lock.h\"\n#include \"asterisk/utils.h\"\n#include \"asterisk/cli.h\"\n#include \"asterisk/manager.h\"\n#include \"asterisk/unaligned.h\"\n#include \"asterisk/module.h\"\n#include \"asterisk/rtp_engine.h\"\n#include \"asterisk/smoother.h\"\n#include \"asterisk/uuid.h\"\n#include \"asterisk/test.h\"\n#include \"asterisk/data_buffer.h\"\n#ifdef HAVE_PJPROJECT\n#include \"asterisk/res_pjproject.h\"\n#include \"asterisk/security_events.h\"\n#endif\n\n#define MAX_TIMESTAMP_SKEW\t640\n\n#define RTP_SEQ_MOD     (1<<16)\t/*!< A sequence number can't be more than 16 bits */\n#define RTCP_DEFAULT_INTERVALMS   5000\t/*!< Default milli-seconds between RTCP reports we send */\n#define RTCP_MIN_INTERVALMS       500\t/*!< Min milli-seconds between RTCP reports we send */\n#define RTCP_MAX_INTERVALMS       60000\t/*!< Max milli-seconds between RTCP reports we send */\n\n#define DEFAULT_RTP_START 5000 /*!< Default port number to start allocating RTP ports from */\n#define DEFAULT_RTP_END 31000  /*!< Default maximum port number to end allocating RTP ports at */\n\n#define MINIMUM_RTP_PORT 1024 /*!< Minimum port number to accept */\n#define MAXIMUM_RTP_PORT 65535 /*!< Maximum port number to accept */\n\n#define DEFAULT_TURN_PORT 3478\n\n#define TURN_STATE_WAIT_TIME 2000\n\n#define DEFAULT_RTP_SEND_BUFFER_SIZE\t250\t/*!< The initial size of the RTP send buffer */\n#define MAXIMUM_RTP_SEND_BUFFER_SIZE\t(DEFAULT_RTP_SEND_BUFFER_SIZE + 200)\t/*!< Maximum RTP send buffer size */\n#define DEFAULT_RTP_RECV_BUFFER_SIZE\t20\t/*!< The initial size of the RTP receiver buffer */\n#define MAXIMUM_RTP_RECV_BUFFER_SIZE\t(DEFAULT_RTP_RECV_BUFFER_SIZE + 20)\t/*!< Maximum RTP receive buffer size */\n#define OLD_PACKET_COUNT\t\t1000\t/*!< The number of previous packets that are considered old */\n#define MISSING_SEQNOS_ADDED_TRIGGER \t2\t/*!< The number of immediate missing packets that will trigger an immediate NACK */\n\n#define SEQNO_CYCLE_OVER\t\t65536\t/*!< The number after the maximum allowed sequence number */\n\n/*! Full INTRA-frame Request / Fast Update Request (From RFC2032) */\n#define RTCP_PT_FUR     192\n/*! Sender Report (From RFC3550) */\n#define RTCP_PT_SR      AST_RTP_RTCP_SR\n/*! Receiver Report (From RFC3550) */\n#define RTCP_PT_RR      AST_RTP_RTCP_RR\n/*! Source Description (From RFC3550) */\n#define RTCP_PT_SDES    202\n/*! Goodbye (To remove SSRC's from tables) (From RFC3550) */\n#define RTCP_PT_BYE     203\n/*! Application defined (From RFC3550) */\n#define RTCP_PT_APP     204\n/* VP8: RTCP Feedback */\n/*! Payload Specific Feed Back (From RFC4585 also RFC5104) */\n#define RTCP_PT_PSFB    AST_RTP_RTCP_PSFB\n\n#define RTP_MTU\t\t1200\n#define DTMF_SAMPLE_RATE_MS    8 /*!< DTMF samples per millisecond */\n\n#define DEFAULT_DTMF_TIMEOUT (150 * (8000 / 1000))\t/*!< samples */\n\n#define ZFONE_PROFILE_ID 0x505a\n\n#define DEFAULT_LEARNING_MIN_SEQUENTIAL 4\n/*!\n * \\brief Calculate the min learning duration in ms.\n *\n * \\details\n * The min supported packet size represents 10 ms and we need to account\n * for some jitter and fast clocks while learning.  Some messed up devices\n * have very bad jitter for a small packet sample size.  Jitter can also\n * be introduced by the network itself.\n *\n * So we'll allow packets to come in every 9ms on average for fast clocking\n * with the last one coming in 5ms early for jitter.\n */\n#define CALC_LEARNING_MIN_DURATION(count) (((count) - 1) * 9 - 5)\n#define DEFAULT_LEARNING_MIN_DURATION CALC_LEARNING_MIN_DURATION(DEFAULT_LEARNING_MIN_SEQUENTIAL)\n\n#define SRTP_MASTER_KEY_LEN 16\n#define SRTP_MASTER_SALT_LEN 14\n#define SRTP_MASTER_LEN (SRTP_MASTER_KEY_LEN + SRTP_MASTER_SALT_LEN)\n\n#define RTP_DTLS_ESTABLISHED -37\n\nenum strict_rtp_state {\n\tSTRICT_RTP_OPEN = 0, /*! No RTP packets should be dropped, all sources accepted */\n\tSTRICT_RTP_LEARN,    /*! Accept next packet as source */\n\tSTRICT_RTP_CLOSED,   /*! Drop all RTP packets not coming from source that was learned */\n};\n\nenum strict_rtp_mode {\n\tSTRICT_RTP_NO = 0,\t/*! Don't adhere to any strict RTP rules */\n\tSTRICT_RTP_YES,\t\t/*! Strict RTP that restricts packets based on time and sequence number */\n\tSTRICT_RTP_SEQNO,\t/*! Strict RTP that restricts packets based on sequence number */\n};\n\n/*!\n * \\brief Strict RTP learning timeout time in milliseconds\n *\n * \\note Set to 5 seconds to allow reinvite chains for direct media\n * to settle before media actually starts to arrive.  There may be a\n * reinvite collision involved on the other leg.\n */\n#define STRICT_RTP_LEARN_TIMEOUT\t5000\n\n#define DEFAULT_STRICT_RTP STRICT_RTP_YES\t/*!< Enabled by default */\n#define DEFAULT_SRTP_REPLAY_PROTECTION 1\n#define DEFAULT_ICESUPPORT 1\n#define DEFAULT_STUN_SOFTWARE_ATTRIBUTE 1\n#define DEFAULT_DTLS_MTU 1200\n\n/*!\n * Because both ends usually don't start sending RTP\n * at the same time, some of the calculations like\n * rtt and jitter will probably be unstable for a while\n * so we'll skip some received packets before starting\n * analyzing.  This just affects analyzing; we still\n * process the RTP as normal.\n */\n#define RTP_IGNORE_FIRST_PACKETS_COUNT 15\n\nextern struct ast_srtp_res *res_srtp;\nextern struct ast_srtp_policy_res *res_srtp_policy;\n\nstatic int dtmftimeout = DEFAULT_DTMF_TIMEOUT;\n\nstatic int rtpstart = DEFAULT_RTP_START;\t\t\t/*!< First port for RTP sessions (set in rtp.conf) */\nstatic int rtpend = DEFAULT_RTP_END;\t\t\t/*!< Last port for RTP sessions (set in rtp.conf) */\nstatic int rtcpstats;\t\t\t/*!< Are we debugging RTCP? */\nstatic int rtcpinterval = RTCP_DEFAULT_INTERVALMS; /*!< Time between rtcp reports in millisecs */\nstatic struct ast_sockaddr rtpdebugaddr;\t/*!< Debug packets to/from this host */\nstatic struct ast_sockaddr rtcpdebugaddr;\t/*!< Debug RTCP packets to/from this host */\nstatic int rtpdebugport;\t\t/*!< Debug only RTP packets from IP or IP+Port if port is > 0 */\nstatic int rtcpdebugport;\t\t/*!< Debug only RTCP packets from IP or IP+Port if port is > 0 */\n#ifdef SO_NO_CHECK\nstatic int nochecksums;\n#endif\nstatic int strictrtp = DEFAULT_STRICT_RTP; /*!< Only accept RTP frames from a defined source. If we receive an indication of a changing source, enter learning mode. */\nstatic int learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL; /*!< Number of sequential RTP frames needed from a single source during learning mode to accept new source. */\nstatic int learning_min_duration = DEFAULT_LEARNING_MIN_DURATION; /*!< Lowest acceptable timeout between the first and the last sequential RTP frame. */\nstatic int srtp_replay_protection = DEFAULT_SRTP_REPLAY_PROTECTION;\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int dtls_mtu = DEFAULT_DTLS_MTU;\n#endif\n#ifdef HAVE_PJPROJECT\nstatic int icesupport = DEFAULT_ICESUPPORT;\nstatic int stun_software_attribute = DEFAULT_STUN_SOFTWARE_ATTRIBUTE;\nstatic struct sockaddr_in stunaddr;\nstatic pj_str_t turnaddr;\nstatic int turnport = DEFAULT_TURN_PORT;\nstatic pj_str_t turnusername;\nstatic pj_str_t turnpassword;\nstatic struct stasis_subscription *acl_change_sub = NULL;\nstatic struct ast_sockaddr lo6 = { .len = 0 };\n\n/*! ACL for ICE addresses */\nstatic struct ast_acl_list *ice_acl = NULL;\nstatic ast_rwlock_t ice_acl_lock = AST_RWLOCK_INIT_VALUE;\n\n/*! ACL for STUN requests */\nstatic struct ast_acl_list *stun_acl = NULL;\nstatic ast_rwlock_t stun_acl_lock = AST_RWLOCK_INIT_VALUE;\n\n/*! stunaddr recurring resolution */\nstatic ast_rwlock_t stunaddr_lock = AST_RWLOCK_INIT_VALUE;\nstatic struct ast_dns_query_recurring *stunaddr_resolver = NULL;\n\n/*! \\brief Pool factory used by pjlib to allocate memory. */\nstatic pj_caching_pool cachingpool;\n\n/*! \\brief Global memory pool for configuration and timers */\nstatic pj_pool_t *pool;\n\n/*! \\brief Global timer heap */\nstatic pj_timer_heap_t *timer_heap;\n\n/*! \\brief Thread executing the timer heap */\nstatic pj_thread_t *timer_thread;\n\n/*! \\brief Used to tell the timer thread to terminate */\nstatic int timer_terminate;\n\n/*! \\brief Structure which contains ioqueue thread information */\nstruct ast_rtp_ioqueue_thread {\n\t/*! \\brief Pool used by the thread */\n\tpj_pool_t *pool;\n\t/*! \\brief The thread handling the queue and timer heap */\n\tpj_thread_t *thread;\n\t/*! \\brief Ioqueue which polls on sockets */\n\tpj_ioqueue_t *ioqueue;\n\t/*! \\brief Timer heap for scheduled items */\n\tpj_timer_heap_t *timerheap;\n\t/*! \\brief Termination request */\n\tint terminate;\n\t/*! \\brief Current number of descriptors being waited on */\n\tunsigned int count;\n\t/*! \\brief Linked list information */\n\tAST_LIST_ENTRY(ast_rtp_ioqueue_thread) next;\n};\n\n/*! \\brief List of ioqueue threads */\nstatic AST_LIST_HEAD_STATIC(ioqueues, ast_rtp_ioqueue_thread);\n\n/*! \\brief Structure which contains ICE host candidate mapping information */\nstruct ast_ice_host_candidate {\n\tstruct ast_sockaddr local;\n\tstruct ast_sockaddr advertised;\n\tunsigned int include_local;\n\tAST_RWLIST_ENTRY(ast_ice_host_candidate) next;\n};\n\n/*! \\brief List of ICE host candidate mappings */\nstatic AST_RWLIST_HEAD_STATIC(host_candidates, ast_ice_host_candidate);\n\nstatic char *generate_random_string(char *buf, size_t size);\n\n#endif\n\n#define FLAG_3389_WARNING               (1 << 0)\n#define FLAG_NAT_ACTIVE                 (3 << 1)\n#define FLAG_NAT_INACTIVE               (0 << 1)\n#define FLAG_NAT_INACTIVE_NOWARN        (1 << 1)\n#define FLAG_NEED_MARKER_BIT            (1 << 3)\n#define FLAG_DTMF_COMPENSATE            (1 << 4)\n#define FLAG_REQ_LOCAL_BRIDGE_BIT       (1 << 5)\n\n#define TRANSPORT_SOCKET_RTP 0\n#define TRANSPORT_SOCKET_RTCP 1\n#define TRANSPORT_TURN_RTP 2\n#define TRANSPORT_TURN_RTCP 3\n\n/*! \\brief RTP learning mode tracking information */\nstruct rtp_learning_info {\n\tstruct ast_sockaddr proposed_address;\t/*!< Proposed remote address for strict RTP */\n\tstruct timeval start;\t/*!< The time learning mode was started */\n\tstruct timeval received; /*!< The time of the first received packet */\n\tint max_seq;\t/*!< The highest sequence number received */\n\tint packets;\t/*!< The number of remaining packets before the source is accepted */\n\t/*! Type of media stream carried by the RTP instance */\n\tenum ast_media_type stream_type;\n};\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstruct dtls_details {\n\tSSL *ssl;         /*!< SSL session */\n\tBIO *read_bio;    /*!< Memory buffer for reading */\n\tBIO *write_bio;   /*!< Memory buffer for writing */\n\tenum ast_rtp_dtls_setup dtls_setup; /*!< Current setup state */\n\tenum ast_rtp_dtls_connection connection; /*!< Whether this is a new or existing connection */\n\tint timeout_timer; /*!< Scheduler id for timeout timer */\n};\n#endif\n\n#ifdef HAVE_PJPROJECT\n/*! An ao2 wrapper protecting the PJPROJECT ice structure with ref counting. */\nstruct ice_wrap {\n\tpj_ice_sess *real_ice;           /*!< ICE session */\n};\n#endif\n\n/*! \\brief Structure used for mapping an incoming SSRC to an RTP instance */\nstruct rtp_ssrc_mapping {\n\t/*! \\brief The received SSRC */\n\tunsigned int ssrc;\n\t/*! True if the SSRC is available.  Otherwise, this is a placeholder mapping until the SSRC is set. */\n\tunsigned int ssrc_valid;\n\t/*! \\brief The RTP instance this SSRC belongs to*/\n\tstruct ast_rtp_instance *instance;\n};\n\n/*! \\brief Packet statistics (used for transport-cc) */\nstruct rtp_transport_wide_cc_packet_statistics {\n\t/*! The transport specific sequence number */\n\tunsigned int seqno;\n\t/*! The time at which the packet was received */\n\tstruct timeval received;\n\t/*! The delta between this packet and the previous */\n\tint delta;\n};\n\n/*! \\brief Statistics information (used for transport-cc) */\nstruct rtp_transport_wide_cc_statistics {\n\t/*! A vector of packet statistics */\n\tAST_VECTOR(, struct rtp_transport_wide_cc_packet_statistics) packet_statistics; /*!< Packet statistics, used for transport-cc */\n\t/*! The last sequence number received */\n\tunsigned int last_seqno;\n\t/*! The last extended sequence number */\n\tunsigned int last_extended_seqno;\n\t/*! How many feedback packets have gone out */\n\tunsigned int feedback_count;\n\t/*! How many cycles have occurred for the sequence numbers */\n\tunsigned int cycles;\n\t/*! Scheduler id for periodic feedback transmission */\n\tint schedid;\n};\n\ntypedef struct {\n\tunsigned int ts;\n\tunsigned char is_set;\n} optional_ts;\n\n/*! \\brief RTP session description */\nstruct ast_rtp {\n\tint s;\n\t/*! \\note The f.subclass.format holds a ref. */\n\tstruct ast_frame f;\n\tunsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];\n\tunsigned int ssrc;\t\t/*!< Synchronization source, RFC 3550, page 10. */\n\tunsigned int ssrc_orig;\t\t/*!< SSRC used before native bridge activated */\n\tunsigned char ssrc_saved;\t/*!< indicates if ssrc_orig has a value */\n\tchar cname[AST_UUID_STR_LEN]; /*!< Our local CNAME */\n\tunsigned int themssrc;\t\t/*!< Their SSRC */\n\tunsigned int themssrc_valid;\t/*!< True if their SSRC is available. */\n\tunsigned int lastts;\n\tunsigned int lastividtimestamp;\n\tunsigned int lastovidtimestamp;\n\tunsigned int lastitexttimestamp;\n\tunsigned int lastotexttimestamp;\n\tint prevrxseqno;                /*!< Previous received packeted sequence number, from the network */\n\tint lastrxseqno;                /*!< Last received sequence number, from the network */\n\tint expectedrxseqno;            /*!< Next expected sequence number, from the network */\n\tAST_VECTOR(, int) missing_seqno; /*!< A vector of sequence numbers we never received */\n\tint expectedseqno;\t\t/*!< Next expected sequence number, from the core */\n\tunsigned short seedrxseqno;     /*!< What sequence number did they start with?*/\n\tunsigned int rxcount;           /*!< How many packets have we received? */\n\tunsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/\n\tunsigned int txcount;           /*!< How many packets have we sent? */\n\tunsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/\n\tunsigned int cycles;            /*!< Shifted count of sequence number cycles */\n\tstruct ast_format *lasttxformat;\n\tstruct ast_format *lastrxformat;\n\n\t/*\n\t * RX RTP Timestamp and Jitter calculation.\n\t */\n\tdouble rxstart;                       /*!< RX time of the first packet in the session in seconds since EPOCH. */\n\tdouble rxstart_stable;                /*!< RX time of the first packet after RTP_IGNORE_FIRST_PACKETS_COUNT */\n\tunsigned int remote_seed_rx_rtp_ts;         /*!< RTP timestamp of first RX packet. */\n\tunsigned int remote_seed_rx_rtp_ts_stable;  /*!< RTP timestamp of first packet after RTP_IGNORE_FIRST_PACKETS_COUNT */\n\tunsigned int last_transit_time_samples;     /*!< The last transit time in samples */\n\tdouble rxjitter;                      /*!< Last calculated Interarrival jitter in seconds. */\n\tdouble rxjitter_samples;              /*!< Last calculated Interarrival jitter in samples. */\n\tdouble rxmes;                         /*!< Media Experince Score at the moment to be reported */\n\n\t/* DTMF Reception Variables */\n\tchar resp;                        /*!< The current digit being processed */\n\tunsigned int last_seqno;          /*!< The last known sequence number for any DTMF packet */\n\toptional_ts last_end_timestamp;   /*!< The last known timestamp received from an END packet */\n\tunsigned int dtmf_duration;       /*!< Total duration in samples since the digit start event */\n\tunsigned int dtmf_timeout;        /*!< When this timestamp is reached we consider END frame lost and forcibly abort digit */\n\tunsigned int dtmfsamples;\n\tenum ast_rtp_dtmf_mode dtmfmode;  /*!< The current DTMF mode of the RTP stream */\n\t/* DTMF Transmission Variables */\n\tunsigned int lastdigitts;\n\tchar sending_digit;\t/*!< boolean - are we sending digits */\n\tchar send_digit;\t/*!< digit we are sending */\n\tint send_payload;\n\tint send_duration;\n\tunsigned int flags;\n\tstruct timeval rxcore;\n\tstruct timeval txcore;\n\n\tstruct timeval dtmfmute;\n\tstruct ast_smoother *smoother;\n\tunsigned short seqno;\t\t/*!< Sequence number, RFC 3550, page 13. */\n\tstruct ast_sched_context *sched;\n\tstruct ast_rtcp *rtcp;\n\tunsigned int asymmetric_codec;  /*!< Indicate if asymmetric send/receive codecs are allowed */\n\n\tstruct ast_rtp_instance *bundled; /*!< The RTP instance we are bundled to */\n\t/*!\n\t * \\brief The RTP instance owning us (used for debugging purposes)\n\t * We don't hold a reference to the instance because it created\n\t * us in the first place.  It can't go away.\n\t */\n\tstruct ast_rtp_instance *owner;\n\tint stream_num; /*!< Stream num for this RTP instance */\n\tAST_VECTOR(, struct rtp_ssrc_mapping) ssrc_mapping; /*!< Mappings of SSRC to RTP instances */\n\tstruct ast_sockaddr bind_address; /*!< Requested bind address for the sockets */\n\n\tenum strict_rtp_state strict_rtp_state; /*!< Current state that strict RTP protection is in */\n\tstruct ast_sockaddr strict_rtp_address;  /*!< Remote address information for strict RTP purposes */\n\n\t/*\n\t * Learning mode values based on pjmedia's probation mode.  Many of these values are redundant to the above,\n\t * but these are in place to keep learning mode sequence values sealed from their normal counterparts.\n\t */\n\tstruct rtp_learning_info rtp_source_learn;\t/* Learning mode track for the expected RTP source */\n\n\tstruct rtp_red *red;\n\n\tstruct ast_data_buffer *send_buffer;\t\t/*!< Buffer for storing sent packets for retransmission */\n\tstruct ast_data_buffer *recv_buffer;\t\t/*!< Buffer for storing received packets for retransmission */\n\n\tstruct rtp_transport_wide_cc_statistics transport_wide_cc; /*!< Transport-cc statistics information */\n\n#ifdef HAVE_PJPROJECT\n\tast_cond_t cond;            /*!< ICE/TURN condition for signaling */\n\n\tstruct ice_wrap *ice;       /*!< ao2 wrapped ICE session */\n\tenum ast_rtp_ice_role role; /*!< Our role in ICE negotiation */\n\tpj_turn_sock *turn_rtp;     /*!< RTP TURN relay */\n\tpj_turn_sock *turn_rtcp;    /*!< RTCP TURN relay */\n\tpj_turn_state_t turn_state; /*!< Current state of the TURN relay session */\n\tunsigned int passthrough:1; /*!< Bit to indicate that the received packet should be passed through */\n\tunsigned int rtp_passthrough:1; /*!< Bit to indicate that TURN RTP should be passed through */\n\tunsigned int rtcp_passthrough:1; /*!< Bit to indicate that TURN RTCP should be passed through */\n\tunsigned int ice_port;      /*!< Port that ICE was started with if it was previously started */\n\tstruct ast_sockaddr rtp_loop; /*!< Loopback address for forwarding RTP from TURN */\n\tstruct ast_sockaddr rtcp_loop; /*!< Loopback address for forwarding RTCP from TURN */\n\n\tstruct ast_rtp_ioqueue_thread *ioqueue; /*!< The ioqueue thread handling us */\n\n\tchar remote_ufrag[256];  /*!< The remote ICE username */\n\tchar remote_passwd[256]; /*!< The remote ICE password */\n\n\tchar local_ufrag[256];  /*!< The local ICE username */\n\tchar local_passwd[256]; /*!< The local ICE password */\n\n\tstruct ao2_container *ice_local_candidates;           /*!< The local ICE candidates */\n\tstruct ao2_container *ice_active_remote_candidates;   /*!< The remote ICE candidates */\n\tstruct ao2_container *ice_proposed_remote_candidates; /*!< Incoming remote ICE candidates for new session */\n\tstruct ast_sockaddr ice_original_rtp_addr;            /*!< rtp address that ICE started on first session */\n\tunsigned int ice_num_components; /*!< The number of ICE components */\n\tunsigned int ice_media_started:1; /*!< ICE media has started, either on a valid pair or on ICE completion */\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tSSL_CTX *ssl_ctx; /*!< SSL context */\n\tenum ast_rtp_dtls_verify dtls_verify; /*!< What to verify */\n\tenum ast_srtp_suite suite;   /*!< SRTP crypto suite */\n\tenum ast_rtp_dtls_hash local_hash; /*!< Local hash used for the fingerprint */\n\tchar local_fingerprint[160]; /*!< Fingerprint of our certificate */\n\tenum ast_rtp_dtls_hash remote_hash; /*!< Remote hash used for the fingerprint */\n\tunsigned char remote_fingerprint[EVP_MAX_MD_SIZE]; /*!< Fingerprint of the peer certificate */\n\tunsigned int rekey; /*!< Interval at which to renegotiate and rekey */\n\tint rekeyid; /*!< Scheduled item id for rekeying */\n\tstruct dtls_details dtls; /*!< DTLS state information */\n#endif\n};\n\n/*!\n * \\brief Structure defining an RTCP session.\n *\n * The concept \"RTCP session\" is not defined in RFC 3550, but since\n * this structure is analogous to ast_rtp, which tracks a RTP session,\n * it is logical to think of this as a RTCP session.\n *\n * RTCP packet is defined on page 9 of RFC 3550.\n *\n */\nstruct ast_rtcp {\n\tint rtcp_info;\n\tint s;\t\t\t\t/*!< Socket */\n\tstruct ast_sockaddr us;\t\t/*!< Socket representation of the local endpoint. */\n\tstruct ast_sockaddr them;\t/*!< Socket representation of the remote endpoint. */\n\tunsigned int soc;\t\t/*!< What they told us */\n\tunsigned int spc;\t\t/*!< What they told us */\n\tunsigned int themrxlsr;\t\t/*!< The middle 32 bits of the NTP timestamp in the last received SR*/\n\tstruct timeval rxlsr;\t\t/*!< Time when we got their last SR */\n\tstruct timeval txlsr;\t\t/*!< Time when we sent or last SR*/\n\tunsigned int expected_prior;\t/*!< no. packets in previous interval */\n\tunsigned int received_prior;\t/*!< no. packets received in previous interval */\n\tint schedid;\t\t\t/*!< Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/\n\tunsigned int rr_count;\t\t/*!< number of RRs we've sent, not including report blocks in SR's */\n\tunsigned int sr_count;\t\t/*!< number of SRs we've sent */\n\tunsigned int lastsrtxcount;     /*!< Transmit packet count when last SR sent */\n\tdouble accumulated_transit;\t/*!< accumulated a-dlsr-lsr */\n\tdouble rtt;\t\t\t/*!< Last reported rtt */\n\tdouble reported_jitter;\t/*!< The contents of their last jitter entry in the RR in seconds */\n\tunsigned int reported_lost;\t/*!< Reported lost packets in their RR */\n\n\tdouble reported_maxjitter; /*!< Maximum reported interarrival jitter */\n\tdouble reported_minjitter; /*!< Minimum reported interarrival jitter */\n\tdouble reported_normdev_jitter; /*!< Mean of reported interarrival jitter */\n\tdouble reported_stdev_jitter; /*!< Standard deviation of reported interarrival jitter */\n\tunsigned int reported_jitter_count; /*!< Reported interarrival jitter count */\n\n\tdouble reported_maxlost; /*!< Maximum reported packets lost */\n\tdouble reported_minlost; /*!< Minimum reported packets lost */\n\tdouble reported_normdev_lost; /*!< Mean of reported packets lost */\n\tdouble reported_stdev_lost; /*!< Standard deviation of reported packets lost */\n\tunsigned int reported_lost_count; /*!< Reported packets lost count */\n\n\tdouble rxlost; /*!< Calculated number of lost packets since last report */\n\tdouble maxrxlost; /*!< Maximum calculated lost number of packets between reports */\n\tdouble minrxlost; /*!< Minimum calculated lost number of packets between reports */\n\tdouble normdev_rxlost; /*!< Mean of calculated lost packets between reports */\n\tdouble stdev_rxlost; /*!< Standard deviation of calculated lost packets between reports */\n\tunsigned int rxlost_count; /*!< Calculated lost packets sample count */\n\n\tdouble maxrxjitter; /*!< Maximum of calculated interarrival jitter */\n\tdouble minrxjitter; /*!< Minimum of calculated interarrival jitter */\n\tdouble normdev_rxjitter; /*!< Mean of calculated interarrival jitter */\n\tdouble stdev_rxjitter; /*!< Standard deviation of calculated interarrival jitter */\n\tunsigned int rxjitter_count; /*!< Calculated interarrival jitter count */\n\n\tdouble maxrtt; /*!< Maximum of calculated round trip time */\n\tdouble minrtt; /*!< Minimum of calculated round trip time */\n\tdouble normdevrtt; /*!< Mean of calculated round trip time */\n\tdouble stdevrtt; /*!< Standard deviation of calculated round trip time */\n\tunsigned int rtt_count; /*!< Calculated round trip time count */\n\n\tdouble reported_mes;\t/*!< The calculated MES from their last RR */\n\tdouble reported_maxmes; /*!< Maximum reported mes */\n\tdouble reported_minmes; /*!< Minimum reported mes */\n\tdouble reported_normdev_mes; /*!< Mean of reported mes */\n\tdouble reported_stdev_mes; /*!< Standard deviation of reported mes */\n\tunsigned int reported_mes_count; /*!< Reported mes count */\n\n\tdouble maxrxmes; /*!< Maximum of calculated mes */\n\tdouble minrxmes; /*!< Minimum of calculated mes */\n\tdouble normdev_rxmes; /*!< Mean of calculated mes */\n\tdouble stdev_rxmes; /*!< Standard deviation of calculated mes */\n\tunsigned int rxmes_count; /*!< mes count */\n\n\t/* VP8: sequence number for the RTCP FIR FCI */\n\tint firseq;\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tstruct dtls_details dtls; /*!< DTLS state information */\n#endif\n\n\t/* Cached local address string allows us to generate\n\t * RTCP stasis messages without having to look up our\n\t * own address every time\n\t */\n\tchar *local_addr_str;\n\tenum ast_rtp_instance_rtcp type;\n\t/* Buffer for frames created during RTCP interpretation */\n\tunsigned char frame_buf[512 + AST_FRIENDLY_OFFSET];\n};\n\nstruct rtp_red {\n\tstruct ast_frame t140;  /*!< Primary data  */\n\tstruct ast_frame t140red;   /*!< Redundant t140*/\n\tunsigned char pt[AST_RED_MAX_GENERATION];  /*!< Payload types for redundancy data */\n\tunsigned char ts[AST_RED_MAX_GENERATION]; /*!< Time stamps */\n\tunsigned char len[AST_RED_MAX_GENERATION]; /*!< length of each generation */\n\tint num_gen; /*!< Number of generations */\n\tint schedid; /*!< Timer id */\n\tint ti; /*!< How long to buffer data before send */\n\tunsigned char t140red_data[64000];\n\tunsigned char buf_data[64000]; /*!< buffered primary data */\n\tint hdrlen;\n\tlong int prev_ts;\n};\n\n/*! \\brief Structure for storing RTP packets for retransmission */\nstruct ast_rtp_rtcp_nack_payload {\n\tsize_t size;\t\t/*!< The size of the payload */\n\tunsigned char buf[0];\t/*!< The payload data */\n};\n\nAST_LIST_HEAD_NOLOCK(frame_list, ast_frame);\n\n/* Forward Declarations */\nstatic int ast_rtp_new(struct ast_rtp_instance *instance, struct ast_sched_context *sched, struct ast_sockaddr *addr, void *data);\nstatic int ast_rtp_destroy(struct ast_rtp_instance *instance);\nstatic int ast_rtp_dtmf_begin(struct ast_rtp_instance *instance, char digit);\nstatic int ast_rtp_dtmf_end(struct ast_rtp_instance *instance, char digit);\nstatic int ast_rtp_dtmf_end_with_duration(struct ast_rtp_instance *instance, char digit, unsigned int duration);\nstatic int ast_rtp_dtmf_mode_set(struct ast_rtp_instance *instance, enum ast_rtp_dtmf_mode dtmf_mode);\nstatic enum ast_rtp_dtmf_mode ast_rtp_dtmf_mode_get(struct ast_rtp_instance *instance);\nstatic void ast_rtp_update_source(struct ast_rtp_instance *instance);\nstatic void ast_rtp_change_source(struct ast_rtp_instance *instance);\nstatic int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame);\nstatic struct ast_frame *ast_rtp_read(struct ast_rtp_instance *instance, int rtcp);\nstatic void ast_rtp_prop_set(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value);\nstatic int ast_rtp_fd(struct ast_rtp_instance *instance, int rtcp);\nstatic void ast_rtp_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr);\nstatic int rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations);\nstatic int rtp_red_buffer(struct ast_rtp_instance *instance, struct ast_frame *frame);\nstatic int ast_rtp_local_bridge(struct ast_rtp_instance *instance0, struct ast_rtp_instance *instance1);\nstatic int ast_rtp_get_stat(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat);\nstatic int ast_rtp_dtmf_compatible(struct ast_channel *chan0, struct ast_rtp_instance *instance0, struct ast_channel *chan1, struct ast_rtp_instance *instance1);\nstatic void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username);\nstatic void ast_rtp_stop(struct ast_rtp_instance *instance);\nstatic int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char* desc);\nstatic int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level);\nstatic unsigned int ast_rtp_get_ssrc(struct ast_rtp_instance *instance);\nstatic const char *ast_rtp_get_cname(struct ast_rtp_instance *instance);\nstatic void ast_rtp_set_remote_ssrc(struct ast_rtp_instance *instance, unsigned int ssrc);\nstatic void ast_rtp_set_stream_num(struct ast_rtp_instance *instance, int stream_num);\nstatic int ast_rtp_extension_enable(struct ast_rtp_instance *instance, enum ast_rtp_extension extension);\nstatic int ast_rtp_bundle(struct ast_rtp_instance *child, struct ast_rtp_instance *parent);\nstatic void update_reported_mes_stats(struct ast_rtp *rtp);\nstatic void update_local_mes_stats(struct ast_rtp *rtp);\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int ast_rtp_activate(struct ast_rtp_instance *instance);\nstatic void dtls_srtp_start_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp);\nstatic void dtls_srtp_stop_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp);\nstatic int dtls_bio_write(BIO *bio, const char *buf, int len);\nstatic long dtls_bio_ctrl(BIO *bio, int cmd, long arg1, void *arg2);\nstatic int dtls_bio_new(BIO *bio);\nstatic int dtls_bio_free(BIO *bio);\n\n#ifndef HAVE_OPENSSL_BIO_METHOD\nstatic BIO_METHOD dtls_bio_methods = {\n\t.type = BIO_TYPE_BIO,\n\t.name = \"rtp write\",\n\t.bwrite = dtls_bio_write,\n\t.ctrl = dtls_bio_ctrl,\n\t.create = dtls_bio_new,\n\t.destroy = dtls_bio_free,\n};\n#else\nstatic BIO_METHOD *dtls_bio_methods;\n#endif\n#endif\n\nstatic int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *via_ice, int use_srtp);\n\n#ifdef HAVE_PJPROJECT\nstatic void stunaddr_resolve_callback(const struct ast_dns_query *query);\nstatic int store_stunaddr_resolved(const struct ast_dns_query *query);\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int dtls_bio_new(BIO *bio)\n{\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tBIO_set_init(bio, 1);\n\tBIO_set_data(bio, NULL);\n\tBIO_set_shutdown(bio, 0);\n#else\n\tbio->init = 1;\n\tbio->ptr = NULL;\n\tbio->flags = 0;\n#endif\n\treturn 1;\n}\n\nstatic int dtls_bio_free(BIO *bio)\n{\n\t/* The pointer on the BIO is that of the RTP instance. It is not reference counted as the BIO\n\t * lifetime is tied to the instance, and actions on the BIO are taken by the thread handling\n\t * the RTP instance - not another thread.\n\t */\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tBIO_set_data(bio, NULL);\n#else\n\tbio->ptr = NULL;\n#endif\n\treturn 1;\n}\n\nstatic int dtls_bio_write(BIO *bio, const char *buf, int len)\n{\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tstruct ast_rtp_instance *instance = BIO_get_data(bio);\n#else\n\tstruct ast_rtp_instance *instance = bio->ptr;\n#endif\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint rtcp = 0;\n\tstruct ast_sockaddr remote_address = { {0, } };\n\tint ice;\n\tint bytes_sent;\n\n\t/* OpenSSL can't tolerate a packet not being sent, so we always state that\n\t * we sent the packet. If it isn't then retransmission will occur.\n\t */\n\n\tif (rtp->rtcp && rtp->rtcp->dtls.write_bio == bio) {\n\t\trtcp = 1;\n\t\tast_sockaddr_copy(&remote_address, &rtp->rtcp->them);\n\t} else {\n\t\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\t}\n\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn len;\n\t}\n\n\tbytes_sent = __rtp_sendto(instance, (char *)buf, len, 0, &remote_address, rtcp, &ice, 0);\n\n\tif (bytes_sent > 0 && ast_debug_dtls_packet_is_allowed) {\n\t\tast_debug(0, \"(%p) DTLS - sent %s packet to %s%s (len %-6.6d)\\n\",\n\t\t\tinstance, rtcp ? \"RTCP\" : \"RTP\", ast_sockaddr_stringify(&remote_address),\n\t\t\tice ? \" (via ICE)\" : \"\", bytes_sent);\n\t}\n\n\treturn len;\n}\n\nstatic long dtls_bio_ctrl(BIO *bio, int cmd, long arg1, void *arg2)\n{\n\tswitch (cmd) {\n\tcase BIO_CTRL_FLUSH:\n\t\treturn 1;\n\tcase BIO_CTRL_DGRAM_QUERY_MTU:\n\t\treturn dtls_mtu;\n\tcase BIO_CTRL_WPENDING:\n\tcase BIO_CTRL_PENDING:\n\t\treturn 0L;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#endif\n\n#ifdef HAVE_PJPROJECT\n/*! \\brief Helper function which clears the ICE host candidate mapping */\nstatic void host_candidate_overrides_clear(void)\n{\n\tstruct ast_ice_host_candidate *candidate;\n\n\tAST_RWLIST_WRLOCK(&host_candidates);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&host_candidates, candidate, next) {\n\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\tast_free(candidate);\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&host_candidates);\n}\n\n/*! \\brief Helper function which updates an ast_sockaddr with the candidate used for the component */\nstatic void update_address_with_ice_candidate(pj_ice_sess *ice, enum ast_rtp_ice_component_type component,\n\tstruct ast_sockaddr *cand_address)\n{\n\tchar address[PJ_INET6_ADDRSTRLEN];\n\n\tif (component < 1 || !ice->comp[component - 1].valid_check) {\n\t\treturn;\n\t}\n\n\tast_sockaddr_parse(cand_address,\n\t\tpj_sockaddr_print(&ice->comp[component - 1].valid_check->rcand->addr, address,\n\t\t\tsizeof(address), 0), 0);\n\tast_sockaddr_set_port(cand_address,\n\t\tpj_sockaddr_get_port(&ice->comp[component - 1].valid_check->rcand->addr));\n}\n\n/*! \\brief Destructor for locally created ICE candidates */\nstatic void ast_rtp_ice_candidate_destroy(void *obj)\n{\n\tstruct ast_rtp_engine_ice_candidate *candidate = obj;\n\n\tif (candidate->foundation) {\n\t\tast_free(candidate->foundation);\n\t}\n\n\tif (candidate->transport) {\n\t\tast_free(candidate->transport);\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_set_authentication(struct ast_rtp_instance *instance, const char *ufrag, const char *password)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint ice_attrb_reset = 0;\n\n\tif (!ast_strlen_zero(ufrag)) {\n\t\tif (!ast_strlen_zero(rtp->remote_ufrag) && strcmp(ufrag, rtp->remote_ufrag)) {\n\t\t\tice_attrb_reset = 1;\n\t\t}\n\t\tast_copy_string(rtp->remote_ufrag, ufrag, sizeof(rtp->remote_ufrag));\n\t}\n\n\tif (!ast_strlen_zero(password)) {\n\t\tif (!ast_strlen_zero(rtp->remote_passwd) && strcmp(password, rtp->remote_passwd)) {\n\t\t\tice_attrb_reset = 1;\n\t\t}\n\t\tast_copy_string(rtp->remote_passwd, password, sizeof(rtp->remote_passwd));\n\t}\n\n\t/* If the remote ufrag or passwd changed, local ufrag and passwd need to regenerate */\n\tif (ice_attrb_reset) {\n\t\tgenerate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));\n\t\tgenerate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));\n\t}\n}\n\nstatic int ice_candidate_cmp(void *obj, void *arg, int flags)\n{\n\tstruct ast_rtp_engine_ice_candidate *candidate1 = obj, *candidate2 = arg;\n\n\tif (strcmp(candidate1->foundation, candidate2->foundation) ||\n\t\t\tcandidate1->id != candidate2->id ||\n\t\t\tcandidate1->type != candidate2->type ||\n\t\t\tast_sockaddr_cmp(&candidate1->address, &candidate2->address)) {\n\t\treturn 0;\n\t}\n\n\treturn CMP_MATCH | CMP_STOP;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_add_remote_candidate(struct ast_rtp_instance *instance, const struct ast_rtp_engine_ice_candidate *candidate)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_engine_ice_candidate *remote_candidate;\n\n\t/* ICE sessions only support UDP candidates */\n\tif (strcasecmp(candidate->transport, \"udp\")) {\n\t\treturn;\n\t}\n\n\tif (!rtp->ice_proposed_remote_candidates) {\n\t\trtp->ice_proposed_remote_candidates = ao2_container_alloc_list(\n\t\t\tAO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, ice_candidate_cmp);\n\t\tif (!rtp->ice_proposed_remote_candidates) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* If this is going to exceed the maximum number of ICE candidates don't even add it */\n\tif (ao2_container_count(rtp->ice_proposed_remote_candidates) == PJ_ICE_MAX_CAND) {\n\t\treturn;\n\t}\n\n\tif (!(remote_candidate = ao2_alloc(sizeof(*remote_candidate), ast_rtp_ice_candidate_destroy))) {\n\t\treturn;\n\t}\n\n\tremote_candidate->foundation = ast_strdup(candidate->foundation);\n\tremote_candidate->id = candidate->id;\n\tremote_candidate->transport = ast_strdup(candidate->transport);\n\tremote_candidate->priority = candidate->priority;\n\tast_sockaddr_copy(&remote_candidate->address, &candidate->address);\n\tast_sockaddr_copy(&remote_candidate->relay_address, &candidate->relay_address);\n\tremote_candidate->type = candidate->type;\n\n\tast_debug_ice(2, \"(%p) ICE add remote candidate\\n\", instance);\n\n\tao2_link(rtp->ice_proposed_remote_candidates, remote_candidate);\n\tao2_ref(remote_candidate, -1);\n}\n\nAST_THREADSTORAGE(pj_thread_storage);\n\n/*! \\brief Function used to check if the calling thread is registered with pjlib. If it is not it will be registered. */\nstatic void pj_thread_register_check(void)\n{\n\tpj_thread_desc *desc;\n\tpj_thread_t *thread;\n\n\tif (pj_thread_is_registered() == PJ_TRUE) {\n\t\treturn;\n\t}\n\n\tdesc = ast_threadstorage_get(&pj_thread_storage, sizeof(pj_thread_desc));\n\tif (!desc) {\n\t\tast_log(LOG_ERROR, \"Could not get thread desc from thread-local storage. Expect awful things to occur\\n\");\n\t\treturn;\n\t}\n\tpj_bzero(*desc, sizeof(*desc));\n\n\tif (pj_thread_register(\"Asterisk Thread\", *desc, &thread) != PJ_SUCCESS) {\n\t\tast_log(LOG_ERROR, \"Coudln't register thread with PJLIB.\\n\");\n\t}\n\treturn;\n}\n\nstatic int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,\n\tint port, int replace);\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_stop(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ice_wrap *ice;\n\n\tice = rtp->ice;\n\trtp->ice = NULL;\n\tif (ice) {\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tast_debug_ice(2, \"(%p) ICE stopped\\n\", instance);\n\t}\n}\n\n/*!\n * \\brief ao2 ICE wrapper object destructor.\n *\n * \\param vdoomed Object being destroyed.\n *\n * \\note The associated struct ast_rtp_instance object must not\n * be locked when unreffing the object.  Otherwise we could\n * deadlock trying to destroy the PJPROJECT ICE structure.\n */\nstatic void ice_wrap_dtor(void *vdoomed)\n{\n\tstruct ice_wrap *ice = vdoomed;\n\n\tif (ice->real_ice) {\n\t\tpj_thread_register_check();\n\n\t\tpj_ice_sess_destroy(ice->real_ice);\n\t}\n}\n\nstatic void ast2pj_rtp_ice_role(enum ast_rtp_ice_role ast_role, enum pj_ice_sess_role *pj_role)\n{\n\tswitch (ast_role) {\n\tcase AST_RTP_ICE_ROLE_CONTROLLED:\n\t\t*pj_role = PJ_ICE_SESS_ROLE_CONTROLLED;\n\t\tbreak;\n\tcase AST_RTP_ICE_ROLE_CONTROLLING:\n\t\t*pj_role = PJ_ICE_SESS_ROLE_CONTROLLING;\n\t\tbreak;\n\t}\n}\n\nstatic void pj2ast_rtp_ice_role(enum pj_ice_sess_role pj_role, enum ast_rtp_ice_role *ast_role)\n{\n\tswitch (pj_role) {\n\tcase PJ_ICE_SESS_ROLE_CONTROLLED:\n\t\t*ast_role = AST_RTP_ICE_ROLE_CONTROLLED;\n\t\treturn;\n\tcase PJ_ICE_SESS_ROLE_CONTROLLING:\n\t\t*ast_role = AST_RTP_ICE_ROLE_CONTROLLING;\n\t\treturn;\n\tcase PJ_ICE_SESS_ROLE_UNKNOWN:\n\t\t/* Don't change anything */\n\t\treturn;\n\tdefault:\n\t\t/* If we aren't explicitly handling something, it's a bug */\n\t\tast_assert(0);\n\t\treturn;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic int ice_reset_session(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint res;\n\n\tast_debug_ice(3, \"(%p) ICE resetting\\n\", instance);\n\tif (!rtp->ice->real_ice->is_nominating && !rtp->ice->real_ice->is_complete) {\n\t\tast_debug_ice(3, \" (%p) ICE nevermind, not ready for a reset\\n\", instance);\n\t\treturn 0;\n\t}\n\n\tast_debug_ice(3, \"(%p) ICE recreating ICE session %s (%d)\\n\",\n\t\tinstance, ast_sockaddr_stringify(&rtp->ice_original_rtp_addr), rtp->ice_port);\n\tres = ice_create(instance, &rtp->ice_original_rtp_addr, rtp->ice_port, 1);\n\tif (!res) {\n\t\t/* Use the current expected role for the ICE session */\n\t\tenum pj_ice_sess_role role = PJ_ICE_SESS_ROLE_UNKNOWN;\n\t\tast2pj_rtp_ice_role(rtp->role, &role);\n\t\tpj_ice_sess_change_role(rtp->ice->real_ice, role);\n\t}\n\n\t/* If we only have one component now, and we previously set up TURN for RTCP,\n\t * we need to destroy that TURN socket.\n\t */\n\tif (rtp->ice_num_components == 1 && rtp->turn_rtcp) {\n\t\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));\n\t\tstruct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };\n\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(rtp->turn_rtcp);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t}\n\n\trtp->ice_media_started = 0;\n\n\treturn res;\n}\n\nstatic int ice_candidates_compare(struct ao2_container *left, struct ao2_container *right)\n{\n\tstruct ao2_iterator i;\n\tstruct ast_rtp_engine_ice_candidate *right_candidate;\n\n\tif (ao2_container_count(left) != ao2_container_count(right)) {\n\t\treturn -1;\n\t}\n\n\ti = ao2_iterator_init(right, 0);\n\twhile ((right_candidate = ao2_iterator_next(&i))) {\n\t\tstruct ast_rtp_engine_ice_candidate *left_candidate = ao2_find(left, right_candidate, OBJ_POINTER);\n\n\t\tif (!left_candidate) {\n\t\t\tao2_ref(right_candidate, -1);\n\t\t\tao2_iterator_destroy(&i);\n\t\t\treturn -1;\n\t\t}\n\n\t\tao2_ref(left_candidate, -1);\n\t\tao2_ref(right_candidate, -1);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_start(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tpj_str_t ufrag = pj_str(rtp->remote_ufrag), passwd = pj_str(rtp->remote_passwd);\n\tpj_ice_sess_cand candidates[PJ_ICE_MAX_CAND];\n\tstruct ao2_iterator i;\n\tstruct ast_rtp_engine_ice_candidate *candidate;\n\tint cand_cnt = 0, has_rtp = 0, has_rtcp = 0;\n\n\tif (!rtp->ice || !rtp->ice_proposed_remote_candidates) {\n\t\treturn;\n\t}\n\n\t/* Check for equivalence in the lists */\n\tif (rtp->ice_active_remote_candidates &&\n\t\t\t!ice_candidates_compare(rtp->ice_proposed_remote_candidates, rtp->ice_active_remote_candidates)) {\n\t\tast_debug_ice(2, \"(%p) ICE proposed equals active candidates\\n\", instance);\n\t\tao2_cleanup(rtp->ice_proposed_remote_candidates);\n\t\trtp->ice_proposed_remote_candidates = NULL;\n\t\t/* If this ICE session is being preserved then go back to the role it currently is */\n\t\tpj2ast_rtp_ice_role(rtp->ice->real_ice->role, &rtp->role);\n\t\treturn;\n\t}\n\n\t/* Out with the old, in with the new */\n\tao2_cleanup(rtp->ice_active_remote_candidates);\n\trtp->ice_active_remote_candidates = rtp->ice_proposed_remote_candidates;\n\trtp->ice_proposed_remote_candidates = NULL;\n\n\tast_debug_ice(2, \"(%p) ICE start\\n\", instance);\n\n\t/* Reset the ICE session. Is this going to work? */\n\tif (ice_reset_session(instance)) {\n\t\tast_log(LOG_NOTICE, \"(%p) ICE failed to create replacement session\\n\", instance);\n\t\treturn;\n\t}\n\n\tpj_thread_register_check();\n\n\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n\n\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n\t\tpj_str_t address;\n\n\t\t/* there needs to be at least one rtp and rtcp candidate in the list */\n\t\thas_rtp |= candidate->id == AST_RTP_ICE_COMPONENT_RTP;\n\t\thas_rtcp |= candidate->id == AST_RTP_ICE_COMPONENT_RTCP;\n\n\t\tpj_strdup2(rtp->ice->real_ice->pool, &candidates[cand_cnt].foundation,\n\t\t\tcandidate->foundation);\n\t\tcandidates[cand_cnt].comp_id = candidate->id;\n\t\tcandidates[cand_cnt].prio = candidate->priority;\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&candidate->address)), &candidates[cand_cnt].addr);\n\n\t\tif (!ast_sockaddr_isnull(&candidate->relay_address)) {\n\t\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&candidate->relay_address)), &candidates[cand_cnt].rel_addr);\n\t\t}\n\n\t\tif (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_HOST) {\n\t\t\tcandidates[cand_cnt].type = PJ_ICE_CAND_TYPE_HOST;\n\t\t} else if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_SRFLX) {\n\t\t\tcandidates[cand_cnt].type = PJ_ICE_CAND_TYPE_SRFLX;\n\t\t} else if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_RELAYED) {\n\t\t\tcandidates[cand_cnt].type = PJ_ICE_CAND_TYPE_RELAYED;\n\t\t}\n\n\t\tif (candidate->id == AST_RTP_ICE_COMPONENT_RTP && rtp->turn_rtp) {\n\t\t\tast_debug_ice(2, \"(%p) ICE RTP candidate %s\\n\", instance, ast_sockaddr_stringify(&candidate->address));\n\t\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\t\tao2_unlock(instance);\n\t\t\tpj_turn_sock_set_perm(rtp->turn_rtp, 1, &candidates[cand_cnt].addr, 1);\n\t\t\tao2_lock(instance);\n\t\t} else if (candidate->id == AST_RTP_ICE_COMPONENT_RTCP && rtp->turn_rtcp) {\n\t\t\tast_debug_ice(2, \"(%p) ICE RTCP candidate %s\\n\", instance, ast_sockaddr_stringify(&candidate->address));\n\t\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\t\tao2_unlock(instance);\n\t\t\tpj_turn_sock_set_perm(rtp->turn_rtcp, 1, &candidates[cand_cnt].addr, 1);\n\t\t\tao2_lock(instance);\n\t\t}\n\n\t\tcand_cnt++;\n\t\tao2_ref(candidate, -1);\n\t}\n\n\tao2_iterator_destroy(&i);\n\n\tif (cand_cnt < ao2_container_count(rtp->ice_active_remote_candidates)) {\n\t\tast_log(LOG_WARNING, \"(%p) ICE lost %d candidates. Consider increasing PJ_ICE_MAX_CAND in PJSIP\\n\",\n\t\t\tinstance, ao2_container_count(rtp->ice_active_remote_candidates) - cand_cnt);\n\t}\n\n\tif (!has_rtp) {\n\t\tast_log(LOG_WARNING, \"(%p) ICE no RTP candidates; skipping checklist\\n\", instance);\n\t}\n\n\t/* If we're only dealing with one ICE component, then we don't care about the lack of RTCP candidates */\n\tif (!has_rtcp && rtp->ice_num_components > 1) {\n\t\tast_log(LOG_WARNING, \"(%p) ICE no RTCP candidates; skipping checklist\\n\", instance);\n\t}\n\n\tif (rtp->ice && has_rtp && (has_rtcp || rtp->ice_num_components == 1)) {\n\t\tpj_status_t res;\n\t\tchar reason[80];\n\t\tstruct ice_wrap *ice;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tres = pj_ice_sess_create_check_list(ice->real_ice, &ufrag, &passwd, cand_cnt, &candidates[0]);\n\t\tif (res == PJ_SUCCESS) {\n\t\t\tast_debug_ice(2, \"(%p) ICE successfully created checklist\\n\", instance);\n\t\t\tast_test_suite_event_notify(\"ICECHECKLISTCREATE\", \"Result: SUCCESS\");\n\t\t\tpj_ice_sess_start_check(ice->real_ice);\n\t\t\tpj_timer_heap_poll(timer_heap, NULL);\n\t\t\tao2_ref(ice, -1);\n\t\t\tao2_lock(instance);\n\t\t\trtp->strict_rtp_state = STRICT_RTP_OPEN;\n\t\t\treturn;\n\t\t}\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\n\t\tpj_strerror(res, reason, sizeof(reason));\n\t\tast_log(LOG_WARNING, \"(%p) ICE failed to create session check list: %s\\n\", instance, reason);\n\t}\n\n\tast_test_suite_event_notify(\"ICECHECKLISTCREATE\", \"Result: FAILURE\");\n\n\t/* even though create check list failed don't stop ice as\n\t   it might still work */\n\t/* however we do need to reset remote candidates since\n\t   this function may be re-entered */\n\tao2_ref(rtp->ice_active_remote_candidates, -1);\n\trtp->ice_active_remote_candidates = NULL;\n\tif (rtp->ice) {\n\t\trtp->ice->real_ice->rcand_cnt = rtp->ice->real_ice->clist.count = 0;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_ice_get_ufrag(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_ufrag;\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_ice_get_password(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_passwd;\n}\n\n/*! \\pre instance is locked */\nstatic struct ao2_container *ast_rtp_ice_get_local_candidates(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->ice_local_candidates) {\n\t\tao2_ref(rtp->ice_local_candidates, +1);\n\t}\n\n\treturn rtp->ice_local_candidates;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_lite(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->ice) {\n\t\treturn;\n\t}\n\n\tpj_thread_register_check();\n\n\tpj_ice_sess_change_role(rtp->ice->real_ice, PJ_ICE_SESS_ROLE_CONTROLLING);\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_set_role(struct ast_rtp_instance *instance, enum ast_rtp_ice_role role)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->ice) {\n\t\tast_debug_ice(3, \"(%p) ICE set role failed; no ice instance\\n\", instance);\n\t\treturn;\n\t}\n\n\trtp->role = role;\n\n\tif (!rtp->ice->real_ice->is_nominating && !rtp->ice->real_ice->is_complete) {\n\t\tpj_thread_register_check();\n\t\tast_debug_ice(2, \"(%p) ICE set role to %s\\n\",\n\t\t\tinstance, role == AST_RTP_ICE_ROLE_CONTROLLED ? \"CONTROLLED\" : \"CONTROLLING\");\n\t\tpj_ice_sess_change_role(rtp->ice->real_ice, role == AST_RTP_ICE_ROLE_CONTROLLED ?\n\t\t\tPJ_ICE_SESS_ROLE_CONTROLLED : PJ_ICE_SESS_ROLE_CONTROLLING);\n\t} else {\n\t\tast_debug_ice(2, \"(%p) ICE not setting role because state is %s\\n\",\n\t\t\tinstance, rtp->ice->real_ice->is_nominating ? \"nominating\" : \"complete\");\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_add_cand(struct ast_rtp_instance *instance, struct ast_rtp *rtp,\n\tunsigned comp_id, unsigned transport_id, pj_ice_cand_type type, pj_uint16_t local_pref,\n\tconst pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr,\n\tint addr_len)\n{\n\tpj_str_t foundation;\n\tstruct ast_rtp_engine_ice_candidate *candidate, *existing;\n\tstruct ice_wrap *ice;\n\tchar address[PJ_INET6_ADDRSTRLEN];\n\tpj_status_t status;\n\n\tif (!rtp->ice) {\n\t\treturn;\n\t}\n\n\tpj_thread_register_check();\n\n\tpj_ice_calc_foundation(rtp->ice->real_ice->pool, &foundation, type, addr);\n\n\tif (!rtp->ice_local_candidates) {\n\t\trtp->ice_local_candidates = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0,\n\t\t\tNULL, ice_candidate_cmp);\n\t\tif (!rtp->ice_local_candidates) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!(candidate = ao2_alloc(sizeof(*candidate), ast_rtp_ice_candidate_destroy))) {\n\t\treturn;\n\t}\n\n\tcandidate->foundation = ast_strndup(pj_strbuf(&foundation), pj_strlen(&foundation));\n\tcandidate->id = comp_id;\n\tcandidate->transport = ast_strdup(\"UDP\");\n\n\tast_sockaddr_parse(&candidate->address, pj_sockaddr_print(addr, address, sizeof(address), 0), 0);\n\tast_sockaddr_set_port(&candidate->address, pj_sockaddr_get_port(addr));\n\n\tif (rel_addr) {\n\t\tast_sockaddr_parse(&candidate->relay_address, pj_sockaddr_print(rel_addr, address, sizeof(address), 0), 0);\n\t\tast_sockaddr_set_port(&candidate->relay_address, pj_sockaddr_get_port(rel_addr));\n\t}\n\n\tif (type == PJ_ICE_CAND_TYPE_HOST) {\n\t\tcandidate->type = AST_RTP_ICE_CANDIDATE_TYPE_HOST;\n\t} else if (type == PJ_ICE_CAND_TYPE_SRFLX) {\n\t\tcandidate->type = AST_RTP_ICE_CANDIDATE_TYPE_SRFLX;\n\t} else if (type == PJ_ICE_CAND_TYPE_RELAYED) {\n\t\tcandidate->type = AST_RTP_ICE_CANDIDATE_TYPE_RELAYED;\n\t}\n\n\tif ((existing = ao2_find(rtp->ice_local_candidates, candidate, OBJ_POINTER))) {\n\t\tao2_ref(existing, -1);\n\t\tao2_ref(candidate, -1);\n\t\treturn;\n\t}\n\n\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\tice = rtp->ice;\n\tao2_ref(ice, +1);\n\tao2_unlock(instance);\n\tstatus = pj_ice_sess_add_cand(ice->real_ice, comp_id, transport_id, type, local_pref,\n\t\t&foundation, addr, base_addr, rel_addr, addr_len, NULL);\n\tao2_ref(ice, -1);\n\tao2_lock(instance);\n\tif (!rtp->ice || status != PJ_SUCCESS) {\n\t\tast_debug_ice(2, \"(%p) ICE unable to add candidate: %s, %d\\n\", instance, ast_sockaddr_stringify(\n\t\t\t&candidate->address), candidate->priority);\n\t\tao2_ref(candidate, -1);\n\t\treturn;\n\t}\n\n\t/* By placing the candidate into the ICE session it will have produced the priority, so update the local candidate with it */\n\tcandidate->priority = rtp->ice->real_ice->lcand[rtp->ice->real_ice->lcand_cnt - 1].prio;\n\n\tast_debug_ice(2, \"(%p) ICE add candidate: %s, %d\\n\", instance, ast_sockaddr_stringify(\n\t\t&candidate->address), candidate->priority);\n\n\tao2_link(rtp->ice_local_candidates, candidate);\n\tao2_ref(candidate, -1);\n}\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rx_rtp_data(pj_turn_sock *turn_sock, void *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ice_wrap *ice;\n\tpj_status_t status;\n\n\tao2_lock(instance);\n\tice = ao2_bump(rtp->ice);\n\tao2_unlock(instance);\n\n\tif (ice) {\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice, AST_RTP_ICE_COMPONENT_RTP,\n\t\t\tTRANSPORT_TURN_RTP, pkt, pkt_len, peer_addr, addr_len);\n\t\tao2_ref(ice, -1);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar buf[100];\n\n\t\t\tpj_strerror(status, buf, sizeof(buf));\n\t\t\tast_log(LOG_WARNING, \"(%p) ICE PJ Rx error status code: %d '%s'.\\n\",\n\t\t\t\tinstance, (int)status, buf);\n\t\t\treturn;\n\t\t}\n\t\tif (!rtp->rtp_passthrough) {\n\t\t\treturn;\n\t\t}\n\t\trtp->rtp_passthrough = 0;\n\t}\n\n\tast_sendto(rtp->s, pkt, pkt_len, 0, &rtp->rtp_loop);\n}\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rtp_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state, pj_turn_state_t new_state)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp;\n\n\t/* If this is a leftover from an already notified RTP instance just ignore the state change */\n\tif (!instance) {\n\t\treturn;\n\t}\n\n\trtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\t/* We store the new state so the other thread can actually handle it */\n\trtp->turn_state = new_state;\n\tast_cond_signal(&rtp->cond);\n\n\tif (new_state == PJ_TURN_STATE_DESTROYING) {\n\t\tpj_turn_sock_set_user_data(rtp->turn_rtp, NULL);\n\t\trtp->turn_rtp = NULL;\n\t}\n\n\tao2_unlock(instance);\n}\n\n/* RTP TURN Socket interface declaration */\nstatic pj_turn_sock_cb ast_rtp_turn_rtp_sock_cb = {\n\t.on_rx_data = ast_rtp_on_turn_rx_rtp_data,\n\t.on_state = ast_rtp_on_turn_rtp_state,\n};\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rx_rtcp_data(pj_turn_sock *turn_sock, void *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ice_wrap *ice;\n\tpj_status_t status;\n\n\tao2_lock(instance);\n\tice = ao2_bump(rtp->ice);\n\tao2_unlock(instance);\n\n\tif (ice) {\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice, AST_RTP_ICE_COMPONENT_RTCP,\n\t\t\tTRANSPORT_TURN_RTCP, pkt, pkt_len, peer_addr, addr_len);\n\t\tao2_ref(ice, -1);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar buf[100];\n\n\t\t\tpj_strerror(status, buf, sizeof(buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, buf);\n\t\t\treturn;\n\t\t}\n\t\tif (!rtp->rtcp_passthrough) {\n\t\t\treturn;\n\t\t}\n\t\trtp->rtcp_passthrough = 0;\n\t}\n\n\tast_sendto(rtp->rtcp->s, pkt, pkt_len, 0, &rtp->rtcp_loop);\n}\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rtcp_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state, pj_turn_state_t new_state)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp;\n\n\t/* If this is a leftover from an already destroyed RTP instance just ignore the state change */\n\tif (!instance) {\n\t\treturn;\n\t}\n\n\trtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\t/* We store the new state so the other thread can actually handle it */\n\trtp->turn_state = new_state;\n\tast_cond_signal(&rtp->cond);\n\n\tif (new_state == PJ_TURN_STATE_DESTROYING) {\n\t\tpj_turn_sock_set_user_data(rtp->turn_rtcp, NULL);\n\t\trtp->turn_rtcp = NULL;\n\t}\n\n\tao2_unlock(instance);\n}\n\n/* RTCP TURN Socket interface declaration */\nstatic pj_turn_sock_cb ast_rtp_turn_rtcp_sock_cb = {\n\t.on_rx_data = ast_rtp_on_turn_rx_rtcp_data,\n\t.on_state = ast_rtp_on_turn_rtcp_state,\n};\n\n/*! \\brief Worker thread for ioqueue and timerheap */\nstatic int ioqueue_worker_thread(void *data)\n{\n\tstruct ast_rtp_ioqueue_thread *ioqueue = data;\n\n\twhile (!ioqueue->terminate) {\n\t\tconst pj_time_val delay = {0, 10};\n\n\t\tpj_ioqueue_poll(ioqueue->ioqueue, &delay);\n\n\t\tpj_timer_heap_poll(ioqueue->timerheap, NULL);\n\t}\n\n\treturn 0;\n}\n\n/*! \\brief Destroyer for ioqueue thread */\nstatic void rtp_ioqueue_thread_destroy(struct ast_rtp_ioqueue_thread *ioqueue)\n{\n\tif (ioqueue->thread) {\n\t\tioqueue->terminate = 1;\n\t\tpj_thread_join(ioqueue->thread);\n\t\tpj_thread_destroy(ioqueue->thread);\n\t}\n\n\tif (ioqueue->pool) {\n\t\t/* This mimics the behavior of pj_pool_safe_release\n\t\t * which was introduced in pjproject 2.6.\n\t\t */\n\t\tpj_pool_t *temp_pool = ioqueue->pool;\n\n\t\tioqueue->pool = NULL;\n\t\tpj_pool_release(temp_pool);\n\t}\n\n\tast_free(ioqueue);\n}\n\n/*! \\brief Removal function for ioqueue thread, determines if it should be terminated and destroyed */\nstatic void rtp_ioqueue_thread_remove(struct ast_rtp_ioqueue_thread *ioqueue)\n{\n\tint destroy = 0;\n\n\t/* If nothing is using this ioqueue thread destroy it */\n\tAST_LIST_LOCK(&ioqueues);\n\tif ((ioqueue->count -= 2) == 0) {\n\t\tdestroy = 1;\n\t\tAST_LIST_REMOVE(&ioqueues, ioqueue, next);\n\t}\n\tAST_LIST_UNLOCK(&ioqueues);\n\n\tif (!destroy) {\n\t\treturn;\n\t}\n\n\trtp_ioqueue_thread_destroy(ioqueue);\n}\n\n/*! \\brief Finder and allocator for an ioqueue thread */\nstatic struct ast_rtp_ioqueue_thread *rtp_ioqueue_thread_get_or_create(void)\n{\n\tstruct ast_rtp_ioqueue_thread *ioqueue;\n\tpj_lock_t *lock;\n\n\tAST_LIST_LOCK(&ioqueues);\n\n\t/* See if an ioqueue thread exists that can handle more */\n\tAST_LIST_TRAVERSE(&ioqueues, ioqueue, next) {\n\t\tif ((ioqueue->count + 2) < PJ_IOQUEUE_MAX_HANDLES) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found one bump it up and return it */\n\tif (ioqueue) {\n\t\tioqueue->count += 2;\n\t\tgoto end;\n\t}\n\n\tioqueue = ast_calloc(1, sizeof(*ioqueue));\n\tif (!ioqueue) {\n\t\tgoto end;\n\t}\n\n\tioqueue->pool = pj_pool_create(&cachingpool.factory, \"rtp\", 512, 512, NULL);\n\n\t/* We use a timer on the ioqueue thread for TURN so that two threads aren't operating\n\t * on a session at the same time\n\t */\n\tif (pj_timer_heap_create(ioqueue->pool, 4, &ioqueue->timerheap) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tif (pj_lock_create_recursive_mutex(ioqueue->pool, \"rtp%p\", &lock) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tpj_timer_heap_set_lock(ioqueue->timerheap, lock, PJ_TRUE);\n\n\tif (pj_ioqueue_create(ioqueue->pool, PJ_IOQUEUE_MAX_HANDLES, &ioqueue->ioqueue) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tif (pj_thread_create(ioqueue->pool, \"ice\", &ioqueue_worker_thread, ioqueue, 0, 0, &ioqueue->thread) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tAST_LIST_INSERT_HEAD(&ioqueues, ioqueue, next);\n\n\t/* Since this is being returned to an active session the count always starts at 2 */\n\tioqueue->count = 2;\n\n\tgoto end;\n\nfatal:\n\trtp_ioqueue_thread_destroy(ioqueue);\n\tioqueue = NULL;\n\nend:\n\tAST_LIST_UNLOCK(&ioqueues);\n\treturn ioqueue;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_turn_request(struct ast_rtp_instance *instance, enum ast_rtp_ice_component_type component,\n\t\tenum ast_transport transport, const char *server, unsigned int port, const char *username, const char *password)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tpj_turn_sock **turn_sock;\n\tconst pj_turn_sock_cb *turn_cb;\n\tpj_turn_tp_type conn_type;\n\tint conn_transport;\n\tpj_stun_auth_cred cred = { 0, };\n\tpj_str_t turn_addr;\n\tstruct ast_sockaddr addr = { { 0, } };\n\tpj_stun_config stun_config;\n\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));\n\tstruct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };\n\tpj_turn_session_info info;\n\tstruct ast_sockaddr local, loop;\n\tpj_status_t status;\n\tpj_turn_sock_cfg turn_sock_cfg;\n\tstruct ice_wrap *ice;\n\n\tast_rtp_instance_get_local_address(instance, &local);\n\tif (ast_sockaddr_is_ipv4(&local)) {\n\t\tast_sockaddr_parse(&loop, \"127.0.0.1\", PARSE_PORT_FORBID);\n\t} else {\n\t\tast_sockaddr_parse(&loop, \"::1\", PARSE_PORT_FORBID);\n\t}\n\n\t/* Determine what component we are requesting a TURN session for */\n\tif (component == AST_RTP_ICE_COMPONENT_RTP) {\n\t\tturn_sock = &rtp->turn_rtp;\n\t\tturn_cb = &ast_rtp_turn_rtp_sock_cb;\n\t\tconn_transport = TRANSPORT_TURN_RTP;\n\t\tast_sockaddr_set_port(&loop, ast_sockaddr_port(&local));\n\t} else if (component == AST_RTP_ICE_COMPONENT_RTCP) {\n\t\tturn_sock = &rtp->turn_rtcp;\n\t\tturn_cb = &ast_rtp_turn_rtcp_sock_cb;\n\t\tconn_transport = TRANSPORT_TURN_RTCP;\n\t\tast_sockaddr_set_port(&loop, ast_sockaddr_port(&rtp->rtcp->us));\n\t} else {\n\t\treturn;\n\t}\n\n\tif (transport == AST_TRANSPORT_UDP) {\n\t\tconn_type = PJ_TURN_TP_UDP;\n\t} else if (transport == AST_TRANSPORT_TCP) {\n\t\tconn_type = PJ_TURN_TP_TCP;\n\t} else {\n\t\tast_assert(0);\n\t\treturn;\n\t}\n\n\tast_sockaddr_parse(&addr, server, PARSE_PORT_FORBID);\n\n\tif (*turn_sock) {\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(*turn_sock);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t}\n\n\tif (component == AST_RTP_ICE_COMPONENT_RTP && !rtp->ioqueue) {\n\t\t/*\n\t\t * We cannot hold the instance lock because we could wait\n\t\t * for the ioqueue thread to die and we might deadlock as\n\t\t * a result.\n\t\t */\n\t\tao2_unlock(instance);\n\t\trtp->ioqueue = rtp_ioqueue_thread_get_or_create();\n\t\tao2_lock(instance);\n\t\tif (!rtp->ioqueue) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpj_stun_config_init(&stun_config, &cachingpool.factory, 0, rtp->ioqueue->ioqueue, rtp->ioqueue->timerheap);\n\tif (!stun_software_attribute) {\n\t\tstun_config.software_name = pj_str(NULL);\n\t}\n\n\t/* Use ICE session group lock for TURN session to avoid deadlock */\n\tpj_turn_sock_cfg_default(&turn_sock_cfg);\n\tice = rtp->ice;\n\tif (ice) {\n\t\tturn_sock_cfg.grp_lock = ice->real_ice->grp_lock;\n\t\tao2_ref(ice, +1);\n\t}\n\n\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\tao2_unlock(instance);\n\tstatus = pj_turn_sock_create(&stun_config,\n\t\tast_sockaddr_is_ipv4(&addr) ? pj_AF_INET() : pj_AF_INET6(), conn_type,\n\t\tturn_cb, &turn_sock_cfg, instance, turn_sock);\n\tao2_cleanup(ice);\n\tif (status != PJ_SUCCESS) {\n\t\tast_log(LOG_WARNING, \"(%p) Could not create a TURN client socket\\n\", instance);\n\t\tao2_lock(instance);\n\t\treturn;\n\t}\n\n\tcred.type = PJ_STUN_AUTH_CRED_STATIC;\n\tpj_strset2(&cred.data.static_cred.username, (char*)username);\n\tcred.data.static_cred.data_type = PJ_STUN_PASSWD_PLAIN;\n\tpj_strset2(&cred.data.static_cred.data, (char*)password);\n\n\tpj_turn_sock_alloc(*turn_sock, pj_cstr(&turn_addr, server), port, NULL, &cred, NULL);\n\n\tast_debug_ice(2, \"(%p) ICE request TURN %s %s candidate\\n\", instance,\n\t\ttransport == AST_TRANSPORT_UDP ? \"UDP\" : \"TCP\",\n\t\tcomponent == AST_RTP_ICE_COMPONENT_RTP ? \"RTP\" : \"RTCP\");\n\n\tao2_lock(instance);\n\n\t/*\n\t * Because the TURN socket is asynchronous and we are synchronous we need to\n\t * wait until it is done\n\t */\n\twhile (rtp->turn_state < PJ_TURN_STATE_READY) {\n\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t}\n\n\t/* If a TURN session was allocated add it as a candidate */\n\tif (rtp->turn_state != PJ_TURN_STATE_READY) {\n\t\treturn;\n\t}\n\n\tpj_turn_sock_get_info(*turn_sock, &info);\n\n\tast_rtp_ice_add_cand(instance, rtp, component, conn_transport,\n\t\tPJ_ICE_CAND_TYPE_RELAYED, 65535, &info.relay_addr, &info.relay_addr,\n\t\t&info.mapped_addr, pj_sockaddr_get_len(&info.relay_addr));\n\n\tif (component == AST_RTP_ICE_COMPONENT_RTP) {\n\t\tast_sockaddr_copy(&rtp->rtp_loop, &loop);\n\t} else if (component == AST_RTP_ICE_COMPONENT_RTCP) {\n\t\tast_sockaddr_copy(&rtp->rtcp_loop, &loop);\n\t}\n}\n\nstatic char *generate_random_string(char *buf, size_t size)\n{\n        long val[4];\n        int x;\n\n        for (x=0; x<4; x++) {\n                val[x] = ast_random();\n\t}\n        snprintf(buf, size, \"%08lx%08lx%08lx%08lx\", (long unsigned)val[0], (long unsigned)val[1], (long unsigned)val[2], (long unsigned)val[3]);\n\n        return buf;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_change_components(struct ast_rtp_instance *instance, int num_components)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* Don't do anything if ICE is unsupported or if we're not changing the\n\t * number of components\n\t */\n\tif (!icesupport || !rtp->ice || rtp->ice_num_components == num_components) {\n\t\treturn;\n\t}\n\n\tast_debug_ice(2, \"(%p) ICE change number of components %u -> %u\\n\", instance,\n\t\trtp->ice_num_components, num_components);\n\n\trtp->ice_num_components = num_components;\n\tice_reset_session(instance);\n}\n\n/* ICE RTP Engine interface declaration */\nstatic struct ast_rtp_engine_ice ast_rtp_ice = {\n\t.set_authentication = ast_rtp_ice_set_authentication,\n\t.add_remote_candidate = ast_rtp_ice_add_remote_candidate,\n\t.start = ast_rtp_ice_start,\n\t.stop = ast_rtp_ice_stop,\n\t.get_ufrag = ast_rtp_ice_get_ufrag,\n\t.get_password = ast_rtp_ice_get_password,\n\t.get_local_candidates = ast_rtp_ice_get_local_candidates,\n\t.ice_lite = ast_rtp_ice_lite,\n\t.set_role = ast_rtp_ice_set_role,\n\t.turn_request = ast_rtp_ice_turn_request,\n\t.change_components = ast_rtp_ice_change_components,\n};\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int dtls_verify_callback(int preverify_ok, X509_STORE_CTX *ctx)\n{\n\t/* We don't want to actually verify the certificate so just accept what they have provided */\n\treturn 1;\n}\n\nstatic int dtls_details_initialize(struct dtls_details *dtls, SSL_CTX *ssl_ctx,\n\tenum ast_rtp_dtls_setup setup, struct ast_rtp_instance *instance)\n{\n\tdtls->dtls_setup = setup;\n\n\tif (!(dtls->ssl = SSL_new(ssl_ctx))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for SSL\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dtls->read_bio = BIO_new(BIO_s_mem()))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for inbound SSL traffic\\n\");\n\t\tgoto error;\n\t}\n\tBIO_set_mem_eof_return(dtls->read_bio, -1);\n\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tif (!(dtls->write_bio = BIO_new(dtls_bio_methods))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for outbound SSL traffic\\n\");\n\t\tgoto error;\n\t}\n\n\tBIO_set_data(dtls->write_bio, instance);\n#else\n\tif (!(dtls->write_bio = BIO_new(&dtls_bio_methods))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for outbound SSL traffic\\n\");\n\t\tgoto error;\n\t}\n\tdtls->write_bio->ptr = instance;\n#endif\n\tSSL_set_bio(dtls->ssl, dtls->read_bio, dtls->write_bio);\n\n\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_PASSIVE) {\n\t\tSSL_set_accept_state(dtls->ssl);\n\t} else {\n\t\tSSL_set_connect_state(dtls->ssl);\n\t}\n\tdtls->connection = AST_RTP_DTLS_CONNECTION_NEW;\n\n\treturn 0;\n\nerror:\n\tif (dtls->read_bio) {\n\t\tBIO_free(dtls->read_bio);\n\t\tdtls->read_bio = NULL;\n\t}\n\n\tif (dtls->write_bio) {\n\t\tBIO_free(dtls->write_bio);\n\t\tdtls->write_bio = NULL;\n\t}\n\n\tif (dtls->ssl) {\n\t\tSSL_free(dtls->ssl);\n\t\tdtls->ssl = NULL;\n\t}\n\treturn -1;\n}\n\nstatic int dtls_setup_rtcp(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->ssl_ctx || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tast_debug_dtls(3, \"(%p) DTLS RTCP setup\\n\", instance);\n\treturn dtls_details_initialize(&rtp->rtcp->dtls, rtp->ssl_ctx, rtp->dtls.dtls_setup, instance);\n}\n\nstatic const SSL_METHOD *get_dtls_method(void)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10002000L\n\treturn DTLSv1_method();\n#else\n\treturn DTLS_method();\n#endif\n}\n\nstruct dtls_cert_info {\n\tEVP_PKEY *private_key;\n\tX509 *certificate;\n};\n\nstatic int apply_dh_params(SSL_CTX *ctx, BIO *bio)\n{\n\tint res = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n\tEVP_PKEY *dhpkey = PEM_read_bio_Parameters(bio, NULL);\n\tif (dhpkey && EVP_PKEY_is_a(dhpkey, \"DH\")) {\n\t\tres = SSL_CTX_set0_tmp_dh_pkey(ctx, dhpkey);\n\t}\n\tif (!res) {\n\t\t/* A successful call to SSL_CTX_set0_tmp_dh_pkey() means\n\t\t   that we lost ownership of dhpkey and should not free\n\t\t   it ourselves */\n\t\tEVP_PKEY_free(dhpkey);\n\t}\n#else\n\tDH *dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tif (dh) {\n\t\tres = SSL_CTX_set_tmp_dh(ctx, dh);\n\t}\n\tDH_free(dh);\n#endif\n\n\treturn res;\n}\n\nstatic void configure_dhparams(const struct ast_rtp *rtp, const struct ast_rtp_dtls_cfg *dtls_cfg)\n{\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L) && (OPENSSL_VERSION_NUMBER < 0x10100000L)\n\tEC_KEY *ecdh;\n#endif\n\n#ifndef OPENSSL_NO_DH\n\tif (!ast_strlen_zero(dtls_cfg->pvtfile)) {\n\t\tBIO *bio = BIO_new_file(dtls_cfg->pvtfile, \"r\");\n\t\tif (bio) {\n\t\t\tif (apply_dh_params(rtp->ssl_ctx, bio)) {\n\t\t\t\tlong options = SSL_OP_CIPHER_SERVER_PREFERENCE |\n\t\t\t\t\tSSL_OP_SINGLE_DH_USE | SSL_OP_SINGLE_ECDH_USE;\n\t\t\t\toptions = SSL_CTX_set_options(rtp->ssl_ctx, options);\n\t\t\t\tast_verb(2, \"DTLS DH initialized, PFS enabled\\n\");\n\t\t\t}\n\t\t\tBIO_free(bio);\n\t\t}\n\t}\n#endif /* !OPENSSL_NO_DH */\n\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L) && (OPENSSL_VERSION_NUMBER < 0x10100000L)\n\t/* enables AES-128 ciphers, to get AES-256 use NID_secp384r1 */\n\tecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (ecdh) {\n\t\tif (SSL_CTX_set_tmp_ecdh(rtp->ssl_ctx, ecdh)) {\n\t\t\t#ifndef SSL_CTRL_SET_ECDH_AUTO\n\t\t\t\t#define SSL_CTRL_SET_ECDH_AUTO 94\n\t\t\t#endif\n\t\t\t/* SSL_CTX_set_ecdh_auto(rtp->ssl_ctx, on); requires OpenSSL 1.0.2 which wraps: */\n\t\t\tif (SSL_CTX_ctrl(rtp->ssl_ctx, SSL_CTRL_SET_ECDH_AUTO, 1, NULL)) {\n\t\t\t\tast_verb(2, \"DTLS ECDH initialized (automatic), faster PFS enabled\\n\");\n\t\t\t} else {\n\t\t\t\tast_verb(2, \"DTLS ECDH initialized (secp256r1), faster PFS enabled\\n\");\n\t\t\t}\n\t\t}\n\t\tEC_KEY_free(ecdh);\n\t}\n#endif /* !OPENSSL_NO_ECDH */\n}\n\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n\nstatic int create_ephemeral_ec_keypair(EVP_PKEY **keypair)\n{\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n\t*keypair = EVP_EC_gen(SN_X9_62_prime256v1);\n\treturn *keypair ? 0 : -1;\n#else\n\tEC_KEY *eckey = NULL;\n\tEC_GROUP *group = NULL;\n\n\tgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (!group) {\n\t\tgoto error;\n\t}\n\n\tEC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);\n\tEC_GROUP_set_point_conversion_form(group, POINT_CONVERSION_UNCOMPRESSED);\n\n\teckey = EC_KEY_new();\n\tif (!eckey) {\n\t\tgoto error;\n\t}\n\n\tif (!EC_KEY_set_group(eckey, group)) {\n\t\tgoto error;\n\t}\n\n\tif (!EC_KEY_generate_key(eckey)) {\n\t\tgoto error;\n\t}\n\n\t*keypair = EVP_PKEY_new();\n\tif (!*keypair) {\n\t\tgoto error;\n\t}\n\n\tEVP_PKEY_assign_EC_KEY(*keypair, eckey);\n\tEC_GROUP_free(group);\n\n\treturn 0;\n\nerror:\n\tEC_KEY_free(eckey);\n\tEC_GROUP_free(group);\n\n\treturn -1;\n#endif\n}\n\n/* From OpenSSL's x509 command */\n#define SERIAL_RAND_BITS 159\n\nstatic int create_ephemeral_certificate(EVP_PKEY *keypair, X509 **certificate)\n{\n\tX509 *cert = NULL;\n\tBIGNUM *serial = NULL;\n\tX509_NAME *name = NULL;\n\n\tcert = X509_new();\n\tif (!cert) {\n\t\tgoto error;\n\t}\n\n\tif (!X509_set_version(cert, 2)) {\n\t\tgoto error;\n\t}\n\n\t/* Set the public key */\n\tX509_set_pubkey(cert, keypair);\n\n\t/* Generate a random serial number */\n\tif (!(serial = BN_new())\n\t   || !BN_rand(serial, SERIAL_RAND_BITS, -1, 0)\n\t   || !BN_to_ASN1_INTEGER(serial, X509_get_serialNumber(cert))) {\n\t\tBN_free(serial);\n\t\tgoto error;\n\t}\n\n\tBN_free(serial);\n\n\t/*\n\t * Validity period - Current Chrome & Firefox make it 31 days starting\n\t * with yesterday at the current time, so we will do the same.\n\t */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tif (!X509_time_adj_ex(X509_get_notBefore(cert), -1, 0, NULL)\n\t   || !X509_time_adj_ex(X509_get_notAfter(cert), 30, 0, NULL)) {\n\t\tgoto error;\n\t}\n#else\n\tif (!X509_time_adj_ex(X509_getm_notBefore(cert), -1, 0, NULL)\n\t   || !X509_time_adj_ex(X509_getm_notAfter(cert), 30, 0, NULL)) {\n\t\tgoto error;\n\t}\n#endif\n\n\t/* Set the name and issuer */\n\tif (!(name = X509_get_subject_name(cert))\n\t   || !X509_NAME_add_entry_by_NID(name, NID_commonName, MBSTRING_ASC,\n\t\t\t\t\t\t\t\t\t  (unsigned char *) \"asterisk\", -1, -1, 0)\n\t   || !X509_set_issuer_name(cert, name)) {\n\t\tgoto error;\n\t}\n\n\t/* Sign it */\n\tif (!X509_sign(cert, keypair, EVP_sha256())) {\n\t\tgoto error;\n\t}\n\n\t*certificate = cert;\n\n\treturn 0;\n\nerror:\n\tX509_free(cert);\n\n\treturn -1;\n}\n\nstatic int create_certificate_ephemeral(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t\t\tconst struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t\t\tstruct dtls_cert_info *cert_info)\n{\n\t/* Make sure these are initialized */\n\tcert_info->private_key = NULL;\n\tcert_info->certificate = NULL;\n\n\tif (create_ephemeral_ec_keypair(&cert_info->private_key)) {\n\t\tast_log(LOG_ERROR, \"Failed to create ephemeral ECDSA keypair\\n\");\n\t\tgoto error;\n\t}\n\n\tif (create_ephemeral_certificate(cert_info->private_key, &cert_info->certificate)) {\n\t\tast_log(LOG_ERROR, \"Failed to create ephemeral X509 certificate\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n  error:\n\tX509_free(cert_info->certificate);\n\tEVP_PKEY_free(cert_info->private_key);\n\n\treturn -1;\n}\n\n#else\n\nstatic int create_certificate_ephemeral(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t\t\tconst struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t\t\tstruct dtls_cert_info *cert_info)\n{\n\tast_log(LOG_ERROR, \"Your version of OpenSSL does not support ECDSA keys\\n\");\n\treturn -1;\n}\n\n#endif /* !OPENSSL_NO_ECDH */\n\nstatic int create_certificate_from_file(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t\t\tconst struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t\t\tstruct dtls_cert_info *cert_info)\n{\n\tFILE *fp;\n\tBIO *certbio = NULL;\n\tEVP_PKEY *private_key = NULL;\n\tX509 *cert = NULL;\n\tchar *private_key_file = ast_strlen_zero(dtls_cfg->pvtfile) ? dtls_cfg->certfile : dtls_cfg->pvtfile;\n\n\tfp = fopen(private_key_file, \"r\");\n\tif (!fp) {\n\t\tast_log(LOG_ERROR, \"Failed to read private key from file '%s': %s\\n\", private_key_file, strerror(errno));\n\t\tgoto error;\n\t}\n\n\tif (!PEM_read_PrivateKey(fp, &private_key, NULL, NULL)) {\n\t\tast_log(LOG_ERROR, \"Failed to read private key from PEM file '%s'\\n\", private_key_file);\n\t\tfclose(fp);\n\t\tgoto error;\n\t}\n\n\tif (fclose(fp)) {\n\t\tast_log(LOG_ERROR, \"Failed to close private key file '%s': %s\\n\", private_key_file, strerror(errno));\n\t\tgoto error;\n\t}\n\n\tcertbio = BIO_new(BIO_s_file());\n\tif (!certbio) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for certificate fingerprinting on RTP instance '%p'\\n\",\n\t\t\t\tinstance);\n\t\tgoto error;\n\t}\n\n\tif (!BIO_read_filename(certbio, dtls_cfg->certfile)\n\t   || !(cert = PEM_read_bio_X509(certbio, NULL, 0, NULL))) {\n\t\tast_log(LOG_ERROR, \"Failed to read certificate from file '%s'\\n\", dtls_cfg->certfile);\n\t\tgoto error;\n\t}\n\n\tcert_info->private_key = private_key;\n\tcert_info->certificate = cert;\n\n\tBIO_free_all(certbio);\n\n\treturn 0;\n\nerror:\n\tX509_free(cert);\n\tBIO_free_all(certbio);\n\tEVP_PKEY_free(private_key);\n\n\treturn -1;\n}\n\nstatic int load_dtls_certificate(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t const struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t struct dtls_cert_info *cert_info)\n{\n\tif (dtls_cfg->ephemeral_cert) {\n\t\treturn create_certificate_ephemeral(instance, dtls_cfg, cert_info);\n\t} else if (!ast_strlen_zero(dtls_cfg->certfile)) {\n\t\treturn create_certificate_from_file(instance, dtls_cfg, cert_info);\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtls_set_configuration(struct ast_rtp_instance *instance, const struct ast_rtp_dtls_cfg *dtls_cfg)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct dtls_cert_info cert_info = { 0 };\n\tint res;\n\n\tif (!dtls_cfg->enabled) {\n\t\treturn 0;\n\t}\n\n\tast_debug_dtls(3, \"(%p) DTLS RTP setup\\n\", instance);\n\n\tif (!ast_rtp_engine_srtp_is_registered()) {\n\t\tast_log(LOG_ERROR, \"SRTP support module is not loaded or available. Try loading res_srtp.so.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rtp->ssl_ctx) {\n\t\treturn 0;\n\t}\n\n\trtp->ssl_ctx = SSL_CTX_new(get_dtls_method());\n\tif (!rtp->ssl_ctx) {\n\t\treturn -1;\n\t}\n\n\tSSL_CTX_set_read_ahead(rtp->ssl_ctx, 1);\n\n\tconfigure_dhparams(rtp, dtls_cfg);\n\n\trtp->dtls_verify = dtls_cfg->verify;\n\n\tSSL_CTX_set_verify(rtp->ssl_ctx, (rtp->dtls_verify & AST_RTP_DTLS_VERIFY_FINGERPRINT) || (rtp->dtls_verify & AST_RTP_DTLS_VERIFY_CERTIFICATE) ?\n\t\tSSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT : SSL_VERIFY_NONE, !(rtp->dtls_verify & AST_RTP_DTLS_VERIFY_CERTIFICATE) ?\n\t\tdtls_verify_callback : NULL);\n\n\tif (dtls_cfg->suite == AST_AES_CM_128_HMAC_SHA1_80) {\n\t\tSSL_CTX_set_tlsext_use_srtp(rtp->ssl_ctx, \"SRTP_AES128_CM_SHA1_80\");\n\t} else if (dtls_cfg->suite == AST_AES_CM_128_HMAC_SHA1_32) {\n\t\tSSL_CTX_set_tlsext_use_srtp(rtp->ssl_ctx, \"SRTP_AES128_CM_SHA1_32\");\n\t} else {\n\t\tast_log(LOG_ERROR, \"Unsupported suite specified for DTLS-SRTP on RTP instance '%p'\\n\", instance);\n\t\treturn -1;\n\t}\n\n\trtp->local_hash = dtls_cfg->hash;\n\n\tif (!load_dtls_certificate(instance, dtls_cfg, &cert_info)) {\n\t\tconst EVP_MD *type;\n\t\tunsigned int size, i;\n\t\tunsigned char fingerprint[EVP_MAX_MD_SIZE];\n\t\tchar *local_fingerprint = rtp->local_fingerprint;\n\n\t\tif (!SSL_CTX_use_certificate(rtp->ssl_ctx, cert_info.certificate)) {\n\t\t\tast_log(LOG_ERROR, \"Specified certificate for RTP instance '%p' could not be used\\n\",\n\t\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!SSL_CTX_use_PrivateKey(rtp->ssl_ctx, cert_info.private_key)\n\t\t    || !SSL_CTX_check_private_key(rtp->ssl_ctx)) {\n\t\t\tast_log(LOG_ERROR, \"Specified private key for RTP instance '%p' could not be used\\n\",\n\t\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rtp->local_hash == AST_RTP_DTLS_HASH_SHA1) {\n\t\t\ttype = EVP_sha1();\n\t\t} else if (rtp->local_hash == AST_RTP_DTLS_HASH_SHA256) {\n\t\t\ttype = EVP_sha256();\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Unsupported fingerprint hash type on RTP instance '%p'\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!X509_digest(cert_info.certificate, type, fingerprint, &size) || !size) {\n\t\t\tast_log(LOG_ERROR, \"Could not produce fingerprint from certificate for RTP instance '%p'\\n\",\n\t\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tsprintf(local_fingerprint, \"%02hhX:\", fingerprint[i]);\n\t\t\tlocal_fingerprint += 3;\n\t\t}\n\n\t\t*(local_fingerprint - 1) = 0;\n\n\t\tEVP_PKEY_free(cert_info.private_key);\n\t\tX509_free(cert_info.certificate);\n\t}\n\n\tif (!ast_strlen_zero(dtls_cfg->cipher)) {\n\t\tif (!SSL_CTX_set_cipher_list(rtp->ssl_ctx, dtls_cfg->cipher)) {\n\t\t\tast_log(LOG_ERROR, \"Invalid cipher specified in cipher list '%s' for RTP instance '%p'\\n\",\n\t\t\t\tdtls_cfg->cipher, instance);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!ast_strlen_zero(dtls_cfg->cafile) || !ast_strlen_zero(dtls_cfg->capath)) {\n\t\tif (!SSL_CTX_load_verify_locations(rtp->ssl_ctx, S_OR(dtls_cfg->cafile, NULL), S_OR(dtls_cfg->capath, NULL))) {\n\t\t\tast_log(LOG_ERROR, \"Invalid certificate authority file '%s' or path '%s' specified for RTP instance '%p'\\n\",\n\t\t\t\tS_OR(dtls_cfg->cafile, \"\"), S_OR(dtls_cfg->capath, \"\"), instance);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trtp->rekey = dtls_cfg->rekey;\n\trtp->suite = dtls_cfg->suite;\n\n\tres = dtls_details_initialize(&rtp->dtls, rtp->ssl_ctx, dtls_cfg->default_setup, instance);\n\tif (!res) {\n\t\tdtls_setup_rtcp(instance);\n\t}\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtls_active(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn !rtp->ssl_ctx ? 0 : 1;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_stop(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tSSL *ssl = rtp->dtls.ssl;\n\n\tast_debug_dtls(3, \"(%p) DTLS stop\\n\", instance);\n\tao2_unlock(instance);\n\tdtls_srtp_stop_timeout_timer(instance, rtp, 0);\n\tao2_lock(instance);\n\n\tif (rtp->ssl_ctx) {\n\t\tSSL_CTX_free(rtp->ssl_ctx);\n\t\trtp->ssl_ctx = NULL;\n\t}\n\n\tif (rtp->dtls.ssl) {\n\t\tSSL_free(rtp->dtls.ssl);\n\t\trtp->dtls.ssl = NULL;\n\t}\n\n\tif (rtp->rtcp) {\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, 1);\n\t\tao2_lock(instance);\n\n\t\tif (rtp->rtcp->dtls.ssl) {\n\t\t\tif (rtp->rtcp->dtls.ssl != ssl) {\n\t\t\t\tSSL_free(rtp->rtcp->dtls.ssl);\n\t\t\t}\n\t\t\trtp->rtcp->dtls.ssl = NULL;\n\t\t}\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_reset(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (SSL_is_init_finished(rtp->dtls.ssl)) {\n\t\tSSL_shutdown(rtp->dtls.ssl);\n\t\trtp->dtls.connection = AST_RTP_DTLS_CONNECTION_NEW;\n\t}\n\n\tif (rtp->rtcp && SSL_is_init_finished(rtp->rtcp->dtls.ssl)) {\n\t\tSSL_shutdown(rtp->rtcp->dtls.ssl);\n\t\trtp->rtcp->dtls.connection = AST_RTP_DTLS_CONNECTION_NEW;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtls_connection ast_rtp_dtls_get_connection(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->dtls.connection;\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtls_setup ast_rtp_dtls_get_setup(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->dtls.dtls_setup;\n}\n\nstatic void dtls_set_setup(enum ast_rtp_dtls_setup *dtls_setup, enum ast_rtp_dtls_setup setup, SSL *ssl)\n{\n\tenum ast_rtp_dtls_setup old = *dtls_setup;\n\n\tswitch (setup) {\n\tcase AST_RTP_DTLS_SETUP_ACTIVE:\n\t\t*dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\tbreak;\n\tcase AST_RTP_DTLS_SETUP_PASSIVE:\n\t\t*dtls_setup = AST_RTP_DTLS_SETUP_ACTIVE;\n\t\tbreak;\n\tcase AST_RTP_DTLS_SETUP_ACTPASS:\n\t\t/* We can't respond to an actpass setup with actpass ourselves... so respond with active, as we can initiate connections */\n\t\tif (*dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\t*dtls_setup = AST_RTP_DTLS_SETUP_ACTIVE;\n\t\t}\n\t\tbreak;\n\tcase AST_RTP_DTLS_SETUP_HOLDCONN:\n\t\t*dtls_setup = AST_RTP_DTLS_SETUP_HOLDCONN;\n\t\tbreak;\n\tdefault:\n\t\t/* This should never occur... if it does exit early as we don't know what state things are in */\n\t\treturn;\n\t}\n\n\t/* If the setup state did not change we go on as if nothing happened */\n\tif (old == *dtls_setup) {\n\t\treturn;\n\t}\n\n\t/* If they don't want us to establish a connection wait until later */\n\tif (*dtls_setup == AST_RTP_DTLS_SETUP_HOLDCONN) {\n\t\treturn;\n\t}\n\n\tif (*dtls_setup == AST_RTP_DTLS_SETUP_ACTIVE) {\n\t\tSSL_set_connect_state(ssl);\n\t} else if (*dtls_setup == AST_RTP_DTLS_SETUP_PASSIVE) {\n\t\tSSL_set_accept_state(ssl);\n\t} else {\n\t\treturn;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_set_setup(struct ast_rtp_instance *instance, enum ast_rtp_dtls_setup setup)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->dtls.ssl) {\n\t\tdtls_set_setup(&rtp->dtls.dtls_setup, setup, rtp->dtls.ssl);\n\t}\n\n\tif (rtp->rtcp && rtp->rtcp->dtls.ssl) {\n\t\tdtls_set_setup(&rtp->rtcp->dtls.dtls_setup, setup, rtp->rtcp->dtls.ssl);\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_set_fingerprint(struct ast_rtp_instance *instance, enum ast_rtp_dtls_hash hash, const char *fingerprint)\n{\n\tchar *tmp = ast_strdupa(fingerprint), *value;\n\tint pos = 0;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (hash != AST_RTP_DTLS_HASH_SHA1 && hash != AST_RTP_DTLS_HASH_SHA256) {\n\t\treturn;\n\t}\n\n\trtp->remote_hash = hash;\n\n\twhile ((value = strsep(&tmp, \":\")) && (pos != (EVP_MAX_MD_SIZE - 1))) {\n\t\tsscanf(value, \"%02hhx\", &rtp->remote_fingerprint[pos++]);\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtls_hash ast_rtp_dtls_get_fingerprint_hash(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_hash;\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_dtls_get_fingerprint(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_fingerprint;\n}\n\n/* DTLS RTP Engine interface declaration */\nstatic struct ast_rtp_engine_dtls ast_rtp_dtls = {\n\t.set_configuration = ast_rtp_dtls_set_configuration,\n\t.active = ast_rtp_dtls_active,\n\t.stop = ast_rtp_dtls_stop,\n\t.reset = ast_rtp_dtls_reset,\n\t.get_connection = ast_rtp_dtls_get_connection,\n\t.get_setup = ast_rtp_dtls_get_setup,\n\t.set_setup = ast_rtp_dtls_set_setup,\n\t.set_fingerprint = ast_rtp_dtls_set_fingerprint,\n\t.get_fingerprint_hash = ast_rtp_dtls_get_fingerprint_hash,\n\t.get_fingerprint = ast_rtp_dtls_get_fingerprint,\n};\n\n#endif\n\n#ifdef TEST_FRAMEWORK\nstatic size_t get_recv_buffer_count(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->recv_buffer) {\n\t\treturn ast_data_buffer_count(rtp->recv_buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t get_recv_buffer_max(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->recv_buffer) {\n\t\treturn ast_data_buffer_max(rtp->recv_buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t get_send_buffer_count(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->send_buffer) {\n\t\treturn ast_data_buffer_count(rtp->send_buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_rtp_rtcp_schedid(struct ast_rtp_instance *instance, int id)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->rtcp) {\n\t\trtp->rtcp->schedid = id;\n\t}\n}\n\nstatic struct ast_rtp_engine_test ast_rtp_test = {\n\t.packets_to_drop = 0,\n\t.send_report = 0,\n\t.sdes_received = 0,\n\t.recv_buffer_count = get_recv_buffer_count,\n\t.recv_buffer_max = get_recv_buffer_max,\n\t.send_buffer_count = get_send_buffer_count,\n\t.set_schedid = set_rtp_rtcp_schedid,\n};\n#endif\n\n/* RTP Engine Declaration */\nstatic struct ast_rtp_engine asterisk_rtp_engine = {\n\t.name = \"asterisk\",\n\t.new = ast_rtp_new,\n\t.destroy = ast_rtp_destroy,\n\t.dtmf_begin = ast_rtp_dtmf_begin,\n\t.dtmf_end = ast_rtp_dtmf_end,\n\t.dtmf_end_with_duration = ast_rtp_dtmf_end_with_duration,\n\t.dtmf_mode_set = ast_rtp_dtmf_mode_set,\n\t.dtmf_mode_get = ast_rtp_dtmf_mode_get,\n\t.update_source = ast_rtp_update_source,\n\t.change_source = ast_rtp_change_source,\n\t.write = ast_rtp_write,\n\t.read = ast_rtp_read,\n\t.prop_set = ast_rtp_prop_set,\n\t.fd = ast_rtp_fd,\n\t.remote_address_set = ast_rtp_remote_address_set,\n\t.red_init = rtp_red_init,\n\t.red_buffer = rtp_red_buffer,\n\t.local_bridge = ast_rtp_local_bridge,\n\t.get_stat = ast_rtp_get_stat,\n\t.dtmf_compatible = ast_rtp_dtmf_compatible,\n\t.stun_request = ast_rtp_stun_request,\n\t.stop = ast_rtp_stop,\n\t.qos = ast_rtp_qos_set,\n\t.sendcng = ast_rtp_sendcng,\n#ifdef HAVE_PJPROJECT\n\t.ice = &ast_rtp_ice,\n#endif\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t.dtls = &ast_rtp_dtls,\n\t.activate = ast_rtp_activate,\n#endif\n\t.ssrc_get = ast_rtp_get_ssrc,\n\t.cname_get = ast_rtp_get_cname,\n\t.set_remote_ssrc = ast_rtp_set_remote_ssrc,\n\t.set_stream_num = ast_rtp_set_stream_num,\n\t.extension_enable = ast_rtp_extension_enable,\n\t.bundle = ast_rtp_bundle,\n#ifdef TEST_FRAMEWORK\n\t.test = &ast_rtp_test,\n#endif\n};\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n/*! \\pre instance is locked */\nstatic void dtls_perform_handshake(struct ast_rtp_instance *instance, struct dtls_details *dtls, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tast_debug_dtls(3, \"(%p) DTLS perform handshake - ssl = %p, setup = %d\\n\",\n\t\trtp, dtls->ssl, dtls->dtls_setup);\n\n\t/* If we are not acting as a client connecting to the remote side then\n\t * don't start the handshake as it will accomplish nothing and would conflict\n\t * with the handshake we receive from the remote side.\n\t */\n\tif (!dtls->ssl || (dtls->dtls_setup != AST_RTP_DTLS_SETUP_ACTIVE)) {\n\t\treturn;\n\t}\n\n\tSSL_do_handshake(dtls->ssl);\n\n\t/*\n\t * A race condition is prevented between this function and __rtp_recvfrom()\n\t * because both functions have to get the instance lock before they can do\n\t * anything.  Without holding the instance lock, this function could start\n\t * the SSL handshake above in one thread and the __rtp_recvfrom() function\n\t * called by the channel thread could read the response and stop the timeout\n\t * timer before we have a chance to even start it.\n\t */\n\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic void dtls_perform_setup(struct dtls_details *dtls)\n{\n\tif (!dtls->ssl || !SSL_is_init_finished(dtls->ssl)) {\n\t\treturn;\n\t}\n\n\tSSL_clear(dtls->ssl);\n\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_PASSIVE) {\n\t\tSSL_set_accept_state(dtls->ssl);\n\t} else {\n\t\tSSL_set_connect_state(dtls->ssl);\n\t}\n\tdtls->connection = AST_RTP_DTLS_CONNECTION_NEW;\n\n\tast_debug_dtls(3, \"DTLS perform setup - connection reset\\n\");\n}\n#endif\n\n#ifdef HAVE_PJPROJECT\nstatic void rtp_learning_start(struct ast_rtp *rtp);\n\n/* Handles start of media during ICE negotiation or completion */\nstatic void ast_rtp_ice_start_media(pj_ice_sess *ice, pj_status_t status)\n{\n\tstruct ast_rtp_instance *instance = ice->user_data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\tif (status == PJ_SUCCESS) {\n\t\tstruct ast_sockaddr remote_address;\n\n\t\tast_sockaddr_setnull(&remote_address);\n\t\tupdate_address_with_ice_candidate(ice, AST_RTP_ICE_COMPONENT_RTP, &remote_address);\n\t\tif (!ast_sockaddr_isnull(&remote_address)) {\n\t\t\t/* Symmetric RTP must be disabled for the remote address to not get overwritten */\n\t\t\tast_rtp_instance_set_prop(instance, AST_RTP_PROPERTY_NAT, 0);\n\n\t\t\tast_rtp_instance_set_remote_address(instance, &remote_address);\n\t\t}\n\n\t\tif (rtp->rtcp) {\n\t\t\tupdate_address_with_ice_candidate(ice, AST_RTP_ICE_COMPONENT_RTCP, &rtp->rtcp->them);\n\t\t}\n\t}\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If we've already started media, no need to do all of this again */\n\tif (rtp->ice_media_started) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tast_debug_category(2, AST_DEBUG_CATEGORY_ICE | AST_DEBUG_CATEGORY_DTLS,\n\t\t\"(%p) ICE starting media - perform DTLS - (%p)\\n\", instance, rtp);\n\n\t/*\n\t * Seemingly no reason to call dtls_perform_setup here. Currently we'll do a full\n\t * protocol level renegotiation if things do change. And if bundled is being used\n\t * then ICE is reused when a stream is added.\n\t *\n\t * Note, if for some reason in the future dtls_perform_setup does need to done here\n\t * be aware that creates a race condition between the call here (on ice completion)\n\t * and potential DTLS handshaking when receiving RTP. What happens is the ssl object\n\t * can get cleared (SSL_clear) during that handshaking process (DTLS init). If that\n\t * happens then Asterisk won't complete DTLS initialization. RTP packets are still\n\t * sent/received but won't be encrypted/decrypted.\n\t */\n\tdtls_perform_handshake(instance, &rtp->dtls, 0);\n\n\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\tdtls_perform_handshake(instance, &rtp->rtcp->dtls, 1);\n\t}\n#endif\n\n\trtp->ice_media_started = 1;\n\n\tif (!strictrtp) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tast_verb(4, \"%p -- Strict RTP learning after ICE completion\\n\", rtp);\n\trtp_learning_start(rtp);\n\tao2_unlock(instance);\n}\n\n#ifdef HAVE_PJPROJECT_ON_VALID_ICE_PAIR_CALLBACK\n/* PJPROJECT ICE optional callback */\nstatic void ast_rtp_on_valid_pair(pj_ice_sess *ice)\n{\n\tast_debug_ice(2, \"(%p) ICE valid pair, start media\\n\", ice->user_data);\n\tast_rtp_ice_start_media(ice, PJ_SUCCESS);\n}\n#endif\n\n/* PJPROJECT ICE callback */\nstatic void ast_rtp_on_ice_complete(pj_ice_sess *ice, pj_status_t status)\n{\n\tast_debug_ice(2, \"(%p) ICE complete, start media\\n\", ice->user_data);\n\tast_rtp_ice_start_media(ice, status);\n}\n\n/* PJPROJECT ICE callback */\nstatic void ast_rtp_on_ice_rx_data(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, void *pkt, pj_size_t size, const pj_sockaddr_t *src_addr, unsigned src_addr_len)\n{\n\tstruct ast_rtp_instance *instance = ice->user_data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* Instead of handling the packet here (which really doesn't work with our architecture) we set a bit to indicate that it should be handled after pj_ice_sess_on_rx_pkt\n\t * returns */\n\tif (transport_id == TRANSPORT_SOCKET_RTP || transport_id == TRANSPORT_SOCKET_RTCP) {\n\t\trtp->passthrough = 1;\n\t} else if (transport_id == TRANSPORT_TURN_RTP) {\n\t\trtp->rtp_passthrough = 1;\n\t} else if (transport_id == TRANSPORT_TURN_RTCP) {\n\t\trtp->rtcp_passthrough = 1;\n\t}\n}\n\n/* PJPROJECT ICE callback */\nstatic pj_status_t ast_rtp_on_ice_tx_pkt(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, const void *pkt, pj_size_t size, const pj_sockaddr_t *dst_addr, unsigned dst_addr_len)\n{\n\tstruct ast_rtp_instance *instance = ice->user_data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tpj_status_t status = PJ_EINVALIDOP;\n\tpj_ssize_t _size = (pj_ssize_t)size;\n\n\tif (transport_id == TRANSPORT_SOCKET_RTP) {\n\t\t/* Traffic is destined to go right out the RTP socket we already have */\n\t\tstatus = pj_sock_sendto(rtp->s, pkt, &_size, 0, dst_addr, dst_addr_len);\n\t\t/* sendto on a connectionless socket should send all the data, or none at all */\n\t\tast_assert(_size == size || status != PJ_SUCCESS);\n\t} else if (transport_id == TRANSPORT_SOCKET_RTCP) {\n\t\t/* Traffic is destined to go right out the RTCP socket we already have */\n\t\tif (rtp->rtcp) {\n\t\t\tstatus = pj_sock_sendto(rtp->rtcp->s, pkt, &_size, 0, dst_addr, dst_addr_len);\n\t\t\t/* sendto on a connectionless socket should send all the data, or none at all */\n\t\t\tast_assert(_size == size || status != PJ_SUCCESS);\n\t\t} else {\n\t\t\tstatus = PJ_SUCCESS;\n\t\t}\n\t} else if (transport_id == TRANSPORT_TURN_RTP) {\n\t\t/* Traffic is going through the RTP TURN relay */\n\t\tif (rtp->turn_rtp) {\n\t\t\tstatus = pj_turn_sock_sendto(rtp->turn_rtp, pkt, size, dst_addr, dst_addr_len);\n\t\t}\n\t} else if (transport_id == TRANSPORT_TURN_RTCP) {\n\t\t/* Traffic is going through the RTCP TURN relay */\n\t\tif (rtp->turn_rtcp) {\n\t\t\tstatus = pj_turn_sock_sendto(rtp->turn_rtcp, pkt, size, dst_addr, dst_addr_len);\n\t\t}\n\t}\n\n\treturn status;\n}\n\n/* ICE Session interface declaration */\nstatic pj_ice_sess_cb ast_rtp_ice_sess_cb = {\n#ifdef HAVE_PJPROJECT_ON_VALID_ICE_PAIR_CALLBACK\n\t.on_valid_pair = ast_rtp_on_valid_pair,\n#endif\n\t.on_ice_complete = ast_rtp_on_ice_complete,\n\t.on_rx_data = ast_rtp_on_ice_rx_data,\n\t.on_tx_pkt = ast_rtp_on_ice_tx_pkt,\n};\n\n/*! \\brief Worker thread for timerheap */\nstatic int timer_worker_thread(void *data)\n{\n\tpj_ioqueue_t *ioqueue;\n\n\tif (pj_ioqueue_create(pool, 1, &ioqueue) != PJ_SUCCESS) {\n\t\treturn -1;\n\t}\n\n\twhile (!timer_terminate) {\n\t\tconst pj_time_val delay = {0, 10};\n\n\t\tpj_timer_heap_poll(timer_heap, NULL);\n\t\tpj_ioqueue_poll(ioqueue, &delay);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic inline int rtp_debug_test_addr(struct ast_sockaddr *addr)\n{\n\tif (!ast_debug_rtp_packet_is_allowed) {\n\t\treturn 0;\n\t}\n\tif (!ast_sockaddr_isnull(&rtpdebugaddr)) {\n\t\tif (rtpdebugport) {\n\t\t\treturn (ast_sockaddr_cmp(&rtpdebugaddr, addr) == 0); /* look for RTP packets from IP+Port */\n\t\t} else {\n\t\t\treturn (ast_sockaddr_cmp_addr(&rtpdebugaddr, addr) == 0); /* only look for RTP packets from IP */\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic inline int rtcp_debug_test_addr(struct ast_sockaddr *addr)\n{\n\tif (!ast_debug_rtcp_packet_is_allowed) {\n\t\treturn 0;\n\t}\n\tif (!ast_sockaddr_isnull(&rtcpdebugaddr)) {\n\t\tif (rtcpdebugport) {\n\t\t\treturn (ast_sockaddr_cmp(&rtcpdebugaddr, addr) == 0); /* look for RTCP packets from IP+Port */\n\t\t} else {\n\t\t\treturn (ast_sockaddr_cmp_addr(&rtcpdebugaddr, addr) == 0); /* only look for RTCP packets from IP */\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n/*! \\pre instance is locked */\nstatic int dtls_srtp_handle_timeout(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\tstruct timeval dtls_timeout;\n\n\tast_debug_dtls(3, \"(%p) DTLS srtp - handle timeout - rtcp=%d\\n\", instance, rtcp);\n\tDTLSv1_handle_timeout(dtls->ssl);\n\n\t/* If a timeout can't be retrieved then this recurring scheduled item must stop */\n\tif (!DTLSv1_get_timeout(dtls->ssl, &dtls_timeout)) {\n\t\tdtls->timeout_timer = -1;\n\t\treturn 0;\n\t}\n\n\treturn dtls_timeout.tv_sec * 1000 + dtls_timeout.tv_usec / 1000;\n}\n\n/* Scheduler callback */\nstatic int dtls_srtp_handle_rtp_timeout(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;\n\tint reschedule;\n\n\tao2_lock(instance);\n\treschedule = dtls_srtp_handle_timeout(instance, 0);\n\tao2_unlock(instance);\n\tif (!reschedule) {\n\t\tao2_ref(instance, -1);\n\t}\n\n\treturn reschedule;\n}\n\n/* Scheduler callback */\nstatic int dtls_srtp_handle_rtcp_timeout(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;\n\tint reschedule;\n\n\tao2_lock(instance);\n\treschedule = dtls_srtp_handle_timeout(instance, 1);\n\tao2_unlock(instance);\n\tif (!reschedule) {\n\t\tao2_ref(instance, -1);\n\t}\n\n\treturn reschedule;\n}\n\nstatic void dtls_srtp_start_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp)\n{\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\tstruct timeval dtls_timeout;\n\n\tif (DTLSv1_get_timeout(dtls->ssl, &dtls_timeout)) {\n\t\tint timeout = dtls_timeout.tv_sec * 1000 + dtls_timeout.tv_usec / 1000;\n\n\t\tast_assert(dtls->timeout_timer == -1);\n\n\t\tao2_ref(instance, +1);\n\t\tif ((dtls->timeout_timer = ast_sched_add(rtp->sched, timeout,\n\t\t\t!rtcp ? dtls_srtp_handle_rtp_timeout : dtls_srtp_handle_rtcp_timeout, instance)) < 0) {\n\t\t\tao2_ref(instance, -1);\n\t\t\tast_log(LOG_WARNING, \"Scheduling '%s' DTLS retransmission for RTP instance [%p] failed.\\n\",\n\t\t\t\t!rtcp ? \"RTP\" : \"RTCP\", instance);\n\t\t} else {\n\t\t\tast_debug_dtls(3, \"(%p) DTLS srtp - scheduled timeout timer for '%d'\\n\", instance, timeout);\n\t\t}\n\t}\n}\n\n/*! \\pre Must not be called with the instance locked. */\nstatic void dtls_srtp_stop_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp)\n{\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\n\tAST_SCHED_DEL_UNREF(rtp->sched, dtls->timeout_timer, ao2_ref(instance, -1));\n\tast_debug_dtls(3, \"(%p) DTLS srtp - stopped timeout timer'\\n\", instance);\n}\n\n/* Scheduler callback */\nstatic int dtls_srtp_renegotiate(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\tast_debug_dtls(3, \"(%p) DTLS srtp - renegotiate'\\n\", instance);\n\tSSL_renegotiate(rtp->dtls.ssl);\n\tSSL_do_handshake(rtp->dtls.ssl);\n\n\tif (rtp->rtcp && rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {\n\t\tSSL_renegotiate(rtp->rtcp->dtls.ssl);\n\t\tSSL_do_handshake(rtp->rtcp->dtls.ssl);\n\t}\n\n\trtp->rekeyid = -1;\n\n\tao2_unlock(instance);\n\tao2_ref(instance, -1);\n\n\treturn 0;\n}\n\nstatic int dtls_srtp_add_local_ssrc(struct ast_rtp *rtp, struct ast_rtp_instance *instance, int rtcp, unsigned int ssrc, int set_remote_policy)\n{\n\tunsigned char material[SRTP_MASTER_LEN * 2];\n\tunsigned char *local_key, *local_salt, *remote_key, *remote_salt;\n\tstruct ast_srtp_policy *local_policy, *remote_policy = NULL;\n\tint res = -1;\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\n\tast_debug_dtls(3, \"(%p) DTLS srtp - add local ssrc - rtcp=%d, set_remote_policy=%d'\\n\",\n\t\t\t\t   instance, rtcp, set_remote_policy);\n\n\t/* Produce key information and set up SRTP */\n\tif (!SSL_export_keying_material(dtls->ssl, material, SRTP_MASTER_LEN * 2, \"EXTRACTOR-dtls_srtp\", 19, NULL, 0, 0)) {\n\t\tast_log(LOG_WARNING, \"Unable to extract SRTP keying material from DTLS-SRTP negotiation on RTP instance '%p'\\n\",\n\t\t\tinstance);\n\t\treturn -1;\n\t}\n\n\t/* Whether we are acting as a server or client determines where the keys/salts are */\n\tif (rtp->dtls.dtls_setup == AST_RTP_DTLS_SETUP_ACTIVE) {\n\t\tlocal_key = material;\n\t\tremote_key = local_key + SRTP_MASTER_KEY_LEN;\n\t\tlocal_salt = remote_key + SRTP_MASTER_KEY_LEN;\n\t\tremote_salt = local_salt + SRTP_MASTER_SALT_LEN;\n\t} else {\n\t\tremote_key = material;\n\t\tlocal_key = remote_key + SRTP_MASTER_KEY_LEN;\n\t\tremote_salt = local_key + SRTP_MASTER_KEY_LEN;\n\t\tlocal_salt = remote_salt + SRTP_MASTER_SALT_LEN;\n\t}\n\n\tif (!(local_policy = res_srtp_policy->alloc())) {\n\t\treturn -1;\n\t}\n\n\tif (res_srtp_policy->set_master_key(local_policy, local_key, SRTP_MASTER_KEY_LEN, local_salt, SRTP_MASTER_SALT_LEN) < 0) {\n\t\tast_log(LOG_WARNING, \"Could not set key/salt information on local policy of '%p' when setting up DTLS-SRTP\\n\", rtp);\n\t\tgoto error;\n\t}\n\n\tif (res_srtp_policy->set_suite(local_policy, rtp->suite)) {\n\t\tast_log(LOG_WARNING, \"Could not set suite to '%u' on local policy of '%p' when setting up DTLS-SRTP\\n\", rtp->suite, rtp);\n\t\tgoto error;\n\t}\n\n\tres_srtp_policy->set_ssrc(local_policy, ssrc, 0);\n\n\tif (set_remote_policy) {\n\t\tif (!(remote_policy = res_srtp_policy->alloc())) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (res_srtp_policy->set_master_key(remote_policy, remote_key, SRTP_MASTER_KEY_LEN, remote_salt, SRTP_MASTER_SALT_LEN) < 0) {\n\t\t\tast_log(LOG_WARNING, \"Could not set key/salt information on remote policy of '%p' when setting up DTLS-SRTP\\n\", rtp);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (res_srtp_policy->set_suite(remote_policy, rtp->suite)) {\n\t\t\tast_log(LOG_WARNING, \"Could not set suite to '%u' on remote policy of '%p' when setting up DTLS-SRTP\\n\", rtp->suite, rtp);\n\t\t\tgoto error;\n\t\t}\n\n\t\tres_srtp_policy->set_ssrc(remote_policy, 0, 1);\n\t}\n\n\tif (ast_rtp_instance_add_srtp_policy(instance, remote_policy, local_policy, rtcp)) {\n\t\tast_log(LOG_WARNING, \"Could not set policies when setting up DTLS-SRTP on '%p'\\n\", rtp);\n\t\tgoto error;\n\t}\n\n\tres = 0;\n\nerror:\n\t/* policy->destroy() called even on success to release local reference to these resources */\n\tres_srtp_policy->destroy(local_policy);\n\n\tif (remote_policy) {\n\t\tres_srtp_policy->destroy(remote_policy);\n\t}\n\n\treturn res;\n}\n\nstatic int dtls_srtp_setup(struct ast_rtp *rtp, struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\tint index;\n\n\tast_debug_dtls(3, \"(%p) DTLS setup SRTP rtp=%p'\\n\", instance, rtp);\n\n\t/* If a fingerprint is present in the SDP make sure that the peer certificate matches it */\n\tif (rtp->dtls_verify & AST_RTP_DTLS_VERIFY_FINGERPRINT) {\n\t\tX509 *certificate;\n\n\t\tif (!(certificate = SSL_get_peer_certificate(dtls->ssl))) {\n\t\t\tast_log(LOG_WARNING, \"No certificate was provided by the peer on RTP instance '%p'\\n\", instance);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If a fingerprint is present in the SDP make sure that the peer certificate matches it */\n\t\tif (rtp->remote_fingerprint[0]) {\n\t\t\tconst EVP_MD *type;\n\t\t\tunsigned char fingerprint[EVP_MAX_MD_SIZE];\n\t\t\tunsigned int size;\n\n\t\t\tif (rtp->remote_hash == AST_RTP_DTLS_HASH_SHA1) {\n\t\t\t\ttype = EVP_sha1();\n\t\t\t} else if (rtp->remote_hash == AST_RTP_DTLS_HASH_SHA256) {\n\t\t\t\ttype = EVP_sha256();\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Unsupported fingerprint hash type on RTP instance '%p'\\n\", instance);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!X509_digest(certificate, type, fingerprint, &size) ||\n\t\t\t    !size ||\n\t\t\t    memcmp(fingerprint, rtp->remote_fingerprint, size)) {\n\t\t\t\tX509_free(certificate);\n\t\t\t\tast_log(LOG_WARNING, \"Fingerprint provided by remote party does not match that of peer certificate on RTP instance '%p'\\n\",\n\t\t\t\t\tinstance);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tX509_free(certificate);\n\t}\n\n\tif (dtls_srtp_add_local_ssrc(rtp, instance, rtcp, ast_rtp_instance_get_ssrc(instance), 1)) {\n\t\tast_log(LOG_ERROR, \"Failed to add local source '%p'\\n\", rtp);\n\t\treturn -1;\n\t}\n\n\tfor (index = 0; index < AST_VECTOR_SIZE(&rtp->ssrc_mapping); ++index) {\n\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&rtp->ssrc_mapping, index);\n\n\t\tif (dtls_srtp_add_local_ssrc(rtp, instance, rtcp, ast_rtp_instance_get_ssrc(mapping->instance), 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (rtp->rekey) {\n\t\tao2_ref(instance, +1);\n\t\tif ((rtp->rekeyid = ast_sched_add(rtp->sched, rtp->rekey * 1000, dtls_srtp_renegotiate, instance)) < 0) {\n\t\t\tao2_ref(instance, -1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n/*! \\brief Helper function to compare an elem in a vector by value */\nstatic int compare_by_value(int elem, int value)\n{\n\treturn elem - value;\n}\n\n/*! \\brief Helper function to find an elem in a vector by value */\nstatic int find_by_value(int elem, int value)\n{\n\treturn elem == value;\n}\n\nstatic int rtcp_mux(struct ast_rtp *rtp, const unsigned char *packet)\n{\n\tuint8_t version;\n\tuint8_t pt;\n\tuint8_t m;\n\n\tif (!rtp->rtcp || rtp->rtcp->type != AST_RTP_INSTANCE_RTCP_MUX) {\n\t\treturn 0;\n\t}\n\n\tversion = (packet[0] & 0XC0) >> 6;\n\tif (version == 0) {\n\t\t/* version 0 indicates this is a STUN packet and shouldn't\n\t\t * be interpreted as a possible RTCP packet\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* The second octet of a packet will be one of the following:\n\t * For RTP: The marker bit (1 bit) and the RTP payload type (7 bits)\n\t * For RTCP: The payload type (8)\n\t *\n\t * RTP has a forbidden range of payload types (64-95) since these\n\t * will conflict with RTCP payload numbers if the marker bit is set.\n\t */\n\tm = packet[1] & 0x80;\n\tpt = packet[1] & 0x7F;\n\tif (m && pt >= 64 && pt <= 95) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n{\n\tint len;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tchar *in = buf;\n#endif\n#ifdef HAVE_PJPROJECT\n\tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n#endif\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n\t\treturn len;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->packets_to_drop > 0) {\n\t\ttest->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n\t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n\tif ((*in >= 20) && (*in <= 63)) {\n\t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\t\tint res = 0;\n\n\t\t/* If no SSL session actually exists terminate things */\n\t\tif (!dtls->ssl) {\n\t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n\n\t\t/*\n\t\t * A race condition is prevented between dtls_perform_handshake()\n\t\t * and this function because both functions have to get the\n\t\t * instance lock before they can do anything.  The\n\t\t * dtls_perform_handshake() function needs to start the timer\n\t\t * before we stop it below.\n\t\t */\n\n\t\t/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, rtcp);\n\t\tao2_lock(instance);\n\n\t\t/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */\n\t\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\tdtls->dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t\tSSL_set_accept_state(dtls->ssl);\n\t\t}\n\n\t\tBIO_write(dtls->read_bio, buf, len);\n\n\t\tlen = SSL_read(dtls->ssl, buf, len);\n\n\t\tif ((len < 0) && (SSL_get_error(dtls->ssl, len) == SSL_ERROR_SSL)) {\n\t\t\tunsigned long error = ERR_get_error();\n\t\t\tast_log(LOG_ERROR, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tinstance, ERR_reason_error_string(error));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\t\t/* Any further connections will be existing since this is now established */\n\t\t\tdtls->connection = AST_RTP_DTLS_CONNECTION_EXISTING;\n\t\t\t/* Use the keying material to set up key/salt information */\n\t\t\tif ((res = dtls_srtp_setup(rtp, instance, rtcp))) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t/* Notify that dtls has been established */\n\t\t\tres = RTP_DTLS_ESTABLISHED;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", instance, rtp);\n\t\t} else {\n\t\t\t/* Since we've sent additional traffic start the timeout timer for retransmission */\n\t\t\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n\t\t}\n\n\t\treturn res;\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\tif (!ast_sockaddr_isnull(loop) && !ast_sockaddr_cmp(loop, sa)) {\n\t\t/* ICE traffic will have been handled in the TURN callback, so skip it but update the address\n\t\t * so it reflects the actual source and not the loopback\n\t\t */\n\t\tif (rtcp) {\n\t\t\tast_sockaddr_copy(sa, &rtp->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(instance, sa);\n\t\t}\n\t} else if (rtp->ice) {\n\t\tpj_str_t combined = pj_str(ast_sockaddr_stringify(sa));\n\t\tpj_sockaddr address;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice,\n\t\t\trtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,\n\t\t\trtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,\n\t\t\tpj_sockaddr_get_len(&address));\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar err_buf[100];\n\n\t\t\tpj_strerror(status, err_buf, sizeof(err_buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, err_buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!rtp->passthrough) {\n\t\t\t/* If a unidirectional ICE negotiation occurs then lock on to the source of the\n\t\t\t * ICE traffic and use it as the target. This will occur if the remote side only\n\t\t\t * wants to receive media but never send to us.\n\t\t\t */\n\t\t\tif (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {\n\t\t\t\tif (rtcp) {\n\t\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, sa);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(instance, sa);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\trtp->passthrough = 0;\n\t}\n#endif\n\n\treturn len;\n}\n\n/*! \\pre instance is locked */\nstatic int rtcp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa)\n{\n\treturn __rtp_recvfrom(instance, buf, size, flags, sa, 1);\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa)\n{\n\treturn __rtp_recvfrom(instance, buf, size, flags, sa, 0);\n}\n\n/*! \\pre instance is locked */\nstatic int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *via_ice, int use_srtp)\n{\n\tint len = size;\n\tvoid *temp = buf;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_instance *transport = rtp->bundled ? rtp->bundled : instance;\n\tstruct ast_rtp *transport_rtp = ast_rtp_instance_get_data(transport);\n\tstruct ast_srtp *srtp = ast_rtp_instance_get_srtp(transport, rtcp);\n\tint res;\n\n\t*via_ice = 0;\n\n\tif (use_srtp && res_srtp && srtp && res_srtp->protect(srtp, &temp, &len, rtcp) < 0) {\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_PJPROJECT\n\tif (transport_rtp->ice) {\n\t\tenum ast_rtp_ice_component_type component = rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\t/* If RTCP is sharing the same socket then use the same component */\n\t\tif (rtcp && rtp->rtcp->s == rtp->s) {\n\t\t\tcomponent = AST_RTP_ICE_COMPONENT_RTP;\n\t\t}\n\n\t\tpj_thread_register_check();\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = transport_rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tif (instance == transport) {\n\t\t\tao2_unlock(instance);\n\t\t}\n\t\tstatus = pj_ice_sess_send_data(ice->real_ice, component, temp, len);\n\t\tao2_ref(ice, -1);\n\t\tif (instance == transport) {\n\t\t\tao2_lock(instance);\n\t\t}\n\t\tif (status == PJ_SUCCESS) {\n\t\t\t*via_ice = 1;\n\t\t\treturn len;\n\t\t}\n\t}\n#endif\n\n\tres = ast_sendto(rtcp ? transport_rtp->rtcp->s : transport_rtp->s, temp, len, flags, sa);\n\tif (res > 0) {\n\t\tast_rtp_instance_set_last_tx(instance, time(NULL));\n\t}\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic int rtcp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int *ice)\n{\n\treturn __rtp_sendto(instance, buf, size, flags, sa, 1, ice, 1);\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int *ice)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint hdrlen = 12;\n\tint res;\n\n\tif ((res = __rtp_sendto(instance, buf, size, flags, sa, 0, ice, 1)) > 0) {\n\t\trtp->txcount++;\n\t\trtp->txoctetcount += (res - hdrlen);\n\t}\n\n\treturn res;\n}\n\nstatic unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp)\n{\n\tunsigned int interval;\n\t/*! \\todo XXX Do a more reasonable calculation on this one\n\t * Look in RFC 3550 Section A.7 for an example*/\n\tinterval = rtcpinterval;\n\treturn interval;\n}\n\nstatic void calc_mean_and_standard_deviation(double new_sample, double *mean, double *std_dev, unsigned int *count)\n{\n\tdouble delta1;\n\tdouble delta2;\n\n\t/* First convert the standard deviation back into a sum of squares. */\n\tdouble last_sum_of_squares = (*std_dev) * (*std_dev) * (*count ?: 1);\n\n\tif (++(*count) == 0) {\n\t\t/* Avoid potential divide by zero on an overflow */\n\t\t*count = 1;\n\t}\n\n\t/*\n\t * Below is an implementation of Welford's online algorithm [1] for calculating\n\t * mean and variance in a single pass.\n\t *\n\t * [1] https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n\t */\n\n\tdelta1 = new_sample - *mean;\n\t*mean += (delta1 / *count);\n\tdelta2 = new_sample - *mean;\n\n\t/* Now calculate the new variance, and subsequent standard deviation */\n\t*std_dev = sqrt((last_sum_of_squares + (delta1 * delta2)) / *count);\n}\n\nstatic int create_new_socket(const char *type, int af)\n{\n\tint sock = ast_socket_nonblock(af, SOCK_DGRAM, 0);\n\n\tif (sock < 0) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate %s socket: %s\\n\", type, strerror(errno));\n\t\treturn sock;\n\t}\n\n#ifdef SO_NO_CHECK\n\tif (nochecksums) {\n\t\tsetsockopt(sock, SOL_SOCKET, SO_NO_CHECK, &nochecksums, sizeof(nochecksums));\n\t}\n#endif\n\n\treturn sock;\n}\n\n/*!\n * \\internal\n * \\brief Initializes sequence values and probation for learning mode.\n * \\note This is an adaptation of pjmedia's pjmedia_rtp_seq_init function.\n *\n * \\param info The learning information to track\n * \\param seq sequence number read from the rtp header to initialize the information with\n */\nstatic void rtp_learning_seq_init(struct rtp_learning_info *info, uint16_t seq)\n{\n\tinfo->max_seq = seq;\n\tinfo->packets = learning_min_sequential;\n\tmemset(&info->received, 0, sizeof(info->received));\n}\n\n/*!\n * \\internal\n * \\brief Updates sequence information for learning mode and determines if probation/learning mode should remain in effect.\n * \\note This function was adapted from pjmedia's pjmedia_rtp_seq_update function.\n *\n * \\param info Structure tracking the learning progress of some address\n * \\param seq sequence number read from the rtp header\n * \\retval 0 if probation mode should exit for this address\n * \\retval non-zero if probation mode should continue\n */\nstatic int rtp_learning_rtp_seq_update(struct rtp_learning_info *info, uint16_t seq)\n{\n\tif (seq == (uint16_t) (info->max_seq + 1)) {\n\t\t/* packet is in sequence */\n\t\tinfo->packets--;\n\t} else {\n\t\t/* Sequence discontinuity; reset */\n\t\tinfo->packets = learning_min_sequential - 1;\n\t\tinfo->received = ast_tvnow();\n\t}\n\n\t/* Only check time if strictrtp is set to yes. Otherwise, we only needed to check seqno */\n\tif (strictrtp == STRICT_RTP_YES) {\n\t\tswitch (info->stream_type) {\n\t\tcase AST_MEDIA_TYPE_UNKNOWN:\n\t\tcase AST_MEDIA_TYPE_AUDIO:\n\t\t\t/*\n\t\t\t * Protect against packet floods by checking that we\n\t\t\t * received the packet sequence in at least the minimum\n\t\t\t * allowed time.\n\t\t\t */\n\t\t\tif (ast_tvzero(info->received)) {\n\t\t\t\tinfo->received = ast_tvnow();\n\t\t\t} else if (!info->packets\n\t\t\t\t&& ast_tvdiff_ms(ast_tvnow(), info->received) < learning_min_duration) {\n\t\t\t\t/* Packet flood; reset */\n\t\t\t\tinfo->packets = learning_min_sequential - 1;\n\t\t\t\tinfo->received = ast_tvnow();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_MEDIA_TYPE_VIDEO:\n\t\tcase AST_MEDIA_TYPE_IMAGE:\n\t\tcase AST_MEDIA_TYPE_TEXT:\n\t\tcase AST_MEDIA_TYPE_END:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinfo->max_seq = seq;\n\n\treturn info->packets;\n}\n\n/*!\n * \\brief Start the strictrtp learning mode.\n *\n * \\param rtp RTP session description\n */\nstatic void rtp_learning_start(struct ast_rtp *rtp)\n{\n\trtp->strict_rtp_state = STRICT_RTP_LEARN;\n\tmemset(&rtp->rtp_source_learn.proposed_address, 0,\n\t\tsizeof(rtp->rtp_source_learn.proposed_address));\n\trtp->rtp_source_learn.start = ast_tvnow();\n\trtp_learning_seq_init(&rtp->rtp_source_learn, (uint16_t) rtp->lastrxseqno);\n}\n\n#ifdef HAVE_PJPROJECT\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message);\n\n/*!\n * \\internal\n * \\brief Resets and ACL to empty state.\n */\nstatic void rtp_unload_acl(ast_rwlock_t *lock, struct ast_acl_list **acl)\n{\n\tast_rwlock_wrlock(lock);\n\t*acl = ast_free_acl_list(*acl);\n\tast_rwlock_unlock(lock);\n}\n\n/*!\n * \\internal\n * \\brief Checks an address against the ICE blacklist\n * \\note If there is no ice_blacklist list, always returns 0\n *\n * \\param address The address to consider\n * \\retval 0 if address is not ICE blacklisted\n * \\retval 1 if address is ICE blacklisted\n */\nstatic int rtp_address_is_ice_blacklisted(const struct ast_sockaddr *address)\n{\n\tint result = 0;\n\n\tast_rwlock_rdlock(&ice_acl_lock);\n\tresult |= ast_apply_acl_nolog(ice_acl, address) == AST_SENSE_DENY;\n\tast_rwlock_unlock(&ice_acl_lock);\n\n\treturn result;\n}\n\n/*!\n * \\internal\n * \\brief Checks an address against the STUN blacklist\n * \\since 13.16.0\n *\n * \\note If there is no stun_blacklist list, always returns 0\n *\n * \\param addr The address to consider\n *\n * \\retval 0 if address is not STUN blacklisted\n * \\retval 1 if address is STUN blacklisted\n */\nstatic int stun_address_is_blacklisted(const struct ast_sockaddr *addr)\n{\n\tint result = 0;\n\n\tast_rwlock_rdlock(&stun_acl_lock);\n\tresult |= ast_apply_acl_nolog(stun_acl, addr) == AST_SENSE_DENY;\n\tast_rwlock_unlock(&stun_acl_lock);\n\n\treturn result;\n}\n\n/*! \\pre instance is locked */\nstatic void rtp_add_candidates_to_ice(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *addr, int port, int component,\n\t\t\t\t      int transport)\n{\n\tunsigned int count = 0;\n\tstruct ifaddrs *ifa, *ia;\n\tstruct ast_sockaddr tmp;\n\tpj_sockaddr pjtmp;\n\tstruct ast_ice_host_candidate *candidate;\n\tint af_inet_ok = 0, af_inet6_ok = 0;\n\tstruct sockaddr_in stunaddr_copy;\n\n\tif (ast_sockaddr_is_ipv4(addr)) {\n\t\taf_inet_ok = 1;\n\t} else if (ast_sockaddr_is_any(addr)) {\n\t\taf_inet_ok = af_inet6_ok = 1;\n\t} else {\n\t\taf_inet6_ok = 1;\n\t}\n\n\tif (getifaddrs(&ifa) < 0) {\n\t\t/* If we can't get addresses, we can't load ICE candidates */\n\t\tast_log(LOG_ERROR, \"(%p) ICE Error obtaining list of local addresses: %s\\n\",\n\t\t\t\tinstance, strerror(errno));\n\t} else {\n\t\tast_debug_ice(2, \"(%p) ICE add system candidates\\n\", instance);\n\t\t/* Iterate through the list of addresses obtained from the system,\n\t\t * until we've iterated through all of them, or accepted\n\t\t * PJ_ICE_MAX_CAND candidates */\n\t\tfor (ia = ifa; ia && count < PJ_ICE_MAX_CAND; ia = ia->ifa_next) {\n\t\t\t/* Interface is either not UP or doesn't have an address assigned,\n\t\t\t * eg, a ppp that just completed LCP but no IPCP yet */\n\t\t\tif (!ia->ifa_addr || (ia->ifa_flags & IFF_UP) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Filter out non-IPvX addresses, eg, link-layer */\n\t\t\tif (ia->ifa_addr->sa_family != AF_INET && ia->ifa_addr->sa_family != AF_INET6) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_sockaddr_from_sockaddr(&tmp, ia->ifa_addr);\n\n\t\t\tif (ia->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tconst struct sockaddr_in *sa_in = (struct sockaddr_in*)ia->ifa_addr;\n\t\t\t\tif (!af_inet_ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Skip 127.0.0.0/8 (loopback) */\n\t\t\t\t/* Don't use IFF_LOOPBACK check since one could assign usable\n\t\t\t\t * publics to the loopback */\n\t\t\t\tif ((sa_in->sin_addr.s_addr & htonl(0xFF000000)) == htonl(0x7F000000)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Skip 0.0.0.0/8 based on RFC1122, and from pjproject */\n\t\t\t\tif ((sa_in->sin_addr.s_addr & htonl(0xFF000000)) == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else { /* ia->ifa_addr->sa_family == AF_INET6 */\n\t\t\t\tif (!af_inet6_ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Filter ::1 */\n\t\t\t\tif (!ast_sockaddr_cmp_addr(&lo6, &tmp)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Pull in the host candidates from [ice_host_candidates] */\n\t\t\tAST_RWLIST_RDLOCK(&host_candidates);\n\t\t\tAST_LIST_TRAVERSE(&host_candidates, candidate, next) {\n\t\t\t\tif (!ast_sockaddr_cmp(&candidate->local, &tmp)) {\n\t\t\t\t\t/* candidate->local matches actual assigned, so check if\n\t\t\t\t\t * advertised is blacklisted, if not, add it to the\n\t\t\t\t\t * advertised list.  Not that it would make sense to remap\n\t\t\t\t\t * a local address to a blacklisted address, but honour it\n\t\t\t\t\t * anyway. */\n\t\t\t\t\tif (!rtp_address_is_ice_blacklisted(&candidate->advertised)) {\n\t\t\t\t\t\tast_sockaddr_to_pj_sockaddr(&candidate->advertised, &pjtmp);\n\t\t\t\t\t\tpj_sockaddr_set_port(&pjtmp, port);\n\t\t\t\t\t\tast_rtp_ice_add_cand(instance, rtp, component, transport,\n\t\t\t\t\t\t\t\tPJ_ICE_CAND_TYPE_HOST, 65535, &pjtmp, &pjtmp, NULL,\n\t\t\t\t\t\t\t\tpj_sockaddr_get_len(&pjtmp));\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!candidate->include_local) {\n\t\t\t\t\t\t/* We don't want to advertise the actual address */\n\t\t\t\t\t\tast_sockaddr_setnull(&tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAST_RWLIST_UNLOCK(&host_candidates);\n\n\t\t\t/* we had an entry in [ice_host_candidates] that matched, and\n\t\t\t * didn't have include_local_address set.  Alternatively, adding\n\t\t\t * that match resulted in us going to PJ_ICE_MAX_CAND */\n\t\t\tif (ast_sockaddr_isnull(&tmp) || count == PJ_ICE_MAX_CAND) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rtp_address_is_ice_blacklisted(&tmp)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_sockaddr_to_pj_sockaddr(&tmp, &pjtmp);\n\t\t\tpj_sockaddr_set_port(&pjtmp, port);\n\t\t\tast_rtp_ice_add_cand(instance, rtp, component, transport,\n\t\t\t\t\tPJ_ICE_CAND_TYPE_HOST, 65535, &pjtmp, &pjtmp, NULL,\n\t\t\t\t\tpj_sockaddr_get_len(&pjtmp));\n\t\t\t++count;\n\t\t}\n\t\tfreeifaddrs(ifa);\n\t}\n\n\tast_rwlock_rdlock(&stunaddr_lock);\n\tmemcpy(&stunaddr_copy, &stunaddr, sizeof(stunaddr));\n\tast_rwlock_unlock(&stunaddr_lock);\n\n\t/* If configured to use a STUN server to get our external mapped address do so */\n\tif (stunaddr_copy.sin_addr.s_addr && !stun_address_is_blacklisted(addr) &&\n\t\t(ast_sockaddr_is_ipv4(addr) || ast_sockaddr_is_any(addr)) &&\n\t\tcount < PJ_ICE_MAX_CAND) {\n\t\tstruct sockaddr_in answer;\n\t\tint rsp;\n\n\t\tast_debug_category(3, AST_DEBUG_CATEGORY_ICE | AST_DEBUG_CATEGORY_STUN,\n\t\t\t\"(%p) ICE request STUN %s %s candidate\\n\", instance,\n\t\t\ttransport == AST_TRANSPORT_UDP ? \"UDP\" : \"TCP\",\n\t\t\tcomponent == AST_RTP_ICE_COMPONENT_RTP ? \"RTP\" : \"RTCP\");\n\n\t\t/*\n\t\t * The instance should not be locked because we can block\n\t\t * waiting for a STUN respone.\n\t\t */\n\t\tao2_unlock(instance);\n\t\trsp = ast_stun_request(component == AST_RTP_ICE_COMPONENT_RTCP\n\t\t\t? rtp->rtcp->s : rtp->s, &stunaddr_copy, NULL, &answer);\n\t\tao2_lock(instance);\n\t\tif (!rsp) {\n\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n\t\t\tpj_sockaddr ext, base;\n\t\t\tpj_str_t mapped = pj_str(ast_strdupa(ast_inet_ntoa(answer.sin_addr)));\n\t\t\tint srflx = 1, baseset = 0;\n\t\t\tstruct ao2_iterator i;\n\n\t\t\tpj_sockaddr_init(pj_AF_INET(), &ext, &mapped, ntohs(answer.sin_port));\n\n\t\t\t/*\n\t\t\t * If the returned address is the same as one of our host\n\t\t\t * candidates, don't send the srflx.  At the same time,\n\t\t\t * we need to set the base address (raddr).\n\t\t\t */\n\t\t\ti = ao2_iterator_init(rtp->ice_local_candidates, 0);\n\t\t\twhile (srflx && (candidate = ao2_iterator_next(&i))) {\n\t\t\t\tif (!baseset && ast_sockaddr_is_ipv4(&candidate->address)) {\n\t\t\t\t\tbaseset = 1;\n\t\t\t\t\tast_sockaddr_to_pj_sockaddr(&candidate->address, &base);\n\t\t\t\t}\n\n\t\t\t\tif (!pj_sockaddr_cmp(&candidate->address, &ext)) {\n\t\t\t\t\tsrflx = 0;\n\t\t\t\t}\n\n\t\t\t\tao2_ref(candidate, -1);\n\t\t\t}\n\t\t\tao2_iterator_destroy(&i);\n\n\t\t\tif (srflx && baseset) {\n\t\t\t\tpj_sockaddr_set_port(&base, port);\n\t\t\t\tast_rtp_ice_add_cand(instance, rtp, component, transport,\n\t\t\t\t\tPJ_ICE_CAND_TYPE_SRFLX, 65535, &ext, &base, &base,\n\t\t\t\t\tpj_sockaddr_get_len(&ext));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If configured to use a TURN relay create a session and allocate */\n\tif (pj_strlen(&turnaddr)) {\n\t\tast_rtp_ice_turn_request(instance, component, AST_TRANSPORT_TCP, pj_strbuf(&turnaddr), turnport,\n\t\t\tpj_strbuf(&turnusername), pj_strbuf(&turnpassword));\n\t}\n}\n#endif\n\n/*!\n * \\internal\n * \\brief Calculates the elapsed time from issue of the first tx packet in an\n *        rtp session and a specified time\n *\n * \\param rtp pointer to the rtp struct with the transmitted rtp packet\n * \\param delivery time of delivery - if NULL or zero value, will be ast_tvnow()\n *\n * \\return time elapsed in milliseconds\n */\nstatic unsigned int calc_txstamp(struct ast_rtp *rtp, struct timeval *delivery)\n{\n\tstruct timeval t;\n\tlong ms;\n\n\tif (ast_tvzero(rtp->txcore)) {\n\t\trtp->txcore = ast_tvnow();\n\t\trtp->txcore.tv_usec -= rtp->txcore.tv_usec % 20000;\n\t}\n\n\tt = (delivery && !ast_tvzero(*delivery)) ? *delivery : ast_tvnow();\n\tif ((ms = ast_tvdiff_ms(t, rtp->txcore)) < 0) {\n\t\tms = 0;\n\t}\n\trtp->txcore = t;\n\n\treturn (unsigned int) ms;\n}\n\n#ifdef HAVE_PJPROJECT\n/*!\n * \\internal\n * \\brief Creates an ICE session. Can be used to replace a destroyed ICE session.\n *\n * \\param instance RTP instance for which the ICE session is being replaced\n * \\param addr ast_sockaddr to use for adding RTP candidates to the ICE session\n * \\param port port to use for adding RTP candidates to the ICE session\n * \\param replace 0 when creating a new session, 1 when replacing a destroyed session\n *\n * \\pre instance is locked\n *\n * \\retval 0 on success\n * \\retval -1 on failure\n */\nstatic int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,\n\tint port, int replace)\n{\n\tpj_stun_config stun_config;\n\tpj_str_t ufrag, passwd;\n\tpj_status_t status;\n\tstruct ice_wrap *ice_old;\n\tstruct ice_wrap *ice;\n\tpj_ice_sess *real_ice = NULL;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_cleanup(rtp->ice_local_candidates);\n\trtp->ice_local_candidates = NULL;\n\n\tast_debug_ice(2, \"(%p) ICE create%s\\n\", instance, replace ? \" and replace\" : \"\");\n\n\tice = ao2_alloc_options(sizeof(*ice), ice_wrap_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!ice) {\n\t\tast_rtp_ice_stop(instance);\n\t\treturn -1;\n\t}\n\n\tpj_thread_register_check();\n\n\tpj_stun_config_init(&stun_config, &cachingpool.factory, 0, NULL, timer_heap);\n\tif (!stun_software_attribute) {\n\t\tstun_config.software_name = pj_str(NULL);\n\t}\n\n\tufrag = pj_str(rtp->local_ufrag);\n\tpasswd = pj_str(rtp->local_passwd);\n\n\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\tao2_unlock(instance);\n\t/* Create an ICE session for ICE negotiation */\n\tstatus = pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN,\n\t\trtp->ice_num_components, &ast_rtp_ice_sess_cb, &ufrag, &passwd, NULL, &real_ice);\n\tao2_lock(instance);\n\tif (status == PJ_SUCCESS) {\n\t\t/* Safely complete linking the ICE session into the instance */\n\t\treal_ice->user_data = instance;\n\t\tice->real_ice = real_ice;\n\t\tice_old = rtp->ice;\n\t\trtp->ice = ice;\n\t\tif (ice_old) {\n\t\t\tao2_unlock(instance);\n\t\t\tao2_ref(ice_old, -1);\n\t\t\tao2_lock(instance);\n\t\t}\n\n\t\t/* Add all of the available candidates to the ICE session */\n\t\trtp_add_candidates_to_ice(instance, rtp, addr, port, AST_RTP_ICE_COMPONENT_RTP,\n\t\t\tTRANSPORT_SOCKET_RTP);\n\n\t\t/* Only add the RTCP candidates to ICE when replacing the session and if\n\t\t * the ICE session contains more than just an RTP component. New sessions\n\t\t * handle this in a separate part of the setup phase */\n\t\tif (replace && rtp->rtcp && rtp->ice_num_components > 1) {\n\t\t\trtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us,\n\t\t\t\tast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP,\n\t\t\t\tTRANSPORT_SOCKET_RTCP);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * It is safe to unref this while instance is locked here.\n\t * It was not initialized with a real_ice pointer.\n\t */\n\tao2_ref(ice, -1);\n\n\tast_rtp_ice_stop(instance);\n\treturn -1;\n\n}\n#endif\n\nstatic int rtp_allocate_transport(struct ast_rtp_instance *instance, struct ast_rtp *rtp)\n{\n\tint x, startplace, i, maxloops;\n\n\trtp->strict_rtp_state = (strictrtp ? STRICT_RTP_CLOSED : STRICT_RTP_OPEN);\n\n\t/* Create a new socket for us to listen on and use */\n\tif ((rtp->s =\n\t     create_new_socket(\"RTP\",\n\t\t\t       ast_sockaddr_is_ipv4(&rtp->bind_address) ? AF_INET  :\n\t\t\t       ast_sockaddr_is_ipv6(&rtp->bind_address) ? AF_INET6 : -1)) < 0) {\n\t\tast_log(LOG_WARNING, \"Failed to create a new socket for RTP instance '%p'\\n\", instance);\n\t\treturn -1;\n\t}\n\n\t/* Now actually find a free RTP port to use */\n\tx = (ast_random() % (rtpend - rtpstart)) + rtpstart;\n\tx = x & ~1;\n\tstartplace = x;\n\n\t/* Protection against infinite loops in the case there is a potential case where the loop is not broken such as an odd\n\t   start port sneaking in (even though this condition is checked at load.) */\n\tmaxloops = rtpend - rtpstart;\n\tfor (i = 0; i <= maxloops; i++) {\n\t\tast_sockaddr_set_port(&rtp->bind_address, x);\n\t\t/* Try to bind, this will tell us whether the port is available or not */\n\t\tif (!ast_bind(rtp->s, &rtp->bind_address)) {\n\t\t\tast_debug_rtp(1, \"(%p) RTP allocated port %d\\n\", instance, x);\n\t\t\tast_rtp_instance_set_local_address(instance, &rtp->bind_address);\n\t\t\tast_test_suite_event_notify(\"RTP_PORT_ALLOCATED\", \"Port: %d\", x);\n\t\t\tbreak;\n\t\t}\n\n\t\tx += 2;\n\t\tif (x > rtpend) {\n\t\t\tx = (rtpstart + 1) & ~1;\n\t\t}\n\n\t\t/* See if we ran out of ports or if the bind actually failed because of something other than the address being in use */\n\t\tif (x == startplace || (errno != EADDRINUSE && errno != EACCES)) {\n\t\t\tast_log(LOG_ERROR, \"Oh dear... we couldn't allocate a port for RTP instance '%p'\\n\", instance);\n\t\t\tclose(rtp->s);\n\t\t\trtp->s = -1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n#ifdef HAVE_PJPROJECT\n\t/* Initialize synchronization aspects */\n\tast_cond_init(&rtp->cond, NULL);\n\n\tgenerate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));\n\tgenerate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));\n\n\t/* Create an ICE session for ICE negotiation */\n\tif (icesupport) {\n\t\trtp->ice_num_components = 2;\n\t\tast_debug_ice(2, \"(%p) ICE creating session %s (%d)\\n\", instance,\n\t\t\tast_sockaddr_stringify(&rtp->bind_address), x);\n\t\tif (ice_create(instance, &rtp->bind_address, x, 0)) {\n\t\t\tast_log(LOG_NOTICE, \"(%p) ICE failed to create session\\n\", instance);\n\t\t} else {\n\t\t\trtp->ice_port = x;\n\t\t\tast_sockaddr_copy(&rtp->ice_original_rtp_addr, &rtp->bind_address);\n\t\t}\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\trtp->rekeyid = -1;\n\trtp->dtls.timeout_timer = -1;\n#endif\n\n\treturn 0;\n}\n\nstatic void rtp_deallocate_transport(struct ast_rtp_instance *instance, struct ast_rtp *rtp)\n{\n\tint saved_rtp_s = rtp->s;\n#ifdef HAVE_PJPROJECT\n\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));\n\tstruct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tast_rtp_dtls_stop(instance);\n#endif\n\n\t/* Close our own socket so we no longer get packets */\n\tif (rtp->s > -1) {\n\t\tclose(rtp->s);\n\t\trtp->s = -1;\n\t}\n\n\t/* Destroy RTCP if it was being used */\n\tif (rtp->rtcp && rtp->rtcp->s > -1) {\n\t\tif (saved_rtp_s != rtp->rtcp->s) {\n\t\t\tclose(rtp->rtcp->s);\n\t\t}\n\t\trtp->rtcp->s = -1;\n\t}\n\n#ifdef HAVE_PJPROJECT\n\tpj_thread_register_check();\n\n\t/*\n\t * The instance lock is already held.\n\t *\n\t * Destroy the RTP TURN relay if being used\n\t */\n\tif (rtp->turn_rtp) {\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(rtp->turn_rtp);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t\trtp->turn_rtp = NULL;\n\t}\n\n\t/* Destroy the RTCP TURN relay if being used */\n\tif (rtp->turn_rtcp) {\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(rtp->turn_rtcp);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t\trtp->turn_rtcp = NULL;\n\t}\n\n\tast_debug_ice(2, \"(%p) ICE RTP transport deallocating\\n\", instance);\n\t/* Destroy any ICE session */\n\tast_rtp_ice_stop(instance);\n\n\t/* Destroy any candidates */\n\tif (rtp->ice_local_candidates) {\n\t\tao2_ref(rtp->ice_local_candidates, -1);\n\t\trtp->ice_local_candidates = NULL;\n\t}\n\n\tif (rtp->ice_active_remote_candidates) {\n\t\tao2_ref(rtp->ice_active_remote_candidates, -1);\n\t\trtp->ice_active_remote_candidates = NULL;\n\t}\n\n\tif (rtp->ice_proposed_remote_candidates) {\n\t\tao2_ref(rtp->ice_proposed_remote_candidates, -1);\n\t\trtp->ice_proposed_remote_candidates = NULL;\n\t}\n\n\tif (rtp->ioqueue) {\n\t\t/*\n\t\t * We cannot hold the instance lock because we could wait\n\t\t * for the ioqueue thread to die and we might deadlock as\n\t\t * a result.\n\t\t */\n\t\tao2_unlock(instance);\n\t\trtp_ioqueue_thread_remove(rtp->ioqueue);\n\t\tao2_lock(instance);\n\t\trtp->ioqueue = NULL;\n\t}\n#endif\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_new(struct ast_rtp_instance *instance,\n\t\t       struct ast_sched_context *sched, struct ast_sockaddr *addr,\n\t\t       void *data)\n{\n\tstruct ast_rtp *rtp = NULL;\n\n\t/* Create a new RTP structure to hold all of our data */\n\tif (!(rtp = ast_calloc(1, sizeof(*rtp)))) {\n\t\treturn -1;\n\t}\n\trtp->owner = instance;\n\t/* Set default parameters on the newly created RTP structure */\n\trtp->ssrc = ast_random();\n\tast_uuid_generate_str(rtp->cname, sizeof(rtp->cname));\n\trtp->seqno = ast_random() & 0x7fff;\n\trtp->expectedrxseqno = -1;\n\trtp->expectedseqno = -1;\n\trtp->rxstart = -1;\n\trtp->sched = sched;\n\tast_sockaddr_copy(&rtp->bind_address, addr);\n\t/* Transport creation operations can grab the RTP data from the instance, so set it */\n\tast_rtp_instance_set_data(instance, rtp);\n\n\tif (rtp_allocate_transport(instance, rtp)) {\n\t\treturn -1;\n\t}\n\n\tif (AST_VECTOR_INIT(&rtp->ssrc_mapping, 1)) {\n\t\treturn -1;\n\t}\n\n\tif (AST_VECTOR_INIT(&rtp->transport_wide_cc.packet_statistics, 0)) {\n\t\treturn -1;\n\t}\n\trtp->transport_wide_cc.schedid = -1;\n\n\trtp->f.subclass.format = ao2_bump(ast_format_none);\n\trtp->lastrxformat = ao2_bump(ast_format_none);\n\trtp->lasttxformat = ao2_bump(ast_format_none);\n\trtp->stream_num = -1;\n\n\treturn 0;\n}\n\n/*!\n * \\brief SSRC mapping comparator for AST_VECTOR_REMOVE_CMP_UNORDERED()\n *\n * \\param elem Element to compare against\n * \\param value Value to compare with the vector element.\n *\n * \\retval 0 if element does not match.\n * \\retval Non-zero if element matches.\n */\n#define SSRC_MAPPING_ELEM_CMP(elem, value) ((elem).instance == (value))\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_destroy(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->bundled) {\n\t\tstruct ast_rtp *bundled_rtp;\n\n\t\t/* We can't hold our instance lock while removing ourselves from the parent */\n\t\tao2_unlock(instance);\n\n\t\tao2_lock(rtp->bundled);\n\t\tbundled_rtp = ast_rtp_instance_get_data(rtp->bundled);\n\t\tAST_VECTOR_REMOVE_CMP_UNORDERED(&bundled_rtp->ssrc_mapping, instance, SSRC_MAPPING_ELEM_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\t\tao2_unlock(rtp->bundled);\n\n\t\tao2_lock(instance);\n\t\tao2_ref(rtp->bundled, -1);\n\t}\n\n\trtp_deallocate_transport(instance, rtp);\n\n\t/* Destroy the smoother that was smoothing out audio if present */\n\tif (rtp->smoother) {\n\t\tast_smoother_free(rtp->smoother);\n\t}\n\n\t/* Destroy RTCP if it was being used */\n\tif (rtp->rtcp) {\n\t\t/*\n\t\t * It is not possible for there to be an active RTCP scheduler\n\t\t * entry at this point since it holds a reference to the\n\t\t * RTP instance while it's active.\n\t\t */\n\t\tast_free(rtp->rtcp->local_addr_str);\n\t\tast_free(rtp->rtcp);\n\t}\n\n\t/* Destroy RED if it was being used */\n\tif (rtp->red) {\n\t\tao2_unlock(instance);\n\t\tAST_SCHED_DEL(rtp->sched, rtp->red->schedid);\n\t\tao2_lock(instance);\n\t\tast_free(rtp->red);\n\t\trtp->red = NULL;\n\t}\n\n\t/* Destroy the send buffer if it was being used */\n\tif (rtp->send_buffer) {\n\t\tast_data_buffer_free(rtp->send_buffer);\n\t}\n\n\t/* Destroy the recv buffer if it was being used */\n\tif (rtp->recv_buffer) {\n\t\tast_data_buffer_free(rtp->recv_buffer);\n\t}\n\n\tAST_VECTOR_FREE(&rtp->transport_wide_cc.packet_statistics);\n\n\tao2_cleanup(rtp->lasttxformat);\n\tao2_cleanup(rtp->lastrxformat);\n\tao2_cleanup(rtp->f.subclass.format);\n\tAST_VECTOR_FREE(&rtp->ssrc_mapping);\n\tAST_VECTOR_FREE(&rtp->missing_seqno);\n\n\t/* Finally destroy ourselves */\n\trtp->owner = NULL;\n\tast_free(rtp);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_mode_set(struct ast_rtp_instance *instance, enum ast_rtp_dtmf_mode dtmf_mode)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\trtp->dtmfmode = dtmf_mode;\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtmf_mode ast_rtp_dtmf_mode_get(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\treturn rtp->dtmfmode;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_begin(struct ast_rtp_instance *instance, char digit)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint hdrlen = 12, res = 0, i = 0, payload = 101;\n\tchar data[256];\n\tunsigned int *rtpheader = (unsigned int*)data;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* If we have no remote address information bail out now */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn -1;\n\t}\n\n\t/* Convert given digit into what we want to transmit */\n\tif ((digit <= '9') && (digit >= '0')) {\n\t\tdigit -= '0';\n\t} else if (digit == '*') {\n\t\tdigit = 10;\n\t} else if (digit == '#') {\n\t\tdigit = 11;\n\t} else if ((digit >= 'A') && (digit <= 'D')) {\n\t\tdigit = digit - 'A' + 12;\n\t} else if ((digit >= 'a') && (digit <= 'd')) {\n\t\tdigit = digit - 'a' + 12;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Don't know how to represent '%c'\\n\", digit);\n\t\treturn -1;\n\t}\n\n\t/* Grab the payload that they expect the RFC2833 packet to be received in */\n\tpayload = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance), 0, NULL, AST_RTP_DTMF);\n\n\trtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));\n\trtp->send_duration = 160;\n\trtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;\n\trtp->lastdigitts = rtp->lastts + rtp->send_duration;\n\n\t/* Create the actual packet that we will be sending */\n\trtpheader[0] = htonl((2 << 30) | (1 << 23) | (payload << 16) | (rtp->seqno));\n\trtpheader[1] = htonl(rtp->lastdigitts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\n\t/* Actually send the packet */\n\tfor (i = 0; i < 2; i++) {\n\t\tint ice;\n\n\t\trtpheader[3] = htonl((digit << 24) | (0xa << 16) | (rtp->send_duration));\n\t\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 4, 0, &remote_address, &ice);\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_ERROR, \"RTP Transmission error to %s: %s\\n\",\n\t\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\tif (rtp_debug_test_addr(&remote_address)) {\n\t\t\tast_verbose(\"Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t\t    payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t\t}\n\t\trtp->seqno++;\n\t\trtp->send_duration += 160;\n\t\trtpheader[0] = htonl((2 << 30) | (payload << 16) | (rtp->seqno));\n\t}\n\n\t/* Record that we are in the process of sending a digit and information needed to continue doing so */\n\trtp->sending_digit = 1;\n\trtp->send_digit = digit;\n\trtp->send_payload = payload;\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_continuation(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint hdrlen = 12, res = 0;\n\tchar data[256];\n\tunsigned int *rtpheader = (unsigned int*)data;\n\tint ice;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* Make sure we know where the other side is so we can send them the packet */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn -1;\n\t}\n\n\t/* Actually create the packet we will be sending */\n\trtpheader[0] = htonl((2 << 30) | (rtp->send_payload << 16) | (rtp->seqno));\n\trtpheader[1] = htonl(rtp->lastdigitts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\trtpheader[3] = htonl((rtp->send_digit << 24) | (0xa << 16) | (rtp->send_duration));\n\n\t/* Boom, send it on out */\n\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 4, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTP Transmission error to %s: %s\\n\",\n\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\tstrerror(errno));\n\t}\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t    rtp->send_payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t}\n\n\t/* And now we increment some values for the next time we swing by */\n\trtp->seqno++;\n\trtp->send_duration += 160;\n\trtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_end_with_duration(struct ast_rtp_instance *instance, char digit, unsigned int duration)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint hdrlen = 12, res = -1, i = 0;\n\tchar data[256];\n\tunsigned int *rtpheader = (unsigned int*)data;\n\tunsigned int measured_samples;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* Make sure we know where the remote side is so we can send them the packet we construct */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* Convert the given digit to the one we are going to send */\n\tif ((digit <= '9') && (digit >= '0')) {\n\t\tdigit -= '0';\n\t} else if (digit == '*') {\n\t\tdigit = 10;\n\t} else if (digit == '#') {\n\t\tdigit = 11;\n\t} else if ((digit >= 'A') && (digit <= 'D')) {\n\t\tdigit = digit - 'A' + 12;\n\t} else if ((digit >= 'a') && (digit <= 'd')) {\n\t\tdigit = digit - 'a' + 12;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Don't know how to represent '%c'\\n\", digit);\n\t\tgoto cleanup;\n\t}\n\n\trtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));\n\n\tif (duration > 0 && (measured_samples = duration * ast_rtp_get_rate(rtp->f.subclass.format) / 1000) > rtp->send_duration) {\n\t\tast_debug_rtp(2, \"(%p) RTP adjusting final end duration from %d to %u\\n\",\n\t\t\tinstance, rtp->send_duration, measured_samples);\n\t\trtp->send_duration = measured_samples;\n\t}\n\n\t/* Construct the packet we are going to send */\n\trtpheader[1] = htonl(rtp->lastdigitts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\trtpheader[3] = htonl((digit << 24) | (0xa << 16) | (rtp->send_duration));\n\trtpheader[3] |= htonl((1 << 23));\n\n\t/* Send it 3 times, that's the magical number */\n\tfor (i = 0; i < 3; i++) {\n\t\tint ice;\n\n\t\trtpheader[0] = htonl((2 << 30) | (rtp->send_payload << 16) | (rtp->seqno));\n\n\t\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 4, 0, &remote_address, &ice);\n\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_ERROR, \"RTP Transmission error to %s: %s\\n\",\n\t\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\t\tstrerror(errno));\n\t\t}\n\n\t\tif (rtp_debug_test_addr(&remote_address)) {\n\t\t\tast_verbose(\"Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t\t    rtp->send_payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t\t}\n\n\t\trtp->seqno++;\n\t}\n\tres = 0;\n\n\t/* Oh and we can't forget to turn off the stuff that says we are sending DTMF */\n\trtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;\n\n\t/* Reset the smoother as the delivery time stored in it is now out of date */\n\tif (rtp->smoother) {\n\t\tast_smoother_free(rtp->smoother);\n\t\trtp->smoother = NULL;\n\t}\ncleanup:\n\trtp->sending_digit = 0;\n\trtp->send_digit = 0;\n\n\t/* Re-Learn expected seqno */\n\trtp->expectedseqno = -1;\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_end(struct ast_rtp_instance *instance, char digit)\n{\n\treturn ast_rtp_dtmf_end_with_duration(instance, digit, 0);\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_update_source(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* We simply set this bit so that the next packet sent will have the marker bit turned on */\n\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT);\n\tast_debug_rtp(3, \"(%p) RTP setting the marker bit due to a source update\\n\", instance);\n\n\treturn;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_change_source(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_srtp *srtp = ast_rtp_instance_get_srtp(instance, 0);\n\tstruct ast_srtp *rtcp_srtp = ast_rtp_instance_get_srtp(instance, 1);\n\tunsigned int ssrc = ast_random();\n\n\tif (rtp->lastts) {\n\t\t/* We simply set this bit so that the next packet sent will have the marker bit turned on */\n\t\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT);\n\t}\n\n\tast_debug_rtp(3, \"(%p) RTP changing ssrc from %u to %u due to a source change\\n\",\n\t\tinstance, rtp->ssrc, ssrc);\n\n\tif (srtp) {\n\t\tast_debug_rtp(3, \"(%p) RTP changing ssrc for SRTP from %u to %u\\n\",\n\t\t\tinstance, rtp->ssrc, ssrc);\n\t\tres_srtp->change_source(srtp, rtp->ssrc, ssrc);\n\t\tif (rtcp_srtp != srtp) {\n\t\t\tres_srtp->change_source(rtcp_srtp, rtp->ssrc, ssrc);\n\t\t}\n\t}\n\n\trtp->ssrc = ssrc;\n\n\t/* Since the source is changing, we don't know what sequence number to expect next */\n\trtp->expectedrxseqno = -1;\n\n\treturn;\n}\n\nstatic void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw)\n{\n\tunsigned int sec, usec, frac;\n\tsec = tv.tv_sec + 2208988800u; /* Sec between 1900 and 1970 */\n\tusec = tv.tv_usec;\n\t/*\n\t * Convert usec to 0.32 bit fixed point without overflow.\n\t *\n\t * = usec * 2^32 / 10^6\n\t * = usec * 2^32 / (2^6 * 5^6)\n\t * = usec * 2^26 / 5^6\n\t *\n\t * The usec value needs 20 bits to represent 999999 usec.  So\n\t * splitting the 2^26 to get the most precision using 32 bit\n\t * values gives:\n\t *\n\t * = ((usec * 2^12) / 5^6) * 2^14\n\t *\n\t * Splitting the division into two stages preserves all the\n\t * available significant bits of usec over doing the division\n\t * all at once.\n\t *\n\t * = ((((usec * 2^12) / 5^3) * 2^7) / 5^3) * 2^7\n\t */\n\tfrac = ((((usec << 12) / 125) << 7) / 125) << 7;\n\t*msw = sec;\n\t*lsw = frac;\n}\n\nstatic void ntp2timeval(unsigned int msw, unsigned int lsw, struct timeval *tv)\n{\n\ttv->tv_sec = msw - 2208988800u;\n\t/* Reverse the sequence in timeval2ntp() */\n\ttv->tv_usec = ((((lsw >> 7) * 125) >> 7) * 125) >> 12;\n}\n\nstatic void calculate_lost_packet_statistics(struct ast_rtp *rtp,\n\t\tunsigned int *lost_packets,\n\t\tint *fraction_lost)\n{\n\tunsigned int extended_seq_no;\n\tunsigned int expected_packets;\n\tunsigned int expected_interval;\n\tunsigned int received_interval;\n\tint lost_interval;\n\n\t/* Compute statistics */\n\textended_seq_no = rtp->cycles + rtp->lastrxseqno;\n\texpected_packets = extended_seq_no - rtp->seedrxseqno + 1;\n\tif (rtp->rxcount > expected_packets) {\n\t\texpected_packets += rtp->rxcount - expected_packets;\n\t}\n\t*lost_packets = expected_packets - rtp->rxcount;\n\texpected_interval = expected_packets - rtp->rtcp->expected_prior;\n\treceived_interval = rtp->rxcount - rtp->rtcp->received_prior;\n\tif (received_interval > expected_interval) {\n\t\t/* If we receive some late packets it is possible for the packets\n\t\t * we received in this interval to exceed the number we expected.\n\t\t * We update the expected so that the packet loss calculations\n\t\t * show that no packets are lost.\n\t\t */\n\t\texpected_interval = received_interval;\n\t}\n\tlost_interval = expected_interval - received_interval;\n\tif (expected_interval == 0 || lost_interval <= 0) {\n\t\t*fraction_lost = 0;\n\t} else {\n\t\t*fraction_lost = (lost_interval << 8) / expected_interval;\n\t}\n\n\t/* Update RTCP statistics */\n\trtp->rtcp->received_prior = rtp->rxcount;\n\trtp->rtcp->expected_prior = expected_packets;\n\n\t/*\n\t * While rxlost represents the number of packets lost since the last report was sent, for\n\t * the calculations below it should be thought of as a single sample. Thus min/max are the\n\t * lowest/highest sample value seen, and the mean is the average number of packets lost\n\t * between each report. As such rxlost_count only needs to be incremented per report.\n\t */\n\tif (lost_interval <= 0) {\n\t\trtp->rtcp->rxlost = 0;\n\t} else {\n\t\trtp->rtcp->rxlost = lost_interval;\n\t}\n\tif (rtp->rtcp->rxlost_count == 0) {\n\t\trtp->rtcp->minrxlost = rtp->rtcp->rxlost;\n\t}\n\tif (lost_interval && lost_interval < rtp->rtcp->minrxlost) {\n\t\trtp->rtcp->minrxlost = rtp->rtcp->rxlost;\n\t}\n\tif (lost_interval > rtp->rtcp->maxrxlost) {\n\t\trtp->rtcp->maxrxlost = rtp->rtcp->rxlost;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rtcp->rxlost, &rtp->rtcp->normdev_rxlost,\n\t\t&rtp->rtcp->stdev_rxlost, &rtp->rtcp->rxlost_count);\n}\n\nstatic int ast_rtcp_generate_report(struct ast_rtp_instance *instance, unsigned char *rtcpheader,\n\t\tstruct ast_rtp_rtcp_report *rtcp_report, int *sr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint len = 0;\n\tstruct timeval now;\n\tunsigned int now_lsw;\n\tunsigned int now_msw;\n\tunsigned int lost_packets;\n\tint fraction_lost;\n\tstruct timeval dlsr = { 0, };\n\tstruct ast_rtp_rtcp_report_block *report_block = NULL;\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) { /* This'll stop rtcp for this rtp session */\n\t\t/* RTCP was stopped. */\n\t\treturn 0;\n\t}\n\n\tif (!rtcp_report) {\n\t\treturn 1;\n\t}\n\n\t*sr = rtp->txcount > rtp->rtcp->lastsrtxcount ? 1 : 0;\n\n\t/* Compute statistics */\n\tcalculate_lost_packet_statistics(rtp, &lost_packets, &fraction_lost);\n\t/*\n\t * update_local_mes_stats must be called AFTER\n\t * calculate_lost_packet_statistics\n\t */\n\tupdate_local_mes_stats(rtp);\n\n\tgettimeofday(&now, NULL);\n\trtcp_report->reception_report_count = rtp->themssrc_valid ? 1 : 0;\n\trtcp_report->ssrc = rtp->ssrc;\n\trtcp_report->type = *sr ? RTCP_PT_SR : RTCP_PT_RR;\n\tif (*sr) {\n\t\trtcp_report->sender_information.ntp_timestamp = now;\n\t\trtcp_report->sender_information.rtp_timestamp = rtp->lastts;\n\t\trtcp_report->sender_information.packet_count = rtp->txcount;\n\t\trtcp_report->sender_information.octet_count = rtp->txoctetcount;\n\t}\n\n\tif (rtp->themssrc_valid) {\n\t\treport_block = ast_calloc(1, sizeof(*report_block));\n\t\tif (!report_block) {\n\t\t\treturn 1;\n\t\t}\n\n\t\trtcp_report->report_block[0] = report_block;\n\t\treport_block->source_ssrc = rtp->themssrc;\n\t\treport_block->lost_count.fraction = (fraction_lost & 0xff);\n\t\treport_block->lost_count.packets = (lost_packets & 0xffffff);\n\t\treport_block->highest_seq_no = (rtp->cycles | (rtp->lastrxseqno & 0xffff));\n\t\treport_block->ia_jitter = (unsigned int)rtp->rxjitter_samples;\n\t\treport_block->lsr = rtp->rtcp->themrxlsr;\n\t\t/* If we haven't received an SR report, DLSR should be 0 */\n\t\tif (!ast_tvzero(rtp->rtcp->rxlsr)) {\n\t\t\ttimersub(&now, &rtp->rtcp->rxlsr, &dlsr);\n\t\t\treport_block->dlsr = (((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000;\n\t\t}\n\t}\n\ttimeval2ntp(rtcp_report->sender_information.ntp_timestamp, &now_msw, &now_lsw);\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtcp_report->ssrc)); /* Our SSRC */\n\tlen += 8;\n\tif (*sr) {\n\t\tput_unaligned_uint32(rtcpheader + len, htonl(now_msw)); /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970 */\n\t\tput_unaligned_uint32(rtcpheader + len + 4, htonl(now_lsw)); /* now, LSW */\n\t\tput_unaligned_uint32(rtcpheader + len + 8, htonl(rtcp_report->sender_information.rtp_timestamp));\n\t\tput_unaligned_uint32(rtcpheader + len + 12, htonl(rtcp_report->sender_information.packet_count));\n\t\tput_unaligned_uint32(rtcpheader + len + 16, htonl(rtcp_report->sender_information.octet_count));\n\t\tlen += 20;\n\t}\n\tif (report_block) {\n\t\tput_unaligned_uint32(rtcpheader + len, htonl(report_block->source_ssrc)); /* Their SSRC */\n\t\tput_unaligned_uint32(rtcpheader + len + 4, htonl((report_block->lost_count.fraction << 24) | report_block->lost_count.packets));\n\t\tput_unaligned_uint32(rtcpheader + len + 8, htonl(report_block->highest_seq_no));\n\t\tput_unaligned_uint32(rtcpheader + len + 12, htonl(report_block->ia_jitter));\n\t\tput_unaligned_uint32(rtcpheader + len + 16, htonl(report_block->lsr));\n\t\tput_unaligned_uint32(rtcpheader + len + 20, htonl(report_block->dlsr));\n\t\tlen += 24;\n\t}\n\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (rtcp_report->reception_report_count << 24)\n\t\t\t\t| ((*sr ? RTCP_PT_SR : RTCP_PT_RR) << 16) | ((len/4)-1)));\n\n\treturn len;\n}\n\nstatic int ast_rtcp_calculate_sr_rr_statistics(struct ast_rtp_instance *instance,\n\t\tstruct ast_rtp_rtcp_report *rtcp_report, struct ast_sockaddr remote_address, int ice, int sr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_rtcp_report_block *report_block = NULL;\n\tRAII_VAR(struct ast_json *, message_blob, NULL, ast_json_unref);\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) {\n\t\treturn 0;\n\t}\n\n\tif (!rtcp_report) {\n\t\treturn -1;\n\t}\n\n\treport_block = rtcp_report->report_block[0];\n\n\tif (sr) {\n\t\trtp->rtcp->txlsr = rtcp_report->sender_information.ntp_timestamp;\n\t\trtp->rtcp->sr_count++;\n\t\trtp->rtcp->lastsrtxcount = rtp->txcount;\n\t} else {\n\t\trtp->rtcp->rr_count++;\n\t}\n\n\tif (rtcp_debug_test_addr(&rtp->rtcp->them)) {\n\t\tast_verbose(\"* Sent RTCP %s to %s%s\\n\", sr ? \"SR\" : \"RR\",\n\t\t\t\tast_sockaddr_stringify(&remote_address), ice ? \" (via ICE)\" : \"\");\n\t\tast_verbose(\"  Our SSRC: %u\\n\", rtcp_report->ssrc);\n\t\tif (sr) {\n\t\t\tast_verbose(\"  Sent(NTP): %u.%06u\\n\",\n\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,\n\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);\n\t\t\tast_verbose(\"  Sent(RTP): %u\\n\", rtcp_report->sender_information.rtp_timestamp);\n\t\t\tast_verbose(\"  Sent packets: %u\\n\", rtcp_report->sender_information.packet_count);\n\t\t\tast_verbose(\"  Sent octets: %u\\n\", rtcp_report->sender_information.octet_count);\n\t\t}\n\t\tif (report_block) {\n\t\t\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\t\t\tast_verbose(\"  Report block:\\n\");\n\t\t\tast_verbose(\"    Their SSRC: %u\\n\", report_block->source_ssrc);\n\t\t\tast_verbose(\"    Fraction lost: %d\\n\", report_block->lost_count.fraction);\n\t\t\tast_verbose(\"    Cumulative loss: %u\\n\", report_block->lost_count.packets);\n\t\t\tast_verbose(\"    Highest seq no: %u\\n\", report_block->highest_seq_no);\n\t\t\tast_verbose(\"    IA jitter (samp): %u\\n\", report_block->ia_jitter);\n\t\t\tast_verbose(\"    IA jitter (secs): %.6f\\n\", ast_samp2sec(report_block->ia_jitter, rate));\n\t\t\tast_verbose(\"    Their last SR: %u\\n\", report_block->lsr);\n\t\t\tast_verbose(\"    DLSR: %4.4f (sec)\\n\\n\", (double)(report_block->dlsr / 65536.0));\n\t\t}\n\t}\n\n\tmessage_blob = ast_json_pack(\"{s: s, s: s, s: f}\",\n\t\t\t\"to\", ast_sockaddr_stringify(&remote_address),\n\t\t\t\"from\", rtp->rtcp->local_addr_str,\n\t\t\t\"mes\", rtp->rxmes);\n\n\tast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_sent_type(),\n\t\t\trtcp_report, message_blob);\n\n\treturn 1;\n}\n\nstatic int ast_rtcp_generate_sdes(struct ast_rtp_instance *instance, unsigned char *rtcpheader,\n\t\tstruct ast_rtp_rtcp_report *rtcp_report)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint len = 0;\n\tuint16_t sdes_packet_len_bytes;\n\tuint16_t sdes_packet_len_rounded;\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) {\n\t\treturn 0;\n\t}\n\n\tif (!rtcp_report) {\n\t\treturn -1;\n\t}\n\n\tsdes_packet_len_bytes =\n\t\t4 + /* RTCP Header */\n\t\t4 + /* SSRC */\n\t\t1 + /* Type (CNAME) */\n\t\t1 + /* Text Length */\n\t\tAST_UUID_STR_LEN /* Text and NULL terminator */\n\t\t;\n\n\t/* Round to 32 bit boundary */\n\tsdes_packet_len_rounded = (sdes_packet_len_bytes + 3) & ~0x3;\n\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | ((sdes_packet_len_rounded / 4) - 1)));\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtcp_report->ssrc));\n\trtcpheader[8] = 0x01; /* CNAME */\n\trtcpheader[9] = AST_UUID_STR_LEN - 1; /* Number of bytes of text */\n\tmemcpy(rtcpheader + 10, rtp->cname, AST_UUID_STR_LEN);\n\tlen += 10 + AST_UUID_STR_LEN;\n\n\t/* Padding - Note that we don't set the padded bit on the packet. From\n\t * RFC 3550 Section 6.5:\n\t *\n\t *   No length octet follows the null item type octet, but additional null\n\t *   octets MUST be included if needd to pad until the next 32-bit\n\t *   boundary. Note that this padding is separate from that indicated by\n\t *   the P bit in the RTCP header.\n\t *\n\t * These bytes will already be zeroed out during array initialization.\n\t */\n\tlen += (sdes_packet_len_rounded - sdes_packet_len_bytes);\n\n\treturn len;\n}\n\n/* Lock instance before calling this if it isn't already\n *\n * If successful, the overall packet length is returned\n * If not, then 0 is returned\n */\nstatic int ast_rtcp_generate_compound_prefix(struct ast_rtp_instance *instance, unsigned char *rtcpheader,\n\tstruct ast_rtp_rtcp_report *report, int *sr)\n{\n\tint packet_len = 0;\n\tint res;\n\n\t/* Every RTCP packet needs to be sent out with a SR/RR and SDES prefixing it.\n\t * At the end of this function, rtcpheader should contain both of those packets,\n\t * and will return the length of the overall packet. This can be used to determine\n\t * where further packets can be inserted in the compound packet.\n\t */\n\tres = ast_rtcp_generate_report(instance, rtcpheader, report, sr);\n\n\tif (res == 0 || res == 1) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP failed to generate %s report!\\n\", instance, sr ? \"SR\" : \"RR\");\n\t\treturn 0;\n\t}\n\n\tpacket_len += res;\n\n\tres = ast_rtcp_generate_sdes(instance, rtcpheader + packet_len, report);\n\n\tif (res == 0 || res == 1) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP failed to generate SDES!\\n\", instance);\n\t\treturn 0;\n\t}\n\n\treturn packet_len + res;\n}\n\nstatic int ast_rtcp_generate_nack(struct ast_rtp_instance *instance, unsigned char *rtcpheader)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint packet_len;\n\tint blp_index = -1;\n\tint current_seqno;\n\tunsigned int fci = 0;\n\tsize_t remaining_missing_seqno;\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) {\n\t\treturn 0;\n\t}\n\n\tcurrent_seqno = rtp->expectedrxseqno;\n\tremaining_missing_seqno = AST_VECTOR_SIZE(&rtp->missing_seqno);\n\tpacket_len = 12; /* The header length is 12 (version line, packet source SSRC, media source SSRC) */\n\n\t/* If there are no missing sequence numbers then don't bother sending a NACK needlessly */\n\tif (!remaining_missing_seqno) {\n\t\treturn 0;\n\t}\n\n\t/* This iterates through the possible forward sequence numbers seeing which ones we\n\t * have no packet for, adding it to the NACK until we are out of missing packets.\n\t */\n\twhile (remaining_missing_seqno) {\n\t\tint *missing_seqno;\n\n\t\t/* On the first entry to this loop blp_index will be -1, so this will become 0\n\t\t * and the sequence number will be placed into the packet as the PID.\n\t\t */\n\t\tblp_index++;\n\n\t\tmissing_seqno = AST_VECTOR_GET_CMP(&rtp->missing_seqno, current_seqno,\n\t\t\t\tfind_by_value);\n\t\tif (missing_seqno) {\n\t\t\t/* We hit the max blp size, reset */\n\t\t\tif (blp_index >= 17) {\n\t\t\t\tput_unaligned_uint32(rtcpheader + packet_len, htonl(fci));\n\t\t\t\tfci = 0;\n\t\t\t\tblp_index = 0;\n\t\t\t\tpacket_len += 4;\n\t\t\t}\n\n\t\t\tif (blp_index == 0) {\n\t\t\t\tfci |= (current_seqno << 16);\n\t\t\t} else {\n\t\t\t\tfci |= (1 << (blp_index - 1));\n\t\t\t}\n\n\t\t\t/* Since we've used a missing sequence number, we're down one */\n\t\t\tremaining_missing_seqno--;\n\t\t}\n\n\t\t/* Handle cycling of the sequence number */\n\t\tcurrent_seqno++;\n\t\tif (current_seqno == SEQNO_CYCLE_OVER) {\n\t\t\tcurrent_seqno = 0;\n\t\t}\n\t}\n\n\tput_unaligned_uint32(rtcpheader + packet_len, htonl(fci));\n\tpacket_len += 4;\n\n\t/* Length MUST be 2+n, where n is the number of NACKs. Same as length in words minus 1 */\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (AST_RTP_RTCP_FMT_NACK << 24)\n\t\t\t\t| (AST_RTP_RTCP_RTPFB << 16) | ((packet_len / 4) - 1)));\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + 8, htonl(rtp->themssrc));\n\n\treturn packet_len;\n}\n\n/*!\n * \\brief Write a RTCP packet to the far end\n *\n * \\note Decide if we are going to send an SR (with Reception Block) or RR\n * RR is sent if we have not sent any rtp packets in the previous interval\n *\n * Scheduler callback\n */\nstatic int ast_rtcp_write(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint res;\n\tint sr = 0;\n\tint packet_len = 0;\n\tint ice;\n\tstruct ast_sockaddr remote_address = { { 0, } };\n\tunsigned char *rtcpheader;\n\tunsigned char bdata[AST_UUID_STR_LEN + 128] = \"\"; /* More than enough */\n\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\n\tif (!rtp || !rtp->rtcp || rtp->rtcp->schedid == -1) {\n\t\tao2_ref(instance, -1);\n\t\treturn 0;\n\t}\n\n\tao2_lock(instance);\n\trtcpheader = bdata;\n\trtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);\n\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\tif (res == 0 || res == 1) {\n\t\tgoto cleanup;\n\t}\n\n\tpacket_len += res;\n\n\tif (rtp->bundled) {\n\t\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\t} else {\n\t\tast_sockaddr_copy(&remote_address, &rtp->rtcp->them);\n\t}\n\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP %s transmission error to %s, rtcp halted %s\\n\",\n\t\t\t\tsr ? \"SR\" : \"RR\",\n\t\t\t\tast_sockaddr_stringify(&rtp->rtcp->them),\n\t\t\t\tstrerror(errno));\n\t\tres = 0;\n\t} else {\n\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, remote_address, ice, sr);\n\t}\n\ncleanup:\n\tao2_unlock(instance);\n\n\tif (!res) {\n\t\t/*\n\t\t * Not being rescheduled.\n\t\t */\n\t\trtp->rtcp->schedid = -1;\n\t\tao2_ref(instance, -1);\n\t}\n\n\treturn res;\n}\n\nstatic void put_unaligned_time24(void *p, uint32_t time_msw, uint32_t time_lsw)\n{\n\tunsigned char *cp = p;\n\tuint32_t datum;\n\n\t/* Convert the time to 6.18 format */\n\tdatum = (time_msw << 18) & 0x00fc0000;\n\tdatum |= (time_lsw >> 14) & 0x0003ffff;\n\n\tcp[0] = datum >> 16;\n\tcp[1] = datum >> 8;\n\tcp[2] = datum;\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_raw_write(struct ast_rtp_instance *instance, struct ast_frame *frame, int codec)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint pred, mark = 0;\n\tunsigned int ms = calc_txstamp(rtp, &frame->delivery);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint rate = ast_rtp_get_rate(frame->subclass.format) / 1000;\n\tunsigned int seqno;\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif (ast_format_cmp(frame->subclass.format, ast_format_g722) == AST_FORMAT_CMP_EQUAL) {\n\t\tframe->samples /= 2;\n\t}\n\n\tif (rtp->sending_digit) {\n\t\treturn 0;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->send_report) {\n\t\ttest->send_report = 0;\n\t\tast_rtcp_write(instance);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (frame->frametype == AST_FRAME_VOICE) {\n\t\tpred = rtp->lastts + frame->samples;\n\n\t\t/* Re-calculate last TS */\n\t\trtp->lastts = rtp->lastts + ms * rate;\n\t\tif (ast_tvzero(frame->delivery)) {\n\t\t\t/* If this isn't an absolute delivery time, Check if it is close to our prediction,\n\t\t\t   and if so, go with our prediction */\n\t\t\tif (abs((int)rtp->lastts - pred) < MAX_TIMESTAMP_SKEW) {\n\t\t\t\trtp->lastts = pred;\n\t\t\t} else {\n\t\t\t\tast_debug_rtp(3, \"(%p) RTP audio difference is %d, ms is %u\\n\",\n\t\t\t\t\tinstance, abs((int)rtp->lastts - pred), ms);\n\t\t\t\tmark = 1;\n\t\t\t}\n\t\t}\n\t} else if (frame->frametype == AST_FRAME_VIDEO) {\n\t\tmark = frame->subclass.frame_ending;\n\t\tpred = rtp->lastovidtimestamp + frame->samples;\n\t\t/* Re-calculate last TS */\n\t\trtp->lastts = rtp->lastts + ms * 90;\n\t\t/* If it's close to our prediction, go for it */\n\t\tif (ast_tvzero(frame->delivery)) {\n\t\t\tif (abs((int)rtp->lastts - pred) < 7200) {\n\t\t\t\trtp->lastts = pred;\n\t\t\t\trtp->lastovidtimestamp += frame->samples;\n\t\t\t} else {\n\t\t\t\tast_debug_rtp(3, \"(%p) RTP video difference is %d, ms is %u (%u), pred/ts/samples %u/%d/%d\\n\",\n\t\t\t\t\tinstance, abs((int)rtp->lastts - pred), ms, ms * 90, rtp->lastts, pred, frame->samples);\n\t\t\t\trtp->lastovidtimestamp = rtp->lastts;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpred = rtp->lastotexttimestamp + frame->samples;\n\t\t/* Re-calculate last TS */\n\t\trtp->lastts = rtp->lastts + ms;\n\t\t/* If it's close to our prediction, go for it */\n\t\tif (ast_tvzero(frame->delivery)) {\n\t\t\tif (abs((int)rtp->lastts - pred) < 7200) {\n\t\t\t\trtp->lastts = pred;\n\t\t\t\trtp->lastotexttimestamp += frame->samples;\n\t\t\t} else {\n\t\t\t\tast_debug_rtp(3, \"(%p) RTP other difference is %d, ms is %u, pred/ts/samples %u/%d/%d\\n\",\n\t\t\t\t\tinstance, abs((int)rtp->lastts - pred), ms, rtp->lastts, pred, frame->samples);\n\t\t\t\trtp->lastotexttimestamp = rtp->lastts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If we have been explicitly told to set the marker bit then do so */\n\tif (ast_test_flag(rtp, FLAG_NEED_MARKER_BIT)) {\n\t\tmark = 1;\n\t\tast_clear_flag(rtp, FLAG_NEED_MARKER_BIT);\n\t}\n\n\t/* If the timestamp for non-digt packets has moved beyond the timestamp for digits, update the digit timestamp */\n\tif (rtp->lastts > rtp->lastdigitts) {\n\t\trtp->lastdigitts = rtp->lastts;\n\t}\n\n\t/* Assume that the sequence number we expect to use is what will be used until proven otherwise */\n\tseqno = rtp->seqno;\n\n\t/* If the frame contains sequence number information use it to influence our sequence number */\n\tif (ast_test_flag(frame, AST_FRFLAG_HAS_SEQUENCE_NUMBER)) {\n\t\tif (rtp->expectedseqno != -1) {\n\t\t\t/* Determine where the frame from the core is in relation to where we expected */\n\t\t\tint difference = frame->seqno - rtp->expectedseqno;\n\n\t\t\t/* If there is a substantial difference then we've either got packets really out\n\t\t\t * of order, or the source is RTP and it has cycled. If this happens we resync\n\t\t\t * the sequence number adjustments to this frame. If we also have packet loss\n\t\t\t * things won't be reflected correctly but it will sort itself out after a bit.\n\t\t\t */\n\t\t\tif (abs(difference) > 100) {\n\t\t\t\tdifference = 0;\n\t\t\t}\n\n\t\t\t/* Adjust the sequence number being used for this packet accordingly */\n\t\t\tseqno += difference;\n\n\t\t\tif (difference >= 0) {\n\t\t\t\t/* This frame is on time or in the future */\n\t\t\t\trtp->expectedseqno = frame->seqno + 1;\n\t\t\t\trtp->seqno += difference;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is the first frame with sequence number we've seen, so start keeping track */\n\t\t\trtp->expectedseqno = frame->seqno + 1;\n\t\t}\n\t} else {\n\t\trtp->expectedseqno = -1;\n\t}\n\n\tif (ast_test_flag(frame, AST_FRFLAG_HAS_TIMING_INFO)) {\n\t\trtp->lastts = frame->ts * rate;\n\t}\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* If we know the remote address construct a packet and send it out */\n\tif (!ast_sockaddr_isnull(&remote_address)) {\n\t\tint hdrlen = 12;\n\t\tint res;\n\t\tint ice;\n\t\tint ext = 0;\n\t\tint abs_send_time_id;\n\t\tint packet_len;\n\t\tunsigned char *rtpheader;\n\n\t\t/* If the abs-send-time extension has been negotiated determine how much space we need */\n\t\tabs_send_time_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_ABS_SEND_TIME);\n\t\tif (abs_send_time_id != -1) {\n\t\t\t/* 4 bytes for the shared information, 1 byte for identifier, 3 bytes for abs-send-time */\n\t\t\thdrlen += 8;\n\t\t\text = 1;\n\t\t}\n\n\t\tpacket_len = frame->datalen + hdrlen;\n\t\trtpheader = (unsigned char *)(frame->data.ptr - hdrlen);\n\n\t\tput_unaligned_uint32(rtpheader, htonl((2 << 30) | (ext << 28) | (codec << 16) | (seqno) | (mark << 23)));\n\t\tput_unaligned_uint32(rtpheader + 4, htonl(rtp->lastts));\n\t\tput_unaligned_uint32(rtpheader + 8, htonl(rtp->ssrc));\n\n\t\t/* We assume right now that we will only ever have the abs-send-time extension in the packet\n\t\t * which simplifies things a bit.\n\t\t */\n\t\tif (abs_send_time_id != -1) {\n\t\t\tunsigned int now_msw;\n\t\t\tunsigned int now_lsw;\n\n\t\t\t/* This happens before being placed into the retransmission buffer so that when we\n\t\t\t * retransmit we only have to update the timestamp, not everything else.\n\t\t\t */\n\t\t\tput_unaligned_uint32(rtpheader + 12, htonl((0xBEDE << 16) | 1));\n\t\t\trtpheader[16] = (abs_send_time_id << 4) | 2;\n\n\t\t\ttimeval2ntp(ast_tvnow(), &now_msw, &now_lsw);\n\t\t\tput_unaligned_time24(rtpheader + 17, now_msw, now_lsw);\n\t\t}\n\n\t\t/* If retransmissions are enabled, we need to store this packet for future use */\n\t\tif (rtp->send_buffer) {\n\t\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\n\t\t\tpayload = ast_malloc(sizeof(*payload) + packet_len);\n\t\t\tif (payload) {\n\t\t\t\tpayload->size = packet_len;\n\t\t\t\tmemcpy(payload->buf, rtpheader, packet_len);\n\t\t\t\tif (ast_data_buffer_put(rtp->send_buffer, rtp->seqno, payload) == -1) {\n\t\t\t\t\tast_free(payload);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres = rtp_sendto(instance, (void *)rtpheader, packet_len, 0, &remote_address, &ice);\n\t\tif (res < 0) {\n\t\t\tif (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT) || (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT) && (ast_test_flag(rtp, FLAG_NAT_ACTIVE) == FLAG_NAT_ACTIVE))) {\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP transmission error of packet %d to %s: %s\\n\",\n\t\t\t\t\t  instance, rtp->seqno,\n\t\t\t\t\t  ast_sockaddr_stringify(&remote_address),\n\t\t\t\t\t  strerror(errno));\n\t\t\t} else if (((ast_test_flag(rtp, FLAG_NAT_ACTIVE) == FLAG_NAT_INACTIVE) || ast_debug_rtp_packet_is_allowed) && !ast_test_flag(rtp, FLAG_NAT_INACTIVE_NOWARN)) {\n\t\t\t\t/* Only give this error message once if we are not RTP debugging */\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed)\n\t\t\t\t\tast_debug(0, \"(%p) RTP NAT: Can't write RTP to private address %s, waiting for other end to send audio...\\n\",\n\t\t\t\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\t\t\tast_set_flag(rtp, FLAG_NAT_INACTIVE_NOWARN);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp->rtcp && rtp->rtcp->schedid < 0) {\n\t\t\t\tast_debug_rtcp(2, \"(%s) RTCP starting transmission in %u ms\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance), ast_rtcp_calc_interval(rtp));\n\t\t\t\tao2_ref(instance, +1);\n\t\t\t\trtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);\n\t\t\t\tif (rtp->rtcp->schedid < 0) {\n\t\t\t\t\tao2_ref(instance, -1);\n\t\t\t\t\tast_log(LOG_WARNING, \"scheduling RTCP transmission failed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_debug_test_addr(&remote_address)) {\n\t\t\tast_verbose(\"Sent RTP packet to      %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t\t    codec, rtp->seqno, rtp->lastts, res - hdrlen);\n\t\t}\n\t}\n\n\t/* If the sequence number that has been used doesn't match what we expected then this is an out of\n\t * order late packet, so we don't need to increment as we haven't yet gotten the expected frame from\n\t * the core.\n\t */\n\tif (seqno == rtp->seqno) {\n\t\trtp->seqno++;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ast_frame *red_t140_to_red(struct rtp_red *red)\n{\n\tunsigned char *data = red->t140red.data.ptr;\n\tint len = 0;\n\tint i;\n\n\t/* replace most aged generation */\n\tif (red->len[0]) {\n\t\tfor (i = 1; i < red->num_gen+1; i++)\n\t\t\tlen += red->len[i];\n\n\t\tmemmove(&data[red->hdrlen], &data[red->hdrlen+red->len[0]], len);\n\t}\n\n\t/* Store length of each generation and primary data length*/\n\tfor (i = 0; i < red->num_gen; i++)\n\t\tred->len[i] = red->len[i+1];\n\tred->len[i] = red->t140.datalen;\n\n\t/* write each generation length in red header */\n\tlen = red->hdrlen;\n\tfor (i = 0; i < red->num_gen; i++) {\n\t\tlen += data[i*4+3] = red->len[i];\n\t}\n\n\t/* add primary data to buffer */\n\tmemcpy(&data[len], red->t140.data.ptr, red->t140.datalen);\n\tred->t140red.datalen = len + red->t140.datalen;\n\n\t/* no primary data and no generations to send */\n\tif (len == red->hdrlen && !red->t140.datalen) {\n\t\treturn NULL;\n\t}\n\n\t/* reset t.140 buffer */\n\tred->t140.datalen = 0;\n\n\treturn &red->t140red;\n}\n\nstatic void rtp_write_rtcp_fir(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *remote_address)\n{\n\tunsigned char *rtcpheader;\n\tunsigned char bdata[1024];\n\tint packet_len = 0;\n\tint fir_len = 20;\n\tint ice;\n\tint res;\n\tint sr;\n\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them) || rtp->rtcp->schedid < 0) {\n\t\t/*\n\t\t * RTCP was stopped.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (!rtp->themssrc_valid) {\n\t\t/* We don't know their SSRC value so we don't know who to update. */\n\t\treturn;\n\t}\n\n\t/* Prepare RTCP FIR (PT=206, FMT=4) */\n\trtp->rtcp->firseq++;\n\tif(rtp->rtcp->firseq == 256) {\n\t\trtp->rtcp->firseq = 0;\n\t}\n\n\trtcpheader = bdata;\n\n\tao2_lock(instance);\n\trtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);\n\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\tif (res == 0 || res == 1) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tpacket_len += res;\n\n\tput_unaligned_uint32(rtcpheader + packet_len + 0, htonl((2 << 30) | (4 << 24) | (RTCP_PT_PSFB << 16) | ((fir_len/4)-1)));\n\tput_unaligned_uint32(rtcpheader + packet_len + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + packet_len + 8, htonl(rtp->themssrc));\n\tput_unaligned_uint32(rtcpheader + packet_len + 12, htonl(rtp->themssrc)); /* FCI: SSRC */\n\tput_unaligned_uint32(rtcpheader + packet_len + 16, htonl(rtp->rtcp->firseq << 24)); /* FCI: Sequence number */\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len + fir_len, 0, rtp->bundled ? remote_address : &rtp->rtcp->them, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP FIR transmission error: %s\\n\", strerror(errno));\n\t} else {\n\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, rtp->bundled ? *remote_address : rtp->rtcp->them, ice, sr);\n\t}\n\n\tao2_unlock(instance);\n}\n\nstatic void rtp_write_rtcp_psfb(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_frame *frame, struct ast_sockaddr *remote_address)\n{\n\tstruct ast_rtp_rtcp_feedback *feedback = frame->data.ptr;\n\tunsigned char *rtcpheader;\n\tunsigned char bdata[1024];\n\tint remb_len = 24;\n\tint ice;\n\tint res;\n\tint sr = 0;\n\tint packet_len = 0;\n\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\n\tif (feedback->fmt != AST_RTP_RTCP_FMT_REMB) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP provided feedback frame of format %d to write, but only REMB is supported\\n\",\n\t\t\tinstance, feedback->fmt);\n\t\treturn;\n\t}\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn;\n\t}\n\n\t/* If REMB support is not enabled don't send this RTCP packet */\n\tif (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_REMB)) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP provided feedback REMB report to write, but REMB support not enabled\\n\",\n\t\t\tinstance);\n\t\treturn;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them) || rtp->rtcp->schedid < 0) {\n\t\t/*\n\t\t * RTCP was stopped.\n\t\t */\n\t\treturn;\n\t}\n\n\trtcpheader = bdata;\n\n\tao2_lock(instance);\n\trtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);\n\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\tif (res == 0 || res == 1) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tpacket_len += res;\n\n\tput_unaligned_uint32(rtcpheader + packet_len + 0, htonl((2 << 30) | (AST_RTP_RTCP_FMT_REMB << 24) | (RTCP_PT_PSFB << 16) | ((remb_len/4)-1)));\n\tput_unaligned_uint32(rtcpheader + packet_len + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + packet_len + 8, htonl(0)); /* Per the draft, this should always be 0 */\n\tput_unaligned_uint32(rtcpheader + packet_len + 12, htonl(('R' << 24) | ('E' << 16) | ('M' << 8) | ('B'))); /* Unique identifier 'R' 'E' 'M' 'B' */\n\tput_unaligned_uint32(rtcpheader + packet_len + 16, htonl((1 << 24) | (feedback->remb.br_exp << 18) | (feedback->remb.br_mantissa))); /* Number of SSRCs / BR Exp / BR Mantissa */\n\tput_unaligned_uint32(rtcpheader + packet_len + 20, htonl(rtp->ssrc)); /* The SSRC this feedback message applies to */\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len + remb_len, 0, rtp->bundled ? remote_address : &rtp->rtcp->them, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP PSFB transmission error: %s\\n\", strerror(errno));\n\t} else {\n\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, rtp->bundled ? *remote_address : rtp->rtcp->them, ice, sr);\n\t}\n\n\tao2_unlock(instance);\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tstruct ast_format *format;\n\tint codec;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* If we don't actually know the remote address don't even bother doing anything */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\tast_debug_rtp(1, \"(%p) RTP no remote address on instance, so dropping frame\\n\", instance);\n\t\treturn 0;\n\t}\n\n\t/* VP8: is this a request to send a RTCP FIR? */\n\tif (frame->frametype == AST_FRAME_CONTROL && frame->subclass.integer == AST_CONTROL_VIDUPDATE) {\n\t\trtp_write_rtcp_fir(instance, rtp, &remote_address);\n\t\treturn 0;\n\t} else if (frame->frametype == AST_FRAME_RTCP) {\n\t\tif (frame->subclass.integer == AST_RTP_RTCP_PSFB) {\n\t\t\trtp_write_rtcp_psfb(instance, rtp, frame, &remote_address);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* If there is no data length we can't very well send the packet */\n\tif (!frame->datalen) {\n\t\tast_debug_rtp(1, \"(%p) RTP received frame with no data for instance, so dropping frame\\n\", instance);\n\t\treturn 0;\n\t}\n\n\t/* If the packet is not one our RTP stack supports bail out */\n\tif (frame->frametype != AST_FRAME_VOICE && frame->frametype != AST_FRAME_VIDEO && frame->frametype != AST_FRAME_TEXT) {\n\t\tast_log(LOG_WARNING, \"RTP can only send voice, video, and text\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rtp->red) {\n\t\t/* return 0; */\n\t\t/* no primary data or generations to send */\n\t\tif ((frame = red_t140_to_red(rtp->red)) == NULL)\n\t\t\treturn 0;\n\t}\n\n\t/* Grab the subclass and look up the payload we are going to use */\n\tcodec = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance),\n\t\t1, frame->subclass.format, 0);\n\tif (codec < 0) {\n\t\tast_log(LOG_WARNING, \"Don't know how to send format %s packets with RTP\\n\",\n\t\t\tast_format_get_name(frame->subclass.format));\n\t\treturn -1;\n\t}\n\n\t/* Note that we do not increase the ref count here as this pointer\n\t * will not be held by any thing explicitly. The format variable is\n\t * merely a convenience reference to frame->subclass.format */\n\tformat = frame->subclass.format;\n\tif (ast_format_cmp(rtp->lasttxformat, format) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t/* Oh dear, if the format changed we will have to set up a new smoother */\n\t\tast_debug_rtp(1, \"(%s) RTP ooh, format changed from %s to %s\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\tast_format_get_name(rtp->lasttxformat),\n\t\t\tast_format_get_name(frame->subclass.format));\n\t\tao2_replace(rtp->lasttxformat, format);\n\t\tif (rtp->smoother) {\n\t\t\tast_smoother_free(rtp->smoother);\n\t\t\trtp->smoother = NULL;\n\t\t}\n\t}\n\n\t/* If no smoother is present see if we have to set one up */\n\tif (!rtp->smoother && ast_format_can_be_smoothed(format)) {\n\t\tunsigned int smoother_flags = ast_format_get_smoother_flags(format);\n\t\tunsigned int framing_ms = ast_rtp_codecs_get_framing(ast_rtp_instance_get_codecs(instance));\n\n\t\tif (!framing_ms && (smoother_flags & AST_SMOOTHER_FLAG_FORCED)) {\n\t\t\tframing_ms = ast_format_get_default_ms(format);\n\t\t}\n\n\t\tif (framing_ms) {\n\t\t\trtp->smoother = ast_smoother_new((framing_ms * ast_format_get_minimum_bytes(format)) / ast_format_get_minimum_ms(format));\n\t\t\tif (!rtp->smoother) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create smoother: format %s ms: %u len: %u\\n\",\n\t\t\t\t\tast_format_get_name(format), framing_ms, ast_format_get_minimum_bytes(format));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tast_smoother_set_flags(rtp->smoother, smoother_flags);\n\t\t}\n\t}\n\n\t/* Feed audio frames into the actual function that will create a frame and send it */\n\tif (rtp->smoother) {\n\t\tstruct ast_frame *f;\n\n\t\tif (ast_smoother_test_flag(rtp->smoother, AST_SMOOTHER_FLAG_BE)) {\n\t\t\tast_smoother_feed_be(rtp->smoother, frame);\n\t\t} else {\n\t\t\tast_smoother_feed(rtp->smoother, frame);\n\t\t}\n\n\t\twhile ((f = ast_smoother_read(rtp->smoother)) && (f->data.ptr)) {\n\t\t\t\trtp_raw_write(instance, f, codec);\n\t\t}\n\t} else {\n\t\tint hdrlen = 12;\n\t\tstruct ast_frame *f = NULL;\n\n\t\tif (frame->offset < hdrlen) {\n\t\t\tf = ast_frdup(frame);\n\t\t} else {\n\t\t\tf = frame;\n\t\t}\n\t\tif (f->data.ptr) {\n\t\t\trtp_raw_write(instance, f, codec);\n\t\t}\n\t\tif (f != frame) {\n\t\t\tast_frfree(f);\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic void calc_rxstamp_and_jitter(struct timeval *tv,\n\tstruct ast_rtp *rtp, unsigned int rx_rtp_ts,\n\tint mark)\n{\n\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\n\tdouble jitter = 0.0;\n\tdouble prev_jitter = 0.0;\n\tstruct timeval now;\n\tstruct timeval tmp;\n\tdouble rxnow;\n\tdouble arrival_sec;\n\tunsigned int arrival;\n\tint transit;\n\tint d;\n\n\tgettimeofday(&now,NULL);\n\n\tif (rtp->rxcount == 1 || mark) {\n\t\trtp->rxstart = ast_tv2double(&now);\n\t\trtp->remote_seed_rx_rtp_ts = rx_rtp_ts;\n\n\t\t/*\n\t\t * \"tv\" is placed in the received frame's\n\t\t * \"delivered\" field and when this frame is\n\t\t * sent out again on the other side, it's\n\t\t * used to calculate the timestamp on the\n\t\t * outgoing RTP packets.\n\t\t *\n\t\t * NOTE: We need to do integer math here\n\t\t * because double math rounding issues can\n\t\t * generate incorrect timestamps.\n\t\t */\n\t\trtp->rxcore = now;\n\t\ttmp = ast_samp2tv(rx_rtp_ts, rate);\n\t\trtp->rxcore = ast_tvsub(rtp->rxcore, tmp);\n\t\trtp->rxcore.tv_usec -= rtp->rxcore.tv_usec % 100;\n\t\t*tv = ast_tvadd(rtp->rxcore, tmp);\n\n\t\tast_debug_rtcp(3, \"%s: \"\n\t\t\t\"Seed ts: %u current time: %f\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rx_rtp_ts\n\t\t\t, rtp->rxstart\n\t\t);\n\n\t\treturn;\n\t}\n\n\ttmp = ast_samp2tv(rx_rtp_ts, rate);\n\t/* See the comment about \"tv\" above. Even if\n\t * we don't use this received packet for jitter\n\t * calculations, we still need to set tv so the\n\t * timestamp will be correct when this packet is\n\t * sent out again.\n\t */\n\t*tv = ast_tvadd(rtp->rxcore, tmp);\n\n\t/*\n\t * The first few packets are generally unstable so let's\n\t * not use them in the calculations.\n\t */\n\tif (rtp->rxcount < RTP_IGNORE_FIRST_PACKETS_COUNT) {\n\t\tast_debug_rtcp(3, \"%s: Packet %d < %d.  Ignoring\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rtp->rxcount\n\t\t\t, RTP_IGNORE_FIRST_PACKETS_COUNT\n\t\t);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * First good packet. Capture the start time and timestamp\n\t * but don't actually use this packet for calculation.\n\t */\n\tif (rtp->rxcount == RTP_IGNORE_FIRST_PACKETS_COUNT) {\n\t\trtp->rxstart_stable = ast_tv2double(&now);\n\t\trtp->remote_seed_rx_rtp_ts_stable = rx_rtp_ts;\n\t\trtp->last_transit_time_samples = -rx_rtp_ts;\n\n\t\tast_debug_rtcp(3, \"%s: \"\n\t\t\t\"pkt: %5u Stable Seed ts: %u current time: %f\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rtp->rxcount\n\t\t\t, rx_rtp_ts\n\t\t\t, rtp->rxstart_stable\n\t\t);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If the current packet isn't in sequence, don't\n\t * use it in any calculations as remote_current_rx_rtp_ts\n\t * is not going to be correct.\n\t */\n\tif (rtp->lastrxseqno != rtp->prevrxseqno + 1) {\n\t\tast_debug_rtcp(3, \"%s: Current packet seq %d != last packet seq %d + 1.  Ignoring\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rtp->lastrxseqno\n\t\t\t, rtp->prevrxseqno\n\t\t);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * The following calculations are taken from\n\t * https://www.rfc-editor.org/rfc/rfc3550#appendix-A.8\n\t *\n\t * The received rtp timestamp is the random \"seed\"\n\t * timestamp chosen by the sender when they sent the\n\t * first packet, plus the number of samples since then.\n\t *\n\t * To get our arrival time in the same units, we\n\t * calculate the time difference in seconds between\n\t * when we received the first packet and when we\n\t * received this packet and convert that to samples.\n\t */\n\trxnow = ast_tv2double(&now);\n\tarrival_sec = rxnow - rtp->rxstart_stable;\n\tarrival = ast_sec2samp(arrival_sec, rate);\n\n\t/*\n\t * Now we can use the exact formula in\n\t * https://www.rfc-editor.org/rfc/rfc3550#appendix-A.8 :\n\t *\n\t * int transit = arrival - r->ts;\n\t * int d = transit - s->transit;\n\t * s->transit = transit;\n\t * if (d < 0) d = -d;\n\t * s->jitter += (1./16.) * ((double)d - s->jitter);\n\t *\n\t * Our rx_rtp_ts is their r->ts.\n\t * Our rtp->last_transit_time_samples is their s->transit.\n\t * Our rtp->rxjitter is their s->jitter.\n\t */\n\ttransit = arrival - rx_rtp_ts;\n\td = transit - rtp->last_transit_time_samples;\n\n\tif (d < 0) {\n\t\td = -d;\n\t}\n\n\tprev_jitter = rtp->rxjitter_samples;\n\tjitter = (1.0/16.0) * (((double)d) - prev_jitter);\n\trtp->rxjitter_samples = prev_jitter + jitter;\n\n\t/*\n\t * We need to hang on to jitter in both samples and seconds.\n\t */\n\trtp->rxjitter = ast_samp2sec(rtp->rxjitter_samples, rate);\n\n\tast_debug_rtcp(3, \"%s: pkt: %5u \"\n\t\t\"Arrival sec: %7.3f  Arrival ts: %10u  RX ts: %10u \"\n\t\t\"Transit samp: %6d Last transit samp: %6d d: %4d \"\n\t\t\"Curr jitter: %7.0f(%7.3f) Prev Jitter: %7.0f(%7.3f) New Jitter: %7.0f(%7.3f)\\n\",\n\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t, rtp->rxcount\n\t\t, arrival_sec\n\t\t, arrival\n\t\t, rx_rtp_ts\n\t\t, transit\n\t\t, rtp->last_transit_time_samples\n\t\t, d\n\t\t, jitter\n\t\t, ast_samp2sec(jitter, rate)\n\t\t, prev_jitter\n\t\t, ast_samp2sec(prev_jitter, rate)\n\t\t, rtp->rxjitter_samples\n\t\t, rtp->rxjitter\n\t\t);\n\n\trtp->last_transit_time_samples = transit;\n\n\t/*\n\t * Update all the stats.\n\t */\n\tif (rtp->rtcp) {\n\t\tif (rtp->rxjitter > rtp->rtcp->maxrxjitter)\n\t\t\trtp->rtcp->maxrxjitter = rtp->rxjitter;\n\t\tif (rtp->rtcp->rxjitter_count == 1)\n\t\t\trtp->rtcp->minrxjitter = rtp->rxjitter;\n\t\tif (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter)\n\t\t\trtp->rtcp->minrxjitter = rtp->rxjitter;\n\n\t\tcalc_mean_and_standard_deviation(rtp->rxjitter,\n\t\t\t&rtp->rtcp->normdev_rxjitter, &rtp->rtcp->stdev_rxjitter,\n\t\t\t&rtp->rtcp->rxjitter_count);\n\t}\n\n\treturn;\n}\n\nstatic struct ast_frame *create_dtmf_frame(struct ast_rtp_instance *instance, enum ast_frame_type type, int compensate)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\tif (((compensate && type == AST_FRAME_DTMF_END) || (type == AST_FRAME_DTMF_BEGIN)) && ast_tvcmp(ast_tvnow(), rtp->dtmfmute) < 0) {\n\t\tast_debug_rtp(1, \"(%p) RTP ignore potential DTMF echo from '%s'\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\trtp->resp = 0;\n\t\trtp->dtmfsamples = 0;\n\t\treturn &ast_null_frame;\n\t} else if (type == AST_FRAME_DTMF_BEGIN && rtp->resp == 'X') {\n\t\tast_debug_rtp(1, \"(%p) RTP ignore flash begin from '%s'\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\trtp->resp = 0;\n\t\trtp->dtmfsamples = 0;\n\t\treturn &ast_null_frame;\n\t}\n\n\tif (rtp->resp == 'X') {\n\t\tast_debug_rtp(1, \"(%p) RTP creating flash Frame at %s\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\trtp->f.frametype = AST_FRAME_CONTROL;\n\t\trtp->f.subclass.integer = AST_CONTROL_FLASH;\n\t} else {\n\t\tast_debug_rtp(1, \"(%p) RTP creating %s DTMF Frame: %d (%c), at %s\\n\",\n\t\t\tinstance, type == AST_FRAME_DTMF_END ? \"END\" : \"BEGIN\",\n\t\t\trtp->resp, rtp->resp,\n\t\t\tast_sockaddr_stringify(&remote_address));\n\t\trtp->f.frametype = type;\n\t\trtp->f.subclass.integer = rtp->resp;\n\t}\n\trtp->f.datalen = 0;\n\trtp->f.samples = 0;\n\trtp->f.mallocd = 0;\n\trtp->f.src = \"RTP\";\n\tAST_LIST_NEXT(&rtp->f, frame_list) = NULL;\n\n\treturn &rtp->f;\n}\n\nstatic void process_dtmf_rfc2833(struct ast_rtp_instance *instance, unsigned char *data, int len, unsigned int seqno, unsigned int timestamp, int payloadtype, int mark, struct frame_list *frames)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tunsigned int event, event_end, samples;\n\tchar resp = 0;\n\tstruct ast_frame *f = NULL;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* Figure out event, event end, and samples */\n\tevent = ntohl(*((unsigned int *)(data)));\n\tevent >>= 24;\n\tevent_end = ntohl(*((unsigned int *)(data)));\n\tevent_end <<= 8;\n\tevent_end >>= 24;\n\tsamples = ntohl(*((unsigned int *)(data)));\n\tsamples &= 0xFFFF;\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Got  RTP RFC2833 from   %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d, mark %d, event %08x, end %d, duration %-5.5u) \\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    payloadtype, seqno, timestamp, len, (mark?1:0), event, ((event_end & 0x80)?1:0), samples);\n\t}\n\n\t/* Print out debug if turned on */\n\tif (ast_debug_rtp_packet_is_allowed)\n\t\tast_debug(0, \"- RTP 2833 Event: %08x (len = %d)\\n\", event, len);\n\n\t/* Figure out what digit was pressed */\n\tif (event < 10) {\n\t\tresp = '0' + event;\n\t} else if (event < 11) {\n\t\tresp = '*';\n\t} else if (event < 12) {\n\t\tresp = '#';\n\t} else if (event < 16) {\n\t\tresp = 'A' + (event - 12);\n\t} else if (event < 17) {        /* Event 16: Hook flash */\n\t\tresp = 'X';\n\t} else {\n\t\t/* Not a supported event */\n\t\tast_debug_rtp(1, \"(%p) RTP ignoring RTP 2833 Event: %08x. Not a DTMF Digit.\\n\", instance, event);\n\t\treturn;\n\t}\n\n\tif (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE)) {\n\t\tif (!rtp->last_end_timestamp.is_set || rtp->last_end_timestamp.ts != timestamp || (rtp->resp && rtp->resp != resp)) {\n\t\t\trtp->resp = resp;\n\t\t\trtp->dtmf_timeout = 0;\n\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_END, ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE)));\n\t\t\tf->len = 0;\n\t\t\trtp->last_end_timestamp.ts = timestamp;\n\t\t\trtp->last_end_timestamp.is_set = 1;\n\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t}\n\t} else {\n\t\t/*  The duration parameter measures the complete\n\t\t    duration of the event (from the beginning) - RFC2833.\n\t\t    Account for the fact that duration is only 16 bits long\n\t\t    (about 8 seconds at 8000 Hz) and can wrap is digit\n\t\t    is hold for too long. */\n\t\tunsigned int new_duration = rtp->dtmf_duration;\n\t\tunsigned int last_duration = new_duration & 0xFFFF;\n\n\t\tif (last_duration > 64000 && samples < last_duration) {\n\t\t\tnew_duration += 0xFFFF + 1;\n\t\t}\n\t\tnew_duration = (new_duration & ~0xFFFF) | samples;\n\n\t\tif (event_end & 0x80) {\n\t\t\t/* End event */\n\t\t\tif (rtp->last_seqno != seqno && (!rtp->last_end_timestamp.is_set || timestamp > rtp->last_end_timestamp.ts)) {\n\t\t\t\trtp->last_end_timestamp.ts = timestamp;\n\t\t\t\trtp->last_end_timestamp.is_set = 1;\n\t\t\t\trtp->dtmf_duration = new_duration;\n\t\t\t\trtp->resp = resp;\n\t\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_END, 0));\n\t\t\t\tf->len = ast_tvdiff_ms(ast_samp2tv(rtp->dtmf_duration, ast_rtp_get_rate(f->subclass.format)), ast_tv(0, 0));\n\t\t\t\trtp->resp = 0;\n\t\t\t\trtp->dtmf_duration = rtp->dtmf_timeout = 0;\n\t\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t\t} else if (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP dropping duplicate or out of order DTMF END frame (seqno: %u, ts %u, digit %c)\\n\",\n\t\t\t\t\tinstance, seqno, timestamp, resp);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Begin/continuation */\n\n\t\t\t/* The second portion of the seqno check is to not mistakenly\n\t\t\t * stop accepting DTMF if the seqno rolls over beyond\n\t\t\t * 65535.\n\t\t\t */\n\t\t\tif ((rtp->last_seqno > seqno && rtp->last_seqno - seqno < 50)\n\t\t\t   || (rtp->last_end_timestamp.is_set\n\t\t\t\t  && timestamp <= rtp->last_end_timestamp.ts)) {\n\t\t\t\t/* Out of order frame. Processing this can cause us to\n\t\t\t\t * improperly duplicate incoming DTMF, so just drop\n\t\t\t\t * this.\n\t\t\t\t */\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\t\tast_debug(0, \"Dropping out of order DTMF frame (seqno %u, ts %u, digit %c)\\n\",\n\t\t\t\t\t\tseqno, timestamp, resp);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rtp->resp && rtp->resp != resp) {\n\t\t\t\t/* Another digit already began. End it */\n\t\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_END, 0));\n\t\t\t\tf->len = ast_tvdiff_ms(ast_samp2tv(rtp->dtmf_duration, ast_rtp_get_rate(f->subclass.format)), ast_tv(0, 0));\n\t\t\t\trtp->resp = 0;\n\t\t\t\trtp->dtmf_duration = rtp->dtmf_timeout = 0;\n\t\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t\t}\n\n\t\t\tif (rtp->resp) {\n\t\t\t\t/* Digit continues */\n\t\t\t\trtp->dtmf_duration = new_duration;\n\t\t\t} else {\n\t\t\t\t/* New digit began */\n\t\t\t\trtp->resp = resp;\n\t\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_BEGIN, 0));\n\t\t\t\trtp->dtmf_duration = samples;\n\t\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t\t}\n\n\t\t\trtp->dtmf_timeout = timestamp + rtp->dtmf_duration + dtmftimeout;\n\t\t}\n\n\t\trtp->last_seqno = seqno;\n\t}\n\n\trtp->dtmfsamples = samples;\n\n\treturn;\n}\n\nstatic struct ast_frame *process_dtmf_cisco(struct ast_rtp_instance *instance, unsigned char *data, int len, unsigned int seqno, unsigned int timestamp, int payloadtype, int mark)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tunsigned int event, flags, power;\n\tchar resp = 0;\n\tunsigned char seq;\n\tstruct ast_frame *f = NULL;\n\n\tif (len < 4) {\n\t\treturn NULL;\n\t}\n\n\t/*      The format of Cisco RTP DTMF packet looks like next:\n\t\t+0                              - sequence number of DTMF RTP packet (begins from 1,\n\t\t\t\t\t\t  wrapped to 0)\n\t\t+1                              - set of flags\n\t\t+1 (bit 0)              - flaps by different DTMF digits delimited by audio\n\t\t\t\t\t\t  or repeated digit without audio???\n\t\t+2 (+4,+6,...)  - power level? (rises from 0 to 32 at begin of tone\n\t\t\t\t\t\t  then falls to 0 at its end)\n\t\t+3 (+5,+7,...)  - detected DTMF digit (0..9,*,#,A-D,...)\n\t\tRepeated DTMF information (bytes 4/5, 6/7) is history shifted right\n\t\tby each new packet and thus provides some redundancy.\n\n\t\tSample of Cisco RTP DTMF packet is (all data in hex):\n\t\t\t19 07 00 02 12 02 20 02\n\t\tshowing end of DTMF digit '2'.\n\n\t\tThe packets\n\t\t\t27 07 00 02 0A 02 20 02\n\t\t\t28 06 20 02 00 02 0A 02\n\t\tshows begin of new digit '2' with very short pause (20 ms) after\n\t\tprevious digit '2'. Bit +1.0 flips at begin of new digit.\n\n\t\tCisco RTP DTMF packets comes as replacement of audio RTP packets\n\t\tso its uses the same sequencing and timestamping rules as replaced\n\t\taudio packets. Repeat interval of DTMF packets is 20 ms and not rely\n\t\ton audio framing parameters. Marker bit isn't used within stream of\n\t\tDTMFs nor audio stream coming immediately after DTMF stream. Timestamps\n\t\tare not sequential at borders between DTMF and audio streams,\n\t*/\n\n\tseq = data[0];\n\tflags = data[1];\n\tpower = data[2];\n\tevent = data[3] & 0x1f;\n\n\tif (ast_debug_rtp_packet_is_allowed)\n\t\tast_debug(0, \"Cisco DTMF Digit: %02x (len=%d, seq=%d, flags=%02x, power=%u, history count=%d)\\n\", event, len, seq, flags, power, (len - 4) / 2);\n\tif (event < 10) {\n\t\tresp = '0' + event;\n\t} else if (event < 11) {\n\t\tresp = '*';\n\t} else if (event < 12) {\n\t\tresp = '#';\n\t} else if (event < 16) {\n\t\tresp = 'A' + (event - 12);\n\t} else if (event < 17) {\n\t\tresp = 'X';\n\t}\n\tif ((!rtp->resp && power) || (rtp->resp && (rtp->resp != resp))) {\n\t\trtp->resp = resp;\n\t\t/* Why we should care on DTMF compensation at reception? */\n\t\tif (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE)) {\n\t\t\tf = create_dtmf_frame(instance, AST_FRAME_DTMF_BEGIN, 0);\n\t\t\trtp->dtmfsamples = 0;\n\t\t}\n\t} else if ((rtp->resp == resp) && !power) {\n\t\tf = create_dtmf_frame(instance, AST_FRAME_DTMF_END, ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE));\n\t\tf->samples = rtp->dtmfsamples * (ast_rtp_get_rate(rtp->lastrxformat) / 1000);\n\t\trtp->resp = 0;\n\t} else if (rtp->resp == resp) {\n\t\trtp->dtmfsamples += 20 * (ast_rtp_get_rate(rtp->lastrxformat) / 1000);\n\t}\n\n\trtp->dtmf_timeout = 0;\n\n\treturn f;\n}\n\nstatic struct ast_frame *process_cn_rfc3389(struct ast_rtp_instance *instance, unsigned char *data, int len, unsigned int seqno, unsigned int timestamp, int payloadtype, int mark)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* Convert comfort noise into audio with various codecs.  Unfortunately this doesn't\n\t   totally help us out because we don't have an engine to keep it going and we are not\n\t   guaranteed to have it every 20ms or anything */\n\tif (ast_debug_rtp_packet_is_allowed) {\n\t\tast_debug(0, \"- RTP 3389 Comfort noise event: Format %s (len = %d)\\n\",\n\t\t\tast_format_get_name(rtp->lastrxformat), len);\n\t}\n\n\tif (!ast_test_flag(rtp, FLAG_3389_WARNING)) {\n\t\tstruct ast_sockaddr remote_address = { {0,} };\n\n\t\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t\tast_log(LOG_NOTICE, \"Comfort noise support incomplete in Asterisk (RFC 3389). Please turn off on client if possible. Client address: %s\\n\",\n\t\t\tast_sockaddr_stringify(&remote_address));\n\t\tast_set_flag(rtp, FLAG_3389_WARNING);\n\t}\n\n\t/* Must have at least one byte */\n\tif (!len) {\n\t\treturn NULL;\n\t}\n\tif (len < 24) {\n\t\trtp->f.data.ptr = rtp->rawdata + AST_FRIENDLY_OFFSET;\n\t\trtp->f.datalen = len - 1;\n\t\trtp->f.offset = AST_FRIENDLY_OFFSET;\n\t\tmemcpy(rtp->f.data.ptr, data + 1, len - 1);\n\t} else {\n\t\trtp->f.data.ptr = NULL;\n\t\trtp->f.offset = 0;\n\t\trtp->f.datalen = 0;\n\t}\n\trtp->f.frametype = AST_FRAME_CNG;\n\trtp->f.subclass.integer = data[0] & 0x7f;\n\trtp->f.samples = 0;\n\trtp->f.delivery.tv_usec = rtp->f.delivery.tv_sec = 0;\n\n\treturn &rtp->f;\n}\n\nstatic int update_rtt_stats(struct ast_rtp *rtp, unsigned int lsr, unsigned int dlsr)\n{\n\tstruct timeval now;\n\tstruct timeval rtt_tv;\n\tunsigned int msw;\n\tunsigned int lsw;\n\tunsigned int rtt_msw;\n\tunsigned int rtt_lsw;\n\tunsigned int lsr_a;\n\tunsigned int rtt;\n\n\tgettimeofday(&now, NULL);\n\ttimeval2ntp(now, &msw, &lsw);\n\n\tlsr_a = ((msw & 0x0000ffff) << 16) | ((lsw & 0xffff0000) >> 16);\n\trtt = lsr_a - lsr - dlsr;\n\trtt_msw = (rtt & 0xffff0000) >> 16;\n\trtt_lsw = (rtt & 0x0000ffff);\n\trtt_tv.tv_sec = rtt_msw;\n\t/*\n\t * Convert 16.16 fixed point rtt_lsw to usec without\n\t * overflow.\n\t *\n\t * = rtt_lsw * 10^6 / 2^16\n\t * = rtt_lsw * (2^6 * 5^6) / 2^16\n\t * = rtt_lsw * 5^6 / 2^10\n\t *\n\t * The rtt_lsw value is in 16.16 fixed point format and 5^6\n\t * requires 14 bits to represent.  We have enough space to\n\t * directly do the conversion because there is no integer\n\t * component in rtt_lsw.\n\t */\n\trtt_tv.tv_usec = (rtt_lsw * 15625) >> 10;\n\trtp->rtcp->rtt = (double)rtt_tv.tv_sec + ((double)rtt_tv.tv_usec / 1000000);\n\tif (lsr_a - dlsr < lsr) {\n\t\treturn 1;\n\t}\n\n\trtp->rtcp->accumulated_transit += rtp->rtcp->rtt;\n\tif (rtp->rtcp->rtt_count == 0 || rtp->rtcp->minrtt > rtp->rtcp->rtt) {\n\t\trtp->rtcp->minrtt = rtp->rtcp->rtt;\n\t}\n\tif (rtp->rtcp->maxrtt < rtp->rtcp->rtt) {\n\t\trtp->rtcp->maxrtt = rtp->rtcp->rtt;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rtcp->rtt, &rtp->rtcp->normdevrtt,\n\t\t&rtp->rtcp->stdevrtt, &rtp->rtcp->rtt_count);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Update RTCP interarrival jitter stats\n */\nstatic void update_jitter_stats(struct ast_rtp *rtp, unsigned int ia_jitter)\n{\n\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\n\trtp->rtcp->reported_jitter = ast_samp2sec(ia_jitter, rate);\n\n\tif (rtp->rtcp->reported_jitter_count == 0) {\n\t\trtp->rtcp->reported_minjitter = rtp->rtcp->reported_jitter;\n\t}\n\tif (rtp->rtcp->reported_jitter < rtp->rtcp->reported_minjitter) {\n\t\trtp->rtcp->reported_minjitter = rtp->rtcp->reported_jitter;\n\t}\n\tif (rtp->rtcp->reported_jitter > rtp->rtcp->reported_maxjitter) {\n\t\trtp->rtcp->reported_maxjitter = rtp->rtcp->reported_jitter;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rtcp->reported_jitter,\n\t\t&rtp->rtcp->reported_normdev_jitter, &rtp->rtcp->reported_stdev_jitter,\n\t\t&rtp->rtcp->reported_jitter_count);\n}\n\n/*!\n * \\internal\n * \\brief Update RTCP lost packet stats\n */\nstatic void update_lost_stats(struct ast_rtp *rtp, unsigned int lost_packets)\n{\n\tdouble reported_lost;\n\n\trtp->rtcp->reported_lost = lost_packets;\n\treported_lost = (double)rtp->rtcp->reported_lost;\n\tif (rtp->rtcp->reported_lost_count == 0) {\n\t\trtp->rtcp->reported_minlost = reported_lost;\n\t}\n\tif (reported_lost < rtp->rtcp->reported_minlost) {\n\t\trtp->rtcp->reported_minlost = reported_lost;\n\t}\n\tif (reported_lost > rtp->rtcp->reported_maxlost) {\n\t\trtp->rtcp->reported_maxlost = reported_lost;\n\t}\n\n\tcalc_mean_and_standard_deviation(reported_lost, &rtp->rtcp->reported_normdev_lost,\n\t\t&rtp->rtcp->reported_stdev_lost, &rtp->rtcp->reported_lost_count);\n}\n\n#define RESCALE(in, inmin, inmax, outmin, outmax) ((((in - inmin)/(inmax-inmin))*(outmax-outmin))+outmin)\n/*!\n * \\brief Calculate a \"media experience score\" based on given data\n *\n * Technically, a mean opinion score (MOS) cannot be calculated without the involvement\n * of human eyes (video) and ears (audio). Thus instead we'll approximate an opinion\n * using the given parameters, and call it a media experience score.\n *\n * The tallied score is based upon recommendations and formulas from ITU-T G.107,\n * ITU-T G.109, ITU-T G.113, and other various internet sources.\n *\n * \\param instance RTP instance\n * \\param normdevrtt The average round trip time\n * \\param normdev_rxjitter The smoothed jitter\n * \\param stdev_rxjitter The jitter standard deviation value\n * \\param normdev_rxlost The average number of packets lost since last check\n *\n * \\return A media experience score.\n *\n * \\note The calculations in this function could probably be simplified\n * but calculating a MOS using the information available publicly,\n * then re-scaling it to 0.0 -> 100.0 makes the process clearer and\n * easier to troubleshoot or change.\n */\nstatic double calc_media_experience_score(struct ast_rtp_instance *instance,\n\tdouble normdevrtt, double normdev_rxjitter, double stdev_rxjitter,\n\tdouble normdev_rxlost)\n{\n\tdouble r_value;\n\tdouble pseudo_mos;\n\tdouble mes = 0;\n\n\t/*\n\t * While the media itself might be okay, a significant enough delay could make\n\t * for an unpleasant user experience.\n\t *\n\t * Calculate the effective latency by using the given round trip time, and adding\n\t * jitter scaled according to its standard deviation. The scaling is done in order\n\t * to increase jitter's weight since a higher deviation can result in poorer overall\n\t * quality.\n\t */\n\tdouble effective_latency = (normdevrtt * 1000)\n\t\t+ ((normdev_rxjitter * 2) * (stdev_rxjitter / 3))\n\t\t+ 10;\n\n\t/*\n\t * Using the defaults for the standard transmission rating factor (\"R\" value)\n\t * one arrives at 93.2 (see ITU-T G.107 for more details), so we'll use that\n\t * as the starting value and subtract deficiencies that could affect quality.\n\t *\n\t * Calculate the impact of the effective latency. Influence increases with\n\t * values over 160 as the significant \"lag\" can degrade user experience.\n\t */\n\tif (effective_latency < 160) {\n\t\tr_value = 93.2 - (effective_latency / 40);\n\t} else {\n\t\tr_value = 93.2 - (effective_latency - 120) / 10;\n\t}\n\n\t/* Next evaluate the impact of lost packets */\n\tr_value = r_value - (normdev_rxlost * 2.0);\n\n\t/*\n\t * Finally convert the \"R\" value into a opinion/quality score between 1 (really anything\n\t * below 3 should be considered poor) and 4.5 (the highest achievable for VOIP).\n\t */\n\tif (r_value < 0) {\n\t\tpseudo_mos = 1.0;\n\t} else if (r_value > 100) {\n\t\tpseudo_mos = 4.5;\n\t} else {\n\t\tpseudo_mos = 1 + (0.035 * r_value) + (r_value * (r_value - 60) * (100 - r_value) * 0.0000007);\n\t}\n\n\t/*\n\t * We're going to rescale the 0.0->5.0 pseudo_mos to the 0.0->100.0 MES.\n\t * For those ranges, we could actually just multiply the pseudo_mos\n\t * by 20 but we may want to change the scale later.\n\t */\n\tmes = RESCALE(pseudo_mos, 0.0, 5.0, 0.0, 100.0);\n\n\treturn mes;\n}\n\n/*!\n * \\internal\n * \\brief Update MES stats based on info received in an SR or RR.\n * This is RTP we sent and they received.\n */\nstatic void update_reported_mes_stats(struct ast_rtp *rtp)\n{\n\tdouble mes = calc_media_experience_score(rtp->owner,\n\t\trtp->rtcp->normdevrtt,\n\t\trtp->rtcp->reported_jitter,\n\t\trtp->rtcp->reported_stdev_jitter,\n\t\trtp->rtcp->reported_normdev_lost);\n\n\trtp->rtcp->reported_mes = mes;\n\tif (rtp->rtcp->reported_mes_count == 0) {\n\t\trtp->rtcp->reported_minmes = mes;\n\t}\n\tif (mes < rtp->rtcp->reported_minmes) {\n\t\trtp->rtcp->reported_minmes = mes;\n\t}\n\tif (mes > rtp->rtcp->reported_maxmes) {\n\t\trtp->rtcp->reported_maxmes = mes;\n\t}\n\n\tcalc_mean_and_standard_deviation(mes, &rtp->rtcp->reported_normdev_mes,\n\t\t&rtp->rtcp->reported_stdev_mes, &rtp->rtcp->reported_mes_count);\n\n\tast_debug_rtcp(2, \"%s: rtt: %.9f j: %.9f sjh: %.9f lost: %.9f mes: %4.1f\\n\",\n\t\tast_rtp_instance_get_channel_id(rtp->owner),\n\t\trtp->rtcp->normdevrtt,\n\t\t\t\trtp->rtcp->reported_jitter,\n\t\t\t\trtp->rtcp->reported_stdev_jitter,\n\t\t\t\trtp->rtcp->reported_normdev_lost, mes);\n}\n\n/*!\n * \\internal\n * \\brief Update MES stats based on info we will send in an SR or RR.\n * This is RTP they sent and we received.\n */\nstatic void update_local_mes_stats(struct ast_rtp *rtp)\n{\n\trtp->rxmes = calc_media_experience_score(rtp->owner,\n\t\trtp->rtcp->normdevrtt,\n\t\trtp->rxjitter,\n\t\trtp->rtcp->stdev_rxjitter,\n\t\trtp->rtcp->normdev_rxlost);\n\n\tif (rtp->rtcp->rxmes_count == 0) {\n\t\trtp->rtcp->minrxmes = rtp->rxmes;\n\t}\n\tif (rtp->rxmes < rtp->rtcp->minrxmes) {\n\t\trtp->rtcp->minrxmes = rtp->rxmes;\n\t}\n\tif (rtp->rxmes > rtp->rtcp->maxrxmes) {\n\t\trtp->rtcp->maxrxmes = rtp->rxmes;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rxmes, &rtp->rtcp->normdev_rxmes,\n\t\t&rtp->rtcp->stdev_rxmes, &rtp->rtcp->rxmes_count);\n\n\tast_debug_rtcp(2, \"   %s: rtt: %.9f j: %.9f sjh: %.9f lost: %.9f mes: %4.1f\\n\",\n\t\tast_rtp_instance_get_channel_id(rtp->owner),\n\t\trtp->rtcp->normdevrtt,\n\t\t\t\trtp->rxjitter,\n\t\t\t\trtp->rtcp->stdev_rxjitter,\n\t\t\t\trtp->rtcp->normdev_rxlost, rtp->rxmes);\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_rtp_instance *__rtp_find_instance_by_ssrc(struct ast_rtp_instance *instance,\n\tstruct ast_rtp *rtp, unsigned int ssrc, int source)\n{\n\tint index;\n\n\tif (!AST_VECTOR_SIZE(&rtp->ssrc_mapping)) {\n\t\t/* This instance is not bundled */\n\t\treturn instance;\n\t}\n\n\t/* Find the bundled child instance */\n\tfor (index = 0; index < AST_VECTOR_SIZE(&rtp->ssrc_mapping); ++index) {\n\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&rtp->ssrc_mapping, index);\n\t\tunsigned int mapping_ssrc = source ? ast_rtp_get_ssrc(mapping->instance) : mapping->ssrc;\n\n\t\tif (mapping->ssrc_valid && mapping_ssrc == ssrc) {\n\t\t\treturn mapping->instance;\n\t\t}\n\t}\n\n\t/* Does the SSRC match the bundled parent? */\n\tif (rtp->themssrc_valid && rtp->themssrc == ssrc) {\n\t\treturn instance;\n\t}\n\treturn NULL;\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_rtp_instance *rtp_find_instance_by_packet_source_ssrc(struct ast_rtp_instance *instance,\n\tstruct ast_rtp *rtp, unsigned int ssrc)\n{\n\treturn __rtp_find_instance_by_ssrc(instance, rtp, ssrc, 0);\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_rtp_instance *rtp_find_instance_by_media_source_ssrc(struct ast_rtp_instance *instance,\n\tstruct ast_rtp *rtp, unsigned int ssrc)\n{\n\treturn __rtp_find_instance_by_ssrc(instance, rtp, ssrc, 1);\n}\n\nstatic const char *rtcp_payload_type2str(unsigned int pt)\n{\n\tconst char *str;\n\n\tswitch (pt) {\n\tcase RTCP_PT_SR:\n\t\tstr = \"Sender Report\";\n\t\tbreak;\n\tcase RTCP_PT_RR:\n\t\tstr = \"Receiver Report\";\n\t\tbreak;\n\tcase RTCP_PT_FUR:\n\t\t/* Full INTRA-frame Request / Fast Update Request */\n\t\tstr = \"H.261 FUR\";\n\t\tbreak;\n\tcase RTCP_PT_PSFB:\n\t\t/* Payload Specific Feed Back */\n\t\tstr = \"PSFB\";\n\t\tbreak;\n\tcase RTCP_PT_SDES:\n\t\tstr = \"Source Description\";\n\t\tbreak;\n\tcase RTCP_PT_BYE:\n\t\tstr = \"BYE\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"Unknown\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic const char *rtcp_payload_subtype2str(unsigned int pt, unsigned int subtype)\n{\n\tswitch (pt) {\n\tcase AST_RTP_RTCP_RTPFB:\n\t\tif (subtype == AST_RTP_RTCP_FMT_NACK) {\n\t\t\treturn \"NACK\";\n\t\t}\n\t\tbreak;\n\tcase RTCP_PT_PSFB:\n\t\tif (subtype == AST_RTP_RTCP_FMT_REMB) {\n\t\t\treturn \"REMB\";\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_rtcp_handle_nack(struct ast_rtp_instance *instance, unsigned int *nackdata, unsigned int position,\n\tunsigned int length)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint res = 0;\n\tint blp_index;\n\tint packet_index;\n\tint ice;\n\tstruct ast_rtp_rtcp_nack_payload *payload;\n\tunsigned int current_word;\n\tunsigned int pid;\t/* Packet ID which refers to seqno of lost packet */\n\tunsigned int blp;\t/* Bitmask of following lost packets */\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint abs_send_time_id;\n\tunsigned int now_msw = 0;\n\tunsigned int now_lsw = 0;\n\tunsigned int packets_not_found = 0;\n\n\tif (!rtp->send_buffer) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP tried to handle NACK request, \"\n\t\t\t\"but we don't have a RTP packet storage!\\n\", instance);\n\t\treturn res;\n\t}\n\n\tabs_send_time_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_ABS_SEND_TIME);\n\tif (abs_send_time_id != -1) {\n\t\ttimeval2ntp(ast_tvnow(), &now_msw, &now_lsw);\n\t}\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/*\n\t * We use index 3 because with feedback messages, the FCI (Feedback Control Information)\n\t * does not begin until after the version, packet SSRC, and media SSRC words.\n\t */\n\tfor (packet_index = 3; packet_index < length; packet_index++) {\n\t\tcurrent_word = ntohl(nackdata[position + packet_index]);\n\t\tpid = current_word >> 16;\n\t\t/* We know the remote end is missing this packet. Go ahead and send it if we still have it. */\n\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_get(rtp->send_buffer, pid);\n\t\tif (payload) {\n\t\t\tif (abs_send_time_id != -1) {\n\t\t\t\t/* On retransmission we need to update the timestamp within the packet, as it\n\t\t\t\t * is supposed to contain when the packet was actually sent.\n\t\t\t\t */\n\t\t\t\tput_unaligned_time24(payload->buf + 17, now_msw, now_lsw);\n\t\t\t}\n\t\t\tres += rtp_sendto(instance, payload->buf, payload->size, 0, &remote_address, &ice);\n\t\t} else {\n\t\t\tast_debug_rtcp(1, \"(%p) RTCP received NACK request for RTP packet with seqno %d, \"\n\t\t\t\t\"but we don't have it\\n\", instance, pid);\n\t\t\tpackets_not_found++;\n\t\t}\n\t\t/*\n\t\t * The bitmask. Denoting the least significant bit as 1 and its most significant bit\n\t\t * as 16, then bit i of the bitmask is set to 1 if the receiver has not received RTP\n\t\t * packet (pid+i)(modulo 2^16). Otherwise, it is set to 0. We cannot assume bits set\n\t\t * to 0 after a bit set to 1 have actually been received.\n\t\t */\n\t\tblp = current_word & 0xffff;\n\t\tblp_index = 1;\n\t\twhile (blp) {\n\t\t\tif (blp & 1) {\n\t\t\t\t/* Packet (pid + i)(modulo 2^16) is missing too. */\n\t\t\t\tunsigned int seqno = (pid + blp_index) % 65536;\n\t\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_get(rtp->send_buffer, seqno);\n\t\t\t\tif (payload) {\n\t\t\t\t\tif (abs_send_time_id != -1) {\n\t\t\t\t\t\tput_unaligned_time24(payload->buf + 17, now_msw, now_lsw);\n\t\t\t\t\t}\n\t\t\t\t\tres += rtp_sendto(instance, payload->buf, payload->size, 0, &remote_address, &ice);\n\t\t\t\t} else {\n\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP remote end also requested RTP packet with seqno %d, \"\n\t\t\t\t\t\t\"but we don't have it\\n\", instance, seqno);\n\t\t\t\t\tpackets_not_found++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblp >>= 1;\n\t\t\tblp_index++;\n\t\t}\n\t}\n\n\tif (packets_not_found) {\n\t\t/* Grow the send buffer based on how many packets were not found in the buffer, but\n\t\t * enforce a maximum.\n\t\t */\n\t\tast_data_buffer_resize(rtp->send_buffer, MIN(MAXIMUM_RTP_SEND_BUFFER_SIZE,\n\t\t\tast_data_buffer_max(rtp->send_buffer) + packets_not_found));\n\t\tast_debug_rtcp(2, \"(%p) RTCP send buffer on RTP instance is now at maximum of %zu\\n\",\n\t\t\tinstance, ast_data_buffer_max(rtp->send_buffer));\n\t}\n\n\treturn res;\n}\n\n/*\n * Unshifted RTCP header bit field masks\n */\n#define RTCP_LENGTH_MASK\t\t\t0xFFFF\n#define RTCP_PAYLOAD_TYPE_MASK\t\t0xFF\n#define RTCP_REPORT_COUNT_MASK\t\t0x1F\n#define RTCP_PADDING_MASK\t\t\t0x01\n#define RTCP_VERSION_MASK\t\t\t0x03\n\n/*\n * RTCP header bit field shift offsets\n */\n#define RTCP_LENGTH_SHIFT\t\t\t0\n#define RTCP_PAYLOAD_TYPE_SHIFT\t\t16\n#define RTCP_REPORT_COUNT_SHIFT\t\t24\n#define RTCP_PADDING_SHIFT\t\t\t29\n#define RTCP_VERSION_SHIFT\t\t\t30\n\n#define RTCP_VERSION\t\t\t\t2U\n#define RTCP_VERSION_SHIFTED\t\t(RTCP_VERSION << RTCP_VERSION_SHIFT)\n#define RTCP_VERSION_MASK_SHIFTED\t(RTCP_VERSION_MASK << RTCP_VERSION_SHIFT)\n\n/*\n * RTCP first packet record validity header mask and value.\n *\n * RFC3550 intentionally defines the encoding of RTCP_PT_SR and RTCP_PT_RR\n * such that they differ in the least significant bit.  Either of these two\n * payload types MUST be the first RTCP packet record in a compound packet.\n *\n * RFC3550 checks the padding bit in the algorithm they use to check the\n * RTCP packet for validity.  However, we aren't masking the padding bit\n * to check since we don't know if it is a compound RTCP packet or not.\n */\n#define RTCP_VALID_MASK (RTCP_VERSION_MASK_SHIFTED | (((RTCP_PAYLOAD_TYPE_MASK & ~0x1)) << RTCP_PAYLOAD_TYPE_SHIFT))\n#define RTCP_VALID_VALUE (RTCP_VERSION_SHIFTED | (RTCP_PT_SR << RTCP_PAYLOAD_TYPE_SHIFT))\n\n#define RTCP_SR_BLOCK_WORD_LENGTH 5\n#define RTCP_RR_BLOCK_WORD_LENGTH 6\n#define RTCP_HEADER_SSRC_LENGTH   2\n#define RTCP_FB_REMB_BLOCK_WORD_LENGTH 4\n#define RTCP_FB_NACK_BLOCK_WORD_LENGTH 2\n\nstatic struct ast_frame *ast_rtcp_interpret(struct ast_rtp_instance *instance, struct ast_srtp *srtp,\n\tconst unsigned char *rtcpdata, size_t size, struct ast_sockaddr *addr)\n{\n\tstruct ast_rtp_instance *transport = instance;\n\tstruct ast_rtp *transport_rtp = ast_rtp_instance_get_data(instance);\n\tint len = size;\n\tunsigned int *rtcpheader = (unsigned int *)(rtcpdata);\n\tunsigned int packetwords;\n\tunsigned int position;\n\tunsigned int first_word;\n\t/*! True if we have seen an acceptable SSRC to learn the remote RTCP address */\n\tunsigned int ssrc_seen;\n\tstruct ast_rtp_rtcp_report_block *report_block;\n\tstruct ast_frame *f = &ast_null_frame;\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test_engine;\n#endif\n\n\t/* If this is encrypted then decrypt the payload */\n\tif ((*rtcpheader & 0xC0) && res_srtp && srtp && res_srtp->unprotect(\n\t\t    srtp, rtcpheader, &len, 1 | (srtp_replay_protection << 1)) < 0) {\n\t   return &ast_null_frame;\n\t}\n\n\tpacketwords = len / 4;\n\n\tast_debug_rtcp(2, \"(%s) RTCP got report of %d bytes from %s\\n\",\n\t\tast_rtp_instance_get_channel_id(instance),\n\t\tlen, ast_sockaddr_stringify(addr));\n\n\t/*\n\t * Validate the RTCP packet according to an adapted and slightly\n\t * modified RFC3550 validation algorithm.\n\t */\n\tif (packetwords < RTCP_HEADER_SSRC_LENGTH) {\n\t\tast_debug_rtcp(2, \"(%s) RTCP %p -- from %s: Frame size (%u words) is too short\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\ttransport_rtp, ast_sockaddr_stringify(addr), packetwords);\n\t\treturn &ast_null_frame;\n\t}\n\tposition = 0;\n\tfirst_word = ntohl(rtcpheader[position]);\n\tif ((first_word & RTCP_VALID_MASK) != RTCP_VALID_VALUE) {\n\t\tast_debug_rtcp(2, \"(%s) RTCP %p -- from %s: Failed first packet validity check\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\ttransport_rtp, ast_sockaddr_stringify(addr));\n\t\treturn &ast_null_frame;\n\t}\n\tdo {\n\t\tposition += ((first_word >> RTCP_LENGTH_SHIFT) & RTCP_LENGTH_MASK) + 1;\n\t\tif (packetwords <= position) {\n\t\t\tbreak;\n\t\t}\n\t\tfirst_word = ntohl(rtcpheader[position]);\n\t} while ((first_word & RTCP_VERSION_MASK_SHIFTED) == RTCP_VERSION_SHIFTED);\n\tif (position != packetwords) {\n\t\tast_debug_rtcp(2, \"(%s) RTCP %p -- from %s: Failed packet version or length check\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\ttransport_rtp, ast_sockaddr_stringify(addr));\n\t\treturn &ast_null_frame;\n\t}\n\n\t/*\n\t * Note: RFC3605 points out that true NAT (vs NAPT) can cause RTCP\n\t * to have a different IP address and port than RTP.  Otherwise, when\n\t * strictrtp is enabled we could reject RTCP packets not coming from\n\t * the learned RTP IP address if it is available.\n\t */\n\n\t/*\n\t * strictrtp safety needs SSRC to match before we use the\n\t * sender's address for symmetrical RTP to send our RTCP\n\t * reports.\n\t *\n\t * If strictrtp is not enabled then claim to have already seen\n\t * a matching SSRC so we'll accept this packet's address for\n\t * symmetrical RTP.\n\t */\n\tssrc_seen = transport_rtp->strict_rtp_state == STRICT_RTP_OPEN;\n\n\tposition = 0;\n\twhile (position < packetwords) {\n\t\tunsigned int i;\n\t\tunsigned int pt;\n\t\tunsigned int rc;\n\t\tunsigned int ssrc;\n\t\t/*! True if the ssrc value we have is valid and not garbage because it doesn't exist. */\n\t\tunsigned int ssrc_valid;\n\t\tunsigned int length;\n\t\tunsigned int min_length;\n\t\t/*! Always use packet source SSRC to find the rtp instance unless explicitly told not to. */\n\t\tunsigned int use_packet_source = 1;\n\n\t\tstruct ast_json *message_blob;\n\t\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\t\tstruct ast_rtp_instance *child;\n\t\tstruct ast_rtp *rtp;\n\t\tstruct ast_rtp_rtcp_feedback *feedback;\n\n\t\ti = position;\n\t\tfirst_word = ntohl(rtcpheader[i]);\n\t\tpt = (first_word >> RTCP_PAYLOAD_TYPE_SHIFT) & RTCP_PAYLOAD_TYPE_MASK;\n\t\trc = (first_word >> RTCP_REPORT_COUNT_SHIFT) & RTCP_REPORT_COUNT_MASK;\n\t\t/* RFC3550 says 'length' is the number of words in the packet - 1 */\n\t\tlength = ((first_word >> RTCP_LENGTH_SHIFT) & RTCP_LENGTH_MASK) + 1;\n\n\t\t/* Check expected RTCP packet record length */\n\t\tmin_length = RTCP_HEADER_SSRC_LENGTH;\n\t\tswitch (pt) {\n\t\tcase RTCP_PT_SR:\n\t\t\tmin_length += RTCP_SR_BLOCK_WORD_LENGTH;\n\t\t\t/* fall through */\n\t\tcase RTCP_PT_RR:\n\t\t\tmin_length += (rc * RTCP_RR_BLOCK_WORD_LENGTH);\n\t\t\tuse_packet_source = 0;\n\t\t\tbreak;\n\t\tcase RTCP_PT_FUR:\n\t\t\tbreak;\n\t\tcase AST_RTP_RTCP_RTPFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_NACK:\n\t\t\t\tmin_length += RTCP_FB_NACK_BLOCK_WORD_LENGTH;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuse_packet_source = 0;\n\t\t\tbreak;\n\t\tcase RTCP_PT_PSFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_REMB:\n\t\t\t\tmin_length += RTCP_FB_REMB_BLOCK_WORD_LENGTH;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTCP_PT_SDES:\n\t\tcase RTCP_PT_BYE:\n\t\t\t/*\n\t\t\t * There may not be a SSRC/CSRC present.  The packet is\n\t\t\t * useless but still valid if it isn't present.\n\t\t\t *\n\t\t\t * We don't know what min_length should be so disable the check\n\t\t\t */\n\t\t\tmin_length = length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_debug_rtcp(1, \"(%p) RTCP %p -- from %s: %u(%s) skipping record\\n\",\n\t\t\t\tinstance, transport_rtp, ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt));\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"\\n\");\n\t\t\t\tast_verbose(\"RTCP from %s: %u(%s) skipping record\\n\",\n\t\t\t\t\tast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt));\n\t\t\t}\n\t\t\tposition += length;\n\t\t\tcontinue;\n\t\t}\n\t\tif (length < min_length) {\n\t\t\tast_debug_rtcp(1, \"(%p) RTCP %p -- from %s: %u(%s) length field less than expected minimum.  Min:%u Got:%u\\n\",\n\t\t\t\tinstance, transport_rtp, ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt),\n\t\t\t\tmin_length - 1, length - 1);\n\t\t\treturn &ast_null_frame;\n\t\t}\n\n\t\t/* Get the RTCP record SSRC if defined for the record */\n\t\tssrc_valid = 1;\n\t\tswitch (pt) {\n\t\tcase RTCP_PT_SR:\n\t\tcase RTCP_PT_RR:\n\t\t\trtcp_report = ast_rtp_rtcp_report_alloc(rc);\n\t\t\tif (!rtcp_report) {\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\t\t\trtcp_report->reception_report_count = rc;\n\n\t\t\tssrc = ntohl(rtcpheader[i + 2]);\n\t\t\trtcp_report->ssrc = ssrc;\n\t\t\tbreak;\n\t\tcase RTCP_PT_FUR:\n\t\tcase RTCP_PT_PSFB:\n\t\t\tssrc = ntohl(rtcpheader[i + 1]);\n\t\t\tbreak;\n\t\tcase AST_RTP_RTCP_RTPFB:\n\t\t\tssrc = ntohl(rtcpheader[i + 2]);\n\t\t\tbreak;\n\t\tcase RTCP_PT_SDES:\n\t\tcase RTCP_PT_BYE:\n\t\tdefault:\n\t\t\tssrc = 0;\n\t\t\tssrc_valid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\tconst char *subtype = rtcp_payload_subtype2str(pt, rc);\n\n\t\t\tast_verbose(\"\\n\");\n\t\t\tast_verbose(\"RTCP from %s\\n\", ast_sockaddr_stringify(addr));\n\t\t\tast_verbose(\"PT: %u (%s)\\n\", pt, rtcp_payload_type2str(pt));\n\t\t\tif (subtype) {\n\t\t\t\tast_verbose(\"Packet Subtype: %u (%s)\\n\", rc, subtype);\n\t\t\t} else {\n\t\t\t\tast_verbose(\"Reception reports: %u\\n\", rc);\n\t\t\t}\n\t\t\tast_verbose(\"SSRC of sender: %u\\n\", ssrc);\n\t\t}\n\n\t\t/* Determine the appropriate instance for this */\n\t\tif (ssrc_valid) {\n\t\t\t/*\n\t\t\t * Depending on the payload type, either the packet source or media source\n\t\t\t * SSRC is used.\n\t\t\t */\n\t\t\tif (use_packet_source) {\n\t\t\t\tchild = rtp_find_instance_by_packet_source_ssrc(transport, transport_rtp, ssrc);\n\t\t\t} else {\n\t\t\t\tchild = rtp_find_instance_by_media_source_ssrc(transport, transport_rtp, ssrc);\n\t\t\t}\n\t\t\tif (child && child != transport) {\n\t\t\t\t/*\n\t\t\t\t * It is safe to hold the child lock while holding the parent lock.\n\t\t\t\t * We guarantee that the locking order is always parent->child or\n\t\t\t\t * that the child lock is not held when acquiring the parent lock.\n\t\t\t\t */\n\t\t\t\tao2_lock(child);\n\t\t\t\tinstance = child;\n\t\t\t\trtp = ast_rtp_instance_get_data(instance);\n\t\t\t} else {\n\t\t\t\t/* The child is the parent! We don't need to unlock it. */\n\t\t\t\tchild = NULL;\n\t\t\t\trtp = transport_rtp;\n\t\t\t}\n\t\t} else {\n\t\t\tchild = NULL;\n\t\t\trtp = transport_rtp;\n\t\t}\n\n\t\tif (ssrc_valid && rtp->themssrc_valid) {\n\t\t\t/*\n\t\t\t * If the SSRC is 1, we still need to handle RTCP since this could be a\n\t\t\t * special case. For example, if we have a unidirectional video stream, the\n\t\t\t * SSRC may be set to 1 by the browser (in the case of chromium), and requests\n\t\t\t * will still need to be processed so that video can flow as expected. This\n\t\t\t * should only be done for PLI and FUR, since there is not a way to get the\n\t\t\t * appropriate rtp instance when the SSRC is 1.\n\t\t\t */\n\t\t\tint exception = (ssrc == 1 && !((pt == RTCP_PT_PSFB && rc == AST_RTP_RTCP_FMT_PLI) || pt == RTCP_PT_FUR));\n\t\t\tif ((ssrc != rtp->themssrc && use_packet_source && ssrc != 1)\n\t\t\t\t\t|| exception) {\n\t\t\t\t/*\n\t\t\t\t * Skip over this RTCP record as it does not contain the\n\t\t\t\t * correct SSRC.  We should not act upon RTCP records\n\t\t\t\t * for a different stream.\n\t\t\t\t */\n\t\t\t\tposition += length;\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP %p -- from %s: Skipping record, received SSRC '%u' != expected '%u'\\n\",\n\t\t\t\t\tinstance, rtp, ast_sockaddr_stringify(addr), ssrc, rtp->themssrc);\n\t\t\t\tif (child) {\n\t\t\t\t\tao2_unlock(child);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tssrc_seen = 1;\n\t\t}\n\n\t\tif (ssrc_seen && ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {\n\t\t\t/* Send to whoever sent to us */\n\t\t\tif (ast_sockaddr_cmp(&rtp->rtcp->them, addr)) {\n\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, addr);\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\t\tast_debug(0, \"(%p) RTCP NAT: Got RTCP from other end. Now sending to address %s\\n\",\n\t\t\t\t\t\tinstance, ast_sockaddr_stringify(addr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti += RTCP_HEADER_SSRC_LENGTH; /* Advance past header and ssrc */\n\t\tswitch (pt) {\n\t\tcase RTCP_PT_SR:\n\t\t\tgettimeofday(&rtp->rtcp->rxlsr, NULL);\n\t\t\trtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16);\n\t\t\trtp->rtcp->spc = ntohl(rtcpheader[i + 3]);\n\t\t\trtp->rtcp->soc = ntohl(rtcpheader[i + 4]);\n\n\t\t\trtcp_report->type = RTCP_PT_SR;\n\t\t\trtcp_report->sender_information.packet_count = rtp->rtcp->spc;\n\t\t\trtcp_report->sender_information.octet_count = rtp->rtcp->soc;\n\t\t\tntp2timeval((unsigned int)ntohl(rtcpheader[i]),\n\t\t\t\t\t(unsigned int)ntohl(rtcpheader[i + 1]),\n\t\t\t\t\t&rtcp_report->sender_information.ntp_timestamp);\n\t\t\trtcp_report->sender_information.rtp_timestamp = ntohl(rtcpheader[i + 2]);\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"NTP timestamp: %u.%06u\\n\",\n\t\t\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,\n\t\t\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);\n\t\t\t\tast_verbose(\"RTP timestamp: %u\\n\", rtcp_report->sender_information.rtp_timestamp);\n\t\t\t\tast_verbose(\"SPC: %u\\tSOC: %u\\n\",\n\t\t\t\t\t\trtcp_report->sender_information.packet_count,\n\t\t\t\t\t\trtcp_report->sender_information.octet_count);\n\t\t\t}\n\t\t\ti += RTCP_SR_BLOCK_WORD_LENGTH;\n\t\t\t/* Intentional fall through */\n\t\tcase RTCP_PT_RR:\n\t\t\tif (rtcp_report->type != RTCP_PT_SR) {\n\t\t\t\trtcp_report->type = RTCP_PT_RR;\n\t\t\t}\n\n\t\t\tif (rc > 0) {\n\t\t\t\t/* Don't handle multiple reception reports (rc > 1) yet */\n\t\t\t\treport_block = ast_calloc(1, sizeof(*report_block));\n\t\t\t\tif (!report_block) {\n\t\t\t\t\tif (child) {\n\t\t\t\t\t\tao2_unlock(child);\n\t\t\t\t\t}\n\t\t\t\t\treturn &ast_null_frame;\n\t\t\t\t}\n\t\t\t\trtcp_report->report_block[0] = report_block;\n\t\t\t\treport_block->source_ssrc = ntohl(rtcpheader[i]);\n\t\t\t\treport_block->lost_count.packets = ntohl(rtcpheader[i + 1]) & 0x00ffffff;\n\t\t\t\treport_block->lost_count.fraction = ((ntohl(rtcpheader[i + 1]) & 0xff000000) >> 24);\n\t\t\t\treport_block->highest_seq_no = ntohl(rtcpheader[i + 2]);\n\t\t\t\treport_block->ia_jitter =  ntohl(rtcpheader[i + 3]);\n\t\t\t\treport_block->lsr = ntohl(rtcpheader[i + 4]);\n\t\t\t\treport_block->dlsr = ntohl(rtcpheader[i + 5]);\n\t\t\t\tif (report_block->lsr) {\n\t\t\t\t\tint skewed = update_rtt_stats(rtp, report_block->lsr, report_block->dlsr);\n\t\t\t\t\tif (skewed && rtcp_debug_test_addr(addr)) {\n\t\t\t\t\t\tstruct timeval now;\n\t\t\t\t\t\tunsigned int lsr_now, lsw, msw;\n\t\t\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\t\t\ttimeval2ntp(now, &msw, &lsw);\n\t\t\t\t\t\tlsr_now = (((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16));\n\t\t\t\t\t\tast_verbose(\"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t\t\t\t\"lsr=%u, now=%u, dlsr=%u (%u:%03ums), \"\n\t\t\t\t\t\t\t\"diff=%u\\n\",\n\t\t\t\t\t\t\treport_block->lsr, lsr_now, report_block->dlsr, report_block->dlsr / 65536,\n\t\t\t\t\t\t\t(report_block->dlsr % 65536) * 1000 / 65536,\n\t\t\t\t\t\t\treport_block->dlsr - (lsr_now - report_block->lsr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tupdate_jitter_stats(rtp, report_block->ia_jitter);\n\t\t\t\tupdate_lost_stats(rtp, report_block->lost_count.packets);\n\t\t\t\t/*\n\t\t\t\t * update_reported_mes_stats must be called AFTER\n\t\t\t\t * update_rtt_stats, update_jitter_stats and\n\t\t\t\t * update_lost_stats.\n\t\t\t\t */\n\t\t\t\tupdate_reported_mes_stats(rtp);\n\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\n\t\t\t\t\tast_verbose(\"  Fraction lost: %d\\n\", report_block->lost_count.fraction);\n\t\t\t\t\tast_verbose(\"  Packets lost so far: %u\\n\", report_block->lost_count.packets);\n\t\t\t\t\tast_verbose(\"  Highest sequence number: %u\\n\", report_block->highest_seq_no & 0x0000ffff);\n\t\t\t\t\tast_verbose(\"  Sequence number cycles: %u\\n\", report_block->highest_seq_no >> 16);\n\t\t\t\t\tast_verbose(\"  Interarrival jitter (samp): %u\\n\", report_block->ia_jitter);\n\t\t\t\t\tast_verbose(\"  Interarrival jitter (secs): %.6f\\n\", ast_samp2sec(report_block->ia_jitter, rate));\n\t\t\t\t\tast_verbose(\"  Last SR(our NTP): %lu.%010lu\\n\",(unsigned long)(report_block->lsr) >> 16,((unsigned long)(report_block->lsr) << 16) * 4096);\n\t\t\t\t\tast_verbose(\"  DLSR: %4.4f (sec)\\n\",(double)report_block->dlsr / 65536.0);\n\t\t\t\t\tast_verbose(\"  RTT: %4.4f(sec)\\n\", rtp->rtcp->rtt);\n\t\t\t\t\tast_verbose(\"  MES: %4.1f\\n\", rtp->rtcp->reported_mes);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If and when we handle more than one report block, this should occur outside\n\t\t\t * this loop.\n\t\t\t */\n\n\t\t\tmessage_blob = ast_json_pack(\"{s: s, s: s, s: f, s: f}\",\n\t\t\t\t\"from\", ast_sockaddr_stringify(addr),\n\t\t\t\t\"to\", transport_rtp->rtcp->local_addr_str,\n\t\t\t\t\"rtt\", rtp->rtcp->rtt,\n\t\t\t\t\"mes\", rtp->rtcp->reported_mes);\n\t\t\tast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_received_type(),\n\t\t\t\t\trtcp_report,\n\t\t\t\t\tmessage_blob);\n\t\t\tast_json_unref(message_blob);\n\n\t\t\t/* Return an AST_FRAME_RTCP frame with the ast_rtp_rtcp_report\n\t\t\t * object as a its data */\n\t\t\ttransport_rtp->f.frametype = AST_FRAME_RTCP;\n\t\t\ttransport_rtp->f.subclass.integer = pt;\n\t\t\ttransport_rtp->f.data.ptr = rtp->rtcp->frame_buf + AST_FRIENDLY_OFFSET;\n\t\t\tmemcpy(transport_rtp->f.data.ptr, rtcp_report, sizeof(struct ast_rtp_rtcp_report));\n\t\t\ttransport_rtp->f.datalen = sizeof(struct ast_rtp_rtcp_report);\n\t\t\tif (rc > 0) {\n\t\t\t\t/* There's always a single report block stored, here */\n\t\t\t\tstruct ast_rtp_rtcp_report *rtcp_report2;\n\t\t\t\treport_block = transport_rtp->f.data.ptr + transport_rtp->f.datalen + sizeof(struct ast_rtp_rtcp_report_block *);\n\t\t\t\tmemcpy(report_block, rtcp_report->report_block[0], sizeof(struct ast_rtp_rtcp_report_block));\n\t\t\t\trtcp_report2 = (struct ast_rtp_rtcp_report *)transport_rtp->f.data.ptr;\n\t\t\t\trtcp_report2->report_block[0] = report_block;\n\t\t\t\ttransport_rtp->f.datalen += sizeof(struct ast_rtp_rtcp_report_block);\n\t\t\t}\n\t\t\ttransport_rtp->f.offset = AST_FRIENDLY_OFFSET;\n\t\t\ttransport_rtp->f.samples = 0;\n\t\t\ttransport_rtp->f.mallocd = 0;\n\t\t\ttransport_rtp->f.delivery.tv_sec = 0;\n\t\t\ttransport_rtp->f.delivery.tv_usec = 0;\n\t\t\ttransport_rtp->f.src = \"RTP\";\n\t\t\ttransport_rtp->f.stream_num = rtp->stream_num;\n\t\t\tf = &transport_rtp->f;\n\t\t\tbreak;\n\t\tcase AST_RTP_RTCP_RTPFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_NACK:\n\t\t\t\t/* If retransmissions are not enabled ignore this message */\n\t\t\t\tif (!rtp->send_buffer) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tast_verbose(\"Received generic RTCP NACK message\\n\");\n\t\t\t\t}\n\n\t\t\t\tast_rtp_rtcp_handle_nack(instance, rtcpheader, position, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTCP_PT_FUR:\n\t\t\t/* Handle RTCP FUR as FIR by setting the format to 4 */\n\t\t\trc = AST_RTP_RTCP_FMT_FIR;\n\t\tcase RTCP_PT_PSFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_PLI:\n\t\t\tcase AST_RTP_RTCP_FMT_FIR:\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tast_verbose(\"Received an RTCP Fast Update Request\\n\");\n\t\t\t\t}\n\t\t\t\ttransport_rtp->f.frametype = AST_FRAME_CONTROL;\n\t\t\t\ttransport_rtp->f.subclass.integer = AST_CONTROL_VIDUPDATE;\n\t\t\t\ttransport_rtp->f.datalen = 0;\n\t\t\t\ttransport_rtp->f.samples = 0;\n\t\t\t\ttransport_rtp->f.mallocd = 0;\n\t\t\t\ttransport_rtp->f.src = \"RTP\";\n\t\t\t\tf = &transport_rtp->f;\n\t\t\t\tbreak;\n\t\t\tcase AST_RTP_RTCP_FMT_REMB:\n\t\t\t\t/* If REMB support is not enabled ignore this message */\n\t\t\t\tif (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_REMB)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tast_verbose(\"Received REMB report\\n\");\n\t\t\t\t}\n\t\t\t\ttransport_rtp->f.frametype = AST_FRAME_RTCP;\n\t\t\t\ttransport_rtp->f.subclass.integer = pt;\n\t\t\t\ttransport_rtp->f.stream_num = rtp->stream_num;\n\t\t\t\ttransport_rtp->f.data.ptr = rtp->rtcp->frame_buf + AST_FRIENDLY_OFFSET;\n\t\t\t\tfeedback = transport_rtp->f.data.ptr;\n\t\t\t\tfeedback->fmt = rc;\n\n\t\t\t\t/* We don't actually care about the SSRC information in the feedback message */\n\t\t\t\tfirst_word = ntohl(rtcpheader[i + 2]);\n\t\t\t\tfeedback->remb.br_exp = (first_word >> 18) & ((1 << 6) - 1);\n\t\t\t\tfeedback->remb.br_mantissa = first_word & ((1 << 18) - 1);\n\n\t\t\t\ttransport_rtp->f.datalen = sizeof(struct ast_rtp_rtcp_feedback);\n\t\t\t\ttransport_rtp->f.offset = AST_FRIENDLY_OFFSET;\n\t\t\t\ttransport_rtp->f.samples = 0;\n\t\t\t\ttransport_rtp->f.mallocd = 0;\n\t\t\t\ttransport_rtp->f.delivery.tv_sec = 0;\n\t\t\t\ttransport_rtp->f.delivery.tv_usec = 0;\n\t\t\t\ttransport_rtp->f.src = \"RTP\";\n\t\t\t\tf = &transport_rtp->f;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTCP_PT_SDES:\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"Received an SDES from %s\\n\",\n\t\t\t\t\tast_sockaddr_stringify(addr));\n\t\t\t}\n#ifdef TEST_FRAMEWORK\n\t\t\tif ((test_engine = ast_rtp_instance_get_test(instance))) {\n\t\t\t\ttest_engine->sdes_received = 1;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase RTCP_PT_BYE:\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"Received a BYE from %s\\n\",\n\t\t\t\t\tast_sockaddr_stringify(addr));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tposition += length;\n\t\trtp->rtcp->rtcp_info = 1;\n\n\t\tif (child) {\n\t\t\tao2_unlock(child);\n\t\t}\n\t}\n\n\treturn f;\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_srtp *srtp = ast_rtp_instance_get_srtp(instance, 1);\n\tstruct ast_sockaddr addr;\n\tunsigned char rtcpdata[8192 + AST_FRIENDLY_OFFSET];\n\tunsigned char *read_area = rtcpdata + AST_FRIENDLY_OFFSET;\n\tsize_t read_area_size = sizeof(rtcpdata) - AST_FRIENDLY_OFFSET;\n\tint res;\n\n\t/* Read in RTCP data from the socket */\n\tif ((res = rtcp_recvfrom(instance, read_area, read_area_size,\n\t\t\t\t0, &addr)) < 0) {\n\t\tif (res == RTP_DTLS_ESTABLISHED) {\n\t\t\trtp->f.frametype = AST_FRAME_CONTROL;\n\t\t\trtp->f.subclass.integer = AST_CONTROL_SRCCHANGE;\n\t\t\treturn &rtp->f;\n\t\t}\n\n\t\tast_assert(errno != EBADF);\n\t\tif (errno != EAGAIN) {\n\t\t\tast_log(LOG_WARNING, \"RTCP Read error: %s.  Hanging up.\\n\",\n\t\t\t\t(errno) ? strerror(errno) : \"Unspecified\");\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If this was handled by the ICE session don't do anything further */\n\tif (!res) {\n\t\treturn &ast_null_frame;\n\t}\n\n\tif (!*read_area) {\n\t\tstruct sockaddr_in addr_tmp;\n\t\tstruct ast_sockaddr addr_v4;\n\n\t\tif (ast_sockaddr_is_ipv4(&addr)) {\n\t\t\tast_sockaddr_to_sin(&addr, &addr_tmp);\n\t\t} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {\n\t\t\tast_debug_stun(2, \"(%p) STUN using IPv6 mapped address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\tast_sockaddr_to_sin(&addr_v4, &addr_tmp);\n\t\t} else {\n\t\t\tast_debug_stun(2, \"(%p) STUN cannot do for non IPv4 address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\treturn &ast_null_frame;\n\t\t}\n\t\tif ((ast_stun_handle_packet(rtp->rtcp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT)) {\n\t\t\tast_sockaddr_from_sin(&addr, &addr_tmp);\n\t\t\tast_sockaddr_copy(&rtp->rtcp->them, &addr);\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\treturn ast_rtcp_interpret(instance, srtp, read_area, res, &addr);\n}\n\n/*! \\pre instance is locked */\nstatic int bridge_p2p_rtp_write(struct ast_rtp_instance *instance,\n\tstruct ast_rtp_instance *instance1, unsigned int *rtpheader, int len, int hdrlen)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp *bridged;\n\tint res = 0, payload = 0, bridged_payload = 0, mark;\n\tRAII_VAR(struct ast_rtp_payload_type *, payload_type, NULL, ao2_cleanup);\n\tint reconstruct = ntohl(rtpheader[0]);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint ice;\n\tunsigned int timestamp = ntohl(rtpheader[1]);\n\n\t/* Get fields from packet */\n\tpayload = (reconstruct & 0x7f0000) >> 16;\n\tmark = (reconstruct & 0x800000) >> 23;\n\n\t/* Check what the payload value should be */\n\tpayload_type = ast_rtp_codecs_get_payload(ast_rtp_instance_get_codecs(instance), payload);\n\tif (!payload_type) {\n\t\treturn -1;\n\t}\n\n\t/* Otherwise adjust bridged payload to match */\n\tbridged_payload = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance1),\n\t\tpayload_type->asterisk_format, payload_type->format, payload_type->rtp_code);\n\n\t/* If no codec could be matched between instance and instance1, then somehow things were made incompatible while we were still bridged.  Bail. */\n\tif (bridged_payload < 0) {\n\t\treturn -1;\n\t}\n\n\t/* If the payload coming in is not one of the negotiated ones then send it to the core, this will cause formats to change and the bridge to break */\n\tif (ast_rtp_codecs_find_payload_code(ast_rtp_instance_get_codecs(instance1), bridged_payload) == -1) {\n\t\tast_debug_rtp(1, \"(%p, %p) RTP unsupported payload type received\\n\", instance, instance1);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Even if we are no longer in dtmf, we could still be receiving\n\t * re-transmissions of the last dtmf end still.  Feed those to the\n\t * core so they can be filtered accordingly.\n\t */\n\tif (rtp->last_end_timestamp.is_set && rtp->last_end_timestamp.ts == timestamp) {\n\t\tast_debug_rtp(1, \"(%p, %p) RTP feeding packet with duplicate timestamp to core\\n\", instance, instance1);\n\t\treturn -1;\n\t}\n\n\tif (payload_type->asterisk_format) {\n\t\tao2_replace(rtp->lastrxformat, payload_type->format);\n\t}\n\n\t/*\n\t * We have now determined that we need to send the RTP packet\n\t * out the bridged instance to do local bridging so we must unlock\n\t * the receiving instance to prevent deadlock with the bridged\n\t * instance.\n\t *\n\t * Technically we should grab a ref to instance1 so it won't go\n\t * away on us.  However, we should be safe because the bridged\n\t * instance won't change without both channels involved being\n\t * locked and we currently have the channel lock for the receiving\n\t * instance.\n\t */\n\tao2_unlock(instance);\n\tao2_lock(instance1);\n\n\t/*\n\t * Get the peer rtp pointer now to emphasize that using it\n\t * must happen while instance1 is locked.\n\t */\n\tbridged = ast_rtp_instance_get_data(instance1);\n\n\n\t/* If bridged peer is in dtmf, feed all packets to core until it finishes to avoid infinite dtmf */\n\tif (bridged->sending_digit) {\n\t\tast_debug_rtp(1, \"(%p, %p) RTP Feeding packet to core until DTMF finishes\\n\", instance, instance1);\n\t\tao2_unlock(instance1);\n\t\tao2_lock(instance);\n\t\treturn -1;\n\t}\n\n\tif (payload_type->asterisk_format) {\n\t\t/*\n\t\t * If bridged peer has already received rtp, perform the asymmetric codec check\n\t\t * if that feature has been activated\n\t\t */\n\t\tif (!bridged->asymmetric_codec\n\t\t\t&& bridged->lastrxformat != ast_format_none\n\t\t\t&& ast_format_cmp(payload_type->format, bridged->lastrxformat) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t\tast_debug_rtp(1, \"(%p, %p) RTP asymmetric RTP codecs detected (TX: %s, RX: %s) sending frame to core\\n\",\n\t\t\t\tinstance, instance1, ast_format_get_name(payload_type->format),\n\t\t\t\tast_format_get_name(bridged->lastrxformat));\n\t\t\tao2_unlock(instance1);\n\t\t\tao2_lock(instance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tao2_replace(bridged->lasttxformat, payload_type->format);\n\t}\n\n\tast_rtp_instance_get_remote_address(instance1, &remote_address);\n\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\tast_debug_rtp(5, \"(%p, %p) RTP remote address is null, most likely RTP has been stopped\\n\",\n\t\t\tinstance, instance1);\n\t\tao2_unlock(instance1);\n\t\tao2_lock(instance);\n\t\treturn 0;\n\t}\n\n\t/* If the marker bit has been explicitly set turn it on */\n\tif (ast_test_flag(bridged, FLAG_NEED_MARKER_BIT)) {\n\t\tmark = 1;\n\t\tast_clear_flag(bridged, FLAG_NEED_MARKER_BIT);\n\t}\n\n\t/* Set the marker bit for the first local bridged packet which has the first bridged peer's SSRC. */\n\tif (ast_test_flag(bridged, FLAG_REQ_LOCAL_BRIDGE_BIT)) {\n\t\tmark = 1;\n\t\tast_clear_flag(bridged, FLAG_REQ_LOCAL_BRIDGE_BIT);\n\t}\n\n\t/* Reconstruct part of the packet */\n\treconstruct &= 0xFF80FFFF;\n\treconstruct |= (bridged_payload << 16);\n\treconstruct |= (mark << 23);\n\trtpheader[0] = htonl(reconstruct);\n\n\tif (mark) {\n\t\t/* make this rtp instance aware of the new ssrc it is sending */\n\t\tbridged->ssrc = ntohl(rtpheader[2]);\n\t}\n\n\t/* Send the packet back out */\n\tres = rtp_sendto(instance1, (void *)rtpheader, len, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tif (!ast_rtp_instance_get_prop(instance1, AST_RTP_PROPERTY_NAT) || (ast_rtp_instance_get_prop(instance1, AST_RTP_PROPERTY_NAT) && (ast_test_flag(bridged, FLAG_NAT_ACTIVE) == FLAG_NAT_ACTIVE))) {\n\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\"RTP Transmission error of packet to %s: %s\\n\",\n\t\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\t\tstrerror(errno));\n\t\t} else if (((ast_test_flag(bridged, FLAG_NAT_ACTIVE) == FLAG_NAT_INACTIVE) || ast_debug_rtp_packet_is_allowed) && !ast_test_flag(bridged, FLAG_NAT_INACTIVE_NOWARN)) {\n\t\t\tif (ast_debug_rtp_packet_is_allowed || DEBUG_ATLEAST(1)) {\n\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"RTP NAT: Can't write RTP to private \"\n\t\t\t\t\t\"address %s, waiting for other end to \"\n\t\t\t\t\t\"send audio...\\n\",\n\t\t\t\t\tast_sockaddr_stringify(&remote_address));\n\t\t\t}\n\t\t\tast_set_flag(bridged, FLAG_NAT_INACTIVE_NOWARN);\n\t\t}\n\t\tao2_unlock(instance1);\n\t\tao2_lock(instance);\n\t\treturn 0;\n\t}\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Sent RTP P2P packet to %s%s (type %-2.2d, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t    bridged_payload, len - hdrlen);\n\t}\n\n\tao2_unlock(instance1);\n\tao2_lock(instance);\n\treturn 0;\n}\n\nstatic void rtp_instance_unlock(struct ast_rtp_instance *instance)\n{\n\tif (instance) {\n\t\tao2_unlock(instance);\n\t}\n}\n\nstatic int rtp_transport_wide_cc_packet_statistics_cmp(struct rtp_transport_wide_cc_packet_statistics a,\n\tstruct rtp_transport_wide_cc_packet_statistics b)\n{\n\treturn a.seqno - b.seqno;\n}\n\nstatic void rtp_transport_wide_cc_feedback_status_vector_append(unsigned char *rtcpheader, int *packet_len, int *status_vector_chunk_bits,\n\tuint16_t *status_vector_chunk, int status)\n{\n\t/* Appending this status will use up 2 bits */\n\t*status_vector_chunk_bits -= 2;\n\n\t/* We calculate which bits we want to update the status of. Since a status vector\n\t * is 16 bits we take away 2 (for the header), and then we take away any that have\n\t * already been used.\n\t */\n\t*status_vector_chunk |= (status << (16 - 2 - (14 - *status_vector_chunk_bits)));\n\n\t/* If there are still bits available we can return early */\n\tif (*status_vector_chunk_bits) {\n\t\treturn;\n\t}\n\n\t/* Otherwise we have to place this chunk into the packet */\n\tput_unaligned_uint16(rtcpheader + *packet_len, htons(*status_vector_chunk));\n\t*status_vector_chunk_bits = 14;\n\n\t/* The first bit being 1 indicates that this is a status vector chunk and the second\n\t * bit being 1 indicates that we are using 2 bits to represent each status for a\n\t * packet.\n\t */\n\t*status_vector_chunk = (1 << 15) | (1 << 14);\n\t*packet_len += 2;\n}\n\nstatic void rtp_transport_wide_cc_feedback_status_append(unsigned char *rtcpheader, int *packet_len, int *status_vector_chunk_bits,\n\tuint16_t *status_vector_chunk, int *run_length_chunk_count, int *run_length_chunk_status, int status)\n{\n\tif (*run_length_chunk_status != status) {\n\t\twhile (*run_length_chunk_count > 0 && *run_length_chunk_count < 8) {\n\t\t\t/* Realistically it only makes sense to use a run length chunk if there were 8 or more\n\t\t\t * consecutive packets of the same type, otherwise we could end up making the packet larger\n\t\t\t * if we have lots of small blocks of the same type. To help with this we backfill the status\n\t\t\t * vector (since it always represents 7 packets). Best case we end up with only that single\n\t\t\t * status vector and the rest are run length chunks.\n\t\t\t */\n\t\t\trtp_transport_wide_cc_feedback_status_vector_append(rtcpheader, packet_len, status_vector_chunk_bits,\n\t\t\t\tstatus_vector_chunk, *run_length_chunk_status);\n\t\t\t*run_length_chunk_count -= 1;\n\t\t}\n\n\t\tif (*run_length_chunk_count) {\n\t\t\t/* There is a run length chunk which needs to be written out */\n\t\t\tput_unaligned_uint16(rtcpheader + *packet_len, htons((0 << 15) | (*run_length_chunk_status << 13) | *run_length_chunk_count));\n\t\t\t*packet_len += 2;\n\t\t}\n\n\t\t/* In all cases the run length chunk has to be reset */\n\t\t*run_length_chunk_count = 0;\n\t\t*run_length_chunk_status = -1;\n\n\t\tif (*status_vector_chunk_bits == 14) {\n\t\t\t/* We aren't in the middle of a status vector so we can try for a run length chunk */\n\t\t\t*run_length_chunk_status = status;\n\t\t\t*run_length_chunk_count = 1;\n\t\t} else {\n\t\t\t/* We're doing a status vector so populate it accordingly */\n\t\t\trtp_transport_wide_cc_feedback_status_vector_append(rtcpheader, packet_len, status_vector_chunk_bits,\n\t\t\t\tstatus_vector_chunk, status);\n\t\t}\n\t} else {\n\t\t/* This is easy, the run length chunk count can just get bumped up */\n\t\t*run_length_chunk_count += 1;\n\t}\n}\n\nstatic int rtp_transport_wide_cc_feedback_produce(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tunsigned char *rtcpheader;\n\tchar bdata[1024];\n\tstruct rtp_transport_wide_cc_packet_statistics *first_packet;\n\tstruct rtp_transport_wide_cc_packet_statistics *previous_packet;\n\tint i;\n\tint status_vector_chunk_bits = 14;\n\tuint16_t status_vector_chunk = (1 << 15) | (1 << 14);\n\tint run_length_chunk_count = 0;\n\tint run_length_chunk_status = -1;\n\tint packet_len = 20;\n\tint delta_len = 0;\n\tint packet_count = 0;\n\tunsigned int received_msw;\n\tunsigned int received_lsw;\n\tstruct ast_sockaddr remote_address = { { 0, } };\n\tint res;\n\tint ice;\n\tunsigned int large_delta_count = 0;\n\tunsigned int small_delta_count = 0;\n\tunsigned int lost_count = 0;\n\n\tif (!rtp || !rtp->rtcp || rtp->transport_wide_cc.schedid == -1) {\n\t\tao2_ref(instance, -1);\n\t\treturn 0;\n\t}\n\n\tao2_lock(instance);\n\n\t/* If no packets have been received then do nothing */\n\tif (!AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics)) {\n\t\tao2_unlock(instance);\n\t\treturn 1000;\n\t}\n\n\trtcpheader = (unsigned char *)bdata;\n\n\t/* The first packet in the vector acts as our base sequence number and reference time */\n\tfirst_packet = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, 0);\n\tprevious_packet = first_packet;\n\n\t/* We go through each packet that we have statistics for, adding it either to a status\n\t * vector chunk or a run length chunk. The code tries to be as efficient as possible to\n\t * reduce packet size and will favor run length chunks when it makes sense.\n\t */\n\tfor (i = 0; i < AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics); ++i) {\n\t\tstruct rtp_transport_wide_cc_packet_statistics *statistics;\n\t\tint lost = 0;\n\t\tint res = 0;\n\n\t\tstatistics = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, i);\n\n\t\tpacket_count++;\n\n\t\tif (first_packet != statistics) {\n\t\t\t/* The vector stores statistics in a sorted fashion based on the sequence\n\t\t\t * number. This ensures we can detect any packets that have been lost/not\n\t\t\t * received by comparing the sequence numbers.\n\t\t\t */\n\t\t\tlost = statistics->seqno - (previous_packet->seqno + 1);\n\t\t\tlost_count += lost;\n\t\t}\n\n\t\twhile (lost) {\n\t\t\t/* We append a not received status until all the lost packets have been accounted for */\n\t\t\trtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,\n\t\t\t\t&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 0);\n\t\t\tpacket_count++;\n\n\t\t\t/* If there is no more room left for storing packets stop now, we leave 20\n\t\t\t * extra bits at the end just in case.\n\t\t\t */\n\t\t\tif (packet_len + delta_len + 20 > sizeof(bdata)) {\n\t\t\t\tres = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlost--;\n\t\t}\n\n\t\t/* If the lost packet appending bailed out because we have no more space, then exit here too */\n\t\tif (res) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Per the spec the delta is in increments of 250 */\n\t\tstatistics->delta = ast_tvdiff_us(statistics->received, previous_packet->received) / 250;\n\n\t\t/* Based on the delta determine the status of this packet */\n\t\tif (statistics->delta < 0 || statistics->delta > 127) {\n\t\t\t/* Large or negative delta */\n\t\t\trtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,\n\t\t\t\t&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 2);\n\t\t\tdelta_len += 2;\n\t\t\tlarge_delta_count++;\n\t\t} else {\n\t\t\t/* Small delta */\n\t\t\trtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,\n\t\t\t\t&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 1);\n\t\t\tdelta_len += 1;\n\t\t\tsmall_delta_count++;\n\t\t}\n\n\t\tprevious_packet = statistics;\n\n\t\t/* If there is no more room left in the packet stop handling of any subsequent packets */\n\t\tif (packet_len + delta_len + 20 > sizeof(bdata)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status_vector_chunk_bits != 14) {\n\t\t/* If the status vector chunk has packets in it then place it in the RTCP packet */\n\t\tput_unaligned_uint16(rtcpheader + packet_len, htons(status_vector_chunk));\n\t\tpacket_len += 2;\n\t} else if (run_length_chunk_count) {\n\t\t/* If there is a run length chunk in progress then place it in the RTCP packet */\n\t\tput_unaligned_uint16(rtcpheader + packet_len, htons((0 << 15) | (run_length_chunk_status << 13) | run_length_chunk_count));\n\t\tpacket_len += 2;\n\t}\n\n\t/* We iterate again to build delta chunks */\n\tfor (i = 0; i < AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics); ++i) {\n\t\tstruct rtp_transport_wide_cc_packet_statistics *statistics;\n\n\t\tstatistics = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, i);\n\n\t\tif (statistics->delta < 0 || statistics->delta > 127) {\n\t\t\t/* We need 2 bytes to store this delta */\n\t\t\tput_unaligned_uint16(rtcpheader + packet_len, htons(statistics->delta));\n\t\t\tpacket_len += 2;\n\t\t} else {\n\t\t\t/* We can store this delta in 1 byte */\n\t\t\trtcpheader[packet_len] = statistics->delta;\n\t\t\tpacket_len += 1;\n\t\t}\n\n\t\t/* If this is the last packet handled by the run length chunk or status vector chunk code\n\t\t * then we can go no further.\n\t\t */\n\t\tif (statistics == previous_packet) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Zero pad the end of the packet */\n\twhile (packet_len % 4) {\n\t\trtcpheader[packet_len++] = 0;\n\t}\n\n\t/* Add the general RTCP header information */\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (AST_RTP_RTCP_FMT_TRANSPORT_WIDE_CC << 24)\n\t\t| (AST_RTP_RTCP_RTPFB << 16) | ((packet_len / 4) - 1)));\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + 8, htonl(rtp->themssrc));\n\n\t/* Add the transport-cc specific header information */\n\tput_unaligned_uint32(rtcpheader + 12, htonl((first_packet->seqno << 16) | packet_count));\n\n\ttimeval2ntp(first_packet->received, &received_msw, &received_lsw);\n\tput_unaligned_time24(rtcpheader + 16, received_msw, received_lsw);\n\trtcpheader[19] = rtp->transport_wide_cc.feedback_count;\n\n\t/* The packet is now fully constructed so send it out */\n\tast_sockaddr_copy(&remote_address, &rtp->rtcp->them);\n\n\tast_debug_rtcp(2, \"(%p) RTCP sending transport-cc feedback packet of size '%d' on '%s' with packet count of %d (small = %d, large = %d, lost = %d)\\n\",\n\t\tinstance, packet_len, ast_rtp_instance_get_channel_id(instance), packet_count, small_delta_count, large_delta_count, lost_count);\n\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP transport-cc feedback error to %s due to %s\\n\",\n\t\t\tast_sockaddr_stringify(&remote_address), strerror(errno));\n\t}\n\n\tAST_VECTOR_RESET(&rtp->transport_wide_cc.packet_statistics, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\n\trtp->transport_wide_cc.feedback_count++;\n\n\tao2_unlock(instance);\n\n\treturn 1000;\n}\n\nstatic void rtp_instance_parse_transport_wide_cc(struct ast_rtp_instance *instance, struct ast_rtp *rtp,\n\tunsigned char *data, int len)\n{\n\tuint16_t *seqno = (uint16_t *)data;\n\tstruct rtp_transport_wide_cc_packet_statistics statistics;\n\tstruct ast_rtp_instance *transport = rtp->bundled ? rtp->bundled : instance;\n\tstruct ast_rtp *transport_rtp = ast_rtp_instance_get_data(transport);\n\n\t/* If the sequence number has cycled over then record it as such */\n\tif (((int)transport_rtp->transport_wide_cc.last_seqno - (int)ntohs(*seqno)) > 100) {\n\t\ttransport_rtp->transport_wide_cc.cycles += RTP_SEQ_MOD;\n\t}\n\n\t/* Populate the statistics information for this packet */\n\tstatistics.seqno = transport_rtp->transport_wide_cc.cycles + ntohs(*seqno);\n\tstatistics.received = ast_tvnow();\n\n\t/* We allow at a maximum 1000 packet statistics in play at a time, if we hit the\n\t * limit we give up and start fresh.\n\t */\n\tif (AST_VECTOR_SIZE(&transport_rtp->transport_wide_cc.packet_statistics) > 1000) {\n\t\tAST_VECTOR_RESET(&rtp->transport_wide_cc.packet_statistics, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\t}\n\n\tif (!AST_VECTOR_SIZE(&transport_rtp->transport_wide_cc.packet_statistics) ||\n\t\tstatistics.seqno > transport_rtp->transport_wide_cc.last_extended_seqno) {\n\t\t/* This is the expected path */\n\t\tif (AST_VECTOR_APPEND(&transport_rtp->transport_wide_cc.packet_statistics, statistics)) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransport_rtp->transport_wide_cc.last_extended_seqno = statistics.seqno;\n\t\ttransport_rtp->transport_wide_cc.last_seqno = ntohs(*seqno);\n\t} else {\n\t\t/* This packet was out of order, so reorder it within the vector accordingly */\n\t\tif (AST_VECTOR_ADD_SORTED(&transport_rtp->transport_wide_cc.packet_statistics, statistics,\n\t\t\trtp_transport_wide_cc_packet_statistics_cmp)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* If we have not yet scheduled the periodic sending of feedback for this transport then do so */\n\tif (transport_rtp->transport_wide_cc.schedid < 0 && transport_rtp->rtcp) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP starting transport-cc feedback transmission on RTP instance '%p'\\n\", instance, transport);\n\t\tao2_ref(transport, +1);\n\t\ttransport_rtp->transport_wide_cc.schedid = ast_sched_add(rtp->sched, 1000,\n\t\t\trtp_transport_wide_cc_feedback_produce, transport);\n\t\tif (transport_rtp->transport_wide_cc.schedid < 0) {\n\t\t\tao2_ref(transport, -1);\n\t\t\tast_log(LOG_WARNING, \"Scheduling RTCP transport-cc feedback transmission failed on RTP instance '%p'\\n\",\n\t\t\t\ttransport);\n\t\t}\n\t}\n}\n\nstatic void rtp_instance_parse_extmap_extensions(struct ast_rtp_instance *instance, struct ast_rtp *rtp,\n\tunsigned char *extension, int len)\n{\n\tint transport_wide_cc_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_TRANSPORT_WIDE_CC);\n\tint pos = 0;\n\n\t/* We currently only care about the transport-cc extension, so if that's not negotiated then do nothing */\n\tif (transport_wide_cc_id == -1) {\n\t\treturn;\n\t}\n\n\t/* Only while we do not exceed available extension data do we continue */\n\twhile (pos < len) {\n\t\tint id = extension[pos] >> 4;\n\t\tint extension_len = (extension[pos] & 0xF) + 1;\n\n\t\t/* We've handled the first byte as it contains the extension id and length, so always\n\t\t * skip ahead now\n\t\t */\n\t\tpos += 1;\n\n\t\tif (id == 0) {\n\t\t\t/* From the RFC:\n\t\t\t * In both forms, padding bytes have the value of 0 (zero).  They may be\n\t\t\t * placed between extension elements, if desired for alignment, or after\n\t\t\t * the last extension element, if needed for padding.  A padding byte\n\t\t\t * does not supply the ID of an element, nor the length field.  When a\n\t\t\t * padding byte is found, it is ignored and the parser moves on to\n\t\t\t * interpreting the next byte.\n\t\t\t */\n\t\t\tcontinue;\n\t\t} else if (id == 15) {\n\t\t\t/* From the RFC:\n\t\t\t * The local identifier value 15 is reserved for future extension and\n\t\t\t * MUST NOT be used as an identifier.  If the ID value 15 is\n\t\t\t * encountered, its length field should be ignored, processing of the\n\t\t\t * entire extension should terminate at that point, and only the\n\t\t\t * extension elements present prior to the element with ID 15\n\t\t\t * considered.\n\t\t\t */\n\t\t\tbreak;\n\t\t} else if ((pos + extension_len) > len) {\n\t\t\t/* The extension is corrupted and is stating that it contains more data than is\n\t\t\t * available in the extensions data.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this is transport-cc then we need to parse it further */\n\t\tif (id == transport_wide_cc_id) {\n\t\t\trtp_instance_parse_transport_wide_cc(instance, rtp, extension + pos, extension_len);\n\t\t}\n\n\t\t/* Skip ahead to the next extension */\n\t\tpos += extension_len;\n\t}\n}\n\nstatic struct ast_frame *ast_rtp_interpret(struct ast_rtp_instance *instance, struct ast_srtp *srtp,\n\tconst struct ast_sockaddr *remote_address, unsigned char *read_area, int length, int prev_seqno,\n\tunsigned int bundled)\n{\n\tunsigned int *rtpheader = (unsigned int*)(read_area);\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_instance *instance1;\n\tint res = length, hdrlen = 12, ssrc, seqno, payloadtype, padding, mark, ext, cc;\n\tunsigned int timestamp;\n\tRAII_VAR(struct ast_rtp_payload_type *, payload, NULL, ao2_cleanup);\n\tstruct frame_list frames;\n\n\t/* If this payload is encrypted then decrypt it using the given SRTP instance */\n\tif ((*read_area & 0xC0) && res_srtp && srtp && res_srtp->unprotect(\n\t\t    srtp, read_area, &res, 0 | (srtp_replay_protection << 1)) < 0) {\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If we are currently sending DTMF to the remote party send a continuation packet */\n\tif (rtp->sending_digit) {\n\t\tast_rtp_dtmf_continuation(instance);\n\t}\n\n\t/* Pull out the various other fields we will need */\n\tssrc = ntohl(rtpheader[2]);\n\tseqno = ntohl(rtpheader[0]);\n\tpayloadtype = (seqno & 0x7f0000) >> 16;\n\tpadding = seqno & (1 << 29);\n\tmark = seqno & (1 << 23);\n\text = seqno & (1 << 28);\n\tcc = (seqno & 0xF000000) >> 24;\n\tseqno &= 0xffff;\n\ttimestamp = ntohl(rtpheader[1]);\n\n\tAST_LIST_HEAD_INIT_NOLOCK(&frames);\n\n\t/* Remove any padding bytes that may be present */\n\tif (padding) {\n\t\tres -= read_area[res - 1];\n\t}\n\n\t/* Skip over any CSRC fields */\n\tif (cc) {\n\t\thdrlen += cc * 4;\n\t}\n\n\t/* Look for any RTP extensions, currently we do not support any */\n\tif (ext) {\n\t\tint extensions_size = (ntohl(rtpheader[hdrlen/4]) & 0xffff) << 2;\n\t\tunsigned int profile;\n\t\tprofile = (ntohl(rtpheader[3]) & 0xffff0000) >> 16;\n\n\t\tif (profile == 0xbede) {\n\t\t\t/* We skip over the first 4 bytes as they are just for the one byte extension header */\n\t\t\trtp_instance_parse_extmap_extensions(instance, rtp, read_area + hdrlen + 4, extensions_size);\n\t\t} else if (DEBUG_ATLEAST(1)) {\n\t\t\tif (profile == 0x505a) {\n\t\t\t\tast_log(LOG_DEBUG, \"Found Zfone extension in RTP stream - zrtp - not supported.\\n\");\n\t\t\t} else {\n\t\t\t\t/* SDP negotiated RTP extensions can not currently be output in logging */\n\t\t\t\tast_log(LOG_DEBUG, \"Found unknown RTP Extensions %x\\n\", profile);\n\t\t\t}\n\t\t}\n\n\t\thdrlen += extensions_size;\n\t\thdrlen += 4;\n\t}\n\n\t/* Make sure after we potentially mucked with the header length that it is once again valid */\n\tif (res < hdrlen) {\n\t\tast_log(LOG_WARNING, \"RTP Read too short (%d, expecting %d\\n\", res, hdrlen);\n\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t}\n\n\t/* Only non-bundled instances can change/learn the remote's SSRC implicitly. */\n\tif (!bundled) {\n\t\t/* Force a marker bit and change SSRC if the SSRC changes */\n\t\tif (rtp->themssrc_valid && rtp->themssrc != ssrc) {\n\t\t\tstruct ast_frame *f, srcupdate = {\n\t\t\t\tAST_FRAME_CONTROL,\n\t\t\t\t.subclass.integer = AST_CONTROL_SRCCHANGE,\n\t\t\t};\n\n\t\t\tif (!mark) {\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\t\tast_debug(0, \"(%p) RTP forcing Marker bit, because SSRC has changed\\n\", instance);\n\t\t\t\t}\n\t\t\t\tmark = 1;\n\t\t\t}\n\n\t\t\tf = ast_frisolate(&srcupdate);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, f, frame_list);\n\n\t\t\trtp->seedrxseqno = 0;\n\t\t\trtp->rxcount = 0;\n\t\t\trtp->rxoctetcount = 0;\n\t\t\trtp->cycles = 0;\n\t\t\tprev_seqno = 0;\n\t\t\trtp->last_seqno = 0;\n\t\t\trtp->last_end_timestamp.ts = 0;\n\t\t\trtp->last_end_timestamp.is_set = 0;\n\t\t\tif (rtp->rtcp) {\n\t\t\t\trtp->rtcp->expected_prior = 0;\n\t\t\t\trtp->rtcp->received_prior = 0;\n\t\t\t}\n\t\t}\n\n\t\trtp->themssrc = ssrc; /* Record their SSRC to put in future RR */\n\t\trtp->themssrc_valid = 1;\n\t}\n\n\trtp->rxcount++;\n\trtp->rxoctetcount += (res - hdrlen);\n\tif (rtp->rxcount == 1) {\n\t\trtp->seedrxseqno = seqno;\n\t}\n\n\t/* Do not schedule RR if RTCP isn't run */\n\tif (rtp->rtcp && !ast_sockaddr_isnull(&rtp->rtcp->them) && rtp->rtcp->schedid < 0) {\n\t\t/* Schedule transmission of Receiver Report */\n\t\tao2_ref(instance, +1);\n\t\trtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);\n\t\tif (rtp->rtcp->schedid < 0) {\n\t\t\tao2_ref(instance, -1);\n\t\t\tast_log(LOG_WARNING, \"scheduling RTCP transmission failed.\\n\");\n\t\t}\n\t}\n\tif ((int)prev_seqno - (int)seqno  > 100) /* if so it would indicate that the sender cycled; allow for misordering */\n\t\trtp->cycles += RTP_SEQ_MOD;\n\n\t/* If we are directly bridged to another instance send the audio directly out,\n\t * but only after updating core information about the received traffic so that\n\t * outgoing RTCP reflects it.\n\t */\n\tinstance1 = ast_rtp_instance_get_bridged(instance);\n\tif (instance1\n\t\t&& !bridge_p2p_rtp_write(instance, instance1, rtpheader, res, hdrlen)) {\n\t\tstruct timeval rxtime;\n\t\tstruct ast_frame *f;\n\n\t\t/* Update statistics for jitter so they are correct in RTCP */\n\t\tcalc_rxstamp_and_jitter(&rxtime, rtp, timestamp, mark);\n\n\n\t\t/* When doing P2P we don't need to raise any frames about SSRC change to the core */\n\t\twhile ((f = AST_LIST_REMOVE_HEAD(&frames, frame_list)) != NULL) {\n\t\t\tast_frfree(f);\n\t\t}\n\n\t\treturn &ast_null_frame;\n\t}\n\n\tpayload = ast_rtp_codecs_get_payload(ast_rtp_instance_get_codecs(instance), payloadtype);\n\tif (!payload) {\n\t\t/* Unknown payload type. */\n\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t}\n\n\t/* If the payload is not actually an Asterisk one but a special one pass it off to the respective handler */\n\tif (!payload->asterisk_format) {\n\t\tstruct ast_frame *f = NULL;\n\t\tif (payload->rtp_code == AST_RTP_DTMF) {\n\t\t\t/* process_dtmf_rfc2833 may need to return multiple frames. We do this\n\t\t\t * by passing the pointer to the frame list to it so that the method\n\t\t\t * can append frames to the list as needed.\n\t\t\t */\n\t\t\tprocess_dtmf_rfc2833(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, payloadtype, mark, &frames);\n\t\t} else if (payload->rtp_code == AST_RTP_CISCO_DTMF) {\n\t\t\tf = process_dtmf_cisco(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, payloadtype, mark);\n\t\t} else if (payload->rtp_code == AST_RTP_CN) {\n\t\t\tf = process_cn_rfc3389(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, payloadtype, mark);\n\t\t} else {\n\t\t\tast_log(LOG_NOTICE, \"Unknown RTP codec %d received from '%s'\\n\",\n\t\t\t\tpayloadtype,\n\t\t\t\tast_sockaddr_stringify(remote_address));\n\t\t}\n\n\t\tif (f) {\n\t\t\tAST_LIST_INSERT_TAIL(&frames, f, frame_list);\n\t\t}\n\t\t/* Even if no frame was returned by one of the above methods,\n\t\t * we may have a frame to return in our frame list\n\t\t */\n\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t}\n\n\tao2_replace(rtp->lastrxformat, payload->format);\n\tao2_replace(rtp->f.subclass.format, payload->format);\n\tswitch (ast_format_get_type(rtp->f.subclass.format)) {\n\tcase AST_MEDIA_TYPE_AUDIO:\n\t\trtp->f.frametype = AST_FRAME_VOICE;\n\t\tbreak;\n\tcase AST_MEDIA_TYPE_VIDEO:\n\t\trtp->f.frametype = AST_FRAME_VIDEO;\n\t\tbreak;\n\tcase AST_MEDIA_TYPE_TEXT:\n\t\trtp->f.frametype = AST_FRAME_TEXT;\n\t\tbreak;\n\tcase AST_MEDIA_TYPE_IMAGE:\n\t\t/* Fall through */\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Unknown or unsupported media type: %s\\n\",\n\t\t\tast_codec_media_type2str(ast_format_get_type(rtp->f.subclass.format)));\n\t\treturn &ast_null_frame;\n\t}\n\n\tif (rtp->dtmf_timeout && rtp->dtmf_timeout < timestamp) {\n\t\trtp->dtmf_timeout = 0;\n\n\t\tif (rtp->resp) {\n\t\t\tstruct ast_frame *f;\n\t\t\tf = create_dtmf_frame(instance, AST_FRAME_DTMF_END, 0);\n\t\t\tf->len = ast_tvdiff_ms(ast_samp2tv(rtp->dtmf_duration, ast_rtp_get_rate(f->subclass.format)), ast_tv(0, 0));\n\t\t\trtp->resp = 0;\n\t\t\trtp->dtmf_timeout = rtp->dtmf_duration = 0;\n\t\t\tAST_LIST_INSERT_TAIL(&frames, f, frame_list);\n\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t}\n\t}\n\n\trtp->f.src = \"RTP\";\n\trtp->f.mallocd = 0;\n\trtp->f.datalen = res - hdrlen;\n\trtp->f.data.ptr = read_area + hdrlen;\n\trtp->f.offset = hdrlen + AST_FRIENDLY_OFFSET;\n\tast_set_flag(&rtp->f, AST_FRFLAG_HAS_SEQUENCE_NUMBER);\n\trtp->f.seqno = seqno;\n\trtp->f.stream_num = rtp->stream_num;\n\n\tif ((ast_format_cmp(rtp->f.subclass.format, ast_format_t140) == AST_FORMAT_CMP_EQUAL)\n\t\t&& ((int)seqno - (prev_seqno + 1) > 0)\n\t\t&& ((int)seqno - (prev_seqno + 1) < 10)) {\n\t\tunsigned char *data = rtp->f.data.ptr;\n\n\t\tmemmove(rtp->f.data.ptr+3, rtp->f.data.ptr, rtp->f.datalen);\n\t\trtp->f.datalen +=3;\n\t\t*data++ = 0xEF;\n\t\t*data++ = 0xBF;\n\t\t*data = 0xBD;\n\t}\n\n\tif (ast_format_cmp(rtp->f.subclass.format, ast_format_t140_red) == AST_FORMAT_CMP_EQUAL) {\n\t\tunsigned char *data = rtp->f.data.ptr;\n\t\tunsigned char *header_end;\n\t\tint num_generations;\n\t\tint header_length;\n\t\tint len;\n\t\tint diff =(int)seqno - (prev_seqno+1); /* if diff = 0, no drop*/\n\t\tint x;\n\n\t\tao2_replace(rtp->f.subclass.format, ast_format_t140);\n\t\theader_end = memchr(data, ((*data) & 0x7f), rtp->f.datalen);\n\t\tif (header_end == NULL) {\n\t\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t\t}\n\t\theader_end++;\n\n\t\theader_length = header_end - data;\n\t\tnum_generations = header_length / 4;\n\t\tlen = header_length;\n\n\t\tif (!diff) {\n\t\t\tfor (x = 0; x < num_generations; x++)\n\t\t\t\tlen += data[x * 4 + 3];\n\n\t\t\tif (!(rtp->f.datalen - len))\n\t\t\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\n\t\t\trtp->f.data.ptr += len;\n\t\t\trtp->f.datalen -= len;\n\t\t} else if (diff > num_generations && diff < 10) {\n\t\t\tlen -= 3;\n\t\t\trtp->f.data.ptr += len;\n\t\t\trtp->f.datalen -= len;\n\n\t\t\tdata = rtp->f.data.ptr;\n\t\t\t*data++ = 0xEF;\n\t\t\t*data++ = 0xBF;\n\t\t\t*data = 0xBD;\n\t\t} else {\n\t\t\tfor ( x = 0; x < num_generations - diff; x++)\n\t\t\t\tlen += data[x * 4 + 3];\n\n\t\t\trtp->f.data.ptr += len;\n\t\t\trtp->f.datalen -= len;\n\t\t}\n\t}\n\n\tif (ast_format_get_type(rtp->f.subclass.format) == AST_MEDIA_TYPE_AUDIO) {\n\t\trtp->f.samples = ast_codec_samples_count(&rtp->f);\n\t\tif (ast_format_cache_is_slinear(rtp->f.subclass.format)) {\n\t\t\tast_frame_byteswap_be(&rtp->f);\n\t\t}\n\t\tcalc_rxstamp_and_jitter(&rtp->f.delivery, rtp, timestamp, mark);\n\t\t/* Add timing data to let ast_generic_bridge() put the frame into a jitterbuf */\n\t\tast_set_flag(&rtp->f, AST_FRFLAG_HAS_TIMING_INFO);\n\t\trtp->f.ts = timestamp / (ast_rtp_get_rate(rtp->f.subclass.format) / 1000);\n\t\trtp->f.len = rtp->f.samples / ((ast_format_get_sample_rate(rtp->f.subclass.format) / 1000));\n\t} else if (ast_format_get_type(rtp->f.subclass.format) == AST_MEDIA_TYPE_VIDEO) {\n\t\t/* Video -- samples is # of samples vs. 90000 */\n\t\tif (!rtp->lastividtimestamp)\n\t\t\trtp->lastividtimestamp = timestamp;\n\t\tcalc_rxstamp_and_jitter(&rtp->f.delivery, rtp, timestamp, mark);\n\t\tast_set_flag(&rtp->f, AST_FRFLAG_HAS_TIMING_INFO);\n\t\trtp->f.ts = timestamp / (ast_rtp_get_rate(rtp->f.subclass.format) / 1000);\n\t\trtp->f.samples = timestamp - rtp->lastividtimestamp;\n\t\trtp->lastividtimestamp = timestamp;\n\t\trtp->f.delivery.tv_sec = 0;\n\t\trtp->f.delivery.tv_usec = 0;\n\t\t/* Pass the RTP marker bit as bit */\n\t\trtp->f.subclass.frame_ending = mark ? 1 : 0;\n\t} else if (ast_format_get_type(rtp->f.subclass.format) == AST_MEDIA_TYPE_TEXT) {\n\t\t/* TEXT -- samples is # of samples vs. 1000 */\n\t\tif (!rtp->lastitexttimestamp)\n\t\t\trtp->lastitexttimestamp = timestamp;\n\t\trtp->f.samples = timestamp - rtp->lastitexttimestamp;\n\t\trtp->lastitexttimestamp = timestamp;\n\t\trtp->f.delivery.tv_sec = 0;\n\t\trtp->f.delivery.tv_usec = 0;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Unknown or unsupported media type: %s\\n\",\n\t\t\tast_codec_media_type2str(ast_format_get_type(rtp->f.subclass.format)));\n\t\treturn &ast_null_frame;\n\t}\n\n\tAST_LIST_INSERT_TAIL(&frames, &rtp->f, frame_list);\n\treturn AST_LIST_FIRST(&frames);\n}\n\n#ifdef AST_DEVMODE\n\nstruct rtp_drop_packets_data {\n\t/* Whether or not to randomize the number of packets to drop. */\n\tunsigned int use_random_num;\n\t/* Whether or not to randomize the time interval between packets drops. */\n\tunsigned int use_random_interval;\n\t/* The total number of packets to drop. If 'use_random_num' is true then this\n\t * value becomes the upper bound for a number of random packets to drop. */\n\tunsigned int num_to_drop;\n\t/* The current number of packets that have been dropped during an interval. */\n\tunsigned int num_dropped;\n\t/* The optional interval to use between packet drops. If 'use_random_interval'\n\t * is true then this values becomes the upper bound for a random interval used. */\n\tstruct timeval interval;\n\t/* The next time a packet drop should be triggered. */\n\tstruct timeval next;\n\t/* An optional IP address from which to drop packets from. */\n\tstruct ast_sockaddr addr;\n\t/* The optional port from which to drop packets from. */\n\tunsigned int port;\n};\n\nstatic struct rtp_drop_packets_data drop_packets_data;\n\nstatic void drop_packets_data_update(struct timeval tv)\n{\n\t/*\n\t * num_dropped keeps up with the number of packets that have been dropped for a\n\t * given interval. Once the specified number of packets have been dropped and\n\t * the next time interval is ready to trigger then set this number to zero (drop\n\t * the next 'n' packets up to 'num_to_drop'), or if 'use_random_num' is set to\n\t * true then set to a random number between zero and 'num_to_drop'.\n\t */\n\tdrop_packets_data.num_dropped = drop_packets_data.use_random_num ?\n\t\tast_random() % drop_packets_data.num_to_drop : 0;\n\n\t/*\n\t * A specified number of packets can be dropped at a given interval (e.g every\n\t * 30 seconds). If 'use_random_interval' is false simply add the interval to\n\t * the given time to get the next trigger point. If set to true, then get a\n\t * random time between the given time and up to the specified interval.\n\t */\n\tif (drop_packets_data.use_random_interval) {\n\t\t/* Calculate as a percentage of the specified drop packets interval */\n\t\tstruct timeval interval = ast_time_create_by_unit(ast_time_tv_to_usec(\n\t\t\t&drop_packets_data.interval) * ((double)(ast_random() % 100 + 1) / 100),\n\t\t\tTIME_UNIT_MICROSECOND);\n\n\t\tdrop_packets_data.next = ast_tvadd(tv, interval);\n\t} else {\n\t\tdrop_packets_data.next = ast_tvadd(tv, drop_packets_data.interval);\n\t}\n}\n\nstatic int should_drop_packets(struct ast_sockaddr *addr)\n{\n\tstruct timeval tv;\n\n\tif (!drop_packets_data.num_to_drop) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If an address has been specified then filter on it, and also the port if\n\t * it too was included.\n\t */\n\tif (!ast_sockaddr_isnull(&drop_packets_data.addr) &&\n\t\t(drop_packets_data.port ?\n\t\t\tast_sockaddr_cmp(&drop_packets_data.addr, addr) :\n\t\t\tast_sockaddr_cmp_addr(&drop_packets_data.addr, addr)) != 0) {\n\t\t/* Address and/or port does not match */\n\t\treturn 0;\n\t}\n\n\t/* Keep dropping packets until we've reached the total to drop */\n\tif (drop_packets_data.num_dropped < drop_packets_data.num_to_drop) {\n\t\t++drop_packets_data.num_dropped;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Once the set number of packets has been dropped check to see if it's\n\t * time to drop more.\n\t */\n\n\tif (ast_tvzero(drop_packets_data.interval)) {\n\t\t/* If no interval then drop specified number of packets and be done */\n\t\tdrop_packets_data.num_to_drop = 0;\n\t\treturn 0;\n\t}\n\n\ttv = ast_tvnow();\n\tif (ast_tvcmp(tv, drop_packets_data.next) == -1) {\n\t\t/* Still waiting for the next time interval to elapse */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The next time interval has elapsed so update the tracking structure\n\t * in order to start dropping more packets, and figure out when the next\n\t * time interval is.\n\t */\n\tdrop_packets_data_update(tv);\n\treturn 1;\n}\n\n#endif\n\n/*! \\pre instance is locked */\nstatic struct ast_frame *ast_rtp_read(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_srtp *srtp;\n\tRAII_VAR(struct ast_rtp_instance *, child, NULL, rtp_instance_unlock);\n\tstruct ast_sockaddr addr;\n\tint res, hdrlen = 12, version, payloadtype;\n\tunsigned char *read_area = rtp->rawdata + AST_FRIENDLY_OFFSET;\n\tsize_t read_area_size = sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET;\n\tunsigned int *rtpheader = (unsigned int*)(read_area), seqno, ssrc, timestamp, prev_seqno;\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tstruct frame_list frames;\n\tstruct ast_frame *frame;\n\tunsigned int bundled;\n\n\t/* If this is actually RTCP let's hop on over and handle it */\n\tif (rtcp) {\n\t\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\treturn ast_rtcp_read(instance);\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* Actually read in the data from the socket */\n\tif ((res = rtp_recvfrom(instance, read_area, read_area_size, 0,\n\t\t\t\t&addr)) < 0) {\n\t\tif (res == RTP_DTLS_ESTABLISHED) {\n\t\t\trtp->f.frametype = AST_FRAME_CONTROL;\n\t\t\trtp->f.subclass.integer = AST_CONTROL_SRCCHANGE;\n\t\t\treturn &rtp->f;\n\t\t}\n\n\t\tast_assert(errno != EBADF);\n\t\tif (errno != EAGAIN) {\n\t\t\tast_log(LOG_WARNING, \"RTP Read error: %s.  Hanging up.\\n\",\n\t\t\t\t(errno) ? strerror(errno) : \"Unspecified\");\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If this was handled by the ICE session don't do anything */\n\tif (!res) {\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* This could be a multiplexed RTCP packet. If so, be sure to interpret it correctly */\n\tif (rtcp_mux(rtp, read_area)) {\n\t\treturn ast_rtcp_interpret(instance, ast_rtp_instance_get_srtp(instance, 1), read_area, res, &addr);\n\t}\n\n\t/* Make sure the data that was read in is actually enough to make up an RTP packet */\n\tif (res < hdrlen) {\n\t\t/* If this is a keepalive containing only nulls, don't bother with a warning */\n\t\tint i;\n\t\tfor (i = 0; i < res; ++i) {\n\t\t\tif (read_area[i] != '\\0') {\n\t\t\t\tast_log(LOG_WARNING, \"RTP Read too short\\n\");\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* Get fields and verify this is an RTP packet */\n\tseqno = ntohl(rtpheader[0]);\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\tif (!(version = (seqno & 0xC0000000) >> 30)) {\n\t\tstruct sockaddr_in addr_tmp;\n\t\tstruct ast_sockaddr addr_v4;\n\t\tif (ast_sockaddr_is_ipv4(&addr)) {\n\t\t\tast_sockaddr_to_sin(&addr, &addr_tmp);\n\t\t} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {\n\t\t\tast_debug_stun(1, \"(%p) STUN using IPv6 mapped address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\tast_sockaddr_to_sin(&addr_v4, &addr_tmp);\n\t\t} else {\n\t\t\tast_debug_stun(1, \"(%p) STUN cannot do for non IPv4 address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\treturn &ast_null_frame;\n\t\t}\n\t\tif ((ast_stun_handle_packet(rtp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT) &&\n\t\t    ast_sockaddr_isnull(&remote_address)) {\n\t\t\tast_sockaddr_from_sin(&addr, &addr_tmp);\n\t\t\tast_rtp_instance_set_remote_address(instance, &addr);\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If the version is not what we expected by this point then just drop the packet */\n\tif (version != 2) {\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* We use the SSRC to determine what RTP instance this packet is actually for */\n\tssrc = ntohl(rtpheader[2]);\n\n\t/* We use the SRTP data from the provided instance that it came in on, not the child */\n\tsrtp = ast_rtp_instance_get_srtp(instance, 0);\n\n\t/* Determine the appropriate instance for this */\n\tchild = rtp_find_instance_by_packet_source_ssrc(instance, rtp, ssrc);\n\tif (!child) {\n\t\t/* Neither the bundled parent nor any child has this SSRC */\n\t\treturn &ast_null_frame;\n\t}\n\tif (child != instance) {\n\t\t/* It is safe to hold the child lock while holding the parent lock, we guarantee that the locking order\n\t\t * is always parent->child or that the child lock is not held when acquiring the parent lock.\n\t\t */\n\t\tao2_lock(child);\n\t\tinstance = child;\n\t\trtp = ast_rtp_instance_get_data(instance);\n\t} else {\n\t\t/* The child is the parent! We don't need to unlock it. */\n\t\tchild = NULL;\n\t}\n\n\t/* If strict RTP protection is enabled see if we need to learn the remote address or if we need to drop the packet */\n\tswitch (rtp->strict_rtp_state) {\n\tcase STRICT_RTP_LEARN:\n\t\t/*\n\t\t * Scenario setup:\n\t\t * PartyA -- Ast1 -- Ast2 -- PartyB\n\t\t *\n\t\t * The learning timeout is necessary for Ast1 to handle the above\n\t\t * setup where PartyA calls PartyB and Ast2 initiates direct media\n\t\t * between Ast1 and PartyB.  Ast1 may lock onto the Ast2 stream and\n\t\t * never learn the PartyB stream when it starts.  The timeout makes\n\t\t * Ast1 stay in the learning state long enough to see and learn the\n\t\t * RTP stream from PartyB.\n\t\t *\n\t\t * To mitigate against attack, the learning state cannot switch\n\t\t * streams while there are competing streams.  The competing streams\n\t\t * interfere with each other's qualification.  Once we accept a\n\t\t * stream and reach the timeout, an attacker cannot interfere\n\t\t * anymore.\n\t\t *\n\t\t * Here are a few scenarios and each one assumes that the streams\n\t\t * are continuous:\n\t\t *\n\t\t * 1) We already have a known stream source address and the known\n\t\t * stream wants to change to a new source address.  An attacking\n\t\t * stream will block learning the new stream source.  After the\n\t\t * timeout we re-lock onto the original stream source address which\n\t\t * likely went away.  The result is one way audio.\n\t\t *\n\t\t * 2) We already have a known stream source address and the known\n\t\t * stream doesn't want to change source addresses.  An attacking\n\t\t * stream will not be able to replace the known stream.  After the\n\t\t * timeout we re-lock onto the known stream.  The call is not\n\t\t * affected.\n\t\t *\n\t\t * 3) We don't have a known stream source address.  This presumably\n\t\t * is the start of a call.  Competing streams will result in staying\n\t\t * in learning mode until a stream becomes the victor and we reach\n\t\t * the timeout.  We cannot exit learning if we have no known stream\n\t\t * to lock onto.  The result is one way audio until there is a victor.\n\t\t *\n\t\t * If we learn a stream source address before the timeout we will be\n\t\t * in scenario 1) or 2) when a competing stream starts.\n\t\t */\n\t\tif (!ast_sockaddr_isnull(&rtp->strict_rtp_address)\n\t\t\t&& STRICT_RTP_LEARN_TIMEOUT < ast_tvdiff_ms(ast_tvnow(), rtp->rtp_source_learn.start)) {\n\t\t\tast_verb(4, \"%p -- Strict RTP learning complete - Locking on source address %s\\n\",\n\t\t\t\trtp, ast_sockaddr_stringify(&rtp->strict_rtp_address));\n\t\t\tast_test_suite_event_notify(\"STRICT_RTP_LEARN\", \"Source: %s\",\n\t\t\t\tast_sockaddr_stringify(&rtp->strict_rtp_address));\n\t\t\trtp->strict_rtp_state = STRICT_RTP_CLOSED;\n\t\t} else {\n\t\t\tstruct ast_sockaddr target_address;\n\n\t\t\tif (!ast_sockaddr_cmp(&rtp->strict_rtp_address, &addr)) {\n\t\t\t\t/*\n\t\t\t\t * We are open to learning a new address but have received\n\t\t\t\t * traffic from the current address, accept it and reset\n\t\t\t\t * the learning counts for a new source.  When no more\n\t\t\t\t * current source packets arrive a new source can take over\n\t\t\t\t * once sufficient traffic is received.\n\t\t\t\t */\n\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We give preferential treatment to the requested target address\n\t\t\t * (negotiated SDP address) where we are to send our RTP.  However,\n\t\t\t * the other end has no obligation to send from that address even\n\t\t\t * though it is practically a requirement when NAT is involved.\n\t\t\t */\n\t\t\tast_rtp_instance_get_requested_target_address(instance, &target_address);\n\t\t\tif (!ast_sockaddr_cmp(&target_address, &addr)) {\n\t\t\t\t/* Accept the negotiated target RTP stream as the source */\n\t\t\t\tast_verb(4, \"%p -- Strict RTP switching to RTP target address %s as source\\n\",\n\t\t\t\t\trtp, ast_sockaddr_stringify(&addr));\n\t\t\t\tast_sockaddr_copy(&rtp->strict_rtp_address, &addr);\n\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Trying to learn a new address.  If we pass a probationary period\n\t\t\t * with it, that means we've stopped getting RTP from the original\n\t\t\t * source and we should switch to it.\n\t\t\t */\n\t\t\tif (!ast_sockaddr_cmp(&rtp->rtp_source_learn.proposed_address, &addr)) {\n\t\t\t\tif (rtp->rtp_source_learn.stream_type == AST_MEDIA_TYPE_UNKNOWN) {\n\t\t\t\t\tstruct ast_rtp_codecs *codecs;\n\n\t\t\t\t\tcodecs = ast_rtp_instance_get_codecs(instance);\n\t\t\t\t\trtp->rtp_source_learn.stream_type =\n\t\t\t\t\t\tast_rtp_codecs_get_stream_type(codecs);\n\t\t\t\t\tast_verb(4, \"%p -- Strict RTP qualifying stream type: %s\\n\",\n\t\t\t\t\t\trtp, ast_codec_media_type2str(rtp->rtp_source_learn.stream_type));\n\t\t\t\t}\n\t\t\t\tif (!rtp_learning_rtp_seq_update(&rtp->rtp_source_learn, seqno)) {\n\t\t\t\t\t/* Accept the new RTP stream */\n\t\t\t\t\tast_verb(4, \"%p -- Strict RTP switching source address to %s\\n\",\n\t\t\t\t\t\trtp, ast_sockaddr_stringify(&addr));\n\t\t\t\t\tast_sockaddr_copy(&rtp->strict_rtp_address, &addr);\n\t\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Not ready to accept the RTP stream candidate */\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection. Will switch to it in %d packets.\\n\",\n\t\t\t\t\tinstance, rtp, ast_sockaddr_stringify(&addr), rtp->rtp_source_learn.packets);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This is either an attacking stream or\n\t\t\t\t * the start of the expected new stream.\n\t\t\t\t */\n\t\t\t\tast_sockaddr_copy(&rtp->rtp_source_learn.proposed_address, &addr);\n\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection. Qualifying new stream.\\n\",\n\t\t\t\t\tinstance, rtp, ast_sockaddr_stringify(&addr));\n\t\t\t}\n\t\t\treturn &ast_null_frame;\n\t\t}\n\t\t/* Fall through */\n\tcase STRICT_RTP_CLOSED:\n\t\t/*\n\t\t * We should not allow a stream address change if the SSRC matches\n\t\t * once strictrtp learning is closed.  Any kind of address change\n\t\t * like this should have happened while we were in the learning\n\t\t * state.  We do not want to allow the possibility of an attacker\n\t\t * interfering with the RTP stream after the learning period.\n\t\t * An attacker could manage to get an RTCP packet redirected to\n\t\t * them which can contain the SSRC value.\n\t\t */\n\t\tif (!ast_sockaddr_cmp(&rtp->strict_rtp_address, &addr)) {\n\t\t\tbreak;\n\t\t}\n\t\tast_debug_rtp(1, \"(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection.\\n\",\n\t\t\tinstance, rtp, ast_sockaddr_stringify(&addr));\n#ifdef TEST_FRAMEWORK\n\t{\n\t\tstatic int strict_rtp_test_event = 1;\n\t\tif (strict_rtp_test_event) {\n\t\t\tast_test_suite_event_notify(\"STRICT_RTP_CLOSED\", \"Source: %s\",\n\t\t\t\tast_sockaddr_stringify(&addr));\n\t\t\tstrict_rtp_test_event = 0; /* Only run this event once to prevent possible spam */\n\t\t}\n\t}\n#endif\n\t\treturn &ast_null_frame;\n\tcase STRICT_RTP_OPEN:\n\t\tbreak;\n\t}\n\n\t/* If symmetric RTP is enabled see if the remote side is not what we expected and change where we are sending audio */\n\tif (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {\n\t\tif (ast_sockaddr_cmp(&remote_address, &addr)) {\n\t\t\t/* do not update the originally given address, but only the remote */\n\t\t\tast_rtp_instance_set_incoming_source_address(instance, &addr);\n\t\t\tast_sockaddr_copy(&remote_address, &addr);\n\t\t\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, &addr);\n\t\t\t\tast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(&addr) + 1);\n\t\t\t}\n\t\t\tast_set_flag(rtp, FLAG_NAT_ACTIVE);\n\t\t\tif (ast_debug_rtp_packet_is_allowed)\n\t\t\t\tast_debug(0, \"(%p) RTP NAT: Got audio from other end. Now sending to address %s\\n\",\n\t\t\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\t}\n\t}\n\n\t/* Pull out the various other fields we will need */\n\tpayloadtype = (seqno & 0x7f0000) >> 16;\n\tseqno &= 0xffff;\n\ttimestamp = ntohl(rtpheader[1]);\n\n#ifdef AST_DEVMODE\n\tif (should_drop_packets(&addr)) {\n\t\tast_debug(0, \"(%p) RTP: drop received packet from %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&addr), payloadtype, seqno, timestamp, res - hdrlen);\n\t\treturn &ast_null_frame;\n\t}\n#endif\n\n\tif (rtp_debug_test_addr(&addr)) {\n\t\tast_verbose(\"Got  RTP packet from    %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&addr),\n\t\t\t    payloadtype, seqno, timestamp, res - hdrlen);\n\t}\n\n\tAST_LIST_HEAD_INIT_NOLOCK(&frames);\n\n\tbundled = (child || AST_VECTOR_SIZE(&rtp->ssrc_mapping)) ? 1 : 0;\n\n\tprev_seqno = rtp->lastrxseqno;\n\t/* We need to save lastrxseqno for use by jitter before resetting it. */\n\trtp->prevrxseqno = rtp->lastrxseqno;\n\trtp->lastrxseqno = seqno;\n\n\tif (!rtp->recv_buffer) {\n\t\t/* If there is no receive buffer then we can pass back the frame directly */\n\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\treturn AST_LIST_FIRST(&frames);\n\t} else if (rtp->expectedrxseqno == -1 || seqno == rtp->expectedrxseqno) {\n\t\trtp->expectedrxseqno = seqno + 1;\n\n\t\t/* We've cycled over, so go back to 0 */\n\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\trtp->expectedrxseqno = 0;\n\t\t}\n\n\t\t/* If there are no buffered packets that will be placed after this frame then we can\n\t\t * return it directly without duplicating it.\n\t\t */\n\t\tif (!ast_data_buffer_count(rtp->recv_buffer)) {\n\t\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t}\n\n\t\tif (!AST_VECTOR_REMOVE_CMP_ORDERED(&rtp->missing_seqno, seqno, find_by_value,\n\t\t\tAST_VECTOR_ELEM_CLEANUP_NOOP)) {\n\t\t\tast_debug_rtp(2, \"(%p) RTP Packet with sequence number '%d' on instance is no longer missing\\n\",\n\t\t\t\tinstance, seqno);\n\t\t}\n\n\t\t/* If we don't have the next packet after this we can directly return the frame, as there is no\n\t\t * chance it will be overwritten.\n\t\t */\n\t\tif (!ast_data_buffer_get(rtp->recv_buffer, rtp->expectedrxseqno)) {\n\t\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t}\n\n\t\t/* Otherwise we need to dupe the frame so that the potential processing of frames placed after\n\t\t * it do not overwrite the data. You may be thinking that we could just add the current packet\n\t\t * to the head of the frames list and avoid having to duplicate it but this would result in out\n\t\t * of order packet processing by libsrtp which we are trying to avoid.\n\t\t */\n\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled));\n\t\tif (frame) {\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\tprev_seqno = seqno;\n\t\t}\n\n\t\t/* Add any additional packets that we have buffered and that are available */\n\t\twhile (ast_data_buffer_count(rtp->recv_buffer)) {\n\t\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\n\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, rtp->expectedrxseqno);\n\t\t\tif (!payload) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, payload->buf, payload->size, prev_seqno, bundled));\n\t\t\tast_free(payload);\n\n\t\t\tif (!frame) {\n\t\t\t\t/* If this packet can't be interpreted due to being out of memory we return what we have and assume\n\t\t\t\t * that we will determine it is a missing packet later and NACK for it.\n\t\t\t\t */\n\t\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t\t}\n\n\t\t\tast_debug_rtp(2, \"(%p) RTP pulled buffered packet with sequence number '%d' to additionally return\\n\",\n\t\t\t\tinstance, frame->seqno);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\tprev_seqno = rtp->expectedrxseqno;\n\t\t\trtp->expectedrxseqno++;\n\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn AST_LIST_FIRST(&frames);\n\t} else if ((((seqno - rtp->expectedrxseqno) > 100) && timestamp > rtp->lastividtimestamp) ||\n\t\tast_data_buffer_count(rtp->recv_buffer) == ast_data_buffer_max(rtp->recv_buffer)) {\n\t\tint inserted = 0;\n\n\t\t/* We have a large number of outstanding buffered packets or we've jumped far ahead in time.\n\t\t * To compensate we dump what we have in the buffer and place the current packet in a logical\n\t\t * spot. In the case of video we also require a full frame to give the decoding side a fighting\n\t\t * chance.\n\t\t */\n\n\t\tif (rtp->rtp_source_learn.stream_type == AST_MEDIA_TYPE_VIDEO) {\n\t\t\tast_debug_rtp(2, \"(%p) RTP source has wild gap or packet loss, sending FIR\\n\",\n\t\t\t\tinstance);\n\t\t\trtp_write_rtcp_fir(instance, rtp, &remote_address);\n\t\t}\n\n\t\t/* This works by going through the progression of the sequence number retrieving buffered packets\n\t\t * or inserting the current received packet until we've run out of packets. This ensures that the\n\t\t * packets are in the correct sequence number order.\n\t\t */\n\t\twhile (ast_data_buffer_count(rtp->recv_buffer)) {\n\t\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\n\t\t\t/* If the packet we received is the one we are expecting at this point then add it in */\n\t\t\tif (rtp->expectedrxseqno == seqno) {\n\t\t\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled));\n\t\t\t\tif (frame) {\n\t\t\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\t\t\tprev_seqno = seqno;\n\t\t\t\t\tast_debug_rtp(2, \"(%p) RTP inserted just received packet with sequence number '%d' in correct order\\n\",\n\t\t\t\t\t\tinstance, seqno);\n\t\t\t\t}\n\t\t\t\t/* It is possible due to packet retransmission for this packet to also exist in the receive\n\t\t\t\t * buffer so we explicitly remove it in case this occurs, otherwise the receive buffer will\n\t\t\t\t * never be empty.\n\t\t\t\t */\n\t\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, seqno);\n\t\t\t\tif (payload) {\n\t\t\t\t\tast_free(payload);\n\t\t\t\t}\n\t\t\t\trtp->expectedrxseqno++;\n\t\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t\t}\n\t\t\t\tinserted = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, rtp->expectedrxseqno);\n\t\t\tif (payload) {\n\t\t\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, payload->buf, payload->size, prev_seqno, bundled));\n\t\t\t\tif (frame) {\n\t\t\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\t\t\tprev_seqno = rtp->expectedrxseqno;\n\t\t\t\t\tast_debug_rtp(2, \"(%p) RTP emptying queue and returning packet with sequence number '%d'\\n\",\n\t\t\t\t\t\tinstance, frame->seqno);\n\t\t\t\t}\n\t\t\t\tast_free(payload);\n\t\t\t}\n\n\t\t\trtp->expectedrxseqno++;\n\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!inserted) {\n\t\t\t/* This current packet goes after them, and we assume that packets going forward will follow\n\t\t\t * that new sequence number increment. It is okay for this to not be duplicated as it is guaranteed\n\t\t\t * to be the last packet processed right now and it is also guaranteed that it will always return\n\t\t\t * non-NULL.\n\t\t\t */\n\t\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\trtp->expectedrxseqno = seqno + 1;\n\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t}\n\n\t\t\tast_debug_rtp(2, \"(%p) RTP adding just received packet with sequence number '%d' to end of dumped queue\\n\",\n\t\t\t\tinstance, seqno);\n\t\t}\n\n\t\t/* When we flush increase our chance for next time by growing the receive buffer when possible\n\t\t * by how many packets we missed, to give ourselves a bit more breathing room.\n\t\t */\n\t\tast_data_buffer_resize(rtp->recv_buffer, MIN(MAXIMUM_RTP_RECV_BUFFER_SIZE,\n\t\t\tast_data_buffer_max(rtp->recv_buffer) + AST_VECTOR_SIZE(&rtp->missing_seqno)));\n\t\tast_debug_rtp(2, \"(%p) RTP receive buffer is now at maximum of %zu\\n\", instance, ast_data_buffer_max(rtp->recv_buffer));\n\n\t\t/* As there is such a large gap we don't want to flood the order side with missing packets, so we\n\t\t * give up and start anew.\n\t\t */\n\t\tAST_VECTOR_RESET(&rtp->missing_seqno, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\n\t\treturn AST_LIST_FIRST(&frames);\n\t}\n\n\t/* We're finished with the frames list */\n\tast_frame_free(AST_LIST_FIRST(&frames), 0);\n\n\t/* Determine if the received packet is from the last OLD_PACKET_COUNT (1000 by default) packets or not.\n\t * For the case where the received sequence number exceeds that of the expected sequence number we calculate\n\t * the past sequence number that would be 1000 sequence numbers ago. If the received sequence number\n\t * exceeds or meets that then it is within OLD_PACKET_COUNT packets ago. For example if the expected\n\t * sequence number is 100 and we receive 65530, then it would be considered old. This is because\n\t * 65535 - 1000 + 100 = 64635 which gives us the sequence number at which we would consider the packets\n\t * old. Since 65530 is above that, it would be considered old.\n\t * For the case where the received sequence number is less than the expected sequence number we can do\n\t * a simple subtraction to see if it is 1000 packets ago or not.\n\t */\n\tif ((seqno < rtp->expectedrxseqno && ((rtp->expectedrxseqno - seqno) <= OLD_PACKET_COUNT)) ||\n\t\t(seqno > rtp->expectedrxseqno && (seqno >= (65535 - OLD_PACKET_COUNT + rtp->expectedrxseqno)))) {\n\t\t/* If this is a packet from the past then we have received a duplicate packet, so just drop it */\n\t\tast_debug_rtp(2, \"(%p) RTP received an old packet with sequence number '%d', dropping it\\n\",\n\t\t\tinstance, seqno);\n\t\treturn &ast_null_frame;\n\t} else if (ast_data_buffer_get(rtp->recv_buffer, seqno)) {\n\t\t/* If this is a packet we already have buffered then it is a duplicate, so just drop it */\n\t\tast_debug_rtp(2, \"(%p) RTP received a duplicate transmission of packet with sequence number '%d', dropping it\\n\",\n\t\t\tinstance, seqno);\n\t\treturn &ast_null_frame;\n\t} else {\n\t\t/* This is an out of order packet from the future */\n\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\t\tint missing_seqno;\n\t\tint remove_failed;\n\t\tunsigned int missing_seqnos_added = 0;\n\n\t\tast_debug_rtp(2, \"(%p) RTP received an out of order packet with sequence number '%d' while expecting '%d' from the future\\n\",\n\t\t\tinstance, seqno, rtp->expectedrxseqno);\n\n\t\tpayload = ast_malloc(sizeof(*payload) + res);\n\t\tif (!payload) {\n\t\t\t/* If the payload can't be allocated then we can't defer this packet right now.\n\t\t\t * Instead of dumping what we have we pretend we lost this packet. It will then\n\t\t\t * get NACKed later or the existing buffer will be returned entirely. Well, we may\n\t\t\t * try since we're seemingly out of memory. It's a bad situation all around and\n\t\t\t * packets are likely to get lost anyway.\n\t\t\t */\n\t\t\treturn &ast_null_frame;\n\t\t}\n\n\t\tpayload->size = res;\n\t\tmemcpy(payload->buf, rtpheader, res);\n\t\tif (ast_data_buffer_put(rtp->recv_buffer, seqno, payload) == -1) {\n\t\t\tast_free(payload);\n\t\t}\n\n\t\t/* If this sequence number is removed that means we had a gap and this packet has filled it in\n\t\t * some. Since it was part of the gap we will have already added any other missing sequence numbers\n\t\t * before it (and possibly after it) to the vector so we don't need to do that again. Note that\n\t\t * remove_failed will be set to -1 if the sequence number isn't removed, and 0 if it is.\n\t\t */\n\t\tremove_failed = AST_VECTOR_REMOVE_CMP_ORDERED(&rtp->missing_seqno, seqno, find_by_value,\n\t\t\tAST_VECTOR_ELEM_CLEANUP_NOOP);\n\t\tif (!remove_failed) {\n\t\t\tast_debug_rtp(2, \"(%p) RTP packet with sequence number '%d' is no longer missing\\n\",\n\t\t\t\tinstance, seqno);\n\t\t}\n\n\t\t/* The missing sequence number code works by taking the sequence number of the\n\t\t * packet we've just received and going backwards until we hit the sequence number\n\t\t * of the last packet we've received. While doing so we check to make sure that the\n\t\t * sequence number is not already missing and that it is not already buffered.\n\t\t */\n\t\tmissing_seqno = seqno;\n\t\twhile (remove_failed) {\n\t\t\tmissing_seqno -= 1;\n\n\t\t\t/* If we've cycled backwards then start back at the top */\n\t\t\tif (missing_seqno < 0) {\n\t\t\t\tmissing_seqno = 65535;\n\t\t\t}\n\n\t\t\t/* We've gone backwards enough such that we've hit the previous sequence number */\n\t\t\tif (missing_seqno == prev_seqno) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* We don't want missing sequence number duplicates. If, for some reason,\n\t\t\t * packets are really out of order, we could end up in this scenario:\n\t\t\t *\n\t\t\t * We are expecting sequence number 100\n\t\t\t * We receive sequence number 105\n\t\t\t * Sequence numbers 100 through 104 get added to the vector\n\t\t\t * We receive sequence number 101 (this section is skipped)\n\t\t\t * We receive sequence number 103\n\t\t\t * Sequence number 102 is added to the vector\n\t\t\t *\n\t\t\t * This will prevent the duplicate from being added.\n\t\t\t */\n\t\t\tif (AST_VECTOR_GET_CMP(&rtp->missing_seqno, missing_seqno,\n\t\t\t\t\t\tfind_by_value)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If this packet has been buffered already then don't count it amongst the\n\t\t\t * missing.\n\t\t\t */\n\t\t\tif (ast_data_buffer_get(rtp->recv_buffer, missing_seqno)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_debug_rtp(2, \"(%p) RTP added missing sequence number '%d'\\n\",\n\t\t\t\tinstance, missing_seqno);\n\t\t\tAST_VECTOR_ADD_SORTED(&rtp->missing_seqno, missing_seqno,\n\t\t\t\t\tcompare_by_value);\n\t\t\tmissing_seqnos_added++;\n\t\t}\n\n\t\t/* When we add a large number of missing sequence numbers we assume there was a substantial\n\t\t * gap in reception so we trigger an immediate NACK. When our data buffer is 1/4 full we\n\t\t * assume that the packets aren't just out of order but have actually been lost. At 1/2\n\t\t * full we get more aggressive and ask for retransmission when we get a new packet.\n\t\t * To get them back we construct and send a NACK causing the sender to retransmit them.\n\t\t */\n\t\tif (missing_seqnos_added >= MISSING_SEQNOS_ADDED_TRIGGER ||\n\t\t\tast_data_buffer_count(rtp->recv_buffer) == ast_data_buffer_max(rtp->recv_buffer) / 4 ||\n\t\t\tast_data_buffer_count(rtp->recv_buffer) >= ast_data_buffer_max(rtp->recv_buffer) / 2) {\n\t\t\tint packet_len = 0;\n\t\t\tint res = 0;\n\t\t\tint ice;\n\t\t\tint sr;\n\t\t\tsize_t data_size = AST_UUID_STR_LEN + 128 + (AST_VECTOR_SIZE(&rtp->missing_seqno) * 4);\n\t\t\tRAII_VAR(unsigned char *, rtcpheader, NULL, ast_free_ptr);\n\t\t\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report,\n\t\t\t\t\tast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0),\n\t\t\t\t\tao2_cleanup);\n\n\t\t\t/* Sufficient space for RTCP headers and report, SDES with CNAME, NACK header,\n\t\t\t * and worst case 4 bytes per missing sequence number.\n\t\t\t */\n\t\t\trtcpheader = ast_malloc(sizeof(*rtcpheader) + data_size);\n\t\t\tif (!rtcpheader) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to allocate memory for NACK\\n\", instance);\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\n\t\t\tmemset(rtcpheader, 0, data_size);\n\n\t\t\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\t\t\tif (res == 0 || res == 1) {\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\n\t\t\tpacket_len += res;\n\n\t\t\tres = ast_rtcp_generate_nack(instance, rtcpheader + packet_len);\n\n\t\t\tif (res == 0) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to construct NACK, stopping here\\n\", instance);\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\n\t\t\tpacket_len += res;\n\n\t\t\tres = rtcp_sendto(instance, rtcpheader, packet_len, 0, &remote_address, &ice);\n\t\t\tif (res < 0) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to send NACK request out\\n\", instance);\n\t\t\t} else {\n\t\t\t\tast_debug_rtcp(2, \"(%p) RTCP sending a NACK request to get missing packets\\n\", instance);\n\t\t\t\t/* Update RTCP SR/RR statistics */\n\t\t\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, remote_address, ice, sr);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &ast_null_frame;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_prop_set(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (property == AST_RTP_PROPERTY_RTCP) {\n\t\tif (value) {\n\t\t\tstruct ast_sockaddr local_addr;\n\n\t\t\tif (rtp->rtcp && rtp->rtcp->type == value) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP ignoring duplicate property\\n\", instance);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!rtp->rtcp) {\n\t\t\t\trtp->rtcp = ast_calloc(1, sizeof(*rtp->rtcp));\n\t\t\t\tif (!rtp->rtcp) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\trtp->rtcp->s = -1;\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\trtp->rtcp->dtls.timeout_timer = -1;\n#endif\n\t\t\t\trtp->rtcp->schedid = -1;\n\t\t\t}\n\n\t\t\trtp->rtcp->type = value;\n\n\t\t\t/* Grab the IP address and port we are going to use */\n\t\t\tast_rtp_instance_get_local_address(instance, &rtp->rtcp->us);\n\t\t\tif (value == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\t\tast_sockaddr_set_port(&rtp->rtcp->us,\n\t\t\t\t\tast_sockaddr_port(&rtp->rtcp->us) + 1);\n\t\t\t}\n\n\t\t\tast_sockaddr_copy(&local_addr, &rtp->rtcp->us);\n\t\t\tif (!ast_find_ourip(&local_addr, &rtp->rtcp->us, 0)) {\n\t\t\t\tast_sockaddr_set_port(&local_addr, ast_sockaddr_port(&rtp->rtcp->us));\n\t\t\t} else {\n\t\t\t\t/* Failed to get local address reset to use default. */\n\t\t\t\tast_sockaddr_copy(&local_addr, &rtp->rtcp->us);\n\t\t\t}\n\n\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\trtp->rtcp->local_addr_str = ast_strdup(ast_sockaddr_stringify(&local_addr));\n\t\t\tif (!rtp->rtcp->local_addr_str) {\n\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\trtp->rtcp = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (value == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\t\t/* We're either setting up RTCP from scratch or\n\t\t\t\t * switching from MUX. Either way, we won't have\n\t\t\t\t * a socket set up, and we need to set it up\n\t\t\t\t */\n\t\t\t\tif ((rtp->rtcp->s =\n\t\t\t\t     create_new_socket(\"RTCP\",\n\t\t\t\t\t\t       ast_sockaddr_is_ipv4(&rtp->rtcp->us) ?\n\t\t\t\t\t\t       AF_INET :\n\t\t\t\t\t\t       ast_sockaddr_is_ipv6(&rtp->rtcp->us) ?\n\t\t\t\t\t\t       AF_INET6 : -1)) < 0) {\n\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to create a new socket\\n\", instance);\n\t\t\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\t\trtp->rtcp = NULL;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/* Try to actually bind to the IP address and port we are going to use for RTCP, if this fails we have to bail out */\n\t\t\t\tif (ast_bind(rtp->rtcp->s, &rtp->rtcp->us)) {\n\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to setup RTP instance\\n\", instance);\n\t\t\t\t\tclose(rtp->rtcp->s);\n\t\t\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\t\trtp->rtcp = NULL;\n\t\t\t\t\treturn;\n\t\t\t\t}\n#ifdef HAVE_PJPROJECT\n\t\t\t\tif (rtp->ice) {\n\t\t\t\t\trtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP);\n\t\t\t\t}\n#endif\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\tdtls_setup_rtcp(instance);\n#endif\n\t\t\t} else {\n\t\t\t\tstruct ast_sockaddr addr;\n\t\t\t\t/* RTCPMUX uses the same socket as RTP. If we were previously using standard RTCP\n\t\t\t\t * then close the socket we previously created.\n\t\t\t\t *\n\t\t\t\t * It may seem as though there is a possible race condition here where we might try\n\t\t\t\t * to close the RTCP socket while it is being used to send data. However, this is not\n\t\t\t\t * a problem in practice since setting and adjusting of RTCP properties happens prior\n\t\t\t\t * to activating RTP. It is not until RTP is activated that timers start for RTCP\n\t\t\t\t * transmission\n\t\t\t\t */\n\t\t\t\tif (rtp->rtcp->s > -1 && rtp->rtcp->s != rtp->s) {\n\t\t\t\t\tclose(rtp->rtcp->s);\n\t\t\t\t}\n\t\t\t\trtp->rtcp->s = rtp->s;\n\t\t\t\tast_rtp_instance_get_remote_address(instance, &addr);\n\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, &addr);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\tif (rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {\n\t\t\t\t\tSSL_free(rtp->rtcp->dtls.ssl);\n\t\t\t\t}\n\t\t\t\trtp->rtcp->dtls.ssl = rtp->dtls.ssl;\n#endif\n\t\t\t}\n\n\t\t\tast_debug_rtcp(1, \"(%s) RTCP setup on RTP instance\\n\",\n\t\t\t\tast_rtp_instance_get_channel_id(instance));\n\t\t} else {\n\t\t\tif (rtp->rtcp) {\n\t\t\t\tif (rtp->rtcp->schedid > -1) {\n\t\t\t\t\tao2_unlock(instance);\n\t\t\t\t\tif (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {\n\t\t\t\t\t\t/* Successfully cancelled scheduler entry. */\n\t\t\t\t\t\tao2_ref(instance, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Unable to cancel scheduler entry */\n\t\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to tear down RTCP\\n\", instance);\n\t\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\trtp->rtcp->schedid = -1;\n\t\t\t\t}\n\t\t\t\tif (rtp->transport_wide_cc.schedid > -1) {\n\t\t\t\t\tao2_unlock(instance);\n\t\t\t\t\tif (!ast_sched_del(rtp->sched, rtp->transport_wide_cc.schedid)) {\n\t\t\t\t\t\tao2_ref(instance, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to tear down transport-cc feedback\\n\", instance);\n\t\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\trtp->transport_wide_cc.schedid = -1;\n\t\t\t\t}\n\t\t\t\tif (rtp->rtcp->s > -1 && rtp->rtcp->s != rtp->s) {\n\t\t\t\t\tclose(rtp->rtcp->s);\n\t\t\t\t}\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\tao2_unlock(instance);\n\t\t\t\tdtls_srtp_stop_timeout_timer(instance, rtp, 1);\n\t\t\t\tao2_lock(instance);\n\n\t\t\t\tif (rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {\n\t\t\t\t\tSSL_free(rtp->rtcp->dtls.ssl);\n\t\t\t\t}\n#endif\n\t\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\trtp->rtcp = NULL;\n\t\t\t\tast_debug_rtcp(1, \"(%s) RTCP torn down on RTP instance\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance));\n\t\t\t}\n\t\t}\n\t} else if (property == AST_RTP_PROPERTY_ASYMMETRIC_CODEC) {\n\t\trtp->asymmetric_codec = value;\n\t} else if (property == AST_RTP_PROPERTY_RETRANS_SEND) {\n\t\tif (value) {\n\t\t\tif (!rtp->send_buffer) {\n\t\t\t\trtp->send_buffer = ast_data_buffer_alloc(ast_free_ptr, DEFAULT_RTP_SEND_BUFFER_SIZE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp->send_buffer) {\n\t\t\t\tast_data_buffer_free(rtp->send_buffer);\n\t\t\t\trtp->send_buffer = NULL;\n\t\t\t}\n\t\t}\n\t} else if (property == AST_RTP_PROPERTY_RETRANS_RECV) {\n\t\tif (value) {\n\t\t\tif (!rtp->recv_buffer) {\n\t\t\t\trtp->recv_buffer = ast_data_buffer_alloc(ast_free_ptr, DEFAULT_RTP_RECV_BUFFER_SIZE);\n\t\t\t\tAST_VECTOR_INIT(&rtp->missing_seqno, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp->recv_buffer) {\n\t\t\t\tast_data_buffer_free(rtp->recv_buffer);\n\t\t\t\trtp->recv_buffer = NULL;\n\t\t\t\tAST_VECTOR_FREE(&rtp->missing_seqno);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_fd(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtcp ? (rtp->rtcp ? rtp->rtcp->s : -1) : rtp->s;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr local;\n\tint index;\n\n\tast_rtp_instance_get_local_address(instance, &local);\n\tif (!ast_sockaddr_isnull(addr)) {\n\t\t/* Update the local RTP address with what is being used */\n\t\tif (ast_ouraddrfor(addr, &local)) {\n\t\t\t/* Failed to update our address so reuse old local address */\n\t\t\tast_rtp_instance_get_local_address(instance, &local);\n\t\t} else {\n\t\t\tast_rtp_instance_set_local_address(instance, &local);\n\t\t}\n\t}\n\n\tif (rtp->rtcp && !ast_sockaddr_isnull(addr)) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP setting address on RTP instance\\n\", instance);\n\t\tast_sockaddr_copy(&rtp->rtcp->them, addr);\n\n\t\tif (rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\tast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(addr) + 1);\n\n\t\t\t/* Update the local RTCP address with what is being used */\n\t\t\tast_sockaddr_set_port(&local, ast_sockaddr_port(&local) + 1);\n\t\t}\n\t\tast_sockaddr_copy(&rtp->rtcp->us, &local);\n\n\t\tast_free(rtp->rtcp->local_addr_str);\n\t\trtp->rtcp->local_addr_str = ast_strdup(ast_sockaddr_stringify(&local));\n\t}\n\n\t/* Update any bundled RTP instances */\n\tfor (index = 0; index < AST_VECTOR_SIZE(&rtp->ssrc_mapping); ++index) {\n\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&rtp->ssrc_mapping, index);\n\n\t\tast_rtp_instance_set_remote_address(mapping->instance, addr);\n\t}\n\n\t/* Need to reset the DTMF last sequence number and the timestamp of the last END packet */\n\trtp->last_seqno = 0;\n\trtp->last_end_timestamp.ts = 0;\n\trtp->last_end_timestamp.is_set = 0;\n\n\tif (strictrtp && rtp->strict_rtp_state != STRICT_RTP_OPEN\n\t\t&& !ast_sockaddr_isnull(addr) && ast_sockaddr_cmp(addr, &rtp->strict_rtp_address)) {\n\t\t/* We only need to learn a new strict source address if we've been told the source is\n\t\t * changing to something different.\n\t\t */\n\t\tast_verb(4, \"%p -- Strict RTP learning after remote address set to: %s\\n\",\n\t\t\trtp, ast_sockaddr_stringify(addr));\n\t\trtp_learning_start(rtp);\n\t}\n}\n\n/*!\n * \\brief Write t140 redundancy frame\n *\n * \\param data primary data to be buffered\n *\n * Scheduler callback\n */\nstatic int red_write(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance*) data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\tif (rtp->red->t140.datalen > 0) {\n\t\tast_rtp_write(instance, &rtp->red->t140);\n\t}\n\tao2_unlock(instance);\n\n\treturn 1;\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint x;\n\n\trtp->red = ast_calloc(1, sizeof(*rtp->red));\n\tif (!rtp->red) {\n\t\treturn -1;\n\t}\n\n\trtp->red->t140.frametype = AST_FRAME_TEXT;\n\trtp->red->t140.subclass.format = ast_format_t140_red;\n\trtp->red->t140.data.ptr = &rtp->red->buf_data;\n\n\trtp->red->t140red = rtp->red->t140;\n\trtp->red->t140red.data.ptr = &rtp->red->t140red_data;\n\n\trtp->red->ti = buffer_time;\n\trtp->red->num_gen = generations;\n\trtp->red->hdrlen = generations * 4 + 1;\n\n\tfor (x = 0; x < generations; x++) {\n\t\trtp->red->pt[x] = payloads[x];\n\t\trtp->red->pt[x] |= 1 << 7; /* mark redundant generations pt */\n\t\trtp->red->t140red_data[x*4] = rtp->red->pt[x];\n\t}\n\trtp->red->t140red_data[x*4] = rtp->red->pt[x] = payloads[x]; /* primary pt */\n\trtp->red->schedid = ast_sched_add(rtp->sched, generations, red_write, instance);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_red_buffer(struct ast_rtp_instance *instance, struct ast_frame *frame)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct rtp_red *red = rtp->red;\n\n\tif (!red) {\n\t\treturn 0;\n\t}\n\n\tif (frame->datalen > 0) {\n\t\tif (red->t140.datalen > 0) {\n\t\t\tconst unsigned char *primary = red->buf_data;\n\n\t\t\t/* There is something already in the T.140 buffer */\n\t\t\tif (primary[0] == 0x08 || primary[0] == 0x0a || primary[0] == 0x0d) {\n\t\t\t\t/* Flush the previous T.140 packet if it is a command */\n\t\t\t\tast_rtp_write(instance, &rtp->red->t140);\n\t\t\t} else {\n\t\t\t\tprimary = frame->data.ptr;\n\t\t\t\tif (primary[0] == 0x08 || primary[0] == 0x0a || primary[0] == 0x0d) {\n\t\t\t\t\t/* Flush the previous T.140 packet if we are buffering a command now */\n\t\t\t\t\tast_rtp_write(instance, &rtp->red->t140);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(&red->buf_data[red->t140.datalen], frame->data.ptr, frame->datalen);\n\t\tred->t140.datalen += frame->datalen;\n\t\tred->t140.ts = frame->ts;\n\t}\n\n\treturn 0;\n}\n\n/*! \\pre Neither instance0 nor instance1 are locked */\nstatic int ast_rtp_local_bridge(struct ast_rtp_instance *instance0, struct ast_rtp_instance *instance1)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance0);\n\n\tao2_lock(instance0);\n\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT | FLAG_REQ_LOCAL_BRIDGE_BIT);\n\tif (rtp->smoother) {\n\t\tast_smoother_free(rtp->smoother);\n\t\trtp->smoother = NULL;\n\t}\n\n\t/* We must use a new SSRC when local bridge ends */\n\tif (!instance1) {\n\t\trtp->ssrc = rtp->ssrc_orig;\n\t\trtp->ssrc_orig = 0;\n\t\trtp->ssrc_saved = 0;\n\t} else if (!rtp->ssrc_saved) {\n\t\t/* In case ast_rtp_local_bridge is called multiple times, only save the ssrc from before local bridge began */\n\t\trtp->ssrc_orig = rtp->ssrc;\n\t\trtp->ssrc_saved = 1;\n\t}\n\n\tao2_unlock(instance0);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_get_stat(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->rtcp) {\n\t\treturn -1;\n\t}\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXCOUNT, -1, stats->txcount, rtp->txcount);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXCOUNT, -1, stats->rxcount, rtp->rxcount);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXOCTETCOUNT, -1, stats->txoctetcount, rtp->txoctetcount);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXOCTETCOUNT, -1, stats->rxoctetcount, rtp->rxoctetcount);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->txploss, rtp->rtcp->reported_lost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->rxploss, rtp->rtcp->expected_prior - rtp->rtcp->received_prior);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MAXRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_maxrxploss, rtp->rtcp->reported_maxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MINRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_minrxploss, rtp->rtcp->reported_minlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_NORMDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_normdevrxploss, rtp->rtcp->reported_normdev_lost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_STDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_stdevrxploss, rtp->rtcp->reported_stdev_lost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MAXRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_maxrxploss, rtp->rtcp->maxrxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MINRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_minrxploss, rtp->rtcp->minrxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_NORMDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_normdevrxploss, rtp->rtcp->normdev_rxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_STDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_stdevrxploss, rtp->rtcp->stdev_rxlost);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_LOSS);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->txjitter, rtp->rxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->rxjitter, rtp->rtcp->reported_jitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MAXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_maxjitter, rtp->rtcp->reported_maxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MINJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_minjitter, rtp->rtcp->reported_minjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_NORMDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_normdevjitter, rtp->rtcp->reported_normdev_jitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_STDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_stdevjitter, rtp->rtcp->reported_stdev_jitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MAXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_maxjitter, rtp->rtcp->maxrxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MINJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_minjitter, rtp->rtcp->minrxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_NORMDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_normdevjitter, rtp->rtcp->normdev_rxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_STDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_stdevjitter, rtp->rtcp->stdev_rxjitter);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_JITTER);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->rtt, rtp->rtcp->rtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_MAX_RTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->maxrtt, rtp->rtcp->maxrtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_MIN_RTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->minrtt, rtp->rtcp->minrtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_NORMDEVRTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->normdevrtt, rtp->rtcp->normdevrtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_STDEVRTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->stdevrtt, rtp->rtcp->stdevrtt);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_RTT);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->txmes, rtp->rxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->rxmes, rtp->rtcp->reported_mes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MAXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_maxmes, rtp->rtcp->reported_maxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MINMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_minmes, rtp->rtcp->reported_minmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_NORMDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_normdevmes, rtp->rtcp->reported_normdev_mes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_STDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_stdevmes, rtp->rtcp->reported_stdev_mes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MAXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_maxmes, rtp->rtcp->maxrxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MINMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_minmes, rtp->rtcp->minrxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_NORMDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_normdevmes, rtp->rtcp->normdev_rxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_STDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_stdevmes, rtp->rtcp->stdev_rxjitter);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_MES);\n\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_SSRC, -1, stats->local_ssrc, rtp->ssrc);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_SSRC, -1, stats->remote_ssrc, rtp->themssrc);\n\tAST_RTP_STAT_STRCPY(AST_RTP_INSTANCE_STAT_CHANNEL_UNIQUEID, -1, stats->channel_uniqueid, ast_rtp_instance_get_channel_id(instance));\n\n\treturn 0;\n}\n\n/*! \\pre Neither instance0 nor instance1 are locked */\nstatic int ast_rtp_dtmf_compatible(struct ast_channel *chan0, struct ast_rtp_instance *instance0, struct ast_channel *chan1, struct ast_rtp_instance *instance1)\n{\n\t/* If both sides are not using the same method of DTMF transmission\n\t * (ie: one is RFC2833, other is INFO... then we can not do direct media.\n\t * --------------------------------------------------\n\t * | DTMF Mode |  HAS_DTMF  |  Accepts Begin Frames |\n\t * |-----------|------------|-----------------------|\n\t * | Inband    | False      | True                  |\n\t * | RFC2833   | True       | True                  |\n\t * | SIP INFO  | False      | False                 |\n\t * --------------------------------------------------\n\t */\n\treturn (((ast_rtp_instance_get_prop(instance0, AST_RTP_PROPERTY_DTMF) != ast_rtp_instance_get_prop(instance1, AST_RTP_PROPERTY_DTMF)) ||\n\t\t (!ast_channel_tech(chan0)->send_digit_begin != !ast_channel_tech(chan1)->send_digit_begin)) ? 0 : 1);\n}\n\n/*! \\pre instance is NOT locked */\nstatic void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct sockaddr_in suggestion_tmp;\n\n\t/*\n\t * The instance should not be locked because we can block\n\t * waiting for a STUN respone.\n\t */\n\tast_sockaddr_to_sin(suggestion, &suggestion_tmp);\n\tast_stun_request(rtp->s, &suggestion_tmp, username, NULL);\n\tast_sockaddr_from_sin(suggestion, &suggestion_tmp);\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_stop(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr addr = { {0,} };\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tao2_unlock(instance);\n\tAST_SCHED_DEL_UNREF(rtp->sched, rtp->rekeyid, ao2_ref(instance, -1));\n\n\tdtls_srtp_stop_timeout_timer(instance, rtp, 0);\n\tif (rtp->rtcp) {\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, 1);\n\t}\n\tao2_lock(instance);\n#endif\n\tast_debug_rtp(1, \"(%s) RTP Stop\\n\",\n\t\tast_rtp_instance_get_channel_id(instance));\n\n\tif (rtp->rtcp && rtp->rtcp->schedid > -1) {\n\t\tao2_unlock(instance);\n\t\tif (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {\n\t\t\t/* successfully cancelled scheduler entry. */\n\t\t\tao2_ref(instance, -1);\n\t\t}\n\t\tao2_lock(instance);\n\t\trtp->rtcp->schedid = -1;\n\t}\n\n\tif (rtp->transport_wide_cc.schedid > -1) {\n\t\tao2_unlock(instance);\n\t\tif (!ast_sched_del(rtp->sched, rtp->transport_wide_cc.schedid)) {\n\t\t\tao2_ref(instance, -1);\n\t\t}\n\t\tao2_lock(instance);\n\t\trtp->transport_wide_cc.schedid = -1;\n        }\n\n\tif (rtp->red) {\n\t\tao2_unlock(instance);\n\t\tAST_SCHED_DEL(rtp->sched, rtp->red->schedid);\n\t\tao2_lock(instance);\n\t\tast_free(rtp->red);\n\t\trtp->red = NULL;\n\t}\n\n\tast_rtp_instance_set_remote_address(instance, &addr);\n\n\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT);\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char *desc)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn ast_set_qos(rtp->s, tos, cos, desc);\n}\n\n/*!\n * \\brief generate comfort noice (CNG)\n *\n * \\pre instance is locked\n */\nstatic int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level)\n{\n\tunsigned int *rtpheader;\n\tint hdrlen = 12;\n\tint res, payload = 0;\n\tchar data[256];\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint ice;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn -1;\n\t}\n\n\tpayload = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance), 0, NULL, AST_RTP_CN);\n\n\tlevel = 127 - (level & 0x7f);\n\n\trtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));\n\n\t/* Get a pointer to the header */\n\trtpheader = (unsigned int *)data;\n\trtpheader[0] = htonl((2 << 30) | (payload << 16) | (rtp->seqno));\n\trtpheader[1] = htonl(rtp->lastts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\tdata[12] = level;\n\n\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 1, 0, &remote_address, &ice);\n\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTP Comfort Noise Transmission error to %s: %s\\n\", ast_sockaddr_stringify(&remote_address), strerror(errno));\n\t\treturn res;\n\t}\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Sent Comfort Noise RTP packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t    AST_RTP_CN, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t}\n\n\trtp->seqno++;\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic unsigned int ast_rtp_get_ssrc(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->ssrc;\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_get_cname(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->cname;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_set_remote_ssrc(struct ast_rtp_instance *instance, unsigned int ssrc)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->themssrc_valid && rtp->themssrc == ssrc) {\n\t\treturn;\n\t}\n\n\trtp->themssrc = ssrc;\n\trtp->themssrc_valid = 1;\n\n\t/* If this is bundled we need to update the SSRC mapping */\n\tif (rtp->bundled) {\n\t\tstruct ast_rtp *bundled_rtp;\n\t\tint index;\n\n\t\tao2_unlock(instance);\n\n\t\t/* The child lock can't be held while accessing the parent */\n\t\tao2_lock(rtp->bundled);\n\t\tbundled_rtp = ast_rtp_instance_get_data(rtp->bundled);\n\n\t\tfor (index = 0; index < AST_VECTOR_SIZE(&bundled_rtp->ssrc_mapping); ++index) {\n\t\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&bundled_rtp->ssrc_mapping, index);\n\n\t\t\tif (mapping->instance == instance) {\n\t\t\t\tmapping->ssrc = ssrc;\n\t\t\t\tmapping->ssrc_valid = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tao2_unlock(rtp->bundled);\n\n\t\tao2_lock(instance);\n\t}\n}\n\nstatic void ast_rtp_set_stream_num(struct ast_rtp_instance *instance, int stream_num)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\trtp->stream_num = stream_num;\n}\n\nstatic int ast_rtp_extension_enable(struct ast_rtp_instance *instance, enum ast_rtp_extension extension)\n{\n\tswitch (extension) {\n\tcase AST_RTP_EXTENSION_ABS_SEND_TIME:\n\tcase AST_RTP_EXTENSION_TRANSPORT_WIDE_CC:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/*! \\pre child is locked */\nstatic int ast_rtp_bundle(struct ast_rtp_instance *child, struct ast_rtp_instance *parent)\n{\n\tstruct ast_rtp *child_rtp = ast_rtp_instance_get_data(child);\n\tstruct ast_rtp *parent_rtp;\n\tstruct rtp_ssrc_mapping mapping;\n\tstruct ast_sockaddr them = { { 0, } };\n\n\tif (child_rtp->bundled == parent) {\n\t\treturn 0;\n\t}\n\n\t/* If this instance was already bundled then remove the SSRC mapping */\n\tif (child_rtp->bundled) {\n\t\tstruct ast_rtp *bundled_rtp;\n\n\t\tao2_unlock(child);\n\n\t\t/* The child lock can't be held while accessing the parent */\n\t\tao2_lock(child_rtp->bundled);\n\t\tbundled_rtp = ast_rtp_instance_get_data(child_rtp->bundled);\n\t\tAST_VECTOR_REMOVE_CMP_UNORDERED(&bundled_rtp->ssrc_mapping, child, SSRC_MAPPING_ELEM_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\t\tao2_unlock(child_rtp->bundled);\n\n\t\tao2_lock(child);\n\t\tao2_ref(child_rtp->bundled, -1);\n\t\tchild_rtp->bundled = NULL;\n\t}\n\n\tif (!parent) {\n\t\t/* We transitioned away from bundle so we need our own transport resources once again */\n\t\trtp_allocate_transport(child, child_rtp);\n\t\treturn 0;\n\t}\n\n\tparent_rtp = ast_rtp_instance_get_data(parent);\n\n\t/* We no longer need any transport related resources as we will use our parent RTP instance instead */\n\trtp_deallocate_transport(child, child_rtp);\n\n\t/* Children maintain a reference to the parent to guarantee that the transport doesn't go away on them */\n\tchild_rtp->bundled = ao2_bump(parent);\n\n\tmapping.ssrc = child_rtp->themssrc;\n\tmapping.ssrc_valid = child_rtp->themssrc_valid;\n\tmapping.instance = child;\n\n\tao2_unlock(child);\n\n\tao2_lock(parent);\n\n\tAST_VECTOR_APPEND(&parent_rtp->ssrc_mapping, mapping);\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If DTLS-SRTP is already in use then add the local SSRC to it, otherwise it will get added once DTLS\n\t * negotiation has been completed.\n\t */\n\tif (parent_rtp->dtls.connection == AST_RTP_DTLS_CONNECTION_EXISTING) {\n\t\tdtls_srtp_add_local_ssrc(parent_rtp, parent, 0, child_rtp->ssrc, 0);\n\t}\n#endif\n\n\t/* Bundle requires that RTCP-MUX be in use so only the main remote address needs to match */\n\tast_rtp_instance_get_remote_address(parent, &them);\n\n\tao2_unlock(parent);\n\n\tao2_lock(child);\n\n\tast_rtp_instance_set_remote_address(child, &them);\n\n\treturn 0;\n}\n\n#ifdef HAVE_PJPROJECT\nstatic void stunaddr_resolve_callback(const struct ast_dns_query *query)\n{\n\tconst int lowest_ttl = ast_dns_result_get_lowest_ttl(ast_dns_query_get_result(query));\n\tconst char *stunaddr_name = ast_dns_query_get_name(query);\n\tconst char *stunaddr_resolved_str;\n\n\tif (!store_stunaddr_resolved(query)) {\n\t\tast_log(LOG_WARNING, \"Failed to resolve stunaddr '%s'. Cancelling recurring resolution.\\n\", stunaddr_name);\n\t\treturn;\n\t}\n\n\tif (DEBUG_ATLEAST(2)) {\n\t\tast_rwlock_rdlock(&stunaddr_lock);\n\t\tstunaddr_resolved_str = ast_inet_ntoa(stunaddr.sin_addr);\n\t\tast_rwlock_unlock(&stunaddr_lock);\n\n\t\tast_debug_stun(2, \"Resolved stunaddr '%s' to '%s'. Lowest TTL = %d.\\n\",\n\t\t\tstunaddr_name,\n\t\t\tstunaddr_resolved_str,\n\t\t\tlowest_ttl);\n\t}\n\n\tif (!lowest_ttl) {\n\t\tast_log(LOG_WARNING, \"Resolution for stunaddr '%s' returned TTL = 0. Recurring resolution was cancelled.\\n\", ast_dns_query_get_name(query));\n\t}\n}\n\nstatic int store_stunaddr_resolved(const struct ast_dns_query *query)\n{\n\tconst struct ast_dns_result *result = ast_dns_query_get_result(query);\n\tconst struct ast_dns_record *record;\n\n\tfor (record = ast_dns_result_get_records(result); record; record = ast_dns_record_get_next(record)) {\n\t\tconst size_t data_size = ast_dns_record_get_data_size(record);\n\t\tconst unsigned char *data = (unsigned char *)ast_dns_record_get_data(record);\n\t\tconst int rr_type = ast_dns_record_get_rr_type(record);\n\n\t\tif (rr_type == ns_t_a && data_size == 4) {\n\t\t\tast_rwlock_wrlock(&stunaddr_lock);\n\t\t\tmemcpy(&stunaddr.sin_addr, data, data_size);\n\t\t\tstunaddr.sin_family = AF_INET;\n\t\t\tast_rwlock_unlock(&stunaddr_lock);\n\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tast_debug_stun(3, \"Unrecognized rr_type '%u' or data_size '%zu' from DNS query for stunaddr '%s'\\n\",\n\t\t\t\t\t\t\t\t\t\t rr_type, data_size, ast_dns_query_get_name(query));\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void clean_stunaddr(void) {\n\tif (stunaddr_resolver) {\n\t\tif (ast_dns_resolve_recurring_cancel(stunaddr_resolver)) {\n\t\t\tast_log(LOG_ERROR, \"Failed to cancel recurring DNS resolution of previous stunaddr.\\n\");\n\t\t}\n\t\tao2_ref(stunaddr_resolver, -1);\n\t\tstunaddr_resolver = NULL;\n\t}\n\tast_rwlock_wrlock(&stunaddr_lock);\n\tmemset(&stunaddr, 0, sizeof(stunaddr));\n\tast_rwlock_unlock(&stunaddr_lock);\n}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n/*! \\pre instance is locked */\nstatic int ast_rtp_activate(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* If ICE negotiation is enabled the DTLS Handshake will be performed upon completion of it */\n#ifdef HAVE_PJPROJECT\n\tif (rtp->ice) {\n\t\treturn 0;\n\t}\n#endif\n\n\tast_debug_dtls(3, \"(%p) DTLS - ast_rtp_activate rtp=%p - setup and perform DTLS'\\n\", instance, rtp);\n\n\tdtls_perform_setup(&rtp->dtls);\n\tdtls_perform_handshake(instance, &rtp->dtls, 0);\n\n\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\tdtls_perform_setup(&rtp->rtcp->dtls);\n\t\tdtls_perform_handshake(instance, &rtp->rtcp->dtls, 1);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic char *rtp_do_debug_ip(struct ast_cli_args *a)\n{\n\tchar *arg = ast_strdupa(a->argv[4]);\n\tchar *debughost = NULL;\n\tchar *debugport = NULL;\n\n\tif (!ast_sockaddr_parse(&rtpdebugaddr, arg, 0) || !ast_sockaddr_split_hostport(arg, &debughost, &debugport, 0)) {\n\t\tast_cli(a->fd, \"Lookup failed for '%s'\\n\", arg);\n\t\treturn CLI_FAILURE;\n\t}\n\trtpdebugport = (!ast_strlen_zero(debugport) && debugport[0] != '0');\n\tast_cli(a->fd, \"RTP Packet Debugging Enabled for address: %s\\n\",\n\t\tast_sockaddr_stringify(&rtpdebugaddr));\n\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\treturn CLI_SUCCESS;\n}\n\nstatic char *rtcp_do_debug_ip(struct ast_cli_args *a)\n{\n\tchar *arg = ast_strdupa(a->argv[4]);\n\tchar *debughost = NULL;\n\tchar *debugport = NULL;\n\n\tif (!ast_sockaddr_parse(&rtcpdebugaddr, arg, 0) || !ast_sockaddr_split_hostport(arg, &debughost, &debugport, 0)) {\n\t\tast_cli(a->fd, \"Lookup failed for '%s'\\n\", arg);\n\t\treturn CLI_FAILURE;\n\t}\n\trtcpdebugport = (!ast_strlen_zero(debugport) && debugport[0] != '0');\n\tast_cli(a->fd, \"RTCP Packet Debugging Enabled for address: %s\\n\",\n\t\tast_sockaddr_stringify(&rtcpdebugaddr));\n\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTCP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_cli_rtp_set_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtp set debug {on|off|ip}\";\n\t\te->usage =\n\t\t\t\"Usage: rtp set debug {on|off|ip host[:port]}\\n\"\n\t\t\t\"       Enable/Disable dumping of all RTP packets. If 'ip' is\\n\"\n\t\t\t\"       specified, limit the dumped packets to those to and from\\n\"\n\t\t\t\"       the specified 'host' with optional port.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc == e->args) { /* set on or off */\n\t\tif (!strncasecmp(a->argv[e->args-1], \"on\", 2)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\t\t\tmemset(&rtpdebugaddr, 0, sizeof(rtpdebugaddr));\n\t\t\tast_cli(a->fd, \"RTP Packet Debugging Enabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t} else if (!strncasecmp(a->argv[e->args-1], \"off\", 3)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTP_PACKET, AST_LOG_CATEGORY_DISABLED);\n\t\t\tast_cli(a->fd, \"RTP Packet Debugging Disabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t} else if (a->argc == e->args +1) { /* ip */\n\t\treturn rtp_do_debug_ip(a);\n\t}\n\n\treturn CLI_SHOWUSAGE;   /* default, failure */\n}\n\n\nstatic char *handle_cli_rtp_settings(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n#ifdef HAVE_PJPROJECT\n\tstruct sockaddr_in stunaddr_copy;\n#endif\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtp show settings\";\n\t\te->usage =\n\t\t\t\"Usage: rtp show settings\\n\"\n\t\t\t\"       Display RTP configuration settings\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tast_cli(a->fd, \"\\n\\nGeneral Settings:\\n\");\n\tast_cli(a->fd, \"----------------\\n\");\n\tast_cli(a->fd, \"  Port start:      %d\\n\", rtpstart);\n\tast_cli(a->fd, \"  Port end:        %d\\n\", rtpend);\n#ifdef SO_NO_CHECK\n\tast_cli(a->fd, \"  Checksums:       %s\\n\", AST_CLI_YESNO(nochecksums == 0));\n#endif\n\tast_cli(a->fd, \"  DTMF Timeout:    %d\\n\", dtmftimeout);\n\tast_cli(a->fd, \"  Strict RTP:      %s\\n\", AST_CLI_YESNO(strictrtp));\n\n\tif (strictrtp) {\n\t\tast_cli(a->fd, \"  Probation:       %d frames\\n\", learning_min_sequential);\n\t}\n\n\tast_cli(a->fd, \"  Replay Protect:  %s\\n\", AST_CLI_YESNO(srtp_replay_protection));\n#ifdef HAVE_PJPROJECT\n\tast_cli(a->fd, \"  ICE support:     %s\\n\", AST_CLI_YESNO(icesupport));\n\n\tast_rwlock_rdlock(&stunaddr_lock);\n\tmemcpy(&stunaddr_copy, &stunaddr, sizeof(stunaddr));\n\tast_rwlock_unlock(&stunaddr_lock);\n\tast_cli(a->fd, \"  STUN address:    %s:%d\\n\", ast_inet_ntoa(stunaddr_copy.sin_addr), htons(stunaddr_copy.sin_port));\n#endif\n\treturn CLI_SUCCESS;\n}\n\n\nstatic char *handle_cli_rtcp_set_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtcp set debug {on|off|ip}\";\n\t\te->usage =\n\t\t\t\"Usage: rtcp set debug {on|off|ip host[:port]}\\n\"\n\t\t\t\"       Enable/Disable dumping of all RTCP packets. If 'ip' is\\n\"\n\t\t\t\"       specified, limit the dumped packets to those to and from\\n\"\n\t\t\t\"       the specified 'host' with optional port.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc == e->args) { /* set on or off */\n\t\tif (!strncasecmp(a->argv[e->args-1], \"on\", 2)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTCP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\t\t\tmemset(&rtcpdebugaddr, 0, sizeof(rtcpdebugaddr));\n\t\t\tast_cli(a->fd, \"RTCP Packet Debugging Enabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t} else if (!strncasecmp(a->argv[e->args-1], \"off\", 3)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTCP_PACKET, AST_LOG_CATEGORY_DISABLED);\n\t\t\tast_cli(a->fd, \"RTCP Packet Debugging Disabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t} else if (a->argc == e->args +1) { /* ip */\n\t\treturn rtcp_do_debug_ip(a);\n\t}\n\n\treturn CLI_SHOWUSAGE;   /* default, failure */\n}\n\nstatic char *handle_cli_rtcp_set_stats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtcp set stats {on|off}\";\n\t\te->usage =\n\t\t\t\"Usage: rtcp set stats {on|off}\\n\"\n\t\t\t\"       Enable/Disable dumping of RTCP stats.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != e->args)\n\t\treturn CLI_SHOWUSAGE;\n\n\tif (!strncasecmp(a->argv[e->args-1], \"on\", 2))\n\t\trtcpstats = 1;\n\telse if (!strncasecmp(a->argv[e->args-1], \"off\", 3))\n\t\trtcpstats = 0;\n\telse\n\t\treturn CLI_SHOWUSAGE;\n\n\tast_cli(a->fd, \"RTCP Stats %s\\n\", rtcpstats ? \"Enabled\" : \"Disabled\");\n\treturn CLI_SUCCESS;\n}\n\n#ifdef AST_DEVMODE\n\nstatic unsigned int use_random(struct ast_cli_args *a, int pos, unsigned int index)\n{\n\treturn pos >= index && !ast_strlen_zero(a->argv[index - 1]) &&\n\t\t!strcasecmp(a->argv[index - 1], \"random\");\n}\n\nstatic char *handle_cli_rtp_drop_incoming_packets(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstatic const char * const completions_2[] = { \"stop\", \"<N>\", NULL };\n\tstatic const char * const completions_3[] = { \"random\", \"incoming packets\", NULL };\n\tstatic const char * const completions_5[] = { \"on\", \"every\", NULL };\n\tstatic const char * const completions_units[] =\t{ \"random\", \"usec\", \"msec\", \"sec\", \"min\", NULL };\n\n\tunsigned int use_random_num = 0;\n\tunsigned int use_random_interval = 0;\n\tunsigned int num_to_drop = 0;\n\tunsigned int interval = 0;\n\tconst char *interval_s = NULL;\n\tconst char *unit_s = NULL;\n\tstruct ast_sockaddr addr;\n\tconst char *addr_s = NULL;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtp drop\";\n\t\te->usage =\n\t\t\t\"Usage: rtp drop [stop|[<N> [random] incoming packets[ every <N> [random] {usec|msec|sec|min}][ on <ip[:port]>]]\\n\"\n\t\t\t\"       Drop RTP incoming packets.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tuse_random_num = use_random(a, a->pos, 4);\n\t\tuse_random_interval = use_random(a, a->pos, 8 + use_random_num) ||\n\t\t\tuse_random(a, a->pos, 10 + use_random_num);\n\n\t\tswitch (a->pos - use_random_num - use_random_interval) {\n\t\tcase 2:\n\t\t\treturn ast_cli_complete(a->word, completions_2, a->n);\n\t\tcase 3:\n\t\t\treturn ast_cli_complete(a->word, completions_3 + use_random_num, a->n);\n\t\tcase 5:\n\t\t\treturn ast_cli_complete(a->word, completions_5, a->n);\n\t\tcase 7:\n\t\t\tif (!strcasecmp(a->argv[a->pos - 2], \"on\")) {\n\t\t\t\tast_cli_completion_add(ast_strdup(\"every\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall through */\n\t\tcase 9:\n\t\t\tif (!strcasecmp(a->argv[a->pos - 2 - use_random_interval], \"every\")) {\n\t\t\t\treturn ast_cli_complete(a->word, completions_units + use_random_interval, a->n);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (!strcasecmp(a->argv[a->pos - 3 - use_random_interval], \"every\")) {\n\t\t\t\tast_cli_completion_add(ast_strdup(\"on\"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\tif (a->argc < 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tuse_random_num = use_random(a, a->argc, 4);\n\tuse_random_interval = use_random(a, a->argc, 8 + use_random_num) ||\n\t\tuse_random(a, a->argc, 10 + use_random_num);\n\n\tif (!strcasecmp(a->argv[2], \"stop\")) {\n\t\t/* rtp drop stop */\n\t} else if (a->argc < 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t} else if (ast_str_to_uint(a->argv[2], &num_to_drop)) {\n\t\tast_cli(a->fd, \"%s is not a valid number of packets to drop\\n\", a->argv[2]);\n\t\treturn CLI_FAILURE;\n\t} else if (a->argc - use_random_num == 5) {\n\t\t/* rtp drop <N> [random] incoming packets */\n\t} else if (a->argc - use_random_num >= 7 && !strcasecmp(a->argv[5 + use_random_num], \"on\")) {\n\t\t/* rtp drop <N> [random] incoming packets on <ip[:port]> */\n\t\taddr_s = a->argv[6 + use_random_num];\n\t\tif (a->argc - use_random_num - use_random_interval == 10 &&\n\t\t\t\t!strcasecmp(a->argv[7 + use_random_num], \"every\")) {\n\t\t\t/* rtp drop <N> [random] incoming packets on <ip[:port]> every <N> [random] {usec|msec|sec|min} */\n\t\t\tinterval_s = a->argv[8 + use_random_num];\n\t\t\tunit_s = a->argv[9 + use_random_num + use_random_interval];\n\t\t}\n\t} else if (a->argc - use_random_num >= 8 && !strcasecmp(a->argv[5 + use_random_num], \"every\")) {\n\t\t/* rtp drop <N> [random] incoming packets every <N> [random] {usec|msec|sec|min} */\n\t\tinterval_s = a->argv[6 + use_random_num];\n\t\tunit_s = a->argv[7 + use_random_num + use_random_interval];\n\t\tif (a->argc == 10 + use_random_num + use_random_interval &&\n\t\t\t\t!strcasecmp(a->argv[8 + use_random_num + use_random_interval], \"on\")) {\n\t\t\t/* rtp drop <N> [random] incoming packets every <N> [random] {usec|msec|sec|min} on <ip[:port]> */\n\t\t\taddr_s = a->argv[9 + use_random_num + use_random_interval];\n\t\t}\n\t} else {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tif (a->argc - use_random_num >= 8 && !interval_s && !addr_s) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tif (interval_s && ast_str_to_uint(interval_s, &interval)) {\n\t\tast_cli(a->fd, \"%s is not a valid interval number\\n\", interval_s);\n\t\treturn CLI_FAILURE;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\tif (addr_s && !ast_sockaddr_parse(&addr, addr_s, 0)) {\n\t\tast_cli(a->fd, \"%s is not a valid hostname[:port]\\n\", addr_s);\n\t\treturn CLI_FAILURE;\n\t}\n\n\tdrop_packets_data.use_random_num = use_random_num;\n\tdrop_packets_data.use_random_interval = use_random_interval;\n\tdrop_packets_data.num_to_drop = num_to_drop;\n\tdrop_packets_data.interval = ast_time_create_by_unit_str(interval, unit_s);\n\tast_sockaddr_copy(&drop_packets_data.addr, &addr);\n\tdrop_packets_data.port = ast_sockaddr_port(&addr);\n\n\tdrop_packets_data_update(ast_tvnow());\n\n\treturn CLI_SUCCESS;\n}\n#endif\n\nstatic struct ast_cli_entry cli_rtp[] = {\n\tAST_CLI_DEFINE(handle_cli_rtp_set_debug,  \"Enable/Disable RTP debugging\"),\n\tAST_CLI_DEFINE(handle_cli_rtp_settings,   \"Display RTP settings\"),\n\tAST_CLI_DEFINE(handle_cli_rtcp_set_debug, \"Enable/Disable RTCP debugging\"),\n\tAST_CLI_DEFINE(handle_cli_rtcp_set_stats, \"Enable/Disable RTCP stats\"),\n#ifdef AST_DEVMODE\n\tAST_CLI_DEFINE(handle_cli_rtp_drop_incoming_packets, \"Drop RTP incoming packets\"),\n#endif\n};\n\nstatic int rtp_reload(int reload, int by_external_config)\n{\n\tstruct ast_config *cfg;\n\tconst char *s;\n\tstruct ast_flags config_flags = { (reload && !by_external_config) ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\n#ifdef HAVE_PJPROJECT\n\tstruct ast_variable *var;\n\tstruct ast_ice_host_candidate *candidate;\n\tint acl_subscription_flag = 0;\n#endif\n\n\tcfg = ast_config_load2(\"rtp.conf\", \"rtp\", config_flags);\n\tif (!cfg || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\treturn 0;\n\t}\n\n#ifdef SO_NO_CHECK\n\tnochecksums = 0;\n#endif\n\n\trtpstart = DEFAULT_RTP_START;\n\trtpend = DEFAULT_RTP_END;\n\trtcpinterval = RTCP_DEFAULT_INTERVALMS;\n\tdtmftimeout = DEFAULT_DTMF_TIMEOUT;\n\tstrictrtp = DEFAULT_STRICT_RTP;\n\tlearning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL;\n\tlearning_min_duration = DEFAULT_LEARNING_MIN_DURATION;\n\tsrtp_replay_protection = DEFAULT_SRTP_REPLAY_PROTECTION;\n\n\t/** This resource is not \"reloaded\" so much as unloaded and loaded again.\n\t * In the case of the TURN related variables, the memory referenced by a\n\t * previously loaded instance  *should* have been released when the\n\t * corresponding pool was destroyed. If at some point in the future this\n\t * resource were to support ACTUAL live reconfiguration and did NOT release\n\t * the pool this will cause a small memory leak.\n\t */\n\n#ifdef HAVE_PJPROJECT\n\ticesupport = DEFAULT_ICESUPPORT;\n\tstun_software_attribute = DEFAULT_STUN_SOFTWARE_ATTRIBUTE;\n\tturnport = DEFAULT_TURN_PORT;\n\tclean_stunaddr();\n\tturnaddr = pj_str(NULL);\n\tturnusername = pj_str(NULL);\n\tturnpassword = pj_str(NULL);\n\thost_candidate_overrides_clear();\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tdtls_mtu = DEFAULT_DTLS_MTU;\n#endif\n\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtpstart\"))) {\n\t\trtpstart = atoi(s);\n\t\tif (rtpstart < MINIMUM_RTP_PORT)\n\t\t\trtpstart = MINIMUM_RTP_PORT;\n\t\tif (rtpstart > MAXIMUM_RTP_PORT)\n\t\t\trtpstart = MAXIMUM_RTP_PORT;\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtpend\"))) {\n\t\trtpend = atoi(s);\n\t\tif (rtpend < MINIMUM_RTP_PORT)\n\t\t\trtpend = MINIMUM_RTP_PORT;\n\t\tif (rtpend > MAXIMUM_RTP_PORT)\n\t\t\trtpend = MAXIMUM_RTP_PORT;\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtcpinterval\"))) {\n\t\trtcpinterval = atoi(s);\n\t\tif (rtcpinterval == 0)\n\t\t\trtcpinterval = 0; /* Just so we're clear... it's zero */\n\t\tif (rtcpinterval < RTCP_MIN_INTERVALMS)\n\t\t\trtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */\n\t\tif (rtcpinterval > RTCP_MAX_INTERVALMS)\n\t\t\trtcpinterval = RTCP_MAX_INTERVALMS;\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtpchecksums\"))) {\n#ifdef SO_NO_CHECK\n\t\tnochecksums = ast_false(s) ? 1 : 0;\n#else\n\t\tif (ast_false(s))\n\t\t\tast_log(LOG_WARNING, \"Disabling RTP checksums is not supported on this operating system!\\n\");\n#endif\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"dtmftimeout\"))) {\n\t\tdtmftimeout = atoi(s);\n\t\tif ((dtmftimeout < 0) || (dtmftimeout > 64000)) {\n\t\t\tast_log(LOG_WARNING, \"DTMF timeout of '%d' outside range, using default of '%d' instead\\n\",\n\t\t\t\tdtmftimeout, DEFAULT_DTMF_TIMEOUT);\n\t\t\tdtmftimeout = DEFAULT_DTMF_TIMEOUT;\n\t\t};\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"strictrtp\"))) {\n\t\tif (ast_true(s)) {\n\t\t\tstrictrtp = STRICT_RTP_YES;\n\t\t} else if (!strcasecmp(s, \"seqno\")) {\n\t\t\tstrictrtp = STRICT_RTP_SEQNO;\n\t\t} else {\n\t\t\tstrictrtp = STRICT_RTP_NO;\n\t\t}\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"probation\"))) {\n\t\tif ((sscanf(s, \"%d\", &learning_min_sequential) != 1) || learning_min_sequential <= 1) {\n\t\t\tast_log(LOG_WARNING, \"Value for 'probation' could not be read, using default of '%d' instead\\n\",\n\t\t\t\tDEFAULT_LEARNING_MIN_SEQUENTIAL);\n\t\t\tlearning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL;\n\t\t}\n\t\tlearning_min_duration = CALC_LEARNING_MIN_DURATION(learning_min_sequential);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"srtpreplayprotection\"))) {\n\t\tsrtp_replay_protection = ast_true(s);\n\t}\n#ifdef HAVE_PJPROJECT\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"icesupport\"))) {\n\t\ticesupport = ast_true(s);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"stun_software_attribute\"))) {\n\t\tstun_software_attribute = ast_true(s);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"stunaddr\"))) {\n\t\tchar *hostport, *host, *port;\n\t\tunsigned int port_parsed = STANDARD_STUN_PORT;\n\t\tstruct ast_sockaddr stunaddr_parsed;\n\n\t\thostport = ast_strdupa(s);\n\n\t\tif (!ast_parse_arg(hostport, PARSE_ADDR, &stunaddr_parsed)) {\n\t\t\tast_debug_stun(3, \"stunaddr = '%s' does not need name resolution\\n\",\n\t\t\t\tast_sockaddr_stringify_host(&stunaddr_parsed));\n\t\t\tif (!ast_sockaddr_port(&stunaddr_parsed)) {\n\t\t\t\tast_sockaddr_set_port(&stunaddr_parsed, STANDARD_STUN_PORT);\n\t\t\t}\n\t\t\tast_rwlock_wrlock(&stunaddr_lock);\n\t\t\tast_sockaddr_to_sin(&stunaddr_parsed, &stunaddr);\n\t\t\tast_rwlock_unlock(&stunaddr_lock);\n\t\t} else if (ast_sockaddr_split_hostport(hostport, &host, &port, 0)) {\n\t\t\tif (port) {\n\t\t\t\tast_parse_arg(port, PARSE_UINT32|PARSE_IN_RANGE, &port_parsed, 1, 65535);\n\t\t\t}\n\t\t\tstunaddr.sin_port = htons(port_parsed);\n\n\t\t\tstunaddr_resolver = ast_dns_resolve_recurring(host, T_A, C_IN,\n\t\t\t\t&stunaddr_resolve_callback, NULL);\n\t\t\tif (!stunaddr_resolver) {\n\t\t\t\tast_log(LOG_ERROR, \"Failed to setup recurring DNS resolution of stunaddr '%s'\",\n\t\t\t\t\thost);\n\t\t\t}\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Failed to parse stunaddr '%s'\", hostport);\n\t\t}\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"turnaddr\"))) {\n\t\tstruct sockaddr_in addr;\n\t\taddr.sin_port = htons(DEFAULT_TURN_PORT);\n\t\tif (ast_parse_arg(s, PARSE_INADDR, &addr)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid TURN server address: %s\\n\", s);\n\t\t} else {\n\t\t\tpj_strdup2_with_null(pool, &turnaddr, ast_inet_ntoa(addr.sin_addr));\n\t\t\t/* ntohs() is not a bug here. The port number is used in host byte order with\n\t\t\t * a pjnat API. */\n\t\t\tturnport = ntohs(addr.sin_port);\n\t\t}\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"turnusername\"))) {\n\t\tpj_strdup2_with_null(pool, &turnusername, s);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"turnpassword\"))) {\n\t\tpj_strdup2_with_null(pool, &turnpassword, s);\n\t}\n\n\tAST_RWLIST_WRLOCK(&host_candidates);\n\tfor (var = ast_variable_browse(cfg, \"ice_host_candidates\"); var; var = var->next) {\n\t\tstruct ast_sockaddr local_addr, advertised_addr;\n\t\tunsigned int include_local_address = 0;\n\t\tchar *sep;\n\n\t\tast_sockaddr_setnull(&local_addr);\n\t\tast_sockaddr_setnull(&advertised_addr);\n\n\t\tif (ast_parse_arg(var->name, PARSE_ADDR | PARSE_PORT_IGNORE, &local_addr)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid local ICE host address: %s\\n\", var->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsep = strchr(var->value,',');\n\t\tif (sep) {\n\t\t\t*sep = '\\0';\n\t\t\tsep++;\n\t\t\tsep = ast_skip_blanks(sep);\n\t\t\tinclude_local_address = strcmp(sep, \"include_local_address\") == 0;\n\t\t}\n\n\t\tif (ast_parse_arg(var->value, PARSE_ADDR | PARSE_PORT_IGNORE, &advertised_addr)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid advertised ICE host address: %s\\n\", var->value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(candidate = ast_calloc(1, sizeof(*candidate)))) {\n\t\t\tast_log(LOG_ERROR, \"Failed to allocate ICE host candidate mapping.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcandidate->include_local = include_local_address;\n\n\t\tast_sockaddr_copy(&candidate->local, &local_addr);\n\t\tast_sockaddr_copy(&candidate->advertised, &advertised_addr);\n\n\t\tAST_RWLIST_INSERT_TAIL(&host_candidates, candidate, next);\n\t}\n\tAST_RWLIST_UNLOCK(&host_candidates);\n\n\tast_rwlock_wrlock(&ice_acl_lock);\n\tast_rwlock_wrlock(&stun_acl_lock);\n\n\tice_acl = ast_free_acl_list(ice_acl);\n\tstun_acl = ast_free_acl_list(stun_acl);\n\n\tfor (var = ast_variable_browse(cfg, \"general\"); var; var = var->next) {\n\t\tconst char* sense = NULL;\n\t\tstruct ast_acl_list **acl = NULL;\n\t\tif (strncasecmp(var->name, \"ice_\", 4) == 0) {\n\t\t\tsense = var->name + 4;\n\t\t\tacl = &ice_acl;\n\t\t} else if (strncasecmp(var->name, \"stun_\", 5) == 0) {\n\t\t\tsense = var->name + 5;\n\t\t\tacl = &stun_acl;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcasecmp(sense, \"blacklist\") == 0) {\n\t\t\tsense = \"deny\";\n\t\t}\n\n\t\tif (strcasecmp(sense, \"acl\") && strcasecmp(sense, \"permit\") && strcasecmp(sense, \"deny\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tast_append_acl(sense, var->value, acl, NULL, &acl_subscription_flag);\n\t}\n\tast_rwlock_unlock(&ice_acl_lock);\n\tast_rwlock_unlock(&stun_acl_lock);\n\n\tif (acl_subscription_flag && !acl_change_sub) {\n\t\tacl_change_sub = stasis_subscribe(ast_security_topic(), acl_change_stasis_cb, NULL);\n\t\tstasis_subscription_accept_message_type(acl_change_sub, ast_named_acl_change_type());\n\t\tstasis_subscription_set_filter(acl_change_sub, STASIS_SUBSCRIPTION_FILTER_SELECTIVE);\n\t} else if (!acl_subscription_flag && acl_change_sub) {\n\t\tacl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);\n\t}\n#endif\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"dtls_mtu\"))) {\n\t\tif ((sscanf(s, \"%d\", &dtls_mtu) != 1) || dtls_mtu < 256) {\n\t\t\tast_log(LOG_WARNING, \"Value for 'dtls_mtu' could not be read, using default of '%d' instead\\n\",\n\t\t\t\tDEFAULT_DTLS_MTU);\n\t\t\tdtls_mtu = DEFAULT_DTLS_MTU;\n\t\t}\n\t}\n#endif\n\n\tast_config_destroy(cfg);\n\n\t/* Choosing an odd start port casues issues (like a potential infinite loop) and as odd parts are not\n\t   chosen anyway, we are going to round up and issue a warning */\n\tif (rtpstart & 1) {\n\t\trtpstart++;\n\t\tast_log(LOG_WARNING, \"Odd start value for RTP port in rtp.conf, rounding up to %d\\n\", rtpstart);\n\t}\n\n\tif (rtpstart >= rtpend) {\n\t\tast_log(LOG_WARNING, \"Unreasonable values for RTP start/end port in rtp.conf\\n\");\n\t\trtpstart = DEFAULT_RTP_START;\n\t\trtpend = DEFAULT_RTP_END;\n\t}\n\tast_verb(2, \"RTP Allocating from port range %d -> %d\\n\", rtpstart, rtpend);\n\treturn 0;\n}\n\nstatic int reload_module(void)\n{\n\trtp_reload(1, 0);\n\treturn 0;\n}\n\n#ifdef HAVE_PJPROJECT\nstatic void rtp_terminate_pjproject(void)\n{\n\tpj_thread_register_check();\n\n\tif (timer_thread) {\n\t\ttimer_terminate = 1;\n\t\tpj_thread_join(timer_thread);\n\t\tpj_thread_destroy(timer_thread);\n\t}\n\n\tast_pjproject_caching_pool_destroy(&cachingpool);\n\tpj_shutdown();\n}\n\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message)\n{\n\tif (stasis_message_type(message) != ast_named_acl_change_type()) {\n\t\treturn;\n\t}\n\n\t/* There is no simple way to just reload the ACLs, so just execute a forced reload. */\n\trtp_reload(1, 1);\n}\n#endif\n\nstatic int load_module(void)\n{\n#ifdef HAVE_PJPROJECT\n\tpj_lock_t *lock;\n\n\tast_sockaddr_parse(&lo6, \"::1\", PARSE_PORT_IGNORE);\n\n\tAST_PJPROJECT_INIT_LOG_LEVEL();\n\tif (pj_init() != PJ_SUCCESS) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (pjlib_util_init() != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (pjnath_init() != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tast_pjproject_caching_pool_init(&cachingpool, &pj_pool_factory_default_policy, 0);\n\n\tpool = pj_pool_create(&cachingpool.factory, \"timer\", 512, 512, NULL);\n\n\tif (pj_timer_heap_create(pool, 100, &timer_heap) != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (pj_lock_create_recursive_mutex(pool, \"rtp%p\", &lock) != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tpj_timer_heap_set_lock(timer_heap, lock, PJ_TRUE);\n\n\tif (pj_thread_create(pool, \"timer\", &timer_worker_thread, NULL, 0, 0, &timer_thread) != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\tdtls_bio_methods = BIO_meth_new(BIO_TYPE_BIO, \"rtp write\");\n\tif (!dtls_bio_methods) {\n#ifdef HAVE_PJPROJECT\n\t\trtp_terminate_pjproject();\n#endif\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tBIO_meth_set_write(dtls_bio_methods, dtls_bio_write);\n\tBIO_meth_set_ctrl(dtls_bio_methods, dtls_bio_ctrl);\n\tBIO_meth_set_create(dtls_bio_methods, dtls_bio_new);\n\tBIO_meth_set_destroy(dtls_bio_methods, dtls_bio_free);\n#endif\n\n\tif (ast_rtp_engine_register(&asterisk_rtp_engine)) {\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\t\tBIO_meth_free(dtls_bio_methods);\n#endif\n#ifdef HAVE_PJPROJECT\n\t\trtp_terminate_pjproject();\n#endif\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (ast_cli_register_multiple(cli_rtp, ARRAY_LEN(cli_rtp))) {\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\t\tBIO_meth_free(dtls_bio_methods);\n#endif\n#ifdef HAVE_PJPROJECT\n\t\tast_rtp_engine_unregister(&asterisk_rtp_engine);\n\t\trtp_terminate_pjproject();\n#endif\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\trtp_reload(0, 0);\n\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n\nstatic int unload_module(void)\n{\n\tast_rtp_engine_unregister(&asterisk_rtp_engine);\n\tast_cli_unregister_multiple(cli_rtp, ARRAY_LEN(cli_rtp));\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\tif (dtls_bio_methods) {\n\t\tBIO_meth_free(dtls_bio_methods);\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\thost_candidate_overrides_clear();\n\tpj_thread_register_check();\n\trtp_terminate_pjproject();\n\n\tacl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);\n\trtp_unload_acl(&ice_acl_lock, &ice_acl);\n\trtp_unload_acl(&stun_acl_lock, &stun_acl);\n\tclean_stunaddr();\n#endif\n\n\treturn 0;\n}\n\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, \"Asterisk RTP Stack\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.reload = reload_module,\n\t.load_pri = AST_MODPRI_CHANNEL_DEPEND,\n#ifdef HAVE_PJPROJECT\n\t.requires = \"res_pjproject\",\n#endif\n);\n"], "fixing_code": ["/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 1999 - 2008, Digium, Inc.\n *\n * Mark Spencer <markster@digium.com>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */\n\n/*!\n * \\file\n *\n * \\brief Supports RTP and RTCP with Symmetric RTP support for NAT traversal.\n *\n * \\author Mark Spencer <markster@digium.com>\n *\n * \\note RTP is defined in RFC 3550.\n *\n * \\ingroup rtp_engines\n */\n\n/*** MODULEINFO\n\t<use type=\"external\">openssl</use>\n\t<use type=\"external\">pjproject</use>\n\t<support_level>core</support_level>\n ***/\n\n#include \"asterisk.h\"\n\n#include <arpa/nameser.h>\n#include \"asterisk/dns_core.h\"\n#include \"asterisk/dns_internal.h\"\n#include \"asterisk/dns_recurring.h\"\n\n#include <sys/time.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <math.h>\n\n#ifdef HAVE_OPENSSL\n#include <openssl/opensslconf.h>\n#include <openssl/opensslv.h>\n#if !defined(OPENSSL_NO_SRTP) && (OPENSSL_VERSION_NUMBER >= 0x10001000L)\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/bio.h>\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n#include <openssl/bn.h>\n#endif\n#ifndef OPENSSL_NO_DH\n#include <openssl/dh.h>\n#endif\n#endif\n#endif\n\n#ifdef HAVE_PJPROJECT\n#include <pjlib.h>\n#include <pjlib-util.h>\n#include <pjnath.h>\n#include <ifaddrs.h>\n#endif\n\n#include \"asterisk/conversions.h\"\n#include \"asterisk/options.h\"\n#include \"asterisk/logger_category.h\"\n#include \"asterisk/stun.h\"\n#include \"asterisk/pbx.h\"\n#include \"asterisk/frame.h\"\n#include \"asterisk/format_cache.h\"\n#include \"asterisk/channel.h\"\n#include \"asterisk/acl.h\"\n#include \"asterisk/config.h\"\n#include \"asterisk/lock.h\"\n#include \"asterisk/utils.h\"\n#include \"asterisk/cli.h\"\n#include \"asterisk/manager.h\"\n#include \"asterisk/unaligned.h\"\n#include \"asterisk/module.h\"\n#include \"asterisk/rtp_engine.h\"\n#include \"asterisk/smoother.h\"\n#include \"asterisk/uuid.h\"\n#include \"asterisk/test.h\"\n#include \"asterisk/data_buffer.h\"\n#ifdef HAVE_PJPROJECT\n#include \"asterisk/res_pjproject.h\"\n#include \"asterisk/security_events.h\"\n#endif\n\n#define MAX_TIMESTAMP_SKEW\t640\n\n#define RTP_SEQ_MOD     (1<<16)\t/*!< A sequence number can't be more than 16 bits */\n#define RTCP_DEFAULT_INTERVALMS   5000\t/*!< Default milli-seconds between RTCP reports we send */\n#define RTCP_MIN_INTERVALMS       500\t/*!< Min milli-seconds between RTCP reports we send */\n#define RTCP_MAX_INTERVALMS       60000\t/*!< Max milli-seconds between RTCP reports we send */\n\n#define DEFAULT_RTP_START 5000 /*!< Default port number to start allocating RTP ports from */\n#define DEFAULT_RTP_END 31000  /*!< Default maximum port number to end allocating RTP ports at */\n\n#define MINIMUM_RTP_PORT 1024 /*!< Minimum port number to accept */\n#define MAXIMUM_RTP_PORT 65535 /*!< Maximum port number to accept */\n\n#define DEFAULT_TURN_PORT 3478\n\n#define TURN_STATE_WAIT_TIME 2000\n\n#define DEFAULT_RTP_SEND_BUFFER_SIZE\t250\t/*!< The initial size of the RTP send buffer */\n#define MAXIMUM_RTP_SEND_BUFFER_SIZE\t(DEFAULT_RTP_SEND_BUFFER_SIZE + 200)\t/*!< Maximum RTP send buffer size */\n#define DEFAULT_RTP_RECV_BUFFER_SIZE\t20\t/*!< The initial size of the RTP receiver buffer */\n#define MAXIMUM_RTP_RECV_BUFFER_SIZE\t(DEFAULT_RTP_RECV_BUFFER_SIZE + 20)\t/*!< Maximum RTP receive buffer size */\n#define OLD_PACKET_COUNT\t\t1000\t/*!< The number of previous packets that are considered old */\n#define MISSING_SEQNOS_ADDED_TRIGGER \t2\t/*!< The number of immediate missing packets that will trigger an immediate NACK */\n\n#define SEQNO_CYCLE_OVER\t\t65536\t/*!< The number after the maximum allowed sequence number */\n\n/*! Full INTRA-frame Request / Fast Update Request (From RFC2032) */\n#define RTCP_PT_FUR     192\n/*! Sender Report (From RFC3550) */\n#define RTCP_PT_SR      AST_RTP_RTCP_SR\n/*! Receiver Report (From RFC3550) */\n#define RTCP_PT_RR      AST_RTP_RTCP_RR\n/*! Source Description (From RFC3550) */\n#define RTCP_PT_SDES    202\n/*! Goodbye (To remove SSRC's from tables) (From RFC3550) */\n#define RTCP_PT_BYE     203\n/*! Application defined (From RFC3550) */\n#define RTCP_PT_APP     204\n/* VP8: RTCP Feedback */\n/*! Payload Specific Feed Back (From RFC4585 also RFC5104) */\n#define RTCP_PT_PSFB    AST_RTP_RTCP_PSFB\n\n#define RTP_MTU\t\t1200\n#define DTMF_SAMPLE_RATE_MS    8 /*!< DTMF samples per millisecond */\n\n#define DEFAULT_DTMF_TIMEOUT (150 * (8000 / 1000))\t/*!< samples */\n\n#define ZFONE_PROFILE_ID 0x505a\n\n#define DEFAULT_LEARNING_MIN_SEQUENTIAL 4\n/*!\n * \\brief Calculate the min learning duration in ms.\n *\n * \\details\n * The min supported packet size represents 10 ms and we need to account\n * for some jitter and fast clocks while learning.  Some messed up devices\n * have very bad jitter for a small packet sample size.  Jitter can also\n * be introduced by the network itself.\n *\n * So we'll allow packets to come in every 9ms on average for fast clocking\n * with the last one coming in 5ms early for jitter.\n */\n#define CALC_LEARNING_MIN_DURATION(count) (((count) - 1) * 9 - 5)\n#define DEFAULT_LEARNING_MIN_DURATION CALC_LEARNING_MIN_DURATION(DEFAULT_LEARNING_MIN_SEQUENTIAL)\n\n#define SRTP_MASTER_KEY_LEN 16\n#define SRTP_MASTER_SALT_LEN 14\n#define SRTP_MASTER_LEN (SRTP_MASTER_KEY_LEN + SRTP_MASTER_SALT_LEN)\n\n#define RTP_DTLS_ESTABLISHED -37\n\nenum strict_rtp_state {\n\tSTRICT_RTP_OPEN = 0, /*! No RTP packets should be dropped, all sources accepted */\n\tSTRICT_RTP_LEARN,    /*! Accept next packet as source */\n\tSTRICT_RTP_CLOSED,   /*! Drop all RTP packets not coming from source that was learned */\n};\n\nenum strict_rtp_mode {\n\tSTRICT_RTP_NO = 0,\t/*! Don't adhere to any strict RTP rules */\n\tSTRICT_RTP_YES,\t\t/*! Strict RTP that restricts packets based on time and sequence number */\n\tSTRICT_RTP_SEQNO,\t/*! Strict RTP that restricts packets based on sequence number */\n};\n\n/*!\n * \\brief Strict RTP learning timeout time in milliseconds\n *\n * \\note Set to 5 seconds to allow reinvite chains for direct media\n * to settle before media actually starts to arrive.  There may be a\n * reinvite collision involved on the other leg.\n */\n#define STRICT_RTP_LEARN_TIMEOUT\t5000\n\n#define DEFAULT_STRICT_RTP STRICT_RTP_YES\t/*!< Enabled by default */\n#define DEFAULT_SRTP_REPLAY_PROTECTION 1\n#define DEFAULT_ICESUPPORT 1\n#define DEFAULT_STUN_SOFTWARE_ATTRIBUTE 1\n#define DEFAULT_DTLS_MTU 1200\n\n/*!\n * Because both ends usually don't start sending RTP\n * at the same time, some of the calculations like\n * rtt and jitter will probably be unstable for a while\n * so we'll skip some received packets before starting\n * analyzing.  This just affects analyzing; we still\n * process the RTP as normal.\n */\n#define RTP_IGNORE_FIRST_PACKETS_COUNT 15\n\nextern struct ast_srtp_res *res_srtp;\nextern struct ast_srtp_policy_res *res_srtp_policy;\n\nstatic int dtmftimeout = DEFAULT_DTMF_TIMEOUT;\n\nstatic int rtpstart = DEFAULT_RTP_START;\t\t\t/*!< First port for RTP sessions (set in rtp.conf) */\nstatic int rtpend = DEFAULT_RTP_END;\t\t\t/*!< Last port for RTP sessions (set in rtp.conf) */\nstatic int rtcpstats;\t\t\t/*!< Are we debugging RTCP? */\nstatic int rtcpinterval = RTCP_DEFAULT_INTERVALMS; /*!< Time between rtcp reports in millisecs */\nstatic struct ast_sockaddr rtpdebugaddr;\t/*!< Debug packets to/from this host */\nstatic struct ast_sockaddr rtcpdebugaddr;\t/*!< Debug RTCP packets to/from this host */\nstatic int rtpdebugport;\t\t/*!< Debug only RTP packets from IP or IP+Port if port is > 0 */\nstatic int rtcpdebugport;\t\t/*!< Debug only RTCP packets from IP or IP+Port if port is > 0 */\n#ifdef SO_NO_CHECK\nstatic int nochecksums;\n#endif\nstatic int strictrtp = DEFAULT_STRICT_RTP; /*!< Only accept RTP frames from a defined source. If we receive an indication of a changing source, enter learning mode. */\nstatic int learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL; /*!< Number of sequential RTP frames needed from a single source during learning mode to accept new source. */\nstatic int learning_min_duration = DEFAULT_LEARNING_MIN_DURATION; /*!< Lowest acceptable timeout between the first and the last sequential RTP frame. */\nstatic int srtp_replay_protection = DEFAULT_SRTP_REPLAY_PROTECTION;\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int dtls_mtu = DEFAULT_DTLS_MTU;\n#endif\n#ifdef HAVE_PJPROJECT\nstatic int icesupport = DEFAULT_ICESUPPORT;\nstatic int stun_software_attribute = DEFAULT_STUN_SOFTWARE_ATTRIBUTE;\nstatic struct sockaddr_in stunaddr;\nstatic pj_str_t turnaddr;\nstatic int turnport = DEFAULT_TURN_PORT;\nstatic pj_str_t turnusername;\nstatic pj_str_t turnpassword;\nstatic struct stasis_subscription *acl_change_sub = NULL;\nstatic struct ast_sockaddr lo6 = { .len = 0 };\n\n/*! ACL for ICE addresses */\nstatic struct ast_acl_list *ice_acl = NULL;\nstatic ast_rwlock_t ice_acl_lock = AST_RWLOCK_INIT_VALUE;\n\n/*! ACL for STUN requests */\nstatic struct ast_acl_list *stun_acl = NULL;\nstatic ast_rwlock_t stun_acl_lock = AST_RWLOCK_INIT_VALUE;\n\n/*! stunaddr recurring resolution */\nstatic ast_rwlock_t stunaddr_lock = AST_RWLOCK_INIT_VALUE;\nstatic struct ast_dns_query_recurring *stunaddr_resolver = NULL;\n\n/*! \\brief Pool factory used by pjlib to allocate memory. */\nstatic pj_caching_pool cachingpool;\n\n/*! \\brief Global memory pool for configuration and timers */\nstatic pj_pool_t *pool;\n\n/*! \\brief Global timer heap */\nstatic pj_timer_heap_t *timer_heap;\n\n/*! \\brief Thread executing the timer heap */\nstatic pj_thread_t *timer_thread;\n\n/*! \\brief Used to tell the timer thread to terminate */\nstatic int timer_terminate;\n\n/*! \\brief Structure which contains ioqueue thread information */\nstruct ast_rtp_ioqueue_thread {\n\t/*! \\brief Pool used by the thread */\n\tpj_pool_t *pool;\n\t/*! \\brief The thread handling the queue and timer heap */\n\tpj_thread_t *thread;\n\t/*! \\brief Ioqueue which polls on sockets */\n\tpj_ioqueue_t *ioqueue;\n\t/*! \\brief Timer heap for scheduled items */\n\tpj_timer_heap_t *timerheap;\n\t/*! \\brief Termination request */\n\tint terminate;\n\t/*! \\brief Current number of descriptors being waited on */\n\tunsigned int count;\n\t/*! \\brief Linked list information */\n\tAST_LIST_ENTRY(ast_rtp_ioqueue_thread) next;\n};\n\n/*! \\brief List of ioqueue threads */\nstatic AST_LIST_HEAD_STATIC(ioqueues, ast_rtp_ioqueue_thread);\n\n/*! \\brief Structure which contains ICE host candidate mapping information */\nstruct ast_ice_host_candidate {\n\tstruct ast_sockaddr local;\n\tstruct ast_sockaddr advertised;\n\tunsigned int include_local;\n\tAST_RWLIST_ENTRY(ast_ice_host_candidate) next;\n};\n\n/*! \\brief List of ICE host candidate mappings */\nstatic AST_RWLIST_HEAD_STATIC(host_candidates, ast_ice_host_candidate);\n\nstatic char *generate_random_string(char *buf, size_t size);\n\n#endif\n\n#define FLAG_3389_WARNING               (1 << 0)\n#define FLAG_NAT_ACTIVE                 (3 << 1)\n#define FLAG_NAT_INACTIVE               (0 << 1)\n#define FLAG_NAT_INACTIVE_NOWARN        (1 << 1)\n#define FLAG_NEED_MARKER_BIT            (1 << 3)\n#define FLAG_DTMF_COMPENSATE            (1 << 4)\n#define FLAG_REQ_LOCAL_BRIDGE_BIT       (1 << 5)\n\n#define TRANSPORT_SOCKET_RTP 0\n#define TRANSPORT_SOCKET_RTCP 1\n#define TRANSPORT_TURN_RTP 2\n#define TRANSPORT_TURN_RTCP 3\n\n/*! \\brief RTP learning mode tracking information */\nstruct rtp_learning_info {\n\tstruct ast_sockaddr proposed_address;\t/*!< Proposed remote address for strict RTP */\n\tstruct timeval start;\t/*!< The time learning mode was started */\n\tstruct timeval received; /*!< The time of the first received packet */\n\tint max_seq;\t/*!< The highest sequence number received */\n\tint packets;\t/*!< The number of remaining packets before the source is accepted */\n\t/*! Type of media stream carried by the RTP instance */\n\tenum ast_media_type stream_type;\n};\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstruct dtls_details {\n\tSSL *ssl;         /*!< SSL session */\n\tBIO *read_bio;    /*!< Memory buffer for reading */\n\tBIO *write_bio;   /*!< Memory buffer for writing */\n\tenum ast_rtp_dtls_setup dtls_setup; /*!< Current setup state */\n\tenum ast_rtp_dtls_connection connection; /*!< Whether this is a new or existing connection */\n\tint timeout_timer; /*!< Scheduler id for timeout timer */\n};\n#endif\n\n#ifdef HAVE_PJPROJECT\n/*! An ao2 wrapper protecting the PJPROJECT ice structure with ref counting. */\nstruct ice_wrap {\n\tpj_ice_sess *real_ice;           /*!< ICE session */\n};\n#endif\n\n/*! \\brief Structure used for mapping an incoming SSRC to an RTP instance */\nstruct rtp_ssrc_mapping {\n\t/*! \\brief The received SSRC */\n\tunsigned int ssrc;\n\t/*! True if the SSRC is available.  Otherwise, this is a placeholder mapping until the SSRC is set. */\n\tunsigned int ssrc_valid;\n\t/*! \\brief The RTP instance this SSRC belongs to*/\n\tstruct ast_rtp_instance *instance;\n};\n\n/*! \\brief Packet statistics (used for transport-cc) */\nstruct rtp_transport_wide_cc_packet_statistics {\n\t/*! The transport specific sequence number */\n\tunsigned int seqno;\n\t/*! The time at which the packet was received */\n\tstruct timeval received;\n\t/*! The delta between this packet and the previous */\n\tint delta;\n};\n\n/*! \\brief Statistics information (used for transport-cc) */\nstruct rtp_transport_wide_cc_statistics {\n\t/*! A vector of packet statistics */\n\tAST_VECTOR(, struct rtp_transport_wide_cc_packet_statistics) packet_statistics; /*!< Packet statistics, used for transport-cc */\n\t/*! The last sequence number received */\n\tunsigned int last_seqno;\n\t/*! The last extended sequence number */\n\tunsigned int last_extended_seqno;\n\t/*! How many feedback packets have gone out */\n\tunsigned int feedback_count;\n\t/*! How many cycles have occurred for the sequence numbers */\n\tunsigned int cycles;\n\t/*! Scheduler id for periodic feedback transmission */\n\tint schedid;\n};\n\ntypedef struct {\n\tunsigned int ts;\n\tunsigned char is_set;\n} optional_ts;\n\n/*! \\brief RTP session description */\nstruct ast_rtp {\n\tint s;\n\t/*! \\note The f.subclass.format holds a ref. */\n\tstruct ast_frame f;\n\tunsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];\n\tunsigned int ssrc;\t\t/*!< Synchronization source, RFC 3550, page 10. */\n\tunsigned int ssrc_orig;\t\t/*!< SSRC used before native bridge activated */\n\tunsigned char ssrc_saved;\t/*!< indicates if ssrc_orig has a value */\n\tchar cname[AST_UUID_STR_LEN]; /*!< Our local CNAME */\n\tunsigned int themssrc;\t\t/*!< Their SSRC */\n\tunsigned int themssrc_valid;\t/*!< True if their SSRC is available. */\n\tunsigned int lastts;\n\tunsigned int lastividtimestamp;\n\tunsigned int lastovidtimestamp;\n\tunsigned int lastitexttimestamp;\n\tunsigned int lastotexttimestamp;\n\tint prevrxseqno;                /*!< Previous received packeted sequence number, from the network */\n\tint lastrxseqno;                /*!< Last received sequence number, from the network */\n\tint expectedrxseqno;            /*!< Next expected sequence number, from the network */\n\tAST_VECTOR(, int) missing_seqno; /*!< A vector of sequence numbers we never received */\n\tint expectedseqno;\t\t/*!< Next expected sequence number, from the core */\n\tunsigned short seedrxseqno;     /*!< What sequence number did they start with?*/\n\tunsigned int rxcount;           /*!< How many packets have we received? */\n\tunsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/\n\tunsigned int txcount;           /*!< How many packets have we sent? */\n\tunsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/\n\tunsigned int cycles;            /*!< Shifted count of sequence number cycles */\n\tstruct ast_format *lasttxformat;\n\tstruct ast_format *lastrxformat;\n\n\t/*\n\t * RX RTP Timestamp and Jitter calculation.\n\t */\n\tdouble rxstart;                       /*!< RX time of the first packet in the session in seconds since EPOCH. */\n\tdouble rxstart_stable;                /*!< RX time of the first packet after RTP_IGNORE_FIRST_PACKETS_COUNT */\n\tunsigned int remote_seed_rx_rtp_ts;         /*!< RTP timestamp of first RX packet. */\n\tunsigned int remote_seed_rx_rtp_ts_stable;  /*!< RTP timestamp of first packet after RTP_IGNORE_FIRST_PACKETS_COUNT */\n\tunsigned int last_transit_time_samples;     /*!< The last transit time in samples */\n\tdouble rxjitter;                      /*!< Last calculated Interarrival jitter in seconds. */\n\tdouble rxjitter_samples;              /*!< Last calculated Interarrival jitter in samples. */\n\tdouble rxmes;                         /*!< Media Experince Score at the moment to be reported */\n\n\t/* DTMF Reception Variables */\n\tchar resp;                        /*!< The current digit being processed */\n\tunsigned int last_seqno;          /*!< The last known sequence number for any DTMF packet */\n\toptional_ts last_end_timestamp;   /*!< The last known timestamp received from an END packet */\n\tunsigned int dtmf_duration;       /*!< Total duration in samples since the digit start event */\n\tunsigned int dtmf_timeout;        /*!< When this timestamp is reached we consider END frame lost and forcibly abort digit */\n\tunsigned int dtmfsamples;\n\tenum ast_rtp_dtmf_mode dtmfmode;  /*!< The current DTMF mode of the RTP stream */\n\t/* DTMF Transmission Variables */\n\tunsigned int lastdigitts;\n\tchar sending_digit;\t/*!< boolean - are we sending digits */\n\tchar send_digit;\t/*!< digit we are sending */\n\tint send_payload;\n\tint send_duration;\n\tunsigned int flags;\n\tstruct timeval rxcore;\n\tstruct timeval txcore;\n\n\tstruct timeval dtmfmute;\n\tstruct ast_smoother *smoother;\n\tunsigned short seqno;\t\t/*!< Sequence number, RFC 3550, page 13. */\n\tstruct ast_sched_context *sched;\n\tstruct ast_rtcp *rtcp;\n\tunsigned int asymmetric_codec;  /*!< Indicate if asymmetric send/receive codecs are allowed */\n\n\tstruct ast_rtp_instance *bundled; /*!< The RTP instance we are bundled to */\n\t/*!\n\t * \\brief The RTP instance owning us (used for debugging purposes)\n\t * We don't hold a reference to the instance because it created\n\t * us in the first place.  It can't go away.\n\t */\n\tstruct ast_rtp_instance *owner;\n\tint stream_num; /*!< Stream num for this RTP instance */\n\tAST_VECTOR(, struct rtp_ssrc_mapping) ssrc_mapping; /*!< Mappings of SSRC to RTP instances */\n\tstruct ast_sockaddr bind_address; /*!< Requested bind address for the sockets */\n\n\tenum strict_rtp_state strict_rtp_state; /*!< Current state that strict RTP protection is in */\n\tstruct ast_sockaddr strict_rtp_address;  /*!< Remote address information for strict RTP purposes */\n\n\t/*\n\t * Learning mode values based on pjmedia's probation mode.  Many of these values are redundant to the above,\n\t * but these are in place to keep learning mode sequence values sealed from their normal counterparts.\n\t */\n\tstruct rtp_learning_info rtp_source_learn;\t/* Learning mode track for the expected RTP source */\n\n\tstruct rtp_red *red;\n\n\tstruct ast_data_buffer *send_buffer;\t\t/*!< Buffer for storing sent packets for retransmission */\n\tstruct ast_data_buffer *recv_buffer;\t\t/*!< Buffer for storing received packets for retransmission */\n\n\tstruct rtp_transport_wide_cc_statistics transport_wide_cc; /*!< Transport-cc statistics information */\n\n#ifdef HAVE_PJPROJECT\n\tast_cond_t cond;            /*!< ICE/TURN condition for signaling */\n\n\tstruct ice_wrap *ice;       /*!< ao2 wrapped ICE session */\n\tenum ast_rtp_ice_role role; /*!< Our role in ICE negotiation */\n\tpj_turn_sock *turn_rtp;     /*!< RTP TURN relay */\n\tpj_turn_sock *turn_rtcp;    /*!< RTCP TURN relay */\n\tpj_turn_state_t turn_state; /*!< Current state of the TURN relay session */\n\tunsigned int passthrough:1; /*!< Bit to indicate that the received packet should be passed through */\n\tunsigned int rtp_passthrough:1; /*!< Bit to indicate that TURN RTP should be passed through */\n\tunsigned int rtcp_passthrough:1; /*!< Bit to indicate that TURN RTCP should be passed through */\n\tunsigned int ice_port;      /*!< Port that ICE was started with if it was previously started */\n\tstruct ast_sockaddr rtp_loop; /*!< Loopback address for forwarding RTP from TURN */\n\tstruct ast_sockaddr rtcp_loop; /*!< Loopback address for forwarding RTCP from TURN */\n\n\tstruct ast_rtp_ioqueue_thread *ioqueue; /*!< The ioqueue thread handling us */\n\n\tchar remote_ufrag[256];  /*!< The remote ICE username */\n\tchar remote_passwd[256]; /*!< The remote ICE password */\n\n\tchar local_ufrag[256];  /*!< The local ICE username */\n\tchar local_passwd[256]; /*!< The local ICE password */\n\n\tstruct ao2_container *ice_local_candidates;           /*!< The local ICE candidates */\n\tstruct ao2_container *ice_active_remote_candidates;   /*!< The remote ICE candidates */\n\tstruct ao2_container *ice_proposed_remote_candidates; /*!< Incoming remote ICE candidates for new session */\n\tstruct ast_sockaddr ice_original_rtp_addr;            /*!< rtp address that ICE started on first session */\n\tunsigned int ice_num_components; /*!< The number of ICE components */\n\tunsigned int ice_media_started:1; /*!< ICE media has started, either on a valid pair or on ICE completion */\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tSSL_CTX *ssl_ctx; /*!< SSL context */\n\tenum ast_rtp_dtls_verify dtls_verify; /*!< What to verify */\n\tenum ast_srtp_suite suite;   /*!< SRTP crypto suite */\n\tenum ast_rtp_dtls_hash local_hash; /*!< Local hash used for the fingerprint */\n\tchar local_fingerprint[160]; /*!< Fingerprint of our certificate */\n\tenum ast_rtp_dtls_hash remote_hash; /*!< Remote hash used for the fingerprint */\n\tunsigned char remote_fingerprint[EVP_MAX_MD_SIZE]; /*!< Fingerprint of the peer certificate */\n\tunsigned int rekey; /*!< Interval at which to renegotiate and rekey */\n\tint rekeyid; /*!< Scheduled item id for rekeying */\n\tstruct dtls_details dtls; /*!< DTLS state information */\n#endif\n};\n\n/*!\n * \\brief Structure defining an RTCP session.\n *\n * The concept \"RTCP session\" is not defined in RFC 3550, but since\n * this structure is analogous to ast_rtp, which tracks a RTP session,\n * it is logical to think of this as a RTCP session.\n *\n * RTCP packet is defined on page 9 of RFC 3550.\n *\n */\nstruct ast_rtcp {\n\tint rtcp_info;\n\tint s;\t\t\t\t/*!< Socket */\n\tstruct ast_sockaddr us;\t\t/*!< Socket representation of the local endpoint. */\n\tstruct ast_sockaddr them;\t/*!< Socket representation of the remote endpoint. */\n\tunsigned int soc;\t\t/*!< What they told us */\n\tunsigned int spc;\t\t/*!< What they told us */\n\tunsigned int themrxlsr;\t\t/*!< The middle 32 bits of the NTP timestamp in the last received SR*/\n\tstruct timeval rxlsr;\t\t/*!< Time when we got their last SR */\n\tstruct timeval txlsr;\t\t/*!< Time when we sent or last SR*/\n\tunsigned int expected_prior;\t/*!< no. packets in previous interval */\n\tunsigned int received_prior;\t/*!< no. packets received in previous interval */\n\tint schedid;\t\t\t/*!< Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/\n\tunsigned int rr_count;\t\t/*!< number of RRs we've sent, not including report blocks in SR's */\n\tunsigned int sr_count;\t\t/*!< number of SRs we've sent */\n\tunsigned int lastsrtxcount;     /*!< Transmit packet count when last SR sent */\n\tdouble accumulated_transit;\t/*!< accumulated a-dlsr-lsr */\n\tdouble rtt;\t\t\t/*!< Last reported rtt */\n\tdouble reported_jitter;\t/*!< The contents of their last jitter entry in the RR in seconds */\n\tunsigned int reported_lost;\t/*!< Reported lost packets in their RR */\n\n\tdouble reported_maxjitter; /*!< Maximum reported interarrival jitter */\n\tdouble reported_minjitter; /*!< Minimum reported interarrival jitter */\n\tdouble reported_normdev_jitter; /*!< Mean of reported interarrival jitter */\n\tdouble reported_stdev_jitter; /*!< Standard deviation of reported interarrival jitter */\n\tunsigned int reported_jitter_count; /*!< Reported interarrival jitter count */\n\n\tdouble reported_maxlost; /*!< Maximum reported packets lost */\n\tdouble reported_minlost; /*!< Minimum reported packets lost */\n\tdouble reported_normdev_lost; /*!< Mean of reported packets lost */\n\tdouble reported_stdev_lost; /*!< Standard deviation of reported packets lost */\n\tunsigned int reported_lost_count; /*!< Reported packets lost count */\n\n\tdouble rxlost; /*!< Calculated number of lost packets since last report */\n\tdouble maxrxlost; /*!< Maximum calculated lost number of packets between reports */\n\tdouble minrxlost; /*!< Minimum calculated lost number of packets between reports */\n\tdouble normdev_rxlost; /*!< Mean of calculated lost packets between reports */\n\tdouble stdev_rxlost; /*!< Standard deviation of calculated lost packets between reports */\n\tunsigned int rxlost_count; /*!< Calculated lost packets sample count */\n\n\tdouble maxrxjitter; /*!< Maximum of calculated interarrival jitter */\n\tdouble minrxjitter; /*!< Minimum of calculated interarrival jitter */\n\tdouble normdev_rxjitter; /*!< Mean of calculated interarrival jitter */\n\tdouble stdev_rxjitter; /*!< Standard deviation of calculated interarrival jitter */\n\tunsigned int rxjitter_count; /*!< Calculated interarrival jitter count */\n\n\tdouble maxrtt; /*!< Maximum of calculated round trip time */\n\tdouble minrtt; /*!< Minimum of calculated round trip time */\n\tdouble normdevrtt; /*!< Mean of calculated round trip time */\n\tdouble stdevrtt; /*!< Standard deviation of calculated round trip time */\n\tunsigned int rtt_count; /*!< Calculated round trip time count */\n\n\tdouble reported_mes;\t/*!< The calculated MES from their last RR */\n\tdouble reported_maxmes; /*!< Maximum reported mes */\n\tdouble reported_minmes; /*!< Minimum reported mes */\n\tdouble reported_normdev_mes; /*!< Mean of reported mes */\n\tdouble reported_stdev_mes; /*!< Standard deviation of reported mes */\n\tunsigned int reported_mes_count; /*!< Reported mes count */\n\n\tdouble maxrxmes; /*!< Maximum of calculated mes */\n\tdouble minrxmes; /*!< Minimum of calculated mes */\n\tdouble normdev_rxmes; /*!< Mean of calculated mes */\n\tdouble stdev_rxmes; /*!< Standard deviation of calculated mes */\n\tunsigned int rxmes_count; /*!< mes count */\n\n\t/* VP8: sequence number for the RTCP FIR FCI */\n\tint firseq;\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tstruct dtls_details dtls; /*!< DTLS state information */\n#endif\n\n\t/* Cached local address string allows us to generate\n\t * RTCP stasis messages without having to look up our\n\t * own address every time\n\t */\n\tchar *local_addr_str;\n\tenum ast_rtp_instance_rtcp type;\n\t/* Buffer for frames created during RTCP interpretation */\n\tunsigned char frame_buf[512 + AST_FRIENDLY_OFFSET];\n};\n\nstruct rtp_red {\n\tstruct ast_frame t140;  /*!< Primary data  */\n\tstruct ast_frame t140red;   /*!< Redundant t140*/\n\tunsigned char pt[AST_RED_MAX_GENERATION];  /*!< Payload types for redundancy data */\n\tunsigned char ts[AST_RED_MAX_GENERATION]; /*!< Time stamps */\n\tunsigned char len[AST_RED_MAX_GENERATION]; /*!< length of each generation */\n\tint num_gen; /*!< Number of generations */\n\tint schedid; /*!< Timer id */\n\tint ti; /*!< How long to buffer data before send */\n\tunsigned char t140red_data[64000];\n\tunsigned char buf_data[64000]; /*!< buffered primary data */\n\tint hdrlen;\n\tlong int prev_ts;\n};\n\n/*! \\brief Structure for storing RTP packets for retransmission */\nstruct ast_rtp_rtcp_nack_payload {\n\tsize_t size;\t\t/*!< The size of the payload */\n\tunsigned char buf[0];\t/*!< The payload data */\n};\n\nAST_LIST_HEAD_NOLOCK(frame_list, ast_frame);\n\n/* Forward Declarations */\nstatic int ast_rtp_new(struct ast_rtp_instance *instance, struct ast_sched_context *sched, struct ast_sockaddr *addr, void *data);\nstatic int ast_rtp_destroy(struct ast_rtp_instance *instance);\nstatic int ast_rtp_dtmf_begin(struct ast_rtp_instance *instance, char digit);\nstatic int ast_rtp_dtmf_end(struct ast_rtp_instance *instance, char digit);\nstatic int ast_rtp_dtmf_end_with_duration(struct ast_rtp_instance *instance, char digit, unsigned int duration);\nstatic int ast_rtp_dtmf_mode_set(struct ast_rtp_instance *instance, enum ast_rtp_dtmf_mode dtmf_mode);\nstatic enum ast_rtp_dtmf_mode ast_rtp_dtmf_mode_get(struct ast_rtp_instance *instance);\nstatic void ast_rtp_update_source(struct ast_rtp_instance *instance);\nstatic void ast_rtp_change_source(struct ast_rtp_instance *instance);\nstatic int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame);\nstatic struct ast_frame *ast_rtp_read(struct ast_rtp_instance *instance, int rtcp);\nstatic void ast_rtp_prop_set(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value);\nstatic int ast_rtp_fd(struct ast_rtp_instance *instance, int rtcp);\nstatic void ast_rtp_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr);\nstatic int rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations);\nstatic int rtp_red_buffer(struct ast_rtp_instance *instance, struct ast_frame *frame);\nstatic int ast_rtp_local_bridge(struct ast_rtp_instance *instance0, struct ast_rtp_instance *instance1);\nstatic int ast_rtp_get_stat(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat);\nstatic int ast_rtp_dtmf_compatible(struct ast_channel *chan0, struct ast_rtp_instance *instance0, struct ast_channel *chan1, struct ast_rtp_instance *instance1);\nstatic void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username);\nstatic void ast_rtp_stop(struct ast_rtp_instance *instance);\nstatic int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char* desc);\nstatic int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level);\nstatic unsigned int ast_rtp_get_ssrc(struct ast_rtp_instance *instance);\nstatic const char *ast_rtp_get_cname(struct ast_rtp_instance *instance);\nstatic void ast_rtp_set_remote_ssrc(struct ast_rtp_instance *instance, unsigned int ssrc);\nstatic void ast_rtp_set_stream_num(struct ast_rtp_instance *instance, int stream_num);\nstatic int ast_rtp_extension_enable(struct ast_rtp_instance *instance, enum ast_rtp_extension extension);\nstatic int ast_rtp_bundle(struct ast_rtp_instance *child, struct ast_rtp_instance *parent);\nstatic void update_reported_mes_stats(struct ast_rtp *rtp);\nstatic void update_local_mes_stats(struct ast_rtp *rtp);\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int ast_rtp_activate(struct ast_rtp_instance *instance);\nstatic void dtls_srtp_start_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp);\nstatic void dtls_srtp_stop_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp);\nstatic int dtls_bio_write(BIO *bio, const char *buf, int len);\nstatic long dtls_bio_ctrl(BIO *bio, int cmd, long arg1, void *arg2);\nstatic int dtls_bio_new(BIO *bio);\nstatic int dtls_bio_free(BIO *bio);\n\n#ifndef HAVE_OPENSSL_BIO_METHOD\nstatic BIO_METHOD dtls_bio_methods = {\n\t.type = BIO_TYPE_BIO,\n\t.name = \"rtp write\",\n\t.bwrite = dtls_bio_write,\n\t.ctrl = dtls_bio_ctrl,\n\t.create = dtls_bio_new,\n\t.destroy = dtls_bio_free,\n};\n#else\nstatic BIO_METHOD *dtls_bio_methods;\n#endif\n#endif\n\nstatic int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *via_ice, int use_srtp);\n\n#ifdef HAVE_PJPROJECT\nstatic void stunaddr_resolve_callback(const struct ast_dns_query *query);\nstatic int store_stunaddr_resolved(const struct ast_dns_query *query);\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int dtls_bio_new(BIO *bio)\n{\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tBIO_set_init(bio, 1);\n\tBIO_set_data(bio, NULL);\n\tBIO_set_shutdown(bio, 0);\n#else\n\tbio->init = 1;\n\tbio->ptr = NULL;\n\tbio->flags = 0;\n#endif\n\treturn 1;\n}\n\nstatic int dtls_bio_free(BIO *bio)\n{\n\t/* The pointer on the BIO is that of the RTP instance. It is not reference counted as the BIO\n\t * lifetime is tied to the instance, and actions on the BIO are taken by the thread handling\n\t * the RTP instance - not another thread.\n\t */\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tBIO_set_data(bio, NULL);\n#else\n\tbio->ptr = NULL;\n#endif\n\treturn 1;\n}\n\nstatic int dtls_bio_write(BIO *bio, const char *buf, int len)\n{\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tstruct ast_rtp_instance *instance = BIO_get_data(bio);\n#else\n\tstruct ast_rtp_instance *instance = bio->ptr;\n#endif\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint rtcp = 0;\n\tstruct ast_sockaddr remote_address = { {0, } };\n\tint ice;\n\tint bytes_sent;\n\n\t/* OpenSSL can't tolerate a packet not being sent, so we always state that\n\t * we sent the packet. If it isn't then retransmission will occur.\n\t */\n\n\tif (rtp->rtcp && rtp->rtcp->dtls.write_bio == bio) {\n\t\trtcp = 1;\n\t\tast_sockaddr_copy(&remote_address, &rtp->rtcp->them);\n\t} else {\n\t\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\t}\n\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn len;\n\t}\n\n\tbytes_sent = __rtp_sendto(instance, (char *)buf, len, 0, &remote_address, rtcp, &ice, 0);\n\n\tif (bytes_sent > 0 && ast_debug_dtls_packet_is_allowed) {\n\t\tast_debug(0, \"(%p) DTLS - sent %s packet to %s%s (len %-6.6d)\\n\",\n\t\t\tinstance, rtcp ? \"RTCP\" : \"RTP\", ast_sockaddr_stringify(&remote_address),\n\t\t\tice ? \" (via ICE)\" : \"\", bytes_sent);\n\t}\n\n\treturn len;\n}\n\nstatic long dtls_bio_ctrl(BIO *bio, int cmd, long arg1, void *arg2)\n{\n\tswitch (cmd) {\n\tcase BIO_CTRL_FLUSH:\n\t\treturn 1;\n\tcase BIO_CTRL_DGRAM_QUERY_MTU:\n\t\treturn dtls_mtu;\n\tcase BIO_CTRL_WPENDING:\n\tcase BIO_CTRL_PENDING:\n\t\treturn 0L;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#endif\n\n#ifdef HAVE_PJPROJECT\n/*! \\brief Helper function which clears the ICE host candidate mapping */\nstatic void host_candidate_overrides_clear(void)\n{\n\tstruct ast_ice_host_candidate *candidate;\n\n\tAST_RWLIST_WRLOCK(&host_candidates);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&host_candidates, candidate, next) {\n\t\tAST_RWLIST_REMOVE_CURRENT(next);\n\t\tast_free(candidate);\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&host_candidates);\n}\n\n/*! \\brief Helper function which updates an ast_sockaddr with the candidate used for the component */\nstatic void update_address_with_ice_candidate(pj_ice_sess *ice, enum ast_rtp_ice_component_type component,\n\tstruct ast_sockaddr *cand_address)\n{\n\tchar address[PJ_INET6_ADDRSTRLEN];\n\n\tif (component < 1 || !ice->comp[component - 1].valid_check) {\n\t\treturn;\n\t}\n\n\tast_sockaddr_parse(cand_address,\n\t\tpj_sockaddr_print(&ice->comp[component - 1].valid_check->rcand->addr, address,\n\t\t\tsizeof(address), 0), 0);\n\tast_sockaddr_set_port(cand_address,\n\t\tpj_sockaddr_get_port(&ice->comp[component - 1].valid_check->rcand->addr));\n}\n\n/*! \\brief Destructor for locally created ICE candidates */\nstatic void ast_rtp_ice_candidate_destroy(void *obj)\n{\n\tstruct ast_rtp_engine_ice_candidate *candidate = obj;\n\n\tif (candidate->foundation) {\n\t\tast_free(candidate->foundation);\n\t}\n\n\tif (candidate->transport) {\n\t\tast_free(candidate->transport);\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_set_authentication(struct ast_rtp_instance *instance, const char *ufrag, const char *password)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint ice_attrb_reset = 0;\n\n\tif (!ast_strlen_zero(ufrag)) {\n\t\tif (!ast_strlen_zero(rtp->remote_ufrag) && strcmp(ufrag, rtp->remote_ufrag)) {\n\t\t\tice_attrb_reset = 1;\n\t\t}\n\t\tast_copy_string(rtp->remote_ufrag, ufrag, sizeof(rtp->remote_ufrag));\n\t}\n\n\tif (!ast_strlen_zero(password)) {\n\t\tif (!ast_strlen_zero(rtp->remote_passwd) && strcmp(password, rtp->remote_passwd)) {\n\t\t\tice_attrb_reset = 1;\n\t\t}\n\t\tast_copy_string(rtp->remote_passwd, password, sizeof(rtp->remote_passwd));\n\t}\n\n\t/* If the remote ufrag or passwd changed, local ufrag and passwd need to regenerate */\n\tif (ice_attrb_reset) {\n\t\tgenerate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));\n\t\tgenerate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));\n\t}\n}\n\nstatic int ice_candidate_cmp(void *obj, void *arg, int flags)\n{\n\tstruct ast_rtp_engine_ice_candidate *candidate1 = obj, *candidate2 = arg;\n\n\tif (strcmp(candidate1->foundation, candidate2->foundation) ||\n\t\t\tcandidate1->id != candidate2->id ||\n\t\t\tcandidate1->type != candidate2->type ||\n\t\t\tast_sockaddr_cmp(&candidate1->address, &candidate2->address)) {\n\t\treturn 0;\n\t}\n\n\treturn CMP_MATCH | CMP_STOP;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_add_remote_candidate(struct ast_rtp_instance *instance, const struct ast_rtp_engine_ice_candidate *candidate)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_engine_ice_candidate *remote_candidate;\n\n\t/* ICE sessions only support UDP candidates */\n\tif (strcasecmp(candidate->transport, \"udp\")) {\n\t\treturn;\n\t}\n\n\tif (!rtp->ice_proposed_remote_candidates) {\n\t\trtp->ice_proposed_remote_candidates = ao2_container_alloc_list(\n\t\t\tAO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, ice_candidate_cmp);\n\t\tif (!rtp->ice_proposed_remote_candidates) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* If this is going to exceed the maximum number of ICE candidates don't even add it */\n\tif (ao2_container_count(rtp->ice_proposed_remote_candidates) == PJ_ICE_MAX_CAND) {\n\t\treturn;\n\t}\n\n\tif (!(remote_candidate = ao2_alloc(sizeof(*remote_candidate), ast_rtp_ice_candidate_destroy))) {\n\t\treturn;\n\t}\n\n\tremote_candidate->foundation = ast_strdup(candidate->foundation);\n\tremote_candidate->id = candidate->id;\n\tremote_candidate->transport = ast_strdup(candidate->transport);\n\tremote_candidate->priority = candidate->priority;\n\tast_sockaddr_copy(&remote_candidate->address, &candidate->address);\n\tast_sockaddr_copy(&remote_candidate->relay_address, &candidate->relay_address);\n\tremote_candidate->type = candidate->type;\n\n\tast_debug_ice(2, \"(%p) ICE add remote candidate\\n\", instance);\n\n\tao2_link(rtp->ice_proposed_remote_candidates, remote_candidate);\n\tao2_ref(remote_candidate, -1);\n}\n\nAST_THREADSTORAGE(pj_thread_storage);\n\n/*! \\brief Function used to check if the calling thread is registered with pjlib. If it is not it will be registered. */\nstatic void pj_thread_register_check(void)\n{\n\tpj_thread_desc *desc;\n\tpj_thread_t *thread;\n\n\tif (pj_thread_is_registered() == PJ_TRUE) {\n\t\treturn;\n\t}\n\n\tdesc = ast_threadstorage_get(&pj_thread_storage, sizeof(pj_thread_desc));\n\tif (!desc) {\n\t\tast_log(LOG_ERROR, \"Could not get thread desc from thread-local storage. Expect awful things to occur\\n\");\n\t\treturn;\n\t}\n\tpj_bzero(*desc, sizeof(*desc));\n\n\tif (pj_thread_register(\"Asterisk Thread\", *desc, &thread) != PJ_SUCCESS) {\n\t\tast_log(LOG_ERROR, \"Coudln't register thread with PJLIB.\\n\");\n\t}\n\treturn;\n}\n\nstatic int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,\n\tint port, int replace);\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_stop(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ice_wrap *ice;\n\n\tice = rtp->ice;\n\trtp->ice = NULL;\n\tif (ice) {\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tast_debug_ice(2, \"(%p) ICE stopped\\n\", instance);\n\t}\n}\n\n/*!\n * \\brief ao2 ICE wrapper object destructor.\n *\n * \\param vdoomed Object being destroyed.\n *\n * \\note The associated struct ast_rtp_instance object must not\n * be locked when unreffing the object.  Otherwise we could\n * deadlock trying to destroy the PJPROJECT ICE structure.\n */\nstatic void ice_wrap_dtor(void *vdoomed)\n{\n\tstruct ice_wrap *ice = vdoomed;\n\n\tif (ice->real_ice) {\n\t\tpj_thread_register_check();\n\n\t\tpj_ice_sess_destroy(ice->real_ice);\n\t}\n}\n\nstatic void ast2pj_rtp_ice_role(enum ast_rtp_ice_role ast_role, enum pj_ice_sess_role *pj_role)\n{\n\tswitch (ast_role) {\n\tcase AST_RTP_ICE_ROLE_CONTROLLED:\n\t\t*pj_role = PJ_ICE_SESS_ROLE_CONTROLLED;\n\t\tbreak;\n\tcase AST_RTP_ICE_ROLE_CONTROLLING:\n\t\t*pj_role = PJ_ICE_SESS_ROLE_CONTROLLING;\n\t\tbreak;\n\t}\n}\n\nstatic void pj2ast_rtp_ice_role(enum pj_ice_sess_role pj_role, enum ast_rtp_ice_role *ast_role)\n{\n\tswitch (pj_role) {\n\tcase PJ_ICE_SESS_ROLE_CONTROLLED:\n\t\t*ast_role = AST_RTP_ICE_ROLE_CONTROLLED;\n\t\treturn;\n\tcase PJ_ICE_SESS_ROLE_CONTROLLING:\n\t\t*ast_role = AST_RTP_ICE_ROLE_CONTROLLING;\n\t\treturn;\n\tcase PJ_ICE_SESS_ROLE_UNKNOWN:\n\t\t/* Don't change anything */\n\t\treturn;\n\tdefault:\n\t\t/* If we aren't explicitly handling something, it's a bug */\n\t\tast_assert(0);\n\t\treturn;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic int ice_reset_session(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint res;\n\n\tast_debug_ice(3, \"(%p) ICE resetting\\n\", instance);\n\tif (!rtp->ice->real_ice->is_nominating && !rtp->ice->real_ice->is_complete) {\n\t\tast_debug_ice(3, \" (%p) ICE nevermind, not ready for a reset\\n\", instance);\n\t\treturn 0;\n\t}\n\n\tast_debug_ice(3, \"(%p) ICE recreating ICE session %s (%d)\\n\",\n\t\tinstance, ast_sockaddr_stringify(&rtp->ice_original_rtp_addr), rtp->ice_port);\n\tres = ice_create(instance, &rtp->ice_original_rtp_addr, rtp->ice_port, 1);\n\tif (!res) {\n\t\t/* Use the current expected role for the ICE session */\n\t\tenum pj_ice_sess_role role = PJ_ICE_SESS_ROLE_UNKNOWN;\n\t\tast2pj_rtp_ice_role(rtp->role, &role);\n\t\tpj_ice_sess_change_role(rtp->ice->real_ice, role);\n\t}\n\n\t/* If we only have one component now, and we previously set up TURN for RTCP,\n\t * we need to destroy that TURN socket.\n\t */\n\tif (rtp->ice_num_components == 1 && rtp->turn_rtcp) {\n\t\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));\n\t\tstruct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };\n\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(rtp->turn_rtcp);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t}\n\n\trtp->ice_media_started = 0;\n\n\treturn res;\n}\n\nstatic int ice_candidates_compare(struct ao2_container *left, struct ao2_container *right)\n{\n\tstruct ao2_iterator i;\n\tstruct ast_rtp_engine_ice_candidate *right_candidate;\n\n\tif (ao2_container_count(left) != ao2_container_count(right)) {\n\t\treturn -1;\n\t}\n\n\ti = ao2_iterator_init(right, 0);\n\twhile ((right_candidate = ao2_iterator_next(&i))) {\n\t\tstruct ast_rtp_engine_ice_candidate *left_candidate = ao2_find(left, right_candidate, OBJ_POINTER);\n\n\t\tif (!left_candidate) {\n\t\t\tao2_ref(right_candidate, -1);\n\t\t\tao2_iterator_destroy(&i);\n\t\t\treturn -1;\n\t\t}\n\n\t\tao2_ref(left_candidate, -1);\n\t\tao2_ref(right_candidate, -1);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_start(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tpj_str_t ufrag = pj_str(rtp->remote_ufrag), passwd = pj_str(rtp->remote_passwd);\n\tpj_ice_sess_cand candidates[PJ_ICE_MAX_CAND];\n\tstruct ao2_iterator i;\n\tstruct ast_rtp_engine_ice_candidate *candidate;\n\tint cand_cnt = 0, has_rtp = 0, has_rtcp = 0;\n\n\tif (!rtp->ice || !rtp->ice_proposed_remote_candidates) {\n\t\treturn;\n\t}\n\n\t/* Check for equivalence in the lists */\n\tif (rtp->ice_active_remote_candidates &&\n\t\t\t!ice_candidates_compare(rtp->ice_proposed_remote_candidates, rtp->ice_active_remote_candidates)) {\n\t\tast_debug_ice(2, \"(%p) ICE proposed equals active candidates\\n\", instance);\n\t\tao2_cleanup(rtp->ice_proposed_remote_candidates);\n\t\trtp->ice_proposed_remote_candidates = NULL;\n\t\t/* If this ICE session is being preserved then go back to the role it currently is */\n\t\tpj2ast_rtp_ice_role(rtp->ice->real_ice->role, &rtp->role);\n\t\treturn;\n\t}\n\n\t/* Out with the old, in with the new */\n\tao2_cleanup(rtp->ice_active_remote_candidates);\n\trtp->ice_active_remote_candidates = rtp->ice_proposed_remote_candidates;\n\trtp->ice_proposed_remote_candidates = NULL;\n\n\tast_debug_ice(2, \"(%p) ICE start\\n\", instance);\n\n\t/* Reset the ICE session. Is this going to work? */\n\tif (ice_reset_session(instance)) {\n\t\tast_log(LOG_NOTICE, \"(%p) ICE failed to create replacement session\\n\", instance);\n\t\treturn;\n\t}\n\n\tpj_thread_register_check();\n\n\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n\n\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n\t\tpj_str_t address;\n\n\t\t/* there needs to be at least one rtp and rtcp candidate in the list */\n\t\thas_rtp |= candidate->id == AST_RTP_ICE_COMPONENT_RTP;\n\t\thas_rtcp |= candidate->id == AST_RTP_ICE_COMPONENT_RTCP;\n\n\t\tpj_strdup2(rtp->ice->real_ice->pool, &candidates[cand_cnt].foundation,\n\t\t\tcandidate->foundation);\n\t\tcandidates[cand_cnt].comp_id = candidate->id;\n\t\tcandidates[cand_cnt].prio = candidate->priority;\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&candidate->address)), &candidates[cand_cnt].addr);\n\n\t\tif (!ast_sockaddr_isnull(&candidate->relay_address)) {\n\t\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&candidate->relay_address)), &candidates[cand_cnt].rel_addr);\n\t\t}\n\n\t\tif (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_HOST) {\n\t\t\tcandidates[cand_cnt].type = PJ_ICE_CAND_TYPE_HOST;\n\t\t} else if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_SRFLX) {\n\t\t\tcandidates[cand_cnt].type = PJ_ICE_CAND_TYPE_SRFLX;\n\t\t} else if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_RELAYED) {\n\t\t\tcandidates[cand_cnt].type = PJ_ICE_CAND_TYPE_RELAYED;\n\t\t}\n\n\t\tif (candidate->id == AST_RTP_ICE_COMPONENT_RTP && rtp->turn_rtp) {\n\t\t\tast_debug_ice(2, \"(%p) ICE RTP candidate %s\\n\", instance, ast_sockaddr_stringify(&candidate->address));\n\t\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\t\tao2_unlock(instance);\n\t\t\tpj_turn_sock_set_perm(rtp->turn_rtp, 1, &candidates[cand_cnt].addr, 1);\n\t\t\tao2_lock(instance);\n\t\t} else if (candidate->id == AST_RTP_ICE_COMPONENT_RTCP && rtp->turn_rtcp) {\n\t\t\tast_debug_ice(2, \"(%p) ICE RTCP candidate %s\\n\", instance, ast_sockaddr_stringify(&candidate->address));\n\t\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\t\tao2_unlock(instance);\n\t\t\tpj_turn_sock_set_perm(rtp->turn_rtcp, 1, &candidates[cand_cnt].addr, 1);\n\t\t\tao2_lock(instance);\n\t\t}\n\n\t\tcand_cnt++;\n\t\tao2_ref(candidate, -1);\n\t}\n\n\tao2_iterator_destroy(&i);\n\n\tif (cand_cnt < ao2_container_count(rtp->ice_active_remote_candidates)) {\n\t\tast_log(LOG_WARNING, \"(%p) ICE lost %d candidates. Consider increasing PJ_ICE_MAX_CAND in PJSIP\\n\",\n\t\t\tinstance, ao2_container_count(rtp->ice_active_remote_candidates) - cand_cnt);\n\t}\n\n\tif (!has_rtp) {\n\t\tast_log(LOG_WARNING, \"(%p) ICE no RTP candidates; skipping checklist\\n\", instance);\n\t}\n\n\t/* If we're only dealing with one ICE component, then we don't care about the lack of RTCP candidates */\n\tif (!has_rtcp && rtp->ice_num_components > 1) {\n\t\tast_log(LOG_WARNING, \"(%p) ICE no RTCP candidates; skipping checklist\\n\", instance);\n\t}\n\n\tif (rtp->ice && has_rtp && (has_rtcp || rtp->ice_num_components == 1)) {\n\t\tpj_status_t res;\n\t\tchar reason[80];\n\t\tstruct ice_wrap *ice;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tres = pj_ice_sess_create_check_list(ice->real_ice, &ufrag, &passwd, cand_cnt, &candidates[0]);\n\t\tif (res == PJ_SUCCESS) {\n\t\t\tast_debug_ice(2, \"(%p) ICE successfully created checklist\\n\", instance);\n\t\t\tast_test_suite_event_notify(\"ICECHECKLISTCREATE\", \"Result: SUCCESS\");\n\t\t\tpj_ice_sess_start_check(ice->real_ice);\n\t\t\tpj_timer_heap_poll(timer_heap, NULL);\n\t\t\tao2_ref(ice, -1);\n\t\t\tao2_lock(instance);\n\t\t\trtp->strict_rtp_state = STRICT_RTP_OPEN;\n\t\t\treturn;\n\t\t}\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\n\t\tpj_strerror(res, reason, sizeof(reason));\n\t\tast_log(LOG_WARNING, \"(%p) ICE failed to create session check list: %s\\n\", instance, reason);\n\t}\n\n\tast_test_suite_event_notify(\"ICECHECKLISTCREATE\", \"Result: FAILURE\");\n\n\t/* even though create check list failed don't stop ice as\n\t   it might still work */\n\t/* however we do need to reset remote candidates since\n\t   this function may be re-entered */\n\tao2_ref(rtp->ice_active_remote_candidates, -1);\n\trtp->ice_active_remote_candidates = NULL;\n\tif (rtp->ice) {\n\t\trtp->ice->real_ice->rcand_cnt = rtp->ice->real_ice->clist.count = 0;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_ice_get_ufrag(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_ufrag;\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_ice_get_password(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_passwd;\n}\n\n/*! \\pre instance is locked */\nstatic struct ao2_container *ast_rtp_ice_get_local_candidates(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->ice_local_candidates) {\n\t\tao2_ref(rtp->ice_local_candidates, +1);\n\t}\n\n\treturn rtp->ice_local_candidates;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_lite(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->ice) {\n\t\treturn;\n\t}\n\n\tpj_thread_register_check();\n\n\tpj_ice_sess_change_role(rtp->ice->real_ice, PJ_ICE_SESS_ROLE_CONTROLLING);\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_set_role(struct ast_rtp_instance *instance, enum ast_rtp_ice_role role)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->ice) {\n\t\tast_debug_ice(3, \"(%p) ICE set role failed; no ice instance\\n\", instance);\n\t\treturn;\n\t}\n\n\trtp->role = role;\n\n\tif (!rtp->ice->real_ice->is_nominating && !rtp->ice->real_ice->is_complete) {\n\t\tpj_thread_register_check();\n\t\tast_debug_ice(2, \"(%p) ICE set role to %s\\n\",\n\t\t\tinstance, role == AST_RTP_ICE_ROLE_CONTROLLED ? \"CONTROLLED\" : \"CONTROLLING\");\n\t\tpj_ice_sess_change_role(rtp->ice->real_ice, role == AST_RTP_ICE_ROLE_CONTROLLED ?\n\t\t\tPJ_ICE_SESS_ROLE_CONTROLLED : PJ_ICE_SESS_ROLE_CONTROLLING);\n\t} else {\n\t\tast_debug_ice(2, \"(%p) ICE not setting role because state is %s\\n\",\n\t\t\tinstance, rtp->ice->real_ice->is_nominating ? \"nominating\" : \"complete\");\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_add_cand(struct ast_rtp_instance *instance, struct ast_rtp *rtp,\n\tunsigned comp_id, unsigned transport_id, pj_ice_cand_type type, pj_uint16_t local_pref,\n\tconst pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr,\n\tint addr_len)\n{\n\tpj_str_t foundation;\n\tstruct ast_rtp_engine_ice_candidate *candidate, *existing;\n\tstruct ice_wrap *ice;\n\tchar address[PJ_INET6_ADDRSTRLEN];\n\tpj_status_t status;\n\n\tif (!rtp->ice) {\n\t\treturn;\n\t}\n\n\tpj_thread_register_check();\n\n\tpj_ice_calc_foundation(rtp->ice->real_ice->pool, &foundation, type, addr);\n\n\tif (!rtp->ice_local_candidates) {\n\t\trtp->ice_local_candidates = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0,\n\t\t\tNULL, ice_candidate_cmp);\n\t\tif (!rtp->ice_local_candidates) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!(candidate = ao2_alloc(sizeof(*candidate), ast_rtp_ice_candidate_destroy))) {\n\t\treturn;\n\t}\n\n\tcandidate->foundation = ast_strndup(pj_strbuf(&foundation), pj_strlen(&foundation));\n\tcandidate->id = comp_id;\n\tcandidate->transport = ast_strdup(\"UDP\");\n\n\tast_sockaddr_parse(&candidate->address, pj_sockaddr_print(addr, address, sizeof(address), 0), 0);\n\tast_sockaddr_set_port(&candidate->address, pj_sockaddr_get_port(addr));\n\n\tif (rel_addr) {\n\t\tast_sockaddr_parse(&candidate->relay_address, pj_sockaddr_print(rel_addr, address, sizeof(address), 0), 0);\n\t\tast_sockaddr_set_port(&candidate->relay_address, pj_sockaddr_get_port(rel_addr));\n\t}\n\n\tif (type == PJ_ICE_CAND_TYPE_HOST) {\n\t\tcandidate->type = AST_RTP_ICE_CANDIDATE_TYPE_HOST;\n\t} else if (type == PJ_ICE_CAND_TYPE_SRFLX) {\n\t\tcandidate->type = AST_RTP_ICE_CANDIDATE_TYPE_SRFLX;\n\t} else if (type == PJ_ICE_CAND_TYPE_RELAYED) {\n\t\tcandidate->type = AST_RTP_ICE_CANDIDATE_TYPE_RELAYED;\n\t}\n\n\tif ((existing = ao2_find(rtp->ice_local_candidates, candidate, OBJ_POINTER))) {\n\t\tao2_ref(existing, -1);\n\t\tao2_ref(candidate, -1);\n\t\treturn;\n\t}\n\n\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\tice = rtp->ice;\n\tao2_ref(ice, +1);\n\tao2_unlock(instance);\n\tstatus = pj_ice_sess_add_cand(ice->real_ice, comp_id, transport_id, type, local_pref,\n\t\t&foundation, addr, base_addr, rel_addr, addr_len, NULL);\n\tao2_ref(ice, -1);\n\tao2_lock(instance);\n\tif (!rtp->ice || status != PJ_SUCCESS) {\n\t\tast_debug_ice(2, \"(%p) ICE unable to add candidate: %s, %d\\n\", instance, ast_sockaddr_stringify(\n\t\t\t&candidate->address), candidate->priority);\n\t\tao2_ref(candidate, -1);\n\t\treturn;\n\t}\n\n\t/* By placing the candidate into the ICE session it will have produced the priority, so update the local candidate with it */\n\tcandidate->priority = rtp->ice->real_ice->lcand[rtp->ice->real_ice->lcand_cnt - 1].prio;\n\n\tast_debug_ice(2, \"(%p) ICE add candidate: %s, %d\\n\", instance, ast_sockaddr_stringify(\n\t\t&candidate->address), candidate->priority);\n\n\tao2_link(rtp->ice_local_candidates, candidate);\n\tao2_ref(candidate, -1);\n}\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rx_rtp_data(pj_turn_sock *turn_sock, void *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ice_wrap *ice;\n\tpj_status_t status;\n\n\tao2_lock(instance);\n\tice = ao2_bump(rtp->ice);\n\tao2_unlock(instance);\n\n\tif (ice) {\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice, AST_RTP_ICE_COMPONENT_RTP,\n\t\t\tTRANSPORT_TURN_RTP, pkt, pkt_len, peer_addr, addr_len);\n\t\tao2_ref(ice, -1);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar buf[100];\n\n\t\t\tpj_strerror(status, buf, sizeof(buf));\n\t\t\tast_log(LOG_WARNING, \"(%p) ICE PJ Rx error status code: %d '%s'.\\n\",\n\t\t\t\tinstance, (int)status, buf);\n\t\t\treturn;\n\t\t}\n\t\tif (!rtp->rtp_passthrough) {\n\t\t\treturn;\n\t\t}\n\t\trtp->rtp_passthrough = 0;\n\t}\n\n\tast_sendto(rtp->s, pkt, pkt_len, 0, &rtp->rtp_loop);\n}\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rtp_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state, pj_turn_state_t new_state)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp;\n\n\t/* If this is a leftover from an already notified RTP instance just ignore the state change */\n\tif (!instance) {\n\t\treturn;\n\t}\n\n\trtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\t/* We store the new state so the other thread can actually handle it */\n\trtp->turn_state = new_state;\n\tast_cond_signal(&rtp->cond);\n\n\tif (new_state == PJ_TURN_STATE_DESTROYING) {\n\t\tpj_turn_sock_set_user_data(rtp->turn_rtp, NULL);\n\t\trtp->turn_rtp = NULL;\n\t}\n\n\tao2_unlock(instance);\n}\n\n/* RTP TURN Socket interface declaration */\nstatic pj_turn_sock_cb ast_rtp_turn_rtp_sock_cb = {\n\t.on_rx_data = ast_rtp_on_turn_rx_rtp_data,\n\t.on_state = ast_rtp_on_turn_rtp_state,\n};\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rx_rtcp_data(pj_turn_sock *turn_sock, void *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ice_wrap *ice;\n\tpj_status_t status;\n\n\tao2_lock(instance);\n\tice = ao2_bump(rtp->ice);\n\tao2_unlock(instance);\n\n\tif (ice) {\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice, AST_RTP_ICE_COMPONENT_RTCP,\n\t\t\tTRANSPORT_TURN_RTCP, pkt, pkt_len, peer_addr, addr_len);\n\t\tao2_ref(ice, -1);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar buf[100];\n\n\t\t\tpj_strerror(status, buf, sizeof(buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, buf);\n\t\t\treturn;\n\t\t}\n\t\tif (!rtp->rtcp_passthrough) {\n\t\t\treturn;\n\t\t}\n\t\trtp->rtcp_passthrough = 0;\n\t}\n\n\tast_sendto(rtp->rtcp->s, pkt, pkt_len, 0, &rtp->rtcp_loop);\n}\n\n/* PJPROJECT TURN callback */\nstatic void ast_rtp_on_turn_rtcp_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state, pj_turn_state_t new_state)\n{\n\tstruct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);\n\tstruct ast_rtp *rtp;\n\n\t/* If this is a leftover from an already destroyed RTP instance just ignore the state change */\n\tif (!instance) {\n\t\treturn;\n\t}\n\n\trtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\t/* We store the new state so the other thread can actually handle it */\n\trtp->turn_state = new_state;\n\tast_cond_signal(&rtp->cond);\n\n\tif (new_state == PJ_TURN_STATE_DESTROYING) {\n\t\tpj_turn_sock_set_user_data(rtp->turn_rtcp, NULL);\n\t\trtp->turn_rtcp = NULL;\n\t}\n\n\tao2_unlock(instance);\n}\n\n/* RTCP TURN Socket interface declaration */\nstatic pj_turn_sock_cb ast_rtp_turn_rtcp_sock_cb = {\n\t.on_rx_data = ast_rtp_on_turn_rx_rtcp_data,\n\t.on_state = ast_rtp_on_turn_rtcp_state,\n};\n\n/*! \\brief Worker thread for ioqueue and timerheap */\nstatic int ioqueue_worker_thread(void *data)\n{\n\tstruct ast_rtp_ioqueue_thread *ioqueue = data;\n\n\twhile (!ioqueue->terminate) {\n\t\tconst pj_time_val delay = {0, 10};\n\n\t\tpj_ioqueue_poll(ioqueue->ioqueue, &delay);\n\n\t\tpj_timer_heap_poll(ioqueue->timerheap, NULL);\n\t}\n\n\treturn 0;\n}\n\n/*! \\brief Destroyer for ioqueue thread */\nstatic void rtp_ioqueue_thread_destroy(struct ast_rtp_ioqueue_thread *ioqueue)\n{\n\tif (ioqueue->thread) {\n\t\tioqueue->terminate = 1;\n\t\tpj_thread_join(ioqueue->thread);\n\t\tpj_thread_destroy(ioqueue->thread);\n\t}\n\n\tif (ioqueue->pool) {\n\t\t/* This mimics the behavior of pj_pool_safe_release\n\t\t * which was introduced in pjproject 2.6.\n\t\t */\n\t\tpj_pool_t *temp_pool = ioqueue->pool;\n\n\t\tioqueue->pool = NULL;\n\t\tpj_pool_release(temp_pool);\n\t}\n\n\tast_free(ioqueue);\n}\n\n/*! \\brief Removal function for ioqueue thread, determines if it should be terminated and destroyed */\nstatic void rtp_ioqueue_thread_remove(struct ast_rtp_ioqueue_thread *ioqueue)\n{\n\tint destroy = 0;\n\n\t/* If nothing is using this ioqueue thread destroy it */\n\tAST_LIST_LOCK(&ioqueues);\n\tif ((ioqueue->count -= 2) == 0) {\n\t\tdestroy = 1;\n\t\tAST_LIST_REMOVE(&ioqueues, ioqueue, next);\n\t}\n\tAST_LIST_UNLOCK(&ioqueues);\n\n\tif (!destroy) {\n\t\treturn;\n\t}\n\n\trtp_ioqueue_thread_destroy(ioqueue);\n}\n\n/*! \\brief Finder and allocator for an ioqueue thread */\nstatic struct ast_rtp_ioqueue_thread *rtp_ioqueue_thread_get_or_create(void)\n{\n\tstruct ast_rtp_ioqueue_thread *ioqueue;\n\tpj_lock_t *lock;\n\n\tAST_LIST_LOCK(&ioqueues);\n\n\t/* See if an ioqueue thread exists that can handle more */\n\tAST_LIST_TRAVERSE(&ioqueues, ioqueue, next) {\n\t\tif ((ioqueue->count + 2) < PJ_IOQUEUE_MAX_HANDLES) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found one bump it up and return it */\n\tif (ioqueue) {\n\t\tioqueue->count += 2;\n\t\tgoto end;\n\t}\n\n\tioqueue = ast_calloc(1, sizeof(*ioqueue));\n\tif (!ioqueue) {\n\t\tgoto end;\n\t}\n\n\tioqueue->pool = pj_pool_create(&cachingpool.factory, \"rtp\", 512, 512, NULL);\n\n\t/* We use a timer on the ioqueue thread for TURN so that two threads aren't operating\n\t * on a session at the same time\n\t */\n\tif (pj_timer_heap_create(ioqueue->pool, 4, &ioqueue->timerheap) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tif (pj_lock_create_recursive_mutex(ioqueue->pool, \"rtp%p\", &lock) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tpj_timer_heap_set_lock(ioqueue->timerheap, lock, PJ_TRUE);\n\n\tif (pj_ioqueue_create(ioqueue->pool, PJ_IOQUEUE_MAX_HANDLES, &ioqueue->ioqueue) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tif (pj_thread_create(ioqueue->pool, \"ice\", &ioqueue_worker_thread, ioqueue, 0, 0, &ioqueue->thread) != PJ_SUCCESS) {\n\t\tgoto fatal;\n\t}\n\n\tAST_LIST_INSERT_HEAD(&ioqueues, ioqueue, next);\n\n\t/* Since this is being returned to an active session the count always starts at 2 */\n\tioqueue->count = 2;\n\n\tgoto end;\n\nfatal:\n\trtp_ioqueue_thread_destroy(ioqueue);\n\tioqueue = NULL;\n\nend:\n\tAST_LIST_UNLOCK(&ioqueues);\n\treturn ioqueue;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_turn_request(struct ast_rtp_instance *instance, enum ast_rtp_ice_component_type component,\n\t\tenum ast_transport transport, const char *server, unsigned int port, const char *username, const char *password)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tpj_turn_sock **turn_sock;\n\tconst pj_turn_sock_cb *turn_cb;\n\tpj_turn_tp_type conn_type;\n\tint conn_transport;\n\tpj_stun_auth_cred cred = { 0, };\n\tpj_str_t turn_addr;\n\tstruct ast_sockaddr addr = { { 0, } };\n\tpj_stun_config stun_config;\n\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));\n\tstruct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };\n\tpj_turn_session_info info;\n\tstruct ast_sockaddr local, loop;\n\tpj_status_t status;\n\tpj_turn_sock_cfg turn_sock_cfg;\n\tstruct ice_wrap *ice;\n\n\tast_rtp_instance_get_local_address(instance, &local);\n\tif (ast_sockaddr_is_ipv4(&local)) {\n\t\tast_sockaddr_parse(&loop, \"127.0.0.1\", PARSE_PORT_FORBID);\n\t} else {\n\t\tast_sockaddr_parse(&loop, \"::1\", PARSE_PORT_FORBID);\n\t}\n\n\t/* Determine what component we are requesting a TURN session for */\n\tif (component == AST_RTP_ICE_COMPONENT_RTP) {\n\t\tturn_sock = &rtp->turn_rtp;\n\t\tturn_cb = &ast_rtp_turn_rtp_sock_cb;\n\t\tconn_transport = TRANSPORT_TURN_RTP;\n\t\tast_sockaddr_set_port(&loop, ast_sockaddr_port(&local));\n\t} else if (component == AST_RTP_ICE_COMPONENT_RTCP) {\n\t\tturn_sock = &rtp->turn_rtcp;\n\t\tturn_cb = &ast_rtp_turn_rtcp_sock_cb;\n\t\tconn_transport = TRANSPORT_TURN_RTCP;\n\t\tast_sockaddr_set_port(&loop, ast_sockaddr_port(&rtp->rtcp->us));\n\t} else {\n\t\treturn;\n\t}\n\n\tif (transport == AST_TRANSPORT_UDP) {\n\t\tconn_type = PJ_TURN_TP_UDP;\n\t} else if (transport == AST_TRANSPORT_TCP) {\n\t\tconn_type = PJ_TURN_TP_TCP;\n\t} else {\n\t\tast_assert(0);\n\t\treturn;\n\t}\n\n\tast_sockaddr_parse(&addr, server, PARSE_PORT_FORBID);\n\n\tif (*turn_sock) {\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(*turn_sock);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t}\n\n\tif (component == AST_RTP_ICE_COMPONENT_RTP && !rtp->ioqueue) {\n\t\t/*\n\t\t * We cannot hold the instance lock because we could wait\n\t\t * for the ioqueue thread to die and we might deadlock as\n\t\t * a result.\n\t\t */\n\t\tao2_unlock(instance);\n\t\trtp->ioqueue = rtp_ioqueue_thread_get_or_create();\n\t\tao2_lock(instance);\n\t\tif (!rtp->ioqueue) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpj_stun_config_init(&stun_config, &cachingpool.factory, 0, rtp->ioqueue->ioqueue, rtp->ioqueue->timerheap);\n\tif (!stun_software_attribute) {\n\t\tstun_config.software_name = pj_str(NULL);\n\t}\n\n\t/* Use ICE session group lock for TURN session to avoid deadlock */\n\tpj_turn_sock_cfg_default(&turn_sock_cfg);\n\tice = rtp->ice;\n\tif (ice) {\n\t\tturn_sock_cfg.grp_lock = ice->real_ice->grp_lock;\n\t\tao2_ref(ice, +1);\n\t}\n\n\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\tao2_unlock(instance);\n\tstatus = pj_turn_sock_create(&stun_config,\n\t\tast_sockaddr_is_ipv4(&addr) ? pj_AF_INET() : pj_AF_INET6(), conn_type,\n\t\tturn_cb, &turn_sock_cfg, instance, turn_sock);\n\tao2_cleanup(ice);\n\tif (status != PJ_SUCCESS) {\n\t\tast_log(LOG_WARNING, \"(%p) Could not create a TURN client socket\\n\", instance);\n\t\tao2_lock(instance);\n\t\treturn;\n\t}\n\n\tcred.type = PJ_STUN_AUTH_CRED_STATIC;\n\tpj_strset2(&cred.data.static_cred.username, (char*)username);\n\tcred.data.static_cred.data_type = PJ_STUN_PASSWD_PLAIN;\n\tpj_strset2(&cred.data.static_cred.data, (char*)password);\n\n\tpj_turn_sock_alloc(*turn_sock, pj_cstr(&turn_addr, server), port, NULL, &cred, NULL);\n\n\tast_debug_ice(2, \"(%p) ICE request TURN %s %s candidate\\n\", instance,\n\t\ttransport == AST_TRANSPORT_UDP ? \"UDP\" : \"TCP\",\n\t\tcomponent == AST_RTP_ICE_COMPONENT_RTP ? \"RTP\" : \"RTCP\");\n\n\tao2_lock(instance);\n\n\t/*\n\t * Because the TURN socket is asynchronous and we are synchronous we need to\n\t * wait until it is done\n\t */\n\twhile (rtp->turn_state < PJ_TURN_STATE_READY) {\n\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t}\n\n\t/* If a TURN session was allocated add it as a candidate */\n\tif (rtp->turn_state != PJ_TURN_STATE_READY) {\n\t\treturn;\n\t}\n\n\tpj_turn_sock_get_info(*turn_sock, &info);\n\n\tast_rtp_ice_add_cand(instance, rtp, component, conn_transport,\n\t\tPJ_ICE_CAND_TYPE_RELAYED, 65535, &info.relay_addr, &info.relay_addr,\n\t\t&info.mapped_addr, pj_sockaddr_get_len(&info.relay_addr));\n\n\tif (component == AST_RTP_ICE_COMPONENT_RTP) {\n\t\tast_sockaddr_copy(&rtp->rtp_loop, &loop);\n\t} else if (component == AST_RTP_ICE_COMPONENT_RTCP) {\n\t\tast_sockaddr_copy(&rtp->rtcp_loop, &loop);\n\t}\n}\n\nstatic char *generate_random_string(char *buf, size_t size)\n{\n        long val[4];\n        int x;\n\n        for (x=0; x<4; x++) {\n                val[x] = ast_random();\n\t}\n        snprintf(buf, size, \"%08lx%08lx%08lx%08lx\", (long unsigned)val[0], (long unsigned)val[1], (long unsigned)val[2], (long unsigned)val[3]);\n\n        return buf;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_ice_change_components(struct ast_rtp_instance *instance, int num_components)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* Don't do anything if ICE is unsupported or if we're not changing the\n\t * number of components\n\t */\n\tif (!icesupport || !rtp->ice || rtp->ice_num_components == num_components) {\n\t\treturn;\n\t}\n\n\tast_debug_ice(2, \"(%p) ICE change number of components %u -> %u\\n\", instance,\n\t\trtp->ice_num_components, num_components);\n\n\trtp->ice_num_components = num_components;\n\tice_reset_session(instance);\n}\n\n/* ICE RTP Engine interface declaration */\nstatic struct ast_rtp_engine_ice ast_rtp_ice = {\n\t.set_authentication = ast_rtp_ice_set_authentication,\n\t.add_remote_candidate = ast_rtp_ice_add_remote_candidate,\n\t.start = ast_rtp_ice_start,\n\t.stop = ast_rtp_ice_stop,\n\t.get_ufrag = ast_rtp_ice_get_ufrag,\n\t.get_password = ast_rtp_ice_get_password,\n\t.get_local_candidates = ast_rtp_ice_get_local_candidates,\n\t.ice_lite = ast_rtp_ice_lite,\n\t.set_role = ast_rtp_ice_set_role,\n\t.turn_request = ast_rtp_ice_turn_request,\n\t.change_components = ast_rtp_ice_change_components,\n};\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic int dtls_verify_callback(int preverify_ok, X509_STORE_CTX *ctx)\n{\n\t/* We don't want to actually verify the certificate so just accept what they have provided */\n\treturn 1;\n}\n\nstatic int dtls_details_initialize(struct dtls_details *dtls, SSL_CTX *ssl_ctx,\n\tenum ast_rtp_dtls_setup setup, struct ast_rtp_instance *instance)\n{\n\tdtls->dtls_setup = setup;\n\n\tif (!(dtls->ssl = SSL_new(ssl_ctx))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for SSL\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dtls->read_bio = BIO_new(BIO_s_mem()))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for inbound SSL traffic\\n\");\n\t\tgoto error;\n\t}\n\tBIO_set_mem_eof_return(dtls->read_bio, -1);\n\n#ifdef HAVE_OPENSSL_BIO_METHOD\n\tif (!(dtls->write_bio = BIO_new(dtls_bio_methods))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for outbound SSL traffic\\n\");\n\t\tgoto error;\n\t}\n\n\tBIO_set_data(dtls->write_bio, instance);\n#else\n\tif (!(dtls->write_bio = BIO_new(&dtls_bio_methods))) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for outbound SSL traffic\\n\");\n\t\tgoto error;\n\t}\n\tdtls->write_bio->ptr = instance;\n#endif\n\tSSL_set_bio(dtls->ssl, dtls->read_bio, dtls->write_bio);\n\n\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_PASSIVE) {\n\t\tSSL_set_accept_state(dtls->ssl);\n\t} else {\n\t\tSSL_set_connect_state(dtls->ssl);\n\t}\n\tdtls->connection = AST_RTP_DTLS_CONNECTION_NEW;\n\n\treturn 0;\n\nerror:\n\tif (dtls->read_bio) {\n\t\tBIO_free(dtls->read_bio);\n\t\tdtls->read_bio = NULL;\n\t}\n\n\tif (dtls->write_bio) {\n\t\tBIO_free(dtls->write_bio);\n\t\tdtls->write_bio = NULL;\n\t}\n\n\tif (dtls->ssl) {\n\t\tSSL_free(dtls->ssl);\n\t\tdtls->ssl = NULL;\n\t}\n\treturn -1;\n}\n\nstatic int dtls_setup_rtcp(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->ssl_ctx || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tast_debug_dtls(3, \"(%p) DTLS RTCP setup\\n\", instance);\n\treturn dtls_details_initialize(&rtp->rtcp->dtls, rtp->ssl_ctx, rtp->dtls.dtls_setup, instance);\n}\n\nstatic const SSL_METHOD *get_dtls_method(void)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10002000L\n\treturn DTLSv1_method();\n#else\n\treturn DTLS_method();\n#endif\n}\n\nstruct dtls_cert_info {\n\tEVP_PKEY *private_key;\n\tX509 *certificate;\n};\n\nstatic int apply_dh_params(SSL_CTX *ctx, BIO *bio)\n{\n\tint res = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n\tEVP_PKEY *dhpkey = PEM_read_bio_Parameters(bio, NULL);\n\tif (dhpkey && EVP_PKEY_is_a(dhpkey, \"DH\")) {\n\t\tres = SSL_CTX_set0_tmp_dh_pkey(ctx, dhpkey);\n\t}\n\tif (!res) {\n\t\t/* A successful call to SSL_CTX_set0_tmp_dh_pkey() means\n\t\t   that we lost ownership of dhpkey and should not free\n\t\t   it ourselves */\n\t\tEVP_PKEY_free(dhpkey);\n\t}\n#else\n\tDH *dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tif (dh) {\n\t\tres = SSL_CTX_set_tmp_dh(ctx, dh);\n\t}\n\tDH_free(dh);\n#endif\n\n\treturn res;\n}\n\nstatic void configure_dhparams(const struct ast_rtp *rtp, const struct ast_rtp_dtls_cfg *dtls_cfg)\n{\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L) && (OPENSSL_VERSION_NUMBER < 0x10100000L)\n\tEC_KEY *ecdh;\n#endif\n\n#ifndef OPENSSL_NO_DH\n\tif (!ast_strlen_zero(dtls_cfg->pvtfile)) {\n\t\tBIO *bio = BIO_new_file(dtls_cfg->pvtfile, \"r\");\n\t\tif (bio) {\n\t\t\tif (apply_dh_params(rtp->ssl_ctx, bio)) {\n\t\t\t\tlong options = SSL_OP_CIPHER_SERVER_PREFERENCE |\n\t\t\t\t\tSSL_OP_SINGLE_DH_USE | SSL_OP_SINGLE_ECDH_USE;\n\t\t\t\toptions = SSL_CTX_set_options(rtp->ssl_ctx, options);\n\t\t\t\tast_verb(2, \"DTLS DH initialized, PFS enabled\\n\");\n\t\t\t}\n\t\t\tBIO_free(bio);\n\t\t}\n\t}\n#endif /* !OPENSSL_NO_DH */\n\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L) && (OPENSSL_VERSION_NUMBER < 0x10100000L)\n\t/* enables AES-128 ciphers, to get AES-256 use NID_secp384r1 */\n\tecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (ecdh) {\n\t\tif (SSL_CTX_set_tmp_ecdh(rtp->ssl_ctx, ecdh)) {\n\t\t\t#ifndef SSL_CTRL_SET_ECDH_AUTO\n\t\t\t\t#define SSL_CTRL_SET_ECDH_AUTO 94\n\t\t\t#endif\n\t\t\t/* SSL_CTX_set_ecdh_auto(rtp->ssl_ctx, on); requires OpenSSL 1.0.2 which wraps: */\n\t\t\tif (SSL_CTX_ctrl(rtp->ssl_ctx, SSL_CTRL_SET_ECDH_AUTO, 1, NULL)) {\n\t\t\t\tast_verb(2, \"DTLS ECDH initialized (automatic), faster PFS enabled\\n\");\n\t\t\t} else {\n\t\t\t\tast_verb(2, \"DTLS ECDH initialized (secp256r1), faster PFS enabled\\n\");\n\t\t\t}\n\t\t}\n\t\tEC_KEY_free(ecdh);\n\t}\n#endif /* !OPENSSL_NO_ECDH */\n}\n\n#if !defined(OPENSSL_NO_ECDH) && (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n\nstatic int create_ephemeral_ec_keypair(EVP_PKEY **keypair)\n{\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n\t*keypair = EVP_EC_gen(SN_X9_62_prime256v1);\n\treturn *keypair ? 0 : -1;\n#else\n\tEC_KEY *eckey = NULL;\n\tEC_GROUP *group = NULL;\n\n\tgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (!group) {\n\t\tgoto error;\n\t}\n\n\tEC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);\n\tEC_GROUP_set_point_conversion_form(group, POINT_CONVERSION_UNCOMPRESSED);\n\n\teckey = EC_KEY_new();\n\tif (!eckey) {\n\t\tgoto error;\n\t}\n\n\tif (!EC_KEY_set_group(eckey, group)) {\n\t\tgoto error;\n\t}\n\n\tif (!EC_KEY_generate_key(eckey)) {\n\t\tgoto error;\n\t}\n\n\t*keypair = EVP_PKEY_new();\n\tif (!*keypair) {\n\t\tgoto error;\n\t}\n\n\tEVP_PKEY_assign_EC_KEY(*keypair, eckey);\n\tEC_GROUP_free(group);\n\n\treturn 0;\n\nerror:\n\tEC_KEY_free(eckey);\n\tEC_GROUP_free(group);\n\n\treturn -1;\n#endif\n}\n\n/* From OpenSSL's x509 command */\n#define SERIAL_RAND_BITS 159\n\nstatic int create_ephemeral_certificate(EVP_PKEY *keypair, X509 **certificate)\n{\n\tX509 *cert = NULL;\n\tBIGNUM *serial = NULL;\n\tX509_NAME *name = NULL;\n\n\tcert = X509_new();\n\tif (!cert) {\n\t\tgoto error;\n\t}\n\n\tif (!X509_set_version(cert, 2)) {\n\t\tgoto error;\n\t}\n\n\t/* Set the public key */\n\tX509_set_pubkey(cert, keypair);\n\n\t/* Generate a random serial number */\n\tif (!(serial = BN_new())\n\t   || !BN_rand(serial, SERIAL_RAND_BITS, -1, 0)\n\t   || !BN_to_ASN1_INTEGER(serial, X509_get_serialNumber(cert))) {\n\t\tBN_free(serial);\n\t\tgoto error;\n\t}\n\n\tBN_free(serial);\n\n\t/*\n\t * Validity period - Current Chrome & Firefox make it 31 days starting\n\t * with yesterday at the current time, so we will do the same.\n\t */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tif (!X509_time_adj_ex(X509_get_notBefore(cert), -1, 0, NULL)\n\t   || !X509_time_adj_ex(X509_get_notAfter(cert), 30, 0, NULL)) {\n\t\tgoto error;\n\t}\n#else\n\tif (!X509_time_adj_ex(X509_getm_notBefore(cert), -1, 0, NULL)\n\t   || !X509_time_adj_ex(X509_getm_notAfter(cert), 30, 0, NULL)) {\n\t\tgoto error;\n\t}\n#endif\n\n\t/* Set the name and issuer */\n\tif (!(name = X509_get_subject_name(cert))\n\t   || !X509_NAME_add_entry_by_NID(name, NID_commonName, MBSTRING_ASC,\n\t\t\t\t\t\t\t\t\t  (unsigned char *) \"asterisk\", -1, -1, 0)\n\t   || !X509_set_issuer_name(cert, name)) {\n\t\tgoto error;\n\t}\n\n\t/* Sign it */\n\tif (!X509_sign(cert, keypair, EVP_sha256())) {\n\t\tgoto error;\n\t}\n\n\t*certificate = cert;\n\n\treturn 0;\n\nerror:\n\tX509_free(cert);\n\n\treturn -1;\n}\n\nstatic int create_certificate_ephemeral(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t\t\tconst struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t\t\tstruct dtls_cert_info *cert_info)\n{\n\t/* Make sure these are initialized */\n\tcert_info->private_key = NULL;\n\tcert_info->certificate = NULL;\n\n\tif (create_ephemeral_ec_keypair(&cert_info->private_key)) {\n\t\tast_log(LOG_ERROR, \"Failed to create ephemeral ECDSA keypair\\n\");\n\t\tgoto error;\n\t}\n\n\tif (create_ephemeral_certificate(cert_info->private_key, &cert_info->certificate)) {\n\t\tast_log(LOG_ERROR, \"Failed to create ephemeral X509 certificate\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n  error:\n\tX509_free(cert_info->certificate);\n\tEVP_PKEY_free(cert_info->private_key);\n\n\treturn -1;\n}\n\n#else\n\nstatic int create_certificate_ephemeral(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t\t\tconst struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t\t\tstruct dtls_cert_info *cert_info)\n{\n\tast_log(LOG_ERROR, \"Your version of OpenSSL does not support ECDSA keys\\n\");\n\treturn -1;\n}\n\n#endif /* !OPENSSL_NO_ECDH */\n\nstatic int create_certificate_from_file(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t\t\tconst struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t\t\tstruct dtls_cert_info *cert_info)\n{\n\tFILE *fp;\n\tBIO *certbio = NULL;\n\tEVP_PKEY *private_key = NULL;\n\tX509 *cert = NULL;\n\tchar *private_key_file = ast_strlen_zero(dtls_cfg->pvtfile) ? dtls_cfg->certfile : dtls_cfg->pvtfile;\n\n\tfp = fopen(private_key_file, \"r\");\n\tif (!fp) {\n\t\tast_log(LOG_ERROR, \"Failed to read private key from file '%s': %s\\n\", private_key_file, strerror(errno));\n\t\tgoto error;\n\t}\n\n\tif (!PEM_read_PrivateKey(fp, &private_key, NULL, NULL)) {\n\t\tast_log(LOG_ERROR, \"Failed to read private key from PEM file '%s'\\n\", private_key_file);\n\t\tfclose(fp);\n\t\tgoto error;\n\t}\n\n\tif (fclose(fp)) {\n\t\tast_log(LOG_ERROR, \"Failed to close private key file '%s': %s\\n\", private_key_file, strerror(errno));\n\t\tgoto error;\n\t}\n\n\tcertbio = BIO_new(BIO_s_file());\n\tif (!certbio) {\n\t\tast_log(LOG_ERROR, \"Failed to allocate memory for certificate fingerprinting on RTP instance '%p'\\n\",\n\t\t\t\tinstance);\n\t\tgoto error;\n\t}\n\n\tif (!BIO_read_filename(certbio, dtls_cfg->certfile)\n\t   || !(cert = PEM_read_bio_X509(certbio, NULL, 0, NULL))) {\n\t\tast_log(LOG_ERROR, \"Failed to read certificate from file '%s'\\n\", dtls_cfg->certfile);\n\t\tgoto error;\n\t}\n\n\tcert_info->private_key = private_key;\n\tcert_info->certificate = cert;\n\n\tBIO_free_all(certbio);\n\n\treturn 0;\n\nerror:\n\tX509_free(cert);\n\tBIO_free_all(certbio);\n\tEVP_PKEY_free(private_key);\n\n\treturn -1;\n}\n\nstatic int load_dtls_certificate(struct ast_rtp_instance *instance,\n\t\t\t\t\t\t\t\t const struct ast_rtp_dtls_cfg *dtls_cfg,\n\t\t\t\t\t\t\t\t struct dtls_cert_info *cert_info)\n{\n\tif (dtls_cfg->ephemeral_cert) {\n\t\treturn create_certificate_ephemeral(instance, dtls_cfg, cert_info);\n\t} else if (!ast_strlen_zero(dtls_cfg->certfile)) {\n\t\treturn create_certificate_from_file(instance, dtls_cfg, cert_info);\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtls_set_configuration(struct ast_rtp_instance *instance, const struct ast_rtp_dtls_cfg *dtls_cfg)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct dtls_cert_info cert_info = { 0 };\n\tint res;\n\n\tif (!dtls_cfg->enabled) {\n\t\treturn 0;\n\t}\n\n\tast_debug_dtls(3, \"(%p) DTLS RTP setup\\n\", instance);\n\n\tif (!ast_rtp_engine_srtp_is_registered()) {\n\t\tast_log(LOG_ERROR, \"SRTP support module is not loaded or available. Try loading res_srtp.so.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rtp->ssl_ctx) {\n\t\treturn 0;\n\t}\n\n\trtp->ssl_ctx = SSL_CTX_new(get_dtls_method());\n\tif (!rtp->ssl_ctx) {\n\t\treturn -1;\n\t}\n\n\tSSL_CTX_set_read_ahead(rtp->ssl_ctx, 1);\n\n\tconfigure_dhparams(rtp, dtls_cfg);\n\n\trtp->dtls_verify = dtls_cfg->verify;\n\n\tSSL_CTX_set_verify(rtp->ssl_ctx, (rtp->dtls_verify & AST_RTP_DTLS_VERIFY_FINGERPRINT) || (rtp->dtls_verify & AST_RTP_DTLS_VERIFY_CERTIFICATE) ?\n\t\tSSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT : SSL_VERIFY_NONE, !(rtp->dtls_verify & AST_RTP_DTLS_VERIFY_CERTIFICATE) ?\n\t\tdtls_verify_callback : NULL);\n\n\tif (dtls_cfg->suite == AST_AES_CM_128_HMAC_SHA1_80) {\n\t\tSSL_CTX_set_tlsext_use_srtp(rtp->ssl_ctx, \"SRTP_AES128_CM_SHA1_80\");\n\t} else if (dtls_cfg->suite == AST_AES_CM_128_HMAC_SHA1_32) {\n\t\tSSL_CTX_set_tlsext_use_srtp(rtp->ssl_ctx, \"SRTP_AES128_CM_SHA1_32\");\n\t} else {\n\t\tast_log(LOG_ERROR, \"Unsupported suite specified for DTLS-SRTP on RTP instance '%p'\\n\", instance);\n\t\treturn -1;\n\t}\n\n\trtp->local_hash = dtls_cfg->hash;\n\n\tif (!load_dtls_certificate(instance, dtls_cfg, &cert_info)) {\n\t\tconst EVP_MD *type;\n\t\tunsigned int size, i;\n\t\tunsigned char fingerprint[EVP_MAX_MD_SIZE];\n\t\tchar *local_fingerprint = rtp->local_fingerprint;\n\n\t\tif (!SSL_CTX_use_certificate(rtp->ssl_ctx, cert_info.certificate)) {\n\t\t\tast_log(LOG_ERROR, \"Specified certificate for RTP instance '%p' could not be used\\n\",\n\t\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!SSL_CTX_use_PrivateKey(rtp->ssl_ctx, cert_info.private_key)\n\t\t    || !SSL_CTX_check_private_key(rtp->ssl_ctx)) {\n\t\t\tast_log(LOG_ERROR, \"Specified private key for RTP instance '%p' could not be used\\n\",\n\t\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rtp->local_hash == AST_RTP_DTLS_HASH_SHA1) {\n\t\t\ttype = EVP_sha1();\n\t\t} else if (rtp->local_hash == AST_RTP_DTLS_HASH_SHA256) {\n\t\t\ttype = EVP_sha256();\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Unsupported fingerprint hash type on RTP instance '%p'\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!X509_digest(cert_info.certificate, type, fingerprint, &size) || !size) {\n\t\t\tast_log(LOG_ERROR, \"Could not produce fingerprint from certificate for RTP instance '%p'\\n\",\n\t\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tsprintf(local_fingerprint, \"%02hhX:\", fingerprint[i]);\n\t\t\tlocal_fingerprint += 3;\n\t\t}\n\n\t\t*(local_fingerprint - 1) = 0;\n\n\t\tEVP_PKEY_free(cert_info.private_key);\n\t\tX509_free(cert_info.certificate);\n\t}\n\n\tif (!ast_strlen_zero(dtls_cfg->cipher)) {\n\t\tif (!SSL_CTX_set_cipher_list(rtp->ssl_ctx, dtls_cfg->cipher)) {\n\t\t\tast_log(LOG_ERROR, \"Invalid cipher specified in cipher list '%s' for RTP instance '%p'\\n\",\n\t\t\t\tdtls_cfg->cipher, instance);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!ast_strlen_zero(dtls_cfg->cafile) || !ast_strlen_zero(dtls_cfg->capath)) {\n\t\tif (!SSL_CTX_load_verify_locations(rtp->ssl_ctx, S_OR(dtls_cfg->cafile, NULL), S_OR(dtls_cfg->capath, NULL))) {\n\t\t\tast_log(LOG_ERROR, \"Invalid certificate authority file '%s' or path '%s' specified for RTP instance '%p'\\n\",\n\t\t\t\tS_OR(dtls_cfg->cafile, \"\"), S_OR(dtls_cfg->capath, \"\"), instance);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trtp->rekey = dtls_cfg->rekey;\n\trtp->suite = dtls_cfg->suite;\n\n\tres = dtls_details_initialize(&rtp->dtls, rtp->ssl_ctx, dtls_cfg->default_setup, instance);\n\tif (!res) {\n\t\tdtls_setup_rtcp(instance);\n\t}\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtls_active(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn !rtp->ssl_ctx ? 0 : 1;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_stop(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tSSL *ssl = rtp->dtls.ssl;\n\n\tast_debug_dtls(3, \"(%p) DTLS stop\\n\", instance);\n\tao2_unlock(instance);\n\tdtls_srtp_stop_timeout_timer(instance, rtp, 0);\n\tao2_lock(instance);\n\n\tif (rtp->ssl_ctx) {\n\t\tSSL_CTX_free(rtp->ssl_ctx);\n\t\trtp->ssl_ctx = NULL;\n\t}\n\n\tif (rtp->dtls.ssl) {\n\t\tSSL_free(rtp->dtls.ssl);\n\t\trtp->dtls.ssl = NULL;\n\t}\n\n\tif (rtp->rtcp) {\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, 1);\n\t\tao2_lock(instance);\n\n\t\tif (rtp->rtcp->dtls.ssl) {\n\t\t\tif (rtp->rtcp->dtls.ssl != ssl) {\n\t\t\t\tSSL_free(rtp->rtcp->dtls.ssl);\n\t\t\t}\n\t\t\trtp->rtcp->dtls.ssl = NULL;\n\t\t}\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_reset(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (SSL_is_init_finished(rtp->dtls.ssl)) {\n\t\tSSL_shutdown(rtp->dtls.ssl);\n\t\trtp->dtls.connection = AST_RTP_DTLS_CONNECTION_NEW;\n\t}\n\n\tif (rtp->rtcp && SSL_is_init_finished(rtp->rtcp->dtls.ssl)) {\n\t\tSSL_shutdown(rtp->rtcp->dtls.ssl);\n\t\trtp->rtcp->dtls.connection = AST_RTP_DTLS_CONNECTION_NEW;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtls_connection ast_rtp_dtls_get_connection(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->dtls.connection;\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtls_setup ast_rtp_dtls_get_setup(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->dtls.dtls_setup;\n}\n\nstatic void dtls_set_setup(enum ast_rtp_dtls_setup *dtls_setup, enum ast_rtp_dtls_setup setup, SSL *ssl)\n{\n\tenum ast_rtp_dtls_setup old = *dtls_setup;\n\n\tswitch (setup) {\n\tcase AST_RTP_DTLS_SETUP_ACTIVE:\n\t\t*dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\tbreak;\n\tcase AST_RTP_DTLS_SETUP_PASSIVE:\n\t\t*dtls_setup = AST_RTP_DTLS_SETUP_ACTIVE;\n\t\tbreak;\n\tcase AST_RTP_DTLS_SETUP_ACTPASS:\n\t\t/* We can't respond to an actpass setup with actpass ourselves... so respond with active, as we can initiate connections */\n\t\tif (*dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\t*dtls_setup = AST_RTP_DTLS_SETUP_ACTIVE;\n\t\t}\n\t\tbreak;\n\tcase AST_RTP_DTLS_SETUP_HOLDCONN:\n\t\t*dtls_setup = AST_RTP_DTLS_SETUP_HOLDCONN;\n\t\tbreak;\n\tdefault:\n\t\t/* This should never occur... if it does exit early as we don't know what state things are in */\n\t\treturn;\n\t}\n\n\t/* If the setup state did not change we go on as if nothing happened */\n\tif (old == *dtls_setup) {\n\t\treturn;\n\t}\n\n\t/* If they don't want us to establish a connection wait until later */\n\tif (*dtls_setup == AST_RTP_DTLS_SETUP_HOLDCONN) {\n\t\treturn;\n\t}\n\n\tif (*dtls_setup == AST_RTP_DTLS_SETUP_ACTIVE) {\n\t\tSSL_set_connect_state(ssl);\n\t} else if (*dtls_setup == AST_RTP_DTLS_SETUP_PASSIVE) {\n\t\tSSL_set_accept_state(ssl);\n\t} else {\n\t\treturn;\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_set_setup(struct ast_rtp_instance *instance, enum ast_rtp_dtls_setup setup)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->dtls.ssl) {\n\t\tdtls_set_setup(&rtp->dtls.dtls_setup, setup, rtp->dtls.ssl);\n\t}\n\n\tif (rtp->rtcp && rtp->rtcp->dtls.ssl) {\n\t\tdtls_set_setup(&rtp->rtcp->dtls.dtls_setup, setup, rtp->rtcp->dtls.ssl);\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_dtls_set_fingerprint(struct ast_rtp_instance *instance, enum ast_rtp_dtls_hash hash, const char *fingerprint)\n{\n\tchar *tmp = ast_strdupa(fingerprint), *value;\n\tint pos = 0;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (hash != AST_RTP_DTLS_HASH_SHA1 && hash != AST_RTP_DTLS_HASH_SHA256) {\n\t\treturn;\n\t}\n\n\trtp->remote_hash = hash;\n\n\twhile ((value = strsep(&tmp, \":\")) && (pos != (EVP_MAX_MD_SIZE - 1))) {\n\t\tsscanf(value, \"%02hhx\", &rtp->remote_fingerprint[pos++]);\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtls_hash ast_rtp_dtls_get_fingerprint_hash(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_hash;\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_dtls_get_fingerprint(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->local_fingerprint;\n}\n\n/* DTLS RTP Engine interface declaration */\nstatic struct ast_rtp_engine_dtls ast_rtp_dtls = {\n\t.set_configuration = ast_rtp_dtls_set_configuration,\n\t.active = ast_rtp_dtls_active,\n\t.stop = ast_rtp_dtls_stop,\n\t.reset = ast_rtp_dtls_reset,\n\t.get_connection = ast_rtp_dtls_get_connection,\n\t.get_setup = ast_rtp_dtls_get_setup,\n\t.set_setup = ast_rtp_dtls_set_setup,\n\t.set_fingerprint = ast_rtp_dtls_set_fingerprint,\n\t.get_fingerprint_hash = ast_rtp_dtls_get_fingerprint_hash,\n\t.get_fingerprint = ast_rtp_dtls_get_fingerprint,\n};\n\n#endif\n\n#ifdef TEST_FRAMEWORK\nstatic size_t get_recv_buffer_count(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->recv_buffer) {\n\t\treturn ast_data_buffer_count(rtp->recv_buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t get_recv_buffer_max(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->recv_buffer) {\n\t\treturn ast_data_buffer_max(rtp->recv_buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t get_send_buffer_count(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->send_buffer) {\n\t\treturn ast_data_buffer_count(rtp->send_buffer);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_rtp_rtcp_schedid(struct ast_rtp_instance *instance, int id)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp && rtp->rtcp) {\n\t\trtp->rtcp->schedid = id;\n\t}\n}\n\nstatic struct ast_rtp_engine_test ast_rtp_test = {\n\t.packets_to_drop = 0,\n\t.send_report = 0,\n\t.sdes_received = 0,\n\t.recv_buffer_count = get_recv_buffer_count,\n\t.recv_buffer_max = get_recv_buffer_max,\n\t.send_buffer_count = get_send_buffer_count,\n\t.set_schedid = set_rtp_rtcp_schedid,\n};\n#endif\n\n/* RTP Engine Declaration */\nstatic struct ast_rtp_engine asterisk_rtp_engine = {\n\t.name = \"asterisk\",\n\t.new = ast_rtp_new,\n\t.destroy = ast_rtp_destroy,\n\t.dtmf_begin = ast_rtp_dtmf_begin,\n\t.dtmf_end = ast_rtp_dtmf_end,\n\t.dtmf_end_with_duration = ast_rtp_dtmf_end_with_duration,\n\t.dtmf_mode_set = ast_rtp_dtmf_mode_set,\n\t.dtmf_mode_get = ast_rtp_dtmf_mode_get,\n\t.update_source = ast_rtp_update_source,\n\t.change_source = ast_rtp_change_source,\n\t.write = ast_rtp_write,\n\t.read = ast_rtp_read,\n\t.prop_set = ast_rtp_prop_set,\n\t.fd = ast_rtp_fd,\n\t.remote_address_set = ast_rtp_remote_address_set,\n\t.red_init = rtp_red_init,\n\t.red_buffer = rtp_red_buffer,\n\t.local_bridge = ast_rtp_local_bridge,\n\t.get_stat = ast_rtp_get_stat,\n\t.dtmf_compatible = ast_rtp_dtmf_compatible,\n\t.stun_request = ast_rtp_stun_request,\n\t.stop = ast_rtp_stop,\n\t.qos = ast_rtp_qos_set,\n\t.sendcng = ast_rtp_sendcng,\n#ifdef HAVE_PJPROJECT\n\t.ice = &ast_rtp_ice,\n#endif\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t.dtls = &ast_rtp_dtls,\n\t.activate = ast_rtp_activate,\n#endif\n\t.ssrc_get = ast_rtp_get_ssrc,\n\t.cname_get = ast_rtp_get_cname,\n\t.set_remote_ssrc = ast_rtp_set_remote_ssrc,\n\t.set_stream_num = ast_rtp_set_stream_num,\n\t.extension_enable = ast_rtp_extension_enable,\n\t.bundle = ast_rtp_bundle,\n#ifdef TEST_FRAMEWORK\n\t.test = &ast_rtp_test,\n#endif\n};\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n/*! \\pre instance is locked */\nstatic void dtls_perform_handshake(struct ast_rtp_instance *instance, struct dtls_details *dtls, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tast_debug_dtls(3, \"(%p) DTLS perform handshake - ssl = %p, setup = %d\\n\",\n\t\trtp, dtls->ssl, dtls->dtls_setup);\n\n\t/* If we are not acting as a client connecting to the remote side then\n\t * don't start the handshake as it will accomplish nothing and would conflict\n\t * with the handshake we receive from the remote side.\n\t */\n\tif (!dtls->ssl || (dtls->dtls_setup != AST_RTP_DTLS_SETUP_ACTIVE)) {\n\t\treturn;\n\t}\n\n\tSSL_do_handshake(dtls->ssl);\n\n\t/*\n\t * A race condition is prevented between this function and __rtp_recvfrom()\n\t * because both functions have to get the instance lock before they can do\n\t * anything.  Without holding the instance lock, this function could start\n\t * the SSL handshake above in one thread and the __rtp_recvfrom() function\n\t * called by the channel thread could read the response and stop the timeout\n\t * timer before we have a chance to even start it.\n\t */\n\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\nstatic void dtls_perform_setup(struct dtls_details *dtls)\n{\n\tif (!dtls->ssl || !SSL_is_init_finished(dtls->ssl)) {\n\t\treturn;\n\t}\n\n\tSSL_clear(dtls->ssl);\n\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_PASSIVE) {\n\t\tSSL_set_accept_state(dtls->ssl);\n\t} else {\n\t\tSSL_set_connect_state(dtls->ssl);\n\t}\n\tdtls->connection = AST_RTP_DTLS_CONNECTION_NEW;\n\n\tast_debug_dtls(3, \"DTLS perform setup - connection reset\\n\");\n}\n#endif\n\n#ifdef HAVE_PJPROJECT\nstatic void rtp_learning_start(struct ast_rtp *rtp);\n\n/* Handles start of media during ICE negotiation or completion */\nstatic void ast_rtp_ice_start_media(pj_ice_sess *ice, pj_status_t status)\n{\n\tstruct ast_rtp_instance *instance = ice->user_data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\tif (status == PJ_SUCCESS) {\n\t\tstruct ast_sockaddr remote_address;\n\n\t\tast_sockaddr_setnull(&remote_address);\n\t\tupdate_address_with_ice_candidate(ice, AST_RTP_ICE_COMPONENT_RTP, &remote_address);\n\t\tif (!ast_sockaddr_isnull(&remote_address)) {\n\t\t\t/* Symmetric RTP must be disabled for the remote address to not get overwritten */\n\t\t\tast_rtp_instance_set_prop(instance, AST_RTP_PROPERTY_NAT, 0);\n\n\t\t\tast_rtp_instance_set_remote_address(instance, &remote_address);\n\t\t}\n\n\t\tif (rtp->rtcp) {\n\t\t\tupdate_address_with_ice_candidate(ice, AST_RTP_ICE_COMPONENT_RTCP, &rtp->rtcp->them);\n\t\t}\n\t}\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If we've already started media, no need to do all of this again */\n\tif (rtp->ice_media_started) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tast_debug_category(2, AST_DEBUG_CATEGORY_ICE | AST_DEBUG_CATEGORY_DTLS,\n\t\t\"(%p) ICE starting media - perform DTLS - (%p)\\n\", instance, rtp);\n\n\t/*\n\t * Seemingly no reason to call dtls_perform_setup here. Currently we'll do a full\n\t * protocol level renegotiation if things do change. And if bundled is being used\n\t * then ICE is reused when a stream is added.\n\t *\n\t * Note, if for some reason in the future dtls_perform_setup does need to done here\n\t * be aware that creates a race condition between the call here (on ice completion)\n\t * and potential DTLS handshaking when receiving RTP. What happens is the ssl object\n\t * can get cleared (SSL_clear) during that handshaking process (DTLS init). If that\n\t * happens then Asterisk won't complete DTLS initialization. RTP packets are still\n\t * sent/received but won't be encrypted/decrypted.\n\t */\n\tdtls_perform_handshake(instance, &rtp->dtls, 0);\n\n\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\tdtls_perform_handshake(instance, &rtp->rtcp->dtls, 1);\n\t}\n#endif\n\n\trtp->ice_media_started = 1;\n\n\tif (!strictrtp) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tast_verb(4, \"%p -- Strict RTP learning after ICE completion\\n\", rtp);\n\trtp_learning_start(rtp);\n\tao2_unlock(instance);\n}\n\n#ifdef HAVE_PJPROJECT_ON_VALID_ICE_PAIR_CALLBACK\n/* PJPROJECT ICE optional callback */\nstatic void ast_rtp_on_valid_pair(pj_ice_sess *ice)\n{\n\tast_debug_ice(2, \"(%p) ICE valid pair, start media\\n\", ice->user_data);\n\tast_rtp_ice_start_media(ice, PJ_SUCCESS);\n}\n#endif\n\n/* PJPROJECT ICE callback */\nstatic void ast_rtp_on_ice_complete(pj_ice_sess *ice, pj_status_t status)\n{\n\tast_debug_ice(2, \"(%p) ICE complete, start media\\n\", ice->user_data);\n\tast_rtp_ice_start_media(ice, status);\n}\n\n/* PJPROJECT ICE callback */\nstatic void ast_rtp_on_ice_rx_data(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, void *pkt, pj_size_t size, const pj_sockaddr_t *src_addr, unsigned src_addr_len)\n{\n\tstruct ast_rtp_instance *instance = ice->user_data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* Instead of handling the packet here (which really doesn't work with our architecture) we set a bit to indicate that it should be handled after pj_ice_sess_on_rx_pkt\n\t * returns */\n\tif (transport_id == TRANSPORT_SOCKET_RTP || transport_id == TRANSPORT_SOCKET_RTCP) {\n\t\trtp->passthrough = 1;\n\t} else if (transport_id == TRANSPORT_TURN_RTP) {\n\t\trtp->rtp_passthrough = 1;\n\t} else if (transport_id == TRANSPORT_TURN_RTCP) {\n\t\trtp->rtcp_passthrough = 1;\n\t}\n}\n\n/* PJPROJECT ICE callback */\nstatic pj_status_t ast_rtp_on_ice_tx_pkt(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, const void *pkt, pj_size_t size, const pj_sockaddr_t *dst_addr, unsigned dst_addr_len)\n{\n\tstruct ast_rtp_instance *instance = ice->user_data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tpj_status_t status = PJ_EINVALIDOP;\n\tpj_ssize_t _size = (pj_ssize_t)size;\n\n\tif (transport_id == TRANSPORT_SOCKET_RTP) {\n\t\t/* Traffic is destined to go right out the RTP socket we already have */\n\t\tstatus = pj_sock_sendto(rtp->s, pkt, &_size, 0, dst_addr, dst_addr_len);\n\t\t/* sendto on a connectionless socket should send all the data, or none at all */\n\t\tast_assert(_size == size || status != PJ_SUCCESS);\n\t} else if (transport_id == TRANSPORT_SOCKET_RTCP) {\n\t\t/* Traffic is destined to go right out the RTCP socket we already have */\n\t\tif (rtp->rtcp) {\n\t\t\tstatus = pj_sock_sendto(rtp->rtcp->s, pkt, &_size, 0, dst_addr, dst_addr_len);\n\t\t\t/* sendto on a connectionless socket should send all the data, or none at all */\n\t\t\tast_assert(_size == size || status != PJ_SUCCESS);\n\t\t} else {\n\t\t\tstatus = PJ_SUCCESS;\n\t\t}\n\t} else if (transport_id == TRANSPORT_TURN_RTP) {\n\t\t/* Traffic is going through the RTP TURN relay */\n\t\tif (rtp->turn_rtp) {\n\t\t\tstatus = pj_turn_sock_sendto(rtp->turn_rtp, pkt, size, dst_addr, dst_addr_len);\n\t\t}\n\t} else if (transport_id == TRANSPORT_TURN_RTCP) {\n\t\t/* Traffic is going through the RTCP TURN relay */\n\t\tif (rtp->turn_rtcp) {\n\t\t\tstatus = pj_turn_sock_sendto(rtp->turn_rtcp, pkt, size, dst_addr, dst_addr_len);\n\t\t}\n\t}\n\n\treturn status;\n}\n\n/* ICE Session interface declaration */\nstatic pj_ice_sess_cb ast_rtp_ice_sess_cb = {\n#ifdef HAVE_PJPROJECT_ON_VALID_ICE_PAIR_CALLBACK\n\t.on_valid_pair = ast_rtp_on_valid_pair,\n#endif\n\t.on_ice_complete = ast_rtp_on_ice_complete,\n\t.on_rx_data = ast_rtp_on_ice_rx_data,\n\t.on_tx_pkt = ast_rtp_on_ice_tx_pkt,\n};\n\n/*! \\brief Worker thread for timerheap */\nstatic int timer_worker_thread(void *data)\n{\n\tpj_ioqueue_t *ioqueue;\n\n\tif (pj_ioqueue_create(pool, 1, &ioqueue) != PJ_SUCCESS) {\n\t\treturn -1;\n\t}\n\n\twhile (!timer_terminate) {\n\t\tconst pj_time_val delay = {0, 10};\n\n\t\tpj_timer_heap_poll(timer_heap, NULL);\n\t\tpj_ioqueue_poll(ioqueue, &delay);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic inline int rtp_debug_test_addr(struct ast_sockaddr *addr)\n{\n\tif (!ast_debug_rtp_packet_is_allowed) {\n\t\treturn 0;\n\t}\n\tif (!ast_sockaddr_isnull(&rtpdebugaddr)) {\n\t\tif (rtpdebugport) {\n\t\t\treturn (ast_sockaddr_cmp(&rtpdebugaddr, addr) == 0); /* look for RTP packets from IP+Port */\n\t\t} else {\n\t\t\treturn (ast_sockaddr_cmp_addr(&rtpdebugaddr, addr) == 0); /* only look for RTP packets from IP */\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic inline int rtcp_debug_test_addr(struct ast_sockaddr *addr)\n{\n\tif (!ast_debug_rtcp_packet_is_allowed) {\n\t\treturn 0;\n\t}\n\tif (!ast_sockaddr_isnull(&rtcpdebugaddr)) {\n\t\tif (rtcpdebugport) {\n\t\t\treturn (ast_sockaddr_cmp(&rtcpdebugaddr, addr) == 0); /* look for RTCP packets from IP+Port */\n\t\t} else {\n\t\t\treturn (ast_sockaddr_cmp_addr(&rtcpdebugaddr, addr) == 0); /* only look for RTCP packets from IP */\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n/*! \\pre instance is locked */\nstatic int dtls_srtp_handle_timeout(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\tstruct timeval dtls_timeout;\n\n\tast_debug_dtls(3, \"(%p) DTLS srtp - handle timeout - rtcp=%d\\n\", instance, rtcp);\n\tDTLSv1_handle_timeout(dtls->ssl);\n\n\t/* If a timeout can't be retrieved then this recurring scheduled item must stop */\n\tif (!DTLSv1_get_timeout(dtls->ssl, &dtls_timeout)) {\n\t\tdtls->timeout_timer = -1;\n\t\treturn 0;\n\t}\n\n\treturn dtls_timeout.tv_sec * 1000 + dtls_timeout.tv_usec / 1000;\n}\n\n/* Scheduler callback */\nstatic int dtls_srtp_handle_rtp_timeout(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;\n\tint reschedule;\n\n\tao2_lock(instance);\n\treschedule = dtls_srtp_handle_timeout(instance, 0);\n\tao2_unlock(instance);\n\tif (!reschedule) {\n\t\tao2_ref(instance, -1);\n\t}\n\n\treturn reschedule;\n}\n\n/* Scheduler callback */\nstatic int dtls_srtp_handle_rtcp_timeout(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;\n\tint reschedule;\n\n\tao2_lock(instance);\n\treschedule = dtls_srtp_handle_timeout(instance, 1);\n\tao2_unlock(instance);\n\tif (!reschedule) {\n\t\tao2_ref(instance, -1);\n\t}\n\n\treturn reschedule;\n}\n\nstatic void dtls_srtp_start_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp)\n{\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\tstruct timeval dtls_timeout;\n\n\tif (DTLSv1_get_timeout(dtls->ssl, &dtls_timeout)) {\n\t\tint timeout = dtls_timeout.tv_sec * 1000 + dtls_timeout.tv_usec / 1000;\n\n\t\tast_assert(dtls->timeout_timer == -1);\n\n\t\tao2_ref(instance, +1);\n\t\tif ((dtls->timeout_timer = ast_sched_add(rtp->sched, timeout,\n\t\t\t!rtcp ? dtls_srtp_handle_rtp_timeout : dtls_srtp_handle_rtcp_timeout, instance)) < 0) {\n\t\t\tao2_ref(instance, -1);\n\t\t\tast_log(LOG_WARNING, \"Scheduling '%s' DTLS retransmission for RTP instance [%p] failed.\\n\",\n\t\t\t\t!rtcp ? \"RTP\" : \"RTCP\", instance);\n\t\t} else {\n\t\t\tast_debug_dtls(3, \"(%p) DTLS srtp - scheduled timeout timer for '%d'\\n\", instance, timeout);\n\t\t}\n\t}\n}\n\n/*! \\pre Must not be called with the instance locked. */\nstatic void dtls_srtp_stop_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp)\n{\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\n\tAST_SCHED_DEL_UNREF(rtp->sched, dtls->timeout_timer, ao2_ref(instance, -1));\n\tast_debug_dtls(3, \"(%p) DTLS srtp - stopped timeout timer'\\n\", instance);\n}\n\n/* Scheduler callback */\nstatic int dtls_srtp_renegotiate(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\n\tast_debug_dtls(3, \"(%p) DTLS srtp - renegotiate'\\n\", instance);\n\tSSL_renegotiate(rtp->dtls.ssl);\n\tSSL_do_handshake(rtp->dtls.ssl);\n\n\tif (rtp->rtcp && rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {\n\t\tSSL_renegotiate(rtp->rtcp->dtls.ssl);\n\t\tSSL_do_handshake(rtp->rtcp->dtls.ssl);\n\t}\n\n\trtp->rekeyid = -1;\n\n\tao2_unlock(instance);\n\tao2_ref(instance, -1);\n\n\treturn 0;\n}\n\nstatic int dtls_srtp_add_local_ssrc(struct ast_rtp *rtp, struct ast_rtp_instance *instance, int rtcp, unsigned int ssrc, int set_remote_policy)\n{\n\tunsigned char material[SRTP_MASTER_LEN * 2];\n\tunsigned char *local_key, *local_salt, *remote_key, *remote_salt;\n\tstruct ast_srtp_policy *local_policy, *remote_policy = NULL;\n\tint res = -1;\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\n\tast_debug_dtls(3, \"(%p) DTLS srtp - add local ssrc - rtcp=%d, set_remote_policy=%d'\\n\",\n\t\t\t\t   instance, rtcp, set_remote_policy);\n\n\t/* Produce key information and set up SRTP */\n\tif (!SSL_export_keying_material(dtls->ssl, material, SRTP_MASTER_LEN * 2, \"EXTRACTOR-dtls_srtp\", 19, NULL, 0, 0)) {\n\t\tast_log(LOG_WARNING, \"Unable to extract SRTP keying material from DTLS-SRTP negotiation on RTP instance '%p'\\n\",\n\t\t\tinstance);\n\t\treturn -1;\n\t}\n\n\t/* Whether we are acting as a server or client determines where the keys/salts are */\n\tif (rtp->dtls.dtls_setup == AST_RTP_DTLS_SETUP_ACTIVE) {\n\t\tlocal_key = material;\n\t\tremote_key = local_key + SRTP_MASTER_KEY_LEN;\n\t\tlocal_salt = remote_key + SRTP_MASTER_KEY_LEN;\n\t\tremote_salt = local_salt + SRTP_MASTER_SALT_LEN;\n\t} else {\n\t\tremote_key = material;\n\t\tlocal_key = remote_key + SRTP_MASTER_KEY_LEN;\n\t\tremote_salt = local_key + SRTP_MASTER_KEY_LEN;\n\t\tlocal_salt = remote_salt + SRTP_MASTER_SALT_LEN;\n\t}\n\n\tif (!(local_policy = res_srtp_policy->alloc())) {\n\t\treturn -1;\n\t}\n\n\tif (res_srtp_policy->set_master_key(local_policy, local_key, SRTP_MASTER_KEY_LEN, local_salt, SRTP_MASTER_SALT_LEN) < 0) {\n\t\tast_log(LOG_WARNING, \"Could not set key/salt information on local policy of '%p' when setting up DTLS-SRTP\\n\", rtp);\n\t\tgoto error;\n\t}\n\n\tif (res_srtp_policy->set_suite(local_policy, rtp->suite)) {\n\t\tast_log(LOG_WARNING, \"Could not set suite to '%u' on local policy of '%p' when setting up DTLS-SRTP\\n\", rtp->suite, rtp);\n\t\tgoto error;\n\t}\n\n\tres_srtp_policy->set_ssrc(local_policy, ssrc, 0);\n\n\tif (set_remote_policy) {\n\t\tif (!(remote_policy = res_srtp_policy->alloc())) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (res_srtp_policy->set_master_key(remote_policy, remote_key, SRTP_MASTER_KEY_LEN, remote_salt, SRTP_MASTER_SALT_LEN) < 0) {\n\t\t\tast_log(LOG_WARNING, \"Could not set key/salt information on remote policy of '%p' when setting up DTLS-SRTP\\n\", rtp);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (res_srtp_policy->set_suite(remote_policy, rtp->suite)) {\n\t\t\tast_log(LOG_WARNING, \"Could not set suite to '%u' on remote policy of '%p' when setting up DTLS-SRTP\\n\", rtp->suite, rtp);\n\t\t\tgoto error;\n\t\t}\n\n\t\tres_srtp_policy->set_ssrc(remote_policy, 0, 1);\n\t}\n\n\tif (ast_rtp_instance_add_srtp_policy(instance, remote_policy, local_policy, rtcp)) {\n\t\tast_log(LOG_WARNING, \"Could not set policies when setting up DTLS-SRTP on '%p'\\n\", rtp);\n\t\tgoto error;\n\t}\n\n\tres = 0;\n\nerror:\n\t/* policy->destroy() called even on success to release local reference to these resources */\n\tres_srtp_policy->destroy(local_policy);\n\n\tif (remote_policy) {\n\t\tres_srtp_policy->destroy(remote_policy);\n\t}\n\n\treturn res;\n}\n\nstatic int dtls_srtp_setup(struct ast_rtp *rtp, struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\tint index;\n\n\tast_debug_dtls(3, \"(%p) DTLS setup SRTP rtp=%p'\\n\", instance, rtp);\n\n\t/* If a fingerprint is present in the SDP make sure that the peer certificate matches it */\n\tif (rtp->dtls_verify & AST_RTP_DTLS_VERIFY_FINGERPRINT) {\n\t\tX509 *certificate;\n\n\t\tif (!(certificate = SSL_get_peer_certificate(dtls->ssl))) {\n\t\t\tast_log(LOG_WARNING, \"No certificate was provided by the peer on RTP instance '%p'\\n\", instance);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If a fingerprint is present in the SDP make sure that the peer certificate matches it */\n\t\tif (rtp->remote_fingerprint[0]) {\n\t\t\tconst EVP_MD *type;\n\t\t\tunsigned char fingerprint[EVP_MAX_MD_SIZE];\n\t\t\tunsigned int size;\n\n\t\t\tif (rtp->remote_hash == AST_RTP_DTLS_HASH_SHA1) {\n\t\t\t\ttype = EVP_sha1();\n\t\t\t} else if (rtp->remote_hash == AST_RTP_DTLS_HASH_SHA256) {\n\t\t\t\ttype = EVP_sha256();\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Unsupported fingerprint hash type on RTP instance '%p'\\n\", instance);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!X509_digest(certificate, type, fingerprint, &size) ||\n\t\t\t    !size ||\n\t\t\t    memcmp(fingerprint, rtp->remote_fingerprint, size)) {\n\t\t\t\tX509_free(certificate);\n\t\t\t\tast_log(LOG_WARNING, \"Fingerprint provided by remote party does not match that of peer certificate on RTP instance '%p'\\n\",\n\t\t\t\t\tinstance);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tX509_free(certificate);\n\t}\n\n\tif (dtls_srtp_add_local_ssrc(rtp, instance, rtcp, ast_rtp_instance_get_ssrc(instance), 1)) {\n\t\tast_log(LOG_ERROR, \"Failed to add local source '%p'\\n\", rtp);\n\t\treturn -1;\n\t}\n\n\tfor (index = 0; index < AST_VECTOR_SIZE(&rtp->ssrc_mapping); ++index) {\n\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&rtp->ssrc_mapping, index);\n\n\t\tif (dtls_srtp_add_local_ssrc(rtp, instance, rtcp, ast_rtp_instance_get_ssrc(mapping->instance), 0)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (rtp->rekey) {\n\t\tao2_ref(instance, +1);\n\t\tif ((rtp->rekeyid = ast_sched_add(rtp->sched, rtp->rekey * 1000, dtls_srtp_renegotiate, instance)) < 0) {\n\t\t\tao2_ref(instance, -1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n/*! \\brief Helper function to compare an elem in a vector by value */\nstatic int compare_by_value(int elem, int value)\n{\n\treturn elem - value;\n}\n\n/*! \\brief Helper function to find an elem in a vector by value */\nstatic int find_by_value(int elem, int value)\n{\n\treturn elem == value;\n}\n\nstatic int rtcp_mux(struct ast_rtp *rtp, const unsigned char *packet)\n{\n\tuint8_t version;\n\tuint8_t pt;\n\tuint8_t m;\n\n\tif (!rtp->rtcp || rtp->rtcp->type != AST_RTP_INSTANCE_RTCP_MUX) {\n\t\treturn 0;\n\t}\n\n\tversion = (packet[0] & 0XC0) >> 6;\n\tif (version == 0) {\n\t\t/* version 0 indicates this is a STUN packet and shouldn't\n\t\t * be interpreted as a possible RTCP packet\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* The second octet of a packet will be one of the following:\n\t * For RTP: The marker bit (1 bit) and the RTP payload type (7 bits)\n\t * For RTCP: The payload type (8)\n\t *\n\t * RTP has a forbidden range of payload types (64-95) since these\n\t * will conflict with RTCP payload numbers if the marker bit is set.\n\t */\n\tm = packet[1] & 0x80;\n\tpt = packet[1] & 0x7F;\n\tif (m && pt >= 64 && pt <= 95) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n{\n\tint len;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tchar *in = buf;\n#endif\n#ifdef HAVE_PJPROJECT\n\tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n#endif\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n\t\treturn len;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->packets_to_drop > 0) {\n\t\ttest->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n\t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n\tif ((*in >= 20) && (*in <= 63)) {\n\t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\t\tint res = 0;\n\n\t\t/* If no SSL session actually exists terminate things */\n\t\tif (!dtls->ssl) {\n\t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n\n\t\t/*\n\t\t * If ICE is in use, we can prevent a possible DOS attack\n\t\t * by allowing DTLS protocol messages (client hello, etc)\n\t\t * only from sources that are in the active remote\n\t\t * candidates list.\n\t\t */\n\n\t\tif (rtp->ice) {\n\t\t\tint pass_src_check = 0;\n\t\t\tstruct ao2_iterator i;\n\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n\t\t\tint cand_cnt = 0;\n\n\t\t\t/*\n\t\t\t * You'd think that this check would cause a \"deadlock\"\n\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n\t\t\t * before it sets ice_media_started = 1 so how can we do a\n\t\t\t * handshake if we're dropping packets before we send them\n\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets\n\t\t\t * up openssl to do the handshake and doesn't actually perform it\n\t\t\t * itself and the locking prevents __rtp_recvfrom from\n\t\t\t * running before the ice_media_started flag is set.  So only\n\t\t\t * unexpected DTLS packets can get dropped here.\n\t\t\t */\n\t\t\tif (!rtp->ice_media_started) {\n\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\t\t\tast_sockaddr_stringify(sa));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we got this far, then ice_active_remote_candidates\n\t\t\t * can't be NULL.\n\t\t\t */\n\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);\n\t\t\t\tao2_ref(candidate, -1);\n\t\t\t\tif (res == 0) {\n\t\t\t\t\tpass_src_check = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcand_cnt++;\n\t\t\t}\n\t\t\tao2_iterator_destroy(&i);\n\n\t\t\tif (!pass_src_check) {\n\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\t\t\tast_sockaddr_stringify(sa));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * A race condition is prevented between dtls_perform_handshake()\n\t\t * and this function because both functions have to get the\n\t\t * instance lock before they can do anything.  The\n\t\t * dtls_perform_handshake() function needs to start the timer\n\t\t * before we stop it below.\n\t\t */\n\n\t\t/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, rtcp);\n\t\tao2_lock(instance);\n\n\t\t/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */\n\t\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\tdtls->dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t\tSSL_set_accept_state(dtls->ssl);\n\t\t}\n\n\t\tBIO_write(dtls->read_bio, buf, len);\n\n\t\tlen = SSL_read(dtls->ssl, buf, len);\n\n\t\tif ((len < 0) && (SSL_get_error(dtls->ssl, len) == SSL_ERROR_SSL)) {\n\t\t\tunsigned long error = ERR_get_error();\n\t\t\tast_log(LOG_ERROR, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tinstance, ERR_reason_error_string(error));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\t\t/* Any further connections will be existing since this is now established */\n\t\t\tdtls->connection = AST_RTP_DTLS_CONNECTION_EXISTING;\n\t\t\t/* Use the keying material to set up key/salt information */\n\t\t\tif ((res = dtls_srtp_setup(rtp, instance, rtcp))) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t/* Notify that dtls has been established */\n\t\t\tres = RTP_DTLS_ESTABLISHED;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", instance, rtp);\n\t\t} else {\n\t\t\t/* Since we've sent additional traffic start the timeout timer for retransmission */\n\t\t\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n\t\t}\n\n\t\treturn res;\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\tif (!ast_sockaddr_isnull(loop) && !ast_sockaddr_cmp(loop, sa)) {\n\t\t/* ICE traffic will have been handled in the TURN callback, so skip it but update the address\n\t\t * so it reflects the actual source and not the loopback\n\t\t */\n\t\tif (rtcp) {\n\t\t\tast_sockaddr_copy(sa, &rtp->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(instance, sa);\n\t\t}\n\t} else if (rtp->ice) {\n\t\tpj_str_t combined = pj_str(ast_sockaddr_stringify(sa));\n\t\tpj_sockaddr address;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice,\n\t\t\trtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,\n\t\t\trtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,\n\t\t\tpj_sockaddr_get_len(&address));\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar err_buf[100];\n\n\t\t\tpj_strerror(status, err_buf, sizeof(err_buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, err_buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!rtp->passthrough) {\n\t\t\t/* If a unidirectional ICE negotiation occurs then lock on to the source of the\n\t\t\t * ICE traffic and use it as the target. This will occur if the remote side only\n\t\t\t * wants to receive media but never send to us.\n\t\t\t */\n\t\t\tif (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {\n\t\t\t\tif (rtcp) {\n\t\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, sa);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(instance, sa);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\trtp->passthrough = 0;\n\t}\n#endif\n\n\treturn len;\n}\n\n/*! \\pre instance is locked */\nstatic int rtcp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa)\n{\n\treturn __rtp_recvfrom(instance, buf, size, flags, sa, 1);\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa)\n{\n\treturn __rtp_recvfrom(instance, buf, size, flags, sa, 0);\n}\n\n/*! \\pre instance is locked */\nstatic int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *via_ice, int use_srtp)\n{\n\tint len = size;\n\tvoid *temp = buf;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_instance *transport = rtp->bundled ? rtp->bundled : instance;\n\tstruct ast_rtp *transport_rtp = ast_rtp_instance_get_data(transport);\n\tstruct ast_srtp *srtp = ast_rtp_instance_get_srtp(transport, rtcp);\n\tint res;\n\n\t*via_ice = 0;\n\n\tif (use_srtp && res_srtp && srtp && res_srtp->protect(srtp, &temp, &len, rtcp) < 0) {\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_PJPROJECT\n\tif (transport_rtp->ice) {\n\t\tenum ast_rtp_ice_component_type component = rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\t/* If RTCP is sharing the same socket then use the same component */\n\t\tif (rtcp && rtp->rtcp->s == rtp->s) {\n\t\t\tcomponent = AST_RTP_ICE_COMPONENT_RTP;\n\t\t}\n\n\t\tpj_thread_register_check();\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = transport_rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tif (instance == transport) {\n\t\t\tao2_unlock(instance);\n\t\t}\n\t\tstatus = pj_ice_sess_send_data(ice->real_ice, component, temp, len);\n\t\tao2_ref(ice, -1);\n\t\tif (instance == transport) {\n\t\t\tao2_lock(instance);\n\t\t}\n\t\tif (status == PJ_SUCCESS) {\n\t\t\t*via_ice = 1;\n\t\t\treturn len;\n\t\t}\n\t}\n#endif\n\n\tres = ast_sendto(rtcp ? transport_rtp->rtcp->s : transport_rtp->s, temp, len, flags, sa);\n\tif (res > 0) {\n\t\tast_rtp_instance_set_last_tx(instance, time(NULL));\n\t}\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic int rtcp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int *ice)\n{\n\treturn __rtp_sendto(instance, buf, size, flags, sa, 1, ice, 1);\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int *ice)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint hdrlen = 12;\n\tint res;\n\n\tif ((res = __rtp_sendto(instance, buf, size, flags, sa, 0, ice, 1)) > 0) {\n\t\trtp->txcount++;\n\t\trtp->txoctetcount += (res - hdrlen);\n\t}\n\n\treturn res;\n}\n\nstatic unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp)\n{\n\tunsigned int interval;\n\t/*! \\todo XXX Do a more reasonable calculation on this one\n\t * Look in RFC 3550 Section A.7 for an example*/\n\tinterval = rtcpinterval;\n\treturn interval;\n}\n\nstatic void calc_mean_and_standard_deviation(double new_sample, double *mean, double *std_dev, unsigned int *count)\n{\n\tdouble delta1;\n\tdouble delta2;\n\n\t/* First convert the standard deviation back into a sum of squares. */\n\tdouble last_sum_of_squares = (*std_dev) * (*std_dev) * (*count ?: 1);\n\n\tif (++(*count) == 0) {\n\t\t/* Avoid potential divide by zero on an overflow */\n\t\t*count = 1;\n\t}\n\n\t/*\n\t * Below is an implementation of Welford's online algorithm [1] for calculating\n\t * mean and variance in a single pass.\n\t *\n\t * [1] https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n\t */\n\n\tdelta1 = new_sample - *mean;\n\t*mean += (delta1 / *count);\n\tdelta2 = new_sample - *mean;\n\n\t/* Now calculate the new variance, and subsequent standard deviation */\n\t*std_dev = sqrt((last_sum_of_squares + (delta1 * delta2)) / *count);\n}\n\nstatic int create_new_socket(const char *type, int af)\n{\n\tint sock = ast_socket_nonblock(af, SOCK_DGRAM, 0);\n\n\tif (sock < 0) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate %s socket: %s\\n\", type, strerror(errno));\n\t\treturn sock;\n\t}\n\n#ifdef SO_NO_CHECK\n\tif (nochecksums) {\n\t\tsetsockopt(sock, SOL_SOCKET, SO_NO_CHECK, &nochecksums, sizeof(nochecksums));\n\t}\n#endif\n\n\treturn sock;\n}\n\n/*!\n * \\internal\n * \\brief Initializes sequence values and probation for learning mode.\n * \\note This is an adaptation of pjmedia's pjmedia_rtp_seq_init function.\n *\n * \\param info The learning information to track\n * \\param seq sequence number read from the rtp header to initialize the information with\n */\nstatic void rtp_learning_seq_init(struct rtp_learning_info *info, uint16_t seq)\n{\n\tinfo->max_seq = seq;\n\tinfo->packets = learning_min_sequential;\n\tmemset(&info->received, 0, sizeof(info->received));\n}\n\n/*!\n * \\internal\n * \\brief Updates sequence information for learning mode and determines if probation/learning mode should remain in effect.\n * \\note This function was adapted from pjmedia's pjmedia_rtp_seq_update function.\n *\n * \\param info Structure tracking the learning progress of some address\n * \\param seq sequence number read from the rtp header\n * \\retval 0 if probation mode should exit for this address\n * \\retval non-zero if probation mode should continue\n */\nstatic int rtp_learning_rtp_seq_update(struct rtp_learning_info *info, uint16_t seq)\n{\n\tif (seq == (uint16_t) (info->max_seq + 1)) {\n\t\t/* packet is in sequence */\n\t\tinfo->packets--;\n\t} else {\n\t\t/* Sequence discontinuity; reset */\n\t\tinfo->packets = learning_min_sequential - 1;\n\t\tinfo->received = ast_tvnow();\n\t}\n\n\t/* Only check time if strictrtp is set to yes. Otherwise, we only needed to check seqno */\n\tif (strictrtp == STRICT_RTP_YES) {\n\t\tswitch (info->stream_type) {\n\t\tcase AST_MEDIA_TYPE_UNKNOWN:\n\t\tcase AST_MEDIA_TYPE_AUDIO:\n\t\t\t/*\n\t\t\t * Protect against packet floods by checking that we\n\t\t\t * received the packet sequence in at least the minimum\n\t\t\t * allowed time.\n\t\t\t */\n\t\t\tif (ast_tvzero(info->received)) {\n\t\t\t\tinfo->received = ast_tvnow();\n\t\t\t} else if (!info->packets\n\t\t\t\t&& ast_tvdiff_ms(ast_tvnow(), info->received) < learning_min_duration) {\n\t\t\t\t/* Packet flood; reset */\n\t\t\t\tinfo->packets = learning_min_sequential - 1;\n\t\t\t\tinfo->received = ast_tvnow();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AST_MEDIA_TYPE_VIDEO:\n\t\tcase AST_MEDIA_TYPE_IMAGE:\n\t\tcase AST_MEDIA_TYPE_TEXT:\n\t\tcase AST_MEDIA_TYPE_END:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinfo->max_seq = seq;\n\n\treturn info->packets;\n}\n\n/*!\n * \\brief Start the strictrtp learning mode.\n *\n * \\param rtp RTP session description\n */\nstatic void rtp_learning_start(struct ast_rtp *rtp)\n{\n\trtp->strict_rtp_state = STRICT_RTP_LEARN;\n\tmemset(&rtp->rtp_source_learn.proposed_address, 0,\n\t\tsizeof(rtp->rtp_source_learn.proposed_address));\n\trtp->rtp_source_learn.start = ast_tvnow();\n\trtp_learning_seq_init(&rtp->rtp_source_learn, (uint16_t) rtp->lastrxseqno);\n}\n\n#ifdef HAVE_PJPROJECT\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message);\n\n/*!\n * \\internal\n * \\brief Resets and ACL to empty state.\n */\nstatic void rtp_unload_acl(ast_rwlock_t *lock, struct ast_acl_list **acl)\n{\n\tast_rwlock_wrlock(lock);\n\t*acl = ast_free_acl_list(*acl);\n\tast_rwlock_unlock(lock);\n}\n\n/*!\n * \\internal\n * \\brief Checks an address against the ICE blacklist\n * \\note If there is no ice_blacklist list, always returns 0\n *\n * \\param address The address to consider\n * \\retval 0 if address is not ICE blacklisted\n * \\retval 1 if address is ICE blacklisted\n */\nstatic int rtp_address_is_ice_blacklisted(const struct ast_sockaddr *address)\n{\n\tint result = 0;\n\n\tast_rwlock_rdlock(&ice_acl_lock);\n\tresult |= ast_apply_acl_nolog(ice_acl, address) == AST_SENSE_DENY;\n\tast_rwlock_unlock(&ice_acl_lock);\n\n\treturn result;\n}\n\n/*!\n * \\internal\n * \\brief Checks an address against the STUN blacklist\n * \\since 13.16.0\n *\n * \\note If there is no stun_blacklist list, always returns 0\n *\n * \\param addr The address to consider\n *\n * \\retval 0 if address is not STUN blacklisted\n * \\retval 1 if address is STUN blacklisted\n */\nstatic int stun_address_is_blacklisted(const struct ast_sockaddr *addr)\n{\n\tint result = 0;\n\n\tast_rwlock_rdlock(&stun_acl_lock);\n\tresult |= ast_apply_acl_nolog(stun_acl, addr) == AST_SENSE_DENY;\n\tast_rwlock_unlock(&stun_acl_lock);\n\n\treturn result;\n}\n\n/*! \\pre instance is locked */\nstatic void rtp_add_candidates_to_ice(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *addr, int port, int component,\n\t\t\t\t      int transport)\n{\n\tunsigned int count = 0;\n\tstruct ifaddrs *ifa, *ia;\n\tstruct ast_sockaddr tmp;\n\tpj_sockaddr pjtmp;\n\tstruct ast_ice_host_candidate *candidate;\n\tint af_inet_ok = 0, af_inet6_ok = 0;\n\tstruct sockaddr_in stunaddr_copy;\n\n\tif (ast_sockaddr_is_ipv4(addr)) {\n\t\taf_inet_ok = 1;\n\t} else if (ast_sockaddr_is_any(addr)) {\n\t\taf_inet_ok = af_inet6_ok = 1;\n\t} else {\n\t\taf_inet6_ok = 1;\n\t}\n\n\tif (getifaddrs(&ifa) < 0) {\n\t\t/* If we can't get addresses, we can't load ICE candidates */\n\t\tast_log(LOG_ERROR, \"(%p) ICE Error obtaining list of local addresses: %s\\n\",\n\t\t\t\tinstance, strerror(errno));\n\t} else {\n\t\tast_debug_ice(2, \"(%p) ICE add system candidates\\n\", instance);\n\t\t/* Iterate through the list of addresses obtained from the system,\n\t\t * until we've iterated through all of them, or accepted\n\t\t * PJ_ICE_MAX_CAND candidates */\n\t\tfor (ia = ifa; ia && count < PJ_ICE_MAX_CAND; ia = ia->ifa_next) {\n\t\t\t/* Interface is either not UP or doesn't have an address assigned,\n\t\t\t * eg, a ppp that just completed LCP but no IPCP yet */\n\t\t\tif (!ia->ifa_addr || (ia->ifa_flags & IFF_UP) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Filter out non-IPvX addresses, eg, link-layer */\n\t\t\tif (ia->ifa_addr->sa_family != AF_INET && ia->ifa_addr->sa_family != AF_INET6) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_sockaddr_from_sockaddr(&tmp, ia->ifa_addr);\n\n\t\t\tif (ia->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tconst struct sockaddr_in *sa_in = (struct sockaddr_in*)ia->ifa_addr;\n\t\t\t\tif (!af_inet_ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Skip 127.0.0.0/8 (loopback) */\n\t\t\t\t/* Don't use IFF_LOOPBACK check since one could assign usable\n\t\t\t\t * publics to the loopback */\n\t\t\t\tif ((sa_in->sin_addr.s_addr & htonl(0xFF000000)) == htonl(0x7F000000)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Skip 0.0.0.0/8 based on RFC1122, and from pjproject */\n\t\t\t\tif ((sa_in->sin_addr.s_addr & htonl(0xFF000000)) == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else { /* ia->ifa_addr->sa_family == AF_INET6 */\n\t\t\t\tif (!af_inet6_ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Filter ::1 */\n\t\t\t\tif (!ast_sockaddr_cmp_addr(&lo6, &tmp)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Pull in the host candidates from [ice_host_candidates] */\n\t\t\tAST_RWLIST_RDLOCK(&host_candidates);\n\t\t\tAST_LIST_TRAVERSE(&host_candidates, candidate, next) {\n\t\t\t\tif (!ast_sockaddr_cmp(&candidate->local, &tmp)) {\n\t\t\t\t\t/* candidate->local matches actual assigned, so check if\n\t\t\t\t\t * advertised is blacklisted, if not, add it to the\n\t\t\t\t\t * advertised list.  Not that it would make sense to remap\n\t\t\t\t\t * a local address to a blacklisted address, but honour it\n\t\t\t\t\t * anyway. */\n\t\t\t\t\tif (!rtp_address_is_ice_blacklisted(&candidate->advertised)) {\n\t\t\t\t\t\tast_sockaddr_to_pj_sockaddr(&candidate->advertised, &pjtmp);\n\t\t\t\t\t\tpj_sockaddr_set_port(&pjtmp, port);\n\t\t\t\t\t\tast_rtp_ice_add_cand(instance, rtp, component, transport,\n\t\t\t\t\t\t\t\tPJ_ICE_CAND_TYPE_HOST, 65535, &pjtmp, &pjtmp, NULL,\n\t\t\t\t\t\t\t\tpj_sockaddr_get_len(&pjtmp));\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!candidate->include_local) {\n\t\t\t\t\t\t/* We don't want to advertise the actual address */\n\t\t\t\t\t\tast_sockaddr_setnull(&tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAST_RWLIST_UNLOCK(&host_candidates);\n\n\t\t\t/* we had an entry in [ice_host_candidates] that matched, and\n\t\t\t * didn't have include_local_address set.  Alternatively, adding\n\t\t\t * that match resulted in us going to PJ_ICE_MAX_CAND */\n\t\t\tif (ast_sockaddr_isnull(&tmp) || count == PJ_ICE_MAX_CAND) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rtp_address_is_ice_blacklisted(&tmp)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_sockaddr_to_pj_sockaddr(&tmp, &pjtmp);\n\t\t\tpj_sockaddr_set_port(&pjtmp, port);\n\t\t\tast_rtp_ice_add_cand(instance, rtp, component, transport,\n\t\t\t\t\tPJ_ICE_CAND_TYPE_HOST, 65535, &pjtmp, &pjtmp, NULL,\n\t\t\t\t\tpj_sockaddr_get_len(&pjtmp));\n\t\t\t++count;\n\t\t}\n\t\tfreeifaddrs(ifa);\n\t}\n\n\tast_rwlock_rdlock(&stunaddr_lock);\n\tmemcpy(&stunaddr_copy, &stunaddr, sizeof(stunaddr));\n\tast_rwlock_unlock(&stunaddr_lock);\n\n\t/* If configured to use a STUN server to get our external mapped address do so */\n\tif (stunaddr_copy.sin_addr.s_addr && !stun_address_is_blacklisted(addr) &&\n\t\t(ast_sockaddr_is_ipv4(addr) || ast_sockaddr_is_any(addr)) &&\n\t\tcount < PJ_ICE_MAX_CAND) {\n\t\tstruct sockaddr_in answer;\n\t\tint rsp;\n\n\t\tast_debug_category(3, AST_DEBUG_CATEGORY_ICE | AST_DEBUG_CATEGORY_STUN,\n\t\t\t\"(%p) ICE request STUN %s %s candidate\\n\", instance,\n\t\t\ttransport == AST_TRANSPORT_UDP ? \"UDP\" : \"TCP\",\n\t\t\tcomponent == AST_RTP_ICE_COMPONENT_RTP ? \"RTP\" : \"RTCP\");\n\n\t\t/*\n\t\t * The instance should not be locked because we can block\n\t\t * waiting for a STUN respone.\n\t\t */\n\t\tao2_unlock(instance);\n\t\trsp = ast_stun_request(component == AST_RTP_ICE_COMPONENT_RTCP\n\t\t\t? rtp->rtcp->s : rtp->s, &stunaddr_copy, NULL, &answer);\n\t\tao2_lock(instance);\n\t\tif (!rsp) {\n\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n\t\t\tpj_sockaddr ext, base;\n\t\t\tpj_str_t mapped = pj_str(ast_strdupa(ast_inet_ntoa(answer.sin_addr)));\n\t\t\tint srflx = 1, baseset = 0;\n\t\t\tstruct ao2_iterator i;\n\n\t\t\tpj_sockaddr_init(pj_AF_INET(), &ext, &mapped, ntohs(answer.sin_port));\n\n\t\t\t/*\n\t\t\t * If the returned address is the same as one of our host\n\t\t\t * candidates, don't send the srflx.  At the same time,\n\t\t\t * we need to set the base address (raddr).\n\t\t\t */\n\t\t\ti = ao2_iterator_init(rtp->ice_local_candidates, 0);\n\t\t\twhile (srflx && (candidate = ao2_iterator_next(&i))) {\n\t\t\t\tif (!baseset && ast_sockaddr_is_ipv4(&candidate->address)) {\n\t\t\t\t\tbaseset = 1;\n\t\t\t\t\tast_sockaddr_to_pj_sockaddr(&candidate->address, &base);\n\t\t\t\t}\n\n\t\t\t\tif (!pj_sockaddr_cmp(&candidate->address, &ext)) {\n\t\t\t\t\tsrflx = 0;\n\t\t\t\t}\n\n\t\t\t\tao2_ref(candidate, -1);\n\t\t\t}\n\t\t\tao2_iterator_destroy(&i);\n\n\t\t\tif (srflx && baseset) {\n\t\t\t\tpj_sockaddr_set_port(&base, port);\n\t\t\t\tast_rtp_ice_add_cand(instance, rtp, component, transport,\n\t\t\t\t\tPJ_ICE_CAND_TYPE_SRFLX, 65535, &ext, &base, &base,\n\t\t\t\t\tpj_sockaddr_get_len(&ext));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If configured to use a TURN relay create a session and allocate */\n\tif (pj_strlen(&turnaddr)) {\n\t\tast_rtp_ice_turn_request(instance, component, AST_TRANSPORT_TCP, pj_strbuf(&turnaddr), turnport,\n\t\t\tpj_strbuf(&turnusername), pj_strbuf(&turnpassword));\n\t}\n}\n#endif\n\n/*!\n * \\internal\n * \\brief Calculates the elapsed time from issue of the first tx packet in an\n *        rtp session and a specified time\n *\n * \\param rtp pointer to the rtp struct with the transmitted rtp packet\n * \\param delivery time of delivery - if NULL or zero value, will be ast_tvnow()\n *\n * \\return time elapsed in milliseconds\n */\nstatic unsigned int calc_txstamp(struct ast_rtp *rtp, struct timeval *delivery)\n{\n\tstruct timeval t;\n\tlong ms;\n\n\tif (ast_tvzero(rtp->txcore)) {\n\t\trtp->txcore = ast_tvnow();\n\t\trtp->txcore.tv_usec -= rtp->txcore.tv_usec % 20000;\n\t}\n\n\tt = (delivery && !ast_tvzero(*delivery)) ? *delivery : ast_tvnow();\n\tif ((ms = ast_tvdiff_ms(t, rtp->txcore)) < 0) {\n\t\tms = 0;\n\t}\n\trtp->txcore = t;\n\n\treturn (unsigned int) ms;\n}\n\n#ifdef HAVE_PJPROJECT\n/*!\n * \\internal\n * \\brief Creates an ICE session. Can be used to replace a destroyed ICE session.\n *\n * \\param instance RTP instance for which the ICE session is being replaced\n * \\param addr ast_sockaddr to use for adding RTP candidates to the ICE session\n * \\param port port to use for adding RTP candidates to the ICE session\n * \\param replace 0 when creating a new session, 1 when replacing a destroyed session\n *\n * \\pre instance is locked\n *\n * \\retval 0 on success\n * \\retval -1 on failure\n */\nstatic int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,\n\tint port, int replace)\n{\n\tpj_stun_config stun_config;\n\tpj_str_t ufrag, passwd;\n\tpj_status_t status;\n\tstruct ice_wrap *ice_old;\n\tstruct ice_wrap *ice;\n\tpj_ice_sess *real_ice = NULL;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_cleanup(rtp->ice_local_candidates);\n\trtp->ice_local_candidates = NULL;\n\n\tast_debug_ice(2, \"(%p) ICE create%s\\n\", instance, replace ? \" and replace\" : \"\");\n\n\tice = ao2_alloc_options(sizeof(*ice), ice_wrap_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!ice) {\n\t\tast_rtp_ice_stop(instance);\n\t\treturn -1;\n\t}\n\n\tpj_thread_register_check();\n\n\tpj_stun_config_init(&stun_config, &cachingpool.factory, 0, NULL, timer_heap);\n\tif (!stun_software_attribute) {\n\t\tstun_config.software_name = pj_str(NULL);\n\t}\n\n\tufrag = pj_str(rtp->local_ufrag);\n\tpasswd = pj_str(rtp->local_passwd);\n\n\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\tao2_unlock(instance);\n\t/* Create an ICE session for ICE negotiation */\n\tstatus = pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN,\n\t\trtp->ice_num_components, &ast_rtp_ice_sess_cb, &ufrag, &passwd, NULL, &real_ice);\n\tao2_lock(instance);\n\tif (status == PJ_SUCCESS) {\n\t\t/* Safely complete linking the ICE session into the instance */\n\t\treal_ice->user_data = instance;\n\t\tice->real_ice = real_ice;\n\t\tice_old = rtp->ice;\n\t\trtp->ice = ice;\n\t\tif (ice_old) {\n\t\t\tao2_unlock(instance);\n\t\t\tao2_ref(ice_old, -1);\n\t\t\tao2_lock(instance);\n\t\t}\n\n\t\t/* Add all of the available candidates to the ICE session */\n\t\trtp_add_candidates_to_ice(instance, rtp, addr, port, AST_RTP_ICE_COMPONENT_RTP,\n\t\t\tTRANSPORT_SOCKET_RTP);\n\n\t\t/* Only add the RTCP candidates to ICE when replacing the session and if\n\t\t * the ICE session contains more than just an RTP component. New sessions\n\t\t * handle this in a separate part of the setup phase */\n\t\tif (replace && rtp->rtcp && rtp->ice_num_components > 1) {\n\t\t\trtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us,\n\t\t\t\tast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP,\n\t\t\t\tTRANSPORT_SOCKET_RTCP);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * It is safe to unref this while instance is locked here.\n\t * It was not initialized with a real_ice pointer.\n\t */\n\tao2_ref(ice, -1);\n\n\tast_rtp_ice_stop(instance);\n\treturn -1;\n\n}\n#endif\n\nstatic int rtp_allocate_transport(struct ast_rtp_instance *instance, struct ast_rtp *rtp)\n{\n\tint x, startplace, i, maxloops;\n\n\trtp->strict_rtp_state = (strictrtp ? STRICT_RTP_CLOSED : STRICT_RTP_OPEN);\n\n\t/* Create a new socket for us to listen on and use */\n\tif ((rtp->s =\n\t     create_new_socket(\"RTP\",\n\t\t\t       ast_sockaddr_is_ipv4(&rtp->bind_address) ? AF_INET  :\n\t\t\t       ast_sockaddr_is_ipv6(&rtp->bind_address) ? AF_INET6 : -1)) < 0) {\n\t\tast_log(LOG_WARNING, \"Failed to create a new socket for RTP instance '%p'\\n\", instance);\n\t\treturn -1;\n\t}\n\n\t/* Now actually find a free RTP port to use */\n\tx = (ast_random() % (rtpend - rtpstart)) + rtpstart;\n\tx = x & ~1;\n\tstartplace = x;\n\n\t/* Protection against infinite loops in the case there is a potential case where the loop is not broken such as an odd\n\t   start port sneaking in (even though this condition is checked at load.) */\n\tmaxloops = rtpend - rtpstart;\n\tfor (i = 0; i <= maxloops; i++) {\n\t\tast_sockaddr_set_port(&rtp->bind_address, x);\n\t\t/* Try to bind, this will tell us whether the port is available or not */\n\t\tif (!ast_bind(rtp->s, &rtp->bind_address)) {\n\t\t\tast_debug_rtp(1, \"(%p) RTP allocated port %d\\n\", instance, x);\n\t\t\tast_rtp_instance_set_local_address(instance, &rtp->bind_address);\n\t\t\tast_test_suite_event_notify(\"RTP_PORT_ALLOCATED\", \"Port: %d\", x);\n\t\t\tbreak;\n\t\t}\n\n\t\tx += 2;\n\t\tif (x > rtpend) {\n\t\t\tx = (rtpstart + 1) & ~1;\n\t\t}\n\n\t\t/* See if we ran out of ports or if the bind actually failed because of something other than the address being in use */\n\t\tif (x == startplace || (errno != EADDRINUSE && errno != EACCES)) {\n\t\t\tast_log(LOG_ERROR, \"Oh dear... we couldn't allocate a port for RTP instance '%p'\\n\", instance);\n\t\t\tclose(rtp->s);\n\t\t\trtp->s = -1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n#ifdef HAVE_PJPROJECT\n\t/* Initialize synchronization aspects */\n\tast_cond_init(&rtp->cond, NULL);\n\n\tgenerate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));\n\tgenerate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));\n\n\t/* Create an ICE session for ICE negotiation */\n\tif (icesupport) {\n\t\trtp->ice_num_components = 2;\n\t\tast_debug_ice(2, \"(%p) ICE creating session %s (%d)\\n\", instance,\n\t\t\tast_sockaddr_stringify(&rtp->bind_address), x);\n\t\tif (ice_create(instance, &rtp->bind_address, x, 0)) {\n\t\t\tast_log(LOG_NOTICE, \"(%p) ICE failed to create session\\n\", instance);\n\t\t} else {\n\t\t\trtp->ice_port = x;\n\t\t\tast_sockaddr_copy(&rtp->ice_original_rtp_addr, &rtp->bind_address);\n\t\t}\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\trtp->rekeyid = -1;\n\trtp->dtls.timeout_timer = -1;\n#endif\n\n\treturn 0;\n}\n\nstatic void rtp_deallocate_transport(struct ast_rtp_instance *instance, struct ast_rtp *rtp)\n{\n\tint saved_rtp_s = rtp->s;\n#ifdef HAVE_PJPROJECT\n\tstruct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));\n\tstruct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tast_rtp_dtls_stop(instance);\n#endif\n\n\t/* Close our own socket so we no longer get packets */\n\tif (rtp->s > -1) {\n\t\tclose(rtp->s);\n\t\trtp->s = -1;\n\t}\n\n\t/* Destroy RTCP if it was being used */\n\tif (rtp->rtcp && rtp->rtcp->s > -1) {\n\t\tif (saved_rtp_s != rtp->rtcp->s) {\n\t\t\tclose(rtp->rtcp->s);\n\t\t}\n\t\trtp->rtcp->s = -1;\n\t}\n\n#ifdef HAVE_PJPROJECT\n\tpj_thread_register_check();\n\n\t/*\n\t * The instance lock is already held.\n\t *\n\t * Destroy the RTP TURN relay if being used\n\t */\n\tif (rtp->turn_rtp) {\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(rtp->turn_rtp);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t\trtp->turn_rtp = NULL;\n\t}\n\n\t/* Destroy the RTCP TURN relay if being used */\n\tif (rtp->turn_rtcp) {\n\t\trtp->turn_state = PJ_TURN_STATE_NULL;\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tao2_unlock(instance);\n\t\tpj_turn_sock_destroy(rtp->turn_rtcp);\n\t\tao2_lock(instance);\n\t\twhile (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {\n\t\t\tast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);\n\t\t}\n\t\trtp->turn_rtcp = NULL;\n\t}\n\n\tast_debug_ice(2, \"(%p) ICE RTP transport deallocating\\n\", instance);\n\t/* Destroy any ICE session */\n\tast_rtp_ice_stop(instance);\n\n\t/* Destroy any candidates */\n\tif (rtp->ice_local_candidates) {\n\t\tao2_ref(rtp->ice_local_candidates, -1);\n\t\trtp->ice_local_candidates = NULL;\n\t}\n\n\tif (rtp->ice_active_remote_candidates) {\n\t\tao2_ref(rtp->ice_active_remote_candidates, -1);\n\t\trtp->ice_active_remote_candidates = NULL;\n\t}\n\n\tif (rtp->ice_proposed_remote_candidates) {\n\t\tao2_ref(rtp->ice_proposed_remote_candidates, -1);\n\t\trtp->ice_proposed_remote_candidates = NULL;\n\t}\n\n\tif (rtp->ioqueue) {\n\t\t/*\n\t\t * We cannot hold the instance lock because we could wait\n\t\t * for the ioqueue thread to die and we might deadlock as\n\t\t * a result.\n\t\t */\n\t\tao2_unlock(instance);\n\t\trtp_ioqueue_thread_remove(rtp->ioqueue);\n\t\tao2_lock(instance);\n\t\trtp->ioqueue = NULL;\n\t}\n#endif\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_new(struct ast_rtp_instance *instance,\n\t\t       struct ast_sched_context *sched, struct ast_sockaddr *addr,\n\t\t       void *data)\n{\n\tstruct ast_rtp *rtp = NULL;\n\n\t/* Create a new RTP structure to hold all of our data */\n\tif (!(rtp = ast_calloc(1, sizeof(*rtp)))) {\n\t\treturn -1;\n\t}\n\trtp->owner = instance;\n\t/* Set default parameters on the newly created RTP structure */\n\trtp->ssrc = ast_random();\n\tast_uuid_generate_str(rtp->cname, sizeof(rtp->cname));\n\trtp->seqno = ast_random() & 0x7fff;\n\trtp->expectedrxseqno = -1;\n\trtp->expectedseqno = -1;\n\trtp->rxstart = -1;\n\trtp->sched = sched;\n\tast_sockaddr_copy(&rtp->bind_address, addr);\n\t/* Transport creation operations can grab the RTP data from the instance, so set it */\n\tast_rtp_instance_set_data(instance, rtp);\n\n\tif (rtp_allocate_transport(instance, rtp)) {\n\t\treturn -1;\n\t}\n\n\tif (AST_VECTOR_INIT(&rtp->ssrc_mapping, 1)) {\n\t\treturn -1;\n\t}\n\n\tif (AST_VECTOR_INIT(&rtp->transport_wide_cc.packet_statistics, 0)) {\n\t\treturn -1;\n\t}\n\trtp->transport_wide_cc.schedid = -1;\n\n\trtp->f.subclass.format = ao2_bump(ast_format_none);\n\trtp->lastrxformat = ao2_bump(ast_format_none);\n\trtp->lasttxformat = ao2_bump(ast_format_none);\n\trtp->stream_num = -1;\n\n\treturn 0;\n}\n\n/*!\n * \\brief SSRC mapping comparator for AST_VECTOR_REMOVE_CMP_UNORDERED()\n *\n * \\param elem Element to compare against\n * \\param value Value to compare with the vector element.\n *\n * \\retval 0 if element does not match.\n * \\retval Non-zero if element matches.\n */\n#define SSRC_MAPPING_ELEM_CMP(elem, value) ((elem).instance == (value))\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_destroy(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->bundled) {\n\t\tstruct ast_rtp *bundled_rtp;\n\n\t\t/* We can't hold our instance lock while removing ourselves from the parent */\n\t\tao2_unlock(instance);\n\n\t\tao2_lock(rtp->bundled);\n\t\tbundled_rtp = ast_rtp_instance_get_data(rtp->bundled);\n\t\tAST_VECTOR_REMOVE_CMP_UNORDERED(&bundled_rtp->ssrc_mapping, instance, SSRC_MAPPING_ELEM_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\t\tao2_unlock(rtp->bundled);\n\n\t\tao2_lock(instance);\n\t\tao2_ref(rtp->bundled, -1);\n\t}\n\n\trtp_deallocate_transport(instance, rtp);\n\n\t/* Destroy the smoother that was smoothing out audio if present */\n\tif (rtp->smoother) {\n\t\tast_smoother_free(rtp->smoother);\n\t}\n\n\t/* Destroy RTCP if it was being used */\n\tif (rtp->rtcp) {\n\t\t/*\n\t\t * It is not possible for there to be an active RTCP scheduler\n\t\t * entry at this point since it holds a reference to the\n\t\t * RTP instance while it's active.\n\t\t */\n\t\tast_free(rtp->rtcp->local_addr_str);\n\t\tast_free(rtp->rtcp);\n\t}\n\n\t/* Destroy RED if it was being used */\n\tif (rtp->red) {\n\t\tao2_unlock(instance);\n\t\tAST_SCHED_DEL(rtp->sched, rtp->red->schedid);\n\t\tao2_lock(instance);\n\t\tast_free(rtp->red);\n\t\trtp->red = NULL;\n\t}\n\n\t/* Destroy the send buffer if it was being used */\n\tif (rtp->send_buffer) {\n\t\tast_data_buffer_free(rtp->send_buffer);\n\t}\n\n\t/* Destroy the recv buffer if it was being used */\n\tif (rtp->recv_buffer) {\n\t\tast_data_buffer_free(rtp->recv_buffer);\n\t}\n\n\tAST_VECTOR_FREE(&rtp->transport_wide_cc.packet_statistics);\n\n\tao2_cleanup(rtp->lasttxformat);\n\tao2_cleanup(rtp->lastrxformat);\n\tao2_cleanup(rtp->f.subclass.format);\n\tAST_VECTOR_FREE(&rtp->ssrc_mapping);\n\tAST_VECTOR_FREE(&rtp->missing_seqno);\n\n\t/* Finally destroy ourselves */\n\trtp->owner = NULL;\n\tast_free(rtp);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_mode_set(struct ast_rtp_instance *instance, enum ast_rtp_dtmf_mode dtmf_mode)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\trtp->dtmfmode = dtmf_mode;\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic enum ast_rtp_dtmf_mode ast_rtp_dtmf_mode_get(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\treturn rtp->dtmfmode;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_begin(struct ast_rtp_instance *instance, char digit)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint hdrlen = 12, res = 0, i = 0, payload = 101;\n\tchar data[256];\n\tunsigned int *rtpheader = (unsigned int*)data;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* If we have no remote address information bail out now */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn -1;\n\t}\n\n\t/* Convert given digit into what we want to transmit */\n\tif ((digit <= '9') && (digit >= '0')) {\n\t\tdigit -= '0';\n\t} else if (digit == '*') {\n\t\tdigit = 10;\n\t} else if (digit == '#') {\n\t\tdigit = 11;\n\t} else if ((digit >= 'A') && (digit <= 'D')) {\n\t\tdigit = digit - 'A' + 12;\n\t} else if ((digit >= 'a') && (digit <= 'd')) {\n\t\tdigit = digit - 'a' + 12;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Don't know how to represent '%c'\\n\", digit);\n\t\treturn -1;\n\t}\n\n\t/* Grab the payload that they expect the RFC2833 packet to be received in */\n\tpayload = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance), 0, NULL, AST_RTP_DTMF);\n\n\trtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));\n\trtp->send_duration = 160;\n\trtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;\n\trtp->lastdigitts = rtp->lastts + rtp->send_duration;\n\n\t/* Create the actual packet that we will be sending */\n\trtpheader[0] = htonl((2 << 30) | (1 << 23) | (payload << 16) | (rtp->seqno));\n\trtpheader[1] = htonl(rtp->lastdigitts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\n\t/* Actually send the packet */\n\tfor (i = 0; i < 2; i++) {\n\t\tint ice;\n\n\t\trtpheader[3] = htonl((digit << 24) | (0xa << 16) | (rtp->send_duration));\n\t\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 4, 0, &remote_address, &ice);\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_ERROR, \"RTP Transmission error to %s: %s\\n\",\n\t\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\tif (rtp_debug_test_addr(&remote_address)) {\n\t\t\tast_verbose(\"Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t\t    payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t\t}\n\t\trtp->seqno++;\n\t\trtp->send_duration += 160;\n\t\trtpheader[0] = htonl((2 << 30) | (payload << 16) | (rtp->seqno));\n\t}\n\n\t/* Record that we are in the process of sending a digit and information needed to continue doing so */\n\trtp->sending_digit = 1;\n\trtp->send_digit = digit;\n\trtp->send_payload = payload;\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_continuation(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint hdrlen = 12, res = 0;\n\tchar data[256];\n\tunsigned int *rtpheader = (unsigned int*)data;\n\tint ice;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* Make sure we know where the other side is so we can send them the packet */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn -1;\n\t}\n\n\t/* Actually create the packet we will be sending */\n\trtpheader[0] = htonl((2 << 30) | (rtp->send_payload << 16) | (rtp->seqno));\n\trtpheader[1] = htonl(rtp->lastdigitts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\trtpheader[3] = htonl((rtp->send_digit << 24) | (0xa << 16) | (rtp->send_duration));\n\n\t/* Boom, send it on out */\n\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 4, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTP Transmission error to %s: %s\\n\",\n\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\tstrerror(errno));\n\t}\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t    rtp->send_payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t}\n\n\t/* And now we increment some values for the next time we swing by */\n\trtp->seqno++;\n\trtp->send_duration += 160;\n\trtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_end_with_duration(struct ast_rtp_instance *instance, char digit, unsigned int duration)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint hdrlen = 12, res = -1, i = 0;\n\tchar data[256];\n\tunsigned int *rtpheader = (unsigned int*)data;\n\tunsigned int measured_samples;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* Make sure we know where the remote side is so we can send them the packet we construct */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* Convert the given digit to the one we are going to send */\n\tif ((digit <= '9') && (digit >= '0')) {\n\t\tdigit -= '0';\n\t} else if (digit == '*') {\n\t\tdigit = 10;\n\t} else if (digit == '#') {\n\t\tdigit = 11;\n\t} else if ((digit >= 'A') && (digit <= 'D')) {\n\t\tdigit = digit - 'A' + 12;\n\t} else if ((digit >= 'a') && (digit <= 'd')) {\n\t\tdigit = digit - 'a' + 12;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Don't know how to represent '%c'\\n\", digit);\n\t\tgoto cleanup;\n\t}\n\n\trtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));\n\n\tif (duration > 0 && (measured_samples = duration * ast_rtp_get_rate(rtp->f.subclass.format) / 1000) > rtp->send_duration) {\n\t\tast_debug_rtp(2, \"(%p) RTP adjusting final end duration from %d to %u\\n\",\n\t\t\tinstance, rtp->send_duration, measured_samples);\n\t\trtp->send_duration = measured_samples;\n\t}\n\n\t/* Construct the packet we are going to send */\n\trtpheader[1] = htonl(rtp->lastdigitts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\trtpheader[3] = htonl((digit << 24) | (0xa << 16) | (rtp->send_duration));\n\trtpheader[3] |= htonl((1 << 23));\n\n\t/* Send it 3 times, that's the magical number */\n\tfor (i = 0; i < 3; i++) {\n\t\tint ice;\n\n\t\trtpheader[0] = htonl((2 << 30) | (rtp->send_payload << 16) | (rtp->seqno));\n\n\t\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 4, 0, &remote_address, &ice);\n\n\t\tif (res < 0) {\n\t\t\tast_log(LOG_ERROR, \"RTP Transmission error to %s: %s\\n\",\n\t\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\t\tstrerror(errno));\n\t\t}\n\n\t\tif (rtp_debug_test_addr(&remote_address)) {\n\t\t\tast_verbose(\"Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t\t    rtp->send_payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t\t}\n\n\t\trtp->seqno++;\n\t}\n\tres = 0;\n\n\t/* Oh and we can't forget to turn off the stuff that says we are sending DTMF */\n\trtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;\n\n\t/* Reset the smoother as the delivery time stored in it is now out of date */\n\tif (rtp->smoother) {\n\t\tast_smoother_free(rtp->smoother);\n\t\trtp->smoother = NULL;\n\t}\ncleanup:\n\trtp->sending_digit = 0;\n\trtp->send_digit = 0;\n\n\t/* Re-Learn expected seqno */\n\trtp->expectedseqno = -1;\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_dtmf_end(struct ast_rtp_instance *instance, char digit)\n{\n\treturn ast_rtp_dtmf_end_with_duration(instance, digit, 0);\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_update_source(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* We simply set this bit so that the next packet sent will have the marker bit turned on */\n\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT);\n\tast_debug_rtp(3, \"(%p) RTP setting the marker bit due to a source update\\n\", instance);\n\n\treturn;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_change_source(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_srtp *srtp = ast_rtp_instance_get_srtp(instance, 0);\n\tstruct ast_srtp *rtcp_srtp = ast_rtp_instance_get_srtp(instance, 1);\n\tunsigned int ssrc = ast_random();\n\n\tif (rtp->lastts) {\n\t\t/* We simply set this bit so that the next packet sent will have the marker bit turned on */\n\t\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT);\n\t}\n\n\tast_debug_rtp(3, \"(%p) RTP changing ssrc from %u to %u due to a source change\\n\",\n\t\tinstance, rtp->ssrc, ssrc);\n\n\tif (srtp) {\n\t\tast_debug_rtp(3, \"(%p) RTP changing ssrc for SRTP from %u to %u\\n\",\n\t\t\tinstance, rtp->ssrc, ssrc);\n\t\tres_srtp->change_source(srtp, rtp->ssrc, ssrc);\n\t\tif (rtcp_srtp != srtp) {\n\t\t\tres_srtp->change_source(rtcp_srtp, rtp->ssrc, ssrc);\n\t\t}\n\t}\n\n\trtp->ssrc = ssrc;\n\n\t/* Since the source is changing, we don't know what sequence number to expect next */\n\trtp->expectedrxseqno = -1;\n\n\treturn;\n}\n\nstatic void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw)\n{\n\tunsigned int sec, usec, frac;\n\tsec = tv.tv_sec + 2208988800u; /* Sec between 1900 and 1970 */\n\tusec = tv.tv_usec;\n\t/*\n\t * Convert usec to 0.32 bit fixed point without overflow.\n\t *\n\t * = usec * 2^32 / 10^6\n\t * = usec * 2^32 / (2^6 * 5^6)\n\t * = usec * 2^26 / 5^6\n\t *\n\t * The usec value needs 20 bits to represent 999999 usec.  So\n\t * splitting the 2^26 to get the most precision using 32 bit\n\t * values gives:\n\t *\n\t * = ((usec * 2^12) / 5^6) * 2^14\n\t *\n\t * Splitting the division into two stages preserves all the\n\t * available significant bits of usec over doing the division\n\t * all at once.\n\t *\n\t * = ((((usec * 2^12) / 5^3) * 2^7) / 5^3) * 2^7\n\t */\n\tfrac = ((((usec << 12) / 125) << 7) / 125) << 7;\n\t*msw = sec;\n\t*lsw = frac;\n}\n\nstatic void ntp2timeval(unsigned int msw, unsigned int lsw, struct timeval *tv)\n{\n\ttv->tv_sec = msw - 2208988800u;\n\t/* Reverse the sequence in timeval2ntp() */\n\ttv->tv_usec = ((((lsw >> 7) * 125) >> 7) * 125) >> 12;\n}\n\nstatic void calculate_lost_packet_statistics(struct ast_rtp *rtp,\n\t\tunsigned int *lost_packets,\n\t\tint *fraction_lost)\n{\n\tunsigned int extended_seq_no;\n\tunsigned int expected_packets;\n\tunsigned int expected_interval;\n\tunsigned int received_interval;\n\tint lost_interval;\n\n\t/* Compute statistics */\n\textended_seq_no = rtp->cycles + rtp->lastrxseqno;\n\texpected_packets = extended_seq_no - rtp->seedrxseqno + 1;\n\tif (rtp->rxcount > expected_packets) {\n\t\texpected_packets += rtp->rxcount - expected_packets;\n\t}\n\t*lost_packets = expected_packets - rtp->rxcount;\n\texpected_interval = expected_packets - rtp->rtcp->expected_prior;\n\treceived_interval = rtp->rxcount - rtp->rtcp->received_prior;\n\tif (received_interval > expected_interval) {\n\t\t/* If we receive some late packets it is possible for the packets\n\t\t * we received in this interval to exceed the number we expected.\n\t\t * We update the expected so that the packet loss calculations\n\t\t * show that no packets are lost.\n\t\t */\n\t\texpected_interval = received_interval;\n\t}\n\tlost_interval = expected_interval - received_interval;\n\tif (expected_interval == 0 || lost_interval <= 0) {\n\t\t*fraction_lost = 0;\n\t} else {\n\t\t*fraction_lost = (lost_interval << 8) / expected_interval;\n\t}\n\n\t/* Update RTCP statistics */\n\trtp->rtcp->received_prior = rtp->rxcount;\n\trtp->rtcp->expected_prior = expected_packets;\n\n\t/*\n\t * While rxlost represents the number of packets lost since the last report was sent, for\n\t * the calculations below it should be thought of as a single sample. Thus min/max are the\n\t * lowest/highest sample value seen, and the mean is the average number of packets lost\n\t * between each report. As such rxlost_count only needs to be incremented per report.\n\t */\n\tif (lost_interval <= 0) {\n\t\trtp->rtcp->rxlost = 0;\n\t} else {\n\t\trtp->rtcp->rxlost = lost_interval;\n\t}\n\tif (rtp->rtcp->rxlost_count == 0) {\n\t\trtp->rtcp->minrxlost = rtp->rtcp->rxlost;\n\t}\n\tif (lost_interval && lost_interval < rtp->rtcp->minrxlost) {\n\t\trtp->rtcp->minrxlost = rtp->rtcp->rxlost;\n\t}\n\tif (lost_interval > rtp->rtcp->maxrxlost) {\n\t\trtp->rtcp->maxrxlost = rtp->rtcp->rxlost;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rtcp->rxlost, &rtp->rtcp->normdev_rxlost,\n\t\t&rtp->rtcp->stdev_rxlost, &rtp->rtcp->rxlost_count);\n}\n\nstatic int ast_rtcp_generate_report(struct ast_rtp_instance *instance, unsigned char *rtcpheader,\n\t\tstruct ast_rtp_rtcp_report *rtcp_report, int *sr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint len = 0;\n\tstruct timeval now;\n\tunsigned int now_lsw;\n\tunsigned int now_msw;\n\tunsigned int lost_packets;\n\tint fraction_lost;\n\tstruct timeval dlsr = { 0, };\n\tstruct ast_rtp_rtcp_report_block *report_block = NULL;\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) { /* This'll stop rtcp for this rtp session */\n\t\t/* RTCP was stopped. */\n\t\treturn 0;\n\t}\n\n\tif (!rtcp_report) {\n\t\treturn 1;\n\t}\n\n\t*sr = rtp->txcount > rtp->rtcp->lastsrtxcount ? 1 : 0;\n\n\t/* Compute statistics */\n\tcalculate_lost_packet_statistics(rtp, &lost_packets, &fraction_lost);\n\t/*\n\t * update_local_mes_stats must be called AFTER\n\t * calculate_lost_packet_statistics\n\t */\n\tupdate_local_mes_stats(rtp);\n\n\tgettimeofday(&now, NULL);\n\trtcp_report->reception_report_count = rtp->themssrc_valid ? 1 : 0;\n\trtcp_report->ssrc = rtp->ssrc;\n\trtcp_report->type = *sr ? RTCP_PT_SR : RTCP_PT_RR;\n\tif (*sr) {\n\t\trtcp_report->sender_information.ntp_timestamp = now;\n\t\trtcp_report->sender_information.rtp_timestamp = rtp->lastts;\n\t\trtcp_report->sender_information.packet_count = rtp->txcount;\n\t\trtcp_report->sender_information.octet_count = rtp->txoctetcount;\n\t}\n\n\tif (rtp->themssrc_valid) {\n\t\treport_block = ast_calloc(1, sizeof(*report_block));\n\t\tif (!report_block) {\n\t\t\treturn 1;\n\t\t}\n\n\t\trtcp_report->report_block[0] = report_block;\n\t\treport_block->source_ssrc = rtp->themssrc;\n\t\treport_block->lost_count.fraction = (fraction_lost & 0xff);\n\t\treport_block->lost_count.packets = (lost_packets & 0xffffff);\n\t\treport_block->highest_seq_no = (rtp->cycles | (rtp->lastrxseqno & 0xffff));\n\t\treport_block->ia_jitter = (unsigned int)rtp->rxjitter_samples;\n\t\treport_block->lsr = rtp->rtcp->themrxlsr;\n\t\t/* If we haven't received an SR report, DLSR should be 0 */\n\t\tif (!ast_tvzero(rtp->rtcp->rxlsr)) {\n\t\t\ttimersub(&now, &rtp->rtcp->rxlsr, &dlsr);\n\t\t\treport_block->dlsr = (((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000;\n\t\t}\n\t}\n\ttimeval2ntp(rtcp_report->sender_information.ntp_timestamp, &now_msw, &now_lsw);\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtcp_report->ssrc)); /* Our SSRC */\n\tlen += 8;\n\tif (*sr) {\n\t\tput_unaligned_uint32(rtcpheader + len, htonl(now_msw)); /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970 */\n\t\tput_unaligned_uint32(rtcpheader + len + 4, htonl(now_lsw)); /* now, LSW */\n\t\tput_unaligned_uint32(rtcpheader + len + 8, htonl(rtcp_report->sender_information.rtp_timestamp));\n\t\tput_unaligned_uint32(rtcpheader + len + 12, htonl(rtcp_report->sender_information.packet_count));\n\t\tput_unaligned_uint32(rtcpheader + len + 16, htonl(rtcp_report->sender_information.octet_count));\n\t\tlen += 20;\n\t}\n\tif (report_block) {\n\t\tput_unaligned_uint32(rtcpheader + len, htonl(report_block->source_ssrc)); /* Their SSRC */\n\t\tput_unaligned_uint32(rtcpheader + len + 4, htonl((report_block->lost_count.fraction << 24) | report_block->lost_count.packets));\n\t\tput_unaligned_uint32(rtcpheader + len + 8, htonl(report_block->highest_seq_no));\n\t\tput_unaligned_uint32(rtcpheader + len + 12, htonl(report_block->ia_jitter));\n\t\tput_unaligned_uint32(rtcpheader + len + 16, htonl(report_block->lsr));\n\t\tput_unaligned_uint32(rtcpheader + len + 20, htonl(report_block->dlsr));\n\t\tlen += 24;\n\t}\n\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (rtcp_report->reception_report_count << 24)\n\t\t\t\t| ((*sr ? RTCP_PT_SR : RTCP_PT_RR) << 16) | ((len/4)-1)));\n\n\treturn len;\n}\n\nstatic int ast_rtcp_calculate_sr_rr_statistics(struct ast_rtp_instance *instance,\n\t\tstruct ast_rtp_rtcp_report *rtcp_report, struct ast_sockaddr remote_address, int ice, int sr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_rtcp_report_block *report_block = NULL;\n\tRAII_VAR(struct ast_json *, message_blob, NULL, ast_json_unref);\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) {\n\t\treturn 0;\n\t}\n\n\tif (!rtcp_report) {\n\t\treturn -1;\n\t}\n\n\treport_block = rtcp_report->report_block[0];\n\n\tif (sr) {\n\t\trtp->rtcp->txlsr = rtcp_report->sender_information.ntp_timestamp;\n\t\trtp->rtcp->sr_count++;\n\t\trtp->rtcp->lastsrtxcount = rtp->txcount;\n\t} else {\n\t\trtp->rtcp->rr_count++;\n\t}\n\n\tif (rtcp_debug_test_addr(&rtp->rtcp->them)) {\n\t\tast_verbose(\"* Sent RTCP %s to %s%s\\n\", sr ? \"SR\" : \"RR\",\n\t\t\t\tast_sockaddr_stringify(&remote_address), ice ? \" (via ICE)\" : \"\");\n\t\tast_verbose(\"  Our SSRC: %u\\n\", rtcp_report->ssrc);\n\t\tif (sr) {\n\t\t\tast_verbose(\"  Sent(NTP): %u.%06u\\n\",\n\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,\n\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);\n\t\t\tast_verbose(\"  Sent(RTP): %u\\n\", rtcp_report->sender_information.rtp_timestamp);\n\t\t\tast_verbose(\"  Sent packets: %u\\n\", rtcp_report->sender_information.packet_count);\n\t\t\tast_verbose(\"  Sent octets: %u\\n\", rtcp_report->sender_information.octet_count);\n\t\t}\n\t\tif (report_block) {\n\t\t\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\t\t\tast_verbose(\"  Report block:\\n\");\n\t\t\tast_verbose(\"    Their SSRC: %u\\n\", report_block->source_ssrc);\n\t\t\tast_verbose(\"    Fraction lost: %d\\n\", report_block->lost_count.fraction);\n\t\t\tast_verbose(\"    Cumulative loss: %u\\n\", report_block->lost_count.packets);\n\t\t\tast_verbose(\"    Highest seq no: %u\\n\", report_block->highest_seq_no);\n\t\t\tast_verbose(\"    IA jitter (samp): %u\\n\", report_block->ia_jitter);\n\t\t\tast_verbose(\"    IA jitter (secs): %.6f\\n\", ast_samp2sec(report_block->ia_jitter, rate));\n\t\t\tast_verbose(\"    Their last SR: %u\\n\", report_block->lsr);\n\t\t\tast_verbose(\"    DLSR: %4.4f (sec)\\n\\n\", (double)(report_block->dlsr / 65536.0));\n\t\t}\n\t}\n\n\tmessage_blob = ast_json_pack(\"{s: s, s: s, s: f}\",\n\t\t\t\"to\", ast_sockaddr_stringify(&remote_address),\n\t\t\t\"from\", rtp->rtcp->local_addr_str,\n\t\t\t\"mes\", rtp->rxmes);\n\n\tast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_sent_type(),\n\t\t\trtcp_report, message_blob);\n\n\treturn 1;\n}\n\nstatic int ast_rtcp_generate_sdes(struct ast_rtp_instance *instance, unsigned char *rtcpheader,\n\t\tstruct ast_rtp_rtcp_report *rtcp_report)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint len = 0;\n\tuint16_t sdes_packet_len_bytes;\n\tuint16_t sdes_packet_len_rounded;\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) {\n\t\treturn 0;\n\t}\n\n\tif (!rtcp_report) {\n\t\treturn -1;\n\t}\n\n\tsdes_packet_len_bytes =\n\t\t4 + /* RTCP Header */\n\t\t4 + /* SSRC */\n\t\t1 + /* Type (CNAME) */\n\t\t1 + /* Text Length */\n\t\tAST_UUID_STR_LEN /* Text and NULL terminator */\n\t\t;\n\n\t/* Round to 32 bit boundary */\n\tsdes_packet_len_rounded = (sdes_packet_len_bytes + 3) & ~0x3;\n\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | ((sdes_packet_len_rounded / 4) - 1)));\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtcp_report->ssrc));\n\trtcpheader[8] = 0x01; /* CNAME */\n\trtcpheader[9] = AST_UUID_STR_LEN - 1; /* Number of bytes of text */\n\tmemcpy(rtcpheader + 10, rtp->cname, AST_UUID_STR_LEN);\n\tlen += 10 + AST_UUID_STR_LEN;\n\n\t/* Padding - Note that we don't set the padded bit on the packet. From\n\t * RFC 3550 Section 6.5:\n\t *\n\t *   No length octet follows the null item type octet, but additional null\n\t *   octets MUST be included if needd to pad until the next 32-bit\n\t *   boundary. Note that this padding is separate from that indicated by\n\t *   the P bit in the RTCP header.\n\t *\n\t * These bytes will already be zeroed out during array initialization.\n\t */\n\tlen += (sdes_packet_len_rounded - sdes_packet_len_bytes);\n\n\treturn len;\n}\n\n/* Lock instance before calling this if it isn't already\n *\n * If successful, the overall packet length is returned\n * If not, then 0 is returned\n */\nstatic int ast_rtcp_generate_compound_prefix(struct ast_rtp_instance *instance, unsigned char *rtcpheader,\n\tstruct ast_rtp_rtcp_report *report, int *sr)\n{\n\tint packet_len = 0;\n\tint res;\n\n\t/* Every RTCP packet needs to be sent out with a SR/RR and SDES prefixing it.\n\t * At the end of this function, rtcpheader should contain both of those packets,\n\t * and will return the length of the overall packet. This can be used to determine\n\t * where further packets can be inserted in the compound packet.\n\t */\n\tres = ast_rtcp_generate_report(instance, rtcpheader, report, sr);\n\n\tif (res == 0 || res == 1) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP failed to generate %s report!\\n\", instance, sr ? \"SR\" : \"RR\");\n\t\treturn 0;\n\t}\n\n\tpacket_len += res;\n\n\tres = ast_rtcp_generate_sdes(instance, rtcpheader + packet_len, report);\n\n\tif (res == 0 || res == 1) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP failed to generate SDES!\\n\", instance);\n\t\treturn 0;\n\t}\n\n\treturn packet_len + res;\n}\n\nstatic int ast_rtcp_generate_nack(struct ast_rtp_instance *instance, unsigned char *rtcpheader)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint packet_len;\n\tint blp_index = -1;\n\tint current_seqno;\n\tunsigned int fci = 0;\n\tsize_t remaining_missing_seqno;\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn 0;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them)) {\n\t\treturn 0;\n\t}\n\n\tcurrent_seqno = rtp->expectedrxseqno;\n\tremaining_missing_seqno = AST_VECTOR_SIZE(&rtp->missing_seqno);\n\tpacket_len = 12; /* The header length is 12 (version line, packet source SSRC, media source SSRC) */\n\n\t/* If there are no missing sequence numbers then don't bother sending a NACK needlessly */\n\tif (!remaining_missing_seqno) {\n\t\treturn 0;\n\t}\n\n\t/* This iterates through the possible forward sequence numbers seeing which ones we\n\t * have no packet for, adding it to the NACK until we are out of missing packets.\n\t */\n\twhile (remaining_missing_seqno) {\n\t\tint *missing_seqno;\n\n\t\t/* On the first entry to this loop blp_index will be -1, so this will become 0\n\t\t * and the sequence number will be placed into the packet as the PID.\n\t\t */\n\t\tblp_index++;\n\n\t\tmissing_seqno = AST_VECTOR_GET_CMP(&rtp->missing_seqno, current_seqno,\n\t\t\t\tfind_by_value);\n\t\tif (missing_seqno) {\n\t\t\t/* We hit the max blp size, reset */\n\t\t\tif (blp_index >= 17) {\n\t\t\t\tput_unaligned_uint32(rtcpheader + packet_len, htonl(fci));\n\t\t\t\tfci = 0;\n\t\t\t\tblp_index = 0;\n\t\t\t\tpacket_len += 4;\n\t\t\t}\n\n\t\t\tif (blp_index == 0) {\n\t\t\t\tfci |= (current_seqno << 16);\n\t\t\t} else {\n\t\t\t\tfci |= (1 << (blp_index - 1));\n\t\t\t}\n\n\t\t\t/* Since we've used a missing sequence number, we're down one */\n\t\t\tremaining_missing_seqno--;\n\t\t}\n\n\t\t/* Handle cycling of the sequence number */\n\t\tcurrent_seqno++;\n\t\tif (current_seqno == SEQNO_CYCLE_OVER) {\n\t\t\tcurrent_seqno = 0;\n\t\t}\n\t}\n\n\tput_unaligned_uint32(rtcpheader + packet_len, htonl(fci));\n\tpacket_len += 4;\n\n\t/* Length MUST be 2+n, where n is the number of NACKs. Same as length in words minus 1 */\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (AST_RTP_RTCP_FMT_NACK << 24)\n\t\t\t\t| (AST_RTP_RTCP_RTPFB << 16) | ((packet_len / 4) - 1)));\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + 8, htonl(rtp->themssrc));\n\n\treturn packet_len;\n}\n\n/*!\n * \\brief Write a RTCP packet to the far end\n *\n * \\note Decide if we are going to send an SR (with Reception Block) or RR\n * RR is sent if we have not sent any rtp packets in the previous interval\n *\n * Scheduler callback\n */\nstatic int ast_rtcp_write(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint res;\n\tint sr = 0;\n\tint packet_len = 0;\n\tint ice;\n\tstruct ast_sockaddr remote_address = { { 0, } };\n\tunsigned char *rtcpheader;\n\tunsigned char bdata[AST_UUID_STR_LEN + 128] = \"\"; /* More than enough */\n\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\n\tif (!rtp || !rtp->rtcp || rtp->rtcp->schedid == -1) {\n\t\tao2_ref(instance, -1);\n\t\treturn 0;\n\t}\n\n\tao2_lock(instance);\n\trtcpheader = bdata;\n\trtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);\n\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\tif (res == 0 || res == 1) {\n\t\tgoto cleanup;\n\t}\n\n\tpacket_len += res;\n\n\tif (rtp->bundled) {\n\t\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\t} else {\n\t\tast_sockaddr_copy(&remote_address, &rtp->rtcp->them);\n\t}\n\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP %s transmission error to %s, rtcp halted %s\\n\",\n\t\t\t\tsr ? \"SR\" : \"RR\",\n\t\t\t\tast_sockaddr_stringify(&rtp->rtcp->them),\n\t\t\t\tstrerror(errno));\n\t\tres = 0;\n\t} else {\n\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, remote_address, ice, sr);\n\t}\n\ncleanup:\n\tao2_unlock(instance);\n\n\tif (!res) {\n\t\t/*\n\t\t * Not being rescheduled.\n\t\t */\n\t\trtp->rtcp->schedid = -1;\n\t\tao2_ref(instance, -1);\n\t}\n\n\treturn res;\n}\n\nstatic void put_unaligned_time24(void *p, uint32_t time_msw, uint32_t time_lsw)\n{\n\tunsigned char *cp = p;\n\tuint32_t datum;\n\n\t/* Convert the time to 6.18 format */\n\tdatum = (time_msw << 18) & 0x00fc0000;\n\tdatum |= (time_lsw >> 14) & 0x0003ffff;\n\n\tcp[0] = datum >> 16;\n\tcp[1] = datum >> 8;\n\tcp[2] = datum;\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_raw_write(struct ast_rtp_instance *instance, struct ast_frame *frame, int codec)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint pred, mark = 0;\n\tunsigned int ms = calc_txstamp(rtp, &frame->delivery);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint rate = ast_rtp_get_rate(frame->subclass.format) / 1000;\n\tunsigned int seqno;\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif (ast_format_cmp(frame->subclass.format, ast_format_g722) == AST_FORMAT_CMP_EQUAL) {\n\t\tframe->samples /= 2;\n\t}\n\n\tif (rtp->sending_digit) {\n\t\treturn 0;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->send_report) {\n\t\ttest->send_report = 0;\n\t\tast_rtcp_write(instance);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (frame->frametype == AST_FRAME_VOICE) {\n\t\tpred = rtp->lastts + frame->samples;\n\n\t\t/* Re-calculate last TS */\n\t\trtp->lastts = rtp->lastts + ms * rate;\n\t\tif (ast_tvzero(frame->delivery)) {\n\t\t\t/* If this isn't an absolute delivery time, Check if it is close to our prediction,\n\t\t\t   and if so, go with our prediction */\n\t\t\tif (abs((int)rtp->lastts - pred) < MAX_TIMESTAMP_SKEW) {\n\t\t\t\trtp->lastts = pred;\n\t\t\t} else {\n\t\t\t\tast_debug_rtp(3, \"(%p) RTP audio difference is %d, ms is %u\\n\",\n\t\t\t\t\tinstance, abs((int)rtp->lastts - pred), ms);\n\t\t\t\tmark = 1;\n\t\t\t}\n\t\t}\n\t} else if (frame->frametype == AST_FRAME_VIDEO) {\n\t\tmark = frame->subclass.frame_ending;\n\t\tpred = rtp->lastovidtimestamp + frame->samples;\n\t\t/* Re-calculate last TS */\n\t\trtp->lastts = rtp->lastts + ms * 90;\n\t\t/* If it's close to our prediction, go for it */\n\t\tif (ast_tvzero(frame->delivery)) {\n\t\t\tif (abs((int)rtp->lastts - pred) < 7200) {\n\t\t\t\trtp->lastts = pred;\n\t\t\t\trtp->lastovidtimestamp += frame->samples;\n\t\t\t} else {\n\t\t\t\tast_debug_rtp(3, \"(%p) RTP video difference is %d, ms is %u (%u), pred/ts/samples %u/%d/%d\\n\",\n\t\t\t\t\tinstance, abs((int)rtp->lastts - pred), ms, ms * 90, rtp->lastts, pred, frame->samples);\n\t\t\t\trtp->lastovidtimestamp = rtp->lastts;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpred = rtp->lastotexttimestamp + frame->samples;\n\t\t/* Re-calculate last TS */\n\t\trtp->lastts = rtp->lastts + ms;\n\t\t/* If it's close to our prediction, go for it */\n\t\tif (ast_tvzero(frame->delivery)) {\n\t\t\tif (abs((int)rtp->lastts - pred) < 7200) {\n\t\t\t\trtp->lastts = pred;\n\t\t\t\trtp->lastotexttimestamp += frame->samples;\n\t\t\t} else {\n\t\t\t\tast_debug_rtp(3, \"(%p) RTP other difference is %d, ms is %u, pred/ts/samples %u/%d/%d\\n\",\n\t\t\t\t\tinstance, abs((int)rtp->lastts - pred), ms, rtp->lastts, pred, frame->samples);\n\t\t\t\trtp->lastotexttimestamp = rtp->lastts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If we have been explicitly told to set the marker bit then do so */\n\tif (ast_test_flag(rtp, FLAG_NEED_MARKER_BIT)) {\n\t\tmark = 1;\n\t\tast_clear_flag(rtp, FLAG_NEED_MARKER_BIT);\n\t}\n\n\t/* If the timestamp for non-digt packets has moved beyond the timestamp for digits, update the digit timestamp */\n\tif (rtp->lastts > rtp->lastdigitts) {\n\t\trtp->lastdigitts = rtp->lastts;\n\t}\n\n\t/* Assume that the sequence number we expect to use is what will be used until proven otherwise */\n\tseqno = rtp->seqno;\n\n\t/* If the frame contains sequence number information use it to influence our sequence number */\n\tif (ast_test_flag(frame, AST_FRFLAG_HAS_SEQUENCE_NUMBER)) {\n\t\tif (rtp->expectedseqno != -1) {\n\t\t\t/* Determine where the frame from the core is in relation to where we expected */\n\t\t\tint difference = frame->seqno - rtp->expectedseqno;\n\n\t\t\t/* If there is a substantial difference then we've either got packets really out\n\t\t\t * of order, or the source is RTP and it has cycled. If this happens we resync\n\t\t\t * the sequence number adjustments to this frame. If we also have packet loss\n\t\t\t * things won't be reflected correctly but it will sort itself out after a bit.\n\t\t\t */\n\t\t\tif (abs(difference) > 100) {\n\t\t\t\tdifference = 0;\n\t\t\t}\n\n\t\t\t/* Adjust the sequence number being used for this packet accordingly */\n\t\t\tseqno += difference;\n\n\t\t\tif (difference >= 0) {\n\t\t\t\t/* This frame is on time or in the future */\n\t\t\t\trtp->expectedseqno = frame->seqno + 1;\n\t\t\t\trtp->seqno += difference;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is the first frame with sequence number we've seen, so start keeping track */\n\t\t\trtp->expectedseqno = frame->seqno + 1;\n\t\t}\n\t} else {\n\t\trtp->expectedseqno = -1;\n\t}\n\n\tif (ast_test_flag(frame, AST_FRFLAG_HAS_TIMING_INFO)) {\n\t\trtp->lastts = frame->ts * rate;\n\t}\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* If we know the remote address construct a packet and send it out */\n\tif (!ast_sockaddr_isnull(&remote_address)) {\n\t\tint hdrlen = 12;\n\t\tint res;\n\t\tint ice;\n\t\tint ext = 0;\n\t\tint abs_send_time_id;\n\t\tint packet_len;\n\t\tunsigned char *rtpheader;\n\n\t\t/* If the abs-send-time extension has been negotiated determine how much space we need */\n\t\tabs_send_time_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_ABS_SEND_TIME);\n\t\tif (abs_send_time_id != -1) {\n\t\t\t/* 4 bytes for the shared information, 1 byte for identifier, 3 bytes for abs-send-time */\n\t\t\thdrlen += 8;\n\t\t\text = 1;\n\t\t}\n\n\t\tpacket_len = frame->datalen + hdrlen;\n\t\trtpheader = (unsigned char *)(frame->data.ptr - hdrlen);\n\n\t\tput_unaligned_uint32(rtpheader, htonl((2 << 30) | (ext << 28) | (codec << 16) | (seqno) | (mark << 23)));\n\t\tput_unaligned_uint32(rtpheader + 4, htonl(rtp->lastts));\n\t\tput_unaligned_uint32(rtpheader + 8, htonl(rtp->ssrc));\n\n\t\t/* We assume right now that we will only ever have the abs-send-time extension in the packet\n\t\t * which simplifies things a bit.\n\t\t */\n\t\tif (abs_send_time_id != -1) {\n\t\t\tunsigned int now_msw;\n\t\t\tunsigned int now_lsw;\n\n\t\t\t/* This happens before being placed into the retransmission buffer so that when we\n\t\t\t * retransmit we only have to update the timestamp, not everything else.\n\t\t\t */\n\t\t\tput_unaligned_uint32(rtpheader + 12, htonl((0xBEDE << 16) | 1));\n\t\t\trtpheader[16] = (abs_send_time_id << 4) | 2;\n\n\t\t\ttimeval2ntp(ast_tvnow(), &now_msw, &now_lsw);\n\t\t\tput_unaligned_time24(rtpheader + 17, now_msw, now_lsw);\n\t\t}\n\n\t\t/* If retransmissions are enabled, we need to store this packet for future use */\n\t\tif (rtp->send_buffer) {\n\t\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\n\t\t\tpayload = ast_malloc(sizeof(*payload) + packet_len);\n\t\t\tif (payload) {\n\t\t\t\tpayload->size = packet_len;\n\t\t\t\tmemcpy(payload->buf, rtpheader, packet_len);\n\t\t\t\tif (ast_data_buffer_put(rtp->send_buffer, rtp->seqno, payload) == -1) {\n\t\t\t\t\tast_free(payload);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres = rtp_sendto(instance, (void *)rtpheader, packet_len, 0, &remote_address, &ice);\n\t\tif (res < 0) {\n\t\t\tif (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT) || (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT) && (ast_test_flag(rtp, FLAG_NAT_ACTIVE) == FLAG_NAT_ACTIVE))) {\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP transmission error of packet %d to %s: %s\\n\",\n\t\t\t\t\t  instance, rtp->seqno,\n\t\t\t\t\t  ast_sockaddr_stringify(&remote_address),\n\t\t\t\t\t  strerror(errno));\n\t\t\t} else if (((ast_test_flag(rtp, FLAG_NAT_ACTIVE) == FLAG_NAT_INACTIVE) || ast_debug_rtp_packet_is_allowed) && !ast_test_flag(rtp, FLAG_NAT_INACTIVE_NOWARN)) {\n\t\t\t\t/* Only give this error message once if we are not RTP debugging */\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed)\n\t\t\t\t\tast_debug(0, \"(%p) RTP NAT: Can't write RTP to private address %s, waiting for other end to send audio...\\n\",\n\t\t\t\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\t\t\tast_set_flag(rtp, FLAG_NAT_INACTIVE_NOWARN);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp->rtcp && rtp->rtcp->schedid < 0) {\n\t\t\t\tast_debug_rtcp(2, \"(%s) RTCP starting transmission in %u ms\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance), ast_rtcp_calc_interval(rtp));\n\t\t\t\tao2_ref(instance, +1);\n\t\t\t\trtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);\n\t\t\t\tif (rtp->rtcp->schedid < 0) {\n\t\t\t\t\tao2_ref(instance, -1);\n\t\t\t\t\tast_log(LOG_WARNING, \"scheduling RTCP transmission failed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_debug_test_addr(&remote_address)) {\n\t\t\tast_verbose(\"Sent RTP packet to      %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t\t    codec, rtp->seqno, rtp->lastts, res - hdrlen);\n\t\t}\n\t}\n\n\t/* If the sequence number that has been used doesn't match what we expected then this is an out of\n\t * order late packet, so we don't need to increment as we haven't yet gotten the expected frame from\n\t * the core.\n\t */\n\tif (seqno == rtp->seqno) {\n\t\trtp->seqno++;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ast_frame *red_t140_to_red(struct rtp_red *red)\n{\n\tunsigned char *data = red->t140red.data.ptr;\n\tint len = 0;\n\tint i;\n\n\t/* replace most aged generation */\n\tif (red->len[0]) {\n\t\tfor (i = 1; i < red->num_gen+1; i++)\n\t\t\tlen += red->len[i];\n\n\t\tmemmove(&data[red->hdrlen], &data[red->hdrlen+red->len[0]], len);\n\t}\n\n\t/* Store length of each generation and primary data length*/\n\tfor (i = 0; i < red->num_gen; i++)\n\t\tred->len[i] = red->len[i+1];\n\tred->len[i] = red->t140.datalen;\n\n\t/* write each generation length in red header */\n\tlen = red->hdrlen;\n\tfor (i = 0; i < red->num_gen; i++) {\n\t\tlen += data[i*4+3] = red->len[i];\n\t}\n\n\t/* add primary data to buffer */\n\tmemcpy(&data[len], red->t140.data.ptr, red->t140.datalen);\n\tred->t140red.datalen = len + red->t140.datalen;\n\n\t/* no primary data and no generations to send */\n\tif (len == red->hdrlen && !red->t140.datalen) {\n\t\treturn NULL;\n\t}\n\n\t/* reset t.140 buffer */\n\tred->t140.datalen = 0;\n\n\treturn &red->t140red;\n}\n\nstatic void rtp_write_rtcp_fir(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *remote_address)\n{\n\tunsigned char *rtcpheader;\n\tunsigned char bdata[1024];\n\tint packet_len = 0;\n\tint fir_len = 20;\n\tint ice;\n\tint res;\n\tint sr;\n\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them) || rtp->rtcp->schedid < 0) {\n\t\t/*\n\t\t * RTCP was stopped.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (!rtp->themssrc_valid) {\n\t\t/* We don't know their SSRC value so we don't know who to update. */\n\t\treturn;\n\t}\n\n\t/* Prepare RTCP FIR (PT=206, FMT=4) */\n\trtp->rtcp->firseq++;\n\tif(rtp->rtcp->firseq == 256) {\n\t\trtp->rtcp->firseq = 0;\n\t}\n\n\trtcpheader = bdata;\n\n\tao2_lock(instance);\n\trtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);\n\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\tif (res == 0 || res == 1) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tpacket_len += res;\n\n\tput_unaligned_uint32(rtcpheader + packet_len + 0, htonl((2 << 30) | (4 << 24) | (RTCP_PT_PSFB << 16) | ((fir_len/4)-1)));\n\tput_unaligned_uint32(rtcpheader + packet_len + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + packet_len + 8, htonl(rtp->themssrc));\n\tput_unaligned_uint32(rtcpheader + packet_len + 12, htonl(rtp->themssrc)); /* FCI: SSRC */\n\tput_unaligned_uint32(rtcpheader + packet_len + 16, htonl(rtp->rtcp->firseq << 24)); /* FCI: Sequence number */\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len + fir_len, 0, rtp->bundled ? remote_address : &rtp->rtcp->them, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP FIR transmission error: %s\\n\", strerror(errno));\n\t} else {\n\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, rtp->bundled ? *remote_address : rtp->rtcp->them, ice, sr);\n\t}\n\n\tao2_unlock(instance);\n}\n\nstatic void rtp_write_rtcp_psfb(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_frame *frame, struct ast_sockaddr *remote_address)\n{\n\tstruct ast_rtp_rtcp_feedback *feedback = frame->data.ptr;\n\tunsigned char *rtcpheader;\n\tunsigned char bdata[1024];\n\tint remb_len = 24;\n\tint ice;\n\tint res;\n\tint sr = 0;\n\tint packet_len = 0;\n\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\n\tif (feedback->fmt != AST_RTP_RTCP_FMT_REMB) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP provided feedback frame of format %d to write, but only REMB is supported\\n\",\n\t\t\tinstance, feedback->fmt);\n\t\treturn;\n\t}\n\n\tif (!rtp || !rtp->rtcp) {\n\t\treturn;\n\t}\n\n\t/* If REMB support is not enabled don't send this RTCP packet */\n\tif (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_REMB)) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP provided feedback REMB report to write, but REMB support not enabled\\n\",\n\t\t\tinstance);\n\t\treturn;\n\t}\n\n\tif (ast_sockaddr_isnull(&rtp->rtcp->them) || rtp->rtcp->schedid < 0) {\n\t\t/*\n\t\t * RTCP was stopped.\n\t\t */\n\t\treturn;\n\t}\n\n\trtcpheader = bdata;\n\n\tao2_lock(instance);\n\trtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);\n\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\tif (res == 0 || res == 1) {\n\t\tao2_unlock(instance);\n\t\treturn;\n\t}\n\n\tpacket_len += res;\n\n\tput_unaligned_uint32(rtcpheader + packet_len + 0, htonl((2 << 30) | (AST_RTP_RTCP_FMT_REMB << 24) | (RTCP_PT_PSFB << 16) | ((remb_len/4)-1)));\n\tput_unaligned_uint32(rtcpheader + packet_len + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + packet_len + 8, htonl(0)); /* Per the draft, this should always be 0 */\n\tput_unaligned_uint32(rtcpheader + packet_len + 12, htonl(('R' << 24) | ('E' << 16) | ('M' << 8) | ('B'))); /* Unique identifier 'R' 'E' 'M' 'B' */\n\tput_unaligned_uint32(rtcpheader + packet_len + 16, htonl((1 << 24) | (feedback->remb.br_exp << 18) | (feedback->remb.br_mantissa))); /* Number of SSRCs / BR Exp / BR Mantissa */\n\tput_unaligned_uint32(rtcpheader + packet_len + 20, htonl(rtp->ssrc)); /* The SSRC this feedback message applies to */\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len + remb_len, 0, rtp->bundled ? remote_address : &rtp->rtcp->them, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP PSFB transmission error: %s\\n\", strerror(errno));\n\t} else {\n\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, rtp->bundled ? *remote_address : rtp->rtcp->them, ice, sr);\n\t}\n\n\tao2_unlock(instance);\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tstruct ast_format *format;\n\tint codec;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* If we don't actually know the remote address don't even bother doing anything */\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\tast_debug_rtp(1, \"(%p) RTP no remote address on instance, so dropping frame\\n\", instance);\n\t\treturn 0;\n\t}\n\n\t/* VP8: is this a request to send a RTCP FIR? */\n\tif (frame->frametype == AST_FRAME_CONTROL && frame->subclass.integer == AST_CONTROL_VIDUPDATE) {\n\t\trtp_write_rtcp_fir(instance, rtp, &remote_address);\n\t\treturn 0;\n\t} else if (frame->frametype == AST_FRAME_RTCP) {\n\t\tif (frame->subclass.integer == AST_RTP_RTCP_PSFB) {\n\t\t\trtp_write_rtcp_psfb(instance, rtp, frame, &remote_address);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* If there is no data length we can't very well send the packet */\n\tif (!frame->datalen) {\n\t\tast_debug_rtp(1, \"(%p) RTP received frame with no data for instance, so dropping frame\\n\", instance);\n\t\treturn 0;\n\t}\n\n\t/* If the packet is not one our RTP stack supports bail out */\n\tif (frame->frametype != AST_FRAME_VOICE && frame->frametype != AST_FRAME_VIDEO && frame->frametype != AST_FRAME_TEXT) {\n\t\tast_log(LOG_WARNING, \"RTP can only send voice, video, and text\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rtp->red) {\n\t\t/* return 0; */\n\t\t/* no primary data or generations to send */\n\t\tif ((frame = red_t140_to_red(rtp->red)) == NULL)\n\t\t\treturn 0;\n\t}\n\n\t/* Grab the subclass and look up the payload we are going to use */\n\tcodec = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance),\n\t\t1, frame->subclass.format, 0);\n\tif (codec < 0) {\n\t\tast_log(LOG_WARNING, \"Don't know how to send format %s packets with RTP\\n\",\n\t\t\tast_format_get_name(frame->subclass.format));\n\t\treturn -1;\n\t}\n\n\t/* Note that we do not increase the ref count here as this pointer\n\t * will not be held by any thing explicitly. The format variable is\n\t * merely a convenience reference to frame->subclass.format */\n\tformat = frame->subclass.format;\n\tif (ast_format_cmp(rtp->lasttxformat, format) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t/* Oh dear, if the format changed we will have to set up a new smoother */\n\t\tast_debug_rtp(1, \"(%s) RTP ooh, format changed from %s to %s\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\tast_format_get_name(rtp->lasttxformat),\n\t\t\tast_format_get_name(frame->subclass.format));\n\t\tao2_replace(rtp->lasttxformat, format);\n\t\tif (rtp->smoother) {\n\t\t\tast_smoother_free(rtp->smoother);\n\t\t\trtp->smoother = NULL;\n\t\t}\n\t}\n\n\t/* If no smoother is present see if we have to set one up */\n\tif (!rtp->smoother && ast_format_can_be_smoothed(format)) {\n\t\tunsigned int smoother_flags = ast_format_get_smoother_flags(format);\n\t\tunsigned int framing_ms = ast_rtp_codecs_get_framing(ast_rtp_instance_get_codecs(instance));\n\n\t\tif (!framing_ms && (smoother_flags & AST_SMOOTHER_FLAG_FORCED)) {\n\t\t\tframing_ms = ast_format_get_default_ms(format);\n\t\t}\n\n\t\tif (framing_ms) {\n\t\t\trtp->smoother = ast_smoother_new((framing_ms * ast_format_get_minimum_bytes(format)) / ast_format_get_minimum_ms(format));\n\t\t\tif (!rtp->smoother) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create smoother: format %s ms: %u len: %u\\n\",\n\t\t\t\t\tast_format_get_name(format), framing_ms, ast_format_get_minimum_bytes(format));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tast_smoother_set_flags(rtp->smoother, smoother_flags);\n\t\t}\n\t}\n\n\t/* Feed audio frames into the actual function that will create a frame and send it */\n\tif (rtp->smoother) {\n\t\tstruct ast_frame *f;\n\n\t\tif (ast_smoother_test_flag(rtp->smoother, AST_SMOOTHER_FLAG_BE)) {\n\t\t\tast_smoother_feed_be(rtp->smoother, frame);\n\t\t} else {\n\t\t\tast_smoother_feed(rtp->smoother, frame);\n\t\t}\n\n\t\twhile ((f = ast_smoother_read(rtp->smoother)) && (f->data.ptr)) {\n\t\t\t\trtp_raw_write(instance, f, codec);\n\t\t}\n\t} else {\n\t\tint hdrlen = 12;\n\t\tstruct ast_frame *f = NULL;\n\n\t\tif (frame->offset < hdrlen) {\n\t\t\tf = ast_frdup(frame);\n\t\t} else {\n\t\t\tf = frame;\n\t\t}\n\t\tif (f->data.ptr) {\n\t\t\trtp_raw_write(instance, f, codec);\n\t\t}\n\t\tif (f != frame) {\n\t\t\tast_frfree(f);\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic void calc_rxstamp_and_jitter(struct timeval *tv,\n\tstruct ast_rtp *rtp, unsigned int rx_rtp_ts,\n\tint mark)\n{\n\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\n\tdouble jitter = 0.0;\n\tdouble prev_jitter = 0.0;\n\tstruct timeval now;\n\tstruct timeval tmp;\n\tdouble rxnow;\n\tdouble arrival_sec;\n\tunsigned int arrival;\n\tint transit;\n\tint d;\n\n\tgettimeofday(&now,NULL);\n\n\tif (rtp->rxcount == 1 || mark) {\n\t\trtp->rxstart = ast_tv2double(&now);\n\t\trtp->remote_seed_rx_rtp_ts = rx_rtp_ts;\n\n\t\t/*\n\t\t * \"tv\" is placed in the received frame's\n\t\t * \"delivered\" field and when this frame is\n\t\t * sent out again on the other side, it's\n\t\t * used to calculate the timestamp on the\n\t\t * outgoing RTP packets.\n\t\t *\n\t\t * NOTE: We need to do integer math here\n\t\t * because double math rounding issues can\n\t\t * generate incorrect timestamps.\n\t\t */\n\t\trtp->rxcore = now;\n\t\ttmp = ast_samp2tv(rx_rtp_ts, rate);\n\t\trtp->rxcore = ast_tvsub(rtp->rxcore, tmp);\n\t\trtp->rxcore.tv_usec -= rtp->rxcore.tv_usec % 100;\n\t\t*tv = ast_tvadd(rtp->rxcore, tmp);\n\n\t\tast_debug_rtcp(3, \"%s: \"\n\t\t\t\"Seed ts: %u current time: %f\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rx_rtp_ts\n\t\t\t, rtp->rxstart\n\t\t);\n\n\t\treturn;\n\t}\n\n\ttmp = ast_samp2tv(rx_rtp_ts, rate);\n\t/* See the comment about \"tv\" above. Even if\n\t * we don't use this received packet for jitter\n\t * calculations, we still need to set tv so the\n\t * timestamp will be correct when this packet is\n\t * sent out again.\n\t */\n\t*tv = ast_tvadd(rtp->rxcore, tmp);\n\n\t/*\n\t * The first few packets are generally unstable so let's\n\t * not use them in the calculations.\n\t */\n\tif (rtp->rxcount < RTP_IGNORE_FIRST_PACKETS_COUNT) {\n\t\tast_debug_rtcp(3, \"%s: Packet %d < %d.  Ignoring\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rtp->rxcount\n\t\t\t, RTP_IGNORE_FIRST_PACKETS_COUNT\n\t\t);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * First good packet. Capture the start time and timestamp\n\t * but don't actually use this packet for calculation.\n\t */\n\tif (rtp->rxcount == RTP_IGNORE_FIRST_PACKETS_COUNT) {\n\t\trtp->rxstart_stable = ast_tv2double(&now);\n\t\trtp->remote_seed_rx_rtp_ts_stable = rx_rtp_ts;\n\t\trtp->last_transit_time_samples = -rx_rtp_ts;\n\n\t\tast_debug_rtcp(3, \"%s: \"\n\t\t\t\"pkt: %5u Stable Seed ts: %u current time: %f\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rtp->rxcount\n\t\t\t, rx_rtp_ts\n\t\t\t, rtp->rxstart_stable\n\t\t);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If the current packet isn't in sequence, don't\n\t * use it in any calculations as remote_current_rx_rtp_ts\n\t * is not going to be correct.\n\t */\n\tif (rtp->lastrxseqno != rtp->prevrxseqno + 1) {\n\t\tast_debug_rtcp(3, \"%s: Current packet seq %d != last packet seq %d + 1.  Ignoring\\n\",\n\t\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t\t, rtp->lastrxseqno\n\t\t\t, rtp->prevrxseqno\n\t\t);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * The following calculations are taken from\n\t * https://www.rfc-editor.org/rfc/rfc3550#appendix-A.8\n\t *\n\t * The received rtp timestamp is the random \"seed\"\n\t * timestamp chosen by the sender when they sent the\n\t * first packet, plus the number of samples since then.\n\t *\n\t * To get our arrival time in the same units, we\n\t * calculate the time difference in seconds between\n\t * when we received the first packet and when we\n\t * received this packet and convert that to samples.\n\t */\n\trxnow = ast_tv2double(&now);\n\tarrival_sec = rxnow - rtp->rxstart_stable;\n\tarrival = ast_sec2samp(arrival_sec, rate);\n\n\t/*\n\t * Now we can use the exact formula in\n\t * https://www.rfc-editor.org/rfc/rfc3550#appendix-A.8 :\n\t *\n\t * int transit = arrival - r->ts;\n\t * int d = transit - s->transit;\n\t * s->transit = transit;\n\t * if (d < 0) d = -d;\n\t * s->jitter += (1./16.) * ((double)d - s->jitter);\n\t *\n\t * Our rx_rtp_ts is their r->ts.\n\t * Our rtp->last_transit_time_samples is their s->transit.\n\t * Our rtp->rxjitter is their s->jitter.\n\t */\n\ttransit = arrival - rx_rtp_ts;\n\td = transit - rtp->last_transit_time_samples;\n\n\tif (d < 0) {\n\t\td = -d;\n\t}\n\n\tprev_jitter = rtp->rxjitter_samples;\n\tjitter = (1.0/16.0) * (((double)d) - prev_jitter);\n\trtp->rxjitter_samples = prev_jitter + jitter;\n\n\t/*\n\t * We need to hang on to jitter in both samples and seconds.\n\t */\n\trtp->rxjitter = ast_samp2sec(rtp->rxjitter_samples, rate);\n\n\tast_debug_rtcp(3, \"%s: pkt: %5u \"\n\t\t\"Arrival sec: %7.3f  Arrival ts: %10u  RX ts: %10u \"\n\t\t\"Transit samp: %6d Last transit samp: %6d d: %4d \"\n\t\t\"Curr jitter: %7.0f(%7.3f) Prev Jitter: %7.0f(%7.3f) New Jitter: %7.0f(%7.3f)\\n\",\n\t\tast_rtp_instance_get_channel_id(rtp->owner)\n\t\t, rtp->rxcount\n\t\t, arrival_sec\n\t\t, arrival\n\t\t, rx_rtp_ts\n\t\t, transit\n\t\t, rtp->last_transit_time_samples\n\t\t, d\n\t\t, jitter\n\t\t, ast_samp2sec(jitter, rate)\n\t\t, prev_jitter\n\t\t, ast_samp2sec(prev_jitter, rate)\n\t\t, rtp->rxjitter_samples\n\t\t, rtp->rxjitter\n\t\t);\n\n\trtp->last_transit_time_samples = transit;\n\n\t/*\n\t * Update all the stats.\n\t */\n\tif (rtp->rtcp) {\n\t\tif (rtp->rxjitter > rtp->rtcp->maxrxjitter)\n\t\t\trtp->rtcp->maxrxjitter = rtp->rxjitter;\n\t\tif (rtp->rtcp->rxjitter_count == 1)\n\t\t\trtp->rtcp->minrxjitter = rtp->rxjitter;\n\t\tif (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter)\n\t\t\trtp->rtcp->minrxjitter = rtp->rxjitter;\n\n\t\tcalc_mean_and_standard_deviation(rtp->rxjitter,\n\t\t\t&rtp->rtcp->normdev_rxjitter, &rtp->rtcp->stdev_rxjitter,\n\t\t\t&rtp->rtcp->rxjitter_count);\n\t}\n\n\treturn;\n}\n\nstatic struct ast_frame *create_dtmf_frame(struct ast_rtp_instance *instance, enum ast_frame_type type, int compensate)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\tif (((compensate && type == AST_FRAME_DTMF_END) || (type == AST_FRAME_DTMF_BEGIN)) && ast_tvcmp(ast_tvnow(), rtp->dtmfmute) < 0) {\n\t\tast_debug_rtp(1, \"(%p) RTP ignore potential DTMF echo from '%s'\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\trtp->resp = 0;\n\t\trtp->dtmfsamples = 0;\n\t\treturn &ast_null_frame;\n\t} else if (type == AST_FRAME_DTMF_BEGIN && rtp->resp == 'X') {\n\t\tast_debug_rtp(1, \"(%p) RTP ignore flash begin from '%s'\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\trtp->resp = 0;\n\t\trtp->dtmfsamples = 0;\n\t\treturn &ast_null_frame;\n\t}\n\n\tif (rtp->resp == 'X') {\n\t\tast_debug_rtp(1, \"(%p) RTP creating flash Frame at %s\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\trtp->f.frametype = AST_FRAME_CONTROL;\n\t\trtp->f.subclass.integer = AST_CONTROL_FLASH;\n\t} else {\n\t\tast_debug_rtp(1, \"(%p) RTP creating %s DTMF Frame: %d (%c), at %s\\n\",\n\t\t\tinstance, type == AST_FRAME_DTMF_END ? \"END\" : \"BEGIN\",\n\t\t\trtp->resp, rtp->resp,\n\t\t\tast_sockaddr_stringify(&remote_address));\n\t\trtp->f.frametype = type;\n\t\trtp->f.subclass.integer = rtp->resp;\n\t}\n\trtp->f.datalen = 0;\n\trtp->f.samples = 0;\n\trtp->f.mallocd = 0;\n\trtp->f.src = \"RTP\";\n\tAST_LIST_NEXT(&rtp->f, frame_list) = NULL;\n\n\treturn &rtp->f;\n}\n\nstatic void process_dtmf_rfc2833(struct ast_rtp_instance *instance, unsigned char *data, int len, unsigned int seqno, unsigned int timestamp, int payloadtype, int mark, struct frame_list *frames)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tunsigned int event, event_end, samples;\n\tchar resp = 0;\n\tstruct ast_frame *f = NULL;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/* Figure out event, event end, and samples */\n\tevent = ntohl(*((unsigned int *)(data)));\n\tevent >>= 24;\n\tevent_end = ntohl(*((unsigned int *)(data)));\n\tevent_end <<= 8;\n\tevent_end >>= 24;\n\tsamples = ntohl(*((unsigned int *)(data)));\n\tsamples &= 0xFFFF;\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Got  RTP RFC2833 from   %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d, mark %d, event %08x, end %d, duration %-5.5u) \\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    payloadtype, seqno, timestamp, len, (mark?1:0), event, ((event_end & 0x80)?1:0), samples);\n\t}\n\n\t/* Print out debug if turned on */\n\tif (ast_debug_rtp_packet_is_allowed)\n\t\tast_debug(0, \"- RTP 2833 Event: %08x (len = %d)\\n\", event, len);\n\n\t/* Figure out what digit was pressed */\n\tif (event < 10) {\n\t\tresp = '0' + event;\n\t} else if (event < 11) {\n\t\tresp = '*';\n\t} else if (event < 12) {\n\t\tresp = '#';\n\t} else if (event < 16) {\n\t\tresp = 'A' + (event - 12);\n\t} else if (event < 17) {        /* Event 16: Hook flash */\n\t\tresp = 'X';\n\t} else {\n\t\t/* Not a supported event */\n\t\tast_debug_rtp(1, \"(%p) RTP ignoring RTP 2833 Event: %08x. Not a DTMF Digit.\\n\", instance, event);\n\t\treturn;\n\t}\n\n\tif (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE)) {\n\t\tif (!rtp->last_end_timestamp.is_set || rtp->last_end_timestamp.ts != timestamp || (rtp->resp && rtp->resp != resp)) {\n\t\t\trtp->resp = resp;\n\t\t\trtp->dtmf_timeout = 0;\n\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_END, ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE)));\n\t\t\tf->len = 0;\n\t\t\trtp->last_end_timestamp.ts = timestamp;\n\t\t\trtp->last_end_timestamp.is_set = 1;\n\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t}\n\t} else {\n\t\t/*  The duration parameter measures the complete\n\t\t    duration of the event (from the beginning) - RFC2833.\n\t\t    Account for the fact that duration is only 16 bits long\n\t\t    (about 8 seconds at 8000 Hz) and can wrap is digit\n\t\t    is hold for too long. */\n\t\tunsigned int new_duration = rtp->dtmf_duration;\n\t\tunsigned int last_duration = new_duration & 0xFFFF;\n\n\t\tif (last_duration > 64000 && samples < last_duration) {\n\t\t\tnew_duration += 0xFFFF + 1;\n\t\t}\n\t\tnew_duration = (new_duration & ~0xFFFF) | samples;\n\n\t\tif (event_end & 0x80) {\n\t\t\t/* End event */\n\t\t\tif (rtp->last_seqno != seqno && (!rtp->last_end_timestamp.is_set || timestamp > rtp->last_end_timestamp.ts)) {\n\t\t\t\trtp->last_end_timestamp.ts = timestamp;\n\t\t\t\trtp->last_end_timestamp.is_set = 1;\n\t\t\t\trtp->dtmf_duration = new_duration;\n\t\t\t\trtp->resp = resp;\n\t\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_END, 0));\n\t\t\t\tf->len = ast_tvdiff_ms(ast_samp2tv(rtp->dtmf_duration, ast_rtp_get_rate(f->subclass.format)), ast_tv(0, 0));\n\t\t\t\trtp->resp = 0;\n\t\t\t\trtp->dtmf_duration = rtp->dtmf_timeout = 0;\n\t\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t\t} else if (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP dropping duplicate or out of order DTMF END frame (seqno: %u, ts %u, digit %c)\\n\",\n\t\t\t\t\tinstance, seqno, timestamp, resp);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Begin/continuation */\n\n\t\t\t/* The second portion of the seqno check is to not mistakenly\n\t\t\t * stop accepting DTMF if the seqno rolls over beyond\n\t\t\t * 65535.\n\t\t\t */\n\t\t\tif ((rtp->last_seqno > seqno && rtp->last_seqno - seqno < 50)\n\t\t\t   || (rtp->last_end_timestamp.is_set\n\t\t\t\t  && timestamp <= rtp->last_end_timestamp.ts)) {\n\t\t\t\t/* Out of order frame. Processing this can cause us to\n\t\t\t\t * improperly duplicate incoming DTMF, so just drop\n\t\t\t\t * this.\n\t\t\t\t */\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\t\tast_debug(0, \"Dropping out of order DTMF frame (seqno %u, ts %u, digit %c)\\n\",\n\t\t\t\t\t\tseqno, timestamp, resp);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rtp->resp && rtp->resp != resp) {\n\t\t\t\t/* Another digit already began. End it */\n\t\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_END, 0));\n\t\t\t\tf->len = ast_tvdiff_ms(ast_samp2tv(rtp->dtmf_duration, ast_rtp_get_rate(f->subclass.format)), ast_tv(0, 0));\n\t\t\t\trtp->resp = 0;\n\t\t\t\trtp->dtmf_duration = rtp->dtmf_timeout = 0;\n\t\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t\t}\n\n\t\t\tif (rtp->resp) {\n\t\t\t\t/* Digit continues */\n\t\t\t\trtp->dtmf_duration = new_duration;\n\t\t\t} else {\n\t\t\t\t/* New digit began */\n\t\t\t\trtp->resp = resp;\n\t\t\t\tf = ast_frdup(create_dtmf_frame(instance, AST_FRAME_DTMF_BEGIN, 0));\n\t\t\t\trtp->dtmf_duration = samples;\n\t\t\t\tAST_LIST_INSERT_TAIL(frames, f, frame_list);\n\t\t\t}\n\n\t\t\trtp->dtmf_timeout = timestamp + rtp->dtmf_duration + dtmftimeout;\n\t\t}\n\n\t\trtp->last_seqno = seqno;\n\t}\n\n\trtp->dtmfsamples = samples;\n\n\treturn;\n}\n\nstatic struct ast_frame *process_dtmf_cisco(struct ast_rtp_instance *instance, unsigned char *data, int len, unsigned int seqno, unsigned int timestamp, int payloadtype, int mark)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tunsigned int event, flags, power;\n\tchar resp = 0;\n\tunsigned char seq;\n\tstruct ast_frame *f = NULL;\n\n\tif (len < 4) {\n\t\treturn NULL;\n\t}\n\n\t/*      The format of Cisco RTP DTMF packet looks like next:\n\t\t+0                              - sequence number of DTMF RTP packet (begins from 1,\n\t\t\t\t\t\t  wrapped to 0)\n\t\t+1                              - set of flags\n\t\t+1 (bit 0)              - flaps by different DTMF digits delimited by audio\n\t\t\t\t\t\t  or repeated digit without audio???\n\t\t+2 (+4,+6,...)  - power level? (rises from 0 to 32 at begin of tone\n\t\t\t\t\t\t  then falls to 0 at its end)\n\t\t+3 (+5,+7,...)  - detected DTMF digit (0..9,*,#,A-D,...)\n\t\tRepeated DTMF information (bytes 4/5, 6/7) is history shifted right\n\t\tby each new packet and thus provides some redundancy.\n\n\t\tSample of Cisco RTP DTMF packet is (all data in hex):\n\t\t\t19 07 00 02 12 02 20 02\n\t\tshowing end of DTMF digit '2'.\n\n\t\tThe packets\n\t\t\t27 07 00 02 0A 02 20 02\n\t\t\t28 06 20 02 00 02 0A 02\n\t\tshows begin of new digit '2' with very short pause (20 ms) after\n\t\tprevious digit '2'. Bit +1.0 flips at begin of new digit.\n\n\t\tCisco RTP DTMF packets comes as replacement of audio RTP packets\n\t\tso its uses the same sequencing and timestamping rules as replaced\n\t\taudio packets. Repeat interval of DTMF packets is 20 ms and not rely\n\t\ton audio framing parameters. Marker bit isn't used within stream of\n\t\tDTMFs nor audio stream coming immediately after DTMF stream. Timestamps\n\t\tare not sequential at borders between DTMF and audio streams,\n\t*/\n\n\tseq = data[0];\n\tflags = data[1];\n\tpower = data[2];\n\tevent = data[3] & 0x1f;\n\n\tif (ast_debug_rtp_packet_is_allowed)\n\t\tast_debug(0, \"Cisco DTMF Digit: %02x (len=%d, seq=%d, flags=%02x, power=%u, history count=%d)\\n\", event, len, seq, flags, power, (len - 4) / 2);\n\tif (event < 10) {\n\t\tresp = '0' + event;\n\t} else if (event < 11) {\n\t\tresp = '*';\n\t} else if (event < 12) {\n\t\tresp = '#';\n\t} else if (event < 16) {\n\t\tresp = 'A' + (event - 12);\n\t} else if (event < 17) {\n\t\tresp = 'X';\n\t}\n\tif ((!rtp->resp && power) || (rtp->resp && (rtp->resp != resp))) {\n\t\trtp->resp = resp;\n\t\t/* Why we should care on DTMF compensation at reception? */\n\t\tif (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE)) {\n\t\t\tf = create_dtmf_frame(instance, AST_FRAME_DTMF_BEGIN, 0);\n\t\t\trtp->dtmfsamples = 0;\n\t\t}\n\t} else if ((rtp->resp == resp) && !power) {\n\t\tf = create_dtmf_frame(instance, AST_FRAME_DTMF_END, ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_DTMF_COMPENSATE));\n\t\tf->samples = rtp->dtmfsamples * (ast_rtp_get_rate(rtp->lastrxformat) / 1000);\n\t\trtp->resp = 0;\n\t} else if (rtp->resp == resp) {\n\t\trtp->dtmfsamples += 20 * (ast_rtp_get_rate(rtp->lastrxformat) / 1000);\n\t}\n\n\trtp->dtmf_timeout = 0;\n\n\treturn f;\n}\n\nstatic struct ast_frame *process_cn_rfc3389(struct ast_rtp_instance *instance, unsigned char *data, int len, unsigned int seqno, unsigned int timestamp, int payloadtype, int mark)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* Convert comfort noise into audio with various codecs.  Unfortunately this doesn't\n\t   totally help us out because we don't have an engine to keep it going and we are not\n\t   guaranteed to have it every 20ms or anything */\n\tif (ast_debug_rtp_packet_is_allowed) {\n\t\tast_debug(0, \"- RTP 3389 Comfort noise event: Format %s (len = %d)\\n\",\n\t\t\tast_format_get_name(rtp->lastrxformat), len);\n\t}\n\n\tif (!ast_test_flag(rtp, FLAG_3389_WARNING)) {\n\t\tstruct ast_sockaddr remote_address = { {0,} };\n\n\t\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t\tast_log(LOG_NOTICE, \"Comfort noise support incomplete in Asterisk (RFC 3389). Please turn off on client if possible. Client address: %s\\n\",\n\t\t\tast_sockaddr_stringify(&remote_address));\n\t\tast_set_flag(rtp, FLAG_3389_WARNING);\n\t}\n\n\t/* Must have at least one byte */\n\tif (!len) {\n\t\treturn NULL;\n\t}\n\tif (len < 24) {\n\t\trtp->f.data.ptr = rtp->rawdata + AST_FRIENDLY_OFFSET;\n\t\trtp->f.datalen = len - 1;\n\t\trtp->f.offset = AST_FRIENDLY_OFFSET;\n\t\tmemcpy(rtp->f.data.ptr, data + 1, len - 1);\n\t} else {\n\t\trtp->f.data.ptr = NULL;\n\t\trtp->f.offset = 0;\n\t\trtp->f.datalen = 0;\n\t}\n\trtp->f.frametype = AST_FRAME_CNG;\n\trtp->f.subclass.integer = data[0] & 0x7f;\n\trtp->f.samples = 0;\n\trtp->f.delivery.tv_usec = rtp->f.delivery.tv_sec = 0;\n\n\treturn &rtp->f;\n}\n\nstatic int update_rtt_stats(struct ast_rtp *rtp, unsigned int lsr, unsigned int dlsr)\n{\n\tstruct timeval now;\n\tstruct timeval rtt_tv;\n\tunsigned int msw;\n\tunsigned int lsw;\n\tunsigned int rtt_msw;\n\tunsigned int rtt_lsw;\n\tunsigned int lsr_a;\n\tunsigned int rtt;\n\n\tgettimeofday(&now, NULL);\n\ttimeval2ntp(now, &msw, &lsw);\n\n\tlsr_a = ((msw & 0x0000ffff) << 16) | ((lsw & 0xffff0000) >> 16);\n\trtt = lsr_a - lsr - dlsr;\n\trtt_msw = (rtt & 0xffff0000) >> 16;\n\trtt_lsw = (rtt & 0x0000ffff);\n\trtt_tv.tv_sec = rtt_msw;\n\t/*\n\t * Convert 16.16 fixed point rtt_lsw to usec without\n\t * overflow.\n\t *\n\t * = rtt_lsw * 10^6 / 2^16\n\t * = rtt_lsw * (2^6 * 5^6) / 2^16\n\t * = rtt_lsw * 5^6 / 2^10\n\t *\n\t * The rtt_lsw value is in 16.16 fixed point format and 5^6\n\t * requires 14 bits to represent.  We have enough space to\n\t * directly do the conversion because there is no integer\n\t * component in rtt_lsw.\n\t */\n\trtt_tv.tv_usec = (rtt_lsw * 15625) >> 10;\n\trtp->rtcp->rtt = (double)rtt_tv.tv_sec + ((double)rtt_tv.tv_usec / 1000000);\n\tif (lsr_a - dlsr < lsr) {\n\t\treturn 1;\n\t}\n\n\trtp->rtcp->accumulated_transit += rtp->rtcp->rtt;\n\tif (rtp->rtcp->rtt_count == 0 || rtp->rtcp->minrtt > rtp->rtcp->rtt) {\n\t\trtp->rtcp->minrtt = rtp->rtcp->rtt;\n\t}\n\tif (rtp->rtcp->maxrtt < rtp->rtcp->rtt) {\n\t\trtp->rtcp->maxrtt = rtp->rtcp->rtt;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rtcp->rtt, &rtp->rtcp->normdevrtt,\n\t\t&rtp->rtcp->stdevrtt, &rtp->rtcp->rtt_count);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Update RTCP interarrival jitter stats\n */\nstatic void update_jitter_stats(struct ast_rtp *rtp, unsigned int ia_jitter)\n{\n\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\n\trtp->rtcp->reported_jitter = ast_samp2sec(ia_jitter, rate);\n\n\tif (rtp->rtcp->reported_jitter_count == 0) {\n\t\trtp->rtcp->reported_minjitter = rtp->rtcp->reported_jitter;\n\t}\n\tif (rtp->rtcp->reported_jitter < rtp->rtcp->reported_minjitter) {\n\t\trtp->rtcp->reported_minjitter = rtp->rtcp->reported_jitter;\n\t}\n\tif (rtp->rtcp->reported_jitter > rtp->rtcp->reported_maxjitter) {\n\t\trtp->rtcp->reported_maxjitter = rtp->rtcp->reported_jitter;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rtcp->reported_jitter,\n\t\t&rtp->rtcp->reported_normdev_jitter, &rtp->rtcp->reported_stdev_jitter,\n\t\t&rtp->rtcp->reported_jitter_count);\n}\n\n/*!\n * \\internal\n * \\brief Update RTCP lost packet stats\n */\nstatic void update_lost_stats(struct ast_rtp *rtp, unsigned int lost_packets)\n{\n\tdouble reported_lost;\n\n\trtp->rtcp->reported_lost = lost_packets;\n\treported_lost = (double)rtp->rtcp->reported_lost;\n\tif (rtp->rtcp->reported_lost_count == 0) {\n\t\trtp->rtcp->reported_minlost = reported_lost;\n\t}\n\tif (reported_lost < rtp->rtcp->reported_minlost) {\n\t\trtp->rtcp->reported_minlost = reported_lost;\n\t}\n\tif (reported_lost > rtp->rtcp->reported_maxlost) {\n\t\trtp->rtcp->reported_maxlost = reported_lost;\n\t}\n\n\tcalc_mean_and_standard_deviation(reported_lost, &rtp->rtcp->reported_normdev_lost,\n\t\t&rtp->rtcp->reported_stdev_lost, &rtp->rtcp->reported_lost_count);\n}\n\n#define RESCALE(in, inmin, inmax, outmin, outmax) ((((in - inmin)/(inmax-inmin))*(outmax-outmin))+outmin)\n/*!\n * \\brief Calculate a \"media experience score\" based on given data\n *\n * Technically, a mean opinion score (MOS) cannot be calculated without the involvement\n * of human eyes (video) and ears (audio). Thus instead we'll approximate an opinion\n * using the given parameters, and call it a media experience score.\n *\n * The tallied score is based upon recommendations and formulas from ITU-T G.107,\n * ITU-T G.109, ITU-T G.113, and other various internet sources.\n *\n * \\param instance RTP instance\n * \\param normdevrtt The average round trip time\n * \\param normdev_rxjitter The smoothed jitter\n * \\param stdev_rxjitter The jitter standard deviation value\n * \\param normdev_rxlost The average number of packets lost since last check\n *\n * \\return A media experience score.\n *\n * \\note The calculations in this function could probably be simplified\n * but calculating a MOS using the information available publicly,\n * then re-scaling it to 0.0 -> 100.0 makes the process clearer and\n * easier to troubleshoot or change.\n */\nstatic double calc_media_experience_score(struct ast_rtp_instance *instance,\n\tdouble normdevrtt, double normdev_rxjitter, double stdev_rxjitter,\n\tdouble normdev_rxlost)\n{\n\tdouble r_value;\n\tdouble pseudo_mos;\n\tdouble mes = 0;\n\n\t/*\n\t * While the media itself might be okay, a significant enough delay could make\n\t * for an unpleasant user experience.\n\t *\n\t * Calculate the effective latency by using the given round trip time, and adding\n\t * jitter scaled according to its standard deviation. The scaling is done in order\n\t * to increase jitter's weight since a higher deviation can result in poorer overall\n\t * quality.\n\t */\n\tdouble effective_latency = (normdevrtt * 1000)\n\t\t+ ((normdev_rxjitter * 2) * (stdev_rxjitter / 3))\n\t\t+ 10;\n\n\t/*\n\t * Using the defaults for the standard transmission rating factor (\"R\" value)\n\t * one arrives at 93.2 (see ITU-T G.107 for more details), so we'll use that\n\t * as the starting value and subtract deficiencies that could affect quality.\n\t *\n\t * Calculate the impact of the effective latency. Influence increases with\n\t * values over 160 as the significant \"lag\" can degrade user experience.\n\t */\n\tif (effective_latency < 160) {\n\t\tr_value = 93.2 - (effective_latency / 40);\n\t} else {\n\t\tr_value = 93.2 - (effective_latency - 120) / 10;\n\t}\n\n\t/* Next evaluate the impact of lost packets */\n\tr_value = r_value - (normdev_rxlost * 2.0);\n\n\t/*\n\t * Finally convert the \"R\" value into a opinion/quality score between 1 (really anything\n\t * below 3 should be considered poor) and 4.5 (the highest achievable for VOIP).\n\t */\n\tif (r_value < 0) {\n\t\tpseudo_mos = 1.0;\n\t} else if (r_value > 100) {\n\t\tpseudo_mos = 4.5;\n\t} else {\n\t\tpseudo_mos = 1 + (0.035 * r_value) + (r_value * (r_value - 60) * (100 - r_value) * 0.0000007);\n\t}\n\n\t/*\n\t * We're going to rescale the 0.0->5.0 pseudo_mos to the 0.0->100.0 MES.\n\t * For those ranges, we could actually just multiply the pseudo_mos\n\t * by 20 but we may want to change the scale later.\n\t */\n\tmes = RESCALE(pseudo_mos, 0.0, 5.0, 0.0, 100.0);\n\n\treturn mes;\n}\n\n/*!\n * \\internal\n * \\brief Update MES stats based on info received in an SR or RR.\n * This is RTP we sent and they received.\n */\nstatic void update_reported_mes_stats(struct ast_rtp *rtp)\n{\n\tdouble mes = calc_media_experience_score(rtp->owner,\n\t\trtp->rtcp->normdevrtt,\n\t\trtp->rtcp->reported_jitter,\n\t\trtp->rtcp->reported_stdev_jitter,\n\t\trtp->rtcp->reported_normdev_lost);\n\n\trtp->rtcp->reported_mes = mes;\n\tif (rtp->rtcp->reported_mes_count == 0) {\n\t\trtp->rtcp->reported_minmes = mes;\n\t}\n\tif (mes < rtp->rtcp->reported_minmes) {\n\t\trtp->rtcp->reported_minmes = mes;\n\t}\n\tif (mes > rtp->rtcp->reported_maxmes) {\n\t\trtp->rtcp->reported_maxmes = mes;\n\t}\n\n\tcalc_mean_and_standard_deviation(mes, &rtp->rtcp->reported_normdev_mes,\n\t\t&rtp->rtcp->reported_stdev_mes, &rtp->rtcp->reported_mes_count);\n\n\tast_debug_rtcp(2, \"%s: rtt: %.9f j: %.9f sjh: %.9f lost: %.9f mes: %4.1f\\n\",\n\t\tast_rtp_instance_get_channel_id(rtp->owner),\n\t\trtp->rtcp->normdevrtt,\n\t\t\t\trtp->rtcp->reported_jitter,\n\t\t\t\trtp->rtcp->reported_stdev_jitter,\n\t\t\t\trtp->rtcp->reported_normdev_lost, mes);\n}\n\n/*!\n * \\internal\n * \\brief Update MES stats based on info we will send in an SR or RR.\n * This is RTP they sent and we received.\n */\nstatic void update_local_mes_stats(struct ast_rtp *rtp)\n{\n\trtp->rxmes = calc_media_experience_score(rtp->owner,\n\t\trtp->rtcp->normdevrtt,\n\t\trtp->rxjitter,\n\t\trtp->rtcp->stdev_rxjitter,\n\t\trtp->rtcp->normdev_rxlost);\n\n\tif (rtp->rtcp->rxmes_count == 0) {\n\t\trtp->rtcp->minrxmes = rtp->rxmes;\n\t}\n\tif (rtp->rxmes < rtp->rtcp->minrxmes) {\n\t\trtp->rtcp->minrxmes = rtp->rxmes;\n\t}\n\tif (rtp->rxmes > rtp->rtcp->maxrxmes) {\n\t\trtp->rtcp->maxrxmes = rtp->rxmes;\n\t}\n\n\tcalc_mean_and_standard_deviation(rtp->rxmes, &rtp->rtcp->normdev_rxmes,\n\t\t&rtp->rtcp->stdev_rxmes, &rtp->rtcp->rxmes_count);\n\n\tast_debug_rtcp(2, \"   %s: rtt: %.9f j: %.9f sjh: %.9f lost: %.9f mes: %4.1f\\n\",\n\t\tast_rtp_instance_get_channel_id(rtp->owner),\n\t\trtp->rtcp->normdevrtt,\n\t\t\t\trtp->rxjitter,\n\t\t\t\trtp->rtcp->stdev_rxjitter,\n\t\t\t\trtp->rtcp->normdev_rxlost, rtp->rxmes);\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_rtp_instance *__rtp_find_instance_by_ssrc(struct ast_rtp_instance *instance,\n\tstruct ast_rtp *rtp, unsigned int ssrc, int source)\n{\n\tint index;\n\n\tif (!AST_VECTOR_SIZE(&rtp->ssrc_mapping)) {\n\t\t/* This instance is not bundled */\n\t\treturn instance;\n\t}\n\n\t/* Find the bundled child instance */\n\tfor (index = 0; index < AST_VECTOR_SIZE(&rtp->ssrc_mapping); ++index) {\n\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&rtp->ssrc_mapping, index);\n\t\tunsigned int mapping_ssrc = source ? ast_rtp_get_ssrc(mapping->instance) : mapping->ssrc;\n\n\t\tif (mapping->ssrc_valid && mapping_ssrc == ssrc) {\n\t\t\treturn mapping->instance;\n\t\t}\n\t}\n\n\t/* Does the SSRC match the bundled parent? */\n\tif (rtp->themssrc_valid && rtp->themssrc == ssrc) {\n\t\treturn instance;\n\t}\n\treturn NULL;\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_rtp_instance *rtp_find_instance_by_packet_source_ssrc(struct ast_rtp_instance *instance,\n\tstruct ast_rtp *rtp, unsigned int ssrc)\n{\n\treturn __rtp_find_instance_by_ssrc(instance, rtp, ssrc, 0);\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_rtp_instance *rtp_find_instance_by_media_source_ssrc(struct ast_rtp_instance *instance,\n\tstruct ast_rtp *rtp, unsigned int ssrc)\n{\n\treturn __rtp_find_instance_by_ssrc(instance, rtp, ssrc, 1);\n}\n\nstatic const char *rtcp_payload_type2str(unsigned int pt)\n{\n\tconst char *str;\n\n\tswitch (pt) {\n\tcase RTCP_PT_SR:\n\t\tstr = \"Sender Report\";\n\t\tbreak;\n\tcase RTCP_PT_RR:\n\t\tstr = \"Receiver Report\";\n\t\tbreak;\n\tcase RTCP_PT_FUR:\n\t\t/* Full INTRA-frame Request / Fast Update Request */\n\t\tstr = \"H.261 FUR\";\n\t\tbreak;\n\tcase RTCP_PT_PSFB:\n\t\t/* Payload Specific Feed Back */\n\t\tstr = \"PSFB\";\n\t\tbreak;\n\tcase RTCP_PT_SDES:\n\t\tstr = \"Source Description\";\n\t\tbreak;\n\tcase RTCP_PT_BYE:\n\t\tstr = \"BYE\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"Unknown\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic const char *rtcp_payload_subtype2str(unsigned int pt, unsigned int subtype)\n{\n\tswitch (pt) {\n\tcase AST_RTP_RTCP_RTPFB:\n\t\tif (subtype == AST_RTP_RTCP_FMT_NACK) {\n\t\t\treturn \"NACK\";\n\t\t}\n\t\tbreak;\n\tcase RTCP_PT_PSFB:\n\t\tif (subtype == AST_RTP_RTCP_FMT_REMB) {\n\t\t\treturn \"REMB\";\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_rtcp_handle_nack(struct ast_rtp_instance *instance, unsigned int *nackdata, unsigned int position,\n\tunsigned int length)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint res = 0;\n\tint blp_index;\n\tint packet_index;\n\tint ice;\n\tstruct ast_rtp_rtcp_nack_payload *payload;\n\tunsigned int current_word;\n\tunsigned int pid;\t/* Packet ID which refers to seqno of lost packet */\n\tunsigned int blp;\t/* Bitmask of following lost packets */\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint abs_send_time_id;\n\tunsigned int now_msw = 0;\n\tunsigned int now_lsw = 0;\n\tunsigned int packets_not_found = 0;\n\n\tif (!rtp->send_buffer) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP tried to handle NACK request, \"\n\t\t\t\"but we don't have a RTP packet storage!\\n\", instance);\n\t\treturn res;\n\t}\n\n\tabs_send_time_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_ABS_SEND_TIME);\n\tif (abs_send_time_id != -1) {\n\t\ttimeval2ntp(ast_tvnow(), &now_msw, &now_lsw);\n\t}\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\t/*\n\t * We use index 3 because with feedback messages, the FCI (Feedback Control Information)\n\t * does not begin until after the version, packet SSRC, and media SSRC words.\n\t */\n\tfor (packet_index = 3; packet_index < length; packet_index++) {\n\t\tcurrent_word = ntohl(nackdata[position + packet_index]);\n\t\tpid = current_word >> 16;\n\t\t/* We know the remote end is missing this packet. Go ahead and send it if we still have it. */\n\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_get(rtp->send_buffer, pid);\n\t\tif (payload) {\n\t\t\tif (abs_send_time_id != -1) {\n\t\t\t\t/* On retransmission we need to update the timestamp within the packet, as it\n\t\t\t\t * is supposed to contain when the packet was actually sent.\n\t\t\t\t */\n\t\t\t\tput_unaligned_time24(payload->buf + 17, now_msw, now_lsw);\n\t\t\t}\n\t\t\tres += rtp_sendto(instance, payload->buf, payload->size, 0, &remote_address, &ice);\n\t\t} else {\n\t\t\tast_debug_rtcp(1, \"(%p) RTCP received NACK request for RTP packet with seqno %d, \"\n\t\t\t\t\"but we don't have it\\n\", instance, pid);\n\t\t\tpackets_not_found++;\n\t\t}\n\t\t/*\n\t\t * The bitmask. Denoting the least significant bit as 1 and its most significant bit\n\t\t * as 16, then bit i of the bitmask is set to 1 if the receiver has not received RTP\n\t\t * packet (pid+i)(modulo 2^16). Otherwise, it is set to 0. We cannot assume bits set\n\t\t * to 0 after a bit set to 1 have actually been received.\n\t\t */\n\t\tblp = current_word & 0xffff;\n\t\tblp_index = 1;\n\t\twhile (blp) {\n\t\t\tif (blp & 1) {\n\t\t\t\t/* Packet (pid + i)(modulo 2^16) is missing too. */\n\t\t\t\tunsigned int seqno = (pid + blp_index) % 65536;\n\t\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_get(rtp->send_buffer, seqno);\n\t\t\t\tif (payload) {\n\t\t\t\t\tif (abs_send_time_id != -1) {\n\t\t\t\t\t\tput_unaligned_time24(payload->buf + 17, now_msw, now_lsw);\n\t\t\t\t\t}\n\t\t\t\t\tres += rtp_sendto(instance, payload->buf, payload->size, 0, &remote_address, &ice);\n\t\t\t\t} else {\n\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP remote end also requested RTP packet with seqno %d, \"\n\t\t\t\t\t\t\"but we don't have it\\n\", instance, seqno);\n\t\t\t\t\tpackets_not_found++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblp >>= 1;\n\t\t\tblp_index++;\n\t\t}\n\t}\n\n\tif (packets_not_found) {\n\t\t/* Grow the send buffer based on how many packets were not found in the buffer, but\n\t\t * enforce a maximum.\n\t\t */\n\t\tast_data_buffer_resize(rtp->send_buffer, MIN(MAXIMUM_RTP_SEND_BUFFER_SIZE,\n\t\t\tast_data_buffer_max(rtp->send_buffer) + packets_not_found));\n\t\tast_debug_rtcp(2, \"(%p) RTCP send buffer on RTP instance is now at maximum of %zu\\n\",\n\t\t\tinstance, ast_data_buffer_max(rtp->send_buffer));\n\t}\n\n\treturn res;\n}\n\n/*\n * Unshifted RTCP header bit field masks\n */\n#define RTCP_LENGTH_MASK\t\t\t0xFFFF\n#define RTCP_PAYLOAD_TYPE_MASK\t\t0xFF\n#define RTCP_REPORT_COUNT_MASK\t\t0x1F\n#define RTCP_PADDING_MASK\t\t\t0x01\n#define RTCP_VERSION_MASK\t\t\t0x03\n\n/*\n * RTCP header bit field shift offsets\n */\n#define RTCP_LENGTH_SHIFT\t\t\t0\n#define RTCP_PAYLOAD_TYPE_SHIFT\t\t16\n#define RTCP_REPORT_COUNT_SHIFT\t\t24\n#define RTCP_PADDING_SHIFT\t\t\t29\n#define RTCP_VERSION_SHIFT\t\t\t30\n\n#define RTCP_VERSION\t\t\t\t2U\n#define RTCP_VERSION_SHIFTED\t\t(RTCP_VERSION << RTCP_VERSION_SHIFT)\n#define RTCP_VERSION_MASK_SHIFTED\t(RTCP_VERSION_MASK << RTCP_VERSION_SHIFT)\n\n/*\n * RTCP first packet record validity header mask and value.\n *\n * RFC3550 intentionally defines the encoding of RTCP_PT_SR and RTCP_PT_RR\n * such that they differ in the least significant bit.  Either of these two\n * payload types MUST be the first RTCP packet record in a compound packet.\n *\n * RFC3550 checks the padding bit in the algorithm they use to check the\n * RTCP packet for validity.  However, we aren't masking the padding bit\n * to check since we don't know if it is a compound RTCP packet or not.\n */\n#define RTCP_VALID_MASK (RTCP_VERSION_MASK_SHIFTED | (((RTCP_PAYLOAD_TYPE_MASK & ~0x1)) << RTCP_PAYLOAD_TYPE_SHIFT))\n#define RTCP_VALID_VALUE (RTCP_VERSION_SHIFTED | (RTCP_PT_SR << RTCP_PAYLOAD_TYPE_SHIFT))\n\n#define RTCP_SR_BLOCK_WORD_LENGTH 5\n#define RTCP_RR_BLOCK_WORD_LENGTH 6\n#define RTCP_HEADER_SSRC_LENGTH   2\n#define RTCP_FB_REMB_BLOCK_WORD_LENGTH 4\n#define RTCP_FB_NACK_BLOCK_WORD_LENGTH 2\n\nstatic struct ast_frame *ast_rtcp_interpret(struct ast_rtp_instance *instance, struct ast_srtp *srtp,\n\tconst unsigned char *rtcpdata, size_t size, struct ast_sockaddr *addr)\n{\n\tstruct ast_rtp_instance *transport = instance;\n\tstruct ast_rtp *transport_rtp = ast_rtp_instance_get_data(instance);\n\tint len = size;\n\tunsigned int *rtcpheader = (unsigned int *)(rtcpdata);\n\tunsigned int packetwords;\n\tunsigned int position;\n\tunsigned int first_word;\n\t/*! True if we have seen an acceptable SSRC to learn the remote RTCP address */\n\tunsigned int ssrc_seen;\n\tstruct ast_rtp_rtcp_report_block *report_block;\n\tstruct ast_frame *f = &ast_null_frame;\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test_engine;\n#endif\n\n\t/* If this is encrypted then decrypt the payload */\n\tif ((*rtcpheader & 0xC0) && res_srtp && srtp && res_srtp->unprotect(\n\t\t    srtp, rtcpheader, &len, 1 | (srtp_replay_protection << 1)) < 0) {\n\t   return &ast_null_frame;\n\t}\n\n\tpacketwords = len / 4;\n\n\tast_debug_rtcp(2, \"(%s) RTCP got report of %d bytes from %s\\n\",\n\t\tast_rtp_instance_get_channel_id(instance),\n\t\tlen, ast_sockaddr_stringify(addr));\n\n\t/*\n\t * Validate the RTCP packet according to an adapted and slightly\n\t * modified RFC3550 validation algorithm.\n\t */\n\tif (packetwords < RTCP_HEADER_SSRC_LENGTH) {\n\t\tast_debug_rtcp(2, \"(%s) RTCP %p -- from %s: Frame size (%u words) is too short\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\ttransport_rtp, ast_sockaddr_stringify(addr), packetwords);\n\t\treturn &ast_null_frame;\n\t}\n\tposition = 0;\n\tfirst_word = ntohl(rtcpheader[position]);\n\tif ((first_word & RTCP_VALID_MASK) != RTCP_VALID_VALUE) {\n\t\tast_debug_rtcp(2, \"(%s) RTCP %p -- from %s: Failed first packet validity check\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\ttransport_rtp, ast_sockaddr_stringify(addr));\n\t\treturn &ast_null_frame;\n\t}\n\tdo {\n\t\tposition += ((first_word >> RTCP_LENGTH_SHIFT) & RTCP_LENGTH_MASK) + 1;\n\t\tif (packetwords <= position) {\n\t\t\tbreak;\n\t\t}\n\t\tfirst_word = ntohl(rtcpheader[position]);\n\t} while ((first_word & RTCP_VERSION_MASK_SHIFTED) == RTCP_VERSION_SHIFTED);\n\tif (position != packetwords) {\n\t\tast_debug_rtcp(2, \"(%s) RTCP %p -- from %s: Failed packet version or length check\\n\",\n\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\ttransport_rtp, ast_sockaddr_stringify(addr));\n\t\treturn &ast_null_frame;\n\t}\n\n\t/*\n\t * Note: RFC3605 points out that true NAT (vs NAPT) can cause RTCP\n\t * to have a different IP address and port than RTP.  Otherwise, when\n\t * strictrtp is enabled we could reject RTCP packets not coming from\n\t * the learned RTP IP address if it is available.\n\t */\n\n\t/*\n\t * strictrtp safety needs SSRC to match before we use the\n\t * sender's address for symmetrical RTP to send our RTCP\n\t * reports.\n\t *\n\t * If strictrtp is not enabled then claim to have already seen\n\t * a matching SSRC so we'll accept this packet's address for\n\t * symmetrical RTP.\n\t */\n\tssrc_seen = transport_rtp->strict_rtp_state == STRICT_RTP_OPEN;\n\n\tposition = 0;\n\twhile (position < packetwords) {\n\t\tunsigned int i;\n\t\tunsigned int pt;\n\t\tunsigned int rc;\n\t\tunsigned int ssrc;\n\t\t/*! True if the ssrc value we have is valid and not garbage because it doesn't exist. */\n\t\tunsigned int ssrc_valid;\n\t\tunsigned int length;\n\t\tunsigned int min_length;\n\t\t/*! Always use packet source SSRC to find the rtp instance unless explicitly told not to. */\n\t\tunsigned int use_packet_source = 1;\n\n\t\tstruct ast_json *message_blob;\n\t\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);\n\t\tstruct ast_rtp_instance *child;\n\t\tstruct ast_rtp *rtp;\n\t\tstruct ast_rtp_rtcp_feedback *feedback;\n\n\t\ti = position;\n\t\tfirst_word = ntohl(rtcpheader[i]);\n\t\tpt = (first_word >> RTCP_PAYLOAD_TYPE_SHIFT) & RTCP_PAYLOAD_TYPE_MASK;\n\t\trc = (first_word >> RTCP_REPORT_COUNT_SHIFT) & RTCP_REPORT_COUNT_MASK;\n\t\t/* RFC3550 says 'length' is the number of words in the packet - 1 */\n\t\tlength = ((first_word >> RTCP_LENGTH_SHIFT) & RTCP_LENGTH_MASK) + 1;\n\n\t\t/* Check expected RTCP packet record length */\n\t\tmin_length = RTCP_HEADER_SSRC_LENGTH;\n\t\tswitch (pt) {\n\t\tcase RTCP_PT_SR:\n\t\t\tmin_length += RTCP_SR_BLOCK_WORD_LENGTH;\n\t\t\t/* fall through */\n\t\tcase RTCP_PT_RR:\n\t\t\tmin_length += (rc * RTCP_RR_BLOCK_WORD_LENGTH);\n\t\t\tuse_packet_source = 0;\n\t\t\tbreak;\n\t\tcase RTCP_PT_FUR:\n\t\t\tbreak;\n\t\tcase AST_RTP_RTCP_RTPFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_NACK:\n\t\t\t\tmin_length += RTCP_FB_NACK_BLOCK_WORD_LENGTH;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuse_packet_source = 0;\n\t\t\tbreak;\n\t\tcase RTCP_PT_PSFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_REMB:\n\t\t\t\tmin_length += RTCP_FB_REMB_BLOCK_WORD_LENGTH;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTCP_PT_SDES:\n\t\tcase RTCP_PT_BYE:\n\t\t\t/*\n\t\t\t * There may not be a SSRC/CSRC present.  The packet is\n\t\t\t * useless but still valid if it isn't present.\n\t\t\t *\n\t\t\t * We don't know what min_length should be so disable the check\n\t\t\t */\n\t\t\tmin_length = length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tast_debug_rtcp(1, \"(%p) RTCP %p -- from %s: %u(%s) skipping record\\n\",\n\t\t\t\tinstance, transport_rtp, ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt));\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"\\n\");\n\t\t\t\tast_verbose(\"RTCP from %s: %u(%s) skipping record\\n\",\n\t\t\t\t\tast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt));\n\t\t\t}\n\t\t\tposition += length;\n\t\t\tcontinue;\n\t\t}\n\t\tif (length < min_length) {\n\t\t\tast_debug_rtcp(1, \"(%p) RTCP %p -- from %s: %u(%s) length field less than expected minimum.  Min:%u Got:%u\\n\",\n\t\t\t\tinstance, transport_rtp, ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt),\n\t\t\t\tmin_length - 1, length - 1);\n\t\t\treturn &ast_null_frame;\n\t\t}\n\n\t\t/* Get the RTCP record SSRC if defined for the record */\n\t\tssrc_valid = 1;\n\t\tswitch (pt) {\n\t\tcase RTCP_PT_SR:\n\t\tcase RTCP_PT_RR:\n\t\t\trtcp_report = ast_rtp_rtcp_report_alloc(rc);\n\t\t\tif (!rtcp_report) {\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\t\t\trtcp_report->reception_report_count = rc;\n\n\t\t\tssrc = ntohl(rtcpheader[i + 2]);\n\t\t\trtcp_report->ssrc = ssrc;\n\t\t\tbreak;\n\t\tcase RTCP_PT_FUR:\n\t\tcase RTCP_PT_PSFB:\n\t\t\tssrc = ntohl(rtcpheader[i + 1]);\n\t\t\tbreak;\n\t\tcase AST_RTP_RTCP_RTPFB:\n\t\t\tssrc = ntohl(rtcpheader[i + 2]);\n\t\t\tbreak;\n\t\tcase RTCP_PT_SDES:\n\t\tcase RTCP_PT_BYE:\n\t\tdefault:\n\t\t\tssrc = 0;\n\t\t\tssrc_valid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\tconst char *subtype = rtcp_payload_subtype2str(pt, rc);\n\n\t\t\tast_verbose(\"\\n\");\n\t\t\tast_verbose(\"RTCP from %s\\n\", ast_sockaddr_stringify(addr));\n\t\t\tast_verbose(\"PT: %u (%s)\\n\", pt, rtcp_payload_type2str(pt));\n\t\t\tif (subtype) {\n\t\t\t\tast_verbose(\"Packet Subtype: %u (%s)\\n\", rc, subtype);\n\t\t\t} else {\n\t\t\t\tast_verbose(\"Reception reports: %u\\n\", rc);\n\t\t\t}\n\t\t\tast_verbose(\"SSRC of sender: %u\\n\", ssrc);\n\t\t}\n\n\t\t/* Determine the appropriate instance for this */\n\t\tif (ssrc_valid) {\n\t\t\t/*\n\t\t\t * Depending on the payload type, either the packet source or media source\n\t\t\t * SSRC is used.\n\t\t\t */\n\t\t\tif (use_packet_source) {\n\t\t\t\tchild = rtp_find_instance_by_packet_source_ssrc(transport, transport_rtp, ssrc);\n\t\t\t} else {\n\t\t\t\tchild = rtp_find_instance_by_media_source_ssrc(transport, transport_rtp, ssrc);\n\t\t\t}\n\t\t\tif (child && child != transport) {\n\t\t\t\t/*\n\t\t\t\t * It is safe to hold the child lock while holding the parent lock.\n\t\t\t\t * We guarantee that the locking order is always parent->child or\n\t\t\t\t * that the child lock is not held when acquiring the parent lock.\n\t\t\t\t */\n\t\t\t\tao2_lock(child);\n\t\t\t\tinstance = child;\n\t\t\t\trtp = ast_rtp_instance_get_data(instance);\n\t\t\t} else {\n\t\t\t\t/* The child is the parent! We don't need to unlock it. */\n\t\t\t\tchild = NULL;\n\t\t\t\trtp = transport_rtp;\n\t\t\t}\n\t\t} else {\n\t\t\tchild = NULL;\n\t\t\trtp = transport_rtp;\n\t\t}\n\n\t\tif (ssrc_valid && rtp->themssrc_valid) {\n\t\t\t/*\n\t\t\t * If the SSRC is 1, we still need to handle RTCP since this could be a\n\t\t\t * special case. For example, if we have a unidirectional video stream, the\n\t\t\t * SSRC may be set to 1 by the browser (in the case of chromium), and requests\n\t\t\t * will still need to be processed so that video can flow as expected. This\n\t\t\t * should only be done for PLI and FUR, since there is not a way to get the\n\t\t\t * appropriate rtp instance when the SSRC is 1.\n\t\t\t */\n\t\t\tint exception = (ssrc == 1 && !((pt == RTCP_PT_PSFB && rc == AST_RTP_RTCP_FMT_PLI) || pt == RTCP_PT_FUR));\n\t\t\tif ((ssrc != rtp->themssrc && use_packet_source && ssrc != 1)\n\t\t\t\t\t|| exception) {\n\t\t\t\t/*\n\t\t\t\t * Skip over this RTCP record as it does not contain the\n\t\t\t\t * correct SSRC.  We should not act upon RTCP records\n\t\t\t\t * for a different stream.\n\t\t\t\t */\n\t\t\t\tposition += length;\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP %p -- from %s: Skipping record, received SSRC '%u' != expected '%u'\\n\",\n\t\t\t\t\tinstance, rtp, ast_sockaddr_stringify(addr), ssrc, rtp->themssrc);\n\t\t\t\tif (child) {\n\t\t\t\t\tao2_unlock(child);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tssrc_seen = 1;\n\t\t}\n\n\t\tif (ssrc_seen && ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {\n\t\t\t/* Send to whoever sent to us */\n\t\t\tif (ast_sockaddr_cmp(&rtp->rtcp->them, addr)) {\n\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, addr);\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\t\tast_debug(0, \"(%p) RTCP NAT: Got RTCP from other end. Now sending to address %s\\n\",\n\t\t\t\t\t\tinstance, ast_sockaddr_stringify(addr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti += RTCP_HEADER_SSRC_LENGTH; /* Advance past header and ssrc */\n\t\tswitch (pt) {\n\t\tcase RTCP_PT_SR:\n\t\t\tgettimeofday(&rtp->rtcp->rxlsr, NULL);\n\t\t\trtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16);\n\t\t\trtp->rtcp->spc = ntohl(rtcpheader[i + 3]);\n\t\t\trtp->rtcp->soc = ntohl(rtcpheader[i + 4]);\n\n\t\t\trtcp_report->type = RTCP_PT_SR;\n\t\t\trtcp_report->sender_information.packet_count = rtp->rtcp->spc;\n\t\t\trtcp_report->sender_information.octet_count = rtp->rtcp->soc;\n\t\t\tntp2timeval((unsigned int)ntohl(rtcpheader[i]),\n\t\t\t\t\t(unsigned int)ntohl(rtcpheader[i + 1]),\n\t\t\t\t\t&rtcp_report->sender_information.ntp_timestamp);\n\t\t\trtcp_report->sender_information.rtp_timestamp = ntohl(rtcpheader[i + 2]);\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"NTP timestamp: %u.%06u\\n\",\n\t\t\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,\n\t\t\t\t\t\t(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);\n\t\t\t\tast_verbose(\"RTP timestamp: %u\\n\", rtcp_report->sender_information.rtp_timestamp);\n\t\t\t\tast_verbose(\"SPC: %u\\tSOC: %u\\n\",\n\t\t\t\t\t\trtcp_report->sender_information.packet_count,\n\t\t\t\t\t\trtcp_report->sender_information.octet_count);\n\t\t\t}\n\t\t\ti += RTCP_SR_BLOCK_WORD_LENGTH;\n\t\t\t/* Intentional fall through */\n\t\tcase RTCP_PT_RR:\n\t\t\tif (rtcp_report->type != RTCP_PT_SR) {\n\t\t\t\trtcp_report->type = RTCP_PT_RR;\n\t\t\t}\n\n\t\t\tif (rc > 0) {\n\t\t\t\t/* Don't handle multiple reception reports (rc > 1) yet */\n\t\t\t\treport_block = ast_calloc(1, sizeof(*report_block));\n\t\t\t\tif (!report_block) {\n\t\t\t\t\tif (child) {\n\t\t\t\t\t\tao2_unlock(child);\n\t\t\t\t\t}\n\t\t\t\t\treturn &ast_null_frame;\n\t\t\t\t}\n\t\t\t\trtcp_report->report_block[0] = report_block;\n\t\t\t\treport_block->source_ssrc = ntohl(rtcpheader[i]);\n\t\t\t\treport_block->lost_count.packets = ntohl(rtcpheader[i + 1]) & 0x00ffffff;\n\t\t\t\treport_block->lost_count.fraction = ((ntohl(rtcpheader[i + 1]) & 0xff000000) >> 24);\n\t\t\t\treport_block->highest_seq_no = ntohl(rtcpheader[i + 2]);\n\t\t\t\treport_block->ia_jitter =  ntohl(rtcpheader[i + 3]);\n\t\t\t\treport_block->lsr = ntohl(rtcpheader[i + 4]);\n\t\t\t\treport_block->dlsr = ntohl(rtcpheader[i + 5]);\n\t\t\t\tif (report_block->lsr) {\n\t\t\t\t\tint skewed = update_rtt_stats(rtp, report_block->lsr, report_block->dlsr);\n\t\t\t\t\tif (skewed && rtcp_debug_test_addr(addr)) {\n\t\t\t\t\t\tstruct timeval now;\n\t\t\t\t\t\tunsigned int lsr_now, lsw, msw;\n\t\t\t\t\t\tgettimeofday(&now, NULL);\n\t\t\t\t\t\ttimeval2ntp(now, &msw, &lsw);\n\t\t\t\t\t\tlsr_now = (((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16));\n\t\t\t\t\t\tast_verbose(\"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t\t\t\t\"lsr=%u, now=%u, dlsr=%u (%u:%03ums), \"\n\t\t\t\t\t\t\t\"diff=%u\\n\",\n\t\t\t\t\t\t\treport_block->lsr, lsr_now, report_block->dlsr, report_block->dlsr / 65536,\n\t\t\t\t\t\t\t(report_block->dlsr % 65536) * 1000 / 65536,\n\t\t\t\t\t\t\treport_block->dlsr - (lsr_now - report_block->lsr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tupdate_jitter_stats(rtp, report_block->ia_jitter);\n\t\t\t\tupdate_lost_stats(rtp, report_block->lost_count.packets);\n\t\t\t\t/*\n\t\t\t\t * update_reported_mes_stats must be called AFTER\n\t\t\t\t * update_rtt_stats, update_jitter_stats and\n\t\t\t\t * update_lost_stats.\n\t\t\t\t */\n\t\t\t\tupdate_reported_mes_stats(rtp);\n\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tint rate = ast_rtp_get_rate(rtp->f.subclass.format);\n\n\t\t\t\t\tast_verbose(\"  Fraction lost: %d\\n\", report_block->lost_count.fraction);\n\t\t\t\t\tast_verbose(\"  Packets lost so far: %u\\n\", report_block->lost_count.packets);\n\t\t\t\t\tast_verbose(\"  Highest sequence number: %u\\n\", report_block->highest_seq_no & 0x0000ffff);\n\t\t\t\t\tast_verbose(\"  Sequence number cycles: %u\\n\", report_block->highest_seq_no >> 16);\n\t\t\t\t\tast_verbose(\"  Interarrival jitter (samp): %u\\n\", report_block->ia_jitter);\n\t\t\t\t\tast_verbose(\"  Interarrival jitter (secs): %.6f\\n\", ast_samp2sec(report_block->ia_jitter, rate));\n\t\t\t\t\tast_verbose(\"  Last SR(our NTP): %lu.%010lu\\n\",(unsigned long)(report_block->lsr) >> 16,((unsigned long)(report_block->lsr) << 16) * 4096);\n\t\t\t\t\tast_verbose(\"  DLSR: %4.4f (sec)\\n\",(double)report_block->dlsr / 65536.0);\n\t\t\t\t\tast_verbose(\"  RTT: %4.4f(sec)\\n\", rtp->rtcp->rtt);\n\t\t\t\t\tast_verbose(\"  MES: %4.1f\\n\", rtp->rtcp->reported_mes);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If and when we handle more than one report block, this should occur outside\n\t\t\t * this loop.\n\t\t\t */\n\n\t\t\tmessage_blob = ast_json_pack(\"{s: s, s: s, s: f, s: f}\",\n\t\t\t\t\"from\", ast_sockaddr_stringify(addr),\n\t\t\t\t\"to\", transport_rtp->rtcp->local_addr_str,\n\t\t\t\t\"rtt\", rtp->rtcp->rtt,\n\t\t\t\t\"mes\", rtp->rtcp->reported_mes);\n\t\t\tast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_received_type(),\n\t\t\t\t\trtcp_report,\n\t\t\t\t\tmessage_blob);\n\t\t\tast_json_unref(message_blob);\n\n\t\t\t/* Return an AST_FRAME_RTCP frame with the ast_rtp_rtcp_report\n\t\t\t * object as a its data */\n\t\t\ttransport_rtp->f.frametype = AST_FRAME_RTCP;\n\t\t\ttransport_rtp->f.subclass.integer = pt;\n\t\t\ttransport_rtp->f.data.ptr = rtp->rtcp->frame_buf + AST_FRIENDLY_OFFSET;\n\t\t\tmemcpy(transport_rtp->f.data.ptr, rtcp_report, sizeof(struct ast_rtp_rtcp_report));\n\t\t\ttransport_rtp->f.datalen = sizeof(struct ast_rtp_rtcp_report);\n\t\t\tif (rc > 0) {\n\t\t\t\t/* There's always a single report block stored, here */\n\t\t\t\tstruct ast_rtp_rtcp_report *rtcp_report2;\n\t\t\t\treport_block = transport_rtp->f.data.ptr + transport_rtp->f.datalen + sizeof(struct ast_rtp_rtcp_report_block *);\n\t\t\t\tmemcpy(report_block, rtcp_report->report_block[0], sizeof(struct ast_rtp_rtcp_report_block));\n\t\t\t\trtcp_report2 = (struct ast_rtp_rtcp_report *)transport_rtp->f.data.ptr;\n\t\t\t\trtcp_report2->report_block[0] = report_block;\n\t\t\t\ttransport_rtp->f.datalen += sizeof(struct ast_rtp_rtcp_report_block);\n\t\t\t}\n\t\t\ttransport_rtp->f.offset = AST_FRIENDLY_OFFSET;\n\t\t\ttransport_rtp->f.samples = 0;\n\t\t\ttransport_rtp->f.mallocd = 0;\n\t\t\ttransport_rtp->f.delivery.tv_sec = 0;\n\t\t\ttransport_rtp->f.delivery.tv_usec = 0;\n\t\t\ttransport_rtp->f.src = \"RTP\";\n\t\t\ttransport_rtp->f.stream_num = rtp->stream_num;\n\t\t\tf = &transport_rtp->f;\n\t\t\tbreak;\n\t\tcase AST_RTP_RTCP_RTPFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_NACK:\n\t\t\t\t/* If retransmissions are not enabled ignore this message */\n\t\t\t\tif (!rtp->send_buffer) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tast_verbose(\"Received generic RTCP NACK message\\n\");\n\t\t\t\t}\n\n\t\t\t\tast_rtp_rtcp_handle_nack(instance, rtcpheader, position, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTCP_PT_FUR:\n\t\t\t/* Handle RTCP FUR as FIR by setting the format to 4 */\n\t\t\trc = AST_RTP_RTCP_FMT_FIR;\n\t\tcase RTCP_PT_PSFB:\n\t\t\tswitch (rc) {\n\t\t\tcase AST_RTP_RTCP_FMT_PLI:\n\t\t\tcase AST_RTP_RTCP_FMT_FIR:\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tast_verbose(\"Received an RTCP Fast Update Request\\n\");\n\t\t\t\t}\n\t\t\t\ttransport_rtp->f.frametype = AST_FRAME_CONTROL;\n\t\t\t\ttransport_rtp->f.subclass.integer = AST_CONTROL_VIDUPDATE;\n\t\t\t\ttransport_rtp->f.datalen = 0;\n\t\t\t\ttransport_rtp->f.samples = 0;\n\t\t\t\ttransport_rtp->f.mallocd = 0;\n\t\t\t\ttransport_rtp->f.src = \"RTP\";\n\t\t\t\tf = &transport_rtp->f;\n\t\t\t\tbreak;\n\t\t\tcase AST_RTP_RTCP_FMT_REMB:\n\t\t\t\t/* If REMB support is not enabled ignore this message */\n\t\t\t\tif (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_REMB)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\t\tast_verbose(\"Received REMB report\\n\");\n\t\t\t\t}\n\t\t\t\ttransport_rtp->f.frametype = AST_FRAME_RTCP;\n\t\t\t\ttransport_rtp->f.subclass.integer = pt;\n\t\t\t\ttransport_rtp->f.stream_num = rtp->stream_num;\n\t\t\t\ttransport_rtp->f.data.ptr = rtp->rtcp->frame_buf + AST_FRIENDLY_OFFSET;\n\t\t\t\tfeedback = transport_rtp->f.data.ptr;\n\t\t\t\tfeedback->fmt = rc;\n\n\t\t\t\t/* We don't actually care about the SSRC information in the feedback message */\n\t\t\t\tfirst_word = ntohl(rtcpheader[i + 2]);\n\t\t\t\tfeedback->remb.br_exp = (first_word >> 18) & ((1 << 6) - 1);\n\t\t\t\tfeedback->remb.br_mantissa = first_word & ((1 << 18) - 1);\n\n\t\t\t\ttransport_rtp->f.datalen = sizeof(struct ast_rtp_rtcp_feedback);\n\t\t\t\ttransport_rtp->f.offset = AST_FRIENDLY_OFFSET;\n\t\t\t\ttransport_rtp->f.samples = 0;\n\t\t\t\ttransport_rtp->f.mallocd = 0;\n\t\t\t\ttransport_rtp->f.delivery.tv_sec = 0;\n\t\t\t\ttransport_rtp->f.delivery.tv_usec = 0;\n\t\t\t\ttransport_rtp->f.src = \"RTP\";\n\t\t\t\tf = &transport_rtp->f;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTCP_PT_SDES:\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"Received an SDES from %s\\n\",\n\t\t\t\t\tast_sockaddr_stringify(addr));\n\t\t\t}\n#ifdef TEST_FRAMEWORK\n\t\t\tif ((test_engine = ast_rtp_instance_get_test(instance))) {\n\t\t\t\ttest_engine->sdes_received = 1;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase RTCP_PT_BYE:\n\t\t\tif (rtcp_debug_test_addr(addr)) {\n\t\t\t\tast_verbose(\"Received a BYE from %s\\n\",\n\t\t\t\t\tast_sockaddr_stringify(addr));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tposition += length;\n\t\trtp->rtcp->rtcp_info = 1;\n\n\t\tif (child) {\n\t\t\tao2_unlock(child);\n\t\t}\n\t}\n\n\treturn f;\n}\n\n/*! \\pre instance is locked */\nstatic struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_srtp *srtp = ast_rtp_instance_get_srtp(instance, 1);\n\tstruct ast_sockaddr addr;\n\tunsigned char rtcpdata[8192 + AST_FRIENDLY_OFFSET];\n\tunsigned char *read_area = rtcpdata + AST_FRIENDLY_OFFSET;\n\tsize_t read_area_size = sizeof(rtcpdata) - AST_FRIENDLY_OFFSET;\n\tint res;\n\n\t/* Read in RTCP data from the socket */\n\tif ((res = rtcp_recvfrom(instance, read_area, read_area_size,\n\t\t\t\t0, &addr)) < 0) {\n\t\tif (res == RTP_DTLS_ESTABLISHED) {\n\t\t\trtp->f.frametype = AST_FRAME_CONTROL;\n\t\t\trtp->f.subclass.integer = AST_CONTROL_SRCCHANGE;\n\t\t\treturn &rtp->f;\n\t\t}\n\n\t\tast_assert(errno != EBADF);\n\t\tif (errno != EAGAIN) {\n\t\t\tast_log(LOG_WARNING, \"RTCP Read error: %s.  Hanging up.\\n\",\n\t\t\t\t(errno) ? strerror(errno) : \"Unspecified\");\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If this was handled by the ICE session don't do anything further */\n\tif (!res) {\n\t\treturn &ast_null_frame;\n\t}\n\n\tif (!*read_area) {\n\t\tstruct sockaddr_in addr_tmp;\n\t\tstruct ast_sockaddr addr_v4;\n\n\t\tif (ast_sockaddr_is_ipv4(&addr)) {\n\t\t\tast_sockaddr_to_sin(&addr, &addr_tmp);\n\t\t} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {\n\t\t\tast_debug_stun(2, \"(%p) STUN using IPv6 mapped address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\tast_sockaddr_to_sin(&addr_v4, &addr_tmp);\n\t\t} else {\n\t\t\tast_debug_stun(2, \"(%p) STUN cannot do for non IPv4 address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\treturn &ast_null_frame;\n\t\t}\n\t\tif ((ast_stun_handle_packet(rtp->rtcp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT)) {\n\t\t\tast_sockaddr_from_sin(&addr, &addr_tmp);\n\t\t\tast_sockaddr_copy(&rtp->rtcp->them, &addr);\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\treturn ast_rtcp_interpret(instance, srtp, read_area, res, &addr);\n}\n\n/*! \\pre instance is locked */\nstatic int bridge_p2p_rtp_write(struct ast_rtp_instance *instance,\n\tstruct ast_rtp_instance *instance1, unsigned int *rtpheader, int len, int hdrlen)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp *bridged;\n\tint res = 0, payload = 0, bridged_payload = 0, mark;\n\tRAII_VAR(struct ast_rtp_payload_type *, payload_type, NULL, ao2_cleanup);\n\tint reconstruct = ntohl(rtpheader[0]);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint ice;\n\tunsigned int timestamp = ntohl(rtpheader[1]);\n\n\t/* Get fields from packet */\n\tpayload = (reconstruct & 0x7f0000) >> 16;\n\tmark = (reconstruct & 0x800000) >> 23;\n\n\t/* Check what the payload value should be */\n\tpayload_type = ast_rtp_codecs_get_payload(ast_rtp_instance_get_codecs(instance), payload);\n\tif (!payload_type) {\n\t\treturn -1;\n\t}\n\n\t/* Otherwise adjust bridged payload to match */\n\tbridged_payload = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance1),\n\t\tpayload_type->asterisk_format, payload_type->format, payload_type->rtp_code);\n\n\t/* If no codec could be matched between instance and instance1, then somehow things were made incompatible while we were still bridged.  Bail. */\n\tif (bridged_payload < 0) {\n\t\treturn -1;\n\t}\n\n\t/* If the payload coming in is not one of the negotiated ones then send it to the core, this will cause formats to change and the bridge to break */\n\tif (ast_rtp_codecs_find_payload_code(ast_rtp_instance_get_codecs(instance1), bridged_payload) == -1) {\n\t\tast_debug_rtp(1, \"(%p, %p) RTP unsupported payload type received\\n\", instance, instance1);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Even if we are no longer in dtmf, we could still be receiving\n\t * re-transmissions of the last dtmf end still.  Feed those to the\n\t * core so they can be filtered accordingly.\n\t */\n\tif (rtp->last_end_timestamp.is_set && rtp->last_end_timestamp.ts == timestamp) {\n\t\tast_debug_rtp(1, \"(%p, %p) RTP feeding packet with duplicate timestamp to core\\n\", instance, instance1);\n\t\treturn -1;\n\t}\n\n\tif (payload_type->asterisk_format) {\n\t\tao2_replace(rtp->lastrxformat, payload_type->format);\n\t}\n\n\t/*\n\t * We have now determined that we need to send the RTP packet\n\t * out the bridged instance to do local bridging so we must unlock\n\t * the receiving instance to prevent deadlock with the bridged\n\t * instance.\n\t *\n\t * Technically we should grab a ref to instance1 so it won't go\n\t * away on us.  However, we should be safe because the bridged\n\t * instance won't change without both channels involved being\n\t * locked and we currently have the channel lock for the receiving\n\t * instance.\n\t */\n\tao2_unlock(instance);\n\tao2_lock(instance1);\n\n\t/*\n\t * Get the peer rtp pointer now to emphasize that using it\n\t * must happen while instance1 is locked.\n\t */\n\tbridged = ast_rtp_instance_get_data(instance1);\n\n\n\t/* If bridged peer is in dtmf, feed all packets to core until it finishes to avoid infinite dtmf */\n\tif (bridged->sending_digit) {\n\t\tast_debug_rtp(1, \"(%p, %p) RTP Feeding packet to core until DTMF finishes\\n\", instance, instance1);\n\t\tao2_unlock(instance1);\n\t\tao2_lock(instance);\n\t\treturn -1;\n\t}\n\n\tif (payload_type->asterisk_format) {\n\t\t/*\n\t\t * If bridged peer has already received rtp, perform the asymmetric codec check\n\t\t * if that feature has been activated\n\t\t */\n\t\tif (!bridged->asymmetric_codec\n\t\t\t&& bridged->lastrxformat != ast_format_none\n\t\t\t&& ast_format_cmp(payload_type->format, bridged->lastrxformat) == AST_FORMAT_CMP_NOT_EQUAL) {\n\t\t\tast_debug_rtp(1, \"(%p, %p) RTP asymmetric RTP codecs detected (TX: %s, RX: %s) sending frame to core\\n\",\n\t\t\t\tinstance, instance1, ast_format_get_name(payload_type->format),\n\t\t\t\tast_format_get_name(bridged->lastrxformat));\n\t\t\tao2_unlock(instance1);\n\t\t\tao2_lock(instance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tao2_replace(bridged->lasttxformat, payload_type->format);\n\t}\n\n\tast_rtp_instance_get_remote_address(instance1, &remote_address);\n\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\tast_debug_rtp(5, \"(%p, %p) RTP remote address is null, most likely RTP has been stopped\\n\",\n\t\t\tinstance, instance1);\n\t\tao2_unlock(instance1);\n\t\tao2_lock(instance);\n\t\treturn 0;\n\t}\n\n\t/* If the marker bit has been explicitly set turn it on */\n\tif (ast_test_flag(bridged, FLAG_NEED_MARKER_BIT)) {\n\t\tmark = 1;\n\t\tast_clear_flag(bridged, FLAG_NEED_MARKER_BIT);\n\t}\n\n\t/* Set the marker bit for the first local bridged packet which has the first bridged peer's SSRC. */\n\tif (ast_test_flag(bridged, FLAG_REQ_LOCAL_BRIDGE_BIT)) {\n\t\tmark = 1;\n\t\tast_clear_flag(bridged, FLAG_REQ_LOCAL_BRIDGE_BIT);\n\t}\n\n\t/* Reconstruct part of the packet */\n\treconstruct &= 0xFF80FFFF;\n\treconstruct |= (bridged_payload << 16);\n\treconstruct |= (mark << 23);\n\trtpheader[0] = htonl(reconstruct);\n\n\tif (mark) {\n\t\t/* make this rtp instance aware of the new ssrc it is sending */\n\t\tbridged->ssrc = ntohl(rtpheader[2]);\n\t}\n\n\t/* Send the packet back out */\n\tres = rtp_sendto(instance1, (void *)rtpheader, len, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tif (!ast_rtp_instance_get_prop(instance1, AST_RTP_PROPERTY_NAT) || (ast_rtp_instance_get_prop(instance1, AST_RTP_PROPERTY_NAT) && (ast_test_flag(bridged, FLAG_NAT_ACTIVE) == FLAG_NAT_ACTIVE))) {\n\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\"RTP Transmission error of packet to %s: %s\\n\",\n\t\t\t\tast_sockaddr_stringify(&remote_address),\n\t\t\t\tstrerror(errno));\n\t\t} else if (((ast_test_flag(bridged, FLAG_NAT_ACTIVE) == FLAG_NAT_INACTIVE) || ast_debug_rtp_packet_is_allowed) && !ast_test_flag(bridged, FLAG_NAT_INACTIVE_NOWARN)) {\n\t\t\tif (ast_debug_rtp_packet_is_allowed || DEBUG_ATLEAST(1)) {\n\t\t\t\tast_log(LOG_WARNING,\n\t\t\t\t\t\"RTP NAT: Can't write RTP to private \"\n\t\t\t\t\t\"address %s, waiting for other end to \"\n\t\t\t\t\t\"send audio...\\n\",\n\t\t\t\t\tast_sockaddr_stringify(&remote_address));\n\t\t\t}\n\t\t\tast_set_flag(bridged, FLAG_NAT_INACTIVE_NOWARN);\n\t\t}\n\t\tao2_unlock(instance1);\n\t\tao2_lock(instance);\n\t\treturn 0;\n\t}\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Sent RTP P2P packet to %s%s (type %-2.2d, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t    bridged_payload, len - hdrlen);\n\t}\n\n\tao2_unlock(instance1);\n\tao2_lock(instance);\n\treturn 0;\n}\n\nstatic void rtp_instance_unlock(struct ast_rtp_instance *instance)\n{\n\tif (instance) {\n\t\tao2_unlock(instance);\n\t}\n}\n\nstatic int rtp_transport_wide_cc_packet_statistics_cmp(struct rtp_transport_wide_cc_packet_statistics a,\n\tstruct rtp_transport_wide_cc_packet_statistics b)\n{\n\treturn a.seqno - b.seqno;\n}\n\nstatic void rtp_transport_wide_cc_feedback_status_vector_append(unsigned char *rtcpheader, int *packet_len, int *status_vector_chunk_bits,\n\tuint16_t *status_vector_chunk, int status)\n{\n\t/* Appending this status will use up 2 bits */\n\t*status_vector_chunk_bits -= 2;\n\n\t/* We calculate which bits we want to update the status of. Since a status vector\n\t * is 16 bits we take away 2 (for the header), and then we take away any that have\n\t * already been used.\n\t */\n\t*status_vector_chunk |= (status << (16 - 2 - (14 - *status_vector_chunk_bits)));\n\n\t/* If there are still bits available we can return early */\n\tif (*status_vector_chunk_bits) {\n\t\treturn;\n\t}\n\n\t/* Otherwise we have to place this chunk into the packet */\n\tput_unaligned_uint16(rtcpheader + *packet_len, htons(*status_vector_chunk));\n\t*status_vector_chunk_bits = 14;\n\n\t/* The first bit being 1 indicates that this is a status vector chunk and the second\n\t * bit being 1 indicates that we are using 2 bits to represent each status for a\n\t * packet.\n\t */\n\t*status_vector_chunk = (1 << 15) | (1 << 14);\n\t*packet_len += 2;\n}\n\nstatic void rtp_transport_wide_cc_feedback_status_append(unsigned char *rtcpheader, int *packet_len, int *status_vector_chunk_bits,\n\tuint16_t *status_vector_chunk, int *run_length_chunk_count, int *run_length_chunk_status, int status)\n{\n\tif (*run_length_chunk_status != status) {\n\t\twhile (*run_length_chunk_count > 0 && *run_length_chunk_count < 8) {\n\t\t\t/* Realistically it only makes sense to use a run length chunk if there were 8 or more\n\t\t\t * consecutive packets of the same type, otherwise we could end up making the packet larger\n\t\t\t * if we have lots of small blocks of the same type. To help with this we backfill the status\n\t\t\t * vector (since it always represents 7 packets). Best case we end up with only that single\n\t\t\t * status vector and the rest are run length chunks.\n\t\t\t */\n\t\t\trtp_transport_wide_cc_feedback_status_vector_append(rtcpheader, packet_len, status_vector_chunk_bits,\n\t\t\t\tstatus_vector_chunk, *run_length_chunk_status);\n\t\t\t*run_length_chunk_count -= 1;\n\t\t}\n\n\t\tif (*run_length_chunk_count) {\n\t\t\t/* There is a run length chunk which needs to be written out */\n\t\t\tput_unaligned_uint16(rtcpheader + *packet_len, htons((0 << 15) | (*run_length_chunk_status << 13) | *run_length_chunk_count));\n\t\t\t*packet_len += 2;\n\t\t}\n\n\t\t/* In all cases the run length chunk has to be reset */\n\t\t*run_length_chunk_count = 0;\n\t\t*run_length_chunk_status = -1;\n\n\t\tif (*status_vector_chunk_bits == 14) {\n\t\t\t/* We aren't in the middle of a status vector so we can try for a run length chunk */\n\t\t\t*run_length_chunk_status = status;\n\t\t\t*run_length_chunk_count = 1;\n\t\t} else {\n\t\t\t/* We're doing a status vector so populate it accordingly */\n\t\t\trtp_transport_wide_cc_feedback_status_vector_append(rtcpheader, packet_len, status_vector_chunk_bits,\n\t\t\t\tstatus_vector_chunk, status);\n\t\t}\n\t} else {\n\t\t/* This is easy, the run length chunk count can just get bumped up */\n\t\t*run_length_chunk_count += 1;\n\t}\n}\n\nstatic int rtp_transport_wide_cc_feedback_produce(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tunsigned char *rtcpheader;\n\tchar bdata[1024];\n\tstruct rtp_transport_wide_cc_packet_statistics *first_packet;\n\tstruct rtp_transport_wide_cc_packet_statistics *previous_packet;\n\tint i;\n\tint status_vector_chunk_bits = 14;\n\tuint16_t status_vector_chunk = (1 << 15) | (1 << 14);\n\tint run_length_chunk_count = 0;\n\tint run_length_chunk_status = -1;\n\tint packet_len = 20;\n\tint delta_len = 0;\n\tint packet_count = 0;\n\tunsigned int received_msw;\n\tunsigned int received_lsw;\n\tstruct ast_sockaddr remote_address = { { 0, } };\n\tint res;\n\tint ice;\n\tunsigned int large_delta_count = 0;\n\tunsigned int small_delta_count = 0;\n\tunsigned int lost_count = 0;\n\n\tif (!rtp || !rtp->rtcp || rtp->transport_wide_cc.schedid == -1) {\n\t\tao2_ref(instance, -1);\n\t\treturn 0;\n\t}\n\n\tao2_lock(instance);\n\n\t/* If no packets have been received then do nothing */\n\tif (!AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics)) {\n\t\tao2_unlock(instance);\n\t\treturn 1000;\n\t}\n\n\trtcpheader = (unsigned char *)bdata;\n\n\t/* The first packet in the vector acts as our base sequence number and reference time */\n\tfirst_packet = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, 0);\n\tprevious_packet = first_packet;\n\n\t/* We go through each packet that we have statistics for, adding it either to a status\n\t * vector chunk or a run length chunk. The code tries to be as efficient as possible to\n\t * reduce packet size and will favor run length chunks when it makes sense.\n\t */\n\tfor (i = 0; i < AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics); ++i) {\n\t\tstruct rtp_transport_wide_cc_packet_statistics *statistics;\n\t\tint lost = 0;\n\t\tint res = 0;\n\n\t\tstatistics = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, i);\n\n\t\tpacket_count++;\n\n\t\tif (first_packet != statistics) {\n\t\t\t/* The vector stores statistics in a sorted fashion based on the sequence\n\t\t\t * number. This ensures we can detect any packets that have been lost/not\n\t\t\t * received by comparing the sequence numbers.\n\t\t\t */\n\t\t\tlost = statistics->seqno - (previous_packet->seqno + 1);\n\t\t\tlost_count += lost;\n\t\t}\n\n\t\twhile (lost) {\n\t\t\t/* We append a not received status until all the lost packets have been accounted for */\n\t\t\trtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,\n\t\t\t\t&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 0);\n\t\t\tpacket_count++;\n\n\t\t\t/* If there is no more room left for storing packets stop now, we leave 20\n\t\t\t * extra bits at the end just in case.\n\t\t\t */\n\t\t\tif (packet_len + delta_len + 20 > sizeof(bdata)) {\n\t\t\t\tres = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlost--;\n\t\t}\n\n\t\t/* If the lost packet appending bailed out because we have no more space, then exit here too */\n\t\tif (res) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Per the spec the delta is in increments of 250 */\n\t\tstatistics->delta = ast_tvdiff_us(statistics->received, previous_packet->received) / 250;\n\n\t\t/* Based on the delta determine the status of this packet */\n\t\tif (statistics->delta < 0 || statistics->delta > 127) {\n\t\t\t/* Large or negative delta */\n\t\t\trtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,\n\t\t\t\t&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 2);\n\t\t\tdelta_len += 2;\n\t\t\tlarge_delta_count++;\n\t\t} else {\n\t\t\t/* Small delta */\n\t\t\trtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,\n\t\t\t\t&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 1);\n\t\t\tdelta_len += 1;\n\t\t\tsmall_delta_count++;\n\t\t}\n\n\t\tprevious_packet = statistics;\n\n\t\t/* If there is no more room left in the packet stop handling of any subsequent packets */\n\t\tif (packet_len + delta_len + 20 > sizeof(bdata)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status_vector_chunk_bits != 14) {\n\t\t/* If the status vector chunk has packets in it then place it in the RTCP packet */\n\t\tput_unaligned_uint16(rtcpheader + packet_len, htons(status_vector_chunk));\n\t\tpacket_len += 2;\n\t} else if (run_length_chunk_count) {\n\t\t/* If there is a run length chunk in progress then place it in the RTCP packet */\n\t\tput_unaligned_uint16(rtcpheader + packet_len, htons((0 << 15) | (run_length_chunk_status << 13) | run_length_chunk_count));\n\t\tpacket_len += 2;\n\t}\n\n\t/* We iterate again to build delta chunks */\n\tfor (i = 0; i < AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics); ++i) {\n\t\tstruct rtp_transport_wide_cc_packet_statistics *statistics;\n\n\t\tstatistics = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, i);\n\n\t\tif (statistics->delta < 0 || statistics->delta > 127) {\n\t\t\t/* We need 2 bytes to store this delta */\n\t\t\tput_unaligned_uint16(rtcpheader + packet_len, htons(statistics->delta));\n\t\t\tpacket_len += 2;\n\t\t} else {\n\t\t\t/* We can store this delta in 1 byte */\n\t\t\trtcpheader[packet_len] = statistics->delta;\n\t\t\tpacket_len += 1;\n\t\t}\n\n\t\t/* If this is the last packet handled by the run length chunk or status vector chunk code\n\t\t * then we can go no further.\n\t\t */\n\t\tif (statistics == previous_packet) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Zero pad the end of the packet */\n\twhile (packet_len % 4) {\n\t\trtcpheader[packet_len++] = 0;\n\t}\n\n\t/* Add the general RTCP header information */\n\tput_unaligned_uint32(rtcpheader, htonl((2 << 30) | (AST_RTP_RTCP_FMT_TRANSPORT_WIDE_CC << 24)\n\t\t| (AST_RTP_RTCP_RTPFB << 16) | ((packet_len / 4) - 1)));\n\tput_unaligned_uint32(rtcpheader + 4, htonl(rtp->ssrc));\n\tput_unaligned_uint32(rtcpheader + 8, htonl(rtp->themssrc));\n\n\t/* Add the transport-cc specific header information */\n\tput_unaligned_uint32(rtcpheader + 12, htonl((first_packet->seqno << 16) | packet_count));\n\n\ttimeval2ntp(first_packet->received, &received_msw, &received_lsw);\n\tput_unaligned_time24(rtcpheader + 16, received_msw, received_lsw);\n\trtcpheader[19] = rtp->transport_wide_cc.feedback_count;\n\n\t/* The packet is now fully constructed so send it out */\n\tast_sockaddr_copy(&remote_address, &rtp->rtcp->them);\n\n\tast_debug_rtcp(2, \"(%p) RTCP sending transport-cc feedback packet of size '%d' on '%s' with packet count of %d (small = %d, large = %d, lost = %d)\\n\",\n\t\tinstance, packet_len, ast_rtp_instance_get_channel_id(instance), packet_count, small_delta_count, large_delta_count, lost_count);\n\n\tres = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len, 0, &remote_address, &ice);\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTCP transport-cc feedback error to %s due to %s\\n\",\n\t\t\tast_sockaddr_stringify(&remote_address), strerror(errno));\n\t}\n\n\tAST_VECTOR_RESET(&rtp->transport_wide_cc.packet_statistics, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\n\trtp->transport_wide_cc.feedback_count++;\n\n\tao2_unlock(instance);\n\n\treturn 1000;\n}\n\nstatic void rtp_instance_parse_transport_wide_cc(struct ast_rtp_instance *instance, struct ast_rtp *rtp,\n\tunsigned char *data, int len)\n{\n\tuint16_t *seqno = (uint16_t *)data;\n\tstruct rtp_transport_wide_cc_packet_statistics statistics;\n\tstruct ast_rtp_instance *transport = rtp->bundled ? rtp->bundled : instance;\n\tstruct ast_rtp *transport_rtp = ast_rtp_instance_get_data(transport);\n\n\t/* If the sequence number has cycled over then record it as such */\n\tif (((int)transport_rtp->transport_wide_cc.last_seqno - (int)ntohs(*seqno)) > 100) {\n\t\ttransport_rtp->transport_wide_cc.cycles += RTP_SEQ_MOD;\n\t}\n\n\t/* Populate the statistics information for this packet */\n\tstatistics.seqno = transport_rtp->transport_wide_cc.cycles + ntohs(*seqno);\n\tstatistics.received = ast_tvnow();\n\n\t/* We allow at a maximum 1000 packet statistics in play at a time, if we hit the\n\t * limit we give up and start fresh.\n\t */\n\tif (AST_VECTOR_SIZE(&transport_rtp->transport_wide_cc.packet_statistics) > 1000) {\n\t\tAST_VECTOR_RESET(&rtp->transport_wide_cc.packet_statistics, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\t}\n\n\tif (!AST_VECTOR_SIZE(&transport_rtp->transport_wide_cc.packet_statistics) ||\n\t\tstatistics.seqno > transport_rtp->transport_wide_cc.last_extended_seqno) {\n\t\t/* This is the expected path */\n\t\tif (AST_VECTOR_APPEND(&transport_rtp->transport_wide_cc.packet_statistics, statistics)) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransport_rtp->transport_wide_cc.last_extended_seqno = statistics.seqno;\n\t\ttransport_rtp->transport_wide_cc.last_seqno = ntohs(*seqno);\n\t} else {\n\t\t/* This packet was out of order, so reorder it within the vector accordingly */\n\t\tif (AST_VECTOR_ADD_SORTED(&transport_rtp->transport_wide_cc.packet_statistics, statistics,\n\t\t\trtp_transport_wide_cc_packet_statistics_cmp)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* If we have not yet scheduled the periodic sending of feedback for this transport then do so */\n\tif (transport_rtp->transport_wide_cc.schedid < 0 && transport_rtp->rtcp) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP starting transport-cc feedback transmission on RTP instance '%p'\\n\", instance, transport);\n\t\tao2_ref(transport, +1);\n\t\ttransport_rtp->transport_wide_cc.schedid = ast_sched_add(rtp->sched, 1000,\n\t\t\trtp_transport_wide_cc_feedback_produce, transport);\n\t\tif (transport_rtp->transport_wide_cc.schedid < 0) {\n\t\t\tao2_ref(transport, -1);\n\t\t\tast_log(LOG_WARNING, \"Scheduling RTCP transport-cc feedback transmission failed on RTP instance '%p'\\n\",\n\t\t\t\ttransport);\n\t\t}\n\t}\n}\n\nstatic void rtp_instance_parse_extmap_extensions(struct ast_rtp_instance *instance, struct ast_rtp *rtp,\n\tunsigned char *extension, int len)\n{\n\tint transport_wide_cc_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_TRANSPORT_WIDE_CC);\n\tint pos = 0;\n\n\t/* We currently only care about the transport-cc extension, so if that's not negotiated then do nothing */\n\tif (transport_wide_cc_id == -1) {\n\t\treturn;\n\t}\n\n\t/* Only while we do not exceed available extension data do we continue */\n\twhile (pos < len) {\n\t\tint id = extension[pos] >> 4;\n\t\tint extension_len = (extension[pos] & 0xF) + 1;\n\n\t\t/* We've handled the first byte as it contains the extension id and length, so always\n\t\t * skip ahead now\n\t\t */\n\t\tpos += 1;\n\n\t\tif (id == 0) {\n\t\t\t/* From the RFC:\n\t\t\t * In both forms, padding bytes have the value of 0 (zero).  They may be\n\t\t\t * placed between extension elements, if desired for alignment, or after\n\t\t\t * the last extension element, if needed for padding.  A padding byte\n\t\t\t * does not supply the ID of an element, nor the length field.  When a\n\t\t\t * padding byte is found, it is ignored and the parser moves on to\n\t\t\t * interpreting the next byte.\n\t\t\t */\n\t\t\tcontinue;\n\t\t} else if (id == 15) {\n\t\t\t/* From the RFC:\n\t\t\t * The local identifier value 15 is reserved for future extension and\n\t\t\t * MUST NOT be used as an identifier.  If the ID value 15 is\n\t\t\t * encountered, its length field should be ignored, processing of the\n\t\t\t * entire extension should terminate at that point, and only the\n\t\t\t * extension elements present prior to the element with ID 15\n\t\t\t * considered.\n\t\t\t */\n\t\t\tbreak;\n\t\t} else if ((pos + extension_len) > len) {\n\t\t\t/* The extension is corrupted and is stating that it contains more data than is\n\t\t\t * available in the extensions data.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this is transport-cc then we need to parse it further */\n\t\tif (id == transport_wide_cc_id) {\n\t\t\trtp_instance_parse_transport_wide_cc(instance, rtp, extension + pos, extension_len);\n\t\t}\n\n\t\t/* Skip ahead to the next extension */\n\t\tpos += extension_len;\n\t}\n}\n\nstatic struct ast_frame *ast_rtp_interpret(struct ast_rtp_instance *instance, struct ast_srtp *srtp,\n\tconst struct ast_sockaddr *remote_address, unsigned char *read_area, int length, int prev_seqno,\n\tunsigned int bundled)\n{\n\tunsigned int *rtpheader = (unsigned int*)(read_area);\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_rtp_instance *instance1;\n\tint res = length, hdrlen = 12, ssrc, seqno, payloadtype, padding, mark, ext, cc;\n\tunsigned int timestamp;\n\tRAII_VAR(struct ast_rtp_payload_type *, payload, NULL, ao2_cleanup);\n\tstruct frame_list frames;\n\n\t/* If this payload is encrypted then decrypt it using the given SRTP instance */\n\tif ((*read_area & 0xC0) && res_srtp && srtp && res_srtp->unprotect(\n\t\t    srtp, read_area, &res, 0 | (srtp_replay_protection << 1)) < 0) {\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If we are currently sending DTMF to the remote party send a continuation packet */\n\tif (rtp->sending_digit) {\n\t\tast_rtp_dtmf_continuation(instance);\n\t}\n\n\t/* Pull out the various other fields we will need */\n\tssrc = ntohl(rtpheader[2]);\n\tseqno = ntohl(rtpheader[0]);\n\tpayloadtype = (seqno & 0x7f0000) >> 16;\n\tpadding = seqno & (1 << 29);\n\tmark = seqno & (1 << 23);\n\text = seqno & (1 << 28);\n\tcc = (seqno & 0xF000000) >> 24;\n\tseqno &= 0xffff;\n\ttimestamp = ntohl(rtpheader[1]);\n\n\tAST_LIST_HEAD_INIT_NOLOCK(&frames);\n\n\t/* Remove any padding bytes that may be present */\n\tif (padding) {\n\t\tres -= read_area[res - 1];\n\t}\n\n\t/* Skip over any CSRC fields */\n\tif (cc) {\n\t\thdrlen += cc * 4;\n\t}\n\n\t/* Look for any RTP extensions, currently we do not support any */\n\tif (ext) {\n\t\tint extensions_size = (ntohl(rtpheader[hdrlen/4]) & 0xffff) << 2;\n\t\tunsigned int profile;\n\t\tprofile = (ntohl(rtpheader[3]) & 0xffff0000) >> 16;\n\n\t\tif (profile == 0xbede) {\n\t\t\t/* We skip over the first 4 bytes as they are just for the one byte extension header */\n\t\t\trtp_instance_parse_extmap_extensions(instance, rtp, read_area + hdrlen + 4, extensions_size);\n\t\t} else if (DEBUG_ATLEAST(1)) {\n\t\t\tif (profile == 0x505a) {\n\t\t\t\tast_log(LOG_DEBUG, \"Found Zfone extension in RTP stream - zrtp - not supported.\\n\");\n\t\t\t} else {\n\t\t\t\t/* SDP negotiated RTP extensions can not currently be output in logging */\n\t\t\t\tast_log(LOG_DEBUG, \"Found unknown RTP Extensions %x\\n\", profile);\n\t\t\t}\n\t\t}\n\n\t\thdrlen += extensions_size;\n\t\thdrlen += 4;\n\t}\n\n\t/* Make sure after we potentially mucked with the header length that it is once again valid */\n\tif (res < hdrlen) {\n\t\tast_log(LOG_WARNING, \"RTP Read too short (%d, expecting %d\\n\", res, hdrlen);\n\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t}\n\n\t/* Only non-bundled instances can change/learn the remote's SSRC implicitly. */\n\tif (!bundled) {\n\t\t/* Force a marker bit and change SSRC if the SSRC changes */\n\t\tif (rtp->themssrc_valid && rtp->themssrc != ssrc) {\n\t\t\tstruct ast_frame *f, srcupdate = {\n\t\t\t\tAST_FRAME_CONTROL,\n\t\t\t\t.subclass.integer = AST_CONTROL_SRCCHANGE,\n\t\t\t};\n\n\t\t\tif (!mark) {\n\t\t\t\tif (ast_debug_rtp_packet_is_allowed) {\n\t\t\t\t\tast_debug(0, \"(%p) RTP forcing Marker bit, because SSRC has changed\\n\", instance);\n\t\t\t\t}\n\t\t\t\tmark = 1;\n\t\t\t}\n\n\t\t\tf = ast_frisolate(&srcupdate);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, f, frame_list);\n\n\t\t\trtp->seedrxseqno = 0;\n\t\t\trtp->rxcount = 0;\n\t\t\trtp->rxoctetcount = 0;\n\t\t\trtp->cycles = 0;\n\t\t\tprev_seqno = 0;\n\t\t\trtp->last_seqno = 0;\n\t\t\trtp->last_end_timestamp.ts = 0;\n\t\t\trtp->last_end_timestamp.is_set = 0;\n\t\t\tif (rtp->rtcp) {\n\t\t\t\trtp->rtcp->expected_prior = 0;\n\t\t\t\trtp->rtcp->received_prior = 0;\n\t\t\t}\n\t\t}\n\n\t\trtp->themssrc = ssrc; /* Record their SSRC to put in future RR */\n\t\trtp->themssrc_valid = 1;\n\t}\n\n\trtp->rxcount++;\n\trtp->rxoctetcount += (res - hdrlen);\n\tif (rtp->rxcount == 1) {\n\t\trtp->seedrxseqno = seqno;\n\t}\n\n\t/* Do not schedule RR if RTCP isn't run */\n\tif (rtp->rtcp && !ast_sockaddr_isnull(&rtp->rtcp->them) && rtp->rtcp->schedid < 0) {\n\t\t/* Schedule transmission of Receiver Report */\n\t\tao2_ref(instance, +1);\n\t\trtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);\n\t\tif (rtp->rtcp->schedid < 0) {\n\t\t\tao2_ref(instance, -1);\n\t\t\tast_log(LOG_WARNING, \"scheduling RTCP transmission failed.\\n\");\n\t\t}\n\t}\n\tif ((int)prev_seqno - (int)seqno  > 100) /* if so it would indicate that the sender cycled; allow for misordering */\n\t\trtp->cycles += RTP_SEQ_MOD;\n\n\t/* If we are directly bridged to another instance send the audio directly out,\n\t * but only after updating core information about the received traffic so that\n\t * outgoing RTCP reflects it.\n\t */\n\tinstance1 = ast_rtp_instance_get_bridged(instance);\n\tif (instance1\n\t\t&& !bridge_p2p_rtp_write(instance, instance1, rtpheader, res, hdrlen)) {\n\t\tstruct timeval rxtime;\n\t\tstruct ast_frame *f;\n\n\t\t/* Update statistics for jitter so they are correct in RTCP */\n\t\tcalc_rxstamp_and_jitter(&rxtime, rtp, timestamp, mark);\n\n\n\t\t/* When doing P2P we don't need to raise any frames about SSRC change to the core */\n\t\twhile ((f = AST_LIST_REMOVE_HEAD(&frames, frame_list)) != NULL) {\n\t\t\tast_frfree(f);\n\t\t}\n\n\t\treturn &ast_null_frame;\n\t}\n\n\tpayload = ast_rtp_codecs_get_payload(ast_rtp_instance_get_codecs(instance), payloadtype);\n\tif (!payload) {\n\t\t/* Unknown payload type. */\n\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t}\n\n\t/* If the payload is not actually an Asterisk one but a special one pass it off to the respective handler */\n\tif (!payload->asterisk_format) {\n\t\tstruct ast_frame *f = NULL;\n\t\tif (payload->rtp_code == AST_RTP_DTMF) {\n\t\t\t/* process_dtmf_rfc2833 may need to return multiple frames. We do this\n\t\t\t * by passing the pointer to the frame list to it so that the method\n\t\t\t * can append frames to the list as needed.\n\t\t\t */\n\t\t\tprocess_dtmf_rfc2833(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, payloadtype, mark, &frames);\n\t\t} else if (payload->rtp_code == AST_RTP_CISCO_DTMF) {\n\t\t\tf = process_dtmf_cisco(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, payloadtype, mark);\n\t\t} else if (payload->rtp_code == AST_RTP_CN) {\n\t\t\tf = process_cn_rfc3389(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, payloadtype, mark);\n\t\t} else {\n\t\t\tast_log(LOG_NOTICE, \"Unknown RTP codec %d received from '%s'\\n\",\n\t\t\t\tpayloadtype,\n\t\t\t\tast_sockaddr_stringify(remote_address));\n\t\t}\n\n\t\tif (f) {\n\t\t\tAST_LIST_INSERT_TAIL(&frames, f, frame_list);\n\t\t}\n\t\t/* Even if no frame was returned by one of the above methods,\n\t\t * we may have a frame to return in our frame list\n\t\t */\n\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t}\n\n\tao2_replace(rtp->lastrxformat, payload->format);\n\tao2_replace(rtp->f.subclass.format, payload->format);\n\tswitch (ast_format_get_type(rtp->f.subclass.format)) {\n\tcase AST_MEDIA_TYPE_AUDIO:\n\t\trtp->f.frametype = AST_FRAME_VOICE;\n\t\tbreak;\n\tcase AST_MEDIA_TYPE_VIDEO:\n\t\trtp->f.frametype = AST_FRAME_VIDEO;\n\t\tbreak;\n\tcase AST_MEDIA_TYPE_TEXT:\n\t\trtp->f.frametype = AST_FRAME_TEXT;\n\t\tbreak;\n\tcase AST_MEDIA_TYPE_IMAGE:\n\t\t/* Fall through */\n\tdefault:\n\t\tast_log(LOG_WARNING, \"Unknown or unsupported media type: %s\\n\",\n\t\t\tast_codec_media_type2str(ast_format_get_type(rtp->f.subclass.format)));\n\t\treturn &ast_null_frame;\n\t}\n\n\tif (rtp->dtmf_timeout && rtp->dtmf_timeout < timestamp) {\n\t\trtp->dtmf_timeout = 0;\n\n\t\tif (rtp->resp) {\n\t\t\tstruct ast_frame *f;\n\t\t\tf = create_dtmf_frame(instance, AST_FRAME_DTMF_END, 0);\n\t\t\tf->len = ast_tvdiff_ms(ast_samp2tv(rtp->dtmf_duration, ast_rtp_get_rate(f->subclass.format)), ast_tv(0, 0));\n\t\t\trtp->resp = 0;\n\t\t\trtp->dtmf_timeout = rtp->dtmf_duration = 0;\n\t\t\tAST_LIST_INSERT_TAIL(&frames, f, frame_list);\n\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t}\n\t}\n\n\trtp->f.src = \"RTP\";\n\trtp->f.mallocd = 0;\n\trtp->f.datalen = res - hdrlen;\n\trtp->f.data.ptr = read_area + hdrlen;\n\trtp->f.offset = hdrlen + AST_FRIENDLY_OFFSET;\n\tast_set_flag(&rtp->f, AST_FRFLAG_HAS_SEQUENCE_NUMBER);\n\trtp->f.seqno = seqno;\n\trtp->f.stream_num = rtp->stream_num;\n\n\tif ((ast_format_cmp(rtp->f.subclass.format, ast_format_t140) == AST_FORMAT_CMP_EQUAL)\n\t\t&& ((int)seqno - (prev_seqno + 1) > 0)\n\t\t&& ((int)seqno - (prev_seqno + 1) < 10)) {\n\t\tunsigned char *data = rtp->f.data.ptr;\n\n\t\tmemmove(rtp->f.data.ptr+3, rtp->f.data.ptr, rtp->f.datalen);\n\t\trtp->f.datalen +=3;\n\t\t*data++ = 0xEF;\n\t\t*data++ = 0xBF;\n\t\t*data = 0xBD;\n\t}\n\n\tif (ast_format_cmp(rtp->f.subclass.format, ast_format_t140_red) == AST_FORMAT_CMP_EQUAL) {\n\t\tunsigned char *data = rtp->f.data.ptr;\n\t\tunsigned char *header_end;\n\t\tint num_generations;\n\t\tint header_length;\n\t\tint len;\n\t\tint diff =(int)seqno - (prev_seqno+1); /* if diff = 0, no drop*/\n\t\tint x;\n\n\t\tao2_replace(rtp->f.subclass.format, ast_format_t140);\n\t\theader_end = memchr(data, ((*data) & 0x7f), rtp->f.datalen);\n\t\tif (header_end == NULL) {\n\t\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\t\t}\n\t\theader_end++;\n\n\t\theader_length = header_end - data;\n\t\tnum_generations = header_length / 4;\n\t\tlen = header_length;\n\n\t\tif (!diff) {\n\t\t\tfor (x = 0; x < num_generations; x++)\n\t\t\t\tlen += data[x * 4 + 3];\n\n\t\t\tif (!(rtp->f.datalen - len))\n\t\t\t\treturn AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;\n\n\t\t\trtp->f.data.ptr += len;\n\t\t\trtp->f.datalen -= len;\n\t\t} else if (diff > num_generations && diff < 10) {\n\t\t\tlen -= 3;\n\t\t\trtp->f.data.ptr += len;\n\t\t\trtp->f.datalen -= len;\n\n\t\t\tdata = rtp->f.data.ptr;\n\t\t\t*data++ = 0xEF;\n\t\t\t*data++ = 0xBF;\n\t\t\t*data = 0xBD;\n\t\t} else {\n\t\t\tfor ( x = 0; x < num_generations - diff; x++)\n\t\t\t\tlen += data[x * 4 + 3];\n\n\t\t\trtp->f.data.ptr += len;\n\t\t\trtp->f.datalen -= len;\n\t\t}\n\t}\n\n\tif (ast_format_get_type(rtp->f.subclass.format) == AST_MEDIA_TYPE_AUDIO) {\n\t\trtp->f.samples = ast_codec_samples_count(&rtp->f);\n\t\tif (ast_format_cache_is_slinear(rtp->f.subclass.format)) {\n\t\t\tast_frame_byteswap_be(&rtp->f);\n\t\t}\n\t\tcalc_rxstamp_and_jitter(&rtp->f.delivery, rtp, timestamp, mark);\n\t\t/* Add timing data to let ast_generic_bridge() put the frame into a jitterbuf */\n\t\tast_set_flag(&rtp->f, AST_FRFLAG_HAS_TIMING_INFO);\n\t\trtp->f.ts = timestamp / (ast_rtp_get_rate(rtp->f.subclass.format) / 1000);\n\t\trtp->f.len = rtp->f.samples / ((ast_format_get_sample_rate(rtp->f.subclass.format) / 1000));\n\t} else if (ast_format_get_type(rtp->f.subclass.format) == AST_MEDIA_TYPE_VIDEO) {\n\t\t/* Video -- samples is # of samples vs. 90000 */\n\t\tif (!rtp->lastividtimestamp)\n\t\t\trtp->lastividtimestamp = timestamp;\n\t\tcalc_rxstamp_and_jitter(&rtp->f.delivery, rtp, timestamp, mark);\n\t\tast_set_flag(&rtp->f, AST_FRFLAG_HAS_TIMING_INFO);\n\t\trtp->f.ts = timestamp / (ast_rtp_get_rate(rtp->f.subclass.format) / 1000);\n\t\trtp->f.samples = timestamp - rtp->lastividtimestamp;\n\t\trtp->lastividtimestamp = timestamp;\n\t\trtp->f.delivery.tv_sec = 0;\n\t\trtp->f.delivery.tv_usec = 0;\n\t\t/* Pass the RTP marker bit as bit */\n\t\trtp->f.subclass.frame_ending = mark ? 1 : 0;\n\t} else if (ast_format_get_type(rtp->f.subclass.format) == AST_MEDIA_TYPE_TEXT) {\n\t\t/* TEXT -- samples is # of samples vs. 1000 */\n\t\tif (!rtp->lastitexttimestamp)\n\t\t\trtp->lastitexttimestamp = timestamp;\n\t\trtp->f.samples = timestamp - rtp->lastitexttimestamp;\n\t\trtp->lastitexttimestamp = timestamp;\n\t\trtp->f.delivery.tv_sec = 0;\n\t\trtp->f.delivery.tv_usec = 0;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Unknown or unsupported media type: %s\\n\",\n\t\t\tast_codec_media_type2str(ast_format_get_type(rtp->f.subclass.format)));\n\t\treturn &ast_null_frame;\n\t}\n\n\tAST_LIST_INSERT_TAIL(&frames, &rtp->f, frame_list);\n\treturn AST_LIST_FIRST(&frames);\n}\n\n#ifdef AST_DEVMODE\n\nstruct rtp_drop_packets_data {\n\t/* Whether or not to randomize the number of packets to drop. */\n\tunsigned int use_random_num;\n\t/* Whether or not to randomize the time interval between packets drops. */\n\tunsigned int use_random_interval;\n\t/* The total number of packets to drop. If 'use_random_num' is true then this\n\t * value becomes the upper bound for a number of random packets to drop. */\n\tunsigned int num_to_drop;\n\t/* The current number of packets that have been dropped during an interval. */\n\tunsigned int num_dropped;\n\t/* The optional interval to use between packet drops. If 'use_random_interval'\n\t * is true then this values becomes the upper bound for a random interval used. */\n\tstruct timeval interval;\n\t/* The next time a packet drop should be triggered. */\n\tstruct timeval next;\n\t/* An optional IP address from which to drop packets from. */\n\tstruct ast_sockaddr addr;\n\t/* The optional port from which to drop packets from. */\n\tunsigned int port;\n};\n\nstatic struct rtp_drop_packets_data drop_packets_data;\n\nstatic void drop_packets_data_update(struct timeval tv)\n{\n\t/*\n\t * num_dropped keeps up with the number of packets that have been dropped for a\n\t * given interval. Once the specified number of packets have been dropped and\n\t * the next time interval is ready to trigger then set this number to zero (drop\n\t * the next 'n' packets up to 'num_to_drop'), or if 'use_random_num' is set to\n\t * true then set to a random number between zero and 'num_to_drop'.\n\t */\n\tdrop_packets_data.num_dropped = drop_packets_data.use_random_num ?\n\t\tast_random() % drop_packets_data.num_to_drop : 0;\n\n\t/*\n\t * A specified number of packets can be dropped at a given interval (e.g every\n\t * 30 seconds). If 'use_random_interval' is false simply add the interval to\n\t * the given time to get the next trigger point. If set to true, then get a\n\t * random time between the given time and up to the specified interval.\n\t */\n\tif (drop_packets_data.use_random_interval) {\n\t\t/* Calculate as a percentage of the specified drop packets interval */\n\t\tstruct timeval interval = ast_time_create_by_unit(ast_time_tv_to_usec(\n\t\t\t&drop_packets_data.interval) * ((double)(ast_random() % 100 + 1) / 100),\n\t\t\tTIME_UNIT_MICROSECOND);\n\n\t\tdrop_packets_data.next = ast_tvadd(tv, interval);\n\t} else {\n\t\tdrop_packets_data.next = ast_tvadd(tv, drop_packets_data.interval);\n\t}\n}\n\nstatic int should_drop_packets(struct ast_sockaddr *addr)\n{\n\tstruct timeval tv;\n\n\tif (!drop_packets_data.num_to_drop) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If an address has been specified then filter on it, and also the port if\n\t * it too was included.\n\t */\n\tif (!ast_sockaddr_isnull(&drop_packets_data.addr) &&\n\t\t(drop_packets_data.port ?\n\t\t\tast_sockaddr_cmp(&drop_packets_data.addr, addr) :\n\t\t\tast_sockaddr_cmp_addr(&drop_packets_data.addr, addr)) != 0) {\n\t\t/* Address and/or port does not match */\n\t\treturn 0;\n\t}\n\n\t/* Keep dropping packets until we've reached the total to drop */\n\tif (drop_packets_data.num_dropped < drop_packets_data.num_to_drop) {\n\t\t++drop_packets_data.num_dropped;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Once the set number of packets has been dropped check to see if it's\n\t * time to drop more.\n\t */\n\n\tif (ast_tvzero(drop_packets_data.interval)) {\n\t\t/* If no interval then drop specified number of packets and be done */\n\t\tdrop_packets_data.num_to_drop = 0;\n\t\treturn 0;\n\t}\n\n\ttv = ast_tvnow();\n\tif (ast_tvcmp(tv, drop_packets_data.next) == -1) {\n\t\t/* Still waiting for the next time interval to elapse */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The next time interval has elapsed so update the tracking structure\n\t * in order to start dropping more packets, and figure out when the next\n\t * time interval is.\n\t */\n\tdrop_packets_data_update(tv);\n\treturn 1;\n}\n\n#endif\n\n/*! \\pre instance is locked */\nstatic struct ast_frame *ast_rtp_read(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_srtp *srtp;\n\tRAII_VAR(struct ast_rtp_instance *, child, NULL, rtp_instance_unlock);\n\tstruct ast_sockaddr addr;\n\tint res, hdrlen = 12, version, payloadtype;\n\tunsigned char *read_area = rtp->rawdata + AST_FRIENDLY_OFFSET;\n\tsize_t read_area_size = sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET;\n\tunsigned int *rtpheader = (unsigned int*)(read_area), seqno, ssrc, timestamp, prev_seqno;\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tstruct frame_list frames;\n\tstruct ast_frame *frame;\n\tunsigned int bundled;\n\n\t/* If this is actually RTCP let's hop on over and handle it */\n\tif (rtcp) {\n\t\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\treturn ast_rtcp_read(instance);\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* Actually read in the data from the socket */\n\tif ((res = rtp_recvfrom(instance, read_area, read_area_size, 0,\n\t\t\t\t&addr)) < 0) {\n\t\tif (res == RTP_DTLS_ESTABLISHED) {\n\t\t\trtp->f.frametype = AST_FRAME_CONTROL;\n\t\t\trtp->f.subclass.integer = AST_CONTROL_SRCCHANGE;\n\t\t\treturn &rtp->f;\n\t\t}\n\n\t\tast_assert(errno != EBADF);\n\t\tif (errno != EAGAIN) {\n\t\t\tast_log(LOG_WARNING, \"RTP Read error: %s.  Hanging up.\\n\",\n\t\t\t\t(errno) ? strerror(errno) : \"Unspecified\");\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If this was handled by the ICE session don't do anything */\n\tif (!res) {\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* This could be a multiplexed RTCP packet. If so, be sure to interpret it correctly */\n\tif (rtcp_mux(rtp, read_area)) {\n\t\treturn ast_rtcp_interpret(instance, ast_rtp_instance_get_srtp(instance, 1), read_area, res, &addr);\n\t}\n\n\t/* Make sure the data that was read in is actually enough to make up an RTP packet */\n\tif (res < hdrlen) {\n\t\t/* If this is a keepalive containing only nulls, don't bother with a warning */\n\t\tint i;\n\t\tfor (i = 0; i < res; ++i) {\n\t\t\tif (read_area[i] != '\\0') {\n\t\t\t\tast_log(LOG_WARNING, \"RTP Read too short\\n\");\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* Get fields and verify this is an RTP packet */\n\tseqno = ntohl(rtpheader[0]);\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\tif (!(version = (seqno & 0xC0000000) >> 30)) {\n\t\tstruct sockaddr_in addr_tmp;\n\t\tstruct ast_sockaddr addr_v4;\n\t\tif (ast_sockaddr_is_ipv4(&addr)) {\n\t\t\tast_sockaddr_to_sin(&addr, &addr_tmp);\n\t\t} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {\n\t\t\tast_debug_stun(1, \"(%p) STUN using IPv6 mapped address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\tast_sockaddr_to_sin(&addr_v4, &addr_tmp);\n\t\t} else {\n\t\t\tast_debug_stun(1, \"(%p) STUN cannot do for non IPv4 address %s\\n\",\n\t\t\t\tinstance, ast_sockaddr_stringify(&addr));\n\t\t\treturn &ast_null_frame;\n\t\t}\n\t\tif ((ast_stun_handle_packet(rtp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT) &&\n\t\t    ast_sockaddr_isnull(&remote_address)) {\n\t\t\tast_sockaddr_from_sin(&addr, &addr_tmp);\n\t\t\tast_rtp_instance_set_remote_address(instance, &addr);\n\t\t}\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* If the version is not what we expected by this point then just drop the packet */\n\tif (version != 2) {\n\t\treturn &ast_null_frame;\n\t}\n\n\t/* We use the SSRC to determine what RTP instance this packet is actually for */\n\tssrc = ntohl(rtpheader[2]);\n\n\t/* We use the SRTP data from the provided instance that it came in on, not the child */\n\tsrtp = ast_rtp_instance_get_srtp(instance, 0);\n\n\t/* Determine the appropriate instance for this */\n\tchild = rtp_find_instance_by_packet_source_ssrc(instance, rtp, ssrc);\n\tif (!child) {\n\t\t/* Neither the bundled parent nor any child has this SSRC */\n\t\treturn &ast_null_frame;\n\t}\n\tif (child != instance) {\n\t\t/* It is safe to hold the child lock while holding the parent lock, we guarantee that the locking order\n\t\t * is always parent->child or that the child lock is not held when acquiring the parent lock.\n\t\t */\n\t\tao2_lock(child);\n\t\tinstance = child;\n\t\trtp = ast_rtp_instance_get_data(instance);\n\t} else {\n\t\t/* The child is the parent! We don't need to unlock it. */\n\t\tchild = NULL;\n\t}\n\n\t/* If strict RTP protection is enabled see if we need to learn the remote address or if we need to drop the packet */\n\tswitch (rtp->strict_rtp_state) {\n\tcase STRICT_RTP_LEARN:\n\t\t/*\n\t\t * Scenario setup:\n\t\t * PartyA -- Ast1 -- Ast2 -- PartyB\n\t\t *\n\t\t * The learning timeout is necessary for Ast1 to handle the above\n\t\t * setup where PartyA calls PartyB and Ast2 initiates direct media\n\t\t * between Ast1 and PartyB.  Ast1 may lock onto the Ast2 stream and\n\t\t * never learn the PartyB stream when it starts.  The timeout makes\n\t\t * Ast1 stay in the learning state long enough to see and learn the\n\t\t * RTP stream from PartyB.\n\t\t *\n\t\t * To mitigate against attack, the learning state cannot switch\n\t\t * streams while there are competing streams.  The competing streams\n\t\t * interfere with each other's qualification.  Once we accept a\n\t\t * stream and reach the timeout, an attacker cannot interfere\n\t\t * anymore.\n\t\t *\n\t\t * Here are a few scenarios and each one assumes that the streams\n\t\t * are continuous:\n\t\t *\n\t\t * 1) We already have a known stream source address and the known\n\t\t * stream wants to change to a new source address.  An attacking\n\t\t * stream will block learning the new stream source.  After the\n\t\t * timeout we re-lock onto the original stream source address which\n\t\t * likely went away.  The result is one way audio.\n\t\t *\n\t\t * 2) We already have a known stream source address and the known\n\t\t * stream doesn't want to change source addresses.  An attacking\n\t\t * stream will not be able to replace the known stream.  After the\n\t\t * timeout we re-lock onto the known stream.  The call is not\n\t\t * affected.\n\t\t *\n\t\t * 3) We don't have a known stream source address.  This presumably\n\t\t * is the start of a call.  Competing streams will result in staying\n\t\t * in learning mode until a stream becomes the victor and we reach\n\t\t * the timeout.  We cannot exit learning if we have no known stream\n\t\t * to lock onto.  The result is one way audio until there is a victor.\n\t\t *\n\t\t * If we learn a stream source address before the timeout we will be\n\t\t * in scenario 1) or 2) when a competing stream starts.\n\t\t */\n\t\tif (!ast_sockaddr_isnull(&rtp->strict_rtp_address)\n\t\t\t&& STRICT_RTP_LEARN_TIMEOUT < ast_tvdiff_ms(ast_tvnow(), rtp->rtp_source_learn.start)) {\n\t\t\tast_verb(4, \"%p -- Strict RTP learning complete - Locking on source address %s\\n\",\n\t\t\t\trtp, ast_sockaddr_stringify(&rtp->strict_rtp_address));\n\t\t\tast_test_suite_event_notify(\"STRICT_RTP_LEARN\", \"Source: %s\",\n\t\t\t\tast_sockaddr_stringify(&rtp->strict_rtp_address));\n\t\t\trtp->strict_rtp_state = STRICT_RTP_CLOSED;\n\t\t} else {\n\t\t\tstruct ast_sockaddr target_address;\n\n\t\t\tif (!ast_sockaddr_cmp(&rtp->strict_rtp_address, &addr)) {\n\t\t\t\t/*\n\t\t\t\t * We are open to learning a new address but have received\n\t\t\t\t * traffic from the current address, accept it and reset\n\t\t\t\t * the learning counts for a new source.  When no more\n\t\t\t\t * current source packets arrive a new source can take over\n\t\t\t\t * once sufficient traffic is received.\n\t\t\t\t */\n\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We give preferential treatment to the requested target address\n\t\t\t * (negotiated SDP address) where we are to send our RTP.  However,\n\t\t\t * the other end has no obligation to send from that address even\n\t\t\t * though it is practically a requirement when NAT is involved.\n\t\t\t */\n\t\t\tast_rtp_instance_get_requested_target_address(instance, &target_address);\n\t\t\tif (!ast_sockaddr_cmp(&target_address, &addr)) {\n\t\t\t\t/* Accept the negotiated target RTP stream as the source */\n\t\t\t\tast_verb(4, \"%p -- Strict RTP switching to RTP target address %s as source\\n\",\n\t\t\t\t\trtp, ast_sockaddr_stringify(&addr));\n\t\t\t\tast_sockaddr_copy(&rtp->strict_rtp_address, &addr);\n\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Trying to learn a new address.  If we pass a probationary period\n\t\t\t * with it, that means we've stopped getting RTP from the original\n\t\t\t * source and we should switch to it.\n\t\t\t */\n\t\t\tif (!ast_sockaddr_cmp(&rtp->rtp_source_learn.proposed_address, &addr)) {\n\t\t\t\tif (rtp->rtp_source_learn.stream_type == AST_MEDIA_TYPE_UNKNOWN) {\n\t\t\t\t\tstruct ast_rtp_codecs *codecs;\n\n\t\t\t\t\tcodecs = ast_rtp_instance_get_codecs(instance);\n\t\t\t\t\trtp->rtp_source_learn.stream_type =\n\t\t\t\t\t\tast_rtp_codecs_get_stream_type(codecs);\n\t\t\t\t\tast_verb(4, \"%p -- Strict RTP qualifying stream type: %s\\n\",\n\t\t\t\t\t\trtp, ast_codec_media_type2str(rtp->rtp_source_learn.stream_type));\n\t\t\t\t}\n\t\t\t\tif (!rtp_learning_rtp_seq_update(&rtp->rtp_source_learn, seqno)) {\n\t\t\t\t\t/* Accept the new RTP stream */\n\t\t\t\t\tast_verb(4, \"%p -- Strict RTP switching source address to %s\\n\",\n\t\t\t\t\t\trtp, ast_sockaddr_stringify(&addr));\n\t\t\t\t\tast_sockaddr_copy(&rtp->strict_rtp_address, &addr);\n\t\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Not ready to accept the RTP stream candidate */\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection. Will switch to it in %d packets.\\n\",\n\t\t\t\t\tinstance, rtp, ast_sockaddr_stringify(&addr), rtp->rtp_source_learn.packets);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This is either an attacking stream or\n\t\t\t\t * the start of the expected new stream.\n\t\t\t\t */\n\t\t\t\tast_sockaddr_copy(&rtp->rtp_source_learn.proposed_address, &addr);\n\t\t\t\trtp_learning_seq_init(&rtp->rtp_source_learn, seqno);\n\t\t\t\tast_debug_rtp(1, \"(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection. Qualifying new stream.\\n\",\n\t\t\t\t\tinstance, rtp, ast_sockaddr_stringify(&addr));\n\t\t\t}\n\t\t\treturn &ast_null_frame;\n\t\t}\n\t\t/* Fall through */\n\tcase STRICT_RTP_CLOSED:\n\t\t/*\n\t\t * We should not allow a stream address change if the SSRC matches\n\t\t * once strictrtp learning is closed.  Any kind of address change\n\t\t * like this should have happened while we were in the learning\n\t\t * state.  We do not want to allow the possibility of an attacker\n\t\t * interfering with the RTP stream after the learning period.\n\t\t * An attacker could manage to get an RTCP packet redirected to\n\t\t * them which can contain the SSRC value.\n\t\t */\n\t\tif (!ast_sockaddr_cmp(&rtp->strict_rtp_address, &addr)) {\n\t\t\tbreak;\n\t\t}\n\t\tast_debug_rtp(1, \"(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection.\\n\",\n\t\t\tinstance, rtp, ast_sockaddr_stringify(&addr));\n#ifdef TEST_FRAMEWORK\n\t{\n\t\tstatic int strict_rtp_test_event = 1;\n\t\tif (strict_rtp_test_event) {\n\t\t\tast_test_suite_event_notify(\"STRICT_RTP_CLOSED\", \"Source: %s\",\n\t\t\t\tast_sockaddr_stringify(&addr));\n\t\t\tstrict_rtp_test_event = 0; /* Only run this event once to prevent possible spam */\n\t\t}\n\t}\n#endif\n\t\treturn &ast_null_frame;\n\tcase STRICT_RTP_OPEN:\n\t\tbreak;\n\t}\n\n\t/* If symmetric RTP is enabled see if the remote side is not what we expected and change where we are sending audio */\n\tif (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {\n\t\tif (ast_sockaddr_cmp(&remote_address, &addr)) {\n\t\t\t/* do not update the originally given address, but only the remote */\n\t\t\tast_rtp_instance_set_incoming_source_address(instance, &addr);\n\t\t\tast_sockaddr_copy(&remote_address, &addr);\n\t\t\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, &addr);\n\t\t\t\tast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(&addr) + 1);\n\t\t\t}\n\t\t\tast_set_flag(rtp, FLAG_NAT_ACTIVE);\n\t\t\tif (ast_debug_rtp_packet_is_allowed)\n\t\t\t\tast_debug(0, \"(%p) RTP NAT: Got audio from other end. Now sending to address %s\\n\",\n\t\t\t\t\tinstance, ast_sockaddr_stringify(&remote_address));\n\t\t}\n\t}\n\n\t/* Pull out the various other fields we will need */\n\tpayloadtype = (seqno & 0x7f0000) >> 16;\n\tseqno &= 0xffff;\n\ttimestamp = ntohl(rtpheader[1]);\n\n#ifdef AST_DEVMODE\n\tif (should_drop_packets(&addr)) {\n\t\tast_debug(0, \"(%p) RTP: drop received packet from %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\tinstance, ast_sockaddr_stringify(&addr), payloadtype, seqno, timestamp, res - hdrlen);\n\t\treturn &ast_null_frame;\n\t}\n#endif\n\n\tif (rtp_debug_test_addr(&addr)) {\n\t\tast_verbose(\"Got  RTP packet from    %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&addr),\n\t\t\t    payloadtype, seqno, timestamp, res - hdrlen);\n\t}\n\n\tAST_LIST_HEAD_INIT_NOLOCK(&frames);\n\n\tbundled = (child || AST_VECTOR_SIZE(&rtp->ssrc_mapping)) ? 1 : 0;\n\n\tprev_seqno = rtp->lastrxseqno;\n\t/* We need to save lastrxseqno for use by jitter before resetting it. */\n\trtp->prevrxseqno = rtp->lastrxseqno;\n\trtp->lastrxseqno = seqno;\n\n\tif (!rtp->recv_buffer) {\n\t\t/* If there is no receive buffer then we can pass back the frame directly */\n\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\treturn AST_LIST_FIRST(&frames);\n\t} else if (rtp->expectedrxseqno == -1 || seqno == rtp->expectedrxseqno) {\n\t\trtp->expectedrxseqno = seqno + 1;\n\n\t\t/* We've cycled over, so go back to 0 */\n\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\trtp->expectedrxseqno = 0;\n\t\t}\n\n\t\t/* If there are no buffered packets that will be placed after this frame then we can\n\t\t * return it directly without duplicating it.\n\t\t */\n\t\tif (!ast_data_buffer_count(rtp->recv_buffer)) {\n\t\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t}\n\n\t\tif (!AST_VECTOR_REMOVE_CMP_ORDERED(&rtp->missing_seqno, seqno, find_by_value,\n\t\t\tAST_VECTOR_ELEM_CLEANUP_NOOP)) {\n\t\t\tast_debug_rtp(2, \"(%p) RTP Packet with sequence number '%d' on instance is no longer missing\\n\",\n\t\t\t\tinstance, seqno);\n\t\t}\n\n\t\t/* If we don't have the next packet after this we can directly return the frame, as there is no\n\t\t * chance it will be overwritten.\n\t\t */\n\t\tif (!ast_data_buffer_get(rtp->recv_buffer, rtp->expectedrxseqno)) {\n\t\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t}\n\n\t\t/* Otherwise we need to dupe the frame so that the potential processing of frames placed after\n\t\t * it do not overwrite the data. You may be thinking that we could just add the current packet\n\t\t * to the head of the frames list and avoid having to duplicate it but this would result in out\n\t\t * of order packet processing by libsrtp which we are trying to avoid.\n\t\t */\n\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled));\n\t\tif (frame) {\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\tprev_seqno = seqno;\n\t\t}\n\n\t\t/* Add any additional packets that we have buffered and that are available */\n\t\twhile (ast_data_buffer_count(rtp->recv_buffer)) {\n\t\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\n\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, rtp->expectedrxseqno);\n\t\t\tif (!payload) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, payload->buf, payload->size, prev_seqno, bundled));\n\t\t\tast_free(payload);\n\n\t\t\tif (!frame) {\n\t\t\t\t/* If this packet can't be interpreted due to being out of memory we return what we have and assume\n\t\t\t\t * that we will determine it is a missing packet later and NACK for it.\n\t\t\t\t */\n\t\t\t\treturn AST_LIST_FIRST(&frames);\n\t\t\t}\n\n\t\t\tast_debug_rtp(2, \"(%p) RTP pulled buffered packet with sequence number '%d' to additionally return\\n\",\n\t\t\t\tinstance, frame->seqno);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\tprev_seqno = rtp->expectedrxseqno;\n\t\t\trtp->expectedrxseqno++;\n\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn AST_LIST_FIRST(&frames);\n\t} else if ((((seqno - rtp->expectedrxseqno) > 100) && timestamp > rtp->lastividtimestamp) ||\n\t\tast_data_buffer_count(rtp->recv_buffer) == ast_data_buffer_max(rtp->recv_buffer)) {\n\t\tint inserted = 0;\n\n\t\t/* We have a large number of outstanding buffered packets or we've jumped far ahead in time.\n\t\t * To compensate we dump what we have in the buffer and place the current packet in a logical\n\t\t * spot. In the case of video we also require a full frame to give the decoding side a fighting\n\t\t * chance.\n\t\t */\n\n\t\tif (rtp->rtp_source_learn.stream_type == AST_MEDIA_TYPE_VIDEO) {\n\t\t\tast_debug_rtp(2, \"(%p) RTP source has wild gap or packet loss, sending FIR\\n\",\n\t\t\t\tinstance);\n\t\t\trtp_write_rtcp_fir(instance, rtp, &remote_address);\n\t\t}\n\n\t\t/* This works by going through the progression of the sequence number retrieving buffered packets\n\t\t * or inserting the current received packet until we've run out of packets. This ensures that the\n\t\t * packets are in the correct sequence number order.\n\t\t */\n\t\twhile (ast_data_buffer_count(rtp->recv_buffer)) {\n\t\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\n\t\t\t/* If the packet we received is the one we are expecting at this point then add it in */\n\t\t\tif (rtp->expectedrxseqno == seqno) {\n\t\t\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled));\n\t\t\t\tif (frame) {\n\t\t\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\t\t\tprev_seqno = seqno;\n\t\t\t\t\tast_debug_rtp(2, \"(%p) RTP inserted just received packet with sequence number '%d' in correct order\\n\",\n\t\t\t\t\t\tinstance, seqno);\n\t\t\t\t}\n\t\t\t\t/* It is possible due to packet retransmission for this packet to also exist in the receive\n\t\t\t\t * buffer so we explicitly remove it in case this occurs, otherwise the receive buffer will\n\t\t\t\t * never be empty.\n\t\t\t\t */\n\t\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, seqno);\n\t\t\t\tif (payload) {\n\t\t\t\t\tast_free(payload);\n\t\t\t\t}\n\t\t\t\trtp->expectedrxseqno++;\n\t\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t\t}\n\t\t\t\tinserted = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpayload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, rtp->expectedrxseqno);\n\t\t\tif (payload) {\n\t\t\t\tframe = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, payload->buf, payload->size, prev_seqno, bundled));\n\t\t\t\tif (frame) {\n\t\t\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\t\t\tprev_seqno = rtp->expectedrxseqno;\n\t\t\t\t\tast_debug_rtp(2, \"(%p) RTP emptying queue and returning packet with sequence number '%d'\\n\",\n\t\t\t\t\t\tinstance, frame->seqno);\n\t\t\t\t}\n\t\t\t\tast_free(payload);\n\t\t\t}\n\n\t\t\trtp->expectedrxseqno++;\n\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!inserted) {\n\t\t\t/* This current packet goes after them, and we assume that packets going forward will follow\n\t\t\t * that new sequence number increment. It is okay for this to not be duplicated as it is guaranteed\n\t\t\t * to be the last packet processed right now and it is also guaranteed that it will always return\n\t\t\t * non-NULL.\n\t\t\t */\n\t\t\tframe = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);\n\t\t\tAST_LIST_INSERT_TAIL(&frames, frame, frame_list);\n\t\t\trtp->expectedrxseqno = seqno + 1;\n\t\t\tif (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {\n\t\t\t\trtp->expectedrxseqno = 0;\n\t\t\t}\n\n\t\t\tast_debug_rtp(2, \"(%p) RTP adding just received packet with sequence number '%d' to end of dumped queue\\n\",\n\t\t\t\tinstance, seqno);\n\t\t}\n\n\t\t/* When we flush increase our chance for next time by growing the receive buffer when possible\n\t\t * by how many packets we missed, to give ourselves a bit more breathing room.\n\t\t */\n\t\tast_data_buffer_resize(rtp->recv_buffer, MIN(MAXIMUM_RTP_RECV_BUFFER_SIZE,\n\t\t\tast_data_buffer_max(rtp->recv_buffer) + AST_VECTOR_SIZE(&rtp->missing_seqno)));\n\t\tast_debug_rtp(2, \"(%p) RTP receive buffer is now at maximum of %zu\\n\", instance, ast_data_buffer_max(rtp->recv_buffer));\n\n\t\t/* As there is such a large gap we don't want to flood the order side with missing packets, so we\n\t\t * give up and start anew.\n\t\t */\n\t\tAST_VECTOR_RESET(&rtp->missing_seqno, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\n\t\treturn AST_LIST_FIRST(&frames);\n\t}\n\n\t/* We're finished with the frames list */\n\tast_frame_free(AST_LIST_FIRST(&frames), 0);\n\n\t/* Determine if the received packet is from the last OLD_PACKET_COUNT (1000 by default) packets or not.\n\t * For the case where the received sequence number exceeds that of the expected sequence number we calculate\n\t * the past sequence number that would be 1000 sequence numbers ago. If the received sequence number\n\t * exceeds or meets that then it is within OLD_PACKET_COUNT packets ago. For example if the expected\n\t * sequence number is 100 and we receive 65530, then it would be considered old. This is because\n\t * 65535 - 1000 + 100 = 64635 which gives us the sequence number at which we would consider the packets\n\t * old. Since 65530 is above that, it would be considered old.\n\t * For the case where the received sequence number is less than the expected sequence number we can do\n\t * a simple subtraction to see if it is 1000 packets ago or not.\n\t */\n\tif ((seqno < rtp->expectedrxseqno && ((rtp->expectedrxseqno - seqno) <= OLD_PACKET_COUNT)) ||\n\t\t(seqno > rtp->expectedrxseqno && (seqno >= (65535 - OLD_PACKET_COUNT + rtp->expectedrxseqno)))) {\n\t\t/* If this is a packet from the past then we have received a duplicate packet, so just drop it */\n\t\tast_debug_rtp(2, \"(%p) RTP received an old packet with sequence number '%d', dropping it\\n\",\n\t\t\tinstance, seqno);\n\t\treturn &ast_null_frame;\n\t} else if (ast_data_buffer_get(rtp->recv_buffer, seqno)) {\n\t\t/* If this is a packet we already have buffered then it is a duplicate, so just drop it */\n\t\tast_debug_rtp(2, \"(%p) RTP received a duplicate transmission of packet with sequence number '%d', dropping it\\n\",\n\t\t\tinstance, seqno);\n\t\treturn &ast_null_frame;\n\t} else {\n\t\t/* This is an out of order packet from the future */\n\t\tstruct ast_rtp_rtcp_nack_payload *payload;\n\t\tint missing_seqno;\n\t\tint remove_failed;\n\t\tunsigned int missing_seqnos_added = 0;\n\n\t\tast_debug_rtp(2, \"(%p) RTP received an out of order packet with sequence number '%d' while expecting '%d' from the future\\n\",\n\t\t\tinstance, seqno, rtp->expectedrxseqno);\n\n\t\tpayload = ast_malloc(sizeof(*payload) + res);\n\t\tif (!payload) {\n\t\t\t/* If the payload can't be allocated then we can't defer this packet right now.\n\t\t\t * Instead of dumping what we have we pretend we lost this packet. It will then\n\t\t\t * get NACKed later or the existing buffer will be returned entirely. Well, we may\n\t\t\t * try since we're seemingly out of memory. It's a bad situation all around and\n\t\t\t * packets are likely to get lost anyway.\n\t\t\t */\n\t\t\treturn &ast_null_frame;\n\t\t}\n\n\t\tpayload->size = res;\n\t\tmemcpy(payload->buf, rtpheader, res);\n\t\tif (ast_data_buffer_put(rtp->recv_buffer, seqno, payload) == -1) {\n\t\t\tast_free(payload);\n\t\t}\n\n\t\t/* If this sequence number is removed that means we had a gap and this packet has filled it in\n\t\t * some. Since it was part of the gap we will have already added any other missing sequence numbers\n\t\t * before it (and possibly after it) to the vector so we don't need to do that again. Note that\n\t\t * remove_failed will be set to -1 if the sequence number isn't removed, and 0 if it is.\n\t\t */\n\t\tremove_failed = AST_VECTOR_REMOVE_CMP_ORDERED(&rtp->missing_seqno, seqno, find_by_value,\n\t\t\tAST_VECTOR_ELEM_CLEANUP_NOOP);\n\t\tif (!remove_failed) {\n\t\t\tast_debug_rtp(2, \"(%p) RTP packet with sequence number '%d' is no longer missing\\n\",\n\t\t\t\tinstance, seqno);\n\t\t}\n\n\t\t/* The missing sequence number code works by taking the sequence number of the\n\t\t * packet we've just received and going backwards until we hit the sequence number\n\t\t * of the last packet we've received. While doing so we check to make sure that the\n\t\t * sequence number is not already missing and that it is not already buffered.\n\t\t */\n\t\tmissing_seqno = seqno;\n\t\twhile (remove_failed) {\n\t\t\tmissing_seqno -= 1;\n\n\t\t\t/* If we've cycled backwards then start back at the top */\n\t\t\tif (missing_seqno < 0) {\n\t\t\t\tmissing_seqno = 65535;\n\t\t\t}\n\n\t\t\t/* We've gone backwards enough such that we've hit the previous sequence number */\n\t\t\tif (missing_seqno == prev_seqno) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* We don't want missing sequence number duplicates. If, for some reason,\n\t\t\t * packets are really out of order, we could end up in this scenario:\n\t\t\t *\n\t\t\t * We are expecting sequence number 100\n\t\t\t * We receive sequence number 105\n\t\t\t * Sequence numbers 100 through 104 get added to the vector\n\t\t\t * We receive sequence number 101 (this section is skipped)\n\t\t\t * We receive sequence number 103\n\t\t\t * Sequence number 102 is added to the vector\n\t\t\t *\n\t\t\t * This will prevent the duplicate from being added.\n\t\t\t */\n\t\t\tif (AST_VECTOR_GET_CMP(&rtp->missing_seqno, missing_seqno,\n\t\t\t\t\t\tfind_by_value)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If this packet has been buffered already then don't count it amongst the\n\t\t\t * missing.\n\t\t\t */\n\t\t\tif (ast_data_buffer_get(rtp->recv_buffer, missing_seqno)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_debug_rtp(2, \"(%p) RTP added missing sequence number '%d'\\n\",\n\t\t\t\tinstance, missing_seqno);\n\t\t\tAST_VECTOR_ADD_SORTED(&rtp->missing_seqno, missing_seqno,\n\t\t\t\t\tcompare_by_value);\n\t\t\tmissing_seqnos_added++;\n\t\t}\n\n\t\t/* When we add a large number of missing sequence numbers we assume there was a substantial\n\t\t * gap in reception so we trigger an immediate NACK. When our data buffer is 1/4 full we\n\t\t * assume that the packets aren't just out of order but have actually been lost. At 1/2\n\t\t * full we get more aggressive and ask for retransmission when we get a new packet.\n\t\t * To get them back we construct and send a NACK causing the sender to retransmit them.\n\t\t */\n\t\tif (missing_seqnos_added >= MISSING_SEQNOS_ADDED_TRIGGER ||\n\t\t\tast_data_buffer_count(rtp->recv_buffer) == ast_data_buffer_max(rtp->recv_buffer) / 4 ||\n\t\t\tast_data_buffer_count(rtp->recv_buffer) >= ast_data_buffer_max(rtp->recv_buffer) / 2) {\n\t\t\tint packet_len = 0;\n\t\t\tint res = 0;\n\t\t\tint ice;\n\t\t\tint sr;\n\t\t\tsize_t data_size = AST_UUID_STR_LEN + 128 + (AST_VECTOR_SIZE(&rtp->missing_seqno) * 4);\n\t\t\tRAII_VAR(unsigned char *, rtcpheader, NULL, ast_free_ptr);\n\t\t\tRAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report,\n\t\t\t\t\tast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0),\n\t\t\t\t\tao2_cleanup);\n\n\t\t\t/* Sufficient space for RTCP headers and report, SDES with CNAME, NACK header,\n\t\t\t * and worst case 4 bytes per missing sequence number.\n\t\t\t */\n\t\t\trtcpheader = ast_malloc(sizeof(*rtcpheader) + data_size);\n\t\t\tif (!rtcpheader) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to allocate memory for NACK\\n\", instance);\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\n\t\t\tmemset(rtcpheader, 0, data_size);\n\n\t\t\tres = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);\n\n\t\t\tif (res == 0 || res == 1) {\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\n\t\t\tpacket_len += res;\n\n\t\t\tres = ast_rtcp_generate_nack(instance, rtcpheader + packet_len);\n\n\t\t\tif (res == 0) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to construct NACK, stopping here\\n\", instance);\n\t\t\t\treturn &ast_null_frame;\n\t\t\t}\n\n\t\t\tpacket_len += res;\n\n\t\t\tres = rtcp_sendto(instance, rtcpheader, packet_len, 0, &remote_address, &ice);\n\t\t\tif (res < 0) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to send NACK request out\\n\", instance);\n\t\t\t} else {\n\t\t\t\tast_debug_rtcp(2, \"(%p) RTCP sending a NACK request to get missing packets\\n\", instance);\n\t\t\t\t/* Update RTCP SR/RR statistics */\n\t\t\t\tast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, remote_address, ice, sr);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &ast_null_frame;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_prop_set(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (property == AST_RTP_PROPERTY_RTCP) {\n\t\tif (value) {\n\t\t\tstruct ast_sockaddr local_addr;\n\n\t\t\tif (rtp->rtcp && rtp->rtcp->type == value) {\n\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP ignoring duplicate property\\n\", instance);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!rtp->rtcp) {\n\t\t\t\trtp->rtcp = ast_calloc(1, sizeof(*rtp->rtcp));\n\t\t\t\tif (!rtp->rtcp) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\trtp->rtcp->s = -1;\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\trtp->rtcp->dtls.timeout_timer = -1;\n#endif\n\t\t\t\trtp->rtcp->schedid = -1;\n\t\t\t}\n\n\t\t\trtp->rtcp->type = value;\n\n\t\t\t/* Grab the IP address and port we are going to use */\n\t\t\tast_rtp_instance_get_local_address(instance, &rtp->rtcp->us);\n\t\t\tif (value == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\t\tast_sockaddr_set_port(&rtp->rtcp->us,\n\t\t\t\t\tast_sockaddr_port(&rtp->rtcp->us) + 1);\n\t\t\t}\n\n\t\t\tast_sockaddr_copy(&local_addr, &rtp->rtcp->us);\n\t\t\tif (!ast_find_ourip(&local_addr, &rtp->rtcp->us, 0)) {\n\t\t\t\tast_sockaddr_set_port(&local_addr, ast_sockaddr_port(&rtp->rtcp->us));\n\t\t\t} else {\n\t\t\t\t/* Failed to get local address reset to use default. */\n\t\t\t\tast_sockaddr_copy(&local_addr, &rtp->rtcp->us);\n\t\t\t}\n\n\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\trtp->rtcp->local_addr_str = ast_strdup(ast_sockaddr_stringify(&local_addr));\n\t\t\tif (!rtp->rtcp->local_addr_str) {\n\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\trtp->rtcp = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (value == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\t\t/* We're either setting up RTCP from scratch or\n\t\t\t\t * switching from MUX. Either way, we won't have\n\t\t\t\t * a socket set up, and we need to set it up\n\t\t\t\t */\n\t\t\t\tif ((rtp->rtcp->s =\n\t\t\t\t     create_new_socket(\"RTCP\",\n\t\t\t\t\t\t       ast_sockaddr_is_ipv4(&rtp->rtcp->us) ?\n\t\t\t\t\t\t       AF_INET :\n\t\t\t\t\t\t       ast_sockaddr_is_ipv6(&rtp->rtcp->us) ?\n\t\t\t\t\t\t       AF_INET6 : -1)) < 0) {\n\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to create a new socket\\n\", instance);\n\t\t\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\t\trtp->rtcp = NULL;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/* Try to actually bind to the IP address and port we are going to use for RTCP, if this fails we have to bail out */\n\t\t\t\tif (ast_bind(rtp->rtcp->s, &rtp->rtcp->us)) {\n\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to setup RTP instance\\n\", instance);\n\t\t\t\t\tclose(rtp->rtcp->s);\n\t\t\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\t\trtp->rtcp = NULL;\n\t\t\t\t\treturn;\n\t\t\t\t}\n#ifdef HAVE_PJPROJECT\n\t\t\t\tif (rtp->ice) {\n\t\t\t\t\trtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP);\n\t\t\t\t}\n#endif\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\tdtls_setup_rtcp(instance);\n#endif\n\t\t\t} else {\n\t\t\t\tstruct ast_sockaddr addr;\n\t\t\t\t/* RTCPMUX uses the same socket as RTP. If we were previously using standard RTCP\n\t\t\t\t * then close the socket we previously created.\n\t\t\t\t *\n\t\t\t\t * It may seem as though there is a possible race condition here where we might try\n\t\t\t\t * to close the RTCP socket while it is being used to send data. However, this is not\n\t\t\t\t * a problem in practice since setting and adjusting of RTCP properties happens prior\n\t\t\t\t * to activating RTP. It is not until RTP is activated that timers start for RTCP\n\t\t\t\t * transmission\n\t\t\t\t */\n\t\t\t\tif (rtp->rtcp->s > -1 && rtp->rtcp->s != rtp->s) {\n\t\t\t\t\tclose(rtp->rtcp->s);\n\t\t\t\t}\n\t\t\t\trtp->rtcp->s = rtp->s;\n\t\t\t\tast_rtp_instance_get_remote_address(instance, &addr);\n\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, &addr);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\tif (rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {\n\t\t\t\t\tSSL_free(rtp->rtcp->dtls.ssl);\n\t\t\t\t}\n\t\t\t\trtp->rtcp->dtls.ssl = rtp->dtls.ssl;\n#endif\n\t\t\t}\n\n\t\t\tast_debug_rtcp(1, \"(%s) RTCP setup on RTP instance\\n\",\n\t\t\t\tast_rtp_instance_get_channel_id(instance));\n\t\t} else {\n\t\t\tif (rtp->rtcp) {\n\t\t\t\tif (rtp->rtcp->schedid > -1) {\n\t\t\t\t\tao2_unlock(instance);\n\t\t\t\t\tif (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {\n\t\t\t\t\t\t/* Successfully cancelled scheduler entry. */\n\t\t\t\t\t\tao2_ref(instance, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Unable to cancel scheduler entry */\n\t\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to tear down RTCP\\n\", instance);\n\t\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\trtp->rtcp->schedid = -1;\n\t\t\t\t}\n\t\t\t\tif (rtp->transport_wide_cc.schedid > -1) {\n\t\t\t\t\tao2_unlock(instance);\n\t\t\t\t\tif (!ast_sched_del(rtp->sched, rtp->transport_wide_cc.schedid)) {\n\t\t\t\t\t\tao2_ref(instance, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_debug_rtcp(1, \"(%p) RTCP failed to tear down transport-cc feedback\\n\", instance);\n\t\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tao2_lock(instance);\n\t\t\t\t\trtp->transport_wide_cc.schedid = -1;\n\t\t\t\t}\n\t\t\t\tif (rtp->rtcp->s > -1 && rtp->rtcp->s != rtp->s) {\n\t\t\t\t\tclose(rtp->rtcp->s);\n\t\t\t\t}\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t\t\t\tao2_unlock(instance);\n\t\t\t\tdtls_srtp_stop_timeout_timer(instance, rtp, 1);\n\t\t\t\tao2_lock(instance);\n\n\t\t\t\tif (rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {\n\t\t\t\t\tSSL_free(rtp->rtcp->dtls.ssl);\n\t\t\t\t}\n#endif\n\t\t\t\tast_free(rtp->rtcp->local_addr_str);\n\t\t\t\tast_free(rtp->rtcp);\n\t\t\t\trtp->rtcp = NULL;\n\t\t\t\tast_debug_rtcp(1, \"(%s) RTCP torn down on RTP instance\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance));\n\t\t\t}\n\t\t}\n\t} else if (property == AST_RTP_PROPERTY_ASYMMETRIC_CODEC) {\n\t\trtp->asymmetric_codec = value;\n\t} else if (property == AST_RTP_PROPERTY_RETRANS_SEND) {\n\t\tif (value) {\n\t\t\tif (!rtp->send_buffer) {\n\t\t\t\trtp->send_buffer = ast_data_buffer_alloc(ast_free_ptr, DEFAULT_RTP_SEND_BUFFER_SIZE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp->send_buffer) {\n\t\t\t\tast_data_buffer_free(rtp->send_buffer);\n\t\t\t\trtp->send_buffer = NULL;\n\t\t\t}\n\t\t}\n\t} else if (property == AST_RTP_PROPERTY_RETRANS_RECV) {\n\t\tif (value) {\n\t\t\tif (!rtp->recv_buffer) {\n\t\t\t\trtp->recv_buffer = ast_data_buffer_alloc(ast_free_ptr, DEFAULT_RTP_RECV_BUFFER_SIZE);\n\t\t\t\tAST_VECTOR_INIT(&rtp->missing_seqno, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp->recv_buffer) {\n\t\t\t\tast_data_buffer_free(rtp->recv_buffer);\n\t\t\t\trtp->recv_buffer = NULL;\n\t\t\t\tAST_VECTOR_FREE(&rtp->missing_seqno);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_fd(struct ast_rtp_instance *instance, int rtcp)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtcp ? (rtp->rtcp ? rtp->rtcp->s : -1) : rtp->s;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr local;\n\tint index;\n\n\tast_rtp_instance_get_local_address(instance, &local);\n\tif (!ast_sockaddr_isnull(addr)) {\n\t\t/* Update the local RTP address with what is being used */\n\t\tif (ast_ouraddrfor(addr, &local)) {\n\t\t\t/* Failed to update our address so reuse old local address */\n\t\t\tast_rtp_instance_get_local_address(instance, &local);\n\t\t} else {\n\t\t\tast_rtp_instance_set_local_address(instance, &local);\n\t\t}\n\t}\n\n\tif (rtp->rtcp && !ast_sockaddr_isnull(addr)) {\n\t\tast_debug_rtcp(1, \"(%p) RTCP setting address on RTP instance\\n\", instance);\n\t\tast_sockaddr_copy(&rtp->rtcp->them, addr);\n\n\t\tif (rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\t\tast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(addr) + 1);\n\n\t\t\t/* Update the local RTCP address with what is being used */\n\t\t\tast_sockaddr_set_port(&local, ast_sockaddr_port(&local) + 1);\n\t\t}\n\t\tast_sockaddr_copy(&rtp->rtcp->us, &local);\n\n\t\tast_free(rtp->rtcp->local_addr_str);\n\t\trtp->rtcp->local_addr_str = ast_strdup(ast_sockaddr_stringify(&local));\n\t}\n\n\t/* Update any bundled RTP instances */\n\tfor (index = 0; index < AST_VECTOR_SIZE(&rtp->ssrc_mapping); ++index) {\n\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&rtp->ssrc_mapping, index);\n\n\t\tast_rtp_instance_set_remote_address(mapping->instance, addr);\n\t}\n\n\t/* Need to reset the DTMF last sequence number and the timestamp of the last END packet */\n\trtp->last_seqno = 0;\n\trtp->last_end_timestamp.ts = 0;\n\trtp->last_end_timestamp.is_set = 0;\n\n\tif (strictrtp && rtp->strict_rtp_state != STRICT_RTP_OPEN\n\t\t&& !ast_sockaddr_isnull(addr) && ast_sockaddr_cmp(addr, &rtp->strict_rtp_address)) {\n\t\t/* We only need to learn a new strict source address if we've been told the source is\n\t\t * changing to something different.\n\t\t */\n\t\tast_verb(4, \"%p -- Strict RTP learning after remote address set to: %s\\n\",\n\t\t\trtp, ast_sockaddr_stringify(addr));\n\t\trtp_learning_start(rtp);\n\t}\n}\n\n/*!\n * \\brief Write t140 redundancy frame\n *\n * \\param data primary data to be buffered\n *\n * Scheduler callback\n */\nstatic int red_write(const void *data)\n{\n\tstruct ast_rtp_instance *instance = (struct ast_rtp_instance*) data;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tao2_lock(instance);\n\tif (rtp->red->t140.datalen > 0) {\n\t\tast_rtp_write(instance, &rtp->red->t140);\n\t}\n\tao2_unlock(instance);\n\n\treturn 1;\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tint x;\n\n\trtp->red = ast_calloc(1, sizeof(*rtp->red));\n\tif (!rtp->red) {\n\t\treturn -1;\n\t}\n\n\trtp->red->t140.frametype = AST_FRAME_TEXT;\n\trtp->red->t140.subclass.format = ast_format_t140_red;\n\trtp->red->t140.data.ptr = &rtp->red->buf_data;\n\n\trtp->red->t140red = rtp->red->t140;\n\trtp->red->t140red.data.ptr = &rtp->red->t140red_data;\n\n\trtp->red->ti = buffer_time;\n\trtp->red->num_gen = generations;\n\trtp->red->hdrlen = generations * 4 + 1;\n\n\tfor (x = 0; x < generations; x++) {\n\t\trtp->red->pt[x] = payloads[x];\n\t\trtp->red->pt[x] |= 1 << 7; /* mark redundant generations pt */\n\t\trtp->red->t140red_data[x*4] = rtp->red->pt[x];\n\t}\n\trtp->red->t140red_data[x*4] = rtp->red->pt[x] = payloads[x]; /* primary pt */\n\trtp->red->schedid = ast_sched_add(rtp->sched, generations, red_write, instance);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int rtp_red_buffer(struct ast_rtp_instance *instance, struct ast_frame *frame)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct rtp_red *red = rtp->red;\n\n\tif (!red) {\n\t\treturn 0;\n\t}\n\n\tif (frame->datalen > 0) {\n\t\tif (red->t140.datalen > 0) {\n\t\t\tconst unsigned char *primary = red->buf_data;\n\n\t\t\t/* There is something already in the T.140 buffer */\n\t\t\tif (primary[0] == 0x08 || primary[0] == 0x0a || primary[0] == 0x0d) {\n\t\t\t\t/* Flush the previous T.140 packet if it is a command */\n\t\t\t\tast_rtp_write(instance, &rtp->red->t140);\n\t\t\t} else {\n\t\t\t\tprimary = frame->data.ptr;\n\t\t\t\tif (primary[0] == 0x08 || primary[0] == 0x0a || primary[0] == 0x0d) {\n\t\t\t\t\t/* Flush the previous T.140 packet if we are buffering a command now */\n\t\t\t\t\tast_rtp_write(instance, &rtp->red->t140);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(&red->buf_data[red->t140.datalen], frame->data.ptr, frame->datalen);\n\t\tred->t140.datalen += frame->datalen;\n\t\tred->t140.ts = frame->ts;\n\t}\n\n\treturn 0;\n}\n\n/*! \\pre Neither instance0 nor instance1 are locked */\nstatic int ast_rtp_local_bridge(struct ast_rtp_instance *instance0, struct ast_rtp_instance *instance1)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance0);\n\n\tao2_lock(instance0);\n\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT | FLAG_REQ_LOCAL_BRIDGE_BIT);\n\tif (rtp->smoother) {\n\t\tast_smoother_free(rtp->smoother);\n\t\trtp->smoother = NULL;\n\t}\n\n\t/* We must use a new SSRC when local bridge ends */\n\tif (!instance1) {\n\t\trtp->ssrc = rtp->ssrc_orig;\n\t\trtp->ssrc_orig = 0;\n\t\trtp->ssrc_saved = 0;\n\t} else if (!rtp->ssrc_saved) {\n\t\t/* In case ast_rtp_local_bridge is called multiple times, only save the ssrc from before local bridge began */\n\t\trtp->ssrc_orig = rtp->ssrc;\n\t\trtp->ssrc_saved = 1;\n\t}\n\n\tao2_unlock(instance0);\n\n\treturn 0;\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_get_stat(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (!rtp->rtcp) {\n\t\treturn -1;\n\t}\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXCOUNT, -1, stats->txcount, rtp->txcount);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXCOUNT, -1, stats->rxcount, rtp->rxcount);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXOCTETCOUNT, -1, stats->txoctetcount, rtp->txoctetcount);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXOCTETCOUNT, -1, stats->rxoctetcount, rtp->rxoctetcount);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->txploss, rtp->rtcp->reported_lost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->rxploss, rtp->rtcp->expected_prior - rtp->rtcp->received_prior);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MAXRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_maxrxploss, rtp->rtcp->reported_maxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MINRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_minrxploss, rtp->rtcp->reported_minlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_NORMDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_normdevrxploss, rtp->rtcp->reported_normdev_lost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_STDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->remote_stdevrxploss, rtp->rtcp->reported_stdev_lost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MAXRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_maxrxploss, rtp->rtcp->maxrxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MINRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_minrxploss, rtp->rtcp->minrxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_NORMDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_normdevrxploss, rtp->rtcp->normdev_rxlost);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_STDEVRXPLOSS, AST_RTP_INSTANCE_STAT_COMBINED_LOSS, stats->local_stdevrxploss, rtp->rtcp->stdev_rxlost);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_LOSS);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->txjitter, rtp->rxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->rxjitter, rtp->rtcp->reported_jitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MAXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_maxjitter, rtp->rtcp->reported_maxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MINJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_minjitter, rtp->rtcp->reported_minjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_NORMDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_normdevjitter, rtp->rtcp->reported_normdev_jitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_STDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->remote_stdevjitter, rtp->rtcp->reported_stdev_jitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MAXJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_maxjitter, rtp->rtcp->maxrxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MINJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_minjitter, rtp->rtcp->minrxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_NORMDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_normdevjitter, rtp->rtcp->normdev_rxjitter);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_STDEVJITTER, AST_RTP_INSTANCE_STAT_COMBINED_JITTER, stats->local_stdevjitter, rtp->rtcp->stdev_rxjitter);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_JITTER);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->rtt, rtp->rtcp->rtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_MAX_RTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->maxrtt, rtp->rtcp->maxrtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_MIN_RTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->minrtt, rtp->rtcp->minrtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_NORMDEVRTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->normdevrtt, rtp->rtcp->normdevrtt);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_STDEVRTT, AST_RTP_INSTANCE_STAT_COMBINED_RTT, stats->stdevrtt, rtp->rtcp->stdevrtt);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_RTT);\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_TXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->txmes, rtp->rxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_RXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->rxmes, rtp->rtcp->reported_mes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MAXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_maxmes, rtp->rtcp->reported_maxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_MINMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_minmes, rtp->rtcp->reported_minmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_NORMDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_normdevmes, rtp->rtcp->reported_normdev_mes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_STDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->remote_stdevmes, rtp->rtcp->reported_stdev_mes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MAXMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_maxmes, rtp->rtcp->maxrxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_MINMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_minmes, rtp->rtcp->minrxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_NORMDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_normdevmes, rtp->rtcp->normdev_rxmes);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_STDEVMES, AST_RTP_INSTANCE_STAT_COMBINED_MES, stats->local_stdevmes, rtp->rtcp->stdev_rxjitter);\n\tAST_RTP_STAT_TERMINATOR(AST_RTP_INSTANCE_STAT_COMBINED_MES);\n\n\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_SSRC, -1, stats->local_ssrc, rtp->ssrc);\n\tAST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_SSRC, -1, stats->remote_ssrc, rtp->themssrc);\n\tAST_RTP_STAT_STRCPY(AST_RTP_INSTANCE_STAT_CHANNEL_UNIQUEID, -1, stats->channel_uniqueid, ast_rtp_instance_get_channel_id(instance));\n\n\treturn 0;\n}\n\n/*! \\pre Neither instance0 nor instance1 are locked */\nstatic int ast_rtp_dtmf_compatible(struct ast_channel *chan0, struct ast_rtp_instance *instance0, struct ast_channel *chan1, struct ast_rtp_instance *instance1)\n{\n\t/* If both sides are not using the same method of DTMF transmission\n\t * (ie: one is RFC2833, other is INFO... then we can not do direct media.\n\t * --------------------------------------------------\n\t * | DTMF Mode |  HAS_DTMF  |  Accepts Begin Frames |\n\t * |-----------|------------|-----------------------|\n\t * | Inband    | False      | True                  |\n\t * | RFC2833   | True       | True                  |\n\t * | SIP INFO  | False      | False                 |\n\t * --------------------------------------------------\n\t */\n\treturn (((ast_rtp_instance_get_prop(instance0, AST_RTP_PROPERTY_DTMF) != ast_rtp_instance_get_prop(instance1, AST_RTP_PROPERTY_DTMF)) ||\n\t\t (!ast_channel_tech(chan0)->send_digit_begin != !ast_channel_tech(chan1)->send_digit_begin)) ? 0 : 1);\n}\n\n/*! \\pre instance is NOT locked */\nstatic void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct sockaddr_in suggestion_tmp;\n\n\t/*\n\t * The instance should not be locked because we can block\n\t * waiting for a STUN respone.\n\t */\n\tast_sockaddr_to_sin(suggestion, &suggestion_tmp);\n\tast_stun_request(rtp->s, &suggestion_tmp, username, NULL);\n\tast_sockaddr_from_sin(suggestion, &suggestion_tmp);\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_stop(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr addr = { {0,} };\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tao2_unlock(instance);\n\tAST_SCHED_DEL_UNREF(rtp->sched, rtp->rekeyid, ao2_ref(instance, -1));\n\n\tdtls_srtp_stop_timeout_timer(instance, rtp, 0);\n\tif (rtp->rtcp) {\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, 1);\n\t}\n\tao2_lock(instance);\n#endif\n\tast_debug_rtp(1, \"(%s) RTP Stop\\n\",\n\t\tast_rtp_instance_get_channel_id(instance));\n\n\tif (rtp->rtcp && rtp->rtcp->schedid > -1) {\n\t\tao2_unlock(instance);\n\t\tif (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {\n\t\t\t/* successfully cancelled scheduler entry. */\n\t\t\tao2_ref(instance, -1);\n\t\t}\n\t\tao2_lock(instance);\n\t\trtp->rtcp->schedid = -1;\n\t}\n\n\tif (rtp->transport_wide_cc.schedid > -1) {\n\t\tao2_unlock(instance);\n\t\tif (!ast_sched_del(rtp->sched, rtp->transport_wide_cc.schedid)) {\n\t\t\tao2_ref(instance, -1);\n\t\t}\n\t\tao2_lock(instance);\n\t\trtp->transport_wide_cc.schedid = -1;\n        }\n\n\tif (rtp->red) {\n\t\tao2_unlock(instance);\n\t\tAST_SCHED_DEL(rtp->sched, rtp->red->schedid);\n\t\tao2_lock(instance);\n\t\tast_free(rtp->red);\n\t\trtp->red = NULL;\n\t}\n\n\tast_rtp_instance_set_remote_address(instance, &addr);\n\n\tast_set_flag(rtp, FLAG_NEED_MARKER_BIT);\n}\n\n/*! \\pre instance is locked */\nstatic int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char *desc)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn ast_set_qos(rtp->s, tos, cos, desc);\n}\n\n/*!\n * \\brief generate comfort noice (CNG)\n *\n * \\pre instance is locked\n */\nstatic int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level)\n{\n\tunsigned int *rtpheader;\n\tint hdrlen = 12;\n\tint res, payload = 0;\n\tchar data[256];\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\tstruct ast_sockaddr remote_address = { {0,} };\n\tint ice;\n\n\tast_rtp_instance_get_remote_address(instance, &remote_address);\n\n\tif (ast_sockaddr_isnull(&remote_address)) {\n\t\treturn -1;\n\t}\n\n\tpayload = ast_rtp_codecs_payload_code_tx(ast_rtp_instance_get_codecs(instance), 0, NULL, AST_RTP_CN);\n\n\tlevel = 127 - (level & 0x7f);\n\n\trtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));\n\n\t/* Get a pointer to the header */\n\trtpheader = (unsigned int *)data;\n\trtpheader[0] = htonl((2 << 30) | (payload << 16) | (rtp->seqno));\n\trtpheader[1] = htonl(rtp->lastts);\n\trtpheader[2] = htonl(rtp->ssrc);\n\tdata[12] = level;\n\n\tres = rtp_sendto(instance, (void *) rtpheader, hdrlen + 1, 0, &remote_address, &ice);\n\n\tif (res < 0) {\n\t\tast_log(LOG_ERROR, \"RTP Comfort Noise Transmission error to %s: %s\\n\", ast_sockaddr_stringify(&remote_address), strerror(errno));\n\t\treturn res;\n\t}\n\n\tif (rtp_debug_test_addr(&remote_address)) {\n\t\tast_verbose(\"Sent Comfort Noise RTP packet to %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\\n\",\n\t\t\t    ast_sockaddr_stringify(&remote_address),\n\t\t\t    ice ? \" (via ICE)\" : \"\",\n\t\t\t    AST_RTP_CN, rtp->seqno, rtp->lastdigitts, res - hdrlen);\n\t}\n\n\trtp->seqno++;\n\n\treturn res;\n}\n\n/*! \\pre instance is locked */\nstatic unsigned int ast_rtp_get_ssrc(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->ssrc;\n}\n\n/*! \\pre instance is locked */\nstatic const char *ast_rtp_get_cname(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\treturn rtp->cname;\n}\n\n/*! \\pre instance is locked */\nstatic void ast_rtp_set_remote_ssrc(struct ast_rtp_instance *instance, unsigned int ssrc)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\tif (rtp->themssrc_valid && rtp->themssrc == ssrc) {\n\t\treturn;\n\t}\n\n\trtp->themssrc = ssrc;\n\trtp->themssrc_valid = 1;\n\n\t/* If this is bundled we need to update the SSRC mapping */\n\tif (rtp->bundled) {\n\t\tstruct ast_rtp *bundled_rtp;\n\t\tint index;\n\n\t\tao2_unlock(instance);\n\n\t\t/* The child lock can't be held while accessing the parent */\n\t\tao2_lock(rtp->bundled);\n\t\tbundled_rtp = ast_rtp_instance_get_data(rtp->bundled);\n\n\t\tfor (index = 0; index < AST_VECTOR_SIZE(&bundled_rtp->ssrc_mapping); ++index) {\n\t\t\tstruct rtp_ssrc_mapping *mapping = AST_VECTOR_GET_ADDR(&bundled_rtp->ssrc_mapping, index);\n\n\t\t\tif (mapping->instance == instance) {\n\t\t\t\tmapping->ssrc = ssrc;\n\t\t\t\tmapping->ssrc_valid = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tao2_unlock(rtp->bundled);\n\n\t\tao2_lock(instance);\n\t}\n}\n\nstatic void ast_rtp_set_stream_num(struct ast_rtp_instance *instance, int stream_num)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\trtp->stream_num = stream_num;\n}\n\nstatic int ast_rtp_extension_enable(struct ast_rtp_instance *instance, enum ast_rtp_extension extension)\n{\n\tswitch (extension) {\n\tcase AST_RTP_EXTENSION_ABS_SEND_TIME:\n\tcase AST_RTP_EXTENSION_TRANSPORT_WIDE_CC:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/*! \\pre child is locked */\nstatic int ast_rtp_bundle(struct ast_rtp_instance *child, struct ast_rtp_instance *parent)\n{\n\tstruct ast_rtp *child_rtp = ast_rtp_instance_get_data(child);\n\tstruct ast_rtp *parent_rtp;\n\tstruct rtp_ssrc_mapping mapping;\n\tstruct ast_sockaddr them = { { 0, } };\n\n\tif (child_rtp->bundled == parent) {\n\t\treturn 0;\n\t}\n\n\t/* If this instance was already bundled then remove the SSRC mapping */\n\tif (child_rtp->bundled) {\n\t\tstruct ast_rtp *bundled_rtp;\n\n\t\tao2_unlock(child);\n\n\t\t/* The child lock can't be held while accessing the parent */\n\t\tao2_lock(child_rtp->bundled);\n\t\tbundled_rtp = ast_rtp_instance_get_data(child_rtp->bundled);\n\t\tAST_VECTOR_REMOVE_CMP_UNORDERED(&bundled_rtp->ssrc_mapping, child, SSRC_MAPPING_ELEM_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);\n\t\tao2_unlock(child_rtp->bundled);\n\n\t\tao2_lock(child);\n\t\tao2_ref(child_rtp->bundled, -1);\n\t\tchild_rtp->bundled = NULL;\n\t}\n\n\tif (!parent) {\n\t\t/* We transitioned away from bundle so we need our own transport resources once again */\n\t\trtp_allocate_transport(child, child_rtp);\n\t\treturn 0;\n\t}\n\n\tparent_rtp = ast_rtp_instance_get_data(parent);\n\n\t/* We no longer need any transport related resources as we will use our parent RTP instance instead */\n\trtp_deallocate_transport(child, child_rtp);\n\n\t/* Children maintain a reference to the parent to guarantee that the transport doesn't go away on them */\n\tchild_rtp->bundled = ao2_bump(parent);\n\n\tmapping.ssrc = child_rtp->themssrc;\n\tmapping.ssrc_valid = child_rtp->themssrc_valid;\n\tmapping.instance = child;\n\n\tao2_unlock(child);\n\n\tao2_lock(parent);\n\n\tAST_VECTOR_APPEND(&parent_rtp->ssrc_mapping, mapping);\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If DTLS-SRTP is already in use then add the local SSRC to it, otherwise it will get added once DTLS\n\t * negotiation has been completed.\n\t */\n\tif (parent_rtp->dtls.connection == AST_RTP_DTLS_CONNECTION_EXISTING) {\n\t\tdtls_srtp_add_local_ssrc(parent_rtp, parent, 0, child_rtp->ssrc, 0);\n\t}\n#endif\n\n\t/* Bundle requires that RTCP-MUX be in use so only the main remote address needs to match */\n\tast_rtp_instance_get_remote_address(parent, &them);\n\n\tao2_unlock(parent);\n\n\tao2_lock(child);\n\n\tast_rtp_instance_set_remote_address(child, &them);\n\n\treturn 0;\n}\n\n#ifdef HAVE_PJPROJECT\nstatic void stunaddr_resolve_callback(const struct ast_dns_query *query)\n{\n\tconst int lowest_ttl = ast_dns_result_get_lowest_ttl(ast_dns_query_get_result(query));\n\tconst char *stunaddr_name = ast_dns_query_get_name(query);\n\tconst char *stunaddr_resolved_str;\n\n\tif (!store_stunaddr_resolved(query)) {\n\t\tast_log(LOG_WARNING, \"Failed to resolve stunaddr '%s'. Cancelling recurring resolution.\\n\", stunaddr_name);\n\t\treturn;\n\t}\n\n\tif (DEBUG_ATLEAST(2)) {\n\t\tast_rwlock_rdlock(&stunaddr_lock);\n\t\tstunaddr_resolved_str = ast_inet_ntoa(stunaddr.sin_addr);\n\t\tast_rwlock_unlock(&stunaddr_lock);\n\n\t\tast_debug_stun(2, \"Resolved stunaddr '%s' to '%s'. Lowest TTL = %d.\\n\",\n\t\t\tstunaddr_name,\n\t\t\tstunaddr_resolved_str,\n\t\t\tlowest_ttl);\n\t}\n\n\tif (!lowest_ttl) {\n\t\tast_log(LOG_WARNING, \"Resolution for stunaddr '%s' returned TTL = 0. Recurring resolution was cancelled.\\n\", ast_dns_query_get_name(query));\n\t}\n}\n\nstatic int store_stunaddr_resolved(const struct ast_dns_query *query)\n{\n\tconst struct ast_dns_result *result = ast_dns_query_get_result(query);\n\tconst struct ast_dns_record *record;\n\n\tfor (record = ast_dns_result_get_records(result); record; record = ast_dns_record_get_next(record)) {\n\t\tconst size_t data_size = ast_dns_record_get_data_size(record);\n\t\tconst unsigned char *data = (unsigned char *)ast_dns_record_get_data(record);\n\t\tconst int rr_type = ast_dns_record_get_rr_type(record);\n\n\t\tif (rr_type == ns_t_a && data_size == 4) {\n\t\t\tast_rwlock_wrlock(&stunaddr_lock);\n\t\t\tmemcpy(&stunaddr.sin_addr, data, data_size);\n\t\t\tstunaddr.sin_family = AF_INET;\n\t\t\tast_rwlock_unlock(&stunaddr_lock);\n\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tast_debug_stun(3, \"Unrecognized rr_type '%u' or data_size '%zu' from DNS query for stunaddr '%s'\\n\",\n\t\t\t\t\t\t\t\t\t\t rr_type, data_size, ast_dns_query_get_name(query));\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void clean_stunaddr(void) {\n\tif (stunaddr_resolver) {\n\t\tif (ast_dns_resolve_recurring_cancel(stunaddr_resolver)) {\n\t\t\tast_log(LOG_ERROR, \"Failed to cancel recurring DNS resolution of previous stunaddr.\\n\");\n\t\t}\n\t\tao2_ref(stunaddr_resolver, -1);\n\t\tstunaddr_resolver = NULL;\n\t}\n\tast_rwlock_wrlock(&stunaddr_lock);\n\tmemset(&stunaddr, 0, sizeof(stunaddr));\n\tast_rwlock_unlock(&stunaddr_lock);\n}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n/*! \\pre instance is locked */\nstatic int ast_rtp_activate(struct ast_rtp_instance *instance)\n{\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n\n\t/* If ICE negotiation is enabled the DTLS Handshake will be performed upon completion of it */\n#ifdef HAVE_PJPROJECT\n\tif (rtp->ice) {\n\t\treturn 0;\n\t}\n#endif\n\n\tast_debug_dtls(3, \"(%p) DTLS - ast_rtp_activate rtp=%p - setup and perform DTLS'\\n\", instance, rtp);\n\n\tdtls_perform_setup(&rtp->dtls);\n\tdtls_perform_handshake(instance, &rtp->dtls, 0);\n\n\tif (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {\n\t\tdtls_perform_setup(&rtp->rtcp->dtls);\n\t\tdtls_perform_handshake(instance, &rtp->rtcp->dtls, 1);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic char *rtp_do_debug_ip(struct ast_cli_args *a)\n{\n\tchar *arg = ast_strdupa(a->argv[4]);\n\tchar *debughost = NULL;\n\tchar *debugport = NULL;\n\n\tif (!ast_sockaddr_parse(&rtpdebugaddr, arg, 0) || !ast_sockaddr_split_hostport(arg, &debughost, &debugport, 0)) {\n\t\tast_cli(a->fd, \"Lookup failed for '%s'\\n\", arg);\n\t\treturn CLI_FAILURE;\n\t}\n\trtpdebugport = (!ast_strlen_zero(debugport) && debugport[0] != '0');\n\tast_cli(a->fd, \"RTP Packet Debugging Enabled for address: %s\\n\",\n\t\tast_sockaddr_stringify(&rtpdebugaddr));\n\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\treturn CLI_SUCCESS;\n}\n\nstatic char *rtcp_do_debug_ip(struct ast_cli_args *a)\n{\n\tchar *arg = ast_strdupa(a->argv[4]);\n\tchar *debughost = NULL;\n\tchar *debugport = NULL;\n\n\tif (!ast_sockaddr_parse(&rtcpdebugaddr, arg, 0) || !ast_sockaddr_split_hostport(arg, &debughost, &debugport, 0)) {\n\t\tast_cli(a->fd, \"Lookup failed for '%s'\\n\", arg);\n\t\treturn CLI_FAILURE;\n\t}\n\trtcpdebugport = (!ast_strlen_zero(debugport) && debugport[0] != '0');\n\tast_cli(a->fd, \"RTCP Packet Debugging Enabled for address: %s\\n\",\n\t\tast_sockaddr_stringify(&rtcpdebugaddr));\n\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTCP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_cli_rtp_set_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtp set debug {on|off|ip}\";\n\t\te->usage =\n\t\t\t\"Usage: rtp set debug {on|off|ip host[:port]}\\n\"\n\t\t\t\"       Enable/Disable dumping of all RTP packets. If 'ip' is\\n\"\n\t\t\t\"       specified, limit the dumped packets to those to and from\\n\"\n\t\t\t\"       the specified 'host' with optional port.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc == e->args) { /* set on or off */\n\t\tif (!strncasecmp(a->argv[e->args-1], \"on\", 2)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\t\t\tmemset(&rtpdebugaddr, 0, sizeof(rtpdebugaddr));\n\t\t\tast_cli(a->fd, \"RTP Packet Debugging Enabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t} else if (!strncasecmp(a->argv[e->args-1], \"off\", 3)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTP_PACKET, AST_LOG_CATEGORY_DISABLED);\n\t\t\tast_cli(a->fd, \"RTP Packet Debugging Disabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t} else if (a->argc == e->args +1) { /* ip */\n\t\treturn rtp_do_debug_ip(a);\n\t}\n\n\treturn CLI_SHOWUSAGE;   /* default, failure */\n}\n\n\nstatic char *handle_cli_rtp_settings(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n#ifdef HAVE_PJPROJECT\n\tstruct sockaddr_in stunaddr_copy;\n#endif\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtp show settings\";\n\t\te->usage =\n\t\t\t\"Usage: rtp show settings\\n\"\n\t\t\t\"       Display RTP configuration settings\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tast_cli(a->fd, \"\\n\\nGeneral Settings:\\n\");\n\tast_cli(a->fd, \"----------------\\n\");\n\tast_cli(a->fd, \"  Port start:      %d\\n\", rtpstart);\n\tast_cli(a->fd, \"  Port end:        %d\\n\", rtpend);\n#ifdef SO_NO_CHECK\n\tast_cli(a->fd, \"  Checksums:       %s\\n\", AST_CLI_YESNO(nochecksums == 0));\n#endif\n\tast_cli(a->fd, \"  DTMF Timeout:    %d\\n\", dtmftimeout);\n\tast_cli(a->fd, \"  Strict RTP:      %s\\n\", AST_CLI_YESNO(strictrtp));\n\n\tif (strictrtp) {\n\t\tast_cli(a->fd, \"  Probation:       %d frames\\n\", learning_min_sequential);\n\t}\n\n\tast_cli(a->fd, \"  Replay Protect:  %s\\n\", AST_CLI_YESNO(srtp_replay_protection));\n#ifdef HAVE_PJPROJECT\n\tast_cli(a->fd, \"  ICE support:     %s\\n\", AST_CLI_YESNO(icesupport));\n\n\tast_rwlock_rdlock(&stunaddr_lock);\n\tmemcpy(&stunaddr_copy, &stunaddr, sizeof(stunaddr));\n\tast_rwlock_unlock(&stunaddr_lock);\n\tast_cli(a->fd, \"  STUN address:    %s:%d\\n\", ast_inet_ntoa(stunaddr_copy.sin_addr), htons(stunaddr_copy.sin_port));\n#endif\n\treturn CLI_SUCCESS;\n}\n\n\nstatic char *handle_cli_rtcp_set_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtcp set debug {on|off|ip}\";\n\t\te->usage =\n\t\t\t\"Usage: rtcp set debug {on|off|ip host[:port]}\\n\"\n\t\t\t\"       Enable/Disable dumping of all RTCP packets. If 'ip' is\\n\"\n\t\t\t\"       specified, limit the dumped packets to those to and from\\n\"\n\t\t\t\"       the specified 'host' with optional port.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc == e->args) { /* set on or off */\n\t\tif (!strncasecmp(a->argv[e->args-1], \"on\", 2)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTCP_PACKET, AST_LOG_CATEGORY_ENABLED);\n\t\t\tmemset(&rtcpdebugaddr, 0, sizeof(rtcpdebugaddr));\n\t\t\tast_cli(a->fd, \"RTCP Packet Debugging Enabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t} else if (!strncasecmp(a->argv[e->args-1], \"off\", 3)) {\n\t\t\tast_debug_category_set_sublevel(AST_LOG_CATEGORY_RTCP_PACKET, AST_LOG_CATEGORY_DISABLED);\n\t\t\tast_cli(a->fd, \"RTCP Packet Debugging Disabled\\n\");\n\t\t\treturn CLI_SUCCESS;\n\t\t}\n\t} else if (a->argc == e->args +1) { /* ip */\n\t\treturn rtcp_do_debug_ip(a);\n\t}\n\n\treturn CLI_SHOWUSAGE;   /* default, failure */\n}\n\nstatic char *handle_cli_rtcp_set_stats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtcp set stats {on|off}\";\n\t\te->usage =\n\t\t\t\"Usage: rtcp set stats {on|off}\\n\"\n\t\t\t\"       Enable/Disable dumping of RTCP stats.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != e->args)\n\t\treturn CLI_SHOWUSAGE;\n\n\tif (!strncasecmp(a->argv[e->args-1], \"on\", 2))\n\t\trtcpstats = 1;\n\telse if (!strncasecmp(a->argv[e->args-1], \"off\", 3))\n\t\trtcpstats = 0;\n\telse\n\t\treturn CLI_SHOWUSAGE;\n\n\tast_cli(a->fd, \"RTCP Stats %s\\n\", rtcpstats ? \"Enabled\" : \"Disabled\");\n\treturn CLI_SUCCESS;\n}\n\n#ifdef AST_DEVMODE\n\nstatic unsigned int use_random(struct ast_cli_args *a, int pos, unsigned int index)\n{\n\treturn pos >= index && !ast_strlen_zero(a->argv[index - 1]) &&\n\t\t!strcasecmp(a->argv[index - 1], \"random\");\n}\n\nstatic char *handle_cli_rtp_drop_incoming_packets(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstatic const char * const completions_2[] = { \"stop\", \"<N>\", NULL };\n\tstatic const char * const completions_3[] = { \"random\", \"incoming packets\", NULL };\n\tstatic const char * const completions_5[] = { \"on\", \"every\", NULL };\n\tstatic const char * const completions_units[] =\t{ \"random\", \"usec\", \"msec\", \"sec\", \"min\", NULL };\n\n\tunsigned int use_random_num = 0;\n\tunsigned int use_random_interval = 0;\n\tunsigned int num_to_drop = 0;\n\tunsigned int interval = 0;\n\tconst char *interval_s = NULL;\n\tconst char *unit_s = NULL;\n\tstruct ast_sockaddr addr;\n\tconst char *addr_s = NULL;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"rtp drop\";\n\t\te->usage =\n\t\t\t\"Usage: rtp drop [stop|[<N> [random] incoming packets[ every <N> [random] {usec|msec|sec|min}][ on <ip[:port]>]]\\n\"\n\t\t\t\"       Drop RTP incoming packets.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tuse_random_num = use_random(a, a->pos, 4);\n\t\tuse_random_interval = use_random(a, a->pos, 8 + use_random_num) ||\n\t\t\tuse_random(a, a->pos, 10 + use_random_num);\n\n\t\tswitch (a->pos - use_random_num - use_random_interval) {\n\t\tcase 2:\n\t\t\treturn ast_cli_complete(a->word, completions_2, a->n);\n\t\tcase 3:\n\t\t\treturn ast_cli_complete(a->word, completions_3 + use_random_num, a->n);\n\t\tcase 5:\n\t\t\treturn ast_cli_complete(a->word, completions_5, a->n);\n\t\tcase 7:\n\t\t\tif (!strcasecmp(a->argv[a->pos - 2], \"on\")) {\n\t\t\t\tast_cli_completion_add(ast_strdup(\"every\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall through */\n\t\tcase 9:\n\t\t\tif (!strcasecmp(a->argv[a->pos - 2 - use_random_interval], \"every\")) {\n\t\t\t\treturn ast_cli_complete(a->word, completions_units + use_random_interval, a->n);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (!strcasecmp(a->argv[a->pos - 3 - use_random_interval], \"every\")) {\n\t\t\t\tast_cli_completion_add(ast_strdup(\"on\"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\tif (a->argc < 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tuse_random_num = use_random(a, a->argc, 4);\n\tuse_random_interval = use_random(a, a->argc, 8 + use_random_num) ||\n\t\tuse_random(a, a->argc, 10 + use_random_num);\n\n\tif (!strcasecmp(a->argv[2], \"stop\")) {\n\t\t/* rtp drop stop */\n\t} else if (a->argc < 5) {\n\t\treturn CLI_SHOWUSAGE;\n\t} else if (ast_str_to_uint(a->argv[2], &num_to_drop)) {\n\t\tast_cli(a->fd, \"%s is not a valid number of packets to drop\\n\", a->argv[2]);\n\t\treturn CLI_FAILURE;\n\t} else if (a->argc - use_random_num == 5) {\n\t\t/* rtp drop <N> [random] incoming packets */\n\t} else if (a->argc - use_random_num >= 7 && !strcasecmp(a->argv[5 + use_random_num], \"on\")) {\n\t\t/* rtp drop <N> [random] incoming packets on <ip[:port]> */\n\t\taddr_s = a->argv[6 + use_random_num];\n\t\tif (a->argc - use_random_num - use_random_interval == 10 &&\n\t\t\t\t!strcasecmp(a->argv[7 + use_random_num], \"every\")) {\n\t\t\t/* rtp drop <N> [random] incoming packets on <ip[:port]> every <N> [random] {usec|msec|sec|min} */\n\t\t\tinterval_s = a->argv[8 + use_random_num];\n\t\t\tunit_s = a->argv[9 + use_random_num + use_random_interval];\n\t\t}\n\t} else if (a->argc - use_random_num >= 8 && !strcasecmp(a->argv[5 + use_random_num], \"every\")) {\n\t\t/* rtp drop <N> [random] incoming packets every <N> [random] {usec|msec|sec|min} */\n\t\tinterval_s = a->argv[6 + use_random_num];\n\t\tunit_s = a->argv[7 + use_random_num + use_random_interval];\n\t\tif (a->argc == 10 + use_random_num + use_random_interval &&\n\t\t\t\t!strcasecmp(a->argv[8 + use_random_num + use_random_interval], \"on\")) {\n\t\t\t/* rtp drop <N> [random] incoming packets every <N> [random] {usec|msec|sec|min} on <ip[:port]> */\n\t\t\taddr_s = a->argv[9 + use_random_num + use_random_interval];\n\t\t}\n\t} else {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tif (a->argc - use_random_num >= 8 && !interval_s && !addr_s) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tif (interval_s && ast_str_to_uint(interval_s, &interval)) {\n\t\tast_cli(a->fd, \"%s is not a valid interval number\\n\", interval_s);\n\t\treturn CLI_FAILURE;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\tif (addr_s && !ast_sockaddr_parse(&addr, addr_s, 0)) {\n\t\tast_cli(a->fd, \"%s is not a valid hostname[:port]\\n\", addr_s);\n\t\treturn CLI_FAILURE;\n\t}\n\n\tdrop_packets_data.use_random_num = use_random_num;\n\tdrop_packets_data.use_random_interval = use_random_interval;\n\tdrop_packets_data.num_to_drop = num_to_drop;\n\tdrop_packets_data.interval = ast_time_create_by_unit_str(interval, unit_s);\n\tast_sockaddr_copy(&drop_packets_data.addr, &addr);\n\tdrop_packets_data.port = ast_sockaddr_port(&addr);\n\n\tdrop_packets_data_update(ast_tvnow());\n\n\treturn CLI_SUCCESS;\n}\n#endif\n\nstatic struct ast_cli_entry cli_rtp[] = {\n\tAST_CLI_DEFINE(handle_cli_rtp_set_debug,  \"Enable/Disable RTP debugging\"),\n\tAST_CLI_DEFINE(handle_cli_rtp_settings,   \"Display RTP settings\"),\n\tAST_CLI_DEFINE(handle_cli_rtcp_set_debug, \"Enable/Disable RTCP debugging\"),\n\tAST_CLI_DEFINE(handle_cli_rtcp_set_stats, \"Enable/Disable RTCP stats\"),\n#ifdef AST_DEVMODE\n\tAST_CLI_DEFINE(handle_cli_rtp_drop_incoming_packets, \"Drop RTP incoming packets\"),\n#endif\n};\n\nstatic int rtp_reload(int reload, int by_external_config)\n{\n\tstruct ast_config *cfg;\n\tconst char *s;\n\tstruct ast_flags config_flags = { (reload && !by_external_config) ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\n#ifdef HAVE_PJPROJECT\n\tstruct ast_variable *var;\n\tstruct ast_ice_host_candidate *candidate;\n\tint acl_subscription_flag = 0;\n#endif\n\n\tcfg = ast_config_load2(\"rtp.conf\", \"rtp\", config_flags);\n\tif (!cfg || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\treturn 0;\n\t}\n\n#ifdef SO_NO_CHECK\n\tnochecksums = 0;\n#endif\n\n\trtpstart = DEFAULT_RTP_START;\n\trtpend = DEFAULT_RTP_END;\n\trtcpinterval = RTCP_DEFAULT_INTERVALMS;\n\tdtmftimeout = DEFAULT_DTMF_TIMEOUT;\n\tstrictrtp = DEFAULT_STRICT_RTP;\n\tlearning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL;\n\tlearning_min_duration = DEFAULT_LEARNING_MIN_DURATION;\n\tsrtp_replay_protection = DEFAULT_SRTP_REPLAY_PROTECTION;\n\n\t/** This resource is not \"reloaded\" so much as unloaded and loaded again.\n\t * In the case of the TURN related variables, the memory referenced by a\n\t * previously loaded instance  *should* have been released when the\n\t * corresponding pool was destroyed. If at some point in the future this\n\t * resource were to support ACTUAL live reconfiguration and did NOT release\n\t * the pool this will cause a small memory leak.\n\t */\n\n#ifdef HAVE_PJPROJECT\n\ticesupport = DEFAULT_ICESUPPORT;\n\tstun_software_attribute = DEFAULT_STUN_SOFTWARE_ATTRIBUTE;\n\tturnport = DEFAULT_TURN_PORT;\n\tclean_stunaddr();\n\tturnaddr = pj_str(NULL);\n\tturnusername = pj_str(NULL);\n\tturnpassword = pj_str(NULL);\n\thost_candidate_overrides_clear();\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tdtls_mtu = DEFAULT_DTLS_MTU;\n#endif\n\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtpstart\"))) {\n\t\trtpstart = atoi(s);\n\t\tif (rtpstart < MINIMUM_RTP_PORT)\n\t\t\trtpstart = MINIMUM_RTP_PORT;\n\t\tif (rtpstart > MAXIMUM_RTP_PORT)\n\t\t\trtpstart = MAXIMUM_RTP_PORT;\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtpend\"))) {\n\t\trtpend = atoi(s);\n\t\tif (rtpend < MINIMUM_RTP_PORT)\n\t\t\trtpend = MINIMUM_RTP_PORT;\n\t\tif (rtpend > MAXIMUM_RTP_PORT)\n\t\t\trtpend = MAXIMUM_RTP_PORT;\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtcpinterval\"))) {\n\t\trtcpinterval = atoi(s);\n\t\tif (rtcpinterval == 0)\n\t\t\trtcpinterval = 0; /* Just so we're clear... it's zero */\n\t\tif (rtcpinterval < RTCP_MIN_INTERVALMS)\n\t\t\trtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */\n\t\tif (rtcpinterval > RTCP_MAX_INTERVALMS)\n\t\t\trtcpinterval = RTCP_MAX_INTERVALMS;\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"rtpchecksums\"))) {\n#ifdef SO_NO_CHECK\n\t\tnochecksums = ast_false(s) ? 1 : 0;\n#else\n\t\tif (ast_false(s))\n\t\t\tast_log(LOG_WARNING, \"Disabling RTP checksums is not supported on this operating system!\\n\");\n#endif\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"dtmftimeout\"))) {\n\t\tdtmftimeout = atoi(s);\n\t\tif ((dtmftimeout < 0) || (dtmftimeout > 64000)) {\n\t\t\tast_log(LOG_WARNING, \"DTMF timeout of '%d' outside range, using default of '%d' instead\\n\",\n\t\t\t\tdtmftimeout, DEFAULT_DTMF_TIMEOUT);\n\t\t\tdtmftimeout = DEFAULT_DTMF_TIMEOUT;\n\t\t};\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"strictrtp\"))) {\n\t\tif (ast_true(s)) {\n\t\t\tstrictrtp = STRICT_RTP_YES;\n\t\t} else if (!strcasecmp(s, \"seqno\")) {\n\t\t\tstrictrtp = STRICT_RTP_SEQNO;\n\t\t} else {\n\t\t\tstrictrtp = STRICT_RTP_NO;\n\t\t}\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"probation\"))) {\n\t\tif ((sscanf(s, \"%d\", &learning_min_sequential) != 1) || learning_min_sequential <= 1) {\n\t\t\tast_log(LOG_WARNING, \"Value for 'probation' could not be read, using default of '%d' instead\\n\",\n\t\t\t\tDEFAULT_LEARNING_MIN_SEQUENTIAL);\n\t\t\tlearning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL;\n\t\t}\n\t\tlearning_min_duration = CALC_LEARNING_MIN_DURATION(learning_min_sequential);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"srtpreplayprotection\"))) {\n\t\tsrtp_replay_protection = ast_true(s);\n\t}\n#ifdef HAVE_PJPROJECT\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"icesupport\"))) {\n\t\ticesupport = ast_true(s);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"stun_software_attribute\"))) {\n\t\tstun_software_attribute = ast_true(s);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"stunaddr\"))) {\n\t\tchar *hostport, *host, *port;\n\t\tunsigned int port_parsed = STANDARD_STUN_PORT;\n\t\tstruct ast_sockaddr stunaddr_parsed;\n\n\t\thostport = ast_strdupa(s);\n\n\t\tif (!ast_parse_arg(hostport, PARSE_ADDR, &stunaddr_parsed)) {\n\t\t\tast_debug_stun(3, \"stunaddr = '%s' does not need name resolution\\n\",\n\t\t\t\tast_sockaddr_stringify_host(&stunaddr_parsed));\n\t\t\tif (!ast_sockaddr_port(&stunaddr_parsed)) {\n\t\t\t\tast_sockaddr_set_port(&stunaddr_parsed, STANDARD_STUN_PORT);\n\t\t\t}\n\t\t\tast_rwlock_wrlock(&stunaddr_lock);\n\t\t\tast_sockaddr_to_sin(&stunaddr_parsed, &stunaddr);\n\t\t\tast_rwlock_unlock(&stunaddr_lock);\n\t\t} else if (ast_sockaddr_split_hostport(hostport, &host, &port, 0)) {\n\t\t\tif (port) {\n\t\t\t\tast_parse_arg(port, PARSE_UINT32|PARSE_IN_RANGE, &port_parsed, 1, 65535);\n\t\t\t}\n\t\t\tstunaddr.sin_port = htons(port_parsed);\n\n\t\t\tstunaddr_resolver = ast_dns_resolve_recurring(host, T_A, C_IN,\n\t\t\t\t&stunaddr_resolve_callback, NULL);\n\t\t\tif (!stunaddr_resolver) {\n\t\t\t\tast_log(LOG_ERROR, \"Failed to setup recurring DNS resolution of stunaddr '%s'\",\n\t\t\t\t\thost);\n\t\t\t}\n\t\t} else {\n\t\t\tast_log(LOG_ERROR, \"Failed to parse stunaddr '%s'\", hostport);\n\t\t}\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"turnaddr\"))) {\n\t\tstruct sockaddr_in addr;\n\t\taddr.sin_port = htons(DEFAULT_TURN_PORT);\n\t\tif (ast_parse_arg(s, PARSE_INADDR, &addr)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid TURN server address: %s\\n\", s);\n\t\t} else {\n\t\t\tpj_strdup2_with_null(pool, &turnaddr, ast_inet_ntoa(addr.sin_addr));\n\t\t\t/* ntohs() is not a bug here. The port number is used in host byte order with\n\t\t\t * a pjnat API. */\n\t\t\tturnport = ntohs(addr.sin_port);\n\t\t}\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"turnusername\"))) {\n\t\tpj_strdup2_with_null(pool, &turnusername, s);\n\t}\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"turnpassword\"))) {\n\t\tpj_strdup2_with_null(pool, &turnpassword, s);\n\t}\n\n\tAST_RWLIST_WRLOCK(&host_candidates);\n\tfor (var = ast_variable_browse(cfg, \"ice_host_candidates\"); var; var = var->next) {\n\t\tstruct ast_sockaddr local_addr, advertised_addr;\n\t\tunsigned int include_local_address = 0;\n\t\tchar *sep;\n\n\t\tast_sockaddr_setnull(&local_addr);\n\t\tast_sockaddr_setnull(&advertised_addr);\n\n\t\tif (ast_parse_arg(var->name, PARSE_ADDR | PARSE_PORT_IGNORE, &local_addr)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid local ICE host address: %s\\n\", var->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsep = strchr(var->value,',');\n\t\tif (sep) {\n\t\t\t*sep = '\\0';\n\t\t\tsep++;\n\t\t\tsep = ast_skip_blanks(sep);\n\t\t\tinclude_local_address = strcmp(sep, \"include_local_address\") == 0;\n\t\t}\n\n\t\tif (ast_parse_arg(var->value, PARSE_ADDR | PARSE_PORT_IGNORE, &advertised_addr)) {\n\t\t\tast_log(LOG_WARNING, \"Invalid advertised ICE host address: %s\\n\", var->value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(candidate = ast_calloc(1, sizeof(*candidate)))) {\n\t\t\tast_log(LOG_ERROR, \"Failed to allocate ICE host candidate mapping.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcandidate->include_local = include_local_address;\n\n\t\tast_sockaddr_copy(&candidate->local, &local_addr);\n\t\tast_sockaddr_copy(&candidate->advertised, &advertised_addr);\n\n\t\tAST_RWLIST_INSERT_TAIL(&host_candidates, candidate, next);\n\t}\n\tAST_RWLIST_UNLOCK(&host_candidates);\n\n\tast_rwlock_wrlock(&ice_acl_lock);\n\tast_rwlock_wrlock(&stun_acl_lock);\n\n\tice_acl = ast_free_acl_list(ice_acl);\n\tstun_acl = ast_free_acl_list(stun_acl);\n\n\tfor (var = ast_variable_browse(cfg, \"general\"); var; var = var->next) {\n\t\tconst char* sense = NULL;\n\t\tstruct ast_acl_list **acl = NULL;\n\t\tif (strncasecmp(var->name, \"ice_\", 4) == 0) {\n\t\t\tsense = var->name + 4;\n\t\t\tacl = &ice_acl;\n\t\t} else if (strncasecmp(var->name, \"stun_\", 5) == 0) {\n\t\t\tsense = var->name + 5;\n\t\t\tacl = &stun_acl;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcasecmp(sense, \"blacklist\") == 0) {\n\t\t\tsense = \"deny\";\n\t\t}\n\n\t\tif (strcasecmp(sense, \"acl\") && strcasecmp(sense, \"permit\") && strcasecmp(sense, \"deny\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tast_append_acl(sense, var->value, acl, NULL, &acl_subscription_flag);\n\t}\n\tast_rwlock_unlock(&ice_acl_lock);\n\tast_rwlock_unlock(&stun_acl_lock);\n\n\tif (acl_subscription_flag && !acl_change_sub) {\n\t\tacl_change_sub = stasis_subscribe(ast_security_topic(), acl_change_stasis_cb, NULL);\n\t\tstasis_subscription_accept_message_type(acl_change_sub, ast_named_acl_change_type());\n\t\tstasis_subscription_set_filter(acl_change_sub, STASIS_SUBSCRIPTION_FILTER_SELECTIVE);\n\t} else if (!acl_subscription_flag && acl_change_sub) {\n\t\tacl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);\n\t}\n#endif\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tif ((s = ast_variable_retrieve(cfg, \"general\", \"dtls_mtu\"))) {\n\t\tif ((sscanf(s, \"%d\", &dtls_mtu) != 1) || dtls_mtu < 256) {\n\t\t\tast_log(LOG_WARNING, \"Value for 'dtls_mtu' could not be read, using default of '%d' instead\\n\",\n\t\t\t\tDEFAULT_DTLS_MTU);\n\t\t\tdtls_mtu = DEFAULT_DTLS_MTU;\n\t\t}\n\t}\n#endif\n\n\tast_config_destroy(cfg);\n\n\t/* Choosing an odd start port casues issues (like a potential infinite loop) and as odd parts are not\n\t   chosen anyway, we are going to round up and issue a warning */\n\tif (rtpstart & 1) {\n\t\trtpstart++;\n\t\tast_log(LOG_WARNING, \"Odd start value for RTP port in rtp.conf, rounding up to %d\\n\", rtpstart);\n\t}\n\n\tif (rtpstart >= rtpend) {\n\t\tast_log(LOG_WARNING, \"Unreasonable values for RTP start/end port in rtp.conf\\n\");\n\t\trtpstart = DEFAULT_RTP_START;\n\t\trtpend = DEFAULT_RTP_END;\n\t}\n\tast_verb(2, \"RTP Allocating from port range %d -> %d\\n\", rtpstart, rtpend);\n\treturn 0;\n}\n\nstatic int reload_module(void)\n{\n\trtp_reload(1, 0);\n\treturn 0;\n}\n\n#ifdef HAVE_PJPROJECT\nstatic void rtp_terminate_pjproject(void)\n{\n\tpj_thread_register_check();\n\n\tif (timer_thread) {\n\t\ttimer_terminate = 1;\n\t\tpj_thread_join(timer_thread);\n\t\tpj_thread_destroy(timer_thread);\n\t}\n\n\tast_pjproject_caching_pool_destroy(&cachingpool);\n\tpj_shutdown();\n}\n\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message)\n{\n\tif (stasis_message_type(message) != ast_named_acl_change_type()) {\n\t\treturn;\n\t}\n\n\t/* There is no simple way to just reload the ACLs, so just execute a forced reload. */\n\trtp_reload(1, 1);\n}\n#endif\n\nstatic int load_module(void)\n{\n#ifdef HAVE_PJPROJECT\n\tpj_lock_t *lock;\n\n\tast_sockaddr_parse(&lo6, \"::1\", PARSE_PORT_IGNORE);\n\n\tAST_PJPROJECT_INIT_LOG_LEVEL();\n\tif (pj_init() != PJ_SUCCESS) {\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (pjlib_util_init() != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (pjnath_init() != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tast_pjproject_caching_pool_init(&cachingpool, &pj_pool_factory_default_policy, 0);\n\n\tpool = pj_pool_create(&cachingpool.factory, \"timer\", 512, 512, NULL);\n\n\tif (pj_timer_heap_create(pool, 100, &timer_heap) != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (pj_lock_create_recursive_mutex(pool, \"rtp%p\", &lock) != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tpj_timer_heap_set_lock(timer_heap, lock, PJ_TRUE);\n\n\tif (pj_thread_create(pool, \"timer\", &timer_worker_thread, NULL, 0, 0, &timer_thread) != PJ_SUCCESS) {\n\t\trtp_terminate_pjproject();\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\tdtls_bio_methods = BIO_meth_new(BIO_TYPE_BIO, \"rtp write\");\n\tif (!dtls_bio_methods) {\n#ifdef HAVE_PJPROJECT\n\t\trtp_terminate_pjproject();\n#endif\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\tBIO_meth_set_write(dtls_bio_methods, dtls_bio_write);\n\tBIO_meth_set_ctrl(dtls_bio_methods, dtls_bio_ctrl);\n\tBIO_meth_set_create(dtls_bio_methods, dtls_bio_new);\n\tBIO_meth_set_destroy(dtls_bio_methods, dtls_bio_free);\n#endif\n\n\tif (ast_rtp_engine_register(&asterisk_rtp_engine)) {\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\t\tBIO_meth_free(dtls_bio_methods);\n#endif\n#ifdef HAVE_PJPROJECT\n\t\trtp_terminate_pjproject();\n#endif\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\tif (ast_cli_register_multiple(cli_rtp, ARRAY_LEN(cli_rtp))) {\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\t\tBIO_meth_free(dtls_bio_methods);\n#endif\n#ifdef HAVE_PJPROJECT\n\t\tast_rtp_engine_unregister(&asterisk_rtp_engine);\n\t\trtp_terminate_pjproject();\n#endif\n\t\treturn AST_MODULE_LOAD_DECLINE;\n\t}\n\n\trtp_reload(0, 0);\n\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n\nstatic int unload_module(void)\n{\n\tast_rtp_engine_unregister(&asterisk_rtp_engine);\n\tast_cli_unregister_multiple(cli_rtp, ARRAY_LEN(cli_rtp));\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP) && defined(HAVE_OPENSSL_BIO_METHOD)\n\tif (dtls_bio_methods) {\n\t\tBIO_meth_free(dtls_bio_methods);\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\thost_candidate_overrides_clear();\n\tpj_thread_register_check();\n\trtp_terminate_pjproject();\n\n\tacl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);\n\trtp_unload_acl(&ice_acl_lock, &ice_acl);\n\trtp_unload_acl(&stun_acl_lock, &stun_acl);\n\tclean_stunaddr();\n#endif\n\n\treturn 0;\n}\n\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, \"Asterisk RTP Stack\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.reload = reload_module,\n\t.load_pri = AST_MODPRI_CHANNEL_DEPEND,\n#ifdef HAVE_PJPROJECT\n\t.requires = \"res_pjproject\",\n#endif\n);\n"], "filenames": ["res/res_rtp_asterisk.c"], "buggy_code_start_loc": [3208], "buggy_code_end_loc": [3208], "fixing_code_start_loc": [3209], "fixing_code_end_loc": [3264], "type": "CWE-362", "message": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk prior to versions 18.20.1, 20.5.1, and 21.0.1; as well as certified-asterisk prior to 18.9-cert6; Asterisk is susceptible to a DoS due to a race condition in the hello handshake phase of the DTLS protocol when handling DTLS-SRTP for media setup. This attack can be done continuously, thus denying new DTLS-SRTP encrypted calls during the attack. Abuse of this vulnerability may lead to a massive Denial of Service on vulnerable Asterisk servers for calls that rely on DTLS-SRTP. Commit d7d7764cb07c8a1872804321302ef93bf62cba05 contains a fix, which is part of versions 18.20.1, 20.5.1, 21.0.1, amd 18.9-cert6.", "other": {"cve": {"id": "CVE-2023-49786", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T20:15:52.927", "lastModified": "2023-12-29T00:15:50.043", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk prior to versions 18.20.1, 20.5.1, and 21.0.1; as well as certified-asterisk prior to 18.9-cert6; Asterisk is susceptible to a DoS due to a race condition in the hello handshake phase of the DTLS protocol when handling DTLS-SRTP for media setup. This attack can be done continuously, thus denying new DTLS-SRTP encrypted calls during the attack. Abuse of this vulnerability may lead to a massive Denial of Service on vulnerable Asterisk servers for calls that rely on DTLS-SRTP. Commit d7d7764cb07c8a1872804321302ef93bf62cba05 contains a fix, which is part of versions 18.20.1, 20.5.1, 21.0.1, amd 18.9-cert6."}, {"lang": "es", "value": "Asterisk es un conjunto de herramientas de telefon\u00eda y centralita privada de c\u00f3digo abierto. En Asterisk anteriores a las versiones 18.20.1, 20.5.1 y 21.0.1; as\u00ed como certificado-asterisco anterior a 18.9-cert6; Asterisk es susceptible a un DoS debido a una condici\u00f3n de ejecuci\u00f3n en la fase \"hello handshake\" del protocolo DTLS cuando maneja DTLS-SRTP para la configuraci\u00f3n de medios. Este ataque se puede realizar de forma continua, negando as\u00ed nuevas llamadas cifradas DTLS-SRTP durante el ataque. El abuso de esta vulnerabilidad puede provocar una denegaci\u00f3n de servicio masiva en servidores Asterisk vulnerables para llamadas que dependen de DTLS-SRTP. El commit d7d7764cb07c8a1872804321302ef93bf62cba05 contiene una soluci\u00f3n, que forma parte de las versiones 18.20.1, 20.5.1, 21.0.1, amd 18.9-cert6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-703"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:*:*:*:*:*:*:*:*", "versionEndExcluding": "18.20.1", "matchCriteriaId": "A49E9157-3440-47C5-B730-B1F3BE7240C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.0.0", "versionEndExcluding": "20.5.1", "matchCriteriaId": "FCA06EB6-E31A-43B2-A750-186255114B8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:21.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D3E690E3-3E92-42ED-87DD-1C6B838A3FF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "2AFE2011-05AA-45A6-A561-65C6C664DA7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "C1117AA4-CE6B-479B-9995-A9F71C430663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc1:*:*:*:*:*:*", "matchCriteriaId": "775041BD-5C86-42B6-8B34-E1D5171B3D87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc2:*:*:*:*:*:*", "matchCriteriaId": "55EC2877-2FF5-4777-B118-E764A94BCE56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc3:*:*:*:*:*:*", "matchCriteriaId": "EB0392C9-A5E9-4D71-8B8D-63FB96E055A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc4:*:*:*:*:*:*", "matchCriteriaId": "09AF962D-D4BB-40BA-B435-A59E4402931C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "559D1063-7F37-44F8-B5C6-94758B675FDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "185B2B4B-B246-4379-906B-9BDA7CDD4400"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "73D3592D-3CE5-4462-9FE8-4BCB54E74B5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B3CCE9E0-5DC4-43A2-96DB-9ABEA60EC157"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "1EAD713A-CBA2-40C3-9DE3-5366827F18C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "A5F5A8B7-29C9-403C-9561-7B3E96F9FCA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert10:*:*:*:*:*:*", "matchCriteriaId": "F9B96A53-2263-463C-9CCA-0F29865FE500"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert11:*:*:*:*:*:*", "matchCriteriaId": "A53049F1-8551-453E-834A-68826A7AA959"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert12:*:*:*:*:*:*", "matchCriteriaId": "B224A4E9-4B6B-4187-B0D6-E4BAE2637960"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "9501DBFF-516D-4F26-BBF6-1B453EE2A630"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "9D3E9AC0-C0B4-4E87-8D48-2B688D28B678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert4:*:*:*:*:*:*", "matchCriteriaId": "1A8628F6-F8D1-4C0C-BD89-8E2EEF19A5F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert5:*:*:*:*:*:*", "matchCriteriaId": "E27A6FD1-9321-4C9E-B32B-D6330CD3DC92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert6:*:*:*:*:*:*", "matchCriteriaId": "B6BF5EDB-9D17-453D-A22E-FDDC4DCDD85B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert7:*:*:*:*:*:*", "matchCriteriaId": "4C75A21E-5D05-434B-93DE-8DAC4DD3E587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert8:*:*:*:*:*:*", "matchCriteriaId": "1D725758-C9F5-4DB2-8C45-CC052518D3FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert9:*:*:*:*:*:*", "matchCriteriaId": "B5E2AECC-B681-4EA5-9DE5-2086BB37A5F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert1:*:*:*:*:*:*", "matchCriteriaId": "79EEB5E5-B79E-454B-8DCD-3272BA337A9E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert2:*:*:*:*:*:*", "matchCriteriaId": "892BAE5D-A64E-4FE0-9A99-8C07F342A042"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert3:*:*:*:*:*:*", "matchCriteriaId": "1A716A45-7075-4CA6-9EF5-2DD088248A5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert4:*:*:*:*:*:*", "matchCriteriaId": "80EFA05B-E22D-49CE-BDD6-5C7123F1C12B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert5:*:*:*:*:*:*", "matchCriteriaId": "20FD475F-2B46-47C9-B535-1561E29CB7A1"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/176251/Asterisk-20.1.0-Denial-Of-Service.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2023/Dec/24", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/12/15/7", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List"]}, {"url": "https://github.com/EnableSecurity/advisories/tree/master/ES2023-01-asterisk-dtls-hello-race", "source": "security-advisories@github.com", "tags": ["Exploit"]}, {"url": "https://github.com/asterisk/asterisk/commit/d7d7764cb07c8a1872804321302ef93bf62cba05", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/asterisk/asterisk/security/advisories/GHSA-hxj9-xwr8-w8pq", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00019.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/asterisk/asterisk/commit/d7d7764cb07c8a1872804321302ef93bf62cba05"}}